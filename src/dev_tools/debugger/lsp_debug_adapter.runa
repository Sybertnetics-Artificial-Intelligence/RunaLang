Note: LSP Debug Adapter for Runa Advanced Debugger
Note: Implements Debug Adapter Protocol (DAP) for integration with IDEs
Note: Provides standardized debugging interface compatible with VS Code, vim, etc.

Import "collections" as Collections
Import "json" as JSON
Import "os" as OS
Import "advanced_debugger" as Debugger

Note: Debug Adapter Protocol message types
Type called "DAPMessageType":
    | Request
    | Response
    | Event

Type called "DAPMessage":
    message_type as DAPMessageType
    seq as Integer
    command as String
    request_seq as Integer
    success as Boolean
    message as String
    body as Dictionary[String, String]

Type called "DAPCapabilities":
    supports_configuration_done_request as Boolean
    supports_function_breakpoints as Boolean
    supports_conditional_breakpoints as Boolean
    supports_hit_conditional_breakpoints as Boolean
    supports_evaluate_for_hovers as Boolean
    supports_step_back as Boolean
    supports_set_variable as Boolean
    supports_restart_frame as Boolean
    supports_goto_targets_request as Boolean
    supports_step_in_targets_request as Boolean
    supports_completions_request as Boolean
    supports_modules_request as Boolean
    supports_restart_request as Boolean
    supports_exception_options as Boolean
    supports_value_formatting_options as Boolean
    supports_exception_info_request as Boolean
    supports_terminate_debuggee as Boolean
    supports_delayed_stack_trace_loading as Boolean
    supports_loaded_sources_request as Boolean
    supports_log_points as Boolean
    supports_terminate_threads_request as Boolean
    supports_set_expression as Boolean
    supports_terminate_request as Boolean
    supports_data_breakpoints as Boolean
    supports_read_memory_request as Boolean
    supports_write_memory_request as Boolean
    supports_disassemble_request as Boolean

Type called "LSPDebugAdapter":
    debugger as Debugger::AdvancedDebugger
    capabilities as DAPCapabilities
    next_seq as Integer
    active_session as Boolean
    client_connection as ClientConnection
    message_handlers as Dictionary[String, MessageHandler]

Type called "ClientConnection":
    input_stream as String
    output_stream as String
    is_connected as Boolean
    client_id as String

Type called "MessageHandler":
    command as String
    handler_function as String

Note: Create new LSP Debug Adapter
Process called "create_lsp_debug_adapter" returns LSPDebugAdapter:
    Let capabilities be DAPCapabilities with:
        supports_configuration_done_request as true
        supports_function_breakpoints as true
        supports_conditional_breakpoints as true
        supports_hit_conditional_breakpoints as true
        supports_evaluate_for_hovers as true
        supports_step_back as false
        supports_set_variable as true
        supports_restart_frame as false
        supports_goto_targets_request as false
        supports_step_in_targets_request as true
        supports_completions_request as true
        supports_modules_request as true
        supports_restart_request as true
        supports_exception_options as true
        supports_value_formatting_options as true
        supports_exception_info_request as false
        supports_terminate_debuggee as true
        supports_delayed_stack_trace_loading as true
        supports_loaded_sources_request as true
        supports_log_points as true
        supports_terminate_threads_request as false
        supports_set_expression as true
        supports_terminate_request as true
        supports_data_breakpoints as false
        supports_read_memory_request as false
        supports_write_memory_request as false
        supports_disassemble_request as false
    
    Let handlers be Collections::create_dictionary()
    Set handlers["initialize"] as "handle_initialize_request"
    Set handlers["launch"] as "handle_launch_request"
    Set handlers["attach"] as "handle_attach_request"
    Set handlers["configurationDone"] as "handle_configuration_done_request"
    Set handlers["setBreakpoints"] as "handle_set_breakpoints_request"
    Set handlers["setFunctionBreakpoints"] as "handle_set_function_breakpoints_request"
    Set handlers["continue"] as "handle_continue_request"
    Set handlers["next"] as "handle_next_request"
    Set handlers["stepIn"] as "handle_step_in_request"
    Set handlers["stepOut"] as "handle_step_out_request"
    Set handlers["pause"] as "handle_pause_request"
    Set handlers["stackTrace"] as "handle_stack_trace_request"
    Set handlers["scopes"] as "handle_scopes_request"
    Set handlers["variables"] as "handle_variables_request"
    Set handlers["evaluate"] as "handle_evaluate_request"
    Set handlers["disconnect"] as "handle_disconnect_request"
    Set handlers["terminate"] as "handle_terminate_request"
    
    Return LSPDebugAdapter with:
        debugger as Debugger::create_advanced_debugger()
        capabilities as capabilities
        next_seq as 1
        active_session as false
        client_connection as create_client_connection()
        message_handlers as handlers

Process called "create_client_connection" returns ClientConnection:
    Return ClientConnection with:
        input_stream as "stdin"
        output_stream as "stdout"
        is_connected as false
        client_id as ""

Note: Main message processing loop
Process called "start_debug_adapter" that takes adapter as LSPDebugAdapter returns Boolean:
    Set adapter.client_connection.is_connected as true
    
    Print "Runa Debug Adapter Protocol Server starting..."
    Print "Listening for DAP messages on stdin"
    
    While adapter.client_connection.is_connected:
        Let message be read_dap_message_from_stdin()
        If length of message > 0:
            Let processed be process_dap_message with adapter and message
            If not processed:
                Print "Warning: Failed to process DAP message: " joined with message
        Otherwise:
            Note: No message received, brief pause
            Continue
    
    Print "Debug adapter shutting down"
    Return true

Process called "process_dap_message" that takes adapter as LSPDebugAdapter and raw_message as String returns Boolean:
    Note: Parse DAP message from JSON
    Let parse_result be JSON::parse with raw_message
    If not parse_result.success:
        Let error_response be create_error_response with 0 and "Invalid JSON message"
        Send send_dap_response with adapter and error_response
        Return false
    
    Let message_data be parse_result.data
    
    Note: Extract message components
    Let command be ""
    Let seq be 0
    Let message_type be "request"
    
    If message_data contains "command":
        Set command as message_data["command"]
    If message_data contains "seq":
        Set seq as (message_data["seq"] as Integer)
    If message_data contains "type":
        Set message_type as message_data["type"]
    
    Note: Route to appropriate handler
    If message_type equals "request":
        Return handle_dap_request with adapter and command and seq and message_data
    Otherwise If message_type equals "response":
        Return handle_dap_response with adapter and message_data
    Otherwise:
        Let error_response be create_error_response with seq and ("Unknown message type: " joined with message_type)
        Send send_dap_response with adapter and error_response
        Return false

Process called "handle_dap_request" that takes adapter as LSPDebugAdapter and command as String and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    If adapter.message_handlers contains command:
        Let handler_name be adapter.message_handlers[command]
        Return invoke_message_handler with adapter and handler_name and seq and message_data
    Otherwise:
        Let error_response be create_error_response with seq and ("Unsupported command: " joined with command)
        Send send_dap_response with adapter and error_response
        Return false

Process called "handle_dap_response" that takes adapter as LSPDebugAdapter and message_data as Dictionary[String, String] returns Boolean:
    Note: Handle responses from client (currently not implemented)
    Return true

Note: DAP Request Handlers
Process called "handle_initialize_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Let response_body be Collections::create_dictionary()
    Set response_body["supportsConfigurationDoneRequest"] as (adapter.capabilities.supports_configuration_done_request as String)
    Set response_body["supportsFunctionBreakpoints"] as (adapter.capabilities.supports_function_breakpoints as String)
    Set response_body["supportsConditionalBreakpoints"] as (adapter.capabilities.supports_conditional_breakpoints as String)
    Set response_body["supportsHitConditionalBreakpoints"] as (adapter.capabilities.supports_hit_conditional_breakpoints as String)
    Set response_body["supportsEvaluateForHovers"] as (adapter.capabilities.supports_evaluate_for_hovers as String)
    Set response_body["supportsSetVariable"] as (adapter.capabilities.supports_set_variable as String)
    Set response_body["supportsStepInTargetsRequest"] as (adapter.capabilities.supports_step_in_targets_request as String)
    Set response_body["supportsCompletionsRequest"] as (adapter.capabilities.supports_completions_request as String)
    Set response_body["supportsModulesRequest"] as (adapter.capabilities.supports_modules_request as String)
    Set response_body["supportsRestartRequest"] as (adapter.capabilities.supports_restart_request as String)
    Set response_body["supportsExceptionOptions"] as (adapter.capabilities.supports_exception_options as String)
    Set response_body["supportsValueFormattingOptions"] as (adapter.capabilities.supports_value_formatting_options as String)
    Set response_body["supportsTerminateDebuggee"] as (adapter.capabilities.supports_terminate_debuggee as String)
    Set response_body["supportsDelayedStackTraceLoading"] as (adapter.capabilities.supports_delayed_stack_trace_loading as String)
    Set response_body["supportsLoadedSourcesRequest"] as (adapter.capabilities.supports_loaded_sources_request as String)
    Set response_body["supportsLogPoints"] as (adapter.capabilities.supports_log_points as String)
    Set response_body["supportsSetExpression"] as (adapter.capabilities.supports_set_expression as String)
    Set response_body["supportsTerminateRequest"] as (adapter.capabilities.supports_terminate_request as String)
    
    Let response be create_success_response with seq and "initialize" and response_body
    Return send_dap_response with adapter and response

Process called "handle_launch_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Note: Extract launch configuration
    Let program_path be ""
    Let args be Collections::create_list()
    
    If message_data contains "arguments":
        Let args_data be message_data["arguments"]
        If args_data contains "program":
            Set program_path as args_data["program"]
    
    Note: Launch the Runa program for debugging
    Let launch_success be launch_program_for_debugging with adapter.debugger and program_path and args
    
    If launch_success:
        Set adapter.active_session as true
        Let response be create_success_response with seq and "launch" and Collections::create_dictionary()
        Let sent be send_dap_response with adapter and response
        
        Note: Send initialized event
        Let initialized_event be create_initialized_event()
        Send send_dap_event with adapter and initialized_event
        
        Return sent
    Otherwise:
        Let error_response be create_error_response with seq and "Failed to launch program"
        Return send_dap_response with adapter and error_response

Process called "handle_attach_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Note: Extract attach configuration
    Let process_id be 0
    
    If message_data contains "arguments":
        Let args_data be message_data["arguments"]
        If args_data contains "processId":
            Set process_id as (args_data["processId"] as Integer)
    
    Note: Attach to existing Runa process
    Let attach_success be attach_to_process_for_debugging with adapter.debugger and process_id
    
    If attach_success:
        Set adapter.active_session as true
        Let response be create_success_response with seq and "attach" and Collections::create_dictionary()
        Let sent be send_dap_response with adapter and response
        
        Note: Send initialized event
        Let initialized_event be create_initialized_event()
        Send send_dap_event with adapter and initialized_event
        
        Return sent
    Otherwise:
        Let error_response be create_error_response with seq and "Failed to attach to process"
        Return send_dap_response with adapter and error_response

Process called "handle_configuration_done_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Note: Configuration is complete, ready to start debugging
    Let response be create_success_response with seq and "configurationDone" and Collections::create_dictionary()
    Return send_dap_response with adapter and response

Process called "handle_set_breakpoints_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Let source_path be ""
    Let breakpoints_data be Collections::create_list()
    
    If message_data contains "arguments":
        Let args_data be message_data["arguments"]
        If args_data contains "source":
            Let source_data be args_data["source"]
            If source_data contains "path":
                Set source_path as source_data["path"]
        If args_data contains "breakpoints":
            Set breakpoints_data as args_data["breakpoints"]
    
    Note: Clear existing breakpoints for this file
    Send clear_breakpoints_for_file with adapter.debugger and source_path
    
    Let response_breakpoints be Collections::create_list()
    
    Note: Set new breakpoints
    For Each breakpoint_data in breakpoints_data:
        Let line_number be (breakpoint_data["line"] as Integer)
        Let condition be ""
        
        If breakpoint_data contains "condition":
            Set condition as breakpoint_data["condition"]
        
        Let breakpoint_id be ""
        If length of condition > 0:
            Set breakpoint_id as Debugger::add_conditional_breakpoint with adapter.debugger and source_path and line_number and condition
        Otherwise:
            Set breakpoint_id as Debugger::add_line_breakpoint with adapter.debugger and source_path and line_number
        
        Let bp_response be Collections::create_dictionary()
        Set bp_response["verified"] as (length of breakpoint_id > 0) as String
        Set bp_response["line"] as line_number as String
        If length of breakpoint_id > 0:
            Set bp_response["id"] as breakpoint_id
        
        Add bp_response to response_breakpoints
    
    Let response_body be Collections::create_dictionary()
    Set response_body["breakpoints"] as response_breakpoints
    
    Let response be create_success_response with seq and "setBreakpoints" and response_body
    Return send_dap_response with adapter and response

Process called "handle_set_function_breakpoints_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Let breakpoints_data be Collections::create_list()
    
    If message_data contains "arguments":
        Let args_data be message_data["arguments"]
        If args_data contains "breakpoints":
            Set breakpoints_data as args_data["breakpoints"]
    
    Let response_breakpoints be Collections::create_list()
    
    Note: Set function breakpoints
    For Each breakpoint_data in breakpoints_data:
        Let function_name be breakpoint_data["name"]
        Let breakpoint_id be Debugger::add_function_breakpoint with adapter.debugger and function_name
        
        Let bp_response be Collections::create_dictionary()
        Set bp_response["verified"] as (length of breakpoint_id > 0) as String
        If length of breakpoint_id > 0:
            Set bp_response["id"] as breakpoint_id
        
        Add bp_response to response_breakpoints
    
    Let response_body be Collections::create_dictionary()
    Set response_body["breakpoints"] as response_breakpoints
    
    Let response be create_success_response with seq and "setFunctionBreakpoints" and response_body
    Return send_dap_response with adapter and response

Process called "handle_continue_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Let continue_success be Debugger::continue_execution with adapter.debugger
    
    If continue_success:
        Let response be create_success_response with seq and "continue" and Collections::create_dictionary()
        Send send_dap_response with adapter and response
        
        Note: Send continued event
        Let continued_event be create_continued_event()
        Send send_dap_event with adapter and continued_event
        
        Return true
    Otherwise:
        Let error_response be create_error_response with seq and "Failed to continue execution"
        Return send_dap_response with adapter and error_response

Process called "handle_next_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Let step_success be Debugger::step_over with adapter.debugger
    
    If step_success:
        Let response be create_success_response with seq and "next" and Collections::create_dictionary()
        Return send_dap_response with adapter and response
    Otherwise:
        Let error_response be create_error_response with seq and "Failed to step over"
        Return send_dap_response with adapter and error_response

Process called "handle_step_in_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Let step_success be Debugger::step_into with adapter.debugger
    
    If step_success:
        Let response be create_success_response with seq and "stepIn" and Collections::create_dictionary()
        Return send_dap_response with adapter and response
    Otherwise:
        Let error_response be create_error_response with seq and "Failed to step into"
        Return send_dap_response with adapter and error_response

Process called "handle_step_out_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Let step_success be Debugger::step_out with adapter.debugger
    
    If step_success:
        Let response be create_success_response with seq and "stepOut" and Collections::create_dictionary()
        Return send_dap_response with adapter and response
    Otherwise:
        Let error_response be create_error_response with seq and "Failed to step out"
        Return send_dap_response with adapter and error_response

Process called "handle_pause_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Let pause_success be Debugger::pause_execution with adapter.debugger
    
    If pause_success:
        Let response be create_success_response with seq and "pause" and Collections::create_dictionary()
        Send send_dap_response with adapter and response
        
        Note: Send stopped event
        Let stopped_event be create_stopped_event with "pause" and "Paused by user request"
        Send send_dap_event with adapter and stopped_event
        
        Return true
    Otherwise:
        Let error_response be create_error_response with seq and "Failed to pause execution"
        Return send_dap_response with adapter and error_response

Process called "handle_stack_trace_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Note: Refresh call stack from debugger
    Let stack_refreshed be Debugger::refresh_call_stack with adapter.debugger
    
    If not stack_refreshed:
        Let error_response be create_error_response with seq and "Failed to retrieve call stack"
        Return send_dap_response with adapter and error_response
    
    Note: Convert debugger stack frames to DAP format
    Let dap_stack_frames be Collections::create_list()
    Let frame_index be 0
    
    For Each stack_frame in adapter.debugger.call_stack:
        Let dap_frame be Collections::create_dictionary()
        Set dap_frame["id"] as frame_index as String
        Set dap_frame["name"] as stack_frame.function_name
        Set dap_frame["line"] as stack_frame.line_number as String
        Set dap_frame["column"] as stack_frame.column_number as String
        
        Let source_info be Collections::create_dictionary()
        Set source_info["name"] as get_filename_from_path with stack_frame.file_path
        Set source_info["path"] as stack_frame.file_path
        Set dap_frame["source"] as source_info
        
        Add dap_frame to dap_stack_frames
        Set frame_index as frame_index + 1
    
    Let response_body be Collections::create_dictionary()
    Set response_body["stackFrames"] as dap_stack_frames
    Set response_body["totalFrames"] as (length of dap_stack_frames) as String
    
    Let response be create_success_response with seq and "stackTrace" and response_body
    Return send_dap_response with adapter and response

Process called "handle_scopes_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Let frame_id be 0
    
    If message_data contains "arguments":
        Let args_data be message_data["arguments"]
        If args_data contains "frameId":
            Set frame_id as (args_data["frameId"] as Integer)
    
    Note: Select the requested stack frame
    Let frame_selected be Debugger::select_stack_frame with adapter.debugger and frame_id
    
    If not frame_selected:
        Let error_response be create_error_response with seq and "Invalid frame ID"
        Return send_dap_response with adapter and error_response
    
    Note: Create scope information
    Let scopes be Collections::create_list()
    
    Let local_scope be Collections::create_dictionary()
    Set local_scope["name"] as "Local"
    Set local_scope["variablesReference"] as (1000 + frame_id) as String
    Set local_scope["expensive"] as "false"
    Add local_scope to scopes
    
    Let global_scope be Collections::create_dictionary()
    Set global_scope["name"] as "Global"
    Set global_scope["variablesReference"] as (2000 + frame_id) as String
    Set global_scope["expensive"] as "false"
    Add global_scope to scopes
    
    Let response_body be Collections::create_dictionary()
    Set response_body["scopes"] as scopes
    
    Let response be create_success_response with seq and "scopes" and response_body
    Return send_dap_response with adapter and response

Process called "handle_variables_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Let variables_reference be 0
    
    If message_data contains "arguments":
        Let args_data be message_data["arguments"]
        If args_data contains "variablesReference":
            Set variables_reference as (args_data["variablesReference"] as Integer)
    
    Let variables be Collections::create_list()
    
    Note: Determine variable scope based on reference ID
    If variables_reference >= 1000 and variables_reference < 2000:
        Note: Local variables
        For Each var_name and debug_var in adapter.debugger.execution_context.local_variables:
            Let dap_var be convert_debug_variable_to_dap with debug_var and (variables_reference + 1)
            Add dap_var to variables
    
    Otherwise If variables_reference >= 2000 and variables_reference < 3000:
        Note: Global variables
        For Each var_name and debug_var in adapter.debugger.execution_context.global_variables:
            Let dap_var be convert_debug_variable_to_dap with debug_var and (variables_reference + 100)
            Add dap_var to variables
    
    Otherwise If variables_reference > 3000:
        Note: Child variables of expandable variable
        Let parent_var be find_variable_by_reference with adapter.debugger and variables_reference
        If parent_var is not null:
            Let children be Debugger::get_variable_children with adapter.debugger and parent_var
            For Each child in children:
                Let dap_var be convert_debug_variable_to_dap with child and (variables_reference + 1)
                Add dap_var to variables
    
    Let response_body be Collections::create_dictionary()
    Set response_body["variables"] as variables
    
    Let response be create_success_response with seq and "variables" and response_body
    Return send_dap_response with adapter and response

Process called "handle_evaluate_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Let expression be ""
    Let context be "watch"
    
    If message_data contains "arguments":
        Let args_data be message_data["arguments"]
        If args_data contains "expression":
            Set expression as args_data["expression"]
        If args_data contains "context":
            Set context as args_data["context"]
    
    Note: Evaluate expression in current frame context
    Let eval_result be Debugger::evaluate_expression with adapter.debugger and expression
    
    Let response_body be Collections::create_dictionary()
    Set response_body["result"] as eval_result.value
    Set response_body["type"] as eval_result.data_type
    Set response_body["variablesReference"] as "0"
    
    If eval_result.is_expandable:
        Set response_body["variablesReference"] as "3001"
    
    Let response be create_success_response with seq and "evaluate" and response_body
    Return send_dap_response with adapter and response

Process called "handle_disconnect_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Set adapter.active_session as false
    Set adapter.client_connection.is_connected as false
    
    Let response be create_success_response with seq and "disconnect" and Collections::create_dictionary()
    Return send_dap_response with adapter and response

Process called "handle_terminate_request" that takes adapter as LSPDebugAdapter and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    Note: Terminate the debugged process
    Let terminate_success be terminate_debugged_process with adapter.debugger
    
    Set adapter.active_session as false
    
    If terminate_success:
        Let response be create_success_response with seq and "terminate" and Collections::create_dictionary()
        Let sent be send_dap_response with adapter and response
        
        Note: Send terminated event
        Let terminated_event be create_terminated_event()
        Send send_dap_event with adapter and terminated_event
        
        Return sent
    Otherwise:
        Let error_response be create_error_response with seq and "Failed to terminate process"
        Return send_dap_response with adapter and error_response

Note: Helper functions for DAP message handling
Process called "convert_debug_variable_to_dap" that takes debug_var as Debugger::DebugVariable and next_ref_id as Integer returns Dictionary[String, String]:
    Let dap_var be Collections::create_dictionary()
    Set dap_var["name"] as debug_var.name
    Set dap_var["value"] as debug_var.value
    Set dap_var["type"] as debug_var.data_type
    Set dap_var["variablesReference"] as "0"
    
    If debug_var.is_expandable:
        Set dap_var["variablesReference"] as next_ref_id as String
    
    Return dap_var

Process called "get_filename_from_path" that takes file_path as String returns String:
    Let path_parts be split_string with file_path and "/"
    If length of path_parts > 0:
        Return path_parts[length of path_parts - 1]
    Otherwise:
        Return file_path

Process called "create_success_response" that takes seq as Integer and command as String and body as Dictionary[String, String] returns DAPMessage:
    Return DAPMessage with:
        message_type as DAPMessageType::Response
        seq as seq
        command as command
        request_seq as seq
        success as true
        message as ""
        body as body

Process called "create_error_response" that takes seq as Integer and error_message as String returns DAPMessage:
    Return DAPMessage with:
        message_type as DAPMessageType::Response
        seq as seq
        command as ""
        request_seq as seq
        success as false
        message as error_message
        body as Collections::create_dictionary()

Process called "create_initialized_event" returns DAPMessage:
    Return DAPMessage with:
        message_type as DAPMessageType::Event
        seq as 0
        command as "initialized"
        request_seq as 0
        success as true
        message as ""
        body as Collections::create_dictionary()

Process called "create_stopped_event" that takes reason as String and description as String returns DAPMessage:
    Let body be Collections::create_dictionary()
    Set body["reason"] as reason
    Set body["description"] as description
    Set body["threadId"] as "1"
    Set body["allThreadsStopped"] as "true"
    
    Return DAPMessage with:
        message_type as DAPMessageType::Event
        seq as 0
        command as "stopped"
        request_seq as 0
        success as true
        message as ""
        body as body

Process called "create_continued_event" returns DAPMessage:
    Let body be Collections::create_dictionary()
    Set body["threadId"] as "1"
    Set body["allThreadsContinued"] as "true"
    
    Return DAPMessage with:
        message_type as DAPMessageType::Event
        seq as 0
        command as "continued"
        request_seq as 0
        success as true
        message as ""
        body as body

Process called "create_terminated_event" returns DAPMessage:
    Return DAPMessage with:
        message_type as DAPMessageType::Event
        seq as 0
        command as "terminated"
        request_seq as 0
        success as true
        message as ""
        body as Collections::create_dictionary()

Note: Communication functions
Process called "send_dap_response" that takes adapter as LSPDebugAdapter and response as DAPMessage returns Boolean:
    Let json_response be serialize_dap_message_to_json with response and adapter.next_seq
    Set adapter.next_seq as adapter.next_seq + 1
    Return write_dap_message_to_stdout with json_response

Process called "send_dap_event" that takes adapter as LSPDebugAdapter and event as DAPMessage returns Boolean:
    Let json_event be serialize_dap_message_to_json with event and adapter.next_seq
    Set adapter.next_seq as adapter.next_seq + 1
    Return write_dap_message_to_stdout with json_event

Process called "invoke_message_handler" that takes adapter as LSPDebugAdapter and handler_name as String and seq as Integer and message_data as Dictionary[String, String] returns Boolean:
    If handler_name equals "handle_initialize_request":
        Return handle_initialize_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_launch_request":
        Return handle_launch_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_attach_request":
        Return handle_attach_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_configuration_done_request":
        Return handle_configuration_done_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_set_breakpoints_request":
        Return handle_set_breakpoints_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_set_function_breakpoints_request":
        Return handle_set_function_breakpoints_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_continue_request":
        Return handle_continue_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_next_request":
        Return handle_next_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_step_in_request":
        Return handle_step_in_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_step_out_request":
        Return handle_step_out_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_pause_request":
        Return handle_pause_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_stack_trace_request":
        Return handle_stack_trace_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_scopes_request":
        Return handle_scopes_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_variables_request":
        Return handle_variables_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_evaluate_request":
        Return handle_evaluate_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_disconnect_request":
        Return handle_disconnect_request with adapter and seq and message_data
    Otherwise If handler_name equals "handle_terminate_request":
        Return handle_terminate_request with adapter and seq and message_data
    Otherwise:
        Return false

Note: Low-level I/O functions (FFI boundaries - implemented by host)
Process called "read_dap_message_from_stdin" returns String:
    Return ""

Process called "write_dap_message_to_stdout" that takes message as String returns Boolean:
    Return false

Process called "serialize_dap_message_to_json" that takes message as DAPMessage and seq as Integer returns String:
    Return ""

Process called "split_string" that takes input as String and delimiter as String returns List[String]:
    Return Collections::create_list()

Process called "launch_program_for_debugging" that takes debugger as Debugger::AdvancedDebugger and program_path as String and args as List[String] returns Boolean:
    Return false

Process called "attach_to_process_for_debugging" that takes debugger as Debugger::AdvancedDebugger and process_id as Integer returns Boolean:
    Return false

Process called "terminate_debugged_process" that takes debugger as Debugger::AdvancedDebugger returns Boolean:
    Return false

Process called "clear_breakpoints_for_file" that takes debugger as Debugger::AdvancedDebugger and file_path as String returns Boolean:
    Return false

Process called "find_variable_by_reference" that takes debugger as Debugger::AdvancedDebugger and reference_id as Integer returns Debugger::DebugVariable:
    Return Debugger::DebugVariable with:
        name as ""
        value as ""
        data_type as ""
        is_expandable as false
        children as Collections::create_list()
        memory_address as ""
        scope as ""