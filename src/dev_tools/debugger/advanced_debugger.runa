Note: Advanced Debugger for Runa Language
Note: Provides comprehensive debugging capabilities with breakpoint management,
Note: variable inspection, call stack analysis, and step-through debugging

Import "collections" as Collections
Import "os" as OS

Note: Debugger state and breakpoint management
Type called "BreakpointType":
    | Line
    | Function  
    | Conditional
    | Exception

Type called "Breakpoint":
    id as String
    breakpoint_type as BreakpointType
    file_path as String
    line_number as Integer
    function_name as String
    condition as String
    is_enabled as Boolean
    hit_count as Integer
    hit_condition as String

Type called "StackFrame":
    frame_id as String
    function_name as String
    file_path as String
    line_number as Integer
    column_number as Integer
    variables as Dictionary[String, DebugVariable]
    is_user_code as Boolean

Type called "DebugVariable":
    name as String
    value as String
    data_type as String
    is_expandable as Boolean
    children as List[DebugVariable]
    memory_address as String
    scope as String

Type called "DebuggerState":
    | Running
    | Paused
    | Stopped
    | Error

Type called "StepType":
    | StepOver
    | StepInto
    | StepOut
    | Continue

Type called "AdvancedDebugger":
    current_state as DebuggerState
    breakpoints as Dictionary[String, Breakpoint]
    call_stack as List[StackFrame]
    current_frame as StackFrame
    source_maps as Dictionary[String, SourceMap]
    runtime_connection as RuntimeConnection
    lsp_integration as LSPDebugAdapter
    next_breakpoint_id as Integer
    execution_context as ExecutionContext

Note: Source mapping for debug information
Type called "SourceMap":
    file_path as String
    line_mappings as Dictionary[Integer, BytecodeLocation]
    function_mappings as Dictionary[String, FunctionDebugInfo]
    variable_mappings as Dictionary[String, VariableDebugInfo]

Type called "BytecodeLocation":
    instruction_pointer as Integer
    bytecode_offset as Integer
    optimization_level as Integer

Type called "FunctionDebugInfo":
    function_name as String
    start_line as Integer
    end_line as Integer
    parameters as List[VariableDebugInfo]
    local_variables as List[VariableDebugInfo]

Type called "VariableDebugInfo":
    name as String
    data_type as String
    memory_location as String
    scope_start as Integer
    scope_end as Integer

Note: Runtime connection interface
Type called "RuntimeConnection":
    process_id as Integer
    is_connected as Boolean
    runtime_type as String
    debug_protocol_version as String

Type called "ExecutionContext":
    current_instruction as Integer
    local_variables as Dictionary[String, DebugVariable]
    global_variables as Dictionary[String, DebugVariable]
    heap_state as HeapSnapshot
    thread_id as String

Type called "HeapSnapshot":
    total_memory as Integer
    used_memory as Integer
    objects as List[HeapObject]
    gc_generation as Integer

Type called "HeapObject":
    object_id as String
    object_type as String
    size_bytes as Integer
    references as List[String]
    is_root as Boolean

Note: Create new advanced debugger instance
Process called "create_advanced_debugger" returns AdvancedDebugger:
    Return AdvancedDebugger with:
        current_state as DebuggerState::Stopped
        breakpoints as Collections::create_dictionary()
        call_stack as Collections::create_list()
        current_frame as create_empty_stack_frame()
        source_maps as Collections::create_dictionary()
        runtime_connection as create_runtime_connection()
        lsp_integration as create_lsp_debug_adapter()
        next_breakpoint_id as 1
        execution_context as create_execution_context()

Process called "create_empty_stack_frame" returns StackFrame:
    Return StackFrame with:
        frame_id as ""
        function_name as ""
        file_path as ""
        line_number as 0
        column_number as 0
        variables as Collections::create_dictionary()
        is_user_code as true

Process called "create_runtime_connection" returns RuntimeConnection:
    Return RuntimeConnection with:
        process_id as 0
        is_connected as false
        runtime_type as "runa"
        debug_protocol_version as "1.0"

Process called "create_execution_context" returns ExecutionContext:
    Return ExecutionContext with:
        current_instruction as 0
        local_variables as Collections::create_dictionary()
        global_variables as Collections::create_dictionary()
        heap_state as create_heap_snapshot()
        thread_id as "main"

Process called "create_heap_snapshot" returns HeapSnapshot:
    Return HeapSnapshot with:
        total_memory as 0
        used_memory as 0
        objects as Collections::create_list()
        gc_generation as 0

Note: Breakpoint management
Process called "add_line_breakpoint" that takes debugger as AdvancedDebugger and file_path as String and line_number as Integer returns String:
    Let breakpoint_id be "bp_" joined with (debugger.next_breakpoint_id as String)
    
    Let breakpoint be Breakpoint with:
        id as breakpoint_id
        breakpoint_type as BreakpointType::Line
        file_path as file_path
        line_number as line_number
        function_name as ""
        condition as ""
        is_enabled as true
        hit_count as 0
        hit_condition as ""
    
    Set debugger.breakpoints[breakpoint_id] as breakpoint
    Set debugger.next_breakpoint_id as debugger.next_breakpoint_id + 1
    
    Note: Register breakpoint with runtime
    Let runtime_success be register_breakpoint_with_runtime with debugger.runtime_connection and breakpoint
    
    If runtime_success:
        Return breakpoint_id
    Otherwise:
        Remove debugger.breakpoints[breakpoint_id]
        Return ""

Process called "add_function_breakpoint" that takes debugger as AdvancedDebugger and function_name as String returns String:
    Let breakpoint_id be "bp_" joined with (debugger.next_breakpoint_id as String)
    
    Let breakpoint be Breakpoint with:
        id as breakpoint_id
        breakpoint_type as BreakpointType::Function
        file_path as ""
        line_number as 0
        function_name as function_name
        condition as ""
        is_enabled as true
        hit_count as 0
        hit_condition as ""
    
    Set debugger.breakpoints[breakpoint_id] as breakpoint
    Set debugger.next_breakpoint_id as debugger.next_breakpoint_id + 1
    
    Let runtime_success be register_breakpoint_with_runtime with debugger.runtime_connection and breakpoint
    
    If runtime_success:
        Return breakpoint_id
    Otherwise:
        Remove debugger.breakpoints[breakpoint_id]
        Return ""

Process called "add_conditional_breakpoint" that takes debugger as AdvancedDebugger and file_path as String and line_number as Integer and condition as String returns String:
    Let breakpoint_id be "bp_" joined with (debugger.next_breakpoint_id as String)
    
    Let breakpoint be Breakpoint with:
        id as breakpoint_id
        breakpoint_type as BreakpointType::Conditional
        file_path as file_path
        line_number as line_number
        function_name as ""
        condition as condition
        is_enabled as true
        hit_count as 0
        hit_condition as ""
    
    Set debugger.breakpoints[breakpoint_id] as breakpoint
    Set debugger.next_breakpoint_id as debugger.next_breakpoint_id + 1
    
    Let runtime_success be register_breakpoint_with_runtime with debugger.runtime_connection and breakpoint
    
    If runtime_success:
        Return breakpoint_id
    Otherwise:
        Remove debugger.breakpoints[breakpoint_id]
        Return ""

Process called "remove_breakpoint" that takes debugger as AdvancedDebugger and breakpoint_id as String returns Boolean:
    If debugger.breakpoints contains breakpoint_id:
        Let breakpoint be debugger.breakpoints[breakpoint_id]
        Let runtime_success be unregister_breakpoint_with_runtime with debugger.runtime_connection and breakpoint
        Remove debugger.breakpoints[breakpoint_id]
        Return runtime_success
    Otherwise:
        Return false

Process called "enable_breakpoint" that takes debugger as AdvancedDebugger and breakpoint_id as String returns Boolean:
    If debugger.breakpoints contains breakpoint_id:
        Set debugger.breakpoints[breakpoint_id].is_enabled as true
        Return update_breakpoint_in_runtime with debugger.runtime_connection and debugger.breakpoints[breakpoint_id]
    Otherwise:
        Return false

Process called "disable_breakpoint" that takes debugger as AdvancedDebugger and breakpoint_id as String returns Boolean:
    If debugger.breakpoints contains breakpoint_id:
        Set debugger.breakpoints[breakpoint_id].is_enabled as false
        Return update_breakpoint_in_runtime with debugger.runtime_connection and debugger.breakpoints[breakpoint_id]
    Otherwise:
        Return false

Note: Variable inspection and evaluation
Process called "inspect_variable" that takes debugger as AdvancedDebugger and variable_name as String returns DebugVariable:
    Note: Check current frame first
    If debugger.current_frame.variables contains variable_name:
        Return debugger.current_frame.variables[variable_name]
    
    Note: Check local variables in execution context
    If debugger.execution_context.local_variables contains variable_name:
        Return debugger.execution_context.local_variables[variable_name]
    
    Note: Check global variables
    If debugger.execution_context.global_variables contains variable_name:
        Return debugger.execution_context.global_variables[variable_name]
    
    Note: Variable not found, return empty debug variable
    Return DebugVariable with:
        name as variable_name
        value as "<not found>"
        data_type as "unknown"
        is_expandable as false
        children as Collections::create_list()
        memory_address as ""
        scope as "unknown"

Process called "evaluate_expression" that takes debugger as AdvancedDebugger and expression as String returns DebugVariable:
    Note: Send expression evaluation request to runtime
    Let evaluation_result be evaluate_expression_in_runtime with debugger.runtime_connection and expression and debugger.current_frame.frame_id
    
    If evaluation_result.success:
        Return DebugVariable with:
            name as expression
            value as evaluation_result.value
            data_type as evaluation_result.data_type
            is_expandable as evaluation_result.is_expandable
            children as evaluation_result.children
            memory_address as evaluation_result.memory_address
            scope as "expression"
    Otherwise:
        Return DebugVariable with:
            name as expression
            value as "<evaluation failed: " joined with evaluation_result.error joined with ">"
            data_type as "error"
            is_expandable as false
            children as Collections::create_list()
            memory_address as ""
            scope as "expression"

Process called "get_variable_children" that takes debugger as AdvancedDebugger and parent_variable as DebugVariable returns List[DebugVariable]:
    If not parent_variable.is_expandable:
        Return Collections::create_list()
    
    Note: Request children from runtime based on memory address
    Let children_result be get_variable_children_from_runtime with debugger.runtime_connection and parent_variable.memory_address
    
    If children_result.success:
        Return children_result.children
    Otherwise:
        Return Collections::create_list()

Note: Call stack analysis
Process called "refresh_call_stack" that takes debugger as AdvancedDebugger returns Boolean:
    Note: Request current call stack from runtime
    Let stack_result be get_call_stack_from_runtime with debugger.runtime_connection
    
    If stack_result.success:
        Set debugger.call_stack as stack_result.frames
        If length of debugger.call_stack > 0:
            Set debugger.current_frame as debugger.call_stack[0]
        Otherwise:
            Set debugger.current_frame as create_empty_stack_frame()
        Return true
    Otherwise:
        Return false

Process called "select_stack_frame" that takes debugger as AdvancedDebugger and frame_index as Integer returns Boolean:
    If frame_index >= 0 and frame_index < length of debugger.call_stack:
        Set debugger.current_frame as debugger.call_stack[frame_index]
        
        Note: Update execution context for selected frame
        Let context_result be get_frame_context_from_runtime with debugger.runtime_connection and debugger.current_frame.frame_id
        
        If context_result.success:
            Set debugger.execution_context.local_variables as context_result.local_variables
            Set debugger.execution_context.current_instruction as context_result.instruction_pointer
            Return true
        Otherwise:
            Return false
    Otherwise:
        Return false

Note: Step-through debugging
Process called "step_over" that takes debugger as AdvancedDebugger returns Boolean:
    If debugger.current_state equals DebuggerState::Paused:
        Let step_result be send_step_command_to_runtime with debugger.runtime_connection and StepType::StepOver
        If step_result.success:
            Set debugger.current_state as DebuggerState::Running
            Return true
        Otherwise:
            Return false
    Otherwise:
        Return false

Process called "step_into" that takes debugger as AdvancedDebugger returns Boolean:
    If debugger.current_state equals DebuggerState::Paused:
        Let step_result be send_step_command_to_runtime with debugger.runtime_connection and StepType::StepInto
        If step_result.success:
            Set debugger.current_state as DebuggerState::Running
            Return true
        Otherwise:
            Return false
    Otherwise:
        Return false

Process called "step_out" that takes debugger as AdvancedDebugger returns Boolean:
    If debugger.current_state equals DebuggerState::Paused:
        Let step_result be send_step_command_to_runtime with debugger.runtime_connection and StepType::StepOut
        If step_result.success:
            Set debugger.current_state as DebuggerState::Running
            Return true
        Otherwise:
            Return false
    Otherwise:
        Return false

Process called "continue_execution" that takes debugger as AdvancedDebugger returns Boolean:
    If debugger.current_state equals DebuggerState::Paused:
        Let continue_result be send_step_command_to_runtime with debugger.runtime_connection and StepType::Continue
        If continue_result.success:
            Set debugger.current_state as DebuggerState::Running
            Return true
        Otherwise:
            Return false
    Otherwise:
        Return false

Process called "pause_execution" that takes debugger as AdvancedDebugger returns Boolean:
    If debugger.current_state equals DebuggerState::Running:
        Let pause_result be send_pause_command_to_runtime with debugger.runtime_connection
        If pause_result.success:
            Set debugger.current_state as DebuggerState::Paused
            Let stack_refreshed be refresh_call_stack with debugger
            Return stack_refreshed
        Otherwise:
            Return false
    Otherwise:
        Return false

Note: Source mapping and debugging information
Process called "load_source_map" that takes debugger as AdvancedDebugger and file_path as String returns Boolean:
    Note: Load debugging symbols and source mapping from compiled binary
    Let debug_info_result be load_debug_info_from_file with file_path
    
    If debug_info_result.success:
        Let source_map be SourceMap with:
            file_path as file_path
            line_mappings as debug_info_result.line_mappings
            function_mappings as debug_info_result.function_mappings
            variable_mappings as debug_info_result.variable_mappings
        
        Set debugger.source_maps[file_path] as source_map
        Return true
    Otherwise:
        Return false

Process called "get_source_location_for_instruction" that takes debugger as AdvancedDebugger and instruction_pointer as Integer returns Dictionary[String, String]:
    Note: Find source location for given instruction pointer
    For Each file_path and source_map in debugger.source_maps:
        For Each line_number and bytecode_location in source_map.line_mappings:
            If bytecode_location.instruction_pointer equals instruction_pointer:
                Return Dictionary with:
                    "file_path" as file_path
                    "line_number" as (line_number as String)
                    "column_number" as "0"
                    "function_name" as get_function_name_for_line with source_map and line_number
    
    Note: Source location not found
    Return Dictionary with:
        "file_path" as ""
        "line_number" as "0"
        "column_number" as "0"
        "function_name" as ""

Process called "get_function_name_for_line" that takes source_map as SourceMap and line_number as Integer returns String:
    For Each function_name and function_info in source_map.function_mappings:
        If line_number >= function_info.start_line and line_number <= function_info.end_line:
            Return function_name
    Return ""

Note: Runtime interface functions (FFI boundaries - implemented by host)
Process called "register_breakpoint_with_runtime" that takes connection as RuntimeConnection and breakpoint as Breakpoint returns Boolean:
    Return false

Process called "unregister_breakpoint_with_runtime" that takes connection as RuntimeConnection and breakpoint as Breakpoint returns Boolean:
    Return false

Process called "update_breakpoint_in_runtime" that takes connection as RuntimeConnection and breakpoint as Breakpoint returns Boolean:
    Return false

Process called "evaluate_expression_in_runtime" that takes connection as RuntimeConnection and expression as String and frame_id as String returns EvaluationResult:
    Return EvaluationResult with:
        success as false
        value as ""
        data_type as ""
        is_expandable as false
        children as Collections::create_list()
        memory_address as ""
        error as "Not implemented"

Process called "get_variable_children_from_runtime" that takes connection as RuntimeConnection and memory_address as String returns ChildrenResult:
    Return ChildrenResult with:
        success as false
        children as Collections::create_list()
        error as "Not implemented"

Process called "get_call_stack_from_runtime" that takes connection as RuntimeConnection returns StackResult:
    Return StackResult with:
        success as false
        frames as Collections::create_list()
        error as "Not implemented"

Process called "get_frame_context_from_runtime" that takes connection as RuntimeConnection and frame_id as String returns ContextResult:
    Return ContextResult with:
        success as false
        local_variables as Collections::create_dictionary()
        instruction_pointer as 0
        error as "Not implemented"

Process called "send_step_command_to_runtime" that takes connection as RuntimeConnection and step_type as StepType returns StepResult:
    Return StepResult with:
        success as false
        error as "Not implemented"

Process called "send_pause_command_to_runtime" that takes connection as RuntimeConnection returns PauseResult:
    Return PauseResult with:
        success as false
        error as "Not implemented"

Process called "load_debug_info_from_file" that takes file_path as String returns DebugInfoResult:
    Return DebugInfoResult with:
        success as false
        line_mappings as Collections::create_dictionary()
        function_mappings as Collections::create_dictionary()
        variable_mappings as Collections::create_dictionary()
        error as "Not implemented"

Note: Result types for runtime interface
Type called "EvaluationResult":
    success as Boolean
    value as String
    data_type as String
    is_expandable as Boolean
    children as List[DebugVariable]
    memory_address as String
    error as String

Type called "ChildrenResult":
    success as Boolean
    children as List[DebugVariable]
    error as String

Type called "StackResult":
    success as Boolean
    frames as List[StackFrame]
    error as String

Type called "ContextResult":
    success as Boolean
    local_variables as Dictionary[String, DebugVariable]
    instruction_pointer as Integer
    error as String

Type called "StepResult":
    success as Boolean
    error as String

Type called "PauseResult":
    success as Boolean
    error as String

Type called "DebugInfoResult":
    success as Boolean
    line_mappings as Dictionary[Integer, BytecodeLocation]
    function_mappings as Dictionary[String, FunctionDebugInfo]
    variable_mappings as Dictionary[String, VariableDebugInfo]
    error as String