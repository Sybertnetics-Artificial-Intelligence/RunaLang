Note:
dev_tools/repl/triple_syntax_repl.runa
Interactive Triple Syntax REPL with Live Mode Switching

This module provides a comprehensive interactive REPL (Read-Eval-Print Loop) that showcases
the full power of Runa's Triple Syntax Architecture. Users can seamlessly switch between
Viewer, Canonical, and Technical modes while seeing real-time conversions and execution results.

Revolutionary features:
- Live syntax mode switching with instant conversion preview
- Real-time execution across all three syntax modes
- Interactive pattern discovery and experimentation
- Syntax learning assistance with guided tutorials
- Performance benchmarking across syntax modes
- Code snippet sharing and collaboration
- Integration with community pattern marketplace
- AI-powered syntax suggestions and completions
- Visual syntax flow diagrams and explanations
- Export capabilities for IDE integration testing
:End Note

Import "compiler/frontend/patterns/triple_syntax_converter" as TripleSyntaxConverter
Import "compiler/frontend/macros/triple_syntax_macros" as TripleSyntaxMacros
Import "compiler/frontend/patterns/community_marketplace" as CommunityMarketplace
Import "compiler/frontend/diagnostics/diagnostic_engine" as DiagnosticEngine
Import "dev/debug/errors/core" as Errors

Note: =============================================================================
Note: TRIPLE SYNTAX REPL CORE DATA STRUCTURES
Note: =============================================================================

Type called "REPLSession":
    session_id as String                    Note: Unique session identifier
    current_syntax_mode as TripleSyntaxConverter.SyntaxMode Note: Active syntax mode
    session_history as List[REPLCommand]   Note: Command history for this session
    active_variables as Dictionary[String, REPLValue] Note: Variables in current scope
    syntax_preferences as REPLSyntaxPreferences Note: User syntax preferences
    
    Note: Conversion and caching
    conversion_cache as Dictionary[String, String] Note: Cache for syntax conversions
    last_conversion_time as Integer        Note: Performance tracking
    
    Note: Learning and assistance
    tutorial_mode as Boolean               Note: Whether tutorial mode is active
    current_tutorial_step as Integer      Note: Current tutorial step
    assistance_level as String            Note: Level of syntax assistance (beginner, intermediate, expert)
    
    Note: Performance and analytics
    execution_metrics as List[ExecutionMetric] Note: Performance metrics for this session
    syntax_usage_stats as Dictionary[String, Integer] Note: Usage statistics by syntax mode
    
    Note: Collaboration and sharing
    shared_session as Boolean             Note: Whether session is shared with others
    collaboration_token as String         Note: Token for collaborative sessions

Type called "REPLCommand":
    command_id as String                   Note: Unique command identifier
    input_text as String                  Note: Original user input
    input_syntax_mode as TripleSyntaxConverter.SyntaxMode Note: Syntax mode of input
    timestamp as Integer                  Note: When command was executed
    
    Note: Processing results
    parsed_successfully as Boolean        Note: Whether command parsed correctly
    execution_result as REPLExecutionResult Note: Execution outcome
    conversion_results as Dictionary[String, String] Note: Conversions to other syntax modes
    
    Note: Performance metrics
    parse_time as Integer                 Note: Parse time in microseconds
    execution_time as Integer             Note: Execution time in microseconds
    conversion_time as Integer            Note: Time for syntax conversions
    
    Note: Error handling
    errors as List[String]                Note: Any errors encountered
    warnings as List[String]              Note: Any warnings generated
    suggestions as List[String]           Note: Syntax improvement suggestions

Type called "REPLExecutionResult":
    success as Boolean                    Note: Whether execution succeeded
    result_value as REPLValue            Note: The computed result
    result_type as String                Note: Type of the result
    output_text as String                Note: Text output for display
    side_effects as List[String]         Note: Any side effects (prints, assignments, etc.)
    performance_metrics as Dictionary[String, Float] Note: Execution performance data

Type called "REPLValue":
    value_type as String                 Note: Type of the value
    value_data as String                 Note: String representation of value
    display_format as Dictionary[String, String] Note: How to display in each syntax mode
    is_displayable as Boolean            Note: Whether value can be displayed
    memory_usage as Integer              Note: Memory used by this value

Type called "REPLSyntaxPreferences":
    preferred_input_mode as TripleSyntaxConverter.SyntaxMode Note: Preferred input syntax
    auto_convert_output as Boolean       Note: Auto-convert output to preferred mode
    show_all_conversions as Boolean      Note: Show conversions in all modes
    highlight_differences as Boolean     Note: Highlight syntax differences
    enable_suggestions as Boolean        Note: Enable syntax improvement suggestions
    tutorial_prompts_enabled as Boolean Note: Show tutorial prompts

Type called "ExecutionMetric":
    metric_name as String                Note: Name of the metric
    metric_value as Float                Note: Measured value
    syntax_mode as TripleSyntaxConverter.SyntaxMode Note: Syntax mode being measured
    timestamp as Integer                 Note: When metric was recorded
    context as String                    Note: Additional context for the metric

Note: =============================================================================
Note: REPL CORE FUNCTIONALITY
Note: =============================================================================

Process called "create_repl_session" that takes session_config as Dictionary[String, String] returns REPLSession:
    Note: Create new interactive Triple Syntax REPL session
    Note: Initializes session with user preferences and tutorial settings
    
    Let session_id be generate_session_id()
    Let default_syntax_mode be parse_syntax_mode(get_value_or_default(session_config, "default_mode", "canonical"))
    
    Let session be REPLSession with:
        session_id: session_id
        current_syntax_mode: default_syntax_mode
        session_history: empty list
        active_variables: empty dictionary
        syntax_preferences: initialize_default_preferences(session_config)
        conversion_cache: empty dictionary
        last_conversion_time: 0
        tutorial_mode: parse_as_boolean(get_value_or_default(session_config, "tutorial_mode", "false"))
        current_tutorial_step: 0
        assistance_level: get_value_or_default(session_config, "assistance_level", "intermediate")
        execution_metrics: empty list
        syntax_usage_stats: Dictionary with:
            "viewer": 0
            "canonical": 0
            "technical": 0
        shared_session: parse_as_boolean(get_value_or_default(session_config, "shared", "false"))
        collaboration_token: ""
    
    Note: Initialize with welcome message and tutorial prompt
    Let welcome_result be display_welcome_message(session)
    
    If session.tutorial_mode:
        Let tutorial_start_result be start_tutorial_mode(session)
    
    Print "ðŸš€ Triple Syntax REPL initialized!"
    Print "Session ID: " joined with session_id
    Print "Default Mode: " joined with default_syntax_mode as String
    Print "Type ':help' for commands or ':tutorial' to start learning"
    
    Return session

Process called "process_repl_input" that takes session as REPLSession, input_text as String returns REPLCommand:
    Note: Process user input through the Triple Syntax REPL pipeline
    Note: Handles special commands, syntax conversion, execution, and display
    
    Let command_start_time be get_current_timestamp_microseconds()
    
    Note: Create command record
    Let command be REPLCommand with:
        command_id: generate_command_id()
        input_text: input_text
        input_syntax_mode: session.current_syntax_mode
        timestamp: command_start_time
        parsed_successfully: false
        execution_result: REPLExecutionResult with:
            success: false
            result_value: REPLValue with: value_type: "none", value_data: "", display_format: empty dictionary, is_displayable: false, memory_usage: 0
            result_type: "none"
            output_text: ""
            side_effects: empty list
            performance_metrics: empty dictionary
        conversion_results: empty dictionary
        parse_time: 0
        execution_time: 0
        conversion_time: 0
        errors: empty list
        warnings: empty list
        suggestions: empty list
    
    Note: Handle special REPL commands
    If starts_with(input_text, ":"):
        Let special_command_result be process_special_command(session, input_text)
        Set command.execution_result to special_command_result
        Set command.parsed_successfully to special_command_result.success
        Add command to session.session_history
        Return command
    
    Note: Parse input in current syntax mode
    Let parse_start_time be get_current_timestamp_microseconds()
    Let parse_result be parse_input_in_syntax_mode(input_text, session.current_syntax_mode)
    Let parse_end_time be get_current_timestamp_microseconds()
    Set command.parse_time to parse_end_time minus parse_start_time
    Set command.parsed_successfully to parse_result.success
    
    If NOT parse_result.success:
        Set command.errors to parse_result.errors
        Set command.suggestions to generate_syntax_error_suggestions(parse_result.errors, session.current_syntax_mode)
        Add command to session.session_history
        Return command
    
    Note: Execute parsed command
    Let execution_start_time be get_current_timestamp_microseconds()
    Let execution_result be execute_parsed_command(parse_result.parsed_ast, session)
    Let execution_end_time be get_current_timestamp_microseconds()
    Set command.execution_time to execution_end_time minus execution_start_time
    Set command.execution_result to execution_result
    
    Note: Generate syntax conversions if successful
    If execution_result.success:
        Let conversion_start_time be get_current_timestamp_microseconds()
        Set command.conversion_results to generate_all_syntax_conversions(input_text, session.current_syntax_mode, session)
        Let conversion_end_time be get_current_timestamp_microseconds()
        Set command.conversion_time to conversion_end_time minus conversion_start_time
    
    Note: Update session state
    Let session_update_success be update_session_after_command(session, command)
    
    Note: Generate suggestions for improvement
    Set command.suggestions to generate_command_improvement_suggestions(command, session)
    
    Note: Record performance metrics
    Let metric_recording_success be record_command_performance_metrics(session, command)
    
    Add command to session.session_history
    Return command

Process called "switch_syntax_mode" that takes session as REPLSession, target_mode as TripleSyntaxConverter.SyntaxMode returns Dictionary[String, String]:
    Note: Switch REPL to different syntax mode with live preview
    Note: Shows conversion of recent commands in new syntax mode
    
    Let switch_result be Dictionary with:
        "success": "false"
        "previous_mode": session.current_syntax_mode as String
        "new_mode": target_mode as String
        "preview_conversions": ""
        "warnings": ""
    
    Let previous_mode be session.current_syntax_mode
    Set session.current_syntax_mode to target_mode
    
    Note: Update usage statistics
    Set session.syntax_usage_stats[target_mode as String] to get_value_or_default(session.syntax_usage_stats, target_mode as String, 0) plus 1
    
    Note: Generate preview of recent commands in new syntax mode
    Let preview_conversions be empty List[String]
    Let recent_commands be get_last_n_commands(session, 3)
    
    For Each recent_command in recent_commands:
        If recent_command.parsed_successfully:
            Let converted_input be convert_syntax_with_caching(
                recent_command.input_text,
                recent_command.input_syntax_mode,
                target_mode,
                session
            )
            Let preview_line be "  " joined with recent_command.input_syntax_mode as String joined with ": " joined with recent_command.input_text
            Add preview_line to preview_conversions
            Let converted_line be "  " joined with target_mode as String joined with ": " joined with converted_input
            Add converted_line to preview_conversions
            Add "" to preview_conversions
    
    Set switch_result["preview_conversions"] to join_with_newlines(preview_conversions)
    Set switch_result["success"] to "true"
    
    Note: Display mode switch confirmation
    Print "ðŸ”„ Syntax mode switched: " joined with previous_mode as String joined with " â†’ " joined with target_mode as String
    
    If size(preview_conversions) > 0:
        Print "\nðŸ“‹ Recent commands in new syntax mode:"
        Print switch_result["preview_conversions"]
    
    Note: Show mode-specific tips if assistance is enabled
    If session.syntax_preferences.enable_suggestions:
        Let mode_tips be get_syntax_mode_tips(target_mode, session.assistance_level)
        If mode_tips is not equal to "":
            Print "\nðŸ’¡ " joined with target_mode as String joined with " mode tips:"
            Print mode_tips
    
    Return switch_result

Process called "display_command_results" that takes command as REPLCommand, session as REPLSession returns String:
    Note: Display command results with syntax-aware formatting
    Note: Shows results in current mode plus conversions if requested
    
    Let output_lines be empty List[String]
    
    Note: Display any errors first
    If size(command.errors) > 0:
        Add "âŒ Errors:" to output_lines
        For Each error in command.errors:
            Add ("   " joined with error) to output_lines
        Add "" to output_lines
    
    Note: Display warnings
    If size(command.warnings) > 0:
        Add "âš ï¸  Warnings:" to output_lines
        For Each warning in command.warnings:
            Add ("   " joined with warning) to output_lines
        Add "" to output_lines
    
    Note: Display execution result if successful
    If command.execution_result.success:
        If command.execution_result.output_text is not equal to "":
            Add "ðŸ“¤ Output:" to output_lines
            Add command.execution_result.output_text to output_lines
            Add "" to output_lines
        
        If command.execution_result.result_value.is_displayable:
            Add "âœ¨ Result:" to output_lines
            Let result_display be format_result_for_syntax_mode(command.execution_result.result_value, session.current_syntax_mode)
            Add result_display to output_lines
            Add "" to output_lines
    
    Note: Display syntax conversions if enabled
    If session.syntax_preferences.show_all_conversions and size(command.conversion_results) > 0:
        Add "ðŸ”„ Syntax Conversions:" to output_lines
        For Each mode_name in get_keys(command.conversion_results):
            If mode_name is not equal to session.current_syntax_mode as String:
                Let conversion_text be get_value(command.conversion_results, mode_name)
                Add ("   " joined with mode_name joined with ": " joined with conversion_text) to output_lines
        Add "" to output_lines
    
    Note: Display performance metrics if available
    If size(command.execution_result.performance_metrics) > 0:
        Add "âš¡ Performance:" to output_lines
        Add ("   Parse time: " joined with command.parse_time as String joined with "Î¼s") to output_lines
        Add ("   Execution time: " joined with command.execution_time as String joined with "Î¼s") to output_lines
        Add ("   Conversion time: " joined with command.conversion_time as String joined with "Î¼s") to output_lines
        Add "" to output_lines
    
    Note: Display suggestions if available
    If size(command.suggestions) > 0:
        Add "ðŸ’¡ Suggestions:" to output_lines
        For Each suggestion in command.suggestions:
            Add ("   " joined with suggestion) to output_lines
        Add "" to output_lines
    
    Let final_output be join_with_newlines(output_lines)
    Print final_output
    Return final_output

Note: =============================================================================
Note: SPECIAL REPL COMMANDS
Note: =============================================================================

Process called "process_special_command" that takes session as REPLSession, command_text as String returns REPLExecutionResult:
    Note: Handle special REPL commands (starting with :)
    
    Let command_parts be split_string(command_text, " ")
    Let main_command be get_item(command_parts, 0)
    
    If main_command is equal to ":help":
        Return show_help_command(session, command_parts)
    
    If main_command is equal to ":mode":
        Return switch_mode_command(session, command_parts)
    
    If main_command is equal to ":convert":
        Return convert_command(session, command_parts)
    
    If main_command is equal to ":history":
        Return show_history_command(session, command_parts)
    
    If main_command is equal to ":clear":
        Return clear_session_command(session, command_parts)
    
    If main_command is equal to ":vars":
        Return show_variables_command(session, command_parts)
    
    If main_command is equal to ":performance":
        Return show_performance_command(session, command_parts)
    
    If main_command is equal to ":tutorial":
        Return start_tutorial_command(session, command_parts)
    
    If main_command is equal to ":marketplace":
        Return marketplace_command(session, command_parts)
    
    If main_command is equal to ":export":
        Return export_session_command(session, command_parts)
    
    If main_command is equal to ":preferences":
        Return preferences_command(session, command_parts)
    
    Return REPLExecutionResult with:
        success: false
        result_value: REPLValue with: value_type: "error", value_data: "Unknown command: " joined with main_command, display_format: empty dictionary, is_displayable: true, memory_usage: 0
        result_type: "error"
        output_text: "Unknown command. Type :help for available commands."
        side_effects: empty list
        performance_metrics: empty dictionary

Process called "show_help_command" that takes session as REPLSession, command_parts as List[String] returns REPLExecutionResult:
    Note: Display comprehensive help information
    
    Let help_text be empty List[String]
    Add "ðŸš€ Triple Syntax REPL Help" to help_text
    Add "=========================" to help_text
    Add "" to help_text
    
    Add "SYNTAX MODES:" to help_text
    Add "  Viewer Mode    - Natural language syntax (human-readable)" to help_text
    Add "  Canonical Mode - Standard Runa syntax (default)" to help_text
    Add "  Technical Mode - Concise developer syntax" to help_text
    Add "" to help_text
    
    Add "SPECIAL COMMANDS:" to help_text
    Add "  :help                    - Show this help" to help_text
    Add "  :mode <viewer|canonical|technical> - Switch syntax mode" to help_text
    Add "  :convert <text>          - Convert text to all syntax modes" to help_text
    Add "  :history [n]             - Show command history (last n commands)" to help_text
    Add "  :clear                   - Clear session history and variables" to help_text
    Add "  :vars                    - Show active variables" to help_text
    Add "  :performance             - Show performance statistics" to help_text
    Add "  :tutorial                - Start interactive tutorial" to help_text
    Add "  :marketplace <search>    - Search community patterns" to help_text
    Add "  :export <format>         - Export session (json, markdown)" to help_text
    Add "  :preferences             - Show/modify REPL preferences" to help_text
    Add "" to help_text
    
    Add "EXAMPLES:" to help_text
    Add "  Viewer: Let the result be 5 plus 3" to help_text
    Add "  Canonical: Let result be 5 plus 3" to help_text
    Add "  Technical: result = 5 + 3" to help_text
    Add "" to help_text
    
    Add "Current Mode: " joined with session.current_syntax_mode as String to help_text
    
    Return REPLExecutionResult with:
        success: true
        result_value: REPLValue with: value_type: "help", value_data: "help_displayed", display_format: empty dictionary, is_displayable: false, memory_usage: 0
        result_type: "help"
        output_text: join_with_newlines(help_text)
        side_effects: empty list
        performance_metrics: empty dictionary

Process called "switch_mode_command" that takes session as REPLSession, command_parts as List[String] returns REPLExecutionResult:
    Note: Handle :mode command for switching syntax modes
    
    If size(command_parts) < 2:
        Return REPLExecutionResult with:
            success: false
            result_value: REPLValue with: value_type: "error", value_data: "Missing mode argument", display_format: empty dictionary, is_displayable: true, memory_usage: 0
            result_type: "error"
            output_text: "Usage: :mode <viewer|canonical|technical>\nCurrent mode: " joined with session.current_syntax_mode as String
            side_effects: empty list
            performance_metrics: empty dictionary
    
    Let mode_name be get_item(command_parts, 1)
    Let target_mode be parse_syntax_mode(mode_name)
    
    If target_mode is equal to session.current_syntax_mode:
        Return REPLExecutionResult with:
            success: true
            result_value: REPLValue with: value_type: "info", value_data: "Already in " joined with mode_name joined with " mode", display_format: empty dictionary, is_displayable: true, memory_usage: 0
            result_type: "info"
            output_text: "Already in " joined with mode_name joined with " mode."
            side_effects: empty list
            performance_metrics: empty dictionary
    
    Let switch_result be switch_syntax_mode(session, target_mode)
    
    Return REPLExecutionResult with:
        success: parse_as_boolean(get_value(switch_result, "success"))
        result_value: REPLValue with: value_type: "mode_switch", value_data: get_value(switch_result, "new_mode"), display_format: empty dictionary, is_displayable: true, memory_usage: 0
        result_type: "mode_switch"
        output_text: "Switched to " joined with get_value(switch_result, "new_mode") joined with " mode"
        side_effects: List with: "mode_changed"
        performance_metrics: empty dictionary

Note: =============================================================================
Note: INTERACTIVE TUTORIAL SYSTEM
Note: =============================================================================

Process called "start_tutorial_mode" that takes session as REPLSession returns Dictionary[String, String]:
    Note: Initialize interactive tutorial for learning Triple Syntax
    
    Set session.tutorial_mode to true
    Set session.current_tutorial_step to 0
    
    Let tutorial_intro be empty List[String]
    Add "ðŸŽ“ Welcome to the Triple Syntax Tutorial!" to tutorial_intro
    Add "=======================================" to tutorial_intro
    Add "" to tutorial_intro
    Add "This interactive tutorial will teach you how to use Runa's revolutionary" to tutorial_intro
    Add "Triple Syntax Architecture. You'll learn to:" to tutorial_intro
    Add "" to tutorial_intro
    Add "1. Write code in natural Viewer mode" to tutorial_intro
    Add "2. Use standard Canonical Runa syntax" to tutorial_intro
    Add "3. Work with concise Technical mode" to tutorial_intro
    Add "4. Switch seamlessly between all modes" to tutorial_intro
    Add "5. Understand when to use each mode" to tutorial_intro
    Add "" to tutorial_intro
    Add "ðŸš€ Let's start with Viewer mode - the most natural way to write code!" to tutorial_intro
    Add "" to tutorial_intro
    Add "Try typing: Let the result be 10 plus 5" to tutorial_intro
    Add "(Type ':tutorial next' to skip ahead or ':tutorial stop' to exit)" to tutorial_intro
    
    Print join_with_newlines(tutorial_intro)
    
    Return Dictionary with:
        "tutorial_started": "true"
        "current_step": "0"
        "mode": "viewer_introduction"

Process called "advance_tutorial_step" that takes session as REPLSession, user_input as String returns Dictionary[String, String]:
    Note: Advance tutorial based on user input and current step
    
    Set session.current_tutorial_step to session.current_tutorial_step plus 1
    
    If session.current_tutorial_step is equal to 1:
        Return show_tutorial_step_canonical_introduction(session)
    Otherwise if session.current_tutorial_step is equal to 2:
        Return show_tutorial_step_technical_introduction(session)
    Otherwise if session.current_tutorial_step is equal to 3:
        Return show_tutorial_step_mode_switching(session)
    Otherwise if session.current_tutorial_step is equal to 4:
        Return show_tutorial_step_pattern_domains(session)
    Otherwise if session.current_tutorial_step is equal to 5:
        Return show_tutorial_step_macros_and_templates(session)
    Otherwise:
        Return complete_tutorial(session)

Process called "show_tutorial_step_canonical_introduction" that takes session as REPLSession returns Dictionary[String, String]:
    Note: Tutorial step introducing Canonical mode
    
    Let step_content be empty List[String]
    Add "âœ… Great! You've mastered Viewer mode basics." to step_content
    Add "" to step_content
    Add "ðŸŽ¯ Now let's learn Canonical mode - Runa's standard syntax." to step_content
    Add "Canonical mode is more concise while staying readable." to step_content
    Add "" to step_content
    Add "Switch to canonical mode by typing: :mode canonical" to step_content
    Add "Then try: Let result be 10 plus 5" to step_content
    Add "" to step_content
    Add "Notice how it's similar but more streamlined!" to step_content
    
    Print join_with_newlines(step_content)
    
    Return Dictionary with:
        "step": "1"
        "mode": "canonical_introduction"
        "instruction": "Switch to canonical mode and try basic arithmetic"

Note: =============================================================================
Note: PERFORMANCE MONITORING AND ANALYTICS
Note: =============================================================================

Process called "record_command_performance_metrics" that takes session as REPLSession, command as REPLCommand returns Boolean:
    Note: Record detailed performance metrics for command execution
    
    Note: Create execution metric for overall command performance
    Let overall_metric be ExecutionMetric with:
        metric_name: "total_execution_time"
        metric_value: (command.parse_time plus command.execution_time plus command.conversion_time) as Float
        syntax_mode: command.input_syntax_mode
        timestamp: command.timestamp
        context: "command_id:" joined with command.command_id
    
    Add overall_metric to session.execution_metrics
    
    Note: Record parse performance
    Let parse_metric be ExecutionMetric with:
        metric_name: "parse_time"
        metric_value: command.parse_time as Float
        syntax_mode: command.input_syntax_mode
        timestamp: command.timestamp
        context: "parse_success:" joined with command.parsed_successfully as String
    
    Add parse_metric to session.execution_metrics
    
    Note: Record execution performance if successful
    If command.execution_result.success:
        Let exec_metric be ExecutionMetric with:
            metric_name: "execution_time"
            metric_value: command.execution_time as Float
            syntax_mode: command.input_syntax_mode
            timestamp: command.timestamp
            context: "result_type:" joined with command.execution_result.result_type
        
        Add exec_metric to session.execution_metrics
    
    Note: Record conversion performance
    If command.conversion_time > 0:
        Let conversion_metric be ExecutionMetric with:
            metric_name: "conversion_time"
            metric_value: command.conversion_time as Float
            syntax_mode: command.input_syntax_mode
            timestamp: command.timestamp
            context: "conversions_count:" joined with size(command.conversion_results) as String
        
        Add conversion_metric to session.execution_metrics
    
    Note: Trim metrics history if it gets too large
    If size(session.execution_metrics) > 1000:
        Set session.execution_metrics to get_last_n_items(session.execution_metrics, 500)
    
    Return true

Process called "generate_performance_report" that takes session as REPLSession, time_window as String returns String:
    Note: Generate comprehensive performance report for the REPL session
    
    Let report_lines be empty List[String]
    Add "âš¡ Triple Syntax REPL Performance Report" to report_lines
    Add "=========================================" to report_lines
    Add ("Session ID: " joined with session.session_id) to report_lines
    Add ("Report Time: " joined with format_timestamp(get_current_timestamp())) to report_lines
    Add ("Time Window: " joined with time_window) to report_lines
    Add "" to report_lines
    
    Note: Overall session statistics
    Add "SESSION STATISTICS:" to report_lines
    Add ("Commands Executed: " joined with size(session.session_history) as String) to report_lines
    Add ("Session Duration: " joined with calculate_session_duration(session) as String joined with " minutes") to report_lines
    Add "" to report_lines
    
    Note: Syntax mode usage breakdown
    Add "SYNTAX MODE USAGE:" to report_lines
    Let total_usage be get_value(session.syntax_usage_stats, "viewer") plus get_value(session.syntax_usage_stats, "canonical") plus get_value(session.syntax_usage_stats, "technical")
    
    For Each mode in get_keys(session.syntax_usage_stats):
        Let usage_count be get_value(session.syntax_usage_stats, mode)
        Let usage_percentage be (usage_count as Float divided by total_usage as Float) multiplied by 100.0
        Add ("  " joined with mode joined with ": " joined with usage_count as String joined with " (" joined with format_percentage(usage_percentage) joined with ")") to report_lines
    Add "" to report_lines
    
    Note: Performance metrics by syntax mode
    Add "PERFORMANCE BY SYNTAX MODE:" to report_lines
    Let performance_by_mode be calculate_performance_by_syntax_mode(session)
    
    For Each mode in get_keys(performance_by_mode):
        Let mode_stats be get_value(performance_by_mode, mode)
        Add ("  " joined with mode joined with ":") to report_lines
        Add ("    Avg Parse Time: " joined with get_value(mode_stats, "avg_parse_time") joined with "Î¼s") to report_lines
        Add ("    Avg Execution Time: " joined with get_value(mode_stats, "avg_execution_time") joined with "Î¼s") to report_lines
        Add ("    Success Rate: " joined with get_value(mode_stats, "success_rate")) to report_lines
    Add "" to report_lines
    
    Note: Recent trends
    Add "RECENT PERFORMANCE TRENDS:" to report_lines
    Let trend_analysis be analyze_performance_trends(session)
    For Each trend in get_keys(trend_analysis):
        Add ("  " joined with trend joined with ": " joined with get_value(trend_analysis, trend)) to report_lines
    
    Return join_with_newlines(report_lines)

Note: =============================================================================
Note: SESSION EXPORT AND SHARING
Note: =============================================================================

Process called "export_session_data" that takes session as REPLSession, export_format as String, options as Dictionary[String, String] returns String:
    Note: Export REPL session data in various formats for sharing and analysis
    
    If export_format is equal to "json":
        Return export_session_as_json(session, options)
    Otherwise if export_format is equal to "markdown":
        Return export_session_as_markdown(session, options)
    Otherwise if export_format is equal to "ide_snippets":
        Return export_session_as_ide_snippets(session, options)
    Otherwise if export_format is equal to "performance_csv":
        Return export_performance_data_as_csv(session, options)
    Otherwise:
        Return "ERROR: Unsupported export format: " joined with export_format

Process called "export_session_as_markdown" that takes session as REPLSession, options as Dictionary[String, String] returns String:
    Note: Export session as markdown document for sharing and documentation
    
    Let markdown_lines be empty List[String]
    Add "# Triple Syntax REPL Session" to markdown_lines
    Add "" to markdown_lines
    Add ("**Session ID:** " joined with session.session_id) to markdown_lines
    Add ("**Export Date:** " joined with format_timestamp(get_current_timestamp())) to markdown_lines
    Add ("**Commands Executed:** " joined with size(session.session_history) as String) to markdown_lines
    Add "" to markdown_lines
    
    Note: Add syntax mode statistics
    Add "## Syntax Mode Usage" to markdown_lines
    Add "" to markdown_lines
    For Each mode in get_keys(session.syntax_usage_stats):
        Let usage_count be get_value(session.syntax_usage_stats, mode)
        Add ("- **" joined with mode joined with ":** " joined with usage_count as String joined with " commands") to markdown_lines
    Add "" to markdown_lines
    
    Note: Add command history
    Add "## Command History" to markdown_lines
    Add "" to markdown_lines
    
    Let command_count be 0
    For Each command in session.session_history:
        Set command_count to command_count plus 1
        Add ("### Command " joined with command_count as String joined with " (" joined with command.input_syntax_mode as String joined with " mode)") to markdown_lines
        Add "" to markdown_lines
        Add "```runa" to markdown_lines
        Add command.input_text to markdown_lines
        Add "```" to markdown_lines
        Add "" to markdown_lines
        
        If command.execution_result.success and command.execution_result.output_text is not equal to "":
            Add "**Output:**" to markdown_lines
            Add "```" to markdown_lines
            Add command.execution_result.output_text to markdown_lines
            Add "```" to markdown_lines
            Add "" to markdown_lines
        
        Note: Add conversions if available
        If size(command.conversion_results) > 0:
            Add "**Syntax Conversions:**" to markdown_lines
            For Each mode_name in get_keys(command.conversion_results):
                If mode_name is not equal to command.input_syntax_mode as String:
                    Add ("- **" joined with mode_name joined with ":** `" joined with get_value(command.conversion_results, mode_name) joined with "`") to markdown_lines
            Add "" to markdown_lines
        
        Add "---" to markdown_lines
        Add "" to markdown_lines
    
    Note: Add performance summary if requested
    If get_value_or_default(options, "include_performance", "false") is equal to "true":
        Add "## Performance Summary" to markdown_lines
        Add "" to markdown_lines
        Let performance_summary be generate_performance_summary_markdown(session)
        Add performance_summary to markdown_lines
    
    Return join_with_newlines(markdown_lines)