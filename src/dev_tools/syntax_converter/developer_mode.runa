Note:
Runa Developer Mode Syntax Converter

Converts natural language Runa syntax to technical dot notation and symbols.
This tool transforms verbose, readable code into concise, performance-optimized syntax
preferred by experienced developers.

Features:
- Natural language → dot notation conversion
- Verbose method calls → operator symbols  
- Function chains → fluent interfaces
- Type annotations → concise forms
- Loop constructs → functional equivalents
- Error handling → shorthand syntax
:End Note

Import "../compiler/semantic/semantic_analyzer" as SemanticAnalyzer
Import "../compiler/lexer/enhanced_lexer" as Lexer
Import "../compiler/parser/enhanced_parser" as Parser
Import "utilities/common" as Common

Note: Core transformation engine for developer mode
Type called "DeveloperModeConverter":
    source_code as String
    ast as ASTNode
    transformation_rules as Dictionary[String, TransformationRule]
    optimization_level as String
    preserve_comments as Boolean
    metadata as Dictionary[String, Any]

Type called "TransformationRule":
    pattern as String
    replacement as String
    condition as Optional[String]
    priority as Integer
    category as String

Type called "SyntaxTransformation":
    original_text as String
    transformed_text as String
    transformation_type as String
    line_number as Integer
    confidence as Float

Note: Main conversion process
Process called "convert_to_developer_syntax" that takes source_code as String and options as Dictionary[String, Any] returns String:
    Note: Convert natural language Runa to technical syntax
    Try:
        Let converter be create_developer_converter with source as source_code and options as options
        Let ast be parse_source_code with converter as converter
        Let transformed_ast be apply_developer_transformations with converter as converter and ast as ast
        Let result_code be generate_technical_code with ast as transformed_ast and options as options
        Return result_code
    Catch parse_error:
        Return "Error: Could not parse source code - " plus parse_error.message
    Catch transform_error:
        Return "Error: Transformation failed - " plus transform_error.message

Process called "create_developer_converter" that takes source as String and options as Dictionary[String, Any] returns DeveloperModeConverter:
    Let rules be load_transformation_rules()
    Return DeveloperModeConverter with:
        source_code as source
        ast as Optional.None
        transformation_rules as rules
        optimization_level as options.get("optimization", "standard")
        preserve_comments as options.get("preserve_comments", true)
        metadata as dictionary containing

Process called "load_transformation_rules" returns Dictionary[String, TransformationRule]:
    Note: Define transformation rules for natural → technical syntax
    Let rules be dictionary containing
    
    Note: Method call transformations
    Set rules["length_of"] to TransformationRule with:
        pattern as "length of (.+)"
        replacement as "$1.length"
        condition as None
        priority as 100
        category as "method_calls"
    
    Set rules["add_to"] to TransformationRule with:
        pattern as "Add (.+) to (.+)"
        replacement as "$2.add($1)"
        condition as None
        priority as 100
        category as "method_calls"
    
    Set rules["remove_from"] to TransformationRule with:
        pattern as "Remove (.+) from (.+)"
        replacement as "$2.remove($1)"
        condition as None
        priority as 100
        category as "method_calls"
    
    Set rules["contains_check"] to TransformationRule with:
        pattern as "(.+) contains (.+)"
        replacement as "$1.contains($2)"
        condition as None
        priority as 90
        category as "method_calls"
    
    Note: Collection operations
    Set rules["for_each_in"] to TransformationRule with:
        pattern as "For each (.+) in (.+):"
        replacement as "$2.forEach(($1) => {"
        condition as None
        priority as 95
        category as "loops"
    
    Set rules["filter_where"] to TransformationRule with:
        pattern as "filter (.+) where (.+)"
        replacement as "$1.filter($2)"
        condition as None
        priority as 90
        category as "functional"
    
    Set rules["map_to"] to TransformationRule with:
        pattern as "map (.+) to (.+)"
        replacement as "$1.map($2)"
        condition as None
        priority as 90
        category as "functional"
    
    Note: Arithmetic operations
    Set rules["plus_operator"] to TransformationRule with:
        pattern as "(.+) plus (.+)"
        replacement as "$1 + $2"
        condition as None
        priority as 80
        category as "arithmetic"
    
    Set rules["minus_operator"] to TransformationRule with:
        pattern as "(.+) minus (.+)"
        replacement as "$1 - $2"
        condition as None
        priority as 80
        category as "arithmetic"
    
    Set rules["multiplied_by"] to TransformationRule with:
        pattern as "(.+) multiplied by (.+)"
        replacement as "$1 * $2"
        condition as None
        priority as 80
        category as "arithmetic"
    
    Set rules["divided_by"] to TransformationRule with:
        pattern as "(.+) divided by (.+)"
        replacement as "$1 / $2"
        condition as None
        priority as 80
        category as "arithmetic"
    
    Note: Comparison operations
    Set rules["is_equal_to"] to TransformationRule with:
        pattern as "(.+) is equal to (.+)"
        replacement as "$1 = $2"
        condition as None
        priority as 85
        category as "comparison"
    
    Set rules["is_greater_than"] to TransformationRule with:
        pattern as "(.+) is greater than (.+)"
        replacement as "$1 > $2"
        condition as None
        priority as 85
        category as "comparison"
    
    Set rules["is_less_than"] to TransformationRule with:
        pattern as "(.+) is less than (.+)"
        replacement as "$1 < $2"
        condition as None
        priority as 85
        category as "comparison"
    
    Set rules["is_less_than_or_equal_to"] to TransformationRule with:
        pattern as "(.+) is less than or equal to (.+)"
        replacement as "$1 <= $2"
        condition as None
        priority as 90
        category as "comparison"
    
    Set rules["is_greater_than_or_equal_to"] to TransformationRule with:
        pattern as "(.+) is greater than or equal to (.+)"
        replacement as "$1 >= $2"
        condition as None
        priority as 90
        category as "comparison"
    
    Note: Boolean operations
    Set rules["and_operator"] to TransformationRule with:
        pattern as "(.+) and (.+)"
        replacement as "$1 && $2"
        condition as None
        priority as 75
        category as "boolean"
    
    Set rules["or_operator"] to TransformationRule with:
        pattern as "(.+) or (.+)"
        replacement as "$1 || $2"
        condition as None
        priority as 75
        category as "boolean"
    
    Set rules["not_operator"] to TransformationRule with:
        pattern as "not (.+)"
        replacement as "!$1"
        condition as None
        priority as 85
        category as "boolean"
    
    Note: String operations  
    Set rules["joined_with"] to TransformationRule with:
        pattern as "(.+) joined with (.+)"
        replacement as "concat($1, $2)"
        condition as None
        priority as 85
        category as "string_operations"
    
    Note: Variable declarations (bare assignment - no keywords)
    Set rules["let_declaration"] to TransformationRule with:
        pattern as "Let (.+) be (.+)"
        replacement as "$1 = $2"
        condition as None
        priority as 100
        category as "declarations"
    
    Note: Constructor transformations (bare assignment style)
    Set rules["a_value_of_type_constructor"] to TransformationRule with:
        pattern as "Let (.+) be a value of type (.+)"
        replacement as "$1 = new $2()"
        condition as None
        priority as 105
        category as "constructors"
    
    Set rules["of_type_constructor"] to TransformationRule with:
        pattern as "Let (.+) be of type (.+)"
        replacement as "$1 = new $2()"
        condition as None
        priority as 105
        category as "constructors"
    
    Set rules["constructor_with_fields"] to TransformationRule with:
        pattern as "(.+) with (.+) End (.+)"
        replacement as "new $3({ $2 })"
        condition as None
        priority as 104
        category as "constructors"
    
    Set rules["set_assignment"] to TransformationRule with:
        pattern as "Set (.+) to (.+)"
        replacement as "$1 = $2"
        condition as None
        priority as 100
        category as "assignments"
    
    Note: Function calls with 'with' syntax
    Set rules["function_with_params"] to TransformationRule with:
        pattern as "(.+) with (.+) as (.+)"
        replacement as "$1($3: $2)"
        condition as None
        priority as 95
        category as "function_calls"
    
    Note: Type annotations
    Set rules["as_type"] to TransformationRule with:
        pattern as "(.+) as (.+)"
        replacement as "$1: $2"
        condition as None
        priority as 70
        category as "types"
    
    Note: Mathematical symbols (escape sequences to Unicode)
    Set rules["alpha_symbol"] to TransformationRule with:
        pattern as "\\\\alpha"
        replacement as "α"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["beta_symbol"] to TransformationRule with:
        pattern as "\\\\beta"
        replacement as "β"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["gamma_symbol"] to TransformationRule with:
        pattern as "\\\\gamma"
        replacement as "γ"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["delta_symbol"] to TransformationRule with:
        pattern as "\\\\delta"
        replacement as "δ"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["theta_symbol"] to TransformationRule with:
        pattern as "\\\\theta"
        replacement as "θ"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["lambda_symbol"] to TransformationRule with:
        pattern as "\\\\lambda"
        replacement as "λ"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["pi_symbol"] to TransformationRule with:
        pattern as "\\\\pi"
        replacement as "π"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["sigma_symbol"] to TransformationRule with:
        pattern as "\\\\sigma"
        replacement as "σ"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["phi_symbol"] to TransformationRule with:
        pattern as "\\\\phi"
        replacement as "φ"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["omega_symbol"] to TransformationRule with:
        pattern as "\\\\omega"
        replacement as "ω"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["sum_symbol"] to TransformationRule with:
        pattern as "\\\\sum"
        replacement as "∑"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["prod_symbol"] to TransformationRule with:
        pattern as "\\\\prod"
        replacement as "∏"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["integral_symbol"] to TransformationRule with:
        pattern as "\\\\int"
        replacement as "∫"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["infinity_symbol"] to TransformationRule with:
        pattern as "\\\\infty"
        replacement as "∞"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["in_symbol"] to TransformationRule with:
        pattern as "\\\\in"
        replacement as "∈"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["forall_symbol"] to TransformationRule with:
        pattern as "\\\\forall"
        replacement as "∀"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Set rules["exists_symbol"] to TransformationRule with:
        pattern as "\\\\exists"
        replacement as "∃"
        condition as None
        priority as 110
        category as "math_symbols"
    
    Return rules

Process called "parse_source_code" that takes converter as DeveloperModeConverter returns ASTNode:
    Note: Parse source code into AST for transformation
    Try:
        Let lexer be Lexer.create_lexer with source as converter.source_code
        Let tokens be Lexer.tokenize with lexer as lexer
        Let parser be Parser.create_parser with tokens as tokens
        Let ast be Parser.parse with parser as parser
        Set converter.ast to ast
        Return ast
    Catch error:
        Throw ParseError with message as "Failed to parse source: " plus error.message

Process called "apply_developer_transformations" that takes converter as DeveloperModeConverter and ast as ASTNode returns ASTNode:
    Note: Apply all transformation rules to convert natural syntax to technical
    Let transformed_ast be deep_copy_ast with ast as ast
    
    Note: Apply transformations by priority (highest first)
    Let sorted_rules be sort_rules_by_priority with rules as converter.transformation_rules
    
    For each rule_name, rule in sorted_rules:
        Set transformed_ast to apply_single_transformation with ast as transformed_ast and rule as rule
    
    Note: Post-process for optimization
    Set transformed_ast to optimize_technical_syntax with ast as transformed_ast and level as converter.optimization_level
    
    Return transformed_ast

Process called "sort_rules_by_priority" that takes rules as Dictionary[String, TransformationRule] returns List[Tuple[String, TransformationRule]]:
    Let rule_list be list containing
    For each name, rule in rules:
        Add tuple with name and rule to rule_list
    
    Note: Sort by priority (descending)
    Let sorted_list be list containing
    For each item in rule_list:
        Let inserted be false
        For i from 0 to length of sorted_list:
            If item[1].priority is greater than sorted_list[i][1].priority:
                Insert item at position i in sorted_list
                Set inserted to true
                Break
        If not inserted:
            Add item to sorted_list
    
    Return sorted_list

Process called "apply_single_transformation" that takes ast as ASTNode and rule as TransformationRule returns ASTNode:
    Note: Apply a single transformation rule to the AST
    Try:
        Let pattern_matcher be create_pattern_matcher with pattern as rule.pattern
        Let matches be find_pattern_matches with ast as ast and matcher as pattern_matcher
        
        For each match in matches:
            If rule.condition is None or evaluate_condition with condition as rule.condition and match as match:
                Replace match in ast with rule.replacement
        
        Return ast
    Catch error:
        Note: Log transformation error but continue
        Return ast

Process called "create_pattern_matcher" that takes pattern as String returns PatternMatcher:
    Note: Create pattern matcher for AST node matching
    Return PatternMatcher with:
        pattern as pattern
        compiled_regex as compile_regex with pattern as pattern
        capture_groups as extract_capture_groups with pattern as pattern

Process called "find_pattern_matches" that takes ast as ASTNode and matcher as PatternMatcher returns List[ASTMatch]:
    Note: Find all nodes in AST that match the pattern
    Let matches be list containing
    Call traverse_ast_for_matches with ast as ast and matcher as matcher and matches as matches
    Return matches

Process called "traverse_ast_for_matches" that takes ast as ASTNode and matcher as PatternMatcher and matches as List[ASTMatch] returns None:
    Note: Recursively traverse AST to find pattern matches
    If ast.node_type is equal to "Identifier" or ast.node_type is equal to "Expression":
        Let text_representation be get_node_text with node as ast
        If matcher.compiled_regex.matches with text as text_representation:
            Let match be ASTMatch with:
                node as ast
                text as text_representation
                captures as matcher.compiled_regex.capture_groups with text as text_representation
            Add match to matches
    
    For each child in ast.children:
        Call traverse_ast_for_matches with ast as child and matcher as matcher and matches as matches

Process called "optimize_technical_syntax" that takes ast as ASTNode and level as String returns ASTNode:
    Note: Apply optimization-specific transformations
    Match level:
        When "minimal":
            Return apply_minimal_optimizations with ast as ast
        When "standard":
            Return apply_standard_optimizations with ast as ast
        When "aggressive":
            Return apply_aggressive_optimizations with ast as ast
        Otherwise:
            Return ast

Process called "apply_minimal_optimizations" that takes ast as ASTNode returns ASTNode:
    Note: Basic optimizations - remove unnecessary verbosity
    Let optimized_ast be ast
    
    Note: Convert simple chains to dot notation
    Set optimized_ast to convert_simple_chains with ast as optimized_ast
    
    Return optimized_ast

Process called "apply_standard_optimizations" that takes ast as ASTNode returns ASTNode:
    Note: Standard optimizations - balance readability and conciseness
    Let optimized_ast be apply_minimal_optimizations with ast as ast
    
    Note: Convert method chains to fluent interfaces
    Set optimized_ast to convert_method_chains with ast as optimized_ast
    
    Note: Optimize boolean expressions
    Set optimized_ast to optimize_boolean_expressions with ast as optimized_ast
    
    Return optimized_ast

Process called "apply_aggressive_optimizations" that takes ast as ASTNode returns ASTNode:
    Note: Aggressive optimizations - prioritize conciseness
    Let optimized_ast be apply_standard_optimizations with ast as ast
    
    Note: Convert loops to functional forms where possible
    Set optimized_ast to convert_loops_to_functional with ast as optimized_ast
    
    Note: Inline simple variables
    Set optimized_ast to inline_simple_variables with ast as optimized_ast
    
    Return optimized_ast

Process called "generate_technical_code" that takes ast as ASTNode and options as Dictionary[String, Any] returns String:
    Note: Generate technical syntax code from transformed AST
    Let code_generator be create_technical_generator with options as options
    Let generated_code be generate_code_from_ast with generator as code_generator and ast as ast
    Return generated_code

Process called "create_technical_generator" that takes options as Dictionary[String, Any] returns CodeGenerator:
    Return CodeGenerator with:
        style as "technical"
        indent_size as options.get("indent_size", 2)
        use_semicolons as options.get("use_semicolons", false)
        prefer_symbols as options.get("prefer_symbols", true)
        compress_whitespace as options.get("compress_whitespace", false)

Note: Supporting types and utility functions
Type called "PatternMatcher":
    pattern as String
    compiled_regex as Regex
    capture_groups as List[String]

Type called "ASTMatch":
    node as ASTNode
    text as String
    captures as List[String]

Type called "CodeGenerator":
    style as String
    indent_size as Integer
    use_semicolons as Boolean
    prefer_symbols as Boolean
    compress_whitespace as Boolean

Note: Helper functions for AST manipulation
Process called "deep_copy_ast" that takes ast as ASTNode returns ASTNode:
    Note: Create deep copy of AST for safe transformation
    Return ASTNode with:
        node_type as ast.node_type
        value as ast.value
        children as copy_children_list with children as ast.children
        position as copy_position with position as ast.position
        annotations as Common.copy_list with list as ast.annotations
        metadata as Common.copy_dictionary with dict as ast.metadata

Process called "copy_children_list" that takes children as List[ASTNode] returns List[ASTNode]:
    Let copied_children be list containing
    For each child in children:
        Add deep_copy_ast with ast as child to copied_children
    Return copied_children

Process called "copy_position" that takes position as Position returns Position:
    Return Position with:
        line as position.line
        column as position.column
        offset as position.offset
        metadata as Common.copy_dictionary with dict as position.metadata

Process called "get_node_text" that takes node as ASTNode returns String:
    Note: Extract text representation of AST node
    Match node.node_type:
        When "Identifier":
            Return node.value as String
        When "Literal":
            Return node.value as String
        When "Expression":
            Return reconstruct_expression_text with node as node
        Otherwise:
            Return ""

Process called "reconstruct_expression_text" that takes node as ASTNode returns String:
    Note: Reconstruct text from expression AST node
    Let text_parts be list containing
    For each child in node.children:
        Add get_node_text with node as child to text_parts
    Return join_strings with strings as text_parts and separator as " "

Process called "join_strings" that takes strings as List[String] and separator as String returns String:
    If length of strings is equal to 0:
        Return ""
    
    Let result be strings[0]
    For i from 1 to length of strings minus 1:
        Set result to result plus separator plus strings[i]
    Return result

Process called "compile_regex" that takes pattern as String returns Regex:
    Note: Compile pattern into regex for matching
    Try:
        Return Regex.compile with pattern as convert_to_regex_pattern with pattern as pattern
    Catch error:
        Return Regex.compile with pattern as escape_regex_pattern with pattern as pattern

Process called "convert_to_regex_pattern" that takes pattern as String returns String:
    Note: Convert transformation pattern to regex pattern
    Let regex_pattern be pattern
    
    Note: Replace (.+) with named capture groups
    Set regex_pattern to replace_all with text as regex_pattern and search as "(.+)" and replacement as "(.+?)"
    
    Note: Escape special regex characters
    Set regex_pattern to escape_special_chars with text as regex_pattern
    
    Return regex_pattern

Process called "escape_regex_pattern" that takes pattern as String returns String:
    Note: Escape pattern for literal matching
    Let escaped be ""
    For each char in pattern:
        If char is equal to "." or char is equal to "*" or char is equal to "+" or char is equal to "?" or char is equal to "(" or char is equal to ")":
            Set escaped to escaped plus "\\" plus char
        Otherwise:
            Set escaped to escaped plus char
    Return escaped

Process called "extract_capture_groups" that takes pattern as String returns List[String]:
    Note: Extract capture group names from pattern
    Let groups be list containing
    Let in_group be false
    Let current_group be ""
    
    For each char in pattern:
        If char is equal to "(":
            Set in_group to true
            Set current_group to ""
        Else if char is equal to ")":
            If in_group:
                Add current_group to groups
                Set in_group to false
        Else if in_group:
            Set current_group to current_group plus char
    
    Return groups

Note: Advanced transformation functions
Process called "convert_simple_chains" that takes ast as ASTNode returns ASTNode:
    Note: Convert simple method chains to dot notation
    If ast.node_type is equal to "MethodCall":
        Let optimized_chain be optimize_method_call_chain with call as ast
        Return optimized_chain
    
    For each child in ast.children:
        Set child to convert_simple_chains with ast as child
    
    Return ast

Process called "convert_method_chains" that takes ast as ASTNode returns ASTNode:
    Note: Convert complex method chains to fluent interfaces
    Return fluent_interface_transform with ast as ast

Process called "optimize_boolean_expressions" that takes ast as ASTNode returns ASTNode:
    Note: Optimize boolean expressions for conciseness
    Return boolean_optimization_transform with ast as ast

Process called "convert_loops_to_functional" that takes ast as ASTNode returns ASTNode:
    Note: Convert appropriate loops to functional forms
    Return functional_loop_transform with ast as ast

Process called "inline_simple_variables" that takes ast as ASTNode returns ASTNode:
    Note: Inline simple variable assignments where beneficial
    Return variable_inlining_transform with ast as ast

Note: Code generation functions
Process called "generate_code_from_ast" that takes generator as CodeGenerator and ast as ASTNode returns String:
    Note: Generate final technical syntax code
    Let code_builder be StringBuilder.create()
    Call generate_node_code with builder as code_builder and node as ast and generator as generator and indent as 0
    Return StringBuilder.toString with builder as code_builder

Process called "generate_node_code" that takes builder as StringBuilder and node as ASTNode and generator as CodeGenerator and indent as Integer returns None:
    Note: Generate code for a single AST node
    Match node.node_type:
        When "Program":
            Call generate_program_code with builder as builder and node as node and generator as generator and indent as indent
        When "Function":
            Call generate_function_code with builder as builder and node as node and generator as generator and indent as indent
        When "Expression":
            Call generate_expression_code with builder as builder and node as node and generator as generator
        When "Identifier":
            StringBuilder.append with builder as builder and text as node.value as String
        When "Literal":
            StringBuilder.append with builder as builder and text as format_literal with value as node.value and generator as generator
        Otherwise:
            StringBuilder.append with builder as builder and text as node.value as String

Process called "generate_program_code" that takes builder as StringBuilder and node as ASTNode and generator as CodeGenerator and indent as Integer returns None:
    For each child in node.children:
        Call generate_node_code with builder as builder and node as child and generator as generator and indent as indent
        StringBuilder.append with builder as builder and text as "\n"

Process called "generate_function_code" that takes builder as StringBuilder and node as ASTNode and generator as CodeGenerator and indent as Integer returns None:
    Note: Generate function in technical syntax
    Let indentation be create_indentation with size as indent and generator as generator
    StringBuilder.append with builder as builder and text as indentation
    StringBuilder.append with builder as builder and text as "function " 
    
    For each child in node.children:
        Call generate_node_code with builder as builder and node as child and generator as generator and indent as indent

Process called "generate_expression_code" that takes builder as StringBuilder and node as ASTNode and generator as CodeGenerator returns None:
    Note: Generate expression in technical form
    For i from 0 to length of node.children minus 1:
        Call generate_node_code with builder as builder and node as node.children[i] and generator as generator and indent as 0
        If i is less than length of node.children minus 1:
            StringBuilder.append with builder as builder and text as " "

Process called "format_literal" that takes value as Any and generator as CodeGenerator returns String:
    Note: Format literal values according to technical style
    If value is String:
        Return "\"" plus value as String plus "\""
    Otherwise:
        Return value as String

Process called "create_indentation" that takes size as Integer and generator as CodeGenerator returns String:
    Let indent_char be if generator.use_semicolons then "  " else "    "
    Let indentation be ""
    For i from 0 to size minus 1:
        Set indentation to indentation plus indent_char
    Return indentation

Note: Main CLI integration function
Process called "run_developer_mode" that takes source_file as String and output_file as Optional[String] and options as Dictionary[String, Any] returns Boolean:
    Note: Main entry point for developer mode conversion
    Try:
        Let source_code be read_file with path as source_file
        Let converted_code be convert_to_developer_syntax with source_code as source_code and options as options
        
        If output_file is not None:
            Call write_file with path as output_file and content as converted_code
            Display "Developer mode conversion complete: " plus output_file
        Otherwise:
            Display converted_code
        
        Return true
    Catch file_error:
        Display "Error reading file: " plus file_error.message
        Return false
    Catch conversion_error:
        Display "Error during conversion: " plus conversion_error.message
        Return false

Process called "read_file" that takes path as String returns String:
    Note: Read source file content
    Try:
        Import "io"
        Return io.read_text_file with path as path
    Catch error:
        Throw FileError with message as "Could not read file: " plus path

Process called "write_file" that takes path as String and content as String returns None:
    Note: Write converted code to file
    Try:
        Import "io"
        Call io.write_text_file with path as path and content as content
    Catch error:
        Throw FileError with message as "Could not write file: " plus path