Note:
Runa Viewer Mode Display Engine (READ-ONLY)

Converts canonical and technical Runa syntax to natural language display.
This is a READ-ONLY mode for viewing and comprehension - not for editing.
Viewer mode is designed for AI comprehension, stakeholder review, and documentation.

Triple Syntax Architecture:
- Viewer Mode: READ-ONLY natural language display (this file)
- Canonical Mode: Writeable standard Runa syntax (canonical_mode.runa)
- Developer Mode: Writeable technical syntax with symbols

Conversion Flow:
- FROM: Canonical or Developer modes (writeable)
- TO: Viewer mode (display only)
- EDITING: Convert viewer back to canonical/developer for modifications

Features:
- Natural language sentence display
- Symbol-free readable format
- Educational explanations
- Stakeholder-friendly output
:End Note

Import "../compiler/semantic/semantic_analyzer" as SemanticAnalyzer
Import "../compiler/lexer/enhanced_lexer" as Lexer
Import "../compiler/parser/enhanced_parser" as Parser
Import "utilities/common" as Common

Note: Core transformation engine for viewer mode
Type called "ViewerModeConverter":
    source_code as String
    ast as ASTNode
    transformation_rules as Dictionary[String, TransformationRule]
    verbosity_level as String
    preserve_technical_comments as Boolean
    metadata as Dictionary[String, Any]

Type called "TransformationRule":
    pattern as String
    replacement as String
    condition as Optional[String]
    priority as Integer
    category as String
    explanation as Optional[String]

Type called "SyntaxExpansion":
    original_text as String
    expanded_text as String
    expansion_type as String
    line_number as Integer
    explanation as String

Note: Main conversion process
Process called "convert_to_viewer_display" that takes source_code as String and options as Dictionary[String, Any] returns String:
    Note: Convert canonical/technical Runa syntax to READ-ONLY natural language display
    Try:
        Let converter be create_viewer_display_converter with source as source_code and options as options
        Let ast be parse_source_code with converter as converter
        Let display_ast be apply_display_transformations with ast as ast and converter as converter
        Let display_output be generate_natural_display with ast as display_ast and options as options
        Return add_readonly_header with content as display_output
    Catch parse_error:
        Return "Error: Could not parse source syntax - " plus parse_error.message
    Catch display_error:
        Return "Error: Display generation failed - " plus display_error.message

Process called "create_viewer_display_converter" that takes source as String and options as Dictionary[String, Any] returns ViewerModeConverter:
    Let rules be load_display_transformation_rules()
    Return ViewerModeConverter with:
        source_code as source
        ast as Optional.None
        transformation_rules as rules
        verbosity_level as options.get("verbosity", "educational")
        preserve_technical_comments as options.get("preserve_comments", true)
        metadata as dictionary containing:
            "mode" as "readonly_display"
            "purpose" as "comprehension"
            "editable" as false

Process called "load_display_transformation_rules" returns Dictionary[String, TransformationRule]:
    Note: Define transformation rules for canonical/technical → natural language display
    Let rules be dictionary containing
    
    Note: Method call expansions
    Set rules["dot_length"] to TransformationRule with:
        pattern as "(.+)\\.length"
        replacement as "length of $1"
        condition as None
        priority as 100
        category as "method_calls"
        explanation as Some("Convert dot notation length to natural language")
    
    Set rules["dot_add"] to TransformationRule with:
        pattern as "(.+)\\.add\\((.+)\\)"
        replacement as "Add $2 to $1"
        condition as None
        priority as 100
        category as "method_calls"
        explanation as Some("Convert method call to natural language action")
    
    Set rules["dot_remove"] to TransformationRule with:
        pattern as "(.+)\\.remove\\((.+)\\)"
        replacement as "Remove $2 from $1"
        condition as None
        priority as 100
        category as "method_calls"
        explanation as Some("Convert method call to natural language action")
    
    Set rules["dot_contains"] to TransformationRule with:
        pattern as "(.+)\\.contains\\((.+)\\)"
        replacement as "$1 contains $2"
        condition as None
        priority as 90
        category as "method_calls"
        explanation as Some("Convert contains check to natural language")
    
    Note: Collection operations
    Set rules["for_each_lambda"] to TransformationRule with:
        pattern as "(.+)\\.forEach\\(\\((.+)\\) => \\{"
        replacement as "For each $2 in $1:"
        condition as None
        priority as 95
        category as "loops"
        explanation as Some("Convert functional forEach to natural language loop")
    
    Set rules["filter_method"] to TransformationRule with:
        pattern as "(.+)\\.filter\\((.+)\\)"
        replacement as "filter $1 where $2"
        condition as None
        priority as 90
        category as "functional"
        explanation as Some("Convert filter method to natural language")
    
    Set rules["map_method"] to TransformationRule with:
        pattern as "(.+)\\.map\\((.+)\\)"
        replacement as "map $1 to $2"
        condition as None
        priority as 90
        category as "functional"
        explanation as Some("Convert map method to natural language")
    
    Note: Arithmetic operations
    Set rules["plus_symbol"] to TransformationRule with:
        pattern as "(.+) \\+ (.+)"
        replacement as "$1 plus $2"
        condition as None
        priority as 80
        category as "arithmetic"
        explanation as Some("Convert plus symbol to natural language")
    
    Set rules["minus_symbol"] to TransformationRule with:
        pattern as "(.+) - (.+)"
        replacement as "$1 minus $2"
        condition as None
        priority as 80
        category as "arithmetic"
        explanation as Some("Convert minus symbol to natural language")
    
    Set rules["multiply_symbol"] to TransformationRule with:
        pattern as "(.+) \\* (.+)"
        replacement as "$1 multiplied by $2"
        condition as None
        priority as 80
        category as "arithmetic"
        explanation as Some("Convert multiplication symbol to natural language")
    
    Set rules["divide_symbol"] to TransformationRule with:
        pattern as "(.+) / (.+)"
        replacement as "$1 divided by $2"
        condition as None
        priority as 80
        category as "arithmetic"
        explanation as Some("Convert division symbol to natural language")
    
    Note: Comparison operations
    Set rules["equals_symbol"] to TransformationRule with:
        pattern as "(.+) = (.+)"
        replacement as "$1 is equal to $2"
        condition as None
        priority as 85
        category as "comparison"
        explanation as Some("Convert equality symbol to natural language")
    
    Set rules["greater_than_symbol"] to TransformationRule with:
        pattern as "(.+) > (.+)"
        replacement as "$1 is greater than $2"
        condition as None
        priority as 85
        category as "comparison"
        explanation as Some("Convert greater than symbol to natural language")
    
    Set rules["less_than_symbol"] to TransformationRule with:
        pattern as "(.+) < (.+)"
        replacement as "$1 is less than $2"
        condition as None
        priority as 85
        category as "comparison"
        explanation as Some("Convert less than symbol to natural language")
    
    Set rules["greater_equal_symbol"] to TransformationRule with:
        pattern as "(.+) >= (.+)"
        replacement as "$1 is greater than or equal to $2"
        condition as None
        priority as 85
        category as "comparison"
        explanation as Some("Convert greater than or equal symbol to natural language")
    
    Set rules["less_equal_symbol"] to TransformationRule with:
        pattern as "(.+) <= (.+)"
        replacement as "$1 is less than or equal to $2"
        condition as None
        priority as 85
        category as "comparison"
        explanation as Some("Convert less than or equal symbol to natural language")
    
    Set rules["not_equals_symbol"] to TransformationRule with:
        pattern as "(.+) != (.+)"
        replacement as "$1 is not equal to $2"
        condition as None
        priority as 85
        category as "comparison"
        explanation as Some("Convert not equal symbol to natural language")
    
    Note: Boolean operations
    Set rules["and_symbol"] to TransformationRule with:
        pattern as "(.+) && (.+)"
        replacement as "$1 and $2"
        condition as None
        priority as 75
        category as "boolean"
        explanation as Some("Convert AND symbol to natural language")
    
    Set rules["or_symbol"] to TransformationRule with:
        pattern as "(.+) \\|\\| (.+)"
        replacement as "$1 or $2"
        condition as None
        priority as 75
        category as "boolean"
        explanation as Some("Convert OR symbol to natural language")
    
    Set rules["not_symbol"] to TransformationRule with:
        pattern as "!(.+)"
        replacement as "not $1"
        condition as None
        priority as 85
        category as "boolean"
        explanation as Some("Convert NOT symbol to natural language")
    
    Note: Variable declarations and assignments
    Set rules["let_assignment"] to TransformationRule with:
        pattern as "let (.+) = (.+)"
        replacement as "Let $1 be $2"
        condition as None
        priority as 100
        category as "declarations"
        explanation as Some("Convert let assignment to natural language")
    
    Set rules["variable_assignment"] to TransformationRule with:
        pattern as "(.+) = (.+)"
        replacement as "Set $1 to $2"
        condition as None
        priority as 100
        category as "assignments"
        explanation as Some("Convert assignment to natural language")
    
    Note: Function calls and parameters
    Set rules["function_call_simple"] to TransformationRule with:
        pattern as "(.+)\\((.+): (.+)\\)"
        replacement as "$1 with $3 as $2"
        condition as None
        priority as 95
        category as "function_calls"
        explanation as Some("Convert function call with parameters to natural language")
    
    Set rules["function_call_multiple"] to TransformationRule with:
        pattern as "(.+)\\((.+), (.+)\\)"
        replacement as "$1 with $2 and $3"
        condition as None
        priority as 90
        category as "function_calls"
        explanation as Some("Convert function call with multiple parameters")
    
    Note: String operations
    Set rules["concat_function"] to TransformationRule with:
        pattern as "concat\\((.+), (.+)\\)"
        replacement as "$1 joined with $2"
        condition as None
        priority as 85
        category as "string_operations"
        explanation as Some("Convert concat function to natural language")
    
    Note: Type annotations
    Set rules["type_annotation"] to TransformationRule with:
        pattern as "(.+): (.+)"
        replacement as "$1 as $2"
        condition as None
        priority as 70
        category as "types"
        explanation as Some("Convert type annotation to natural language")
    
    Note: Array/List access
    Set rules["array_access"] to TransformationRule with:
        pattern as "(.+)\\[(.+)\\]"
        replacement as "$1 at index $2"
        condition as None
        priority as 90
        category as "collections"
        explanation as Some("Convert array access to natural language")
    
    Note: Conditional expressions
    Set rules["ternary_operator"] to TransformationRule with:
        pattern as "(.+) \\? (.+) : (.+)"
        replacement as "If $1 then $2 otherwise $3"
        condition as None
        priority as 95
        category as "conditionals"
        explanation as Some("Convert ternary operator to natural language")
    
    Note: Property access
    Set rules["property_access"] to TransformationRule with:
        pattern as "(.+)\\.(.+)"
        replacement as "$2 of $1"
        condition as None
        priority as 60
        category as "property_access"
        explanation as Some("Convert property access to natural language")
    
    Note: Mathematical symbols (Unicode to natural language)
    Set rules["alpha_to_natural"] to TransformationRule with:
        pattern as "α"
        replacement as "alpha"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert Greek alpha to natural language")
    
    Set rules["beta_to_natural"] to TransformationRule with:
        pattern as "β"
        replacement as "beta"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert Greek beta to natural language")
    
    Set rules["gamma_to_natural"] to TransformationRule with:
        pattern as "γ"
        replacement as "gamma"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert Greek gamma to natural language")
    
    Set rules["delta_to_natural"] to TransformationRule with:
        pattern as "δ"
        replacement as "delta"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert Greek delta to natural language")
    
    Set rules["theta_to_natural"] to TransformationRule with:
        pattern as "θ"
        replacement as "theta"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert Greek theta to natural language")
    
    Set rules["lambda_to_natural"] to TransformationRule with:
        pattern as "λ"
        replacement as "lambda"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert Greek lambda to natural language")
    
    Set rules["pi_to_natural"] to TransformationRule with:
        pattern as "π"
        replacement as "pi"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert Greek pi to natural language")
    
    Set rules["sigma_to_natural"] to TransformationRule with:
        pattern as "σ"
        replacement as "sigma"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert Greek sigma to natural language")
    
    Set rules["phi_to_natural"] to TransformationRule with:
        pattern as "φ"
        replacement as "phi"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert Greek phi to natural language")
    
    Set rules["omega_to_natural"] to TransformationRule with:
        pattern as "ω"
        replacement as "omega"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert Greek omega to natural language")
    
    Set rules["sum_to_natural"] to TransformationRule with:
        pattern as "∑"
        replacement as "sum"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert summation symbol to natural language")
    
    Set rules["prod_to_natural"] to TransformationRule with:
        pattern as "∏"
        replacement as "product"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert product symbol to natural language")
    
    Set rules["integral_to_natural"] to TransformationRule with:
        pattern as "∫"
        replacement as "integral"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert integral symbol to natural language")
    
    Set rules["infinity_to_natural"] to TransformationRule with:
        pattern as "∞"
        replacement as "infinity"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert infinity symbol to natural language")
    
    Set rules["in_to_natural"] to TransformationRule with:
        pattern as "∈"
        replacement as "is in"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert element-of symbol to natural language")
    
    Set rules["forall_to_natural"] to TransformationRule with:
        pattern as "∀"
        replacement as "for all"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert universal quantifier to natural language")
    
    Set rules["exists_to_natural"] to TransformationRule with:
        pattern as "∃"
        replacement as "there exists"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert existential quantifier to natural language")
    
    Set rules["leq_to_natural"] to TransformationRule with:
        pattern as "(.+) ≤ (.+)"
        replacement as "$1 is less than or equal to $2"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert Unicode less-than-or-equal to natural language")
    
    Set rules["geq_to_natural"] to TransformationRule with:
        pattern as "(.+) ≥ (.+)"
        replacement as "$1 is greater than or equal to $2"
        condition as None
        priority as 110
        category as "math_symbols"
        explanation as Some("Convert Unicode greater-than-or-equal to natural language")
    
    Return rules

Process called "parse_technical_code" that takes converter as ViewerModeConverter returns ASTNode:
    Note: Parse technical syntax code into AST for expansion
    Try:
        Let lexer be Lexer.create_lexer with source as converter.source_code
        Let tokens be Lexer.tokenize with lexer as lexer
        Let parser be Parser.create_parser with tokens as tokens
        Let ast be Parser.parse with parser as parser
        Set converter.ast to ast
        Return ast
    Catch error:
        Throw ParseError with message as "Failed to parse technical syntax: " plus error.message

Process called "apply_viewer_transformations" that takes converter as ViewerModeConverter and ast as ASTNode returns ASTNode:
    Note: Apply all transformation rules to convert technical syntax to natural
    Let expanded_ast be deep_copy_ast with ast as ast
    
    Note: Apply transformations by priority (highest first)
    Let sorted_rules be sort_rules_by_priority with rules as converter.transformation_rules
    
    For each rule_name, rule in sorted_rules:
        Set expanded_ast to apply_single_expansion with ast as expanded_ast and rule as rule
    
    Note: Post-process for verbosity level
    Set expanded_ast to adjust_verbosity_level with ast as expanded_ast and level as converter.verbosity_level
    
    Return expanded_ast

Process called "sort_rules_by_priority" that takes rules as Dictionary[String, TransformationRule] returns List[Tuple[String, TransformationRule]]:
    Let rule_list be list containing
    For each name, rule in rules:
        Add tuple with name and rule to rule_list
    
    Note: Sort by priority (descending)
    Let sorted_list be list containing
    For each item in rule_list:
        Let inserted be false
        For i from 0 to length of sorted_list:
            If item[1].priority is greater than sorted_list[i][1].priority:
                Insert item at position i in sorted_list
                Set inserted to true
                Break
        If not inserted:
            Add item to sorted_list
    
    Return sorted_list

Process called "apply_single_expansion" that takes ast as ASTNode and rule as TransformationRule returns ASTNode:
    Note: Apply a single expansion rule to the AST
    Try:
        Let pattern_matcher be create_pattern_matcher with pattern as rule.pattern
        Let matches be find_pattern_matches with ast as ast and matcher as pattern_matcher
        
        For each match in matches:
            If rule.condition is None or evaluate_condition with condition as rule.condition and match as match:
                Replace match in ast with rule.replacement and add explanation if provided
        
        Return ast
    Catch error:
        Note: Log expansion error but continue
        Return ast

Process called "adjust_verbosity_level" that takes ast as ASTNode and level as String returns ASTNode:
    Note: Adjust output verbosity based on specified level
    Match level:
        When "minimal":
            Return apply_minimal_expansion with ast as ast
        When "standard":
            Return apply_standard_expansion with ast as ast
        When "verbose":
            Return apply_verbose_expansion with ast as ast
        When "educational":
            Return apply_educational_expansion with ast as ast
        Otherwise:
            Return ast

Process called "apply_minimal_expansion" that takes ast as ASTNode returns ASTNode:
    Note: Minimal expansion - only essential natural language conversions
    Let minimal_ast be ast
    
    Note: Convert only operators and basic symbols
    Set minimal_ast to convert_operators_only with ast as minimal_ast
    
    Return minimal_ast

Process called "apply_standard_expansion" that takes ast as ASTNode returns ASTNode:
    Note: Standard expansion - balance between technical and natural
    Let standard_ast be apply_minimal_expansion with ast as ast
    
    Note: Add method call expansions
    Set standard_ast to expand_method_calls with ast as standard_ast
    
    Note: Add property access expansions
    Set standard_ast to expand_property_access with ast as standard_ast
    
    Return standard_ast

Process called "apply_verbose_expansion" that takes ast as ASTNode returns ASTNode:
    Note: Verbose expansion - maximum natural language conversion
    Let verbose_ast be apply_standard_expansion with ast as ast
    
    Note: Add detailed explanations
    Set verbose_ast to add_detailed_explanations with ast as verbose_ast
    
    Note: Expand complex expressions
    Set verbose_ast to expand_complex_expressions with ast as verbose_ast
    
    Return verbose_ast

Process called "apply_educational_expansion" that takes ast as ASTNode returns ASTNode:
    Note: Educational expansion - include learning aids and explanations
    Let educational_ast be apply_verbose_expansion with ast as ast
    
    Note: Add inline comments explaining concepts
    Set educational_ast to add_educational_comments with ast as educational_ast
    
    Note: Include step-by-step breakdowns
    Set educational_ast to add_step_by_step_explanations with ast as educational_ast
    
    Return educational_ast

Process called "generate_natural_code" that takes ast as ASTNode and options as Dictionary[String, Any] returns String:
    Note: Generate natural language syntax code from expanded AST
    Let code_generator be create_natural_generator with options as options
    Let generated_code be generate_code_from_ast with generator as code_generator and ast as ast
    Return generated_code

Process called "create_natural_generator" that takes options as Dictionary[String, Any] returns CodeGenerator:
    Return CodeGenerator with:
        style as "natural"
        indent_size as options.get("indent_size", 4)
        use_full_words as options.get("use_full_words", true)
        add_explanations as options.get("add_explanations", false)
        line_spacing as options.get("line_spacing", "normal")

Note: Supporting types for viewer mode
Type called "PatternMatcher":
    pattern as String
    compiled_regex as Regex
    capture_groups as List[String]

Type called "ASTMatch":
    node as ASTNode
    text as String
    captures as List[String]
    explanation as Optional[String]

Type called "CodeGenerator":
    style as String
    indent_size as Integer
    use_full_words as Boolean
    add_explanations as Boolean
    line_spacing as String

Note: Advanced expansion functions
Process called "convert_operators_only" that takes ast as ASTNode returns ASTNode:
    Note: Convert only operator symbols to natural language
    If ast.node_type is equal to "BinaryOperation":
        Return expand_binary_operator with operation as ast
    
    For each child in ast.children:
        Set child to convert_operators_only with ast as child
    
    Return ast

Process called "expand_method_calls" that takes ast as ASTNode returns ASTNode:
    Note: Expand method calls to natural language
    If ast.node_type is equal to "MethodCall":
        Return expand_method_call_natural with call as ast
    
    For each child in ast.children:
        Set child to expand_method_calls with ast as child
    
    Return ast

Process called "expand_property_access" that takes ast as ASTNode returns ASTNode:
    Note: Expand property access to natural language
    If ast.node_type is equal to "PropertyAccess":
        Return expand_property_access_natural with access as ast
    
    For each child in ast.children:
        Set child to expand_property_access with ast as child
    
    Return ast

Process called "add_detailed_explanations" that takes ast as ASTNode returns ASTNode:
    Note: Add detailed explanations for complex constructs
    Let explained_ast be ast
    
    Note: Add explanations for complex expressions
    Set explained_ast to add_expression_explanations with ast as explained_ast
    
    Note: Add explanations for algorithm patterns
    Set explained_ast to add_algorithm_explanations with ast as explained_ast
    
    Return explained_ast

Process called "expand_complex_expressions" that takes ast as ASTNode returns ASTNode:
    Note: Break down complex expressions into steps
    If ast.node_type is equal to "ComplexExpression":
        Return break_down_complex_expression with expression as ast
    
    For each child in ast.children:
        Set child to expand_complex_expressions with ast as child
    
    Return ast

Process called "add_educational_comments" that takes ast as ASTNode returns ASTNode:
    Note: Add educational comments for learning purposes
    Let educational_ast be ast
    
    Note: Add concept explanations
    Set educational_ast to add_concept_explanations with ast as educational_ast
    
    Note: Add best practice notes
    Set educational_ast to add_best_practice_notes with ast as educational_ast
    
    Return educational_ast

Process called "add_step_by_step_explanations" that takes ast as ASTNode returns ASTNode:
    Note: Add step-by-step breakdowns for complex logic
    If ast.node_type is equal to "Algorithm" or ast.node_type is equal to "ComplexFunction":
        Return add_step_breakdown with algorithm as ast
    
    For each child in ast.children:
        Set child to add_step_by_step_explanations with ast as child
    
    Return ast

Note: Helper functions for AST manipulation
Process called "deep_copy_ast" that takes ast as ASTNode returns ASTNode:
    Note: Create deep copy of AST for safe transformation
    Return ASTNode with:
        node_type as ast.node_type
        value as ast.value
        children as copy_children_list with children as ast.children
        position as copy_position with position as ast.position
        annotations as Common.copy_list with list as ast.annotations
        metadata as Common.copy_dictionary with dict as ast.metadata

Process called "copy_children_list" that takes children as List[ASTNode] returns List[ASTNode]:
    Let copied_children be list containing
    For each child in children:
        Add deep_copy_ast with ast as child to copied_children
    Return copied_children

Process called "copy_position" that takes position as Position returns Position:
    Return Position with:
        line as position.line
        column as position.column
        offset as position.offset
        metadata as Common.copy_dictionary with dict as position.metadata

Process called "create_pattern_matcher" that takes pattern as String returns PatternMatcher:
    Note: Create pattern matcher for AST node matching
    Return PatternMatcher with:
        pattern as pattern
        compiled_regex as compile_regex with pattern as pattern
        capture_groups as extract_capture_groups with pattern as pattern

Process called "find_pattern_matches" that takes ast as ASTNode and matcher as PatternMatcher returns List[ASTMatch]:
    Note: Find all nodes in AST that match the pattern
    Let matches be list containing
    Call traverse_ast_for_matches with ast as ast and matcher as matcher and matches as matches
    Return matches

Process called "traverse_ast_for_matches" that takes ast as ASTNode and matcher as PatternMatcher and matches as List[ASTMatch] returns None:
    Note: Recursively traverse AST to find pattern matches
    If ast.node_type is equal to "Identifier" or ast.node_type is equal to "Expression" or ast.node_type is equal to "BinaryOperation":
        Let text_representation be get_node_text with node as ast
        If matcher.compiled_regex.matches with text as text_representation:
            Let match be ASTMatch with:
                node as ast
                text as text_representation
                captures as matcher.compiled_regex.capture_groups with text as text_representation
                explanation as None
            Add match to matches
    
    For each child in ast.children:
        Call traverse_ast_for_matches with ast as child and matcher as matcher and matches as matches

Process called "get_node_text" that takes node as ASTNode returns String:
    Note: Extract text representation of AST node
    Match node.node_type:
        When "Identifier":
            Return node.value as String
        When "Literal":
            Return node.value as String
        When "BinaryOperation":
            Return reconstruct_binary_operation_text with node as node
        When "Expression":
            Return reconstruct_expression_text with node as node
        Otherwise:
            Return ""

Process called "reconstruct_binary_operation_text" that takes node as ASTNode returns String:
    Note: Reconstruct text from binary operation AST node
    If length of node.children is greater than or equal to 3:
        Let left be get_node_text with node as node.children[0]
        Let operator be get_node_text with node as node.children[1]
        Let right be get_node_text with node as node.children[2]
        Return left plus " " plus operator plus " " plus right
    Return ""

Process called "reconstruct_expression_text" that takes node as ASTNode returns String:
    Note: Reconstruct text from expression AST node
    Let text_parts be list containing
    For each child in node.children:
        Add get_node_text with node as child to text_parts
    Return join_strings with strings as text_parts and separator as " "

Process called "join_strings" that takes strings as List[String] and separator as String returns String:
    If length of strings is equal to 0:
        Return ""
    
    Let result be strings[0]
    For i from 1 to length of strings minus 1:
        Set result to result plus separator plus strings[i]
    Return result

Process called "compile_regex" that takes pattern as String returns Regex:
    Note: Compile pattern into regex for matching
    Try:
        Return Regex.compile with pattern as convert_to_regex_pattern with pattern as pattern
    Catch error:
        Return Regex.compile with pattern as escape_regex_pattern with pattern as pattern

Process called "convert_to_regex_pattern" that takes pattern as String returns String:
    Note: Convert transformation pattern to regex pattern
    Let regex_pattern be pattern
    
    Note: Replace (.+) with named capture groups
    Set regex_pattern to replace_all with text as regex_pattern and search as "(.+)" and replacement as "(.+?)"
    
    Note: Escape special regex characters except our placeholders
    Set regex_pattern to escape_special_chars with text as regex_pattern
    
    Return regex_pattern

Process called "escape_regex_pattern" that takes pattern as String returns String:
    Note: Escape pattern for literal matching
    Let escaped be ""
    For each char in pattern:
        If char is equal to "." or char is equal to "*" or char is equal to "+" or char is equal to "?":
            Set escaped to escaped plus "\\" plus char
        Otherwise:
            Set escaped to escaped plus char
    Return escaped

Process called "extract_capture_groups" that takes pattern as String returns List[String]:
    Note: Extract capture group names from pattern
    Let groups be list containing
    Let in_group be false
    Let current_group be ""
    
    For each char in pattern:
        If char is equal to "(":
            Set in_group to true
            Set current_group to ""
        Else if char is equal to ")":
            If in_group:
                Add current_group to groups
                Set in_group to false
        Else if in_group:
            Set current_group to current_group plus char
    
    Return groups

Note: Code generation functions for natural language output
Process called "generate_code_from_ast" that takes generator as CodeGenerator and ast as ASTNode returns String:
    Note: Generate final natural language syntax code
    Let code_builder be StringBuilder.create()
    Call generate_node_code with builder as code_builder and node as ast and generator as generator and indent as 0
    Return StringBuilder.toString with builder as code_builder

Process called "generate_node_code" that takes builder as StringBuilder and node as ASTNode and generator as CodeGenerator and indent as Integer returns None:
    Note: Generate code for a single AST node
    Match node.node_type:
        When "Program":
            Call generate_program_code with builder as builder and node as node and generator as generator and indent as indent
        When "Function":
            Call generate_function_code with builder as builder and node as node and generator as generator and indent as indent
        When "Expression":
            Call generate_expression_code with builder as builder and node as node and generator as generator
        When "BinaryOperation":
            Call generate_binary_operation_code with builder as builder and node as node and generator as generator
        When "Identifier":
            StringBuilder.append with builder as builder and text as node.value as String
        When "Literal":
            StringBuilder.append with builder as builder and text as format_literal_natural with value as node.value and generator as generator
        Otherwise:
            StringBuilder.append with builder as builder and text as node.value as String

Process called "generate_program_code" that takes builder as StringBuilder and node as ASTNode and generator as CodeGenerator and indent as Integer returns None:
    For each child in node.children:
        Call generate_node_code with builder as builder and node as child and generator as generator and indent as indent
        StringBuilder.append with builder as builder and text as "\n"
        If generator.line_spacing is equal to "wide":
            StringBuilder.append with builder as builder and text as "\n"

Process called "generate_function_code" that takes builder as StringBuilder and node as ASTNode and generator as CodeGenerator and indent as Integer returns None:
    Note: Generate function in natural language syntax
    Let indentation be create_indentation with size as indent and generator as generator
    StringBuilder.append with builder as builder and text as indentation
    StringBuilder.append with builder as builder and text as "Process called "
    
    For each child in node.children:
        Call generate_node_code with builder as builder and node as child and generator as generator and indent as indent

Process called "generate_expression_code" that takes builder as StringBuilder and node as ASTNode and generator as CodeGenerator returns None:
    Note: Generate expression in natural language form
    For i from 0 to length of node.children minus 1:
        Call generate_node_code with builder as builder and node as node.children[i] and generator as generator and indent as 0
        If i is less than length of node.children minus 1:
            StringBuilder.append with builder as builder and text as " "

Process called "generate_binary_operation_code" that takes builder as StringBuilder and node as ASTNode and generator as CodeGenerator returns None:
    Note: Generate binary operations in natural language
    If length of node.children is greater than or equal to 3:
        Call generate_node_code with builder as builder and node as node.children[0] and generator as generator and indent as 0
        StringBuilder.append with builder as builder and text as " "
        Call generate_operator_natural with builder as builder and operator as node.children[1] and generator as generator
        StringBuilder.append with builder as builder and text as " "
        Call generate_node_code with builder as builder and node as node.children[2] and generator as generator and indent as 0

Process called "generate_operator_natural" that takes builder as StringBuilder and operator as ASTNode and generator as CodeGenerator returns None:
    Note: Generate operators in natural language
    Let operator_text be operator.value as String
    Match operator_text:
        When "+":
            StringBuilder.append with builder as builder and text as "plus"
        When "-":
            StringBuilder.append with builder as builder and text as "minus"
        When "*":
            StringBuilder.append with builder as builder and text as "multiplied by"
        When "/":
            StringBuilder.append with builder as builder and text as "divided by"
        When "==":
            StringBuilder.append with builder as builder and text as "is equal to"
        When ">":
            StringBuilder.append with builder as builder and text as "is greater than"
        When "<":
            StringBuilder.append with builder as builder and text as "is less than"
        When ">=":
            StringBuilder.append with builder as builder and text as "is greater than or equal to"
        When "<=":
            StringBuilder.append with builder as builder and text as "is less than or equal to"
        When "!=":
            StringBuilder.append with builder as builder and text as "is not equal to"
        When "&&":
            StringBuilder.append with builder as builder and text as "and"
        When "||":
            StringBuilder.append with builder as builder and text as "or"
        Otherwise:
            StringBuilder.append with builder as builder and text as operator_text

Process called "format_literal_natural" that takes value as Any and generator as CodeGenerator returns String:
    Note: Format literal values in natural language style
    If value is String:
        Return "\"" plus value as String plus "\""
    Otherwise:
        Return value as String

Process called "create_indentation" that takes size as Integer and generator as CodeGenerator returns String:
    Let spaces_per_indent be generator.indent_size
    Let indentation be ""
    For i from 0 to size multiplied by spaces_per_indent minus 1:
        Set indentation to indentation plus " "
    Return indentation

Note: Main CLI integration function
Process called "run_viewer_mode" that takes source_file as String and output_file as Optional[String] and options as Dictionary[String, Any] returns Boolean:
    Note: Main entry point for READ-ONLY viewer mode display
    Try:
        Let source_code be read_file with path as source_file
        Let display_code be convert_to_viewer_display with source_code as source_code and options as options
        
        If output_file is not None:
            Call write_display_output with path as output_file and content as display_code
            Display "Viewer mode display generated (READ-ONLY): " plus output_file
        Otherwise:
            Display display_code
        
        Display "Note: Viewer mode is READ-ONLY. To edit, convert to canonical or developer mode."
        Return true
    Catch file_error:
        Display "Error reading file: " plus file_error.message
        Return false
    Catch display_error:
        Display "Error during display generation: " plus display_error.message
        Return false

Process called "read_file" that takes path as String returns String:
    Note: Read source file content
    Try:
        Import "io"
        Return io.read_text_file with path as path
    Catch error:
        Throw FileError with message as "Could not read file: " plus path

Note: Legacy write_file function replaced by write_display_output
Note: This function is deprecated in favor of read-only display output

Note: Utility functions for text transformations
Process called "escape_special_chars" that takes text as String returns String:
    Note: Escape special regex characters except placeholders
    Let escaped be ""
    For each char in text:
        If char is equal to "\\" or char is equal to "^" or char is equal to "$" or char is equal to "[" or char is equal to "]":
            Set escaped to escaped plus "\\" plus char
        Otherwise:
            Set escaped to escaped plus char
    Return escaped

Process called "replace_all" that takes text as String and search as String and replacement as String returns String:
    Note: Replace all occurrences of search with replacement
    Let result be text
    Let search_index be find_substring with text as result and search as search
    
    While search_index is not equal to -1:
        Let before be substring with text as result and start as 0 and end as search_index
        Let after be substring with text as result and start as search_index plus length of search
        Set result to before plus replacement plus after
        Set search_index to find_substring with text as result and search as search
    
    Return result

Process called "find_substring" that takes text as String and search as String returns Integer:
    Note: Find first occurrence of search in text
    Let text_length be length of text
    Let search_length be length of search
    
    For i from 0 to text_length minus search_length:
        Let matches be true
        For j from 0 to search_length minus 1:
            If character_at with text as text and position as i plus j is not equal to character_at with text as search and position as j:
                Set matches to false
                Break
        If matches:
            Return i
    
    Return -1

Process called "substring" that takes text as String and start as Integer and end as Optional[Integer] returns String:
    Note: Extract substring from text
    Let actual_end be if end is not None then end else length of text
    If start is less than 0:
        Set start to 0
    If actual_end is greater than length of text:
        Set actual_end to length of text
    
    Let result be ""
    For i from start to actual_end minus 1:
        Set result to result plus character_at with text as text and position as i
    
    Return result

Process called "character_at" that takes text as String and position as Integer returns String:
    Note: Get character at position in string
    If position is less than 0 or position is greater than or equal to length of text:
        Return ""
    
    Note: Convert to character array and access by index
    Let chars be text as List[String]
    Return chars at position

Note: READ-ONLY viewer mode specific functions
Process called "add_readonly_header" that takes content as String returns String:
    Note: Add header indicating this is READ-ONLY display output
    Let header be "Note: This is READ-ONLY viewer mode output for comprehension only.\n"
    Set header to header plus "To edit this code, convert back to canonical or developer mode.\n"
    Set header to header plus "Generated from: Triple Syntax Viewer Mode\n"
    Set header to header plus "Purpose: AI comprehension and stakeholder review\n\n"
    Return header plus content

Process called "add_readonly_context" that takes ast as ASTNode returns ASTNode:
    Note: Add context markers indicating read-only nature
    Let readonly_ast be ast
    Note: Add metadata indicating this is for display only
    If readonly_ast.metadata is None:
        Set readonly_ast.metadata to dictionary containing
    Set readonly_ast.metadata["readonly"] to true
    Set readonly_ast.metadata["display_mode"] to true
    Set readonly_ast.metadata["editable"] to false
    Return readonly_ast

Process called "add_ai_comprehension_markers" that takes ast as ASTNode returns ASTNode:
    Note: Add markers to aid AI comprehension of natural language code
    Let comprehension_ast be ast
    Note: Add comprehension metadata for AI processing
    If comprehension_ast.metadata is None:
        Set comprehension_ast.metadata to dictionary containing
    Set comprehension_ast.metadata["ai_friendly"] to true
    Set comprehension_ast.metadata["natural_language"] to true
    Set comprehension_ast.metadata["comprehension_aids"] to true
    Return comprehension_ast

Process called "write_display_output" that takes path as String and content as String returns None:
    Note: Write display output to file with READ-ONLY markers
    Try:
        Import "io"
        Let readonly_content be add_readonly_file_markers with content as content
        Call io.write_text_file with path as path and content as readonly_content
    Catch error:
        Throw FileError with message as "Could not write display file: " plus path

Process called "add_readonly_file_markers" that takes content as String returns String:
    Note: Add file-level READ-ONLY markers
    Let marked_content be "Note: === READ-ONLY VIEWER MODE OUTPUT ===\n"
    Set marked_content to marked_content plus "Note: This file is generated for display and comprehension only.\n"
    Set marked_content to marked_content plus "Note: Do not edit this file directly.\n"
    Set marked_content to marked_content plus "Note: To make changes, edit the canonical or developer mode source.\n"
    Set marked_content to marked_content plus "Note: === END READ-ONLY HEADER ===\n\n"
    Return marked_content plus content plus "\n\nNote: === END READ-ONLY VIEWER MODE OUTPUT ==="