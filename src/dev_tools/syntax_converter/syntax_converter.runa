Note:
Runa Syntax Converter - Cross-Mode Transformation Engine

Handles bidirectional conversion between canonical Runa and developer (technical) syntax.
Integrates with the triple syntax system to provide seamless mode switching while
preserving metadata for round-trip conversions.

Features:
- Canonical ↔ Developer mode conversion
- Constructor syntax transformation
- Metadata preservation for round-trip accuracy
- Integration with existing lexer/parser infrastructure
- Support for complex nested constructs
:End Note

Import "../compiler/semantic/semantic_analyzer" as SemanticAnalyzer
Import "../compiler/lexer/enhanced_lexer" as Lexer
Import "../compiler/parser/enhanced_parser" as Parser
Import "utilities/common" as Common

Note: Main conversion coordination type
Type called "SyntaxConverter":
    source_mode as String
    target_mode as String
    conversion_rules as Dictionary[String, ConversionRule]
    metadata_preservers as List[MetadataPreserver]
    round_trip_data as Dictionary[String, Any]

Type called "ConversionRule":
    source_pattern as String
    target_pattern as String
    category as String
    priority as Integer
    bidirectional as Boolean
    metadata_handler as Optional[String]

Type called "ConversionResult":
    converted_code as String
    conversion_success as Boolean
    metadata_preserved as Dictionary[String, Any]
    warnings as List[String]
    round_trip_data as Dictionary[String, Any]

Process called "convert_between_modes" that takes source_code as String and from_mode as String and to_mode as String and options as Dictionary[String, Any] returns ConversionResult:
    Note: Main entry point for syntax mode conversion
    Try:
        Let converter be create_syntax_converter with from_mode as from_mode and to_mode as to_mode and options as options
        Let ast be parse_with_metadata_preservation with source as source_code and mode as from_mode
        Let converted_ast be apply_conversion_rules with converter as converter and ast as ast
        Let result_code be generate_target_syntax with ast as converted_ast and mode as to_mode and options as options
        
        Return ConversionResult with
            converted_code as result_code,
            conversion_success as true,
            metadata_preserved as extract_preserved_metadata with ast as converted_ast,
            warnings as list containing,
            round_trip_data as converter.round_trip_data
        End ConversionResult
        
    Catch conversion_error:
        Return ConversionResult with
            converted_code as source_code,
            conversion_success as false,
            metadata_preserved as dictionary containing,
            warnings as list containing conversion_error.message,
            round_trip_data as dictionary containing
        End ConversionResult

Process called "create_syntax_converter" that takes from_mode as String and to_mode as String and options as Dictionary[String, Any] returns SyntaxConverter:
    Note: Initialize converter with appropriate rule set
    Let rules be load_conversion_rules_for_modes with from_mode as from_mode and to_mode as to_mode
    Let preservers be create_metadata_preservers with from_mode as from_mode and to_mode as to_mode
    
    Return SyntaxConverter with
        source_mode as from_mode,
        target_mode as to_mode,
        conversion_rules as rules,
        metadata_preservers as preservers,
        round_trip_data as dictionary containing
    End SyntaxConverter

Process called "load_conversion_rules_for_modes" that takes from_mode as String and to_mode as String returns Dictionary[String, ConversionRule]:
    Note: Load appropriate conversion rules based on source and target modes
    Let rules be dictionary containing
    
    If from_mode is equal to "canonical" and to_mode is equal to "developer":
        Call add_canonical_to_developer_rules with rules as rules
    Else if from_mode is equal to "developer" and to_mode is equal to "canonical":
        Call add_developer_to_canonical_rules with rules as rules
    Otherwise:
        Throw ConversionError with message as "Unsupported conversion: " plus from_mode plus " to " plus to_mode
    
    Return rules

Process called "add_canonical_to_developer_rules" that takes rules as Dictionary[String, ConversionRule] returns None:
    Note: Add rules for converting canonical Runa to developer syntax
    
    Note: Constructor conversions
    Set rules["canonical_a_value_of_type"] to ConversionRule with
        source_pattern as "Let (.+) be a value of type (.+)",
        target_pattern as "let $1 = new $2()",
        category as "constructors",
        priority as 105,
        bidirectional as true,
        metadata_handler as Some("preserve_constructor_metadata")
    End ConversionRule
    
    Set rules["canonical_of_type"] to ConversionRule with
        source_pattern as "Let (.+) be of type (.+)",
        target_pattern as "let $1 = new $2()",
        category as "constructors",
        priority as 105,
        bidirectional as true,
        metadata_handler as Some("preserve_constructor_metadata")
    End ConversionRule
    
    Set rules["canonical_constructor_with_fields"] to ConversionRule with
        source_pattern as "Let (.+) be (.+) with([\\s\\S]*?)End \\2",
        target_pattern as "let $1 = new $2({$3})",
        category as "constructors",
        priority as 104,
        bidirectional as true,
        metadata_handler as Some("preserve_field_initialization_metadata")
    End ConversionRule
    
    Note: Variable declarations
    Set rules["canonical_let_be"] to ConversionRule with
        source_pattern as "Let (.+) be (.+)",
        target_pattern as "let $1 = $2",
        category as "declarations",
        priority as 100,
        bidirectional as true,
        metadata_handler as Some("preserve_variable_metadata")
    End ConversionRule
    
    Set rules["canonical_set_to"] to ConversionRule with
        source_pattern as "Set (.+) to (.+)",
        target_pattern as "$1 = $2",
        category as "assignments",
        priority as 100,
        bidirectional as true,
        metadata_handler as None
    End ConversionRule
    
    Note: Process definitions
    Set rules["canonical_process"] to ConversionRule with
        source_pattern as "Process called \"(.+)\" that takes (.+) returns (.+):",
        target_pattern as "function $1($2): $3 {",
        category as "functions",
        priority as 110,
        bidirectional as true,
        metadata_handler as Some("preserve_function_metadata")
    End ConversionRule
    
    Note: Type definitions
    Set rules["canonical_type"] to ConversionRule with
        source_pattern as "Type called \"(.+)\":",
        target_pattern as "type $1 = {",
        category as "types",
        priority as 110,
        bidirectional as true,
        metadata_handler as Some("preserve_type_metadata")
    End ConversionRule

Process called "add_developer_to_canonical_rules" that takes rules as Dictionary[String, ConversionRule] returns None:
    Note: Add rules for converting developer syntax to canonical Runa
    
    Note: Constructor conversions (reverse)
    Set rules["developer_new_constructor"] to ConversionRule with
        source_pattern as "let (.+) = new (.+)\\(\\)",
        target_pattern as "Let $1 be a value of type $2",
        category as "constructors",
        priority as 105,
        bidirectional as true,
        metadata_handler as Some("preserve_constructor_metadata")
    End ConversionRule
    
    Set rules["developer_new_constructor_with_fields"] to ConversionRule with
        source_pattern as "let (.+) = new (.+)\\(\\{([^}]*)\\}\\)",
        target_pattern as "Let $1 be $2 with$3End $2",
        category as "constructors",
        priority as 104,
        bidirectional as true,
        metadata_handler as Some("preserve_field_initialization_metadata")
    End ConversionRule
    
    Note: Variable declarations (reverse)
    Set rules["developer_let_equals"] to ConversionRule with
        source_pattern as "let (.+) = (.+)",
        target_pattern as "Let $1 be $2",
        category as "declarations",
        priority as 100,
        bidirectional as true,
        metadata_handler as Some("preserve_variable_metadata")
    End ConversionRule
    
    Set rules["developer_assignment"] to ConversionRule with
        source_pattern as "(.+) = (.+)",
        target_pattern as "Set $1 to $2",
        category as "assignments",
        priority as 100,
        bidirectional as true,
        metadata_handler as None
    End ConversionRule
    
    Note: Function definitions (reverse)
    Set rules["developer_function"] to ConversionRule with
        source_pattern as "function (.+)\\((.+)\\): (.+) \\{",
        target_pattern as "Process called \"$1\" that takes $2 returns $3:",
        category as "functions",
        priority as 110,
        bidirectional as true,
        metadata_handler as Some("preserve_function_metadata")
    End ConversionRule
    
    Note: Type definitions (reverse)
    Set rules["developer_type"] to ConversionRule with
        source_pattern as "type (.+) = \\{",
        target_pattern as "Type called \"$1\":",
        category as "types",
        priority as 110,
        bidirectional as true,
        metadata_handler as Some("preserve_type_metadata")
    End ConversionRule

Process called "parse_with_metadata_preservation" that takes source as String and mode as String returns ASTNode:
    Note: Parse source code while preserving metadata for round-trip conversion
    Try:
        Let lexer be Lexer.create_lexer with source as source
        Let tokens be Lexer.tokenize with lexer as lexer
        Let parser be Parser.create_parser with tokens as tokens
        Let ast be Parser.parse with parser as parser
        
        Note: Enhance AST with metadata preservation
        Set ast to enhance_ast_with_conversion_metadata with ast as ast and source_mode as mode
        
        Return ast
    Catch error:
        Throw ParseError with message as "Failed to parse " plus mode plus " syntax: " plus error.message

Process called "enhance_ast_with_conversion_metadata" that takes ast as ASTNode and source_mode as String returns ASTNode:
    Note: Add metadata fields needed for accurate round-trip conversion
    Set ast.metadata["original_source_mode"] to source_mode
    Set ast.metadata["conversion_timestamp"] to current_timestamp()
    Set ast.metadata["original_formatting"] to preserve_original_formatting with ast as ast
    
    Note: Recursively enhance child nodes
    For each child in ast.children:
        Set child to enhance_ast_with_conversion_metadata with ast as child and source_mode as source_mode
    
    Return ast

Process called "apply_conversion_rules" that takes converter as SyntaxConverter and ast as ASTNode returns ASTNode:
    Note: Apply conversion rules to transform AST from source to target mode
    Let converted_ast be deep_copy_ast with ast as ast
    
    Note: Sort rules by priority (highest first)
    Let sorted_rules be sort_conversion_rules_by_priority with rules as converter.conversion_rules
    
    For each rule_name, rule in sorted_rules:
        Set converted_ast to apply_single_conversion_rule with ast as converted_ast and rule as rule and converter as converter
    
    Note: Post-process for target mode specific optimizations
    Set converted_ast to apply_target_mode_optimizations with ast as converted_ast and target_mode as converter.target_mode
    
    Return converted_ast

Process called "apply_single_conversion_rule" that takes ast as ASTNode and rule as ConversionRule and converter as SyntaxConverter returns ASTNode:
    Note: Apply a single conversion rule to the AST
    Try:
        Let pattern_matcher be create_conversion_pattern_matcher with pattern as rule.source_pattern
        Let matches be find_conversion_matches with ast as ast and matcher as pattern_matcher
        
        For each match in matches:
            Note: Apply conversion with metadata preservation
            Let converted_node be convert_node_with_rule with node as match.node and rule as rule
            
            Note: Preserve metadata if handler specified
            If rule.metadata_handler is not None:
                Call preserve_conversion_metadata with original as match.node and converted as converted_node and handler as rule.metadata_handler and converter as converter
            
            Replace match.node in ast with converted_node
        
        Return ast
    Catch error:
        Note: Log conversion error but continue with other rules
        Add "Rule " plus rule.category plus " failed: " plus error.message to converter.round_trip_data["conversion_warnings"]
        Return ast

Process called "preserve_conversion_metadata" that takes original as ASTNode and converted as ASTNode and handler as String and converter as SyntaxConverter returns None:
    Note: Preserve metadata using specified handler
    Match handler:
        When "preserve_constructor_metadata":
            Call preserve_constructor_conversion_metadata with original as original and converted as converted and converter as converter
        When "preserve_field_initialization_metadata":
            Call preserve_field_initialization_conversion_metadata with original as original and converted as converted and converter as converter
        When "preserve_variable_metadata":
            Call preserve_variable_conversion_metadata with original as original and converted as converted and converter as converter
        When "preserve_function_metadata":
            Call preserve_function_conversion_metadata with original as original and converted as converted and converter as converter
        When "preserve_type_metadata":
            Call preserve_type_conversion_metadata with original as original and converted as converted and converter as converter
        Otherwise:
            Note: Unknown metadata handler, skip preservation

Process called "preserve_constructor_conversion_metadata" that takes original as ASTNode and converted as ASTNode and converter as SyntaxConverter returns None:
    Note: Preserve constructor-specific metadata for round-trip conversion
    Let constructor_data be dictionary containing
    Set constructor_data["original_syntax"] to get_node_text_representation with node as original
    Set constructor_data["original_constructor_form"] to extract_constructor_form with node as original
    Set constructor_data["source_mode"] to converter.source_mode
    Set constructor_data["target_mode"] to converter.target_mode
    
    Set converted.metadata["constructor_conversion"] to constructor_data
    
    Note: Store for round-trip data
    If not converter.round_trip_data.contains("constructors"):
        Set converter.round_trip_data["constructors"] to list containing
    
    Add constructor_data to converter.round_trip_data["constructors"]

Process called "extract_constructor_form" that takes node as ASTNode returns String:
    Note: Determine which constructor syntax was used in the original
    Let node_text be get_node_text_representation with node as node
    
    If node_text contains "a value of type":
        Return "a_value_of_type"
    Else if node_text contains "of type":
        Return "of_type"
    Else if node_text contains "new ":
        Return "new_constructor"
    Else if node_text contains " with " and node_text contains "End ":
        Return "with_fields"
    Otherwise:
        Return "unknown"

Process called "generate_target_syntax" that takes ast as ASTNode and mode as String and options as Dictionary[String, Any] returns String:
    Note: Generate code in target syntax mode from converted AST
    Match mode:
        When "canonical":
            Return generate_canonical_syntax_code with ast as ast and options as options
        When "developer":
            Return generate_developer_syntax_code with ast as ast and options as options
        Otherwise:
            Throw GenerationError with message as "Unsupported target mode: " plus mode

Process called "generate_canonical_syntax_code" that takes ast as ASTNode and options as Dictionary[String, Any] returns String:
    Note: Generate canonical Runa syntax from AST
    Let code_generator be create_canonical_code_generator with options as options
    Let generated_code be generate_code_from_ast with generator as code_generator and ast as ast
    Return generated_code

Process called "generate_developer_syntax_code" that takes ast as ASTNode and options as Dictionary[String, Any] returns String:
    Note: Generate developer (technical) syntax from AST
    Let code_generator be create_developer_code_generator with options as options
    Let generated_code be generate_code_from_ast with generator as code_generator and ast as ast
    Return generated_code

Note: Supporting utility functions
Process called "sort_conversion_rules_by_priority" that takes rules as Dictionary[String, ConversionRule] returns List[Tuple[String, ConversionRule]]:
    Note: Sort conversion rules by priority (highest first)
    Let rule_list be list containing
    For each name, rule in rules:
        Add tuple with name and rule to rule_list
    
    Note: Sort by priority (descending)
    Let sorted_list be list containing
    For each item in rule_list:
        Let inserted be false
        For i from 0 to length of sorted_list:
            If item[1].priority is greater than sorted_list[i][1].priority:
                Insert item at position i in sorted_list
                Set inserted to true
                Break
        If not inserted:
            Add item to sorted_list
    
    Return sorted_list

Process called "current_timestamp" returns String:
    Note: Get current timestamp for metadata
    Import "time"
    Return time.current_timestamp_string()

Process called "deep_copy_ast" that takes ast as ASTNode returns ASTNode:
    Note: Create deep copy of AST for safe transformation
    Return ASTNode with
        node_type as ast.node_type,
        value as ast.value,
        children as copy_children_recursively with children as ast.children,
        position as copy_position_data with position as ast.position,
        annotations as Common.copy_list with list as ast.annotations,
        metadata as Common.copy_dictionary with dict as ast.metadata
    End ASTNode

Process called "copy_children_recursively" that takes children as List[ASTNode] returns List[ASTNode]:
    Let copied_children be list containing
    For each child in children:
        Add deep_copy_ast with ast as child to copied_children
    Return copied_children

Process called "copy_position_data" that takes position as Position returns Position:
    Return Position with
        line as position.line,
        column as position.column,
        offset as position.offset,
        metadata as Common.copy_dictionary with dict as position.metadata
    End Position

Note: Integration with existing CLI infrastructure
Process called "handle_conversion_command" that takes from_mode as String and to_mode as String and input_file as String and output_file as Optional[String] and options as Dictionary[String, Any] returns Boolean:
    Note: Handle syntax conversion command from CLI
    Try:
        Let source_code be read_source_file with path as input_file
        Let conversion_result be convert_between_modes with source_code as source_code and from_mode as from_mode and to_mode as to_mode and options as options
        
        If conversion_result.conversion_success:
            If output_file is not None:
                Call write_converted_file with path as output_file and content as conversion_result.converted_code
                Display "✓ Conversion complete: " plus from_mode plus " → " plus to_mode
                Display "  Input:  " plus input_file
                Display "  Output: " plus output_file
            Otherwise:
                Display "✓ Conversion: " plus from_mode plus " → " plus to_mode
                Display "─────────────────────────────"
                Display conversion_result.converted_code
            
            Note: Show warnings if any
            If length of conversion_result.warnings is greater than 0:
                Display ""
                Display "⚠️ Conversion warnings:"
                For warning in conversion_result.warnings:
                    Display "  " plus warning
            
            Return true
        Otherwise:
            Display "✗ Conversion failed: " plus from_mode plus " → " plus to_mode
            For warning in conversion_result.warnings:
                Display "  Error: " plus warning
            Return false
            
    Catch error:
        Display "Error during conversion: " plus error.message
        Return false

Process called "read_source_file" that takes path as String returns String:
    Note: Read source file content
    Try:
        Import "io"
        Return io.read_text_file with path as path
    Catch error:
        Throw FileError with message as "Could not read file: " plus path

Process called "write_converted_file" that takes path as String and content as String returns None:
    Note: Write converted code to file
    Try:
        Import "io"
        Call io.write_text_file with path as path and content as content
    Catch error:
        Throw FileError with message as "Could not write file: " plus path