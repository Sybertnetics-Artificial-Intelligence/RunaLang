Note:
Runa Mixed Syntax Handler - Robust Multi-Format Parser

Handles files with inconsistent syntax by parsing line-by-line and construct-by-construct.
This allows normalization of mixed canonical/developer syntax into clean, consistent output.

Features:
- Line-by-line syntax analysis and conversion
- Graceful handling of mixed syntax patterns
- Progressive normalization to target format
- Detailed reporting of inconsistencies found and fixed
- Fallback mechanisms for unparseable constructs
- Preservation of semantic meaning during conversion
:End Note

Import "../compiler/lexer/enhanced_lexer" as Lexer
Import "../compiler/parser/enhanced_parser" as Parser
Import "utilities/common" as Common
Import "syntax_converter" as SyntaxConverter

Note: Main mixed syntax handler type
Type called "MixedSyntaxHandler":
    source_lines as List[String]
    target_mode as String
    conversion_warnings as List[String]
    syntax_inconsistencies as List[SyntaxInconsistency]
    processed_lines as List[ProcessedLine]
    fallback_mode as String

Type called "SyntaxInconsistency":
    line_number as Integer
    original_syntax as String
    detected_mode as String
    converted_syntax as String
    inconsistency_type as String

Type called "ProcessedLine":
    line_number as Integer
    original_content as String
    processed_content as String
    syntax_mode as String
    conversion_applied as Boolean
    warnings as List[String]

Type called "MixedSyntaxResult":
    normalized_code as String
    conversion_success as Boolean
    inconsistencies_found as Integer
    inconsistencies_fixed as Integer
    warnings as List[String]
    detailed_report as List[SyntaxInconsistency]

Process called "handle_mixed_syntax_file" that takes source_code as String and target_mode as String and options as Dictionary[String, Any] returns MixedSyntaxResult:
    Note: Main entry point for mixed syntax handling
    Try:
        Let handler be create_mixed_syntax_handler with source as source_code and target as target_mode and options as options
        Let analysis_result be analyze_syntax_patterns with handler as handler
        Let conversion_result be convert_mixed_syntax with handler as handler
        Let normalized_code be generate_normalized_output with handler as handler
        
        Return MixedSyntaxResult with
            normalized_code as normalized_code,
            conversion_success as true,
            inconsistencies_found as length of handler.syntax_inconsistencies,
            inconsistencies_fixed as count_fixed_inconsistencies with handler as handler,
            warnings as handler.conversion_warnings,
            detailed_report as handler.syntax_inconsistencies
        End MixedSyntaxResult
        
    Catch error:
        Return MixedSyntaxResult with
            normalized_code as source_code,
            conversion_success as false,
            inconsistencies_found as 0,
            inconsistencies_fixed as 0,
            warnings as list containing error.message,
            detailed_report as list containing
        End MixedSyntaxResult

Process called "create_mixed_syntax_handler" that takes source as String and target as String and options as Dictionary[String, Any] returns MixedSyntaxHandler:
    Note: Initialize mixed syntax handler with source code and target mode
    Let lines be split_into_lines with text as source
    
    Return MixedSyntaxHandler with
        source_lines as lines,
        target_mode as target,
        conversion_warnings as list containing,
        syntax_inconsistencies as list containing,
        processed_lines as list containing,
        fallback_mode as options.get("fallback_mode", "canonical")
    End MixedSyntaxHandler

Process called "analyze_syntax_patterns" that takes handler as MixedSyntaxHandler returns Boolean:
    Note: Analyze each line to detect syntax patterns and inconsistencies
    Let line_number be 1
    
    For each line in handler.source_lines:
        Let trimmed_line be trim_whitespace with text as line
        
        If not is_empty_or_comment_line with line as trimmed_line:
            Let detected_mode be detect_line_syntax_mode with line as trimmed_line
            Let processed_line be create_processed_line with 
                line_num as line_number and 
                content as line and 
                mode as detected_mode
            
            Add processed_line to handler.processed_lines
            
            Note: Check for inconsistency with target mode
            If detected_mode is not equal to handler.target_mode and detected_mode is not equal to "unknown":
                Let inconsistency be create_syntax_inconsistency with 
                    line_num as line_number and 
                    original as line and 
                    detected as detected_mode and 
                    target as handler.target_mode
                
                Add inconsistency to handler.syntax_inconsistencies
        
        Set line_number to line_number plus 1
    
    Return true

Process called "detect_line_syntax_mode" that takes line as String returns String:
    Note: Detect syntax mode for a single line
    Let trimmed be trim_whitespace with text as line
    
    Note: Check for canonical patterns
    If trimmed starts with "Process called \"" or 
       trimmed starts with "Type called \"" or
       trimmed starts with "Let " and trimmed contains " be " or
       trimmed starts with "Set " and trimmed contains " to " or
       trimmed starts with "Note:" or
       trimmed is equal to "End Process" or
       trimmed is equal to "End Type":
        Return "canonical"
    
    Note: Check for developer patterns  
    Else if trimmed starts with "function " or
            trimmed starts with "type " and trimmed contains " = {" or
            trimmed contains " = new " or
            trimmed starts with "//" or
            trimmed ends with "}" or
            trimmed ends with "{":
        Return "developer"
    
    Note: Check for bare assignment (developer pattern: x = value)
    Else if regex_matches with text as trimmed and pattern as "^[a-zA-Z_][a-zA-Z0-9_.]*\\s*=\\s*.+":
        Return "developer"
    
    Note: Check for mixed constructor patterns
    Else if trimmed contains "new " and trimmed contains "()":
        Return "developer"
    Else if trimmed contains "a value of type" or trimmed contains "of type":
        Return "canonical"
    
    Otherwise:
        Return "unknown"

Process called "convert_mixed_syntax" that takes handler as MixedSyntaxHandler returns Boolean:
    Note: Convert each line to target syntax mode
    For i from 0 to length of handler.processed_lines minus 1:
        Let processed_line be handler.processed_lines[i]
        
        If processed_line.syntax_mode is not equal to handler.target_mode and processed_line.syntax_mode is not equal to "unknown":
            Let conversion_result be convert_single_line with 
                line as processed_line.original_content and 
                from_mode as processed_line.syntax_mode and 
                to_mode as handler.target_mode
            
            If conversion_result.success:
                Set processed_line.processed_content to conversion_result.converted_line
                Set processed_line.conversion_applied to true
                
                Note: Update inconsistency record with converted syntax
                Let inconsistency_index be find_inconsistency_for_line with 
                    handler as handler and 
                    line_number as processed_line.line_number
                
                If inconsistency_index is not equal to negative 1:
                    Set handler.syntax_inconsistencies[inconsistency_index].converted_syntax to conversion_result.converted_line
            Otherwise:
                Add "Failed to convert line " plus string_from_integer(processed_line.line_number) plus ": " plus conversion_result.error_message to handler.conversion_warnings
                Set processed_line.processed_content to processed_line.original_content
                Add conversion_result.error_message to processed_line.warnings
        Otherwise:
            Note: Line already in target mode or unknown, keep as-is
            Set processed_line.processed_content to processed_line.original_content
    
    Return true

Process called "convert_single_line" that takes line as String and from_mode as String and to_mode as String returns SingleLineConversionResult:
    Note: Convert a single line from one syntax mode to another
    Let trimmed_line be trim_whitespace with text as line
    Let converted_line be line
    Let conversion_success be true
    Let error_message be ""
    
    Try:
        If from_mode is equal to "canonical" and to_mode is equal to "developer":
            Set converted_line to convert_canonical_line_to_developer with line as line
        Else if from_mode is equal to "developer" and to_mode is equal to "canonical":
            Set converted_line to convert_developer_line_to_canonical with line as line
        Otherwise:
            Set conversion_success to false
            Set error_message to "Unsupported conversion: " plus from_mode plus " to " plus to_mode
            
    Catch conversion_error:
        Set conversion_success to false  
        Set error_message to conversion_error.message
        Set converted_line to line
    
    Return SingleLineConversionResult with
        converted_line as converted_line,
        success as conversion_success,
        error_message as error_message
    End SingleLineConversionResult

Process called "convert_canonical_line_to_developer" that takes line as String returns String:
    Note: Convert canonical syntax line to developer syntax (bare assignment style)
    Let converted be line
    
    Note: Process declarations
    If converted contains "Process called \"":
        Set converted to regex_replace with 
            text as converted and 
            pattern as "Process called \"([^\"]+)\" that takes ([^:]+) returns ([^:]+):" and 
            replacement as "function $1($2): $3 {"
    
    Note: Variable declarations (use bare assignment - no let/var/const)
    Else if converted contains "Let " and converted contains " be ":
        Note: Handle constructor patterns
        If converted contains "a value of type":
            Set converted to regex_replace with 
                text as converted and 
                pattern as "Let\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s+be\\s+a\\s+value\\s+of\\s+type\\s+([a-zA-Z_][a-zA-Z0-9_]*)" and 
                replacement as "$1 = new $2()"
        Else if converted contains "of type":
            Set converted to regex_replace with 
                text as converted and 
                pattern as "Let\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s+be\\s+of\\s+type\\s+([a-zA-Z_][a-zA-Z0-9_]*)" and 
                replacement as "$1 = new $2()"
        Otherwise:
            Set converted to regex_replace with 
                text as converted and 
                pattern as "Let\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s+be\\s+(.+)" and 
                replacement as "$1 = $2"
    
    Note: Assignment statements (already in bare form)
    Else if converted contains "Set " and converted contains " to ":
        Set converted to regex_replace with 
            text as converted and 
            pattern as "Set\\s+([^\\s]+)\\s+to\\s+(.+)" and 
            replacement as "$1 = $2"
    
    Note: Type declarations
    Else if converted contains "Type called \"":
        Set converted to regex_replace with 
            text as converted and 
            pattern as "Type called \"([^\"]+)\":" and 
            replacement as "type $1 = {"
    
    Note: End statements
    Else if converted is equal to "End Process":
        Set converted to "}"
    Else if converted is equal to "End Type":
        Set converted to "}"
    
    Note: Comments
    Else if converted starts with "Note:":
        Set converted to regex_replace with 
            text as converted and 
            pattern as "Note:\\s*(.+)" and 
            replacement as "// $1"
    
    Return converted

Process called "convert_developer_line_to_canonical" that takes line as String returns String:
    Note: Convert developer syntax line to canonical syntax (handling bare assignments)
    Let converted be line
    
    Note: Function declarations
    If converted contains "function ":
        Set converted to regex_replace with 
            text as converted and 
            pattern as "function\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\(([^)]*)\\)\\s*:\\s*([^{]+)\\s*\\{" and 
            replacement as "Process called \"$1\" that takes $2 returns $3:"
    
    Note: Bare assignments with constructors (x = new Type())
    Else if converted contains " = new " and converted contains "()":
        Set converted to regex_replace with 
            text as converted and 
            pattern as "([a-zA-Z_][a-zA-Z0-9_]*)\\s*=\\s*new\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\(\\)" and 
            replacement as "Let $1 be a value of type $2"
    
    Note: Bare assignments (both declarations and reassignments) 
    Else if regex_matches with text as converted and pattern as "^\\s*[a-zA-Z_][a-zA-Z0-9_.]*\\s*=\\s*.+":
        Note: Check if this looks like a first assignment (declaration) vs reassignment
        Note: Since we can't determine scope here, treat all as Let (canonical form)
        Set converted to regex_replace with 
            text as converted and 
            pattern as "([a-zA-Z_][a-zA-Z0-9_.]*)\\s*=\\s*(.+)" and 
            replacement as "Let $1 be $2"
    
    Note: Type declarations
    Else if converted contains "type " and converted contains " = {":
        Set converted to regex_replace with 
            text as converted and 
            pattern as "type\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*=\\s*\\{" and 
            replacement as "Type called \"$1\":"
    
    Note: Closing braces
    Else if converted is equal to "}":
        Note: Need context to determine if this ends a Process or Type
        Note: For now, assume Process (more common)
        Set converted to "End Process"
    
    Note: Comments
    Else if converted starts with "//":
        Set converted to regex_replace with 
            text as converted and 
            pattern as "//\\s*(.+)" and 
            replacement as "Note: $1"
    
    Return converted

Process called "generate_normalized_output" that takes handler as MixedSyntaxHandler returns String:
    Note: Generate the final normalized code from processed lines
    Let output_lines be list containing
    
    For each processed_line in handler.processed_lines:
        Add processed_line.processed_content to output_lines
    
    Return join_lines with lines as output_lines

Note: Supporting types and utility functions
Type called "SingleLineConversionResult":
    converted_line as String
    success as Boolean
    error_message as String

Process called "create_processed_line" that takes line_num as Integer and content as String and mode as String returns ProcessedLine:
    Return ProcessedLine with
        line_number as line_num,
        original_content as content,
        processed_content as content,
        syntax_mode as mode,
        conversion_applied as false,
        warnings as list containing
    End ProcessedLine

Process called "create_syntax_inconsistency" that takes line_num as Integer and original as String and detected as String and target as String returns SyntaxInconsistency:
    Return SyntaxInconsistency with
        line_number as line_num,
        original_syntax as original,
        detected_mode as detected,
        converted_syntax as "",
        inconsistency_type as detected plus "_to_" plus target
    End SyntaxInconsistency

Process called "find_inconsistency_for_line" that takes handler as MixedSyntaxHandler and line_number as Integer returns Integer:
    For i from 0 to length of handler.syntax_inconsistencies minus 1:
        If handler.syntax_inconsistencies[i].line_number is equal to line_number:
            Return i
    Return negative 1

Process called "count_fixed_inconsistencies" that takes handler as MixedSyntaxHandler returns Integer:
    Let fixed_count be 0
    For each inconsistency in handler.syntax_inconsistencies:
        If inconsistency.converted_syntax is not equal to "":
            Set fixed_count to fixed_count plus 1
    Return fixed_count

Process called "is_empty_or_comment_line" that takes line as String returns Boolean:
    Let trimmed be trim_whitespace with text as line
    Return trimmed is equal to "" or trimmed starts with "Note:" or trimmed starts with "//"

Process called "split_into_lines" that takes text as String returns List[String]:
    Note: Split text into lines, preserving empty lines
    Return string_split with text as text and delimiter as "\n"

Process called "join_lines" that takes lines as List[String] returns String:
    Note: Join lines back into text with newline separators
    Return string_join with strings as lines and separator as "\n"

Process called "trim_whitespace" that takes text as String returns String:
    Note: Remove leading and trailing whitespace
    Return string_trim with text as text

Process called "regex_replace" that takes text as String and pattern as String and replacement as String returns String:
    Note: Replace text using regex pattern
    Import "regex" as Regex
    Try:
        Let regex be Regex.compile with pattern as pattern
        Return Regex.replace with regex as regex and text as text and replacement as replacement
    Catch error:
        Return text

Process called "regex_matches" that takes text as String and pattern as String returns Boolean:
    Note: Check if text matches regex pattern
    Import "regex" as Regex
    Try:
        Let regex be Regex.compile with pattern as pattern
        Return Regex.matches with regex as regex and text as text
    Catch error:
        Return false

Process called "string_split" that takes text as String and delimiter as String returns List[String]:
    Import "strings"
    Return strings.split with text as text and delimiter as delimiter

Process called "string_join" that takes strings as List[String] and separator as String returns String:
    Import "strings"
    Return strings.join with strings as strings and separator as separator

Process called "string_trim" that takes text as String returns String:
    Import "strings"
    Return strings.trim with text as text

Process called "string_from_integer" that takes number as Integer returns String:
    Import "conversions"
    Return conversions.integer_to_string with number as number