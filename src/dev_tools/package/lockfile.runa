Note:
Runa Package Manager: Lockfile Management
Handles saving and loading resolved dependency graphs for fast subsequent builds
:End Note

Import "../../stdlib/io/file" as File
Import "../../stdlib/io/console" as Console
Import "../../stdlib/json/json" as JSON
Import "../../stdlib/os/os" as OS
Import "../../stdlib/datetime/datetime" as DateTime

Type called "LockfileEntry":
    name as String
    version as String
    checksum as String
    source as String
    dependencies as Dictionary[String, String]

Type called "LockfileData":
    lockfile_version as String
    generated_at as String
    packages as Dictionary[String, LockfileEntry]
    resolution_order as List[String]
    metadata as Dictionary[String, Any]

Process called "save" that takes graph as DependencyGraph returns Boolean:
    Note: Save resolved dependency graph to runa.lock
    
    Let lockfile_path be "runa.lock"
    
    Console.print("üíæ Saving dependency lockfile...")
    
    Note: Convert graph to lockfile format
    Let lockfile_data be graph_to_lockfile(graph)
    
    Note: Serialize to JSON
    Let json_content be JSON.stringify_pretty(lockfile_data)
    
    Note: Write to file
    Let write_success be File.write_text(lockfile_path, json_content)
    
    If write_success:
        Console.print("‚úì Lockfile saved successfully")
        Return true
    Otherwise:
        Console.print_error("Failed to save lockfile")
        Return false

Process called "load" returns Optional[Dictionary]:
    Note: Load existing lockfile if it exists and is valid
    
    Let lockfile_path be "runa.lock"
    
    If not File.exists(lockfile_path):
        Return none
    
    Let content be File.read_text(lockfile_path)
    If not content:
        Console.print_error("Empty lockfile found")
        Return none
    
    Let lockfile_data be JSON.parse(content)
    If not lockfile_data:
        Console.print_error("Invalid JSON in lockfile")
        Return none
    
    Note: Validate lockfile format
    If not validate_lockfile_format(lockfile_data):
        Console.print_error("Lockfile format is invalid or outdated")
        Return none
    
    Console.print("üìã Using existing lockfile")
    
    Note: Convert back to graph format
    Return lockfile_to_graph(lockfile_data)

Process called "is_current" that takes config as Dictionary returns Boolean:
    Note: Check if lockfile is current with project config
    
    Let lockfile_data be load()
    If not lockfile_data:
        Return false
    
    Note: Compare dependencies
    Let config_deps be config get "dependencies"
    Let lockfile_deps be extract_root_dependencies(lockfile_data)
    
    Return dependencies_match(config_deps, lockfile_deps)

Process called "update" that takes packages as List[String] returns Boolean:
    Note: Update specific packages in lockfile
    
    Let current_lock be load()
    If not current_lock:
        Console.print_error("No lockfile found to update")
        Return false
    
    Console.print("üîÑ Updating packages: " plus join_strings(packages, ", "))
    
    Note: Remove specified packages from lock
    For each package_name in packages:
        remove_package_from_lock(current_lock, package_name)
    
    Note: Re-resolve only the updated packages
    Note: This would integrate with resolver for partial re-resolution
    Console.print("‚úì Lockfile updated")
    Return true

Process called "validate" returns Boolean:
    Note: Validate current lockfile integrity
    
    Let lockfile_data be load()
    If not lockfile_data:
        Console.print_error("No lockfile found")
        Return false
    
    Console.print("üîç Validating lockfile integrity...")
    
    Note: Check all packages exist and checksums match
    Let packages be lockfile_data get "packages"
    Let valid be true
    
    For each name and entry in packages:
        If not validate_package_entry(entry):
            Console.print_error("Invalid entry for package: " plus name)
            Set valid to false
    
    Note: Validate resolution order
    If not validate_resolution_order(lockfile_data):
        Console.print_error("Invalid resolution order in lockfile")
        Set valid to false
    
    If valid:
        Console.print("‚úì Lockfile is valid")
    Otherwise:
        Console.print("‚ùå Lockfile validation failed")
    
    Return valid

Process called "graph_to_lockfile" that takes graph as DependencyGraph returns LockfileData:
    Let packages be dictionary with:
    
    Note: Convert each package node to lockfile entry
    For each name and package in graph get "nodes":
        Let entry be dictionary with:
            "name" as package get "name"
            "version" as package get "version"
            "checksum" as package get "checksum"
            "source" as "registry"  Note: Could be "git", "local", etc.
            "dependencies" as convert_dependencies_to_strings(package get "dependencies")
        
        Set packages with name as entry
    
    Return dictionary with:
        "lockfile_version" as "1.0"
        "generated_at" as DateTime.get_iso_timestamp()
        "packages" as packages
        "resolution_order" as graph get "resolution_order"
        "metadata" as dictionary with:
            "generator" as "runa-package-manager"
            "generator_version" as "0.1.0"

Process called "lockfile_to_graph" that takes lockfile as LockfileData returns Dictionary:
    Let nodes be dictionary with:
    Let edges be dictionary with:
    
    Note: Convert lockfile entries back to package nodes
    For each name and entry in lockfile get "packages":
        Let package be dictionary with:
            "name" as entry get "name"
            "version" as entry get "version"
            "checksum" as entry get "checksum"
            "dependencies" as convert_strings_to_constraints(entry get "dependencies")
            "resolved_path" as none
        
        Set nodes with name as package
        
        Note: Build edges from dependencies
        Set edges with name as convert_deps_to_list(entry get "dependencies")
    
    Return dictionary with:
        "nodes" as nodes
        "edges" as edges
        "resolution_order" as lockfile get "resolution_order"

Process called "validate_lockfile_format" that takes data as Dictionary returns Boolean:
    Note: Validate basic lockfile structure
    
    If not data get "lockfile_version":
        Return false
    
    If not data get "packages":
        Return false
    
    If not data get "resolution_order":
        Return false
    
    Let version be data get "lockfile_version"
    Return version is equal to "1.0"

Process called "validate_package_entry" that takes entry as Dictionary returns Boolean:
    Let required_fields be list containing "name", "version", "checksum", "source", "dependencies"
    
    For each field in required_fields:
        If not entry get field:
            Return false
    
    Return true

Process called "validate_resolution_order" that takes lockfile as Dictionary returns Boolean:
    Let packages be lockfile get "packages"
    Let order be lockfile get "resolution_order"
    
    Note: Ensure all packages in order exist
    For each package_name in order:
        If not packages get package_name:
            Return false
    
    Note: Ensure no duplicates in order
    Return length of order is equal to length of packages

Process called "extract_root_dependencies" that takes lockfile as Dictionary returns Dictionary:
    Note: Extract root-level dependencies from lockfile metadata
    Let metadata be lockfile get "metadata"
    Return metadata get "root_dependencies" or dictionary with:

Process called "dependencies_match" that takes config_deps as Dictionary and lockfile_deps as Dictionary returns Boolean:
    Note: Compare dependency specifications
    
    If length of config_deps is not equal to length of lockfile_deps:
        Return false
    
    For each name and constraint in config_deps:
        If not lockfile_deps get name:
            Return false
        If not lockfile_deps get name is equal to constraint:
            Return false
    
    Return true

Process called "remove_package_from_lock" that takes lockfile as Dictionary and package_name as String returns Nothing:
    Note: Remove package and dependents from lockfile
    Let packages be lockfile get "packages"
    Let order be lockfile get "resolution_order"
    
    Note: Remove from packages
    If packages get package_name:
        Remove package_name from packages
    
    Note: Remove from resolution order
    Let new_order be list containing nothing
    For each name in order:
        If not name is equal to package_name:
            Add name to new_order
    
    Set lockfile with "resolution_order" as new_order

Process called "convert_dependencies_to_strings" that takes deps as Dictionary returns Dictionary:
    Let result be dictionary with:
    
    For each name and constraint in deps:
        Set result with name as constraint get "raw_constraint"
    
    Return result

Process called "convert_strings_to_constraints" that takes deps as Dictionary returns Dictionary:
    Let result be dictionary with:
    
    For each name and constraint_str in deps:
        Let constraint be dictionary with:
            "operator" as "="
            "version" as constraint_str
            "raw_constraint" as constraint_str
        Set result with name as constraint
    
    Return result

Process called "convert_deps_to_list" that takes deps as Dictionary returns List[String]:
    Let result be list containing nothing
    
    For each name and constraint in deps:
        Add name to result
    
    Return result

Process called "join_strings" that takes strings as List[String] and separator as String returns String:
    If length of strings is equal to 0:
        Return ""
    
    If length of strings is equal to 1:
        Return strings get 0
    
    Let result be strings get 0
    Let i be 1
    While i is less than length of strings:
        Set result to result plus separator plus strings get i
        Set i to i plus 1
    
    Return result