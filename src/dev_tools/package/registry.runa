Note:
Runa Package Registry Client
Handles communication with the Runa Universe package registry
:End Note

Import "../../stdlib/http/client" as HTTP
Import "../../stdlib/json/json" as JSON
Import "../../stdlib/crypto/hash" as Crypto
Import "../../stdlib/io/file" as File
Import "../../stdlib/io/console" as Console
Import "../../stdlib/os/os" as OS

Type called "RegistryConfig":
    url as String
    api_key as Optional[String]
    timeout as Float
    cache_dir as String
    verify_checksums as Boolean

Type called "PackageMetadata":
    name as String
    version as String
    description as String
    authors as List[String]
    license as String
    homepage as Optional[String]
    repository as Optional[String]
    documentation as Optional[String]
    keywords as List[String]
    categories as List[String]
    dependencies as Dictionary[String, String]
    dev_dependencies as Dictionary[String, String]
    checksum as String
    download_url as String
    file_size as Integer
    published_at as String

Process called "fetch_package" that takes name as String and constraint as VersionConstraint returns Dictionary:
    Note: Fetch package metadata from registry
    
    Let config be get_registry_config()
    Let cache_key be name plus "-" plus constraint get "raw_constraint"
    
    Note: Check cache first
    Let cached_result be check_cache(cache_key, config get "cache_dir")
    If cached_result:
        Console.print("  Using cached " plus name plus " " plus cached_result get "version")
        Return cached_result
    
    Note: Build registry API URL
    Let api_url be config get "url" plus "/api/v1/packages/" plus name plus "/versions"
    If constraint get "operator" is not equal to "=":
        Set api_url as api_url plus "?constraint=" plus url_encode(constraint get "raw_constraint")
    
    Console.print("  Fetching " plus name plus " from registry...")
    
    Note: Make HTTP request
    Let headers be dictionary with:
        "User-Agent" as "Runa Package Manager 0.1.0"
        "Accept" as "application/json"
    
    If config get "api_key":
        Set headers with "Authorization" as "Bearer " plus config get "api_key"
    
    Let response be HTTP.get(api_url, headers, config get "timeout")
    
    If not response get "success":
        Return dictionary with:
            "error" as "Failed to fetch from registry: " plus response get "error"
    
    If response get "status_code" is not equal to 200:
        Return dictionary with:
            "error" as "Registry error " plus string_from_integer(response get "status_code") plus ": " plus response get "body"
    
    Note: Parse response
    Let metadata be JSON.parse(response get "body")
    If not metadata:
        Return dictionary with:
            "error" as "Invalid JSON response from registry"
    
    Note: Find best matching version
    Let best_version be find_best_version(metadata get "versions", constraint)
    If not best_version:
        Return dictionary with:
            "error" as "No version found matching " plus constraint get "raw_constraint"
    
    Note: Cache result
    cache_package_metadata(cache_key, best_version, config get "cache_dir")
    
    Return best_version

Process called "publish_package" that takes package_path as String and config as Dictionary returns Dictionary:
    Note: Publish package to registry
    
    Let registry_config be get_registry_config()
    
    If not registry_config get "api_key":
        Return dictionary with:
            "error" as "API key required for publishing. Set RUNA_REGISTRY_TOKEN environment variable."
    
    Console.print("ðŸ“¦ Preparing package for publishing...")
    
    Note: Build package tarball
    Let tarball_result be create_package_tarball(package_path)
    If not tarball_result get "success":
        Return dictionary with:
            "error" as "Failed to create package: " plus tarball_result get "error"
    
    Let tarball_path be tarball_result get "path"
    Let package_size be File.get_size(tarball_path)
    
    Console.print("ðŸ“‹ Package size: " plus format_file_size(package_size))
    
    Note: Calculate checksum
    Let checksum be calculate_file_checksum(tarball_path)
    
    Note: Upload to registry
    Let upload_url be registry_config get "url" plus "/api/v1/packages/publish"
    
    Let form_data be dictionary with:
        "package" as File.read_binary(tarball_path)
        "checksum" as checksum
        "metadata" as JSON.stringify(config)
    
    Let headers be dictionary with:
        "Authorization" as "Bearer " plus registry_config get "api_key"
        "User-Agent" as "Runa Package Manager 0.1.0"
    
    Console.print("ðŸš€ Uploading to registry...")
    
    Let response be HTTP.post_multipart(upload_url, form_data, headers, 30.0)
    
    Note: Clean up temporary tarball
    File.delete(tarball_path)
    
    If not response get "success":
        Return dictionary with:
            "error" as "Upload failed: " plus response get "error"
    
    If response get "status_code" is not equal to 200:
        Return dictionary with:
            "error" as "Publish failed: " plus response get "body"
    
    Let result be JSON.parse(response get "body")
    Console.print("âœ… Package published successfully!")
    Console.print("   Version: " plus result get "version")
    Console.print("   URL: " plus result get "url")
    
    Return dictionary with:
        "success" as true
        "version" as result get "version"
        "url" as result get "url"

Process called "search_packages" that takes query as String and limit as Integer returns List[Dictionary]:
    Note: Search for packages in registry
    
    Let config be get_registry_config()
    Let search_url be config get "url" plus "/api/v1/search?q=" plus url_encode(query) plus "&limit=" plus string_from_integer(limit)
    
    Let response be HTTP.get(search_url, dictionary with "User-Agent" as "Runa Package Manager 0.1.0", config get "timeout")
    
    If not response get "success":
        Console.print_error("Search failed: " plus response get "error")
        Return list containing nothing
    
    Let results be JSON.parse(response get "body")
    Return results get "packages"

Process called "get_registry_config" returns RegistryConfig:
    Note: Load registry configuration from environment and defaults
    
    Let default_url be "https://registry.runalang.org"
    Let registry_url be OS.get_env("RUNA_REGISTRY_URL", default_url)
    Let api_key be OS.get_env("RUNA_REGISTRY_TOKEN", none)
    Let cache_dir be OS.get_home_directory() plus "/.runa/cache"
    
    Note: Ensure cache directory exists
    If not OS.directory_exists(cache_dir):
        OS.create_directory_recursive(cache_dir)
    
    Return dictionary with:
        "url" as registry_url
        "api_key" as api_key
        "timeout" as 10.0
        "cache_dir" as cache_dir
        "verify_checksums" as true

Process called "check_cache" that takes key as String and cache_dir as String returns Optional[Dictionary]:
    Note: Check if cached version exists and is not stale
    
    Let cache_file be cache_dir plus "/" plus key plus ".json"
    
    If not File.exists(cache_file):
        Return none
    
    Let cache_age be File.get_modification_time(cache_file)
    Let current_time be get_current_timestamp()
    
    Note: Cache expires after 1 hour
    If current_time minus cache_age > 3600.0:
        File.delete(cache_file)
        Return none
    
    Let cached_data be JSON.parse(File.read_text(cache_file))
    Return cached_data

Process called "cache_package_metadata" that takes key as String and metadata as Dictionary and cache_dir as String returns Nothing:
    Let cache_file be cache_dir plus "/" plus key plus ".json"
    Let json_data be JSON.stringify(metadata)
    File.write_text(cache_file, json_data)

Process called "find_best_version" that takes versions as List[Dictionary] and constraint as VersionConstraint returns Optional[Dictionary]:
    Note: Find the best version matching the constraint
    
    Let compatible_versions be list containing nothing
    
    For each version_info in versions:
        Let version_str be version_info get "version"
        If versions_compatible(version_str, constraint):
            Add version_info to compatible_versions
    
    If length of compatible_versions is equal to 0:
        Return none
    
    Note: Sort by version (highest first) and return best match
    Let sorted_versions be sort_versions_descending(compatible_versions)
    Return sorted_versions get 0

Process called "create_package_tarball" that takes package_path as String returns Dictionary:
    Note: Create a tarball of the package for publishing
    
    Let tarball_name be "package.tar.gz"
    Let temp_dir be OS.get_temp_directory()
    Let tarball_path be temp_dir plus "/" plus tarball_name
    
    Note: Use tar command to create archive
    Let tar_command be "tar -czf " plus tarball_path plus " -C " plus package_path plus " ."
    Let result be OS.execute_command(tar_command)
    
    If result get "exit_code" is not equal to 0:
        Return dictionary with:
            "success" as false
            "error" as "tar failed: " plus result get "stderr"
    
    Return dictionary with:
        "success" as true
        "path" as tarball_path

Process called "calculate_file_checksum" that takes file_path as String returns String:
    Note: Calculate SHA-256 checksum of file
    Let file_content be File.read_binary(file_path)
    Return Crypto.sha256(file_content)

Process called "format_file_size" that takes bytes as Integer returns String:
    If bytes < 1024:
        Return string_from_integer(bytes) plus " B"
    Otherwise if bytes < 1048576:  Note: 1024 * 1024
        Return string_from_integer(bytes divided by 1024) plus " KB"
    Otherwise:
        Return string_from_integer(bytes divided by 1048576) plus " MB"

Process called "url_encode" that takes str as String returns String:
    Note: Basic URL encoding - replace spaces with %20
    Return str replace " " with "%20"

Process called "sort_versions_descending" that takes versions as List[Dictionary] returns List[Dictionary]:
    Note: Sort versions in descending order (newest first)
    Note: Placeholder - implement proper version sorting
    Return versions

Process called "versions_compatible" that takes version as String and constraint as VersionConstraint returns Boolean:
    Note: Import from resolver - this is a duplicate for now
    Let op be constraint get "operator"
    Let target be constraint get "version"
    
    If op is equal to "=":
        Return version is equal to target
    
    Note: Simplified compatibility check
    Return true

Process called "get_current_timestamp" returns Float:
    Import "../../stdlib/time/time" as Time
    Return Time.get_current_time_seconds

Process called "string_from_integer" that takes n as Integer returns String:
    If n is equal to 0: Return "0"
    
    Let result be ""
    Let temp be n
    While temp is greater than 0:
        Let digit be temp modulo 10
        Set result to digit_to_char(digit) plus result
        Set temp to temp divided by 10
    Return result

Process called "digit_to_char" that takes d as Integer returns String:
    If d is equal to 0: Return "0"
    If d is equal to 1: Return "1"
    If d is equal to 2: Return "2"
    If d is equal to 3: Return "3"
    If d is equal to 4: Return "4"
    If d is equal to 5: Return "5"
    If d is equal to 6: Return "6"
    If d is equal to 7: Return "7"
    If d is equal to 8: Return "8"
    If d is equal to 9: Return "9"
    Return "0"