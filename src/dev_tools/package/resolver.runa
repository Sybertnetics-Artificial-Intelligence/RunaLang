Note:
Runa Package Manager: Dependency Resolver
Sophisticated dependency resolution with version constraints and conflict detection
:End Note

Import "../../stdlib/collections/dict" as Dict
Import "../../stdlib/collections/list" as List
Import "../../stdlib/collections/set" as Set
Import "../../stdlib/string/format" as Format
Import "../../stdlib/io/console" as Console
Import "./registry" as Registry
Import "./lockfile" as Lockfile

Type called "Package":
    name as String
    version as String
    dependencies as Dictionary[String, VersionConstraint]
    dev_dependencies as Dictionary[String, VersionConstraint]
    resolved_path as Optional[String]
    checksum as Optional[String]

Type called "VersionConstraint":
    operator as String  Note: "=", ">=", ">", "<=", "<", "~", "^"
    version as String
    raw_constraint as String

Type called "DependencyGraph":
    nodes as Dictionary[String, Package]
    edges as Dictionary[String, List[String]]
    resolution_order as List[String]

Type called "ResolutionResult":
    success as Boolean
    resolved as Optional[DependencyGraph]
    conflicts as List[ConflictInfo]
    error as Optional[String]

Type called "ConflictInfo":
    package as String
    requested_by as List[String]
    conflicting_versions as List[String]

Process called "resolve_dependencies" that takes config as Dictionary returns ResolutionResult:
    Note: Main entry point for dependency resolution
    
    Let package_name be config get "package" get "name"
    Let package_version be config get "package" get "version"
    
    Note: Check for lockfile first
    Let lockfile_data be Lockfile.load()
    If lockfile_data and not config get "update":
        Console.print("Using lockfile for dependency resolution")
        Return resolve_from_lockfile(lockfile_data)
    
    Console.print("Resolving dependencies for " plus package_name plus " v" plus package_version)
    
    Note: Initialize resolution context
    Let graph be dictionary with:
        "nodes" as dictionary with:
        "edges" as dictionary with:
        "resolution_order" as list containing nothing
    
    Let to_resolve be create_work_queue(config)
    Let resolved be Set.create()
    Let conflicts be list containing nothing
    
    Note: Main resolution loop
    While not List.is_empty(to_resolve):
        Let work_item be List.pop_front(to_resolve)
        Let package_spec be work_item get "spec"
        Let requested_by be work_item get "requested_by"
        
        If Set.contains(resolved, package_spec get "name"):
            Note: Check for version conflicts
            Let existing be graph get "nodes" get package_spec get "name"
            If not versions_compatible(existing get "version", package_spec get "version_constraint"):
                Add create_conflict(package_spec, existing, requested_by) to conflicts
                Continue
        
        Note: Fetch package information from registry
        Let package_info be Registry.fetch_package(package_spec get "name", package_spec get "version_constraint")
        
        If package_info get "error":
            Return dictionary with:
                "success" as false
                "resolved" as none
                "conflicts" as conflicts
                "error" as "Failed to fetch " plus package_spec get "name" plus ": " plus package_info get "error"
        
        Note: Add to graph
        Add package_info to graph
        Set.add(resolved, package_spec get "name")
        
        Note: Queue dependencies for resolution
        For each dep_name and dep_constraint in package_info get "dependencies":
            Let dep_spec be dictionary with:
                "name" as dep_name
                "version_constraint" as dep_constraint
            Let dep_work be dictionary with:
                "spec" as dep_spec
                "requested_by" as package_spec get "name"
            List.push_back(to_resolve, dep_work)
    
    If not List.is_empty(conflicts):
        Return dictionary with:
            "success" as false
            "resolved" as none
            "conflicts" as conflicts
            "error" as "Version conflicts detected"
    
    Note: Topological sort for installation order
    Let resolution_order be topological_sort(graph)
    Set graph with "resolution_order" as resolution_order
    
    Note: Save to lockfile
    Lockfile.save(graph)
    
    Return dictionary with:
        "success" as true
        "resolved" as graph
        "conflicts" as list containing nothing
        "error" as none

Process called "create_work_queue" that takes config as Dictionary returns List[Dictionary]:
    Let queue be list containing nothing
    
    Note: Add direct dependencies
    Let dependencies be config get "dependencies"
    If dependencies:
        For each name and constraint_str in dependencies:
            Let spec be dictionary with:
                "name" as name
                "version_constraint" as parse_version_constraint(constraint_str)
            Let work be dictionary with:
                "spec" as spec
                "requested_by" as "root"
            List.push_back(queue, work)
    
    Note: Add dev dependencies if in dev mode
    If config get "include_dev":
        Let dev_deps be config get "dev-dependencies"
        If dev_deps:
            For each name and constraint_str in dev_deps:
                Let spec be dictionary with:
                    "name" as name
                    "version_constraint" as parse_version_constraint(constraint_str)
                Let work be dictionary with:
                    "spec" as spec
                    "requested_by" as "root-dev"
                List.push_back(queue, work)
    
    Return queue

Process called "parse_version_constraint" that takes constraint as String returns VersionConstraint:
    Note: Parse version constraint strings like "^1.2.3", ">=2.0.0", "~0.5.0"
    
    If constraint starts with "^":
        Return dictionary with:
            "operator" as "^"
            "version" as constraint substring from 1
            "raw_constraint" as constraint
    Otherwise if constraint starts with "~":
        Return dictionary with:
            "operator" as "~"
            "version" as constraint substring from 1
            "raw_constraint" as constraint
    Otherwise if constraint starts with ">=":
        Return dictionary with:
            "operator" as ">="
            "version" as constraint substring from 2
            "raw_constraint" as constraint
    Otherwise if constraint starts with ">":
        Return dictionary with:
            "operator" as ">"
            "version" as constraint substring from 1
            "raw_constraint" as constraint
    Otherwise if constraint starts with "<=":
        Return dictionary with:
            "operator" as "<="
            "version" as constraint substring from 2
            "raw_constraint" as constraint
    Otherwise if constraint starts with "<":
        Return dictionary with:
            "operator" as "<"
            "version" as constraint substring from 1
            "raw_constraint" as constraint
    Otherwise:
        Return dictionary with:
            "operator" as "="
            "version" as constraint
            "raw_constraint" as constraint

Process called "versions_compatible" that takes version as String and constraint as VersionConstraint returns Boolean:
    Let op be constraint get "operator"
    Let target be constraint get "version"
    
    If op is equal to "=":
        Return version is equal to target
    Otherwise if op is equal to "^":
        Return check_caret_compatibility(version, target)
    Otherwise if op is equal to "~":
        Return check_tilde_compatibility(version, target)
    Otherwise if op is equal to ">=":
        Return version_greater_or_equal(version, target)
    Otherwise if op is equal to ">":
        Return version_greater(version, target)
    Otherwise if op is equal to "<=":
        Return version_less_or_equal(version, target)
    Otherwise if op is equal to "<":
        Return version_less(version, target)
    
    Return false

Process called "check_caret_compatibility" that takes version as String and target as String returns Boolean:
    Note: Caret allows patch and minor updates (^1.2.3 matches 1.2.3 to <2.0.0)
    Let v_parts be split_version(version)
    Let t_parts be split_version(target)
    
    If v_parts get "major" is not equal to t_parts get "major":
        Return false
    
    If v_parts get "major" is equal to 0:
        Note: For 0.x.y, only patch updates allowed
        Return v_parts get "minor" is equal to t_parts get "minor" and
               v_parts get "patch" >= t_parts get "patch"
    
    Return version_greater_or_equal(version, target)

Process called "check_tilde_compatibility" that takes version as String and target as String returns Boolean:
    Note: Tilde allows patch updates only (~1.2.3 matches 1.2.3 to <1.3.0)
    Let v_parts be split_version(version)
    Let t_parts be split_version(target)
    
    Return v_parts get "major" is equal to t_parts get "major" and
           v_parts get "minor" is equal to t_parts get "minor" and
           v_parts get "patch" >= t_parts get "patch"

Process called "split_version" that takes version as String returns Dictionary:
    Note: Parse "1.2.3" into major, minor, patch
    Let parts be split_string(version, ".")
    Return dictionary with:
        "major" as parse_int(parts get 0)
        "minor" as parse_int(parts get 1)
        "patch" as parse_int(parts get 2)

Process called "topological_sort" that takes graph as DependencyGraph returns List[String]:
    Note: Kahn's algorithm for topological sorting
    Let result be list containing nothing
    Let in_degree be dictionary with:
    Let queue be list containing nothing
    
    Note: Calculate in-degrees
    For each node_name and node in graph get "nodes":
        Set in_degree with node_name as 0
    
    For each source and targets in graph get "edges":
        For each target in targets:
            Set in_degree with target as in_degree get target plus 1
    
    Note: Find nodes with no dependencies
    For each node_name and degree in in_degree:
        If degree is equal to 0:
            List.push_back(queue, node_name)
    
    Note: Process queue
    While not List.is_empty(queue):
        Let current be List.pop_front(queue)
        List.push_back(result, current)
        
        Let edges be graph get "edges" get current
        If edges:
            For each neighbor in edges:
                Set in_degree with neighbor as in_degree get neighbor minus 1
                If in_degree get neighbor is equal to 0:
                    List.push_back(queue, neighbor)
    
    Return result

Process called "create_conflict" that takes spec as Dictionary and existing as Package and requested_by as String returns ConflictInfo:
    Return dictionary with:
        "package" as spec get "name"
        "requested_by" as list containing requested_by, "existing"
        "conflicting_versions" as list containing spec get "version_constraint" get "raw_constraint", existing get "version"

Process called "resolve_from_lockfile" that takes lockfile as Dictionary returns ResolutionResult:
    Note: Fast path - use previously resolved dependencies
    Return dictionary with:
        "success" as true
        "resolved" as lockfile get "graph"
        "conflicts" as list containing nothing
        "error" as none

Process called "version_greater_or_equal" that takes v1 as String and v2 as String returns Boolean:
    Return compare_versions(v1, v2) >= 0

Process called "version_greater" that takes v1 as String and v2 as String returns Boolean:
    Return compare_versions(v1, v2) > 0

Process called "version_less_or_equal" that takes v1 as String and v2 as String returns Boolean:
    Return compare_versions(v1, v2) <= 0

Process called "version_less" that takes v1 as String and v2 as String returns Boolean:
    Return compare_versions(v1, v2) < 0

Process called "compare_versions" that takes v1 as String and v2 as String returns Integer:
    Let parts1 be split_version(v1)
    Let parts2 be split_version(v2)
    
    If parts1 get "major" > parts2 get "major": Return 1
    If parts1 get "major" < parts2 get "major": Return -1
    
    If parts1 get "minor" > parts2 get "minor": Return 1
    If parts1 get "minor" < parts2 get "minor": Return -1
    
    If parts1 get "patch" > parts2 get "patch": Return 1
    If parts1 get "patch" < parts2 get "patch": Return -1
    
    Return 0

Process called "split_string" that takes str as String and delimiter as String returns List[String]:
    Note: Placeholder for string splitting
    Return list containing "1", "0", "0"

Process called "parse_int" that takes str as String returns Integer:
    Note: Placeholder for string to integer parsing
    If str is equal to "0": Return 0
    If str is equal to "1": Return 1
    If str is equal to "2": Return 2
    Return 0