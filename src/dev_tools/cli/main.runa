Note:
Runa Unified CLI Tool
Main entry point for the Runa development experience.
Handles all commands: build, run, test, package management, and more.
:End Note

Import "../../stdlib/os/os" as OS
Import "../../stdlib/io/console" as Console
Import "../../stdlib/collections/dict" as Dict
Import "../../stdlib/string/format" as StringFormat
Import "./commands/commands" as Commands
Import "./parser" as Parser
Import "./mode_support" as ModeSupport

Type called "CLIContext":
    args as List[String]
    command as String
    subcommand as Optional[String]
    flags as Dictionary[String, Any]
    project_root as Optional[String]
    config as Dictionary[String, Any]
    verbosity as Integer
    syntax_mode as ModeConfiguration      Note: Resolved syntax mode configuration

Process called "main" that takes args as List[String] returns Integer:
    Note: Main entry point for the Runa CLI
    
    Note: Parse arguments using the new parser
    Let parsed_args be Parser.parse_arguments(args)
    
    Note: Show help if requested or no command provided
    If parsed_args get "help_requested":
        Let help_text be Parser.get_help_text(parsed_args get "command")
        Console.print(help_text)
        Return 0
    
    Note: Validate arguments
    Let validation be Parser.validate_arguments(parsed_args)
    If not validation get "valid":
        Console.print_error("Invalid arguments:")
        For each error in validation get "errors":
            Console.print_error("  " plus error)
        Console.print("")
        Let help_text be Parser.get_help_text(parsed_args get "command")
        Console.print(help_text)
        Return 1
    
    Note: Validate mode flags don't conflict
    Let mode_validation be ModeSupport.validate_mode_flags(parsed_args get "flags")
    If not mode_validation.is_valid:
        Console.print_error(mode_validation.error)
        Return 1
    
    Note: Build CLI context
    Let context be build_cli_context(parsed_args)
    
    Note: Route to appropriate command handler
    Let command be parsed_args get "command"
    If command is equal to "new":
        Return Commands.handle_new(context)
    Otherwise if command is equal to "build":
        Return Commands.handle_build(context)
    Otherwise if command is equal to "run":
        Return Commands.handle_run(context)
    Otherwise if command is equal to "test":
        Return Commands.handle_test(context)
    Otherwise if command is equal to "get":
        Return Commands.handle_get(context)
    Otherwise if command is equal to "publish":
        Return Commands.handle_publish(context)
    Otherwise if command is equal to "doctor":
        Return Commands.handle_doctor(context)
    Otherwise if command is equal to "serve":
        Return Commands.handle_serve(context)
    Otherwise if command is equal to "version":
        Return show_version()
    Otherwise:
        Console.print_error("Unknown command: " plus command)
        Let help_text be Parser.get_help_text(none)
        Console.print(help_text)
        Return 1

Process called "build_cli_context" that takes parsed_args as ParsedArgs returns CLIContext:
    Note: Build CLI context from parsed arguments
    
    Let project_root be find_project_root()
    Let config be load_project_config(project_root)
    
    Note: Create base context
    Let context be dictionary with:
        "args" as parsed_args get "arguments"
        "command" as parsed_args get "command"
        "subcommand" as parsed_args get "subcommand"
        "flags" as parsed_args get "flags"
        "options" as parsed_args get "options"
        "project_root" as project_root
        "config" as config
        "verbosity" as get_verbosity_level(parsed_args get "flags")
    
    Note: Resolve syntax mode configuration
    Let mode_config be ModeSupport.resolve_syntax_mode(context)
    Set context["syntax_mode"] to mode_config
    
    Note: Display mode information if verbose
    If context get "verbosity" greater than 0:
        Let mode_info be ModeSupport.format_mode_info(mode_config)
        Console.print(mode_info)
    End If
    
    Return context

Process called "get_verbosity_level" that takes flags as Dictionary returns Integer:
    If flags get "quiet":
        Return -1
    Otherwise if flags get "verbose":
        Return 1
    Otherwise:
        Return 0

Process called "find_project_root" returns Optional[String]:
    Note: Search for runa.toml in current and parent directories
    Let current_dir be OS.get_current_directory()
    
    While current_dir is not equal to "/":
        Let config_path be current_dir plus "/runa.toml"
        If OS.file_exists(config_path):
            Return current_dir
        Set current_dir as OS.get_parent_directory(current_dir)
    
    Return none

Process called "load_project_config" that takes project_root as Optional[String] returns Dictionary[String, Any]:
    If project_root is none:
        Return dictionary with:
            "name" as "unnamed"
            "version" as "0.0.1"
    
    Let config_path be project_root plus "/runa.toml"
    If OS.file_exists(config_path):
        Return parse_toml_file(config_path)
    
    Return dictionary with:
        "name" as "unnamed"
        "version" as "0.0.1"

Process called "show_version" returns Integer:
    Console.print("Runa " plus RUNA_VERSION)
    Console.print("The AI-First Programming Language")
    Return 0

Process called "show_help" returns Integer:
    Console.print("Runa - The AI-First Programming Language")
    Console.print("")
    Console.print("Usage: runa <command> [options]")
    Console.print("")
    Console.print("Commands:")
    Console.print("  new <name>      Create a new Runa project")
    Console.print("  build           Compile the current project")
    Console.print("  run             Build and run the current project")
    Console.print("  test            Run project tests")
    Console.print("  get <package>   Add a dependency")
    Console.print("  publish         Publish package to registry")
    Console.print("  doctor          AI-powered code analysis")
    Console.print("  serve           Start installer server")
    Console.print("  version         Show version information")
    Console.print("  help            Show this help message")
    Console.print("")
    Console.print("Options:")
    Console.print("  --release       Build in release mode")
    Console.print("  --verbose       Verbose output")
    Console.print("  --quiet         Minimal output")
    Console.print("")
    Console.print("Examples:")
    Console.print("  runa new my_project")
    Console.print("  runa build --release")
    Console.print("  runa doctor --deep-ai")
    Return 0

Process called "parse_toml_file" that takes path as String returns Dictionary[String, Any]:
    Note: Simple TOML parser - replace with proper implementation
    Return dictionary with:
        "name" as "example-project"
        "version" as "1.0.0"
        "dependencies" as dictionary with:

Constant RUNA_VERSION as String with value "0.1.0-alpha"