Note:
Runa CLI Mode Support Module
Handles Canon/Developer syntax mode integration for the CLI

This module provides:
- Mode flag parsing and validation
- Mode configuration management
- Integration with compiler pipeline
- Mode persistence and preferences
- Default mode detection
:End Note

Import "../../stdlib/collections/dict" as Dict
Import "../../stdlib/string/utils" as StringUtils
Import "../../stdlib/io/file" as File
Import "../../stdlib/os/os" as OS

Note: =====================================================================
Note: MODE CONFIGURATION TYPES
Note: =====================================================================

Type called "SyntaxMode":
    name as String                    Note: "canon" or "developer"
    is_valid as Boolean
    is_default as Boolean
End Type

Type called "ModeConfiguration":
    cli_mode as Optional[String]      Note: From --canon or --developer flag
    project_mode as Optional[String]   Note: From runa.toml
    user_mode as Optional[String]      Note: From ~/.runa/config
    resolved_mode as String            Note: Final resolved mode
    source as String                   Note: Where mode came from
End Type

Type called "ModePreferences":
    default_mode as String
    project_overrides as Dictionary[String, String]
    last_used_mode as String
    auto_detect as Boolean
End Type

Note: =====================================================================
Note: MODE CONSTANTS
Note: =====================================================================

Constant CANON_MODE as String is "canon"
Constant DEVELOPER_MODE as String is "developer"
Constant DEFAULT_MODE as String is "canon"

Constant MODE_FLAGS as List[String] is list containing "--canon", "--developer"

Note: =====================================================================
Note: MODE DETECTION AND RESOLUTION
Note: =====================================================================

@Reasoning
    Mode resolution follows a priority hierarchy:
    1. CLI flags (highest priority)
    2. Project configuration (runa.toml)
    3. User preferences (~/.runa/config)
    4. System default (canon mode)
@End Reasoning

Process called "resolve_syntax_mode" that takes context as Dictionary returns ModeConfiguration:
    @Implementation
        Determine the syntax mode to use based on various configuration sources.
        CLI flags take precedence, followed by project config, then user preferences.
    @End Implementation
    
    Let config be ModeConfiguration with
        cli_mode as extract_cli_mode(context get "flags"),
        project_mode as extract_project_mode(context get "config"),
        user_mode as load_user_mode_preference(),
        resolved_mode as DEFAULT_MODE,
        source as "default"
    End ModeConfiguration
    
    Note: Apply priority hierarchy
    If config.cli_mode is not None:
        Set config.resolved_mode to config.cli_mode
        Set config.source to "cli"
    Otherwise If config.project_mode is not None:
        Set config.resolved_mode to config.project_mode
        Set config.source to "project"
    Otherwise If config.user_mode is not None:
        Set config.resolved_mode to config.user_mode
        Set config.source to "user"
    End If
    
    Note: Validate the resolved mode
    If Not validate_mode(config.resolved_mode):
        Set config.resolved_mode to DEFAULT_MODE
        Set config.source to "default (invalid mode corrected)"
    End If
    
    Return config
End Process

Process called "extract_cli_mode" that takes flags as Dictionary returns Optional[String]:
    @Implementation
        Extract syntax mode from CLI flags.
        Returns None if no mode flag is present.
    @End Implementation
    
    If flags contains "--canon" Or flags contains "canon":
        Return CANON_MODE
    Otherwise If flags contains "--developer" Or flags contains "developer":
        Return DEVELOPER_MODE
    Otherwise:
        Return None
    End If
End Process

Process called "extract_project_mode" that takes config as Dictionary returns Optional[String]:
    @Implementation
        Extract syntax mode from project configuration (runa.toml).
        Looks for [syntax] section with default_mode setting.
    @End Implementation
    
    If config contains "syntax":
        Let syntax_config be config get "syntax"
        If syntax_config contains "default_mode":
            Return syntax_config get "default_mode"
        End If
    End If
    
    Return None
End Process

Process called "load_user_mode_preference" returns Optional[String]:
    @Implementation
        Load user's global mode preference from ~/.runa/config.
        Returns None if no preference file exists.
    @End Implementation
    
    Let home_dir be OS.get_home_directory()
    Let config_path be home_dir concatenated with "/.runa/config"
    
    If Not File.exists(config_path):
        Return None
    End If
    
    Try:
        Let config_content be File.read_text(config_path)
        Let config be parse_config_file(config_content)
        
        If config contains "syntax":
            Let syntax_section be config get "syntax"
            If syntax_section contains "default_mode":
                Return syntax_section get "default_mode"
            End If
        End If
    Catch error:
        Note: Silently ignore config parsing errors
        Return None
    End Try
    
    Return None
End Process

Note: =====================================================================
Note: MODE VALIDATION
Note: =====================================================================

Process called "validate_mode" that takes mode as String returns Boolean:
    @Implementation
        Validate that a mode string is one of the supported syntax modes.
    @End Implementation
    
    Return StringUtils.equals(mode, CANON_MODE) Or 
           StringUtils.equals(mode, DEVELOPER_MODE)
End Process

Process called "validate_mode_flags" that takes flags as Dictionary returns ValidationResult:
    @Implementation
        Ensure that conflicting mode flags aren't specified.
        Returns error if both --canon and --developer are present.
    @End Implementation
    
    Let has_canon be flags contains "--canon" Or flags contains "canon"
    Let has_developer be flags contains "--developer" Or flags contains "developer"
    
    If has_canon And has_developer:
        Return ValidationResult with
            is_valid as False,
            error as "Cannot specify both --canon and --developer flags"
        End ValidationResult
    End If
    
    Return ValidationResult with
        is_valid as True,
        error as None
    End ValidationResult
End Process

Note: =====================================================================
Note: MODE APPLICATION TO COMPILER
Note: =====================================================================

Process called "apply_mode_to_compiler_options" that takes options as Dictionary, mode_config as ModeConfiguration returns Dictionary:
    @Implementation
        Add syntax mode configuration to compiler options.
        This ensures the mode is passed through the compilation pipeline.
    @End Implementation
    
    Note: Add mode to compiler options
    Set options["syntax_mode"] to mode_config.resolved_mode
    Set options["mode_source"] to mode_config.source
    
    Note: Add mode metadata for debugging
    Set options["mode_metadata"] to Dictionary with
        "cli_mode" as mode_config.cli_mode,
        "project_mode" as mode_config.project_mode,
        "user_mode" as mode_config.user_mode
    End Dictionary
    
    Return options
End Process

Note: =====================================================================
Note: MODE PERSISTENCE
Note: =====================================================================

Process called "save_user_mode_preference" that takes mode as String returns Boolean:
    @Implementation
        Save user's mode preference to ~/.runa/config.
        Creates the config file if it doesn't exist.
    @End Implementation
    
    If Not validate_mode(mode):
        Return False
    End If
    
    Let home_dir be OS.get_home_directory()
    Let runa_dir be home_dir concatenated with "/.runa"
    Let config_path be runa_dir concatenated with "/config"
    
    Note: Ensure .runa directory exists
    If Not File.directory_exists(runa_dir):
        File.create_directory(runa_dir)
    End If
    
    Note: Load existing config or create new
    Let config be Dictionary()
    If File.exists(config_path):
        Try:
            Let existing_content be File.read_text(config_path)
            Set config to parse_config_file(existing_content)
        Catch error:
            Note: Start fresh if existing config is corrupted
            Set config to Dictionary()
        End Try
    End If
    
    Note: Update syntax section
    If Not config contains "syntax":
        Set config["syntax"] to Dictionary()
    End If
    
    Let syntax_section be config get "syntax"
    Set syntax_section["default_mode"] to mode
    Set syntax_section["last_updated"] to OS.get_current_timestamp()
    
    Note: Write updated config
    Try:
        Let config_content be format_config_file(config)
        File.write_text(config_path, config_content)
        Return True
    Catch error:
        Return False
    End Try
End Process

Process called "save_project_mode_preference" that takes project_root as String, mode as String returns Boolean:
    @Implementation
        Save mode preference to project's runa.toml file.
        Updates existing file or creates section if needed.
    @End Implementation
    
    If Not validate_mode(mode):
        Return False
    End If
    
    Let config_path be project_root concatenated with "/runa.toml"
    
    If Not File.exists(config_path):
        Return False
    End If
    
    Try:
        Let config_content be File.read_text(config_path)
        Let config be parse_toml_file(config_content)
        
        Note: Add or update syntax section
        If Not config contains "syntax":
            Set config["syntax"] to Dictionary()
        End If
        
        Let syntax_section be config get "syntax"
        Set syntax_section["default_mode"] to mode
        
        Let updated_content be format_toml_file(config)
        File.write_text(config_path, updated_content)
        
        Return True
    Catch error:
        Return False
    End Try
End Process

Note: =====================================================================
Note: MODE INFORMATION DISPLAY
Note: =====================================================================

Process called "format_mode_info" that takes mode_config as ModeConfiguration returns String:
    @Implementation
        Format mode configuration for display to user.
        Shows resolved mode and where it came from.
    @End Implementation
    
    Let mode_name be "Canonical" if StringUtils.equals(mode_config.resolved_mode, CANON_MODE) 
                     else "Developer"
    
    Let source_desc be match mode_config.source:
        When "cli": "command line flag"
        When "project": "project configuration"
        When "user": "user preferences"
        When "default": "system default"
        Otherwise: mode_config.source
    End Match
    
    Return "Syntax Mode: " concatenated with mode_name concatenated with 
           " (from " concatenated with source_desc concatenated with ")"
End Process

Note: =====================================================================
Note: UTILITY TYPES
Note: =====================================================================

Type called "ValidationResult":
    is_valid as Boolean
    error as Optional[String]
End Type

Note: =====================================================================
Note: CONFIG FILE PARSING HELPERS
Note: =====================================================================

Process called "parse_config_file" that takes content as String returns Dictionary:
    @Implementation
        Parse a simple key=value config file format.
        Supports [sections] and # comments.
    @End Implementation
    
    Let config be Dictionary()
    Let current_section be "global"
    Let lines be StringUtils.split_lines(content)
    
    For line in lines:
        Let trimmed be StringUtils.trim(line)
        
        Note: Skip empty lines and comments
        If StringUtils.is_empty(trimmed) Or StringUtils.starts_with(trimmed, "#"):
            Continue
        End If
        
        Note: Check for section header
        If StringUtils.starts_with(trimmed, "[") And StringUtils.ends_with(trimmed, "]"):
            Set current_section to StringUtils.substring(trimmed, 1, StringUtils.length(trimmed) - 1)
            If Not config contains current_section:
                Set config[current_section] to Dictionary()
            End If
            Continue
        End If
        
        Note: Parse key=value pair
        Let parts be StringUtils.split(trimmed, "=", 2)
        If length of parts equals 2:
            Let key be StringUtils.trim(parts[0])
            Let value be StringUtils.trim(parts[1])
            
            If StringUtils.equals(current_section, "global"):
                Set config[key] to value
            Otherwise:
                Let section be config get current_section
                Set section[key] to value
            End If
        End If
    End For
    
    Return config
End Process

Process called "format_config_file" that takes config as Dictionary returns String:
    @Implementation
        Format a config dictionary into simple key=value format.
        Includes [sections] for nested dictionaries.
    @End Implementation
    
    Let lines be List()
    
    Note: Write global entries first
    For key, value in config:
        If Not value is Dictionary:
            Append key concatenated with "=" concatenated with string_from(value) to lines
        End If
    End For
    
    Note: Write sections
    For key, value in config:
        If value is Dictionary:
            Append "" to lines
            Append "[" concatenated with key concatenated with "]" to lines
            For sub_key, sub_value in value:
                Append sub_key concatenated with "=" concatenated with string_from(sub_value) to lines
            End For
        End If
    End For
    
    Return StringUtils.join_lines(lines)
End Process

Note: Placeholder for TOML parsing (would use proper TOML library in production)
Process called "parse_toml_file" that takes content as String returns Dictionary:
    Note: This is a simplified implementation
    Return parse_config_file(content)
End Process

Process called "format_toml_file" that takes config as Dictionary returns String:
    Note: This is a simplified implementation
    Return format_config_file(config)
End Process