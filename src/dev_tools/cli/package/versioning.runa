Note:
Runa Package Versioning System
Handles semantic versioning (SemVer) parsing, comparison, and constraint matching
:End Note

Import "../../../stdlib/string/text" as Text
Import "../../../stdlib/collections/list" as List

Type called "Version":
    major as Integer
    minor as Integer
    patch as Integer
    prerelease as Optional[String]
    build_metadata as Optional[String]
    raw as String

Type called "VersionRange":
    operator as String  Note: "=", ">=", ">", "<=", "<", "^", "~", "*"
    version as Version
    raw_constraint as String

Process called "parse_version" that takes version_str as String returns Version:
    Note: Parse semantic version string (e.g., "1.2.3-alpha+build.1")
    
    Let clean_version be version_str
    Let prerelease be none
    Let build_metadata be none
    
    Note: Extract build metadata (after +)
    If clean_version contains "+":
        Let parts be split_on_plus(clean_version)
        Set clean_version to parts get 0
        Set build_metadata to parts get 1
    
    Note: Extract prerelease (after -)
    If clean_version contains "-":
        Let parts be split_on_dash(clean_version)
        Set clean_version to parts get 0
        Set prerelease to parts get 1
    
    Note: Parse major.minor.patch
    Let version_parts be split_on_dot(clean_version)
    
    If length of version_parts is less than 3:
        Note: Handle incomplete versions (e.g., "1.2" -> "1.2.0")
        While length of version_parts is less than 3:
            Add "0" to version_parts
    
    Let major be string_to_integer(version_parts get 0)
    Let minor be string_to_integer(version_parts get 1)  
    Let patch be string_to_integer(version_parts get 2)
    
    Return dictionary with:
        "major" as major
        "minor" as minor
        "patch" as patch
        "prerelease" as prerelease
        "build_metadata" as build_metadata
        "raw" as version_str

Process called "parse_version_constraint" that takes constraint_str as String returns VersionRange:
    Note: Parse version constraint (e.g., "^1.2.3", ">=2.0.0", "~0.5.0")
    
    Let operator be "="
    Let version_str be constraint_str
    
    Note: Detect constraint operators
    If constraint_str starts with "^":
        Set operator to "^"
        Set version_str to constraint_str substring from 1
    Otherwise if constraint_str starts with "~":
        Set operator to "~"
        Set version_str to constraint_str substring from 1
    Otherwise if constraint_str starts with ">=":
        Set operator to ">="
        Set version_str to constraint_str substring from 2
    Otherwise if constraint_str starts with "<=":
        Set operator to "<="
        Set version_str to constraint_str substring from 2
    Otherwise if constraint_str starts with ">":
        Set operator to ">"
        Set version_str to constraint_str substring from 1
    Otherwise if constraint_str starts with "<":
        Set operator to "<"
        Set version_str to constraint_str substring from 1
    Otherwise if constraint_str is equal to "*":
        Set operator to "*"
        Set version_str to "0.0.0"
    
    Let version be parse_version(version_str)
    
    Return dictionary with:
        "operator" as operator
        "version" as version
        "raw_constraint" as constraint_str

Process called "version_satisfies" that takes version as Version and constraint as VersionRange returns Boolean:
    Note: Check if version satisfies the constraint
    
    Let op be constraint get "operator"
    Let target be constraint get "version"
    
    If op is equal to "=":
        Return versions_equal(version, target)
    Otherwise if op is equal to ">=":
        Return version_greater_or_equal(version, target)
    Otherwise if op is equal to ">":
        Return version_greater(version, target)
    Otherwise if op is equal to "<=":
        Return version_less_or_equal(version, target)
    Otherwise if op is equal to "<":
        Return version_less(version, target)
    Otherwise if op is equal to "^":
        Return caret_satisfies(version, target)
    Otherwise if op is equal to "~":
        Return tilde_satisfies(version, target)
    Otherwise if op is equal to "*":
        Return true
    
    Return false

Process called "caret_satisfies" that takes version as Version and target as Version returns Boolean:
    Note: Caret range allows patch and minor updates (^1.2.3 matches >=1.2.3 <2.0.0)
    
    If version get "major" is not equal to target get "major":
        Return false
    
    Note: For 0.x.y versions, only patch updates are allowed
    If target get "major" is equal to 0:
        If version get "minor" is not equal to target get "minor":
            Return false
        
        Note: For 0.0.x, no updates are allowed except build metadata
        If target get "minor" is equal to 0:
            Return version get "patch" is equal to target get "patch"
        
        Return version get "patch" >= target get "patch"
    
    Note: For 1.x.y+, minor and patch updates are allowed
    Return version_greater_or_equal(version, target)

Process called "tilde_satisfies" that takes version as Version and target as Version returns Boolean:
    Note: Tilde range allows patch updates only (~1.2.3 matches >=1.2.3 <1.3.0)
    
    Return version get "major" is equal to target get "major" and
           version get "minor" is equal to target get "minor" and
           version get "patch" >= target get "patch"

Process called "versions_equal" that takes v1 as Version and v2 as Version returns Boolean:
    Return v1 get "major" is equal to v2 get "major" and
           v1 get "minor" is equal to v2 get "minor" and
           v1 get "patch" is equal to v2 get "patch" and
           prereleases_equal(v1 get "prerelease", v2 get "prerelease")

Process called "version_greater" that takes v1 as Version and v2 as Version returns Boolean:
    Let comparison be compare_versions(v1, v2)
    Return comparison is greater than 0

Process called "version_greater_or_equal" that takes v1 as Version and v2 as Version returns Boolean:
    Let comparison be compare_versions(v1, v2)
    Return comparison >= 0

Process called "version_less" that takes v1 as Version and v2 as Version returns Boolean:
    Let comparison be compare_versions(v1, v2)
    Return comparison is less than 0

Process called "version_less_or_equal" that takes v1 as Version and v2 as Version returns Boolean:
    Let comparison be compare_versions(v1, v2)
    Return comparison <= 0

Process called "compare_versions" that takes v1 as Version and v2 as Version returns Integer:
    Note: Compare versions (-1: v1 < v2, 0: v1 = v2, 1: v1 > v2)
    
    Note: Compare major version
    If v1 get "major" > v2 get "major": Return 1
    If v1 get "major" < v2 get "major": Return -1
    
    Note: Compare minor version
    If v1 get "minor" > v2 get "minor": Return 1
    If v1 get "minor" < v2 get "minor": Return -1
    
    Note: Compare patch version
    If v1 get "patch" > v2 get "patch": Return 1
    If v1 get "patch" < v2 get "patch": Return -1
    
    Note: Compare prerelease versions
    Return compare_prereleases(v1 get "prerelease", v2 get "prerelease")

Process called "compare_prereleases" that takes pre1 as Optional[String] and pre2 as Optional[String] returns Integer:
    Note: Compare prerelease versions according to SemVer rules
    
    Note: No prerelease has higher precedence than prerelease
    If not pre1 and not pre2: Return 0
    If not pre1 and pre2: Return 1
    If pre1 and not pre2: Return -1
    
    Note: Both have prereleases - compare lexically
    If pre1 < pre2: Return -1
    If pre1 > pre2: Return 1
    Return 0

Process called "prereleases_equal" that takes pre1 as Optional[String] and pre2 as Optional[String] returns Boolean:
    If not pre1 and not pre2: Return true
    If not pre1 or not pre2: Return false
    Return pre1 is equal to pre2

Process called "is_valid_version" that takes version_str as String returns Boolean:
    Note: Validate version string format
    
    If length of version_str is equal to 0:
        Return false
    
    Note: Try to parse the version
    Let version be parse_version(version_str)
    
    Note: Basic validation - all parts should be non-negative
    Return version get "major" >= 0 and
           version get "minor" >= 0 and
           version get "patch" >= 0

Process called "increment_version" that takes version as Version and part as String returns Version:
    Note: Increment version part (major, minor, or patch)
    
    Let new_version be version
    
    If part is equal to "major":
        Set new_version with "major" as version get "major" plus 1
        Set new_version with "minor" as 0
        Set new_version with "patch" as 0
        Set new_version with "prerelease" as none
    Otherwise if part is equal to "minor":
        Set new_version with "minor" as version get "minor" plus 1
        Set new_version with "patch" as 0
        Set new_version with "prerelease" as none
    Otherwise if part is equal to "patch":
        Set new_version with "patch" as version get "patch" plus 1
        Set new_version with "prerelease" as none
    
    Note: Update raw version string
    Let raw be version_to_string(new_version)
    Set new_version with "raw" as raw
    
    Return new_version

Process called "version_to_string" that takes version as Version returns String:
    Note: Convert version back to string format
    
    Let base be string_from_integer(version get "major") plus "." plus
               string_from_integer(version get "minor") plus "." plus
               string_from_integer(version get "patch")
    
    If version get "prerelease":
        Set base to base plus "-" plus version get "prerelease"
    
    If version get "build_metadata":
        Set base to base plus "+" plus version get "build_metadata"
    
    Return base

Process called "get_latest_version" that takes versions as List[Version] returns Optional[Version]:
    Note: Find the latest (highest) version from a list
    
    If length of versions is equal to 0:
        Return none
    
    Let latest be versions get 0
    
    For each version in versions:
        If version_greater(version, latest):
            Set latest to version
    
    Return latest

Process called "sort_versions_descending" that takes versions as List[Version] returns List[Version]:
    Note: Sort versions in descending order (latest first)
    Note: Simplified bubble sort - replace with proper sorting algorithm
    
    Let sorted_versions be versions
    Let n be length of sorted_versions
    
    For i from 0 to n minus 2:
        For j from 0 to n minus i minus 2:
            Let current be sorted_versions get j
            Let next be sorted_versions get j plus 1
            
            If version_less(current, next):
                Note: Swap versions
                Set sorted_versions at j to next
                Set sorted_versions at j plus 1 to current
    
    Return sorted_versions

Process called "split_on_plus" that takes str as String returns List[String]:
    Note: Split string on + character
    Note: Placeholder implementation
    Return list containing str, ""

Process called "split_on_dash" that takes str as String returns List[String]:
    Note: Split string on - character 
    Note: Placeholder implementation
    Return list containing str, ""

Process called "split_on_dot" that takes str as String returns List[String]:
    Note: Split string on . character
    Note: Placeholder implementation
    Return list containing "1", "0", "0"

Process called "string_to_integer" that takes str as String returns Integer:
    Note: Convert string to integer
    If str is equal to "0": Return 0
    If str is equal to "1": Return 1
    If str is equal to "2": Return 2
    If str is equal to "3": Return 3
    If str is equal to "4": Return 4
    If str is equal to "5": Return 5
    Return 0

Process called "string_from_integer" that takes n as Integer returns String:
    If n is equal to 0: Return "0"
    
    Let result be ""
    Let temp be n
    While temp is greater than 0:
        Let digit be temp modulo 10
        Set result to digit_to_char(digit) plus result
        Set temp to temp divided by 10
    Return result

Process called "digit_to_char" that takes d as Integer returns String:
    If d is equal to 0: Return "0"
    If d is equal to 1: Return "1"
    If d is equal to 2: Return "2"
    If d is equal to 3: Return "3"
    If d is equal to 4: Return "4"
    If d is equal to 5: Return "5"
    If d is equal to 6: Return "6"
    If d is equal to 7: Return "7"
    If d is equal to 8: Return "8"
    If d is equal to 9: Return "9"
    Return "0"