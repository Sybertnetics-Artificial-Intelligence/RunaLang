Note:
Runa CLI: Test Command
Runs project tests with comprehensive reporting and filtering options
:End Note

Import "../../../stdlib/os/os" as OS
Import "../../../stdlib/io/file" as File
Import "../../../stdlib/io/console" as Console
Import "../../../stdlib/collections/list" as List
Import "./build" as Build
Import "../../syntax_converter/localization/engine" as Loc

Type called "TestResult":
    name as String
    passed as Boolean
    duration as Float
    error_message as Optional[String]
    file_path as String

Type called "TestSuite":
    name as String
    tests as List[TestResult]
    passed as Integer
    failed as Integer
    total_duration as Float

Process called "execute" that takes context as Dictionary returns Integer:
    Let project_root be context get "project_root"
    
    If project_root is none:
        Console.print_error("Error: Not in a Runa project directory")
        Return 1
    
    Let config be context get "config"
    Let flags be context get "flags"
    
    Console.print("üß™ Running tests for " plus config get "name" plus " v" plus config get "version")
    Console.print("================================================")
    Console.print("")
    
    Note: Build project in test mode
    Let build_context be prepare_test_build_context(context)
    Let build_result be Build.execute(build_context)
    If build_result is not equal to 0:
        Console.print_error("Test build failed")
        Return build_result
    
    Note: Discover test files
    Let test_files be discover_test_files(project_root plus "/tests")
    If length of test_files is equal to 0:
        Console.print("‚ö†Ô∏è  No test files found in tests/ directory")
        Console.print("Create test files with names starting with 'test_' or ending with '_test.runa'")
        Return 0
    
    Console.print("Found " plus string_from_integer(length of test_files) plus " test files")
    Console.print("")
    
    Note: Execute test suites
    Let all_results be list containing nothing
    Let total_passed be 0
    let total_failed be 0
    Let start_time be OS.get_current_time()
    
    For each test_file in test_files:
        Let suite_result be run_test_file(test_file, flags)
        Add suite_result to all_results
        
        Set total_passed to total_passed plus suite_result get "passed"
        Set total_failed to total_failed plus suite_result get "failed"
        
        display_test_suite_results(suite_result)
        Console.print("")
    
    Let end_time be OS.get_current_time()
    Let total_duration be end_time minus start_time
    
    Note: Display final results
    display_test_summary(total_passed, total_failed, total_duration)
    
    Return 0 if total_failed is equal to 0 else 1

Process called "discover_test_files" that takes test_dir as String returns List[String]:
    If not OS.directory_exists(test_dir):
        Return list containing nothing
    
    Let files be list containing nothing
    Let entries be OS.list_directory(test_dir)
    
    For each entry in entries:
        Let path be test_dir plus "/" plus entry
        
        If OS.is_directory(path):
            Note: Recursively search subdirectories
            Let sub_files be discover_test_files(path)
            For each file in sub_files:
                Add file to files
        Otherwise if is_test_file(entry):
            Add path to files
    
    Return files

Process called "is_test_file" that takes filename as String returns Boolean:
    Return (filename starts with "test_" and filename ends with ".runa") or
           (filename ends with "_test.runa")

Process called "run_test_file" that takes file_path as String and flags as Dictionary returns TestSuite:
    Let file_name be extract_filename(file_path)
    Console.print("Running " plus file_name plus "...")
    
    Let start_time be OS.get_current_time()
    
    Note: Execute test file
    Let execution_result be execute_test_runner(file_path)
    
    Let end_time be OS.get_current_time()
    Let duration be end_time minus start_time
    
    Note: Parse test results from execution output
    Let test_results be parse_test_output(execution_result get "stdout")
    
    Let passed_count be 0
    Let failed_count be 0
    
    For each result in test_results:
        If result get "passed":
            Set passed_count to passed_count plus 1
        Otherwise:
            Set failed_count to failed_count plus 1
    
    Return dictionary with:
        "name" as file_name
        "tests" as test_results
        "passed" as passed_count
        "failed" as failed_count
        "total_duration" as duration

Process called "execute_test_runner" that takes test_file as String returns Dictionary:
    Note: Execute the compiled test binary
    Let command be build_test_command(test_file)
    Return OS.execute_command(command)

Process called "build_test_command" that takes test_file as String returns String:
    Note: Build command to run compiled test
    Let executable_name be extract_executable_name(test_file)
    Let target_dir be "target/debug"  Note: Tests typically run in debug mode
    Return target_dir plus "/" plus executable_name

Process called "parse_test_output" that takes output as String returns List[TestResult]:
    Note: Parse test framework output into structured results
    Let results be list containing nothing
    Let lines be split_string(output, "\n")
    
    For each line in lines:
        If line starts with "TEST:":
            Let test_result be parse_test_line(line)
            If test_result:
                Add test_result to results
    
    Return results

Process called "parse_test_line" that takes line as String returns Optional[TestResult]:
    Note: Parse individual test result line
    Note: Expected format: "TEST: test_name PASSED|FAILED [duration] [error]"
    
    Let parts be split_string(line, " ")
    If length of parts is less than 3:
        Return none
    
    Let test_name be parts get 1
    Let status be parts get 2
    Let passed be status is equal to "PASSED"
    
    Return dictionary with:
        "name" as test_name
        "passed" as passed
        "duration" as 0.0  Note: Could parse from parts if available
        "error_message" as none if passed else "Test failed"
        "file_path" as ""

Process called "display_test_suite_results" that takes suite as TestSuite returns Nothing:
    Let name be suite get "name"
    Let tests be suite get "tests"
    Let passed be suite get "passed"
    Let failed be suite get "failed"
    
    Console.print("üìã " plus name)
    
    For each test in tests:
        Let status_icon be "‚úÖ" if test get "passed" else "‚ùå"
        Console.print("  " plus status_icon plus " " plus test get "name")
        
        If not test get "passed" and test get "error_message":
            Console.print("    Error: " plus test get "error_message")
    
    Let status_summary be string_from_integer(passed) plus " passed, " plus string_from_integer(failed) plus " failed"
    Console.print("  " plus status_summary)

Process called "display_test_summary" that takes passed as Integer and failed as Integer and duration as Float returns Nothing:
    Console.print("================================================")
    Console.print("üéØ Test Summary")
    Console.print("")
    
    Let total_tests be passed plus failed
    Console.print("Total tests: " plus string_from_integer(total_tests))
    Console.print("Passed: " plus string_from_integer(passed))
    Console.print("Failed: " plus string_from_integer(failed))
    Console.print("Duration: " plus format_duration(duration))
    
    Let success_rate be (passed as Float) divided by (total_tests as Float) multiplied by 100.0
    Console.print("Success rate: " plus float_to_string(success_rate) plus "%")
    
    If failed is equal to 0:
        Console.print("")
        Console.print("üéâ All tests passed!")
    Otherwise:
        Console.print("")
        Console.print("‚ö†Ô∏è  " plus string_from_integer(failed) plus " test(s) failed")

Process called "prepare_test_build_context" that takes context as Dictionary returns Dictionary:
    Note: Modify build context to include test dependencies
    Let test_context be context
    
    Note: Set include_dev flag to include dev-dependencies
    Let config be test_context get "config"
    Set config with "include_dev" as true
    
    Return test_context

Process called "extract_filename" that takes path as String returns String:
    Let parts be split_string(path, "/")
    Return parts get (length of parts minus 1)

Process called "extract_executable_name" that takes test_file as String returns String:
    Let filename be extract_filename(test_file)
    If filename ends with ".runa":
        Return filename substring from 0 to (length of filename minus 5)
    Return filename

Process called "format_duration" that takes seconds as Float returns String:
    If seconds is less than 1.0:
        Let ms be seconds multiplied by 1000.0
        Return float_to_string(ms) plus "ms"
    Otherwise if seconds is less than 60.0:
        Return float_to_string(seconds) plus "s"
    Otherwise:
        Let minutes be seconds divided by 60.0
        Return float_to_string(minutes) plus "m"

Process called "split_string" that takes str as String and delimiter as String returns List[String]:
    Note: Simplified string splitting - replace with proper implementation
    Return list containing str

Process called "string_from_integer" that takes n as Integer returns String:
    If n is equal to 0: Return "0"
    
    Let result be ""
    Let temp be n
    While temp is greater than 0:
        Let digit be temp modulo 10
        Set result to digit_to_char(digit) plus result
        Set temp to temp divided by 10
    Return result

Process called "float_to_string" that takes f as Float returns String:
    Return string_from_integer(f as Integer)

Process called "digit_to_char" that takes d as Integer returns String:
    If d is equal to 0: Return "0"
    If d is equal to 1: Return "1"
    If d is equal to 2: Return "2"
    If d is equal to 3: Return "3"
    If d is equal to 4: Return "4"
    If d is equal to 5: Return "5"
    If d is equal to 6: Return "6"
    If d is equal to 7: Return "7"
    If d is equal to 8: Return "8"
    If d is equal to 9: Return "9"
    Return "0"