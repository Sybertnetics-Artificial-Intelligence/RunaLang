Note:
Runa CLI Triple Syntax Commands - CORRECTED ARCHITECTURE v3.0

Implements --canon, --developer, and --viewer mode functionality for the Runa CLI.
Provides conversion between canonical Runa, developer bare assignment syntax, and read-only natural language display.

Usage:
  runa compile --canon input.runa [output.runa]     # Compile canonical Runa (writeable)
  runa compile --developer input.runa [output.runa] # Compile developer syntax (bare assignment)
  runa view --viewer input.runa                     # Display natural language (READ-ONLY)
  runa convert --from=canon --to=developer input.runa
  runa convert --from=developer --to=viewer input.runa

CORRECT ARCHITECTURE:
- --canon: Writeable canonical Runa (replaces old viewer as writeable mode)
- --developer: Writeable bare assignment syntax (x = value, no keywords)
- --viewer: READ-ONLY natural language display (for comprehension only)

Features:
- Canonical ↔ Developer conversion (both writeable)
- Canon/Developer → Viewer display (read-only)
- Viewer → Canon/Developer conversion (for editing)
- Multiple verbosity levels for display
- Integration with existing CLI infrastructure
:End Note

Import "../syntax_converter/developer_mode" as DeveloperMode
Import "../syntax_converter/viewer_mode" as ViewerMode
Import "../syntax_converter/canonical_mode" as CanonicalMode
Import "../syntax_converter/syntax_converter" as SyntaxConverter
Import "../syntax_converter/mixed_syntax_handler" as MixedSyntaxHandler
Import "../../compiler/main" as Compiler

Note: CLI command handlers for syntax conversion
Process called "handle_developer_mode" that takes args as List[String] and options as Dictionary[String, Any] returns Integer:
    Note: Handle --developer flag - normalize any input to developer syntax
    Try:
        Let input_file be get_input_file with args as args
        Let output_file be get_output_file with args as args
        Let developer_options be create_developer_options with options as options
        
        Let source_code be read_source_file with path as input_file
        
        Note: Use mixed syntax handler for robust conversion
        Let mixed_result be MixedSyntaxHandler.handle_mixed_syntax_file with 
            source_code as source_code and 
            target_mode as "developer" and 
            options as developer_options
        
        If mixed_result.conversion_success:
            If output_file is not None:
                Call write_converted_file with path as output_file and content as mixed_result.normalized_code
            Otherwise:
                Display mixed_result.normalized_code
            
            Note: Show conversion summary
            Display "✓ Developer syntax normalization complete"
            Display "  Input:  " plus input_file
            If output_file is not None:
                Display "  Output: " plus output_file plus " (developer)"
            
            If mixed_result.inconsistencies_found is greater than 0:
                Display "  Fixed:  " plus string_from_integer(mixed_result.inconsistencies_fixed) plus " syntax inconsistencies"
            
            If length of mixed_result.warnings is greater than 0:
                Display "  Warnings:"
                For warning in mixed_result.warnings:
                    Display "    " plus warning
            
            Return 0
        Otherwise:
            Display "✗ Developer syntax normalization failed"
            For warning in mixed_result.warnings:
                Display "  Error: " plus warning
            Return 1
            
    Catch error:
        Display "Error in developer mode: " plus error.message
        Return 1

Process called "handle_viewer_mode" that takes args as List[String] and options as Dictionary[String, Any] returns Integer:
    Note: Handle --viewer flag for READ-ONLY natural language display
    Try:
        Let input_file be get_input_file with args as args
        Let output_file be get_output_file with args as args
        Let viewer_options be create_viewer_options with options as options
        
        Let source_code be read_source_file with path as input_file
        
        Note: First normalize to canonical for consistent viewer input
        Let mixed_result be MixedSyntaxHandler.handle_mixed_syntax_file with 
            source_code as source_code and 
            target_mode as "canonical" and 
            options as viewer_options
        
        If mixed_result.conversion_success:
            Note: Display normalized canonical code in natural language
            Let display_result be ViewerMode.display_as_natural_language with 
                source_file as input_file and 
                source_mode as "canonical" and 
                options as viewer_options
            
            If display_result.success:
                If output_file is None:
                    Note: Display natural language to stdout (READ-ONLY)
                    Display "📖 VIEWER MODE (Read-Only Display):"
                    If mixed_result.inconsistencies_found is greater than 0:
                        Display "Normalized " plus string_from_integer(mixed_result.inconsistencies_found) plus " syntax inconsistencies for display"
                    Display "─────────────────────────────────────"
                    Display display_result.natural_language_content
                    Return 0
                Otherwise:
                    Note: Save natural language display to file
                    Call write_file with path as output_file and content as display_result.natural_language_content
                    Display "✓ Viewer mode display saved"
                    Display "  Input:  " plus input_file
                    Display "  Output: " plus output_file plus " (natural language display)"
                    If mixed_result.inconsistencies_found is greater than 0:
                        Display "  Normalized: " plus string_from_integer(mixed_result.inconsistencies_found) plus " syntax inconsistencies"
                    Return 0
            Otherwise:
                Display "✗ Viewer mode display failed: " plus display_result.error_message
                Return 1
        Otherwise:
            Display "✗ Failed to normalize input for viewer mode"
            For warning in mixed_result.warnings:
                Display "  Error: " plus warning
            Return 1
            
    Catch error:
        Display "Error in viewer mode: " plus error.message
        Return 1

Process called "handle_canonical_mode" that takes args as List[String] and options as Dictionary[String, Any] returns Integer:
    Note: Handle --canon flag - normalize any input to canonical syntax
    Try:
        Let input_file be get_input_file with args as args
        Let output_file be get_output_file with args as args
        Let canonical_options be create_canonical_options with options as options
        
        Let source_code be read_source_file with path as input_file
        
        Note: Use mixed syntax handler for robust conversion
        Let mixed_result be MixedSyntaxHandler.handle_mixed_syntax_file with 
            source_code as source_code and 
            target_mode as "canonical" and 
            options as canonical_options
        
        If mixed_result.conversion_success:
            If output_file is not None:
                Call write_converted_file with path as output_file and content as mixed_result.normalized_code
            Otherwise:
                Display mixed_result.normalized_code
            
            Note: Show conversion summary
            Display "✓ Canonical syntax normalization complete"
            Display "  Input:  " plus input_file
            If output_file is not None:
                Display "  Output: " plus output_file plus " (canonical)"
            
            If mixed_result.inconsistencies_found is greater than 0:
                Display "  Fixed:  " plus string_from_integer(mixed_result.inconsistencies_fixed) plus " syntax inconsistencies"
            
            If length of mixed_result.warnings is greater than 0:
                Display "  Warnings:"
                For warning in mixed_result.warnings:
                    Display "    " plus warning
            
            Return 0
        Otherwise:
            Display "✗ Canonical syntax normalization failed"
            For warning in mixed_result.warnings:
                Display "  Error: " plus warning
            Return 1
            
    Catch error:
        Display "Error in canonical mode: " plus error.message
        Return 1

Process called "handle_syntax_command" that takes args as List[String] and options as Dictionary[String, Any] returns Integer:
    Note: Handle dedicated 'runa syntax' command - SIMPLIFIED AUTO-CONVERSION ARCHITECTURE
    Try:
        If options.contains("canon"):
            Return handle_canonical_mode with args as args and options as options
        Else if options.contains("developer"):
            Return handle_developer_mode with args as args and options as options
        Else if options.contains("viewer"):
            Return handle_viewer_mode with args as args and options as options
        Otherwise:
            Display "Error: Must specify --canon, --developer, or --viewer mode"
            Display ""
            Call show_updated_syntax_help
            Return 1
            
    Catch error:
        Display "Syntax command error: " plus error.message
        Return 1

Process called "get_input_file" that takes args as List[String] returns String:
    Note: Extract input file from command arguments
    If length of args is equal to 0:
        Throw ArgumentError with message as "No input file specified"
    
    Let input_file be args[0]
    If not file_exists with path as input_file:
        Throw FileError with message as "Input file does not exist: " plus input_file
    
    Return input_file

Process called "get_output_file" that takes args as List[String] returns Optional[String]:
    Note: Extract output file from command arguments (optional)
    If length of args is greater than 1:
        Return Some(args[1])
    Otherwise:
        Return None

Process called "create_developer_options" that takes options as Dictionary[String, Any] returns Dictionary[String, Any]:
    Note: Create options dictionary for developer mode
    Let developer_options be dictionary containing
    
    Set developer_options["optimization"] to options.get("optimization", "standard")
    Set developer_options["preserve_comments"] to options.get("preserve_comments", true)
    Set developer_options["indent_size"] to options.get("indent_size", 2)
    Set developer_options["use_semicolons"] to options.get("semicolons", false)
    Set developer_options["prefer_symbols"] to options.get("symbols", true)
    Set developer_options["compress_whitespace"] to options.get("compress", false)
    
    Return developer_options

Process called "create_viewer_options" that takes options as Dictionary[String, Any] returns Dictionary[String, Any]:
    Note: Create options dictionary for viewer mode
    Let viewer_options be dictionary containing
    
    Set viewer_options["verbosity"] to options.get("verbosity", "standard")
    Set viewer_options["preserve_technical_comments"] to options.get("preserve_tech_comments", true)
    Set viewer_options["indent_size"] to options.get("indent_size", 4)
    Set viewer_options["use_full_words"] to options.get("full_words", true)
    Set viewer_options["add_explanations"] to options.get("explanations", false)
    Set viewer_options["line_spacing"] to options.get("spacing", "normal")
    
    Return viewer_options

Process called "create_canonical_options" that takes options as Dictionary[String, Any] returns Dictionary[String, Any]:
    Note: Create options dictionary for canonical mode
    Let canonical_options be dictionary containing
    
    Set canonical_options["preserve_formatting"] to options.get("preserve_formatting", true)
    Set canonical_options["validate_syntax"] to options.get("validate_syntax", true)
    Set canonical_options["indent_size"] to options.get("indent_size", 4)
    Set canonical_options["normalize_style"] to options.get("normalize_style", false)
    Set canonical_options["preserve_comments"] to options.get("preserve_comments", true)
    
    Return canonical_options

Process called "detect_source_file_mode" that takes file_path as String returns String:
    Note: Detect whether file contains canonical or technical syntax
    Try:
        Let file_content be read_file with path as file_path
        
        Note: Simple heuristics to detect syntax mode
        If file_content contains "Process called" or file_content contains "Let " or file_content contains "Type called":
            Return "canonical"
        Else if file_content contains "=" and file_content contains "{" and file_content contains "}":
            Return "developer"
        Otherwise:
            Return "unknown"
            
    Catch error:
        Return "unknown"

Process called "write_file" that takes path as String and content as String returns None:
    Note: Write content to file
    Try:
        Import "io"
        Call io.write_text_file with path as path and content as content
    Catch error:
        Throw FileError with message as "Could not write file: " plus path

Process called "read_file" that takes path as String returns String:
    Note: Read content from file
    Try:
        Import "io"
        Return io.read_text_file with path as path
    Catch error:
        Throw FileError with message as "Could not read file: " plus path

Process called "file_exists" that takes path as String returns Boolean:
    Note: Check if file exists
    Try:
        Import "io"
        Return io.file_exists with path as path
    Catch error:
        Return false

Process called "read_source_file" that takes path as String returns String:
    Note: Read source file content for conversion
    Try:
        Import "io"
        Return io.read_text_file with path as path
    Catch error:
        Throw FileError with message as "Could not read source file: " plus path

Process called "write_converted_file" that takes path as String and content as String returns None:
    Note: Write converted code to output file
    Try:
        Import "io"
        Call io.write_text_file with path as path and content as content
    Catch error:
        Throw FileError with message as "Could not write converted file: " plus path

Process called "string_from_integer" that takes number as Integer returns String:
    Note: Convert integer to string representation
    Import "conversions"
    Return conversions.integer_to_string with number as number

Process called "show_updated_syntax_help" returns None:
    Note: Display SIMPLIFIED help information for auto-converting triple syntax commands
    Display "Runa Triple Syntax System v4.0 - AUTO-CONVERSION ARCHITECTURE"
    Display ""
    Display "🚀 SIMPLE MODE SELECTION - Auto-detects input format and converts as needed:"
    Display "    --canon       Output canonical Runa syntax (auto-converts any input)"
    Display "    --developer   Output technical syntax (auto-converts any input)"
    Display "    --viewer      Display natural language (read-only, auto-converts any input)"
    Display ""
    Display "USAGE:"
    Display "    runa --canon input.runa [output.runa]         # Output canonical (auto-detects input)"
    Display "    runa --developer input.runa [output.runa]    # Output technical (auto-detects input)"
    Display "    runa --viewer input.runa                     # Display natural language (auto-detects input)"
    Display ""
    Display "MODES:"
    Display "    --canon       Standard Runa syntax (writeable, compilation target)"
    Display "    --developer   Technical syntax (writeable, for traditional developers)"
    Display "    --viewer      Natural language display (READ-ONLY, for comprehension)"
    Display ""
    Display "HOW IT WORKS:"
    Display "    📋 Input:    Any format (canonical, developer, or mixed)"
    Display "    🔍 Detect:   Automatically identifies input syntax"
    Display "    🔄 Convert:   Transforms to requested output format"
    Display "    📝 Output:    Clean, consistent syntax in chosen mode"
    Display ""
    Display "OPTIONS:"
    Display "    --optimization LEVEL    Optimization level for developer mode"
    Display "                           (minimal, standard, aggressive)"
    Display "    --verbosity LEVEL       Verbosity level for viewer mode"
    Display "                           (minimal, standard, verbose, educational)"
    Display "    --indent-size SIZE      Number of spaces for indentation"
    Display "    --preserve-formatting   Keep original formatting when possible"
    Display "    --validate-syntax       Validate syntax on processing"
    Display ""
    Display "EXAMPLES:"
    Display "    runa --canon mixed_syntax.runa clean_canonical.runa    # Any input → canonical output"
    Display "    runa --developer canonical.runa technical.runa         # Canonical → technical syntax"
    Display "    runa --viewer technical.runa                          # Technical → natural language display"
    Display "    runa --canon /path/to/any/file.runa                   # Auto-detect and canonicalize"

Process called "parse_syntax_options" that takes cli_args as List[String] returns Dictionary[String, Any]:
    Note: Parse command line options for syntax conversion
    Let options be dictionary containing
    Let i be 0
    
    While i is less than length of cli_args:
        Let arg be cli_args[i]
        
        Match arg:
            When "--optimization":
                If i plus 1 is less than length of cli_args:
                    Set options["optimization"] to cli_args[i plus 1]
                    Set i to i plus 1
                Otherwise:
                    Throw ArgumentError with message as "--optimization requires a value"
            
            When "--verbosity":
                If i plus 1 is less than length of cli_args:
                    Set options["verbosity"] to cli_args[i plus 1]
                    Set i to i plus 1
                Otherwise:
                    Throw ArgumentError with message as "--verbosity requires a value"
            
            When "--indent-size":
                If i plus 1 is less than length of cli_args:
                    Set options["indent_size"] to parse_integer with string as cli_args[i plus 1]
                    Set i to i plus 1
                Otherwise:
                    Throw ArgumentError with message as "--indent-size requires a numeric value"
            
            When "--symbols":
                Set options["symbols"] to true
            
            When "--full-words":
                Set options["full_words"] to true
            
            When "--explanations":
                Set options["explanations"] to true
            
            When "--compress":
                Set options["compress"] to true
            
            When "--spacing":
                If i plus 1 is less than length of cli_args:
                    Set options["spacing"] to cli_args[i plus 1]
                    Set i to i plus 1
                Otherwise:
                    Throw ArgumentError with message as "--spacing requires a value"
            
            When "--developer":
                Set options["developer"] to true
            
            When "--viewer":
                Set options["viewer"] to true
            
            When "--canon":
                Set options["canon"] to true
            
            Note: Removed conversion-specific options - no longer needed with auto-detection
            
            When "--preserve-comments":
                Set options["preserve_comments"] to true
            
            When "--preserve-tech-comments":
                Set options["preserve_tech_comments"] to true
            
            When "--preserve-formatting":
                Set options["preserve_formatting"] to true
            
            When "--validate-syntax":
                Set options["validate_syntax"] to true
            
            Otherwise:
                Note: Skip unknown options, let other parsers handle them
                Pass
        
        Set i to i plus 1
    
    Return options

Process called "validate_syntax_options" that takes options as Dictionary[String, Any] returns Boolean:
    Note: Validate syntax conversion options
    Try:
        Note: Validate optimization level
        If options.contains("optimization"):
            Let opt_level be options["optimization"]
            If opt_level is not equal to "minimal" and opt_level is not equal to "standard" and opt_level is not equal to "aggressive":
                Display "Error: Invalid optimization level. Must be: minimal, standard, or aggressive"
                Return false
        
        Note: Validate verbosity level
        If options.contains("verbosity"):
            Let verb_level be options["verbosity"]
            If verb_level is not equal to "minimal" and verb_level is not equal to "standard" and verb_level is not equal to "verbose" and verb_level is not equal to "educational":
                Display "Error: Invalid verbosity level. Must be: minimal, standard, verbose, or educational"
                Return false
        
        Note: Validate indent size
        If options.contains("indent_size"):
            Let indent_size be options["indent_size"]
            If indent_size is less than 1 or indent_size is greater than 8:
                Display "Error: Indent size must be between 1 and 8"
                Return false
        
        Note: Validate spacing
        If options.contains("spacing"):
            Let spacing be options["spacing"]
            If spacing is not equal to "normal" and spacing is not equal to "wide":
                Display "Error: Invalid spacing. Must be: normal or wide"
                Return false
        
        Note: Validate conflicting options
        If options.contains("symbols") and options.contains("full_words"):
            Display "Warning: Both --symbols and --full-words specified. Using --full-words."
            Set options["symbols"] to false
        
        Return true
        
    Catch error:
        Display "Error validating options: " plus error.message
        Return false

Note: Integration with existing CLI infrastructure
Process called "register_syntax_commands" that takes cli_parser as CLIParser returns None:
    Note: Register syntax-related commands with CLI parser
    
    Note: Register syntax subcommand
    cli_parser.add_command with name as "syntax" and handler as handle_syntax_command and description as "Convert between syntax forms"
    
    Note: Register flags for compile command
    cli_parser.add_flag with name as "developer" and description as "Convert to technical syntax"
    cli_parser.add_flag with name as "viewer" and description as "Convert to natural language syntax"
    
    Note: Register options
    cli_parser.add_option with name as "optimization" and description as "Optimization level for developer mode"
    cli_parser.add_option with name as "verbosity" and description as "Verbosity level for viewer mode"
    cli_parser.add_option with name as "indent-size" and description as "Indentation size"
    cli_parser.add_option with name as "spacing" and description as "Line spacing style"

Process called "handle_compile_with_syntax" that takes args as List[String] and options as Dictionary[String, Any] returns Integer:
    Note: Handle compile command with syntax conversion flags
    Try:
        Let has_developer be options.contains("developer") and options["developer"]
        Let has_viewer be options.contains("viewer") and options["viewer"]
        
        If has_developer and has_viewer:
            Display "Error: Cannot specify both --developer and --viewer modes"
            Return 1
        
        If has_developer:
            Note: First convert to developer syntax, then compile
            Let temp_file be create_temp_file with suffix as ".runa"
            Let convert_success be handle_developer_mode with args as args and options as dictionary with "output_file" as temp_file
            
            If convert_success is equal to 0:
                Note: Now compile the converted file
                Let compile_args be replace_input_file with args as args and new_file as temp_file
                Let compile_result be Compiler.compile with args as compile_args and options as options
                Call cleanup_temp_file with path as temp_file
                Return compile_result
            Otherwise:
                Call cleanup_temp_file with path as temp_file
                Return convert_success
        
        If has_viewer:
            Note: First convert to viewer syntax, then handle as needed
            Return handle_viewer_mode with args as args and options as options
        
        Note: No syntax conversion requested, proceed with normal compilation
        Return Compiler.compile with args as args and options as options
        
    Catch error:
        Display "Compile with syntax conversion error: " plus error.message
        Return 1

Note: Utility functions for CLI integration
Process called "create_temp_file" that takes suffix as String returns String:
    Note: Create temporary file for intermediate processing
    Try:
        Import "os"
        Let temp_dir be os.get_temp_directory()
        Let temp_name be "runa_syntax_" plus generate_random_id() plus suffix
        Let temp_path be temp_dir plus "/" plus temp_name
        Return temp_path
    Catch error:
        Throw FileError with message as "Could not create temporary file"

Process called "cleanup_temp_file" that takes path as String returns None:
    Note: Clean up temporary file
    Try:
        Import "io"
        Call io.delete_file with path as path
    Catch error:
        Note: Ignore cleanup errors
        Pass

Process called "replace_input_file" that takes args as List[String] and new_file as String returns List[String]:
    Note: Replace the input file in arguments list
    If length of args is greater than 0:
        Let new_args be copy_list with list as args
        Set new_args[0] to new_file
        Return new_args
    Otherwise:
        Return list containing new_file

Process called "generate_random_id" returns String:
    Note: Generate random ID for temporary files
    Try:
        Import "random"
        Return random.generate_string with length as 8 and charset as "abcdefghijklmnopqrstuvwxyz0123456789"
    Catch error:
        Return "temp"

Process called "copy_list" that takes list as List[String] returns List[String]:
    Let copied be list containing
    For each item in list:
        Add item to copied
    Return copied

Process called "parse_integer" that takes string as String returns Integer:
    Note: Parse string to integer with error handling
    Try:
        Return string as Integer
    Catch error:
        Throw ArgumentError with message as "Invalid integer: " plus string