Note:
Runa CLI: Run Command
Executes Runa programs with automatic building and dependency resolution
:End Note

Import "../../../stdlib/os/os" as OS
Import "../../../stdlib/io/file" as File
Import "../../../stdlib/io/console" as Console
Import "./build" as Build
Import "../../syntax_converter/localization/engine" as Loc

Process called "execute" that takes context as Dictionary returns Integer:
    Let project_root be context get "project_root"
    
    If project_root is none:
        Console.print_error("Error: Not in a Runa project directory")
        Console.print("Run this command from a directory containing runa.toml")
        Return 1
    
    Let config be context get "config"
    Let flags be context get "flags"
    Let args be context get "arguments"
    
    Note: Build project first unless --no-build flag is set
    Let skip_build be flags get "no-build"
    
    If not skip_build:
        Console.print("Building project before execution...")
        Let build_result be Build.execute(context)
        If build_result is not equal to 0:
            Console.print_error("Build failed - cannot run")
            Return build_result
        Console.print("")
    
    Note: Determine executable path
    Let build_mode be "release" if flags get "release" else "debug"
    Let target_dir be project_root plus "/target/" plus build_mode
    Let executable_name be config get "name"
    Let executable_path be find_executable(target_dir, executable_name)
    
    If not executable_path:
        Console.print_error("Executable not found. Try running 'runa build' first.")
        Return 1
    
    Console.print("Running " plus config get "name" plus " v" plus config get "version")
    Console.print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    Console.print("")
    
    Note: Execute the program
    Let start_time be OS.get_current_time()
    Let run_result be execute_program(executable_path, args)
    Let end_time be OS.get_current_time()
    
    Console.print("")
    Console.print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    
    Let duration be end_time minus start_time
    Console.print("Execution completed in " plus format_duration(duration))
    
    If run_result get "exit_code" is equal to 0:
        Console.print("✓ Program exited successfully")
    Otherwise:
        Console.print("Program exited with code " plus string_from_integer(run_result get "exit_code"))
    
    Return run_result get "exit_code"

Process called "find_executable" that takes target_dir as String and name as String returns Optional[String]:
    Note: Find executable in target directory
    
    Let candidates be list containing:
        target_dir plus "/" plus name
        target_dir plus "/" plus name plus ".exe"
        target_dir plus "/bin/" plus name
        target_dir plus "/bin/" plus name plus ".exe"
    
    For each path in candidates:
        If File.exists(path) and OS.is_executable(path):
            Return path
    
    Return none

Process called "execute_program" that takes executable_path as String and args as List[String] returns Dictionary:
    Note: Execute the program with given arguments
    
    Let command be build_command(executable_path, args)
    Let result be OS.execute_command_interactive(command)
    
    Return dictionary with:
        "exit_code" as result get "exit_code"
        "stdout" as result get "stdout"
        "stderr" as result get "stderr"

Process called "build_command" that takes executable as String and args as List[String] returns String:
    Let command be executable
    
    For each arg in args:
        Set command to command plus " " plus quote_argument(arg)
    
    Return command

Process called "quote_argument" that takes arg as String returns String:
    Note: Quote argument if it contains spaces
    If arg contains " ":
        Return "\"" plus arg plus "\""
    Return arg

Process called "format_duration" that takes seconds as Float returns String:
    If seconds is less than 1.0:
        Let ms be seconds multiplied by 1000.0
        Return float_to_string(ms) plus "ms"
    Otherwise if seconds is less than 60.0:
        Return float_to_string(seconds) plus "s"
    Otherwise:
        Let minutes be seconds divided by 60.0
        Return float_to_string(minutes) plus "m"

Process called "string_from_integer" that takes n as Integer returns String:
    If n is equal to 0:
        Return "0"
    
    Let result be ""
    Let temp be n
    Let is_negative be false
    
    If temp is less than 0:
        Set is_negative to true
        Set temp to 0 minus temp
    
    While temp is greater than 0:
        Let digit be temp modulo 10
        Set result to digit_to_char(digit) plus result
        Set temp to temp divided by 10
    
    If is_negative:
        Set result to "-" plus result
    
    Return result

Process called "float_to_string" that takes f as Float returns String:
    Return string_from_integer(f as Integer)

Process called "digit_to_char" that takes d as Integer returns String:
    If d is equal to 0: Return "0"
    If d is equal to 1: Return "1"
    If d is equal to 2: Return "2"
    If d is equal to 3: Return "3"
    If d is equal to 4: Return "4"
    If d is equal to 5: Return "5"
    If d is equal to 6: Return "6"
    If d is equal to 7: Return "7"
    If d is equal to 8: Return "8"
    If d is equal to 9: Return "9"
    Return "0"