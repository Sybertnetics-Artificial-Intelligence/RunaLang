Note:
Runa CLI: Translate Command

Translates Runa surface tokens/keywords/operators between languages while preserving identifiers, strings, and program structure.
:End Note

Import "../../syntax_converter/localization/engine" as Loc
Import "../../../stdlib/io/file" as File
Import "../../../stdlib/io/console" as Console

Process called "execute" that takes context as Dictionary returns Integer:
    Let args be context get "args"
    Let flags be context get "flags"
    Let options be context get "options"

    If length of args is less than 2 and not (options contains "from" and options contains "to"):
        Console.print("Usage: runa translate [OPTIONS] <FROM_LANG> <TO_LANG> [INPUT] [OUTPUT]")
        Return 1

    Let from_lang be options.get("from", none)
    Let to_lang be options.get("to", none)
    
    If not from_lang:
        Set from_lang to args[0]
    If not to_lang:
        Set to_lang to args[1]

    If not Loc.supported_language(from_lang) or not Loc.supported_language(to_lang):
        Console.print_error("Unsupported language. Supported: en, hi, ja, es, zh, ru")
        Return 1

    Let in_place be flags get "in-place"
    Let detect be flags get "detect"

    Let input_path as Optional[String]
    Let output_path as Optional[String]

    If length of args is greater than or equal to 3:
        Set input_path to args[2]
    If length of args is greater than or equal to 4:
        Set output_path to args[3]
    If options contains "output":
        Set output_path to options["output"]

    Let source_code as String
    If input_path:
        Set source_code to File.read_text(input_path)
    Otherwise:
        Console.print_error("Input file required.")
        Return 1

    If detect:
        Let detected be Loc.detect_language(source_code)
        If detected and detected is not equal to from_lang:
            Console.print("Detected source language: " plus detected)
            Set from_lang to detected

    Let translated be Loc.translate_source(source_code, from_lang, to_lang)

    If in_place and input_path:
        File.write_text(input_path, translated)
        Console.print("✓ Translated in place (" plus input_path plus ")")
        Return 0
    
    If output_path:
        File.write_text(output_path, translated)
        Console.print("✓ Translation written to " plus output_path)
        Return 0
    
    Note: Default output path: filename.<lang>.runa
    Let default_out be derive_default_output(input_path, to_lang)
    File.write_text(default_out, translated)
    Console.print("✓ Translation written to " plus default_out)
    Return 0
    
    Console.print(translated)
    Return 0

Process called "derive_default_output" that takes input_path as String and to_lang as String returns String:
    Let dot be last_index_of(input_path, ".")
    If dot >= 0:
        Return substring(input_path, 0, dot) plus "." plus to_lang plus substring(input_path, dot, length of input_path)
    Return input_path plus "." plus to_lang

Process called "last_index_of" that takes s as String and needle as String returns Integer:
    Let i be length of s minus length of needle
    While i >= 0:
        If substring(s, i, i plus length of needle) is equal to needle:
            Return i
        Set i to i minus 1
    Return -1
