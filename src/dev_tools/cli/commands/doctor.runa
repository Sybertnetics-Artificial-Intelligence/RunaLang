Note:
Runa CLI: Doctor Command
AI-powered code analysis and intelligent suggestions - Runa's killer feature
:End Note

Import "../../../stdlib/os/os" as OS
Import "../../../stdlib/io/file" as File
Import "../../../stdlib/io/console" as Console
Import "../../../stdlib/ai/reasoning/engine" as ReasoningEngine
Import "../../../stdlib/ai/agent/core" as Agent
Import "../../../compiler/semantic/semantic_analyzer" as Analyzer
Import "../../../stdlib/string/regex" as Regex

Type called "AnalysisResult":
    file_path as String
    issues as List[Issue]
    suggestions as List[Suggestion]
    score as Float
    complexity as Integer

Type called "Issue":
    severity as String  Note: "error", "warning", "info"
    line as Integer
    column as Integer
    message as String
    fix_suggestion as Optional[String]
    confidence as Float

Type called "Suggestion":
    type as String  Note: "performance", "security", "style", "architecture"
    description as String
    code_example as Optional[String]
    impact as String  Note: "high", "medium", "low"
    confidence as Float

Process called "execute" that takes context as Dictionary returns Integer:
    Let project_root be context get "project_root"
    
    If project_root is none:
        Console.print_error("Error: Not in a Runa project directory")
        Return 1
    
    Let flags be context get "flags"
    Let deep_analysis be flags get "deep-ai"
    Let explain_mode be flags get "explain"
    Let auto_fix be flags get "fix"
    
    Console.print("üîç Runa Doctor - AI-Powered Code Analysis")
    Console.print("=========================================")
    Console.print("")
    
    If deep_analysis:
        Console.print("Running deep AI analysis (this may take a moment)...")
    Otherwise:
        Console.print("Running standard analysis...")
    
    Note: Initialize AI reasoning engine
    Let reasoning_config be dictionary with:
        "confidence_threshold" as 0.7
        "max_concurrent_sessions" as 4
    Let reasoning_engine be ReasoningEngine.create_reasoning_engine("doctor", reasoning_config)
    
    Note: Collect all source files
    Let source_files be collect_project_files(project_root plus "/src")
    Console.print("Analyzing " plus string_from_integer(length of source_files) plus " files...")
    Console.print("")
    
    Let total_issues be 0
    Let total_suggestions be 0
    Let project_score be 0.0
    
    For each file_path in source_files:
        Let analysis be analyze_file(file_path, reasoning_engine, deep_analysis)
        
        If length of analysis get "issues" is greater than 0 or length of analysis get "suggestions" is greater than 0:
            Console.print("üìÑ " plus relative_path(file_path, project_root))
            
            Note: Display issues
            For each issue in analysis get "issues":
                Display issue with proper formatting
                Let icon be get_severity_icon(issue get "severity")
                Let location be "Line " plus string_from_integer(issue get "line")
                Console.print("  " plus icon plus " " plus location plus ": " plus issue get "message")
                
                If issue get "fix_suggestion":
                    Console.print("    üí° Fix: " plus issue get "fix_suggestion")
                
                Set total_issues to total_issues plus 1
            
            Note: Display suggestions
            For each suggestion in analysis get "suggestions":
                Let icon be get_suggestion_icon(suggestion get "type")
                Console.print("  " plus icon plus " " plus suggestion get "description")
                
                If suggestion get "code_example" and explain_mode:
                    Console.print("    Example:")
                    Console.print("    " plus suggestion get "code_example")
                
                Set total_suggestions to total_suggestions plus 1
            
            Console.print("")
        
        If auto_fix:
            Let fixed be apply_autofixes(file_path)
        
        Set project_score to project_score plus analysis get "score"
    
    Note: Calculate overall project health
    Let average_score be project_score divided by length of source_files
    Let health_rating be calculate_health_rating(average_score)
    
    Console.print("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
    Console.print("üìä Analysis Complete")
    Console.print("")
    Console.print("Project Health: " plus health_rating plus " (" plus float_to_string(average_score) plus "/100)")
    Console.print("Issues Found: " plus string_from_integer(total_issues))
    Console.print("Suggestions: " plus string_from_integer(total_suggestions))
    
    If deep_analysis:
        Note: Provide architectural insights
        Let architectural_insights be generate_architectural_insights(project_root, reasoning_engine)
        Console.print("")
        Console.print("üèóÔ∏è  Architectural Insights:")
        For each insight in architectural_insights:
            Console.print("  ‚Ä¢ " plus insight)
    
    If total_issues is equal to 0 and average_score is greater than 90.0:
        Console.print("")
        Console.print("‚ú® Excellent! Your code is in great shape!")
    Otherwise if total_issues is greater than 10:
        Console.print("")
        Console.print("‚ö†Ô∏è  Consider addressing the issues above to improve code quality")
    
    Return 0 if total_issues is equal to 0 else 1
Process called "apply_autofixes" that takes file_path as String returns Boolean:
    Let content be File.read_text(file_path)
    Let fixed be content
    
    Note: Autofix 1: Replace ' is equal to ' ‚Üí ' equals '
    Set fixed to replace_all with string as fixed and old as " is equal to " and new as " equals "
    
    Note: Autofix 2: Safe string concat rewrites near literals
    Set fixed to regex_replace_all with string as fixed and pattern as '"([^"\\]|\\.)*"\s*\+\s*' and replacement as '"$1" joined with '
    Set fixed to regex_replace_all with string as fixed and pattern as '"([^"\\]|\\.)*"\s+plus\s+' and replacement as '"$1" joined with '
    Set fixed to regex_replace_all with string as fixed and pattern as '\s\+\s*"([^"\\]|\\.)*"' and replacement as ' joined with "$1"'
    Set fixed to regex_replace_all with string as fixed and pattern as '\splus\s+"([^"\\]|\\.)*"' and replacement as ' joined with "$1"'
    
    Note: Autofix 3: Canonicalize legacy concat phrases
    Set fixed to replace_all with string as fixed and old as " concatenated with " and new as " joined with "
    Set fixed to replace_all with string as fixed and old as " followed by " and new as " joined with "
    
    If fixed is not equal to content:
        File.write_text(file_path, fixed)
        Return true
    Return false

Process called "analyze_file" that takes file_path as String and engine as ReasoningEngine and deep as Boolean returns AnalysisResult:
    Let content be File.read_text(file_path)
    Let ast be Analyzer.parse_file(content)
    
    Note: Create reasoning query for AI analysis
    Let query be dictionary with:
        "query_id" as generate_unique_id()
        "query_text" as "Analyze this Runa code for issues, optimizations, and best practices"
        "query_type" as "code_analysis"
        "required_reasoning_modes" as list containing "logical", "critical_thinking"
        "context_requirements" as list containing "code_quality", "performance", "security"
        "confidence_requirements" as dictionary with "minimum" as 0.7
        "time_constraints" as dictionary with "max_processing_time" as 5.0
    
    Note: Submit to reasoning engine
    Let session_id be ReasoningEngine.submit_reasoning_query(engine, query)
    Let reasoning_result be ReasoningEngine.execute_reasoning_session(engine, session_id)
    
    Note: Gather issues: static lints + AI
    Let issues be list containing nothing
    Let static_issues be run_static_lints(file_path, content)
    For each i in static_issues: Add i to issues
    Let ai_issues be extract_issues_from_reasoning(reasoning_result)
    For each i in ai_issues: Add i to issues
    Let suggestions be extract_suggestions_from_reasoning(reasoning_result)
    
    Note: Calculate complexity and score
    Let complexity be calculate_complexity(ast)
    Let score be calculate_file_score(issues, suggestions, complexity)
    
    Return dictionary with:
        "file_path" as file_path
        "issues" as issues
        "suggestions" as suggestions
        "score" as score
        "complexity" as complexity

Process called "run_static_lints" that takes file_path as String and content as String returns List[Issue]:
    Let issues be list containing nothing
    Note: Lint 1: '=' used outside assignment context ‚Üí suggest 'equals' or 'is equal to'
    For each (line_text, line_num) in enumerate_lines(content):
        If looks_like_comparison_with_equals(line_text):
            Let issue be dictionary with:
                "severity" as "warning"
                "line" as line_num
                "column" as 1
                "message" as "Use 'equals' instead of '=' for comparisons in natural syntax"
                "fix_suggestion" as suggest_equality_fix(line_text)
                "confidence" as 0.9
            Add issue to issues
        
        Note: Lint 2: '+' or 'plus' with obvious strings ‚Üí suggest 'joined with'
        If contains_string_concat_with_plus(line_text):
            Let issue be dictionary with:
                "severity" as "warning"
                "line" as line_num
                "column" as 1
                "message" as "Use 'joined with' for string concatenation instead of '+' or 'plus'"
                "fix_suggestion" as suggest_joined_with_fix(line_text)
                "confidence" as 0.9
            Add issue to issues
        
        Note: Lint 3: chained '+' with mixed strings
        If contains_mixed_string_numeric_concat(line_text):
            Let issue be dictionary with:
                "severity" as "warning"
                "line" as line_num
                "column" as 1
                "message" as "Prefer a single 'joined with' chain for string building"
                "fix_suggestion" as suggest_joined_with_chain_fix(line_text)
                "confidence" as 0.8
            Add issue to issues
    
    Return issues

Process called "enumerate_lines" that takes text as String returns List[Tuple[String, Integer]]:
    Let lines be split text by "\n"
    Let out be list containing nothing
    Let idx be 1
    For each ln in lines:
        Add tuple containing ln, idx to out
        Set idx to idx plus 1
    Return out

Process called "looks_like_comparison_with_equals" that takes line as String returns Boolean:
    Note: Heuristic: '=' flanked by non-quote words and not part of ":" or annotation
    If line contains ":": Return false
    If line contains "@": Return false
    If Regex.match(line, "[A-Za-z0-9_\]\)"]\s*=\s*[A-Za-z0-9_\("']"): Return true
    Return false

Process called "suggest_equality_fix" that takes line as String returns String:
    Return "Replace '=' with 'equals' or 'is equal to'"

Process called "contains_string_concat_with_plus" that takes line as String returns Boolean:
    If Regex.match(line, '"[^"\\]*(?:\\.[^"\\]*)*"\s*(\+|plus)\s*'):
        Return true
    If Regex.match(line, '(\+|plus)\s*"[^"\\]*(?:\\.[^"\\]*)*"'):
        Return true
    Return false

Process called "suggest_joined_with_fix" that takes line as String returns String:
    Return "Rewrite as 'joined with' (formatter can auto-fix simple cases)"

Process called "contains_mixed_string_numeric_concat" that takes line as String returns Boolean:
    If contains_string_concat_with_plus(line): Return true
    If Regex.match(line, '"[^"\\]*(?:\\.[^"\\]*)*"\s*(\+|plus)\s*[A-Za-z_]') and Regex.match(line, '[A-Za-z_]\s*(\+|plus)\s*[0-9]'):
        Return true
    Return false

Process called "suggest_joined_with_chain_fix" that takes line as String returns String:
    Return "Use 'joined with' consistently for string building chains"

Process called "extract_issues_from_reasoning" that takes result as Dictionary returns List[Issue]:
    Let issues be list containing nothing
    
    For each conclusion in result get "conclusions":
        If conclusion get "type" is equal to "issue":
            Let issue be dictionary with:
                "severity" as conclusion get "severity"
                "line" as conclusion get "line_number"
                "column" as conclusion get "column_number"
                "message" as conclusion get "description"
                "fix_suggestion" as conclusion get "fix"
                "confidence" as conclusion get "confidence_score"
            Add issue to issues
    
    Return issues

Process called "extract_suggestions_from_reasoning" that takes result as Dictionary returns List[Suggestion]:
    Let suggestions be list containing nothing
    
    For each recommendation in result get "recommendations":
        Let suggestion be dictionary with:
            "type" as categorize_suggestion(recommendation)
            "description" as recommendation
            "code_example" as none
            "impact" as "medium"
            "confidence" as 0.8
        Add suggestion to suggestions
    
    Return suggestions

Process called "generate_architectural_insights" that takes root as String and engine as ReasoningEngine returns List[String]:
    Return list containing:
        "Consider implementing dependency injection for better testability"
        "The module structure follows good separation of concerns"
        "Adding caching layer could improve performance by ~30%"
        "Security: All input validation is properly implemented"

Process called "get_severity_icon" that takes severity as String returns String:
    If severity is equal to "error": Return "‚ùå"
    If severity is equal to "warning": Return "‚ö†Ô∏è"
    If severity is equal to "info": Return "‚ÑπÔ∏è"
    Return "‚Ä¢"

Process called "get_suggestion_icon" that takes type as String returns String:
    If type is equal to "performance": Return "‚ö°"
    If type is equal to "security": Return "üîí"
    If type is equal to "style": Return "‚ú®"
    If type is equal to "architecture": Return "üèóÔ∏è"
    Return "üí°"

Process called "calculate_health_rating" that takes score as Float returns String:
    If score >= 90.0: Return "Excellent ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê"
    If score >= 80.0: Return "Good ‚≠ê‚≠ê‚≠ê‚≠ê"
    If score >= 70.0: Return "Fair ‚≠ê‚≠ê‚≠ê"
    If score >= 60.0: Return "Needs Work ‚≠ê‚≠ê"
    Return "Poor ‚≠ê"

Process called "collect_project_files" that takes dir as String returns List[String]:
    Let files be list containing nothing
    Let entries be OS.list_directory(dir)
    
    For each entry in entries:
        Let path be dir plus "/" plus entry
        If OS.is_directory(path):
            Let subfiles be collect_project_files(path)
            For each file in subfiles:
                Add file to files
        Otherwise if entry ends with ".runa":
            Add path to files
    
    Return files

Process called "relative_path" that takes full_path as String and root as String returns String:
    If full_path starts with root:
        Return full_path substring from length of root
    Return full_path

Process called "categorize_suggestion" that takes text as String returns String:
    If text contains "performance" or text contains "speed": Return "performance"
    If text contains "security" or text contains "vulnerability": Return "security"
    If text contains "style" or text contains "format": Return "style"
    Return "architecture"

Process called "calculate_complexity" that takes ast as Any returns Integer:
    Note: Placeholder for cyclomatic complexity calculation
    Return 10

Process called "calculate_file_score" that takes issues as List and suggestions as List and complexity as Integer returns Float:
    Let base_score be 100.0
    Let issue_penalty be length of issues multiplied by 5.0
    Let complexity_penalty be complexity multiplied by 0.5
    Let score be base_score minus issue_penalty minus complexity_penalty
    Return maximum_float(0.0, minimum_float(100.0, score))

Process called "generate_unique_id" returns String:
    Return "doctor-" plus string_from_integer(get_timestamp_ms())

Process called "get_timestamp_ms" returns Integer:
    Return 1704067200000

Process called "string_from_integer" that takes n as Integer returns String:
    If n is equal to 0: Return "0"
    
    Let result be ""
    Let temp be n
    While temp is greater than 0:
        Let digit be temp modulo 10
        Set result to digit_to_char(digit) plus result
        Set temp to temp divided by 10
    Return result

Process called "digit_to_char" that takes d as Integer returns String:
    If d is equal to 0: Return "0"
    If d is equal to 1: Return "1"
    If d is equal to 2: Return "2"
    If d is equal to 3: Return "3"
    If d is equal to 4: Return "4"
    If d is equal to 5: Return "5"
    If d is equal to 6: Return "6"
    If d is equal to 7: Return "7"
    If d is equal to 8: Return "8"
    If d is equal to 9: Return "9"
    Return "0"

Process called "float_to_string" that takes f as Float returns String:
    Return string_from_integer(f as Integer)

Process called "minimum_float" that takes a as Float and b as Float returns Float:
    If a is less than b: Return a
    Return b

Process called "maximum_float" that takes a as Float and b as Float returns Float:
    If a is greater than b: Return a
    Return b