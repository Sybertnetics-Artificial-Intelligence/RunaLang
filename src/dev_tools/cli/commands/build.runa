Note:
Runa CLI: Build Command
Compiles Runa projects with dependency resolution and optimization
:End Note

Import "../../../stdlib/os/os" as OS
Import "../../../stdlib/io/file" as File
Import "../../../stdlib/io/console" as Console
Import "../../../stdlib/collections/list" as List
Import "../../../compiler/driver" as Compiler
Import "../../package/resolver" as Resolver
Import "../../syntax_converter/localization/engine" as Loc

Process called "execute" that takes context as Dictionary returns Integer:
    Let project_root be context get "project_root"
    
    If project_root is none:
        Console.print_error("Error: Not in a Runa project directory")
        Console.print("Run this command from a directory containing runa.toml")
        Return 1
    
    Let config be context get "config"
    Let flags be context get "flags"
    
    Note: Determine build mode
    Let is_release be flags get "release"
    Let build_mode be "release" if is_release else "debug"
    
    Console.print("Building " plus config get "name" plus " v" plus config get "version" plus " [" plus build_mode plus "]")
    
    Note: Create target directory
    Let target_dir be project_root plus "/target/" plus build_mode
    If not OS.directory_exists(target_dir):
        OS.create_directory_recursive(target_dir)
    
    Note: Resolve dependencies
    Console.print("Resolving dependencies...")
    Let dependencies be Resolver.resolve_dependencies(config)
    If dependencies get "error":
        Console.print_error("Failed to resolve dependencies: " plus dependencies get "error")
        Return 1
    
    Note: Collect source files
    Let source_files be collect_source_files(project_root plus "/src")
    Console.print("Found " plus string_from_integer(length of source_files) plus " source files")

    Note: Normalize sources to canonical language (en) for compilation
    Let normalized_root be target_dir plus "/normalized"
    Let default_lang be config.get("default_language", "detect")
    Let normalized_files be normalize_sources(project_root, source_files, normalized_root, default_lang)
    
    Note: Configure compiler options
    Let compiler_options be dictionary with:
        "input_files" as normalized_files
        "output_dir" as target_dir
        "optimization_level" as "O3" if is_release else "O0"
        "debug_info" as not is_release
        "target_triple" as detect_target_triple()
        "dependencies" as dependencies get "resolved"
        "incremental" as true
    
    Note: Apply syntax mode configuration to compiler options
    Import "../mode_support" as ModeSupport
    Let mode_config be context get "syntax_mode"
    Set compiler_options to ModeSupport.apply_mode_to_compiler_options(compiler_options, mode_config)
    
    Note: Invoke compiler
    Console.print("Compiling...")
    Let compile_result be Compiler.compile(compiler_options)
    
    If compile_result get "success":
        Let output_file be compile_result get "output_file"
        Let compile_time be compile_result get "compile_time"
        
        Console.print("✓ Build successful!")
        Console.print("  Output: " plus output_file)
        Console.print("  Time: " plus format_duration(compile_time))
        
        Note: Copy resources if they exist
        If OS.directory_exists(project_root plus "/resources"):
            copy_resources(project_root plus "/resources", target_dir plus "/resources")
            Console.print("✓ Copied resources")
        
        Return 0
    Otherwise:
        Console.print_error("Build failed:")
        For each error in compile_result get "errors":
            Console.print_error("  " plus error)
        Return 1

Process called "collect_source_files" that takes dir as String returns List[String]:
    Let files be list containing nothing
    Let entries be OS.list_directory(dir)
    
    For each entry in entries:
        Let path be dir plus "/" plus entry
        If OS.is_directory(path):
            Let subdir_files be collect_source_files(path)
            For each file in subdir_files:
                Add file to files
        Otherwise if entry ends with ".runa":
            Add path to files
    
    Return files
Process called "normalize_sources" that takes project_root as String and files as List[String] and out_root as String and default_lang as String returns List[String]:
    If not OS.directory_exists(out_root):
        OS.create_directory_recursive(out_root)
    Let result be list containing nothing
    For each path in files:
        Let rel be make_relative(path, project_root plus "/src")
        Let out_path be out_root plus "/" plus rel
        Let out_dir be parent_directory_of(out_path)
        If not OS.directory_exists(out_dir):
            OS.create_directory_recursive(out_dir)
        Let content be File.read_text(path)
        Let from_lang as String
        If default_lang is equal to "detect":
            Let detected be Loc.detect_language(content)
            Set from_lang to detected if detected else "en"
        Otherwise:
            Set from_lang to default_lang
        Let translated be Loc.translate_source(content, from_lang, "en")
        File.write_text(out_path, translated)
        Add out_path to result
    Return result

Process called "make_relative" that takes full as String and base as String returns String:
    If starts_with(full, base):
        Return substring(full, length of base plus 1, length of full)
    Return full

Process called "starts_with" that takes s as String and prefix as String returns Boolean:
    If length of s < length of prefix: Return false
    Return substring(s, 0, length of prefix) is equal to prefix

Process called "parent_directory_of" that takes path as String returns String:
    Let i be last_index_of(path, "/")
    If i < 0: Return path
    Return substring(path, 0, i)

Process called "last_index_of" that takes s as String and needle as String returns Integer:
    Let i be length of s minus length of needle
    While i >= 0:
        If substring(s, i, i plus length of needle) is equal to needle:
            Return i
        Set i to i minus 1
    Return -1

Process called "detect_target_triple" returns String:
    Let os_name be OS.get_os_name()
    Let arch be OS.get_architecture()
    
    If os_name is equal to "linux":
        Return arch plus "-unknown-linux-gnu"
    Otherwise if os_name is equal to "macos":
        Return arch plus "-apple-darwin"
    Otherwise if os_name is equal to "windows":
        Return arch plus "-pc-windows-msvc"
    Otherwise:
        Return arch plus "-unknown-unknown"

Process called "copy_resources" that takes source as String and dest as String returns Nothing:
    If not OS.directory_exists(dest):
        OS.create_directory_recursive(dest)
    
    Let entries be OS.list_directory(source)
    For each entry in entries:
        Let source_path be source plus "/" plus entry
        Let dest_path be dest plus "/" plus entry
        
        If OS.is_directory(source_path):
            copy_resources(source_path, dest_path)
        Otherwise:
            File.copy(source_path, dest_path)

Process called "format_duration" that takes seconds as Float returns String:
    If seconds is less than 1.0:
        Let ms be seconds multiplied by 1000.0
        Return float_to_string(ms) plus "ms"
    Otherwise if seconds is less than 60.0:
        Return float_to_string(seconds) plus "s"
    Otherwise:
        Let minutes be seconds divided by 60.0
        Return float_to_string(minutes) plus "m"

Process called "string_from_integer" that takes n as Integer returns String:
    Note: Convert integer to string
    If n is equal to 0:
        Return "0"
    
    Let result be ""
    Let temp be n
    Let is_negative be false
    
    If temp is less than 0:
        Set is_negative to true
        Set temp to 0 minus temp
    
    While temp is greater than 0:
        Let digit be temp modulo 10
        Set result to digit_to_char(digit) plus result
        Set temp to temp divided by 10
    
    If is_negative:
        Set result to "-" plus result
    
    Return result

Process called "float_to_string" that takes f as Float returns String:
    Note: Simplified float to string conversion
    Return string_from_integer(f as Integer)

Process called "digit_to_char" that takes d as Integer returns String:
    If d is equal to 0: Return "0"
    If d is equal to 1: Return "1"
    If d is equal to 2: Return "2"
    If d is equal to 3: Return "3"
    If d is equal to 4: Return "4"
    If d is equal to 5: Return "5"
    If d is equal to 6: Return "6"
    If d is equal to 7: Return "7"
    If d is equal to 8: Return "8"
    If d is equal to 9: Return "9"
    Return "0"