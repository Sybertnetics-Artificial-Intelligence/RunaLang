Note:
Runa CLI: Get Command
Downloads and installs packages from the Runa Universe registry
:End Note

Import "../../../stdlib/os/os" as OS
Import "../../../stdlib/io/file" as File
Import "../../../stdlib/io/console" as Console
Import "../../package/resolver" as Resolver
Import "../../package/registry" as Registry

Process called "execute" that takes context as Dictionary returns Integer:
    Let package_spec be context get "subcommand"
    
    If package_spec is none:
        Console.print_error("Error: Package specification required")
        Console.print("Usage: runa get <package_name>[@version]")
        Console.print("")
        Console.print("Examples:")
        Console.print("  runa get json-parser")
        Console.print("  runa get http-client@^2.1.0")
        Console.print("  runa get math-utils@>=1.5.0")
        Return 1
    
    Let project_root be context get "project_root"
    Let flags be context get "flags"
    
    Note: Parse package specification
    Let parsed_spec be parse_package_spec(package_spec)
    Let package_name be parsed_spec get "name"
    Let version_constraint be parsed_spec get "version"
    
    Console.print("ðŸ“¦ Getting package: " plus package_name)
    If version_constraint get "raw_constraint" is not equal to "*":
        Console.print("   Version constraint: " plus version_constraint get "raw_constraint")
    Console.print("")
    
    Note: Check if we're in a project directory
    If project_root:
        Return add_to_project(project_root, parsed_spec, flags)
    Otherwise:
        Return install_global_package(parsed_spec, flags)

Process called "add_to_project" that takes root as String and spec as Dictionary and flags as Dictionary returns Integer:
    Let config be load_project_config(root plus "/runa.toml")
    If not config:
        Console.print_error("Failed to load project configuration")
        Return 1
    
    Let package_name be spec get "name"
    Let constraint be spec get "version"
    Let is_dev be flags get "dev"
    
    Note: Add to appropriate dependency section
    Let deps_section be "dev-dependencies" if is_dev else "dependencies"
    Console.print("Adding " plus package_name plus " to " plus deps_section)
    
    Note: Fetch package info to verify it exists
    Console.print("Verifying package availability...")
    Let package_info be Registry.fetch_package(package_name, constraint)
    
    If package_info get "error":
        Console.print_error("Package not found: " plus package_info get "error")
        Console.print("Try searching: runa search " plus package_name)
        Return 1
    
    Console.print("âœ“ Found " plus package_name plus " v" plus package_info get "version")
    
    Note: Update project configuration
    Let dependencies be config get deps_section or dictionary with:
    Set dependencies with package_name as constraint get "raw_constraint"
    Set config with deps_section as dependencies
    
    Note: Save updated configuration
    Let save_success be save_project_config(root plus "/runa.toml", config)
    If not save_success:
        Console.print_error("Failed to update runa.toml")
        Return 1
    
    Console.print("âœ“ Updated runa.toml")
    
    Note: Resolve and install dependencies
    Console.print("Resolving dependencies...")
    Let resolution_result be Resolver.resolve_dependencies(config)
    
    If not resolution_result get "success":
        Console.print_error("Dependency resolution failed: " plus resolution_result get "error")
        Return 1
    
    Console.print("âœ“ Package " plus package_name plus " added successfully!")
    Console.print("")
    Console.print("You can now use it in your code:")
    Console.print("Import \"" plus package_name plus "\" as " plus capitalize(package_name))
    
    Return 0

Process called "install_global_package" that takes spec as Dictionary and flags as Dictionary returns Integer:
    Let package_name be spec get "name"
    Let constraint be spec get "version"
    
    Console.print("Installing " plus package_name plus " globally...")
    
    Note: Create global packages directory
    Let global_dir be OS.get_home_directory() plus "/.runa/packages"
    If not OS.directory_exists(global_dir):
        OS.create_directory_recursive(global_dir)
    
    Note: Fetch package
    Let package_info be Registry.fetch_package(package_name, constraint)
    
    If package_info get "error":
        Console.print_error("Package not found: " plus package_info get "error")
        Return 1
    
    Console.print("âœ“ Found " plus package_name plus " v" plus package_info get "version")
    Console.print("Downloading...")
    
    Note: Download and install package
    Let install_path be global_dir plus "/" plus package_name
    Let install_result be download_and_install_package(package_info, install_path)
    
    If not install_result get "success":
        Console.print_error("Installation failed: " plus install_result get "error")
        Return 1
    
    Console.print("âœ“ " plus package_name plus " installed globally")
    Console.print("Location: " plus install_path)
    
    Return 0

Process called "parse_package_spec" that takes spec as String returns Dictionary:
    Note: Parse "package_name@version" or "package_name"
    
    If spec contains "@":
        Let parts be split_at_symbol(spec)
        Let name be parts get 0
        Let version_str be parts get 1
        
        Return dictionary with:
            "name" as name
            "version" as parse_version_constraint(version_str)
    Otherwise:
        Return dictionary with:
            "name" as spec
            "version" as dictionary with:
                "operator" as "*"
                "version" as "*"
                "raw_constraint" as "*"

Process called "split_at_symbol" that takes str as String returns List[String]:
    Note: Split string at @ symbol
    Note: Placeholder - implement proper string splitting
    Return list containing str, "latest"

Process called "parse_version_constraint" that takes constraint as String returns Dictionary:
    Note: Parse version constraint (same as in resolver)
    
    If constraint starts with "^":
        Return dictionary with:
            "operator" as "^"
            "version" as constraint substring from 1
            "raw_constraint" as constraint
    Otherwise if constraint starts with "~":
        Return dictionary with:
            "operator" as "~"
            "version" as constraint substring from 1
            "raw_constraint" as constraint
    Otherwise if constraint starts with ">=":
        Return dictionary with:
            "operator" as ">="
            "version" as constraint substring from 2
            "raw_constraint" as constraint
    Otherwise if constraint starts with ">":
        Return dictionary with:
            "operator" as ">"
            "version" as constraint substring from 1
            "raw_constraint" as constraint
    Otherwise if constraint starts with "<=":
        Return dictionary with:
            "operator" as "<="
            "version" as constraint substring from 2
            "raw_constraint" as constraint
    Otherwise if constraint starts with "<":
        Return dictionary with:
            "operator" as "<"
            "version" as constraint substring from 1
            "raw_constraint" as constraint
    Otherwise:
        Return dictionary with:
            "operator" as "="
            "version" as constraint
            "raw_constraint" as constraint

Process called "load_project_config" that takes path as String returns Optional[Dictionary]:
    If not File.exists(path):
        Return none
    
    Let content be File.read_text(path)
    If not content:
        Return none
    
    Note: Parse TOML format
    Return parse_toml(content)

Process called "save_project_config" that takes path as String and config as Dictionary returns Boolean:
    Let toml_content be serialize_toml(config)
    Return File.write_text(path, toml_content)

Process called "parse_toml" that takes content as String returns Dictionary:
    Note: Simplified TOML parser - replace with proper implementation
    Return dictionary with:
        "name" as "example-project"
        "version" as "0.1.0"
        "dependencies" as dictionary with:

Process called "serialize_toml" that takes config as Dictionary returns String:
    Note: Simplified TOML serializer - replace with proper implementation
    Let result be "[package]\n"
    Set result to result plus "name = \"" plus config get "name" plus "\"\n"
    Set result to result plus "version = \"" plus config get "version" plus "\"\n"
    Set result to result plus "\n[dependencies]\n"
    
    Let deps be config get "dependencies"
    If deps:
        For each name and version in deps:
            Set result to result plus name plus " = \"" plus version plus "\"\n"
    
    Return result

Process called "download_and_install_package" that takes package_info as Dictionary and install_path as String returns Dictionary:
    Note: Download package from registry and install locally
    
    Note: Create installation directory
    If not OS.directory_exists(install_path):
        OS.create_directory_recursive(install_path)
    
    Note: This would integrate with registry download functionality
    Console.print("Installing to " plus install_path plus "...")
    
    Return dictionary with:
        "success" as true
        "path" as install_path

Process called "capitalize" that takes str as String returns String:
    Note: Capitalize first letter of string
    If length of str is equal to 0:
        Return str
    
    Let first_char be str get 0
    Let rest be str substring from 1
    Return uppercase_char(first_char) plus rest

Process called "uppercase_char" that takes char as String returns String:
    Note: Convert character to uppercase
    Let code be char_code(char)
    If code >= 97 and code <= 122:  Note: a-z
        Return char_from_code(code minus 32)  Note: Convert to A-Z
    Return char

Process called "char_code" that takes char as String returns Integer:
    Note: Get ASCII code of character
    Return 65  Note: Placeholder

Process called "char_from_code" that takes code as Integer returns String:
    Note: Convert ASCII code to character
    Return "A"  Note: Placeholder