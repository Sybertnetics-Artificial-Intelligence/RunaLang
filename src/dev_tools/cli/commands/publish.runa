Note:
Runa CLI: Publish Command
Publishes packages to the Runa Universe registry with validation and security checks
:End Note

Import "../../../stdlib/os/os" as OS
Import "../../../stdlib/io/file" as File
Import "../../../stdlib/io/console" as Console
Import "../../package/registry" as Registry
Import "./build" as Build
Import "./test" as Test

Process called "execute" that takes context as Dictionary returns Integer:
    Let project_root be context get "project_root"
    
    If project_root is none:
        Console.print_error("Error: Not in a Runa project directory")
        Console.print("Run this command from a directory containing runa.toml")
        Return 1
    
    Let config be context get "config"
    Let flags be context get "flags"
    
    Console.print("üì¶ Publishing " plus config get "name" plus " v" plus config get "version")
    Console.print("========================================")
    Console.print("")
    
    Note: Pre-publication validation
    Let validation_result be validate_package_for_publishing(project_root, config, flags)
    If validation_result get "exit_code" is not equal to 0:
        Return validation_result get "exit_code"
    
    Note: Confirm publication
    If not flags get "yes":
        If not confirm_publication(config):
            Console.print("Publication cancelled")
            Return 0
    
    Note: Build release version
    Console.print("üî® Building release version...")
    Let build_context be prepare_release_build_context(context)
    Let build_result be Build.execute(build_context)
    
    If build_result is not equal to 0:
        Console.print_error("Release build failed - cannot publish")
        Return build_result
    
    Console.print("‚úì Release build successful")
    Console.print("")
    
    Note: Publish to registry
    Console.print("üöÄ Publishing to Runa Universe...")
    Let publish_result be Registry.publish_package(project_root, config)
    
    If publish_result get "error":
        Console.print_error("Publication failed: " plus publish_result get "error")
        Return 1
    
    Console.print("")
    Console.print("üéâ Package published successfully!")
    Console.print("   Name: " plus config get "name")
    Console.print("   Version: " plus publish_result get "version")
    Console.print("   Registry URL: " plus publish_result get "url")
    Console.print("")
    Console.print("Your package is now available:")
    Console.print("   runa get " plus config get "name")
    
    Return 0

Process called "validate_package_for_publishing" that takes root as String and config as Dictionary and flags as Dictionary returns Dictionary:
    Console.print("üîç Validating package for publication...")
    Console.print("")
    
    Note: Check required fields
    Let validation_errors be list containing nothing
    
    If not config get "name":
        Add "Package name is required" to validation_errors
    
    If not config get "version":
        Add "Package version is required" to validation_errors
    
    If not config get "description":
        Add "Package description is required" to validation_errors
    
    If not config get "authors":
        Add "Package authors are required" to validation_errors
    
    If not config get "license":
        Add "Package license is required" to validation_errors
    
    Note: Validate version format
    If config get "version":
        If not is_valid_semver(config get "version"):
            Add "Version must be valid semantic version (e.g., 1.2.3)" to validation_errors
    
    Note: Check for README
    If not File.exists(root plus "/README.md"):
        Add "README.md file is required" to validation_errors
    
    Note: Check for source files
    If not OS.directory_exists(root plus "/src"):
        Add "src/ directory with source files is required" to validation_errors
    
    If length of validation_errors is greater than 0:
        Console.print_error("‚ùå Package validation failed:")
        For each error in validation_errors:
            Console.print_error("   ‚Ä¢ " plus error)
        Console.print("")
        Console.print("Fix these issues before publishing")
        Return dictionary with "exit_code" as 1
    
    Note: Run tests if they exist
    If not flags get "skip-tests" and OS.directory_exists(root plus "/tests"):
        Console.print("üß™ Running tests before publication...")
        Let test_context be create_test_context(root, config)
        Let test_result be Test.execute(test_context)
        
        If test_result is not equal to 0:
            Console.print_error("‚ùå Tests failed - cannot publish")
            Console.print("Use --skip-tests to bypass (not recommended)")
            Return dictionary with "exit_code" as test_result
        
        Console.print("‚úì All tests passed")
    
    Note: Check for sensitive files
    Let sensitive_files be check_for_sensitive_files(root)
    If length of sensitive_files is greater than 0:
        Console.print("‚ö†Ô∏è  Warning: Sensitive files detected:")
        For each file in sensitive_files:
            Console.print("   ‚Ä¢ " plus file)
        Console.print("These files will NOT be included in the package")
        Console.print("")
    
    Console.print("‚úì Package validation successful")
    Console.print("")
    
    Return dictionary with "exit_code" as 0

Process called "confirm_publication" that takes config as Dictionary returns Boolean:
    Console.print("About to publish:")
    Console.print("   Package: " plus config get "name")
    Console.print("   Version: " plus config get "version")
    Console.print("   Description: " plus config get "description")
    Console.print("")
    Console.print("This action cannot be undone. Proceed? (y/N): ")
    
    Note: In real implementation, would read from stdin
    Let response be "y"  Note: Placeholder for user input
    
    Return response is equal to "y" or response is equal to "Y"

Process called "prepare_release_build_context" that takes context as Dictionary returns Dictionary:
    Let release_context be context
    
    Note: Set release flag
    Let flags be release_context get "flags"
    Set flags with "release" as true
    Set release_context with "flags" as flags
    
    Return release_context

Process called "create_test_context" that takes root as String and config as Dictionary returns Dictionary:
    Return dictionary with:
        "project_root" as root
        "config" as config
        "flags" as dictionary with:

Process called "is_valid_semver" that takes version as String returns Boolean:
    Note: Validate semantic version format (major.minor.patch)
    Let parts be split_version_string(version)
    
    If length of parts is not equal to 3:
        Return false
    
    For each part in parts:
        If not is_numeric(part):
            Return false
        
        Let num be parse_integer(part)
        If num is less than 0:
            Return false
    
    Return true

Process called "check_for_sensitive_files" that takes root as String returns List[String]:
    Let sensitive_patterns be list containing:
        "*.key"
        "*.pem"
        "*.p12"
        "*.pfx"
        ".env*"
        "secrets*"
        "credentials*"
        "config.toml"
        "*.log"
        "*.tmp"
        ".DS_Store"
        "Thumbs.db"
    
    Let sensitive_files be list containing nothing
    Let all_files be collect_all_files(root)
    
    For each file_path in all_files:
        Let filename be extract_filename(file_path)
        If matches_any_pattern(filename, sensitive_patterns):
            Add file_path to sensitive_files
    
    Return sensitive_files

Process called "collect_all_files" that takes dir as String returns List[String]:
    Let files be list containing nothing
    Let entries be OS.list_directory(dir)
    
    For each entry in entries:
        Let path be dir plus "/" plus entry
        
        Note: Skip build and cache directories
        If entry is equal to "target" or entry is equal to ".git" or entry is equal to "node_modules":
            Continue
        
        If OS.is_directory(path):
            Let subfiles be collect_all_files(path)
            For each file in subfiles:
                Add file to files
        Otherwise:
            Add path to files
    
    Return files

Process called "extract_filename" that takes path as String returns String:
    Let parts be split_string(path, "/")
    Return parts get (length of parts minus 1)

Process called "matches_any_pattern" that takes filename as String and patterns as List[String] returns Boolean:
    For each pattern in patterns:
        If matches_pattern(filename, pattern):
            Return true
    Return false

Process called "matches_pattern" that takes filename as String and pattern as String returns Boolean:
    Note: Simple glob pattern matching
    If pattern ends with "*":
        Let prefix be pattern substring from 0 to (length of pattern minus 1)
        Return filename starts with prefix
    Otherwise if pattern starts with "*":
        Let suffix be pattern substring from 1
        Return filename ends with suffix
    Otherwise:
        Return filename is equal to pattern

Process called "split_version_string" that takes version as String returns List[String]:
    Note: Split version string by dots
    Note: Placeholder implementation
    Return list containing "1", "0", "0"

Process called "split_string" that takes str as String and delimiter as String returns List[String]:
    Note: Placeholder for string splitting
    Return list containing str

Process called "is_numeric" that takes str as String returns Boolean:
    Note: Check if string contains only digits
    For each char in str:
        If not is_digit(char):
            Return false
    Return true

Process called "is_digit" that takes char as String returns Boolean:
    Let code be char_code(char)
    Return code >= 48 and code <= 57

Process called "char_code" that takes char as String returns Integer:
    Return 48  Note: Placeholder

Process called "parse_integer" that takes str as String returns Integer:
    Note: Parse string to integer
    Return 0  Note: Placeholder