Note:
runtime/src/aott/compilation/backends/aarch64/instruction_selector.runa
Advanced Instruction Selection for AArch64 AOTT Code Generation

This module provides comprehensive instruction selection functionality including:
- Pattern matching for optimal AArch64 instruction selection
- Cost-based instruction selection with multiple alternatives
- Integration with NEON/Advanced SIMD vector instructions
- Integration with SVE (Scalable Vector Extension) instructions
- Profile-guided instruction selection decisions
- Complex addressing mode utilization including pre/post-indexing
- Instruction fusion and macro-operation optimization
- Integration with AOTT tier system for selection strategies
- Mathematical operation optimization with Greek symbols
- Branch prediction and conditional instruction optimization
- Integration with register allocation for optimal instruction forms
- Instruction latency and throughput optimization for ARM cores
- Support for both natural and technical syntax optimization
- ARMv8-A specific instruction pattern matching
- Conditional execution and predication support
- Load/store pair instruction optimization
- Barrel shifter integration for efficient operations
- Pointer authentication instruction selection
:End Note

Import "dev/debug/errors/core" as Errors

Note: =====================================================================
Note: AARCH64 INSTRUCTION SELECTOR DATA STRUCTURES
Note: =====================================================================

Type called "AArch64InstructionSelector":
    selector_id as String
    selection_strategy as SelectionStrategy
    pattern_matcher as PatternMatcher
    cost_model as CostModel
    instruction_database as AArch64InstructionDatabase
    target_features as Dictionary[String, Boolean]
    optimization_level as Integer
    profile_data as Dictionary[String, ProfileInfo]
    selection_statistics as SelectionStatistics
    neon_enabled as Boolean
    sve_enabled as Boolean

Type called "SelectionStrategy":
    strategy_name as String
    optimization_goals as List[String]
    cost_weighting as Dictionary[String, Float]
    pattern_priority as Dictionary[String, Integer]
    enable_fusion as Boolean
    enable_vectorization as Boolean
    enable_conditional_execution as Boolean
    prefer_load_store_pairs as Boolean

Type called "PatternMatcher":
    matcher_id as String
    patterns as List[InstructionPattern]
    neon_patterns as List[VectorPattern]
    sve_patterns as List[ScalableVectorPattern]
    pattern_cache as Dictionary[String, List[String]]
    match_statistics as Dictionary[String, Integer]

Type called "InstructionPattern":
    pattern_id as String
    pattern_name as String
    input_pattern as String
    output_instructions as List[String]
    applicability_conditions as List[String]
    cost_estimate as Integer
    latency_cycles as Integer
    throughput_reciprocal as Float
    required_features as List[String]

Type called "VectorPattern":
    pattern_id as String
    vector_operation as String
    neon_instructions as List[String]
    element_types as List[String]
    vector_widths as List[Integer]
    lane_operations as List[String]
    cost_estimate as Integer

Type called "ScalableVectorPattern":
    pattern_id as String
    sve_operation as String
    sve_instructions as List[String]
    predicate_usage as List[String]
    vector_length_agnostic as Boolean
    cost_per_element as Float

Type called "CostModel":
    model_id as String
    instruction_costs as Dictionary[String, InstructionCost]
    addressing_costs as Dictionary[String, Integer]
    vector_costs as Dictionary[String, VectorCost]
    register_pressure_weight as Float
    latency_weight as Float
    throughput_weight as Float
    energy_weight as Float

Type called "InstructionCost":
    base_cost as Integer
    latency_cost as Integer
    throughput_cost as Float
    register_pressure as Integer
    memory_pressure as Integer
    dependency_cost as Integer
    energy_cost as Float

Type called "VectorCost":
    neon_cost as Integer
    sve_cost as Integer
    predicate_cost as Integer
    lane_cost as Float
    vector_memory_cost as Integer

Type called "AArch64InstructionDatabase":
    database_id as String
    aarch64_instructions as Dictionary[String, AArch64InstructionInfo]
    neon_instructions as Dictionary[String, NEONInstructionInfo]
    sve_instructions as Dictionary[String, SVEInstructionInfo]
    addressing_modes as Dictionary[String, AddressingModeInfo]
    condition_codes as Dictionary[String, ConditionInfo]

Type called "AArch64InstructionInfo":
    mnemonic as String
    opcode as Integer
    operand_types as List[String]
    flags_affected as List[String]
    execution_units as List[String]
    latency as Integer
    reciprocal_throughput as Float
    micro_ops as Integer
    can_be_conditional as Boolean

Type called "NEONInstructionInfo":
    mnemonic as String
    vector_width as Integer
    element_type as String
    lane_count as Integer
    execution_port as String
    latency as Integer
    throughput as Float
    power_usage as String
    supports_immediate as Boolean

Type called "SVEInstructionInfo":
    mnemonic as String
    scalable_vector as Boolean
    predicate_input as Boolean
    element_type as String
    execution_unit as String
    latency_per_element as Float
    throughput_factor as Float
    vector_length_dependent as Boolean

Type called "AddressingModeInfo":
    mode_name as String
    components as List[String]
    offset_range as Dictionary[String, Integer]
    supports_writeback as Boolean
    cache_friendly as Boolean
    encoding_size as Integer

Type called "ConditionInfo":
    condition_code as String
    condition_bits as Integer
    flags_required as List[String]
    inverse_condition as String

Type called "SelectionContext":
    context_id as String
    current_basic_block as String
    available_registers as List[String]
    live_variables as List[String]
    instruction_dependencies as Dictionary[String, List[String]]
    branch_probability as Float
    vector_context as VectorContext

Type called "VectorContext":
    available_vector_registers as List[String]
    current_vector_length as Integer
    predicate_registers as List[String]
    vector_operation_context as String

Type called "ProfileInfo":
    execution_frequency as Integer
    instruction_mix as Dictionary[String, Integer]
    cache_behavior as Dictionary[String, Float]
    branch_patterns as Dictionary[String, Float]
    vector_usage_patterns as Dictionary[String, Integer]

Type called "SelectionStatistics":
    patterns_matched as Integer
    instructions_selected as Integer
    vectorization_opportunities as Integer
    fusion_opportunities as Integer
    conditional_optimizations as Integer
    selection_time_ms as Integer

Note: =====================================================================
Note: INSTRUCTION SELECTOR OPERATIONS
Note: =====================================================================

Process called "create_aarch64_instruction_selector" that takes selector_name as String, strategy as SelectionStrategy returns AArch64InstructionSelector:
    Note: Create AArch64 instruction selector with specified strategy
    Note: TODO: Implement instruction selector creation
    Throw Errors.NotImplemented with "Instruction selector creation not yet implemented"

Process called "initialize_aarch64_patterns" that takes selector as AArch64InstructionSelector returns Boolean:
    Note: Initialize AArch64 instruction selection patterns
    Note: TODO: Implement pattern initialization
    Throw Errors.NotImplemented with "Pattern initialization not yet implemented"

Process called "configure_for_tier" that takes selector as AArch64InstructionSelector, tier as Integer returns Boolean:
    Note: Configure selector for specific AOTT tier level
    Note: TODO: Implement tier configuration
    Throw Errors.NotImplemented with "Tier configuration not yet implemented"

Note: =====================================================================
Note: PATTERN MATCHING OPERATIONS
Note: =====================================================================

Process called "select_instructions_for_block" that takes selector as AArch64InstructionSelector, bytecode_block as List[String], context as SelectionContext returns List[String]:
    Note: Select optimal AArch64 instructions for basic block
    Note: TODO: Implement instruction selection for block
    Throw Errors.NotImplemented with "Instruction selection for block not yet implemented"

Process called "match_instruction_patterns" that takes selector as AArch64InstructionSelector, bytecode_instruction as String returns List[InstructionPattern]:
    Note: Find matching instruction patterns for bytecode
    Note: TODO: Implement pattern matching
    Throw Errors.NotImplemented with "Pattern matching not yet implemented"

Process called "evaluate_pattern_applicability" that takes selector as AArch64InstructionSelector, pattern as InstructionPattern, context as SelectionContext returns Boolean:
    Note: Evaluate if pattern is applicable in current context
    Note: TODO: Implement pattern applicability evaluation
    Throw Errors.NotImplemented with "Pattern applicability evaluation not yet implemented"

Process called "select_best_pattern" that takes selector as AArch64InstructionSelector, candidates as List[InstructionPattern], context as SelectionContext returns InstructionPattern:
    Note: Select best pattern based on cost model
    Note: TODO: Implement best pattern selection
    Throw Errors.NotImplemented with "Best pattern selection not yet implemented"

Note: =====================================================================
Note: ARITHMETIC INSTRUCTION SELECTION
Note: =====================================================================

Process called "select_arithmetic_instruction" that takes selector as AArch64InstructionSelector, operation as String, operands as List[String], data_type as String returns List[String]:
    Note: Select optimal arithmetic instruction for operation
    Note: TODO: Implement arithmetic instruction selection
    Throw Errors.NotImplemented with "Arithmetic instruction selection not yet implemented"

Process called "select_multiplication_strategy" that takes selector as AArch64InstructionSelector, operands as List[String], immediate_values as List[Integer] returns String:
    Note: Select optimal multiplication strategy (MUL, MADD, shifts)
    Note: TODO: Implement multiplication strategy selection
    Throw Errors.NotImplemented with "Multiplication strategy selection not yet implemented"

Process called "select_division_strategy" that takes selector as AArch64InstructionSelector, operands as List[String], divisor as String returns String:
    Note: Select optimal division strategy (UDIV, SDIV, reciprocal)
    Note: TODO: Implement division strategy selection
    Throw Errors.NotImplemented with "Division strategy selection not yet implemented"

Process called "optimize_barrel_shifter_usage" that takes selector as AArch64InstructionSelector, shift_operations as List[String] returns List[String]:
    Note: Optimize operations using AArch64 barrel shifter
    Note: TODO: Implement barrel shifter optimization
    Throw Errors.NotImplemented with "Barrel shifter optimization not yet implemented"

Note: =====================================================================
Note: MEMORY INSTRUCTION SELECTION
Note: =====================================================================

Process called "select_load_store_instruction" that takes selector as AArch64InstructionSelector, operation as String, addressing_mode as String, operands as List[String] returns String:
    Note: Select optimal load/store instruction and addressing mode
    Note: TODO: Implement load/store instruction selection
    Throw Errors.NotImplemented with "Load/store instruction selection not yet implemented"

Process called "select_load_store_pair" that takes selector as AArch64InstructionSelector, operations as List[String] returns String:
    Note: Select load/store pair instructions (LDP/STP) when beneficial
    Note: TODO: Implement load/store pair selection
    Throw Errors.NotImplemented with "Load/store pair selection not yet implemented"

Process called "optimize_addressing_modes" that takes selector as AArch64InstructionSelector, memory_operations as List[String] returns List[String]:
    Note: Select optimal addressing modes including pre/post-indexing
    Note: TODO: Implement addressing mode optimization
    Throw Errors.NotImplemented with "Addressing mode optimization not yet implemented"

Process called "select_atomic_instructions" that takes selector as AArch64InstructionSelector, atomic_operations as List[String] returns List[String]:
    Note: Select appropriate atomic instructions for concurrent operations
    Note: TODO: Implement atomic instruction selection
    Throw Errors.NotImplemented with "Atomic instruction selection not yet implemented"

Note: =====================================================================
Note: VECTORIZATION INSTRUCTION SELECTION
Note: =====================================================================

Process called "select_neon_instructions" that takes selector as AArch64InstructionSelector, vector_operations as List[String], vector_width as Integer returns List[String]:
    Note: Select optimal NEON instructions for SIMD operations
    Note: TODO: Implement NEON instruction selection
    Throw Errors.NotImplemented with "NEON instruction selection not yet implemented"

Process called "select_sve_instructions" that takes selector as AArch64InstructionSelector, scalable_operations as List[String], vector_length as Integer returns List[String]:
    Note: Select appropriate SVE instructions for scalable vector operations
    Note: TODO: Implement SVE instruction selection
    Throw Errors.NotImplemented with "SVE instruction selection not yet implemented"

Process called "select_predicate_instructions" that takes selector as AArch64InstructionSelector, predicate_operations as List[String] returns List[String]:
    Note: Select SVE predicate instructions for vector predicates
    Note: TODO: Implement predicate instruction selection
    Throw Errors.NotImplemented with "Predicate instruction selection not yet implemented"

Process called "optimize_vector_loads_stores" that takes selector as AArch64InstructionSelector, memory_operations as List[String] returns List[String]:
    Note: Optimize vector memory operations
    Note: TODO: Implement vector memory optimization
    Throw Errors.NotImplemented with "Vector memory optimization not yet implemented"

Process called "select_vector_reduction_instructions" that takes selector as AArch64InstructionSelector, reduction_operations as List[String] returns List[String]:
    Note: Select instructions for vector reduction operations
    Note: TODO: Implement vector reduction instruction selection
    Throw Errors.NotImplemented with "Vector reduction instruction selection not yet implemented"

Note: =====================================================================
Note: BRANCH INSTRUCTION SELECTION
Note: =====================================================================

Process called "select_branch_instruction" that takes selector as AArch64InstructionSelector, condition as String, branch_probability as Float returns String:
    Note: Select optimal branch instruction based on condition and probability
    Note: TODO: Implement branch instruction selection
    Throw Errors.NotImplemented with "Branch instruction selection not yet implemented"

Process called "select_conditional_instruction" that takes selector as AArch64InstructionSelector, condition as String, true_instruction as String, false_instruction as String returns String:
    Note: Select conditional instruction to avoid branches
    Note: TODO: Implement conditional instruction selection
    Throw Errors.NotImplemented with "Conditional instruction selection not yet implemented"

Process called "optimize_compare_and_branch" that takes selector as AArch64InstructionSelector, comparison as String, branch_target as String returns List[String]:
    Note: Optimize compare-and-branch instruction patterns
    Note: TODO: Implement compare-and-branch optimization
    Throw Errors.NotImplemented with "Compare-and-branch optimization not yet implemented"

Process called "select_test_and_branch" that takes selector as AArch64InstructionSelector, test_operation as String, branch_condition as String returns String:
    Note: Select test-and-branch instructions (TBZ, TBNZ)
    Note: TODO: Implement test-and-branch selection
    Throw Errors.NotImplemented with "Test-and-branch selection not yet implemented"

Note: =====================================================================
Note: CONDITIONAL EXECUTION OPTIMIZATION
Note: =====================================================================

Process called "optimize_conditional_execution" that takes selector as AArch64InstructionSelector, conditional_code as List[String] returns List[String]:
    Note: Optimize code using AArch64 conditional execution features
    Note: TODO: Implement conditional execution optimization
    Throw Errors.NotImplemented with "Conditional execution optimization not yet implemented"

Process called "select_conditional_select" that takes selector as AArch64InstructionSelector, condition as String, true_value as String, false_value as String returns String:
    Note: Select conditional select instructions (CSEL, CSINC, CSINV, CSNEG)
    Note: TODO: Implement conditional select instruction selection
    Throw Errors.NotImplemented with "Conditional select instruction selection not yet implemented"

Process called "optimize_flag_usage" that takes selector as AArch64InstructionSelector, flag_operations as List[String] returns List[String]:
    Note: Optimize condition flag usage and propagation
    Note: TODO: Implement flag usage optimization
    Throw Errors.NotImplemented with "Flag usage optimization not yet implemented"

Note: =====================================================================
Note: INSTRUCTION FUSION OPERATIONS
Note: =====================================================================

Process called "identify_fusion_opportunities" that takes selector as AArch64InstructionSelector, instruction_sequence as List[String] returns List[String]:
    Note: Identify opportunities for instruction fusion
    Note: TODO: Implement fusion opportunity identification
    Throw Errors.NotImplemented with "Fusion opportunity identification not yet implemented"

Process called "fuse_multiply_add_operations" that takes selector as AArch64InstructionSelector, mul_instruction as String, add_instruction as String returns String:
    Note: Fuse multiply-add operations using MADD/MSUB instructions
    Note: TODO: Implement multiply-add fusion
    Throw Errors.NotImplemented with "Multiply-add fusion not yet implemented"

Process called "fuse_shift_operations" that takes selector as AArch64InstructionSelector, shift_op as String, arithmetic_op as String returns String:
    Note: Fuse shift operations with arithmetic using barrel shifter
    Note: TODO: Implement shift operation fusion
    Throw Errors.NotImplemented with "Shift operation fusion not yet implemented"

Process called "fuse_compare_branch_operations" that takes selector as AArch64InstructionSelector, compare_op as String, branch_op as String returns String:
    Note: Fuse compare and branch operations
    Note: TODO: Implement compare-branch fusion
    Throw Errors.NotImplemented with "Compare-branch fusion not yet implemented"

Note: =====================================================================
Note: MATHEMATICAL OPERATION OPTIMIZATION
Note: =====================================================================

Process called "optimize_mathematical_expressions" that takes selector as AArch64InstructionSelector, math_expression as String, greek_variables as List[String] returns List[String]:
    Note: Optimize mathematical expressions with Greek symbols
    Note: TODO: Implement mathematical expression optimization
    Throw Errors.NotImplemented with "Mathematical expression optimization not yet implemented"

Process called "select_floating_point_instructions" that takes selector as AArch64InstructionSelector, fp_operation as String, precision as String returns String:
    Note: Select optimal floating-point instructions
    Note: TODO: Implement floating-point instruction selection
    Throw Errors.NotImplemented with "Floating-point instruction selection not yet implemented"

Process called "optimize_polynomial_evaluation" that takes selector as AArch64InstructionSelector, coefficients as List[Float], variable as String returns List[String]:
    Note: Optimize polynomial evaluation using FMA and NEON
    Note: TODO: Implement polynomial optimization
    Throw Errors.NotImplemented with "Polynomial optimization not yet implemented"

Process called "select_crypto_instructions" that takes selector as AArch64InstructionSelector, crypto_operation as String returns String:
    Note: Select AArch64 cryptographic instructions when available
    Note: TODO: Implement crypto instruction selection
    Throw Errors.NotImplemented with "Crypto instruction selection not yet implemented"

Note: =====================================================================
Note: COST MODEL OPERATIONS
Note: =====================================================================

Process called "calculate_instruction_cost" that takes selector as AArch64InstructionSelector, instruction as String, context as SelectionContext returns Integer:
    Note: Calculate cost of instruction in given context
    Note: TODO: Implement instruction cost calculation
    Throw Errors.NotImplemented with "Instruction cost calculation not yet implemented"

Process called "estimate_register_pressure" that takes selector as AArch64InstructionSelector, instructions as List[String], context as SelectionContext returns Integer:
    Note: Estimate register pressure for instruction sequence
    Note: TODO: Implement register pressure estimation
    Throw Errors.NotImplemented with "Register pressure estimation not yet implemented"

Process called "calculate_latency_cost" that takes selector as AArch64InstructionSelector, instruction_sequence as List[String] returns Integer:
    Note: Calculate latency cost for instruction sequence
    Note: TODO: Implement latency cost calculation
    Throw Errors.NotImplemented with "Latency cost calculation not yet implemented"

Process called "calculate_energy_cost" that takes selector as AArch64InstructionSelector, instruction_sequence as List[String] returns Float:
    Note: Calculate energy cost for mobile/embedded optimization
    Note: TODO: Implement energy cost calculation
    Throw Errors.NotImplemented with "Energy cost calculation not yet implemented"

Note: =====================================================================
Note: PROFILE-GUIDED SELECTION
Note: =====================================================================

Process called "apply_profile_data" that takes selector as AArch64InstructionSelector, profile as ProfileInfo returns Boolean:
    Note: Apply profile data to guide instruction selection
    Note: TODO: Implement profile-guided selection
    Throw Errors.NotImplemented with "Profile-guided selection not yet implemented"

Process called "select_based_on_frequency" that takes selector as AArch64InstructionSelector, instruction_candidates as List[String], frequency_data as Dictionary[String, Integer] returns String:
    Note: Select instructions based on execution frequency
    Note: TODO: Implement frequency-based selection
    Throw Errors.NotImplemented with "Frequency-based selection not yet implemented"

Process called "optimize_for_cache_behavior" that takes selector as AArch64InstructionSelector, memory_operations as List[String], cache_profile as Dictionary[String, Float] returns List[String]:
    Note: Optimize instruction selection for cache behavior
    Note: TODO: Implement cache-aware optimization
    Throw Errors.NotImplemented with "Cache-aware optimization not yet implemented"

Note: =====================================================================
Note: ARM-SPECIFIC INSTRUCTION SELECTION
Note: =====================================================================

Process called "select_bit_manipulation_instructions" that takes selector as AArch64InstructionSelector, bit_operations as List[String] returns List[String]:
    Note: Select optimal bit manipulation instructions
    Note: TODO: Implement bit manipulation instruction selection
    Throw Errors.NotImplemented with "Bit manipulation instruction selection not yet implemented"

Process called "select_count_instructions" that takes selector as AArch64InstructionSelector, count_operations as List[String] returns List[String]:
    Note: Select leading/trailing zero count instructions (CLZ, CTZ)
    Note: TODO: Implement count instruction selection
    Throw Errors.NotImplemented with "Count instruction selection not yet implemented"

Process called "select_reverse_instructions" that takes selector as AArch64InstructionSelector, reverse_operations as List[String] returns List[String]:
    Note: Select bit/byte reverse instructions (RBIT, REV)
    Note: TODO: Implement reverse instruction selection
    Throw Errors.NotImplemented with "Reverse instruction selection not yet implemented"

Process called "optimize_immediate_encoding" that takes selector as AArch64InstructionSelector, immediate_values as List[Integer] returns Dictionary[String, String]:
    Note: Optimize immediate value encoding in instructions
    Note: TODO: Implement immediate encoding optimization
    Throw Errors.NotImplemented with "Immediate encoding optimization not yet implemented"

Note: =====================================================================
Note: DEPENDENCY ANALYSIS
Note: =====================================================================

Process called "analyze_instruction_dependencies" that takes selector as AArch64InstructionSelector, instructions as List[String] returns Dictionary[String, List[String]]:
    Note: Analyze dependencies between instructions
    Note: TODO: Implement dependency analysis
    Throw Errors.NotImplemented with "Dependency analysis not yet implemented"

Process called "optimize_dependency_chains" that takes selector as AArch64InstructionSelector, dependency_chains as List[List[String]] returns List[String]:
    Note: Optimize instruction ordering to minimize dependency stalls
    Note: TODO: Implement dependency chain optimization
    Throw Errors.NotImplemented with "Dependency chain optimization not yet implemented"

Process called "identify_parallel_instructions" that takes selector as AArch64InstructionSelector, instruction_block as List[String] returns List[List[String]]:
    Note: Identify instructions that can execute in parallel
    Note: TODO: Implement parallel instruction identification
    Throw Errors.NotImplemented with "Parallel instruction identification not yet implemented"

Note: =====================================================================
Note: VALIDATION AND DEBUGGING
Note: =====================================================================

Process called "validate_instruction_selection" that takes selector as AArch64InstructionSelector, selected_instructions as List[String], original_bytecode as List[String] returns List[String]:
    Note: Validate that instruction selection preserves semantics
    Note: TODO: Implement selection validation
    Throw Errors.NotImplemented with "Selection validation not yet implemented"

Process called "verify_pattern_correctness" that takes selector as AArch64InstructionSelector, pattern as InstructionPattern, test_cases as List[String] returns List[String]:
    Note: Verify correctness of instruction patterns
    Note: TODO: Implement pattern verification
    Throw Errors.NotImplemented with "Pattern verification not yet implemented"

Process called "analyze_selection_quality" that takes selector as AArch64InstructionSelector, selected_instructions as List[String] returns Dictionary[String, Float]:
    Note: Analyze quality metrics of instruction selection
    Note: TODO: Implement selection quality analysis
    Throw Errors.NotImplemented with "Selection quality analysis not yet implemented"

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "get_selection_statistics" that takes selector as AArch64InstructionSelector returns SelectionStatistics:
    Note: Get comprehensive instruction selection statistics
    Note: TODO: Implement statistics collection
    Throw Errors.NotImplemented with "Statistics collection not yet implemented"

Process called "export_pattern_database" that takes selector as AArch64InstructionSelector, format as String returns String:
    Note: Export instruction pattern database
    Note: TODO: Implement pattern database export
    Throw Errors.NotImplemented with "Pattern database export not yet implemented"

Process called "import_custom_patterns" that takes selector as AArch64InstructionSelector, pattern_data as String returns Boolean:
    Note: Import custom instruction patterns
    Note: TODO: Implement custom pattern import
    Throw Errors.NotImplemented with "Custom pattern import not yet implemented"

Process called "reset_instruction_selector" that takes selector as AArch64InstructionSelector returns Boolean:
    Note: Reset instruction selector to initial state
    Note: TODO: Implement instruction selector reset
    Throw Errors.NotImplemented with "Instruction selector reset not yet implemented"