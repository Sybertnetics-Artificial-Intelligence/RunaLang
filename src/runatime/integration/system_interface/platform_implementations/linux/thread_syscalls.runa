Note:
runa/src/runatime/integration/system_interface/platform_syscalls/linux/thread_syscalls.runa
Linux Thread Management Syscalls

Import "../../../../../../../compiler/backend/syscalls/platforms/linux_x64" as LinuxX64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/linux_arm64" as LinuxARM64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/platform_interface" as PlatformInterface

This module provides Linux-specific thread management syscall implementations,
including thread creation, synchronization, and thread-local storage.

Key features and capabilities:
- Thread creation and management
- Thread synchronization primitives
- Futex operations
- Thread-local storage (TLS)
- Thread signaling
- Thread scheduling
- Thread affinity
- Thread cancellation
- Robust mutexes
- Priority inheritance
- Read-write locks
- Condition variables
- Barriers and spinlocks
- Thread stack management
- Thread cleanup handlers
:End Note


Note: =====================================================================
Note: THREAD DATA STRUCTURES
Note: =====================================================================

Type called "ThreadInfo":
    tid as Integer                          Note: Thread ID
    tgid as Integer                         Note: Thread group ID (process ID)
    stack_base as Integer                   Note: Stack base address
    stack_size as Integer                   Note: Stack size
    tls_base as Integer                     Note: TLS base address
    cpu_affinity as Integer                 Note: CPU affinity mask
    priority as Integer                     Note: Thread priority
    state as String                         Note: Thread state

Type called "FutexOperation":
    op as Integer                           Note: Futex operation
    val as Integer                          Note: Comparison/wake value
    timeout as Optional[Integer]            Note: Timeout specification
    uaddr2 as Optional[Integer]             Note: Second futex address
    val3 as Integer                         Note: Additional value

Type called "ThreadAttributes":
    detach_state as Integer                 Note: PTHREAD_CREATE_JOINABLE/DETACHED
    sched_policy as Integer                 Note: Scheduling policy
    sched_priority as Integer               Note: Scheduling priority
    stack_addr as Integer                   Note: Stack address
    stack_size as Integer                   Note: Stack size
    guard_size as Integer                   Note: Guard page size

Note: =====================================================================
Note: THREAD CREATION AND MANAGEMENT
Note: =====================================================================

Process called "sys_clone_thread" that takes flags as Integer, stack as Integer, parent_tid as Integer, child_tid as Integer, tls as Integer returns Integer:
    Note: Create new thread
    Note: CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND
    Note: Uses sys_clone internally
    Note: Returns thread ID
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("clone")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: flags
        "mov rsi, %2\n"               Note: stack
        "mov rdx, %3\n"               Note: parent_tid  
        "mov r10, %4\n"               Note: child_tid
        "mov r8, %5\n"                Note: tls
        "mov rax, %6\n"               Note: sys_clone from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (flags), "r" (stack), "r" (parent_tid), "r" (child_tid), "r" (tls), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_gettid" returns Integer:
    Note: Get thread ID
    Note: Current thread identifier
    Note: Unique per thread
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("gettid")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"               Note: sys_gettid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_tkill" that takes tid as Integer, sig as Integer returns Integer:
    Note: Send signal to thread
    Note: Thread-specific signal
    Note: Deprecated, use tgkill
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("tkill")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: tid
        "mov rsi, %2\n"               Note: sig
        "mov rax, %3\n"               Note: sys_tkill from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (tid), "r" (sig), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_tgkill" that takes tgid as Integer, tid as Integer, sig as Integer returns Integer:
    Note: Send signal to thread group
    Note: Safer than tkill
    Note: Verifies thread group
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("tgkill")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: tgid
        "mov rsi, %2\n"               Note: tid
        "mov rdx, %3\n"               Note: sig
        "mov rax, %4\n"               Note: sys_tgkill from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (tgid), "r" (tid), "r" (sig), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: FUTEX OPERATIONS
Note: =====================================================================

Process called "sys_futex" that takes uaddr as Integer, op as Integer, val as Integer, timeout as Integer, uaddr2 as Integer, val3 as Integer returns Integer:
    Note: Fast userspace mutex
    Note: Low-level synchronization
    Note: FUTEX_WAIT, FUTEX_WAKE, etc.
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("futex")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: uaddr
        "mov rsi, %2\n"               Note: op
        "mov rdx, %3\n"               Note: val
        "mov r10, %4\n"               Note: timeout
        "mov r8, %5\n"                Note: uaddr2
        "mov r9, %6\n"                Note: val3
        "mov rax, %7\n"               Note: sys_futex from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (uaddr), "r" (op), "r" (val), "r" (timeout), "r" (uaddr2), "r" (val3), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_futex_wait" that takes uaddr as Integer, val as Integer, timeout as Optional[Integer] returns Integer:
    Note: Wait on futex
    Note: Block if value matches
    Note: Uses FUTEX_WAIT operation
    Note: Timeout support
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("futex")
    Let timeout_ptr be Integer
    
    If timeout has value:
        Set timeout_ptr to timeout.value
    Otherwise:
        Set timeout_ptr to 0
    End If
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: uaddr
        "mov rsi, 0\n"                Note: FUTEX_WAIT = 0
        "mov rdx, %2\n"               Note: val
        "mov r10, %3\n"               Note: timeout
        "xor r8, r8\n"                Note: uaddr2 = NULL
        "xor r9, r9\n"                Note: val3 = 0
        "mov rax, %4\n"               Note: sys_futex from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (uaddr), "r" (val), "r" (timeout_ptr), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_futex_wake" that takes uaddr as Integer, nr_wake as Integer returns Integer:
    Note: Wake futex waiters
    Note: Wake up to nr_wake threads
    Note: Uses FUTEX_WAKE operation
    Note: Returns number woken
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("futex")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: uaddr
        "mov rsi, 1\n"                Note: FUTEX_WAKE = 1
        "mov rdx, %2\n"               Note: nr_wake
        "xor r10, r10\n"              Note: timeout = NULL
        "xor r8, r8\n"                Note: uaddr2 = NULL
        "xor r9, r9\n"                Note: val3 = 0
        "mov rax, %3\n"               Note: sys_futex from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (uaddr), "r" (nr_wake), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_futex_requeue" that takes uaddr as Integer, nr_wake as Integer, nr_requeue as Integer, uaddr2 as Integer returns Integer:
    Note: Requeue futex waiters
    Note: Move waiters to another futex
    Note: Uses FUTEX_REQUEUE operation
    Note: Condition variable support
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("futex")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: uaddr
        "mov rsi, 3\n"                Note: FUTEX_REQUEUE = 3
        "mov rdx, %2\n"               Note: nr_wake
        "mov r10, %3\n"               Note: nr_requeue
        "mov r8, %4\n"                Note: uaddr2
        "xor r9, r9\n"                Note: val3 = 0
        "mov rax, %5\n"               Note: sys_futex from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (uaddr), "r" (nr_wake), "r" (nr_requeue), "r" (uaddr2), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_futex_wait_bitset" that takes uaddr as Integer, val as Integer, timeout as Integer, bitset as Integer returns Integer:
    Note: Wait with bitset mask
    Note: Selective wakeup support
    Note: Uses FUTEX_WAIT_BITSET
    Note: More flexible waiting
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("futex")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: uaddr
        "mov rsi, 9\n"                Note: FUTEX_WAIT_BITSET = 9
        "mov rdx, %2\n"               Note: val
        "mov r10, %3\n"               Note: timeout
        "xor r8, r8\n"                Note: uaddr2 = NULL
        "mov r9, %4\n"                Note: bitset
        "mov rax, %5\n"               Note: sys_futex from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (uaddr), "r" (val), "r" (timeout), "r" (bitset), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_futex_wake_bitset" that takes uaddr as Integer, nr_wake as Integer, bitset as Integer returns Integer:
    Note: Wake with bitset mask
    Note: Selective wakeup
    Note: Uses FUTEX_WAKE_BITSET
    Note: Wake matching waiters
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("futex")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: uaddr
        "mov rsi, 10\n"               Note: FUTEX_WAKE_BITSET = 10
        "mov rdx, %2\n"               Note: nr_wake
        "xor r10, r10\n"              Note: timeout = NULL
        "xor r8, r8\n"                Note: uaddr2 = NULL
        "mov r9, %3\n"                Note: bitset
        "mov rax, %4\n"               Note: sys_futex from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (uaddr), "r" (nr_wake), "r" (bitset), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: ROBUST FUTEXES
Note: =====================================================================

Process called "sys_set_robust_list" that takes head as Integer, len as Integer returns Integer:
    Note: Set robust futex list
    Note: Handle owner death
    Note: Per-thread list
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("set_robust_list")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: head
        "mov rsi, %2\n"               Note: len
        "mov rax, %3\n"               Note: sys_set_robust_list from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (head), "r" (len), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_get_robust_list" that takes pid as Integer, head_ptr as Integer, len_ptr as Integer returns Integer:
    Note: Get robust futex list
    Note: Query robust list
    Note: Debugging support
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("get_robust_list")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: pid
        "mov rsi, %2\n"               Note: head_ptr
        "mov rdx, %3\n"               Note: len_ptr
        "mov rax, %4\n"               Note: sys_get_robust_list from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pid), "r" (head_ptr), "r" (len_ptr), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: THREAD-LOCAL STORAGE
Note: =====================================================================

Process called "sys_set_thread_area" that takes u_info as Integer returns Integer:
    Note: Set thread local storage
    Note: Configure TLS segment
    Note: x86-specific
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("set_thread_area")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: u_info
        "mov rax, %2\n"               Note: sys_set_thread_area from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (u_info), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_get_thread_area" that takes u_info as Integer returns Integer:
    Note: Get thread local storage
    Note: Query TLS configuration
    Note: x86-specific
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("get_thread_area")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: u_info
        "mov rax, %2\n"               Note: sys_get_thread_area from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (u_info), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_arch_prctl" that takes code as Integer, addr as Integer returns Integer:
    Note: Architecture-specific control
    Note: ARCH_SET_FS, ARCH_SET_GS
    Note: x86_64 TLS management
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("arch_prctl")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: code
        "mov rsi, %2\n"               Note: addr
        "mov rax, %3\n"               Note: sys_arch_prctl from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (code), "r" (addr), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: THREAD SCHEDULING
Note: =====================================================================

Process called "sys_sched_setattr" that takes pid as Integer, attr as Integer, flags as Integer returns Integer:
    Note: Set scheduling attributes
    Note: Extended scheduling control
    Note: SCHED_DEADLINE support
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("sched_setattr")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: pid
        "mov rsi, %2\n"               Note: attr
        "mov rdx, %3\n"               Note: flags
        "mov rax, %4\n"               Note: sys_sched_setattr from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pid), "r" (attr), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_sched_getattr" that takes pid as Integer, attr as Integer, size as Integer, flags as Integer returns Integer:
    Note: Get scheduling attributes
    Note: Query scheduling parameters
    Note: Extended attributes
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("sched_getattr")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: pid
        "mov rsi, %2\n"               Note: attr
        "mov rdx, %3\n"               Note: size
        "mov r10, %4\n"               Note: flags
        "mov rax, %5\n"               Note: sys_sched_getattr from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pid), "r" (attr), "r" (size), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_sched_yield" returns Integer:
    Note: Yield processor
    Note: Give up time slice
    Note: Cooperative scheduling
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("sched_yield")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"               Note: sys_sched_yield from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: THREAD SYNCHRONIZATION HELPERS
Note: =====================================================================

Process called "sys_mutex_init" that takes mutex as Integer, attr as Integer returns Integer:
    Note: Initialize mutex
    Note: Setup futex-based mutex
    Note: Not a direct syscall
    Note: Uses futex internally
    Note: Write 0 to mutex location to indicate unlocked
    Inline Assembly:
        "mov rax, %1\n"               Note: mutex address
        "mov dword ptr [rax], 0\n"    Note: Set to unlocked (0)
        "xor rax, rax\n"              Note: Return success (0)
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (mutex)
        : "rax", "memory"
    End Assembly
    Let result be 0
    Return result

Process called "sys_mutex_lock" that takes mutex as Integer returns Integer:
    Note: Lock mutex
    Note: Acquire exclusive access
    Note: Uses futex operations
    Note: May block thread
    Note: Try atomic compare-exchange first, then futex wait if needed
    Let result be Integer
    Let old_val be Integer
    Inline Assembly:
        "mov rax, %2\n"               Note: mutex address
        "mov ecx, 1\n"                Note: Value to set (locked)
        "xor edx, edx\n"              Note: Expected value (unlocked)
        "lock cmpxchg [rax], ecx\n"   Note: Atomic compare and exchange
        "mov %1, eax\n"               Note: Save old value
        "setz al\n"                    Note: Set AL if successful
        "movzx eax, al\n"             Note: Zero-extend to full register
        "mov %0, rax\n"
        : "=r" (result), "=r" (old_val)
        : "r" (mutex)
        : "rax", "rcx", "rdx", "memory", "cc"
    End Assembly
    
    If result equals 1:
        Return 0  Note: Successfully acquired lock
    End If
    
    Note: Need to wait on futex
    Let wait_result be sys_futex_wait(mutex, 1, null)
    Return wait_result

Process called "sys_mutex_unlock" that takes mutex as Integer returns Integer:
    Note: Unlock mutex
    Note: Release exclusive access
    Note: Wake waiting threads
    Note: Uses futex wake
    Note: Atomically set to 0 and wake one waiter
    Inline Assembly:
        "mov rax, %1\n"               Note: mutex address
        "mov dword ptr [rax], 0\n"    Note: Set to unlocked (0)
        : 
        : "r" (mutex)
        : "rax", "memory"
    End Assembly
    
    Note: Wake one waiter if any
    Let wake_result be sys_futex_wake(mutex, 1)
    Return 0  Note: Always succeeds

Process called "sys_cond_wait" that takes cond as Integer, mutex as Integer returns Integer:
    Note: Wait on condition variable
    Note: Atomic unlock and wait
    Note: Uses futex operations
    Note: Reacquires mutex on wake
    
    Note: First unlock the mutex
    Let unlock_result be sys_mutex_unlock(mutex)
    If unlock_result less than 0:
        Return unlock_result
    End If
    
    Note: Wait on condition variable
    Let wait_result be sys_futex_wait(cond, 0, null)
    
    Note: Reacquire mutex before returning
    Let lock_result be sys_mutex_lock(mutex)
    If lock_result less than 0:
        Return lock_result
    End If
    
    Return 0

Process called "sys_cond_signal" that takes cond as Integer returns Integer:
    Note: Signal condition variable
    Note: Wake one waiter
    Note: Uses futex wake
    Note: FIFO wakeup order
    
    Note: Wake one thread waiting on condition
    Let wake_result be sys_futex_wake(cond, 1)
    Return 0  Note: Always succeeds

Process called "sys_cond_broadcast" that takes cond as Integer returns Integer:
    Note: Broadcast condition variable
    Note: Wake all waiters
    Note: Uses futex wake
    Note: Thundering herd issue
    
    Note: Wake all threads waiting on condition
    Let wake_result be sys_futex_wake(cond, 2147483647)  Note: INT_MAX
    Return 0  Note: Always succeeds

Note: =====================================================================
Note: THREAD BARRIERS
Note: =====================================================================

Process called "sys_barrier_wait" that takes barrier as Integer returns Integer:
    Note: Wait at barrier
    Note: Synchronization point
    Note: Uses futex operations
    Note: Last thread wakes all
    
    Note: Atomic decrement and check counter
    Let count be Integer
    Inline Assembly:
        "mov rax, %1\n"               Note: barrier address
        "lock dec dword ptr [rax]\n"  Note: Atomic decrement
        "mov %0, dword ptr [rax]\n"   Note: Read new value
        : "=r" (count)
        : "r" (barrier)
        : "rax", "memory", "cc"
    End Assembly
    
    If count equals 0:
        Note: Last thread, wake all others
        Let wake_result be sys_futex_wake(barrier, 2147483647)
        Return 0
    Otherwise:
        Note: Wait for last thread
        Let wait_result be sys_futex_wait(barrier, count, null)
        Return 0
    End If

Note: =====================================================================
Note: READ-WRITE LOCKS
Note: =====================================================================

Process called "sys_rwlock_rdlock" that takes rwlock as Integer returns Integer:
    Note: Acquire read lock
    Note: Multiple readers allowed
    Note: Uses futex operations
    Note: Blocks on writers
    
    Note: Atomic increment reader count
    Let old_val be Integer
    Inline Assembly:
        "mov rax, %1\n"               Note: rwlock address
        "1:\n"
        "mov ecx, dword ptr [rax]\n"  Note: Load current value
        "test ecx, 0x80000000\n"      Note: Check writer bit
        "jnz 2f\n"                    Note: Jump if writer present
        "lea edx, [ecx + 1]\n"        Note: Increment reader count
        "lock cmpxchg [rax], edx\n"   Note: Try to update
        "jnz 1b\n"                    Note: Retry if failed
        "xor eax, eax\n"              Note: Return success
        "jmp 3f\n"
        "2:\n"                         Note: Writer present, need to wait
        "mov eax, -1\n"               Note: Return -1 to indicate wait needed
        "3:\n"
        "mov %0, eax\n"
        : "=r" (old_val)
        : "r" (rwlock)
        : "rax", "rcx", "rdx", "memory", "cc"
    End Assembly
    
    If old_val equals -1:
        Note: Need to wait for writer
        Let wait_result be sys_futex_wait(rwlock, old_val, null)
        Return sys_rwlock_rdlock(rwlock)  Note: Retry
    End If
    
    Return 0

Process called "sys_rwlock_wrlock" that takes rwlock as Integer returns Integer:
    Note: Acquire write lock
    Note: Exclusive access
    Note: Uses futex operations
    Note: Blocks on any lock
    
    Note: Try to set writer bit atomically
    Let old_val be Integer
    Inline Assembly:
        "mov rax, %1\n"               Note: rwlock address
        "mov ecx, 0x80000000\n"       Note: Writer bit
        "xor edx, edx\n"              Note: Expected value (no readers/writers)
        "lock cmpxchg [rax], ecx\n"   Note: Try to acquire write lock
        "mov %0, eax\n"               Note: Save old value
        : "=r" (old_val)
        : "r" (rwlock)
        : "rax", "rcx", "rdx", "memory", "cc"
    End Assembly
    
    If old_val not equals 0:
        Note: Lock is held, need to wait
        Let wait_result be sys_futex_wait(rwlock, old_val, null)
        Return sys_rwlock_wrlock(rwlock)  Note: Retry
    End If
    
    Return 0

Process called "sys_rwlock_unlock" that takes rwlock as Integer returns Integer:
    Note: Release read/write lock
    Note: Wake appropriate waiters
    Note: Uses futex wake
    Note: Writer priority possible
    
    Note: Determine if we're releasing read or write lock
    Let old_val be Integer
    Inline Assembly:
        "mov rax, %1\n"               Note: rwlock address
        "mov ecx, dword ptr [rax]\n"  Note: Load current value
        "test ecx, 0x80000000\n"      Note: Check writer bit
        "jz 1f\n"                     Note: Jump if reader lock
        Note: Writer lock release
        "mov dword ptr [rax], 0\n"    Note: Clear lock completely
        "jmp 2f\n"
        "1:\n"                         Note: Reader lock release
        "lock dec dword ptr [rax]\n"  Note: Decrement reader count
        "2:\n"
        "mov %0, ecx\n"               Note: Return old value
        : "=r" (old_val)
        : "r" (rwlock)
        : "rax", "rcx", "memory", "cc"
    End Assembly
    
    Note: Wake waiters
    Let wake_result be sys_futex_wake(rwlock, 2147483647)  Note: Wake all
    Return 0