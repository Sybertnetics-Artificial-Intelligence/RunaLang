Note:
runa/src/runatime/integration/system_interface/platform_syscalls/linux/memory_syscalls.runa
Linux Memory Management Syscalls

Import "../../../../../../../compiler/backend/syscalls/platforms/linux_x64" as LinuxX64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/linux_arm64" as LinuxARM64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/platform_interface" as PlatformInterface

This module provides Linux-specific memory management syscall implementations,
including memory allocation, mapping, protection, and advanced memory operations.

Key features and capabilities:
- Memory mapping (mmap, munmap)
- Memory protection (mprotect)
- Memory locking (mlock, mlockall)
- Memory advising (madvise)
- Shared memory operations
- Anonymous memory mapping
- File-backed memory mapping
- Huge page support
- Memory synchronization (msync)
- Virtual memory queries
- NUMA memory management
- Memory policies (mbind)
- Process memory layout
- Memory sealing (memfd)
- userfaultfd support
- Memory migration
:End Note


Note: =====================================================================
Note: MEMORY MANAGEMENT DATA STRUCTURES
Note: =====================================================================

Type called "MemoryMapping":
    address as Integer                      Note: Memory address
    length as Integer                       Note: Mapping size
    prot as Integer                         Note: Protection flags
    flags as Integer                        Note: Mapping flags
    fd as Integer                           Note: File descriptor (-1 for anonymous)
    offset as Integer                       Note: File offset
    is_shared as Boolean                    Note: MAP_SHARED or MAP_PRIVATE

Type called "MemoryRegion":
    start_address as Integer                Note: Region start
    end_address as Integer                  Note: Region end
    permissions as String                   Note: rwxp permissions
    offset as Integer                       Note: File offset
    device as String                        Note: Device major:minor
    inode as Integer                        Note: Inode number
    pathname as Optional[String]            Note: Mapped file path

Type called "MemoryStats":
    vss as Integer                          Note: Virtual set size
    rss as Integer                          Note: Resident set size
    pss as Integer                          Note: Proportional set size
    shared_clean as Integer                 Note: Shared clean pages
    shared_dirty as Integer                 Note: Shared dirty pages
    private_clean as Integer                Note: Private clean pages
    private_dirty as Integer                Note: Private dirty pages
    swap as Integer                         Note: Swap usage

Type called "NumaPolicy":
    mode as String                          Note: MPOL_DEFAULT, MPOL_BIND, etc.
    nodemask as Integer                     Note: NUMA nodes bitmap
    maxnode as Integer                      Note: Number of nodes
    flags as Integer                        Note: Policy flags

Note: =====================================================================
Note: BASIC MEMORY OPERATIONS
Note: =====================================================================

Process called "sys_brk" that takes addr as Integer returns Integer:
    Note: Change data segment size
    Note: Traditional heap allocation
    Note: Returns new break on success
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("brk")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: addr
        "mov rax, %2\n"               Note: sys_brk from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_mmap" that takes addr as Integer, length as Integer, prot as Integer, flags as Integer, fd as Integer, offset as Integer returns Integer:
    Note: Map memory region
    Note: Create new mapping
    Note: Returns mapping address
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mmap")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: addr
        "mov rsi, %2\n"               Note: length
        "mov rdx, %3\n"               Note: prot
        "mov r10, %4\n"               Note: flags (r10, not rcx)
        "mov r8, %5\n"                Note: fd
        "mov r9, %6\n"                Note: offset
        "mov rax, %7\n"               Note: sys_mmap from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (length), "r" (prot), "r" (flags), "r" (fd), "r" (offset), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_munmap" that takes addr as Integer, length as Integer returns Integer:
    Note: Unmap memory region
    Note: Release mapping
    Note: Returns 0 on success
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("munmap")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: addr
        "mov rsi, %2\n"               Note: length
        "mov rax, %3\n"               Note: sys_munmap from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (length), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_mremap" that takes old_address as Integer, old_size as Integer, new_size as Integer, flags as Integer, new_address as Integer returns Integer:
    Note: Remap memory region
    Note: Resize or move mapping
    Note: MREMAP_MAYMOVE flag
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mremap")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: old_address
        "mov rsi, %2\n"               Note: old_size
        "mov rdx, %3\n"               Note: new_size
        "mov r10, %4\n"               Note: flags
        "mov r8, %5\n"                Note: new_address (if MREMAP_FIXED)
        "mov rax, %6\n"               Note: sys_mremap from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (old_address), "r" (old_size), "r" (new_size), "r" (flags), "r" (new_address), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: MEMORY PROTECTION
Note: =====================================================================

Process called "sys_mprotect" that takes addr as Integer, len as Integer, prot as Integer returns Integer:
    Note: Change memory protection
    Note: Modify page permissions
    Note: PROT_READ, PROT_WRITE, PROT_EXEC
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mprotect")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: addr
        "mov rsi, %2\n"               Note: len
        "mov rdx, %3\n"               Note: prot
        "mov rax, %4\n"               Note: sys_mprotect from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (prot), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_pkey_mprotect" that takes addr as Integer, len as Integer, prot as Integer, pkey as Integer returns Integer:
    Note: Memory protection with keys
    Note: Hardware protection keys
    Note: Fine-grained protection
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("pkey_mprotect")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: addr
        "mov rsi, %2\n"               Note: len
        "mov rdx, %3\n"               Note: prot
        "mov r10, %4\n"               Note: pkey
        "mov rax, %5\n"               Note: sys_pkey_mprotect from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (prot), "r" (pkey), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_pkey_alloc" that takes flags as Integer, access_rights as Integer returns Integer:
    Note: Allocate protection key
    Note: Get new protection key
    Note: Limited keys available
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("pkey_alloc")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: flags
        "mov rsi, %2\n"               Note: access_rights
        "mov rax, %3\n"               Note: sys_pkey_alloc from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (flags), "r" (access_rights), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_pkey_free" that takes pkey as Integer returns Integer:
    Note: Free protection key
    Note: Release protection key
    Note: Returns 0 on success
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("pkey_free")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: pkey
        "mov rax, %2\n"               Note: sys_pkey_free from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pkey), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: MEMORY LOCKING
Note: =====================================================================

Process called "sys_mlock" that takes addr as Integer, len as Integer returns Integer:
    Note: Lock memory in RAM
    Note: Prevent swapping
    Note: Requires CAP_IPC_LOCK
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mlock")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: addr
        "mov rsi, %2\n"               Note: len
        "mov rax, %3\n"               Note: sys_mlock from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_munlock" that takes addr as Integer, len as Integer returns Integer:
    Note: Unlock memory
    Note: Allow swapping
    Note: Returns 0 on success
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("munlock")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: addr
        "mov rsi, %2\n"               Note: len
        "mov rax, %3\n"               Note: sys_munlock from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_mlockall" that takes flags as Integer returns Integer:
    Note: Lock all process memory
    Note: MCL_CURRENT, MCL_FUTURE
    Note: Real-time applications
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mlockall")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: flags
        "mov rax, %2\n"               Note: sys_mlockall from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_munlockall" returns Integer:
    Note: Unlock all process memory
    Note: Allow all swapping
    Note: Returns 0 on success
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("munlockall")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"               Note: sys_munlockall from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_mlock2" that takes addr as Integer, len as Integer, flags as Integer returns Integer:
    Note: Lock memory with flags
    Note: MLOCK_ONFAULT support
    Note: Lazy locking option
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mlock2")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: addr
        "mov rsi, %2\n"               Note: len
        "mov rdx, %3\n"               Note: flags
        "mov rax, %4\n"               Note: sys_mlock2 from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: MEMORY ADVISING
Note: =====================================================================

Process called "sys_madvise" that takes addr as Integer, length as Integer, advice as Integer returns Integer:
    Note: Advise kernel on memory usage
    Note: Optimization hints
    Note: MADV_SEQUENTIAL, MADV_RANDOM, etc.
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("madvise")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: addr
        "mov rsi, %2\n"               Note: length
        "mov rdx, %3\n"               Note: advice
        "mov rax, %4\n"               Note: sys_madvise from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (length), "r" (advice), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_process_madvise" that takes pidfd as Integer, addr as Integer, length as Integer, advice as Integer, flags as Integer returns Integer:
    Note: Advise on other process memory
    Note: Cross-process optimization
    Note: Requires appropriate permissions
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("process_madvise")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: pidfd
        "mov rsi, %2\n"               Note: addr (iovec pointer)
        "mov rdx, %3\n"               Note: length (vlen)
        "mov r10, %4\n"               Note: advice
        "mov r8, %5\n"                Note: flags
        "mov rax, %6\n"               Note: sys_process_madvise from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pidfd), "r" (addr), "r" (length), "r" (advice), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: SHARED MEMORY
Note: =====================================================================

Process called "sys_shmget" that takes key as Integer, size as Integer, shmflg as Integer returns Integer:
    Note: Get shared memory segment
    Note: System V shared memory
    Note: Returns segment ID
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shmget")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: key
        "mov rsi, %2\n"               Note: size
        "mov rdx, %3\n"               Note: shmflg
        "mov rax, %4\n"               Note: sys_shmget from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (key), "r" (size), "r" (shmflg), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_shmat" that takes shmid as Integer, shmaddr as Integer, shmflg as Integer returns Integer:
    Note: Attach shared memory
    Note: Map into address space
    Note: Returns attach address
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shmat")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: shmid
        "mov rsi, %2\n"               Note: shmaddr
        "mov rdx, %3\n"               Note: shmflg
        "mov rax, %4\n"               Note: sys_shmat from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (shmid), "r" (shmaddr), "r" (shmflg), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_shmdt" that takes shmaddr as Integer returns Integer:
    Note: Detach shared memory
    Note: Unmap from address space
    Note: Returns 0 on success
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shmdt")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: shmaddr
        "mov rax, %2\n"               Note: sys_shmdt from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (shmaddr), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_shmctl" that takes shmid as Integer, cmd as Integer, buf as Integer returns Integer:
    Note: Control shared memory
    Note: IPC_STAT, IPC_SET, IPC_RMID
    Note: Manage segment attributes
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shmctl")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: shmid
        "mov rsi, %2\n"               Note: cmd
        "mov rdx, %3\n"               Note: buf
        "mov rax, %4\n"               Note: sys_shmctl from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (shmid), "r" (cmd), "r" (buf), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: MEMORY SYNCHRONIZATION
Note: =====================================================================

Process called "sys_msync" that takes addr as Integer, length as Integer, flags as Integer returns Integer:
    Note: Synchronize memory with storage
    Note: Flush changes to disk
    Note: MS_SYNC, MS_ASYNC, MS_INVALIDATE
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("msync")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: addr
        "mov rsi, %2\n"               Note: length
        "mov rdx, %3\n"               Note: flags
        "mov rax, %4\n"               Note: sys_msync from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (length), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_sync_file_range" that takes fd as Integer, offset as Integer, nbytes as Integer, flags as Integer returns Integer:
    Note: Sync file range to disk
    Note: Fine-grained sync control
    Note: Async writeback control
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("sync_file_range")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: fd
        "mov rsi, %2\n"               Note: offset
        "mov rdx, %3\n"               Note: nbytes
        "mov r10, %4\n"               Note: flags
        "mov rax, %5\n"               Note: sys_sync_file_range from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (fd), "r" (offset), "r" (nbytes), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: MEMORY INFORMATION
Note: =====================================================================

Process called "sys_mincore" that takes addr as Integer, length as Integer, vec as Integer returns Integer:
    Note: Check pages in memory
    Note: Page residency status
    Note: Returns page flags
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mincore")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: addr
        "mov rsi, %2\n"               Note: length
        "mov rdx, %3\n"               Note: vec
        "mov rax, %4\n"               Note: sys_mincore from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (length), "r" (vec), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_process_vm_readv" that takes pid as Integer, local_iov as Integer, liovcnt as Integer, remote_iov as Integer, riovcnt as Integer, flags as Integer returns Integer:
    Note: Read from another process
    Note: Cross-process memory access
    Note: Requires PTRACE_MODE_ATTACH
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("process_vm_readv")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: pid
        "mov rsi, %2\n"               Note: local_iov
        "mov rdx, %3\n"               Note: liovcnt
        "mov r10, %4\n"               Note: remote_iov
        "mov r8, %5\n"                Note: riovcnt
        "mov r9, %6\n"                Note: flags
        "mov rax, %7\n"               Note: sys_process_vm_readv from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pid), "r" (local_iov), "r" (liovcnt), "r" (remote_iov), "r" (riovcnt), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_process_vm_writev" that takes pid as Integer, local_iov as Integer, liovcnt as Integer, remote_iov as Integer, riovcnt as Integer, flags as Integer returns Integer:
    Note: Write to another process
    Note: Cross-process memory write
    Note: Requires PTRACE_MODE_ATTACH
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("process_vm_writev")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: pid
        "mov rsi, %2\n"               Note: local_iov
        "mov rdx, %3\n"               Note: liovcnt
        "mov r10, %4\n"               Note: remote_iov
        "mov r8, %5\n"                Note: riovcnt
        "mov r9, %6\n"                Note: flags
        "mov rax, %7\n"               Note: sys_process_vm_writev from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pid), "r" (local_iov), "r" (liovcnt), "r" (remote_iov), "r" (riovcnt), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: NUMA MEMORY MANAGEMENT
Note: =====================================================================

Process called "sys_mbind" that takes addr as Integer, len as Integer, mode as Integer, nodemask as Integer, maxnode as Integer, flags as Integer returns Integer:
    Note: Set NUMA memory policy
    Note: Bind memory to nodes
    Note: MPOL_BIND, MPOL_INTERLEAVE
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mbind")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: addr
        "mov rsi, %2\n"               Note: len
        "mov rdx, %3\n"               Note: mode
        "mov r10, %4\n"               Note: nodemask
        "mov r8, %5\n"                Note: maxnode
        "mov r9, %6\n"                Note: flags
        "mov rax, %7\n"               Note: sys_mbind from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (mode), "r" (nodemask), "r" (maxnode), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_get_mempolicy" that takes policy as Integer, nodemask as Integer, maxnode as Integer, addr as Integer, flags as Integer returns Integer:
    Note: Get NUMA memory policy
    Note: Query memory policy
    Note: Returns current policy
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("get_mempolicy")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: policy
        "mov rsi, %2\n"               Note: nodemask
        "mov rdx, %3\n"               Note: maxnode
        "mov r10, %4\n"               Note: addr
        "mov r8, %5\n"                Note: flags
        "mov rax, %6\n"               Note: sys_get_mempolicy from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (policy), "r" (nodemask), "r" (maxnode), "r" (addr), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_set_mempolicy" that takes mode as Integer, nodemask as Integer, maxnode as Integer returns Integer:
    Note: Set default NUMA policy
    Note: Process-wide policy
    Note: Affects future allocations
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("set_mempolicy")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: mode
        "mov rsi, %2\n"               Note: nodemask
        "mov rdx, %3\n"               Note: maxnode
        "mov rax, %4\n"               Note: sys_set_mempolicy from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (mode), "r" (nodemask), "r" (maxnode), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_migrate_pages" that takes pid as Integer, maxnode as Integer, old_nodes as Integer, new_nodes as Integer returns Integer:
    Note: Migrate pages between nodes
    Note: NUMA page migration
    Note: Requires CAP_SYS_NICE
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("migrate_pages")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: pid
        "mov rsi, %2\n"               Note: maxnode
        "mov rdx, %3\n"               Note: old_nodes
        "mov r10, %4\n"               Note: new_nodes
        "mov rax, %5\n"               Note: sys_migrate_pages from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pid), "r" (maxnode), "r" (old_nodes), "r" (new_nodes), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: HUGE PAGES
Note: =====================================================================

Process called "sys_mmap_hugepages" that takes addr as Integer, length as Integer, prot as Integer, flags as Integer, fd as Integer, offset as Integer returns Integer:
    Note: Map huge pages
    Note: MAP_HUGETLB flag required
    Note: Uses sys_mmap internally
    Note: 2MB or 1GB pages
    
    Note: Set MAP_HUGETLB flag (0x40000)
    Let hugetlb_flags be flags | 0x40000
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mmap")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: addr
        "mov rsi, %2\n"               Note: length
        "mov rdx, %3\n"               Note: prot
        "mov r10, %4\n"               Note: flags with MAP_HUGETLB
        "mov r8, %5\n"                Note: fd
        "mov r9, %6\n"                Note: offset
        "mov rax, %7\n"               Note: sys_mmap from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (length), "r" (prot), "r" (hugetlb_flags), "r" (fd), "r" (offset), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: MEMORY FILE DESCRIPTORS
Note: =====================================================================

Process called "sys_memfd_create" that takes name as String, flags as Integer returns Integer:
    Note: Create anonymous file
    Note: Memory-backed file descriptor
    Note: MFD_CLOEXEC, MFD_ALLOW_SEALING
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("memfd_create")
    Let name_ptr be get_string_pointer(name)
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: name
        "mov rsi, %2\n"               Note: flags
        "mov rax, %3\n"               Note: sys_memfd_create from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (name_ptr), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_memfd_secret" that takes flags as Integer returns Integer:
    Note: Create secret memory area
    Note: Excluded from dumps
    Note: Enhanced security
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("memfd_secret")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: flags
        "mov rax, %2\n"               Note: sys_memfd_secret from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: USERFAULTFD
Note: =====================================================================

Process called "sys_userfaultfd" that takes flags as Integer returns Integer:
    Note: Create userfaultfd object
    Note: User-space page fault handling
    Note: O_CLOEXEC, O_NONBLOCK
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("userfaultfd")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: flags
        "mov rax, %2\n"               Note: sys_userfaultfd from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result