Note:
runa/src/runatime/integration/system_interface/platform_syscalls/linux/ipc_syscalls.runa
Linux Inter-Process Communication Syscalls

Import "../../../../../../../compiler/backend/syscalls/platforms/linux_x64" as LinuxX64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/linux_arm64" as LinuxARM64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/platform_interface" as PlatformInterface

This module provides Linux-specific IPC syscall implementations,
including System V IPC, POSIX IPC, and modern IPC mechanisms.

Key features and capabilities:
- System V message queues
- System V semaphores
- System V shared memory
- POSIX message queues
- POSIX semaphores
- POSIX shared memory
- Pipes and FIFOs
- Unix domain sockets
- Memory-mapped files
- eventfd for signaling
- Futex operations
- Cross-memory attach
- Anonymous shared memory
- IPC namespaces
- IPC resource limits
:End Note


Note: =====================================================================
Note: IPC DATA STRUCTURES
Note: =====================================================================

Type called "MessageQueue":
    msqid as Integer                        Note: Message queue ID
    key as Integer                          Note: IPC key
    mode as Integer                         Note: Permission mode
    max_bytes as Integer                    Note: Maximum bytes in queue
    current_messages as Integer             Note: Current message count

Type called "Semaphore":
    semid as Integer                        Note: Semaphore set ID
    key as Integer                          Note: IPC key
    nsems as Integer                        Note: Number of semaphores
    mode as Integer                         Note: Permission mode

Type called "SharedMemory":
    shmid as Integer                        Note: Shared memory ID
    key as Integer                          Note: IPC key
    size as Integer                         Note: Segment size
    mode as Integer                         Note: Permission mode
    nattch as Integer                       Note: Number of attachments

Type called "MessageBuffer":
    mtype as Integer                        Note: Message type
    mtext as Integer                        Note: Message data pointer
    msize as Integer                        Note: Message size

Type called "SemaphoreOp":
    sem_num as Integer                      Note: Semaphore number
    sem_op as Integer                       Note: Operation value
    sem_flg as Integer                      Note: Operation flags

Note: =====================================================================
Note: MESSAGE QUEUES (SYSTEM V)
Note: =====================================================================

Process called "sys_msgget" that takes key as Integer, msgflg as Integer returns Integer:
    Note: Get message queue
    Note: Create or access queue
    Note: Returns queue ID
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("msgget")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: key
        "mov rsi, %2\n"               Note: msgflg
        "mov rax, %3\n"               Note: sys_msgget from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (key), "r" (msgflg), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_msgsnd" that takes msqid as Integer, msgp as Integer, msgsz as Integer, msgflg as Integer returns Integer:
    Note: Send message to queue
    Note: Add message to queue
    Note: IPC_NOWAIT for non-blocking
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("msgsnd")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: msqid
        "mov rsi, %2\n"               Note: msgp
        "mov rdx, %3\n"               Note: msgsz
        "mov r10, %4\n"               Note: msgflg
        "mov rax, %5\n"               Note: sys_msgsnd from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (msqid), "r" (msgp), "r" (msgsz), "r" (msgflg), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_msgrcv" that takes msqid as Integer, msgp as Integer, msgsz as Integer, msgtyp as Integer, msgflg as Integer returns Integer:
    Note: Receive message from queue
    Note: Remove message from queue
    Note: Syscall number: 70
    Note: MSG_NOERROR, MSG_EXCEPT
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: msqid
        "mov rsi, %2\n"               Note: msgp
        "mov rdx, %3\n"               Note: msgsz
        "mov r10, %4\n"               Note: msgtyp
        "mov r8, %5\n"                Note: msgflg
        "mov rax, %6\n"               Note: sys_msgrcv from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (msqid), "r" (msgp), "r" (msgsz), "r" (msgtyp), "r" (msgflg)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_msgctl" that takes msqid as Integer, cmd as Integer, buf as Integer returns Integer:
    Note: Control message queue
    Note: IPC_STAT, IPC_SET, IPC_RMID
    Note: Syscall number: 71
    Note: Manage queue attributes
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: msqid
        "mov rsi, %2\n"               Note: cmd
        "mov rdx, %3\n"               Note: buf
        "mov rax, %4\n"               Note: sys_msgctl from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (msqid), "r" (cmd), "r" (buf)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: SEMAPHORES (SYSTEM V)
Note: =====================================================================

Process called "sys_semget" that takes key as Integer, nsems as Integer, semflg as Integer returns Integer:
    Note: Get semaphore set
    Note: Create or access semaphores
    Note: Syscall number: 64
    Note: Returns semaphore ID
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: key
        "mov rsi, %2\n"               Note: nsems
        "mov rdx, %3\n"               Note: semflg
        "mov rax, %3\n"               Note: sys_semget from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (key), "r" (nsems), "r" (semflg)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_semop" that takes semid as Integer, sops as Integer, nsops as Integer returns Integer:
    Note: Semaphore operations
    Note: Perform semaphore ops
    Note: Syscall number: 65
    Note: Atomic operations
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: semid
        "mov rsi, %2\n"               Note: sops
        "mov rdx, %3\n"               Note: nsops
        "mov rax, %3\n"               Note: sys_semop from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (semid), "r" (sops), "r" (nsops)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_semtimedop" that takes semid as Integer, sops as Integer, nsops as Integer, timeout as Integer returns Integer:
    Note: Timed semaphore operations
    Note: Semop with timeout
    Note: Syscall number: 220
    Note: Prevents indefinite blocking
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: semid
        "mov rsi, %2\n"               Note: sops
        "mov rdx, %3\n"               Note: nsops
        "mov r10, %4\n"               Note: timeout
        "mov rax, %5\n"               Note: sys_semtimedop from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (semid), "r" (sops), "r" (nsops), "r" (timeout)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_semctl" that takes semid as Integer, semnum as Integer, cmd as Integer, arg as Integer returns Integer:
    Note: Control semaphore set
    Note: IPC_STAT, IPC_SET, IPC_RMID
    Note: Syscall number: 66
    Note: SETVAL, GETVAL operations
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: semid
        "mov rsi, %2\n"               Note: semnum
        "mov rdx, %3\n"               Note: cmd
        "mov r10, %4\n"               Note: arg
        "mov rax, %4\n"               Note: sys_semctl from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (semid), "r" (semnum), "r" (cmd), "r" (arg)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: SHARED MEMORY (SYSTEM V)
Note: =====================================================================

Process called "sys_shmget" that takes key as Integer, size as Integer, shmflg as Integer returns Integer:
    Note: Get shared memory segment
    Note: Create or access segment
    Note: Syscall number: 29
    Note: Returns segment ID
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: key
        "mov rsi, %2\n"               Note: size
        "mov rdx, %3\n"               Note: shmflg
        "mov rax, %3\n"               Note: sys_shmget from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (key), "r" (size), "r" (shmflg)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_shmat" that takes shmid as Integer, shmaddr as Integer, shmflg as Integer returns Integer:
    Note: Attach shared memory
    Note: Map into address space
    Note: Syscall number: 30
    Note: Returns attach address
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: shmid
        "mov rsi, %2\n"               Note: shmaddr
        "mov rdx, %3\n"               Note: shmflg
        "mov rax, %3\n"               Note: sys_shmat from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (shmid), "r" (shmaddr), "r" (shmflg)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_shmdt" that takes shmaddr as Integer returns Integer:
    Note: Detach shared memory
    Note: Unmap from address space
    Note: Syscall number: 67
    Note: Returns 0 on success
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: shmaddr
        "mov rax, %2\n"               Note: sys_shmdt from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (shmaddr)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_shmctl" that takes shmid as Integer, cmd as Integer, buf as Integer returns Integer:
    Note: Control shared memory
    Note: IPC_STAT, IPC_SET, IPC_RMID
    Note: Syscall number: 31
    Note: SHM_LOCK, SHM_UNLOCK
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: shmid
        "mov rsi, %2\n"               Note: cmd
        "mov rdx, %3\n"               Note: buf
        "mov rax, %4\n"               Note: sys_shmctl from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (shmid), "r" (cmd), "r" (buf)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: PIPES AND FIFOS
Note: =====================================================================

Process called "sys_pipe" that takes pipefd as Integer returns Integer:
    Note: Create pipe
    Note: Unidirectional data channel
    Note: Syscall number: 22
    Note: Returns two file descriptors
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: pipefd array
        "mov rax, %2\n"               Note: sys_pipe from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pipefd)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_pipe2" that takes pipefd as Integer, flags as Integer returns Integer:
    Note: Create pipe with flags
    Note: O_CLOEXEC, O_NONBLOCK
    Note: Syscall number: 293
    Note: Atomic flag setting
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: pipefd array
        "mov rsi, %2\n"               Note: flags
        "mov rax, %3\n"               Note: sys_pipe2 from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pipefd), "r" (flags)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_mkfifo" that takes pathname as String, mode as Integer returns Integer:
    Note: Create named pipe
    Note: FIFO special file
    Note: Uses mknod internally
    Note: Persistent named pipe
    
    Let path_ptr be get_string_pointer(pathname)
    Let result be Integer
    Let S_IFIFO be 0o010000        Note: FIFO type
    Let fifo_mode be mode | S_IFIFO
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: pathname
        "mov rsi, %2\n"               Note: mode with S_IFIFO
        "xor rdx, rdx\n"              Note: dev = 0 for FIFO
        "mov rax, %4\n"               Note: sys_mknod from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (path_ptr), "r" (fifo_mode)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: POSIX MESSAGE QUEUES
Note: =====================================================================

Process called "sys_mq_open" that takes name as String, oflag as Integer, mode as Integer, attr as Integer returns Integer:
    Note: Open POSIX message queue
    Note: Named message queue
    Note: Syscall number: 240
    Note: Returns queue descriptor
    
    Let name_ptr be get_string_pointer(name)
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: name
        "mov rsi, %2\n"               Note: oflag
        "mov rdx, %3\n"               Note: mode
        "mov r10, %4\n"               Note: attr
        "mov rax, %4\n"               Note: sys_mq_open from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (name_ptr), "r" (oflag), "r" (mode), "r" (attr)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_mq_send" that takes mqdes as Integer, msg_ptr as Integer, msg_len as Integer, msg_prio as Integer returns Integer:
    Note: Send POSIX message
    Note: Priority-based queuing
    Note: Syscall number: 242
    Note: Blocking or non-blocking
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: mqdes
        "mov rsi, %2\n"               Note: msg_ptr
        "mov rdx, %3\n"               Note: msg_len
        "mov r10, %4\n"               Note: msg_prio
        "xor r8, r8\n"                Note: timeout = NULL
        "mov rax, %6\n"               Note: sys_mq_timedsend from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (mqdes), "r" (msg_ptr), "r" (msg_len), "r" (msg_prio)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_mq_receive" that takes mqdes as Integer, msg_ptr as Integer, msg_len as Integer, msg_prio as Integer returns Integer:
    Note: Receive POSIX message
    Note: Priority-based dequeue
    Note: Syscall number: 243
    Note: Returns message length
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: mqdes
        "mov rsi, %2\n"               Note: msg_ptr
        "mov rdx, %3\n"               Note: msg_len
        "mov r10, %4\n"               Note: msg_prio
        "xor r8, r8\n"                Note: timeout = NULL
        "mov rax, %6\n"               Note: sys_mq_timedreceive from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (mqdes), "r" (msg_ptr), "r" (msg_len), "r" (msg_prio)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_mq_timedsend" that takes mqdes as Integer, msg_ptr as Integer, msg_len as Integer, msg_prio as Integer, abs_timeout as Integer returns Integer:
    Note: Timed message send
    Note: Send with timeout
    Note: Syscall number: 242
    Note: Absolute timeout
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: mqdes
        "mov rsi, %2\n"               Note: msg_ptr
        "mov rdx, %3\n"               Note: msg_len
        "mov r10, %4\n"               Note: msg_prio
        "mov r8, %5\n"                Note: abs_timeout
        "mov rax, %6\n"               Note: sys_mq_timedsend from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (mqdes), "r" (msg_ptr), "r" (msg_len), "r" (msg_prio), "r" (abs_timeout)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_mq_timedreceive" that takes mqdes as Integer, msg_ptr as Integer, msg_len as Integer, msg_prio as Integer, abs_timeout as Integer returns Integer:
    Note: Timed message receive
    Note: Receive with timeout
    Note: Syscall number: 243
    Note: Absolute timeout
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: mqdes
        "mov rsi, %2\n"               Note: msg_ptr
        "mov rdx, %3\n"               Note: msg_len
        "mov r10, %4\n"               Note: msg_prio
        "mov r8, %5\n"                Note: abs_timeout
        "mov rax, %6\n"               Note: sys_mq_timedreceive from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (mqdes), "r" (msg_ptr), "r" (msg_len), "r" (msg_prio), "r" (abs_timeout)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_mq_notify" that takes mqdes as Integer, sevp as Integer returns Integer:
    Note: Register for notification
    Note: Async message arrival
    Note: Syscall number: 244
    Note: Signal or thread notification
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: mqdes
        "mov rsi, %2\n"               Note: sevp
        "mov rax, %3\n"               Note: sys_mq_notify from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (mqdes), "r" (sevp)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_mq_getsetattr" that takes mqdes as Integer, newattr as Integer, oldattr as Integer returns Integer:
    Note: Get/set queue attributes
    Note: Configure queue behavior
    Note: Syscall number: 245
    Note: O_NONBLOCK flag
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: mqdes
        "mov rsi, %2\n"               Note: newattr
        "mov rdx, %3\n"               Note: oldattr
        "mov rax, %3\n"               Note: sys_mq_getsetattr from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (mqdes), "r" (newattr), "r" (oldattr)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_mq_unlink" that takes name as String returns Integer:
    Note: Remove message queue
    Note: Delete named queue
    Note: Syscall number: 241
    Note: Unlink from namespace
    
    Let name_ptr be get_string_pointer(name)
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: name
        "mov rax, %2\n"               Note: sys_mq_unlink from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (name_ptr)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: POSIX SEMAPHORES
Note: =====================================================================

Process called "sys_sem_open" that takes name as String, oflag as Integer, mode as Integer, value as Integer returns Integer:
    Note: Open named semaphore
    Note: POSIX semaphore
    Note: Not a direct syscall
    Note: Uses shared memory
    
    Note: POSIX semaphores use shared memory and futex
    Note: This is a high-level wrapper
    Let name_ptr be get_string_pointer(name)
    Let result be Integer
    
    Note: Open shared memory object for semaphore
    Inline Assembly:
        "mov rdi, %1\n"               Note: name
        "mov rsi, %2\n"               Note: oflag
        "mov rdx, %3\n"               Note: mode
        "mov rax, %3\n"               Note: sys_shm_open from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (name_ptr), "r" (oflag), "r" (mode)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Note: Initialize with value if created
    Return result

Process called "sys_sem_wait" that takes sem as Integer returns Integer:
    Note: Wait on semaphore
    Note: Decrement semaphore
    Note: Uses futex internally
    Note: May block
    
    Let result be Integer
    Let FUTEX_WAIT be 0
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sem address
        "mov rsi, 0\n"                Note: FUTEX_WAIT
        "mov rdx, 0\n"                Note: expected value
        "xor r10, r10\n"              Note: timeout = NULL
        "xor r8, r8\n"                Note: uaddr2 = NULL
        "xor r9, r9\n"                Note: val3 = 0
        "mov rax, %7\n"               Note: sys_futex from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sem)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_sem_post" that takes sem as Integer returns Integer:
    Note: Post to semaphore
    Note: Increment semaphore
    Note: Uses futex internally
    Note: Wake waiters
    
    Let result be Integer
    Let FUTEX_WAKE be 1
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sem address
        "mov rsi, 1\n"                Note: FUTEX_WAKE
        "mov rdx, 1\n"                Note: wake 1 waiter
        "xor r10, r10\n"              Note: timeout = NULL
        "xor r8, r8\n"                Note: uaddr2 = NULL
        "xor r9, r9\n"                Note: val3 = 0
        "mov rax, %7\n"               Note: sys_futex from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sem)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: EVENT FILE DESCRIPTORS
Note: =====================================================================

Process called "sys_eventfd2" that takes initval as Integer, flags as Integer returns Integer:
    Note: Create event file descriptor
    Note: Inter-thread/process signaling
    Note: Syscall number: 290
    Note: EFD_CLOEXEC, EFD_NONBLOCK
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: initval
        "mov rsi, %2\n"               Note: flags
        "mov rax, %3\n"               Note: sys_eventfd2 from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (initval), "r" (flags)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_eventfd_read" that takes fd as Integer, value as Integer returns Integer:
    Note: Read from eventfd
    Note: Consume counter value
    Note: Uses read syscall
    Note: 8-byte read
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: fd
        "mov rsi, %2\n"               Note: value buffer
        "mov rdx, 8\n"                Note: sizeof(uint64_t)
        "mov rax, %2\n"               Note: sys_read from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (fd), "r" (value)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_eventfd_write" that takes fd as Integer, value as Integer returns Integer:
    Note: Write to eventfd
    Note: Add to counter
    Note: Uses write syscall
    Note: 8-byte write
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: fd
        "mov rsi, %2\n"               Note: value buffer
        "mov rdx, 8\n"                Note: sizeof(uint64_t)
        "mov rax, %3\n"               Note: sys_write from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (fd), "r" (value)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result