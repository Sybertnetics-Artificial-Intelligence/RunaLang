Note:
runa/src/runatime/integration/system_interface/platform_syscalls/linux/security_syscalls.runa
Linux Security Syscalls

Import "../../../../../../../compiler/backend/syscalls/platforms/linux_x64" as LinuxX64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/linux_arm64" as LinuxARM64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/platform_interface" as PlatformInterface

This module provides Linux-specific security syscall implementations,
including capabilities, SELinux, AppArmor, seccomp, and modern security frameworks.

Key features and capabilities:
- Linux capabilities management
- SELinux context operations
- AppArmor profile management
- Seccomp filter installation
- Landlock security framework
- Key management subsystem
- Trusted Platform Module (TPM)
- Integrity Measurement Architecture (IMA)
- Linux Security Modules (LSM)
- User namespaces and isolation
- Mandatory Access Control (MAC)
- Audit subsystem integration
- Cryptographic operations
- Security Extended Attributes
- Process sandboxing
:End Note


Note: =====================================================================
Note: SECURITY DATA STRUCTURES
Note: =====================================================================

Type called "Capability":
    cap_effective as Integer                Note: Effective capabilities
    cap_permitted as Integer                Note: Permitted capabilities
    cap_inheritable as Integer              Note: Inheritable capabilities
    cap_bounding as Integer                 Note: Bounding set
    cap_ambient as Integer                  Note: Ambient capabilities

Type called "SeccompFilter":
    mode as Integer                         Note: SECCOMP_MODE_FILTER
    filter_prog as Integer                  Note: BPF program pointer
    prog_len as Integer                     Note: Program length
    flags as Integer                        Note: Filter flags

Type called "LandlockRuleset":
    handled_access_fs as Integer            Note: File system access rights
    handled_access_net as Integer           Note: Network access rights
    rules as Integer                        Note: Rules pointer
    rule_count as Integer                   Note: Number of rules

Type called "KeyringInfo":
    key_id as Integer                       Note: Key identifier
    type as String                          Note: Key type
    description as String                   Note: Key description
    payload as Integer                      Note: Key payload pointer
    payload_len as Integer                  Note: Payload length
    permissions as Integer                  Note: Access permissions

Type called "AuditMessage":
    type as Integer                         Note: Audit message type
    pid as Integer                          Note: Process ID
    uid as Integer                          Note: User ID
    sessionid as Integer                    Note: Audit session ID
    message as String                       Note: Audit message text

Note: =====================================================================
Note: CAPABILITIES MANAGEMENT
Note: =====================================================================

Process called "sys_capget" that takes header as Integer, dataptr as Integer returns Integer:
    Note: Get process capabilities
    Note: Query capability sets
    Note: Returns capability data
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("capget")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: header
        "mov rsi, %2\n"               Note: dataptr
        "mov rax, %3\n"               Note: sys_capget from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (header), "r" (dataptr), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_capset" that takes header as Integer, data as Integer returns Integer:
    Note: Set process capabilities
    Note: Modify capability sets
    Note: Requires CAP_SETPCAP
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("capset")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: header
        "mov rsi, %2\n"               Note: data
        "mov rax, %3\n"               Note: sys_capset from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (header), "r" (data), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_prctl_cap_ambient" that takes option as Integer, arg2 as Integer, arg3 as Integer returns Integer:
    Note: Manage ambient capabilities
    Note: PR_CAP_AMBIENT operations
    Note: Inherited across execve
    Note: Unprivileged capability retention
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("prctl")
    Let result be Integer
    Let PR_CAP_AMBIENT be 47
    
    Inline Assembly:
        "mov rdi, 47\n"               Note: PR_CAP_AMBIENT
        "mov rsi, %1\n"               Note: arg2 (sub-option)
        "mov rdx, %2\n"               Note: arg3 (capability)
        "xor r10, r10\n"              Note: arg4 = 0
        "xor r8, r8\n"                Note: arg5 = 0
        "mov rax, %3\n"               Note: sys_prctl from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (arg2), "r" (arg3), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: SECCOMP FILTERING
Note: =====================================================================

Process called "sys_seccomp" that takes operation as Integer, flags as Integer, args as Integer returns Integer:
    Note: Configure seccomp filters
    Note: Syscall filtering
    Note: SECCOMP_SET_MODE_FILTER
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("seccomp")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: operation
        "mov rsi, %2\n"               Note: flags
        "mov rdx, %3\n"               Note: args
        "mov rax, %4\n"               Note: sys_seccomp from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (operation), "r" (flags), "r" (args), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_prctl_seccomp" that takes option as Integer, arg2 as Integer returns Integer:
    Note: Legacy seccomp interface
    Note: PR_SET_SECCOMP
    Note: Basic filtering mode
    Note: Uses prctl syscall
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("prctl")
    Let result be Integer
    Let PR_SET_SECCOMP be 22
    
    Inline Assembly:
        "mov rdi, 22\n"               Note: PR_SET_SECCOMP
        "mov rsi, %1\n"               Note: arg2 (mode)
        "xor rdx, rdx\n"              Note: arg3 = 0
        "xor r10, r10\n"              Note: arg4 = 0
        "xor r8, r8\n"                Note: arg5 = 0
        "mov rax, %2\n"               Note: sys_prctl from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (arg2), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_seccomp_notify" that takes fd as Integer returns Integer:
    Note: User notification for seccomp
    Note: SECCOMP_RET_USER_NOTIF
    Note: Delegate decisions to userspace
    Note: Supervisor process handling
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("seccomp")
    Let result be Integer
    Let SECCOMP_GET_NOTIF_SIZES be 3
    
    Inline Assembly:
        "mov rdi, 3\n"                Note: SECCOMP_GET_NOTIF_SIZES
        "xor rsi, rsi\n"              Note: flags = 0
        "mov rdx, %1\n"               Note: args (sizes struct)
        "mov rax, %2\n"               Note: sys_seccomp from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (fd), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: LANDLOCK SECURITY
Note: =====================================================================

Process called "sys_landlock_create_ruleset" that takes attr as Integer, size as Integer, flags as Integer returns Integer:
    Note: Create Landlock ruleset
    Note: Define access restrictions
    Note: Returns ruleset FD
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("landlock_create_ruleset")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: attr
        "mov rsi, %2\n"               Note: size
        "mov rdx, %3\n"               Note: flags
        "mov rax, %4\n"               Note: sys_landlock_create_ruleset from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (attr), "r" (size), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_landlock_add_rule" that takes ruleset_fd as Integer, rule_type as Integer, rule_attr as Integer, flags as Integer returns Integer:
    Note: Add rule to ruleset
    Note: Path-based restrictions
    Note: LANDLOCK_RULE_PATH_BENEATH
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("landlock_add_rule")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: ruleset_fd
        "mov rsi, %2\n"               Note: rule_type
        "mov rdx, %3\n"               Note: rule_attr
        "mov r10, %4\n"               Note: flags
        "mov rax, %5\n"               Note: sys_landlock_add_rule from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (ruleset_fd), "r" (rule_type), "r" (rule_attr), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_landlock_restrict_self" that takes ruleset_fd as Integer, flags as Integer returns Integer:
    Note: Apply Landlock restrictions
    Note: Self-sandboxing
    Note: No privilege escalation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("landlock_restrict_self")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: ruleset_fd
        "mov rsi, %2\n"               Note: flags
        "mov rax, %3\n"               Note: sys_landlock_restrict_self from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (ruleset_fd), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: KEY MANAGEMENT
Note: =====================================================================

Process called "sys_add_key" that takes type as String, description as String, payload as Integer, plen as Integer, keyring as Integer returns Integer:
    Note: Add key to kernel keyring
    Note: Store cryptographic keys
    Note: Returns key ID
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("add_key")
    Let type_ptr be get_string_pointer(type)
    Let desc_ptr be get_string_pointer(description)
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: type
        "mov rsi, %2\n"               Note: description
        "mov rdx, %3\n"               Note: payload
        "mov r10, %4\n"               Note: plen
        "mov r8, %5\n"                Note: keyring
        "mov rax, %6\n"               Note: sys_add_key from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (type_ptr), "r" (desc_ptr), "r" (payload), "r" (plen), "r" (keyring), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_request_key" that takes type as String, description as String, callout_info as String, dest_keyring as Integer returns Integer:
    Note: Request key from keyring
    Note: Search for existing key
    Note: May trigger upcall
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("request_key")
    Let type_ptr be get_string_pointer(type)
    Let desc_ptr be get_string_pointer(description)
    Let callout_ptr be get_string_pointer(callout_info)
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: type
        "mov rsi, %2\n"               Note: description
        "mov rdx, %3\n"               Note: callout_info
        "mov r10, %4\n"               Note: dest_keyring
        "mov rax, %5\n"               Note: sys_request_key from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (type_ptr), "r" (desc_ptr), "r" (callout_ptr), "r" (dest_keyring), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_keyctl" that takes cmd as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer, arg5 as Integer returns Integer:
    Note: Key management operations
    Note: KEYCTL_* commands
    Note: Manipulate keyrings
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("keyctl")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: cmd
        "mov rsi, %2\n"               Note: arg2
        "mov rdx, %3\n"               Note: arg3
        "mov r10, %4\n"               Note: arg4
        "mov r8, %5\n"                Note: arg5
        "mov rax, %6\n"               Note: sys_keyctl from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (cmd), "r" (arg2), "r" (arg3), "r" (arg4), "r" (arg5), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: USER AND GROUP MANAGEMENT
Note: =====================================================================

Process called "sys_setuid" that takes uid as Integer returns Integer:
    Note: Set user ID
    Note: Change effective UID
    Note: Requires appropriate privileges
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("setuid")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: uid
        "mov rax, %2\n"               Note: sys_setuid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (uid), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_setgid" that takes gid as Integer returns Integer:
    Note: Set group ID
    Note: Change effective GID
    Note: Requires appropriate privileges
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("setgid")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: gid
        "mov rax, %2\n"               Note: sys_setgid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (gid), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_setresuid" that takes ruid as Integer, euid as Integer, suid as Integer returns Integer:
    Note: Set real, effective, saved UIDs
    Note: Fine-grained UID control
    Note: Atomic UID changes
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("setresuid")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: ruid
        "mov rsi, %2\n"               Note: euid
        "mov rdx, %3\n"               Note: suid
        "mov rax, %4\n"               Note: sys_setresuid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (ruid), "r" (euid), "r" (suid), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_setresgid" that takes rgid as Integer, egid as Integer, sgid as Integer returns Integer:
    Note: Set real, effective, saved GIDs
    Note: Fine-grained GID control
    Note: Atomic GID changes
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("setresgid")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: rgid
        "mov rsi, %2\n"               Note: egid
        "mov rdx, %3\n"               Note: sgid
        "mov rax, %4\n"               Note: sys_setresgid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (rgid), "r" (egid), "r" (sgid), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_getuid" returns Integer:
    Note: Get user ID
    Note: Current real UID
    Note: Always succeeds
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getuid")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"               Note: sys_getuid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rcx", "r11"
    End Assembly
    
    Return result

Process called "sys_geteuid" returns Integer:
    Note: Get effective user ID
    Note: Current effective UID
    Note: Always succeeds
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("geteuid")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"               Note: sys_geteuid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rcx", "r11"
    End Assembly
    
    Return result

Process called "sys_getgid" returns Integer:
    Note: Get group ID
    Note: Current real GID
    Note: Always succeeds
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getgid")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"               Note: sys_getgid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rcx", "r11"
    End Assembly
    
    Return result

Process called "sys_getegid" returns Integer:
    Note: Get effective group ID
    Note: Current effective GID
    Note: Always succeeds
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getegid")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"               Note: sys_getegid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rcx", "r11"
    End Assembly
    
    Return result

Process called "sys_setgroups" that takes size as Integer, list as Integer returns Integer:
    Note: Set supplementary groups
    Note: Group list membership
    Note: Requires CAP_SETGID
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("setgroups")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: size
        "mov rsi, %2\n"               Note: list
        "mov rax, %3\n"               Note: sys_setgroups from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (size), "r" (list), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_getgroups" that takes size as Integer, list as Integer returns Integer:
    Note: Get supplementary groups
    Note: Query group membership
    Note: Returns group count
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getgroups")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: size
        "mov rsi, %2\n"               Note: list
        "mov rax, %3\n"               Note: sys_getgroups from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (size), "r" (list), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: PRCTL SECURITY OPERATIONS
Note: =====================================================================

Process called "sys_prctl" that takes option as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer, arg5 as Integer returns Integer:
    Note: Process control operations
    Note: Security-related options
    Note: PR_SET_DUMPABLE, PR_SET_NO_NEW_PRIVS
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("prctl")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: option
        "mov rsi, %2\n"               Note: arg2
        "mov rdx, %3\n"               Note: arg3
        "mov r10, %4\n"               Note: arg4
        "mov r8, %5\n"                Note: arg5
        "mov rax, %6\n"               Note: sys_prctl from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (option), "r" (arg2), "r" (arg3), "r" (arg4), "r" (arg5), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_prctl_no_new_privs" returns Integer:
    Note: Set no-new-privileges flag
    Note: PR_SET_NO_NEW_PRIVS
    Note: Prevent privilege escalation
    Note: One-way operation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("prctl")
    Let result be Integer
    Let PR_SET_NO_NEW_PRIVS be 38
    
    Inline Assembly:
        "mov rdi, 38\n"               Note: PR_SET_NO_NEW_PRIVS
        "mov rsi, 1\n"                Note: arg2 = 1 (enable)
        "xor rdx, rdx\n"              Note: arg3 = 0
        "xor r10, r10\n"              Note: arg4 = 0
        "xor r8, r8\n"                Note: arg5 = 0
        "mov rax, %1\n"               Note: sys_prctl from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: SELINUX OPERATIONS
Note: =====================================================================

Process called "sys_setxattr_selinux" that takes path as String, context as String returns Integer:
    Note: Set SELinux context
    Note: security.selinux xattr
    Note: Uses setxattr internally
    Note: MAC label assignment
    
    Let path_ptr be get_string_pointer(path)
    Let context_ptr be get_string_pointer(context)
    Let context_len be string_length(context)
    Let attr_name be "security.selinux"
    Let attr_ptr be get_string_pointer(attr_name)
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: path
        "mov rsi, %2\n"               Note: name (security.selinux)
        "mov rdx, %3\n"               Note: value (context)
        "mov r10, %4\n"               Note: size
        "xor r8, r8\n"                Note: flags = 0
        "mov rax, %5\n"               Note: sys_setxattr from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (path_ptr), "r" (attr_ptr), "r" (context_ptr), "r" (context_len)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_getxattr_selinux" that takes path as String returns String:
    Note: Get SELinux context
    Note: security.selinux xattr
    Note: Uses getxattr internally
    Note: Query MAC label
    
    Let path_ptr be get_string_pointer(path)
    Let attr_name be "security.selinux"
    Let attr_ptr be get_string_pointer(attr_name)
    Let buffer_size be 4096
    Let buffer be allocate_buffer(buffer_size)
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: path
        "mov rsi, %2\n"               Note: name (security.selinux)
        "mov rdx, %3\n"               Note: value buffer
        "mov r10, %4\n"               Note: size
        "mov rax, %5\n"               Note: sys_getxattr from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (path_ptr), "r" (attr_ptr), "r" (buffer), "r" (buffer_size)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    If result > 0:
        Return buffer_to_string(buffer, result)
    Otherwise:
        Return ""
    End If

Note: =====================================================================
Note: APPARMOR OPERATIONS
Note: =====================================================================

Process called "sys_apparmor_changeprofile" that takes profile as String returns Integer:
    Note: Change AppArmor profile
    Note: Switch confinement
    Note: /proc interface
    Note: Profile transition
    
    Note: AppArmor uses /proc/self/attr/current
    Let proc_path be "/proc/self/attr/current"
    Let path_ptr be get_string_pointer(proc_path)
    Let profile_ptr be get_string_pointer(profile)
    Let profile_len be string_length(profile)
    Let result be Integer
    
    Note: Open /proc/self/attr/current
    Inline Assembly:
        "mov rdi, %1\n"               Note: pathname
        "mov rsi, 1\n"                Note: O_WRONLY
        "xor rdx, rdx\n"              Note: mode = 0
        "mov rax, %4\n"               Note: sys_open from registry
        "syscall\n"
        "test rax, rax\n"
        "js 1f\n"                     Note: Jump if error
        "mov rdi, rax\n"              Note: fd
        "mov rsi, %2\n"               Note: profile string
        "mov rdx, %3\n"               Note: length
        "mov rax, %5\n"               Note: sys_write from registry
        "syscall\n"
        "push rax\n"                  Note: Save write result
        "mov rax, %6\n"               Note: sys_close from registry
        "syscall\n"
        "pop rax\n"                   Note: Restore write result
        "1:\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (path_ptr), "r" (profile_ptr), "r" (profile_len)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: AUDIT SUBSYSTEM
Note: =====================================================================

Process called "sys_audit" that takes msg as AuditMessage returns Integer:
    Note: Send audit message
    Note: Security event logging
    Note: Netlink-based interface
    Note: Compliance reporting
    
    Note: Audit uses netlink socket
    Let AF_NETLINK be 16
    Let SOCK_RAW be 3
    Let NETLINK_AUDIT be 9
    Let result be Integer
    
    Note: Create netlink audit socket
    Inline Assembly:
        "mov rdi, 16\n"               Note: AF_NETLINK
        "mov rsi, 3\n"                Note: SOCK_RAW
        "mov rdx, 9\n"                Note: NETLINK_AUDIT
        "mov rax, %1\n"               Note: sys_socket from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        :
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_auditctl" that takes cmd as Integer, data as Integer returns Integer:
    Note: Control audit subsystem
    Note: Configure audit rules
    Note: Enable/disable auditing
    Note: Manage audit logs
    
    Let result be 0
    Let socket_fd be 0
    Let AF_NETLINK be 16
    Let NETLINK_AUDIT be 9
    
    Note: Create netlink socket for audit
    Inline Assembly:
        "mov rdi, %1\n"               Note: AF_NETLINK
        "mov rsi, 3\n"                Note: SOCK_RAW
        "mov rdx, %2\n"               Note: NETLINK_AUDIT
        "mov rax, %1\n"               Note: sys_socket from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (socket_fd)
        : "r" (AF_NETLINK), "r" (NETLINK_AUDIT)
        : "rax", "rdi", "rsi", "rdx", "memory"
    End Assembly
    
    If socket_fd < 0:
        Return socket_fd  Note: Return error
    End If
    
    Note: Send control message via netlink
    Inline Assembly:
        "sub rsp, 32\n"               Note: Allocate netlink header
        "mov dword ptr [rsp], 32\n"   Note: nlmsg_len
        "mov word ptr [rsp+4], %2\n"  Note: nlmsg_type (cmd)
        "mov word ptr [rsp+6], 0\n"   Note: nlmsg_flags
        "mov dword ptr [rsp+8], 0\n"  Note: nlmsg_seq
        "mov dword ptr [rsp+12], 0\n" Note: nlmsg_pid
        "mov qword ptr [rsp+16], %3\n" Note: data
        "mov rdi, %1\n"               Note: audit socket fd
        "mov rsi, rsp\n"              Note: Message buffer
        "mov rdx, 32\n"               Note: Message length
        "xor r10, r10\n"              Note: flags = 0
        "mov rax, %7\n"               Note: sys_sendto from registry
        "syscall\n"
        "add rsp, 32\n"               Note: Restore stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (socket_fd), "r" (cmd), "r" (data)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Note: Close the socket
    Inline Assembly:
        "mov rdi, %0\n"               Note: socket fd
        "mov rax, %6\n"               Note: sys_close from registry
        "syscall\n"
        :
        : "r" (socket_fd)
        : "rax", "rdi", "memory"
    End Assembly
    
    Return result