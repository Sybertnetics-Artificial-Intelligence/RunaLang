Note:
runa/src/runatime/integration/system_interface/platform_syscalls/linux/network_syscalls.runa
Linux Network Syscalls

Import "../../../../../../../compiler/backend/syscalls/platforms/linux_x64" as LinuxX64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/linux_arm64" as LinuxARM64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/platform_interface" as PlatformInterface

This module provides Linux-specific network syscall implementations,
including socket operations, network I/O, and protocol management.

Key features and capabilities:
- Socket creation and management
- TCP/UDP operations
- Unix domain sockets
- Network address operations
- Socket options (setsockopt, getsockopt)
- Non-blocking I/O
- Socket polling (poll, epoll)
- Asynchronous I/O
- Network namespaces
- Packet filtering (BPF)
- Raw sockets
- Multicast support
- Network interface control
- Netlink sockets
- SCTP protocol support
- AF_XDP for kernel bypass
:End Note

Note: =====================================================================
Note: NETWORK DATA STRUCTURES
Note: =====================================================================

Type called "SocketInfo":
    fd as Integer                           Note: Socket file descriptor
    domain as Integer                       Note: AF_INET, AF_INET6, AF_UNIX
    type as Integer                         Note: SOCK_STREAM, SOCK_DGRAM
    protocol as Integer                     Note: Protocol number
    state as String                         Note: Socket state
    local_addr as String                    Note: Local address
    remote_addr as String                   Note: Remote address

Type called "SockAddr":
    family as Integer                       Note: Address family
    port as Integer                         Note: Port number
    addr as String                          Note: IP address or path
    scope_id as Integer                     Note: IPv6 scope ID

Type called "SocketOption":
    level as Integer                        Note: SOL_SOCKET, IPPROTO_TCP, etc.
    optname as Integer                      Note: Option name
    optval as Integer                       Note: Option value pointer
    optlen as Integer                       Note: Option value length

Type called "PollFd":
    fd as Integer                           Note: File descriptor
    events as Integer                       Note: Requested events
    revents as Integer                      Note: Returned events

Type called "EpollEvent":
    events as Integer                       Note: Epoll events
    data as Integer                         Note: User data

Note: =====================================================================
Note: SOCKET CREATION AND MANAGEMENT
Note: =====================================================================

Process called "sys_socket" that takes domain as Integer, type as Integer, protocol as Integer returns Integer:
    Note: Create network socket
    Note: Returns socket descriptor
    Note: AF_INET, AF_INET6, AF_UNIX
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("socket")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: domain
        "mov rsi, %2\n"               Note: type
        "mov rdx, %3\n"               Note: protocol
        "mov rax, %4\n"               Note: sys_socket from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (domain), "r" (type), "r" (protocol), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_socketpair" that takes domain as Integer, type as Integer, protocol as Integer, sv as Integer returns Integer:
    Note: Create socket pair
    Note: Connected socket pair
    Note: For IPC communication
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("socketpair")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: domain
        "mov rsi, %2\n"               Note: type
        "mov rdx, %3\n"               Note: protocol
        "mov r10, %4\n"               Note: sv (socket pair array)
        "mov rax, %5\n"               Note: sys_socketpair from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (domain), "r" (type), "r" (protocol), "r" (sv), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_bind" that takes sockfd as Integer, addr as Integer, addrlen as Integer returns Integer:
    Note: Bind socket to address
    Note: Assign local address
    Note: Required for servers
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("bind")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: addr
        "mov rdx, %3\n"               Note: addrlen
        "mov rax, %4\n"               Note: sys_bind from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (addr), "r" (addrlen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_listen" that takes sockfd as Integer, backlog as Integer returns Integer:
    Note: Listen for connections
    Note: Mark as passive socket
    Note: Set connection queue size
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("listen")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: backlog
        "mov rax, %3\n"               Note: sys_listen from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (backlog), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_accept" that takes sockfd as Integer, addr as Integer, addrlen as Integer returns Integer:
    Note: Accept connection
    Note: Extract pending connection
    Note: Returns new socket
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("accept")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: addr
        "mov rdx, %3\n"               Note: addrlen
        "mov rax, %4\n"               Note: sys_accept from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (addr), "r" (addrlen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_accept4" that takes sockfd as Integer, addr as Integer, addrlen as Integer, flags as Integer returns Integer:
    Note: Accept with flags
    Note: SOCK_NONBLOCK, SOCK_CLOEXEC
    Note: Atomic flag setting
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("accept4")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: addr
        "mov rdx, %3\n"               Note: addrlen
        "mov r10, %4\n"               Note: flags
        "mov rax, %5\n"               Note: sys_accept4 from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (addr), "r" (addrlen), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_connect" that takes sockfd as Integer, addr as Integer, addrlen as Integer returns Integer:
    Note: Connect to remote socket
    Note: Establish connection
    Note: For client connections
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("connect")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: addr
        "mov rdx, %3\n"               Note: addrlen
        "mov rax, %4\n"               Note: sys_connect from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (addr), "r" (addrlen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: SOCKET I/O OPERATIONS
Note: =====================================================================

Process called "sys_send" that takes sockfd as Integer, buf as Integer, len as Integer, flags as Integer returns Integer:
    Note: Send data on socket
    Note: Basic send operation
    Note: MSG_DONTWAIT, MSG_NOSIGNAL
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("sendto")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: buf
        "mov rdx, %3\n"               Note: len
        "mov r10, %4\n"               Note: flags
        "mov rax, %5\n"               Note: sys_sendto from registry (send uses sendto)
        "xor r8, r8\n"                Note: dest_addr = NULL
        "xor r9, r9\n"                Note: addrlen = 0
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (buf), "r" (len), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_sendto" that takes sockfd as Integer, buf as Integer, len as Integer, flags as Integer, dest_addr as Integer, addrlen as Integer returns Integer:
    Note: Send to specific address
    Note: For unconnected sockets
    Note: UDP and raw sockets
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("sendto")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: buf
        "mov rdx, %3\n"               Note: len
        "mov r10, %4\n"               Note: flags
        "mov r8, %5\n"                Note: dest_addr
        "mov r9, %6\n"                Note: addrlen
        "mov rax, %7\n"               Note: sys_sendto from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (buf), "r" (len), "r" (flags), "r" (dest_addr), "r" (addrlen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_sendmsg" that takes sockfd as Integer, msg as Integer, flags as Integer returns Integer:
    Note: Send message
    Note: Advanced send with ancillary data
    Note: Control messages support
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("sendmsg")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: msg
        "mov rdx, %3\n"               Note: flags
        "mov rax, %4\n"               Note: sys_sendmsg from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (msg), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_recv" that takes sockfd as Integer, buf as Integer, len as Integer, flags as Integer returns Integer:
    Note: Receive data from socket
    Note: Basic receive operation
    Note: MSG_PEEK, MSG_WAITALL
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("recvfrom")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: buf
        "mov rdx, %3\n"               Note: len
        "mov r10, %4\n"               Note: flags
        "mov rax, %5\n"               Note: sys_recvfrom from registry (recv uses recvfrom)
        "xor r8, r8\n"                Note: src_addr = NULL
        "xor r9, r9\n"                Note: addrlen = NULL
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (buf), "r" (len), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_recvfrom" that takes sockfd as Integer, buf as Integer, len as Integer, flags as Integer, src_addr as Integer, addrlen as Integer returns Integer:
    Note: Receive with source address
    Note: Get sender information
    Note: For unconnected sockets
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("recvfrom")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: buf
        "mov rdx, %3\n"               Note: len
        "mov r10, %4\n"               Note: flags
        "mov r8, %5\n"                Note: src_addr
        "mov r9, %6\n"                Note: addrlen
        "mov rax, %7\n"               Note: sys_recvfrom from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (buf), "r" (len), "r" (flags), "r" (src_addr), "r" (addrlen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_recvmsg" that takes sockfd as Integer, msg as Integer, flags as Integer returns Integer:
    Note: Receive message
    Note: Advanced receive with ancillary
    Note: File descriptor passing
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("recvmsg")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: msg
        "mov rdx, %3\n"               Note: flags
        "mov rax, %4\n"               Note: sys_recvmsg from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (msg), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_sendmmsg" that takes sockfd as Integer, msgvec as Integer, vlen as Integer, flags as Integer returns Integer:
    Note: Send multiple messages
    Note: Batch send operation
    Note: Performance optimization
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("sendmmsg")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: msgvec
        "mov rdx, %3\n"               Note: vlen
        "mov r10, %4\n"               Note: flags
        "mov rax, %5\n"               Note: sys_sendmmsg from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (msgvec), "r" (vlen), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_recvmmsg" that takes sockfd as Integer, msgvec as Integer, vlen as Integer, flags as Integer, timeout as Integer returns Integer:
    Note: Receive multiple messages
    Note: Batch receive operation
    Note: Reduce syscall overhead
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("recvmmsg")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: msgvec
        "mov rdx, %3\n"               Note: vlen
        "mov r10, %4\n"               Note: flags
        "mov r8, %5\n"                Note: timeout
        "mov rax, %6\n"               Note: sys_recvmmsg from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (msgvec), "r" (vlen), "r" (flags), "r" (timeout), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: SOCKET OPTIONS
Note: =====================================================================

Process called "sys_setsockopt" that takes sockfd as Integer, level as Integer, optname as Integer, optval as Integer, optlen as Integer returns Integer:
    Note: Set socket option
    Note: Configure socket behavior
    Note: SO_REUSEADDR, TCP_NODELAY
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("setsockopt")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: level
        "mov rdx, %3\n"               Note: optname
        "mov r10, %4\n"               Note: optval
        "mov r8, %5\n"                Note: optlen
        "mov rax, %6\n"               Note: sys_setsockopt from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (level), "r" (optname), "r" (optval), "r" (optlen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_getsockopt" that takes sockfd as Integer, level as Integer, optname as Integer, optval as Integer, optlen as Integer returns Integer:
    Note: Get socket option
    Note: Query socket configuration
    Note: Returns option value
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getsockopt")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: level
        "mov rdx, %3\n"               Note: optname
        "mov r10, %4\n"               Note: optval
        "mov r8, %5\n"                Note: optlen
        "mov rax, %6\n"               Note: sys_getsockopt from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (level), "r" (optname), "r" (optval), "r" (optlen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: SOCKET STATUS
Note: =====================================================================

Process called "sys_getsockname" that takes sockfd as Integer, addr as Integer, addrlen as Integer returns Integer:
    Note: Get socket local address
    Note: Query bound address
    Note: After bind or connect
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getsockname")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: addr
        "mov rdx, %3\n"               Note: addrlen
        "mov rax, %4\n"               Note: sys_getsockname from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (addr), "r" (addrlen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_getpeername" that takes sockfd as Integer, addr as Integer, addrlen as Integer returns Integer:
    Note: Get peer address
    Note: Remote endpoint address
    Note: For connected sockets
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getpeername")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: addr
        "mov rdx, %3\n"               Note: addrlen
        "mov rax, %4\n"               Note: sys_getpeername from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (addr), "r" (addrlen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_shutdown" that takes sockfd as Integer, how as Integer returns Integer:
    Note: Shutdown socket connection
    Note: SHUT_RD, SHUT_WR, SHUT_RDWR
    Note: Graceful close
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shutdown")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, %2\n"               Note: how
        "mov rax, %3\n"               Note: sys_shutdown from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (how), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: POLLING AND EVENT NOTIFICATION
Note: =====================================================================

Process called "sys_poll" that takes fds as Integer, nfds as Integer, timeout as Integer returns Integer:
    Note: Poll file descriptors
    Note: Wait for events
    Note: Millisecond timeout
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("poll")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: fds
        "mov rsi, %2\n"               Note: nfds
        "mov rdx, %3\n"               Note: timeout
        "mov rax, %4\n"               Note: sys_poll from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (fds), "r" (nfds), "r" (timeout), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_ppoll" that takes fds as Integer, nfds as Integer, tmo_p as Integer, sigmask as Integer, sigsetsize as Integer returns Integer:
    Note: Poll with signal mask
    Note: Atomic poll and sigmask
    Note: Nanosecond precision
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("ppoll")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: fds
        "mov rsi, %2\n"               Note: nfds
        "mov rdx, %3\n"               Note: tmo_p
        "mov r10, %4\n"               Note: sigmask
        "mov r8, %5\n"                Note: sigsetsize
        "mov rax, %6\n"               Note: sys_ppoll from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (fds), "r" (nfds), "r" (tmo_p), "r" (sigmask), "r" (sigsetsize), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_select" that takes nfds as Integer, readfds as Integer, writefds as Integer, exceptfds as Integer, timeout as Integer returns Integer:
    Note: Synchronous I/O multiplexing
    Note: Monitor multiple descriptors
    Note: Legacy interface
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("select")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: nfds
        "mov rsi, %2\n"               Note: readfds
        "mov rdx, %3\n"               Note: writefds
        "mov r10, %4\n"               Note: exceptfds
        "mov r8, %5\n"                Note: timeout
        "mov rax, %6\n"               Note: sys_select from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (nfds), "r" (readfds), "r" (writefds), "r" (exceptfds), "r" (timeout), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_pselect6" that takes nfds as Integer, readfds as Integer, writefds as Integer, exceptfds as Integer, timeout as Integer, sigmask as Integer returns Integer:
    Note: Select with signal mask
    Note: Atomic select and sigmask
    Note: Nanosecond timeout
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("pselect6")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: nfds
        "mov rsi, %2\n"               Note: readfds
        "mov rdx, %3\n"               Note: writefds
        "mov r10, %4\n"               Note: exceptfds
        "mov r8, %5\n"                Note: timeout
        "mov r9, %6\n"                Note: sigmask
        "mov rax, %7\n"               Note: sys_pselect6 from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (nfds), "r" (readfds), "r" (writefds), "r" (exceptfds), "r" (timeout), "r" (sigmask), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: EPOLL EVENT NOTIFICATION
Note: =====================================================================

Process called "sys_epoll_create1" that takes flags as Integer returns Integer:
    Note: Create epoll instance
    Note: Scalable event notification
    Note: EPOLL_CLOEXEC flag
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("epoll_create1")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: flags
        "mov rax, %2\n"               Note: sys_epoll_create1 from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_epoll_ctl" that takes epfd as Integer, op as Integer, fd as Integer, event as Integer returns Integer:
    Note: Control epoll instance
    Note: Add/modify/delete descriptors
    Note: EPOLL_CTL_ADD, MOD, DEL
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("epoll_ctl")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: epfd
        "mov rsi, %2\n"               Note: op
        "mov rdx, %3\n"               Note: fd
        "mov r10, %4\n"               Note: event
        "mov rax, %5\n"               Note: sys_epoll_ctl from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (epfd), "r" (op), "r" (fd), "r" (event), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_epoll_wait" that takes epfd as Integer, events as Integer, maxevents as Integer, timeout as Integer returns Integer:
    Note: Wait for epoll events
    Note: Retrieve ready events
    Note: Returns event count
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("epoll_wait")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: epfd
        "mov rsi, %2\n"               Note: events
        "mov rdx, %3\n"               Note: maxevents
        "mov r10, %4\n"               Note: timeout
        "mov rax, %5\n"               Note: sys_epoll_wait from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (epfd), "r" (events), "r" (maxevents), "r" (timeout), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_epoll_pwait" that takes epfd as Integer, events as Integer, maxevents as Integer, timeout as Integer, sigmask as Integer, sigsetsize as Integer returns Integer:
    Note: Epoll with signal mask
    Note: Atomic wait and sigmask
    Note: Signal-safe waiting
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("epoll_pwait")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: epfd
        "mov rsi, %2\n"               Note: events
        "mov rdx, %3\n"               Note: maxevents
        "mov r10, %4\n"               Note: timeout
        "mov r8, %5\n"                Note: sigmask
        "mov r9, %6\n"                Note: sigsetsize
        "mov rax, %7\n"               Note: sys_epoll_pwait from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (epfd), "r" (events), "r" (maxevents), "r" (timeout), "r" (sigmask), "r" (sigsetsize), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Process called "sys_epoll_pwait2" that takes epfd as Integer, events as Integer, maxevents as Integer, timeout as Integer, sigmask as Integer, sigsetsize as Integer returns Integer:
    Note: Epoll with nanosecond timeout
    Note: High-precision waiting
    Note: Modern epoll variant
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("epoll_pwait2")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: epfd
        "mov rsi, %2\n"               Note: events
        "mov rdx, %3\n"               Note: maxevents
        "mov r10, %4\n"               Note: timeout (timespec pointer)
        "mov r8, %5\n"                Note: sigmask
        "mov r9, %6\n"                Note: sigsetsize
        "mov rax, %7\n"               Note: sys_epoll_pwait2 from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (epfd), "r" (events), "r" (maxevents), "r" (timeout), "r" (sigmask), "r" (sigsetsize), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: NETWORK INTERFACE CONTROL
Note: =====================================================================

Process called "sys_ioctl_network" that takes fd as Integer, request as Integer, argp as Integer returns Integer:
    Note: Network device control
    Note: Interface configuration
    Note: Uses sys_ioctl internally
    Note: SIOCGIFADDR, SIOCSIFADDR
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("ioctl")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: fd
        "mov rsi, %2\n"               Note: request
        "mov rdx, %3\n"               Note: argp
        "mov rax, %4\n"               Note: sys_ioctl from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (fd), "r" (request), "r" (argp), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: NETLINK SOCKETS
Note: =====================================================================

Process called "sys_netlink_socket" returns Integer:
    Note: Create netlink socket
    Note: Kernel communication
    Note: AF_NETLINK domain
    Note: Route, audit, etc.
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("socket")
    Let result be Integer
    Let AF_NETLINK be 16
    Let SOCK_RAW be 3
    Let NETLINK_ROUTE be 0
    
    Inline Assembly:
        "mov rdi, 16\n"               Note: AF_NETLINK
        "mov rsi, 3\n"                Note: SOCK_RAW
        "mov rdx, 0\n"                Note: NETLINK_ROUTE
        "mov rax, %1\n"               Note: sys_socket from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: BPF SOCKET FILTERING
Note: =====================================================================

Process called "sys_setsockopt_bpf" that takes sockfd as Integer, prog as Integer, prog_len as Integer returns Integer:
    Note: Attach BPF filter
    Note: Packet filtering
    Note: SO_ATTACH_BPF option
    Note: eBPF program attachment
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("setsockopt")
    Let result be Integer
    Let SOL_SOCKET be 1
    Let SO_ATTACH_BPF be 50
    
    Inline Assembly:
        "mov rdi, %1\n"               Note: sockfd
        "mov rsi, 1\n"                Note: SOL_SOCKET
        "mov rdx, 50\n"               Note: SO_ATTACH_BPF
        "mov r10, %2\n"               Note: prog
        "mov r8, %3\n"                Note: prog_len
        "mov rax, %4\n"               Note: sys_setsockopt from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (prog), "r" (prog_len), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result