Note: Linux Process Management Syscalls Implementation for x86_64
Note: Provides complete Linux-specific process management syscall implementations

Import "../../../../../../../compiler/backend/syscalls/platforms/linux_x64" as LinuxX64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/linux_arm64" as LinuxARM64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/platform_interface" as PlatformInterface

@Reasoning
This module implements Linux x86_64 process management syscalls using direct inline assembly.
Process creation, execution, termination, and control are fundamental operations for any
operating system interface. Each syscall follows Linux ABI conventions for x86_64.
@End Reasoning

Note: =====================================================================
Note: PROCESS CONSTANTS
Note: =====================================================================

Note: Clone flags
Let CLONE_VM be 0x00000100
Let CLONE_FS be 0x00000200
Let CLONE_FILES be 0x00000400
Let CLONE_SIGHAND be 0x00000800
Let CLONE_PIDFD be 0x00001000
Let CLONE_PTRACE be 0x00002000
Let CLONE_VFORK be 0x00004000
Let CLONE_PARENT be 0x00008000
Let CLONE_THREAD be 0x00010000
Let CLONE_NEWNS be 0x00020000
Let CLONE_SYSVSEM be 0x00040000
Let CLONE_SETTLS be 0x00080000
Let CLONE_PARENT_SETTID be 0x00100000
Let CLONE_CHILD_CLEARTID be 0x00200000
Let CLONE_DETACHED be 0x00400000
Let CLONE_UNTRACED be 0x00800000
Let CLONE_CHILD_SETTID be 0x01000000
Let CLONE_NEWCGROUP be 0x02000000
Let CLONE_NEWUTS be 0x04000000
Let CLONE_NEWIPC be 0x08000000
Let CLONE_NEWUSER be 0x10000000
Let CLONE_NEWPID be 0x20000000
Let CLONE_NEWNET be 0x40000000
Let CLONE_IO be 0x80000000

Note: Wait options
Let WNOHANG be 0x00000001
Let WUNTRACED be 0x00000002
Let WSTOPPED be 0x00000002
Let WEXITED be 0x00000004
Let WCONTINUED be 0x00000008
Let WNOWAIT be 0x01000000

Note: Signal numbers
Let SIGCHLD be 17
Let SIGTERM be 15
Let SIGKILL be 9
Let SIGSTOP be 19
Let SIGCONT be 18

Note: Priority constants
Let PRIO_PROCESS be 0
Let PRIO_PGRP be 1
Let PRIO_USER be 2

Note: Resource limits
Let RLIMIT_CPU be 0
Let RLIMIT_FSIZE be 1
Let RLIMIT_DATA be 2
Let RLIMIT_STACK be 3
Let RLIMIT_CORE be 4
Let RLIMIT_RSS be 5
Let RLIMIT_NPROC be 6
Let RLIMIT_NOFILE be 7
Let RLIMIT_MEMLOCK be 8
Let RLIMIT_AS be 9
Let RLIMIT_LOCKS be 10
Let RLIMIT_SIGPENDING be 11
Let RLIMIT_MSGQUEUE be 12
Let RLIMIT_NICE be 13
Let RLIMIT_RTPRIO be 14
Let RLIMIT_RTTIME be 15

Note: =====================================================================
Note: PROCESS CREATION
Note: =====================================================================

Process called "sys_fork" returns Integer:
    @Implementation
    Creates a child process by duplicating the calling process.
    Returns child PID to parent, 0 to child, or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("fork")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"           Note: sys_fork from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(syscall_num)
        : "rax", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_vfork" returns Integer:
    @Implementation
    Creates a child process that shares memory with parent until exec/exit.
    Parent is suspended until child calls exec or exits.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("vfork")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"           Note: sys_vfork from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(syscall_num)
        : "rax", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_clone" that takes flags as Integer, stack as Integer, parent_tid as Integer, child_tid as Integer, tls as Integer returns Integer:
    @Implementation
    Creates a child process/thread with fine-grained control over sharing.
    Supports threads, namespaces, and more. Returns child TID or error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("clone")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: flags
        "mov rsi, %2\n"           Note: stack
        "mov rdx, %3\n"           Note: parent_tid ptr
        "mov r10, %4\n"           Note: child_tid ptr
        "mov r8, %5\n"            Note: tls
        "mov rax, %6\n"           Note: sys_clone from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(flags), "r"(stack), "r"(parent_tid), "r"(child_tid), "r"(tls), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: =====================================================================
Note: PROCESS EXECUTION
Note: =====================================================================

Process called "sys_execve" that takes filename as String, argv as Integer, envp as Integer returns Integer:
    @Implementation
    Replaces current process image with new program.
    Never returns on success. Returns negative error on failure.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("execve")
    Let path_ptr be get_string_pointer(filename)
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: filename
        "mov rsi, %2\n"           Note: argv array
        "mov rdx, %3\n"           Note: envp array
        "mov rax, %4\n"           Note: sys_execve from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(path_ptr), "r"(argv), "r"(envp), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_execveat" that takes dirfd as Integer, pathname as String, argv as Integer, envp as Integer, flags as Integer returns Integer:
    @Implementation
    Executes program relative to directory file descriptor.
    Supports AT_EMPTY_PATH for fexecve behavior.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("execveat")
    Let path_ptr be get_string_pointer(pathname)
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: dirfd
        "mov rsi, %2\n"           Note: pathname
        "mov rdx, %3\n"           Note: argv
        "mov r10, %4\n"           Note: envp
        "mov r8, %5\n"            Note: flags
        "mov rax, %6\n"           Note: sys_execveat from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(dirfd), "r"(path_ptr), "r"(argv), "r"(envp), "r"(flags), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: =====================================================================
Note: PROCESS TERMINATION
Note: =====================================================================

Process called "sys_exit" that takes status as Integer:
    @Implementation
    Terminates the calling thread.
    In single-threaded process, terminates the process.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("exit")
    
    Inline Assembly:
        "mov rdi, %0\n"           Note: exit status
        "mov rax, %1\n"           Note: sys_exit from registry
        "syscall\n"
        Note: Never returns
        :
        : "r"(status), "r"(syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
End Process

Process called "sys_exit_group" that takes status as Integer:
    @Implementation
    Terminates all threads in the process.
    This is what normal program exit uses.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("exit_group")
    
    Inline Assembly:
        "mov rdi, %0\n"           Note: exit status
        "mov rax, %1\n"           Note: sys_exit_group from registry
        "syscall\n"
        Note: Never returns
        :
        : "r"(status), "r"(syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
End Process

Note: =====================================================================
Note: PROCESS WAITING
Note: =====================================================================

Process called "sys_wait4" that takes pid as Integer, status as Integer, options as Integer, rusage as Integer returns Integer:
    @Implementation
    Waits for child process state changes.
    Returns PID of child that changed state or error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("wait4")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: pid to wait for
        "mov rsi, %2\n"           Note: status pointer
        "mov rdx, %3\n"           Note: options
        "mov r10, %4\n"           Note: rusage pointer
        "mov rax, %5\n"           Note: sys_wait4 from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(pid), "r"(status), "r"(options), "r"(rusage), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_waitid" that takes idtype as Integer, id as Integer, infop as Integer, options as Integer, rusage as Integer returns Integer:
    @Implementation
    Extended wait that provides more control over what to wait for.
    Can wait for specific process, process group, or any child.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("waitid")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: idtype (P_PID, P_PGID, P_ALL)
        "mov rsi, %2\n"           Note: id
        "mov rdx, %3\n"           Note: siginfo pointer
        "mov r10, %4\n"           Note: options
        "mov r8, %5\n"            Note: rusage pointer
        "mov rax, %6\n"           Note: sys_waitid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(idtype), "r"(id), "r"(infop), "r"(options), "r"(rusage), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: =====================================================================
Note: PROCESS IDENTIFICATION
Note: =====================================================================

Process called "sys_getpid" returns Integer:
    @Implementation
    Returns the process ID of the calling process.
    Always succeeds.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getpid")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"           Note: sys_getpid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(syscall_num)
        : "rax", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Process called "sys_getppid" returns Integer:
    @Implementation
    Returns the process ID of the parent process.
    Always succeeds.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getppid")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"           Note: sys_getppid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(syscall_num)
        : "rax", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Process called "sys_getuid" returns Integer:
    @Implementation
    Returns the real user ID of the calling process.
    Always succeeds.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getuid")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"           Note: sys_getuid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(syscall_num)
        : "rax", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Process called "sys_geteuid" returns Integer:
    @Implementation
    Returns the effective user ID of the calling process.
    Always succeeds.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("geteuid")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"           Note: sys_geteuid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(syscall_num)
        : "rax", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Process called "sys_getgid" returns Integer:
    @Implementation
    Returns the real group ID of the calling process.
    Always succeeds.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getgid")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"           Note: sys_getgid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(syscall_num)
        : "rax", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Process called "sys_getegid" returns Integer:
    @Implementation
    Returns the effective group ID of the calling process.
    Always succeeds.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getegid")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"           Note: sys_getegid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(syscall_num)
        : "rax", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Note: =====================================================================
Note: PROCESS GROUPS AND SESSIONS
Note: =====================================================================

Process called "sys_setpgid" that takes pid as Integer, pgid as Integer returns Integer:
    @Implementation
    Sets the process group ID of a process.
    Used for job control. Returns 0 or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("setpgid")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: pid
        "mov rsi, %2\n"           Note: pgid
        "mov rax, %3\n"           Note: sys_setpgid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(pid), "r"(pgid), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Process called "sys_getpgid" that takes pid as Integer returns Integer:
    @Implementation
    Gets the process group ID of a process.
    Returns pgid or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getpgid")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: pid
        "mov rax, %2\n"           Note: sys_getpgid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(pid), "r"(syscall_num)
        : "rax", "rdi", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Process called "sys_setsid" returns Integer:
    @Implementation
    Creates a new session and sets the process group ID.
    Returns new session ID or negative error.
    @End Implementation
    
    Let result be Integer
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("setsid")
    
    Inline Assembly:
        "mov rax, %1\n"           Note: sys_setsid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(syscall_num)
        : "rax", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Process called "sys_getsid" that takes pid as Integer returns Integer:
    @Implementation
    Gets the session ID of a process.
    Returns session ID or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getsid")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: pid
        "mov rax, %2\n"           Note: sys_getsid from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(pid), "r"(syscall_num)
        : "rax", "rdi", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Note: =====================================================================
Note: PROCESS SIGNALING
Note: =====================================================================

Process called "sys_kill" that takes pid as Integer, sig as Integer returns Integer:
    @Implementation
    Sends a signal to a process or process group.
    Returns 0 on success or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("kill")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: pid
        "mov rsi, %2\n"           Note: signal
        "mov rax, %3\n"           Note: sys_kill from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(pid), "r"(sig), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Process called "sys_tkill" that takes tid as Integer, sig as Integer returns Integer:
    @Implementation
    Sends a signal to a specific thread.
    Returns 0 on success or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("tkill")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: tid
        "mov rsi, %2\n"           Note: signal
        "mov rax, %3\n"           Note: sys_tkill from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(tid), "r"(sig), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Process called "sys_tgkill" that takes tgid as Integer, tid as Integer, sig as Integer returns Integer:
    @Implementation
    Sends a signal to a thread in a specific thread group.
    More robust than tkill. Returns 0 or error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("tgkill")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: tgid
        "mov rsi, %2\n"           Note: tid
        "mov rdx, %3\n"           Note: signal
        "mov rax, %4\n"           Note: sys_tgkill from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(tgid), "r"(tid), "r"(sig), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Note: =====================================================================
Note: PROCESS PRIORITY AND SCHEDULING
Note: =====================================================================

Process called "sys_nice" that takes inc as Integer returns Integer:
    @Implementation
    Changes process priority by incrementing nice value.
    Returns new nice value or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("nice")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: increment
        "mov rax, %2\n"           Note: sys_nice from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(inc), "r"(syscall_num)
        : "rax", "rdi", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Process called "sys_getpriority" that takes which as Integer, who as Integer returns Integer:
    @Implementation
    Gets process, process group, or user priority.
    Returns priority (20-nice) or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getpriority")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: which (PRIO_PROCESS, etc)
        "mov rsi, %2\n"           Note: who (pid, pgid, uid)
        "mov rax, %3\n"           Note: sys_getpriority from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(which), "r"(who), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Process called "sys_setpriority" that takes which as Integer, who as Integer, prio as Integer returns Integer:
    @Implementation
    Sets process, process group, or user priority.
    Returns 0 on success or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("setpriority")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: which
        "mov rsi, %2\n"           Note: who
        "mov rdx, %3\n"           Note: priority
        "mov rax, %4\n"           Note: sys_setpriority from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(which), "r"(who), "r"(prio), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Note: =====================================================================
Note: RESOURCE LIMITS
Note: =====================================================================

Process called "sys_getrlimit" that takes resource as Integer, rlim as Integer returns Integer:
    @Implementation
    Gets resource limits for the calling process.
    Fills rlim structure. Returns 0 or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getrlimit")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: resource type
        "mov rsi, %2\n"           Note: rlimit struct pointer
        "mov rax, %3\n"           Note: sys_getrlimit from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(resource), "r"(rlim), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_setrlimit" that takes resource as Integer, rlim as Integer returns Integer:
    @Implementation
    Sets resource limits for the calling process.
    Returns 0 on success or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("setrlimit")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: resource type
        "mov rsi, %2\n"           Note: rlimit struct pointer
        "mov rax, %3\n"           Note: sys_setrlimit from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(resource), "r"(rlim), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_prlimit64" that takes pid as Integer, resource as Integer, new_limit as Integer, old_limit as Integer returns Integer:
    @Implementation
    Gets/sets resource limits for any process.
    Can atomically get and set. Returns 0 or error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("prlimit64")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: pid
        "mov rsi, %2\n"           Note: resource
        "mov rdx, %3\n"           Note: new limit
        "mov r10, %4\n"           Note: old limit
        "mov rax, %5\n"           Note: sys_prlimit64 from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(pid), "r"(resource), "r"(new_limit), "r"(old_limit), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: =====================================================================
Note: PROCESS TIMES
Note: =====================================================================

Process called "sys_times" that takes buf as Integer returns Integer:
    @Implementation
    Gets process times for current process and children.
    Returns clock ticks since boot or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("times")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: tms struct pointer
        "mov rax, %2\n"           Note: sys_times from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(buf), "r"(syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: =====================================================================
Note: PROCESS TRACING
Note: =====================================================================

Process called "sys_ptrace" that takes request as Integer, pid as Integer, addr as Integer, data as Integer returns Integer:
    @Implementation
    Process tracing for debuggers and system call interception.
    PTRACE_ATTACH, PTRACE_DETACH, PTRACE_PEEKDATA, etc.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("ptrace")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: request
        "mov rsi, %2\n"           Note: pid
        "mov rdx, %3\n"           Note: address
        "mov r10, %4\n"           Note: data
        "mov rax, %5\n"           Note: sys_ptrace from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(request), "r"(pid), "r"(addr), "r"(data), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: =====================================================================
Note: PROCESS AFFINITY
Note: =====================================================================

Process called "sys_sched_setaffinity" that takes pid as Integer, cpusetsize as Integer, mask as Integer returns Integer:
    @Implementation
    Sets CPU affinity mask for a process.
    Restricts process to specific CPUs. Returns 0 or error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("sched_setaffinity")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: pid
        "mov rsi, %2\n"           Note: cpusetsize
        "mov rdx, %3\n"           Note: cpu_set_t pointer
        "mov rax, %4\n"           Note: sys_sched_setaffinity from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(pid), "r"(cpusetsize), "r"(mask), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_sched_getaffinity" that takes pid as Integer, cpusetsize as Integer, mask as Integer returns Integer:
    @Implementation
    Gets CPU affinity mask for a process.
    Returns 0 on success or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("sched_getaffinity")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: pid
        "mov rsi, %2\n"           Note: cpusetsize
        "mov rdx, %3\n"           Note: cpu_set_t pointer
        "mov rax, %4\n"           Note: sys_sched_getaffinity from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(pid), "r"(cpusetsize), "r"(mask), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "get_string_pointer" that takes str as String returns Integer:
    @Implementation
    Returns pointer to the string's character data for syscall use.
    @End Implementation
    
    Let ptr be Integer
    
    Inline Assembly:
        "lea rax, %1\n"
        "mov %0, rax\n"
        : "=r"(ptr)
        : "m"(str)
        : "rax"
    End Assembly
    
    Return ptr
End Process