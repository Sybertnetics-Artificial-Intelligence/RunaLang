Note:
runa/src/runatime/integration/system_interface/platform_syscalls/darwin/ipc_syscalls.runa
Darwin/macOS Inter-Process Communication Syscalls

This module provides Darwin-specific IPC syscall implementations,
including Mach IPC, XPC, and traditional Unix IPC mechanisms.

Key features and capabilities:
- Mach ports and messages
- XPC services
- POSIX message queues
- System V IPC (semaphores, shared memory, message queues)
- Unix domain sockets
- Named pipes (FIFOs)
- Distributed notifications
- CFMessagePort
- NSDistributedNotificationCenter bridge
- Mach RPC
- Bootstrap services
- Launch daemon communication
- Service discovery
- Port rights management
- Complex message passing
:End Note

Import "../../../../../../../compiler/backend/syscalls/platforms/darwin_x64" as DarwinX64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/darwin_arm64" as DarwinARM64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/platform_interface" as PlatformInterface
Import "../../../../../../../compiler/frontend/primitives/types/compiler_internals" as Internals

Process called "string_to_ptr" that takes s as String returns Integer:
    Note: Get pointer to string data for syscall use
    Note: Platform-specific string address extraction
    
    Let ptr be 0
    
    Inline Assembly:
        "lea %%rax, %1\n"      Note: Load effective address of string
        "mov %%rax, %0\n"      Note: Store pointer
        : "=r" (ptr)
        : "m" (s)
        : "rax"
    End Assembly
    
    Return ptr

Note: =====================================================================
Note: DARWIN IPC DATA STRUCTURES
Note: =====================================================================

Type called "MachPort":
    port_name as Integer                    Note: Port name
    port_rights as Integer                  Note: Send/receive rights
    port_type as Integer                    Note: Port type
    refs as Integer                         Note: Reference count
    seqno as Integer                        Note: Sequence number
    mscount as Integer                      Note: Make-send count

Type called "MachMessage":
    msgh_bits as Integer                    Note: Message bits
    msgh_size as Integer                    Note: Message size
    msgh_remote_port as Integer             Note: Destination port
    msgh_local_port as Integer              Note: Reply port
    msgh_voucher_port as Integer            Note: Voucher port
    msgh_id as Integer                      Note: Message ID

Type called "XPCConnection":
    connection as Integer                    Note: Connection handle
    service_name as String                  Note: Service identifier
    flags as Integer                        Note: Connection flags
    handler as Integer                      Note: Message handler

Type called "PosixMsgQueue":
    mqd as Integer                          Note: Queue descriptor
    name as String                          Note: Queue name
    flags as Integer                        Note: Open flags
    maxmsg as Integer                       Note: Max messages
    msgsize as Integer                      Note: Max message size

Note: =====================================================================
Note: MACH PORTS
Note: =====================================================================

Process called "sys_mach_port_allocate" that takes task as Integer, right as Integer, name as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let trap_num be platform.get_syscall_number("mach_port_allocate")
    Let result be Integer
    
    Inline Assembly:
        "movq %1, %%rdi\n"             Note: task port
        "movl %2, %%esi\n"             Note: port right type
        "movq %3, %%rdx\n"             Note: name pointer
        "movq %4, %%rax\n"             Note: mach_port_allocate trap number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: kern_return_t
        : "=r" (result)
        : "r" (task), "r" (right), "r" (name), "r" (trap_num)
        : "rdi", "rsi", "rdx", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_mach_port_deallocate" that takes task as Integer, name as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let trap_num be platform.get_syscall_number("mach_port_deallocate")
    Let result be Integer
    
    Inline Assembly:
        "movq %1, %%rdi\n"             Note: task port
        "movl %2, %%esi\n"             Note: port name
        "movq %3, %%rax\n"             Note: mach_port_deallocate trap number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: kern_return_t
        : "=r" (result)
        : "r" (task), "r" (name), "r" (trap_num)
        : "rdi", "rsi", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_mach_port_insert_right" that takes task as Integer, name as Integer, poly as Integer, poly_type as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let trap_num be platform.get_syscall_number("mach_port_insert_right")
    Let result be Integer
    
    Inline Assembly:
        "movq %1, %%rdi\n"             Note: task port
        "movl %2, %%esi\n"             Note: port name
        "movl %3, %%edx\n"             Note: poly port
        "movl %4, %%ecx\n"             Note: poly type
        "movq %5, %%rax\n"             Note: mach_port_insert_right trap number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: kern_return_t
        : "=r" (result)
        : "r" (task), "r" (name), "r" (poly), "r" (poly_type), "r" (trap_num)
        : "rdi", "rsi", "rdx", "rcx", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_mach_port_extract_right" that takes task as Integer, name as Integer, desired_type as Integer, right as Integer, acquired_type as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let trap_num be platform.get_syscall_number("mach_port_extract_right")
    Let result be Integer
    
    Inline Assembly:
        "movq %1, %%rdi\n"             Note: task port
        "movl %2, %%esi\n"             Note: port name
        "movl %3, %%edx\n"             Note: desired type
        "movq %4, %%rcx\n"             Note: right pointer
        "movq %5, %%r8\n"              Note: acquired type pointer
        "movq %6, %%rax\n"             Note: mach_port_extract_right trap number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: kern_return_t
        : "=r" (result)
        : "r" (task), "r" (name), "r" (desired_type), "r" (right), "r" (acquired_type), "r" (trap_num)
        : "rdi", "rsi", "rdx", "rcx", "r8", "rax", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: MACH MESSAGES
Note: =====================================================================

Process called "sys_mach_msg" that takes msg as Integer, option as Integer, send_size as Integer, rcv_size as Integer, rcv_name as Integer, timeout as Integer, notify as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let trap_num be platform.get_syscall_number("mach_msg")
    Let result be Integer
    
    Inline Assembly:
        "subq $16, %%rsp\n"
        
        "movq %1, %%rdi\n"             Note: message buffer
        "movl %2, %%esi\n"             Note: option flags
        "movl %3, %%edx\n"             Note: send size
        "movl %4, %%ecx\n"             Note: receive size
        "movl %5, %%r8d\n"             Note: receive port
        "movl %6, %%r9d\n"             Note: timeout
        "movl %7, 0(%%rsp)\n"          Note: notify port on stack
        "movq %8, %%rax\n"             Note: mach_msg trap number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: kern_return_t
        
        "addq $16, %%rsp\n"
        
        : "=r" (result)
        : "r" (msg), "r" (option), "r" (send_size), "r" (rcv_size),
          "r" (rcv_name), "r" (timeout), "r" (notify), "r" (trap_num)
        : "rdi", "rsi", "rdx", "rcx", "r8", "r9", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_mach_msg_send" that takes msg as Integer returns Integer:
    Note: Send Mach message without receiving
    
    Let send_size be 0
    Let result be 0
    
    Note: Get message size from header
    Inline Assembly:
        "movl 4(%1), %0\n"             Note: Load msgh_size field
        : "=r" (send_size)
        : "r" (msg)
        : "memory"
    End Assembly
    
    Note: Call mach_msg with MACH_SEND_MSG option (0x1)
    Set result to sys_mach_msg(msg, 1, send_size, 0, 0, 0, 0)
    Return result

Process called "sys_mach_msg_receive" that takes msg as Integer returns Integer:
    Note: Receive Mach message without sending
    
    Let rcv_size be 8192  Note: Default receive buffer size
    Let rcv_port be 0
    Let result be 0
    
    Note: Get receive port from message header
    Inline Assembly:
        "movl 12(%1), %0\n"            Note: Load msgh_local_port field
        : "=r" (rcv_port)
        : "r" (msg)
        : "memory"
    End Assembly
    
    Note: Call mach_msg with MACH_RCV_MSG option (0x2)
    Set result to sys_mach_msg(msg, 2, 0, rcv_size, rcv_port, 0, 0)
    Return result

Note: =====================================================================
Note: XPC SERVICES
Note: =====================================================================

Process called "sys_xpc_connection_create" that takes name as String, target_queue as Integer returns Integer:
    Note: Create XPC service connection
    
    Let name_ptr be string_to_ptr(name)
    Let connection be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %1, %%rdi\n"             Note: service name
        "movq %2, %%rsi\n"             Note: dispatch queue
        "call _xpc_connection_create\n"
        "movq %%rax, %0\n"             Note: connection handle
        
        "popq %%rbp\n"
        
        : "=r" (connection)
        : "r" (name_ptr), "r" (target_queue)
        : "rdi", "rsi", "rax", "memory"
    End Assembly
    
    Return connection

Process called "sys_xpc_connection_send_message" that takes connection as Integer, message as Integer returns Nothing:
    Note: Send XPC message asynchronously
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %0, %%rdi\n"             Note: connection handle
        "movq %1, %%rsi\n"             Note: message dictionary
        "call _xpc_connection_send_message\n"
        
        "popq %%rbp\n"
        
        :
        : "r" (connection), "r" (message)
        : "rdi", "rsi", "rax", "memory"
    End Assembly

Process called "sys_xpc_connection_send_message_with_reply" that takes connection as Integer, message as Integer, target_queue as Integer, handler as Integer returns Nothing:
    Note: Send XPC message with reply handler
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %0, %%rdi\n"             Note: connection handle
        "movq %1, %%rsi\n"             Note: message dictionary
        "movq %2, %%rdx\n"             Note: target queue
        "movq %3, %%rcx\n"             Note: reply handler block
        "call _xpc_connection_send_message_with_reply\n"
        
        "popq %%rbp\n"
        
        :
        : "r" (connection), "r" (message), "r" (target_queue), "r" (handler)
        : "rdi", "rsi", "rdx", "rcx", "rax", "memory"
    End Assembly

Note: =====================================================================
Note: POSIX MESSAGE QUEUES
Note: =====================================================================

Process called "sys_mq_open_darwin" that takes name as String, oflag as Integer, mode as Integer, attr as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mq_open")
    Let name_ptr be string_to_ptr(name)
    Let mqd be Integer
    
    Inline Assembly:
        "movq %1, %%rdi\n"             Note: queue name
        "movl %2, %%esi\n"             Note: open flags
        "movl %3, %%edx\n"             Note: mode
        "movq %4, %%rcx\n"             Note: attributes
        "movq %5, %%rax\n"             Note: mq_open syscall number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: queue descriptor
        : "=r" (mqd)
        : "r" (name_ptr), "r" (oflag), "r" (mode), "r" (attr), "r" (syscall_num)
        : "rdi", "rsi", "rdx", "rcx", "rax", "memory"
    End Assembly
    
    Return mqd

Process called "sys_mq_send_darwin" that takes mqdes as Integer, msg_ptr as Integer, msg_len as Integer, msg_prio as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mq_send")
    Let result be Integer
    
    Inline Assembly:
        "movl %1, %%edi\n"             Note: queue descriptor
        "movq %2, %%rsi\n"             Note: message pointer
        "movq %3, %%rdx\n"             Note: message length
        "movl %4, %%ecx\n"             Note: priority
        "movq %5, %%rax\n"             Note: mq_send syscall number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: result
        : "=r" (result)
        : "r" (mqdes), "r" (msg_ptr), "r" (msg_len), "r" (msg_prio), "r" (syscall_num)
        : "rdi", "rsi", "rdx", "rcx", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_mq_receive_darwin" that takes mqdes as Integer, msg_ptr as Integer, msg_len as Integer, msg_prio as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mq_receive")
    Let bytes_received be Integer
    
    Inline Assembly:
        "movl %1, %%edi\n"             Note: queue descriptor
        "movq %2, %%rsi\n"             Note: message buffer
        "movq %3, %%rdx\n"             Note: buffer length
        "movq %4, %%rcx\n"             Note: priority pointer
        "movq %5, %%rax\n"             Note: mq_receive syscall number from registry
        "syscall\n"
        "movq %%rax, %0\n"             Note: bytes received
        : "=r" (bytes_received)
        : "r" (mqdes), "r" (msg_ptr), "r" (msg_len), "r" (msg_prio), "r" (syscall_num)
        : "rdi", "rsi", "rdx", "rcx", "rax", "memory"
    End Assembly
    
    Return bytes_received

Note: =====================================================================
Note: SYSTEM V IPC - SEMAPHORES
Note: =====================================================================

Process called "sys_semget_darwin" that takes key as Integer, nsems as Integer, semflg as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("semget")
    Let semid be Integer
    
    Inline Assembly:
        "movl %1, %%edi\n"             Note: IPC key
        "movl %2, %%esi\n"             Note: number of semaphores
        "movl %3, %%edx\n"             Note: flags
        "movq %4, %%rax\n"             Note: semget syscall number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: semaphore ID
        : "=r" (semid)
        : "r" (key), "r" (nsems), "r" (semflg), "r" (syscall_num)
        : "rdi", "rsi", "rdx", "rax", "memory"
    End Assembly
    
    Return semid

Process called "sys_semop_darwin" that takes semid as Integer, sops as Integer, nsops as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("semop")
    Let result be Integer
    
    Inline Assembly:
        "movl %1, %%edi\n"             Note: semaphore ID
        "movq %2, %%rsi\n"             Note: operations array
        "movq %3, %%rdx\n"             Note: number of operations
        "movq %4, %%rax\n"             Note: semop syscall number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: result
        : "=r" (result)
        : "r" (semid), "r" (sops), "r" (nsops), "r" (syscall_num)
        : "rdi", "rsi", "rdx", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_semctl_darwin" that takes semid as Integer, semnum as Integer, cmd as Integer, arg as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("semctl")
    Let result be Integer
    
    Inline Assembly:
        "movl %1, %%edi\n"             Note: semaphore ID
        "movl %2, %%esi\n"             Note: semaphore number
        "movl %3, %%edx\n"             Note: command
        "movq %4, %%rcx\n"             Note: argument
        "movq %5, %%rax\n"             Note: semctl syscall number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: result
        : "=r" (result)
        : "r" (semid), "r" (semnum), "r" (cmd), "r" (arg), "r" (syscall_num)
        : "rdi", "rsi", "rdx", "rcx", "rax", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: SYSTEM V IPC - SHARED MEMORY
Note: =====================================================================

Process called "sys_shmget_darwin" that takes key as Integer, size as Integer, shmflg as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shmget")
    Let shmid be Integer
    
    Inline Assembly:
        "movl %1, %%edi\n"             Note: IPC key
        "movq %2, %%rsi\n"             Note: segment size
        "movl %3, %%edx\n"             Note: flags
        "movq %4, %%rax\n"             Note: shmget syscall number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: segment ID
        : "=r" (shmid)
        : "r" (key), "r" (size), "r" (shmflg), "r" (syscall_num)
        : "rdi", "rsi", "rdx", "rax", "memory"
    End Assembly
    
    Return shmid

Process called "sys_shmat_darwin" that takes shmid as Integer, shmaddr as Integer, shmflg as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shmat")
    Let addr be Integer
    
    Inline Assembly:
        "movl %1, %%edi\n"             Note: segment ID
        "movq %2, %%rsi\n"             Note: attach address
        "movl %3, %%edx\n"             Note: flags
        "movq %4, %%rax\n"             Note: shmat syscall number from registry
        "syscall\n"
        "movq %%rax, %0\n"             Note: attached address
        : "=r" (addr)
        : "r" (shmid), "r" (shmaddr), "r" (shmflg), "r" (syscall_num)
        : "rdi", "rsi", "rdx", "rax", "memory"
    End Assembly
    
    Return addr

Process called "sys_shmdt_darwin" that takes shmaddr as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shmdt")
    Let result be Integer
    
    Inline Assembly:
        "movq %1, %%rdi\n"             Note: shared memory address
        "movq %2, %%rax\n"             Note: shmdt syscall number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: result
        : "=r" (result)
        : "r" (shmaddr), "r" (syscall_num)
        : "rdi", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_shmctl_darwin" that takes shmid as Integer, cmd as Integer, buf as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shmctl")
    Let result be Integer
    
    Inline Assembly:
        "movl %1, %%edi\n"             Note: segment ID
        "movl %2, %%esi\n"             Note: command
        "movq %3, %%rdx\n"             Note: buffer pointer
        "movq %4, %%rax\n"             Note: shmctl syscall number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: result
        : "=r" (result)
        : "r" (shmid), "r" (cmd), "r" (buf), "r" (syscall_num)
        : "rdi", "rsi", "rdx", "rax", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: SYSTEM V IPC - MESSAGE QUEUES
Note: =====================================================================

Process called "sys_msgget_darwin" that takes key as Integer, msgflg as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("msgget")
    Let msqid be Integer
    
    Inline Assembly:
        "movl %1, %%edi\n"             Note: IPC key
        "movl %2, %%esi\n"             Note: flags
        "movq %3, %%rax\n"             Note: msgget syscall number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: queue ID
        : "=r" (msqid)
        : "r" (key), "r" (msgflg), "r" (syscall_num)
        : "rdi", "rsi", "rax", "memory"
    End Assembly
    
    Return msqid

Process called "sys_msgsnd_darwin" that takes msqid as Integer, msgp as Integer, msgsz as Integer, msgflg as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("msgsnd")
    Let result be Integer
    
    Inline Assembly:
        "movl %1, %%edi\n"             Note: queue ID
        "movq %2, %%rsi\n"             Note: message pointer
        "movq %3, %%rdx\n"             Note: message size
        "movl %4, %%ecx\n"             Note: flags
        "movq %5, %%rax\n"             Note: msgsnd syscall number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: result
        : "=r" (result)
        : "r" (msqid), "r" (msgp), "r" (msgsz), "r" (msgflg), "r" (syscall_num)
        : "rdi", "rsi", "rdx", "rcx", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_msgrcv_darwin" that takes msqid as Integer, msgp as Integer, msgsz as Integer, msgtyp as Integer, msgflg as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("msgrcv")
    Let bytes_received be Integer
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movl %1, %%edi\n"             Note: queue ID
        "movq %2, %%rsi\n"             Note: message buffer
        "movq %3, %%rdx\n"             Note: buffer size
        "movq %4, %%rcx\n"             Note: message type
        "movl %5, %%r8d\n"             Note: flags
        "movq %5, %%rax\n"             Note: msgrcv syscall number from registry
        "syscall\n"
        "movq %%rax, %0\n"             Note: bytes received
        
        "popq %%rbp\n"
        
        : "=r" (bytes_received)
        : "r" (msqid), "r" (msgp), "r" (msgsz), "r" (msgtyp), "r" (msgflg), "r" (syscall_num)
        : "rdi", "rsi", "rdx", "rcx", "r8", "rax", "memory"
    End Assembly
    
    Return bytes_received

Note: =====================================================================
Note: PIPES AND FIFOS
Note: =====================================================================

Process called "sys_pipe_darwin" that takes pipefd as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("pipe")
    Let result be Integer
    
    Inline Assembly:
        "movq %1, %%rdi\n"             Note: pipe fd array
        "movq %2, %%rax\n"             Note: pipe syscall number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: result
        : "=r" (result)
        : "r" (pipefd), "r" (syscall_num)
        : "rdi", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_mkfifo_darwin" that takes pathname as String, mode as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mkfifo")
    Let path_ptr be string_to_ptr(pathname)
    Let result be Integer
    
    Inline Assembly:
        "movq %1, %%rdi\n"             Note: pathname
        "movl %2, %%esi\n"             Note: mode
        "movq %3, %%rax\n"             Note: mkfifo syscall number from registry
        "syscall\n"
        "movl %%eax, %0\n"             Note: result
        : "=r" (result)
        : "r" (path_ptr), "r" (mode), "r" (syscall_num)
        : "rdi", "rsi", "rax", "memory"
    End Assembly
    
    Return result