Note:
runa/src/runatime/integration/system_interface/platform_syscalls/darwin/extended_syscalls.runa
Darwin/macOS Extended Syscalls

This module provides Darwin-specific extended syscall implementations,
including modern macOS features and specialized system operations.

Key features and capabilities:
- FSEvents file system monitoring
- Spotlight search integration
- Core Data integration
- Metal GPU operations
- IOKit device access
- Power management
- Thermal management
- Display management
- Bluetooth operations
- Wi-Fi operations
- Location services
- Push notifications
- CloudKit integration
- Game Center integration
- HealthKit integration
:End Note

Import "../../../../../../../compiler/backend/syscalls/platforms/darwin_x64" as DarwinX64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/darwin_arm64" as DarwinARM64Platform
Import "../../../../../../../compiler/backend/syscalls/platforms/platform_interface" as PlatformInterface
Import "../../../../../../../compiler/frontend/primitives/types/compiler_internals" as Internals

Process called "string_to_ptr" that takes s as String returns Integer:
    Note: Get pointer to string data for syscall use
    Note: Platform-specific string address extraction
    
    Let ptr be 0
    
    Inline Assembly:
        "lea %%rax, %1\n"      Note: Load effective address of string
        "mov %%rax, %0\n"      Note: Store pointer
        : "=r" (ptr)
        : "m" (s)
        : "rax"
    End Assembly
    
    Return ptr

Note: =====================================================================
Note: DARWIN EXTENDED DATA STRUCTURES
Note: =====================================================================

Type called "FSEventStream":
    stream_ref as Integer                   Note: Stream reference
    paths as List[String]                   Note: Monitored paths
    since_when as Integer                   Note: Event ID start
    latency as Float                        Note: Notification latency
    flags as Integer                        Note: Stream flags
    callback as Integer                     Note: Event callback

Type called "SpotlightQuery":
    query_string as String                  Note: Search query
    scopes as List[String]                  Note: Search scopes
    attributes as List[String]              Note: Result attributes
    sort_descriptors as List[String]        Note: Sort order
    max_results as Integer                  Note: Result limit

Type called "IOKitDevice":
    service as Integer                      Note: IOService handle
    device_class as String                  Note: Device class
    properties as Dictionary[String, Any]   Note: Device properties
    parent as Integer                       Note: Parent service
    iterator as Integer                     Note: Device iterator

Type called "PowerState":
    ac_power as Boolean                     Note: AC power connected
    battery_level as Integer                Note: Battery percentage
    thermal_state as String                 Note: Thermal pressure
    cpu_speed_limit as Integer              Note: CPU throttling
    low_power_mode as Boolean               Note: Power saving mode

Note: =====================================================================
Note: FSEVENTS FILE MONITORING
Note: =====================================================================

Process called "sys_FSEventStreamCreate" that takes allocator as Integer, callback as Integer, context as Integer, paths as Integer, since_when as Integer, latency as Float, flags as Integer returns Integer:
    Note: Create FSEvents stream for file system monitoring
    
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        "subq $32, %%rsp\n"
        
        Note: Load parameters
        "movq %1, %%rdi\n"             Note: allocator
        "movq %2, %%rsi\n"             Note: callback
        "movq %3, %%rdx\n"             Note: context
        "movq %4, %%rcx\n"             Note: paths CFArray
        "movq %5, %%r8\n"              Note: since_when
        "movsd %6, %%xmm0\n"           Note: latency (double in xmm0)
        "movq %7, %%r9\n"              Note: flags
        
        Note: Call FSEventStreamCreate
        "call _FSEventStreamCreate\n"
        
        Note: Result in rax
        "movq %%rax, %0\n"
        
        "movq %%rbp, %%rsp\n"
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (allocator), "r" (callback), "r" (context), "r" (paths),
          "r" (since_when), "m" (latency), "r" (flags)
        : "rdi", "rsi", "rdx", "rcx", "r8", "r9", "xmm0", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_FSEventStreamStart" that takes stream as Integer returns Boolean:
    Note: Start FSEvents stream monitoring
    
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %1, %%rdi\n"             Note: stream reference
        "call _FSEventStreamStart\n"
        "movq %%rax, %0\n"             Note: Boolean result
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (stream)
        : "rdi", "rax", "memory"
    End Assembly
    
    Return result != 0

Process called "sys_FSEventStreamStop" that takes stream as Integer returns Nothing:
    Note: Stop FSEvents stream monitoring
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %0, %%rdi\n"             Note: stream reference
        "call _FSEventStreamStop\n"
        
        "popq %%rbp\n"
        
        :
        : "r" (stream)
        : "rdi", "rax", "memory"
    End Assembly

Process called "sys_FSEventStreamInvalidate" that takes stream as Integer returns Nothing:
    Note: Invalidate FSEvents stream permanently
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %0, %%rdi\n"             Note: stream reference
        "call _FSEventStreamInvalidate\n"
        
        "popq %%rbp\n"
        
        :
        : "r" (stream)
        : "rdi", "rax", "memory"
    End Assembly

Note: =====================================================================
Note: SPOTLIGHT SEARCH
Note: =====================================================================

Process called "sys_MDQueryCreate" that takes allocator as Integer, query_string as String, value_list as Integer, sort_order as Integer returns Integer:
    Note: Create Spotlight metadata query
    
    Let query_ptr be string_to_ptr(query_string)
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %1, %%rdi\n"             Note: allocator
        "movq %2, %%rsi\n"             Note: query string
        "movq %3, %%rdx\n"             Note: value list
        "movq %4, %%rcx\n"             Note: sort order
        "call _MDQueryCreate\n"
        "movq %%rax, %0\n"             Note: query reference
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (allocator), "r" (query_ptr), "r" (value_list), "r" (sort_order)
        : "rdi", "rsi", "rdx", "rcx", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_MDQueryExecute" that takes query as Integer, options as Integer returns Boolean:
    Note: Execute Spotlight query synchronously
    
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %1, %%rdi\n"             Note: query reference
        "movq %2, %%rsi\n"             Note: options flags
        "call _MDQueryExecute\n"
        "movq %%rax, %0\n"             Note: Boolean result
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (query), "r" (options)
        : "rdi", "rsi", "rax", "memory"
    End Assembly
    
    Return result != 0

Process called "sys_MDQueryGetResultCount" that takes query as Integer returns Integer:
    Note: Get number of Spotlight query results
    
    Let count be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %1, %%rdi\n"             Note: query reference
        "call _MDQueryGetResultCount\n"
        "movq %%rax, %0\n"             Note: result count
        
        "popq %%rbp\n"
        
        : "=r" (count)
        : "r" (query)
        : "rdi", "rax", "memory"
    End Assembly
    
    Return count

Process called "sys_MDQueryGetResultAtIndex" that takes query as Integer, index as Integer returns Integer:
    Note: Get Spotlight result at specific index
    
    Let item be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %1, %%rdi\n"             Note: query reference
        "movq %2, %%rsi\n"             Note: result index
        "call _MDQueryGetResultAtIndex\n"
        "movq %%rax, %0\n"             Note: MDItem reference
        
        "popq %%rbp\n"
        
        : "=r" (item)
        : "r" (query), "r" (index)
        : "rdi", "rsi", "rax", "memory"
    End Assembly
    
    Return item

Note: =====================================================================
Note: IOKIT DEVICE ACCESS
Note: =====================================================================

Process called "sys_IOServiceGetMatchingServices" that takes master_port as Integer, matching as Integer, iterator as Integer returns Integer:
    Note: Enumerate IOKit services matching criteria
    
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %1, %%rdi\n"             Note: master port
        "movq %2, %%rsi\n"             Note: matching dictionary
        "movq %3, %%rdx\n"             Note: iterator pointer
        "call _IOServiceGetMatchingServices\n"
        "movl %%eax, %0\n"             Note: kern_return_t (32-bit)
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (master_port), "r" (matching), "r" (iterator)
        : "rdi", "rsi", "rdx", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_IOServiceOpen" that takes service as Integer, owning_task as Integer, type as Integer, connect as Integer returns Integer:
    Note: Open connection to IOKit service
    
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %1, %%rdi\n"             Note: service handle
        "movq %2, %%rsi\n"             Note: owning task
        "movl %3, %%edx\n"             Note: connection type (32-bit)
        "movq %4, %%rcx\n"             Note: connection pointer
        "call _IOServiceOpen\n"
        "movl %%eax, %0\n"             Note: kern_return_t (32-bit)
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (service), "r" (owning_task), "r" (type), "r" (connect)
        : "rdi", "rsi", "rdx", "rcx", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_IOConnectCallMethod" that takes connection as Integer, selector as Integer, input as Integer, input_count as Integer, input_struct as Integer, input_struct_count as Integer, output as Integer, output_count as Integer, output_struct as Integer, output_struct_count as Integer returns Integer:
    Note: Call IOKit device driver method
    
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        "subq $32, %%rsp\n"
        
        Note: Load parameters
        "movq %1, %%rdi\n"             Note: connection
        "movl %2, %%esi\n"             Note: selector (32-bit)
        "movq %3, %%rdx\n"             Note: input scalars
        "movl %4, %%ecx\n"             Note: input count (32-bit)
        "movq %5, %%r8\n"              Note: input struct
        "movq %6, %%r9\n"              Note: input struct count
        
        Note: Push remaining parameters
        "movq %7, 0(%%rsp)\n"          Note: output scalars
        "movq %8, 8(%%rsp)\n"          Note: output count
        "movq %9, 16(%%rsp)\n"         Note: output struct
        "movq %10, 24(%%rsp)\n"        Note: output struct count
        
        "call _IOConnectCallMethod\n"
        "movl %%eax, %0\n"             Note: kern_return_t (32-bit)
        
        "movq %%rbp, %%rsp\n"
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (connection), "r" (selector), "r" (input), "r" (input_count),
          "r" (input_struct), "r" (input_struct_count), "r" (output), "r" (output_count),
          "r" (output_struct), "r" (output_struct_count)
        : "rdi", "rsi", "rdx", "rcx", "r8", "r9", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_IOServiceClose" that takes connect as Integer returns Integer:
    Note: Close IOKit service connection
    
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %1, %%rdi\n"             Note: connection handle
        "call _IOServiceClose\n"
        "movl %%eax, %0\n"             Note: kern_return_t (32-bit)
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (connect)
        : "rdi", "rax", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: POWER MANAGEMENT
Note: =====================================================================

Process called "sys_IOPMAssertionCreateWithName" that takes assertion_type as String, assertion_level as Integer, assertion_name as String, assertion_id as Integer returns Integer:
    Note: Create power management assertion
    
    Let type_ptr be string_to_ptr(assertion_type)
    Let name_ptr be string_to_ptr(assertion_name)
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %1, %%rdi\n"             Note: assertion type CFString
        "movl %2, %%esi\n"             Note: assertion level (32-bit)
        "movq %3, %%rdx\n"             Note: assertion name CFString
        "movq %4, %%rcx\n"             Note: assertion ID pointer
        "call _IOPMAssertionCreateWithName\n"
        "movl %%eax, %0\n"             Note: IOReturn (32-bit)
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (type_ptr), "r" (assertion_level), "r" (name_ptr), "r" (assertion_id)
        : "rdi", "rsi", "rdx", "rcx", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_IOPMAssertionRelease" that takes assertion_id as Integer returns Integer:
    Note: Release power management assertion
    
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movl %1, %%edi\n"             Note: assertion ID (32-bit)
        "call _IOPMAssertionRelease\n"
        "movl %%eax, %0\n"             Note: IOReturn (32-bit)
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (assertion_id)
        : "rdi", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_IOPMCopyBatteryInfo" that takes allocator as Integer, info as Integer returns Integer:
    Note: Copy battery information
    
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %1, %%rdi\n"             Note: CFAllocator
        "movq %2, %%rsi\n"             Note: info pointer
        "call _IOPMCopyBatteryInfo\n"
        "movl %%eax, %0\n"             Note: IOReturn (32-bit)
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (allocator), "r" (info)
        : "rdi", "rsi", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_IOPMSchedulePowerEvent" that takes time_to_wake as Integer, my_id as String, type as Integer returns Integer:
    Note: Schedule power management event
    
    Let id_ptr be string_to_ptr(my_id)
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %1, %%rdi\n"             Note: time to wake CFDate
        "movq %2, %%rsi\n"             Note: event ID CFString
        "movl %3, %%edx\n"             Note: event type (32-bit)
        "call _IOPMSchedulePowerEvent\n"
        "movl %%eax, %0\n"             Note: IOReturn (32-bit)
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (time_to_wake), "r" (id_ptr), "r" (type)
        : "rdi", "rsi", "rdx", "rax", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: THERMAL MANAGEMENT
Note: =====================================================================

Process called "sys_OSThermalNotificationCurrentLevel" returns Integer:
    Note: Get current thermal pressure level
    
    Let level be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "call _OSThermalNotificationCurrentLevel\n"
        "movl %%eax, %0\n"             Note: Thermal level (32-bit)
        
        "popq %%rbp\n"
        
        : "=r" (level)
        :
        : "rax", "memory"
    End Assembly
    
    Return level

Process called "sys_notify_register_check" that takes name as String, token as Integer returns Integer:
    Note: Register for system notifications
    
    Let name_ptr be string_to_ptr(name)
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movq %1, %%rdi\n"             Note: notification name
        "movq %2, %%rsi\n"             Note: token pointer
        "call _notify_register_check\n"
        "movl %%eax, %0\n"             Note: status (32-bit)
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (name_ptr), "r" (token)
        : "rdi", "rsi", "rax", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: DISPLAY MANAGEMENT
Note: =====================================================================

Process called "sys_CGGetActiveDisplayList" that takes max_displays as Integer, active_displays as Integer, display_count as Integer returns Integer:
    Note: Get list of active displays
    
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movl %1, %%edi\n"             Note: max displays (32-bit)
        "movq %2, %%rsi\n"             Note: display array
        "movq %3, %%rdx\n"             Note: count pointer
        "call _CGGetActiveDisplayList\n"
        "movl %%eax, %0\n"             Note: CGError (32-bit)
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (max_displays), "r" (active_displays), "r" (display_count)
        : "rdi", "rsi", "rdx", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_CGDisplayBounds" that takes display as Integer returns Integer:
    Note: Get display screen bounds
    
    Let rect_ptr be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        "subq $32, %%rsp\n"            Note: Space for CGRect
        
        "movl %1, %%edi\n"             Note: display ID (32-bit)
        "call _CGDisplayBounds\n"
        Note: CGRect returned in xmm0-xmm1 (packed)
        "movupd %%xmm0, 0(%%rsp)\n"   Note: Store x,y
        "movupd %%xmm1, 16(%%rsp)\n"  Note: Store width,height
        "movq %%rsp, %0\n"             Note: Return rect pointer
        
        "movq %%rbp, %%rsp\n"
        "popq %%rbp\n"
        
        : "=r" (rect_ptr)
        : "r" (display)
        : "rdi", "xmm0", "xmm1", "rax", "memory"
    End Assembly
    
    Return rect_ptr

Process called "sys_CGDisplayCapture" that takes display as Integer returns Integer:
    Note: Capture display for exclusive access
    
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movl %1, %%edi\n"             Note: display ID (32-bit)
        "call _CGDisplayCapture\n"
        "movl %%eax, %0\n"             Note: CGError (32-bit)
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (display)
        : "rdi", "rax", "memory"
    End Assembly
    
    Return result

Process called "sys_CGDisplayRelease" that takes display as Integer returns Integer:
    Note: Release captured display
    
    Let result be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "movl %1, %%edi\n"             Note: display ID (32-bit)
        "call _CGDisplayRelease\n"
        "movl %%eax, %0\n"             Note: CGError (32-bit)
        
        "popq %%rbp\n"
        
        : "=r" (result)
        : "r" (display)
        : "rdi", "rax", "memory"
    End Assembly
    
    Return result

Note: =====================================================================
Note: METAL GPU OPERATIONS
Note: =====================================================================

Process called "sys_MTLCreateSystemDefaultDevice" returns Integer:
    Note: Get default Metal GPU device
    
    Let device be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        "call _MTLCreateSystemDefaultDevice\n"
        "movq %%rax, %0\n"             Note: Device handle
        
        "popq %%rbp\n"
        
        : "=r" (device)
        :
        : "rax", "memory"
    End Assembly
    
    Return device

Process called "sys_MTLDeviceNewCommandQueue" that takes device as Integer returns Integer:
    Note: Create Metal command queue
    
    Let queue be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        Note: Call objc_msgSend with selector "newCommandQueue"
        "movq %1, %%rdi\n"             Note: device object
        "movq _sel_newCommandQueue(%%rip), %%rsi\n"
        "call _objc_msgSend\n"
        "movq %%rax, %0\n"             Note: Queue handle
        
        "popq %%rbp\n"
        
        : "=r" (queue)
        : "r" (device)
        : "rdi", "rsi", "rax", "memory"
    End Assembly
    
    Return queue

Process called "sys_MTLDeviceNewBuffer" that takes device as Integer, length as Integer, options as Integer returns Integer:
    Note: Create Metal GPU buffer
    
    Let buffer be 0
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        Note: Call objc_msgSend with selector "newBufferWithLength:options:"
        "movq %1, %%rdi\n"             Note: device object
        "movq %2, %%rdx\n"             Note: buffer length
        "movq %3, %%rcx\n"             Note: resource options
        "movq _sel_newBufferWithLength_options(%%rip), %%rsi\n"
        "call _objc_msgSend\n"
        "movq %%rax, %0\n"             Note: Buffer handle
        
        "popq %%rbp\n"
        
        : "=r" (buffer)
        : "r" (device), "r" (length), "r" (options)
        : "rdi", "rsi", "rdx", "rcx", "rax", "memory"
    End Assembly
    
    Return buffer

Process called "sys_MTLCommandBufferCommit" that takes command_buffer as Integer returns Nothing:
    Note: Commit Metal command buffer for execution
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        Note: Call objc_msgSend with selector "commit"
        "movq %0, %%rdi\n"             Note: command buffer object
        "movq _sel_commit(%%rip), %%rsi\n"
        "call _objc_msgSend\n"
        
        "popq %%rbp\n"
        
        :
        : "r" (command_buffer)
        : "rdi", "rsi", "rax", "memory"
    End Assembly

Note: =====================================================================
Note: LOCATION SERVICES
Note: =====================================================================

Process called "sys_CLLocationManagerRequestAuthorization" that takes manager as Integer, type as Integer returns Nothing:
    Note: Request location services authorization
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        Note: Call appropriate authorization method based on type
        "movq %0, %%rdi\n"             Note: manager object
        "movl %1, %%eax\n"             Note: authorization type
        "testl %%eax, %%eax\n"
        "jz 1f\n"                      Note: WhenInUse authorization
        
        Note: Always authorization
        "movq _sel_requestAlwaysAuthorization(%%rip), %%rsi\n"
        "jmp 2f\n"
        
        "1:\n"                          Note: WhenInUse authorization
        "movq _sel_requestWhenInUseAuthorization(%%rip), %%rsi\n"
        
        "2:\n"
        "call _objc_msgSend\n"
        
        "popq %%rbp\n"
        
        :
        : "r" (manager), "r" (type)
        : "rdi", "rsi", "rax", "memory"
    End Assembly

Process called "sys_CLLocationManagerStartUpdatingLocation" that takes manager as Integer returns Nothing:
    Note: Start continuous location updates
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        Note: Call objc_msgSend with selector "startUpdatingLocation"
        "movq %0, %%rdi\n"             Note: manager object
        "movq _sel_startUpdatingLocation(%%rip), %%rsi\n"
        "call _objc_msgSend\n"
        
        "popq %%rbp\n"
        
        :
        : "r" (manager)
        : "rdi", "rsi", "rax", "memory"
    End Assembly

Process called "sys_CLLocationManagerStopUpdatingLocation" that takes manager as Integer returns Nothing:
    Note: Stop continuous location updates
    
    Inline Assembly:
        "pushq %%rbp\n"
        "movq %%rsp, %%rbp\n"
        
        Note: Call objc_msgSend with selector "stopUpdatingLocation"
        "movq %0, %%rdi\n"             Note: manager object
        "movq _sel_stopUpdatingLocation(%%rip), %%rsi\n"
        "call _objc_msgSend\n"
        
        "popq %%rbp\n"
        
        :
        : "r" (manager)
        : "rdi", "rsi", "rax", "memory"
    End Assembly