Note:
runa/src/runatime/integration/system_interface/platform_syscalls/bsd/netbsd/memory_syscalls.runa
NetBSD Memory Management Syscalls

This module provides NetBSD-specific memory management syscall implementations,
including virtual memory operations and NetBSD-specific memory features.

Key features and capabilities:
- Memory mapping (mmap, munmap)
- Memory protection (mprotect)
- Memory locking (mlock, mlockall)
- Memory advisories (madvise)
- Shared memory
- Memory statistics
- Page cache control
- Zero-fill on demand
- UVM (Unified Virtual Memory) interface
- Memory barriers
- Swap management
- Anonymous memory
- Memory attributes
- NUMA support
- Memory debugging
:End Note

Import "../../../../../../../compiler/backend/syscalls/platforms/netbsd_x64" as NetBSDPlatform
Import "../../../../../../../compiler/backend/syscalls/platforms/platform_interface" as PlatformInterface
Import "../../../../../../../compiler/frontend/primitives/types/compiler_internals" as Internals

Note: ===== Basic Memory Mapping =====

Process called "sys_mmap" that takes addr as Pointer, len as Integer, prot as Integer, flags as Integer, fd as Integer, offset as Integer returns Pointer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mmap")
    Let result be Pointer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: preferred address (NULL for any)
        "mov rsi, %2\n"           Note: memory length
        "mov rdx, %3\n"           Note: memory protection flags
        "mov r10, %4\n"           Note: mapping flags
        "mov r8, %5\n"            Note: file descriptor
        "mov r9, %6\n"            Note: file offset
        "mov rax, %7\n"           Note: mmap syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (prot), "r" (flags), "r" (fd), "r" (offset), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_munmap" that takes addr as Pointer, len as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("munmap")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: memory address to unmap
        "mov rsi, %2\n"           Note: memory length
        "mov rax, %3\n"           Note: munmap syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_mprotect" that takes addr as Pointer, len as Integer, prot as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mprotect")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: memory address
        "mov rsi, %2\n"           Note: memory length
        "mov rdx, %3\n"           Note: new protection flags
        "mov rax, %4\n"           Note: mprotect syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (prot), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== Memory Locking =====

Process called "sys_mlock" that takes addr as Pointer, len as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mlock")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: memory address to lock
        "mov rsi, %2\n"           Note: memory length
        "mov rax, %3\n"           Note: mlock syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_munlock" that takes addr as Pointer, len as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("munlock")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: memory address to unlock
        "mov rsi, %2\n"           Note: memory length
        "mov rax, %3\n"           Note: munlock syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_mlockall" that takes flags as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mlockall")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: lock flags (current, future)
        "mov rax, %2\n"           Note: mlockall syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_munlockall" returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("munlockall")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"           Note: munlockall syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== Memory Advisories =====

Process called "sys_madvise" that takes addr as Pointer, len as Integer, advice as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("madvise")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: memory address
        "mov rsi, %2\n"           Note: memory length
        "mov rdx, %3\n"           Note: advice flags
        "mov rax, %4\n"           Note: madvise syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (advice), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_posix_madvise" that takes addr as Pointer, len as Integer, advice as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("posix_madvise")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: memory address
        "mov rsi, %2\n"           Note: memory length
        "mov rdx, %3\n"           Note: POSIX advice flags
        "mov rax, %4\n"           Note: posix_madvise syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (advice), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== Memory Synchronization =====

Process called "sys_msync" that takes addr as Pointer, len as Integer, flags as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("msync")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: memory address
        "mov rsi, %2\n"           Note: memory length
        "mov rdx, %3\n"           Note: sync flags
        "mov rax, %4\n"           Note: msync syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_mincore" that takes addr as Pointer, len as Integer, vec as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mincore")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: memory address
        "mov rsi, %2\n"           Note: memory length
        "mov rdx, %3\n"           Note: result vector
        "mov rax, %4\n"           Note: mincore syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (vec), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== NetBSD-Specific Memory Features =====

Process called "sys_uvm_mmap" that takes addr as Pointer, len as Integer, prot as Integer, flags as Integer, fd as Integer, offset as Integer returns Pointer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("uvm_mmap")
    Let result be Pointer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: preferred address
        "mov rsi, %2\n"           Note: memory length
        "mov rdx, %3\n"           Note: memory protection
        "mov r10, %4\n"           Note: UVM mapping flags
        "mov r8, %5\n"            Note: file descriptor
        "mov r9, %6\n"            Note: file offset
        "mov rax, %7\n"           Note: uvm_mmap syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (prot), "r" (flags), "r" (fd), "r" (offset), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_uvm_fault" that takes map as Pointer, va as Pointer, access_type as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("uvm_fault")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: VM map
        "mov rsi, %2\n"           Note: virtual address
        "mov rdx, %3\n"           Note: access type
        "mov rax, %4\n"           Note: uvm_fault syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (map), "r" (va), "r" (access_type), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_uvm_vslock" that takes addr as Pointer, len as Integer, access as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("uvm_vslock")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: memory address
        "mov rsi, %2\n"           Note: memory length
        "mov rdx, %3\n"           Note: access flags
        "mov rax, %4\n"           Note: uvm_vslock syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (access), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_uvm_vsunlock" that takes addr as Pointer, len as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("uvm_vsunlock")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: memory address
        "mov rsi, %2\n"           Note: memory length
        "mov rax, %3\n"           Note: uvm_vsunlock syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== Swap Management =====

Process called "sys_swapctl" that takes cmd as Integer, arg as Pointer, misc as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("swapctl")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: swap command
        "mov rsi, %2\n"           Note: command argument
        "mov rdx, %3\n"           Note: miscellaneous parameter
        "mov rax, %4\n"           Note: swapctl syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (cmd), "r" (arg), "r" (misc), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== Memory Statistics and Information =====

Process called "sys_getrusage" that takes who as Integer, usage as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("getrusage")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: resource target (SELF, CHILDREN)
        "mov rsi, %2\n"           Note: usage structure
        "mov rax, %3\n"           Note: getrusage syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (who), "r" (usage), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_vm_map_info" that takes addr as Pointer, info as Pointer, flags as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("vm_map_info")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: memory address
        "mov rsi, %2\n"           Note: info structure
        "mov rdx, %3\n"           Note: info flags
        "mov rax, %4\n"           Note: vm_map_info syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (info), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== Memory Barriers and Synchronization =====

Process called "sys_membar_consumer" returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("membar_consumer")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"           Note: membar_consumer syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_membar_producer" returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("membar_producer")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"           Note: membar_producer syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_membar_sync" returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("membar_sync")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"           Note: membar_sync syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== Anonymous Memory Management =====

Process called "sys_anon_map" that takes addr as Pointer, len as Integer, prot as Integer, flags as Integer returns Pointer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("anon_map")
    Let result be Pointer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: preferred address
        "mov rsi, %2\n"           Note: memory length
        "mov rdx, %3\n"           Note: memory protection
        "mov r10, %4\n"           Note: anonymous mapping flags
        "mov rax, %5\n"           Note: anon_map syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (len), "r" (prot), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== NUMA Memory Management =====

Process called "sys_numa_getaffinity" that takes which as Integer, id as Integer, mask as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("numa_getaffinity")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: affinity target type
        "mov rsi, %2\n"           Note: target ID
        "mov rdx, %3\n"           Note: affinity mask
        "mov rax, %4\n"           Note: numa_getaffinity syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (which), "r" (id), "r" (mask), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_numa_setaffinity" that takes which as Integer, id as Integer, mask as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("numa_setaffinity")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: affinity target type
        "mov rsi, %2\n"           Note: target ID
        "mov rdx, %3\n"           Note: affinity mask
        "mov rax, %4\n"           Note: numa_setaffinity syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (which), "r" (id), "r" (mask), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== Memory Debugging and Profiling =====

Process called "sys_ktrace_mem" that takes pid as Integer, ops as Integer, facs as Integer, file as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("ktrace_mem")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: process ID
        "mov rsi, %2\n"           Note: trace operations
        "mov rdx, %3\n"           Note: trace facilities
        "mov r10, %4\n"           Note: trace file
        "mov rax, %5\n"           Note: ktrace_mem syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pid), "r" (ops), "r" (facs), "r" (file), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process