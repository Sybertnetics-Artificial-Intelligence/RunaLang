Note:
runa/src/runatime/integration/system_interface/platform_syscalls/bsd/freebsd/extended_syscalls.runa
FreeBSD Extended Syscalls

This module provides FreeBSD-specific extended syscall implementations,
including modern FreeBSD features and specialized system operations.

Key features and capabilities:
- DTrace support
- Bhyve virtualization
- GEOM framework
- ZFS operations
- Netgraph operations
- Sound system (OSS)
- USB operations
- Power management
- Hardware monitoring (SMBus)
- Kernel modules (kld)
- System control (sysctl)
- Kernel events
- Procfs operations
- Devfs operations
- Performance monitoring
:End Note

Import "../../../../../../../compiler/backend/syscalls/platforms/freebsd_x64" as FreeBSDPlatform
Import "../../../../../../../compiler/backend/syscalls/platforms/platform_interface" as PlatformInterface

Note: System control (sysctl) operations

Process called "sys_sysctl" that takes
    mib as Pointer,
    miblen as Integer,
    old as Pointer,
    oldlenp as Pointer,
    new as Pointer,
    newlen as Integer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("__sysctl")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: MIB array pointer
        "mov rsi, %2\n"              Note: MIB length
        "mov rdx, %3\n"              Note: Old value buffer
        "mov r10, %4\n"              Note: Old value length pointer
        "mov r8, %5\n"               Note: New value buffer
        "mov r9, %6\n"               Note: New value length
        "mov rax, %7\n"              Note: __sysctl syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (mib), "r" (miblen), "r" (old), "r" (oldlenp), "r" (new), "r" (newlen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_sysctlbyname" that takes
    name as Pointer,
    old as Pointer,
    oldlenp as Pointer,
    new as Pointer,
    newlen as Integer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("__sysctlbyname")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Name string pointer
        "mov rsi, %2\n"              Note: Old value buffer
        "mov rdx, %3\n"              Note: Old value length pointer
        "mov r10, %4\n"              Note: New value buffer
        "mov r8, %5\n"               Note: New value length
        "mov rax, %6\n"              Note: __sysctlbyname syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (name), "r" (old), "r" (oldlenp), "r" (new), "r" (newlen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Kernel module operations (kld)

Process called "sys_kldload" that takes pathname as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("kldload")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Module pathname
        "mov rax, %2\n"              Note: kldload syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pathname), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_kldunload" that takes fileid as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("kldunload")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Module file ID
        "mov rax, %2\n"              Note: kldunload syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (fileid), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_kldfind" that takes pathname as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("kldfind")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Module pathname
        "mov rax, %2\n"              Note: kldfind syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pathname), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_kldstat" that takes fileid as Integer, stat as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("kldstat")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Module file ID
        "mov rsi, %2\n"              Note: Stat buffer pointer
        "mov rax, %3\n"              Note: kldstat syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (fileid), "r" (stat), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Kernel event notification (kqueue/kevent)

Process called "sys_kqueue" returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("kqueue")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"              Note: kqueue syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (syscall_num)
        : "rax", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_kevent" that takes
    kq as Integer,
    changelist as Pointer,
    nchanges as Integer,
    eventlist as Pointer,
    nevents as Integer,
    timeout as Pointer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("kevent")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Kqueue descriptor
        "mov rsi, %2\n"              Note: Change list pointer
        "mov rdx, %3\n"              Note: Number of changes
        "mov r10, %4\n"              Note: Event list pointer
        "mov r8, %5\n"               Note: Number of events
        "mov r9, %6\n"               Note: Timeout specification
        "mov rax, %7\n"              Note: kevent syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (kq), "r" (changelist), "r" (nchanges), "r" (eventlist), "r" (nevents), "r" (timeout), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: GEOM framework operations

Process called "sys_geom_ctl" that takes req as Pointer, len as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("geom_ctl")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Request structure pointer
        "mov rsi, %2\n"              Note: Request length
        "mov rax, %3\n"              Note: geom_ctl syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (req), "r" (len), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ZFS operations via ioctl

Process called "sys_zfs_ioctl" that takes
    fd as Integer,
    request as Integer,
    arg as Pointer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("ioctl")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: File descriptor
        "mov rsi, %2\n"              Note: ZFS ioctl request code
        "mov rdx, %3\n"              Note: Argument pointer
        "mov rax, %4\n"              Note: ioctl syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (fd), "r" (request), "r" (arg), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Netgraph operations

Process called "sys_ngsocket" that takes domain as Integer, type as Integer, protocol as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("socket")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Domain (AF_NETGRAPH)
        "mov rsi, %2\n"              Note: Socket type
        "mov rdx, %3\n"              Note: Protocol
        "mov rax, %4\n"              Note: socket syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (domain), "r" (type), "r" (protocol), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_ngctl" that takes cmd as Pointer, cmdlen as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("ngctl")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Command structure pointer
        "mov rsi, %2\n"              Note: Command length
        "mov rax, %3\n"              Note: ngctl syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (cmd), "r" (cmdlen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Jail operations

Process called "sys_jail" that takes jail_params as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("jail")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Jail parameters structure
        "mov rax, %2\n"              Note: jail syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (jail_params), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_jail_attach" that takes jid as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("jail_attach")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Jail ID
        "mov rax, %2\n"              Note: jail_attach syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (jid), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_jail_remove" that takes jid as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("jail_remove")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Jail ID
        "mov rax, %2\n"              Note: jail_remove syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (jid), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_jail_get" that takes
    iov as Pointer,
    niov as Integer,
    flags as Integer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("jail_get")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: IO vector array
        "mov rsi, %2\n"              Note: Number of vectors
        "mov rdx, %3\n"              Note: Flags
        "mov rax, %4\n"              Note: jail_get syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (iov), "r" (niov), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_jail_set" that takes
    iov as Pointer,
    niov as Integer,
    flags as Integer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("jail_set")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: IO vector array
        "mov rsi, %2\n"              Note: Number of vectors
        "mov rdx, %3\n"              Note: Flags
        "mov rax, %4\n"              Note: jail_set syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (iov), "r" (niov), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Performance monitoring

Process called "sys_pmc_allocate" that takes
    pmc_spec as Pointer,
    mode as Integer,
    flags as Integer,
    cpu as Integer,
    pmc_id as Pointer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("pmc_allocate")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: PMC specification
        "mov rsi, %2\n"              Note: Mode
        "mov rdx, %3\n"              Note: Flags
        "mov r10, %4\n"              Note: CPU
        "mov r8, %5\n"               Note: PMC ID output
        "mov rax, %6\n"              Note: pmc_allocate syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pmc_spec), "r" (mode), "r" (flags), "r" (cpu), "r" (pmc_id), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_pmc_release" that takes pmc_id as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("pmc_release")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: PMC ID
        "mov rax, %2\n"              Note: pmc_release syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pmc_id), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: CPU affinity and scheduling

Process called "sys_cpuset" that takes setid as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("cpuset")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: CPU set ID pointer
        "mov rax, %2\n"              Note: cpuset syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (setid), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_cpuset_setaffinity" that takes
    level as Integer,
    which as Integer,
    id as Integer,
    cpusetsize as Integer,
    mask as Pointer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("cpuset_setaffinity")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Level
        "mov rsi, %2\n"              Note: Which
        "mov rdx, %3\n"              Note: ID
        "mov r10, %4\n"              Note: CPU set size
        "mov r8, %5\n"               Note: CPU mask
        "mov rax, %6\n"              Note: cpuset_setaffinity syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (level), "r" (which), "r" (id), "r" (cpusetsize), "r" (mask), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_cpuset_getaffinity" that takes
    level as Integer,
    which as Integer,
    id as Integer,
    cpusetsize as Integer,
    mask as Pointer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("cpuset_getaffinity")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Level
        "mov rsi, %2\n"              Note: Which
        "mov rdx, %3\n"              Note: ID
        "mov r10, %4\n"              Note: CPU set size
        "mov r8, %5\n"               Note: CPU mask output
        "mov rax, %6\n"              Note: cpuset_getaffinity syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (level), "r" (which), "r" (id), "r" (cpusetsize), "r" (mask), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ACL (Access Control List) operations

Process called "sys_acl_get_file" that takes
    path as Pointer,
    acl_type as Integer,
    acl as Pointer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("__acl_get_file")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: File path
        "mov rsi, %2\n"              Note: ACL type
        "mov rdx, %3\n"              Note: ACL buffer
        "mov rax, %4\n"              Note: __acl_get_file syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (path), "r" (acl_type), "r" (acl), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_acl_set_file" that takes
    path as Pointer,
    acl_type as Integer,
    acl as Pointer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("__acl_set_file")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: File path
        "mov rsi, %2\n"              Note: ACL type
        "mov rdx, %3\n"              Note: ACL buffer
        "mov rax, %4\n"              Note: __acl_set_file syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (path), "r" (acl_type), "r" (acl), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Audit subsystem operations

Process called "sys_audit" that takes record as Pointer, length as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("audit")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Audit record buffer
        "mov rsi, %2\n"              Note: Record length
        "mov rax, %3\n"              Note: audit syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (record), "r" (length), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_auditon" that takes
    cmd as Integer,
    data as Pointer,
    length as Integer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("auditon")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Audit command
        "mov rsi, %2\n"              Note: Data buffer
        "mov rdx, %3\n"              Note: Data length
        "mov rax, %4\n"              Note: auditon syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (cmd), "r" (data), "r" (length), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Resource limits and accounting

Process called "sys_rctl_get_racct" that takes
    inbuf as Pointer,
    inbuflen as Integer,
    outbuf as Pointer,
    outbuflen as Integer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("rctl_get_racct")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Input buffer
        "mov rsi, %2\n"              Note: Input buffer length
        "mov rdx, %3\n"              Note: Output buffer
        "mov r10, %4\n"              Note: Output buffer length
        "mov rax, %5\n"              Note: rctl_get_racct syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (inbuf), "r" (inbuflen), "r" (outbuf), "r" (outbuflen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_rctl_add_rule" that takes
    inbuf as Pointer,
    inbuflen as Integer,
    outbuf as Pointer,
    outbuflen as Integer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("rctl_add_rule")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Rule specification
        "mov rsi, %2\n"              Note: Input length
        "mov rdx, %3\n"              Note: Output buffer
        "mov r10, %4\n"              Note: Output length
        "mov rax, %5\n"              Note: rctl_add_rule syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (inbuf), "r" (inbuflen), "r" (outbuf), "r" (outbuflen), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: MAC (Mandatory Access Control) framework

Process called "sys_mac_get_file" that takes path as Pointer, mac as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("__mac_get_file")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: File path
        "mov rsi, %2\n"              Note: MAC label buffer
        "mov rax, %3\n"              Note: __mac_get_file syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (path), "r" (mac), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_mac_set_file" that takes path as Pointer, mac as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("__mac_set_file")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: File path
        "mov rsi, %2\n"              Note: MAC label buffer
        "mov rax, %3\n"              Note: __mac_set_file syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (path), "r" (mac), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Process tracing (ptrace extensions)

Process called "sys_ptrace_lwpinfo" that takes
    pid as Integer,
    lwpinfo as Pointer,
    size as Integer returns Integer:
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("ptrace")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"              Note: Process ID
        "mov rsi, %2\n"              Note: LWP info structure
        "mov rdx, %3\n"              Note: Structure size
        "mov r10, 13\n"              Note: PT_LWPINFO request
        "mov rax, %4\n"              Note: ptrace syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pid), "r" (lwpinfo), "r" (size), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Utility helper functions

Process called "create_kevent" that takes
    ident as Integer,
    filter as Integer,
    flags as Integer,
    fflags as Integer,
    data as Integer,
    udata as Pointer,
    out_event as Pointer returns Nothing:
    
    Note: Create a kevent structure
    Note: FreeBSD kevent structure layout (64 bytes):
    Note:   ident  (8 bytes at offset 0)
    Note:   filter (2 bytes at offset 8)
    Note:   flags  (2 bytes at offset 10)
    Note:   fflags (4 bytes at offset 12)
    Note:   data   (8 bytes at offset 16)
    Note:   udata  (8 bytes at offset 24)
    
    Let event_ptr be Pointer is out_event
    
    Note: Store ident
    Inline Assembly:
        "mov rax, %0\n"
        "mov rdi, %1\n"
        "mov [rdi], rax\n"
        :
        : "r" (ident), "r" (event_ptr)
        : "rax", "rdi", "memory"
    End Assembly
    
    Note: Store filter
    Let filter_offset be Pointer is event_ptr + 8
    Inline Assembly:
        "mov ax, %0\n"
        "mov rdi, %1\n"
        "mov [rdi], ax\n"
        :
        : "r" (filter), "r" (filter_offset)
        : "rax", "rdi", "memory"
    End Assembly
    
    Note: Store flags
    Let flags_offset be Pointer is event_ptr + 10
    Inline Assembly:
        "mov ax, %0\n"
        "mov rdi, %1\n"
        "mov [rdi], ax\n"
        :
        : "r" (flags), "r" (flags_offset)
        : "rax", "rdi", "memory"
    End Assembly
    
    Note: Store fflags
    Let fflags_offset be Pointer is event_ptr + 12
    Inline Assembly:
        "mov eax, %0\n"
        "mov rdi, %1\n"
        "mov [rdi], eax\n"
        :
        : "r" (fflags), "r" (fflags_offset)
        : "rax", "rdi", "memory"
    End Assembly
    
    Note: Store data
    Let data_offset be Pointer is event_ptr + 16
    Inline Assembly:
        "mov rax, %0\n"
        "mov rdi, %1\n"
        "mov [rdi], rax\n"
        :
        : "r" (data), "r" (data_offset)
        : "rax", "rdi", "memory"
    End Assembly
    
    Note: Store udata
    Let udata_offset be Pointer is event_ptr + 24
    Inline Assembly:
        "mov rax, %0\n"
        "mov rdi, %1\n"
        "mov [rdi], rax\n"
        :
        : "r" (udata), "r" (udata_offset)
        : "rax", "rdi", "memory"
    End Assembly
End Process

Process called "get_sysctl_value" that takes
    name as String,
    value_buf as Pointer,
    value_size as Pointer returns Integer:
    
    Note: Convert string name to MIB array
    Let mib_buf be Array[6] of Integer
    Let mib_len be Integer is 6
    
    Note: Use sysctlnametomib to convert name to MIB
    Let name_ptr be Pointer is name
    Let mib_ptr be Pointer is mib_buf
    Let mib_len_ptr be Pointer is mib_len
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("sysctlnametomib")
    Let convert_result be Integer
    Inline Assembly:
        "mov rdi, %1\n"              Note: Name string
        "mov rsi, %2\n"              Note: MIB buffer
        "mov rdx, %3\n"              Note: MIB length pointer
        "mov rax, %4\n"              Note: sysctlnametomib syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (convert_result)
        : "r" (name_ptr), "r" (mib_ptr), "r" (mib_len_ptr), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    If convert_result < 0:
        Return convert_result
    End If
    
    Note: Now call sysctl with the MIB
    Return sys_sysctl(mib_ptr, mib_len, value_buf, value_size, null, 0)
End Process
