Note:
runa/src/runatime/integration/system_interface/platform_syscalls/bsd/freebsd/capsicum_syscalls.runa
FreeBSD Capsicum Capability Syscalls

This module provides FreeBSD-specific Capsicum syscall implementations,
including capability-based security and sandboxing features.

Key features and capabilities:
- Capability mode enforcement
- File descriptor capabilities
- Rights limiting
- Capability rights
- Process sandboxing
- Ambient authority removal
- Fine-grained permissions
- Capability unwrapping
- Rights inheritance
- Casper services
:End Note

@Reasoning
Capsicum is FreeBSD's capability-based security framework that provides fine-grained
sandboxing at the file descriptor level. Once a process enters capability mode,
it loses ambient authority and can only interact with resources through
capabilities (file descriptors with specific rights).
@End Reasoning

@Implementation
This module provides direct syscall access to Capsicum features using inline
assembly for x86_64 FreeBSD. Each function maps to the corresponding FreeBSD
syscall with proper register allocation following the System V AMD64 ABI.
@End Implementation

@Performance_Hints
Capsicum operations have minimal overhead once in capability mode. The primary
cost is during capability creation and rights checking. Cache capabilities
when possible to avoid repeated rights operations.
@End Performance_Hints

@Security_Scope
These syscalls form the foundation of FreeBSD's sandboxing. Capability mode
is irreversible within a process - once entered, it cannot be exited. Always
test capability rights before entering capability mode.
@End Security_Scope

Import "../../../../../../../compiler/frontend/primitives/types/compiler_internals" as Internals
Import "../../../../../../../compiler/backend/syscalls/platforms/freebsd_x64" as FreeBSDPlatform
Import "../../../../../../../compiler/backend/syscalls/platforms/platform_interface" as PlatformInterface

Note: ===== Capability Rights Structure =====

Type called "CapRights":
    cr_rights as Internals.InternalArray    Note: Array of 64-bit rights values
    version as Integer                      Note: Rights version number
End Type

Type called "CapIOCTLs":
    cmds as Internals.InternalArray         Note: Allowed ioctl commands
    ncmds as Integer                        Note: Number of commands
End Type

Type called "CapFCNTLs":
    fcntls as Integer                       Note: Allowed fcntl commands bitmask
End Type

Note: ===== Core Capsicum Syscalls =====

Process called "sys_cap_enter" returns Integer:
    @Implementation
    Enters capability mode for the current process. This is irreversible -
    once in capability mode, the process cannot regain ambient authority.
    Returns 0 on success or negative error code.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("cap_enter")
    Let result be Integer
    
    Inline Assembly:
        "mov rax, %1\n"          Note: cap_enter syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(syscall_num)
        : "rax", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_cap_getmode" that takes modep as Integer returns Integer:
    @Implementation
    Gets the current capability mode status. Writes 1 to modep if in
    capability mode, 0 otherwise. Returns 0 on success or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("cap_getmode")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: modep pointer
        "mov rax, %2\n"           Note: cap_getmode syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(modep), "r"(syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== Capability Rights Management =====

Process called "sys_cap_rights_limit" that takes fd as Integer, rights as Integer returns Integer:
    @Implementation
    Limits the rights on a file descriptor, converting it to a capability.
    Once limited, rights can only be reduced, never expanded.
    Returns 0 on success or negative error code.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("cap_rights_limit")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: file descriptor
        "mov rsi, %2\n"           Note: rights structure pointer
        "mov rax, %3\n"           Note: cap_rights_limit syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(fd), "r"(rights), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_cap_rights_get" that takes fd as Integer, rights as Integer returns Integer:
    @Implementation
    Gets the current rights associated with a file descriptor capability.
    Returns 0 on success or negative error code.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("__cap_rights_get")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: file descriptor
        "mov rsi, %2\n"           Note: rights structure pointer
        "mov rax, %3\n"           Note: __cap_rights_get syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(fd), "r"(rights), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== IOCTL and FCNTL Limiting =====

Process called "sys_cap_ioctls_limit" that takes fd as Integer, cmds as Integer, ncmds as Integer returns Integer:
    @Implementation
    Limits the ioctl commands that can be used with a file descriptor capability.
    Pass NULL cmds to allow only generic ioctls.
    Returns 0 on success or negative error code.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("cap_ioctls_limit")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: file descriptor
        "mov rsi, %2\n"           Note: ioctl commands array
        "mov rdx, %3\n"           Note: number of commands
        "mov rax, %4\n"           Note: cap_ioctls_limit syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(fd), "r"(cmds), "r"(ncmds), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_cap_ioctls_get" that takes fd as Integer, cmds as Integer, maxcmds as Integer returns Integer:
    @Implementation
    Gets the list of allowed ioctl commands for a capability.
    Returns the number of commands or negative error code.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("cap_ioctls_get")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: file descriptor
        "mov rsi, %2\n"           Note: buffer for commands
        "mov rdx, %3\n"           Note: buffer size
        "mov rax, %4\n"           Note: cap_ioctls_get syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(fd), "r"(cmds), "r"(maxcmds), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_cap_fcntls_limit" that takes fd as Integer, fcntlrights as Integer returns Integer:
    @Implementation
    Limits the fcntl commands that can be used with a file descriptor capability.
    The fcntlrights parameter is a bitmask of allowed fcntl commands.
    Returns 0 on success or negative error code.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("cap_fcntls_limit")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: file descriptor
        "mov rsi, %2\n"           Note: fcntl rights bitmask
        "mov rax, %3\n"           Note: cap_fcntls_limit syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(fd), "r"(fcntlrights), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_cap_fcntls_get" that takes fd as Integer, fcntlrightsp as Integer returns Integer:
    @Implementation
    Gets the fcntl commands allowed for a capability.
    Returns 0 on success or negative error code.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("cap_fcntls_get")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: file descriptor
        "mov rsi, %2\n"           Note: pointer to store rights
        "mov rax, %3\n"           Note: cap_fcntls_get syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(fd), "r"(fcntlrightsp), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== Process Descriptor Capabilities =====

Process called "sys_pdfork" that takes fdp as Integer, flags as Integer returns Integer:
    @Implementation
    Creates a new process with a process descriptor instead of a PID.
    The process descriptor can be used with capability rights.
    Returns 0 in child, PID in parent, or negative error.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("pdfork")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: pointer to store fd
        "mov rsi, %2\n"           Note: flags
        "mov rax, %3\n"           Note: pdfork syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(fdp), "r"(flags), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_pdgetpid" that takes fd as Integer, pidp as Integer returns Integer:
    @Implementation
    Gets the PID associated with a process descriptor.
    Returns 0 on success or negative error code.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("pdgetpid")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: process descriptor
        "mov rsi, %2\n"           Note: pointer to store PID
        "mov rax, %3\n"           Note: pdgetpid syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(fd), "r"(pidp), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_pdkill" that takes fd as Integer, signum as Integer returns Integer:
    @Implementation
    Sends a signal to a process via its process descriptor.
    Works like kill(2) but uses a process descriptor instead of PID.
    Returns 0 on success or negative error code.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("pdkill")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: process descriptor
        "mov rsi, %2\n"           Note: signal number
        "mov rax, %3\n"           Note: pdkill syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(fd), "r"(signum), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== Extended Capability Operations =====

Process called "sys_bindat" that takes fd as Integer, s as Integer, name as Integer, namelen as Integer returns Integer:
    @Implementation
    Binds a socket relative to a directory descriptor.
    Allows binding in capability mode when directory fd has appropriate rights.
    Returns 0 on success or negative error code.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("bindat")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: directory descriptor
        "mov rsi, %2\n"           Note: socket descriptor
        "mov rdx, %3\n"           Note: socket name
        "mov r10, %4\n"           Note: name length
        "mov rax, %5\n"           Note: bindat syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(fd), "r"(s), "r"(name), "r"(namelen), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "sys_connectat" that takes fd as Integer, s as Integer, name as Integer, namelen as Integer returns Integer:
    @Implementation
    Connects a socket relative to a directory descriptor.
    Allows connecting in capability mode when directory fd has appropriate rights.
    Returns 0 on success or negative error code.
    @End Implementation
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("connectat")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: directory descriptor
        "mov rsi, %2\n"           Note: socket descriptor
        "mov rdx, %3\n"           Note: socket name
        "mov r10, %4\n"           Note: name length
        "mov rax, %5\n"           Note: connectat syscall number from registry
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(fd), "r"(s), "r"(name), "r"(namelen), "r"(syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: ===== Capability Rights Helper Functions =====

Process called "cap_rights_init" that takes rights as CapRights returns Nothing:
    @Implementation
    Initializes a capability rights structure to empty.
    Must be called before setting specific rights.
    @End Implementation
    
    Set rights.version to 0
    Set rights.cr_rights to Internals.create_internal_array(2)
    Internals.array_set(rights.cr_rights, 0, 0)
    Internals.array_set(rights.cr_rights, 1, 0)
End Process

Process called "cap_rights_set_read" that takes rights as CapRights returns Nothing:
    @Implementation
    Adds read permission to capability rights.
    @End Implementation
    
    Let current be Internals.array_get(rights.cr_rights, 0)
    Internals.array_set(rights.cr_rights, 0, current or 0x0000000000000001)
End Process

Process called "cap_rights_set_write" that takes rights as CapRights returns Nothing:
    @Implementation
    Adds write permission to capability rights.
    @End Implementation
    
    Let current be Internals.array_get(rights.cr_rights, 0)
    Internals.array_set(rights.cr_rights, 0, current or 0x0000000000000002)
End Process

Process called "cap_rights_set_seek" that takes rights as CapRights returns Nothing:
    @Implementation
    Adds seek permission to capability rights.
    @End Implementation
    
    Let current be Internals.array_get(rights.cr_rights, 0)
    Internals.array_set(rights.cr_rights, 0, current or 0x0000000000000008)
End Process

Process called "cap_rights_set_ioctl" that takes rights as CapRights returns Nothing:
    @Implementation
    Adds ioctl permission to capability rights.
    @End Implementation
    
    Let current be Internals.array_get(rights.cr_rights, 0)
    Internals.array_set(rights.cr_rights, 0, current or 0x0000000000000080)
End Process

Process called "cap_rights_set_fcntl" that takes rights as CapRights returns Nothing:
    @Implementation
    Adds fcntl permission to capability rights.
    @End Implementation
    
    Let current be Internals.array_get(rights.cr_rights, 0)
    Internals.array_set(rights.cr_rights, 0, current or 0x0000000000000100)
End Process

Process called "cap_rights_set_mmap" that takes rights as CapRights returns Nothing:
    @Implementation
    Adds mmap permission to capability rights.
    @End Implementation
    
    Let current be Internals.array_get(rights.cr_rights, 0)
    Internals.array_set(rights.cr_rights, 0, current or 0x0000000000000010)
End Process

Process called "cap_rights_set_accept" that takes rights as CapRights returns Nothing:
    @Implementation
    Adds accept permission for sockets to capability rights.
    @End Implementation
    
    Let current be Internals.array_get(rights.cr_rights, 0)
    Internals.array_set(rights.cr_rights, 0, current or 0x0000000020000000)
End Process

Process called "cap_rights_set_bind" that takes rights as CapRights returns Nothing:
    @Implementation
    Adds bind permission for sockets to capability rights.
    @End Implementation
    
    Let current be Internals.array_get(rights.cr_rights, 0)
    Internals.array_set(rights.cr_rights, 0, current or 0x0000000040000000)
End Process

Process called "cap_rights_set_connect" that takes rights as CapRights returns Nothing:
    @Implementation
    Adds connect permission for sockets to capability rights.
    @End Implementation
    
    Let current be Internals.array_get(rights.cr_rights, 0)
    Internals.array_set(rights.cr_rights, 0, current or 0x0000000080000000)
End Process

Process called "cap_rights_set_listen" that takes rights as CapRights returns Nothing:
    @Implementation
    Adds listen permission for sockets to capability rights.
    @End Implementation
    
    Let current be Internals.array_get(rights.cr_rights, 0)
    Internals.array_set(rights.cr_rights, 0, current or 0x0000000100000000)
End Process

Note: ===== Utility Functions =====

Process called "is_in_capability_mode" returns Boolean:
    @Implementation
    Checks if the current process is in capability mode.
    Returns true if in capability mode, false otherwise.
    @End Implementation
    
    Let mode_value be Internals.allocate_raw_memory(8)
    Let result be sys_cap_getmode(mode_value)
    
    If result less_than 0:
        Internals.free_raw_memory(mode_value)
        Return false
    End If
    
    Let mode be Internals.read_32bit_at(mode_value, 0)
    Internals.free_raw_memory(mode_value)
    
    Return mode equals 1
End Process

Process called "limit_stdio_capabilities" returns Boolean:
    @Implementation
    Limits standard I/O file descriptors to basic read/write capabilities.
    Useful for sandboxing before entering capability mode.
    Returns true on success, false on error.
    @End Implementation
    
    Let rights be new CapRights
    
    Note: stdin - read only
    cap_rights_init(rights)
    cap_rights_set_read(rights)
    cap_rights_set_seek(rights)
    Let stdin_result be sys_cap_rights_limit(0, Internals.get_address(rights))
    If stdin_result less_than 0:
        Return false
    End If
    
    Note: stdout - write only
    cap_rights_init(rights)
    cap_rights_set_write(rights)
    Let stdout_result be sys_cap_rights_limit(1, Internals.get_address(rights))
    If stdout_result less_than 0:
        Return false
    End If
    
    Note: stderr - write only
    cap_rights_init(rights)
    cap_rights_set_write(rights)
    Let stderr_result be sys_cap_rights_limit(2, Internals.get_address(rights))
    If stderr_result less_than 0:
        Return false
    End If
    
    Return true
End Process