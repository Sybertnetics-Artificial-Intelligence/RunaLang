Note:
runa/src/runatime/integration/system_interface/platform_syscalls/bsd/openbsd/ipc_syscalls.runa
OpenBSD Inter-Process Communication Syscalls

This module provides OpenBSD-specific IPC syscall implementations,
including shared memory, message queues, and OpenBSD-specific IPC features.

Key features and capabilities:
- Shared memory (shmget, shmat)
- Message queues (msgget, msgsnd)
- Semaphores (semget, semop)
- Pipes and FIFOs
- Unix domain sockets
- Memory-mapped files
- Anonymous shared memory
- IPC permissions
- IPC limits
- IPC statistics
- Pledge-aware IPC
- Secure IPC operations
- IPC namespaces
- Process synchronization
- IPC cleanup
:End Note

Import "../../../../../../../compiler/backend/syscalls/platforms/openbsd_x64" as OpenBSDPlatform
Import "../../../../../../../compiler/backend/syscalls/platforms/platform_interface" as PlatformInterface
Import "../../../../../../../compiler/frontend/primitives/types/compiler_internals" as Internals

Note: OpenBSD IPC syscalls implementation using dynamic syscall registry :End Note

Note: Pipe operations :End Note
Process called "pipe" that takes pipefd as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("pipe")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: pipe file descriptor array :End Note
        "mov rax, %2\n"           Note: pipe syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pipefd), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "pipe2" that takes pipefd as Pointer, flags as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("pipe2")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: pipe file descriptor array :End Note
        "mov rsi, %2\n"           Note: pipe flags :End Note
        "mov rax, %3\n"           Note: pipe2 syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (pipefd), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Shared memory operations :End Note
Process called "shmget" that takes key as Integer, size as Integer, shmflg as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shmget")
    Let result be Integer
    
    Inline Assembly:
        "mov edi, %1\n"           Note: IPC key :End Note
        "mov rsi, %2\n"           Note: segment size :End Note
        "mov rdx, %3\n"           Note: flags :End Note
        "mov rax, %4\n"           Note: shmget syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (key), "r" (size), "r" (shmflg), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "shmat" that takes shmid as Integer, shmaddr as Pointer, shmflg as Integer returns Pointer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shmat")
    Let result be Pointer
    
    Inline Assembly:
        "mov edi, %1\n"           Note: shared memory ID :End Note
        "mov rsi, %2\n"           Note: attach address :End Note
        "mov rdx, %3\n"           Note: flags :End Note
        "mov rax, %4\n"           Note: shmat syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (shmid), "r" (shmaddr), "r" (shmflg), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "shmdt" that takes shmaddr as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shmdt")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: shared memory address :End Note
        "mov rax, %2\n"           Note: shmdt syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (shmaddr), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "shmctl" that takes shmid as Integer, cmd as Integer, buf as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shmctl")
    Let result be Integer
    
    Inline Assembly:
        "mov edi, %1\n"           Note: shared memory ID :End Note
        "mov esi, %2\n"           Note: control command :End Note
        "mov rdx, %3\n"           Note: shmid_ds buffer :End Note
        "mov rax, %4\n"           Note: shmctl syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (shmid), "r" (cmd), "r" (buf), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Message queue operations :End Note
Process called "msgget" that takes key as Integer, msgflg as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("msgget")
    Let result be Integer
    
    Inline Assembly:
        "mov edi, %1\n"           Note: IPC key :End Note
        "mov esi, %2\n"           Note: message queue flags :End Note
        "mov rax, %3\n"           Note: msgget syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (key), "r" (msgflg), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "msgsnd" that takes msqid as Integer, msgp as Pointer, msgsz as Integer, msgflg as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("msgsnd")
    Let result be Integer
    
    Inline Assembly:
        "mov edi, %1\n"           Note: message queue ID :End Note
        "mov rsi, %2\n"           Note: message buffer :End Note
        "mov rdx, %3\n"           Note: message size :End Note
        "mov r10, %4\n"           Note: flags :End Note
        "mov rax, %5\n"           Note: msgsnd syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (msqid), "r" (msgp), "r" (msgsz), "r" (msgflg), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "msgrcv" that takes msqid as Integer, msgp as Pointer, msgsz as Integer, msgtyp as Integer, msgflg as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("msgrcv")
    Let result be Integer
    
    Inline Assembly:
        "mov edi, %1\n"           Note: message queue ID :End Note
        "mov rsi, %2\n"           Note: message buffer :End Note
        "mov rdx, %3\n"           Note: max message size :End Note
        "mov r10, %4\n"           Note: message type :End Note
        "mov r8, %5\n"            Note: flags :End Note
        "mov rax, %6\n"           Note: msgrcv syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (msqid), "r" (msgp), "r" (msgsz), "r" (msgtyp), "r" (msgflg), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "msgctl" that takes msqid as Integer, cmd as Integer, buf as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("msgctl")
    Let result be Integer
    
    Inline Assembly:
        "mov edi, %1\n"           Note: message queue ID :End Note
        "mov esi, %2\n"           Note: control command :End Note
        "mov rdx, %3\n"           Note: msqid_ds buffer :End Note
        "mov rax, %4\n"           Note: msgctl syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (msqid), "r" (cmd), "r" (buf), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Semaphore operations :End Note
Process called "semget" that takes key as Integer, nsems as Integer, semflg as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("semget")
    Let result be Integer
    
    Inline Assembly:
        "mov edi, %1\n"           Note: IPC key :End Note
        "mov esi, %2\n"           Note: number of semaphores :End Note
        "mov rdx, %3\n"           Note: flags :End Note
        "mov rax, %4\n"           Note: semget syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (key), "r" (nsems), "r" (semflg), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "semop" that takes semid as Integer, sops as Pointer, nsops as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("semop")
    Let result be Integer
    
    Inline Assembly:
        "mov edi, %1\n"           Note: semaphore set ID :End Note
        "mov rsi, %2\n"           Note: sembuf operations array :End Note
        "mov rdx, %3\n"           Note: number of operations :End Note
        "mov rax, %4\n"           Note: semop syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (semid), "r" (sops), "r" (nsops), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "semctl" that takes semid as Integer, semnum as Integer, cmd as Integer, arg as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("semctl")
    Let result be Integer
    
    Inline Assembly:
        "mov edi, %1\n"           Note: semaphore set ID :End Note
        "mov esi, %2\n"           Note: semaphore number :End Note
        "mov rdx, %3\n"           Note: control command :End Note
        "mov r10, %4\n"           Note: union semun argument :End Note
        "mov rax, %5\n"           Note: semctl syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (semid), "r" (semnum), "r" (cmd), "r" (arg), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Memory mapping operations :End Note
Process called "mmap" that takes addr as Pointer, length as Integer, prot as Integer, flags as Integer, fd as Integer, offset as Integer returns Pointer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mmap")
    Let result be Pointer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: preferred address :End Note
        "mov rsi, %2\n"           Note: mapping length :End Note
        "mov rdx, %3\n"           Note: protection flags :End Note
        "mov r10, %4\n"           Note: mapping flags :End Note
        "mov r8, %5\n"            Note: file descriptor :End Note
        "mov r9, %6\n"            Note: file offset :End Note
        "mov rax, %7\n"           Note: mmap syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (length), "r" (prot), "r" (flags), "r" (fd), "r" (offset), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "munmap" that takes addr as Pointer, length as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("munmap")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: mapping address :End Note
        "mov rsi, %2\n"           Note: mapping length :End Note
        "mov rax, %3\n"           Note: munmap syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (length), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "mprotect" that takes addr as Pointer, length as Integer, prot as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("mprotect")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: memory address :End Note
        "mov rsi, %2\n"           Note: length :End Note
        "mov rdx, %3\n"           Note: new protection :End Note
        "mov rax, %4\n"           Note: mprotect syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (length), "r" (prot), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "msync" that takes addr as Pointer, length as Integer, flags as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("msync")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: memory address :End Note
        "mov rsi, %2\n"           Note: length :End Note
        "mov rdx, %3\n"           Note: sync flags :End Note
        "mov rax, %4\n"           Note: msync syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (addr), "r" (length), "r" (flags), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Unix domain socket operations :End Note
Process called "socketpair" that takes domain as Integer, type as Integer, protocol as Integer, sv as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("socketpair")
    Let result be Integer
    
    Inline Assembly:
        "mov edi, %1\n"           Note: socket domain :End Note
        "mov esi, %2\n"           Note: socket type :End Note
        "mov rdx, %3\n"           Note: protocol :End Note
        "mov r10, %4\n"           Note: socket pair array :End Note
        "mov rax, %5\n"           Note: socketpair syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (domain), "r" (type), "r" (protocol), "r" (sv), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Anonymous shared memory :End Note
Process called "shm_open" that takes name as Pointer, oflag as Integer, mode as Integer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shm_open")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: shared memory object name :End Note
        "mov rsi, %2\n"           Note: open flags :End Note
        "mov rdx, %3\n"           Note: permission mode :End Note
        "mov rax, %4\n"           Note: shm_open syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (name), "r" (oflag), "r" (mode), "r" (syscall_num)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "shm_unlink" that takes name as Pointer returns Integer:
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("shm_unlink")
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: shared memory object name :End Note
        "mov rax, %2\n"           Note: shm_unlink syscall number from registry :End Note
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (name), "r" (syscall_num)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process
