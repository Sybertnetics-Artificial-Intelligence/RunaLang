Note:
runa/src/runatime/integration/system_interface/platform_syscalls/windows/network_syscalls.runa
Windows POSIX Network Syscalls Compatibility Layer

This module provides POSIX-compatible network syscall implementations for Windows,
mapping POSIX socket operations to equivalent Windows NT API calls.

Key compatibility features:
- POSIX socket/bind/listen/accept → Windows AFD operations
- POSIX send/recv → Windows NtReadFile/NtWriteFile on sockets
- POSIX connect → Windows AFD connect operations
- POSIX socket options → Windows socket option mapping
- POSIX address families → Windows address family conversion
- POSIX network I/O → Windows overlapped I/O when needed
- POSIX socket types → Windows socket type mapping
- POSIX error codes → Windows network error conversion
:End Note

Import module "syscalls/platforms/windows_x64" as WindowsPlatform
Import module "syscalls/core/platform_interface" as PlatformInterface
Import module "compiler/frontend/primitives/core/integer_primitive" as Integer
Import module "compiler/frontend/primitives/memory/references" as Memory
Import module "compiler/frontend/primitives/types/conversion" as Convert

@Reasoning
Windows networking uses a different API structure than POSIX sockets.
This compatibility layer provides POSIX socket semantics while using
Windows AFD (Ancillary Function Driver) operations for network I/O.
@End Reasoning

Note: =====================================================================
Note: POSIX SOCKET CREATION AND MANAGEMENT
Note: =====================================================================

Process called "sys_socket" that takes family as Integer, type as Integer, protocol as Integer returns Integer:
    Note: Create socket with POSIX semantics
    Note: Maps to Windows AFD socket creation
    Note: Returns socket descriptor on success, -1 on error
    
    @Implementation
    POSIX socket creation is mapped to Windows AFD operations.
    Address families and socket types are converted to Windows equivalents.
    @End Implementation
    
    Note: Convert POSIX address family to Windows
    Let win_family be family
    Match family:
        When 2:  Note: AF_INET
            Set win_family to 2
        When 23: Note: AF_INET6
            Set win_family to 23
        When 1:  Note: AF_UNIX (handled via named pipes)
            Return sys_socket_unix(type, protocol)
        Otherwise:
            Return -1  Note: Unsupported family
    End Match
    
    Note: Convert POSIX socket type to Windows
    Let win_type be type
    Match type:
        When 1:  Note: SOCK_STREAM
            Set win_type to 1
        When 2:  Note: SOCK_DGRAM
            Set win_type to 2
        When 3:  Note: SOCK_RAW
            Set win_type to 3
        Otherwise:
            Return -1  Note: Unsupported type
    End Match
    
    Note: Create socket using AFD
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtCreateFile")
    Let result be Integer
    
    Note: Create AFD device handle
    Let device_name be "\\Device\\Afd"
    Let object_attributes be Integer.allocate(48)
    Let io_status_block be Integer.allocate(16)
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle (output)
        "mov rdx, 0xC0000000\n"   Note: GENERIC_READ | GENERIC_WRITE
        "mov r8, %2\n"            Note: object attributes
        "mov r9, %3\n"            Note: IO status block
        "push 3\n"                Note: share access
        "push 1\n"                Note: FILE_OPEN
        "push 0\n"                Note: create options
        "push 0\n"                Note: EA buffer
        "mov rax, %4\n"           Note: NtCreateFile syscall number
        "syscall\n"
        "add rsp, 32\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (result), "r" (object_attributes), "r" (io_status_block), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let afd_handle be Convert.windows_status_to_posix(result)
    
    If afd_handle.is_error:
        Return -1
    End If
    
    Note: Initialize socket with AFD_CREATE_PACKET
    Let create_packet_size be 24  Note: AFD_CREATE_PACKET structure size
    Let create_packet be Integer.allocate(create_packet_size)
    
    Integer.write_memory(create_packet, win_family)     Note: AddressFamily
    Integer.write_memory(create_packet + 4, win_type)   Note: SocketType
    Integer.write_memory(create_packet + 8, protocol)   Note: Protocol
    Integer.write_memory(create_packet + 12, 0)         Note: GroupID
    Integer.write_memory(create_packet + 16, 0)         Note: Flags
    Integer.write_memory(create_packet + 20, 0)         Note: Reserved
    
    Let io_status_block be Integer.allocate(16)
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtDeviceIoControlFile")
    Let result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle
        "mov rdx, 0\n"            Note: event (optional)
        "mov r8, 0\n"             Note: APC routine (optional)
        "mov r9, 0\n"             Note: APC context (optional)
        "push 0\n"                Note: output buffer length
        "push 0\n"                Note: output buffer
        "push %4\n"               Note: input buffer length
        "push %3\n"               Note: input buffer
        "push 0x12003\n"          Note: IOCTL_AFD_CREATE
        "push %2\n"               Note: IO status block
        "mov rax, %5\n"           Note: NtDeviceIoControlFile syscall number
        "syscall\n"
        "add rsp, 48\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (afd_handle.value), "r" (io_status_block), "r" (create_packet), "r" (create_packet_size), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let create_result be Convert.windows_status_to_posix(result)
    
    If create_result.is_error:
        Let platform be PlatformInterface.get_current_platform()
        Let syscall_num be platform.get_syscall_number("NtClose")
        Let result be Integer
        
        Inline Assembly:
            "mov rcx, %1\n"           Note: handle to close
            "mov rax, %2\n"           Note: NtClose syscall number
            "syscall\n"
            "mov %0, rax\n"
            : "=r" (result)
            : "r" (afd_handle.value), "r" (syscall_num)
            : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
        End Assembly
        
        Let close_result be Convert.windows_status_to_posix(result)
        Return -1
    End If
    
    Return afd_handle.value

Process called "sys_bind" that takes sockfd as Integer, addr as Integer, addrlen as Integer returns Integer:
    Note: Bind socket to address
    Note: Maps to Windows AFD bind operation
    Note: Returns 0 on success, -1 on error
    
    @Implementation
    Socket binding uses AFD_BIND_DATA structure to bind the socket
    to the specified address with proper address format conversion.
    @End Implementation
    
    Note: Create AFD bind data structure
    Let bind_data_size be (4 + addrlen)  Note: AFD_BIND_DATA header + address
    Let bind_data be Integer.allocate(bind_data_size)
    
    Integer.write_memory(bind_data, addrlen)  Note: Address length
    
    Note: Copy address data
    For i from 0 to (addrlen - 1):
        Let addr_byte be Integer.read_memory(addr + i)
        Integer.write_memory(bind_data + 4 + i, addr_byte)
    End For
    
    Let io_status_block be Integer.allocate(16)
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtDeviceIoControlFile")
    Let result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle
        "mov rdx, 0\n"            Note: event (optional)
        "mov r8, 0\n"             Note: APC routine (optional)
        "mov r9, 0\n"             Note: APC context (optional)
        "push 0\n"                Note: output buffer length
        "push 0\n"                Note: output buffer
        "push %4\n"               Note: input buffer length
        "push %3\n"               Note: input buffer
        "push 0x12007\n"          Note: IOCTL_AFD_BIND
        "push %2\n"               Note: IO status block
        "mov rax, %5\n"           Note: NtDeviceIoControlFile syscall number
        "syscall\n"
        "add rsp, 48\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (io_status_block), "r" (bind_data), "r" (bind_data_size), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let bind_result be Convert.windows_status_to_posix(result)
    
    If bind_result.is_error:
        Return -1
    Otherwise:
        Return 0
    End If

Process called "sys_listen" that takes sockfd as Integer, backlog as Integer returns Integer:
    Note: Mark socket as listening
    Note: Maps to Windows AFD listen operation
    Note: Returns 0 on success, -1 on error
    
    @Implementation
    Listen operation configures the socket to accept incoming connections
    with the specified backlog queue size.
    @End Implementation
    
    Note: Create AFD listen data
    Let listen_data_size be 8
    Let listen_data be Integer.allocate(listen_data_size)
    
    Integer.write_memory(listen_data, backlog)  Note: Backlog count
    Integer.write_memory(listen_data + 4, 0)    Note: Reserved
    
    Let io_status_block be Integer.allocate(16)
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtDeviceIoControlFile")
    Let result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle
        "mov rdx, 0\n"            Note: event (optional)
        "mov r8, 0\n"             Note: APC routine (optional)
        "mov r9, 0\n"             Note: APC context (optional)
        "push 0\n"                Note: output buffer length
        "push 0\n"                Note: output buffer
        "push %4\n"               Note: input buffer length
        "push %3\n"               Note: input buffer
        "push 0x1200B\n"          Note: IOCTL_AFD_LISTEN
        "push %2\n"               Note: IO status block
        "mov rax, %5\n"           Note: NtDeviceIoControlFile syscall number
        "syscall\n"
        "add rsp, 48\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (io_status_block), "r" (listen_data), "r" (listen_data_size), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let listen_result be Convert.windows_status_to_posix(result)
    
    If listen_result.is_error:
        Return -1
    Otherwise:
        Return 0
    End If

Process called "sys_accept" that takes sockfd as Integer, addr as Integer, addrlen as Integer returns Integer:
    Note: Accept connection on listening socket
    Note: Maps to Windows AFD accept operation
    Note: Returns new socket descriptor on success, -1 on error
    
    @Implementation
    Accept operation waits for incoming connections and returns a new
    socket handle for the established connection.
    @End Implementation
    
    Note: Create new socket for accepted connection
    Let addr_family be Integer.read_memory(addr)
    Let new_socket be sys_socket(addr_family, 1, 0)  Note: SOCK_STREAM
    
    If new_socket equals -1:
        Return -1
    End If
    
    Note: Prepare AFD accept data
    Let accept_data_size be (32 + 64)  Note: AFD_ACCEPT_DATA + address space
    Let accept_data be Integer.allocate(accept_data_size)
    
    Integer.write_memory(accept_data, new_socket)  Note: Accept socket handle
    Integer.write_memory(accept_data + 8, 32)      Note: Local address length
    Integer.write_memory(accept_data + 12, 32)     Note: Remote address length
    
    Let io_status_block be Integer.allocate(16)
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtDeviceIoControlFile")
    Let result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle
        "mov rdx, 0\n"            Note: event (optional)
        "mov r8, 0\n"             Note: APC routine (optional)
        "mov r9, 0\n"             Note: APC context (optional)
        "push %4\n"               Note: output buffer length
        "push %3\n"               Note: output buffer
        "push %4\n"               Note: input buffer length
        "push %3\n"               Note: input buffer
        "push 0x1200C\n"          Note: IOCTL_AFD_ACCEPT
        "push %2\n"               Note: IO status block
        "mov rax, %5\n"           Note: NtDeviceIoControlFile syscall number
        "syscall\n"
        "add rsp, 48\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (io_status_block), "r" (accept_data), "r" (accept_data_size), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let accept_result be Convert.windows_status_to_posix(result)
    
    If accept_result.is_error:
        Let platform be PlatformInterface.get_current_platform()
        Let syscall_num be platform.get_syscall_number("NtClose")
        Let result be Integer
        
        Inline Assembly:
            "mov rcx, %1\n"           Note: handle to close
            "mov rax, %2\n"           Note: NtClose syscall number
            "syscall\n"
            "mov %0, rax\n"
            : "=r" (result)
            : "r" (new_socket), "r" (syscall_num)
            : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
        End Assembly
        
        Let close_result be Convert.windows_status_to_posix(result)
        Return -1
    End If
    
    Note: Copy peer address if requested
    If addr not equals 0 and addrlen not equals 0:
        Let remote_addr_offset be (32 + 16)  Note: Skip local address
        Let max_copy_len be Integer.read_memory(addrlen)
        Let actual_addr_len be Integer.read_memory(accept_data + 12)
        
        Let copy_len be actual_addr_len
        If max_copy_len is less than actual_addr_len:
            Set copy_len to max_copy_len
        End If
        
        For i from 0 to (copy_len - 1):
            Let addr_byte be Integer.read_memory(accept_data + remote_addr_offset + i)
            Integer.write_memory(addr + i, addr_byte)
        End For
        
        Integer.write_memory(addrlen, actual_addr_len)
    End If
    
    Return new_socket

Process called "sys_connect" that takes sockfd as Integer, addr as Integer, addrlen as Integer returns Integer:
    Note: Connect socket to remote address
    Note: Maps to Windows AFD connect operation
    Note: Returns 0 on success, -1 on error
    
    @Implementation
    Connect operation establishes connection to the remote address
    specified in the address structure.
    @End Implementation
    
    Note: Prepare AFD connect data
    Let connect_data_size be (8 + addrlen)
    Let connect_data be Integer.allocate(connect_data_size)
    
    Integer.write_memory(connect_data, addrlen)  Note: Remote address length
    Integer.write_memory(connect_data + 4, 0)    Note: Local address length (0 for auto)
    
    Note: Copy remote address
    For i from 0 to (addrlen - 1):
        Let addr_byte be Integer.read_memory(addr + i)
        Integer.write_memory(connect_data + 8 + i, addr_byte)
    End For
    
    Let io_status_block be Integer.allocate(16)
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtDeviceIoControlFile")
    Let result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle
        "mov rdx, 0\n"            Note: event (optional)
        "mov r8, 0\n"             Note: APC routine (optional)
        "mov r9, 0\n"             Note: APC context (optional)
        "push 0\n"                Note: output buffer length
        "push 0\n"                Note: output buffer
        "push %4\n"               Note: input buffer length
        "push %3\n"               Note: input buffer
        "push 0x12008\n"          Note: IOCTL_AFD_CONNECT
        "push %2\n"               Note: IO status block
        "mov rax, %5\n"           Note: NtDeviceIoControlFile syscall number
        "syscall\n"
        "add rsp, 48\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (io_status_block), "r" (connect_data), "r" (connect_data_size), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let connect_result be Convert.windows_status_to_posix(result)
    
    If connect_result.is_error:
        Return -1
    Otherwise:
        Return 0
    End If

Note: =====================================================================
Note: POSIX SOCKET I/O OPERATIONS
Note: =====================================================================

Process called "sys_send" that takes sockfd as Integer, buf as Integer, len as Integer, flags as Integer returns Integer:
    Note: Send data on socket
    Note: Maps to Windows NtWriteFile on socket handle
    Note: Returns bytes sent on success, -1 on error
    
    @Implementation
    Socket send operation uses Windows NtWriteFile with proper
    I/O status block handling for network sockets.
    @End Implementation
    
    Let io_status_block be Integer.allocate(16)
    Integer.write_memory(io_status_block, 0)
    Integer.write_memory(io_status_block + 8, 0)
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtWriteFile")
    Let result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle
        "mov rdx, 0\n"            Note: event (optional)
        "mov r8, 0\n"             Note: APC routine (optional)
        "mov r9, 0\n"             Note: APC context (optional)
        "push 0\n"                Note: key (optional)
        "push %4\n"               Note: length
        "push %3\n"               Note: buffer
        "push %2\n"               Note: IO status block
        "mov rax, %5\n"           Note: NtWriteFile syscall number
        "syscall\n"
        "add rsp, 32\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (io_status_block), "r" (buf), "r" (len), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let send_result be Convert.windows_status_to_posix(result)
    
    If send_result.is_error:
        Return -1
    Otherwise:
        Let bytes_sent be Integer.read_memory(io_status_block + 8)
        Return bytes_sent
    End If

Process called "sys_recv" that takes sockfd as Integer, buf as Integer, len as Integer, flags as Integer returns Integer:
    Note: Receive data from socket
    Note: Maps to Windows NtReadFile on socket handle
    Note: Returns bytes received on success, -1 on error
    
    @Implementation
    Socket receive operation uses Windows NtReadFile with proper
    handling for network socket semantics and partial reads.
    @End Implementation
    
    Let io_status_block be Integer.allocate(16)
    Integer.write_memory(io_status_block, 0)
    Integer.write_memory(io_status_block + 8, 0)
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtReadFile")
    Let result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle
        "mov rdx, 0\n"            Note: event (optional)
        "mov r8, 0\n"             Note: APC routine (optional)
        "mov r9, 0\n"             Note: APC context (optional)
        "push 0\n"                Note: key (optional)
        "push %4\n"               Note: length
        "push %3\n"               Note: buffer
        "push %2\n"               Note: IO status block
        "mov rax, %5\n"           Note: NtReadFile syscall number
        "syscall\n"
        "add rsp, 32\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (io_status_block), "r" (buf), "r" (len), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let recv_result be Convert.windows_status_to_posix(result)
    
    If recv_result.is_error:
        Return -1
    Otherwise:
        Let bytes_received be Integer.read_memory(io_status_block + 8)
        Return bytes_received
    End If

Process called "sys_sendto" that takes sockfd as Integer, buf as Integer, len as Integer, flags as Integer, dest_addr as Integer, addrlen as Integer returns Integer:
    Note: Send data to specific address (UDP)
    Note: Maps to Windows AFD send datagram
    Note: Returns bytes sent on success, -1 on error
    
    @Implementation
    Datagram send operation uses AFD send datagram IOCTL with
    destination address specification for UDP sockets.
    @End Implementation
    
    Note: Prepare AFD send datagram structure
    Let send_data_size be (16 + addrlen + len)
    Let send_data be Integer.allocate(send_data_size)
    
    Integer.write_memory(send_data, addrlen)     Note: Address length
    Integer.write_memory(send_data + 4, len)     Note: Data length
    Integer.write_memory(send_data + 8, 16)      Note: Address offset
    Integer.write_memory(send_data + 12, 16 + addrlen)  Note: Data offset
    
    Note: Copy destination address
    For i from 0 to (addrlen - 1):
        Let addr_byte be Integer.read_memory(dest_addr + i)
        Integer.write_memory(send_data + 16 + i, addr_byte)
    End For
    
    Note: Copy data to send
    For i from 0 to (len - 1):
        Let data_byte be Integer.read_memory(buf + i)
        Integer.write_memory(send_data + 16 + addrlen + i, data_byte)
    End For
    
    Let io_status_block be Integer.allocate(16)
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtDeviceIoControlFile")
    Let result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle
        "mov rdx, 0\n"            Note: event (optional)
        "mov r8, 0\n"             Note: APC routine (optional)
        "mov r9, 0\n"             Note: APC context (optional)
        "push 0\n"                Note: output buffer length
        "push 0\n"                Note: output buffer
        "push %4\n"               Note: input buffer length
        "push %3\n"               Note: input buffer
        "push 0x1201E\n"          Note: IOCTL_AFD_SEND_DATAGRAM
        "push %2\n"               Note: IO status block
        "mov rax, %5\n"           Note: NtDeviceIoControlFile syscall number
        "syscall\n"
        "add rsp, 48\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (io_status_block), "r" (send_data), "r" (send_data_size), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let sendto_result be Convert.windows_status_to_posix(result)
    
    If sendto_result.is_error:
        Return -1
    Otherwise:
        Return len  Note: All data sent in datagram mode
    End If

Process called "sys_recvfrom" that takes sockfd as Integer, buf as Integer, len as Integer, flags as Integer, src_addr as Integer, addrlen as Integer returns Integer:
    Note: Receive data with source address (UDP)
    Note: Maps to Windows AFD receive datagram
    Note: Returns bytes received on success, -1 on error
    
    @Implementation
    Datagram receive operation uses AFD receive datagram IOCTL to
    receive data and source address information.
    @End Implementation
    
    Note: Prepare AFD receive datagram structure
    Let recv_data_size be (16 + 64 + len)  Note: Header + max address + data buffer
    Let recv_data be Integer.allocate(recv_data_size)
    
    Integer.write_memory(recv_data, 64)       Note: Max address length
    Integer.write_memory(recv_data + 4, len)  Note: Max data length
    Integer.write_memory(recv_data + 8, 16)   Note: Address offset
    Integer.write_memory(recv_data + 12, 80)  Note: Data offset (16 + 64)
    
    Let io_status_block be Integer.allocate(16)
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtDeviceIoControlFile")
    Let result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle
        "mov rdx, 0\n"            Note: event (optional)
        "mov r8, 0\n"             Note: APC routine (optional)
        "mov r9, 0\n"             Note: APC context (optional)
        "push %4\n"               Note: output buffer length
        "push %3\n"               Note: output buffer
        "push %4\n"               Note: input buffer length
        "push %3\n"               Note: input buffer
        "push 0x1201F\n"          Note: IOCTL_AFD_RECV_DATAGRAM
        "push %2\n"               Note: IO status block
        "mov rax, %5\n"           Note: NtDeviceIoControlFile syscall number
        "syscall\n"
        "add rsp, 48\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (io_status_block), "r" (recv_data), "r" (recv_data_size), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let recvfrom_result be Convert.windows_status_to_posix(result)
    
    If recvfrom_result.is_error:
        Return -1
    End If
    
    Note: Get actual received lengths
    Let actual_addr_len be Integer.read_memory(recv_data)
    Let actual_data_len be Integer.read_memory(recv_data + 4)
    
    Note: Copy received data
    For i from 0 to (actual_data_len - 1):
        Let data_byte be Integer.read_memory(recv_data + 80 + i)
        Integer.write_memory(buf + i, data_byte)
    End For
    
    Note: Copy source address if requested
    If src_addr not equals 0 and addrlen not equals 0:
        Let max_addr_len be Integer.read_memory(addrlen)
        Let copy_addr_len be actual_addr_len
        
        If max_addr_len is less than actual_addr_len:
            Set copy_addr_len to max_addr_len
        End If
        
        For i from 0 to (copy_addr_len - 1):
            Let addr_byte be Integer.read_memory(recv_data + 16 + i)
            Integer.write_memory(src_addr + i, addr_byte)
        End For
        
        Integer.write_memory(addrlen, actual_addr_len)
    End If
    
    Return actual_data_len

Note: =====================================================================
Note: POSIX SOCKET OPTIONS
Note: =====================================================================

Process called "sys_setsockopt" that takes sockfd as Integer, level as Integer, optname as Integer, optval as Integer, optlen as Integer returns Integer:
    Note: Set socket option
    Note: Maps to Windows AFD set socket option
    Note: Returns 0 on success, -1 on error
    
    @Implementation
    Socket options are set using AFD set socket option IOCTL with
    appropriate option level and name translation.
    @End Implementation
    
    Note: Prepare AFD socket option structure
    Let opt_data_size be (12 + optlen)
    Let opt_data be Integer.allocate(opt_data_size)
    
    Integer.write_memory(opt_data, level)    Note: Option level
    Integer.write_memory(opt_data + 4, optname)  Note: Option name
    Integer.write_memory(opt_data + 8, optlen)   Note: Option length
    
    Note: Copy option value
    For i from 0 to (optlen - 1):
        Let opt_byte be Integer.read_memory(optval + i)
        Integer.write_memory(opt_data + 12 + i, opt_byte)
    End For
    
    Let io_status_block be Integer.allocate(16)
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtDeviceIoControlFile")
    Let result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle
        "mov rdx, 0\n"            Note: event (optional)
        "mov r8, 0\n"             Note: APC routine (optional)
        "mov r9, 0\n"             Note: APC context (optional)
        "push 0\n"                Note: output buffer length
        "push 0\n"                Note: output buffer
        "push %4\n"               Note: input buffer length
        "push %3\n"               Note: input buffer
        "push 0x12010\n"          Note: IOCTL_AFD_SET_SOCKET_OPTION
        "push %2\n"               Note: IO status block
        "mov rax, %5\n"           Note: NtDeviceIoControlFile syscall number
        "syscall\n"
        "add rsp, 48\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (io_status_block), "r" (opt_data), "r" (opt_data_size), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let setopt_result be Convert.windows_status_to_posix(result)
    
    If setopt_result.is_error:
        Return -1
    Otherwise:
        Return 0
    End If

Process called "sys_getsockopt" that takes sockfd as Integer, level as Integer, optname as Integer, optval as Integer, optlen as Integer returns Integer:
    Note: Get socket option
    Note: Maps to Windows AFD get socket option
    Note: Returns 0 on success, -1 on error
    
    @Implementation
    Socket options are retrieved using AFD get socket option IOCTL
    with proper buffer management for the option value.
    @End Implementation
    
    Note: Prepare AFD get socket option structure
    Let max_opt_len be Integer.read_memory(optlen)
    Let opt_data_size be (12 + max_opt_len)
    Let opt_data be Integer.allocate(opt_data_size)
    
    Integer.write_memory(opt_data, level)     Note: Option level
    Integer.write_memory(opt_data + 4, optname)   Note: Option name
    Integer.write_memory(opt_data + 8, max_opt_len)  Note: Buffer size
    
    Let io_status_block be Integer.allocate(16)
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtDeviceIoControlFile")
    Let result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle
        "mov rdx, 0\n"            Note: event (optional)
        "mov r8, 0\n"             Note: APC routine (optional)
        "mov r9, 0\n"             Note: APC context (optional)
        "push %4\n"               Note: output buffer length
        "push %3\n"               Note: output buffer
        "push %4\n"               Note: input buffer length
        "push %3\n"               Note: input buffer
        "push 0x12011\n"          Note: IOCTL_AFD_GET_SOCKET_OPTION
        "push %2\n"               Note: IO status block
        "mov rax, %5\n"           Note: NtDeviceIoControlFile syscall number
        "syscall\n"
        "add rsp, 48\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (io_status_block), "r" (opt_data), "r" (opt_data_size), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let getopt_result be Convert.windows_status_to_posix(result)
    
    If getopt_result.is_error:
        Return -1
    End If
    
    Note: Copy option value back
    Let actual_opt_len be Integer.read_memory(opt_data + 8)
    Integer.write_memory(optlen, actual_opt_len)
    
    For i from 0 to (actual_opt_len - 1):
        Let opt_byte be Integer.read_memory(opt_data + 12 + i)
        Integer.write_memory(optval + i, opt_byte)
    End For
    
    Return 0

Note: =====================================================================
Note: POSIX SOCKET SHUTDOWN
Note: =====================================================================

Process called "sys_shutdown" that takes sockfd as Integer, how as Integer returns Integer:
    Note: Shutdown socket communication
    Note: Maps to Windows AFD disconnect
    Note: Returns 0 on success, -1 on error
    
    @Implementation
    Socket shutdown uses AFD disconnect operations with appropriate
    flags for partial or full connection shutdown.
    @End Implementation
    
    Note: Convert POSIX shutdown mode to AFD flags
    Let disconnect_flags be 0
    
    Match how:
        When 0:  Note: SHUT_RD
            Set disconnect_flags to 1  Note: AFD_DISCONNECT_RECV
        When 1:  Note: SHUT_WR
            Set disconnect_flags to 2  Note: AFD_DISCONNECT_SEND
        When 2:  Note: SHUT_RDWR
            Set disconnect_flags to 3  Note: AFD_DISCONNECT_RECV | AFD_DISCONNECT_SEND
        Otherwise:
            Return -1
    End Match
    
    Let disconnect_data_size be 4
    Let disconnect_data be Integer.allocate(disconnect_data_size)
    Integer.write_memory(disconnect_data, disconnect_flags)
    
    Let io_status_block be Integer.allocate(16)
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtDeviceIoControlFile")
    Let result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle
        "mov rdx, 0\n"            Note: event (optional)
        "mov r8, 0\n"             Note: APC routine (optional)
        "mov r9, 0\n"             Note: APC context (optional)
        "push 0\n"                Note: output buffer length
        "push 0\n"                Note: output buffer
        "push %4\n"               Note: input buffer length
        "push %3\n"               Note: input buffer
        "push 0x12009\n"          Note: IOCTL_AFD_DISCONNECT
        "push %2\n"               Note: IO status block
        "mov rax, %5\n"           Note: NtDeviceIoControlFile syscall number
        "syscall\n"
        "add rsp, 48\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result)
        : "r" (sockfd), "r" (io_status_block), "r" (disconnect_data), "r" (disconnect_data_size), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let shutdown_result be Convert.windows_status_to_posix(result)
    
    If shutdown_result.is_error:
        Return -1
    Otherwise:
        Return 0
    End If

