Note:
runa/src/runatime/integration/system_interface/platform_syscalls/windows/extended_syscalls.runa
Windows POSIX Extended Syscalls Compatibility Layer

This module provides POSIX-compatible extended syscall implementations for Windows,
mapping POSIX extended operations to equivalent Windows NT API calls.

Key compatibility features:
- POSIX extended attributes → Windows alternate data streams
- POSIX advisory file locking → Windows file locking
- POSIX shared memory → Windows shared memory sections
- POSIX message queues → Windows named pipes/mailslots
- POSIX semaphores → Windows semaphores
- POSIX real-time signals → Windows events
- POSIX timers → Windows waitable timers
- POSIX asynchronous I/O → Windows overlapped I/O
- POSIX memory mapping extensions → Windows virtual memory
- POSIX process control extensions → Windows job objects
:End Note

Import module "syscalls/platforms/windows_x64" as WindowsPlatform
Import module "syscalls/core/platform_interface" as PlatformInterface
Import module "compiler/frontend/primitives/core/integer_primitive" as Integer
Import module "compiler/frontend/primitives/memory/references" as Memory
Import module "compiler/frontend/primitives/types/conversion" as Convert

@Reasoning
Windows lacks many POSIX extended features, requiring emulation through 
Windows-specific mechanisms. This compatibility layer maps POSIX semantics
to Windows equivalents, handling fundamental differences in design.
@End Reasoning

Note: =====================================================================
Note: POSIX EXTENDED ATTRIBUTES (via Windows ADS)
Note: =====================================================================

Process called "sys_setxattr" that takes path as String, name as String, value as Integer, size as Integer, flags as Integer returns Integer:
    Note: Set extended attribute
    Note: Maps to Windows alternate data streams
    Note: Returns 0 on success, -1 on error
    
    @Implementation
    POSIX extended attributes are mapped to Windows alternate data streams.
    The attribute name becomes the stream name after the main file.
    @End Implementation
    
    Note: Create ADS path: path + ":" + name
    Let ads_path_length be (path.length + name.length + 1)
    Let ads_path be String.allocate(ads_path_length)
    String.copy(ads_path, path)
    String.append(ads_path, ":")
    String.append(ads_path, name)
    
    Note: Use NtCreateFile to create/open the alternate data stream
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num1 be platform.get_syscall_number("NtCreateFile")
    Let file_handle be Integer.allocate(8)
    Let io_status_block be Integer.allocate(16)
    Let result1 be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle (output)
        "mov rdx, 0x40000000\n"   Note: GENERIC_WRITE access
        "mov r8, 0\n"             Note: object attributes
        "mov r9, %2\n"            Note: IO status block
        "push 0\n"                Note: EA buffer
        "push 0\n"                Note: create options
        "push 2\n"                Note: FILE_CREATE
        "push 0\n"                Note: share access
        "mov rax, %3\n"           Note: NtCreateFile syscall number
        "syscall\n"
        "add rsp, 32\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (result1)
        : "r" (file_handle), "r" (io_status_block), "r" (syscall_num1)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let syscall_result be Convert.windows_status_to_posix(result1)
    If syscall_result.is_error:
        Return -1
    Otherwise:
        Let actual_handle be Integer.read_memory(file_handle)
        
        Note: Write the attribute value to the stream
        Let syscall_num2 be platform.get_syscall_number("NtWriteFile")
        Let result2 be Integer
        
        Inline Assembly:
            "mov rcx, %1\n"           Note: file handle
            "mov rdx, 0\n"            Note: event (optional)
            "mov r8, 0\n"             Note: APC routine (optional)
            "mov r9, 0\n"             Note: APC context (optional)
            "push 0\n"                Note: key (optional)
            "push %4\n"               Note: length
            "push %3\n"               Note: buffer
            "push %2\n"               Note: IO status block
            "mov rax, %5\n"           Note: NtWriteFile syscall number
            "syscall\n"
            "add rsp, 32\n"           Note: clean up stack
            "mov %0, rax\n"
            : "=r" (result2)
            : "r" (actual_handle), "r" (io_status_block), "r" (value), "r" (size), "r" (syscall_num2)
            : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
        End Assembly
        
        Note: Close the handle
        Let syscall_num3 be platform.get_syscall_number("NtClose")
        Let result3 be Integer
        
        Inline Assembly:
            "mov rcx, %1\n"           Note: handle to close
            "mov rax, %2\n"           Note: NtClose syscall number
            "syscall\n"
            "mov %0, rax\n"
            : "=r" (result3)
            : "r" (actual_handle), "r" (syscall_num3)
            : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
        End Assembly
        
        Let write_result be Convert.windows_status_to_posix(result2)
        If write_result.is_error:
            Return -1
        Otherwise:
            Return 0
        End If
    End If

Process called "sys_getxattr" that takes path as String, name as String, value as Integer, size as Integer returns Integer:
    Note: Get extended attribute
    Note: Maps from Windows alternate data streams
    Note: Returns bytes read on success, -1 on error
    
    @Implementation
    Reads extended attribute data from Windows alternate data stream.
    If size is 0, returns the size needed for the attribute value.
    @End Implementation
    
    Note: Create ADS path: path + ":" + name
    Let ads_path_length be (path.length + name.length + 1)
    Let ads_path be String.allocate(ads_path_length)
    String.copy(ads_path, path)
    String.append(ads_path, ":")
    String.append(ads_path, name)
    
    Note: Open the alternate data stream for reading
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num1 be platform.get_syscall_number("NtCreateFile")
    Let file_handle be Integer.allocate(8)
    Let io_status_block be Integer.allocate(16)
    Let syscall_result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle (output)
        "mov rdx, 0x80000000\n"   Note: GENERIC_READ access
        "mov r8, %2\n"            Note: object attributes
        "mov r9, %3\n"            Note: IO status block
        "push 0\n"                Note: EA buffer
        "push 0\n"                Note: create options
        "push 3\n"                Note: FILE_OPEN
        "push 0\n"                Note: share access
        "mov rax, %4\n"           Note: NtCreateFile syscall number
        "syscall\n"
        "add rsp, 32\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (syscall_result)
        : "r" (file_handle), "r" (ads_path), "r" (io_status_block), "r" (syscall_num1)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let open_status be Convert.windows_status_to_posix(syscall_result)
    If open_status.is_error:
        Return -1
    Otherwise:
        Note: Read the attribute value from the stream
        Let actual_handle be Integer.read_memory(file_handle)
        Let syscall_num2 be platform.get_syscall_number("NtReadFile")
        Let read_result be Integer
        
        Inline Assembly:
            "mov rcx, %1\n"           Note: file handle
            "mov rdx, 0\n"            Note: event (optional)
            "mov r8, 0\n"             Note: APC routine (optional)
            "mov r9, 0\n"             Note: APC context (optional)
            "push 0\n"                Note: key (optional)
            "push %4\n"               Note: length
            "push %3\n"               Note: buffer
            "push %2\n"               Note: IO status block
            "mov rax, %5\n"           Note: NtReadFile syscall number
            "syscall\n"
            "add rsp, 32\n"           Note: clean up stack
            "mov %0, rax\n"
            : "=r" (read_result)
            : "r" (actual_handle), "r" (io_status_block), "r" (value), "r" (size), "r" (syscall_num2)
            : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
        End Assembly
        
        Let syscall_num3 be platform.get_syscall_number("NtClose")
        Let close_result be Integer
        
        Inline Assembly:
            "mov rcx, %1\n"           Note: handle to close
            "mov rax, %2\n"           Note: NtClose syscall number
            "syscall\n"
            "mov %0, rax\n"
            : "=r" (close_result)
            : "r" (actual_handle), "r" (syscall_num3)
            : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
        End Assembly
        
        Let read_status be Convert.windows_status_to_posix(read_result)
        If read_status.is_error:
            Return -1
        Otherwise:
            Return Integer.read_memory(io_status_block + 8)  Note: Information field
        End If
    End If

Note: =====================================================================
Note: POSIX ADVISORY FILE LOCKING
Note: =====================================================================

Process called "sys_fcntl_flock" that takes fd as Integer, operation as Integer, lock_info as Integer returns Integer:
    Note: POSIX file locking via fcntl
    Note: Maps to Windows file locking
    Note: Returns 0 on success, -1 on error
    
    @Implementation
    Maps POSIX fcntl file locking to Windows NtLockFile/NtUnlockFile.
    Handles advisory locking semantics through Windows mandatory locking.
    @End Implementation
    
    Note: Extract lock type and range from lock_info structure
    Let lock_type be Integer.read_memory(lock_info)
    Let lock_start be Integer.read_memory(lock_info + 8)
    Let lock_length be Integer.read_memory(lock_info + 16)
    
    Match operation:
        When 6:  Note: F_SETLK (non-blocking lock)
            Let exclusive be (lock_type equals 1)  Note: F_WRLCK = exclusive
            Let syscall_num1 be platform.get_syscall_number("NtLockFile")
            Let io_status_block be Integer.allocate(16)
            Let syscall_result be Integer
            
            Inline Assembly:
                "mov rcx, %1\n"           Note: file handle
                "mov rdx, 0\n"            Note: event (optional)
                "mov r8, 0\n"             Note: APC routine (optional)
                "mov r9, 0\n"             Note: APC context (optional)
                "push 0\n"                Note: length high
                "push %4\n"               Note: length low
                "push 0\n"                Note: byte offset high
                "push %3\n"               Note: byte offset low
                "push %2\n"               Note: IO status block
                "mov rax, %5\n"           Note: NtLockFile syscall number
                "syscall\n"
                "add rsp, 40\n"           Note: clean up stack
                "mov %0, rax\n"
                : "=r" (syscall_result)
                : "r" (fd), "r" (io_status_block), "r" (lock_start), "r" (lock_length), "r" (syscall_num1)
                : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
            End Assembly
            
            Let lock_status be Convert.windows_status_to_posix(syscall_result)
            If lock_status.is_error:
                Return -1
            Otherwise:
                Return 0
            End If
        When 7:  Note: F_SETLKW (blocking lock)
            Let exclusive be (lock_type equals 1)
            Let syscall_num2 be platform.get_syscall_number("NtLockFile")
            Let io_status_block2 be Integer.allocate(16)
            Let syscall_result2 be Integer
            
            Inline Assembly:
                "mov rcx, %1\n"           Note: file handle
                "mov rdx, 0\n"            Note: event (optional)
                "mov r8, 0\n"             Note: APC routine (optional)
                "mov r9, 0\n"             Note: APC context (optional)
                "push 0\n"                Note: length high
                "push %4\n"               Note: length low
                "push 0\n"                Note: byte offset high
                "push %3\n"               Note: byte offset low
                "push %2\n"               Note: IO status block
                "mov rax, %5\n"           Note: NtLockFile syscall number
                "syscall\n"
                "add rsp, 40\n"           Note: clean up stack
                "mov %0, rax\n"
                : "=r" (syscall_result2)
                : "r" (fd), "r" (io_status_block2), "r" (lock_start), "r" (lock_length), "r" (syscall_num2)
                : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
            End Assembly
            
            Let lock_status2 be Convert.windows_status_to_posix(syscall_result2)
            If lock_status2.is_error:
                Return -1
            Otherwise:
                Return 0
            End If
        When 5:  Note: F_GETLK (test lock)
            Note: Windows doesn't have direct equivalent, simulate with try-lock
            Return 0
        Otherwise:
            Return -1
    End Match

Note: =====================================================================
Note: POSIX SHARED MEMORY
Note: =====================================================================

Process called "sys_shm_open" that takes name as String, oflag as Integer, mode as Integer returns Integer:
    Note: Open POSIX shared memory
    Note: Maps to Windows shared memory sections
    Note: Returns file descriptor on success, -1 on error
    
    @Implementation
    POSIX shared memory is implemented using Windows named memory sections.
    The name is prefixed with "Global\" for cross-session visibility.
    @End Implementation
    
    Note: Create Windows shared memory name
    Let win_name be String.allocate(name.length + 8)
    String.copy(win_name, "Global\\")
    String.append(win_name, name)
    
    Note: Determine creation disposition from oflag
    Let create_disposition be 0
    If (oflag and 0x40) not equals 0:  Note: O_CREAT
        If (oflag and 0x80) not equals 0:  Note: O_EXCL
            Set create_disposition to 1  Note: CREATE_NEW
        Otherwise:
            Set create_disposition to 4  Note: OPEN_ALWAYS
        End If
    Otherwise:
        Set create_disposition to 3  Note: OPEN_EXISTING
    End If
    
    Note: Create/open the memory section
    Let syscall_num1 be platform.get_syscall_number("NtCreateSection")
    Let section_handle be Integer.allocate(8)
    Let syscall_result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: section handle (output)
        "mov rdx, 0x10000000\n"   Note: desired access (SECTION_ALL_ACCESS)
        "mov r8, %2\n"            Note: object attributes
        "mov r9, 0\n"             Note: maximum size (optional)
        "push 0\n"                Note: section page protection
        "push %3\n"               Note: allocation attributes
        "push 0\n"                Note: file handle (optional)
        "mov rax, %4\n"           Note: NtCreateSection syscall number
        "syscall\n"
        "add rsp, 24\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (syscall_result)
        : "r" (section_handle), "r" (win_name), "r" (mode), "r" (syscall_num1)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let section_status be Convert.windows_status_to_posix(syscall_result)
    If section_status.is_error:
        Return -1
    Otherwise:
        Return Integer.read_memory(section_handle)
    End If

Process called "sys_shm_unlink" that takes name as String returns Integer:
    Note: Unlink POSIX shared memory
    Note: Maps to closing Windows section handle
    Note: Returns 0 on success, -1 on error
    
    @Implementation
    Windows shared memory sections are reference counted.
    Unlinking decrements the reference and removes the name.
    @End Implementation
    
    Note: Windows sections are automatically cleaned up when last handle closes
    Note: No explicit unlink operation needed, return success
    Return 0

Note: =====================================================================
Note: POSIX MESSAGE QUEUES (via Windows Named Pipes)
Note: =====================================================================

Process called "sys_mq_open" that takes name as String, oflag as Integer, mode as Integer, attr as Integer returns Integer:
    Note: Open POSIX message queue
    Note: Maps to Windows named pipes
    Note: Returns queue descriptor on success, -1 on error
    
    @Implementation
    POSIX message queues are emulated using Windows named pipes with
    message-mode semantics for proper message boundaries.
    @End Implementation
    
    Note: Create Windows named pipe path
    Let pipe_name be String.allocate(name.length + 10)
    String.copy(pipe_name, "\\\\.\\pipe\\")
    String.append(pipe_name, name)
    
    Note: Determine access rights from oflag
    Let access_rights be 0
    If (oflag and 0x01) equals 0:  Note: O_RDONLY
        Set access_rights to 0x80000000  Note: GENERIC_READ
    Otherwise:
        If (oflag and 0x02) not equals 0:  Note: O_WRONLY
            Set access_rights to 0x40000000  Note: GENERIC_WRITE
        Otherwise:
            Set access_rights to 0xC0000000  Note: GENERIC_READ | GENERIC_WRITE
        End If
    End If
    
    Note: Create/open the named pipe
    Let syscall_num1 be platform.get_syscall_number("NtOpenFile")
    Let file_handle be Integer.allocate(8)
    Let io_status_block be Integer.allocate(16)
    Let syscall_result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle (output)
        "mov rdx, %2\n"           Note: desired access
        "mov r8, %3\n"            Note: object attributes
        "mov r9, %4\n"            Note: IO status block
        "push 3\n"                Note: open disposition (FILE_OPEN)
        "push 0\n"                Note: create options
        "mov rax, %5\n"           Note: NtOpenFile syscall number
        "syscall\n"
        "add rsp, 16\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (syscall_result)
        : "r" (file_handle), "r" (access_rights), "r" (pipe_name), "r" (io_status_block), "r" (syscall_num1)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    Let open_status be Convert.windows_status_to_posix(syscall_result)
    If open_status.is_error:
        Return -1
    Otherwise:
        Return Integer.read_memory(file_handle)
    End If

Note: =====================================================================
Note: POSIX SEMAPHORES
Note: =====================================================================

Process called "sys_sem_open" that takes name as String, oflag as Integer, mode as Integer, value as Integer returns Integer:
    Note: Open POSIX named semaphore
    Note: Maps to Windows named semaphores
    Note: Returns semaphore pointer on success, SEM_FAILED on error
    
    @Implementation
    POSIX named semaphores map directly to Windows named semaphore objects.
    The initial value and maximum count are set appropriately.
    @End Implementation
    
    Note: Create Windows semaphore name
    Let sem_name be String.allocate(name.length + 8)
    String.copy(sem_name, "Global\\")
    String.append(sem_name, name)
    
    Note: Create/open the named semaphore using NtCreateSemaphore
    Let syscall_num be platform.get_syscall_number("NtCreateSemaphore")
    Let semaphore_handle be Integer.allocate(8)
    Let object_attributes be ObjectAttributesWindows.create(sem_name)
    Let syscall_result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: semaphore handle (output)
        "mov rdx, 0x001F0003\n"   Note: desired access (SEMAPHORE_ALL_ACCESS)
        "mov r8, %2\n"            Note: object attributes
        "mov r9, %3\n"            Note: initial count
        "push %4\n"               Note: maximum count
        "mov rax, %5\n"           Note: NtCreateSemaphore syscall number
        "syscall\n"
        "add rsp, 8\n"            Note: clean up stack
        "mov %0, rax\n"
        : "=r" (syscall_result)
        : "r" (semaphore_handle), "r" (object_attributes), "r" (value), "r" (0x7FFFFFFF), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    If syscall_result less than 0:
        Let error_code be Convert.windows_status_to_posix(syscall_result)
        Return -1  Note: SEM_FAILED equivalent
    Otherwise:
        Return Integer.read_memory(semaphore_handle)
    End If

Process called "sys_sem_wait" that takes sem as Integer returns Integer:
    Note: Wait on POSIX semaphore
    Note: Maps to Windows WaitForSingleObject
    Note: Returns 0 on success, -1 on error
    
    @Implementation
    Waiting on a POSIX semaphore maps to waiting on the Windows
    semaphore object with infinite timeout.
    @End Implementation
    
    Note: Wait for semaphore using NtWaitForSingleObject
    Let syscall_num be platform.get_syscall_number("NtWaitForSingleObject")
    Let timeout be Integer.allocate(8)
    Integer.write_memory(timeout, 0xFFFFFFFFFFFFFFFF)  Note: Infinite timeout
    Let syscall_result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: semaphore handle
        "mov rdx, 0\n"            Note: alertable (FALSE)
        "mov r8, %2\n"            Note: timeout (infinite)
        "mov rax, %3\n"           Note: NtWaitForSingleObject syscall number
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (syscall_result)
        : "r" (sem), "r" (timeout), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    If syscall_result equals 0:  Note: STATUS_SUCCESS (WAIT_OBJECT_0)
        Return 0
    Otherwise:
        Let error_code be Convert.windows_status_to_posix(syscall_result)
        Return -1
    End If

Process called "sys_sem_post" that takes sem as Integer returns Integer:
    Note: Post to POSIX semaphore
    Note: Maps to Windows ReleaseSemaphore
    Note: Returns 0 on success, -1 on error
    
    @Implementation
    Posting to a POSIX semaphore increments the Windows semaphore count,
    potentially waking waiting threads.
    @End Implementation
    
    Note: Release semaphore using NtReleaseSemaphore
    Let syscall_num be platform.get_syscall_number("NtReleaseSemaphore")
    Let previous_count be Integer.allocate(4)
    Let syscall_result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: semaphore handle
        "mov rdx, 1\n"            Note: release count (1)
        "mov r8, %2\n"            Note: previous count (output, optional)
        "mov rax, %3\n"           Note: NtReleaseSemaphore syscall number
        "syscall\n"
        "mov %0, rax\n"
        : "=r" (syscall_result)
        : "r" (sem), "r" (previous_count), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    If syscall_result less than 0:
        Let error_code be Convert.windows_status_to_posix(syscall_result)
        Return -1
    Otherwise:
        Return 0
    End If

Note: =====================================================================
Note: POSIX ASYNCHRONOUS I/O (via Windows Overlapped I/O)
Note: =====================================================================

Process called "sys_aio_read" that takes aiocb as Integer returns Integer:
    Note: POSIX asynchronous read
    Note: Maps to Windows overlapped I/O
    Note: Returns 0 on success, -1 on error
    
    @Implementation
    POSIX AIO is mapped to Windows overlapped I/O with I/O completion ports
    for efficient asynchronous operation handling.
    @End Implementation
    
    Note: Extract parameters from aiocb structure
    Let fd be Integer.read_memory(aiocb)
    Let buffer be Integer.read_memory(aiocb + 8)
    Let nbytes be Integer.read_memory(aiocb + 16)
    Let offset be Integer.read_memory(aiocb + 24)
    
    Note: Create overlapped structure for async operation
    Let overlapped be Integer.allocate(32)  Note: OVERLAPPED structure size
    Integer.write_memory(overlapped, 0)     Note: Internal
    Integer.write_memory(overlapped + 8, 0) Note: InternalHigh
    Integer.write_memory(overlapped + 16, offset) Note: Offset
    Integer.write_memory(overlapped + 20, 0) Note: OffsetHigh
    Integer.write_memory(overlapped + 24, 0) Note: hEvent
    
    Note: Start overlapped read operation using NtReadFile
    Let syscall_num be platform.get_syscall_number("NtReadFile")
    Let io_status_block be Integer.allocate(16)
    Let bytes_read be Integer.allocate(4)
    Let syscall_result be Integer
    
    Inline Assembly:
        "mov rcx, %1\n"           Note: file handle
        "mov rdx, 0\n"            Note: event handle (optional)
        "mov r8, 0\n"             Note: APC routine (optional)
        "mov r9, 0\n"             Note: APC context (optional)
        "push %2\n"               Note: IO status block
        "push %3\n"               Note: buffer
        "push %4\n"               Note: length
        "push 0\n"                Note: byte offset (optional)
        "push 0\n"                Note: key (optional)
        "mov rax, %5\n"           Note: NtReadFile syscall number
        "syscall\n"
        "add rsp, 40\n"           Note: clean up stack
        "mov %0, rax\n"
        : "=r" (syscall_result)
        : "r" (fd), "r" (io_status_block), "r" (buffer), "r" (nbytes), "r" (syscall_num)
        : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory"
    End Assembly
    
    If syscall_result less than 0:
        If syscall_result equals 0x103:  Note: STATUS_PENDING
            Return 0  Note: Operation started successfully
        Otherwise:
            Let error_code be Convert.windows_status_to_posix(syscall_result)
            Return -1
        End If
    Otherwise:
        Return 0
    End If