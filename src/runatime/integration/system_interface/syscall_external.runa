Note: External Syscall Interface Layer
Note: This module provides the interface layer for syscalls, using our primitive layer
Note: instead of external declarations. This ensures true self-hosting capability.

Import "../compiler/frontend/primitives/assembly/syscall.runa" as SyscallPrimitive
Import "../compiler/frontend/primitives/core/pointer_primitive.runa" as Pointer
Import "../compiler/frontend/primitives/core/integer_primitive.runa" as Integer
Import "../compiler/frontend/primitives/memory/memory_core.runa" as Memory

@Reasoning
This is the interface layer between high-level syscall wrappers and the low-level
primitive syscall implementation. It provides a clean API that hides platform
differences and error handling complexity from higher-level code.
@End Reasoning

Note: =====================================================================
Note: SYSCALL INTERFACE WRAPPERS
Note: =====================================================================
Note: These wrap the primitive syscall functions with a cleaner interface

Process called "runa_syscall0" that takes syscall_num as Integer returns Integer:
    Note: Zero-argument syscall wrapper
    
    @Implementation
    Wraps the primitive make_syscall function for zero-argument syscalls.
    Returns the raw result value, letting callers handle error checking.
    @End Implementation
    
    Let result be SyscallPrimitive.make_syscall(syscall_num)
    Return result.value
End Process

Process called "runa_syscall1" that takes syscall_num as Integer, p1 as Integer returns Integer:
    Note: One-argument syscall wrapper
    
    Let result be SyscallPrimitive.make_syscall_1(syscall_num, p1)
    Return result.value
End Process

Process called "runa_syscall2" that takes syscall_num as Integer, p1 as Integer, p2 as Integer returns Integer:
    Note: Two-argument syscall wrapper
    
    Let result be SyscallPrimitive.make_syscall_2(syscall_num, p1, p2)
    Return result.value
End Process

Process called "runa_syscall3" that takes syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer returns Integer:
    Note: Three-argument syscall wrapper
    
    Let result be SyscallPrimitive.make_syscall_3(syscall_num, p1, p2, p3)
    Return result.value
End Process

Process called "runa_syscall4" that takes syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer, p4 as Integer returns Integer:
    Note: Four-argument syscall wrapper
    
    Let result be SyscallPrimitive.make_syscall_4(syscall_num, p1, p2, p3, p4)
    Return result.value
End Process

Process called "runa_syscall5" that takes syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer, p4 as Integer, p5 as Integer returns Integer:
    Note: Five-argument syscall wrapper
    
    Let result be SyscallPrimitive.make_syscall_5(syscall_num, p1, p2, p3, p4, p5)
    Return result.value
End Process

Process called "runa_syscall6" that takes syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer, p4 as Integer, p5 as Integer, p6 as Integer returns Integer:
    Note: Six-argument syscall wrapper
    
    Let result be SyscallPrimitive.make_syscall_6(syscall_num, p1, p2, p3, p4, p5, p6)
    Return result.value
End Process

Note: =====================================================================
Note: BUFFER MANAGEMENT
Note: =====================================================================
Note: Buffer type and operations for syscall parameter passing

Type called "Buffer":
    Note: Represents a memory buffer for syscall operations
    
    @Implementation
    Buffers are used to pass data to/from syscalls. They track both
    the memory address and size for safety.
    @End Implementation
    
    address as Integer
    size as Integer
End Type

Process called "allocate_buffer" that takes size as Integer returns Buffer:
    Note: Allocate a buffer for syscall operations
    
    @Implementation
    Uses the memory primitive to allocate space, then wraps it in
    a Buffer structure for safe access.
    @End Implementation
    
    Let buffer be Buffer
    Let addr be Memory.allocate_memory(size)
    Set buffer.address to addr
    Set buffer.size to size
    Return buffer
End Process

Process called "free_buffer" that takes buffer as Buffer returns Nothing:
    Note: Free a previously allocated buffer
    
    @Implementation
    Releases the memory associated with a buffer. The buffer should
    not be used after this call.
    @End Implementation
    
    Memory.free_memory(buffer.address, buffer.size)
End Process

Process called "read_byte_at" that takes buffer as Buffer, offset as Integer returns Integer:
    Note: Read a single byte from buffer
    
    @Implementation
    Reads one byte at the specified offset. Bounds checking ensures
    we don't read outside the buffer.
    @End Implementation
    
    If offset is greater than or equal to buffer.size:
        Return 0  Note: Out of bounds
    End If
    
    Let addr be Integer.add_integers(buffer.address, offset)
    Return Memory.read_byte(addr)
End Process

Process called "write_byte_at" that takes buffer as Buffer, offset as Integer, value as Integer returns Nothing:
    Note: Write a single byte to buffer
    
    @Implementation
    Writes one byte at the specified offset. Bounds checking prevents
    buffer overflows.
    @End Implementation
    
    If offset is greater than or equal to buffer.size:
        Return  Note: Out of bounds
    End If
    
    Let addr be Integer.add_integers(buffer.address, offset)
    Memory.write_byte(addr, value)
End Process

Process called "read_16bit_at" that takes buffer as Buffer, offset as Integer returns Integer:
    Note: Read a 16-bit value from buffer
    
    @Implementation
    Reads two bytes as a 16-bit integer. Uses little-endian byte order.
    @End Implementation
    
    If Integer.add_integers(offset, 2) is greater than buffer.size:
        Return 0  Note: Out of bounds
    End If
    
    Let addr be Integer.add_integers(buffer.address, offset)
    Return Memory.read_word(addr)
End Process

Process called "write_16bit_at" that takes buffer as Buffer, offset as Integer, value as Integer returns Nothing:
    Note: Write a 16-bit value to buffer
    
    @Implementation
    Writes two bytes as a 16-bit integer. Uses little-endian byte order.
    @End Implementation
    
    If Integer.add_integers(offset, 2) is greater than buffer.size:
        Return  Note: Out of bounds
    End If
    
    Let addr be Integer.add_integers(buffer.address, offset)
    Memory.write_word(addr, value)
End Process

Process called "read_32bit_at" that takes buffer as Buffer, offset as Integer returns Integer:
    Note: Read a 32-bit value from buffer
    
    @Implementation
    Reads four bytes as a 32-bit integer. Uses little-endian byte order.
    @End Implementation
    
    If Integer.add_integers(offset, 4) is greater than buffer.size:
        Return 0  Note: Out of bounds
    End If
    
    Let addr be Integer.add_integers(buffer.address, offset)
    Return Memory.read_dword(addr)
End Process

Process called "write_32bit_at" that takes buffer as Buffer, offset as Integer, value as Integer returns Nothing:
    Note: Write a 32-bit value to buffer
    
    @Implementation
    Writes four bytes as a 32-bit integer. Uses little-endian byte order.
    @End Implementation
    
    If Integer.add_integers(offset, 4) is greater than buffer.size:
        Return  Note: Out of bounds
    End If
    
    Let addr be Integer.add_integers(buffer.address, offset)
    Memory.write_dword(addr, value)
End Process

Process called "read_64bit_at" that takes buffer as Buffer, offset as Integer returns Integer:
    Note: Read a 64-bit value from buffer
    
    @Implementation
    Reads eight bytes as a 64-bit integer. Uses little-endian byte order.
    @End Implementation
    
    If Integer.add_integers(offset, 8) is greater than buffer.size:
        Return 0  Note: Out of bounds
    End If
    
    Let addr be Integer.add_integers(buffer.address, offset)
    Return Memory.read_qword(addr)
End Process

Process called "write_64bit_at" that takes buffer as Buffer, offset as Integer, value as Integer returns Nothing:
    Note: Write a 64-bit value to buffer
    
    @Implementation
    Writes eight bytes as a 64-bit integer. Uses little-endian byte order.
    @End Implementation
    
    If Integer.add_integers(offset, 8) is greater than buffer.size:
        Return  Note: Out of bounds
    End If
    
    Let addr be Integer.add_integers(buffer.address, offset)
    Memory.write_qword(addr, value)
End Process

Note: =====================================================================
Note: STRING/BUFFER CONVERSION UTILITIES
Note: =====================================================================

Process called "string_to_buffer" that takes str as String returns Buffer:
    Note: Convert a Runa string to a null-terminated buffer
    
    @Implementation
    Strings are converted to buffers for passing to syscalls that expect
    C-style strings. The implementation determines string length and copies
    bytes to a new buffer.
    @End Implementation
    
    Note: Get string address and determine length
    Let str_addr be cast_string_to_address(str)
    Let length be 0
    Let max_scan be 65536  Note: Maximum string length
    
    Note: Scan for string length
    While length is less than max_scan:
        Let byte be Memory.read_byte(Integer.add_integers(str_addr, length))
        If byte equals 0:
            Break
        End If
        Set length to Integer.add_integers(length, 1)
    End While
    
    Note: Allocate buffer with null terminator space
    Let buffer be allocate_buffer(Integer.add_integers(length, 1))
    
    Note: Copy string bytes
    Let i be 0
    While i is less than length:
        Let byte be Memory.read_byte(Integer.add_integers(str_addr, i))
        write_byte_at(buffer, i, byte)
        Set i to Integer.add_integers(i, 1)
    End While
    
    Note: Add null terminator
    write_byte_at(buffer, length, 0)
    Return buffer
End Process

Process called "buffer_to_string" that takes buffer as Buffer, max_length as Integer returns String:
    Note: Convert a buffer to a Runa string
    
    @Implementation
    Creates a string from buffer contents, stopping at null terminator
    or maximum length. Used to convert syscall results to strings.
    @End Implementation
    
    Note: Determine actual string length
    Let actual_length be 0
    While actual_length is less than max_length:
        Let byte be read_byte_at(buffer, actual_length)
        If byte equals 0:
            Break
        End If
        Set actual_length to Integer.add_integers(actual_length, 1)
    End While
    
    Note: Allocate string buffer
    Let string_buffer be allocate_buffer(Integer.add_integers(actual_length, 1))
    
    Note: Copy bytes
    Let i be 0
    While i is less than actual_length:
        Let byte be read_byte_at(buffer, i)
        write_byte_at(string_buffer, i, byte)
        Set i to Integer.add_integers(i, 1)
    End While
    
    Note: Add null terminator
    write_byte_at(string_buffer, actual_length, 0)
    
    Note: Cast buffer to string
    Return cast_address_to_string(string_buffer.address)
End Process

Note: =====================================================================
Note: TYPE CASTING UTILITIES
Note: =====================================================================
Note: These are compiler intrinsics for type conversions

Process called "cast_string_to_address" that takes str as String returns Integer:
    Note: Get the memory address of a string
    
    @Implementation
    Compiler intrinsic that returns the memory address of a string's data.
    This is a zero-cost operation at runtime.
    @End Implementation
    
    Assembly "mov %[result], %[str]" with inputs [str] outputs [result]
    Let result as Integer
    Return result
End Process

Process called "cast_address_to_string" that takes addr as Integer returns String:
    Note: Create a string from a memory address
    
    @Implementation
    Compiler intrinsic that interprets a memory address as a string.
    The memory must contain valid null-terminated string data.
    @End Implementation
    
    Assembly "mov %[result], %[addr]" with inputs [addr] outputs [result]
    Let result as String
    Return result
End Process

Process called "buffer_to_int" that takes buffer as Buffer returns Integer:
    Note: Get buffer address as integer
    
    @Implementation
    Returns the memory address of a buffer for use in syscalls.
    @End Implementation
    
    Return buffer.address
End Process

Process called "int_to_buffer" that takes value as Integer, size as Integer returns Buffer:
    Note: Create a buffer containing an integer value
    
    @Implementation
    Creates a buffer and stores an integer value in it, using the
    appropriate size (1, 2, 4, or 8 bytes).
    @End Implementation
    
    Let buffer be allocate_buffer(size)
    
    Match size:
        When 1:
            write_byte_at(buffer, 0, value)
        When 2:
            write_16bit_at(buffer, 0, value)
        When 4:
            write_32bit_at(buffer, 0, value)
        When 8:
            write_64bit_at(buffer, 0, value)
        Otherwise:
            Note: Invalid size - write as much as possible
            write_64bit_at(buffer, 0, value)
    End Match
    
    Return buffer
End Process

Note: =====================================================================
Note: ERROR CHECKING UTILITIES
Note: =====================================================================

Process called "is_syscall_error" that takes result as Integer returns Boolean:
    Note: Check if syscall returned an error
    
    @Implementation
    Linux syscalls return negative values for errors, typically in the
    range -1 to -4095. This checks for that pattern.
    @End Implementation
    
    If result is less than 0 and result is greater than -4096:
        Return true
    Otherwise:
        Return false
    End If
End Process

Process called "get_errno" that takes result as Integer returns Integer:
    Note: Extract error number from syscall result
    
    @Implementation
    Converts negative error result to positive errno value.
    @End Implementation
    
    If is_syscall_error(result):
        Return Integer.negate_integer(result)
    Otherwise:
        Return 0
    End If
End Process