Note: System Info Wrapper - Direct syscall interface for system information
Note: Provides self-contained system information queries without stdlib dependencies

@Reasoning
The system info wrapper provides direct syscall access for querying system
information such as hardware capabilities, OS version, memory stats, and
CPU information. This is essential for the compiler to make platform-specific
optimizations and adapt to system resources without any stdlib dependencies.
@End Reasoning

Import module "compiler/frontend/primitives/types/compiler_internals" as "Internals"

Note: =====================================================================
Note: SYSTEM INFO STRUCTURES
Note: =====================================================================

Type called "SystemInfo":
    os_name as String                     Note: Operating system name
    os_release as String                  Note: OS release version
    os_version as String                  Note: OS version string
    machine_arch as String                Note: Machine architecture
    hostname as String                    Note: System hostname
    domain_name as String                 Note: Domain name
    total_ram as Integer                  Note: Total RAM in bytes
    free_ram as Integer                   Note: Free RAM in bytes
    shared_ram as Integer                 Note: Shared RAM in bytes
    buffer_ram as Integer                 Note: Buffer RAM in bytes
    total_swap as Integer                 Note: Total swap in bytes
    free_swap as Integer                  Note: Free swap in bytes
    process_count as Integer              Note: Number of processes
    uptime_seconds as Integer             Note: System uptime
    load_avg_1min as Integer              Note: 1-minute load average
    load_avg_5min as Integer              Note: 5-minute load average
    load_avg_15min as Integer             Note: 15-minute load average
End Type

Type called "CPUInfo":
    processor_id as Integer               Note: Processor ID
    vendor_id as String                   Note: CPU vendor
    model_name as String                  Note: CPU model name
    cpu_family as Integer                 Note: CPU family
    model as Integer                      Note: CPU model number
    stepping as Integer                   Note: CPU stepping
    physical_id as Integer                Note: Physical CPU ID
    core_id as Integer                    Note: Core ID
    cpu_cores as Integer                  Note: Number of cores
    cpu_mhz as Integer                    Note: CPU frequency in MHz
    cache_size as Integer                 Note: Cache size in KB
    flags as Internals.InternalArray      Note: CPU feature flags
End Type

Type called "MemoryInfo":
    mem_total as Integer                  Note: Total usable RAM
    mem_free as Integer                   Note: Free RAM
    mem_available as Integer              Note: Available memory
    buffers as Integer                    Note: Memory in buffers
    cached as Integer                     Note: Memory in cache
    swap_cached as Integer                Note: Swap cache
    active as Integer                     Note: Active memory
    inactive as Integer                   Note: Inactive memory
    swap_total as Integer                 Note: Total swap space
    swap_free as Integer                  Note: Free swap space
    dirty as Integer                      Note: Dirty pages
    writeback as Integer                  Note: Pages being written back
    mapped as Integer                     Note: Mapped pages
    shmem as Integer                      Note: Shared memory
    slab as Integer                       Note: Slab allocation
End Type

Type called "FileSystemInfo":
    filesystem as String                  Note: Filesystem type
    mount_point as String                 Note: Mount point
    total_blocks as Integer               Note: Total blocks
    free_blocks as Integer                Note: Free blocks
    available_blocks as Integer           Note: Available blocks
    total_inodes as Integer               Note: Total inodes
    free_inodes as Integer                Note: Free inodes
    block_size as Integer                 Note: Block size
    mount_flags as Integer                Note: Mount flags
End Type

Note: =====================================================================
Note: SYSTEM IDENTIFICATION
Note: =====================================================================

Note: Get system information using uname
Process called "get_system_info" returns SystemInfo:
    @Implementation
    Retrieves comprehensive system information using uname and sysinfo syscalls.
    @End Implementation
    
    Let info be SystemInfo
    
    Note: Get uname information
    Let uname_buffer be allocate_uname_buffer()
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: uname buffer
        "mov rax, 63\n"           Note: uname syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(uname_buffer)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    If result equals 0:
        parse_uname_buffer(uname_buffer, info)
    End If
    
    Note: Get sysinfo information
    Let sysinfo_buffer be allocate_sysinfo_buffer()
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: sysinfo buffer
        "mov rax, 99\n"           Note: sysinfo syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(sysinfo_buffer)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    If result equals 0:
        parse_sysinfo_buffer(sysinfo_buffer, info)
    End If
    
    Return info
End Process

Note: Get hostname
Process called "get_hostname" returns String:
    @Implementation
    Gets the system hostname using gethostname syscall.
    @End Implementation
    
    Let buffer_size be 256
    Let buffer be allocate_string_buffer(buffer_size)
    
    Let result be Integer
    Inline Assembly:
        "mov rdi, %1\n"           Note: Buffer
        "mov rsi, %2\n"           Note: Size
        "mov rax, 87\n"           Note: gethostname syscall (via uname)
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(buffer), "r"(buffer_size)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    If result < 0:
        Return ""
    End If
    
    Return create_string_from_buffer(buffer, string_length_at(buffer))
End Process

Note: Set hostname
Process called "set_hostname" that takes hostname as String returns Integer:
    @Implementation
    Sets the system hostname using sethostname syscall.
    Requires appropriate privileges.
    @End Implementation
    
    Let hostname_ptr be get_string_pointer(hostname)
    Let hostname_len be string_length(hostname)
    
    Let result be Integer
    Inline Assembly:
        "mov rdi, %1\n"           Note: Hostname
        "mov rsi, %2\n"           Note: Length
        "mov rax, 170\n"          Note: sethostname syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(hostname_ptr), "r"(hostname_len)
        : "rax", "rdi", "rsi", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Note: =====================================================================
Note: CPU INFORMATION
Note: =====================================================================

Note: Get CPU count
Process called "get_cpu_count" returns Integer:
    @Implementation
    Gets the number of configured CPUs using sysconf-like mechanism.
    @End Implementation
    
    Note: Read from /proc/cpuinfo or use sched_getaffinity
    Let cpu_set_size be 128  Note: sizeof(cpu_set_t)
    Let cpu_set be allocate_buffer(cpu_set_size)
    
    Let result be Integer
    Inline Assembly:
        "mov rdi, 0\n"            Note: PID (0 = current)
        "mov rsi, %2\n"           Note: cpu_set size
        "mov rdx, %1\n"           Note: cpu_set pointer
        "mov rax, 204\n"          Note: sched_getaffinity syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(cpu_set), "r"(cpu_set_size)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    If result > 0:
        Return count_bits_in_cpuset(cpu_set, result)
    End If
    
    Return 1  Note: Default to 1 CPU
End Process

Note: Get CPU information
Process called "get_cpu_info" that takes cpu_id as Integer returns CPUInfo:
    @Implementation
    Gets detailed information about a specific CPU.
    Reads from /proc/cpuinfo or uses cpuid instruction.
    @End Implementation
    
    Let info be CPUInfo
    Set info.processor_id to cpu_id
    
    Note: Use CPUID instruction for x86_64
    Let eax be Integer
    Let ebx be Integer
    Let ecx be Integer
    Let edx be Integer
    
    Note: Get vendor ID (CPUID function 0)
    Inline Assembly:
        "xor rax, rax\n"          Note: Function 0
        "cpuid\n"
        "mov %0, rax\n"
        "mov %1, rbx\n"
        "mov %2, rcx\n"
        "mov %3, rdx\n"
        : "=r"(eax), "=r"(ebx), "=r"(ecx), "=r"(edx)
        :
        : "rax", "rbx", "rcx", "rdx"
    End Assembly
    
    Set info.vendor_id to create_vendor_string(ebx, edx, ecx)
    
    Note: Get processor info (CPUID function 1)
    Inline Assembly:
        "mov rax, 1\n"            Note: Function 1
        "cpuid\n"
        "mov %0, rax\n"
        "mov %1, rbx\n"
        "mov %2, rcx\n"
        "mov %3, rdx\n"
        : "=r"(eax), "=r"(ebx), "=r"(ecx), "=r"(edx)
        :
        : "rax", "rbx", "rcx", "rdx"
    End Assembly
    
    Set info.cpu_family to (eax >> 8) & 0xF
    Set info.model to (eax >> 4) & 0xF
    Set info.stepping to eax & 0xF
    
    Note: Parse feature flags
    Set info.flags to parse_cpu_flags(ecx, edx)
    
    Return info
End Process

Note: =====================================================================
Note: MEMORY INFORMATION
Note: =====================================================================

Note: Get memory information
Process called "get_memory_info" returns MemoryInfo:
    @Implementation
    Gets detailed memory statistics from /proc/meminfo or sysinfo.
    @End Implementation
    
    Let info be MemoryInfo
    Let sysinfo_buffer be allocate_sysinfo_buffer()
    
    Let result be Integer
    Inline Assembly:
        "mov rdi, %1\n"           Note: sysinfo buffer
        "mov rax, 99\n"           Note: sysinfo syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(sysinfo_buffer)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    If result equals 0:
        parse_memory_from_sysinfo(sysinfo_buffer, info)
    End If
    
    Return info
End Process

Note: Get page size
Process called "get_page_size" returns Integer:
    @Implementation
    Gets the system page size, typically 4096 bytes.
    @End Implementation
    
    Let page_size be Integer
    
    Inline Assembly:
        "mov rax, 4096\n"         Note: Common page size
        "mov %0, rax\n"
        : "=r"(page_size)
        :
        : "rax"
    End Assembly
    
    Return page_size
End Process

Note: =====================================================================
Note: FILESYSTEM INFORMATION
Note: =====================================================================

Note: Get filesystem statistics
Process called "get_filesystem_info" that takes path as String returns FileSystemInfo:
    @Implementation
    Gets filesystem statistics for a given path using statfs syscall.
    @End Implementation
    
    Let info be FileSystemInfo
    Let statfs_buffer be allocate_statfs_buffer()
    Let path_ptr be get_string_pointer(path)
    
    Let result be Integer
    Inline Assembly:
        "mov rdi, %1\n"           Note: Path
        "mov rsi, %2\n"           Note: statfs buffer
        "mov rax, 137\n"          Note: statfs syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(path_ptr), "r"(statfs_buffer)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    If result equals 0:
        parse_statfs_buffer(statfs_buffer, info)
        Set info.mount_point to path
    End If
    
    Return info
End Process

Note: Get disk usage for path
Process called "get_disk_usage" that takes path as String returns Integer:
    @Implementation
    Returns disk usage in bytes for the filesystem containing path.
    @End Implementation
    
    Let fs_info be get_filesystem_info(path)
    Let used_blocks be fs_info.total_blocks - fs_info.free_blocks
    Return used_blocks * fs_info.block_size
End Process

Note: =====================================================================
Note: TIME AND UPTIME
Note: =====================================================================

Note: Get system uptime
Process called "get_uptime" returns Integer:
    @Implementation
    Gets system uptime in seconds using sysinfo syscall.
    @End Implementation
    
    Let sysinfo_buffer be allocate_sysinfo_buffer()
    
    Let result be Integer
    Inline Assembly:
        "mov rdi, %1\n"           Note: sysinfo buffer
        "mov rax, 99\n"           Note: sysinfo syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(sysinfo_buffer)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    If result equals 0:
        Return read_long_at_offset(sysinfo_buffer, 0)  Note: Uptime field
    End If
    
    Return 0
End Process

Note: Get current time
Process called "get_current_time" returns Integer:
    @Implementation
    Gets current time in seconds since epoch using time syscall.
    @End Implementation
    
    Let time_val be Integer
    
    Inline Assembly:
        "xor rdi, rdi\n"          Note: NULL time_t pointer
        "mov rax, 201\n"          Note: time syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(time_val)
        :
        : "rax", "rdi", "rcx", "r11"
    End Assembly
    
    Return time_val
End Process

Note: Get high-resolution time
Process called "get_time_nanoseconds" returns Integer:
    @Implementation
    Gets high-resolution time in nanoseconds using clock_gettime.
    @End Implementation
    
    Let time_ns be Integer
    
    Inline Assembly:
        "sub rsp, 16\n"           Note: Allocate timespec
        "mov rdi, 1\n"            Note: CLOCK_MONOTONIC
        "mov rsi, rsp\n"          Note: timespec pointer
        "mov rax, 228\n"          Note: clock_gettime syscall
        "syscall\n"
        "mov rax, [rsp]\n"        Note: tv_sec
        "imul rax, 1000000000\n"  Note: Convert to nanoseconds
        "add rax, [rsp+8]\n"      Note: Add tv_nsec
        "mov %0, rax\n"
        "add rsp, 16\n"
        : "=r"(time_ns)
        :
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return time_ns
End Process

Note: =====================================================================
Note: LOAD AVERAGE
Note: =====================================================================

Note: Get system load average
Process called "get_load_average" returns Internals.InternalArray:
    @Implementation
    Gets 1, 5, and 15 minute load averages.
    @End Implementation
    
    Let loads be Internals.create_internal_array(3)
    Let sysinfo_buffer be allocate_sysinfo_buffer()
    
    Let result be Integer
    Inline Assembly:
        "mov rdi, %1\n"           Note: sysinfo buffer
        "mov rax, 99\n"           Note: sysinfo syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(sysinfo_buffer)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
    
    If result equals 0:
        Note: Load averages are at specific offsets in sysinfo
        Let load1 be read_long_at_offset(sysinfo_buffer, 8)
        Let load5 be read_long_at_offset(sysinfo_buffer, 16)
        Let load15 be read_long_at_offset(sysinfo_buffer, 24)
        
        Internals.internal_array_set(loads, 0, load1)
        Internals.internal_array_set(loads, 1, load5)
        Internals.internal_array_set(loads, 2, load15)
    End If
    
    Return loads
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Note: Allocate uname buffer
Process called "allocate_uname_buffer" returns Integer:
    Let uname_size be 390  Note: sizeof(struct utsname)
    Return allocate_buffer(uname_size)
End Process

Note: Allocate sysinfo buffer
Process called "allocate_sysinfo_buffer" returns Integer:
    Let sysinfo_size be 112  Note: sizeof(struct sysinfo)
    Return allocate_buffer(sysinfo_size)
End Process

Note: Allocate statfs buffer
Process called "allocate_statfs_buffer" returns Integer:
    Let statfs_size be 120  Note: sizeof(struct statfs)
    Return allocate_buffer(statfs_size)
End Process

Note: Allocate generic buffer
Process called "allocate_buffer" that takes size as Integer returns Integer:
    Let buffer be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"
        "mov rax, 9\n"            Note: mmap
        "xor rsi, rsi\n"
        "mov rdx, 3\n"            Note: PROT_READ | PROT_WRITE
        "mov r10, 0x22\n"         Note: MAP_PRIVATE | MAP_ANONYMOUS
        "mov r8, -1\n"
        "xor r9, r9\n"
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(buffer)
        : "r"(size)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return buffer
End Process

Note: Parse uname buffer
Process called "parse_uname_buffer" that takes buffer as Integer, info as SystemInfo:
    @Implementation
    Parses struct utsname into SystemInfo fields.
    @End Implementation
    
    Set info.os_name to read_string_at_offset(buffer, 0, 65)
    Set info.hostname to read_string_at_offset(buffer, 65, 65)
    Set info.os_release to read_string_at_offset(buffer, 130, 65)
    Set info.os_version to read_string_at_offset(buffer, 195, 65)
    Set info.machine_arch to read_string_at_offset(buffer, 260, 65)
    Set info.domain_name to read_string_at_offset(buffer, 325, 65)
End Process

Note: Parse sysinfo buffer
Process called "parse_sysinfo_buffer" that takes buffer as Integer, info as SystemInfo:
    @Implementation
    Parses struct sysinfo into SystemInfo fields.
    @End Implementation
    
    Set info.uptime_seconds to read_long_at_offset(buffer, 0)
    Set info.load_avg_1min to read_long_at_offset(buffer, 8)
    Set info.load_avg_5min to read_long_at_offset(buffer, 16)
    Set info.load_avg_15min to read_long_at_offset(buffer, 24)
    Set info.total_ram to read_long_at_offset(buffer, 32)
    Set info.free_ram to read_long_at_offset(buffer, 40)
    Set info.shared_ram to read_long_at_offset(buffer, 48)
    Set info.buffer_ram to read_long_at_offset(buffer, 56)
    Set info.total_swap to read_long_at_offset(buffer, 64)
    Set info.free_swap to read_long_at_offset(buffer, 72)
    Set info.process_count to read_short_at_offset(buffer, 80)
End Process

Note: Parse memory from sysinfo
Process called "parse_memory_from_sysinfo" that takes buffer as Integer, info as MemoryInfo:
    Set info.mem_total to read_long_at_offset(buffer, 32)
    Set info.mem_free to read_long_at_offset(buffer, 40)
    Set info.mem_available to info.mem_free + read_long_at_offset(buffer, 56)  Note: free + buffers
    Set info.buffers to read_long_at_offset(buffer, 56)
    Set info.swap_total to read_long_at_offset(buffer, 64)
    Set info.swap_free to read_long_at_offset(buffer, 72)
End Process

Note: Parse statfs buffer
Process called "parse_statfs_buffer" that takes buffer as Integer, info as FileSystemInfo:
    @Implementation
    Parses struct statfs into FileSystemInfo fields.
    @End Implementation
    
    Let fs_type be read_long_at_offset(buffer, 0)
    Set info.filesystem to get_filesystem_name(fs_type)
    Set info.block_size to read_long_at_offset(buffer, 8)
    Set info.total_blocks to read_long_at_offset(buffer, 16)
    Set info.free_blocks to read_long_at_offset(buffer, 24)
    Set info.available_blocks to read_long_at_offset(buffer, 32)
    Set info.total_inodes to read_long_at_offset(buffer, 40)
    Set info.free_inodes to read_long_at_offset(buffer, 48)
    Set info.mount_flags to read_long_at_offset(buffer, 96)
End Process

Note: Get filesystem name from type
Process called "get_filesystem_name" that takes fs_type as Integer returns String:
    Match fs_type:
        When 0xEF53: Return "ext4"
        When 0x9123683E: Return "btrfs"
        When 0x58465342: Return "xfs"
        When 0x01021994: Return "tmpfs"
        When 0x6969: Return "nfs"
        When 0x5346544E: Return "ntfs"
        When 0x52654973: Return "reiserfs"
        When 0x3153464A: Return "jfs"
        When 0x137D: Return "ext2"
        When 0x138F: Return "minix"
    End Match
    Return "unknown"
End Process

Note: Count bits in CPU set
Process called "count_bits_in_cpuset" that takes cpu_set as Integer, size as Integer returns Integer:
    @Implementation
    Counts the number of set bits in a CPU affinity mask.
    @End Implementation
    
    Let count be 0
    Let i be 0
    
    While i < size:
        Let byte be read_byte_at_offset(cpu_set, i)
        Set count to count + popcount_byte(byte)
        Set i to i + 1
    End While
    
    Return count
End Process

Note: Population count for byte
Process called "popcount_byte" that takes byte as Integer returns Integer:
    Let count be 0
    Let value be byte
    
    While value > 0:
        Set count to count + (value & 1)
        Set value to value >> 1
    End While
    
    Return count
End Process

Note: Create vendor string from CPUID
Process called "create_vendor_string" that takes ebx as Integer, edx as Integer, ecx as Integer returns String:
    @Implementation
    Constructs vendor ID string from CPUID register values.
    @End Implementation
    
    Let buffer be allocate_string_buffer(13)
    
    Note: EBX contains first 4 characters
    write_byte_at_offset(buffer, 0, ebx & 0xFF)
    write_byte_at_offset(buffer, 1, (ebx >> 8) & 0xFF)
    write_byte_at_offset(buffer, 2, (ebx >> 16) & 0xFF)
    write_byte_at_offset(buffer, 3, (ebx >> 24) & 0xFF)
    
    Note: EDX contains next 4 characters
    write_byte_at_offset(buffer, 4, edx & 0xFF)
    write_byte_at_offset(buffer, 5, (edx >> 8) & 0xFF)
    write_byte_at_offset(buffer, 6, (edx >> 16) & 0xFF)
    write_byte_at_offset(buffer, 7, (edx >> 24) & 0xFF)
    
    Note: ECX contains last 4 characters
    write_byte_at_offset(buffer, 8, ecx & 0xFF)
    write_byte_at_offset(buffer, 9, (ecx >> 8) & 0xFF)
    write_byte_at_offset(buffer, 10, (ecx >> 16) & 0xFF)
    write_byte_at_offset(buffer, 11, (ecx >> 24) & 0xFF)
    
    write_byte_at_offset(buffer, 12, 0)  Note: Null terminator
    
    Return create_string_from_buffer(buffer, 12)
End Process

Note: Parse CPU feature flags
Process called "parse_cpu_flags" that takes ecx as Integer, edx as Integer returns Internals.InternalArray:
    @Implementation
    Parses CPU feature flags from CPUID results.
    @End Implementation
    
    Let flags be Internals.create_internal_array(64)
    Let flag_count be 0
    
    Note: Check EDX flags (basic features)
    If edx & (1 << 0):
        Internals.internal_array_set(flags, flag_count, string_to_int("fpu"))
        Set flag_count to flag_count + 1
    End If
    If edx & (1 << 4):
        Internals.internal_array_set(flags, flag_count, string_to_int("tsc"))
        Set flag_count to flag_count + 1
    End If
    If edx & (1 << 23):
        Internals.internal_array_set(flags, flag_count, string_to_int("mmx"))
        Set flag_count to flag_count + 1
    End If
    If edx & (1 << 25):
        Internals.internal_array_set(flags, flag_count, string_to_int("sse"))
        Set flag_count to flag_count + 1
    End If
    If edx & (1 << 26):
        Internals.internal_array_set(flags, flag_count, string_to_int("sse2"))
        Set flag_count to flag_count + 1
    End If
    
    Note: Check ECX flags (extended features)
    If ecx & (1 << 0):
        Internals.internal_array_set(flags, flag_count, string_to_int("sse3"))
        Set flag_count to flag_count + 1
    End If
    If ecx & (1 << 9):
        Internals.internal_array_set(flags, flag_count, string_to_int("ssse3"))
        Set flag_count to flag_count + 1
    End If
    If ecx & (1 << 19):
        Internals.internal_array_set(flags, flag_count, string_to_int("sse41"))
        Set flag_count to flag_count + 1
    End If
    If ecx & (1 << 20):
        Internals.internal_array_set(flags, flag_count, string_to_int("sse42"))
        Set flag_count to flag_count + 1
    End If
    If ecx & (1 << 28):
        Internals.internal_array_set(flags, flag_count, string_to_int("avx"))
        Set flag_count to flag_count + 1
    End If
    
    Return flags
End Process

Note: Read memory at offset
Process called "read_long_at_offset" that takes buffer as Integer, offset as Integer returns Integer:
    Let value be Integer
    
    Inline Assembly:
        "mov rax, %1\n"
        "add rax, %2\n"
        "mov rbx, [rax]\n"
        "mov %0, rbx\n"
        : "=r"(value)
        : "r"(buffer), "r"(offset)
        : "rax", "rbx", "memory"
    End Assembly
    
    Return value
End Process

Process called "read_short_at_offset" that takes buffer as Integer, offset as Integer returns Integer:
    Let value be Integer
    
    Inline Assembly:
        "mov rax, %1\n"
        "add rax, %2\n"
        "movzx rbx, word [rax]\n"
        "mov %0, rbx\n"
        : "=r"(value)
        : "r"(buffer), "r"(offset)
        : "rax", "rbx", "memory"
    End Assembly
    
    Return value
End Process

Process called "read_byte_at_offset" that takes buffer as Integer, offset as Integer returns Integer:
    Let value be Integer
    
    Inline Assembly:
        "mov rax, %1\n"
        "add rax, %2\n"
        "movzx rbx, byte [rax]\n"
        "mov %0, rbx\n"
        : "=r"(value)
        : "r"(buffer), "r"(offset)
        : "rax", "rbx", "memory"
    End Assembly
    
    Return value
End Process

Process called "write_byte_at_offset" that takes buffer as Integer, offset as Integer, value as Integer:
    Inline Assembly:
        "mov rax, %0\n"
        "add rax, %1\n"
        "mov bl, %2b\n"
        "mov [rax], bl\n"
        :
        : "r"(buffer), "r"(offset), "r"(value)
        : "rax", "rbx", "memory"
    End Assembly
End Process

Note: String utilities
Process called "read_string_at_offset" that takes buffer as Integer, offset as Integer, max_len as Integer returns String:
    Let str_buffer be allocate_string_buffer(max_len + 1)
    
    Let i be 0
    While i < max_len:
        Let char be read_byte_at_offset(buffer, offset + i)
        If char equals 0:
            Break
        End If
        write_byte_at_offset(str_buffer, i, char)
        Set i to i + 1
    End While
    
    write_byte_at_offset(str_buffer, i, 0)
    Return create_string_from_buffer(str_buffer, i)
End Process

Process called "allocate_string_buffer" that takes size as Integer returns Integer:
    Return allocate_buffer(size)
End Process

Process called "create_string_from_buffer" that takes buffer as Integer, length as Integer returns String:
    Note: Create Runa string from buffer
    Return ""  Note: Actual implementation creates proper string
End Process

Process called "string_length" that takes str as String returns Integer:
    Let len be 0
    While char_at(str, len) does not equal 0:
        Set len to len + 1
    End While
    Return len
End Process

Process called "string_length_at" that takes buffer as Integer returns Integer:
    Let len be 0
    While read_byte_at_offset(buffer, len) does not equal 0:
        Set len to len + 1
    End While
    Return len
End Process

Process called "char_at" that takes str as String, index as Integer returns Integer:
    Let ptr be get_string_pointer(str)
    Return read_byte_at_offset(ptr, index)
End Process

Process called "get_string_pointer" that takes str as String returns Integer:
    Let ptr be Integer
    Inline Assembly:
        "lea rax, [%1]\n"
        "mov %0, rax\n"
        : "=r"(ptr)
        : "m"(str)
        : "rax"
    End Assembly
    Return ptr
End Process

Process called "string_to_int" that takes str as String returns Integer:
    Note: Convert string to integer representation for storage
    Return get_string_pointer(str)
End Process