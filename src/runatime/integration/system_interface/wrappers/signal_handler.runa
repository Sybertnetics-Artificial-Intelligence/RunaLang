Note: Signal Handler Wrapper - Direct syscall interface for signal management
Note: Provides self-contained signal handling without stdlib dependencies

@Reasoning
The signal handler wrapper provides direct syscall access for signal management
operations. This is essential for the compiler to handle interrupts, manage
child process signals, and implement proper cleanup on termination without
relying on any stdlib functionality.
@End Reasoning

Import module "compiler/frontend/primitives/types/compiler_internals" as "Internals"

Note: =====================================================================
Note: SIGNAL CONSTANTS
Note: =====================================================================

Note: Standard POSIX signals
Let SIGHUP be 1      Note: Hangup
Let SIGINT be 2      Note: Interrupt (Ctrl+C)
Let SIGQUIT be 3     Note: Quit
Let SIGILL be 4      Note: Illegal instruction
Let SIGTRAP be 5     Note: Trace trap
Let SIGABRT be 6     Note: Abort
Let SIGBUS be 7      Note: Bus error
Let SIGFPE be 8      Note: Floating-point exception
Let SIGKILL be 9     Note: Kill (cannot be caught)
Let SIGUSR1 be 10    Note: User-defined signal 1
Let SIGSEGV be 11    Note: Segmentation fault
Let SIGUSR2 be 12    Note: User-defined signal 2
Let SIGPIPE be 13    Note: Broken pipe
Let SIGALRM be 14    Note: Alarm clock
Let SIGTERM be 15    Note: Termination
Let SIGSTKFLT be 16  Note: Stack fault
Let SIGCHLD be 17    Note: Child status changed
Let SIGCONT be 18    Note: Continue
Let SIGSTOP be 19    Note: Stop (cannot be caught)
Let SIGTSTP be 20    Note: Terminal stop
Let SIGTTIN be 21    Note: Background read from terminal
Let SIGTTOU be 22    Note: Background write to terminal
Let SIGURG be 23     Note: Urgent socket condition
Let SIGXCPU be 24    Note: CPU time limit exceeded
Let SIGXFSZ be 25    Note: File size limit exceeded
Let SIGVTALRM be 26  Note: Virtual timer expired
Let SIGPROF be 27    Note: Profiling timer expired
Let SIGWINCH be 28   Note: Window size changed
Let SIGIO be 29      Note: I/O possible
Let SIGPWR be 30     Note: Power failure
Let SIGSYS be 31     Note: Bad system call

Note: Signal action flags
Let SA_NOCLDSTOP be 0x00000001
Let SA_NOCLDWAIT be 0x00000002
Let SA_SIGINFO be 0x00000004
Let SA_RESTORER be 0x04000000
Let SA_ONSTACK be 0x08000000
Let SA_RESTART be 0x10000000
Let SA_NODEFER be 0x40000000
Let SA_RESETHAND be 0x80000000

Note: =====================================================================
Note: SIGNAL STRUCTURES
Note: =====================================================================

Type called "SignalAction":
    handler as Integer                    Note: Pointer to signal handler function
    flags as Integer                      Note: Signal action flags
    restorer as Integer                   Note: Signal trampoline (usually NULL)
    mask as SignalSet                     Note: Signals to block during handler
End Type

Type called "SignalSet":
    signals as Internals.InternalArray    Note: Bitmask of signals (128 bits)
End Type

Type called "SignalInfo":
    signal_number as Integer              Note: Signal number
    error_code as Integer                 Note: Error code
    sending_pid as Integer                Note: PID of sending process
    sending_uid as Integer                Note: UID of sending process
    status as Integer                     Note: Exit value or signal
    address as Integer                    Note: Faulting address (for SIGSEGV/SIGBUS)
End Type

Note: =====================================================================
Note: SIGNAL SET OPERATIONS
Note: =====================================================================

Note: Create empty signal set
Process called "create_empty_signal_set" returns SignalSet:
    @Implementation
    Creates an empty signal set with no signals included.
    @End Implementation
    
    Let set be SignalSet
    Set set.signals to Internals.create_internal_array(2)  Note: 128 bits = 2 * 64-bit
    Internals.internal_array_set(set.signals, 0, 0)
    Internals.internal_array_set(set.signals, 1, 0)
    Return set
End Process

Note: Create full signal set
Process called "create_full_signal_set" returns SignalSet:
    @Implementation
    Creates a signal set with all signals included.
    @End Implementation
    
    Let set be SignalSet
    Set set.signals to Internals.create_internal_array(2)
    Internals.internal_array_set(set.signals, 0, -1)  Note: All bits set
    Internals.internal_array_set(set.signals, 1, -1)
    Return set
End Process

Note: Add signal to set
Process called "add_signal_to_set" that takes set as SignalSet, signal as Integer:
    @Implementation
    Adds a specific signal to the signal set.
    @End Implementation
    
    If signal < 1 or signal > 64:
        Return  Note: Invalid signal number
    End If
    
    Let index be (signal - 1) / 64
    Let bit be (signal - 1) % 64
    Let current be Internals.internal_array_get(set.signals, index)
    Let mask be 1 << bit
    Internals.internal_array_set(set.signals, index, current | mask)
End Process

Note: Remove signal from set
Process called "remove_signal_from_set" that takes set as SignalSet, signal as Integer:
    @Implementation
    Removes a specific signal from the signal set.
    @End Implementation
    
    If signal < 1 or signal > 64:
        Return
    End If
    
    Let index be (signal - 1) / 64
    Let bit be (signal - 1) % 64
    Let current be Internals.internal_array_get(set.signals, index)
    Let mask be ~(1 << bit)
    Internals.internal_array_set(set.signals, index, current & mask)
End Process

Note: Check if signal is in set
Process called "is_signal_in_set" that takes set as SignalSet, signal as Integer returns Boolean:
    @Implementation
    Checks if a specific signal is included in the signal set.
    @End Implementation
    
    If signal < 1 or signal > 64:
        Return false
    End If
    
    Let index be (signal - 1) / 64
    Let bit be (signal - 1) % 64
    Let current be Internals.internal_array_get(set.signals, index)
    Let mask be 1 << bit
    
    Return (current & mask) does not equal 0
End Process

Note: =====================================================================
Note: SIGNAL MASKING
Note: =====================================================================

Note: Block signals
Process called "block_signals" that takes set as SignalSet returns Integer:
    @Implementation
    Blocks the specified signals using sigprocmask syscall.
    @End Implementation
    
    Let result be Integer
    Let SIG_BLOCK be 0
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: SIG_BLOCK
        "lea rsi, [%2]\n"         Note: New signal set
        "xor rdx, rdx\n"          Note: Old signal set (NULL)
        "mov r10, 8\n"            Note: Size of sigset_t
        "mov rax, 14\n"           Note: rt_sigprocmask syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(SIG_BLOCK), "m"(set.signals)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Unblock signals
Process called "unblock_signals" that takes set as SignalSet returns Integer:
    @Implementation
    Unblocks the specified signals using sigprocmask syscall.
    @End Implementation
    
    Let result be Integer
    Let SIG_UNBLOCK be 1
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: SIG_UNBLOCK
        "lea rsi, [%2]\n"         Note: New signal set
        "xor rdx, rdx\n"          Note: Old signal set (NULL)
        "mov r10, 8\n"            Note: Size of sigset_t
        "mov rax, 14\n"           Note: rt_sigprocmask syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(SIG_UNBLOCK), "m"(set.signals)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Set signal mask
Process called "set_signal_mask" that takes set as SignalSet returns SignalSet:
    @Implementation
    Sets the signal mask and returns the previous mask.
    @End Implementation
    
    Let old_set be create_empty_signal_set()
    Let result be Integer
    Let SIG_SETMASK be 2
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: SIG_SETMASK
        "lea rsi, [%2]\n"         Note: New signal set
        "lea rdx, [%3]\n"         Note: Old signal set
        "mov r10, 8\n"            Note: Size of sigset_t
        "mov rax, 14\n"           Note: rt_sigprocmask syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(SIG_SETMASK), "m"(set.signals), "m"(old_set.signals)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return old_set
End Process

Note: =====================================================================
Note: SIGNAL HANDLERS
Note: =====================================================================

Note: Install signal handler
Process called "install_signal_handler" that takes signal as Integer, handler as Integer, flags as Integer returns Integer:
    @Implementation
    Installs a signal handler using rt_sigaction syscall.
    Handler is a function pointer that will be called when signal is received.
    @End Implementation
    
    Let action be SignalAction
    Set action.handler to handler
    Set action.flags to flags | SA_RESTORER
    Set action.restorer to get_signal_restorer()
    Set action.mask to create_empty_signal_set()
    
    Let result be Integer
    
    Inline Assembly:
        "sub rsp, 152\n"          Note: Allocate sigaction struct
        "mov rax, %1\n"           Note: Handler
        "mov [rsp], rax\n"
        "mov rax, %2\n"           Note: Flags
        "mov [rsp+8], rax\n"
        "mov rax, %3\n"           Note: Restorer
        "mov [rsp+16], rax\n"
        "xor rax, rax\n"          Note: Clear signal mask
        "mov [rsp+24], rax\n"
        "mov [rsp+32], rax\n"
        "mov rdi, %4\n"           Note: Signal number
        "mov rsi, rsp\n"          Note: New action
        "xor rdx, rdx\n"          Note: Old action (NULL)
        "mov r10, 8\n"            Note: Size of sigset_t
        "mov rax, 13\n"           Note: rt_sigaction syscall
        "syscall\n"
        "mov %0, rax\n"
        "add rsp, 152\n"
        : "=r"(result)
        : "r"(handler), "r"(flags | SA_RESTORER), "r"(get_signal_restorer()), "r"(signal)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Note: Ignore signal
Process called "ignore_signal" that takes signal as Integer returns Integer:
    @Implementation
    Sets signal handler to SIG_IGN to ignore the signal.
    @End Implementation
    
    Let SIG_IGN be 1
    Return install_signal_handler(signal, SIG_IGN, 0)
End Process

Note: Reset signal to default
Process called "reset_signal" that takes signal as Integer returns Integer:
    @Implementation
    Resets signal handler to SIG_DFL (default action).
    @End Implementation
    
    Let SIG_DFL be 0
    Return install_signal_handler(signal, SIG_DFL, 0)
End Process

Note: =====================================================================
Note: SIGNAL SENDING
Note: =====================================================================

Note: Send signal to self
Process called "raise_signal" that takes signal as Integer returns Integer:
    @Implementation
    Sends a signal to the current process using raise/kill syscall.
    @End Implementation
    
    Let pid be Integer
    
    Note: Get current PID
    Inline Assembly:
        "mov rax, 39\n"           Note: getpid syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(pid)
        :
        : "rax", "rcx", "r11"
    End Assembly
    
    Note: Send signal to self
    Let result be Integer
    Inline Assembly:
        "mov rdi, %1\n"           Note: PID
        "mov rsi, %2\n"           Note: Signal
        "mov rax, 62\n"           Note: kill syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(pid), "r"(signal)
        : "rax", "rdi", "rsi", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Note: Send signal to thread
Process called "send_signal_to_thread" that takes tid as Integer, signal as Integer returns Integer:
    @Implementation
    Sends a signal to a specific thread using tkill syscall.
    @End Implementation
    
    Let result be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"           Note: Thread ID
        "mov rsi, %2\n"           Note: Signal
        "mov rax, 200\n"          Note: tkill syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(tid), "r"(signal)
        : "rax", "rdi", "rsi", "rcx", "r11"
    End Assembly
    
    Return result
End Process

Note: =====================================================================
Note: SIGNAL WAITING
Note: =====================================================================

Note: Wait for signal
Process called "wait_for_signal" that takes set as SignalSet returns SignalInfo:
    @Implementation
    Waits for one of the signals in the set using sigwaitinfo syscall.
    @End Implementation
    
    Let info be SignalInfo
    Let siginfo_buffer be allocate_siginfo_buffer()
    
    Let result be Integer
    Inline Assembly:
        "lea rdi, [%1]\n"         Note: Signal set
        "mov rsi, %2\n"           Note: siginfo pointer
        "xor rdx, rdx\n"          Note: Timeout (NULL = infinite)
        "mov r10, 8\n"            Note: Size of sigset_t
        "mov rax, 128\n"          Note: rt_sigtimedwait syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "m"(set.signals), "r"(siginfo_buffer)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    If result > 0:
        parse_siginfo_buffer(siginfo_buffer, info)
    End If
    
    Return info
End Process

Note: Wait for signal with timeout
Process called "wait_for_signal_timeout" that takes set as SignalSet, timeout_ns as Integer returns SignalInfo:
    @Implementation
    Waits for a signal with a timeout using rt_sigtimedwait syscall.
    @End Implementation
    
    Let info be SignalInfo
    Let siginfo_buffer be allocate_siginfo_buffer()
    
    Let timeout_sec be timeout_ns / 1000000000
    Let timeout_nsec be timeout_ns % 1000000000
    
    Let result be Integer
    Inline Assembly:
        "sub rsp, 16\n"           Note: Allocate timespec
        "mov rax, %3\n"           Note: Seconds
        "mov [rsp], rax\n"
        "mov rax, %4\n"           Note: Nanoseconds
        "mov [rsp+8], rax\n"
        "lea rdi, [%1]\n"         Note: Signal set
        "mov rsi, %2\n"           Note: siginfo pointer
        "mov rdx, rsp\n"          Note: Timeout
        "mov r10, 8\n"            Note: Size of sigset_t
        "mov rax, 128\n"          Note: rt_sigtimedwait syscall
        "syscall\n"
        "mov %0, rax\n"
        "add rsp, 16\n"
        : "=r"(result)
        : "m"(set.signals), "r"(siginfo_buffer), "r"(timeout_sec), "r"(timeout_nsec)
        : "rax", "rdi", "rsi", "rdx", "r10", "rcx", "r11", "memory"
    End Assembly
    
    If result > 0:
        parse_siginfo_buffer(siginfo_buffer, info)
    End If
    
    Return info
End Process

Note: =====================================================================
Note: SIGNAL SUSPENSION
Note: =====================================================================

Note: Suspend until signal
Process called "suspend_until_signal":
    @Implementation
    Suspends process execution until a signal is received using pause syscall.
    @End Implementation
    
    Inline Assembly:
        "mov rax, 34\n"           Note: pause syscall
        "syscall\n"
        :
        :
        : "rax", "rcx", "r11"
    End Assembly
End Process

Note: Suspend with signal mask
Process called "suspend_with_mask" that takes mask as SignalSet:
    @Implementation
    Atomically sets signal mask and suspends using sigsuspend syscall.
    @End Implementation
    
    Inline Assembly:
        "lea rdi, [%0]\n"         Note: Signal mask
        "mov rsi, 8\n"            Note: Size of sigset_t
        "mov rax, 130\n"          Note: rt_sigsuspend syscall
        "syscall\n"
        :
        : "m"(mask.signals)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Note: Get signal restorer address
Process called "get_signal_restorer" returns Integer:
    @Implementation
    Returns the address of the signal restorer trampoline.
    This is platform-specific code that restores state after signal handler.
    @End Implementation
    
    Let restorer be Integer
    
    Inline Assembly:
        "lea rax, [rip + signal_restorer]\n"
        "mov %0, rax\n"
        "jmp signal_restorer_end\n"
        "signal_restorer:\n"
        "mov rax, 15\n"           Note: rt_sigreturn syscall
        "syscall\n"
        "signal_restorer_end:\n"
        : "=r"(restorer)
        :
        : "rax"
    End Assembly
    
    Return restorer
End Process

Note: Allocate siginfo buffer
Process called "allocate_siginfo_buffer" returns Integer:
    Let siginfo_size be 128  Note: sizeof(siginfo_t)
    Let buffer be Integer
    
    Inline Assembly:
        "mov rdi, %1\n"
        "mov rax, 9\n"            Note: mmap
        "xor rsi, rsi\n"
        "mov rdx, 3\n"            Note: PROT_READ | PROT_WRITE
        "mov r10, 0x22\n"         Note: MAP_PRIVATE | MAP_ANONYMOUS
        "mov r8, -1\n"
        "xor r9, r9\n"
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(buffer)
        : "r"(siginfo_size)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Return buffer
End Process

Note: Parse siginfo buffer
Process called "parse_siginfo_buffer" that takes buffer as Integer, info as SignalInfo:
    @Implementation
    Extracts signal information from siginfo_t structure.
    @End Implementation
    
    Inline Assembly:
        "mov rax, %1\n"           Note: Buffer address
        "mov rbx, [rax]\n"        Note: si_signo
        "mov %0, rbx\n"
        "mov rbx, [rax+4]\n"      Note: si_errno
        "mov %2, rbx\n"
        "mov rbx, [rax+8]\n"      Note: si_code
        "mov %3, rbx\n"
        "mov rbx, [rax+16]\n"     Note: si_pid
        "mov %4, rbx\n"
        "mov rbx, [rax+20]\n"     Note: si_uid
        "mov %5, rbx\n"
        : "=m"(info.signal_number), "=m"(info.error_code), "=m"(info.status),
          "=m"(info.sending_pid), "=m"(info.sending_uid)
        : "r"(buffer)
        : "rax", "rbx", "memory"
    End Assembly
End Process

Note: Block all signals temporarily
Process called "block_all_signals" returns SignalSet:
    @Implementation
    Blocks all signals and returns the previous mask for restoration.
    @End Implementation
    
    Let full_set be create_full_signal_set()
    Return set_signal_mask(full_set)
End Process

Note: Restore signal mask
Process called "restore_signal_mask" that takes old_mask as SignalSet:
    @Implementation
    Restores a previously saved signal mask.
    @End Implementation
    
    set_signal_mask(old_mask)
End Process