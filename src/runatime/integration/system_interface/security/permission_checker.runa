Note:
security/permission_checker.runa - Syscall Permission Validation System

This module provides comprehensive syscall permission checking and validation
for secure system operation. It enforces allowlists, blocklists, and capability-based
access control to prevent unauthorized system calls and maintain sandbox security.

@Reasoning
Syscall permission checking is critical for system security. Unrestricted system
calls can be used for privilege escalation, data exfiltration, or system compromise.
This module provides defense-in-depth by validating each syscall against security
policies before execution, supporting both process-level and user-level restrictions.
@End Reasoning

@Implementation
The permission checker uses a multi-layered approach:
1. Static allowlist/blocklist checking for known safe/unsafe syscalls
2. Dynamic capability checking based on process privileges
3. Context-aware validation using process state and arguments
4. Platform-specific security model integration (seccomp, sandbox-exec, etc.)
@End Implementation

@Performance_Hints
Permission checking is done synchronously before syscall execution and must be
fast to avoid significant overhead. Most checks use hash table lookups and
bitwise operations. Complex policy evaluation is cached when possible.
@End Performance_Hints

@Security_Scope
This module is part of the core security infrastructure. All code must be
written defensively with proper input validation and fail-safe defaults.
Any permission check failure should deny access rather than permit it.
@End Security_Scope
:End Note

Import module "compiler/frontend/primitives/types/compiler_internals" as Internals
Import module "compiler/backend/syscalls/syscall_registry" as Registry

Note: =====================================================================
Note: PERMISSION LEVELS AND CAPABILITIES
Note: =====================================================================

Type PermissionLevel is:
    | Unrestricted              Note: Full system access (root/admin)
    | Privileged                Note: Elevated permissions (sudo)
    | Standard                  Note: Normal user permissions
    | Restricted                Note: Limited sandbox permissions
    | Minimal                   Note: Highly restricted (read-only)
End Type

Type called "Capability":
    name as String              Note: Capability name
    value as Integer            Note: Capability bitmask
    description as String       Note: Human-readable description
End Type

Note: Capability bit flags
Constant CAP_FILE_READ as Integer is 1
Constant CAP_FILE_WRITE as Integer is 2
Constant CAP_FILE_EXECUTE as Integer is 4
Constant CAP_NETWORK_CONNECT as Integer is 8
Constant CAP_NETWORK_LISTEN as Integer is 16
Constant CAP_PROCESS_FORK as Integer is 32
Constant CAP_PROCESS_EXEC as Integer is 64
Constant CAP_MEMORY_MAP as Integer is 128
Constant CAP_SYSTEM_TIME as Integer is 256
Constant CAP_DEVICE_ACCESS as Integer is 512
Constant CAP_IPC as Integer is 1024
Constant CAP_SIGNALS as Integer is 2048
Constant CAP_PTRACE as Integer is 4096
Constant CAP_CHROOT as Integer is 8192
Constant CAP_RAW_IO as Integer is 16384

Note: =====================================================================
Note: SECURITY POLICY STRUCTURES
Note: =====================================================================

Type called "SecurityPolicy":
    permission_level as PermissionLevel
    capabilities as Integer                Note: Bitmask of allowed capabilities
    allowed_syscalls as Internals.InternalMap   Note: Allowlist of syscalls
    blocked_syscalls as Internals.InternalMap   Note: Blocklist of syscalls
    path_restrictions as Internals.InternalArray Note: Restricted paths
    network_restrictions as NetworkPolicy
    resource_limits as ResourceLimits
    audit_level as AuditLevel
End Type

Type called "NetworkPolicy":
    allow_outbound as Boolean
    allow_inbound as Boolean
    allowed_ports as Internals.InternalArray
    blocked_ips as Internals.InternalArray
    max_connections as Integer
End Type

Type called "ResourceLimits":
    max_memory_mb as Integer
    max_cpu_percent as Integer
    max_file_descriptors as Integer
    max_processes as Integer
    max_file_size_mb as Integer
End Type

Type AuditLevel is:
    | None                      Note: No auditing
    | Failures                  Note: Log only failures
    | Sensitive                 Note: Log sensitive operations
    | All                       Note: Log all operations
End Type

Type called "PermissionCheckResult":
    allowed as Boolean
    reason as String
    audit_required as Boolean
    suggested_alternative as String
End Type

Note: =====================================================================
Note: PERMISSION CHECKER STATE
Note: =====================================================================

Type called "PermissionChecker":
    current_policy as SecurityPolicy
    policy_cache as Internals.InternalMap   Note: Cached policy evaluations
    syscall_stats as Internals.InternalMap   Note: Syscall usage statistics
    audit_log as Internals.InternalArray     Note: Audit trail
    lock as Integer                          Note: Thread safety lock
    enabled as Boolean                       Note: Whether checking is active
    strict_mode as Boolean                   Note: Fail-closed mode
End Type

Note: =====================================================================
Note: INITIALIZATION
Note: =====================================================================

Process called "create_permission_checker" returns PermissionChecker:
    @Security_Scope
    Initializes with restrictive defaults for security.
    @End Security_Scope
    
    Let checker be PermissionChecker()
    Set checker.current_policy to create_default_policy()
    Set checker.policy_cache to Internals.create_internal_map(256)
    Set checker.syscall_stats to Internals.create_internal_map(128)
    Set checker.audit_log to Internals.create_internal_array(1024)
    Set checker.lock to 0
    Set checker.enabled to true
    Set checker.strict_mode to true  Note: Fail-closed by default
    
    Return checker
End Process

Process called "create_default_policy" returns SecurityPolicy:
    @Security_Scope
    Creates a restrictive default policy for standard processes.
    @End Security_Scope
    
    Let policy be SecurityPolicy()
    Set policy.permission_level to PermissionLevel.Standard
    Set policy.capabilities to CAP_FILE_READ or CAP_FILE_WRITE or CAP_NETWORK_CONNECT
    Set policy.allowed_syscalls to create_standard_allowlist()
    Set policy.blocked_syscalls to create_standard_blocklist()
    Set policy.path_restrictions to create_path_restrictions()
    
    Let net_policy be NetworkPolicy()
    Set net_policy.allow_outbound to true
    Set net_policy.allow_inbound to false
    Set net_policy.allowed_ports to Internals.create_internal_array(10)
    Set net_policy.blocked_ips to Internals.create_internal_array(10)
    Set net_policy.max_connections to 100
    Set policy.network_restrictions to net_policy
    
    Let limits be ResourceLimits()
    Set limits.max_memory_mb to 1024
    Set limits.max_cpu_percent to 80
    Set limits.max_file_descriptors to 1024
    Set limits.max_processes to 100
    Set limits.max_file_size_mb to 100
    Set policy.resource_limits to limits
    
    Set policy.audit_level to AuditLevel.Sensitive
    
    Return policy
End Process

Note: =====================================================================
Note: PERMISSION CHECKING
Note: =====================================================================

Process called "check_syscall_permission" that takes checker as PermissionChecker, syscall_name as String, args as Internals.InternalArray returns PermissionCheckResult:
    @Security_Scope
    Main entry point for syscall permission validation.
    Performs multi-layer security checks.
    @End Security_Scope
    
    If not checker.enabled:
        Return create_result(true, "Checker disabled", false, "")
    End If
    
    acquire_lock(address_of(checker.lock))
    
    Note: Check cache first
    Let cache_key be generate_cache_key(syscall_name, args)
    Let cached_result be Internals.internal_map_get(checker.policy_cache, cache_key)
    If cached_result not equals minus 1:
        release_lock(address_of(checker.lock))
        Return ptr_to_result(cached_result)
    End If
    
    Note: Layer 1: Check blocklist
    If is_blocked_syscall(checker, syscall_name):
        Let result be create_result(false, "Syscall is blocked", true, "")
        cache_result(checker, cache_key, result)
        update_stats(checker, syscall_name, false)
        audit_if_required(checker, syscall_name, args, false, "Blocked syscall")
        release_lock(address_of(checker.lock))
        Return result
    End If
    
    Note: Layer 2: Check allowlist
    If not is_allowed_syscall(checker, syscall_name):
        Let result be create_result(false, "Syscall not in allowlist", true, "")
        cache_result(checker, cache_key, result)
        update_stats(checker, syscall_name, false)
        audit_if_required(checker, syscall_name, args, false, "Not allowlisted")
        release_lock(address_of(checker.lock))
        Return result
    End If
    
    Note: Layer 3: Check capabilities
    Let required_caps be get_required_capabilities(syscall_name)
    If not has_capabilities(checker.current_policy.capabilities, required_caps):
        Let result be create_result(false, "Insufficient capabilities", true, suggest_alternative(syscall_name))
        cache_result(checker, cache_key, result)
        update_stats(checker, syscall_name, false)
        audit_if_required(checker, syscall_name, args, false, "Capability denied")
        release_lock(address_of(checker.lock))
        Return result
    End If
    
    Note: Layer 4: Context-aware validation
    Let context_check be validate_syscall_context(checker, syscall_name, args)
    If not context_check.allowed:
        cache_result(checker, cache_key, context_check)
        update_stats(checker, syscall_name, false)
        audit_if_required(checker, syscall_name, args, false, context_check.reason)
        release_lock(address_of(checker.lock))
        Return context_check
    End If
    
    Note: Layer 5: Resource limit checks
    If exceeds_resource_limits(checker, syscall_name, args):
        Let result be create_result(false, "Resource limit exceeded", true, "")
        cache_result(checker, cache_key, result)
        update_stats(checker, syscall_name, false)
        audit_if_required(checker, syscall_name, args, false, "Resource limit")
        release_lock(address_of(checker.lock))
        Return result
    End If
    
    Note: Permission granted
    Let result be create_result(true, "Permission granted", should_audit(checker, syscall_name), "")
    cache_result(checker, cache_key, result)
    update_stats(checker, syscall_name, true)
    audit_if_required(checker, syscall_name, args, true, "Allowed")
    
    release_lock(address_of(checker.lock))
    Return result
End Process

Process called "validate_syscall_context" that takes checker as PermissionChecker, syscall_name as String, args as Internals.InternalArray returns PermissionCheckResult:
    @Security_Scope
    Performs context-aware validation based on syscall arguments.
    @End Security_Scope
    
    Note: File system operations
    If syscall_name equals Registry.SYSCALL_OPEN or syscall_name equals Registry.SYSCALL_STAT:
        If args.length greater than 0:
            Let path be get_string_arg(args, 0)
            If is_restricted_path(checker, path):
                Return create_result(false, "Access to restricted path", true, "")
            End If
        End If
    End If
    
    Note: Network operations
    If syscall_name equals Registry.SYSCALL_CONNECT or syscall_name equals Registry.SYSCALL_BIND:
        If not checker.current_policy.network_restrictions.allow_outbound:
            If syscall_name equals Registry.SYSCALL_CONNECT:
                Return create_result(false, "Outbound connections not allowed", true, "")
            End If
        End If
        If not checker.current_policy.network_restrictions.allow_inbound:
            If syscall_name equals Registry.SYSCALL_BIND:
                Return create_result(false, "Inbound connections not allowed", true, "")
            End If
        End If
        
        Note: Check port restrictions
        If args.length greater than or equal to 2:
            Let port be get_port_from_sockaddr(args, 1)
            If is_blocked_port(checker, port):
                Return create_result(false, "Port is blocked", true, "")
            End If
        End If
    End If
    
    Note: Process operations
    If syscall_name equals Registry.SYSCALL_EXECVE:
        If args.length greater than 0:
            Let program be get_string_arg(args, 0)
            If is_dangerous_program(program):
                Return create_result(false, "Execution of dangerous program blocked", true, "")
            End If
        End If
    End If
    
    Note: Memory operations
    If syscall_name equals Registry.SYSCALL_MMAP:
        If args.length greater than or equal to 3:
            Let prot be Internals.internal_array_get(args, 2)
            Note: Check for executable memory mapping
            If (prot bitwise_and 4) not equals 0:  Note: PROT_EXEC
                If not has_capability(checker.current_policy.capabilities, CAP_FILE_EXECUTE):
                    Return create_result(false, "Executable memory mapping denied", true, "")
                End If
            End If
        End If
    End If
    
    Return create_result(true, "Context validation passed", false, "")
End Process

Note: =====================================================================
Note: ALLOWLIST/BLOCKLIST MANAGEMENT
Note: =====================================================================

Process called "create_standard_allowlist" returns Internals.InternalMap:
    @Security_Scope
    Creates allowlist of safe syscalls for standard processes.
    @End Security_Scope
    
    Let allowlist be Internals.create_internal_map(128)
    
    Note: File operations (read-only safe)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_READ, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_STAT, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_FSTAT, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_LSTAT, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_LSEEK, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_CLOSE, 1)
    
    Note: File operations (write - conditional)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_WRITE, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_OPEN, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_FSYNC, 1)
    
    Note: Process info (safe)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_GETPID, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_GETPPID, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_GETUID, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_GETEUID, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_GETGID, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_GETEGID, 1)
    
    Note: Time operations (safe)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_TIME, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_GETTIMEOFDAY, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_CLOCK_GETTIME, 1)
    
    Note: Memory operations (conditional)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_BRK, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_MMAP, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_MUNMAP, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_MPROTECT, 1)
    
    Note: Network operations (conditional)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_SOCKET, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_CONNECT, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_SEND, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_RECV, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_POLL, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_SELECT, 1)
    
    Note: Process control (conditional)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_EXIT, 1)
    Internals.internal_map_set(allowlist, Registry.SYSCALL_EXIT_GROUP, 1)
    
    Return allowlist
End Process

Process called "create_standard_blocklist" returns Internals.InternalMap:
    @Security_Scope
    Creates blocklist of dangerous syscalls always denied.
    @End Security_Scope
    
    Let blocklist be Internals.create_internal_map(64)
    
    Note: Privilege escalation risks
    Internals.internal_map_set(blocklist, Registry.SYSCALL_SETUID, 1)
    Internals.internal_map_set(blocklist, Registry.SYSCALL_SETGID, 1)
    Internals.internal_map_set(blocklist, "setreuid", 1)
    Internals.internal_map_set(blocklist, "setregid", 1)
    Internals.internal_map_set(blocklist, "setresuid", 1)
    Internals.internal_map_set(blocklist, "setresgid", 1)
    
    Note: Kernel module operations
    Internals.internal_map_set(blocklist, "init_module", 1)
    Internals.internal_map_set(blocklist, "finit_module", 1)
    Internals.internal_map_set(blocklist, "delete_module", 1)
    
    Note: System control
    Internals.internal_map_set(blocklist, "reboot", 1)
    Internals.internal_map_set(blocklist, "kexec_load", 1)
    Internals.internal_map_set(blocklist, "kexec_file_load", 1)
    
    Note: Dangerous IPC
    Internals.internal_map_set(blocklist, "ptrace", 1)
    Internals.internal_map_set(blocklist, "process_vm_readv", 1)
    Internals.internal_map_set(blocklist, "process_vm_writev", 1)
    
    Note: Raw device access
    Internals.internal_map_set(blocklist, "ioperm", 1)
    Internals.internal_map_set(blocklist, "iopl", 1)
    
    Note: Namespace operations
    Internals.internal_map_set(blocklist, "mount", 1)
    Internals.internal_map_set(blocklist, "umount", 1)
    Internals.internal_map_set(blocklist, "pivot_root", 1)
    Internals.internal_map_set(blocklist, "chroot", 1)
    
    Return blocklist
End Process

Process called "create_path_restrictions" returns Internals.InternalArray:
    @Security_Scope
    Creates list of restricted file system paths.
    @End Security_Scope
    
    Let restrictions be Internals.create_internal_array(20)
    
    Note: System directories
    add_path_restriction(restrictions, "/etc/shadow")
    add_path_restriction(restrictions, "/etc/passwd")
    add_path_restriction(restrictions, "/etc/sudoers")
    add_path_restriction(restrictions, "/boot")
    add_path_restriction(restrictions, "/sys")
    add_path_restriction(restrictions, "/proc/sys")
    add_path_restriction(restrictions, "/dev")
    
    Note: Security-sensitive files
    add_path_restriction(restrictions, "/root")
    add_path_restriction(restrictions, "/.ssh")
    add_path_restriction(restrictions, "/.gnupg")
    
    Return restrictions
End Process

Note: =====================================================================
Note: CAPABILITY CHECKING
Note: =====================================================================

Process called "get_required_capabilities" that takes syscall_name as String returns Integer:
    @Security_Scope
    Maps syscalls to required capabilities.
    @End Security_Scope
    
    If syscall_name equals Registry.SYSCALL_READ:
        Return CAP_FILE_READ
    End If
    If syscall_name equals Registry.SYSCALL_WRITE:
        Return CAP_FILE_WRITE
    End If
    If syscall_name equals Registry.SYSCALL_EXECVE:
        Return CAP_PROCESS_EXEC
    End If
    If syscall_name equals Registry.SYSCALL_FORK or syscall_name equals Registry.SYSCALL_VFORK:
        Return CAP_PROCESS_FORK
    End If
    If syscall_name equals Registry.SYSCALL_CONNECT or syscall_name equals Registry.SYSCALL_SEND:
        Return CAP_NETWORK_CONNECT
    End If
    If syscall_name equals Registry.SYSCALL_BIND or syscall_name equals Registry.SYSCALL_LISTEN:
        Return CAP_NETWORK_LISTEN
    End If
    If syscall_name equals Registry.SYSCALL_MMAP:
        Return CAP_MEMORY_MAP
    End If
    If syscall_name equals Registry.SYSCALL_SETTIMEOFDAY or syscall_name equals Registry.SYSCALL_CLOCK_SETTIME:
        Return CAP_SYSTEM_TIME
    End If
    If syscall_name equals Registry.SYSCALL_IOCTL:
        Return CAP_DEVICE_ACCESS
    End If
    If syscall_name equals Registry.SYSCALL_KILL:
        Return CAP_SIGNALS
    End If
    If syscall_name equals "ptrace":
        Return CAP_PTRACE
    End If
    If syscall_name equals "chroot":
        Return CAP_CHROOT
    End If
    
    Return 0  Note: No special capability required
End Process

Process called "has_capabilities" that takes current_caps as Integer, required_caps as Integer returns Boolean:
    @Security_Scope
    Checks if current capabilities include required ones.
    @End Security_Scope
    
    Return (current_caps bitwise_and required_caps) equals required_caps
End Process

Process called "has_capability" that takes current_caps as Integer, capability as Integer returns Boolean:
    @Security_Scope
    Checks for a single capability.
    @End Security_Scope
    
    Return (current_caps bitwise_and capability) not equals 0
End Process

Note: =====================================================================
Note: RESOURCE LIMIT CHECKING
Note: =====================================================================

Process called "exceeds_resource_limits" that takes checker as PermissionChecker, syscall_name as String, args as Internals.InternalArray returns Boolean:
    @Security_Scope
    Checks if syscall would exceed resource limits.
    @End Security_Scope
    
    Let limits be checker.current_policy.resource_limits
    
    Note: Check file descriptor limit
    If syscall_name equals Registry.SYSCALL_OPEN or syscall_name equals Registry.SYSCALL_SOCKET:
        If get_open_fd_count() greater than or equal to limits.max_file_descriptors:
            Return true
        End If
    End If
    
    Note: Check process limit
    If syscall_name equals Registry.SYSCALL_FORK or syscall_name equals Registry.SYSCALL_VFORK:
        If get_process_count() greater than or equal to limits.max_processes:
            Return true
        End If
    End If
    
    Note: Check memory limit
    If syscall_name equals Registry.SYSCALL_MMAP:
        If args.length greater than or equal to 2:
            Let size be Internals.internal_array_get(args, 1)
            Let current_memory be get_current_memory_usage()
            If (current_memory plus size) greater than (limits.max_memory_mb multiplied by 1048576):
                Return true
            End If
        End If
    End If
    
    Return false
End Process

Note: =====================================================================
Note: AUDITING AND STATISTICS
Note: =====================================================================

Process called "audit_if_required" that takes checker as PermissionChecker, syscall_name as String, args as Internals.InternalArray, allowed as Boolean, reason as String returns Nothing:
    @Security_Scope
    Records audit log entry if required by policy.
    @End Security_Scope
    
    Let audit_level be checker.current_policy.audit_level
    
    Let should_log be false
    Match audit_level:
        When AuditLevel.All:
            Set should_log to true
        When AuditLevel.Sensitive:
            If is_sensitive_syscall(syscall_name):
                Set should_log to true
            End If
        When AuditLevel.Failures:
            If not allowed:
                Set should_log to true
            End If
        When AuditLevel.None:
            Set should_log to false
    End Match
    
    If should_log:
        Let entry be create_audit_entry(syscall_name, args, allowed, reason)
        Internals.internal_array_add(checker.audit_log, entry)
    End If
End Process

Process called "update_stats" that takes checker as PermissionChecker, syscall_name as String, allowed as Boolean returns Nothing:
    @Performance_Hints
    Updates syscall usage statistics for monitoring.
    @End Performance_Hints
    
    Let stats_ptr be Internals.internal_map_get(checker.syscall_stats, syscall_name)
    Let stats as SyscallStats
    
    If stats_ptr equals minus 1:
        Set stats.total_calls to 0
        Set stats.allowed_calls to 0
        Set stats.denied_calls to 0
    Otherwise:
        Set stats to ptr_to_stats(stats_ptr)
    End If
    
    Set stats.total_calls to stats.total_calls plus 1
    If allowed:
        Set stats.allowed_calls to stats.allowed_calls plus 1
    Otherwise:
        Set stats.denied_calls to stats.denied_calls plus 1
    End If
    
    Internals.internal_map_set(checker.syscall_stats, syscall_name, stats_to_ptr(stats))
End Process

Note: =====================================================================
Note: POLICY MANAGEMENT
Note: =====================================================================

Process called "set_policy" that takes checker as PermissionChecker, policy as SecurityPolicy returns Nothing:
    @Security_Scope
    Updates the active security policy.
    @End Security_Scope
    
    acquire_lock(address_of(checker.lock))
    
    Set checker.current_policy to policy
    
    Note: Clear cache when policy changes
    Set checker.policy_cache to Internals.create_internal_map(256)
    
    release_lock(address_of(checker.lock))
End Process

Process called "add_allowed_syscall" that takes checker as PermissionChecker, syscall_name as String returns Nothing:
    @Security_Scope
    Adds a syscall to the allowlist.
    @End Security_Scope
    
    acquire_lock(address_of(checker.lock))
    Internals.internal_map_set(checker.current_policy.allowed_syscalls, syscall_name, 1)
    release_lock(address_of(checker.lock))
End Process

Process called "add_blocked_syscall" that takes checker as PermissionChecker, syscall_name as String returns Nothing:
    @Security_Scope
    Adds a syscall to the blocklist.
    @End Security_Scope
    
    acquire_lock(address_of(checker.lock))
    Internals.internal_map_set(checker.current_policy.blocked_syscalls, syscall_name, 1)
    release_lock(address_of(checker.lock))
End Process

Process called "set_permission_level" that takes checker as PermissionChecker, level as PermissionLevel returns Nothing:
    @Security_Scope
    Updates the permission level.
    @End Security_Scope
    
    acquire_lock(address_of(checker.lock))
    Set checker.current_policy.permission_level to level
    
    Note: Adjust capabilities based on level
    Match level:
        When PermissionLevel.Unrestricted:
            Set checker.current_policy.capabilities to minus 1  Note: All capabilities
        When PermissionLevel.Privileged:
            Set checker.current_policy.capabilities to CAP_FILE_READ or CAP_FILE_WRITE or CAP_FILE_EXECUTE or CAP_NETWORK_CONNECT or CAP_NETWORK_LISTEN or CAP_PROCESS_FORK or CAP_PROCESS_EXEC or CAP_MEMORY_MAP
        When PermissionLevel.Standard:
            Set checker.current_policy.capabilities to CAP_FILE_READ or CAP_FILE_WRITE or CAP_NETWORK_CONNECT
        When PermissionLevel.Restricted:
            Set checker.current_policy.capabilities to CAP_FILE_READ
        When PermissionLevel.Minimal:
            Set checker.current_policy.capabilities to 0
    End Match
    
    release_lock(address_of(checker.lock))
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "is_blocked_syscall" that takes checker as PermissionChecker, syscall_name as String returns Boolean:
    @Performance_Hints
    Fast lookup in blocklist.
    @End Performance_Hints
    
    Let result be Internals.internal_map_get(checker.current_policy.blocked_syscalls, syscall_name)
    Return result not equals minus 1
End Process

Process called "is_allowed_syscall" that takes checker as PermissionChecker, syscall_name as String returns Boolean:
    @Performance_Hints
    Fast lookup in allowlist.
    @End Performance_Hints
    
    Let result be Internals.internal_map_get(checker.current_policy.allowed_syscalls, syscall_name)
    Return result not equals minus 1
End Process

Process called "is_restricted_path" that takes checker as PermissionChecker, path as String returns Boolean:
    @Security_Scope
    Checks if path is in restricted list.
    @End Security_Scope
    
    Let i be 0
    While i less than checker.current_policy.path_restrictions.length:
        Let restricted be get_string_from_array(checker.current_policy.path_restrictions, i)
        If path_starts_with(path, restricted):
            Return true
        End If
        Set i to i plus 1
    End While
    
    Return false
End Process

Process called "is_blocked_port" that takes checker as PermissionChecker, port as Integer returns Boolean:
    @Security_Scope
    Checks if port is blocked.
    @End Security_Scope
    
    Note: Well-known dangerous ports
    If port equals 22:  Note: SSH
        Return not has_capability(checker.current_policy.capabilities, CAP_NETWORK_LISTEN)
    End If
    If port equals 23:  Note: Telnet
        Return true
    End If
    If port equals 135 or port equals 139 or port equals 445:  Note: Windows RPC/SMB
        Return true
    End If
    
    Return false
End Process

Process called "is_dangerous_program" that takes program as String returns Boolean:
    @Security_Scope
    Checks if program is known to be dangerous.
    @End Security_Scope
    
    If path_ends_with(program, "/bash") or path_ends_with(program, "/sh"):
        Return true  Note: Shell execution risky
    End If
    If path_ends_with(program, "/nc") or path_ends_with(program, "/netcat"):
        Return true  Note: Network backdoor risk
    End If
    If path_ends_with(program, "/dd"):
        Return true  Note: Raw disk access
    End If
    
    Return false
End Process

Process called "is_sensitive_syscall" that takes syscall_name as String returns Boolean:
    @Security_Scope
    Identifies syscalls that should always be audited.
    @End Security_Scope
    
    If syscall_name equals Registry.SYSCALL_EXECVE:
        Return true
    End If
    If syscall_name equals Registry.SYSCALL_CONNECT:
        Return true
    End If
    If syscall_name equals Registry.SYSCALL_BIND:
        Return true
    End If
    If syscall_name equals Registry.SYSCALL_MMAP:
        Return true
    End If
    If syscall_name equals Registry.SYSCALL_FORK:
        Return true
    End If
    
    Return false
End Process

Process called "should_audit" that takes checker as PermissionChecker, syscall_name as String returns Boolean:
    @Security_Scope
    Determines if successful syscall should be audited.
    @End Security_Scope
    
    Match checker.current_policy.audit_level:
        When AuditLevel.All:
            Return true
        When AuditLevel.Sensitive:
            Return is_sensitive_syscall(syscall_name)
        When AuditLevel.Failures:
            Return false
        When AuditLevel.None:
            Return false
    End Match
    
    Return false
End Process

Process called "suggest_alternative" that takes syscall_name as String returns String:
    @Security_Scope
    Suggests safer alternatives to blocked syscalls.
    @End Security_Scope
    
    If syscall_name equals Registry.SYSCALL_EXECVE:
        Return "Consider using a controlled API instead of direct execution"
    End If
    If syscall_name equals "ptrace":
        Return "Use debugging APIs with proper authorization"
    End If
    If syscall_name equals Registry.SYSCALL_MMAP with executable:
        Return "Use non-executable memory mapping"
    End If
    
    Return ""
End Process

Note: =====================================================================
Note: UTILITY FUNCTIONS
Note: =====================================================================

Process called "create_result" that takes allowed as Boolean, reason as String, audit as Boolean, alternative as String returns PermissionCheckResult:
    Let result be PermissionCheckResult()
    Set result.allowed to allowed
    Set result.reason to reason
    Set result.audit_required to audit
    Set result.suggested_alternative to alternative
    Return result
End Process

Process called "generate_cache_key" that takes syscall_name as String, args as Internals.InternalArray returns String:
    Let sb be Internals.create_string_builder()
    Internals.string_builder_append(sb, syscall_name)
    Internals.string_builder_append(sb, ":")
    
    Let i be 0
    While i less than min_int(args.length, 3):  Note: Only first 3 args for key
        Let arg be Internals.internal_array_get(args, i)
        Internals.string_builder_append(sb, integer_to_string(arg))
        If i less than 2:
            Internals.string_builder_append(sb, ",")
        End If
        Set i to i plus 1
    End While
    
    Return Internals.string_builder_to_string(sb)
End Process

Process called "cache_result" that takes checker as PermissionChecker, key as String, result as PermissionCheckResult returns Nothing:
    Let ptr be result_to_ptr(result)
    Internals.internal_map_set(checker.policy_cache, key, ptr)
End Process

Process called "get_string_arg" that takes args as Internals.InternalArray, index as Integer returns String:
    If index less than args.length:
        Let ptr be Internals.internal_array_get(args, index)
        Return Internals.ptr_to_string(ptr)
    End If
    Return ""
End Process

Process called "get_port_from_sockaddr" that takes args as Internals.InternalArray, index as Integer returns Integer:
    If index less than args.length:
        Let sockaddr_ptr be Internals.internal_array_get(args, index)
        Note: Extract port from sockaddr structure (offset 2 bytes, network byte order)
        Let port_bytes be Internals.read_integer_at(sockaddr_ptr, 2)
        Return ntohs(port_bytes)  Note: Convert network to host byte order
    End If
    Return 0
End Process

Process called "path_starts_with" that takes path as String, prefix as String returns Boolean:
    If path.length() less than prefix.length():
        Return false
    End If
    
    Let i be 0
    While i less than prefix.length():
        If path.char_at(i) not equals prefix.char_at(i):
            Return false
        End If
        Set i to i plus 1
    End While
    
    Return true
End Process

Process called "path_ends_with" that takes path as String, suffix as String returns Boolean:
    If path.length() less than suffix.length():
        Return false
    End If
    
    Let offset be path.length() minus suffix.length()
    Let i be 0
    While i less than suffix.length():
        If path.char_at(offset plus i) not equals suffix.char_at(i):
            Return false
        End If
        Set i to i plus 1
    End While
    
    Return true
End Process

Process called "add_path_restriction" that takes restrictions as Internals.InternalArray, path as String returns Nothing:
    Let ptr be Internals.string_to_ptr(path)
    Internals.internal_array_add(restrictions, ptr)
End Process

Process called "get_string_from_array" that takes arr as Internals.InternalArray, index as Integer returns String:
    Let ptr be Internals.internal_array_get(arr, index)
    Return Internals.ptr_to_string(ptr)
End Process

Note: =====================================================================
Note: SYSTEM INFORMATION FUNCTIONS
Note: =====================================================================

Process called "get_open_fd_count" returns Integer:
    Note: Count open file descriptors
    Let count be 0
    Let fd be 0
    While fd less than 1024:
        If is_fd_open(fd):
            Set count to count plus 1
        End If
        Set fd to fd plus 1
    End While
    Return count
End Process

Process called "is_fd_open" that takes fd as Integer returns Boolean:
    Let result as Integer
    Inline Assembly:
        "mov rax, 5\n"      Note: fcntl syscall
        "mov rdi, %1\n"     Note: fd
        "mov rsi, 1\n"      Note: F_GETFD
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(fd)
        : "rax", "rdi", "rsi", "rcx", "r11"
    End Assembly
    Return result greater than or equal to 0
End Process

Process called "get_process_count" returns Integer:
    Note: Get number of processes for current user
    
    Let uid as Integer
    Inline Assembly:
        "mov rax, 102\n"        Note: getuid syscall
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(uid)
        :
        : "rax", "rcx", "r11"
    End Assembly
    
    Note: Count processes via /proc filesystem
    Let proc_fd as Integer
    Inline Assembly:
        "mov rax, 2\n"          Note: open syscall
        "lea rdi, [rip+proc_dir]\n"
        "mov rsi, 0x10000\n"     Note: O_RDONLY | O_DIRECTORY
        "syscall\n"
        "mov %0, rax\n"
        "jmp skip_proc_dir\n"
        "proc_dir: .asciz \"/proc\"\n"
        "skip_proc_dir:\n"
        : "=r"(proc_fd)
        :
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    If proc_fd less_than 0:
        Return 1  Note: At least this process exists
    End If
    
    Let count be 0
    Let buffer be Internals.allocate_raw_memory(8192)
    
    Note: Read directory entries
    Let bytes_read as Integer
    Inline Assembly:
        "mov rax, 217\n"         Note: getdents64 syscall
        "mov rdi, %1\n"          Note: fd
        "mov rsi, %2\n"          Note: buffer
        "mov rdx, 8192\n"        Note: buffer size
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(bytes_read)
        : "r"(proc_fd), "r"(buffer)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Note: Count numeric directories (PIDs)
    Let offset be 0
    While offset less_than bytes_read:
        Let d_reclen be Internals.read_integer_at(buffer plus offset plus 16, 2)  Note: d_reclen at offset 16
        Let d_type be Internals.read_integer_at(buffer plus offset plus 18, 1)    Note: d_type at offset 18
        Let d_name_ptr be buffer plus offset plus 19                              Note: d_name at offset 19
        
        If d_type equals 4:  Note: DT_DIR
            Let first_char be Internals.read_integer_at(d_name_ptr, 1)
            If first_char greater_than_or_equal 48 and first_char less_than_or_equal 57:  Note: '0' to '9'
                Set count to count plus 1
            End If
        End If
        
        Set offset to offset plus d_reclen
    End While
    
    Internals.free_raw_memory(buffer, 8192)
    
    Note: Close directory
    Inline Assembly:
        "mov rax, 3\n"           Note: close syscall
        "mov rdi, %0\n"
        "syscall\n"
        :
        : "r"(proc_fd)
        : "rax", "rdi", "rcx", "r11"
    End Assembly
    
    If count equals 0:
        Return 1  Note: At least this process
    End If
    Return count
End Process

Process called "get_current_memory_usage" returns Integer:
    Note: Get current process memory usage
    Let usage as Integer
    Inline Assembly:
        "mov rax, 12\n"     Note: brk syscall
        "xor rdi, rdi\n"    Note: Get current break
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(usage)
        :
        : "rax", "rdi", "rcx", "r11"
    End Assembly
    Return usage
End Process

Note: =====================================================================
Note: THREAD SAFETY
Note: =====================================================================

Process called "acquire_lock" that takes lock_ptr as Integer returns Nothing:
    Let expected be 0
    While true:
        Inline Assembly:
            "mov rax, 0\n"
            "mov rcx, 1\n"
            "mov rbx, %1\n"
            "lock cmpxchg [rbx], rcx\n"
            "setz al\n"
            "movzx %0, al\n"
            : "=r"(expected)
            : "r"(lock_ptr)
            : "rax", "rbx", "rcx", "memory", "cc"
        End Assembly
        
        If expected not equals 0:
            Return
        End If
        
        yield_cpu()
    End While
End Process

Process called "release_lock" that takes lock_ptr as Integer returns Nothing:
    Inline Assembly:
        "mov rbx, %0\n"
        "mov dword ptr [rbx], 0\n"
        "mfence\n"
        :
        : "r"(lock_ptr)
        : "rbx", "memory"
    End Assembly
End Process

Process called "yield_cpu" returns Nothing:
    Inline Assembly:
        "pause\n"
        :
        :
        : "memory"
    End Assembly
End Process

Process called "address_of" that takes value as Integer returns Integer:
    Let addr as Integer
    Inline Assembly:
        "lea rax, %1\n"
        "mov %0, rax\n"
        : "=r"(addr)
        : "m"(value)
        : "rax"
    End Assembly
    Return addr
End Process

Note: =====================================================================
Note: TYPE CONVERSION HELPERS
Note: =====================================================================

Type called "SyscallStats":
    total_calls as Integer
    allowed_calls as Integer
    denied_calls as Integer
End Type

Type called "AuditEntry":
    timestamp as Integer
    syscall_name as String
    allowed as Boolean
    reason as String
End Type

Process called "create_audit_entry" that takes syscall_name as String, args as Internals.InternalArray, allowed as Boolean, reason as String returns Integer:
    Let entry be AuditEntry()
    Set entry.timestamp to get_timestamp()
    Set entry.syscall_name to syscall_name
    Set entry.allowed to allowed
    Set entry.reason to reason
    
    Let size be 64
    Let ptr be Internals.allocate_raw_memory(size)
    Internals.write_integer_at(ptr, 0, entry.timestamp)
    Internals.write_integer_at(ptr, 8, Internals.string_to_ptr(entry.syscall_name))
    Internals.write_integer_at(ptr, 16, bool_to_int(entry.allowed))
    Internals.write_integer_at(ptr, 24, Internals.string_to_ptr(entry.reason))
    
    Return ptr
End Process

Process called "ptr_to_result" that takes ptr as Integer returns PermissionCheckResult:
    Let result be PermissionCheckResult()
    Set result.allowed to int_to_bool(Internals.read_integer_at(ptr, 0))
    Set result.reason to Internals.ptr_to_string(Internals.read_integer_at(ptr, 8))
    Set result.audit_required to int_to_bool(Internals.read_integer_at(ptr, 16))
    Set result.suggested_alternative to Internals.ptr_to_string(Internals.read_integer_at(ptr, 24))
    Return result
End Process

Process called "result_to_ptr" that takes result as PermissionCheckResult returns Integer:
    Let size be 32
    Let ptr be Internals.allocate_raw_memory(size)
    Internals.write_integer_at(ptr, 0, bool_to_int(result.allowed))
    Internals.write_integer_at(ptr, 8, Internals.string_to_ptr(result.reason))
    Internals.write_integer_at(ptr, 16, bool_to_int(result.audit_required))
    Internals.write_integer_at(ptr, 24, Internals.string_to_ptr(result.suggested_alternative))
    Return ptr
End Process

Process called "ptr_to_stats" that takes ptr as Integer returns SyscallStats:
    Let stats be SyscallStats()
    Set stats.total_calls to Internals.read_integer_at(ptr, 0)
    Set stats.allowed_calls to Internals.read_integer_at(ptr, 8)
    Set stats.denied_calls to Internals.read_integer_at(ptr, 16)
    Return stats
End Process

Process called "stats_to_ptr" that takes stats as SyscallStats returns Integer:
    Let size be 24
    Let ptr be Internals.allocate_raw_memory(size)
    Internals.write_integer_at(ptr, 0, stats.total_calls)
    Internals.write_integer_at(ptr, 8, stats.allowed_calls)
    Internals.write_integer_at(ptr, 16, stats.denied_calls)
    Return ptr
End Process

Process called "bool_to_int" that takes b as Boolean returns Integer:
    If b:
        Return 1
    End If
    Return 0
End Process

Process called "int_to_bool" that takes i as Integer returns Boolean:
    Return i not equals 0
End Process

Process called "min_int" that takes a as Integer, b as Integer returns Integer:
    If a less than b:
        Return a
    End If
    Return b
End Process

Process called "integer_to_string" that takes value as Integer returns String:
    If value equals 0:
        Return "0"
    End If
    
    Let is_negative be false
    Let num be value
    If value less than 0:
        Set is_negative to true
        Set num to 0 minus value
    End If
    
    Let sb be Internals.create_string_builder()
    Let digits be Internals.create_internal_array(20)
    Let digit_count be 0
    
    While num greater than 0:
        Let digit be num modulo 10
        Internals.internal_array_add(digits, digit)
        Set digit_count to digit_count plus 1
        Set num to num divided by 10
    End While
    
    If is_negative:
        Internals.string_builder_append(sb, "-")
    End If
    
    Let i be digit_count minus 1
    While i greater than or equal to 0:
        Let digit be Internals.internal_array_get(digits, i)
        Let digit_char be digit plus 48
        Let char_str be character_from_code(digit_char)
        Internals.string_builder_append(sb, char_str)
        Set i to i minus 1
    End While
    
    Internals.free_internal_array(digits)
    Return Internals.string_builder_to_string(sb)
End Process

Process called "character_from_code" that takes code as Integer returns String:
    Let chars as InternalArray[1]
    Set chars[0] to code as Character
    Return String from chars
End Process

Process called "get_timestamp" returns Integer:
    Let seconds as Integer
    Let nanoseconds as Integer
    
    Inline Assembly:
        "mov rax, 228\n"
        "mov rdi, 1\n"
        "lea rsi, [rsp-16]\n"
        "syscall\n"
        "mov %0, [rsi]\n"
        "mov %1, [rsi+8]\n"
        : "=r"(seconds), "=r"(nanoseconds)
        :
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return seconds multiplied by 1000000000 plus nanoseconds
End Process

Process called "ntohs" that takes netshort as Integer returns Integer:
    Note: Convert network byte order to host byte order
    Let high_byte be (netshort bitwise_and 0xFF00) shifted_right 8
    Let low_byte be netshort bitwise_and 0x00FF
    Return (low_byte shifted_left 8) or high_byte
End Process
