Note:
Low-Level Intermediate Representation (LIR) Node Definitions Module

This module defines the complete set of LIR node types used in the Runa compiler's
low-level intermediate representation. LIR represents code at a machine-oriented
level suitable for register allocation, instruction scheduling, and final code
generation. These nodes bridge the gap between high-level optimizations and
target-specific machine code generation.

Core responsibilities:
- Machine-oriented instruction and operand definitions
- Virtual and physical register representations
- Target-specific addressing modes and instruction formats
- Call frame and stack management structures
- Exception handling and debugging information integration
- Register allocation and spilling support structures
:End Note

Import "compiler/frontend/diagnostics/errors" as Errors

Note: ===== Core LIR Node Types =====

Type called "LIRInstructionId":
    instruction_identifier as String     Note: Unique instruction identifier
    block_id as String                   Note: Containing basic block ID
    instruction_index as Integer         Note: Index within basic block
    sequence_number as Integer           Note: Global sequence number

Type called "LIRBasicBlockId":
    block_identifier as String           Note: Unique basic block identifier
    function_id as String                Note: Containing function ID
    block_sequence as Integer            Note: Block sequence number in function

Type called "LIRProgram":
    program_id as String                 Note: Unique program identifier
    modules as List[LIRModule]           Note: Program modules
    global_symbols as List[LIRGlobalSymbol] Note: Global symbols and data
    external_functions as List[LIRExternalFunction] Note: External function references
    target_info as TargetMachineInfo     Note: Target machine information
    calling_conventions as Dictionary[String, CallingConvention] Note: Available calling conventions

Type called "LIRModule":
    module_id as String                  Note: Module identifier
    module_name as String                Note: Module name
    functions as List[LIRFunction]       Note: Functions in module
    global_data as List[LIRGlobalData]   Note: Module global data
    constant_pool as ConstantPool        Note: Module constant pool
    debug_info as Optional[ModuleDebugInfo] Note: Debug information

Type called "LIRFunction":
    function_id as String                Note: Function identifier
    function_name as String              Note: Function name
    parameters as List[LIRParameter]     Note: Function parameters
    return_info as ReturnInfo            Note: Return value information
    basic_blocks as List[LIRBasicBlock]  Note: Function basic blocks
    entry_block as LIRBasicBlockId       Note: Entry basic block
    virtual_registers as List[VirtualRegister] Note: Virtual registers used
    stack_frame as StackFrame            Note: Stack frame layout
    call_sites as List[CallSite]         Note: Function call sites
    function_attributes as List[FunctionAttribute] Note: Function attributes

Note: ===== LIR Basic Block Structure =====

Type called "LIRBasicBlock":
    block_id as LIRBasicBlockId          Note: Block identifier
    block_name as Optional[String]       Note: Optional block name
    instructions as List[LIRInstruction] Note: Instructions in block
    predecessors as List[LIRBasicBlockId] Note: Predecessor blocks
    successors as List[LIRBasicBlockId]  Note: Successor blocks
    live_in as Set[VirtualRegister]      Note: Live-in virtual registers
    live_out as Set[VirtualRegister]     Note: Live-out virtual registers
    terminator as LIRTerminator          Note: Block terminator instruction
    block_frequency as Optional[Float]   Note: Execution frequency estimate
    alignment as Optional[Integer]       Note: Block alignment requirement

Type called "LIRInstruction":
    instruction_id as LIRInstructionId   Note: Instruction identifier
    opcode as LIROpcode                  Note: Instruction opcode
    operands as List[LIROperand]         Note: Instruction operands
    result as Optional[VirtualRegister]  Note: Result register
    instruction_flags as List[InstructionFlag] Note: Instruction flags
    source_location as Optional[SourceLocation] Note: Original source location
    scheduling_info as Optional[SchedulingInfo] Note: Instruction scheduling information
    register_constraints as List[RegisterConstraint] Note: Register allocation constraints

Type called "LIRTerminator":
    terminator_id as String              Note: Terminator identifier
    terminator_type as LIRTerminatorType Note: Type of terminator
    targets as List[LIRBasicBlockId]     Note: Target basic blocks
    condition as Optional[VirtualRegister] Note: Branch condition register
    branch_hints as List[BranchHint]     Note: Branch prediction hints

Type called "LIRTerminatorType" is:
    | Return as Optional[VirtualRegister] Note: Return instruction
    | Jump as LIRBasicBlockId             Note: Unconditional jump
    | ConditionalJump as ConditionalJumpInfo Note: Conditional jump
    | IndirectJump as VirtualRegister     Note: Indirect jump through register
    | Switch as SwitchTableInfo           Note: Switch with jump table
    | Call as TailCallInfo                Note: Tail call
    | Unreachable                         Note: Unreachable code marker

Note: ===== LIR Instruction Set =====

Type called "LIROpcode" is:
    | LoadImmediate                       Note: Load immediate value
    | LoadRegister                        Note: Load from register
    | LoadMemory                          Note: Load from memory
    | StoreRegister                       Note: Store to register
    | StoreMemory                         Note: Store to memory
    | Move                                Note: Register to register move
    | AddRegReg                           Note: Add register to register
    | AddRegImm                           Note: Add immediate to register
    | SubRegReg                           Note: Subtract register from register
    | SubRegImm                           Note: Subtract immediate from register
    | MulRegReg                           Note: Multiply register by register
    | MulRegImm                           Note: Multiply register by immediate
    | DivRegReg                           Note: Divide register by register
    | DivRegImm                           Note: Divide register by immediate
    | AndRegReg                           Note: Bitwise AND registers
    | AndRegImm                           Note: Bitwise AND with immediate
    | OrRegReg                            Note: Bitwise OR registers
    | OrRegImm                            Note: Bitwise OR with immediate
    | XorRegReg                           Note: Bitwise XOR registers
    | XorRegImm                           Note: Bitwise XOR with immediate
    | ShiftLeft                           Note: Left shift operation
    | ShiftRight                          Note: Right shift operation
    | CompareRegReg                       Note: Compare two registers
    | CompareRegImm                       Note: Compare register with immediate
    | ConvertIntFloat                     Note: Convert integer to float
    | ConvertFloatInt                     Note: Convert float to integer
    | FunctionCall                        Note: Function call instruction
    | SystemCall                          Note: System call instruction
    | Nop                                 Note: No operation
    | Barrier                             Note: Optimization/memory barrier

Type called "LIROperand":
    operand_id as String                 Note: Operand identifier
    operand_type as LIROperandType       Note: Type of operand
    operand_size as OperandSize          Note: Size of operand in bits
    operand_flags as List[OperandFlag]   Note: Operand-specific flags

Type called "LIROperandType" is:
    | VirtualRegister as VirtualRegister Note: Virtual register operand
    | PhysicalRegister as PhysicalRegister Note: Physical register operand
    | ImmediateValue as ImmediateValue   Note: Immediate value operand
    | MemoryAddress as MemoryAddress     Note: Memory address operand
    | StackSlot as StackSlot             Note: Stack slot operand
    | Label as String                    Note: Code label operand
    | ConstantPoolEntry as ConstantId    Note: Constant pool entry

Type called "OperandSize" is:
    | Bits8                              Note: 8-bit operand
    | Bits16                             Note: 16-bit operand
    | Bits32                             Note: 32-bit operand
    | Bits64                             Note: 64-bit operand
    | Bits128                            Note: 128-bit operand
    | Bits256                            Note: 256-bit operand

Note: ===== Register Representations =====

Type called "VirtualRegister":
    register_id as String                Note: Unique virtual register ID
    register_class as RegisterClass     Note: Register class
    bit_width as Integer                 Note: Register bit width
    spill_slot as Optional[StackSlot]    Note: Assigned spill slot
    physical_register as Optional[PhysicalRegister] Note: Assigned physical register
    definition_instruction as Optional[LIRInstructionId] Note: Defining instruction
    use_instructions as List[LIRInstructionId] Note: Instructions using this register
    live_range as Optional[LiveInterval] Note: Live range interval
    spill_weight as Float                Note: Spill cost weight
    register_hints as List[RegisterHint] Note: Register allocation hints

Type called "PhysicalRegister":
    register_name as String              Note: Physical register name
    register_number as Integer           Note: Register number
    register_class as RegisterClass     Note: Register class
    bit_width as Integer                 Note: Register bit width
    is_callee_saved as Boolean           Note: Whether register is callee-saved
    is_allocatable as Boolean            Note: Whether register can be allocated
    encoding as Integer                  Note: Machine encoding of register

Type called "RegisterClass" is:
    | IntegerRegister                    Note: General-purpose integer register
    | FloatingPointRegister              Note: Floating-point register
    | VectorRegister                     Note: Vector/SIMD register
    | AddressRegister                    Note: Address register
    | IndexRegister                      Note: Index register
    | FlagsRegister                      Note: Processor flags register
    | StackPointer                       Note: Stack pointer register
    | FramePointer                       Note: Frame pointer register
    | InstructionPointer                 Note: Instruction pointer register
    | SpecialPurpose as String           Note: Special-purpose register

Type called "RegisterHint":
    hint_type as RegisterHintType        Note: Type of register hint
    priority as Integer                  Note: Hint priority
    target_register as Optional[PhysicalRegister] Note: Preferred physical register

Type called "RegisterHintType" is:
    | PreferRegister                     Note: Prefer specific register
    | AvoidRegister                      Note: Avoid specific register
    | SameAsOperand as Integer           Note: Use same register as operand
    | DifferentFromOperand as Integer    Note: Use different register from operand

Note: ===== Memory and Stack Operations =====

Type called "MemoryAddress":
    address_type as MemoryAddressType    Note: Type of memory address
    base_register as Optional[VirtualRegister] Note: Base address register
    index_register as Optional[VirtualRegister] Note: Index register
    scale_factor as Integer              Note: Index scale factor
    displacement as Integer              Note: Address displacement
    segment as Optional[SegmentRegister] Note: Segment register (x86)

Type called "MemoryAddressType" is:
    | Direct as VirtualRegister          Note: Direct register addressing
    | Indirect as IndirectAddressInfo    Note: Indirect addressing
    | BaseIndex as BaseIndexInfo         Note: Base plus index addressing
    | Absolute as Integer                Note: Absolute address
    | RIPRelative as Integer             Note: RIP-relative addressing (x86-64)
    | PCRelative as Integer              Note: PC-relative addressing

Type called "StackSlot":
    slot_id as String                    Note: Unique stack slot identifier
    offset_from_frame_pointer as Integer Note: Offset from frame pointer
    size_bytes as Integer                Note: Size of stack slot
    alignment as Integer                 Note: Required alignment
    is_spill_slot as Boolean             Note: Whether slot is for register spilling
    associated_register as Optional[VirtualRegister] Note: Associated virtual register

Type called "StackFrame":
    frame_size as Integer                Note: Total frame size in bytes
    local_area_size as Integer           Note: Size of local variables area
    spill_area_size as Integer           Note: Size of register spill area
    parameter_area_size as Integer       Note: Size of outgoing parameter area
    saved_registers_size as Integer      Note: Size of saved registers area
    alignment as Integer                 Note: Frame alignment requirement
    has_variable_size_objects as Boolean Note: Whether frame has variable-sized objects
    stack_slots as List[StackSlot]       Note: Allocated stack slots

Note: ===== Call and Function Interface =====

Type called "CallSite":
    call_id as String                    Note: Unique call site identifier
    call_instruction as LIRInstructionId Note: Call instruction
    target_function as Optional[String]  Note: Target function name if known
    calling_convention as CallingConvention Note: Calling convention used
    arguments as List[CallArgument]      Note: Call arguments
    return_value as Optional[VirtualRegister] Note: Return value register
    call_frame_size as Integer           Note: Call frame size
    is_tail_call as Boolean              Note: Whether this is a tail call

Type called "CallArgument":
    argument_register as Optional[VirtualRegister] Note: Argument register
    stack_offset as Optional[Integer]    Note: Stack offset if passed on stack
    argument_type as ArgumentType        Note: Type of argument
    size_bytes as Integer                Note: Size of argument

Type called "ArgumentType" is:
    | IntegerArgument                    Note: Integer argument
    | FloatingPointArgument              Note: Floating-point argument
    | PointerArgument                    Note: Pointer argument
    | StructArgument                     Note: Structure argument
    | ArrayArgument                      Note: Array argument

Type called "CallingConvention":
    convention_name as String            Note: Calling convention name
    parameter_registers as List[PhysicalRegister] Note: Registers for parameters
    return_registers as List[PhysicalRegister] Note: Registers for return values
    caller_saved_registers as Set[PhysicalRegister] Note: Caller-saved registers
    callee_saved_registers as Set[PhysicalRegister] Note: Callee-saved registers
    stack_alignment as Integer           Note: Required stack alignment
    shadow_space_size as Integer         Note: Shadow space size
    return_address_location as ReturnAddressLocation Note: Return address location

Type called "ReturnAddressLocation" is:
    | OnStack as Integer                 Note: On stack at specified offset
    | InRegister as PhysicalRegister     Note: In specified register
    | LinkRegister                       Note: In dedicated link register

Note: ===== Control Flow Structures =====

Type called "ConditionalJumpInfo":
    condition_code as ConditionCode      Note: Condition for jump
    true_target as LIRBasicBlockId       Note: Target if condition is true
    false_target as LIRBasicBlockId      Note: Target if condition is false
    condition_register as Optional[VirtualRegister] Note: Register holding condition

Type called "ConditionCode" is:
    | Equal                              Note: Equal (zero flag set)
    | NotEqual                           Note: Not equal (zero flag clear)
    | Less                               Note: Less than (signed)
    | LessEqual                          Note: Less than or equal (signed)
    | Greater                            Note: Greater than (signed)
    | GreaterEqual                       Note: Greater than or equal (signed)
    | Below                              Note: Below (unsigned)
    | BelowEqual                         Note: Below or equal (unsigned)
    | Above                              Note: Above (unsigned)
    | AboveEqual                         Note: Above or equal (unsigned)
    | Overflow                           Note: Overflow occurred
    | NotOverflow                        Note: No overflow
    | Carry                              Note: Carry flag set
    | NotCarry                           Note: Carry flag clear

Type called "SwitchTableInfo":
    switch_register as VirtualRegister   Note: Register containing switch value
    default_target as LIRBasicBlockId    Note: Default case target
    jump_table as JumpTable              Note: Jump table structure
    range_check as Optional[RangeCheck]  Note: Range check before jump

Type called "JumpTable":
    table_id as String                   Note: Jump table identifier
    base_address as Optional[VirtualRegister] Note: Base address register
    entries as List[JumpTableEntry]      Note: Jump table entries
    entry_size as Integer                Note: Size of each entry
    is_position_independent as Boolean   Note: Whether table is PIC

Type called "JumpTableEntry":
    case_value as Integer                Note: Case value
    target_block as LIRBasicBlockId      Note: Target basic block
    target_offset as Optional[Integer]   Note: Offset from table base

Note: ===== Immediate Values and Constants =====

Type called "ImmediateValue":
    value_type as ImmediateValueType     Note: Type of immediate value
    bit_width as Integer                 Note: Bit width of value
    encoding as ImmediateEncoding        Note: How value is encoded

Type called "ImmediateValueType" is:
    | SignedInteger as Integer           Note: Signed integer immediate
    | UnsignedInteger as Integer         Note: Unsigned integer immediate
    | FloatingPoint as Float             Note: Floating-point immediate
    | Address as String                  Note: Address immediate (label)
    | Offset as Integer                  Note: Offset immediate

Type called "ImmediateEncoding" is:
    | Direct as Integer                  Note: Direct encoding in instruction
    | ConstantPool as ConstantId         Note: Reference to constant pool
    | Relocatable as RelocationInfo      Note: Relocatable reference

Type called "ConstantPool":
    pool_id as String                    Note: Constant pool identifier
    constants as Dictionary[ConstantId, PoolConstant] Note: Pool constants
    alignment as Integer                 Note: Pool alignment requirement
    is_read_only as Boolean              Note: Whether pool is read-only

Type called "PoolConstant":
    constant_id as ConstantId            Note: Constant identifier
    constant_value as ConstantValue      Note: Constant value
    size_bytes as Integer                Note: Size in bytes
    alignment as Integer                 Note: Required alignment
    references as List[ConstantReference] Note: References to this constant

Note: ===== Register Allocation Support =====

Type called "LiveInterval":
    virtual_register as VirtualRegister Note: Associated virtual register
    start_point as ProgramPoint          Note: Interval start point
    end_point as ProgramPoint            Note: Interval end point
    use_positions as List[UsePosition]   Note: Use positions within interval
    spill_cost as Float                  Note: Cost of spilling this interval
    split_positions as List[ProgramPoint] Note: Valid split positions

Type called "UsePosition":
    position as ProgramPoint             Note: Program point of use
    use_type as UseType                  Note: Type of use
    required_register as Optional[PhysicalRegister] Note: Required physical register

Type called "UseType" is:
    | Read                               Note: Register is read
    | Write                              Note: Register is written
    | ReadWrite                          Note: Register is read and written
    | Call                               Note: Register used across call
    | Fixed                              Note: Register must use specific physical register

Type called "RegisterConstraint":
    constraint_id as String              Note: Constraint identifier
    constraint_type as RegisterConstraintType Note: Type of constraint
    affected_operands as List[Integer]   Note: Operand indices affected
    required_registers as Set[PhysicalRegister] Note: Required registers
    forbidden_registers as Set[PhysicalRegister] Note: Forbidden registers

Type called "RegisterConstraintType" is:
    | SameRegisterAsOperand              Note: Must use same register as another operand
    | DifferentRegisterFromOperand       Note: Must use different register from operand
    | SpecificRegisterRequired           Note: Must use specific physical register
    | RegisterClassRequired              Note: Must use register from specific class
    | EarlyClobber                       Note: Result register clobbered early

Note: ===== Debug and Optimization Information =====

Type called "SchedulingInfo":
    instruction_latency as Integer       Note: Instruction execution latency
    resource_usage as List[ResourceUsage] Note: Functional unit usage
    dependencies as List[InstructionDependency] Note: Data dependencies
    scheduling_class as SchedulingClass  Note: Instruction scheduling class

Type called "ResourceUsage":
    resource_type as FunctionalUnitType  Note: Type of functional unit
    cycles_used as Integer               Note: Number of cycles used
    is_exclusive as Boolean              Note: Whether usage is exclusive

Type called "FunctionalUnitType" is:
    | IntegerALU                         Note: Integer arithmetic logic unit
    | FloatingPointALU                   Note: Floating-point ALU
    | LoadStoreUnit                      Note: Load/store unit
    | BranchUnit                         Note: Branch prediction unit
    | VectorUnit                         Note: Vector processing unit

Type called "InstructionDependency":
    dependent_instruction as LIRInstructionId Note: Dependent instruction
    dependency_type as DependencyType    Note: Type of dependency
    latency as Integer                   Note: Dependency latency

Type called "DependencyType" is:
    | DataDependency                     Note: True data dependency
    | AntiDependency                     Note: Write-after-read dependency
    | OutputDependency                   Note: Write-after-write dependency
    | ControlDependency                  Note: Control flow dependency

Note: ===== Utility Functions =====

Process called "create_lir_instruction" that takes opcode as LIROpcode, operands as List[LIROperand] returns LIRInstruction:
    Note: Creates new LIR instruction with specified opcode and operands
    Note: Assigns unique instruction ID and initializes metadata
    Note: Time complexity: O(1), Space complexity: O(1)
    Note: TODO: Implement LIR instruction creation
    Throw Errors.NotImplemented

Process called "create_virtual_register" that takes register_class as RegisterClass, bit_width as Integer returns VirtualRegister:
    Note: Creates new virtual register with specified class and width
    Note: Assigns unique register ID and initializes allocation metadata
    Note: Time complexity: O(1), Space complexity: O(1)
    Note: TODO: Implement virtual register creation
    Throw Errors.NotImplemented

Process called "create_memory_address" that takes address_type as MemoryAddressType returns MemoryAddress:
    Note: Creates memory address operand with specified addressing type
    Note: Initializes address components and validation metadata
    Note: Time complexity: O(1), Space complexity: O(1)
    Note: TODO: Implement memory address creation
    Throw Errors.NotImplemented

Process called "get_instruction_operands" that takes instruction as LIRInstruction returns List[VirtualRegister]:
    Note: Extracts all virtual register operands from LIR instruction
    Note: Returns operands that are virtual registers for liveness analysis
    Note: Time complexity: O(o) where o is operand count, Space complexity: O(v) where v is virtual registers
    Note: TODO: Implement instruction operand extraction
    Throw Errors.NotImplemented

Process called "replace_virtual_register" that takes old_register as VirtualRegister, new_register as VirtualRegister, instruction as LIRInstruction returns LIRInstruction:
    Note: Replaces all occurrences of old virtual register with new register
    Note: Updates instruction operands and maintains register constraints
    Note: Time complexity: O(o), Space complexity: O(1)
    Note: TODO: Implement virtual register replacement
    Throw Errors.NotImplemented

Process called "is_terminator_instruction" that takes instruction as LIRInstruction returns Boolean:
    Note: Checks if LIR instruction is a terminator instruction
    Note: Terminator instructions end basic blocks and transfer control
    Note: Time complexity: O(1), Space complexity: O(1)
    Note: TODO: Implement terminator instruction check
    Throw Errors.NotImplemented

Process called "compute_instruction_size" that takes instruction as LIRInstruction, target_info as TargetMachineInfo returns Integer:
    Note: Computes size in bytes of LIR instruction on target machine
    Note: Considers instruction encoding and operand sizes
    Note: Time complexity: O(1), Space complexity: O(1)
    Note: TODO: Implement instruction size computation
    Throw Errors.NotImplemented

Process called "validate_register_constraints" that takes instruction as LIRInstruction returns List[ConstraintViolation]:
    Note: Validates that instruction operands satisfy register constraints
    Note: Checks register class compatibility and allocation requirements
    Note: Time complexity: O(c) where c is constraints, Space complexity: O(v) where v is violations
    Note: TODO: Implement register constraint validation
    Throw Errors.NotImplemented

Process called "clone_lir_instruction" that takes instruction as LIRInstruction returns LIRInstruction:
    Note: Creates deep copy of LIR instruction with new ID
    Note: Preserves operands, constraints, and metadata
    Note: Time complexity: O(o), Space complexity: O(o)
    Note: TODO: Implement LIR instruction cloning
    Throw Errors.NotImplemented

Process called "compute_instruction_hash" that takes instruction as LIRInstruction returns String:
    Note: Computes hash of LIR instruction for deduplication and caching
    Note: Includes opcode, operand types, and constraint information
    Note: Time complexity: O(o), Space complexity: O(1)
    Note: TODO: Implement LIR instruction hash computation
    Throw Errors.NotImplemented