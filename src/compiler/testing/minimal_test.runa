Note:
minimal_test.runa
Ultra-Minimal Assembly-Based Testing for Bootstrap Compiler

This module provides the absolute minimum testing capability needed to verify
the bootstrap compiler's correctness without any dependencies on the standard
library or complex language features.

Key features and capabilities:
- Direct assembly implementation for zero dependencies
- Simple pass/fail semantics via exit codes
- Memory-based string comparison for basic assertions
- Minimal stack usage for bootstrap environment
- No heap allocation or complex data structures
- Integration with OS exit codes for test runners
- Platform-specific x86_64 assembly instructions
:End Note

Note: =====================================================================
Note: CORE TEST PRIMITIVES - ASSEMBLY ONLY
Note: =====================================================================

Process called "test_pass" returns Nothing:
    Note: Signal test success with exit code 0
    Let result be 0
    Inline Assembly:
        "mov rax, 0\n"           Note: Exit code 0 = success
        "ret\n"
        : "=r"(result)
        :
        : "rax"
    End Assembly
End Process

Process called "test_fail" returns Nothing:
    Note: Signal test failure with exit code 1
    Let result be 0
    Inline Assembly:
        "mov rax, 1\n"           Note: Exit code 1 = failure  
        "ret\n"
        : "=r"(result)
        :
        : "rax"
    End Assembly
End Process

Process called "test_assert" that takes condition as Integer returns Nothing:
    Note: Assert condition is non-zero (true), fail if zero (false)
    Let result be 0
    Inline Assembly:
        "test %1, %1\n"          Note: Test if condition is zero
        "jnz .assert_pass\n"     Note: Jump if not zero (true)
        "mov rax, 1\n"           Note: Set failure exit code
        "jmp .assert_done\n"
        ".assert_pass:\n"
        "xor rax, rax\n"         Note: Set success exit code
        ".assert_done:\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(condition)
        : "rax", "flags"
    End Assembly
End Process

Note: =====================================================================
Note: BASIC STRING COMPARISON - ASSEMBLY IMPLEMENTATION
Note: =====================================================================

Process called "strings_equal" that takes str1_ptr as Integer, str1_len as Integer, str2_ptr as Integer, str2_len as Integer returns Integer:
    Note: Compare two strings byte-by-byte, return 1 if equal, 0 if different
    Let result be 0
    Inline Assembly:
        "mov rcx, %2\n"           Note: Load first string length
        "cmp rcx, %4\n"           Note: Compare lengths  
        "jne .not_equal\n"        Note: Different lengths = not equal
        "test rcx, rcx\n"         Note: Check if length is zero
        "jz .equal\n"             Note: Empty strings are equal
        "mov rsi, %1\n"           Note: Source string pointer
        "mov rdi, %3\n"           Note: Destination string pointer
        ".compare_loop:\n"
        "mov al, [rsi]\n"         Note: Load byte from str1
        "cmp al, [rdi]\n"         Note: Compare with byte from str2
        "jne .not_equal\n"        Note: Bytes differ
        "inc rsi\n"               Note: Advance str1 pointer
        "inc rdi\n"               Note: Advance str2 pointer
        "dec rcx\n"               Note: Decrement counter
        "jnz .compare_loop\n"     Note: Continue if more bytes
        ".equal:\n"
        "mov rax, 1\n"            Note: Return true (1)
        "jmp .done\n"
        ".not_equal:\n"
        "xor rax, rax\n"          Note: Return false (0)
        ".done:\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(str1_ptr), "r"(str1_len), "r"(str2_ptr), "r"(str2_len)
        : "rax", "rcx", "rsi", "rdi", "al", "flags", "memory"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: INTEGER COMPARISON - ASSEMBLY IMPLEMENTATION
Note: =====================================================================

Process called "integers_equal" that takes val1 as Integer, val2 as Integer returns Integer:
    Note: Compare two integers, return 1 if equal, 0 if different
    Let result be 0
    Inline Assembly:
        "mov rax, %1\n"           Note: Load first value
        "cmp rax, %2\n"           Note: Compare with second value
        "je .equal\n"             Note: Jump if equal
        "xor rax, rax\n"          Note: Return false (0)
        "jmp .done\n"
        ".equal:\n"
        "mov rax, 1\n"            Note: Return true (1)
        ".done:\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(val1), "r"(val2)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "integer_greater" that takes val1 as Integer, val2 as Integer returns Integer:
    Note: Check if val1 > val2, return 1 if true, 0 if false
    Let result be 0
    Inline Assembly:
        "mov rax, %1\n"           Note: Load first value
        "cmp rax, %2\n"           Note: Compare with second value
        "jg .greater\n"           Note: Jump if greater
        "xor rax, rax\n"          Note: Return false (0)
        "jmp .done\n"
        ".greater:\n"
        "mov rax, 1\n"            Note: Return true (1)
        ".done:\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(val1), "r"(val2)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "integer_less" that takes val1 as Integer, val2 as Integer returns Integer:
    Note: Check if val1 < val2, return 1 if true, 0 if false
    Let result be 0
    Inline Assembly:
        "mov rax, %1\n"           Note: Load first value
        "cmp rax, %2\n"           Note: Compare with second value
        "jl .less\n"              Note: Jump if less
        "xor rax, rax\n"          Note: Return false (0)
        "jmp .done\n"
        ".less:\n"
        "mov rax, 1\n"            Note: Return true (1)
        ".done:\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(val1), "r"(val2)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: TEST EXECUTION HELPERS - MINIMAL IMPLEMENTATION
Note: =====================================================================

Process called "run_test" that takes test_ptr as Integer returns Integer:
    Note: Execute a test function and return its result
    Note: test_ptr should point to a function that returns 0 for pass, 1 for fail
    Let result be 0
    Inline Assembly:
        "call *%1\n"              Note: Call the test function
        "mov %0, rax\n"           Note: Get result from rax
        : "=r"(result)
        : "r"(test_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "memory", "cc"
    End Assembly
    Return result
End Process

Process called "check_result" that takes result as Integer returns Nothing:
    Note: Check test result and exit with appropriate code
    Inline Assembly:
        "test %0, %0\n"           Note: Check if result is zero
        "jz .success\n"           Note: Jump if zero (success)
        "mov rdi, 1\n"            Note: Exit code for syscall
        "mov rax, 60\n"           Note: sys_exit syscall number
        "syscall\n"               Note: Exit with failure
        ".success:\n"
        "xor rdi, rdi\n"          Note: Exit code 0
        "mov rax, 60\n"           Note: sys_exit syscall number
        "syscall\n"               Note: Exit with success
        :
        : "r"(result)
        : "rax", "rdi", "rcx", "r11", "memory"
    End Assembly
End Process