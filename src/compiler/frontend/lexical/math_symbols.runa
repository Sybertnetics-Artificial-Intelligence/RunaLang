Note:
compiler/frontend/lexical/math_symbols.runa
Mathematical Symbol Recognition and LaTeX Support

This module provides core mathematical symbol support for the lexer including:
- Core math symbols (‚àë, ‚àè, ‚à´, ‚àÇ, ‚àá, ‚àû)
- Greek letters (Œ±, Œ≤, Œ≥, Œ¥, etc.)
- Tensor operation symbols (‚äó, ‚äï, ‚äô)
- LaTeX-style input conversion (\alpha ‚Üí Œ±)
- Support for both Canon and developer modes
- Two-tier architecture: core symbols here, extended via library
:End Note

Import Module "compiler/internal/collections" as Collections
Import Module "compiler/internal/string_utils" as StringUtils

Note: =====================================================================
Note: MATH SYMBOL DATA STRUCTURES
Note: =====================================================================

Type called "MathSymbol":
    unicode_char as Character
    latex_name as String
    canonical_name as String
    symbol_type as String
    is_operator as Boolean
    precedence as Integer
    associativity as String
End Type

Type called "MathSymbolTable":
    symbols as Collections.Dictionary
    latex_lookup as Collections.Dictionary
    canonical_lookup as Collections.Dictionary
    operator_symbols as Collections.List
End Type

Note: =====================================================================
Note: CORE MATH SYMBOLS (TIER 1 - BUILT INTO LEXER)
Note: =====================================================================

Process called "create_math_symbol_table" returns MathSymbolTable:
    Let table be MathSymbolTable with
        symbols as Collections.create_dictionary(),
        latex_lookup as Collections.create_dictionary(),
        canonical_lookup as Collections.create_dictionary(),
        operator_symbols as Collections.create_list()
    End MathSymbolTable
    
    Note: Core mathematical operators
    register_symbol(table, '‚àë', "\\sum", "sum", "SUMMATION", False, 0, "none")
    register_symbol(table, '‚àè', "\\prod", "product", "PRODUCT", False, 0, "none")
    register_symbol(table, '‚à´', "\\int", "integral", "INTEGRAL", False, 0, "none")
    register_symbol(table, '‚àÇ', "\\partial", "partial", "PARTIAL", False, 0, "none")
    register_symbol(table, '‚àá', "\\nabla", "nabla", "NABLA", False, 0, "none")
    register_symbol(table, '‚àû', "\\infty", "infinity", "INFINITY", False, 0, "none")
    
    Note: Tensor operation symbols (as operators)
    register_symbol(table, '‚äó', "\\otimes", "tensor_product", "TENSOR_PRODUCT", True, 7, "left")
    register_symbol(table, '‚äï', "\\oplus", "direct_sum", "DIRECT_SUM", True, 6, "left")
    register_symbol(table, '‚äô', "\\odot", "hadamard_product", "HADAMARD_PRODUCT", True, 7, "left")
    register_symbol(table, '‚äò', "\\oslash", "element_division", "ELEMENT_DIVISION", True, 7, "left")
    
    Note: Common Greek letters for AI/ML
    register_symbol(table, 'Œ±', "\\alpha", "alpha", "GREEK", False, 0, "none")
    register_symbol(table, 'Œ≤', "\\beta", "beta", "GREEK", False, 0, "none")
    register_symbol(table, 'Œ≥', "\\gamma", "gamma", "GREEK", False, 0, "none")
    register_symbol(table, 'Œ¥', "\\delta", "delta", "GREEK", False, 0, "none")
    register_symbol(table, 'Œµ', "\\epsilon", "epsilon", "GREEK", False, 0, "none")
    register_symbol(table, 'Œ∏', "\\theta", "theta", "GREEK", False, 0, "none")
    register_symbol(table, 'Œª', "\\lambda", "lambda", "GREEK", False, 0, "none")
    register_symbol(table, 'Œº', "\\mu", "mu", "GREEK", False, 0, "none")
    register_symbol(table, 'œÉ', "\\sigma", "sigma", "GREEK", False, 0, "none")
    register_symbol(table, 'œÑ', "\\tau", "tau", "GREEK", False, 0, "none")
    register_symbol(table, 'œÜ', "\\phi", "phi", "GREEK", False, 0, "none")
    register_symbol(table, 'œâ', "\\omega", "omega", "GREEK", False, 0, "none")
    
    Note: Capital Greek letters
    register_symbol(table, 'Œî', "\\Delta", "Delta", "GREEK", False, 0, "none")
    register_symbol(table, 'Œ£', "\\Sigma", "Sigma", "GREEK", False, 0, "none")
    register_symbol(table, 'Œ†', "\\Pi", "Pi", "GREEK", False, 0, "none")
    register_symbol(table, 'Œ©', "\\Omega", "Omega", "GREEK", False, 0, "none")
    register_symbol(table, 'Œõ', "\\Lambda", "Lambda", "GREEK", False, 0, "none")
    register_symbol(table, 'Œì', "\\Gamma", "Gamma", "GREEK", False, 0, "none")
    register_symbol(table, 'Œò', "\\Theta", "Theta", "GREEK", False, 0, "none")
    register_symbol(table, 'Œ¶', "\\Phi", "Phi", "GREEK", False, 0, "none")
    
    Note: Set operations
    register_symbol(table, '‚àà', "\\in", "element_of", "SET", False, 0, "none")
    register_symbol(table, '‚àâ', "\\notin", "not_element_of", "SET", False, 0, "none")
    register_symbol(table, '‚äÇ', "\\subset", "subset", "SET", False, 0, "none")
    register_symbol(table, '‚äÉ', "\\supset", "superset", "SET", False, 0, "none")
    register_symbol(table, '‚äÜ', "\\subseteq", "subset_or_equal", "SET", False, 0, "none")
    register_symbol(table, '‚äá', "\\supseteq", "superset_or_equal", "SET", False, 0, "none")
    register_symbol(table, '‚à™', "\\cup", "union", "SET", True, 5, "left")
    register_symbol(table, '‚à©', "\\cap", "intersection", "SET", True, 6, "left")
    register_symbol(table, '‚àÖ', "\\emptyset", "empty_set", "SET", False, 0, "none")
    
    Note: Logic symbols
    register_symbol(table, '‚àß', "\\wedge", "logical_and", "LOGIC", True, 3, "left")
    register_symbol(table, '‚à®', "\\vee", "logical_or", "LOGIC", True, 2, "left")
    register_symbol(table, '¬¨', "\\neg", "logical_not", "LOGIC", True, 9, "right")
    register_symbol(table, '‚àÄ', "\\forall", "for_all", "LOGIC", False, 0, "none")
    register_symbol(table, '‚àÉ', "\\exists", "exists", "LOGIC", False, 0, "none")
    register_symbol(table, '‚áí', "\\implies", "implies", "LOGIC", True, 1, "right")
    register_symbol(table, '‚áî', "\\iff", "if_and_only_if", "LOGIC", True, 1, "left")
    
    Note: Comparison symbols
    register_symbol(table, '‚â§', "\\leq", "less_than_or_equal", "COMPARISON", True, 4, "left")
    register_symbol(table, '‚â•', "\\geq", "greater_than_or_equal", "COMPARISON", True, 4, "left")
    register_symbol(table, '‚â†', "\\neq", "not_equal", "COMPARISON", True, 4, "left")
    register_symbol(table, '‚âà', "\\approx", "approximately", "COMPARISON", True, 4, "left")
    register_symbol(table, '‚â°', "\\equiv", "equivalent", "COMPARISON", True, 4, "left")
    
    Note: Arrow symbols
    register_symbol(table, '‚Üí', "\\rightarrow", "arrow_right", "ARROW", False, 0, "none")
    register_symbol(table, '‚Üê', "\\leftarrow", "arrow_left", "ARROW", False, 0, "none")
    register_symbol(table, '‚Üî', "\\leftrightarrow", "arrow_both", "ARROW", False, 0, "none")
    register_symbol(table, '‚áí', "\\Rightarrow", "double_arrow_right", "ARROW", False, 0, "none")
    register_symbol(table, '‚áê', "\\Leftarrow", "double_arrow_left", "ARROW", False, 0, "none")
    
    Note: Matrix and vector operations
    register_symbol(table, '‚ä§', "\\top", "transpose", "MATRIX", False, 0, "none")
    register_symbol(table, '‚ä•', "\\bot", "perpendicular", "MATRIX", False, 0, "none")
    register_symbol(table, '¬∑', "\\cdot", "dot_product", "MATRIX", True, 7, "left")
    register_symbol(table, '√ó', "\\times", "cross_product", "MATRIX", True, 7, "left")
    
    Return table
End Process

Process called "register_symbol" that takes table as MathSymbolTable, unicode as Character, latex as String, canonical as String, sym_type as String, is_op as Boolean, prec as Integer, assoc as String returns Nothing:
    Let symbol be MathSymbol with
        unicode_char as unicode,
        latex_name as latex,
        canonical_name as canonical,
        symbol_type as sym_type,
        is_operator as is_op,
        precedence as prec,
        associativity as assoc
    End MathSymbol
    
    Note: Store in main symbol table
    Collections.dict_set(table.symbols, char_to_string(unicode), symbol)
    
    Note: Store in LaTeX lookup
    Collections.dict_set(table.latex_lookup, latex, symbol)
    
    Note: Store in canonical lookup
    Collections.dict_set(table.canonical_lookup, canonical, symbol)
    
    Note: Add to operator list if applicable
    If is_op:
        Collections.list_append(table.operator_symbols, symbol)
    End If
End Process

Note: =====================================================================
Note: LATEX INPUT CONVERSION
Note: =====================================================================

Process called "convert_latex_sequence" that takes table as MathSymbolTable, text as String, position as Integer returns Integer:
    Note: Check if text at position starts with a LaTeX command
    
    If Not char_equals(get_char_at(text, position), '\\'):
        Return 0
    End If
    
    Note: Extract LaTeX command
    Let command_end be position plus 1
    While command_end is less than string_length(text):
        Let ch be get_char_at(text, command_end)
        If Not is_latex_command_char(ch):
            Break
        End If
        Set command_end to command_end plus 1
    End While
    
    Let latex_command be string_substring(text, position, command_end)
    
    Note: Look up the symbol
    If Collections.dict_has_key(table.latex_lookup, latex_command):
        Return command_end minus position
    End If
    
    Return 0
End Process

Process called "get_symbol_from_latex" that takes table as MathSymbolTable, latex_command as String returns MathSymbol:
    If Collections.dict_has_key(table.latex_lookup, latex_command):
        Return Collections.dict_get(table.latex_lookup, latex_command)
    End If
    
    Return create_null_symbol()
End Process

Process called "is_latex_command_char" that takes ch as Character returns Boolean:
    Note: LaTeX commands contain letters and underscores
    Let code be char_to_int(ch)
    
    Note: Check for lowercase letter
    If code is greater than or equal to 97 And code is less than or equal to 122:
        Return True
    End If
    
    Note: Check for uppercase letter
    If code is greater than or equal to 65 And code is less than or equal to 90:
        Return True
    End If
    
    Note: Check for underscore
    If char_equals(ch, '_'):
        Return True
    End If
    
    Return False
End Process

Note: =====================================================================
Note: SYMBOL RECOGNITION
Note: =====================================================================

Process called "is_math_symbol" that takes table as MathSymbolTable, ch as Character returns Boolean:
    Let char_str be char_to_string(ch)
    Return Collections.dict_has_key(table.symbols, char_str)
End Process

Process called "get_math_symbol" that takes table as MathSymbolTable, ch as Character returns MathSymbol:
    Let char_str be char_to_string(ch)
    If Collections.dict_has_key(table.symbols, char_str):
        Return Collections.dict_get(table.symbols, char_str)
    End If
    
    Return create_null_symbol()
End Process

Process called "is_math_operator" that takes table as MathSymbolTable, ch as Character returns Boolean:
    Let symbol be get_math_symbol(table, ch)
    Return symbol.is_operator
End Process

Process called "get_canonical_name" that takes table as MathSymbolTable, ch as Character, mode as String returns String:
    Let symbol be get_math_symbol(table, ch)
    
    If string_equals(mode, "canon"):
        Return symbol.canonical_name
    End If
    
    Return char_to_string(ch)
End Process

Note: =====================================================================
Note: MODE CONVERSION
Note: =====================================================================

Process called "convert_to_canon_mode" that takes table as MathSymbolTable, text as String returns String:
    Let result be ""
    Let i be 0
    
    While i is less than string_length(text):
        Let ch be get_char_at(text, i)
        
        If is_math_symbol(table, ch):
            Let symbol be get_math_symbol(table, ch)
            Set result to string_concat(result, " ")
            Set result to string_concat(result, symbol.canonical_name)
            Set result to string_concat(result, " ")
        Otherwise:
            Set result to string_concat(result, char_to_string(ch))
        End If
        
        Set i to i plus 1
    End While
    
    Return result
End Process

Process called "convert_from_canon_mode" that takes table as MathSymbolTable, text as String returns String:
    Note: Convert canonical names back to Unicode symbols
    Let result be text
    
    Note: Iterate through all symbols and replace canonical names
    Let symbol_keys be Collections.dict_keys(table.canonical_lookup)
    For Each canonical_name in symbol_keys:
        Let symbol be Collections.dict_get(table.canonical_lookup, canonical_name)
        Let pattern be string_concat(" ", canonical_name)
        Set pattern to string_concat(pattern, " ")
        Let replacement be char_to_string(symbol.unicode_char)
        Set result to string_replace_all(result, pattern, replacement)
    End For
    
    Return result
End Process

Note: =====================================================================
Note: OPERATOR INTEGRATION
Note: =====================================================================

Process called "get_tensor_operators" that takes table as MathSymbolTable returns Collections.List:
    Let operators be Collections.create_list()
    
    For i from 0 to Collections.list_length(table.operator_symbols) minus 1:
        Let symbol be Collections.list_get(table.operator_symbols, i)
        If string_starts_with(symbol.symbol_type, "TENSOR"):
            Collections.list_append(operators, symbol)
        End If
    End For
    
    Return operators
End Process

Process called "get_operator_precedence" that takes table as MathSymbolTable, ch as Character returns Integer:
    Let symbol be get_math_symbol(table, ch)
    If symbol.is_operator:
        Return symbol.precedence
    End If
    Return 0
End Process

Process called "get_operator_associativity" that takes table as MathSymbolTable, ch as Character returns String:
    Let symbol be get_math_symbol(table, ch)
    If symbol.is_operator:
        Return symbol.associativity
    End If
    Return "none"
End Process

Note: =====================================================================
Note: UTILITY FUNCTIONS
Note: =====================================================================

Process called "create_null_symbol" returns MathSymbol:
    Return MathSymbol with
        unicode_char as '\0',
        latex_name as "",
        canonical_name as "",
        symbol_type as "UNKNOWN",
        is_operator as False,
        precedence as 0,
        associativity as "none"
    End MathSymbol
End Process

Process called "char_to_string" that takes ch as Character returns String:
    Let result be ""
    Return result concatenated with ch
End Process

Process called "string_substring" that takes text as String, start as Integer, end as Integer returns String:
    Let result be ""
    For i from start to end minus 1:
        Set result to string_concat(result, char_to_string(get_char_at(text, i)))
    End For
    Return result
End Process

Process called "string_concat" that takes s1 as String, s2 as String returns String:
    Return s1 concatenated with s2
End Process

Process called "string_length" that takes text as String returns Integer:
    Let count be 0
    For Each ch in text:
        Set count to count plus 1
    End For
    Return count
End Process

Process called "get_char_at" that takes text as String, index as Integer returns Character:
    Let i be 0
    For Each ch in text:
        If i is equal to index:
            Return ch
        End If
        Set i to i plus 1
    End For
    Return '\0'
End Process

Process called "char_equals" that takes c1 as Character, c2 as Character returns Boolean:
    Return char_to_int(c1) is equal to char_to_int(c2)
End Process

Process called "char_to_int" that takes ch as Character returns Integer:
    Return ch as Integer
End Process

Process called "string_equals" that takes s1 as String, s2 as String returns Boolean:
    If string_length(s1) is not equal to string_length(s2):
        Return False
    End If
    
    For i from 0 to string_length(s1) minus 1:
        If Not char_equals(get_char_at(s1, i), get_char_at(s2, i)):
            Return False
        End If
    End For
    
    Return True
End Process

Process called "string_starts_with" that takes text as String, prefix as String returns Boolean:
    If string_length(text) is less than string_length(prefix):
        Return False
    End If
    
    For i from 0 to string_length(prefix) minus 1:
        If Not char_equals(get_char_at(text, i), get_char_at(prefix, i)):
            Return False
        End If
    End For
    
    Return True
End Process

Process called "string_replace_all" that takes text as String, pattern as String, replacement as String returns String:
    Let result be ""
    Let i be 0
    Let text_len be string_length(text)
    Let pattern_len be string_length(pattern)
    
    While i is less than text_len:
        If i plus pattern_len is less than or equal to text_len:
            Let chunk be string_substring(text, i, i plus pattern_len)
            If string_equals(chunk, pattern):
                Set result to string_concat(result, replacement)
                Set i to i plus pattern_len
            Otherwise:
                Set result to string_concat(result, char_to_string(get_char_at(text, i)))
                Set i to i plus 1
            End If
        Otherwise:
            Set result to string_concat(result, char_to_string(get_char_at(text, i)))
            Set i to i plus 1
        End If
    End While
    
    Return result
End Process

Note: =====================================================================
Note: EXTENDED SYMBOL SUPPORT (TIER 2 - VIA LIBRARY)
Note: =====================================================================

Process called "load_extended_symbols" that takes table as MathSymbolTable, symbol_domain as String returns Nothing:
    Note: Load domain-specific extended symbols based on the domain identifier
    Note: All symbols are built into Runa, not loaded from external libraries
    
    If string_equals(symbol_domain, "quantum"):
        Note: Quantum computing symbols
        register_symbol(table, '‚ü®', "\\langle", "bra", "QUANTUM", False, 0, "none")
        register_symbol(table, '‚ü©', "\\rangle", "ket", "QUANTUM", False, 0, "none")
        register_symbol(table, '|', "\\vert", "quantum_state", "QUANTUM", False, 0, "none")
        register_symbol(table, '‚äó', "\\otimes", "tensor_product", "QUANTUM", True, 7, "left")
        register_symbol(table, '‚Ä†', "\\dagger", "hermitian_conjugate", "QUANTUM", False, 0, "none")
    Otherwise If string_equals(symbol_domain, "topology"):
        Note: Topology symbols
        register_symbol(table, '‚àÇ', "\\partial", "boundary", "TOPOLOGY", False, 0, "none")
        register_symbol(table, '¬∞', "\\circ", "interior", "TOPOLOGY", False, 0, "none")
        register_symbol(table, '‚âÖ', "\\cong", "homeomorphic", "TOPOLOGY", True, 4, "left")
        register_symbol(table, '‚äî', "\\sqcup", "disjoint_union", "TOPOLOGY", True, 5, "left")
    Otherwise If string_equals(symbol_domain, "category_theory"):
        Note: Category theory symbols
        register_symbol(table, '‚àò', "\\circ", "composition", "CATEGORY", True, 8, "right")
        register_symbol(table, '‚áí', "\\Rightarrow", "morphism", "CATEGORY", False, 0, "none")
        register_symbol(table, '‚âÉ', "\\simeq", "isomorphic", "CATEGORY", True, 4, "left")
        register_symbol(table, '‚ä£', "\\dashv", "adjoint", "CATEGORY", True, 4, "left")
    Otherwise If string_equals(symbol_domain, "statistics"):
        Note: Statistical symbols
        register_symbol(table, 'ùîº', "\\mathbb{E}", "expectation", "STATISTICS", False, 0, "none")
        register_symbol(table, '‚Ñô', "\\mathbb{P}", "probability", "STATISTICS", False, 0, "none")
        register_symbol(table, 'ùïç', "\\mathbb{V}", "variance", "STATISTICS", False, 0, "none")
        register_symbol(table, '‚àº', "\\sim", "distributed_as", "STATISTICS", True, 4, "left")
        register_symbol(table, '‚â´', "\\gg", "much_greater", "STATISTICS", True, 4, "left")
        register_symbol(table, '‚â™', "\\ll", "much_less", "STATISTICS", True, 4, "left")
    Otherwise If string_equals(symbol_domain, "physics"):
        Note: Physics symbols
        register_symbol(table, '‚Ñè', "\\hbar", "reduced_planck", "PHYSICS", False, 0, "none")
        register_symbol(table, '‚àá', "\\nabla", "del_operator", "PHYSICS", False, 0, "none")
        register_symbol(table, '‚ñ°', "\\square", "d_alembertian", "PHYSICS", False, 0, "none")
        register_symbol(table, '‚üÇ', "\\perp", "orthogonal", "PHYSICS", True, 4, "left")
    End If
End Process

Process called "register_custom_symbol" that takes table as MathSymbolTable, unicode as Character, latex as String, canonical as String returns Nothing:
    Note: Allow runtime registration of custom symbols
    register_symbol(table, unicode, latex, canonical, "CUSTOM", False, 0, "none")
End Process