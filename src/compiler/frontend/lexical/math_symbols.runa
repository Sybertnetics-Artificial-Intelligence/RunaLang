Note:
compiler/frontend/lexical/math_symbols.runa
Mathematical Symbol Recognition and LaTeX Support

This module provides core mathematical symbol support for the lexer including:
- Core math symbols (∑, ∏, ∫, ∂, ∇, ∞)
- Greek letters (α, β, γ, δ, etc.)
- Tensor operation symbols (⊗, ⊕, ⊙)
- LaTeX-style input conversion (\alpha → α)
- Support for both Canon and developer modes
- Two-tier architecture: core symbols here, extended via library
:End Note

Import Module "compiler/internal/collections" as Collections
Import Module "compiler/internal/string_utils" as StringUtils

Note: =====================================================================
Note: MATH SYMBOL DATA STRUCTURES
Note: =====================================================================

Type called "MathSymbol":
    unicode_char as Character
    latex_name as String
    canonical_name as String
    symbol_type as String
    is_operator as Boolean
    precedence as Integer
    associativity as String
End Type

Type called "MathSymbolTable":
    symbols as Collections.Dictionary
    latex_lookup as Collections.Dictionary
    canonical_lookup as Collections.Dictionary
    operator_symbols as Collections.List
End Type

Note: =====================================================================
Note: CORE MATH SYMBOLS (TIER 1 - BUILT INTO LEXER)
Note: =====================================================================

Process called "create_math_symbol_table" returns MathSymbolTable:
    Let table be MathSymbolTable with
        symbols as Collections.create_dictionary(),
        latex_lookup as Collections.create_dictionary(),
        canonical_lookup as Collections.create_dictionary(),
        operator_symbols as Collections.create_list()
    End MathSymbolTable
    
    Note: Core mathematical operators
    register_symbol(table, '∑', "\\sum", "sum", "SUMMATION", False, 0, "none")
    register_symbol(table, '∏', "\\prod", "product", "PRODUCT", False, 0, "none")
    register_symbol(table, '∫', "\\int", "integral", "INTEGRAL", False, 0, "none")
    register_symbol(table, '∂', "\\partial", "partial", "PARTIAL", False, 0, "none")
    register_symbol(table, '∇', "\\nabla", "nabla", "NABLA", False, 0, "none")
    register_symbol(table, '∞', "\\infty", "infinity", "INFINITY", False, 0, "none")
    
    Note: Tensor operation symbols (as operators)
    register_symbol(table, '⊗', "\\otimes", "tensor_product", "TENSOR_PRODUCT", True, 7, "left")
    register_symbol(table, '⊕', "\\oplus", "direct_sum", "DIRECT_SUM", True, 6, "left")
    register_symbol(table, '⊙', "\\odot", "hadamard_product", "HADAMARD_PRODUCT", True, 7, "left")
    register_symbol(table, '⊘', "\\oslash", "element_division", "ELEMENT_DIVISION", True, 7, "left")
    
    Note: Common Greek letters for AI/ML
    register_symbol(table, 'α', "\\alpha", "alpha", "GREEK", False, 0, "none")
    register_symbol(table, 'β', "\\beta", "beta", "GREEK", False, 0, "none")
    register_symbol(table, 'γ', "\\gamma", "gamma", "GREEK", False, 0, "none")
    register_symbol(table, 'δ', "\\delta", "delta", "GREEK", False, 0, "none")
    register_symbol(table, 'ε', "\\epsilon", "epsilon", "GREEK", False, 0, "none")
    register_symbol(table, 'θ', "\\theta", "theta", "GREEK", False, 0, "none")
    register_symbol(table, 'λ', "\\lambda", "lambda", "GREEK", False, 0, "none")
    register_symbol(table, 'μ', "\\mu", "mu", "GREEK", False, 0, "none")
    register_symbol(table, 'σ', "\\sigma", "sigma", "GREEK", False, 0, "none")
    register_symbol(table, 'τ', "\\tau", "tau", "GREEK", False, 0, "none")
    register_symbol(table, 'φ', "\\phi", "phi", "GREEK", False, 0, "none")
    register_symbol(table, 'ω', "\\omega", "omega", "GREEK", False, 0, "none")
    
    Note: Capital Greek letters
    register_symbol(table, 'Δ', "\\Delta", "Delta", "GREEK", False, 0, "none")
    register_symbol(table, 'Σ', "\\Sigma", "Sigma", "GREEK", False, 0, "none")
    register_symbol(table, 'Π', "\\Pi", "Pi", "GREEK", False, 0, "none")
    register_symbol(table, 'Ω', "\\Omega", "Omega", "GREEK", False, 0, "none")
    register_symbol(table, 'Λ', "\\Lambda", "Lambda", "GREEK", False, 0, "none")
    register_symbol(table, 'Γ', "\\Gamma", "Gamma", "GREEK", False, 0, "none")
    register_symbol(table, 'Θ', "\\Theta", "Theta", "GREEK", False, 0, "none")
    register_symbol(table, 'Φ', "\\Phi", "Phi", "GREEK", False, 0, "none")
    
    Note: Set operations
    register_symbol(table, '∈', "\\in", "element_of", "SET", False, 0, "none")
    register_symbol(table, '∉', "\\notin", "not_element_of", "SET", False, 0, "none")
    register_symbol(table, '⊂', "\\subset", "subset", "SET", False, 0, "none")
    register_symbol(table, '⊃', "\\supset", "superset", "SET", False, 0, "none")
    register_symbol(table, '⊆', "\\subseteq", "subset_or_equal", "SET", False, 0, "none")
    register_symbol(table, '⊇', "\\supseteq", "superset_or_equal", "SET", False, 0, "none")
    register_symbol(table, '∪', "\\cup", "union", "SET", True, 5, "left")
    register_symbol(table, '∩', "\\cap", "intersection", "SET", True, 6, "left")
    register_symbol(table, '∅', "\\emptyset", "empty_set", "SET", False, 0, "none")
    
    Note: Logic symbols
    register_symbol(table, '∧', "\\wedge", "logical_and", "LOGIC", True, 3, "left")
    register_symbol(table, '∨', "\\vee", "logical_or", "LOGIC", True, 2, "left")
    register_symbol(table, '¬', "\\neg", "logical_not", "LOGIC", True, 9, "right")
    register_symbol(table, '∀', "\\forall", "for_all", "LOGIC", False, 0, "none")
    register_symbol(table, '∃', "\\exists", "exists", "LOGIC", False, 0, "none")
    register_symbol(table, '⇒', "\\implies", "implies", "LOGIC", True, 1, "right")
    register_symbol(table, '⇔', "\\iff", "if_and_only_if", "LOGIC", True, 1, "left")
    
    Note: Comparison symbols
    register_symbol(table, '≤', "\\leq", "less_than_or_equal", "COMPARISON", True, 4, "left")
    register_symbol(table, '≥', "\\geq", "greater_than_or_equal", "COMPARISON", True, 4, "left")
    register_symbol(table, '≠', "\\neq", "not_equal", "COMPARISON", True, 4, "left")
    register_symbol(table, '≈', "\\approx", "approximately", "COMPARISON", True, 4, "left")
    register_symbol(table, '≡', "\\equiv", "equivalent", "COMPARISON", True, 4, "left")
    
    Note: Arrow symbols
    register_symbol(table, '→', "\\rightarrow", "arrow_right", "ARROW", False, 0, "none")
    register_symbol(table, '←', "\\leftarrow", "arrow_left", "ARROW", False, 0, "none")
    register_symbol(table, '↔', "\\leftrightarrow", "arrow_both", "ARROW", False, 0, "none")
    register_symbol(table, '⇒', "\\Rightarrow", "double_arrow_right", "ARROW", False, 0, "none")
    register_symbol(table, '⇐', "\\Leftarrow", "double_arrow_left", "ARROW", False, 0, "none")
    
    Note: Matrix and vector operations
    register_symbol(table, '⊤', "\\top", "transpose", "MATRIX", False, 0, "none")
    register_symbol(table, '⊥', "\\bot", "perpendicular", "MATRIX", False, 0, "none")
    register_symbol(table, '·', "\\cdot", "dot_product", "MATRIX", True, 7, "left")
    register_symbol(table, '×', "\\times", "cross_product", "MATRIX", True, 7, "left")
    
    Return table
End Process

Process called "register_symbol" that takes table as MathSymbolTable, unicode as Character, latex as String, canonical as String, sym_type as String, is_op as Boolean, prec as Integer, assoc as String returns Nothing:
    Let symbol be MathSymbol with
        unicode_char as unicode,
        latex_name as latex,
        canonical_name as canonical,
        symbol_type as sym_type,
        is_operator as is_op,
        precedence as prec,
        associativity as assoc
    End MathSymbol
    
    Note: Store in main symbol table
    Collections.dict_set(table.symbols, char_to_string(unicode), symbol)
    
    Note: Store in LaTeX lookup
    Collections.dict_set(table.latex_lookup, latex, symbol)
    
    Note: Store in canonical lookup
    Collections.dict_set(table.canonical_lookup, canonical, symbol)
    
    Note: Add to operator list if applicable
    If is_op:
        Collections.list_append(table.operator_symbols, symbol)
    End If
End Process

Note: =====================================================================
Note: LATEX INPUT CONVERSION
Note: =====================================================================

Process called "convert_latex_sequence" that takes table as MathSymbolTable, text as String, position as Integer returns Integer:
    Note: Check if text at position starts with a LaTeX command
    
    If Not char_equals(get_char_at(text, position), '\\'):
        Return 0
    End If
    
    Note: Extract LaTeX command
    Let command_end be position plus 1
    While command_end is less than string_length(text):
        Let ch be get_char_at(text, command_end)
        If Not is_latex_command_char(ch):
            Break
        End If
        Set command_end to command_end plus 1
    End While
    
    Let latex_command be string_substring(text, position, command_end)
    
    Note: Look up the symbol
    If Collections.dict_has_key(table.latex_lookup, latex_command):
        Return command_end minus position
    End If
    
    Return 0
End Process

Process called "get_symbol_from_latex" that takes table as MathSymbolTable, latex_command as String returns MathSymbol:
    If Collections.dict_has_key(table.latex_lookup, latex_command):
        Return Collections.dict_get(table.latex_lookup, latex_command)
    End If
    
    Return create_null_symbol()
End Process

Process called "is_latex_command_char" that takes ch as Character returns Boolean:
    Note: LaTeX commands contain letters and underscores
    Let code be char_to_int(ch)
    
    Note: Check for lowercase letter
    If code is greater than or equal to 97 And code is less than or equal to 122:
        Return True
    End If
    
    Note: Check for uppercase letter
    If code is greater than or equal to 65 And code is less than or equal to 90:
        Return True
    End If
    
    Note: Check for underscore
    If char_equals(ch, '_'):
        Return True
    End If
    
    Return False
End Process

Note: =====================================================================
Note: SYMBOL RECOGNITION
Note: =====================================================================

Process called "is_math_symbol" that takes table as MathSymbolTable, ch as Character returns Boolean:
    Let char_str be char_to_string(ch)
    Return Collections.dict_has_key(table.symbols, char_str)
End Process

Process called "get_math_symbol" that takes table as MathSymbolTable, ch as Character returns MathSymbol:
    Let char_str be char_to_string(ch)
    If Collections.dict_has_key(table.symbols, char_str):
        Return Collections.dict_get(table.symbols, char_str)
    End If
    
    Return create_null_symbol()
End Process

Process called "is_math_operator" that takes table as MathSymbolTable, ch as Character returns Boolean:
    Let symbol be get_math_symbol(table, ch)
    Return symbol.is_operator
End Process

Process called "get_canonical_name" that takes table as MathSymbolTable, ch as Character, mode as String returns String:
    Let symbol be get_math_symbol(table, ch)
    
    If string_equals(mode, "canon"):
        Return symbol.canonical_name
    End If
    
    Return char_to_string(ch)
End Process

Note: =====================================================================
Note: MODE CONVERSION
Note: =====================================================================

Process called "convert_to_canon_mode" that takes table as MathSymbolTable, text as String returns String:
    Let result be ""
    Let i be 0
    
    While i is less than string_length(text):
        Let ch be get_char_at(text, i)
        
        If is_math_symbol(table, ch):
            Let symbol be get_math_symbol(table, ch)
            Set result to string_concat(result, " ")
            Set result to string_concat(result, symbol.canonical_name)
            Set result to string_concat(result, " ")
        Otherwise:
            Set result to string_concat(result, char_to_string(ch))
        End If
        
        Set i to i plus 1
    End While
    
    Return result
End Process

Process called "convert_from_canon_mode" that takes table as MathSymbolTable, text as String returns String:
    Note: Convert canonical names back to Unicode symbols
    Let result be text
    
    Note: Iterate through all symbols and replace canonical names
    Let symbol_keys be Collections.dict_keys(table.canonical_lookup)
    For Each canonical_name in symbol_keys:
        Let symbol be Collections.dict_get(table.canonical_lookup, canonical_name)
        Let pattern be string_concat(" ", canonical_name)
        Set pattern to string_concat(pattern, " ")
        Let replacement be char_to_string(symbol.unicode_char)
        Set result to string_replace_all(result, pattern, replacement)
    End For
    
    Return result
End Process

Note: =====================================================================
Note: OPERATOR INTEGRATION
Note: =====================================================================

Process called "get_tensor_operators" that takes table as MathSymbolTable returns Collections.List:
    Let operators be Collections.create_list()
    
    For i from 0 to Collections.list_length(table.operator_symbols) minus 1:
        Let symbol be Collections.list_get(table.operator_symbols, i)
        If string_starts_with(symbol.symbol_type, "TENSOR"):
            Collections.list_append(operators, symbol)
        End If
    End For
    
    Return operators
End Process

Process called "get_operator_precedence" that takes table as MathSymbolTable, ch as Character returns Integer:
    Let symbol be get_math_symbol(table, ch)
    If symbol.is_operator:
        Return symbol.precedence
    End If
    Return 0
End Process

Process called "get_operator_associativity" that takes table as MathSymbolTable, ch as Character returns String:
    Let symbol be get_math_symbol(table, ch)
    If symbol.is_operator:
        Return symbol.associativity
    End If
    Return "none"
End Process

Note: =====================================================================
Note: UTILITY FUNCTIONS
Note: =====================================================================

Process called "create_null_symbol" returns MathSymbol:
    Return MathSymbol with
        unicode_char as '\0',
        latex_name as "",
        canonical_name as "",
        symbol_type as "UNKNOWN",
        is_operator as False,
        precedence as 0,
        associativity as "none"
    End MathSymbol
End Process

Process called "char_to_string" that takes ch as Character returns String:
    Let result be ""
    Return result concatenated with ch
End Process

Process called "string_substring" that takes text as String, start as Integer, end as Integer returns String:
    Let result be ""
    For i from start to end minus 1:
        Set result to string_concat(result, char_to_string(get_char_at(text, i)))
    End For
    Return result
End Process

Process called "string_concat" that takes s1 as String, s2 as String returns String:
    Return s1 concatenated with s2
End Process

Process called "string_length" that takes text as String returns Integer:
    Let count be 0
    For Each ch in text:
        Set count to count plus 1
    End For
    Return count
End Process

Process called "get_char_at" that takes text as String, index as Integer returns Character:
    Let i be 0
    For Each ch in text:
        If i is equal to index:
            Return ch
        End If
        Set i to i plus 1
    End For
    Return '\0'
End Process

Process called "char_equals" that takes c1 as Character, c2 as Character returns Boolean:
    Return char_to_int(c1) is equal to char_to_int(c2)
End Process

Process called "char_to_int" that takes ch as Character returns Integer:
    Return ch as Integer
End Process

Process called "string_equals" that takes s1 as String, s2 as String returns Boolean:
    If string_length(s1) is not equal to string_length(s2):
        Return False
    End If
    
    For i from 0 to string_length(s1) minus 1:
        If Not char_equals(get_char_at(s1, i), get_char_at(s2, i)):
            Return False
        End If
    End For
    
    Return True
End Process

Process called "string_starts_with" that takes text as String, prefix as String returns Boolean:
    If string_length(text) is less than string_length(prefix):
        Return False
    End If
    
    For i from 0 to string_length(prefix) minus 1:
        If Not char_equals(get_char_at(text, i), get_char_at(prefix, i)):
            Return False
        End If
    End For
    
    Return True
End Process

Process called "string_replace_all" that takes text as String, pattern as String, replacement as String returns String:
    Let result be ""
    Let i be 0
    Let text_len be string_length(text)
    Let pattern_len be string_length(pattern)
    
    While i is less than text_len:
        If i plus pattern_len is less than or equal to text_len:
            Let chunk be string_substring(text, i, i plus pattern_len)
            If string_equals(chunk, pattern):
                Set result to string_concat(result, replacement)
                Set i to i plus pattern_len
            Otherwise:
                Set result to string_concat(result, char_to_string(get_char_at(text, i)))
                Set i to i plus 1
            End If
        Otherwise:
            Set result to string_concat(result, char_to_string(get_char_at(text, i)))
            Set i to i plus 1
        End If
    End While
    
    Return result
End Process

Note: =====================================================================
Note: EXTENDED SYMBOL SUPPORT (TIER 2 - VIA LIBRARY)
Note: =====================================================================

Process called "load_extended_symbols" that takes table as MathSymbolTable, symbol_domain as String returns Nothing:
    Note: Load domain-specific extended symbols based on the domain identifier
    Note: All symbols are built into Runa, not loaded from external libraries
    
    If string_equals(symbol_domain, "quantum"):
        Note: Quantum computing symbols
        register_symbol(table, '⟨', "\\langle", "bra", "QUANTUM", False, 0, "none")
        register_symbol(table, '⟩', "\\rangle", "ket", "QUANTUM", False, 0, "none")
        register_symbol(table, '|', "\\vert", "quantum_state", "QUANTUM", False, 0, "none")
        register_symbol(table, '⊗', "\\otimes", "tensor_product", "QUANTUM", True, 7, "left")
        register_symbol(table, '†', "\\dagger", "hermitian_conjugate", "QUANTUM", False, 0, "none")
    Otherwise If string_equals(symbol_domain, "topology"):
        Note: Topology symbols
        register_symbol(table, '∂', "\\partial", "boundary", "TOPOLOGY", False, 0, "none")
        register_symbol(table, '°', "\\circ", "interior", "TOPOLOGY", False, 0, "none")
        register_symbol(table, '≅', "\\cong", "homeomorphic", "TOPOLOGY", True, 4, "left")
        register_symbol(table, '⊔', "\\sqcup", "disjoint_union", "TOPOLOGY", True, 5, "left")
    Otherwise If string_equals(symbol_domain, "category_theory"):
        Note: Category theory symbols
        register_symbol(table, '∘', "\\circ", "composition", "CATEGORY", True, 8, "right")
        register_symbol(table, '⇒', "\\Rightarrow", "morphism", "CATEGORY", False, 0, "none")
        register_symbol(table, '≃', "\\simeq", "isomorphic", "CATEGORY", True, 4, "left")
        register_symbol(table, '⊣', "\\dashv", "adjoint", "CATEGORY", True, 4, "left")
    Otherwise If string_equals(symbol_domain, "statistics"):
        Note: Statistical symbols
        register_symbol(table, '𝔼', "\\mathbb{E}", "expectation", "STATISTICS", False, 0, "none")
        register_symbol(table, 'ℙ', "\\mathbb{P}", "probability", "STATISTICS", False, 0, "none")
        register_symbol(table, '𝕍', "\\mathbb{V}", "variance", "STATISTICS", False, 0, "none")
        register_symbol(table, '∼', "\\sim", "distributed_as", "STATISTICS", True, 4, "left")
        register_symbol(table, '≫', "\\gg", "much_greater", "STATISTICS", True, 4, "left")
        register_symbol(table, '≪', "\\ll", "much_less", "STATISTICS", True, 4, "left")
    Otherwise If string_equals(symbol_domain, "physics"):
        Note: Physics symbols
        register_symbol(table, 'ℏ', "\\hbar", "reduced_planck", "PHYSICS", False, 0, "none")
        register_symbol(table, '∇', "\\nabla", "del_operator", "PHYSICS", False, 0, "none")
        register_symbol(table, '□', "\\square", "d_alembertian", "PHYSICS", False, 0, "none")
        register_symbol(table, '⟂', "\\perp", "orthogonal", "PHYSICS", True, 4, "left")
    End If
End Process

Process called "register_custom_symbol" that takes table as MathSymbolTable, unicode as Character, latex as String, canonical as String returns Nothing:
    Note: Allow runtime registration of custom symbols
    register_symbol(table, unicode, latex, canonical, "CUSTOM", False, 0, "none")
End Process