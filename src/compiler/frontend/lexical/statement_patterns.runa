Note:
compiler/frontend/lexical/statement_patterns.runa
Statement Pattern Recognition

This module recognizes multi-word statement patterns including:
- Imperative assignment statements ("Increase x by 5")
- Import statements ("Import Module x as y")
- Control flow statements
- Natural language statement forms
:End Note

Import "compiler/internal/collections" as Collections
Import "compiler/internal/string_utils" as StringUtils
Import "compiler/frontend/lexical/keywords" as Keywords
Import "compiler/frontend/lexical/token_stream" as TokenStream

Note: =====================================================================
Note: STATEMENT PATTERN DEFINITIONS
Note: =====================================================================

@Reasoning
    Runa supports natural language statement forms that read like English.
    These patterns provide alternative ways to express common operations.
    "Increase count by 1" is equivalent to "count gets increased by 1".
@End Reasoning

Type called "StatementPattern":
    pattern_type as String           Note: Type of statement
    start_keyword as String          Note: First keyword in pattern
    middle_keywords as Collections.List  Note: Keywords in middle
    end_keyword as String            Note: Last keyword in pattern
    has_identifier as Boolean        Note: Whether pattern includes identifier
    has_expression as Boolean        Note: Whether pattern includes expression
    canonical_form as String         Note: Description of the pattern
End Type

Process called "get_imperative_patterns" returns Collections.List:
    Let patterns be Collections.create_list()
    
    Note: Increase pattern: "Increase <identifier> by <expression>"
    Collections.list_append(patterns, StatementPattern with
        pattern_type as "IMPERATIVE_INCREASE",
        start_keyword as "Increase",
        middle_keywords as create_single_item_list("by"),
        end_keyword as "",
        has_identifier as True,
        has_expression as True,
        canonical_form as "Increase ... by ..."
    End StatementPattern)
    
    Note: Decrease pattern: "Decrease <identifier> by <expression>"
    Collections.list_append(patterns, StatementPattern with
        pattern_type as "IMPERATIVE_DECREASE",
        start_keyword as "Decrease",
        middle_keywords as create_single_item_list("by"),
        end_keyword as "",
        has_identifier as True,
        has_expression as True,
        canonical_form as "Decrease ... by ..."
    End StatementPattern)
    
    Note: Multiply pattern: "Multiply <identifier> by <expression>"
    Collections.list_append(patterns, StatementPattern with
        pattern_type as "IMPERATIVE_MULTIPLY",
        start_keyword as "Multiply",
        middle_keywords as create_single_item_list("by"),
        end_keyword as "",
        has_identifier as True,
        has_expression as True,
        canonical_form as "Multiply ... by ..."
    End StatementPattern)
    
    Note: Divide pattern: "Divide <identifier> by <expression>"
    Collections.list_append(patterns, StatementPattern with
        pattern_type as "IMPERATIVE_DIVIDE",
        start_keyword as "Divide",
        middle_keywords as create_single_item_list("by"),
        end_keyword as "",
        has_identifier as True,
        has_expression as True,
        canonical_form as "Divide ... by ..."
    End StatementPattern)
    
    Note: Scale pattern: "Scale <identifier> by <expression>"
    Collections.list_append(patterns, StatementPattern with
        pattern_type as "IMPERATIVE_SCALE",
        start_keyword as "Scale",
        middle_keywords as create_single_item_list("by"),
        end_keyword as "",
        has_identifier as True,
        has_expression as True,
        canonical_form as "Scale ... by ..."
    End StatementPattern)
    
    Note: Scale down pattern: "Scale <identifier> down by <expression>"
    Collections.list_append(patterns, StatementPattern with
        pattern_type as "IMPERATIVE_SCALE_DOWN",
        start_keyword as "Scale",
        middle_keywords as create_two_item_list("down", "by"),
        end_keyword as "",
        has_identifier as True,
        has_expression as True,
        canonical_form as "Scale ... down by ..."
    End StatementPattern)
    
    Return patterns
End Process

Process called "get_import_patterns" returns Collections.List:
    Let patterns be Collections.create_list()
    
    Note: Import Module pattern: "Import Module <path> as <identifier>"
    Collections.list_append(patterns, StatementPattern with
        pattern_type as "IMPORT_MODULE",
        start_keyword as "Import",
        middle_keywords as create_two_item_list("Module", "as"),
        end_keyword as "",
        has_identifier as True,
        has_expression as True,  Note: Path is treated as expression
        canonical_form as "Import Module ... as ..."
    End StatementPattern)
    
    Note: Import from pattern: "Import <items> from <module>"
    Collections.list_append(patterns, StatementPattern with
        pattern_type as "IMPORT_FROM",
        start_keyword as "Import",
        middle_keywords as create_single_item_list("from"),
        end_keyword as "",
        has_identifier as True,
        has_expression as True,
        canonical_form as "Import ... from ..."
    End StatementPattern)
    
    Return patterns
End Process

Process called "get_all_statement_patterns" returns Collections.List:
    Let all_patterns be Collections.create_list()
    
    Note: Add imperative patterns
    Let imperative be get_imperative_patterns()
    For i from 0 to Collections.list_length(imperative) minus 1:
        Collections.list_append(all_patterns, Collections.list_get(imperative, i))
    End For
    
    Note: Add import patterns
    Let imports be get_import_patterns()
    For i from 0 to Collections.list_length(imports) minus 1:
        Collections.list_append(all_patterns, Collections.list_get(imports, i))
    End For
    
    Return all_patterns
End Process

Note: =====================================================================
Note: PATTERN RECOGNITION STATE
Note: =====================================================================

@Reasoning
    Track state while recognizing statement patterns.
    This helps identify which pattern we're in and what we're expecting next.
@End Reasoning

Type called "PatternState":
    is_active as Boolean
    current_pattern as StatementPattern
    tokens_seen as Collections.List
    expecting as String  Note: "identifier", "keyword", "expression"
    identifier_start as Integer
    identifier_end as Integer
End Type

Process called "create_pattern_state" returns PatternState:
    Return PatternState with
        is_active as False,
        current_pattern as create_null_pattern(),
        tokens_seen as Collections.create_list(),
        expecting as "",
        identifier_start as 0,
        identifier_end as 0
    End PatternState
End Process

Process called "create_null_pattern" returns StatementPattern:
    Return StatementPattern with
        pattern_type as "",
        start_keyword as "",
        middle_keywords as Collections.create_list(),
        end_keyword as "",
        has_identifier as False,
        has_expression as False,
        canonical_form as ""
    End StatementPattern
End Process

Note: =====================================================================
Note: PATTERN MATCHING
Note: =====================================================================

@Reasoning
    Check if a keyword starts any statement pattern.
    This is called by the lexer when it encounters keywords.
@End Reasoning

Let all_patterns be get_all_statement_patterns()
Let pattern_start_lookup be create_pattern_start_lookup()

Process called "create_pattern_start_lookup" returns Collections.Dictionary:
    Let lookup be Collections.create_dictionary()
    
    For i from 0 to Collections.list_length(all_patterns) minus 1:
        Let pattern be Collections.list_get(all_patterns, i)
        
        Note: Check if this start keyword already has patterns
        If Not Collections.dict_has_key(lookup, pattern.start_keyword):
            Collections.dict_set(lookup, pattern.start_keyword, Collections.create_list())
        End If
        
        Let pattern_list be Collections.dict_get(lookup, pattern.start_keyword)
        Collections.list_append(pattern_list, pattern)
    End For
    
    Return lookup
End Process

Process called "is_statement_pattern_start" that takes keyword as String returns Boolean:
    Return Collections.dict_has_key(pattern_start_lookup, keyword)
End Process

Process called "get_patterns_starting_with" that takes keyword as String returns Collections.List:
    If Collections.dict_has_key(pattern_start_lookup, keyword):
        Return Collections.dict_get(pattern_start_lookup, keyword)
    End If
    Return Collections.create_list()
End Process

Process called "match_pattern" that takes state as PatternState, token as String returns Boolean:
    Note: Check if token matches what we're expecting in the pattern
    
    If StringUtils.string_equals(state.expecting, "identifier"):
        Note: Any non-keyword can be an identifier
        If Not Keywords.is_keyword(token):
            Collections.list_append(state.tokens_seen, token)
            Note: Move to next expectation
            Update_pattern_expectation(state)
            Return True
        End If
    End If
    
    If StringUtils.string_equals(state.expecting, "keyword"):
        Note: Check if this is the expected keyword
        Let expected_keyword be get_next_expected_keyword(state)
        If StringUtils.string_equals(token, expected_keyword):
            Collections.list_append(state.tokens_seen, token)
            Update_pattern_expectation(state)
            Return True
        End If
    End If
    
    If StringUtils.string_equals(state.expecting, "expression"):
        Note: Expression parsing is handled by parser, not lexer
        Note: Just mark that we've seen the start of expression
        Return True
    End If
    
    Return False
End Process

Process called "get_next_expected_keyword" that takes state as PatternState returns String:
    Let tokens_count be Collections.list_length(state.tokens_seen)
    Let middle_keywords be state.current_pattern.middle_keywords
    
    Note: Find which middle keyword we're expecting
    Let keyword_index be 0
    For i from 0 to Collections.list_length(state.tokens_seen) minus 1:
        Let token be Collections.list_get(state.tokens_seen, i)
        If Keywords.is_keyword(token) And Not StringUtils.string_equals(token, state.current_pattern.start_keyword):
            Set keyword_index to keyword_index plus 1
        End If
    End For
    
    If keyword_index is less than Collections.list_length(middle_keywords):
        Return Collections.list_get(middle_keywords, keyword_index)
    End If
    
    Return state.current_pattern.end_keyword
End Process

Process called "update_pattern_expectation" that takes state as PatternState returns Nothing:
    Note: Update what we're expecting next based on what we've seen
    
    Let tokens_count be Collections.list_length(state.tokens_seen)
    
    If tokens_count is equal to 1:
        Note: Just saw start keyword
        If state.current_pattern.has_identifier:
            Set state.expecting to "identifier"
        Otherwise:
            Set state.expecting to "keyword"
        End If
    Otherwise:
        Note: Check if we need more keywords
        Let keywords_needed be Collections.list_length(state.current_pattern.middle_keywords)
        Let keywords_seen be count_keywords_seen(state)
        
        If keywords_seen is less than keywords_needed plus 1:
            Set state.expecting to "keyword"
        Otherwise If state.current_pattern.has_expression:
            Set state.expecting to "expression"
        Otherwise:
            Set state.expecting to "complete"
        End If
    End If
End Process

Process called "count_keywords_seen" that takes state as PatternState returns Integer:
    Let count be 0
    For i from 0 to Collections.list_length(state.tokens_seen) minus 1:
        Let token be Collections.list_get(state.tokens_seen, i)
        If Keywords.is_keyword(token):
            Set count to count plus 1
        End If
    End For
    Return count
End Process

Note: =====================================================================
Note: UTILITY FUNCTIONS
Note: =====================================================================

Process called "create_single_item_list" that takes item as String returns Collections.List:
    Let list be Collections.create_list()
    Collections.list_append(list, item)
    Return list
End Process

Process called "create_two_item_list" that takes item1 as String, item2 as String returns Collections.List:
    Let list be Collections.create_list()
    Collections.list_append(list, item1)
    Collections.list_append(list, item2)
    Return list
End Process

Process called "get_pattern_type" that takes state as PatternState returns String:
    Return state.current_pattern.pattern_type
End Process

Process called "is_imperative_pattern" that takes pattern_type as String returns Boolean:
    Return StringUtils.string_starts_with(pattern_type, "IMPERATIVE_")
End Process

Process called "is_import_pattern" that takes pattern_type as String returns Boolean:
    Return StringUtils.string_starts_with(pattern_type, "IMPORT_")
End Process

Note: =====================================================================
Note: PATTERN STATE MANAGEMENT
Note: =====================================================================

Process called "start_pattern_matching" that takes state as PatternState, pattern as StatementPattern returns Nothing:
    Set state.is_active to True
    Set state.current_pattern to pattern
    Set state.tokens_seen to Collections.create_list()
    Set state.expecting to "identifier"
    Set state.identifier_start to 0
    Set state.identifier_end to 0
End Process

Process called "end_pattern_matching" that takes state as PatternState returns Nothing:
    Set state.is_active to False
    Set state.current_pattern to create_null_pattern()
    Set state.tokens_seen to Collections.create_list()
    Set state.expecting to ""
    Set state.identifier_start to 0
    Set state.identifier_end to 0
End Process