Note:
compiler/frontend/lexical/literals.runa
Literal Value Parsing and Recognition

This module provides comprehensive literal parsing functionality including:
- Number literals (decimal, hexadecimal, binary, octal)
- String literals (normal, raw, formatted) with escape sequences
- Boolean literals (true, false) in both syntax modes
- Null/None/Nil literal variants
- Scientific notation and floating-point numbers
- Unicode string support with proper encoding
- String interpolation processing
- Performance optimized literal recognition
:End Note

Import module "compiler/frontend/diagnostics/errors" as Errors

Note: =====================================================================
Note: LITERAL DATA STRUCTURES
Note: =====================================================================

Type called "LiteralInfo":
    literal_type as String
    raw_value as String
    parsed_value as String
    data_type as String
    encoding as String
    has_interpolation as Boolean
    validation_errors as List[String]

Type called "NumberLiteral":
    number_base as Integer
    integer_part as String
    fractional_part as String
    exponent_part as String
    is_scientific as Boolean
    precision as Integer
    overflow_risk as Boolean

Type called "StringLiteral":
    quote_type as String
    is_raw as Boolean
    is_formatted as Boolean
    escape_sequences as List[String]
    interpolation_expressions as List[String]
    encoding as String

Type called "LiteralParser":
    parser_id as String
    current_mode as String
    statistics as Dictionary[String, Integer]

Note: =====================================================================
Note: LITERAL PARSING OPERATIONS
Note: =====================================================================

Process called "create_literal_parser" that takes parser_name as String returns LiteralParser:
    Note: Create literal parser with dual syntax support
    Return LiteralParser with
        parser_id as parser_name,
        current_mode as "canon",
        statistics as create_empty_statistics()
    End LiteralParser

Process called "parse_literal" that takes parser as LiteralParser, literal_text as String returns LiteralInfo:
    Note: Parse literal value from text
    Let literal_type be recognize_literal_type(parser, literal_text)
    Let info be LiteralInfo with
        literal_type as literal_type,
        raw_value as literal_text,
        parsed_value as "",
        data_type as "",
        encoding as "UTF-8",
        has_interpolation as False,
        validation_errors as create_empty_string_list()
    End LiteralInfo
    
    If string_equals(literal_type, "NUMBER"):
        Let number_literal be parse_number_literal(parser, literal_text)
        Set info.parsed_value to format_number_literal(number_literal)
        Set info.data_type to determine_number_type(number_literal)
    Otherwise If string_equals(literal_type, "STRING"):
        Let string_literal be parse_string_literal(parser, literal_text)
        Set info.parsed_value to string_literal.processed_content
        Set info.data_type to "String"
        Set info.has_interpolation to string_literal.is_formatted
    Otherwise If string_equals(literal_type, "BOOLEAN"):
        Let bool_value be parse_boolean_literal(parser, literal_text)
        Set info.parsed_value to boolean_to_string(bool_value)
        Set info.data_type to "Boolean"
    Otherwise If string_equals(literal_type, "NULL"):
        Set info.parsed_value to parse_null_literal(parser, literal_text)
        Set info.data_type to "Null"
    End If
    
    Set info.validation_errors to validate_literal(parser, info)
    Update_parser_statistics(parser, literal_type)
    Return info

Process called "recognize_literal_type" that takes parser as LiteralParser, text as String returns String:
    Note: Recognize type of literal from text pattern
    
    Let first_char be get_first_char(text)
    Let text_lower be string_to_lower(text)
    
    Note: Check for boolean literals in both syntax modes
    If string_equals(text_lower, "true") Or string_equals(text_lower, "false"):
        Return "BOOLEAN"
    End If
    
    If string_equals(text_lower, "yes") Or string_equals(text_lower, "no"):
        If string_equals(parser.current_mode, "canon"):
            Return "BOOLEAN"
        End If
    End If
    
    Note: Check for null literals
    If string_equals(text_lower, "null") Or string_equals(text_lower, "none") Or string_equals(text_lower, "nil"):
        Return "NULL"
    End If
    
    Note: Check for string literals
    If char_equals(first_char, '"') Or char_equals(first_char, "'"):
        Return "STRING"
    End If
    
    Note: Check for raw string literals
    If string_starts_with(text, "r\"") Or string_starts_with(text, "r'"):
        Return "STRING"
    End If
    
    Note: Check for formatted string literals
    If string_starts_with(text, "f\"") Or string_starts_with(text, "f'"):
        Return "STRING"
    End If
    
    Note: Check for number literals
    If is_digit(first_char):
        Return "NUMBER"
    End If
    
    Note: Check for hex, binary, octal prefixes
    If string_starts_with(text_lower, "0x") Or string_starts_with(text_lower, "0b") Or string_starts_with(text_lower, "0o"):
        Return "NUMBER"
    End If
    
    Note: Check for negative numbers
    If char_equals(first_char, '-') And string_length(text) is greater than 1:
        Let second_char be get_char_at(text, 1)
        If is_digit(second_char):
            Return "NUMBER"
        End If
    End If
    
    Return "UNKNOWN"

Note: =====================================================================
Note: NUMBER LITERAL OPERATIONS
Note: =====================================================================

Process called "parse_number_literal" that takes parser as LiteralParser, number_text as String returns NumberLiteral:
    Note: Parse number literal with base detection
    
    Let number be NumberLiteral with
        number_base as 10,
        integer_part as "",
        fractional_part as "",
        exponent_part as "",
        is_scientific as False,
        precision as 0,
        overflow_risk as False
    End NumberLiteral
    
    Let text be remove_underscores(number_text)
    Let base be detect_number_base(parser, text)
    Set number.number_base to base
    
    If base is not equal to 10:
        Let base_prefix_length be get_base_prefix_length(base)
        Let digits_text be string_substring(text, base_prefix_length, string_length(text))
        Set number.integer_part to digits_text
        Set number.precision to string_length(digits_text)
        Return number
    End If
    
    Note: Parse decimal number with potential scientific notation
    Let e_index be find_exponent_marker(text)
    If e_index is greater than or equal to 0:
        Set number.is_scientific to True
        Let mantissa be string_substring(text, 0, e_index)
        Let exponent be string_substring(text, e_index plus 1, string_length(text))
        Set number.exponent_part to exponent
        Let dot_index be string_index_of(mantissa, ".")
        If dot_index is greater than or equal to 0:
            Set number.integer_part to string_substring(mantissa, 0, dot_index)
            Set number.fractional_part to string_substring(mantissa, dot_index plus 1, string_length(mantissa))
        Otherwise:
            Set number.integer_part to mantissa
        End If
    Otherwise:
        Let dot_index be string_index_of(text, ".")
        If dot_index is greater than or equal to 0:
            Set number.integer_part to string_substring(text, 0, dot_index)
            Set number.fractional_part to string_substring(text, dot_index plus 1, string_length(text))
        Otherwise:
            Set number.integer_part to text
        End If
    End If
    
    Set number.precision to calculate_precision(number)
    Set number.overflow_risk to check_overflow_risk(number)
    Return number

Process called "detect_number_base" that takes parser as LiteralParser, number_text as String returns Integer:
    Note: Detect number base (decimal, hex, binary, octal)
    
    Let text_lower be string_to_lower(number_text)
    
    If string_starts_with(text_lower, "0x"):
        Return 16
    End If
    
    If string_starts_with(text_lower, "0b"):
        Return 2
    End If
    
    If string_starts_with(text_lower, "0o"):
        Return 8
    End If
    
    Return 10

Process called "parse_scientific_notation" that takes parser as LiteralParser, number_text as String returns NumberLiteral:
    Note: Parse scientific notation numbers
    Note: This is now handled within parse_number_literal
    Return parse_number_literal(parser, number_text)

Note: =====================================================================
Note: STRING LITERAL OPERATIONS
Note: =====================================================================

Process called "parse_string_literal" that takes parser as LiteralParser, string_text as String returns StringLiteral:
    Note: Parse string literal with quote and escape handling
    
    Let string_lit be StringLiteral with
        quote_type as "",
        is_raw as False,
        is_formatted as False,
        escape_sequences as create_empty_string_list(),
        interpolation_expressions as create_empty_string_list(),
        encoding as "UTF-8",
        processed_content as ""
    End StringLiteral
    
    Let first_char be get_first_char(string_text)
    Let prefix_char be '\0'
    Let content_start be 0
    
    Note: Check for raw or formatted string prefixes
    If char_equals(first_char, 'r') Or char_equals(first_char, 'R'):
        Set string_lit.is_raw to True
        Set prefix_char to first_char
        Set content_start to 1
    Otherwise If char_equals(first_char, 'f') Or char_equals(first_char, 'F'):
        Set string_lit.is_formatted to True
        Set prefix_char to first_char
        Set content_start to 1
    End If
    
    Let quote_char be get_char_at(string_text, content_start)
    If char_equals(quote_char, '"'):
        Set string_lit.quote_type to "double"
    Otherwise If char_equals(quote_char, "'"):
        Set string_lit.quote_type to "single"
    End If
    
    Note: Check for triple quotes
    If string_length(string_text) is greater than content_start plus 2:
        Let next_two be string_substring(string_text, content_start, content_start plus 3)
        If string_equals(next_two, "\"\"\"") Or string_equals(next_two, "'''"):
            Set string_lit.quote_type to "triple"
            Set content_start to content_start plus 3
        Otherwise:
            Set content_start to content_start plus 1
        End If
    Otherwise:
        Set content_start to content_start plus 1
    End If
    
    Note: Find closing quote
    Let content_end be find_closing_quote(string_text, content_start, string_lit.quote_type)
    Let raw_content be string_substring(string_text, content_start, content_end)
    
    If string_lit.is_raw:
        Set string_lit.processed_content to raw_content
    Otherwise If string_lit.is_formatted:
        Set string_lit.interpolation_expressions to extract_interpolations(raw_content)
        Set string_lit.processed_content to process_formatted_string(parser, raw_content)
    Otherwise:
        Set string_lit.escape_sequences to find_escape_sequences(raw_content)
        Set string_lit.processed_content to process_escape_sequences(parser, raw_content)
    End If
    
    Return string_lit

Process called "process_escape_sequences" that takes parser as LiteralParser, string_content as String returns String:
    Note: Process escape sequences in string content
    
    Let result be ""
    Let i be 0
    Let length be string_length(string_content)
    
    While i is less than length:
        Let current_char be get_char_at(string_content, i)
        
        If char_equals(current_char, '\\') And i plus 1 is less than length:
            Let next_char be get_char_at(string_content, i plus 1)
            
            If char_equals(next_char, 'n'):
                Set result to string_concat(result, "\n")
                Set i to i plus 2
            Otherwise If char_equals(next_char, 't'):
                Set result to string_concat(result, "\t")
                Set i to i plus 2
            Otherwise If char_equals(next_char, 'r'):
                Set result to string_concat(result, "\r")
                Set i to i plus 2
            Otherwise If char_equals(next_char, '\\'):
                Set result to string_concat(result, "\\")
                Set i to i plus 2
            Otherwise If char_equals(next_char, '\"'):
                Set result to string_concat(result, "\"")
                Set i to i plus 2
            Otherwise If char_equals(next_char, "'"):
                Set result to string_concat(result, "'")
                Set i to i plus 2
            Otherwise If char_equals(next_char, 'x') And i plus 3 is less than length:
                Let hex_code be string_substring(string_content, i plus 2, i plus 4)
                Let char_value be parse_hex_escape(hex_code)
                Set result to string_concat(result, char_value)
                Set i to i plus 4
            Otherwise If char_equals(next_char, 'u') And i plus 5 is less than length:
                Let unicode_code be string_substring(string_content, i plus 2, i plus 6)
                Let char_value be parse_unicode_escape(unicode_code)
                Set result to string_concat(result, char_value)
                Set i to i plus 6
            Otherwise:
                Set result to string_concat(result, char_to_string(next_char))
                Set i to i plus 2
            End If
        Otherwise:
            Set result to string_concat(result, char_to_string(current_char))
            Set i to i plus 1
        End If
    End While
    
    Return result

Process called "parse_string_interpolation" that takes parser as LiteralParser, formatted_string as String returns StringLiteral:
    Note: Parse string interpolation expressions
    Return parse_string_literal(parser, formatted_string)

Note: =====================================================================
Note: BOOLEAN AND NULL LITERAL OPERATIONS
Note: =====================================================================

Process called "parse_boolean_literal" that takes parser as LiteralParser, boolean_text as String returns Boolean:
    Note: Parse boolean literal (true/false)
    
    Let text_lower be string_to_lower(boolean_text)
    
    If string_equals(text_lower, "true") Or string_equals(text_lower, "yes"):
        Return True
    End If
    
    If string_equals(text_lower, "false") Or string_equals(text_lower, "no"):
        Return False
    End If
    
    Note: Should not reach here if recognize_literal_type worked correctly
    Return False

Process called "parse_null_literal" that takes parser as LiteralParser, null_text as String returns String:
    Note: Parse null literal variants (null/none/nil)
    
    Let text_lower be string_to_lower(null_text)
    
    If string_equals(text_lower, "null"):
        Return "null"
    Otherwise If string_equals(text_lower, "none"):
        Return "none"
    Otherwise If string_equals(text_lower, "nil"):
        Return "nil"
    End If
    
    Return "null"

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_literal" that takes parser as LiteralParser, literal as LiteralInfo returns List[String]:
    Note: Validate literal for correctness and constraints
    
    Let errors be create_empty_string_list()
    
    If string_equals(literal.literal_type, "NUMBER"):
        Let number_errors be validate_number_literal(literal)
        For Each error in number_errors:
            list_append(errors, error)
        End For
    Otherwise If string_equals(literal.literal_type, "STRING"):
        Let string_errors be validate_string_literal(literal)
        For Each error in string_errors:
            list_append(errors, error)
        End For
    Otherwise If string_equals(literal.literal_type, "UNKNOWN"):
        list_append(errors, string_concat("Unrecognized literal format: ", literal.raw_value))
    End If
    
    Return errors

Process called "get_literal_statistics" that takes parser as LiteralParser returns Dictionary[String, Integer]:
    Note: Get statistics about literal parsing
    Return parser.statistics

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "create_empty_statistics" returns Dictionary[String, Integer]:
    Let stats be create_dictionary()
    dict_set(stats, "NUMBER", 0)
    dict_set(stats, "STRING", 0)
    dict_set(stats, "BOOLEAN", 0)
    dict_set(stats, "NULL", 0)
    dict_set(stats, "UNKNOWN", 0)
    Return stats
End Process

Process called "create_empty_string_list" returns List[String]:
    Return create_list()
End Process

Process called "string_equals" that takes s1 as String, s2 as String returns Boolean:
    Note: Compare two strings for equality
    Let length1 be string_length(s1)
    Let length2 be string_length(s2)
    
    If length1 is not equal to length2:
        Return False
    End If
    
    For i from 0 to length1 minus 1:
        If Not char_equals(get_char_at(s1, i), get_char_at(s2, i)):
            Return False
        End If
    End For
    
    Return True
End Process

Process called "format_number_literal" that takes number as NumberLiteral returns String:
    Let result be number.integer_part
    
    If string_length(number.fractional_part) is greater than 0:
        Set result to string_concat(result, ".")
        Set result to string_concat(result, number.fractional_part)
    End If
    
    If number.is_scientific:
        Set result to string_concat(result, "e")
        Set result to string_concat(result, number.exponent_part)
    End If
    
    Return result
End Process

Process called "determine_number_type" that takes number as NumberLiteral returns String:
    If string_length(number.fractional_part) is greater than 0 Or number.is_scientific:
        Return "Float"
    End If
    
    Return "Integer"
End Process

Process called "boolean_to_string" that takes value as Boolean returns String:
    If value:
        Return "true"
    End If
    Return "false"
End Process

Process called "update_parser_statistics" that takes parser as LiteralParser, literal_type as String returns Nothing:
    Let current_count be dict_get(parser.statistics, literal_type)
    dict_set(parser.statistics, literal_type, current_count plus 1)
End Process

Process called "get_first_char" that takes text as String returns Character:
    If string_length(text) is greater than 0:
        Return get_char_at(text, 0)
    End If
    Return '\0'
End Process

Process called "string_to_lower" that takes text as String returns String:
    Let result be ""
    For i from 0 to string_length(text) minus 1:
        Let ch be get_char_at(text, i)
        Set result to string_concat(result, char_to_lower(ch))
    End For
    Return result
End Process

Process called "string_starts_with" that takes text as String, prefix as String returns Boolean:
    Let prefix_len be string_length(prefix)
    If string_length(text) is less than prefix_len:
        Return False
    End If
    
    For i from 0 to prefix_len minus 1:
        If Not char_equals(get_char_at(text, i), get_char_at(prefix, i)):
            Return False
        End If
    End For
    
    Return True
End Process

Process called "char_equals" that takes c1 as Character, c2 as Character returns Boolean:
    Return char_to_int(c1) is equal to char_to_int(c2)
End Process

Process called "is_digit" that takes ch as Character returns Boolean:
    Let code be char_to_int(ch)
    Return code is greater than or equal to 48 And code is less than or equal to 57
End Process

Process called "remove_underscores" that takes text as String returns String:
    Let result be ""
    For i from 0 to string_length(text) minus 1:
        Let ch be get_char_at(text, i)
        If Not char_equals(ch, '_'):
            Set result to string_concat(result, char_to_string(ch))
        End If
    End For
    Return result
End Process

Process called "get_base_prefix_length" that takes base as Integer returns Integer:
    If base is equal to 16 Or base is equal to 2 Or base is equal to 8:
        Return 2
    End If
    Return 0
End Process

Process called "find_exponent_marker" that takes text as String returns Integer:
    For i from 0 to string_length(text) minus 1:
        Let ch be get_char_at(text, i)
        If char_equals(ch, 'e') Or char_equals(ch, 'E'):
            Return i
        End If
    End For
    Return -1
End Process

Process called "string_index_of" that takes text as String, search as String returns Integer:
    Let search_len be string_length(search)
    Let text_len be string_length(text)
    
    For i from 0 to text_len minus search_len:
        Let match be True
        For j from 0 to search_len minus 1:
            If Not char_equals(get_char_at(text, i plus j), get_char_at(search, j)):
                Set match to False
                Break
            End If
        End For
        If match:
            Return i
        End If
    End For
    
    Return -1
End Process

Process called "string_substring" that takes text as String, start as Integer, end as Integer returns String:
    Let result be ""
    For i from start to end minus 1:
        Set result to string_concat(result, char_to_string(get_char_at(text, i)))
    End For
    Return result
End Process

Process called "calculate_precision" that takes number as NumberLiteral returns Integer:
    Let precision be string_length(number.integer_part)
    Set precision to precision plus string_length(number.fractional_part)
    Return precision
End Process

Process called "check_overflow_risk" that takes number as NumberLiteral returns Boolean:
    Let total_digits be calculate_precision(number)
    
    If number.number_base is equal to 10:
        If total_digits is greater than 19:
            Return True
        End If
        If number.is_scientific:
            Let exp_value be string_to_int(number.exponent_part)
            If exp_value is greater than 308 Or exp_value is less than -308:
                Return True
            End If
        End If
    End If
    
    Return False
End Process

Process called "find_closing_quote" that takes text as String, start as Integer, quote_type as String returns Integer:
    Let search_char be '\"'
    Let triple_mode be False
    
    If string_equals(quote_type, "single"):
        Set search_char to '\''
    Otherwise If string_equals(quote_type, "triple"):
        Set triple_mode to True
    End If
    
    If triple_mode:
        Let quote_seq be "\"\"\""
        If string_equals(quote_type, "triple") And char_equals(get_char_at(text, start minus 3), '\''):
            Set quote_seq to "'''"
        End If
        
        For i from start to string_length(text) minus 3:
            Let chunk be string_substring(text, i, i plus 3)
            If string_equals(chunk, quote_seq):
                Return i
            End If
        End For
    Otherwise:
        For i from start to string_length(text) minus 1:
            Let ch be get_char_at(text, i)
            If char_equals(ch, search_char):
                Let prev_char be '\0'
                If i is greater than start:
                    Set prev_char to get_char_at(text, i minus 1)
                End If
                If Not char_equals(prev_char, '\\'):
                    Return i
                End If
            End If
        End For
    End If
    
    Return string_length(text)
End Process

Process called "extract_interpolations" that takes content as String returns List[String]:
    Let expressions be create_list()
    Let i be 0
    Let length be string_length(content)
    
    While i is less than length:
        Let ch be get_char_at(content, i)
        If char_equals(ch, '{'):
            Let brace_count be 1
            Let expr_start be i plus 1
            Set i to i plus 1
            
            While i is less than length And brace_count is greater than 0:
                Let next_ch be get_char_at(content, i)
                If char_equals(next_ch, '{'):
                    Set brace_count to brace_count plus 1
                Otherwise If char_equals(next_ch, '}'):
                    Set brace_count to brace_count minus 1
                End If
                Set i to i plus 1
            End While
            
            If brace_count is equal to 0:
                Let expr be string_substring(content, expr_start, i minus 1)
                list_append(expressions, expr)
            End If
        Otherwise:
            Set i to i plus 1
        End If
    End While
    
    Return expressions
End Process

Process called "process_formatted_string" that takes parser as LiteralParser, content as String returns String:
    Note: Process formatted string by replacing interpolation expressions with placeholders
    Let result be ""
    Let i be 0
    Let length be string_length(content)
    
    While i is less than length:
        Let ch be get_char_at(content, i)
        
        If char_equals(ch, '{'):
            Note: Check for escaped brace
            If i plus 1 is less than length And char_equals(get_char_at(content, i plus 1), '{'):
                Set result to string_concat(result, "{")
                Set i to i plus 2
                Continue
            End If
            
            Note: Find matching closing brace
            Let brace_count be 1
            Let expr_start be i plus 1
            Let j be i plus 1
            
            While j is less than length And brace_count is greater than 0:
                Let next_ch be get_char_at(content, j)
                If char_equals(next_ch, '{'):
                    Set brace_count to brace_count plus 1
                Otherwise If char_equals(next_ch, '}'):
                    Set brace_count to brace_count minus 1
                End If
                Set j to j plus 1
            End While
            
            If brace_count is equal to 0:
                Note: Extract and mark the expression
                Let expr be string_substring(content, expr_start, j minus 1)
                Set result to string_concat(result, "${")
                Set result to string_concat(result, expr)
                Set result to string_concat(result, "}")
                Set i to j
            Otherwise:
                Note: Unclosed brace, treat as literal
                Set result to string_concat(result, char_to_string(ch))
                Set i to i plus 1
            End If
        Otherwise If char_equals(ch, '}'):
            Note: Check for escaped closing brace
            If i plus 1 is less than length And char_equals(get_char_at(content, i plus 1), '}'):
                Set result to string_concat(result, "}")
                Set i to i plus 2
            Otherwise:
                Set result to string_concat(result, char_to_string(ch))
                Set i to i plus 1
            End If
        Otherwise:
            Set result to string_concat(result, char_to_string(ch))
            Set i to i plus 1
        End If
    End While
    
    Return result
End Process

Process called "find_escape_sequences" that takes content as String returns List[String]:
    Let sequences be create_list()
    Let i be 0
    Let length be string_length(content)
    
    While i is less than length minus 1:
        Let ch be get_char_at(content, i)
        If char_equals(ch, '\\'):
            Let next_ch be get_char_at(content, i plus 1)
            Let seq be string_concat(char_to_string(ch), char_to_string(next_ch))
            list_append(sequences, seq)
            Set i to i plus 2
        Otherwise:
            Set i to i plus 1
        End If
    End While
    
    Return sequences
End Process

Process called "parse_hex_escape" that takes hex_code as String returns String:
    Let value be 0
    For i from 0 to string_length(hex_code) minus 1:
        Let ch be get_char_at(hex_code, i)
        Set value to value multiplied by 16
        
        If is_digit(ch):
            Set value to value plus (char_to_int(ch) minus 48)
        Otherwise:
            Let lower_ch be char_to_lower(ch)
            If char_to_int(lower_ch) is greater than or equal to 97 And char_to_int(lower_ch) is less than or equal to 102:
                Set value to value plus (char_to_int(lower_ch) minus 87)
            End If
        End If
    End For
    
    Return char_to_string(int_to_char(value))
End Process

Process called "parse_unicode_escape" that takes unicode_code as String returns String:
    Return parse_hex_escape(unicode_code)
End Process

Process called "validate_number_literal" that takes literal as LiteralInfo returns List[String]:
    Let errors be create_list()
    
    Let raw be literal.raw_value
    Let has_invalid_chars be False
    
    For i from 0 to string_length(raw) minus 1:
        Let ch be get_char_at(raw, i)
        If Not is_valid_number_char(ch):
            Set has_invalid_chars to True
            Break
        End If
    End For
    
    If has_invalid_chars:
        list_append(errors, string_concat("Invalid characters in number literal: ", raw))
    End If
    
    Return errors
End Process

Process called "validate_string_literal" that takes literal as LiteralInfo returns List[String]:
    Let errors be create_list()
    
    Let raw be literal.raw_value
    If string_length(raw) is less than 2:
        list_append(errors, "String literal must have opening and closing quotes")
    End If
    
    Return errors
End Process

Process called "is_valid_number_char" that takes ch as Character returns Boolean:
    If is_digit(ch):
        Return True
    End If
    
    If char_equals(ch, '.') Or char_equals(ch, '_'):
        Return True
    End If
    
    If char_equals(ch, 'e') Or char_equals(ch, 'E'):
        Return True
    End If
    
    If char_equals(ch, 'x') Or char_equals(ch, 'X'):
        Return True
    End If
    
    If char_equals(ch, 'b') Or char_equals(ch, 'B'):
        Return True
    End If
    
    If char_equals(ch, 'o') Or char_equals(ch, 'O'):
        Return True
    End If
    
    If char_equals(ch, '-') Or char_equals(ch, '+'):
        Return True
    End If
    
    Let lower_ch be char_to_lower(ch)
    If char_to_int(lower_ch) is greater than or equal to 97 And char_to_int(lower_ch) is less than or equal to 102:
        Return True
    End If
    
    Return False
End Process

Process called "char_to_lower" that takes ch as Character returns Character:
    Let code be char_to_int(ch)
    If code is greater than or equal to 65 And code is less than or equal to 90:
        Return int_to_char(code plus 32)
    End If
    Return ch
End Process

Process called "string_to_int" that takes text as String returns Integer:
    Let result be 0
    Let negative be False
    Let start be 0
    
    If string_length(text) is greater than 0:
        Let first be get_char_at(text, 0)
        If char_equals(first, '-'):
            Set negative to True
            Set start to 1
        Otherwise If char_equals(first, '+'):
            Set start to 1
        End If
    End If
    
    For i from start to string_length(text) minus 1:
        Let ch be get_char_at(text, i)
        If is_digit(ch):
            Set result to result multiplied by 10
            Set result to result plus (char_to_int(ch) minus 48)
        End If
    End For
    
    If negative:
        Set result to 0 minus result
    End If
    
    Return result
End Process

Process called "string_concat" that takes s1 as String, s2 as String returns String:
    Note: Concatenate two strings
    Return s1 concatenated with s2
End Process

Process called "string_length" that takes text as String returns Integer:
    Note: Return the length of a string
    Let count be 0
    For Each ch in text:
        Set count to count plus 1
    End For
    Return count
End Process

Process called "get_char_at" that takes text as String, index as Integer returns Character:
    Note: Get character at specific index
    Let i be 0
    For Each ch in text:
        If i is equal to index:
            Return ch
        End If
        Set i to i plus 1
    End For
    Return '\0'
End Process

Process called "char_to_string" that takes ch as Character returns String:
    Note: Convert single character to string
    Let result be ""
    Return result concatenated with ch
End Process

Process called "char_to_int" that takes ch as Character returns Integer:
    Note: Get ASCII/Unicode value of character
    Return ch as Integer
End Process

Process called "int_to_char" that takes value as Integer returns Character:
    Note: Convert integer to character
    Return value as Character
End Process

Process called "create_list" returns List[String]:
    Note: Create empty list of strings
    Return new List[String]
End Process

Process called "list_append" that takes list as List[String], item as String returns Nothing:
    Note: Add item to end of list
    Append item to list
End Process

Process called "create_dictionary" returns Dictionary[String, Integer]:
    Note: Create empty dictionary
    Return new Dictionary[String, Integer]
End Process

Process called "dict_set" that takes dict as Dictionary[String, Integer], key as String, value as Integer returns Nothing:
    Note: Set dictionary entry
    Set dict[key] to value
End Process

Process called "dict_get" that takes dict as Dictionary[String, Integer], key as String returns Integer:
    Note: Get dictionary entry
    Return dict[key]