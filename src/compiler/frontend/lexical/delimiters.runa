Note:
compiler/frontend/lexical/delimiters.runa
Delimiter and Punctuation Recognition

This module handles all delimiter and punctuation symbols including:
- Parentheses for grouping and function calls
- Brackets for array/dictionary indexing
- Braces for block structures
- Commas for separating items
- Semicolons for statement termination
- Colons for type annotations
:End Note

Import "compiler/internal/collections" as Collections
Import "compiler/internal/string_utils" as StringUtils

Note: =====================================================================
Note: DELIMITER DEFINITIONS
Note: =====================================================================

@Reasoning
    Delimiters provide structure to Runa code. While operators perform
    computations, delimiters organize and group elements. Most delimiters
    remain as symbols even in Canon mode for clarity.
@End Reasoning

Type called "Delimiter":
    symbol as String              Note: The delimiter symbol
    delimiter_type as String      Note: Classification of delimiter
    matching_delimiter as String  Note: For paired delimiters
    canonical_form as String      Note: Natural language form if any
End Type

Process called "get_all_delimiters" returns Collections.List:
    Let delimiters be Collections.create_list()
    
    Note: Parentheses - used for grouping and function calls
    Collections.list_append(delimiters, Delimiter with
        symbol as "(",
        delimiter_type as "OPEN_PAREN",
        matching_delimiter as ")",
        canonical_form as "("  Note: Keep as symbol
    End Delimiter)
    
    Collections.list_append(delimiters, Delimiter with
        symbol as ")",
        delimiter_type as "CLOSE_PAREN",
        matching_delimiter as "(",
        canonical_form as ")"  Note: Keep as symbol
    End Delimiter)
    
    Note: Brackets - used for indexing
    Collections.list_append(delimiters, Delimiter with
        symbol as "[",
        delimiter_type as "OPEN_BRACKET",
        matching_delimiter as "]",
        canonical_form as "["  Note: Keep as symbol
    End Delimiter)
    
    Collections.list_append(delimiters, Delimiter with
        symbol as "]",
        delimiter_type as "CLOSE_BRACKET",
        matching_delimiter as "[",
        canonical_form as "]"  Note: Keep as symbol
    End Delimiter)
    
    Note: Braces - used for dictionaries and blocks
    Collections.list_append(delimiters, Delimiter with
        symbol as "{",
        delimiter_type as "OPEN_BRACE",
        matching_delimiter as "}",
        canonical_form as "{"  Note: Keep as symbol
    End Delimiter)
    
    Collections.list_append(delimiters, Delimiter with
        symbol as "}",
        delimiter_type as "CLOSE_BRACE",
        matching_delimiter as "{",
        canonical_form as "}"  Note: Keep as symbol
    End Delimiter)
    
    Note: Separators
    Collections.list_append(delimiters, Delimiter with
        symbol as ",",
        delimiter_type as "COMMA",
        matching_delimiter as "",
        canonical_form as ","  Note: Keep as symbol
    End Delimiter)
    
    Collections.list_append(delimiters, Delimiter with
        symbol as ";",
        delimiter_type as "SEMICOLON",
        matching_delimiter as "",
        canonical_form as ";"  Note: Keep as symbol
    End Delimiter)
    
    Collections.list_append(delimiters, Delimiter with
        symbol as ":",
        delimiter_type as "COLON",
        matching_delimiter as "",
        canonical_form as ":"  Note: Keep as symbol
    End Delimiter)
    
    Return delimiters
End Process

Note: =====================================================================
Note: DELIMITER LOOKUP TABLES
Note: =====================================================================

@Reasoning
    Build lookup tables for fast delimiter recognition.
    Cache these for performance.
@End Reasoning

Note: Global caches
Let all_delimiters be get_all_delimiters()
Let symbol_to_delimiter be create_delimiter_lookup()

Process called "create_delimiter_lookup" returns Collections.Dictionary:
    Let lookup be Collections.create_dictionary()
    
    For i from 0 to Collections.list_length(all_delimiters) minus 1:
        Let delim be Collections.list_get(all_delimiters, i)
        Collections.dict_set(lookup, delim.symbol, delim)
    End For
    
    Return lookup
End Process

Note: =====================================================================
Note: DELIMITER RECOGNITION
Note: =====================================================================

Process called "is_delimiter" that takes char as Character returns Boolean:
    Let char_string be StringUtils.char_to_string(char)
    Return Collections.dict_has_key(symbol_to_delimiter, char_string)
End Process

Process called "get_delimiter" that takes symbol as String returns Delimiter:
    If Collections.dict_has_key(symbol_to_delimiter, symbol):
        Return Collections.dict_get(symbol_to_delimiter, symbol)
    End If
    
    Note: Return null delimiter if not found
    Return Delimiter with
        symbol as "",
        delimiter_type as "UNKNOWN",
        matching_delimiter as "",
        canonical_form as ""
    End Delimiter
End Process

Process called "get_delimiter_type" that takes symbol as String returns String:
    Let delim be get_delimiter(symbol)
    Return delim.delimiter_type
End Process

Note: =====================================================================
Note: DELIMITER MATCHING
Note: =====================================================================

@Reasoning
    For paired delimiters like parentheses, we need to track matching.
    This helps with syntax validation and error reporting.
@End Reasoning

Process called "is_opening_delimiter" that takes symbol as String returns Boolean:
    Let delim_type be get_delimiter_type(symbol)
    Return StringUtils.string_starts_with(delim_type, "OPEN_")
End Process

Process called "is_closing_delimiter" that takes symbol as String returns Boolean:
    Let delim_type be get_delimiter_type(symbol)
    Return StringUtils.string_starts_with(delim_type, "CLOSE_")
End Process

Process called "get_matching_delimiter" that takes symbol as String returns String:
    Let delim be get_delimiter(symbol)
    Return delim.matching_delimiter
End Process

Process called "delimiters_match" that takes open_delim as String, close_delim as String returns Boolean:
    Let expected_match be get_matching_delimiter(open_delim)
    Return StringUtils.string_equals(expected_match, close_delim)
End Process

Note: =====================================================================
Note: DELIMITER STACK FOR VALIDATION
Note: =====================================================================

@Reasoning
    Track nested delimiters to ensure proper matching.
    Used during lexical analysis to detect mismatched delimiters early.
@End Reasoning

Type called "DelimiterStack":
    stack as Collections.Stack
    error_message as String
End Type

Process called "create_delimiter_stack" returns DelimiterStack:
    Return DelimiterStack with
        stack as Collections.create_stack(),
        error_message as ""
    End DelimiterStack
End Process

Process called "push_delimiter" that takes delim_stack as DelimiterStack, delimiter as String, line as Integer, column as Integer returns Nothing:
    Let delim_info be Collections.create_dictionary()
    Collections.dict_set(delim_info, "symbol", delimiter)
    Collections.dict_set(delim_info, "line", line)
    Collections.dict_set(delim_info, "column", column)
    Collections.stack_push(delim_stack.stack, delim_info)
End Process

Process called "check_closing_delimiter" that takes delim_stack as DelimiterStack, delimiter as String, line as Integer, column as Integer returns Boolean:
    If Collections.stack_is_empty(delim_stack.stack):
        Set delim_stack.error_message to StringUtils.concat_strings("Unexpected closing delimiter '", delimiter)
        Set delim_stack.error_message to StringUtils.concat_strings(delim_stack.error_message, "' at line ")
        Set delim_stack.error_message to StringUtils.concat_strings(delim_stack.error_message, StringUtils.int_to_string(line))
        Return False
    End If
    
    Let top_info be Collections.stack_pop(delim_stack.stack)
    Let open_delim be Collections.dict_get(top_info, "symbol")
    
    If Not delimiters_match(open_delim, delimiter):
        Set delim_stack.error_message to StringUtils.concat_strings("Mismatched delimiters: '", open_delim)
        Set delim_stack.error_message to StringUtils.concat_strings(delim_stack.error_message, "' at line ")
        Let open_line be Collections.dict_get(top_info, "line")
        Set delim_stack.error_message to StringUtils.concat_strings(delim_stack.error_message, StringUtils.int_to_string(open_line))
        Set delim_stack.error_message to StringUtils.concat_strings(delim_stack.error_message, " does not match '")
        Set delim_stack.error_message to StringUtils.concat_strings(delim_stack.error_message, delimiter)
        Set delim_stack.error_message to StringUtils.concat_strings(delim_stack.error_message, "' at line ")
        Set delim_stack.error_message to StringUtils.concat_strings(delim_stack.error_message, StringUtils.int_to_string(line))
        Return False
    End If
    
    Return True
End Process

Process called "is_delimiter_stack_balanced" that takes delim_stack as DelimiterStack returns Boolean:
    Return Collections.stack_is_empty(delim_stack.stack)
End Process

Note: =====================================================================
Note: UTILITY FUNCTIONS
Note: =====================================================================

Process called "get_delimiter_count" returns Integer:
    Return Collections.list_length(all_delimiters)
End Process

Process called "is_separator" that takes symbol as String returns Boolean:
    Let delim_type be get_delimiter_type(symbol)
    Return StringUtils.string_equals(delim_type, "COMMA") Or
           StringUtils.string_equals(delim_type, "SEMICOLON") Or
           StringUtils.string_equals(delim_type, "COLON")
End Process