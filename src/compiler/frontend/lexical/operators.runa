Note:
compiler/frontend/lexical/operators.runa
Operator Recognition and Management

This module provides comprehensive operator functionality including:
- Natural language operator recognition ("plus", "multiplied by", etc.)
- Multi-word operator detection and validation
- Operator precedence and associativity rules
- Context-sensitive operator classification
- Symbol-to-canonical form mapping
- Dual mode support (Canon and Symbol modes)
:End Note

Import "compiler/internal/collections" as Collections
Import "compiler/internal/string_utils" as StringUtils
Import "compiler/internal/primitives" as Primitives

Note: =====================================================================
Note: OPERATOR DEFINITIONS
Note: =====================================================================

@Reasoning
    Runa supports both natural language operators and symbolic operators.
    Canon mode uses words like "plus", Symbol mode uses "+".
    We define all operators and their relationships here.
@End Reasoning

Type called "Operator":
    canonical_form as String      Note: Natural language form ("plus")
    symbol_form as String         Note: Symbolic form ("+")
    precedence as Integer         Note: Higher number = higher precedence
    associativity as String       Note: "left", "right", or "none"
    operator_type as String       Note: Classification of the operator
End Type

Process called "get_all_operators" returns Collections.List:
    Let operators be Collections.create_list()
    
    Note: Arithmetic operators
    Collections.list_append(operators, Operator with
        canonical_form as "plus",
        symbol_form as "+",
        precedence as 10,
        associativity as "left",
        operator_type as "ARITHMETIC"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "minus",
        symbol_form as "-",
        precedence as 10,
        associativity as "left",
        operator_type as "ARITHMETIC"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "multiplied by",
        symbol_form as "*",
        precedence as 20,
        associativity as "left",
        operator_type as "ARITHMETIC"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "divided by",
        symbol_form as "/",
        precedence as 20,
        associativity as "left",
        operator_type as "ARITHMETIC"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "modulo",
        symbol_form as "%",
        precedence as 20,
        associativity as "left",
        operator_type as "ARITHMETIC"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "to the power of",
        symbol_form as "**",
        precedence as 30,
        associativity as "right",
        operator_type as "ARITHMETIC"
    End Operator)
    
    Note: Comparison operators (all have "is" prefix in canonical form)
    Collections.list_append(operators, Operator with
        canonical_form as "is equal to",
        symbol_form as "==",
        precedence as 5,
        associativity as "none",
        operator_type as "COMPARISON"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "is not equal to",
        symbol_form as "!=",
        precedence as 5,
        associativity as "none",
        operator_type as "COMPARISON"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "is greater than",
        symbol_form as ">",
        precedence as 5,
        associativity as "none",
        operator_type as "COMPARISON"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "is less than",
        symbol_form as "<",
        precedence as 5,
        associativity as "none",
        operator_type as "COMPARISON"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "is greater than or equal to",
        symbol_form as ">=",
        precedence as 5,
        associativity as "none",
        operator_type as "COMPARISON"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "is less than or equal to",
        symbol_form as "<=",
        precedence as 5,
        associativity as "none",
        operator_type as "COMPARISON"
    End Operator)
    
    Note: Logical operators
    Collections.list_append(operators, Operator with
        canonical_form as "And",
        symbol_form as "&&",
        precedence as 3,
        associativity as "left",
        operator_type as "LOGICAL"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "Or",
        symbol_form as "||",
        precedence as 2,
        associativity as "left",
        operator_type as "LOGICAL"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "Not",
        symbol_form as "!",
        precedence as 25,
        associativity as "right",
        operator_type as "LOGICAL"
    End Operator)
    
    Note: Bitwise operators
    Collections.list_append(operators, Operator with
        canonical_form as "bitwise and",
        symbol_form as "&",
        precedence as 8,
        associativity as "left",
        operator_type as "BITWISE"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "bitwise or",
        symbol_form as "|",
        precedence as 6,
        associativity as "left",
        operator_type as "BITWISE"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "bitwise xor",
        symbol_form as "^",
        precedence as 7,
        associativity as "left",
        operator_type as "BITWISE"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "bitwise not",
        symbol_form as "~",
        precedence as 25,
        associativity as "right",
        operator_type as "BITWISE"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "shifted left by",
        symbol_form as "<<",
        precedence as 9,
        associativity as "left",
        operator_type as "BITWISE"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "shifted right by",
        symbol_form as ">>",
        precedence as 9,
        associativity as "left",
        operator_type as "BITWISE"
    End Operator)
    
    Note: Assignment operators
    Collections.list_append(operators, Operator with
        canonical_form as "equals",
        symbol_form as "=",
        precedence as 1,
        associativity as "right",
        operator_type as "ASSIGNMENT"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "gets increased by",
        symbol_form as "+=",
        precedence as 1,
        associativity as "right",
        operator_type as "ASSIGNMENT"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "gets decreased by",
        symbol_form as "-=",
        precedence as 1,
        associativity as "right",
        operator_type as "ASSIGNMENT"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "gets multiplied by",
        symbol_form as "*=",
        precedence as 1,
        associativity as "right",
        operator_type as "ASSIGNMENT"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "gets divided by",
        symbol_form as "/=",
        precedence as 1,
        associativity as "right",
        operator_type as "ASSIGNMENT"
    End Operator)
    
    Note: Special operators
    Collections.list_append(operators, Operator with
        canonical_form as "of",
        symbol_form as ".",
        precedence as 40,
        associativity as "left",
        operator_type as "MEMBER_ACCESS"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "from",
        symbol_form as ".",
        precedence as 40,
        associativity as "left",
        operator_type as "MEMBER_ACCESS"
    End Operator)
    
    Note: Arrow and double colon kept as symbols only for developer mode
    Collections.list_append(operators, Operator with
        canonical_form as "->",
        symbol_form as "->",
        precedence as 35,
        associativity as "left",
        operator_type as "FUNCTION_ARROW"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "::",
        symbol_form as "::",
        precedence as 40,
        associativity as "left",
        operator_type as "PATH_SEPARATOR"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "through",
        symbol_form as "..",
        precedence as 4,
        associativity as "none",
        operator_type as "RANGE"
    End Operator)
    
    Collections.list_append(operators, Operator with
        canonical_form as "up to and including",
        symbol_form as "..=",
        precedence as 4,
        associativity as "none",
        operator_type as "RANGE"
    End Operator)
    
    Note: Bracket operators for array/dictionary access
    Collections.list_append(operators, Operator with
        canonical_form as "at",
        symbol_form as "[]",
        precedence as 40,
        associativity as "left",
        operator_type as "INDEX_ACCESS"
    End Operator)
    
    Return operators
End Process

Note: =====================================================================
Note: OPERATOR LOOKUP TABLES
Note: =====================================================================

@Reasoning
    We build lookup tables for fast operator recognition.
    These are initialized once and cached for performance.
@End Reasoning

Note: Global caches for operator lookups
Let all_operators be get_all_operators()
Let canonical_to_operator be create_canonical_lookup()
Let symbol_to_operator be create_symbol_lookup()

Process called "create_canonical_lookup" returns Collections.Dictionary:
    Let lookup be Collections.create_dictionary()
    
    For i from 0 to Collections.list_length(all_operators) minus 1:
        Let op be Collections.list_get(all_operators, i)
        Collections.dict_set(lookup, op.canonical_form, op)
    End For
    
    Return lookup
End Process

Process called "create_symbol_lookup" returns Collections.Dictionary:
    Let lookup be Collections.create_dictionary()
    
    For i from 0 to Collections.list_length(all_operators) minus 1:
        Let op be Collections.list_get(all_operators, i)
        Collections.dict_set(lookup, op.symbol_form, op)
    End For
    
    Return lookup
End Process

Note: =====================================================================
Note: OPERATOR RECOGNITION
Note: =====================================================================

@Reasoning
    Main interface for checking if a string is an operator.
    Supports both canonical and symbolic forms.
@End Reasoning

Process called "is_operator_canonical" that takes text as String returns Boolean:
    Return Collections.dict_has_key(canonical_to_operator, text)
End Process

Process called "is_operator_symbol" that takes text as String returns Boolean:
    Return Collections.dict_has_key(symbol_to_operator, text)
End Process

Process called "get_operator_by_canonical" that takes canonical as String returns Operator:
    If Collections.dict_has_key(canonical_to_operator, canonical):
        Return Collections.dict_get(canonical_to_operator, canonical)
    End If
    
    Note: Return null operator if not found
    Return Operator with
        canonical_form as "",
        symbol_form as "",
        precedence as 0,
        associativity as "none",
        operator_type as "UNKNOWN"
    End Operator
End Process

Process called "get_operator_by_symbol" that takes symbol as String returns Operator:
    If Collections.dict_has_key(symbol_to_operator, symbol):
        Return Collections.dict_get(symbol_to_operator, symbol)
    End If
    
    Note: Return null operator if not found
    Return Operator with
        canonical_form as "",
        symbol_form as "",
        precedence as 0,
        associativity as "none",
        operator_type as "UNKNOWN"
    End Operator
End Process

Note: =====================================================================
Note: MULTI-CHARACTER OPERATOR DETECTION
Note: =====================================================================

@Reasoning
    Some operators are multi-character (==, >=, <<, etc.).
    We need to detect these before single-character operators.
@End Reasoning

Process called "get_max_operator_length" returns Integer:
    Let max_length be 0
    
    For i from 0 to Collections.list_length(all_operators) minus 1:
        Let op be Collections.list_get(all_operators, i)
        Let symbol_length be StringUtils.string_length(op.symbol_form)
        
        If symbol_length is greater than max_length:
            Set max_length to symbol_length
        End If
    End For
    
    Return max_length
End Process

Process called "try_match_operator_symbol" that takes text as String, position as Integer returns Operator:
    Note: Try to match the longest operator first
    Let max_length be get_max_operator_length()
    Let text_length be StringUtils.string_length(text)
    
    For length from max_length to 1 by minus 1:
        If position plus length is less than or equal to text_length:
            Let candidate be StringUtils.substring(text, position, position plus length)
            
            If is_operator_symbol(candidate):
                Return get_operator_by_symbol(candidate)
            End If
        End If
    End For
    
    Note: No operator matched
    Return Operator with
        canonical_form as "",
        symbol_form as "",
        precedence as 0,
        associativity as "none",
        operator_type as "UNKNOWN"
    End Operator
End Process

Note: =====================================================================
Note: OPERATOR PRECEDENCE AND ASSOCIATIVITY
Note: =====================================================================

@Reasoning
    These functions help the parser build correct expression trees.
    Precedence determines grouping, associativity determines evaluation order.
@End Reasoning

Process called "compare_precedence" that takes op1 as Operator, op2 as Operator returns Integer:
    Note: Returns positive if op1 has higher precedence, negative if lower, 0 if equal
    Return op1.precedence minus op2.precedence
End Process

Process called "is_left_associative" that takes op as Operator returns Boolean:
    Return StringUtils.string_equals(op.associativity, "left")
End Process

Process called "is_right_associative" that takes op as Operator returns Boolean:
    Return StringUtils.string_equals(op.associativity, "right")
End Process

Process called "is_non_associative" that takes op as Operator returns Boolean:
    Return StringUtils.string_equals(op.associativity, "none")
End Process

Note: =====================================================================
Note: OPERATOR CLASSIFICATION
Note: =====================================================================

@Reasoning
    Classify operators by their role in the language.
    This helps the parser understand context and validate usage.
@End Reasoning

Process called "is_arithmetic_operator" that takes op as Operator returns Boolean:
    Return StringUtils.string_equals(op.operator_type, "ARITHMETIC")
End Process

Process called "is_comparison_operator" that takes op as Operator returns Boolean:
    Return StringUtils.string_equals(op.operator_type, "COMPARISON")
End Process

Process called "is_logical_operator" that takes op as Operator returns Boolean:
    Return StringUtils.string_equals(op.operator_type, "LOGICAL")
End Process

Process called "is_bitwise_operator" that takes op as Operator returns Boolean:
    Return StringUtils.string_equals(op.operator_type, "BITWISE")
End Process

Process called "is_assignment_operator" that takes op as Operator returns Boolean:
    Return StringUtils.string_equals(op.operator_type, "ASSIGNMENT")
End Process

Process called "is_unary_operator" that takes op as Operator returns Boolean:
    Note: Unary operators include Not, bitwise not, and unary minus
    Return StringUtils.string_equals(op.canonical_form, "Not") Or
           StringUtils.string_equals(op.canonical_form, "bitwise not") Or
           (StringUtils.string_equals(op.canonical_form, "minus") And 
            StringUtils.string_equals(op.associativity, "right"))
End Process

Process called "is_binary_operator" that takes op as Operator returns Boolean:
    Note: Most operators are binary
    Return Not is_unary_operator(op)
End Process

Note: =====================================================================
Note: MODE CONVERSION
Note: =====================================================================

@Reasoning
    Convert between canonical (natural language) and symbolic forms.
    Essential for dual-mode support in the compiler.
@End Reasoning

Process called "canonical_to_symbol" that takes canonical as String returns String:
    Let op be get_operator_by_canonical(canonical)
    Return op.symbol_form
End Process

Process called "symbol_to_canonical" that takes symbol as String returns String:
    Let op be get_operator_by_symbol(symbol)
    Return op.canonical_form
End Process

Process called "is_valid_operator" that takes text as String, mode as String returns Boolean:
    If StringUtils.string_equals(mode, "canon"):
        Return is_operator_canonical(text)
    Otherwise If StringUtils.string_equals(mode, "symbol"):
        Return is_operator_symbol(text)
    Otherwise:
        Return False
    End If
End Process

Note: =====================================================================
Note: SPECIAL OPERATOR HANDLING
Note: =====================================================================

@Reasoning
    Some operators need special handling in certain contexts.
    For example, minus can be both binary and unary.
@End Reasoning

Process called "determine_minus_type" that takes previous_token_type as String returns String:
    Note: Determine if minus is unary or binary based on previous token
    
    If StringUtils.string_equals(previous_token_type, "OPERATOR"):
        Return "UNARY"  Note: After another operator, it's unary
    End If
    
    If StringUtils.string_equals(previous_token_type, "OPEN_PAREN"):
        Return "UNARY"  Note: After opening parenthesis, it's unary
    End If
    
    If StringUtils.string_equals(previous_token_type, "KEYWORD"):
        Return "UNARY"  Note: After most keywords, it's unary
    End If
    
    If StringUtils.string_equals(previous_token_type, "NUMBER") Or
       StringUtils.string_equals(previous_token_type, "IDENTIFIER") Or
       StringUtils.string_equals(previous_token_type, "CLOSE_PAREN"):
        Return "BINARY"  Note: After operands, it's binary
    End If
    
    Return "UNARY"  Note: Default to unary in ambiguous cases
End Process

Note: =====================================================================
Note: UTILITY FUNCTIONS
Note: =====================================================================

Process called "get_operator_count" returns Integer:
    Return Collections.list_length(all_operators)
End Process

Process called "get_all_canonical_operators" returns Collections.List:
    Let canonicals be Collections.create_list()
    
    For i from 0 to Collections.list_length(all_operators) minus 1:
        Let op be Collections.list_get(all_operators, i)
        Collections.list_append(canonicals, op.canonical_form)
    End For
    
    Return canonicals
End Process

Process called "get_all_symbol_operators" returns Collections.List:
    Let symbols be Collections.create_list()
    
    For i from 0 to Collections.list_length(all_operators) minus 1:
        Let op be Collections.list_get(all_operators, i)
        Collections.list_append(symbols, op.symbol_form)
    End For
    
    Return symbols
End Process