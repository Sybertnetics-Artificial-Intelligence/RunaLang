Note:
compiler/frontend/lexical/lexer_factory.runa
Lexer Factory with Syntax Mode Support

This module provides factory functions for creating lexers with specific syntax modes.
It serves as the integration point between the CLI and the lexer, ensuring that
the syntax mode (Canon or Developer) is properly configured.

Features:
- Creates lexers with specified syntax mode
- Validates mode configuration
- Provides mode-specific initialization
- Integrates with existing lexer infrastructure
:End Note

Import "./lexer" as Lexer
Import "./token_stream" as TokenStream
Import "compiler/internal/string_utils" as StringUtils
Import "compiler/internal/collections" as Collections

Note: =====================================================================
Note: LEXER FACTORY FUNCTIONS
Note: =====================================================================

@Reasoning
    The lexer factory serves as the bridge between CLI mode configuration
    and the actual lexer implementation. It ensures that the syntax mode
    is properly validated and applied to the lexer state.
@End Reasoning

Process called "create_lexer_with_mode" that takes source as String, mode as String returns LexerState:
    @Implementation
        Factory function to create a lexer with a specified syntax mode.
        Validates the mode and initializes the lexer with proper configuration.
    @End Implementation
    
    Note: Validate syntax mode
    If Not validate_syntax_mode(mode):
        Throw LexerError with message as "Invalid syntax mode: " concatenated with mode
    End If
    
    Note: Create base lexer with standard initialization
    Let lexer be Lexer.create_lexer(source)
    
    Note: Set the syntax mode
    Set lexer.syntax_mode to mode
    
    Note: Apply mode-specific configuration
    If string_equals(mode, "developer"):
        configure_developer_mode(lexer)
    Otherwise:
        configure_canon_mode(lexer)
    End If
    
    Note: Initialize mode-specific state
    initialize_mode_state(lexer, mode)
    
    Return lexer
End Process

Process called "create_lexer_with_options" that takes source as String, options as Dictionary returns LexerState:
    @Implementation
        Create a lexer with options dictionary that may include syntax mode.
        This is the preferred interface for the compiler driver.
    @End Implementation
    
    Note: Extract syntax mode from options or use default
    Let mode be "canon"
    If options contains "syntax_mode":
        Set mode to options get "syntax_mode"
    End If
    
    Note: Create lexer with specified mode
    Let lexer be create_lexer_with_mode(source, mode)
    
    Note: Apply additional options
    If options contains "file_path":
        Set lexer.current_file to options get "file_path"
    End If
    
    If options contains "preserve_comments":
        Set lexer.preserve_comments to options get "preserve_comments"
    End If
    
    If options contains "preserve_whitespace":
        Set lexer.preserve_whitespace to options get "preserve_whitespace"
    End If
    
    If options contains "track_annotations":
        Set lexer.track_annotations to options get "track_annotations"
    End If
    
    Return lexer
End Process

Note: =====================================================================
Note: MODE VALIDATION
Note: =====================================================================

Process called "validate_syntax_mode" that takes mode as String returns Boolean:
    @Implementation
        Validate that the mode string is one of the supported syntax modes.
        Currently supports "canon" and "developer" modes.
    @End Implementation
    
    Return string_equals(mode, "canon") Or string_equals(mode, "developer")
End Process

Process called "get_supported_modes" returns List:
    @Implementation
        Return list of all supported syntax modes.
        Useful for error messages and documentation.
    @End Implementation
    
    Let modes be Collections.create_list()
    Collections.list_append(modes, "canon")
    Collections.list_append(modes, "developer")
    Return modes
End Process

Note: =====================================================================
Note: MODE-SPECIFIC CONFIGURATION
Note: =====================================================================

Process called "configure_canon_mode" that takes lexer as LexerState returns Nothing:
    @Implementation
        Configure lexer for Canon mode (natural language operators).
        This is the default mode with full natural language support.
    @End Implementation
    
    Note: Canon mode uses natural language operators
    Set lexer.use_natural_operators to True
    Set lexer.allow_unicode_operators to True
    Set lexer.strict_keyword_matching to False
    
    Note: Canon mode specific features
    Set lexer.allow_multiword_operators to True
    Set lexer.case_sensitive_keywords to False
End Process

Process called "configure_developer_mode" that takes lexer as LexerState returns Nothing:
    @Implementation
        Configure lexer for Developer mode (bare assignment syntax).
        This mode uses minimal syntax with bare assignments (x = value).
    @End Implementation
    
    Note: Developer mode uses bare assignment without keywords
    Set lexer.use_natural_operators to False
    Set lexer.allow_unicode_operators to True
    Set lexer.strict_keyword_matching to True
    
    Note: Developer mode specific features - no let/var/const keywords
    Set lexer.allow_multiword_operators to False
    Set lexer.case_sensitive_keywords to False
    Set lexer.support_bare_assignment to True
End Process

Process called "initialize_mode_state" that takes lexer as LexerState, mode as String returns Nothing:
    @Implementation
        Initialize any mode-specific state in the lexer.
        This includes operator tables and conversion mappings.
    @End Implementation
    
    Note: Set mode identifier for downstream processing
    Set lexer.active_mode to mode
    
    Note: Initialize operator conversion state
    If string_equals(mode, "developer"):
        Set lexer.operator_conversion_enabled to True
        Set lexer.operator_target_mode to "canon"
    Otherwise:
        Set lexer.operator_conversion_enabled to False
        Set lexer.operator_target_mode to mode
    End If
    
    Note: Track mode for viewer transformation
    Set lexer.source_syntax_mode to mode
    Set lexer.preserve_original_operators to True
End Process

Note: =====================================================================
Note: MODE INFORMATION UTILITIES
Note: =====================================================================

Process called "get_mode_description" that takes mode as String returns String:
    @Implementation
        Return a human-readable description of the syntax mode.
        Used for user feedback and documentation.
    @End Implementation
    
    If string_equals(mode, "canon"):
        Return "Canonical Runa - Natural language syntax with words like 'plus' and 'is equal to'"
    Otherwise If string_equals(mode, "developer"):
        Return "Developer Mode - Familiar symbols like '+' and '=='"
    Otherwise:
        Return "Unknown mode: " concatenated with mode
    End If
End Process

Process called "detect_source_mode" that takes source as String returns String:
    @Implementation
        Attempt to detect the syntax mode from source code patterns.
        Returns best guess or "canon" as default.
    @End Implementation
    
    Note: Score-based detection
    Let canon_score be 0
    Let developer_score be 0
    
    Note: Check for Canon mode indicators
    If source contains "Process called":
        Add 10 to canon_score
    End If
    If source contains " plus " Or source contains " minus ":
        Add 5 to canon_score
    End If
    If source contains "is equal to" Or source contains "is not equal to":
        Add 5 to canon_score
    End If
    If source contains "Let " Or source contains "Set ":
        Add 3 to canon_score
    End If
    
    Note: Check for Developer mode indicators
    If source contains "==" Or source contains "!=":
        Add 5 to developer_score
    End If
    If source contains "++" Or source contains "--":
        Add 5 to developer_score
    End If
    If source contains "+=" Or source contains "-=":
        Add 3 to developer_score
    End If
    If source contains "&&" Or source contains "||":
        Add 3 to developer_score
    End If
    
    Note: Return mode with higher score
    If developer_score greater than canon_score:
        Return "developer"
    Otherwise:
        Return "canon"
    End If
End Process

Note: =====================================================================
Note: BATCH PROCESSING SUPPORT
Note: =====================================================================

Process called "create_lexers_for_files" that takes files as List, mode as String returns List:
    @Implementation
        Create lexers for multiple files with the same syntax mode.
        Useful for batch compilation.
    @End Implementation
    
    Let lexers be Collections.create_list()
    
    For file_path in files:
        Let source be read_file(file_path)
        Let options be Collections.create_dictionary()
        Collections.dict_set(options, "syntax_mode", mode)
        Collections.dict_set(options, "file_path", file_path)
        
        Let lexer be create_lexer_with_options(source, options)
        Collections.list_append(lexers, lexer)
    End For
    
    Return lexers
End Process