Note:
compiler/frontend/lexical/intentional_recovery/error_context.runa
Error Context Packaging

This module creates structured error context packages that serve as
"sensory reports" from the compiler to potential AI agents.
It transforms raw errors into rich, contextual information.
:End Note

Import Module "compiler/internal/collections" as Collections
Import Module "compiler/internal/string_utils" as StringUtils
Import Module "compiler/frontend/diagnostics/errors" as Errors

Note: =====================================================================
Note: ERROR CONTEXT DATA STRUCTURES
Note: =====================================================================

Type called "ErrorContextPackage":
    error_message as String
    error_type as String
    error_line as Integer
    error_column as Integer
    error_token as String
    
    code_context as String
    preceding_lines as Collections.List
    following_lines as Collections.List
    
    symbol_table_snapshot as Collections.Dictionary
    partial_ast_snapshot as Optional[Any]
    
    task_annotation as Optional[String]
    reasoning_annotation as Optional[String]
    implementation_annotation as Optional[String]
    annotations_nearby as Collections.List
    
    recovery_attempts as Collections.List
    confidence_scores as Collections.Dictionary
    
    ai_prompt as Optional[String]
    structured_data as Collections.Dictionary
End Type

Type called "RecoveryAttempt":
    strategy_name as String
    stage as Integer
    success as Boolean
    confidence as Float
    correction as Optional[String]
    explanation as String
    timestamp as Float
End Type

Type called "CodeContext":
    line_number as Integer
    content as String
    is_error_line as Boolean
    indentation_level as Integer
    tokens as Collections.List
End Type

Note: =====================================================================
Note: CONTEXT PACKAGE CREATION
Note: =====================================================================

Process called "create_error_context_package" returns ErrorContextPackage:
    @Reasoning
        Initialize an empty error context package that will be populated
        with various types of contextual information.
    @End Reasoning
    
    Return ErrorContextPackage with
        error_message as "",
        error_type as "",
        error_line as 0,
        error_column as 0,
        error_token as "",
        
        code_context as "",
        preceding_lines as Collections.create_list(),
        following_lines as Collections.create_list(),
        
        symbol_table_snapshot as Collections.create_dictionary(),
        partial_ast_snapshot as None,
        
        task_annotation as None,
        reasoning_annotation as None,
        implementation_annotation as None,
        annotations_nearby as Collections.create_list(),
        
        recovery_attempts as Collections.create_list(),
        confidence_scores as Collections.create_dictionary(),
        
        ai_prompt as None,
        structured_data as Collections.create_dictionary()
    End ErrorContextPackage
End Process

Note: =====================================================================
Note: CONTEXT POPULATION FUNCTIONS
Note: =====================================================================

Process called "add_error_info" that takes package as ErrorContextPackage, error as Errors.LexerError returns Nothing:
    @Implementation
        Extract and store basic error information from the lexer error.
    @End Implementation
    
    Set package.error_message to error.message
    Set package.error_type to error.error_type
    Set package.error_line to error.line
    Set package.error_column to error.column
    Set package.error_token to error.token_text
End Process

Process called "add_code_context" that takes package as ErrorContextPackage, context as Collections.List returns Nothing:
    @Reasoning
        Add surrounding code lines to provide context for the error.
        This helps understand what the code was doing before and after.
    @End Reasoning
    
    Let error_line_index be find_error_line_index(context, package.error_line)
    
    Note: Extract preceding lines (up to 5)
    Let start_index be max(0, error_line_index minus 5)
    For i from start_index to error_line_index minus 1:
        Let line_context be Collections.list_get(context, i)
        Collections.list_append(package.preceding_lines, line_context)
    End For
    
    Note: Extract error line
    If error_line_index is greater than or equal to 0:
        Let error_line_context be Collections.list_get(context, error_line_index)
        Set package.code_context to error_line_context.content
    End If
    
    Note: Extract following lines (up to 5)
    Let end_index be min(Collections.list_size(context), error_line_index plus 6)
    For i from error_line_index plus 1 to end_index minus 1:
        Let line_context be Collections.list_get(context, i)
        Collections.list_append(package.following_lines, line_context)
    End For
End Process

Process called "add_symbol_table" that takes package as ErrorContextPackage, symbol_table as Optional[Any] returns Nothing:
    @Implementation
        Create a snapshot of relevant symbols in scope at the error location.
    @End Implementation
    
    If symbol_table is None:
        Return Nothing
    End If
    
    Note: Extract symbols in current scope
    Let current_scope be extract_scope_at_line(symbol_table, package.error_line)
    
    For Each symbol in current_scope:
        Let symbol_info be Collections.create_dictionary()
        Collections.dict_set(symbol_info, "name", symbol.name)
        Collections.dict_set(symbol_info, "type", symbol.type_name)
        Collections.dict_set(symbol_info, "kind", symbol.kind)
        Collections.dict_set(symbol_info, "defined_at", symbol.definition_line)
        
        Collections.dict_set(package.symbol_table_snapshot, symbol.name, symbol_info)
    End For
End Process

Process called "add_partial_ast" that takes package as ErrorContextPackage, ast as Optional[Any] returns Nothing:
    @Implementation
        Store a snapshot of the partial AST if available.
        This helps understand the program structure around the error.
    @End Implementation
    
    If ast is None:
        Return Nothing
    End If
    
    Set package.partial_ast_snapshot to ast
    
    Note: Extract structural information
    Let structure_info be extract_ast_structure(ast, package.error_line)
    Collections.dict_set(package.structured_data, "ast_structure", structure_info)
End Process

Process called "add_annotations" that takes package as ErrorContextPackage, annotations as Collections.Dictionary returns Nothing:
    @Reasoning
        Extract and store relevant annotations that provide intent information.
        This is crucial for Stage 2 semantic analysis.
    @End Reasoning
    
    Note: Look for @Task annotation
    If Collections.dict_contains(annotations, "Task"):
        Set package.task_annotation to Collections.dict_get(annotations, "Task")
    End If
    
    Note: Look for @Reasoning annotation
    If Collections.dict_contains(annotations, "Reasoning"):
        Set package.reasoning_annotation to Collections.dict_get(annotations, "Reasoning")
    End If
    
    Note: Look for @Implementation annotation
    If Collections.dict_contains(annotations, "Implementation"):
        Set package.implementation_annotation to Collections.dict_get(annotations, "Implementation")
    End If
    
    Note: Store all nearby annotations
    For Each key in Collections.dict_keys(annotations):
        Let annotation_info be Collections.create_dictionary()
        Collections.dict_set(annotation_info, "type", key)
        Collections.dict_set(annotation_info, "content", Collections.dict_get(annotations, key))
        Collections.list_append(package.annotations_nearby, annotation_info)
    End For
End Process

Process called "add_previous_attempts" that takes package as ErrorContextPackage, previous_result as Any returns Nothing:
    @Implementation
        Record previous recovery attempts for learning and debugging.
    @End Implementation
    
    If previous_result is None:
        Return Nothing
    End If
    
    Let attempt be RecoveryAttempt with
        strategy_name as previous_result.strategy_name,
        stage as previous_result.stage_reached,
        success as previous_result.success,
        confidence as previous_result.confidence,
        correction as previous_result.correction,
        explanation as previous_result.explanation,
        timestamp as get_current_timestamp()
    End RecoveryAttempt
    
    Collections.list_append(package.recovery_attempts, attempt)
    
    Note: Track confidence scores
    Collections.dict_set(package.confidence_scores, 
        previous_result.strategy_name, previous_result.confidence)
End Process

Note: =====================================================================
Note: AI PROMPT GENERATION
Note: =====================================================================

Process called "set_ai_prompt" that takes package as ErrorContextPackage, prompt as String returns Nothing:
    @Implementation
        Store the AI prompt for potential Stage 3 intervention.
    @End Implementation
    
    Set package.ai_prompt to prompt
End Process

Process called "generate_structured_prompt" that takes package as ErrorContextPackage returns String:
    @Reasoning
        Create a highly structured prompt that maximizes the chance of
        getting a correct fix from an AI agent.
    @End Reasoning
    
    Let prompt be "ERROR CONTEXT PACKAGE\n"
    Set prompt to string_concat(prompt, "=" repeated 50, "\n\n")
    
    Note: Error Information
    Set prompt to string_concat(prompt, "ERROR INFORMATION:\n")
    Set prompt to string_concat(prompt, "  Type: ", package.error_type, "\n")
    Set prompt to string_concat(prompt, "  Message: ", package.error_message, "\n")
    Set prompt to string_concat(prompt, "  Location: Line ", integer_to_string(package.error_line))
    Set prompt to string_concat(prompt, ", Column ", integer_to_string(package.error_column), "\n")
    Set prompt to string_concat(prompt, "  Token: '", package.error_token, "'\n\n")
    
    Note: Intent Information
    If package.task_annotation is not None:
        Set prompt to string_concat(prompt, "STATED INTENT (@Task):\n")
        Set prompt to string_concat(prompt, "  ", package.task_annotation, "\n\n")
    End If
    
    If package.reasoning_annotation is not None:
        Set prompt to string_concat(prompt, "DEVELOPER REASONING (@Reasoning):\n")
        Set prompt to string_concat(prompt, "  ", package.reasoning_annotation, "\n\n")
    End If
    
    Note: Code Context
    Set prompt to string_concat(prompt, "CODE CONTEXT:\n")
    Set prompt to string_concat(prompt, format_code_context(package), "\n\n")
    
    Note: Symbol Table
    If not Collections.dict_is_empty(package.symbol_table_snapshot):
        Set prompt to string_concat(prompt, "SYMBOLS IN SCOPE:\n")
        Set prompt to string_concat(prompt, format_symbol_table(package.symbol_table_snapshot), "\n\n")
    End If
    
    Note: Previous Attempts
    If not Collections.list_is_empty(package.recovery_attempts):
        Set prompt to string_concat(prompt, "PREVIOUS RECOVERY ATTEMPTS:\n")
        Set prompt to string_concat(prompt, format_recovery_attempts(package.recovery_attempts), "\n\n")
    End If
    
    Note: Request
    Set prompt to string_concat(prompt, "REQUEST:\n")
    Set prompt to string_concat(prompt, "Based on the above context, generate a corrected version ")
    Set prompt to string_concat(prompt, "of the erroneous line that aligns with the stated intent.\n")
    
    Return prompt
End Process

Note: =====================================================================
Note: FORMATTING HELPERS
Note: =====================================================================

Process called "format_code_context" that takes package as ErrorContextPackage returns String:
    @Implementation
        Format the code context with line numbers and error highlighting.
    @End Implementation
    
    Let formatted be ""
    Let line_num be package.error_line minus Collections.list_size(package.preceding_lines)
    
    Note: Format preceding lines
    For Each line in package.preceding_lines:
        Set formatted to string_concat(formatted, 
            string_pad_left(integer_to_string(line_num), 4), " | ", line.content, "\n")
        Set line_num to line_num plus 1
    End For
    
    Note: Format error line with highlighting
    Set formatted to string_concat(formatted,
        string_pad_left(integer_to_string(package.error_line), 4), " > ", package.code_context, "\n")
    Set formatted to string_concat(formatted,
        "      ", " " repeated package.error_column, "^ Error here\n")
    Set line_num to package.error_line plus 1
    
    Note: Format following lines
    For Each line in package.following_lines:
        Set formatted to string_concat(formatted,
            string_pad_left(integer_to_string(line_num), 4), " | ", line.content, "\n")
        Set line_num to line_num plus 1
    End For
    
    Return formatted
End Process

Process called "format_symbol_table" that takes symbols as Collections.Dictionary returns String:
    @Implementation
        Format the symbol table snapshot for readability.
    @End Implementation
    
    Let formatted be ""
    
    For Each name in Collections.dict_keys(symbols):
        Let symbol be Collections.dict_get(symbols, name)
        Set formatted to string_concat(formatted, "  - ", name)
        Set formatted to string_concat(formatted, " (", Collections.dict_get(symbol, "kind"), ")")
        Set formatted to string_concat(formatted, ": ", Collections.dict_get(symbol, "type"), "\n")
    End For
    
    Return formatted
End Process

Process called "format_recovery_attempts" that takes attempts as Collections.List returns String:
    @Implementation
        Format the list of recovery attempts for debugging.
    @End Implementation
    
    Let formatted be ""
    
    For Each attempt in attempts:
        Set formatted to string_concat(formatted, "  - Stage ", integer_to_string(attempt.stage))
        Set formatted to string_concat(formatted, " / ", attempt.strategy_name)
        Set formatted to string_concat(formatted, " (confidence: ", float_to_string(attempt.confidence), ")")
        
        If attempt.success:
            Set formatted to string_concat(formatted, " [SUCCESS]\n")
            Set formatted to string_concat(formatted, "    Correction: ", attempt.correction, "\n")
        Otherwise:
            Set formatted to string_concat(formatted, " [FAILED]\n")
        End If
        
        Set formatted to string_concat(formatted, "    ", attempt.explanation, "\n")
    End For
    
    Return formatted
End Process

Note: =====================================================================
Note: UTILITY FUNCTIONS
Note: =====================================================================

Process called "extract_scope_at_line" that takes symbol_table as Any, line as Integer returns Collections.List:
    @Implementation
        Extract symbols that are in scope at the given line number.
    @End Implementation
    
    Note: Interface with the symbol table to extract symbols in scope
    Note: Return empty list when no symbols are available at this line
    Return Collections.create_list()
End Process

Process called "extract_ast_structure" that takes ast as Any, line as Integer returns Collections.Dictionary:
    @Implementation
        Extract structural information from the AST around the error line.
    @End Implementation
    
    Note: Interface with the AST to extract structural information
    Note: Return empty dictionary when no AST structure is available
    Return Collections.create_dictionary()
End Process

Process called "find_error_line_index" that takes context as Collections.List, line_number as Integer returns Integer:
    @Implementation
        Find the index of the error line in the context list.
    @End Implementation
    
    Let index be 0
    For Each line_context in context:
        If line_context.line_number equals line_number:
            Return index
        End If
        Set index to index plus 1
    End For
    
    Return negative 1
End Process

Process called "get_current_timestamp" returns Float:
    @Implementation
        Get the current timestamp for tracking recovery attempts.
    @End Implementation
    
    Note: Get current system timestamp using OS syscall
    External clock_gettime_ns() returns Integer
    Let timestamp_ns be clock_gettime_ns()
    Let timestamp_ms be timestamp_ns / 1000000
    Return Float(timestamp_ms) / 1000.0
End Process