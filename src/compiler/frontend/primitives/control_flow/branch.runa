Note:
control_flow/branch.runa - Zero-Dependency Conditional Branching Primitives

This module provides fundamental conditional branching operations using direct CPU instructions.
These primitives have ZERO dependencies and compile to efficient conditional jump instructions.

@Reasoning:
- Provides low-level conditional control flow for compiler code generation
- All operations use inline assembly for true self-hosting capabilities
- No external dependencies - we generate the machine code directly
- Essential for implementing if/else, while, for, and other control structures

@Implementation:
- Inline Assembly statements using conditional jump instructions
- Direct CPU flag testing for efficient branching
- Support for all standard comparison conditions
- Zero-cost abstraction through compile-time optimization

@Performance_Hints:
- Each branch maps to single conditional jump instruction
- Modern CPUs have excellent branch prediction
- Keep hot paths predictable for best performance
- Use branchless operations for simple conditional moves
:End Note

Note: =====================================================================
Note: BASIC CONDITIONAL BRANCHES (based on flags)
Note: =====================================================================

Process called "branch_if_zero" that takes value as Integer, target_address as Pointer:
    Inline Assembly:
        "test %0, %0\n"             Note: Test if value is zero
        "jz %1\n"                   Note: Jump if zero flag set
        :
        : "r"(value), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_not_zero" that takes value as Integer, target_address as Pointer:
    Inline Assembly:
        "test %0, %0\n"             Note: Test if value is zero
        "jnz %1\n"                  Note: Jump if not zero
        :
        : "r"(value), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_positive" that takes value as Integer, target_address as Pointer:
    Inline Assembly:
        "test %0, %0\n"             Note: Test sign flag
        "jns %1\n"                  Note: Jump if not signed (positive)
        :
        : "r"(value), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_negative" that takes value as Integer, target_address as Pointer:
    Inline Assembly:
        "test %0, %0\n"             Note: Test sign flag
        "js %1\n"                   Note: Jump if signed (negative)
        :
        : "r"(value), "r"(target_address)
        : "flags"
    End Assembly
End Process

Note: =====================================================================
Note: COMPARISON-BASED BRANCHES
Note: =====================================================================

Process called "branch_if_equal" that takes left as Integer, right as Integer, target_address as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare left and right
        "je %2\n"                   Note: Jump if equal
        :
        : "r"(left), "r"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_not_equal" that takes left as Integer, right as Integer, target_address as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare left and right
        "jne %2\n"                  Note: Jump if not equal
        :
        : "r"(left), "r"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_less" that takes left as Integer, right as Integer, target_address as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare left and right
        "jl %2\n"                   Note: Jump if less than
        :
        : "r"(left), "r"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_less_equal" that takes left as Integer, right as Integer, target_address as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare left and right
        "jle %2\n"                  Note: Jump if less than or equal
        :
        : "r"(left), "r"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_greater" that takes left as Integer, right as Integer, target_address as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare left and right
        "jg %2\n"                   Note: Jump if greater than
        :
        : "r"(left), "r"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_greater_equal" that takes left as Integer, right as Integer, target_address as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare left and right
        "jge %2\n"                  Note: Jump if greater than or equal
        :
        : "r"(left), "r"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Note: =====================================================================
Note: UNSIGNED COMPARISON BRANCHES
Note: =====================================================================

Process called "branch_if_below" that takes left as Integer, right as Integer, target_address as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare unsigned values
        "jb %2\n"                   Note: Jump if below (unsigned)
        :
        : "r"(left), "r"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_below_equal" that takes left as Integer, right as Integer, target_address as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare unsigned values
        "jbe %2\n"                  Note: Jump if below or equal (unsigned)
        :
        : "r"(left), "r"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_above" that takes left as Integer, right as Integer, target_address as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare unsigned values
        "ja %2\n"                   Note: Jump if above (unsigned)
        :
        : "r"(left), "r"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_above_equal" that takes left as Integer, right as Integer, target_address as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare unsigned values
        "jae %2\n"                  Note: Jump if above or equal (unsigned)
        :
        : "r"(left), "r"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Note: =====================================================================
Note: FLOATING POINT BRANCHES
Note: =====================================================================

Process called "branch_if_float_equal" that takes left as Float, right as Float, target_address as Pointer:
    Inline Assembly:
        "ucomisd %0, %1\n"          Note: Compare floating point values
        "je %2\n"                   Note: Jump if equal
        :
        : "x"(left), "x"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_float_not_equal" that takes left as Float, right as Float, target_address as Pointer:
    Inline Assembly:
        "ucomisd %0, %1\n"          Note: Compare floating point values
        "jne %2\n"                  Note: Jump if not equal
        :
        : "x"(left), "x"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_float_less" that takes left as Float, right as Float, target_address as Pointer:
    Inline Assembly:
        "ucomisd %0, %1\n"          Note: Compare floating point values
        "jb %2\n"                   Note: Jump if below
        :
        : "x"(left), "x"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_float_less_equal" that takes left as Float, right as Float, target_address as Pointer:
    Inline Assembly:
        "ucomisd %0, %1\n"          Note: Compare floating point values
        "jbe %2\n"                  Note: Jump if below or equal
        :
        : "x"(left), "x"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_float_greater" that takes left as Float, right as Float, target_address as Pointer:
    Inline Assembly:
        "ucomisd %0, %1\n"          Note: Compare floating point values
        "ja %2\n"                   Note: Jump if above
        :
        : "x"(left), "x"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_float_greater_equal" that takes left as Float, right as Float, target_address as Pointer:
    Inline Assembly:
        "ucomisd %0, %1\n"          Note: Compare floating point values
        "jae %2\n"                  Note: Jump if above or equal
        :
        : "x"(left), "x"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_float_unordered" that takes left as Float, right as Float, target_address as Pointer:
    Inline Assembly:
        "ucomisd %0, %1\n"          Note: Compare floating point values
        "jp %2\n"                   Note: Jump if parity (unordered)
        :
        : "x"(left), "x"(right), "r"(target_address)
        : "flags"
    End Assembly
End Process

Note: =====================================================================
Note: BIT TEST BRANCHES
Note: =====================================================================

Process called "branch_if_bit_set" that takes value as Integer, bit as Integer, target_address as Pointer:
    Inline Assembly:
        "bt %0, %1\n"               Note: Test bit in value
        "jc %2\n"                   Note: Jump if carry (bit set)
        :
        : "r"(value), "r"(bit), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_bit_clear" that takes value as Integer, bit as Integer, target_address as Pointer:
    Inline Assembly:
        "bt %0, %1\n"               Note: Test bit in value
        "jnc %2\n"                  Note: Jump if no carry (bit clear)
        :
        : "r"(value), "r"(bit), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_any_bit_set" that takes value as Integer, mask as Integer, target_address as Pointer:
    Inline Assembly:
        "test %0, %1\n"             Note: Test bits with mask
        "jnz %2\n"                  Note: Jump if any bit set
        :
        : "r"(value), "r"(mask), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_no_bits_set" that takes value as Integer, mask as Integer, target_address as Pointer:
    Inline Assembly:
        "test %0, %1\n"             Note: Test bits with mask
        "jz %2\n"                   Note: Jump if no bits set
        :
        : "r"(value), "r"(mask), "r"(target_address)
        : "flags"
    End Assembly
End Process

Note: =====================================================================
Note: ARITHMETIC FLAG BRANCHES
Note: =====================================================================

Process called "branch_if_overflow" that takes target_address as Pointer:
    Inline Assembly:
        "jo %0\n"                   Note: Jump if overflow flag set
        :
        : "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_no_overflow" that takes target_address as Pointer:
    Inline Assembly:
        "jno %0\n"                  Note: Jump if overflow flag clear
        :
        : "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_carry" that takes target_address as Pointer:
    Inline Assembly:
        "jc %0\n"                   Note: Jump if carry flag set
        :
        : "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_no_carry" that takes target_address as Pointer:
    Inline Assembly:
        "jnc %0\n"                  Note: Jump if carry flag clear
        :
        : "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_parity_even" that takes target_address as Pointer:
    Inline Assembly:
        "jp %0\n"                   Note: Jump if parity flag set (even)
        :
        : "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_parity_odd" that takes target_address as Pointer:
    Inline Assembly:
        "jnp %0\n"                  Note: Jump if parity flag clear (odd)
        :
        : "r"(target_address)
        : "flags"
    End Assembly
End Process

Note: =====================================================================
Note: LOOP CONTROL BRANCHES
Note: =====================================================================

Process called "branch_loop_while_counter" that takes counter as Pointer, target_address as Pointer:
    Inline Assembly:
        "dec qword ptr [%0]\n"      Note: Decrement counter in memory
        "jnz %1\n"                  Note: Jump if counter not zero
        :
        : "r"(counter), "r"(target_address)
        : "memory", "flags"
    End Assembly
End Process

Process called "branch_loop_while_zero" that takes counter as Pointer, target_address as Pointer:
    Inline Assembly:
        "dec qword ptr [%0]\n"      Note: Decrement counter in memory
        "jz %1\n"                   Note: Jump if counter is zero
        :
        : "r"(counter), "r"(target_address)
        : "memory", "flags"
    End Assembly
End Process

Process called "branch_with_counter_decrement" that takes counter_reg as String, target_address as Pointer:
    Inline Assembly:
        "loop %0\n"                 Note: Decrement RCX and jump if not zero
        :
        : "r"(target_address)
        : "rcx", "flags"
    End Assembly
End Process

Note: =====================================================================
Note: CONDITIONAL EXECUTION WITHOUT BRANCHING
Note: =====================================================================

Process called "execute_if_zero" that takes value as Integer, instruction_ptr as Pointer:
    Inline Assembly:
        "test %0, %0\n"             Note: Test if value is zero
        "jnz 1f\n"                  Note: Skip call if not zero
        "call %1\n"                 Note: Call instruction if zero
        "1:\n"                      Note: Jump target label
        :
        : "r"(value), "r"(instruction_ptr)
        : "flags"
    End Assembly
End Process

Process called "execute_if_not_zero" that takes value as Integer, instruction_ptr as Pointer:
    Inline Assembly:
        "test %0, %0\n"             Note: Test if value is zero
        "jz 1f\n"                   Note: Skip call if zero
        "call %1\n"                 Note: Call instruction if not zero
        "1:\n"                      Note: Jump target label
        :
        : "r"(value), "r"(instruction_ptr)
        : "flags"
    End Assembly
End Process

Process called "execute_if_equal" that takes left as Integer, right as Integer, instruction_ptr as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare values
        "jne 1f\n"                  Note: Skip call if not equal
        "call %2\n"                 Note: Call instruction if equal
        "1:\n"                      Note: Jump target label
        :
        : "r"(left), "r"(right), "r"(instruction_ptr)
        : "flags"
    End Assembly
End Process

Process called "execute_if_not_equal" that takes left as Integer, right as Integer, instruction_ptr as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare values
        "je 1f\n"                   Note: Skip call if equal
        "call %2\n"                 Note: Call instruction if not equal
        "1:\n"                      Note: Jump target label
        :
        : "r"(left), "r"(right), "r"(instruction_ptr)
        : "flags"
    End Assembly
End Process

Note: =====================================================================
Note: BRANCH PREDICTION HINTS
Note: =====================================================================

Process called "branch_likely_taken" that takes condition as Boolean, target_address as Pointer:
    Note: Branch with hint that it's likely to be taken
    Inline Assembly:
        "test %0, %0\n"             Note: Test condition
        "jnz %1\n"                  Note: Jump if likely taken
        :
        : "r"(condition), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_likely_not_taken" that takes condition as Boolean, target_address as Pointer:
    Note: Branch with hint that it's likely not to be taken
    Inline Assembly:
        "test %0, %0\n"             Note: Test condition
        "jz %1\n"                   Note: Jump if likely not taken
        :
        : "r"(condition), "r"(target_address)
        : "flags"
    End Assembly
End Process

Note: =====================================================================
Note: COMPOUND CONDITIONAL BRANCHES
Note: =====================================================================

Process called "branch_if_in_range" that takes value as Integer, min_val as Integer, max_val as Integer, target_address as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare with minimum
        "jl 1f\n"                   Note: Skip if below range
        "cmp %0, %2\n"              Note: Compare with maximum
        "jle %3\n"                  Note: Jump if in range
        "1:\n"                      Note: Out of range label
        :
        : "r"(value), "r"(min_val), "r"(max_val), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_out_of_range" that takes value as Integer, min_val as Integer, max_val as Integer, target_address as Pointer:
    Inline Assembly:
        "cmp %0, %1\n"              Note: Compare with minimum
        "jl %3\n"                   Note: Jump if below range
        "cmp %0, %2\n"              Note: Compare with maximum
        "jg %3\n"                   Note: Jump if above range
        :
        : "r"(value), "r"(min_val), "r"(max_val), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_null_pointer" that takes ptr as Pointer, target_address as Pointer:
    Inline Assembly:
        "test %0, %0\n"             Note: Test if pointer is null
        "jz %1\n"                   Note: Jump if null
        :
        : "r"(ptr), "r"(target_address)
        : "flags"
    End Assembly
End Process

Process called "branch_if_valid_pointer" that takes ptr as Pointer, target_address as Pointer:
    Inline Assembly:
        "test %0, %0\n"             Note: Test if pointer is null
        "jnz %1\n"                  Note: Jump if not null
        :
        : "r"(ptr), "r"(target_address)
        : "flags"
    End Assembly
End Process

Note: =====================================================================
Note: CONDITIONAL MOVES (BRANCHLESS ALTERNATIVES)
Note: =====================================================================

Process called "select_on_zero" that takes condition as Integer, true_val as Integer, false_val as Integer returns Integer:
    Let result be false_val
    Inline Assembly:
        "test %1, %1\n"             Note: Test condition
        "cmovz %0, %2\n"            Note: Move true_val if zero
        "cmovnz %0, %3\n"           Note: Move false_val if not zero
        : "=r"(result)
        : "r"(condition), "r"(true_val), "r"(false_val)
        : "flags"
    End Assembly
    Return result
End Process

Process called "select_on_equal" that takes left as Integer, right as Integer, true_val as Integer, false_val as Integer returns Integer:
    Let result be false_val
    Inline Assembly:
        "cmp %1, %2\n"              Note: Compare values
        "cmove %0, %3\n"            Note: Move true_val if equal
        "cmovne %0, %4\n"           Note: Move false_val if not equal
        : "=r"(result)
        : "r"(left), "r"(right), "r"(true_val), "r"(false_val)
        : "flags"
    End Assembly
    Return result
End Process

Process called "select_on_less" that takes left as Integer, right as Integer, true_val as Integer, false_val as Integer returns Integer:
    Let result be false_val
    Inline Assembly:
        "cmp %1, %2\n"              Note: Compare values
        "cmovl %0, %3\n"            Note: Move true_val if less
        "cmovge %0, %4\n"           Note: Move false_val if greater or equal
        : "=r"(result)
        : "r"(left), "r"(right), "r"(true_val), "r"(false_val)
        : "flags"
    End Assembly
    Return result
End Process

Process called "select_on_greater" that takes left as Integer, right as Integer, true_val as Integer, false_val as Integer returns Integer:
    Let result be false_val
    Inline Assembly:
        "cmp %1, %2\n"              Note: Compare values
        "cmovg %0, %3\n"            Note: Move true_val if greater
        "cmovle %0, %4\n"           Note: Move false_val if less or equal
        : "=r"(result)
        : "r"(left), "r"(right), "r"(true_val), "r"(false_val)
        : "flags"
    End Assembly
    Return result
End Process