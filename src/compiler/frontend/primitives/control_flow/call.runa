Note:
control_flow/call.runa - Zero-Dependency Function Call Primitives

This module provides fundamental function call operations using direct CPU instructions.
These primitives have ZERO dependencies and compile to efficient call instructions.

@Reasoning:
- Provides low-level function call and stack management for compiler code generation
- All operations use inline assembly for true self-hosting capabilities
- No external dependencies - we generate the machine code directly
- Essential for implementing function calls, method dispatch, and stack management

@Implementation:
- Inline Assembly statements using call instructions and stack operations
- Direct stack pointer manipulation for argument passing
- Support for various calling conventions
- Zero-cost abstraction through compile-time optimization

@Performance_Hints:
- Each call maps to optimized call instruction sequence
- Stack alignment maintained for ABI compliance
- Register allocation optimized for calling conventions
- Minimal overhead for function dispatch
:End Note

Note: =====================================================================
Note: BASIC FUNCTION CALLS
Note: =====================================================================

Process called "call_function" that takes function_address as Pointer:
    Inline Assembly:
        "call %0\n"                 Note: Direct function call
        :
        : "r"(function_address)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_relative" that takes offset as Integer:
    Inline Assembly:
        "call %0\n"                 Note: Relative call with offset
        :
        : "r"(offset)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_indirect" that takes function_ptr as Pointer:
    Inline Assembly:
        "call [%0]\n"               Note: Indirect call through pointer
        :
        : "r"(function_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "memory"
    End Assembly
End Process

Process called "call_register" that takes function_reg as Pointer:
    Inline Assembly:
        "call %0\n"                 Note: Call through register
        :
        : "r"(function_reg)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_far" that takes segment as Integer16, offset as Pointer:
    Inline Assembly:
        "call far ptr %0:%1\n"      Note: Far call with segment:offset
        :
        : "r"(segment), "r"(offset)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Note: =====================================================================
Note: STACK MANAGEMENT FOR CALLS
Note: =====================================================================

Process called "push_argument" that takes arg as Integer:
    Inline Assembly:
        "push %0\n"                 Note: Push argument onto stack
        :
        : "r"(arg)
        : "rsp", "memory"
    End Assembly
End Process

Process called "push_argument_64" that takes arg as Integer64:
    Inline Assembly:
        "push %0\n"                 Note: Push 64-bit argument
        :
        : "r"(arg)
        : "rsp", "memory"
    End Assembly
End Process

Process called "push_argument_32" that takes arg as Integer32:
    Inline Assembly:
        "sub rsp, 8\n"              Note: Reserve stack space
        "mov dword ptr [rsp], %0\n" Note: Store 32-bit value
        :
        : "r"(arg)
        : "rsp", "memory"
    End Assembly
End Process

Process called "push_argument_ptr" that takes arg as Pointer:
    Inline Assembly:
        "push %0\n"                 Note: Push pointer argument
        :
        : "r"(arg)
        : "rsp", "memory"
    End Assembly
End Process

Process called "push_float_argument" that takes arg as Float:
    Inline Assembly:
        "sub rsp, 8\n"              Note: Reserve stack space
        "movsd [rsp], %0\n"         Note: Store floating point value
        :
        : "x"(arg)
        : "rsp", "memory"
    End Assembly
End Process

Process called "reserve_stack_space" that takes bytes as Integer:
    Inline Assembly:
        "sub rsp, %0\n"             Note: Reserve stack space
        :
        : "r"(bytes)
        : "rsp"
    End Assembly
End Process

Process called "cleanup_stack_space" that takes bytes as Integer:
    Inline Assembly:
        "add rsp, %0\n"             Note: Clean up stack space
        :
        : "r"(bytes)
        : "rsp"
    End Assembly
End Process

Process called "align_stack" that takes alignment as Integer:
    Inline Assembly:
        "neg %0\n"                  Note: Negate alignment
        "and rsp, %0\n"             Note: Align stack pointer
        :
        : "r"(alignment)
        : "rsp"
    End Assembly
End Process

Note: =====================================================================
Note: CALLING CONVENTION SUPPORT
Note: =====================================================================

Process called "call_cdecl" that takes function_ptr as Pointer, arg_bytes as Integer:
    Inline Assembly:
        "call %0\n"                 Note: Call function
        "add esp, %1\n"             Note: Clean up arguments (cdecl)
        :
        : "r"(function_ptr), "r"(arg_bytes)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "rsp"
    End Assembly
End Process

Process called "call_stdcall" that takes function_ptr as Pointer:
    Inline Assembly:
        "call %0\n"                 Note: Call function (callee cleans stack)
        :
        : "r"(function_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_fastcall" that takes function_ptr as Pointer, arg1 as Integer, arg2 as Integer:
    Inline Assembly:
        "mov ecx, %1\n"             Note: First arg in ECX
        "mov edx, %2\n"             Note: Second arg in EDX
        "call %0\n"                 Note: Call function
        :
        : "r"(function_ptr), "r"(arg1), "r"(arg2)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_system_v" that takes function_ptr as Pointer, rdi_arg as Integer, rsi_arg as Integer, rdx_arg as Integer:
    Inline Assembly:
        "mov rdi, %1\n"             Note: First arg in RDI
        "mov rsi, %2\n"             Note: Second arg in RSI
        "mov rdx, %3\n"             Note: Third arg in RDX
        "call %0\n"                 Note: Call function (System V ABI)
        :
        : "r"(function_ptr), "r"(rdi_arg), "r"(rsi_arg), "r"(rdx_arg)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_microsoft_x64" that takes function_ptr as Pointer, rcx_arg as Integer, rdx_arg as Integer, r8_arg as Integer, r9_arg as Integer:
    Inline Assembly:
        "mov rcx, %1\n"             Note: First arg in RCX
        "mov rdx, %2\n"             Note: Second arg in RDX
        "mov r8, %3\n"              Note: Third arg in R8
        "mov r9, %4\n"              Note: Fourth arg in R9
        "call %0\n"                 Note: Call function (Microsoft x64 ABI)
        :
        : "r"(function_ptr), "r"(rcx_arg), "r"(rdx_arg), "r"(r8_arg), "r"(r9_arg)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Note: =====================================================================
Note: VIRTUAL FUNCTION CALLS
Note: =====================================================================

Process called "call_virtual_method" that takes object_ptr as Pointer, vtable_offset as Integer:
    Inline Assembly:
        "mov rax, [%0]\n"           Note: Load vtable pointer
        "call [rax + %1]\n"         Note: Call virtual method
        :
        : "r"(object_ptr), "r"(vtable_offset)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "memory"
    End Assembly
End Process

Process called "call_interface_method" that takes interface_ptr as Pointer, method_index as Integer:
    Inline Assembly:
        "mov rax, [%0]\n"           Note: Load interface pointer
        "mov rax, [rax]\n"          Note: Load vtable
        "lea rbx, [%1 * 8]\n"       Note: Calculate method offset
        "call [rax + rbx]\n"        Note: Call interface method
        :
        : "r"(interface_ptr), "r"(method_index)
        : "rax", "rbx", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "memory"
    End Assembly
End Process

Process called "call_dynamic_dispatch" that takes dispatch_table as Pointer, type_id as Integer, method_id as Integer:
    Inline Assembly:
        "mov rax, %0\n"             Note: Load dispatch table
        "lea rbx, [%1 * 8]\n"       Note: Calculate type offset
        "mov rax, [rax + rbx]\n"    Note: Load type table
        "lea rbx, [%2 * 8]\n"       Note: Calculate method offset
        "call [rax + rbx]\n"        Note: Call method
        :
        : "r"(dispatch_table), "r"(type_id), "r"(method_id)
        : "rax", "rbx", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "memory"
    End Assembly
End Process

Note: =====================================================================
Note: FUNCTION POINTER CALLS
Note: =====================================================================

Process called "call_function_pointer" that takes func_ptr as Pointer:
    Inline Assembly:
        "call %0\n"                 Note: Call through function pointer
        :
        : "r"(func_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_member_function_ptr" that takes object_ptr as Pointer, member_func_ptr as Pointer:
    Inline Assembly:
        "mov rcx, %0\n"             Note: Load object pointer
        "call %1\n"                 Note: Call member function
        :
        : "r"(object_ptr), "r"(member_func_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_callback" that takes callback_ptr as Pointer, context as Pointer:
    Inline Assembly:
        "mov rdi, %1\n"             Note: Load context
        "call %0\n"                 Note: Call callback
        :
        : "r"(callback_ptr), "r"(context)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_thunk" that takes thunk_ptr as Pointer:
    Inline Assembly:
        "call %0\n"                 Note: Call thunk
        :
        : "r"(thunk_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Note: =====================================================================
Note: COROUTINE/GENERATOR CALLS
Note: =====================================================================

Process called "call_coroutine" that takes coroutine_ptr as Pointer, context as Pointer:
    Inline Assembly:
        "mov rdi, %1\n"             Note: Load context
        "call %0\n"                 Note: Call coroutine
        :
        : "r"(coroutine_ptr), "r"(context)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_generator_next" that takes generator_ptr as Pointer:
    Inline Assembly:
        "call %0\n"                 Note: Call generator next
        :
        : "r"(generator_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_yield_point" that takes yield_func as Pointer, value as Integer:
    Inline Assembly:
        "mov rdi, %1\n"             Note: Load yield value
        "call %0\n"                 Note: Call yield function
        :
        : "r"(yield_func), "r"(value)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_async_continuation" that takes continuation_ptr as Pointer, result as Integer:
    Inline Assembly:
        "mov rdi, %1\n"             Note: Load result
        "call %0\n"                 Note: Call continuation
        :
        : "r"(continuation_ptr), "r"(result)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Note: =====================================================================
Note: EXCEPTION HANDLING CALLS
Note: =====================================================================

Process called "call_exception_handler" that takes handler_ptr as Pointer, exception_ptr as Pointer:
    Inline Assembly:
        "mov rdi, %1\n"             Note: Load exception pointer
        "call %0\n"                 Note: Call exception handler
        :
        : "r"(handler_ptr), "r"(exception_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_finally_block" that takes finally_ptr as Pointer:
    Inline Assembly:
        "call %0\n"                 Note: Call finally block
        :
        : "r"(finally_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_destructor" that takes destructor_ptr as Pointer, object_ptr as Pointer:
    Inline Assembly:
        "mov rdi, %1\n"             Note: Load object pointer
        "call %0\n"                 Note: Call destructor
        :
        : "r"(destructor_ptr), "r"(object_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_cleanup_function" that takes cleanup_ptr as Pointer:
    Inline Assembly:
        "call %0\n"                 Note: Call cleanup function
        :
        : "r"(cleanup_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Note: =====================================================================
Note: SYSTEM/OS CALLS
Note: =====================================================================

Process called "call_syscall" that takes syscall_number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer:
    Inline Assembly:
        "mov rax, %0\n"             Note: System call number
        "mov rdi, %1\n"             Note: First argument
        "mov rsi, %2\n"             Note: Second argument
        "mov rdx, %3\n"             Note: Third argument
        "syscall\n"                 Note: Make system call
        :
        : "r"(syscall_number), "r"(arg1), "r"(arg2), "r"(arg3)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r11", "memory"
    End Assembly
End Process

Process called "call_interrupt" that takes interrupt_number as Integer:
    Inline Assembly:
        "int %0\n"                  Note: Software interrupt
        :
        : "i"(interrupt_number)
        : "rax", "rcx", "rdx", "rsi", "rdi", "memory"
    End Assembly
End Process

Process called "call_system_function" that takes func_ptr as Pointer:
    Inline Assembly:
        "call %0\n"                 Note: Call system function
        :
        : "r"(func_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Note: =====================================================================
Note: PROFILING/INSTRUMENTATION CALLS
Note: =====================================================================

Process called "call_with_profiling" that takes function_ptr as Pointer, profiler_enter as Pointer, profiler_exit as Pointer:
    Inline Assembly:
        "call %1\n"                 Note: Call profiler enter
        "call %0\n"                 Note: Call function
        "call %2\n"                 Note: Call profiler exit
        :
        : "r"(function_ptr), "r"(profiler_enter), "r"(profiler_exit)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_traced" that takes function_ptr as Pointer, trace_enter as Pointer, trace_exit as Pointer:
    Inline Assembly:
        "call %1\n"                 Note: Call trace enter
        "call %0\n"                 Note: Call function
        "call %2\n"                 Note: Call trace exit
        :
        : "r"(function_ptr), "r"(trace_enter), "r"(trace_exit)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_instrumented" that takes function_ptr as Pointer, instrument_ptr as Pointer:
    Inline Assembly:
        "call %1\n"                 Note: Call instrument function
        "call %0\n"                 Note: Call function
        :
        : "r"(function_ptr), "r"(instrument_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Note: =====================================================================
Note: OPTIMIZED CALLS
Note: =====================================================================

Process called "call_leaf_function" that takes function_ptr as Pointer:
    Note: Call function that doesn't call other functions
    Inline Assembly:
        "call %0\n"                 Note: Call leaf function
        :
        : "r"(function_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_inline_candidate" that takes function_ptr as Pointer:
    Note: Call function that's a candidate for inlining
    Inline Assembly:
        "call %0\n"                 Note: Call inline candidate
        :
        : "r"(function_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_hot_function" that takes function_ptr as Pointer:
    Note: Call frequently executed function
    Inline Assembly:
        "call %0\n"                 Note: Call hot function
        :
        : "r"(function_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_cold_function" that takes function_ptr as Pointer:
    Note: Call infrequently executed function
    Inline Assembly:
        "call %0\n"                 Note: Call cold function
        :
        : "r"(function_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Note: =====================================================================
Note: TAIL CALL OPTIMIZATION
Note: =====================================================================

Process called "tail_call" that takes function_ptr as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Tail call optimization
        :
        : "r"(function_ptr)
        :
    End Assembly
End Process

Process called "tail_call_with_cleanup" that takes function_ptr as Pointer, cleanup_bytes as Integer:
    Inline Assembly:
        "add rsp, %1\n"             Note: Clean up stack
        "jmp %0\n"                  Note: Tail call optimization
        :
        : "r"(function_ptr), "r"(cleanup_bytes)
        : "rsp"
    End Assembly
End Process

Process called "sibling_call" that takes function_ptr as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Sibling call optimization
        :
        : "r"(function_ptr)
        :
    End Assembly
End Process

Note: =====================================================================
Note: STACK UNWINDING CALLS
Note: =====================================================================

Process called "call_unwind_handler" that takes unwind_ptr as Pointer, frame_ptr as Pointer:
    Inline Assembly:
        "mov rdi, %1\n"             Note: Load frame pointer
        "call %0\n"                 Note: Call unwind handler
        :
        : "r"(unwind_ptr), "r"(frame_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_stack_walker" that takes walker_ptr as Pointer:
    Inline Assembly:
        "call %0\n"                 Note: Call stack walker
        :
        : "r"(walker_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_frame_destructor" that takes destructor_ptr as Pointer, frame_ptr as Pointer:
    Inline Assembly:
        "mov rdi, %1\n"             Note: Load frame pointer
        "call %0\n"                 Note: Call frame destructor
        :
        : "r"(destructor_ptr), "r"(frame_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Note: =====================================================================
Note: DEBUGGING CALLS
Note: =====================================================================

Process called "call_debug_hook" that takes debug_ptr as Pointer, debug_info as Pointer:
    Inline Assembly:
        "mov rdi, %1\n"             Note: Load debug info
        "call %0\n"                 Note: Call debug hook
        :
        : "r"(debug_ptr), "r"(debug_info)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_breakpoint_handler" that takes handler_ptr as Pointer:
    Inline Assembly:
        "int3\n"                    Note: Breakpoint trap
        "call %0\n"                 Note: Call handler
        :
        : "r"(handler_ptr)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "call_assert_handler" that takes assert_ptr as Pointer, condition as Boolean:
    Inline Assembly:
        "test %1, %1\n"             Note: Test condition
        "jnz 1f\n"                  Note: Skip if true
        "call %0\n"                 Note: Call assert handler
        "1:\n"                      Note: Skip label
        :
        : "r"(assert_ptr), "r"(condition)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "flags"
    End Assembly
End Process