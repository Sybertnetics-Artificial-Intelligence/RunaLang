Note:
control_flow/jump.runa - Zero-Dependency Unconditional Jump Primitives

This module provides fundamental unconditional jump operations using direct CPU instructions.
These primitives have ZERO dependencies and compile to efficient jump instructions.

@Reasoning:
- Provides low-level unconditional control flow for compiler code generation
- All operations use inline assembly for true self-hosting capabilities
- No external dependencies - we generate the machine code directly
- Essential for implementing goto, break, continue, and function calls

@Implementation:
- Inline Assembly statements using unconditional jump instructions
- Direct address targeting for absolute and relative jumps
- Support for both near and far jumps
- Zero-cost abstraction through compile-time optimization

@Performance_Hints:
- Each jump maps to single unconditional jump instruction
- No branch prediction overhead for unconditional jumps
- Use relative jumps for better code density
- Prefer direct jumps over computed jumps for better performance
:End Note

Note: =====================================================================
Note: BASIC UNCONDITIONAL JUMPS
Note: =====================================================================

Process called "jump_absolute" that takes target_address as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Absolute jump to address
        :
        : "r"(target_address)
        :
    End Assembly
End Process

Process called "jump_relative" that takes offset as Integer:
    Inline Assembly:
        "jmp %0\n"                  Note: Relative jump with offset
        :
        : "r"(offset)
        :
    End Assembly
End Process

Process called "jump_short" that takes offset as Integer8:
    Inline Assembly:
        "jmp short %0\n"            Note: Short jump (-128 to +127 bytes)
        :
        : "r"(offset)
        :
    End Assembly
End Process

Process called "jump_near" that takes target_address as Pointer:
    Inline Assembly:
        "jmp near ptr %0\n"         Note: Near jump within segment
        :
        : "r"(target_address)
        :
    End Assembly
End Process

Process called "jump_far" that takes segment as Integer16, offset as Pointer:
    Inline Assembly:
        "jmp far ptr %0:%1\n"       Note: Far jump with segment:offset
        :
        : "r"(segment), "r"(offset)
        :
    End Assembly
End Process

Note: =====================================================================
Note: COMPUTED/INDIRECT JUMPS
Note: =====================================================================

Process called "jump_indirect" that takes target_ptr as Pointer:
    Inline Assembly:
        "jmp [%0]\n"                Note: Indirect jump through pointer
        :
        : "r"(target_ptr)
        : "memory"
    End Assembly
End Process

Process called "jump_register" that takes target_reg as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to register value
        :
        : "r"(target_reg)
        :
    End Assembly
End Process

Process called "jump_computed" that takes base as Pointer, index as Integer, scale as Integer:
    Inline Assembly:
        "lea rax, [%1 * %2]\n"      Note: Calculate offset
        "jmp [%0 + rax]\n"          Note: Jump to computed address
        :
        : "r"(base), "r"(index), "i"(scale)
        : "rax", "memory"
    End Assembly
End Process

Process called "jump_table" that takes table_base as Pointer, index as Integer:
    Inline Assembly:
        "lea rax, [%1 * 8]\n"       Note: Calculate table offset
        "jmp [%0 + rax]\n"          Note: Jump via table entry
        :
        : "r"(table_base), "r"(index)
        : "rax", "memory"
    End Assembly
End Process

Note: =====================================================================
Note: FUNCTION DISPATCH JUMPS
Note: =====================================================================

Process called "jump_to_function" that takes function_ptr as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to function entry
        :
        : "r"(function_ptr)
        :
    End Assembly
End Process

Process called "tail_call_jump" that takes function_ptr as Pointer:
    Note: Tail call optimization - jump instead of call+ret
    Inline Assembly:
        "jmp %0\n"                  Note: Tail call optimization jump
        :
        : "r"(function_ptr)
        :
    End Assembly
End Process

Process called "virtual_function_jump" that takes object_ptr as Pointer, vtable_offset as Integer:
    Inline Assembly:
        "mov rax, [%0]\n"           Note: Load vtable pointer
        "jmp [rax + %1]\n"          Note: Jump to virtual method
        :
        : "r"(object_ptr), "r"(vtable_offset)
        : "rax", "memory"
    End Assembly
End Process

Process called "interface_dispatch_jump" that takes interface_ptr as Pointer, method_index as Integer:
    Inline Assembly:
        "mov rax, [%0]\n"           Note: Load interface pointer
        "mov rax, [rax]\n"          Note: Load vtable
        "lea rbx, [%1 * 8]\n"       Note: Calculate method offset
        "jmp [rax + rbx]\n"         Note: Jump to interface method
        :
        : "r"(interface_ptr), "r"(method_index)
        : "rax", "rbx", "memory"
    End Assembly
End Process

Note: =====================================================================
Note: LOOP CONTROL JUMPS
Note: =====================================================================

Process called "jump_loop_start" that takes loop_header as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to loop header
        :
        : "r"(loop_header)
        :
    End Assembly
End Process

Process called "jump_loop_continue" that takes continue_point as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to continue point
        :
        : "r"(continue_point)
        :
    End Assembly
End Process

Process called "jump_loop_break" that takes exit_point as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to loop exit
        :
        : "r"(exit_point)
        :
    End Assembly
End Process

Process called "jump_while_condition" that takes condition_check as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to condition check
        :
        : "r"(condition_check)
        :
    End Assembly
End Process

Note: =====================================================================
Note: EXCEPTION/ERROR HANDLING JUMPS
Note: =====================================================================

Process called "jump_to_exception_handler" that takes handler_address as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to exception handler
        :
        : "r"(handler_address)
        :
    End Assembly
End Process

Process called "jump_to_finally_block" that takes finally_address as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to finally block
        :
        : "r"(finally_address)
        :
    End Assembly
End Process

Process called "jump_unwind_stack" that takes unwind_address as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to unwind handler
        :
        : "r"(unwind_address)
        :
    End Assembly
End Process

Process called "jump_panic_handler" that takes panic_handler as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to panic handler
        :
        : "r"(panic_handler)
        :
    End Assembly
End Process

Note: =====================================================================
Note: SWITCH/CASE JUMPS
Note: =====================================================================

Process called "jump_switch_table" that takes value as Integer, jump_table as Pointer, default_case as Pointer:
    Inline Assembly:
        "cmp %0, 0\n"               Note: Check lower bound
        "jl %2\n"                   Note: Jump to default if below
        "cmp %0, 255\n"             Note: Check upper bound
        "jg %2\n"                   Note: Jump to default if above
        "lea rax, [%0 * 8]\n"       Note: Calculate table offset
        "jmp [%1 + rax]\n"          Note: Jump via table
        :
        : "r"(value), "r"(jump_table), "r"(default_case)
        : "rax", "flags", "memory"
    End Assembly
End Process

Process called "jump_case" that takes case_target as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to case target
        :
        : "r"(case_target)
        :
    End Assembly
End Process

Process called "jump_default_case" that takes default_target as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to default case
        :
        : "r"(default_target)
        :
    End Assembly
End Process

Process called "jump_switch_end" that takes end_address as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to switch end
        :
        : "r"(end_address)
        :
    End Assembly
End Process

Note: =====================================================================
Note: COROUTINE/FIBER JUMPS
Note: =====================================================================

Process called "jump_yield_point" that takes yield_address as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to yield point
        :
        : "r"(yield_address)
        :
    End Assembly
End Process

Process called "jump_resume_point" that takes resume_address as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to resume point
        :
        : "r"(resume_address)
        :
    End Assembly
End Process

Process called "jump_coroutine_start" that takes coroutine_entry as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to coroutine entry
        :
        : "r"(coroutine_entry)
        :
    End Assembly
End Process

Process called "jump_fiber_switch" that takes fiber_context as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Switch to fiber context
        :
        : "r"(fiber_context)
        :
    End Assembly
End Process

Note: =====================================================================
Note: OPTIMIZATION JUMPS
Note: =====================================================================

Process called "jump_hot_path" that takes hot_code as Pointer:
    Note: Jump to frequently executed code path
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to hot code path
        :
        : "r"(hot_code)
        :
    End Assembly
End Process

Process called "jump_cold_path" that takes cold_code as Pointer:
    Note: Jump to infrequently executed code path
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to cold code path
        :
        : "r"(cold_code)
        :
    End Assembly
End Process

Process called "jump_specialized_version" that takes specialized_func as Pointer:
    Note: Jump to type-specialized function version
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to specialized version
        :
        : "r"(specialized_func)
        :
    End Assembly
End Process

Process called "jump_optimized_path" that takes optimized_code as Pointer:
    Note: Jump to optimized code path
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to optimized path
        :
        : "r"(optimized_code)
        :
    End Assembly
End Process

Note: =====================================================================
Note: ALIGNMENT AND PERFORMANCE JUMPS
Note: =====================================================================

Process called "jump_aligned" that takes target_address as Pointer:
    Note: Jump to aligned target for better performance
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to aligned address
        :
        : "r"(target_address)
        :
    End Assembly
End Process

Process called "jump_with_nop_padding" that takes target_address as Pointer:
    Note: Jump with NOPs for alignment
    Inline Assembly:
        "nop\n"                     Note: Padding for alignment
        "nop\n"                     Note: Padding for alignment
        "jmp %0\n"                  Note: Jump to target
        :
        : "r"(target_address)
        :
    End Assembly
End Process

Process called "jump_prefetch_target" that takes target_address as Pointer:
    Note: Jump with prefetch hint for target code
    Inline Assembly:
        "prefetcht0 [%0]\n"         Note: Prefetch target code
        "jmp %0\n"                  Note: Jump to target
        :
        : "r"(target_address)
        : "memory"
    End Assembly
End Process

Note: =====================================================================
Note: ATOMIC/SYNCHRONIZATION JUMPS
Note: =====================================================================

Process called "jump_after_barrier" that takes barrier_point as Pointer:
    Inline Assembly:
        "mfence\n"                  Note: Memory fence barrier
        "jmp %0\n"                  Note: Jump after barrier
        :
        : "r"(barrier_point)
        : "memory"
    End Assembly
End Process

Process called "jump_after_sync" that takes sync_point as Pointer:
    Inline Assembly:
        "sfence\n"                  Note: Store fence
        "jmp %0\n"                  Note: Jump after sync
        :
        : "r"(sync_point)
        : "memory"
    End Assembly
End Process

Process called "jump_critical_section" that takes critical_code as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to critical section
        :
        : "r"(critical_code)
        :
    End Assembly
End Process

Note: =====================================================================
Note: DEBUGGING/INSTRUMENTATION JUMPS
Note: =====================================================================

Process called "jump_with_breakpoint" that takes target_address as Pointer:
    Inline Assembly:
        "int3\n"                    Note: Breakpoint trap
        "jmp %0\n"                  Note: Jump to target
        :
        : "r"(target_address)
        :
    End Assembly
End Process

Process called "jump_with_trace" that takes trace_handler as Pointer, target_address as Pointer:
    Inline Assembly:
        "call %0\n"                 Note: Call trace handler
        "jmp %1\n"                  Note: Jump to target
        :
        : "r"(trace_handler), "r"(target_address)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "jump_profile_point" that takes profiler as Pointer, target_address as Pointer:
    Inline Assembly:
        "call %0\n"                 Note: Call profiler
        "jmp %1\n"                  Note: Jump to target
        :
        : "r"(profiler), "r"(target_address)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Note: =====================================================================
Note: SECURITY JUMPS
Note: =====================================================================

Process called "jump_safe_target" that takes validated_target as Pointer:
    Note: Jump to validated safe target
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to validated target
        :
        : "r"(validated_target)
        :
    End Assembly
End Process

Process called "jump_after_check" that takes security_check as Pointer, target as Pointer:
    Inline Assembly:
        "call %0\n"                 Note: Call security check
        "jmp %1\n"                  Note: Jump to target
        :
        : "r"(security_check), "r"(target)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"
    End Assembly
End Process

Process called "jump_sandbox_boundary" that takes sandbox_entry as Pointer:
    Inline Assembly:
        "jmp %0\n"                  Note: Jump to sandbox entry
        :
        : "r"(sandbox_entry)
        :
    End Assembly
End Process