Note:
compiler/frontend/primitives/types/validation.runa
Type Validation Primitives

This module provides fundamental type validation operations for all Runa primitive types.

Key features and capabilities:
- Type checking and validation for all primitive types
- Range validation for numeric types
- Format validation for strings and identifiers
- Constraint validation with custom rules
- Type compatibility checking
- Schema validation for structured data
- Performance-optimized validation routines
- Zero-allocation validation where possible
- Integration with compiler type system
- Comprehensive error reporting
- Thread-safe validation operations
- Locale-aware validation rules
:End Note

Note: Using only core primitives - no stdlib imports

Note: Range Validation for Integer Types

Process called "validate_i8_range" that takes value as Integer64 returns Boolean:
    If value < -128:
        Return false
    End If
    If value > 127:
        Return false
    End If
    Return true
End Process

Process called "validate_i16_range" that takes value as Integer64 returns Boolean:
    If value < -32768:
        Return false
    End If
    If value > 32767:
        Return false
    End If
    Return true
End Process

Process called "validate_i32_range" that takes value as Integer64 returns Boolean:
    If value < -2147483648:
        Return false
    End If
    If value > 2147483647:
        Return false
    End If
    Return true
End Process

Process called "validate_i64_range" that takes value as Integer64 returns Boolean:
    Return true
End Process

Note: Range Validation for Unsigned Types

Process called "validate_u8_range" that takes value as Unsigned64 returns Boolean:
    If value > 255:
        Return false
    End If
    Return true
End Process

Process called "validate_u16_range" that takes value as Unsigned64 returns Boolean:
    If value > 65535:
        Return false
    End If
    Return true
End Process

Process called "validate_u32_range" that takes value as Unsigned64 returns Boolean:
    If value > 4294967295:
        Return false
    End If
    Return true
End Process

Process called "validate_u64_range" that takes value as Unsigned64 returns Boolean:
    Return true
End Process

Note: Float Validation - checking for special values

Process called "validate_f32_finite" that takes value as Float32 returns Boolean:
    Let is_nan be check_f32_nan(value)
    If is_nan:
        Return false
    End If
    Let is_infinite be check_f32_infinite(value)
    If is_infinite:
        Return false
    End If
    Return true
End Process

Process called "validate_f64_finite" that takes value as Float64 returns Boolean:
    Let is_nan be check_f64_nan(value)
    If is_nan:
        Return false
    End If
    Let is_infinite be check_f64_infinite(value)
    If is_infinite:
        Return false
    End If
    Return true
End Process

Note: Boolean Validation

Process called "validate_boolean" that takes value as Boolean returns Boolean:
    Return true
End Process

Note: Pointer Validation - checking for null and alignment

Process called "validate_pointer_not_null" that takes ptr as Pointer returns Boolean:
    Let address be convert_pointer_to_u64(ptr)
    If address is 0:
        Return false
    End If
    Return true
End Process

Process called "validate_pointer_aligned" that takes ptr as Pointer, alignment as Unsigned64 returns Boolean:
    Let address be convert_pointer_to_u64(ptr)
    Let remainder be mod_u64(address, alignment)
    If remainder is 0:
        Return true
    End If
    Return false
End Process

Note: Value Range Validation with Min/Max

Process called "validate_i8_in_range" that takes value as Integer8, min as Integer8, max as Integer8 returns Boolean:
    If value < min:
        Return false
    End If
    If value > max:
        Return false
    End If
    Return true
End Process

Process called "validate_i16_in_range" that takes value as Integer16, min as Integer16, max as Integer16 returns Boolean:
    If value < min:
        Return false
    End If
    If value > max:
        Return false
    End If
    Return true
End Process

Process called "validate_i32_in_range" that takes value as Integer32, min as Integer32, max as Integer32 returns Boolean:
    If value < min:
        Return false
    End If
    If value > max:
        Return false
    End If
    Return true
End Process

Process called "validate_i64_in_range" that takes value as Integer64, min as Integer64, max as Integer64 returns Boolean:
    If value < min:
        Return false
    End If
    If value > max:
        Return false
    End If
    Return true
End Process

Process called "validate_u8_in_range" that takes value as Unsigned8, min as Unsigned8, max as Unsigned8 returns Boolean:
    If value < min:
        Return false
    End If
    If value > max:
        Return false
    End If
    Return true
End Process

Process called "validate_u16_in_range" that takes value as Unsigned16, min as Unsigned16, max as Unsigned16 returns Boolean:
    If value < min:
        Return false
    End If
    If value > max:
        Return false
    End If
    Return true
End Process

Process called "validate_u32_in_range" that takes value as Unsigned32, min as Unsigned32, max as Unsigned32 returns Boolean:
    If value < min:
        Return false
    End If
    If value > max:
        Return false
    End If
    Return true
End Process

Process called "validate_u64_in_range" that takes value as Unsigned64, min as Unsigned64, max as Unsigned64 returns Boolean:
    If value < min:
        Return false
    End If
    If value > max:
        Return false
    End If
    Return true
End Process

Note: Float Range Validation

Process called "validate_f32_in_range" that takes value as Float32, min as Float32, max as Float32 returns Boolean:
    If value < min:
        Return false
    End If
    If value > max:
        Return false
    End If
    Return true
End Process

Process called "validate_f64_in_range" that takes value as Float64, min as Float64, max as Float64 returns Boolean:
    If value < min:
        Return false
    End If
    If value > max:
        Return false
    End If
    Return true
End Process

Note: Power of Two Validation

Process called "validate_power_of_two_u8" that takes value as Unsigned8 returns Boolean:
    If value is 0:
        Return false
    End If
    Let mask be sub_u8(value, 1)
    Let result be and_u8(value, mask)
    If result is 0:
        Return true
    End If
    Return false
End Process

Process called "validate_power_of_two_u16" that takes value as Unsigned16 returns Boolean:
    If value is 0:
        Return false
    End If
    Let mask be sub_u16(value, 1)
    Let result be and_u16(value, mask)
    If result is 0:
        Return true
    End If
    Return false
End Process

Process called "validate_power_of_two_u32" that takes value as Unsigned32 returns Boolean:
    If value is 0:
        Return false
    End If
    Let mask be sub_u32(value, 1)
    Let result be and_u32(value, mask)
    If result is 0:
        Return true
    End If
    Return false
End Process

Process called "validate_power_of_two_u64" that takes value as Unsigned64 returns Boolean:
    If value is 0:
        Return false
    End If
    Let mask be sub_u64(value, 1)
    Let result be and_u64(value, mask)
    If result is 0:
        Return true
    End If
    Return false
End Process

Note: Assembly helpers for floating point validation

Process called "check_f32_nan" that takes value as Float32 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomiss %1, %1\n"          Note: Compare float with itself
        "setp %0\n"                 Note: Set result if parity flag (NaN)
        : "=r"(result)
        : "x"(value)
        : "flags"
    End Assembly
    Return result
End Process

Process called "check_f64_nan" that takes value as Float64 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %1\n"          Note: Compare double with itself
        "setp %0\n"                 Note: Set result if parity flag (NaN)
        : "=r"(result)
        : "x"(value)
        : "flags"
    End Assembly
    Return result
End Process

Process called "check_f32_infinite" that takes value as Float32 returns Boolean:
    Let bits be f32_to_bits(value)
    Let exponent_mask be 2139095040
    Let mantissa_mask be 8388607
    Let exponent be and_u32(bits, exponent_mask)
    Let mantissa be and_u32(bits, mantissa_mask)
    If exponent is exponent_mask:
        If mantissa is 0:
            Return true
        End If
    End If
    Return false
End Process

Process called "check_f64_infinite" that takes value as Float64 returns Boolean:
    Let bits be f64_to_bits(value)
    Let exponent_mask be 9218868437227405312
    Let mantissa_mask be 4503599627370495
    Let exponent be and_u64(bits, exponent_mask)
    Let mantissa be and_u64(bits, mantissa_mask)
    If exponent is exponent_mask:
        If mantissa is 0:
            Return true
        End If
    End If
    Return false
End Process

Note: Low-level float bit manipulation helpers - need Assembly for direct register access

Process called "f32_to_bits" that takes value as Float32 returns Unsigned32:
    Let result be 0
    Inline Assembly:
        "movd %0, %1\n"             Note: Move float bits to integer register
        : "=r"(result)
        : "x"(value)
        :
    End Assembly
    Return result
End Process

Process called "f64_to_bits" that takes value as Float64 returns Unsigned64:
    Let result be 0
    Inline Assembly:
        "movq %0, %1\n"             Note: Move double bits to integer register
        : "=r"(result)
        : "x"(value)
        :
    End Assembly
    Return result
End Process
