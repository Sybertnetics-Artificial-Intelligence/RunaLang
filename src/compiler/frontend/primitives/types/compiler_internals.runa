Note:
runa/src/compiler/backend/syscalls/compiler_internals.runa
Compiler Internal Data Structures

This module defines minimal data structures for the compiler's internal use.
These structures do NOT depend on the standard library and use only primitive types.
They provide basic functionality needed by the compiler and runtime.

IMPORTANT: These are NOT part of the language specification.
They are implementation details of the compiler.
User code should use the standard library versions instead.
:End Note

Note: =====================================================================
Note: INTERNAL ARRAY STRUCTURE
Note: =====================================================================

Type called "InternalArray":
    data_ptr as Integer      Note: Pointer to data
    length as Integer         Note: Current number of elements
    capacity as Integer       Note: Allocated capacity
End Type

Process called "create_internal_array" that takes initial_capacity as Integer returns InternalArray:
    @Reasoning {
        Creates a new internal array with given capacity.
        Uses raw memory allocation.
    }
    @Implementation {
        Allocates memory and initializes structure.
        Capacity must be positive.
    }
    @End Reasoning
    @End Implementation
    
    Let arr be InternalArray()
    Set arr.capacity to initial_capacity
    Set arr.length to 0
    Set arr.data_ptr to allocate_raw_memory(initial_capacity times 8)  Note: 8 bytes per element
    Return arr
End Process

Process called "internal_array_add" that takes arr as InternalArray, value as Integer returns Nothing:
    @Reasoning {
        Adds an element to the internal array.
        Grows array if needed.
    }
    @Implementation {
        Checks capacity and reallocates if necessary.
        Uses doubling strategy for growth.
    }
    @End Reasoning
    @End Implementation
    
    If arr.length equal to arr.capacity:
        Note: Need to grow array
        Let new_capacity be arr.capacity times 2
        Let new_ptr be allocate_raw_memory(new_capacity times 8)
        
        Note: Copy existing data
        copy_memory(arr.data_ptr, new_ptr, arr.length times 8)
        
        Note: Free old memory
        free_raw_memory(arr.data_ptr, arr.capacity times 8)
        
        Set arr.data_ptr to new_ptr
        Set arr.capacity to new_capacity
    End If
    
    Note: Add new element
    write_integer_at(arr.data_ptr, arr.length times 8, value)
    Set arr.length to arr.length plus 1
End Process

Process called "internal_array_get" that takes arr as InternalArray, index as Integer returns Integer:
    @Reasoning {
        Gets element at given index.
        No bounds checking for performance.
    }
    @Implementation {
        Direct memory read at calculated offset.
    }
    @End Reasoning
    @End Implementation
    
    Return read_integer_at(arr.data_ptr, index times 8)
End Process

Process called "internal_array_set" that takes arr as InternalArray, index as Integer, value as Integer returns Nothing:
    @Reasoning {
        Sets element at given index.
        No bounds checking for performance.
    }
    @Implementation {
        Direct memory write at calculated offset.
    }
    @End Reasoning
    @End Implementation
    
    write_integer_at(arr.data_ptr, index times 8, value)
End Process

Process called "free_internal_array" that takes arr as InternalArray returns Nothing:
    @Reasoning {
        Frees memory used by internal array.
        Must be called to prevent memory leaks.
    }
    @Implementation {
        Frees the data buffer.
    }
    @End Reasoning
    @End Implementation
    
    free_raw_memory(arr.data_ptr, arr.capacity times 8)
    Set arr.data_ptr to 0
    Set arr.length to 0
    Set arr.capacity to 0
End Process

Note: =====================================================================
Note: INTERNAL MAP STRUCTURE (Simple Hash Table)
Note: =====================================================================

Type called "InternalMapEntry":
    key as String
    value as Integer
    next_ptr as Integer       Note: Pointer to next entry (for chaining)
    is_used as Boolean
End Type

Type called "InternalMap":
    buckets as InternalArray  Note: Array of entry pointers
    size as Integer           Note: Number of entries
    bucket_count as Integer   Note: Number of buckets
End Type

Process called "create_internal_map" that takes initial_buckets as Integer returns InternalMap:
    @Reasoning {
        Creates a new internal map with given bucket count.
        Uses simple chaining for collision resolution.
    }
    @Implementation {
        Initializes bucket array with null pointers.
    }
    @End Reasoning
    @End Implementation
    
    Let map be InternalMap()
    Set map.bucket_count to initial_buckets
    Set map.size to 0
    Set map.buckets to create_internal_array(initial_buckets)
    
    Note: Initialize all buckets to 0 (null)
    Let i be 0
    While i less than initial_buckets:
        internal_array_add(map.buckets, 0)
        Set i to i plus 1
    End While
    
    Return map
End Process

Process called "hash_string" that takes s as String returns Integer:
    @Reasoning {
        Simple hash function for strings.
        Uses djb2 algorithm.
    }
    @Implementation {
        Iterates through string characters computing hash.
    }
    @End Reasoning
    @End Implementation
    
    Let hash be 5381
    Let i be 0
    While i less than s.length():
        Let c be s.char_at(i) as Integer
        Set hash to ((hash shifted left by 5) plus hash) plus c
        Set i to i plus 1
    End While
    
    Note: Make positive
    If hash less than 0:
        Set hash to 0 minus hash
    End If
    
    Return hash
End Process

Process called "internal_map_set" that takes map as InternalMap, key as String, value as Integer returns Nothing:
    @Reasoning {
        Sets a key-value pair in the map.
        Handles collisions with chaining.
    }
    @Implementation {
        Finds bucket and adds/updates entry.
    }
    @End Reasoning
    @End Implementation
    
    Let hash be hash_string(key)
    Let bucket_index be hash modulo map.bucket_count
    Let entry_ptr be internal_array_get(map.buckets, bucket_index)
    
    Note: Search for existing key
    Let prev_ptr be 0
    While entry_ptr not equal to 0:
        Let entry be read_map_entry(entry_ptr)
        If entry.key equal to key:
            Note: Update existing entry
            Set entry.value to value
            write_map_entry(entry_ptr, entry)
            Return
        End If
        Set prev_ptr to entry_ptr
        Set entry_ptr to entry.next_ptr
    End While
    
    Note: Add new entry
    Let new_entry be InternalMapEntry()
    Set new_entry.key to key
    Set new_entry.value to value
    Set new_entry.next_ptr to 0
    Set new_entry.is_used to true
    
    Let new_ptr be allocate_map_entry(new_entry)
    
    If prev_ptr equal to 0:
        Note: First entry in bucket
        internal_array_set(map.buckets, bucket_index, new_ptr)
    Otherwise:
        Note: Add to chain
        Let prev_entry be read_map_entry(prev_ptr)
        Set prev_entry.next_ptr to new_ptr
        write_map_entry(prev_ptr, prev_entry)
    End If
    
    Set map.size to map.size plus 1
End Process

Process called "internal_map_get" that takes map as InternalMap, key as String returns Integer:
    @Reasoning {
        Gets value for given key.
        Returns -1 if not found.
    }
    @Implementation {
        Searches bucket chain for key.
    }
    @End Reasoning
    @End Implementation
    
    Let hash be hash_string(key)
    Let bucket_index be hash modulo map.bucket_count
    Let entry_ptr be internal_array_get(map.buckets, bucket_index)
    
    While entry_ptr not equal to 0:
        Let entry be read_map_entry(entry_ptr)
        If entry.key equal to key:
            Return entry.value
        End If
        Set entry_ptr to entry.next_ptr
    End While
    
    Return minus 1  Note: Not found
End Process

Process called "internal_map_contains" that takes map as InternalMap, key as String returns Boolean:
    @Reasoning {
        Checks if key exists in map.
    }
    @Implementation {
        Searches for key, returns true if found.
    }
    @End Reasoning
    @End Implementation
    
    Let result be internal_map_get(map, key)
    Return result not equal to minus 1
End Process

Note: =====================================================================
Note: INTERNAL STRING BUILDER
Note: =====================================================================

Type called "InternalStringBuilder":
    buffer as InternalArray   Note: Character buffer
    length as Integer         Note: Current string length
End Type

Process called "create_string_builder" returns InternalStringBuilder:
    @Reasoning {
        Creates a new string builder for efficient concatenation.
    }
    @Implementation {
        Initializes with reasonable default capacity.
    }
    @End Reasoning
    @End Implementation
    
    Let sb be InternalStringBuilder()
    sb.buffer = create_internal_array(64)  Note: Initial capacity
    Set sb.length to 0
    Return sb
End Process

Process called "string_builder_append" that takes sb as InternalStringBuilder, s as String returns Nothing:
    @Reasoning {
        Appends string to builder.
    }
    @Implementation {
        Copies string characters to buffer.
    }
    @End Reasoning
    @End Implementation
    
    Let i be 0
    While i less than s.length():
        Let c be s.char_at(i) as Integer
        internal_array_add(sb.buffer, c)
        Set i to i plus 1
    End While
    Set sb.length to sb.length plus s.length()
End Process

Process called "string_builder_to_string" that takes sb as InternalStringBuilder returns String:
    @Reasoning {
        Converts builder contents to string.
    }
    @Implementation {
        Builds string from character buffer.
    }
    @End Reasoning
    @End Implementation
    
    Let result be ""
    Let i be 0
    While i less than sb.length:
        Let c be internal_array_get(sb.buffer, i) as Character
        Set result to result + c
        Set i to i plus 1
    End While
    Return result
End Process

Note: =====================================================================
Note: RAW MEMORY OPERATIONS (Using Syscalls)
Note: =====================================================================

Import "compiler/backend/syscalls/platforms/linux_x64" as Linux

Process called "allocate_raw_memory" that takes size as Integer returns Integer:
    @Reasoning
    Allocates raw memory using mmap syscall.
    Returns pointer to allocated memory.
    @End Reasoning
    
    Note: mmap syscall parameters:
    Note: addr=0 (let kernel choose), length=size, prot=3 (READ|WRITE)
    Note: flags=0x22 (MAP_PRIVATE|MAP_ANONYMOUS), fd=-1, offset=0
    
    Let addr be 0
    Let prot be 3  Note: PROT_READ | PROT_WRITE
    Let flags be 34  Note: MAP_PRIVATE | MAP_ANONYMOUS  
    Let fd be -1
    Let offset be 0
    
    Note: Use inline assembly for mmap syscall (syscall number 9 on Linux x64)
    Let result as Integer
    Inline Assembly:
        "mov rax, 9\n"      Note: mmap syscall number
        "mov rdi, %1\n"     Note: addr
        "mov rsi, %2\n"     Note: length
        "mov rdx, %3\n"     Note: prot
        "mov r10, %4\n"     Note: flags
        "mov r8, %5\n"      Note: fd
        "mov r9, %6\n"      Note: offset
        "syscall\n"
        "mov %0, rax\n"     Note: Store result
        : "=r"(result)
        : "r"(addr), "r"(size), "r"(prot), "r"(flags), "r"(fd), "r"(offset)
        : "rax", "rcx", "r11", "memory"
    End Assembly
    
    Return result
End Process

Process called "free_raw_memory" that takes ptr as Integer, size as Integer returns Nothing:
    @Reasoning
    Frees memory using munmap syscall.
    @End Reasoning
    
    Note: munmap syscall (number 11 on Linux x64)
    Let result as Integer
    Inline Assembly:
        "mov rax, 11\n"     Note: munmap syscall number
        "mov rdi, %1\n"     Note: addr
        "mov rsi, %2\n"     Note: length
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(ptr), "r"(size)
        : "rax", "rcx", "r11", "memory"
    End Assembly
End Process

Process called "copy_memory" that takes src as Integer, dst as Integer, size as Integer returns Nothing:
    @Reasoning
    Copies memory using inline assembly.
    Uses rep movsb for efficient byte-by-byte copy.
    @End Reasoning
    
    Inline Assembly:
        "mov rsi, %0\n"     Note: Source
        "mov rdi, %1\n"     Note: Destination
        "mov rcx, %2\n"     Note: Count
        "cld\n"             Note: Clear direction flag
        "rep movsb\n"       Note: Copy bytes
        :
        : "r"(src), "r"(dst), "r"(size)
        : "rsi", "rdi", "rcx", "memory"
    End Assembly
End Process

Process called "write_integer_at" that takes ptr as Integer, offset as Integer, value as Integer returns Nothing:
    @Reasoning
    Writes 8-byte integer at memory location using inline assembly.
    @End Reasoning
    
    Let addr be ptr + offset
    Inline Assembly:
        "mov rax, %0\n"     Note: Value to write
        "mov rbx, %1\n"     Note: Address
        "mov [rbx], rax\n"  Note: Store value at address
        :
        : "r"(value), "r"(addr)
        : "rax", "rbx", "memory"
    End Assembly
End Process

Process called "read_integer_at" that takes ptr as Integer, offset as Integer returns Integer:
    @Reasoning
    Reads 8-byte integer from memory location using inline assembly.
    @End Reasoning
    
    Let addr be ptr + offset
    Let result as Integer
    Inline Assembly:
        "mov rbx, %1\n"     Note: Address
        "mov rax, [rbx]\n"  Note: Load value from address
        "mov %0, rax\n"     Note: Store result
        : "=r"(result)
        : "r"(addr)
        : "rax", "rbx", "memory"
    End Assembly
    Return result
End Process

Process called "allocate_map_entry" that takes entry as InternalMapEntry returns Integer:
    @Reasoning
    Allocates memory for map entry and copies data.
    @End Reasoning
    
    Note: Size of InternalMapEntry (estimate: 32 bytes)
    Let entry_size be 32
    Let ptr be allocate_raw_memory(entry_size)
    
    Note: Write fields manually
    Note: Assuming string is stored as pointer (8 bytes) for key
    write_integer_at(ptr, 0, string_to_ptr(entry.key))
    write_integer_at(ptr, 8, entry.value)
    write_integer_at(ptr, 16, entry.next_ptr)
    Let is_used_int be 0
    If entry.is_used:
        Set is_used_int to 1
    End If
    write_integer_at(ptr, 24, is_used_int)
    
    Return ptr
End Process

Process called "read_map_entry" that takes ptr as Integer returns InternalMapEntry:
    @Reasoning
    Reads map entry from memory.
    @End Reasoning
    
    Let entry be InternalMapEntry()
    Set entry.key to ptr_to_string(read_integer_at(ptr, 0))
    Set entry.value to read_integer_at(ptr, 8)
    Set entry.next_ptr to read_integer_at(ptr, 16)
    Let is_used_int be read_integer_at(ptr, 24)
    Set entry.is_used to (is_used_int not equals 0)
    
    Return entry
End Process

Process called "write_map_entry" that takes ptr as Integer, entry as InternalMapEntry returns Nothing:
    @Reasoning
    Writes map entry to memory.
    @End Reasoning
    
    write_integer_at(ptr, 0, string_to_ptr(entry.key))
    write_integer_at(ptr, 8, entry.value)
    write_integer_at(ptr, 16, entry.next_ptr)
    Let is_used_int be 0
    If entry.is_used:
        Set is_used_int to 1
    End If
    write_integer_at(ptr, 24, is_used_int)
End Process

Process called "string_to_ptr" that takes s as String returns Integer:
    @Reasoning
    Converts string to pointer by getting its memory address.
    Strings are primitives, so we can get their address directly.
    @End Reasoning
    
    Let ptr as Integer
    Inline Assembly:
        "lea rax, %1\n"     Note: Load effective address of string
        "mov %0, rax\n"     Note: Store pointer
        : "=r"(ptr)
        : "m"(s)
        : "rax"
    End Assembly
    Return ptr
End Process

Process called "ptr_to_string" that takes ptr as Integer returns String:
    @Reasoning
    Dereferences pointer to get string.
    This is a primitive operation that accesses string data.
    @End Reasoning
    
    Let result as String
    Inline Assembly:
        "mov rax, %1\n"     Note: Load pointer
        "mov %0, [rax]\n"   Note: Dereference to get string
        : "=m"(result)
        : "r"(ptr)
        : "rax", "memory"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: RESULT TYPE FOR ERROR HANDLING
Note: =====================================================================

Type called "InternalResult":
    is_success as Boolean
    value as Integer          Note: Success value or error code
    error_message as String   Note: Optional error description
End Type

Process called "success_result" that takes value as Integer returns InternalResult:
    @Reasoning {
        Creates a successful result.
    }
    @Implementation {
        Sets success flag and value.
    }
    @End Reasoning
    @End Implementation
    
    Let result be InternalResult()
    result.is_success = true
    result.value = value
    result.error_message = ""
    Return result
End Process

Process called "error_result" that takes code as Integer, message as String returns InternalResult:
    @Reasoning {
        Creates an error result.
    }
    @Implementation {
        Sets error flag, code, and message.
    }
    @End Reasoning
    @End Implementation
    
    Let result be InternalResult()
    result.is_success = false
    result.value = code
    result.error_message = message
    Return result
End Process

Note: =====================================================================
Note: ITERATION SUPPORT FOR INTERNAL STRUCTURES
Note: =====================================================================

Type called "InternalArrayIterator":
    array as InternalArray
    current_index as Integer
End Type

Process called "internal_array_iterator" that takes arr as InternalArray returns InternalArrayIterator:
    @Reasoning
    Creates an iterator for InternalArray.
    @End Reasoning
    
    Let iter be InternalArrayIterator()
    iter.array = arr
    iter.current_index = 0
    Return iter
End Process

Process called "internal_array_has_next" that takes iter as InternalArrayIterator returns Boolean:
    @Reasoning
    Checks if iterator has more elements.
    @End Reasoning
    
    Return iter.current_index < iter.array.length
End Process

Process called "internal_array_next" that takes iter as InternalArrayIterator returns Integer:
    @Reasoning
    Returns next element and advances iterator.
    @End Reasoning
    
    Let value be internal_array_get(iter.array, iter.current_index)
    iter.current_index = iter.current_index + 1
    Return value
End Process

Type called "InternalMapIterator":
    map as InternalMap
    current_bucket as Integer
    current_entry_ptr as Integer
End Type

Process called "internal_map_iterator" that takes map as InternalMap returns InternalMapIterator:
    @Reasoning
    Creates an iterator for InternalMap.
    @End Reasoning
    
    Let iter be InternalMapIterator()
    iter.map = map
    iter.current_bucket = 0
    iter.current_entry_ptr = 0
    
    Note: Find first non-empty bucket
    While iter.current_bucket < map.bucket_count:
        Let ptr be internal_array_get(map.buckets, iter.current_bucket)
        If ptr not equals 0:
            iter.current_entry_ptr = ptr
            Break
        End If
        iter.current_bucket = iter.current_bucket + 1
    End While
    
    Return iter
End Process

Process called "internal_map_has_next" that takes iter as InternalMapIterator returns Boolean:
    @Reasoning
    Checks if iterator has more entries.
    @End Reasoning
    
    Return iter.current_entry_ptr not equals 0
End Process

Type called "InternalMapKeyValue":
    key as String
    value as Integer
End Type

Process called "internal_map_next" that takes iter as InternalMapIterator returns InternalMapKeyValue:
    @Reasoning
    Returns next key-value pair and advances iterator.
    @End Reasoning
    
    Let entry be read_map_entry(iter.current_entry_ptr)
    Let kv be InternalMapKeyValue()
    kv.key = entry.key
    kv.value = entry.value
    
    Note: Advance to next entry
    If entry.next_ptr not equals 0:
        iter.current_entry_ptr = entry.next_ptr
    Otherwise:
        Note: Find next non-empty bucket
        iter.current_bucket = iter.current_bucket + 1
        iter.current_entry_ptr = 0
        
        While iter.current_bucket < iter.map.bucket_count:
            Let ptr be internal_array_get(iter.map.buckets, iter.current_bucket)
            If ptr not equals 0:
                iter.current_entry_ptr = ptr
                Break
            End If
            iter.current_bucket = iter.current_bucket + 1
        End While
    End If
    
    Return kv
End Process

Process called "internal_map_keys" that takes map as InternalMap returns InternalArray:
    @Reasoning
    Returns array of all keys in the map.
    @End Reasoning
    
    Let keys be create_internal_array(map.size)
    Let iter be internal_map_iterator(map)
    
    While internal_map_has_next(iter):
        Let kv be internal_map_next(iter)
        internal_array_add(keys, string_to_ptr(kv.key))
    End While
    
    Return keys
End Process

Process called "internal_map_values" that takes map as InternalMap returns InternalArray:
    @Reasoning
    Returns array of all values in the map.
    @End Reasoning
    
    Let values be create_internal_array(map.size)
    Let iter be internal_map_iterator(map)
    
    While internal_map_has_next(iter):
        Let kv be internal_map_next(iter)
        internal_array_add(values, kv.value)
    End While
    
    Return values
End Process