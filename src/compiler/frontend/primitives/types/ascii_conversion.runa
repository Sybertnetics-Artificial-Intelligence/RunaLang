Note:
compiler/frontend/primitives/types/ascii_conversion.runa
ASCII Character Conversion Utilities

This module provides ASCII conversion functions for the compiler's internal use.
It is self-contained with no dependencies on the standard library, ensuring
the compiler remains independent and stable.

@Reasoning
    The compiler needs ASCII conversion for various tasks like parsing string
    literals, generating output, and handling file I/O. Having this as a
    compiler-internal primitive ensures no external dependencies.
@End Reasoning

@Implementation
    - Complete ASCII table mapping (0-127)
    - Bidirectional conversion between bytes and characters
    - String/byte array conversion utilities
    - Validation for ASCII range
@End Implementation

@Performance_Hints
    - Direct lookup tables for O(1) character conversion
    - Minimal validation overhead for trusted compiler operations
    - Inline-friendly single-byte operations
@End Performance_Hints
:End Note

Note: Using only core primitives - no stdlib imports

Note: ASCII Range Validation

Process called "is_ascii" that takes byte as Unsigned8 returns Boolean:
    If byte > 127:
        Return false
    End If
    Return true
End Process

Process called "is_ascii_control" that takes byte as Unsigned8 returns Boolean:
    If byte < 32:
        Return true
    End If
    If byte is 127:
        Return true
    End If
    Return false
End Process

Process called "is_ascii_printable" that takes byte as Unsigned8 returns Boolean:
    If byte < 32:
        Return false
    End If
    If byte > 126:
        Return false
    End If
    Return true
End Process

Process called "is_ascii_whitespace" that takes byte as Unsigned8 returns Boolean:
    If byte is 9:
        Return true
    End If
    If byte is 10:
        Return true
    End If
    If byte is 11:
        Return true
    End If
    If byte is 12:
        Return true
    End If
    If byte is 13:
        Return true
    End If
    If byte is 32:
        Return true
    End If
    Return false
End Process

Note: ASCII Character Classification

Process called "is_ascii_digit" that takes byte as Unsigned8 returns Boolean:
    If byte < 48:
        Return false
    End If
    If byte > 57:
        Return false
    End If
    Return true
End Process

Process called "is_ascii_upper" that takes byte as Unsigned8 returns Boolean:
    If byte < 65:
        Return false
    End If
    If byte > 90:
        Return false
    End If
    Return true
End Process

Process called "is_ascii_lower" that takes byte as Unsigned8 returns Boolean:
    If byte < 97:
        Return false
    End If
    If byte > 122:
        Return false
    End If
    Return true
End Process

Process called "is_ascii_alpha" that takes byte as Unsigned8 returns Boolean:
    Let is_upper be is_ascii_upper(byte)
    If is_upper:
        Return true
    End If
    Let is_lower be is_ascii_lower(byte)
    Return is_lower
End Process

Process called "is_ascii_alphanumeric" that takes byte as Unsigned8 returns Boolean:
    Let is_alpha be is_ascii_alpha(byte)
    If is_alpha:
        Return true
    End If
    Let is_digit be is_ascii_digit(byte)
    Return is_digit
End Process

Note: ASCII Case Conversion

Process called "ascii_to_upper" that takes byte as Unsigned8 returns Unsigned8:
    Let is_lower be is_ascii_lower(byte)
    If is_lower:
        Let uppercase be sub_u8(byte, 32)
        Return uppercase
    End If
    Return byte
End Process

Process called "ascii_to_lower" that takes byte as Unsigned8 returns Unsigned8:
    Let is_upper be is_ascii_upper(byte)
    If is_upper:
        Let lowercase be add_u8(byte, 32)
        Return lowercase
    End If
    Return byte
End Process

Note: ASCII-to-Integer Conversion

Process called "ascii_digit_to_value" that takes byte as Unsigned8 returns Unsigned8:
    Let is_digit be is_ascii_digit(byte)
    If is_digit:
        Let value be sub_u8(byte, 48)
        Return value
    End If
    Return 255
End Process

Process called "value_to_ascii_digit" that takes value as Unsigned8 returns Unsigned8:
    If value > 9:
        Return 255
    End If
    Let ascii_byte be add_u8(value, 48)
    Return ascii_byte
End Process

Note: ASCII Hex Conversion

Process called "ascii_hex_to_value" that takes byte as Unsigned8 returns Unsigned8:
    Let is_digit be is_ascii_digit(byte)
    If is_digit:
        Let value be sub_u8(byte, 48)
        Return value
    End If
    Let is_upper_hex be validate_u8_in_range(byte, 65, 70)
    If is_upper_hex:
        Let temp be sub_u8(byte, 65)
        Let value be add_u8(temp, 10)
        Return value
    End If
    Let is_lower_hex be validate_u8_in_range(byte, 97, 102)
    If is_lower_hex:
        Let temp be sub_u8(byte, 97)
        Let value be add_u8(temp, 10)
        Return value
    End If
    Return 255
End Process

Process called "value_to_ascii_hex_upper" that takes value as Unsigned8 returns Unsigned8:
    If value > 15:
        Return 255
    End If
    If value < 10:
        Let ascii_byte be add_u8(value, 48)
        Return ascii_byte
    End If
    Let temp be sub_u8(value, 10)
    Let ascii_byte be add_u8(temp, 65)
    Return ascii_byte
End Process

Process called "value_to_ascii_hex_lower" that takes value as Unsigned8 returns Unsigned8:
    If value > 15:
        Return 255
    End If
    If value < 10:
        Let ascii_byte be add_u8(value, 48)
        Return ascii_byte
    End If
    Let temp be sub_u8(value, 10)
    Let ascii_byte be add_u8(temp, 97)
    Return ascii_byte
End Process

Note: ASCII String Utilities for Compiler

Process called "ascii_string_length" that takes ptr as Pointer returns Unsigned64:
    Let length be 0
    Let current_ptr be ptr
    While true:
        Let byte be load_u8(current_ptr)
        If byte is 0:
            Return length
        End If
        Let length be add_u64(length, 1)
        Let current_ptr be pointer_offset(current_ptr, 1)
    End While
End Process

Process called "ascii_strings_equal" that takes ptr1 as Pointer, ptr2 as Pointer, length as Unsigned64 returns Boolean:
    Let i be 0
    While i < length:
        Let offset_ptr1 be pointer_offset(ptr1, i)
        Let offset_ptr2 be pointer_offset(ptr2, i)
        Let byte1 be load_u8(offset_ptr1)
        Let byte2 be load_u8(offset_ptr2)
        If byte1 is not byte2:
            Return false
        End If
        Let i be add_u64(i, 1)
    End While
    Return true
End Process

Process called "ascii_copy_string" that takes src as Pointer, dest as Pointer, length as Unsigned64:
    Let i be 0
    While i < length:
        Let src_ptr be pointer_offset(src, i)
        Let dest_ptr be pointer_offset(dest, i)
        Let byte be load_u8(src_ptr)
        store_u8(dest_ptr, byte)
        Let i be add_u64(i, 1)
    End While
End Process

Note: Low-level memory helpers using core primitives

Process called "load_u8" that takes ptr as Pointer returns Unsigned8:
    Let result be 0
    Inline Assembly:
        "movzx %0, byte ptr [%1]\n" Note: Load byte from memory
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "store_u8" that takes ptr as Pointer, value as Unsigned8:
    Inline Assembly:
        "mov byte ptr [%0], %1\n"   Note: Store byte to memory
        :
        : "r"(ptr), "r"(value)
        : "memory"
    End Assembly
End Process

Process called "pointer_offset" that takes ptr as Pointer, offset as Unsigned64 returns Pointer:
    Let address be convert_pointer_to_u64(ptr)
    Let new_address be add_u64(address, offset)
    Let new_ptr be convert_u64_to_pointer(new_address)
    Return new_ptr
End Process
