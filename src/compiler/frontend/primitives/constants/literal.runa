Note:
constants/literal.runa - Zero-Dependency Literal Value Primitives

This module provides fundamental literal value handling operations using direct assembly instructions.
These primitives have ZERO dependencies and compile to efficient immediate value loading.

@Reasoning:
- Provides low-level literal value creation and manipulation for compiler code generation
- All operations use inline assembly for true self-hosting capabilities
- No external dependencies - we generate the machine code directly
- Essential for implementing integer, float, string, and boolean literals
@End Reasoning

@Implementation:
- Inline Assembly statements using immediate value loading instructions
- Direct register assignment for literal values
- Support for all fundamental data types
- Zero-cost abstraction through compile-time optimization
@End Implementation

@Performance_Hints:
- Each literal operation maps to single immediate load instruction
- No memory access required for small literals
- Large literals stored in data section for efficiency
- Immediate values are fastest possible data access
@End Performance_Hints
:End Note

Note: =====================================================================
Note: INTEGER LITERAL PRIMITIVES
Note: =====================================================================

Process called "load_integer_literal" that takes value as Integer returns Integer:
    Assembly "mov rax, %[value]"
End Process

Process called "load_integer32_literal" that takes value as Integer32 returns Integer32:
    Assembly "mov eax, %[value]"
End Process

Process called "load_integer16_literal" that takes value as Integer16 returns Integer16:
    Assembly "mov ax, %[value]"
End Process

Process called "load_integer8_literal" that takes value as Integer8 returns Integer8:
    Assembly "mov al, %[value]"
End Process

Process called "load_unsigned64_literal" that takes value as Unsigned64 returns Unsigned64:
    Assembly "mov rax, %[value]"
End Process

Process called "load_unsigned32_literal" that takes value as Unsigned32 returns Unsigned32:
    Assembly "mov eax, %[value]"
End Process

Process called "load_unsigned16_literal" that takes value as Unsigned16 returns Unsigned16:
    Assembly "mov ax, %[value]"
End Process

Process called "load_unsigned8_literal" that takes value as Unsigned8 returns Unsigned8:
    Assembly "mov al, %[value]"
End Process

Note: =====================================================================
Note: FLOATING POINT LITERAL PRIMITIVES
Note: =====================================================================

Process called "load_float_literal" that takes value as Float returns Float:
    Assembly "movsd xmm0, %[value]"
End Process

Process called "load_float32_literal" that takes value as Float32 returns Float32:
    Assembly "movss xmm0, %[value]"
End Process

Process called "load_float_zero":
    Assembly "xorpd xmm0, xmm0"
End Process

Process called "load_float32_zero":
    Assembly "xorps xmm0, xmm0"
End Process

Process called "load_float_one":
    Assembly "movsd xmm0, qword ptr [one_constant]"
End Process

Process called "load_float32_one":
    Assembly "movss xmm0, dword ptr [one_f32_constant]"
End Process

Process called "load_float_pi":
    Assembly "movsd xmm0, qword ptr [pi_constant]"
End Process

Process called "load_float_e":
    Assembly "movsd xmm0, qword ptr [e_constant]"
End Process

Note: =====================================================================
Note: BOOLEAN LITERAL PRIMITIVES
Note: =====================================================================

Process called "load_boolean_literal" that takes value as Boolean returns Boolean:
    Assembly "mov al, %[value]"
End Process

Process called "load_true_literal" returns Boolean:
    Assembly "mov al, 1"
End Process

Process called "load_false_literal" returns Boolean:
    Assembly "mov al, 0"
End Process

Process called "load_boolean_from_comparison" that takes left as Integer, right as Integer returns Boolean:
    Assembly "cmp %[left], %[right]; sete al"
End Process

Note: =====================================================================
Note: POINTER/ADDRESS LITERAL PRIMITIVES
Note: =====================================================================

Process called "load_null_pointer_literal" returns Pointer:
    Assembly "xor rax, rax"
End Process

Process called "load_pointer_literal" that takes address as Pointer returns Pointer:
    Assembly "mov rax, %[address]"
End Process

Process called "load_function_address" that takes func_ptr as Pointer returns Pointer:
    Assembly "lea rax, [%[func_ptr]]"
End Process

Process called "load_data_address" that takes data_ptr as Pointer returns Pointer:
    Assembly "lea rax, [%[data_ptr]]"
End Process

Process called "load_stack_address" that takes offset as Integer returns Pointer:
    Assembly "lea rax, [rsp + %[offset]]"
End Process

Process called "load_frame_address" that takes offset as Integer returns Pointer:
    Assembly "lea rax, [rbp + %[offset]]"
End Process

Note: =====================================================================
Note: STRING LITERAL PRIMITIVES
Note: =====================================================================

Process called "load_string_literal_address" that takes string_ptr as Pointer returns Pointer:
    Assembly "lea rax, [%[string_ptr]]"
End Process

Process called "load_string_length" that takes string_ptr as Pointer returns Integer:
    Note: Load pre-computed string length from data section
    Assembly "mov rax, [%[string_ptr] - 8]"
End Process

Process called "load_empty_string_literal" returns Pointer:
    Assembly "lea rax, [empty_string_constant]"
End Process

Process called "load_char_literal" that takes char_value as Unsigned8 returns Unsigned8:
    Assembly "mov al, %[char_value]"
End Process

Note: =====================================================================
Note: ARRAY/COLLECTION LITERAL PRIMITIVES
Note: =====================================================================

Process called "load_array_literal_address" that takes array_ptr as Pointer returns Pointer:
    Assembly "lea rax, [%[array_ptr]]"
End Process

Process called "load_array_length" that takes array_ptr as Pointer returns Integer:
    Assembly "mov rax, [%[array_ptr] - 8]"
End Process

Process called "load_empty_array_literal" returns Pointer:
    Assembly "lea rax, [empty_array_constant]"
End Process

Process called "get_array_element_address" that takes array_ptr as Pointer, index as Integer, element_size as Integer returns Pointer:
    Assembly "lea rax, [%[array_ptr] + %[index] * %[element_size]]"
End Process

Note: =====================================================================
Note: LITERAL VALUE VALIDATION
Note: =====================================================================

Process called "validate_integer_range" that takes value as Integer, min_val as Integer, max_val as Integer returns Boolean:
    Assembly "cmp %[value], %[min_val]; jl invalid; cmp %[value], %[max_val]; jg invalid; mov al, 1; jmp done; invalid: mov al, 0; done:"
End Process

Process called "validate_unsigned_range" that takes value as Unsigned64, max_val as Unsigned64 returns Boolean:
    Assembly "cmp %[value], %[max_val]; ja invalid; mov al, 1; jmp done; invalid: mov al, 0; done:"
End Process

Process called "validate_float_finite" that takes value as Float returns Boolean:
    Assembly "ucomisd %[value], %[value]; jp invalid; mov al, 1; jmp done; invalid: mov al, 0; done:"
End Process

Process called "validate_pointer_not_null" that takes ptr as Pointer returns Boolean:
    Assembly "test %[ptr], %[ptr]; setnz al"
End Process

Note: =====================================================================
Note: LITERAL CONVERSION PRIMITIVES
Note: =====================================================================

Process called "convert_integer_to_float" that takes int_val as Integer returns Float:
    Assembly "cvtsi2sd xmm0, %[int_val]"
End Process

Process called "convert_float_to_integer" that takes float_val as Float returns Integer:
    Assembly "cvttsd2si rax, %[float_val]"
End Process

Process called "convert_unsigned_to_float" that takes uint_val as Unsigned64 returns Float:
    Assembly "mov rax, %[uint_val]; cvtsi2sd xmm0, rax"
End Process

Process called "convert_float_to_unsigned" that takes float_val as Float returns Unsigned64:
    Assembly "cvttsd2si rax, %[float_val]"
End Process

Process called "extend_integer_sign" that takes value as Integer32 returns Integer:
    Assembly "movsxd rax, %[value]"
End Process

Process called "extend_integer_zero" that takes value as Unsigned32 returns Unsigned64:
    Assembly "mov eax, %[value]; mov rax, rax"
End Process

Note: =====================================================================
Note: LITERAL ARITHMETIC PRIMITIVES
Note: =====================================================================

Process called "negate_integer_literal" that takes value as Integer returns Integer:
    Assembly "mov rax, %[value]; neg rax"
End Process

Process called "negate_float_literal" that takes value as Float returns Float:
    Assembly "movsd xmm0, %[value]; movsd xmm1, qword ptr [float_sign_mask]; xorpd xmm0, xmm1"
End Process

Process called "absolute_integer_literal" that takes value as Integer returns Integer:
    Assembly "mov rax, %[value]; cmp rax, 0; jge done; neg rax; done:"
End Process

Process called "absolute_float_literal" that takes value as Float returns Float:
    Assembly "movsd xmm0, %[value]; movsd xmm1, qword ptr [float_abs_mask]; andpd xmm0, xmm1"
End Process

Note: =====================================================================
Note: LITERAL COMPARISON PRIMITIVES
Note: =====================================================================

Process called "compare_integer_literals" that takes left as Integer, right as Integer returns Integer:
    Assembly "cmp %[left], %[right]; setl al; movzx rdx, al; sete al; movzx rcx, al; setg al; movzx rax, al; sub rax, rdx"
End Process

Process called "compare_float_literals" that takes left as Float, right as Float returns Integer:
    Assembly "ucomisd %[left], %[right]; setb al; movzx rdx, al; sete al; movzx rcx, al; seta al; movzx rax, al; sub rax, rdx"
End Process

Process called "equals_integer_literals" that takes left as Integer, right as Integer returns Boolean:
    Assembly "cmp %[left], %[right]; sete al"
End Process

Process called "equals_float_literals" that takes left as Float, right as Float returns Boolean:
    Assembly "ucomisd %[left], %[right]; sete al"
End Process

Note: =====================================================================
Note: LITERAL MEMORY LOADING
Note: =====================================================================

Process called "load_literal_from_memory" that takes address as Pointer returns Integer:
    Assembly "mov rax, [%[address]]"
End Process

Process called "load_literal_byte" that takes address as Pointer returns Unsigned8:
    Assembly "mov al, byte ptr [%[address]]"
End Process

Process called "load_literal_word" that takes address as Pointer returns Unsigned16:
    Assembly "mov ax, word ptr [%[address]]"
End Process

Process called "load_literal_dword" that takes address as Pointer returns Unsigned32:
    Assembly "mov eax, dword ptr [%[address]]"
End Process

Process called "load_literal_qword" that takes address as Pointer returns Unsigned64:
    Assembly "mov rax, qword ptr [%[address]]"
End Process

Process called "load_float_from_memory" that takes address as Pointer returns Float:
    Assembly "movsd xmm0, qword ptr [%[address]]"
End Process

Process called "load_float32_from_memory" that takes address as Pointer returns Float32:
    Assembly "movss xmm0, dword ptr [%[address]]"
End Process

Note: =====================================================================
Note: LITERAL CONSTANT GENERATION
Note: =====================================================================

Process called "generate_power_of_two" that takes exponent as Integer returns Integer:
    Assembly "mov rcx, %[exponent]; mov rax, 1; shl rax, cl"
End Process

Process called "generate_mask" that takes bit_count as Integer returns Integer:
    Assembly "mov rcx, %[bit_count]; mov rax, 1; shl rax, cl; dec rax"
End Process

Process called "generate_aligned_size" that takes size as Integer, alignment as Integer returns Integer:
    Assembly "mov rax, %[size]; add rax, %[alignment]; dec rax; mov rcx, %[alignment]; dec rcx; not rcx; and rax, rcx"
End Process

Process called "generate_page_aligned_address" that takes address as Pointer returns Pointer:
    Assembly "mov rax, %[address]; and rax, -4096"
End Process

Note: =====================================================================
Note: LITERAL BIT MANIPULATION
Note: =====================================================================

Process called "extract_bit_field" that takes value as Integer, start_bit as Integer, bit_count as Integer returns Integer:
    Assembly "mov rax, %[value]; mov rcx, %[start_bit]; shr rax, cl; mov rcx, %[bit_count]; mov rdx, 1; shl rdx, cl; dec rdx; and rax, rdx"
End Process

Process called "insert_bit_field" that takes target as Integer, value as Integer, start_bit as Integer, bit_count as Integer returns Integer:
    Assembly "mov rax, %[target]; mov rcx, %[bit_count]; mov rdx, 1; shl rdx, cl; dec rdx; mov rcx, %[start_bit]; shl rdx, cl; not rdx; and rax, rdx; mov rdx, %[value]; and rdx, %[bit_count]; shl rdx, cl; or rax, rdx"
End Process

Process called "count_set_bits" that takes value as Integer returns Integer:
    Assembly "mov rax, %[value]; popcnt rax, rax"
End Process

Process called "count_leading_zeros" that takes value as Integer returns Integer:
    Assembly "mov rax, %[value]; lzcnt rax, rax"
End Process

Process called "count_trailing_zeros" that takes value as Integer returns Integer:
    Assembly "mov rax, %[value]; tzcnt rax, rax"
End Process

Note: =====================================================================
Note: LITERAL OPTIMIZATION HELPERS
Note: =====================================================================

Process called "is_power_of_two" that takes value as Integer returns Boolean:
    Assembly "mov rax, %[value]; test rax, rax; jz not_power; dec rax; test %[value], rax; setz al; jmp done; not_power: mov al, 0; done:"
End Process

Process called "next_power_of_two" that takes value as Integer returns Integer:
    Assembly "mov rax, %[value]; dec rax; or rax, rax; shr rax, 1; or rax, rax; shr rax, 2; or rax, rax; shr rax, 4; or rax, rax; shr rax, 8; or rax, rax; shr rax, 16; or rax, rax; shr rax, 32; inc rax"
End Process

Process called "log2_integer" that takes value as Integer returns Integer:
    Assembly "mov rax, %[value]; bsr rax, rax"
End Process

Process called "is_aligned" that takes address as Pointer, alignment as Integer returns Boolean:
    Assembly "mov rax, %[address]; mov rcx, %[alignment]; dec rcx; test rax, rcx; setz al"
End Process