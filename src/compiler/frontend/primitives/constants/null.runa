Note:
constants/null.runa - Zero-Dependency Null/None Value Primitives

This module provides fundamental null and none value handling operations using direct assembly instructions.
These primitives have ZERO dependencies and compile to efficient null checking and manipulation.

@Reasoning:
- Provides low-level null/none value handling for compiler code generation
- All operations use inline assembly for true self-hosting capabilities
- No external dependencies - we generate the machine code directly
- Essential for implementing null checks, optional types, and memory safety
@End Reasoning

@Implementation:
- Inline Assembly statements using null pointer operations
- Direct register manipulation for null testing
- Support for various null representations
- Zero-cost abstraction through compile-time optimization
@End Implementation

@Performance_Hints:
- Null checks compile to single test instruction
- Null pointer represented as zero value
- No memory access required for null operations
- Branch prediction friendly null checking
@End Performance_Hints
:End Note

Note: =====================================================================
Note: BASIC NULL VALUE PRIMITIVES
Note: =====================================================================

Process called "create_null_pointer" returns Pointer:
    Assembly "xor rax, rax"
End Process

Process called "create_null_reference" returns Pointer:
    Assembly "xor rax, rax"
End Process

Process called "create_null_function_pointer" returns Pointer:
    Assembly "xor rax, rax"
End Process

Process called "create_null_object" returns Pointer:
    Assembly "xor rax, rax"
End Process

Process called "create_null_array" returns Pointer:
    Assembly "xor rax, rax"
End Process

Process called "create_null_string" returns Pointer:
    Assembly "xor rax, rax"
End Process

Note: =====================================================================
Note: NULL CHECKING PRIMITIVES
Note: =====================================================================

Process called "is_null_pointer" that takes ptr as Pointer returns Boolean:
    Assembly "test %[ptr], %[ptr]; setz al"
End Process

Process called "is_not_null_pointer" that takes ptr as Pointer returns Boolean:
    Assembly "test %[ptr], %[ptr]; setnz al"
End Process

Process called "is_null_reference" that takes ref as Pointer returns Boolean:
    Assembly "test %[ref], %[ref]; setz al"
End Process

Process called "is_valid_pointer" that takes ptr as Pointer returns Boolean:
    Assembly "test %[ptr], %[ptr]; setnz al"
End Process

Process called "is_null_or_empty" that takes ptr as Pointer returns Boolean:
    Assembly "test %[ptr], %[ptr]; jz is_null; mov al, byte ptr [%[ptr]]; test al, al; setz al; jmp done; is_null: mov al, 1; done:"
End Process

Note: =====================================================================
Note: NULL COMPARISON PRIMITIVES
Note: =====================================================================

Process called "compare_with_null" that takes ptr as Pointer returns Integer:
    Assembly "test %[ptr], %[ptr]; setz al; movzx rax, al; neg rax"
End Process

Process called "equals_null" that takes ptr as Pointer returns Boolean:
    Assembly "test %[ptr], %[ptr]; setz al"
End Process

Process called "not_equals_null" that takes ptr as Pointer returns Boolean:
    Assembly "test %[ptr], %[ptr]; setnz al"
End Process

Process called "compare_pointers_null_safe" that takes ptr1 as Pointer, ptr2 as Pointer returns Integer:
    Assembly "cmp %[ptr1], %[ptr2]; setl al; movzx rdx, al; sete al; movzx rcx, al; setg al; movzx rax, al; sub rax, rdx"
End Process

Note: =====================================================================
Note: NULL COALESCING PRIMITIVES
Note: =====================================================================

Process called "coalesce_pointer" that takes primary as Pointer, fallback as Pointer returns Pointer:
    Assembly "mov rax, %[primary]; test rax, rax; cmovz rax, %[fallback]"
End Process

Process called "coalesce_three_pointers" that takes first as Pointer, second as Pointer, third as Pointer returns Pointer:
    Assembly "mov rax, %[first]; test rax, rax; jnz done; mov rax, %[second]; test rax, rax; jnz done; mov rax, %[third]; done:"
End Process

Process called "first_non_null" that takes ptr_array as Pointer, count as Integer returns Pointer:
    Assembly "mov rcx, %[count]; mov rsi, %[ptr_array]; xor rax, rax; loop_start: mov rdx, [rsi]; test rdx, rdx; jnz found; add rsi, 8; dec rcx; jnz loop_start; jmp done; found: mov rax, rdx; done:"
End Process

Note: =====================================================================
Note: NULL ASSIGNMENT PRIMITIVES
Note: =====================================================================

Process called "set_pointer_to_null" that takes ptr_address as Pointer:
    Assembly "mov qword ptr [%[ptr_address]], 0"
End Process

Process called "clear_pointer_array" that takes array_ptr as Pointer, count as Integer:
    Assembly "mov rdi, %[array_ptr]; mov rcx, %[count]; xor rax, rax; rep stosq"
End Process

Process called "nullify_reference" that takes ref_address as Pointer:
    Assembly "mov qword ptr [%[ref_address]], 0"
End Process

Process called "reset_object_pointer" that takes obj_ptr_address as Pointer:
    Assembly "mov qword ptr [%[obj_ptr_address]], 0"
End Process

Note: =====================================================================
Note: NULL-SAFE OPERATIONS
Note: =====================================================================

Process called "safe_dereference" that takes ptr as Pointer returns Pointer:
    Assembly "mov rax, %[ptr]; test rax, rax; jz null_deref; mov rax, [rax]; jmp done; null_deref: xor rax, rax; done:"
End Process

Process called "safe_call" that takes func_ptr as Pointer returns Boolean:
    Assembly "mov rax, %[func_ptr]; test rax, rax; jz null_call; call rax; mov al, 1; jmp done; null_call: mov al, 0; done:"
End Process

Process called "safe_array_access" that takes array_ptr as Pointer, index as Integer returns Pointer:
    Assembly "mov rax, %[array_ptr]; test rax, rax; jz null_array; mov rcx, %[index]; lea rax, [rax + rcx * 8]; jmp done; null_array: xor rax, rax; done:"
End Process

Process called "safe_string_length" that takes str_ptr as Pointer returns Integer:
    Assembly "mov rax, %[str_ptr]; test rax, rax; jz null_string; mov rsi, rax; xor rcx, rcx; loop_count: lodsb; test al, al; jz done; inc rcx; jmp loop_count; null_string: xor rcx, rcx; done: mov rax, rcx"
End Process

Note: =====================================================================
Note: OPTIONAL TYPE PRIMITIVES
Note: =====================================================================

Process called "create_some_value" that takes value as Pointer returns Pointer:
    Note: Return non-null value as-is for Some variant
    Assembly "mov rax, %[value]"
End Process

Process called "create_none_value" returns Pointer:
    Note: Return null for None variant
    Assembly "xor rax, rax"
End Process

Process called "is_some_value" that takes optional as Pointer returns Boolean:
    Assembly "test %[optional], %[optional]; setnz al"
End Process

Process called "is_none_value" that takes optional as Pointer returns Boolean:
    Assembly "test %[optional], %[optional]; setz al"
End Process

Process called "unwrap_optional" that takes optional as Pointer returns Pointer:
    Assembly "mov rax, %[optional]; test rax, rax; jnz valid; int3; valid:"
End Process

Process called "unwrap_or_default" that takes optional as Pointer, default_value as Pointer returns Pointer:
    Assembly "mov rax, %[optional]; test rax, rax; cmovz rax, %[default_value]"
End Process

Note: =====================================================================
Note: NULL POINTER ARITHMETIC
Note: =====================================================================

Process called "offset_from_null" that takes ptr as Pointer returns Integer:
    Assembly "mov rax, %[ptr]"
End Process

Process called "distance_from_null" that takes ptr as Pointer returns Integer:
    Assembly "mov rax, %[ptr]; test rax, rax; jz zero_distance; neg rax; sar rax, 63; and rax, %[ptr]; jmp done; zero_distance: xor rax, rax; done:"
End Process

Process called "null_safe_pointer_add" that takes ptr as Pointer, offset as Integer returns Pointer:
    Assembly "mov rax, %[ptr]; test rax, rax; jz null_result; add rax, %[offset]; jmp done; null_result: xor rax, rax; done:"
End Process

Process called "null_safe_pointer_sub" that takes ptr as Pointer, offset as Integer returns Pointer:
    Assembly "mov rax, %[ptr]; test rax, rax; jz null_result; sub rax, %[offset]; jmp done; null_result: xor rax, rax; done:"
End Process

Note: =====================================================================
Note: NULL VALIDATION PRIMITIVES
Note: =====================================================================

Process called "validate_not_null" that takes ptr as Pointer returns Boolean:
    Assembly "test %[ptr], %[ptr]; setnz al"
End Process

Process called "assert_not_null" that takes ptr as Pointer:
    Assembly "test %[ptr], %[ptr]; jnz valid; int3; valid:"
End Process

Process called "require_non_null" that takes ptr as Pointer returns Pointer:
    Assembly "mov rax, %[ptr]; test rax, rax; jnz valid; int3; valid:"
End Process

Process called "check_null_and_panic" that takes ptr as Pointer, error_code as Integer:
    Assembly "test %[ptr], %[ptr]; jnz valid; mov rax, %[error_code]; int3; valid:"
End Process

Note: =====================================================================
Note: NULL MEMORY OPERATIONS
Note: =====================================================================

Process called "zero_memory_block" that takes ptr as Pointer, size as Integer:
    Assembly "mov rdi, %[ptr]; mov rcx, %[size]; xor rax, rax; rep stosb"
End Process

Process called "zero_pointer_array" that takes array_ptr as Pointer, count as Integer:
    Assembly "mov rdi, %[array_ptr]; mov rcx, %[count]; xor rax, rax; rep stosq"
End Process

Process called "is_zero_memory" that takes ptr as Pointer, size as Integer returns Boolean:
    Assembly "mov rsi, %[ptr]; mov rcx, %[size]; xor rax, rax; repe scasb; sete al"
End Process

Process called "find_first_null" that takes ptr_array as Pointer, count as Integer returns Integer:
    Assembly "mov rsi, %[ptr_array]; mov rcx, %[count]; xor rax, rax; loop_find: cmp qword ptr [rsi], 0; je found; add rsi, 8; inc rax; dec rcx; jnz loop_find; mov rax, -1; jmp done; found: ; done:"
End Process

Note: =====================================================================
Note: NULL DEBUGGING PRIMITIVES
Note: =====================================================================

Process called "debug_null_check" that takes ptr as Pointer, file_info as Pointer, line_number as Integer:
    Assembly "test %[ptr], %[ptr]; jnz valid; push %[file_info]; push %[line_number]; int3; valid:"
End Process

Process called "log_null_access" that takes ptr as Pointer, access_type as Integer:
    Assembly "test %[ptr], %[ptr]; jnz no_log; push %[access_type]; call null_access_logger; pop rax; no_log:"
End Process

Process called "count_null_pointers" that takes ptr_array as Pointer, count as Integer returns Integer:
    Assembly "mov rsi, %[ptr_array]; mov rcx, %[count]; xor rax, rax; loop_count_null: cmp qword ptr [rsi], 0; jne not_null; inc rax; not_null: add rsi, 8; dec rcx; jnz loop_count_null"
End Process

Note: =====================================================================
Note: NULL SENTINEL VALUES
Note: =====================================================================

Process called "create_null_sentinel" returns Pointer:
    Note: Special null value used as array/list terminator
    Assembly "xor rax, rax"
End Process

Process called "is_null_sentinel" that takes ptr as Pointer returns Boolean:
    Assembly "test %[ptr], %[ptr]; setz al"
End Process

Process called "find_null_sentinel" that takes ptr_array as Pointer returns Integer:
    Assembly "mov rsi, %[ptr_array]; xor rax, rax; loop_sentinel: cmp qword ptr [rsi], 0; je found_sentinel; add rsi, 8; inc rax; jmp loop_sentinel; found_sentinel:"
End Process

Process called "add_null_sentinel" that takes ptr_array as Pointer, index as Integer:
    Assembly "mov rdi, %[ptr_array]; mov rcx, %[index]; lea rdi, [rdi + rcx * 8]; mov qword ptr [rdi], 0"
End Process

Note: =====================================================================
Note: NULL PATTERN MATCHING
Note: =====================================================================

Process called "match_null_pattern" that takes ptr as Pointer returns Integer:
    Assembly "test %[ptr], %[ptr]; setz al; movzx rax, al"
End Process

Process called "match_some_pattern" that takes ptr as Pointer returns Integer:
    Assembly "test %[ptr], %[ptr]; setnz al; movzx rax, al"
End Process

Process called "extract_optional_value" that takes optional as Pointer, result_ptr as Pointer returns Boolean:
    Assembly "mov rax, %[optional]; test rax, rax; jz no_value; mov rdx, %[result_ptr]; mov [rdx], rax; mov al, 1; jmp done; no_value: mov al, 0; done:"
End Process