Note:
constants/constants.runa - Zero-Dependency Compile-Time Constants Primitives

This module provides fundamental compile-time constant handling operations using direct assembly instructions.
These primitives have ZERO dependencies and compile to efficient constant value management.

@Reasoning:
- Provides low-level compile-time constant management for compiler code generation
- All operations use inline assembly for true self-hosting capabilities
- No external dependencies - we generate the machine code directly
- Essential for implementing constant folding, optimization, and static analysis
@End Reasoning

@Implementation:
- Inline Assembly statements using constant value operations
- Direct data section access for compile-time constants
- Support for constant propagation and folding
- Zero-cost abstraction through compile-time optimization
@End Implementation

@Performance_Hints:
- Constants stored in read-only data section
- Constant folding eliminates runtime computation
- Global constants accessible via direct addressing
- Compile-time evaluation for maximum performance
@End Performance_Hints
:End Note

Note: =====================================================================
Note: COMPILE-TIME CONSTANT DEFINITIONS
Note: =====================================================================

Process called "define_integer_constant" that takes name as String, value as Integer:
    Note: Store constant in data section with label
    Assembly ".section .rodata; %[name]: .quad %[value]; .section .text"
End Process

Process called "define_float_constant" that takes name as String, value as Float:
    Assembly ".section .rodata; %[name]: .double %[value]; .section .text"
End Process

Process called "define_string_constant" that takes name as String, str_value as String:
    Assembly ".section .rodata; %[name]: .asciz \"%[str_value]\"; .section .text"
End Process

Process called "define_array_constant" that takes name as String, values as Pointer, count as Integer:
    Assembly ".section .rodata; %[name]: .fill %[count], 8, 0; .section .text"
End Process

Note: =====================================================================
Note: CONSTANT VALUE ACCESS
Note: =====================================================================

Process called "load_integer_constant" that takes constant_name as String returns Integer:
    Assembly "mov rax, qword ptr [%[constant_name]]"
End Process

Process called "load_float_constant" that takes constant_name as String returns Float:
    Assembly "movsd xmm0, qword ptr [%[constant_name]]"
End Process

Process called "load_string_constant" that takes constant_name as String returns Pointer:
    Assembly "lea rax, [%[constant_name]]"
End Process

Process called "get_constant_address" that takes constant_name as String returns Pointer:
    Assembly "lea rax, [%[constant_name]]"
End Process

Note: =====================================================================
Note: MATHEMATICAL CONSTANTS
Note: =====================================================================

Process called "load_pi_constant" returns Float:
    Assembly "movsd xmm0, qword ptr [pi_value]"
End Process

Process called "load_e_constant" returns Float:
    Assembly "movsd xmm0, qword ptr [e_value]"
End Process

Process called "load_golden_ratio_constant" returns Float:
    Assembly "movsd xmm0, qword ptr [golden_ratio_value]"
End Process

Process called "load_sqrt2_constant" returns Float:
    Assembly "movsd xmm0, qword ptr [sqrt2_value]"
End Process

Process called "load_ln2_constant" returns Float:
    Assembly "movsd xmm0, qword ptr [ln2_value]"
End Process

Process called "load_ln10_constant" returns Float:
    Assembly "movsd xmm0, qword ptr [ln10_value]"
End Process

Note: =====================================================================
Note: SYSTEM CONSTANTS
Note: =====================================================================

Process called "load_max_integer_constant" returns Integer:
    Assembly "mov rax, 0x7FFFFFFFFFFFFFFF"
End Process

Process called "load_min_integer_constant" returns Integer:
    Assembly "mov rax, 0x8000000000000000"
End Process

Process called "load_max_unsigned_constant" returns Unsigned64:
    Assembly "mov rax, 0xFFFFFFFFFFFFFFFF"
End Process

Process called "load_page_size_constant" returns Integer:
    Assembly "mov rax, 4096"
End Process

Process called "load_word_size_constant" returns Integer:
    Assembly "mov rax, 8"
End Process

Process called "load_cache_line_size_constant" returns Integer:
    Assembly "mov rax, 64"
End Process

Note: =====================================================================
Note: CONSTANT FOLDING PRIMITIVES
Note: =====================================================================

Process called "fold_constant_add" that takes left as Integer, right as Integer returns Integer:
    Note: Compile-time addition for constant expressions
    Let result be add_integers(left, right)
    Return result
End Process

Process called "fold_constant_multiply" that takes left as Integer, right as Integer returns Integer:
    Note: Compile-time multiplication for constant expressions
    Let result be multiply_integers(left, right)
    Return result
End Process

Process called "fold_constant_divide" that takes left as Integer, right as Integer returns Integer:
    Note: Compile-time division for constant expressions
    If right is 0:
        Return 0
    End If
    Let result be divide_integers(left, right)
    Return result
End Process

Process called "fold_constant_modulo" that takes left as Integer, right as Integer returns Integer:
    Note: Compile-time modulo for constant expressions
    If right is 0:
        Return 0
    End If
    Let result be modulo_integers(left, right)
    Return result
End Process

Note: =====================================================================
Note: CONSTANT COMPARISON FOLDING
Note: =====================================================================

Process called "fold_constant_equals" that takes left as Integer, right as Integer returns Boolean:
    If left is right:
        Return true
    End If
    Return false
End Process

Process called "fold_constant_less_than" that takes left as Integer, right as Integer returns Boolean:
    If left < right:
        Return true
    End If
    Return false
End Process

Process called "fold_constant_greater_than" that takes left as Integer, right as Integer returns Boolean:
    If left > right:
        Return true
    End If
    Return false
End Process

Process called "fold_constant_less_equal" that takes left as Integer, right as Integer returns Boolean:
    If left <= right:
        Return true
    End If
    Return false
End Process

Process called "fold_constant_greater_equal" that takes left as Integer, right as Integer returns Boolean:
    If left >= right:
        Return true
    End If
    Return false
End Process

Note: =====================================================================
Note: CONSTANT BITWISE OPERATIONS
Note: =====================================================================

Process called "fold_constant_and" that takes left as Integer, right as Integer returns Integer:
    Assembly "mov rax, %[left]; and rax, %[right]"
End Process

Process called "fold_constant_or" that takes left as Integer, right as Integer returns Integer:
    Assembly "mov rax, %[left]; or rax, %[right]"
End Process

Process called "fold_constant_xor" that takes left as Integer, right as Integer returns Integer:
    Assembly "mov rax, %[left]; xor rax, %[right]"
End Process

Process called "fold_constant_not" that takes value as Integer returns Integer:
    Assembly "mov rax, %[value]; not rax"
End Process

Process called "fold_constant_shift_left" that takes value as Integer, shift as Integer returns Integer:
    Assembly "mov rax, %[value]; mov rcx, %[shift]; shl rax, cl"
End Process

Process called "fold_constant_shift_right" that takes value as Integer, shift as Integer returns Integer:
    Assembly "mov rax, %[value]; mov rcx, %[shift]; sar rax, cl"
End Process

Note: =====================================================================
Note: CONSTANT ARRAY OPERATIONS
Note: =====================================================================

Process called "get_constant_array_size" that takes array_name as String returns Integer:
    Assembly "mov rax, qword ptr [%[array_name]_size]"
End Process

Process called "get_constant_array_element" that takes array_name as String, index as Integer returns Integer:
    Assembly "mov rax, qword ptr [%[array_name] + %[index] * 8]"
End Process

Process called "set_constant_array_element" that takes array_name as String, index as Integer, value as Integer:
    Assembly "mov qword ptr [%[array_name] + %[index] * 8], %[value]"
End Process

Process called "copy_constant_array" that takes src_name as String, dest_name as String, count as Integer:
    Assembly "mov rsi, %[src_name]; mov rdi, %[dest_name]; mov rcx, %[count]; rep movsq"
End Process

Note: =====================================================================
Note: CONSTANT STRING OPERATIONS
Note: =====================================================================

Process called "get_constant_string_length" that takes string_name as String returns Integer:
    Assembly "mov rax, qword ptr [%[string_name]_length]"
End Process

Process called "get_constant_string_char" that takes string_name as String, index as Integer returns Unsigned8:
    Assembly "mov al, byte ptr [%[string_name] + %[index]]"
End Process

Process called "compare_constant_strings" that takes str1_name as String, str2_name as String returns Integer:
    Assembly "mov rsi, %[str1_name]; mov rdi, %[str2_name]; call strcmp_impl"
End Process

Process called "concatenate_constant_strings" that takes str1_name as String, str2_name as String, result_name as String:
    Assembly "mov rsi, %[str1_name]; mov rdi, %[result_name]; call strcpy_impl; mov rsi, %[str2_name]; call strcat_impl"
End Process

Note: =====================================================================
Note: CONSTANT VALIDATION
Note: =====================================================================

Process called "validate_constant_range" that takes value as Integer, min_val as Integer, max_val as Integer returns Boolean:
    If value < min_val:
        Return false
    End If
    If value > max_val:
        Return false
    End If
    Return true
End Process

Process called "validate_constant_alignment" that takes value as Integer, alignment as Integer returns Boolean:
    Let remainder be modulo_integers(value, alignment)
    If remainder is 0:
        Return true
    End If
    Return false
End Process

Process called "validate_constant_power_of_two" that takes value as Integer returns Boolean:
    If value <= 0:
        Return false
    End If
    Let and_result be fold_constant_and(value, subtract_integers(value, 1))
    If and_result is 0:
        Return true
    End If
    Return false
End Process

Note: =====================================================================
Note: CONSTANT OPTIMIZATION
Note: =====================================================================

Process called "optimize_constant_expression" that takes expr_type as Integer, left as Integer, right as Integer returns Integer:
    Match expr_type:
        When 1:
            Note: Addition
            Return fold_constant_add(left, right)
        When 2:
            Note: Subtraction
            Return subtract_integers(left, right)
        When 3:
            Note: Multiplication
            Return fold_constant_multiply(left, right)
        When 4:
            Note: Division
            Return fold_constant_divide(left, right)
        Otherwise:
            Return 0
    End Match
End Process

Process called "strength_reduce_constant" that takes operation as Integer, operand as Integer returns Integer:
    Match operation:
        When 1:
            Note: Multiply by power of 2 -> shift left
            Let log_val be log2_integer(operand)
            Return log_val
        When 2:
            Note: Divide by power of 2 -> shift right
            Let log_val be log2_integer(operand)
            Return log_val
        Otherwise:
            Return operand
    End Match
End Process

Note: =====================================================================
Note: CONSTANT PROPAGATION
Note: =====================================================================

Process called "propagate_constant_value" that takes variable_id as Integer, constant_value as Integer:
    Assembly "mov qword ptr [constant_table + %[variable_id] * 8], %[constant_value]"
End Process

Process called "get_propagated_constant" that takes variable_id as Integer returns Integer:
    Assembly "mov rax, qword ptr [constant_table + %[variable_id] * 8]"
End Process

Process called "is_constant_variable" that takes variable_id as Integer returns Boolean:
    Assembly "mov rax, qword ptr [constant_flags + %[variable_id]]; test rax, rax; setnz al"
End Process

Process called "mark_variable_constant" that takes variable_id as Integer:
    Assembly "mov qword ptr [constant_flags + %[variable_id]], 1"
End Process

Note: =====================================================================
Note: COMPILE-TIME EVALUATION
Note: =====================================================================

Process called "evaluate_at_compile_time" that takes expression_ptr as Pointer returns Integer:
    Note: Evaluate constant expression during compilation
    Assembly "call compile_time_evaluator; mov rax, qword ptr [eval_result]"
End Process

Process called "is_compile_time_constant" that takes expression_ptr as Pointer returns Boolean:
    Assembly "call constant_checker; mov al, byte ptr [is_constant_result]"
End Process

Process called "fold_compile_time_branch" that takes condition as Boolean, then_block as Pointer, else_block as Pointer returns Pointer:
    If condition:
        Return then_block
    End If
    Return else_block
End Process

Note: =====================================================================
Note: CONSTANT MEMORY LAYOUT
Note: =====================================================================

Process called "allocate_constant_space" that takes size as Integer returns Pointer:
    Assembly ".section .rodata; constant_space_%[unique_id]: .space %[size]; .section .text; lea rax, [constant_space_%[unique_id]]"
End Process

Process called "get_constant_section_address" returns Pointer:
    Assembly "lea rax, [.rodata]"
End Process

Process called "get_constant_section_size" returns Integer:
    Assembly "mov rax, qword ptr [rodata_section_size]"
End Process

Process called "align_constant_data" that takes alignment as Integer returns Pointer:
    Assembly ".align %[alignment]"
End Process

Note: =====================================================================
Note: CONSTANT DEBUGGING
Note: =====================================================================

Process called "dump_constant_table":
    Assembly "call constant_table_dumper"
End Process

Process called "verify_constant_integrity" returns Boolean:
    Assembly "call constant_verifier; mov al, byte ptr [verification_result]"
End Process

Process called "trace_constant_usage" that takes constant_id as Integer:
    Assembly "push %[constant_id]; call constant_tracer; pop rax"
End Process

Note: Helper operations using existing primitives

Process called "add_integers" that takes left as Integer, right as Integer returns Integer:
    Assembly "mov rax, %[left]; add rax, %[right]"
End Process

Process called "subtract_integers" that takes left as Integer, right as Integer returns Integer:
    Assembly "mov rax, %[left]; sub rax, %[right]"
End Process

Process called "multiply_integers" that takes left as Integer, right as Integer returns Integer:
    Assembly "mov rax, %[left]; imul rax, %[right]"
End Process

Process called "divide_integers" that takes left as Integer, right as Integer returns Integer:
    Assembly "mov rax, %[left]; cqo; idiv %[right]"
End Process

Process called "modulo_integers" that takes left as Integer, right as Integer returns Integer:
    Assembly "mov rax, %[left]; cqo; idiv %[right]; mov rax, rdx"
End Process

Process called "log2_integer" that takes value as Integer returns Integer:
    Assembly "mov rax, %[value]; bsr rax, rax"
End Process