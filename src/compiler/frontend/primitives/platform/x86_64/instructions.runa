Note: x86_64 instruction encoding and generation

Import "../../../assembly/machine_code.runa" as MachineCode

@Reasoning
The x86_64 instruction set is complex with variable-length encoding, multiple
addressing modes, and numerous instruction prefixes. This module provides
comprehensive instruction encoding capabilities for the compiler's code generator,
handling everything from simple register moves to complex SIMD operations.
@End Reasoning

Type called "InstructionFormat":
    Note: x86_64 instruction encoding format
    
    @Implementation
    x86_64 instructions consist of optional prefixes, opcode, ModR/M byte,
    SIB byte, displacement, and immediate. This structure captures all components.
    @End Implementation
    
    legacy_prefixes as Integer  Note: REP, LOCK, segment overrides
    rex_prefix as Integer        Note: REX.W, REX.R, REX.X, REX.B
    opcode as Integer           Note: 1-3 byte opcode
    opcode_length as Integer
    has_modrm as Boolean
    modrm_byte as Integer
    has_sib as Boolean
    sib_byte as Integer
    displacement as Integer
    disp_length as Integer      Note: 0, 1, 2, or 4 bytes
    immediate as Integer
    imm_length as Integer       Note: 0, 1, 2, 4, or 8 bytes
End Type

Type called "AddressingMode":
    Note: Memory addressing mode information
    
    @Implementation
    x86_64 supports various addressing modes including register direct,
    register indirect, base+index*scale+displacement, and RIP-relative.
    @End Implementation
    
    mode_type as Integer  Note: 0=reg, 1=mem, 2=rip-rel
    base_reg as Integer
    index_reg as Integer
    scale as Integer      Note: 1, 2, 4, or 8
    displacement as Integer
    segment as Integer    Note: Segment override
End Type

Process called "encode_mov" that takes dest as Pointer, src as Pointer, size as Integer returns InstructionFormat:
    Note: Encode MOV instruction
    
    @Implementation
    MOV is the most common instruction, supporting register-to-register,
    memory-to-register, register-to-memory, and immediate forms.
    @End Implementation
    
    Let inst be InstructionFormat
    
    Note: Determine if 64-bit operation needs REX.W
    If size equals 64:
        Set inst.rex_prefix to 0x48  Note: REX.W = 1
    Otherwise:
        Set inst.rex_prefix to 0
    End If
    
    Note: Check for immediate source
    Let src_is_imm be is_immediate(src)
    If src_is_imm:
        Note: MOV reg, imm
        Let dest_enc be MachineCode.get_register_encoding(dest)
        
        If size equals 64:
            Set inst.opcode to 0xB8 plus dest_enc  Note: MOV r64, imm64
            Set inst.opcode_length to 1
            Set inst.immediate to parse_immediate(src)
            Set inst.imm_length to 8
        Otherwise:
            If size equals 32:
                Set inst.opcode to 0xB8 plus dest_enc  Note: MOV r32, imm32
                Set inst.opcode_length to 1
                Set inst.immediate to parse_immediate(src)
                Set inst.imm_length to 4
            End If
        End If
    Otherwise:
        Note: Register to register MOV
        Set inst.opcode to 0x89  Note: MOV r/m, r
        Set inst.opcode_length to 1
        Set inst.has_modrm to true
        
        Let dest_enc be MachineCode.get_register_encoding(dest)
        Let src_enc be MachineCode.get_register_encoding(src)
        
        Note: ModR/M: mod=11 (register), reg=src, r/m=dest
        Set inst.modrm_byte to 0xC0 plus (src_enc times 8) plus dest_enc
    End If
    
    Return inst
End Process

Process called "encode_arithmetic" that takes op as Pointer, dest as Pointer, src as Pointer, size as Integer returns InstructionFormat:
    Note: Encode arithmetic instructions (ADD, SUB, AND, OR, XOR)
    
    @Implementation
    Arithmetic instructions share similar encoding patterns with different
    opcodes. They support register-register and register-immediate forms.
    @End Implementation
    
    Let inst be InstructionFormat
    
    Note: Set REX prefix if needed
    If size equals 64:
        Set inst.rex_prefix to 0x48
    Otherwise:
        Set inst.rex_prefix to 0
    End If
    
    Note: Determine opcode based on operation
    Let base_opcode as Integer
    Inline Assembly:
        "mov rsi, %1\n"              Note: Load operation string
        "\n"                         Note: Check for ADD
        "lea rdi, [add_str]\n"       Note: Load ADD string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_add\n"               Note: Jump if equal
        "\n"                         Note: Check for SUB
        "lea rdi, [sub_str]\n"       Note: Load SUB string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_sub\n"               Note: Jump if equal
        "\n"                         Note: Check for AND
        "lea rdi, [and_str]\n"       Note: Load AND string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_and\n"               Note: Jump if equal
        "\n"                         Note: Check for OR
        "lea rdi, [or_str]\n"        Note: Load OR string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_or\n"                Note: Jump if equal
        "\n"                         Note: Check for XOR
        "lea rdi, [xor_str]\n"       Note: Load XOR string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_xor\n"               Note: Jump if equal
        "\n"                         Note: Default to ADD
        "mov rax, 0x01\n"            Note: Default to ADD opcode
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Operation labels
        ".is_add:\n"                 Note: ADD opcode
        "mov rax, 0x01\n"            Note: ADD opcode value
        "jmp .done\n"                Note: Jump to end
        ".is_sub:\n"                 Note: SUB opcode
        "mov rax, 0x29\n"            Note: SUB opcode value
        "jmp .done\n"                Note: Jump to end
        ".is_and:\n"                 Note: AND opcode
        "mov rax, 0x21\n"            Note: AND opcode value
        "jmp .done\n"                Note: Jump to end
        ".is_or:\n"                  Note: OR opcode
        "mov rax, 0x09\n"            Note: OR opcode value
        "jmp .done\n"                Note: Jump to end
        ".is_xor:\n"                 Note: XOR opcode
        "mov rax, 0x31\n"            Note: XOR opcode value
        ".done:\n"                   Note: End label
        "mov %0, rax\n"              Note: Store result
        : "=r"(base_opcode)
        : "r"(op)
        : "rax", "rdi", "rsi", "memory"
    End Assembly
    
    Set inst.opcode to base_opcode
    Set inst.opcode_length to 1
    Set inst.has_modrm to true
    
    Let dest_enc be MachineCode.get_register_encoding(dest)
    Let src_enc be MachineCode.get_register_encoding(src)
    
    Set inst.modrm_byte to 0xC0 plus (src_enc times 8) plus dest_enc
    
    Return inst
End Process

Process called "encode_jump" that takes condition as Pointer, target as Integer returns InstructionFormat:
    Note: Encode conditional and unconditional jumps
    
    @Implementation
    Jumps use relative addressing with 8-bit or 32-bit displacements.
    Conditional jumps use two-byte opcodes starting with 0x0F.
    @End Implementation
    
    Let inst be InstructionFormat
    
    Note: Check for unconditional jump
    Inline Assembly:
        "mov rsi, %0\n"              Note: Load condition string
        "test rsi, rsi\n"            Note: Check for null pointer
        "jz .unconditional\n"        Note: Jump if null
        "mov al, [rsi]\n"            Note: Load first character
        "test al, al\n"              Note: Check for empty string
        "jz .unconditional\n"        Note: Jump if empty
        "\n"                         Note: Conditional jump - determine condition code
        "lea rdi, [je_str]\n"        Note: Load JE string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_je\n"                Note: Jump if equal
        "\n"                         Note: Check JNE
        "lea rdi, [jne_str]\n"       Note: Load JNE string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_jne\n"               Note: Jump if equal
        "\n"                         Note: Check JL
        "lea rdi, [jl_str]\n"        Note: Load JL string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_jl\n"                Note: Jump if equal
        "\n"                         Note: Check JLE
        "lea rdi, [jle_str]\n"       Note: Load JLE string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_jle\n"               Note: Jump if equal
        "\n"                         Note: Check JG
        "lea rdi, [jg_str]\n"        Note: Load JG string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_jg\n"                Note: Jump if equal
        "\n"                         Note: Check JGE
        "lea rdi, [jge_str]\n"       Note: Load JGE string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_jge\n"               Note: Jump if equal
        "\n"                         Note: Unconditional jump
        ".unconditional:\n"          Note: Unconditional jump label
        "mov word [inst_opcode], 0xE9\n" Note: JMP rel32 opcode
        "mov byte [inst_opcode_len], 1\n" Note: Opcode length
        "jmp .set_displacement\n"    Note: Jump to set displacement
        "\n"                         Note: Conditional jump labels
        ".is_je:\n"                  Note: JE label
        "mov word [inst_opcode], 0x840F\n" Note: JE rel32 opcode
        "mov byte [inst_opcode_len], 2\n" Note: Opcode length
        "jmp .set_displacement\n"    Note: Jump to set displacement
        "\n"                         Note: JNE
        ".is_jne:\n"                 Note: JNE label
        "mov word [inst_opcode], 0x850F\n" Note: JNE rel32 opcode
        "mov byte [inst_opcode_len], 2\n" Note: Opcode length
        "jmp .set_displacement\n"    Note: Jump to set displacement
        "\n"                         Note: JL
        ".is_jl:\n"                  Note: JL label
        "mov word [inst_opcode], 0x8C0F\n" Note: JL rel32 opcode
        "mov byte [inst_opcode_len], 2\n" Note: Opcode length
        "jmp .set_displacement\n"    Note: Jump to set displacement
        "\n"                         Note: JLE
        ".is_jle:\n"                 Note: JLE label
        "mov word [inst_opcode], 0x8E0F\n" Note: JLE rel32 opcode
        "mov byte [inst_opcode_len], 2\n" Note: Opcode length
        "jmp .set_displacement\n"    Note: Jump to set displacement
        "\n"                         Note: JG
        ".is_jg:\n"                  Note: JG label
        "mov word [inst_opcode], 0x8F0F\n" Note: JG rel32 opcode
        "mov byte [inst_opcode_len], 2\n" Note: Opcode length
        "jmp .set_displacement\n"    Note: Jump to set displacement
        "\n"                         Note: JGE
        ".is_jge:\n"                 Note: JGE label
        "mov word [inst_opcode], 0x8D0F\n" Note: JGE rel32 opcode
        "mov byte [inst_opcode_len], 2\n" Note: Opcode length
        "\n"                         Note: Set displacement
        ".set_displacement:\n"       Note: Set displacement label
        "mov eax, %1\n"              Note: Load target value
        "mov [inst_displacement], eax\n" Note: Store displacement
        "mov byte [inst_disp_len], 4\n" Note: Set displacement length
        :
        : "r"(condition), "r"(target)
        : "rax", "rdi", "rsi", "memory"
    End Assembly
    
    Return inst
End Process

Process called "encode_call" that takes target as Pointer returns InstructionFormat:
    Note: Encode CALL instruction
    
    @Implementation
    CALL can be direct (relative), indirect (register), or indirect (memory).
    This handles the most common direct and register indirect forms.
    @End Implementation
    
    Let inst be InstructionFormat
    
    Note: Check if target is register or address
    Let is_reg be is_register(target)
    
    If is_reg:
        Note: CALL register (indirect)
        Set inst.opcode to 0xFF
        Set inst.opcode_length to 1
        Set inst.has_modrm to true
        
        Let reg_enc be MachineCode.get_register_encoding(target)
        Set inst.modrm_byte to 0xD0 plus reg_enc  Note: mod=11, reg=010, r/m=reg
    Otherwise:
        Note: CALL relative
        Set inst.opcode to 0xE8
        Set inst.opcode_length to 1
        Set inst.displacement to parse_address(target)
        Set inst.disp_length to 4
    End If
    
    Return inst
End Process

Process called "encode_push_pop" that takes is_push as Boolean, reg as Pointer returns InstructionFormat:
    Note: Encode PUSH/POP instructions
    
    @Implementation
    PUSH and POP use single-byte opcodes for common registers.
    Extended registers (R8-R15) require REX prefix.
    @End Implementation
    
    Let inst be InstructionFormat
    
    Let reg_enc be MachineCode.get_register_encoding(reg)
    Let needs_rex be needs_extended_encoding(reg)
    
    If needs_rex:
        Set inst.rex_prefix to 0x41  Note: REX.B for extended registers
    End If
    
    If is_push:
        Set inst.opcode to 0x50 plus (reg_enc bitwise_and 7)
    Otherwise:
        Set inst.opcode to 0x58 plus (reg_enc bitwise_and 7)
    End If
    
    Set inst.opcode_length to 1
    
    Return inst
End Process

Process called "encode_lea" that takes dest as Pointer, addr_mode as AddressingMode returns InstructionFormat:
    Note: Encode LEA (Load Effective Address)
    
    @Implementation
    LEA calculates addresses without memory access, useful for
    complex address calculations and arithmetic operations.
    @End Implementation
    
    Let inst be InstructionFormat
    
    Set inst.rex_prefix to 0x48  Note: LEA typically uses 64-bit addressing
    Set inst.opcode to 0x8D
    Set inst.opcode_length to 1
    Set inst.has_modrm to true
    
    Let dest_enc be MachineCode.get_register_encoding(dest)
    
    Note: Build ModR/M byte based on addressing mode
    If addr_mode.mode_type equals 0:  Note: Register direct (unusual for LEA)
        Set inst.modrm_byte to 0xC0 plus (dest_enc times 8) plus addr_mode.base_reg
    Otherwise:
        Note: Memory addressing
        Let mod_bits as Integer
        If addr_mode.displacement equals 0:
            Set mod_bits to 0x00
        Otherwise:
            If addr_mode.displacement is greater than or equal to -128 and addr_mode.displacement is less than or equal to 127:
                Set mod_bits to 0x40
                Set inst.disp_length to 1
            Otherwise:
                Set mod_bits to 0x80
                Set inst.disp_length to 4
            End If
        End If
        
        Set inst.modrm_byte to mod_bits plus (dest_enc times 8) plus addr_mode.base_reg
        Set inst.displacement to addr_mode.displacement
        
        Note: Check if SIB byte needed
        If addr_mode.index_reg is not equal to -1:
            Set inst.has_sib to true
            Let scale_bits be get_scale_encoding(addr_mode.scale)
            Set inst.sib_byte to (scale_bits times 64) plus (addr_mode.index_reg times 8) plus addr_mode.base_reg
        End If
    End If
    
    Return inst
End Process

Process called "encode_cmp_test" that takes is_test as Boolean, op1 as Pointer, op2 as Pointer returns InstructionFormat:
    Note: Encode CMP or TEST instruction
    
    @Implementation
    CMP and TEST set flags without modifying operands.
    TEST uses AND operation, CMP uses subtraction.
    @End Implementation
    
    Let inst be InstructionFormat
    
    Set inst.rex_prefix to 0x48  Note: Assume 64-bit comparison
    
    If is_test:
        Set inst.opcode to 0x85  Note: TEST r/m, r
    Otherwise:
        Set inst.opcode to 0x39  Note: CMP r/m, r
    End If
    
    Set inst.opcode_length to 1
    Set inst.has_modrm to true
    
    Let op1_enc be MachineCode.get_register_encoding(op1)
    Let op2_enc be MachineCode.get_register_encoding(op2)
    
    Set inst.modrm_byte to 0xC0 plus (op2_enc times 8) plus op1_enc
    
    Return inst
End Process

Process called "write_instruction" that takes inst as InstructionFormat, buffer as Pointer returns Integer:
    Note: Write encoded instruction to buffer
    
    @Implementation
    Assembles all instruction components in correct order:
    legacy prefixes, REX, opcode, ModR/M, SIB, displacement, immediate.
    @End Implementation
    
    Let offset be 0
    
    Note: Write legacy prefixes if present
    If inst.legacy_prefixes is not equal to 0:
        Inline Assembly:
            "mov byte [%0], %1\n"        Note: Write legacy prefix
            :
            : "r"(buffer), "r"(inst.legacy_prefixes)
            : "memory"
        End Assembly
        Set offset to offset plus 1
    End If
    
    Note: Write REX prefix if present
    If inst.rex_prefix is not equal to 0:
        Inline Assembly:
            "mov byte [%0 + %1], %2\n"   Note: Write REX prefix
            :
            : "r"(buffer), "r"(offset), "r"(inst.rex_prefix)
            : "memory"
        End Assembly
        Set offset to offset plus 1
    End If
    
    Note: Write opcode
    If inst.opcode_length equals 1:
        Inline Assembly:
            "mov byte [%0 + %1], %2\n"   Note: Write 1-byte opcode
            :
            : "r"(buffer), "r"(offset), "r"(inst.opcode)
            : "memory"
        End Assembly
        Set offset to offset plus 1
    Otherwise:
        If inst.opcode_length equals 2:
            Inline Assembly:
                "mov word [%0 + %1], %2\n"   Note: Write 2-byte opcode
                :
                : "r"(buffer), "r"(offset), "r"(inst.opcode)
                : "memory"
            End Assembly
            Set offset to offset plus 2
        Otherwise:
            If inst.opcode_length equals 3:
                Inline Assembly:
                    "mov eax, %2\n"              Note: Load 3-byte opcode
                    "mov [%0 + %1], ax\n"        Note: Write first 2 bytes
                    "shr eax, 16\n"             Note: Shift to get third byte
                    "mov [%0 + %1 + 2], al\n"    Note: Write third byte
                    :
                    : "r"(buffer), "r"(offset), "r"(inst.opcode)
                    : "rax", "memory"
                End Assembly
                Set offset to offset plus 3
            End If
        End If
    End If
    
    Note: Write ModR/M byte if present
    If inst.has_modrm:
        Inline Assembly:
            "mov byte [%0 + %1], %2\n"   Note: Write ModR/M byte
            :
            : "r"(buffer), "r"(offset), "r"(inst.modrm_byte)
            : "memory"
        End Assembly
        Set offset to offset plus 1
    End If
    
    Note: Write SIB byte if present
    If inst.has_sib:
        Inline Assembly:
            "mov byte [%0 + %1], %2\n"   Note: Write SIB byte
            :
            : "r"(buffer), "r"(offset), "r"(inst.sib_byte)
            : "memory"
        End Assembly
        Set offset to offset plus 1
    End If
    
    Note: Write displacement if present
    If inst.disp_length is greater than 0:
        Match inst.disp_length:
            When 1:
                Inline Assembly:
                    "mov byte [%0 + %1], %2\n"   Note: Write 1-byte displacement
                    :
                    : "r"(buffer), "r"(offset), "r"(inst.displacement)
                    : "memory"
                End Assembly
            When 2:
                Inline Assembly:
                    "mov word [%0 + %1], %2\n"   Note: Write 2-byte displacement
                    :
                    : "r"(buffer), "r"(offset), "r"(inst.displacement)
                    : "memory"
                End Assembly
            When 4:
                Inline Assembly:
                    "mov dword [%0 + %1], %2\n"  Note: Write 4-byte displacement
                    :
                    : "r"(buffer), "r"(offset), "r"(inst.displacement)
                    : "memory"
                End Assembly
        End Match
        Set offset to offset plus inst.disp_length
    End If
    
    Note: Write immediate if present
    If inst.imm_length is greater than 0:
        Match inst.imm_length:
            When 1:
                Inline Assembly:
                    "mov byte [%0 + %1], %2\n"   Note: Write 1-byte immediate
                    :
                    : "r"(buffer), "r"(offset), "r"(inst.immediate)
                    : "memory"
                End Assembly
            When 2:
                Inline Assembly:
                    "mov word [%0 + %1], %2\n"   Note: Write 2-byte immediate
                    :
                    : "r"(buffer), "r"(offset), "r"(inst.immediate)
                    : "memory"
                End Assembly
            When 4:
                Inline Assembly:
                    "mov dword [%0 + %1], %2\n"  Note: Write 4-byte immediate
                    :
                    : "r"(buffer), "r"(offset), "r"(inst.immediate)
                    : "memory"
                End Assembly
            When 8:
                Inline Assembly:
                    "mov qword [%0 + %1], %2\n"  Note: Write 8-byte immediate
                    :
                    : "r"(buffer), "r"(offset), "r"(inst.immediate)
                    : "memory"
                End Assembly
        End Match
        Set offset to offset plus inst.imm_length
    End If
    
    Return offset
End Process

Process called "get_scale_encoding" that takes scale as Integer returns Integer:
    Note: Convert scale factor to encoding bits
    
    @Implementation
    Scale factors in SIB byte are encoded as:
    1 = 00, 2 = 01, 4 = 10, 8 = 11
    @End Implementation
    
    Match scale:
        When 1:
            Return 0
        When 2:
            Return 1
        When 4:
            Return 2
        When 8:
            Return 3
        Otherwise:
            Return 0  Note: Default to scale of 1
    End Match
End Process

Note: Helper functions for operand parsing
Process called "is_register" that takes operand as Pointer returns Boolean:
    Note: Check if operand is a register name
    
    @Implementation
    Registers start with 'r' or 'e' (rax, eax) or are special names (sp, bp).
    This is a heuristic check for the most common cases.
    @End Implementation
    
    Inline Assembly:
        "mov rsi, %1\n"              Note: Load operand string
        "mov al, [rsi]\n"            Note: Load first character
        "cmp al, 'r'\n"              Note: Check for 'r' (rax, rbx, etc)
        "je .is_reg\n"               Note: Jump if register
        "cmp al, 'e'\n"              Note: Check for 'e' (eax, ebx, etc)
        "je .is_reg\n"               Note: Jump if register
        "cmp al, 's'\n"              Note: Check for 's' (sp)
        "je .check_sp\n"             Note: Jump to check sp
        "cmp al, 'b'\n"              Note: Check for 'b' (bp)
        "je .check_bp\n"             Note: Jump to check bp
        "xor al, al\n"               Note: Not a register
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Check SP
        ".check_sp:\n"               Note: Check SP label
        "mov al, [rsi+1]\n"          Note: Load second character
        "cmp al, 'p'\n"              Note: Check for 'p'
        "sete al\n"                  Note: Set if equal
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Check BP
        ".check_bp:\n"               Note: Check BP label
        "mov al, [rsi+1]\n"          Note: Load second character
        "cmp al, 'p'\n"              Note: Check for 'p'
        "sete al\n"                  Note: Set if equal
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Is register
        ".is_reg:\n"                 Note: Is register label
        "mov al, 1\n"                Note: Set result to true
        ".done:\n"                   Note: End label
        "movzx %0, al\n"             Note: Store result
        : "=r"(result)
        : "r"(operand)
        : "rax", "rsi", "flags"
    End Assembly
    
    Let result as Boolean
    Return result
End Process

Process called "is_immediate" that takes operand as Pointer returns Boolean:
    Note: Check if operand is immediate value
    
    @Implementation
    Immediates start with digits or minus sign for negative values.
    Also handles hex values starting with 0x.
    @End Implementation
    
    Inline Assembly:
        "mov rsi, %1\n"              Note: Load operand string
        "mov al, [rsi]\n"            Note: Load first character
        "cmp al, '0'\n"              Note: Check if >= '0'
        "jl .check_minus\n"          Note: Jump if less
        "cmp al, '9'\n"              Note: Check if <= '9'
        "jle .is_imm\n"              Note: Jump if immediate
        "\n"                         Note: Check minus sign
        ".check_minus:\n"            Note: Check minus label
        "cmp al, '-'\n"              Note: Check for minus
        "je .is_imm\n"               Note: Jump if immediate
        "xor al, al\n"               Note: Not immediate
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Is immediate
        ".is_imm:\n"                 Note: Is immediate label
        "mov al, 1\n"                Note: Set result to true
        ".done:\n"                   Note: End label
        "movzx %0, al\n"             Note: Store result
        : "=r"(result)
        : "r"(operand)
        : "rax", "rsi", "flags"
    End Assembly
    
    Let result as Boolean
    Return result
End Process

Process called "parse_immediate" that takes operand as Pointer returns Integer:
    Note: Parse immediate value from string
    
    @Implementation
    Converts decimal or hexadecimal string to integer value.
    Handles negative values and 0x prefix for hex.
    @End Implementation
    
    Inline Assembly:
        "mov rsi, %1\n"              Note: Load operand string
        "xor rax, rax\n"             Note: Clear result
        "xor rcx, rcx\n"             Note: Clear temp register
        "xor rdx, rdx\n"             Note: Clear sign flag
        "\n"                         Note: Check for minus sign
        "mov cl, [rsi]\n"            Note: Load first character
        "cmp cl, '-'\n"              Note: Check for minus
        "jne .check_hex\n"           Note: Jump if not minus
        "inc rsi\n"                  Note: Skip minus sign
        "mov dl, 1\n"                Note: Set negative flag
        "\n"                         Note: Check for hex prefix
        ".check_hex:\n"              Note: Check hex label
        "mov cl, [rsi]\n"            Note: Load character
        "cmp cl, '0'\n"              Note: Check for '0'
        "jne .parse_decimal\n"       Note: Jump if not hex
        "mov cl, [rsi+1]\n"          Note: Load next character
        "cmp cl, 'x'\n"              Note: Check for 'x'
        "jne .parse_decimal\n"       Note: Jump if not hex
        "add rsi, 2\n"               Note: Skip '0x' prefix
        "\n"                         Note: Parse hex digits
        ".parse_hex:\n"              Note: Parse hex label
        "mov cl, [rsi]\n"            Note: Load character
        "test cl, cl\n"              Note: Check for null
        "jz .apply_sign\n"           Note: Jump if end
        "cmp cl, '0'\n"              Note: Check if >= '0'
        "jl .done\n"                 Note: Jump if invalid
        "cmp cl, '9'\n"              Note: Check if <= '9'
        "jle .hex_digit\n"           Note: Jump if digit
        "cmp cl, 'a'\n"              Note: Check if >= 'a'
        "jl .check_upper\n"          Note: Jump to check upper
        "cmp cl, 'f'\n"              Note: Check if <= 'f'
        "jg .done\n"                 Note: Jump if invalid
        "sub cl, 'a' - 10\n"         Note: Convert a-f to 10-15
        "jmp .add_hex\n"             Note: Jump to add
        ".check_upper:\n"            Note: Check upper case
        "cmp cl, 'A'\n"              Note: Check if >= 'A'
        "jl .done\n"                 Note: Jump if invalid
        "cmp cl, 'F'\n"              Note: Check if <= 'F'
        "jg .done\n"                 Note: Jump if invalid
        "sub cl, 'A' - 10\n"         Note: Convert A-F to 10-15
        "jmp .add_hex\n"             Note: Jump to add
        ".hex_digit:\n"              Note: Hex digit label
        "sub cl, '0'\n"              Note: Convert 0-9 to value
        ".add_hex:\n"                Note: Add hex digit
        "shl rax, 4\n"               Note: Shift result left 4 bits
        "add rax, rcx\n"             Note: Add digit
        "inc rsi\n"                  Note: Next character
        "jmp .parse_hex\n"           Note: Continue parsing
        "\n"                         Note: Parse decimal
        ".parse_decimal:\n"          Note: Parse decimal label
        "mov cl, [rsi]\n"            Note: Load character
        "test cl, cl\n"              Note: Check for null
        "jz .apply_sign\n"           Note: Jump if end
        "cmp cl, '0'\n"              Note: Check if >= '0'
        "jl .done\n"                 Note: Jump if invalid
        "cmp cl, '9'\n"              Note: Check if <= '9'
        "jg .done\n"                 Note: Jump if invalid
        "sub cl, '0'\n"              Note: Convert to digit
        "imul rax, 10\n"             Note: Multiply by 10
        "add rax, rcx\n"             Note: Add digit
        "inc rsi\n"                  Note: Next character
        "jmp .parse_decimal\n"       Note: Continue parsing
        "\n"                         Note: Apply sign
        ".apply_sign:\n"             Note: Apply sign label
        "test dl, dl\n"              Note: Check negative flag
        "jz .done\n"                 Note: Jump if positive
        "neg rax\n"                  Note: Negate result
        "\n"                         Note: Done
        ".done:\n"                   Note: End label
        "mov %0, rax\n"              Note: Store result
        : "=r"(result)
        : "r"(operand)
        : "rax", "rcx", "rdx", "rsi", "flags"
    End Assembly
    
    Let result as Integer
    Return result
End Process

Process called "parse_address" that takes operand as Pointer returns Integer:
    @Reasoning
    Parse address operand handling numeric values, labels, and symbols with full resolution.
    Supports immediate values, symbol lookups, and complex addressing modes for complete
    x86_64 instruction parsing without placeholder limitations.
    @End Reasoning
    
    @Implementation
    Comprehensive address parsing supporting:
    1. Immediate numeric values (decimal, hex)
    2. Symbol name resolution via symbol table lookup
    3. Label references with forward/backward resolution
    4. Complex addressing expressions
    @End Implementation
    
    Note: Validate input operand
    If is_null_pointer(operand):
        Return 0
    End If
    
    Note: Check first character to determine address type
    Let first_char be load_byte_at_offset(operand, 0)
    
    Note: Handle numeric immediate values (0-9, -, +)
    If first_char >= 48:  Note: ASCII '0'
        If first_char <= 57:  Note: ASCII '9'
            Return parse_immediate(operand)
        End If
    End If
    If first_char = 45:  Note: ASCII '-'
        Return parse_immediate(operand)
    End If
    If first_char = 43:  Note: ASCII '+'
        Return parse_immediate(operand)
    End If
    
    Note: Handle hexadecimal values starting with 0x
    If first_char = 48:  Note: ASCII '0'
        Let second_char be load_byte_at_offset(operand, 1)
        If second_char = 120:  Note: ASCII 'x'  
            Return parse_immediate(operand)
        End If
    End If
    
    Note: Handle symbol and label references
    Let symbol_address be lookup_symbol_address(operand)
    If symbol_address is not 0:
        Return symbol_address
    End If
    
    Note: Handle label references  
    Let label_address be lookup_label_address(operand)
    If label_address is not 0:
        Return label_address
    End If
    
    Note: Handle global variable references
    Let global_address be lookup_global_address(operand)
    If global_address is not 0:
        Return global_address
    End If
    
    Note: Handle function name references
    Let function_address be lookup_function_address(operand)
    If function_address is not 0:
        Return function_address
    End If
    
    Note: Handle complex addressing expressions [base+offset*scale]
    If first_char = 91:  Note: ASCII '['
        Return parse_complex_address_expression(operand)
    End If
    
    Note: If no resolution possible, try parsing as immediate
    Return parse_immediate(operand)
End Process

Process called "needs_extended_encoding" that takes reg as Pointer returns Boolean:
    Note: Check if register needs extended encoding
    
    @Implementation
    R8-R15 registers and their sub-registers require REX prefix
    or extended encoding in various instruction forms.
    @End Implementation
    
    Inline Assembly:
        "mov rsi, %1\n"              Note: Load register string
        "mov al, [rsi]\n"            Note: Load first character
        "cmp al, 'r'\n"              Note: Check for 'r'
        "jne .no_extend\n"           Note: Jump if not r-register
        "mov al, [rsi+1]\n"          Note: Load second character
        "cmp al, '8'\n"              Note: Check if >= '8'
        "jl .no_extend\n"            Note: Jump if less
        "cmp al, '9'\n"              Note: Check if <= '9' (r8/r9)
        "jle .needs_extend\n"        Note: Jump if r8 or r9
        "cmp al, '1'\n"              Note: Check for '1' (r10-r15)
        "jne .no_extend\n"           Note: Jump if not
        "\n"                         Note: Needs extended encoding
        ".needs_extend:\n"           Note: Needs extend label
        "mov al, 1\n"                Note: Set result to true
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: No extended encoding
        ".no_extend:\n"              Note: No extend label
        "xor al, al\n"               Note: Set result to false
        ".done:\n"                   Note: End label
        "movzx %0, al\n"             Note: Store result
        : "=r"(result)
        : "r"(reg)
        : "rax", "rsi", "flags"
    End Assembly
    
    Let result as Boolean
    Return result
End Process

Note: String constants for instruction mnemonics
Inline Assembly:
    "section .rodata\n"           Note: Read-only data section
    "add_str: db 'add', 0\n"      Note: ADD mnemonic
    "sub_str: db 'sub', 0\n"      Note: SUB mnemonic
    "and_str: db 'and', 0\n"      Note: AND mnemonic
    "or_str:  db 'or', 0\n"       Note: OR mnemonic
    "xor_str: db 'xor', 0\n"      Note: XOR mnemonic
    "je_str:  db 'je', 0\n"       Note: JE mnemonic
    "jne_str: db 'jne', 0\n"      Note: JNE mnemonic
    "jl_str:  db 'jl', 0\n"       Note: JL mnemonic
    "jle_str: db 'jle', 0\n"      Note: JLE mnemonic
    "jg_str:  db 'jg', 0\n"       Note: JG mnemonic
    "jge_str: db 'jge', 0\n"      Note: JGE mnemonic
    :
    :
    : "memory"
End Assembly