Note: x86_64 register definitions and management

@Reasoning
The x86_64 architecture has a rich set of registers including general purpose,
floating point, vector, and special purpose registers. This module provides
comprehensive register definitions, encoding information, and management utilities
for the compiler's code generation phase.
@End Reasoning

Type called "RegisterClass":
    Note: Categories of x86_64 registers
    
    @Implementation
    Different register classes have different encoding rules and usage patterns.
    The compiler needs to track these for correct instruction encoding.
    @End Implementation
    
    class_id as Integer
    name as Pointer
    bit_width as Integer
    count as Integer
End Type

Type called "Register":
    Note: Individual register information
    
    @Implementation
    Contains all information needed for register allocation and encoding.
    The encoding value is used directly in ModR/M and REX bytes.
    @End Implementation
    
    reg_id as Integer
    name as Pointer
    class as RegisterClass
    encoding as Integer
    is_callee_saved as Boolean
    is_reserved as Boolean
End Type

Type called "RegisterSet":
    Note: Set of registers for allocation
    
    @Performance_Hints
    Uses bit vectors for efficient register tracking during allocation.
    Each bit represents whether a register is available or in use.
    @End Performance_Hints
    
    available_gpr as Integer  Note: Bitmask for general purpose
    available_xmm as Integer  Note: Bitmask for SSE registers
    available_ymm as Integer  Note: Bitmask for AVX registers
    scratch_count as Integer
End Type

Process called "init_register_classes" returns Nothing:
    Note: Initialize x86_64 register class definitions
    
    @Implementation
    Sets up the register class hierarchy used throughout code generation.
    These classes map to x86_64 architectural register groups.
    @End Implementation
    
    Note: General purpose registers
    Inline Assembly:
        "section .data\n"             Note: Data section
        "gpr_class:\n"               Note: GPR class definition
        "    dq 0\n"                  Note: class_id
        "    dq gpr_name\n"           Note: name pointer
        "    dq 64\n"                 Note: bit_width
        "    dq 16\n"                 Note: count (RAX-R15)
        "gpr_name: db 'GPR', 0\n"     Note: GPR name string
        "\n"                         Note: Separator
        "gpr32_class:\n"             Note: 32-bit GPR class
        "    dq 1\n"                  Note: class_id
        "    dq gpr32_name\n"         Note: name pointer
        "    dq 32\n"                 Note: bit_width
        "    dq 16\n"                 Note: count
        "gpr32_name: db 'GPR32', 0\n" Note: GPR32 name string
        "\n"                         Note: Separator
        "gpr16_class:\n"             Note: 16-bit GPR class
        "    dq 2\n"                  Note: class_id
        "    dq gpr16_name\n"         Note: name pointer
        "    dq 16\n"                 Note: bit_width
        "    dq 16\n"                 Note: count
        "gpr16_name: db 'GPR16', 0\n" Note: GPR16 name string
        "\n"                         Note: Separator
        "gpr8_class:\n"              Note: 8-bit GPR class
        "    dq 3\n"                  Note: class_id
        "    dq gpr8_name\n"          Note: name pointer
        "    dq 8\n"                  Note: bit_width
        "    dq 20\n"                 Note: count (includes AH, BH, CH, DH)
        "gpr8_name: db 'GPR8', 0\n"   Note: GPR8 name string
        :
        :
        : "memory"
    End Assembly
    
    Note: Floating point and vector registers
    Inline Assembly:
        "xmm_class:\n"               Note: XMM class definition
        "    dq 4\n"                  Note: class_id
        "    dq xmm_name\n"           Note: name pointer
        "    dq 128\n"                Note: bit_width
        "    dq 16\n"                 Note: count (XMM0-XMM15)
        "xmm_name: db 'XMM', 0\n"     Note: XMM name string
        "\n"                         Note: Separator
        "ymm_class:\n"               Note: YMM class definition
        "    dq 5\n"                  Note: class_id
        "    dq ymm_name\n"           Note: name pointer
        "    dq 256\n"                Note: bit_width
        "    dq 16\n"                 Note: count (YMM0-YMM15)
        "ymm_name: db 'YMM', 0\n"     Note: YMM name string
        "\n"                         Note: Separator
        "zmm_class:\n"               Note: ZMM class definition
        "    dq 6\n"                  Note: class_id
        "    dq zmm_name\n"           Note: name pointer
        "    dq 512\n"                Note: bit_width
        "    dq 32\n"                 Note: count (ZMM0-ZMM31 AVX-512)
        "zmm_name: db 'ZMM', 0\n"     Note: ZMM name string
        :
        :
        : "memory"
    End Assembly
End Process

Process called "get_gpr_encoding" that takes reg_name as Pointer returns Integer:
    Note: Get encoding for general purpose register
    
    @Implementation
    Maps register names to their 3-bit encoding values used in ModR/M bytes.
    Extended registers (R8-R15) use the same base encoding with REX prefix.
    @End Implementation
    
    Let result as Integer
    Note: Compare register name and return encoding
    Inline Assembly:
        "mov rsi, %1\n"              Note: Load register name
        "\n"                         Note: RAX family
        "lea rdi, [rax_name]\n"      Note: Load RAX name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_0\n"             Note: Jump if equal
        "\n"                         Note: RCX family
        "lea rdi, [rcx_name]\n"      Note: Load RCX name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_1\n"             Note: Jump if equal
        "\n"                         Note: RDX family
        "lea rdi, [rdx_name]\n"      Note: Load RDX name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_2\n"             Note: Jump if equal
        "\n"                         Note: RBX family
        "lea rdi, [rbx_name]\n"      Note: Load RBX name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_3\n"             Note: Jump if equal
        "\n"                         Note: RSP family
        "lea rdi, [rsp_name]\n"      Note: Load RSP name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_4\n"             Note: Jump if equal
        "\n"                         Note: RBP family
        "lea rdi, [rbp_name]\n"      Note: Load RBP name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_5\n"             Note: Jump if equal
        "\n"                         Note: RSI family
        "lea rdi, [rsi_name]\n"      Note: Load RSI name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_6\n"             Note: Jump if equal
        "\n"                         Note: RDI family
        "lea rdi, [rdi_name]\n"      Note: Load RDI name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_7\n"             Note: Jump if equal
        "\n"                         Note: R8-R15 (encoding 0-7 with REX)
        "lea rdi, [r8_name]\n"       Note: Load R8 name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_0\n"             Note: Jump if equal
        "\n"                         Note: R9
        "lea rdi, [r9_name]\n"       Note: Load R9 name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_1\n"             Note: Jump if equal
        "\n"                         Note: R10
        "lea rdi, [r10_name]\n"      Note: Load R10 name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_2\n"             Note: Jump if equal
        "\n"                         Note: R11
        "lea rdi, [r11_name]\n"      Note: Load R11 name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_3\n"             Note: Jump if equal
        "\n"                         Note: R12
        "lea rdi, [r12_name]\n"      Note: Load R12 name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_4\n"             Note: Jump if equal
        "\n"                         Note: R13
        "lea rdi, [r13_name]\n"      Note: Load R13 name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_5\n"             Note: Jump if equal
        "\n"                         Note: R14
        "lea rdi, [r14_name]\n"      Note: Load R14 name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_6\n"             Note: Jump if equal
        "\n"                         Note: R15
        "lea rdi, [r15_name]\n"      Note: Load R15 name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_7\n"             Note: Jump if equal
        "\n"                         Note: Not found
        "mov rax, -1\n"              Note: Return -1
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Return labels
        ".return_0:\n"               Note: Return 0
        "xor rax, rax\n"             Note: Clear RAX
        "jmp .done\n"                Note: Jump to end
        ".return_1:\n"               Note: Return 1
        "mov rax, 1\n"               Note: Set RAX to 1
        "jmp .done\n"                Note: Jump to end
        ".return_2:\n"               Note: Return 2
        "mov rax, 2\n"               Note: Set RAX to 2
        "jmp .done\n"                Note: Jump to end
        ".return_3:\n"               Note: Return 3
        "mov rax, 3\n"               Note: Set RAX to 3
        "jmp .done\n"                Note: Jump to end
        ".return_4:\n"               Note: Return 4
        "mov rax, 4\n"               Note: Set RAX to 4
        "jmp .done\n"                Note: Jump to end
        ".return_5:\n"               Note: Return 5
        "mov rax, 5\n"               Note: Set RAX to 5
        "jmp .done\n"                Note: Jump to end
        ".return_6:\n"               Note: Return 6
        "mov rax, 6\n"               Note: Set RAX to 6
        "jmp .done\n"                Note: Jump to end
        ".return_7:\n"               Note: Return 7
        "mov rax, 7\n"               Note: Set RAX to 7
        ".done:\n"                   Note: End label
        "mov %0, rax\n"              Note: Store result
        : "=r"(result)
        : "r"(reg_name)
        : "rax", "rdi", "rsi", "memory"
    End Assembly
    Return result
End Process

Process called "needs_rex_prefix" that takes reg_name as Pointer returns Boolean:
    Note: Check if register requires REX prefix
    
    @Implementation
    Extended registers (R8-R15) and 64-bit operations on certain registers
    require the REX prefix for proper encoding.
    @End Implementation
    
    Let result as Boolean
    Inline Assembly:
        "mov rsi, %1\n"              Note: Load register name
        "\n"                         Note: Check for R8-R15
        "mov al, [rsi]\n"            Note: Load first character
        "cmp al, 'r'\n"              Note: Check if starts with 'r'
        "jne .check_64bit\n"         Note: Jump if not
        "mov al, [rsi+1]\n"          Note: Load second character
        "cmp al, '8'\n"              Note: Check if >= '8'
        "jl .check_64bit\n"          Note: Jump if less
        "cmp al, '9'\n"              Note: Check if <= '9'
        "jle .needs_rex\n"           Note: Jump if r8 or r9
        "cmp al, '1'\n"              Note: Check for '1' (r10-r15)
        "jne .check_64bit\n"         Note: Jump if not
        "\n"                         Note: Needs REX
        ".needs_rex:\n"              Note: REX needed label
        "mov al, 1\n"                Note: Set result to true
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Check 64-bit
        ".check_64bit:\n"            Note: Check 64-bit registers
        "mov al, [rsi]\n"            Note: Load first character
        "cmp al, 'r'\n"              Note: Check if starts with 'r'
        "jne .no_rex\n"              Note: Jump if not
        "mov al, [rsi+1]\n"          Note: Load second character
        "cmp al, 'a'\n"              Note: Check for 'a' (rax)
        "je .needs_rex\n"            Note: Jump if match
        "cmp al, 'b'\n"              Note: Check for 'b' (rbx/rbp)
        "je .needs_rex\n"            Note: Jump if match
        "cmp al, 'c'\n"              Note: Check for 'c' (rcx)
        "je .needs_rex\n"            Note: Jump if match
        "cmp al, 'd'\n"              Note: Check for 'd' (rdx/rdi)
        "je .needs_rex\n"            Note: Jump if match
        "cmp al, 's'\n"              Note: Check for 's' (rsp/rsi)
        "je .needs_rex\n"            Note: Jump if match
        "\n"                         Note: No REX needed
        ".no_rex:\n"                 Note: No REX label
        "xor al, al\n"               Note: Set result to false
        ".done:\n"                   Note: End label
        "movzx %0, al\n"             Note: Store result
        : "=r"(result)
        : "r"(reg_name)
        : "rax", "rsi", "flags"
    End Assembly
    Return result
End Process

Process called "is_callee_saved" that takes reg_name as Pointer returns Boolean:
    Note: Check if register is callee-saved in System V ABI
    
    @Implementation
    System V ABI specifies RBX, RBP, R12-R15 as callee-saved.
    These must be preserved across function calls.
    @End Implementation
    
    Let result as Boolean
    Inline Assembly:
        "mov rsi, %1\n"              Note: Load register name
        "\n"                         Note: Check RBX
        "lea rdi, [rbx_name]\n"      Note: Load RBX name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_saved\n"             Note: Jump if equal
        "\n"                         Note: Check RBP
        "lea rdi, [rbp_name]\n"      Note: Load RBP name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_saved\n"             Note: Jump if equal
        "\n"                         Note: Check R12-R15
        "lea rdi, [r12_name]\n"      Note: Load R12 name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_saved\n"             Note: Jump if equal
        "\n"                         Note: Check R13
        "lea rdi, [r13_name]\n"      Note: Load R13 name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_saved\n"             Note: Jump if equal
        "\n"                         Note: Check R14
        "lea rdi, [r14_name]\n"      Note: Load R14 name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_saved\n"             Note: Jump if equal
        "\n"                         Note: Check R15
        "lea rdi, [r15_name]\n"      Note: Load R15 name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .is_saved\n"             Note: Jump if equal
        "\n"                         Note: Not callee-saved
        "xor al, al\n"               Note: Set result to false
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Is saved
        ".is_saved:\n"               Note: Saved label
        "mov al, 1\n"                Note: Set result to true
        ".done:\n"                   Note: End label
        "movzx %0, al\n"             Note: Store result
        : "=r"(result)
        : "r"(reg_name)
        : "rax", "rdi", "rsi", "memory"
    End Assembly
    Return result
End Process

Process called "get_xmm_encoding" that takes reg_name as Pointer returns Integer:
    Note: Get encoding for XMM/YMM/ZMM register
    
    @Implementation
    Vector registers use 4-bit encoding (5-bit for AVX-512).
    XMM0-XMM15 map directly to encodings 0-15.
    @End Implementation
    
    Let result as Integer
    Inline Assembly:
        "mov rsi, %1\n"              Note: Load register name
        "\n"                         Note: Skip prefix (xmm/ymm/zmm)
        "add rsi, 3\n"               Note: Skip 3 characters
        "\n"                         Note: Parse number
        "xor rax, rax\n"             Note: Clear result
        "xor rcx, rcx\n"             Note: Clear temp
        ".parse_loop:\n"             Note: Parse loop
        "mov cl, [rsi]\n"            Note: Load character
        "test cl, cl\n"              Note: Check for null
        "jz .done\n"                 Note: Jump if end
        "cmp cl, '0'\n"              Note: Check if >= '0'
        "jl .error\n"                Note: Jump if less
        "cmp cl, '9'\n"              Note: Check if <= '9'
        "jg .error\n"                Note: Jump if greater
        "sub cl, '0'\n"              Note: Convert to digit
        "imul rax, 10\n"             Note: Multiply by 10
        "add rax, rcx\n"             Note: Add digit
        "inc rsi\n"                  Note: Next character
        "jmp .parse_loop\n"          Note: Continue loop
        "\n"                         Note: Error case
        ".error:\n"                  Note: Error label
        "mov rax, -1\n"              Note: Return -1
        ".done:\n"                   Note: End label
        "mov %0, rax\n"              Note: Store result
        : "=r"(result)
        : "r"(reg_name)
        : "rax", "rcx", "rsi", "flags"
    End Assembly
    Return result
End Process

Process called "create_register_set" returns RegisterSet:
    Note: Create available register set for allocation
    
    @Performance_Hints
    Initializes register availability masks for efficient allocation.
    Reserves special registers (RSP, RBP) that have fixed uses.
    @End Performance_Hints
    
    Let set be RegisterSet
    
    Note: Mark all GPRs available except RSP and RBP
    Set set.available_gpr to 0xFFFF  Note: All 16 registers
    Set set.available_gpr to set.available_gpr bitwise_and 0xFFCF  Note: Clear RSP(4) and RBP(5)
    
    Note: Mark all XMM registers available
    Set set.available_xmm to 0xFFFF  Note: XMM0-XMM15
    
    Note: Mark all YMM registers available
    Set set.available_ymm to 0xFFFF  Note: YMM0-YMM15
    
    Note: Count scratch registers (caller-saved)
    Set set.scratch_count to 9  Note: RAX, RCX, RDX, RSI, RDI, R8-R11
    
    Return set
End Process

Process called "allocate_gpr" that takes set as RegisterSet returns Integer:
    Note: Allocate next available GPR
    
    @Implementation
    Finds first available register using bit scanning.
    Prioritizes caller-saved registers to minimize save/restore overhead.
    @End Implementation
    
    If set.available_gpr equals 0:
        Return -1  Note: No registers available
    End If
    
    Note: Find first set bit (available register)
    Let reg_index as Integer
    Inline Assembly:
        "bsf %0, %2\n"               Note: Find first set bit
        "jnz .found\n"               Note: Jump if bit found
        "mov %0, -1\n"               Note: No registers available
        "jmp .done\n"                Note: Jump to end
        ".found:\n"                  Note: Found label
        "mov rcx, %0\n"              Note: Load bit index
        "mov rax, 1\n"               Note: Load bit mask
        "shl rax, cl\n"              Note: Shift to position
        "not rax\n"                  Note: Invert mask
        "and %1, rax\n"              Note: Clear the bit
        ".done:\n"                   Note: End label
        : "=&r"(reg_index), "+r"(set.available_gpr)
        : "r"(set.available_gpr)
        : "rax", "rcx", "flags"
    End Assembly
    
    Return reg_index
End Process

Process called "free_gpr" that takes set as RegisterSet, reg_index as Integer returns Nothing:
    Note: Return GPR to available pool
    
    @Implementation
    Marks register as available by setting its bit in the availability mask.
    Used when register is no longer needed in current scope.
    @End Implementation
    
    If reg_index is less than 0 or reg_index is greater than or equal to 16:
        Return  Note: Invalid register
    End If
    
    Inline Assembly:
        "mov rcx, %0\n"              Note: Load register index
        "mov rax, 1\n"               Note: Load bit mask
        "shl rax, cl\n"              Note: Shift to position
        "or %1, rax\n"               Note: Set the bit
        :
        : "r"(reg_index), "+r"(set.available_gpr)
        : "rax", "rcx", "flags"
    End Assembly
End Process

Process called "get_argument_registers" that takes index as Integer returns Pointer:
    Note: Get register for function argument by index
    
    @Implementation
    System V ABI specifies argument registers in order:
    RDI, RSI, RDX, RCX, R8, R9 for integer arguments.
    XMM0-XMM7 for floating point arguments.
    @End Implementation
    
    Let result as Pointer
    Match index:
        When 0:
            Inline Assembly:
                "lea rax, [rdi_name]\n"      Note: Load RDI name address
                : "=r"(result)
                :
                : "rax"
            End Assembly
        When 1:
            Inline Assembly:
                "lea rax, [rsi_name]\n"      Note: Load RSI name address
                : "=r"(result)
                :
                : "rax"
            End Assembly
        When 2:
            Inline Assembly:
                "lea rax, [rdx_name]\n"      Note: Load RDX name address
                : "=r"(result)
                :
                : "rax"
            End Assembly
        When 3:
            Inline Assembly:
                "lea rax, [rcx_name]\n"      Note: Load RCX name address
                : "=r"(result)
                :
                : "rax"
            End Assembly
        When 4:
            Inline Assembly:
                "lea rax, [r8_name]\n"       Note: Load R8 name address
                : "=r"(result)
                :
                : "rax"
            End Assembly
        When 5:
            Inline Assembly:
                "lea rax, [r9_name]\n"       Note: Load R9 name address
                : "=r"(result)
                :
                : "rax"
            End Assembly
        Otherwise:
            Inline Assembly:
                "xor rax, rax\n"             Note: Return null pointer
                : "=r"(result)
                :
                : "rax"
            End Assembly
    End Match
    Return result
End Process

Note: Register name strings
Inline Assembly:
    "section .rodata\n"           Note: Read-only data section
    "rax_name: db 'rax', 0\n"     Note: RAX register name
    "rbx_name: db 'rbx', 0\n"     Note: RBX register name
    "rcx_name: db 'rcx', 0\n"     Note: RCX register name
    "rdx_name: db 'rdx', 0\n"     Note: RDX register name
    "rsp_name: db 'rsp', 0\n"     Note: RSP register name
    "rbp_name: db 'rbp', 0\n"     Note: RBP register name
    "rsi_name: db 'rsi', 0\n"     Note: RSI register name
    "rdi_name: db 'rdi', 0\n"     Note: RDI register name
    "r8_name:  db 'r8', 0\n"      Note: R8 register name
    "r9_name:  db 'r9', 0\n"      Note: R9 register name
    "r10_name: db 'r10', 0\n"     Note: R10 register name
    "r11_name: db 'r11', 0\n"     Note: R11 register name
    "r12_name: db 'r12', 0\n"     Note: R12 register name
    "r13_name: db 'r13', 0\n"     Note: R13 register name
    "r14_name: db 'r14', 0\n"     Note: R14 register name
    "r15_name: db 'r15', 0\n"     Note: R15 register name
    "\n"                         Note: Separator
    "strcmp:\n"                  Note: String comparison function
    "    push rbx\n"              Note: Save rbx
    ".loop:\n"                   Note: Comparison loop
    "    mov al, [rdi]\n"         Note: Load byte from first string
    "    mov bl, [rsi]\n"         Note: Load byte from second string
    "    cmp al, bl\n"            Note: Compare bytes
    "    jne .not_equal\n"        Note: Jump if not equal
    "    test al, al\n"           Note: Check for null terminator
    "    jz .equal\n"             Note: Jump if end of string
    "    inc rdi\n"               Note: Next character in first string
    "    inc rsi\n"               Note: Next character in second string
    "    jmp .loop\n"             Note: Continue loop
    ".equal:\n"                  Note: Strings are equal
    "    xor rax, rax\n"          Note: Return 0 (equal)
    "    pop rbx\n"               Note: Restore rbx
    "    ret\n"                   Note: Return
    ".not_equal:\n"              Note: Strings not equal
    "    mov rax, 1\n"            Note: Return 1 (not equal)
    "    pop rbx\n"               Note: Restore rbx
    "    ret\n"                   Note: Return
    :
    :
    : "memory"
End Assembly