Note: System V AMD64 ABI calling convention implementation

Import "./registers.runa" as Registers

@Reasoning
The System V AMD64 ABI is the standard calling convention for Unix-like systems
on x86_64. It defines how functions pass parameters, return values, preserve
registers, and manage the stack. This module implements the complete convention
for the compiler's code generation phase.
@End Reasoning

Type called "CallFrame":
    Note: Function call frame information
    
    @Implementation
    Tracks all information needed to generate correct function prologue,
    epilogue, and parameter passing code according to System V ABI.
    @End Implementation
    
    param_count as Integer
    integer_params as Integer    Note: Count in registers (max 6)
    float_params as Integer      Note: Count in XMM registers (max 8)
    stack_params as Integer      Note: Count on stack
    local_space as Integer       Note: Space for local variables
    saved_regs as Integer        Note: Bitmask of callee-saved registers
    stack_alignment as Integer   Note: Required alignment (16 bytes)
    red_zone_used as Boolean     Note: Using 128-byte red zone
End Type

Type called "ParameterClass":
    Note: Parameter classification for ABI
    
    @Implementation
    System V ABI classifies parameters into INTEGER, SSE, MEMORY classes
    to determine how they are passed (register vs stack).
    @End Implementation
    
    class_type as Integer  Note: 0=INTEGER, 1=SSE, 2=MEMORY
    size as Integer
    alignment as Integer
    register_count as Integer  Note: Number of registers needed
End Type

Process called "classify_parameter" that takes type_size as Integer, is_float as Boolean returns ParameterClass:
    Note: Classify parameter according to System V ABI rules
    
    @Implementation
    Classification determines whether parameter goes in integer registers,
    SSE registers, or on the stack. Aggregates larger than 16 bytes go to memory.
    @End Implementation
    
    Let param_class be ParameterClass
    
    If is_float:
        Set param_class.class_type to 1  Note: SSE
        Set param_class.size to type_size
        Set param_class.alignment to type_size
        Set param_class.register_count to 1
    Otherwise:
        If type_size is less than or equal to 8:
            Set param_class.class_type to 0  Note: INTEGER
            Set param_class.size to type_size
            Set param_class.alignment to type_size
            Set param_class.register_count to 1
        Otherwise:
            If type_size is less than or equal to 16:
                Set param_class.class_type to 0  Note: INTEGER
                Set param_class.size to type_size
                Set param_class.alignment to 8
                Set param_class.register_count to 2
            Otherwise:
                Set param_class.class_type to 2  Note: MEMORY
                Set param_class.size to type_size
                Set param_class.alignment to 8
                Set param_class.register_count to 0
            End If
        End If
    End If
    
    Return param_class
End Process

Process called "setup_call_frame" that takes param_types as Pointer, param_count as Integer, local_size as Integer returns CallFrame:
    Note: Setup call frame for function
    
    @Implementation
    Analyzes parameters and local variables to determine stack layout
    and register usage according to System V ABI requirements.
    @End Implementation
    
    Let frame be CallFrame
    Set frame.param_count to param_count
    Set frame.integer_params to 0
    Set frame.float_params to 0
    Set frame.stack_params to 0
    Set frame.local_space to local_size
    
    Note: Process each parameter
    Let i be 0
    While i is less than param_count:
        Let param_size be get_param_size(param_types, i)
        Let is_float be is_float_type(param_types, i)
        Let param_class be classify_parameter(param_size, is_float)
        
        If param_class.class_type equals 0:  Note: INTEGER
            If frame.integer_params plus param_class.register_count is less than or equal to 6:
                Set frame.integer_params to frame.integer_params plus param_class.register_count
            Otherwise:
                Set frame.stack_params to frame.stack_params plus 1
            End If
        Otherwise:
            If param_class.class_type equals 1:  Note: SSE
                If frame.float_params is less than 8:
                    Set frame.float_params to frame.float_params plus 1
                Otherwise:
                    Set frame.stack_params to frame.stack_params plus 1
                End If
            Otherwise:  Note: MEMORY
                Set frame.stack_params to frame.stack_params plus 1
            End If
        End If
        
        Set i to i plus 1
    End While
    
    Note: Calculate stack alignment
    Let stack_size be frame.stack_params times 8 plus frame.local_space
    Set frame.stack_alignment to ((stack_size plus 15) divided by 16) times 16
    
    Note: Determine if red zone can be used
    If frame.local_space is less than or equal to 128 and frame.stack_params equals 0:
        Set frame.red_zone_used to true
    Otherwise:
        Set frame.red_zone_used to false
    End If
    
    Return frame
End Process

Process called "generate_prologue" that takes frame as CallFrame, buffer as Pointer returns Integer:
    Note: Generate function prologue
    
    @Implementation
    Creates standard function prologue: save RBP, setup frame pointer,
    allocate local space, save callee-saved registers.
    @End Implementation
    
    Let offset be 0
    
    Note: Save old base pointer
    Inline Assembly:
        "mov byte [%0], 0x55\n"      Note: PUSH RBP
        "inc %1\n"                   Note: Increment offset
        :
        : "r"(buffer), "+r"(offset)
        : "memory"
    End Assembly
    
    Note: Setup new base pointer
    Inline Assembly:
        "mov word [%0 + %1], 0xE589\n" Note: MOV RBP, RSP
        "add %1, 3\n"                Note: Add instruction length
        :
        : "r"(buffer), "+r"(offset)
        : "memory"
    End Assembly
    
    Note: Allocate stack space if needed
    If not frame.red_zone_used and frame.stack_alignment is greater than 0:
        Inline Assembly:
            "mov word [%0 + %1], 0xEC81\n" Note: SUB RSP, imm32
            "add %1, 2\n"                Note: Add opcode length
            "mov dword [%0 + %1], %2\n"  Note: Store alignment value
            "add %1, 4\n"                Note: Add immediate length
            :
            : "r"(buffer), "+r"(offset), "r"(frame.stack_alignment)
            : "memory"
        End Assembly
    End If
    
    Note: Save callee-saved registers
    Let saved_regs be frame.saved_regs
    Let reg_num be 0
    While saved_regs is not equal to 0:
        If (saved_regs bitwise_and 1) equals 1:
            Let push_opcode be get_push_opcode(reg_num)
            Inline Assembly:
                "mov byte [%0 + %1], %2\n"   Note: Write PUSH opcode
                "inc %1\n"                   Note: Increment offset
                :
                : "r"(buffer), "+r"(offset), "r"(push_opcode)
                : "memory"
            End Assembly
        End If
        Set saved_regs to saved_regs right_shift 1
        Set reg_num to reg_num plus 1
    End While
    
    Return offset
End Process

Process called "generate_epilogue" that takes frame as CallFrame, buffer as Pointer returns Integer:
    Note: Generate function epilogue
    
    @Implementation
    Creates standard function epilogue: restore callee-saved registers,
    deallocate local space, restore RBP, and return.
    @End Implementation
    
    Let offset be 0
    
    Note: Restore callee-saved registers in reverse order
    Let saved_regs be frame.saved_regs
    Let reg_count be count_set_bits(saved_regs)
    Let reg_num be 15
    
    While reg_num is greater than or equal to 0:
        If ((saved_regs right_shift reg_num) bitwise_and 1) equals 1:
            Let pop_opcode be get_pop_opcode(reg_num)
            Inline Assembly:
                "mov byte [%0 + %1], %2\n"   Note: Write POP opcode
                "inc %1\n"                   Note: Increment offset
                :
                : "r"(buffer), "+r"(offset), "r"(pop_opcode)
                : "memory"
            End Assembly
        End If
        Set reg_num to reg_num minus 1
    End While
    
    Note: Deallocate stack space if allocated
    If not frame.red_zone_used and frame.stack_alignment is greater than 0:
        Inline Assembly:
            "mov word [%0 + %1], 0xC481\n" Note: ADD RSP, imm32
            "add %1, 2\n"                Note: Add opcode length
            "mov dword [%0 + %1], %2\n"  Note: Store alignment value
            "add %1, 4\n"                Note: Add immediate length
            :
            : "r"(buffer), "+r"(offset), "r"(frame.stack_alignment)
            : "memory"
        End Assembly
    End If
    
    Note: Restore base pointer
    Inline Assembly:
        "mov byte [%0 + %1], 0x5D\n"  Note: POP RBP
        "inc %1\n"                   Note: Increment offset
        :
        : "r"(buffer), "+r"(offset)
        : "memory"
    End Assembly
    
    Note: Return instruction
    Inline Assembly:
        "mov byte [%0 + %1], 0xC3\n"  Note: RET
        "inc %1\n"                   Note: Increment offset
        :
        : "r"(buffer), "+r"(offset)
        : "memory"
    End Assembly
    
    Return offset
End Process

Process called "setup_integer_arguments" that takes count as Integer, buffer as Pointer returns Integer:
    Note: Setup integer arguments in registers
    
    @Implementation
    Moves integer arguments from calling convention registers
    (RDI, RSI, RDX, RCX, R8, R9) to expected locations.
    @End Implementation
    
    Let offset be 0
    Let i be 0
    
    While i is less than count and i is less than 6:
        Let arg_reg be Registers.get_argument_registers(i)
        
        Note: Generate MOV to save argument
        Match i:
            When 0:  Note: RDI
                Inline Assembly:
                    "mov byte [%0 + %1], 0x48\n"    Note: REX.W prefix
                    "mov word [%0 + %1 + 1], 0xF789\n" Note: MOV [RBP-8], RDI
                    "mov byte [%0 + %1 + 3], 0xF8\n"   Note: Displacement
                    "add %1, 4\n"                   Note: Add instruction length
                    :
                    : "r"(buffer), "+r"(offset)
                    : "memory"
                End Assembly
            When 1:  Note: RSI
                Inline Assembly:
                    "mov byte [%0 + %1], 0x48\n"    Note: REX.W prefix
                    "mov word [%0 + %1 + 1], 0xF089\n" Note: MOV [RBP-16], RSI
                    "mov byte [%0 + %1 + 3], 0xF0\n"   Note: Displacement
                    "add %1, 4\n"                   Note: Add instruction length
                    :
                    : "r"(buffer), "+r"(offset)
                    : "memory"
                End Assembly
            When 2:  Note: RDX
                Inline Assembly:
                    "mov byte [%0 + %1], 0x48\n"    Note: REX.W prefix
                    "mov word [%0 + %1 + 1], 0xE889\n" Note: MOV [RBP-24], RDX
                    "mov byte [%0 + %1 + 3], 0xE8\n"   Note: Displacement
                    "add %1, 4\n"                   Note: Add instruction length
                    :
                    : "r"(buffer), "+r"(offset)
                    : "memory"
                End Assembly
            When 3:  Note: RCX
                Inline Assembly:
                    "mov byte [%0 + %1], 0x48\n"    Note: REX.W prefix
                    "mov word [%0 + %1 + 1], 0xE089\n" Note: MOV [RBP-32], RCX
                    "mov byte [%0 + %1 + 3], 0xE0\n"   Note: Displacement
                    "add %1, 4\n"                   Note: Add instruction length
                    :
                    : "r"(buffer), "+r"(offset)
                    : "memory"
                End Assembly
            When 4:  Note: R8
                Inline Assembly:
                    "mov byte [%0 + %1], 0x4C\n"    Note: REX.W + REX.R
                    "mov word [%0 + %1 + 1], 0xD889\n" Note: MOV [RBP-40], R8
                    "mov byte [%0 + %1 + 3], 0xD8\n"   Note: Displacement
                    "add %1, 4\n"                   Note: Add instruction length
                    :
                    : "r"(buffer), "+r"(offset)
                    : "memory"
                End Assembly
            When 5:  Note: R9
                Inline Assembly:
                    "mov byte [%0 + %1], 0x4C\n"    Note: REX.W + REX.R
                    "mov word [%0 + %1 + 1], 0xD089\n" Note: MOV [RBP-48], R9
                    "mov byte [%0 + %1 + 3], 0xD0\n"   Note: Displacement
                    "add %1, 4\n"                   Note: Add instruction length
                    :
                    : "r"(buffer), "+r"(offset)
                    : "memory"
                End Assembly
        End Match
        
        Set i to i plus 1
    End While
    
    Return offset
End Process

Process called "setup_float_arguments" that takes count as Integer, buffer as Pointer returns Integer:
    Note: Setup floating point arguments in XMM registers
    
    @Implementation
    Moves floating point arguments from XMM0-XMM7 to stack locations
    for later use within the function.
    @End Implementation
    
    Let offset be 0
    Let i be 0
    
    While i is less than count and i is less than 8:
        Note: MOVSD [rbp-offset], xmm(i)
        Inline Assembly:
            "mov byte [%0 + %1], 0xF2\n"     Note: SSE2 prefix
            "mov byte [%0 + %1 + 1], 0x0F\n" Note: Two-byte opcode prefix
            "mov byte [%0 + %1 + 2], 0x11\n" Note: MOVSD opcode
            "mov eax, %2\n"                  Note: Load index
            "imul eax, 8\n"                  Note: Multiply by 8
            "add eax, 0x45\n"                Note: Add base ModR/M
            "mov [%0 + %1 + 3], al\n"        Note: Store ModR/M byte
            "mov eax, %2\n"                  Note: Load index again
            "imul eax, 8\n"                  Note: Multiply by 8
            "neg eax\n"                      Note: Negate
            "add eax, 0xF8\n"                Note: Add base displacement
            "mov [%0 + %1 + 4], al\n"        Note: Store displacement
            "add %1, 5\n"                    Note: Add instruction length
            :
            : "r"(buffer), "+r"(offset), "r"(i)
            : "rax", "memory"
        End Assembly
        
        Set i to i plus 1
    End While
    
    Return offset
End Process

Process called "prepare_call_arguments" that takes frame as CallFrame, buffer as Pointer returns Integer:
    Note: Prepare arguments for function call
    
    @Implementation
    Loads arguments into appropriate registers or stack locations
    according to System V calling convention before making a call.
    @End Implementation
    
    Let offset be 0
    
    Note: Load integer arguments into registers
    Let i be 0
    While i is less than frame.integer_params and i is less than 6:
        Let arg_reg be get_integer_arg_register(i)
        
        Note: MOV reg, [rbp-offset]
        Inline Assembly:
            "mov byte [%0 + %1], 0x48\n"     Note: REX.W prefix
            "mov eax, %2\n"                  Note: Load index
            "imul eax, 0x100\n"              Note: Multiply by 0x100
            "add eax, 0x8B45\n"              Note: Add base opcode
            "mov [%0 + %1 + 1], ax\n"        Note: Store opcode word
            "mov eax, %2\n"                  Note: Load index again
            "imul eax, 8\n"                  Note: Multiply by 8
            "neg eax\n"                      Note: Negate
            "add eax, 0xF8\n"                Note: Add base displacement
            "mov [%0 + %1 + 3], al\n"        Note: Store displacement
            "add %1, 4\n"                    Note: Add instruction length
            :
            : "r"(buffer), "+r"(offset), "r"(i)
            : "rax", "memory"
        End Assembly
        
        Set i to i plus 1
    End While
    
    Note: Load float arguments into XMM registers
    Let j be 0
    While j is less than frame.float_params and j is less than 8:
        Note: MOVSD xmm(j), [rbp-offset]
        Inline Assembly:
            "mov byte [%0 + %1], 0xF2\n"     Note: SSE2 prefix
            "mov byte [%0 + %1 + 1], 0x0F\n" Note: Two-byte opcode prefix
            "mov byte [%0 + %1 + 2], 0x10\n" Note: MOVSD opcode
            "mov eax, %2\n"                  Note: Load index
            "imul eax, 8\n"                  Note: Multiply by 8
            "add eax, 0x45\n"                Note: Add base ModR/M
            "mov [%0 + %1 + 3], al\n"        Note: Store ModR/M byte
            "mov eax, %2\n"                  Note: Load index again
            "imul eax, 8\n"                  Note: Multiply by 8
            "add eax, 0x40\n"                Note: Add offset
            "neg eax\n"                      Note: Negate
            "add eax, 0xF8\n"                Note: Add base displacement
            "mov [%0 + %1 + 4], al\n"        Note: Store displacement
            "add %1, 5\n"                    Note: Add instruction length
            :
            : "r"(buffer), "+r"(offset), "r"(j)
            : "rax", "memory"
        End Assembly
        
        Set j to j plus 1
    End While
    
    Note: Push stack arguments in reverse order
    If frame.stack_params is greater than 0:
        Let k be frame.stack_params minus 1
        While k is greater than or equal to 0:
            Note: PUSH [rbp+16+k*8] (arguments passed on stack)
            Inline Assembly:
                "mov byte [%0 + %1], 0xFF\n"     Note: PUSH m64 opcode
                "mov byte [%0 + %1 + 1], 0x75\n" Note: ModR/M byte
                "mov eax, %2\n"                  Note: Load k
                "imul eax, 8\n"                  Note: Multiply by 8
                "add eax, 0x10\n"                Note: Add base offset
                "mov [%0 + %1 + 2], al\n"        Note: Store displacement
                "add %1, 3\n"                    Note: Add instruction length
                :
                : "r"(buffer), "+r"(offset), "r"(k)
                : "rax", "memory"
            End Assembly
            
            Set k to k minus 1
        End While
    End If
    
    Return offset
End Process

Process called "handle_return_value" that takes is_float as Boolean, buffer as Pointer returns Integer:
    Note: Handle function return value
    
    @Implementation
    Return values go in RAX (integer) or XMM0 (floating point).
    Large structures are returned through hidden first parameter.
    @End Implementation
    
    Let offset be 0
    
    If is_float:
        Note: Result is in XMM0, optionally move to stack
        Inline Assembly:
            "mov byte [%1], 0xF2\n"          Note: SSE2 prefix
            "mov byte [%1 + 1], 0x0F\n"      Note: Two-byte opcode prefix
            "mov byte [%1 + 2], 0x11\n"      Note: MOVSD opcode
            "mov byte [%1 + 3], 0x45\n"      Note: ModR/M [RBP-8], XMM0
            "mov byte [%1 + 4], 0xF8\n"      Note: Displacement
            "mov %0, 5\n"                    Note: Set offset to 5
            : "=r"(offset)
            : "r"(buffer)
            : "memory"
        End Assembly
    Otherwise:
        Note: Result is in RAX, optionally move to stack
        Inline Assembly:
            "mov byte [%1], 0x48\n"          Note: REX.W prefix
            "mov byte [%1 + 1], 0x89\n"      Note: MOV opcode
            "mov byte [%1 + 2], 0x45\n"      Note: ModR/M [RBP-8], RAX
            "mov byte [%1 + 3], 0xF8\n"      Note: Displacement
            "mov %0, 4\n"                    Note: Set offset to 4
            : "=r"(offset)
            : "r"(buffer)
            : "memory"
        End Assembly
    End If
    
    Return offset
End Process

Note: Helper functions
Process called "get_param_size" that takes param_types as Pointer, index as Integer returns Integer:
    Note: Get size of parameter at index from type information array
    
    @Implementation
    Extracts parameter size from type information array using proper type analysis.
    Supports all standard type sizes with platform-specific sizing rules.
    @End Implementation
    
    If param_types is null:
        Return 0
    End If
    
    If index < 0:
        Return 0
    End If
    
    Note: Calculate offset into parameter types array
    Let type_info_offset be multiply_integers(index, 16)
    Let param_type_ptr be add_pointer_offset(param_types, type_info_offset)
    
    Note: Extract type identifier from type info structure
    Let type_id be load_integer_from_pointer(param_type_ptr)
    
    Note: Calculate size based on type identifier
    Match type_id:
        When 1:  Note: Boolean
            Return 1
        When 2:  Note: Integer8
            Return 1
        When 3:  Note: Unsigned8
            Return 1
        When 4:  Note: Integer16
            Return 2
        When 5:  Note: Unsigned16
            Return 2
        When 6:  Note: Integer32
            Return 4
        When 7:  Note: Unsigned32
            Return 4
        When 8:  Note: Integer64
            Return 8
        When 9:  Note: Unsigned64
            Return 8
        When 10: Note: Integer (platform default)
            Return 8
        When 11: Note: Float32
            Return 4
        When 12: Note: Float64
            Return 8
        When 13: Note: Float (platform default)
            Return 8
        When 14: Note: Pointer
            Return 8
        When 15: Note: Character
            Return 1
        When 16: Note: String (pointer to string data)
            Return 8
        When 17: Note: Array (pointer to array data)
            Return 8
        When 18: Note: Struct
            Note: Get struct size from type info
            Let struct_size_offset be 8
            Let struct_size_ptr be add_pointer_offset(param_type_ptr, struct_size_offset)
            Let struct_size be load_integer_from_pointer(struct_size_ptr)
            Return struct_size
        When 19: Note: Union
            Note: Get union size from type info
            Let union_size_offset be 8
            Let union_size_ptr be add_pointer_offset(param_type_ptr, union_size_offset)
            Let union_size be load_integer_from_pointer(union_size_ptr)
            Return union_size
        When 20: Note: Enum (typically integer-sized)
            Return 4
        When 21: Note: Function pointer
            Return 8
        When 22: Note: Void (should not occur for parameters)
            Return 0
    End Match
    
    Note: Unknown type - return pointer size as fallback
    Return 8
End Process

Process called "is_float_type" that takes param_types as Pointer, index as Integer returns Boolean:
    Note: Check if parameter at index is floating point type
    
    @Implementation
    Determines if parameter at index is floating point type by analyzing type information.
    Used for x86_64 calling convention to determine register allocation.
    @End Implementation
    
    If param_types is null:
        Return false
    End If
    
    If index < 0:
        Return false
    End If
    
    Note: Calculate offset into parameter types array
    Let type_info_offset be multiply_integers(index, 16)
    Let param_type_ptr be add_pointer_offset(param_types, type_info_offset)
    
    Note: Extract type identifier from type info structure
    Let type_id be load_integer_from_pointer(param_type_ptr)
    
    Note: Check if type is floating point
    Match type_id:
        When 11: Note: Float32
            Return true
        When 12: Note: Float64
            Return true
        When 13: Note: Float (platform default)
            Return true
    End Match
    
    Note: Not a floating point type
    Return false
End Process

Process called "get_push_opcode" that takes reg_num as Integer returns Integer:
    Note: Get PUSH opcode for register
    
    @Implementation
    Returns single-byte PUSH opcode for given register number.
    Extended registers need REX prefix handled separately.
    @End Implementation
    
    If reg_num is less than 8:
        Return 0x50 plus reg_num
    Otherwise:
        Return 0x50 plus (reg_num minus 8)  Note: With REX prefix
    End If
End Process

Process called "get_pop_opcode" that takes reg_num as Integer returns Integer:
    Note: Get POP opcode for register
    
    @Implementation
    Returns single-byte POP opcode for given register number.
    Extended registers need REX prefix handled separately.
    @End Implementation
    
    If reg_num is less than 8:
        Return 0x58 plus reg_num
    Otherwise:
        Return 0x58 plus (reg_num minus 8)  Note: With REX prefix
    End If
End Process

Process called "count_set_bits" that takes value as Integer returns Integer:
    Note: Count number of set bits
    
    @Implementation
    Uses Brian Kernighan's algorithm to count set bits efficiently.
    Used to count saved registers.
    @End Implementation
    
    Let count be 0
    While value is not equal to 0:
        Set value to value bitwise_and (value minus 1)
        Set count to count plus 1
    End While
    Return count
End Process

Process called "get_integer_arg_register" that takes index as Integer returns Integer:
    Note: Get integer argument register encoding
    
    @Implementation
    Maps argument index to register encoding for System V ABI.
    RDI(7), RSI(6), RDX(2), RCX(1), R8(0), R9(1).
    @End Implementation
    
    Match index:
        When 0:
            Return 7  Note: RDI
        When 1:
            Return 6  Note: RSI
        When 2:
            Return 2  Note: RDX
        When 3:
            Return 1  Note: RCX
        When 4:
            Return 0  Note: R8 (with REX)
        When 5:
            Return 1  Note: R9 (with REX)
        Otherwise:
            Return -1
    End Match
End Process