Note: AArch64 (ARM64) register definitions and management

@Reasoning
The AArch64 architecture has 31 general-purpose registers (X0-X30), 32 SIMD/FP
registers (V0-V31), and special registers like SP and PC. This module provides
comprehensive register definitions and management for ARM64 code generation.
@End Reasoning

Type called "AArch64RegisterClass":
    Note: Categories of AArch64 registers
    
    @Implementation
    ARM64 has distinct register classes with different usage patterns.
    X registers are 64-bit, W registers are 32-bit views of X registers.
    @End Implementation
    
    class_id as Integer
    name as Pointer
    bit_width as Integer
    count as Integer
    is_vector as Boolean
End Type

Type called "AArch64Register":
    Note: Individual ARM64 register information
    
    @Implementation
    Contains encoding and usage information for each register.
    X30 is the link register (LR), X29 is frame pointer (FP).
    @End Implementation
    
    reg_id as Integer
    name as Pointer
    encoding as Integer
    is_callee_saved as Boolean
    is_special as Boolean  Note: SP, LR, FP
    w_name as Pointer     Note: 32-bit name (W0-W30)
End Type

Type called "AArch64RegisterSet":
    Note: Available registers for allocation
    
    @Performance_Hints
    Uses bit vectors for efficient tracking during register allocation.
    Separate masks for general purpose and vector registers.
    @End Performance_Hints
    
    available_gpr as Integer    Note: X0-X30 bitmask
    available_vec as Integer    Note: V0-V31 bitmask
    temp_count as Integer       Note: Number of temporary registers
End Type

Process called "init_aarch64_registers" returns Nothing:
    Note: Initialize AArch64 register definitions
    
    @Implementation
    Sets up register classes and special register designations
    according to ARM64 architecture and AAPCS64 ABI.
    @End Implementation
    
    Inline Assembly:
        "section .data\n"             Note: Data section
        "; General purpose 64-bit registers\n" Note: Comment
        "x_reg_class:\n"             Note: X register class
        "    dq 0\n"                  Note: class_id
        "    dq x_name\n"             Note: name pointer
        "    dq 64\n"                 Note: bit_width
        "    dq 31\n"                 Note: count (X0-X30)
        "    dq 0\n"                  Note: not vector
        "x_name: db 'X', 0\n"        Note: X register name
        "\n"                         Note: Separator
        "; General purpose 32-bit registers\n" Note: Comment
        "w_reg_class:\n"             Note: W register class
        "    dq 1\n"                  Note: class_id
        "    dq w_name\n"             Note: name pointer
        "    dq 32\n"                 Note: bit_width
        "    dq 31\n"                 Note: count (W0-W30)
        "    dq 0\n"                  Note: not vector
        "w_name: db 'W', 0\n"        Note: W register name
        "\n"                         Note: Separator
        "; SIMD/FP registers\n"      Note: Comment
        "v_reg_class:\n"             Note: V register class
        "    dq 2\n"                  Note: class_id
        "    dq v_name\n"             Note: name pointer
        "    dq 128\n"                Note: Full vector width
        "    dq 32\n"                 Note: count (V0-V31)
        "    dq 1\n"                  Note: is vector
        "v_name: db 'V', 0\n"        Note: V register name
        "\n"                         Note: Separator
        "; Scalar FP registers (same physical as V)\n" Note: Comment
        "d_reg_class:\n"             Note: D register class
        "    dq 3\n"                  Note: class_id
        "    dq d_name\n"             Note: name pointer
        "    dq 64\n"                 Note: Double precision
        "    dq 32\n"                 Note: count (D0-D31)
        "    dq 0\n"                  Note: not vector
        "d_name: db 'D', 0\n"        Note: D register name
        "\n"                         Note: Separator
        "s_reg_class:\n"             Note: S register class
        "    dq 4\n"                  Note: class_id
        "    dq s_name\n"             Note: name pointer
        "    dq 32\n"                 Note: Single precision
        "    dq 32\n"                 Note: count (S0-S31)
        "    dq 0\n"                  Note: not vector
        "s_name: db 'S', 0\n"        Note: S register name
        :
        :
        : "memory"
    End Assembly
End Process

Process called "get_aarch64_gpr_encoding" that takes reg_name as Pointer returns Integer:
    Note: Get encoding for general purpose register
    
    @Implementation
    X0-X30 map directly to encodings 0-30.
    SP (stack pointer) has special encoding 31 in some contexts.
    @End Implementation
    
    Inline Assembly:
        "mov rsi, %1\n"              Note: Load register name
        "\n"                         Note: Check for X registers
        "mov al, [rsi]\n"            Note: Load first character
        "cmp al, 'x'\n"              Note: Check for lowercase x
        "je .parse_x_reg\n"          Note: Jump if x register
        "cmp al, 'X'\n"              Note: Check for uppercase X
        "je .parse_x_reg\n"          Note: Jump if X register
        "\n"                         Note: Check for W registers
        "cmp al, 'w'\n"              Note: Check for lowercase w
        "je .parse_w_reg\n"          Note: Jump if w register
        "cmp al, 'W'\n"              Note: Check for uppercase W
        "je .parse_w_reg\n"          Note: Jump if W register
        "\n"                         Note: Check for special names
        "lea rdi, [sp_name]\n"       Note: Load SP name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_31\n"            Note: Jump if SP
        "\n"                         Note: Check LR
        "lea rdi, [lr_name]\n"       Note: Load LR name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_30\n"            Note: Jump if LR
        "\n"                         Note: Check FP
        "lea rdi, [fp_name]\n"       Note: Load FP name
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_29\n"            Note: Jump if FP
        "\n"                         Note: Not found
        "mov rax, -1\n"              Note: Return error
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Parse register number
        ".parse_x_reg:\n"            Note: Parse X register
        ".parse_w_reg:\n"            Note: Parse W register
        "inc rsi\n"                  Note: Skip X/W prefix
        "xor rax, rax\n"             Note: Clear result
        "xor rcx, rcx\n"             Note: Clear temp
        ".parse_loop:\n"             Note: Parse loop
        "mov cl, [rsi]\n"            Note: Load character
        "test cl, cl\n"              Note: Check for null
        "jz .validate_range\n"       Note: Jump if end
        "cmp cl, '0'\n"              Note: Check if >= '0'
        "jl .error\n"                Note: Jump if invalid
        "cmp cl, '9'\n"              Note: Check if <= '9'
        "jg .error\n"                Note: Jump if invalid
        "sub cl, '0'\n"              Note: Convert to digit
        "imul rax, 10\n"             Note: Multiply by 10
        "add rax, rcx\n"             Note: Add digit
        "inc rsi\n"                  Note: Next character
        "jmp .parse_loop\n"          Note: Continue loop
        "\n"                         Note: Validate range
        ".validate_range:\n"         Note: Validate range label
        "cmp rax, 30\n"              Note: Check if <= 30
        "jg .error\n"                Note: Jump if invalid
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Return values
        ".return_29:\n"              Note: Return FP (X29)
        "mov rax, 29\n"              Note: Set result to 29
        "jmp .done\n"                Note: Jump to end
        ".return_30:\n"              Note: Return LR (X30)
        "mov rax, 30\n"              Note: Set result to 30
        "jmp .done\n"                Note: Jump to end
        ".return_31:\n"              Note: Return SP (X31)
        "mov rax, 31\n"              Note: Set result to 31
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Error case
        ".error:\n"                  Note: Error label
        "mov rax, -1\n"              Note: Return error
        ".done:\n"                   Note: End label
        "mov %0, rax\n"              Note: Store result
        : "=r"(result)
        : "r"(reg_name)
        : "rax", "rcx", "rdi", "rsi", "memory"
    End Assembly
    
    Let result as Integer
    Return result
End Process

Process called "is_aarch64_callee_saved" that takes reg_name as Pointer returns Boolean:
    Note: Check if register is callee-saved in AAPCS64
    
    @Implementation
    AAPCS64 specifies X19-X29 as callee-saved registers.
    X30 (LR) must also be saved if modified.
    @End Implementation
    
    Let encoding be get_aarch64_gpr_encoding(reg_name)
    
    If encoding is greater than or equal to 19 and encoding is less than or equal to 29:
        Return true
    End If
    
    If encoding equals 30:  Note: LR
        Return true
    End If
    
    Return false
End Process

Process called "get_vec_register_encoding" that takes reg_name as Pointer returns Integer:
    Note: Get encoding for vector/FP register
    
    @Implementation
    V0-V31, D0-D31, S0-S31 all map to same physical registers.
    Encoding is simply the register number (0-31).
    @End Implementation
    
    Inline Assembly:
        "mov rsi, %1\n"              Note: Load register name
        "\n"                         Note: Skip prefix (V/D/S/H/B)
        "mov al, [rsi]\n"            Note: Load first character
        "cmp al, 'v'\n"              Note: Check for lowercase v
        "je .skip_prefix\n"          Note: Jump if v register
        "cmp al, 'V'\n"              Note: Check for uppercase V
        "je .skip_prefix\n"          Note: Jump if V register
        "cmp al, 'd'\n"              Note: Check for lowercase d
        "je .skip_prefix\n"          Note: Jump if d register
        "cmp al, 'D'\n"              Note: Check for uppercase D
        "je .skip_prefix\n"          Note: Jump if D register
        "cmp al, 's'\n"              Note: Check for lowercase s
        "je .skip_prefix\n"          Note: Jump if s register
        "cmp al, 'S'\n"              Note: Check for uppercase S
        "je .skip_prefix\n"          Note: Jump if S register
        "\n"                         Note: Invalid prefix
        "mov rax, -1\n"              Note: Return error
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Skip prefix
        ".skip_prefix:\n"            Note: Skip prefix label
        "inc rsi\n"                  Note: Skip first character
        "\n"                         Note: Parse number
        "xor rax, rax\n"             Note: Clear result
        "xor rcx, rcx\n"             Note: Clear temp
        ".parse_loop:\n"             Note: Parse loop
        "mov cl, [rsi]\n"            Note: Load character
        "test cl, cl\n"              Note: Check for null
        "jz .validate\n"             Note: Jump if end
        "cmp cl, '0'\n"              Note: Check if >= '0'
        "jl .error\n"                Note: Jump if invalid
        "cmp cl, '9'\n"              Note: Check if <= '9'
        "jg .error\n"                Note: Jump if invalid
        "sub cl, '0'\n"              Note: Convert to digit
        "imul rax, 10\n"             Note: Multiply by 10
        "add rax, rcx\n"             Note: Add digit
        "inc rsi\n"                  Note: Next character
        "jmp .parse_loop\n"          Note: Continue loop
        "\n"                         Note: Validate range
        ".validate:\n"               Note: Validate label
        "cmp rax, 31\n"              Note: Check if <= 31
        "jg .error\n"                Note: Jump if invalid
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Error case
        ".error:\n"                  Note: Error label
        "mov rax, -1\n"              Note: Return error
        ".done:\n"                   Note: End label
        "mov %0, rax\n"              Note: Store result
        : "=r"(result)
        : "r"(reg_name)
        : "rax", "rcx", "rsi", "flags"
    End Assembly
    
    Let result as Integer
    Return result
End Process

Process called "create_aarch64_register_set" returns AArch64RegisterSet:
    Note: Create available register set for allocation
    
    @Performance_Hints
    Reserves special registers (SP, LR, FP) and platform register (X18).
    X0-X7 are used for arguments, X8 for indirect result.
    @End Performance_Hints
    
    Let set be AArch64RegisterSet
    
    Note: Mark all GPRs available except specials
    Set set.available_gpr to 0x7FFFFFFF  Note: All 31 registers
    
    Note: Reserve special registers
    Set set.available_gpr to set.available_gpr bitwise_and 0x9FFFFFFF  Note: Clear X29 (FP)
    Set set.available_gpr to set.available_gpr bitwise_and 0xBFFFFFFF  Note: Clear X30 (LR)
    Set set.available_gpr to set.available_gpr bitwise_and 0xFFFBFFFF  Note: Clear X18 (platform)
    
    Note: Mark all vector registers available
    Set set.available_vec to 0xFFFFFFFF  Note: V0-V31 all available
    
    Note: Count temporary registers
    Set set.temp_count to 9  Note: X9-X17 are temporary
    
    Return set
End Process

Process called "allocate_aarch64_gpr" that takes set as AArch64RegisterSet returns Integer:
    Note: Allocate next available GPR
    
    @Implementation
    Prioritizes temporary registers (X9-X17) to minimize saves.
    Then uses argument registers if available.
    @End Implementation
    
    If set.available_gpr equals 0:
        Return -1
    End If
    
    Note: Try temporary registers first (X9-X17)
    Let temp_mask be 0x0003FE00  Note: Bits 9-17
    Let available_temps be set.available_gpr bitwise_and temp_mask
    
    Let reg_index as Integer
    If available_temps is not equal to 0:
        Inline Assembly:
            "bsf %0, %1\n"               Note: Find first set bit
            : "=r"(reg_index)
            : "r"(available_temps)
            : "flags"
        End Assembly
    Otherwise:
        Inline Assembly:
            "bsf %0, %1\n"               Note: Find first set bit
            : "=r"(reg_index)
            : "r"(set.available_gpr)
            : "flags"
        End Assembly
    End If
    
    Note: Mark as allocated
    Inline Assembly:
        "mov rcx, %1\n"              Note: Load register index
        "mov rax, 1\n"               Note: Load bit mask
        "shl rax, cl\n"              Note: Shift to position
        "not rax\n"                  Note: Invert mask
        "and %0, rax\n"              Note: Clear the bit
        :
        : "+r"(set.available_gpr), "r"(reg_index)
        : "rax", "rcx", "flags"
    End Assembly
    
    Return reg_index
End Process

Process called "free_aarch64_gpr" that takes set as AArch64RegisterSet, reg_index as Integer returns Nothing:
    Note: Return GPR to available pool
    
    @Implementation
    Marks register as available by setting its bit.
    Validates register index to prevent corruption.
    @End Implementation
    
    If reg_index is less than 0 or reg_index is greater than 30:
        Return
    End If
    
    Inline Assembly:
        "mov rcx, %1\n"              Note: Load register index
        "mov rax, 1\n"               Note: Load bit mask
        "shl rax, cl\n"              Note: Shift to position
        "or %0, rax\n"               Note: Set the bit
        :
        : "+r"(set.available_gpr), "r"(reg_index)
        : "rax", "rcx", "flags"
    End Assembly
End Process

Process called "get_aarch64_arg_register" that takes index as Integer, is_float as Boolean returns Pointer:
    Note: Get register for function argument
    
    @Implementation
    AAPCS64 uses X0-X7 for integer arguments, V0-V7 for FP arguments.
    X8 is used for indirect result location.
    @End Implementation
    
    If is_float:
        Match index:
            When 0:
                Inline Assembly:
                    "lea rax, [v0_name]\n"       Note: Load V0 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 1:
                Inline Assembly:
                    "lea rax, [v1_name]\n"       Note: Load V1 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 2:
                Inline Assembly:
                    "lea rax, [v2_name]\n"       Note: Load V2 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 3:
                Inline Assembly:
                    "lea rax, [v3_name]\n"       Note: Load V3 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 4:
                Inline Assembly:
                    "lea rax, [v4_name]\n"       Note: Load V4 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 5:
                Inline Assembly:
                    "lea rax, [v5_name]\n"       Note: Load V5 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 6:
                Inline Assembly:
                    "lea rax, [v6_name]\n"       Note: Load V6 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 7:
                Inline Assembly:
                    "lea rax, [v7_name]\n"       Note: Load V7 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            Otherwise:
                Inline Assembly:
                    "xor rax, rax\n"             Note: Return null pointer
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
        End Match
    Otherwise:
        Match index:
            When 0:
                Inline Assembly:
                    "lea rax, [x0_name]\n"       Note: Load X0 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 1:
                Inline Assembly:
                    "lea rax, [x1_name]\n"       Note: Load X1 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 2:
                Inline Assembly:
                    "lea rax, [x2_name]\n"       Note: Load X2 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 3:
                Inline Assembly:
                    "lea rax, [x3_name]\n"       Note: Load X3 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 4:
                Inline Assembly:
                    "lea rax, [x4_name]\n"       Note: Load X4 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 5:
                Inline Assembly:
                    "lea rax, [x5_name]\n"       Note: Load X5 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 6:
                Inline Assembly:
                    "lea rax, [x6_name]\n"       Note: Load X6 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            When 7:
                Inline Assembly:
                    "lea rax, [x7_name]\n"       Note: Load X7 name address
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
            Otherwise:
                Inline Assembly:
                    "xor rax, rax\n"             Note: Return null pointer
                    : "=r"(result)
                    :
                    : "rax"
                End Assembly
        End Match
    End If
    
    Let result as Pointer
    Return result
End Process

Process called "get_aarch64_return_register" that takes is_float as Boolean returns Pointer:
    Note: Get register for return value
    
    @Implementation
    AAPCS64 uses X0 for integer returns, V0 for FP returns.
    Large structures use X8 for indirect return.
    @End Implementation
    
    If is_float:
        Inline Assembly:
            "lea rax, [v0_name]\n"       Note: Load V0 name address
            : "=r"(result)
            :
            : "rax"
        End Assembly
    Otherwise:
        Inline Assembly:
            "lea rax, [x0_name]\n"       Note: Load X0 name address
            : "=r"(result)
            :
            : "rax"
        End Assembly
    End If
    
    Let result as Pointer
    Return result
End Process

Note: Register name strings
Inline Assembly:
    "section .rodata\n"           Note: Read-only data section
    "; General purpose registers\n" Note: Comment
    "x0_name:  db 'x0', 0\n"      Note: X0 register name
    "x1_name:  db 'x1', 0\n"      Note: X1 register name
    "x2_name:  db 'x2', 0\n"      Note: X2 register name
    "x3_name:  db 'x3', 0\n"      Note: X3 register name
    "x4_name:  db 'x4', 0\n"      Note: X4 register name
    "x5_name:  db 'x5', 0\n"      Note: X5 register name
    "x6_name:  db 'x6', 0\n"      Note: X6 register name
    "x7_name:  db 'x7', 0\n"      Note: X7 register name
    "x8_name:  db 'x8', 0\n"      Note: X8 register name
    "x9_name:  db 'x9', 0\n"      Note: X9 register name
    "x10_name: db 'x10', 0\n"     Note: X10 register name
    "x11_name: db 'x11', 0\n"     Note: X11 register name
    "x12_name: db 'x12', 0\n"     Note: X12 register name
    "x13_name: db 'x13', 0\n"     Note: X13 register name
    "x14_name: db 'x14', 0\n"     Note: X14 register name
    "x15_name: db 'x15', 0\n"     Note: X15 register name
    "x16_name: db 'x16', 0\n"     Note: X16 register name
    "x17_name: db 'x17', 0\n"     Note: X17 register name
    "x18_name: db 'x18', 0\n"     Note: X18 register name
    "x19_name: db 'x19', 0\n"     Note: X19 register name
    "x20_name: db 'x20', 0\n"     Note: X20 register name
    "x21_name: db 'x21', 0\n"     Note: X21 register name
    "x22_name: db 'x22', 0\n"     Note: X22 register name
    "x23_name: db 'x23', 0\n"     Note: X23 register name
    "x24_name: db 'x24', 0\n"     Note: X24 register name
    "x25_name: db 'x25', 0\n"     Note: X25 register name
    "x26_name: db 'x26', 0\n"     Note: X26 register name
    "x27_name: db 'x27', 0\n"     Note: X27 register name
    "x28_name: db 'x28', 0\n"     Note: X28 register name
    "x29_name: db 'x29', 0\n"     Note: X29 register name
    "x30_name: db 'x30', 0\n"     Note: X30 register name
    "\n"                         Note: Separator
    "; Vector registers\n"        Note: Comment
    "v0_name:  db 'v0', 0\n"      Note: V0 register name
    "v1_name:  db 'v1', 0\n"      Note: V1 register name
    "v2_name:  db 'v2', 0\n"      Note: V2 register name
    "v3_name:  db 'v3', 0\n"      Note: V3 register name
    "v4_name:  db 'v4', 0\n"      Note: V4 register name
    "v5_name:  db 'v5', 0\n"      Note: V5 register name
    "v6_name:  db 'v6', 0\n"      Note: V6 register name
    "v7_name:  db 'v7', 0\n"      Note: V7 register name
    "\n"                         Note: Separator
    "; Special register names\n"  Note: Comment
    "sp_name:  db 'sp', 0\n"      Note: Stack pointer name
    "lr_name:  db 'lr', 0\n"      Note: Link register name
    "fp_name:  db 'fp', 0\n"      Note: Frame pointer name
    "\n"                         Note: Separator
    "strcmp:\n"                  Note: String comparison function
    "    push rbx\n"              Note: Save rbx
    ".loop:\n"                   Note: Comparison loop
    "    mov al, [rdi]\n"         Note: Load byte from first string
    "    mov bl, [rsi]\n"         Note: Load byte from second string
    "    cmp al, bl\n"            Note: Compare bytes
    "    jne .not_equal\n"        Note: Jump if not equal
    "    test al, al\n"           Note: Check for null terminator
    "    jz .equal\n"             Note: Jump if end of string
    "    inc rdi\n"               Note: Next character in first string
    "    inc rsi\n"               Note: Next character in second string
    "    jmp .loop\n"             Note: Continue loop
    ".equal:\n"                  Note: Strings are equal
    "    xor rax, rax\n"          Note: Return 0 (equal)
    "    pop rbx\n"               Note: Restore rbx
    "    ret\n"                   Note: Return
    ".not_equal:\n"              Note: Strings not equal
    "    mov rax, 1\n"            Note: Return 1 (not equal)
    "    pop rbx\n"               Note: Restore rbx
    "    ret\n"                   Note: Return
    :
    :
    : "memory"
End Assembly