Note: AArch64 instruction encoding and generation

Import "./registers.runa" as Registers

@Reasoning
AArch64 has a more regular instruction encoding than x86_64, with fixed 32-bit
instruction width. This module provides comprehensive instruction encoding for
ARM64, including data processing, memory access, and branch instructions.
@End Reasoning

Type called "AArch64Instruction":
    Note: ARM64 instruction encoding
    
    @Implementation
    All AArch64 instructions are 32 bits wide with regular encoding patterns.
    The top bits typically determine the instruction class.
    @End Implementation
    
    encoding as Integer  Note: 32-bit instruction word
    inst_class as Integer  Note: Instruction category
    rd as Integer          Note: Destination register
    rn as Integer          Note: First source register
    rm as Integer          Note: Second source register
    immediate as Integer   Note: Immediate value if applicable
    shift_type as Integer  Note: Shift operation type
    shift_amount as Integer
End Type

Type called "AArch64Condition":
    Note: Condition codes for branches
    
    @Implementation
    ARM64 supports 16 condition codes for conditional execution.
    These map to specific bit patterns in conditional instructions.
    @End Implementation
    
    code as Integer     Note: 4-bit condition code
    name as Pointer     Note: Mnemonic (eq, ne, cs, cc, etc.)
End Type

Process called "encode_aarch64_mov" that takes dest as Integer, src as Integer, is_immediate as Boolean, imm_value as Integer returns AArch64Instruction:
    Note: Encode MOV instruction
    
    @Implementation
    MOV can be register-to-register or immediate-to-register.
    Uses different encodings for different immediate ranges.
    @End Implementation
    
    Let inst be AArch64Instruction
    
    If is_immediate:
        Note: MOVZ - Move wide immediate (16-bit chunks)
        Let shift_amount be 0
        Let imm16 be imm_value bitwise_and 0xFFFF
        
        Note: Determine shift for larger immediates
        If imm_value is greater than 0xFFFF:
            If imm_value is greater than 0xFFFFFFFF:
                Set shift_amount to 48
                Set imm16 to (imm_value right_shift 48) bitwise_and 0xFFFF
            Otherwise:
                If imm_value is greater than 0xFFFFFF:
                    Set shift_amount to 32
                    Set imm16 to (imm_value right_shift 32) bitwise_and 0xFFFF
                Otherwise:
                    Set shift_amount to 16
                    Set imm16 to (imm_value right_shift 16) bitwise_and 0xFFFF
                End If
            End If
        End If
        
        Note: Build MOVZ instruction: 1101_0010_1hw_iiii_iiii_iiii_iiid_dddd
        Let hw be shift_amount divided by 16
        Set inst.encoding to 0xD2800000  Note: Base MOVZ encoding
        Set inst.encoding to inst.encoding plus dest
        Set inst.encoding to inst.encoding plus (imm16 left_shift 5)
        Set inst.encoding to inst.encoding plus (hw left_shift 21)
    Otherwise:
        Note: Register MOV (actually ORR with zero register)
        Note: ORR Xd, XZR, Xm: 1010_1010_000m_mmmm_0000_0011_111d_dddd
        Set inst.encoding to 0xAA0003E0  Note: Base ORR encoding
        Set inst.encoding to inst.encoding plus dest
        Set inst.encoding to inst.encoding plus (src left_shift 16)
    End If
    
    Set inst.rd to dest
    Set inst.rn to 31  Note: XZR for MOV
    Set inst.rm to src
    
    Return inst
End Process

Process called "encode_aarch64_add_sub" that takes is_add as Boolean, dest as Integer, src1 as Integer, src2 as Integer, is_immediate as Boolean, imm as Integer returns AArch64Instruction:
    Note: Encode ADD or SUB instruction
    
    @Implementation
    ADD/SUB support register and immediate forms.
    Immediate is 12-bit with optional shift by 12.
    @End Implementation
    
    Let inst be AArch64Instruction
    
    If is_immediate:
        Note: ADD/SUB immediate
        Let shift_bit be 0
        Let imm12 be imm
        
        Note: Check if we need to shift immediate
        If imm is greater than 0xFFF:
            If (imm bitwise_and 0xFFF) equals 0:
                Set shift_bit to 1
                Set imm12 to imm right_shift 12
            End If
        End If
        
        If is_add:
            Set inst.encoding to 0x91000000  Note: ADD immediate base
        Otherwise:
            Set inst.encoding to 0xD1000000  Note: SUB immediate base
        End If
        
        Set inst.encoding to inst.encoding plus dest
        Set inst.encoding to inst.encoding plus (src1 left_shift 5)
        Set inst.encoding to inst.encoding plus (imm12 left_shift 10)
        Set inst.encoding to inst.encoding plus (shift_bit left_shift 22)
    Otherwise:
        Note: ADD/SUB register
        If is_add:
            Set inst.encoding to 0x8B000000  Note: ADD register base
        Otherwise:
            Set inst.encoding to 0xCB000000  Note: SUB register base
        End If
        
        Set inst.encoding to inst.encoding plus dest
        Set inst.encoding to inst.encoding plus (src1 left_shift 5)
        Set inst.encoding to inst.encoding plus (src2 left_shift 16)
    End If
    
    Set inst.rd to dest
    Set inst.rn to src1
    Set inst.rm to src2
    
    Return inst
End Process

Process called "encode_aarch64_load_store" that takes is_load as Boolean, reg as Integer, base as Integer, offset as Integer, pre_index as Boolean returns AArch64Instruction:
    Note: Encode LDR/STR instruction
    
    @Implementation
    Load/store with various addressing modes: immediate offset,
    pre-index, post-index, and register offset.
    @End Implementation
    
    Let inst be AArch64Instruction
    
    Note: Check offset range and alignment
    Let is_unscaled be false
    If offset is less than 0 or (offset bitwise_and 7) is not equal to 0:
        Set is_unscaled to true
    End If
    
    If is_unscaled:
        Note: LDUR/STUR for unscaled offset
        If is_load:
            Set inst.encoding to 0xF8400000  Note: LDUR base
        Otherwise:
            Set inst.encoding to 0xF8000000  Note: STUR base
        End If
        
        Note: 9-bit signed immediate
        Let simm9 be offset bitwise_and 0x1FF
        Set inst.encoding to inst.encoding plus reg
        Set inst.encoding to inst.encoding plus (base left_shift 5)
        Set inst.encoding to inst.encoding plus (simm9 left_shift 12)
    Otherwise:
        Note: LDR/STR with unsigned immediate
        If is_load:
            Set inst.encoding to 0xF9400000  Note: LDR base
        Otherwise:
            Set inst.encoding to 0xF9000000  Note: STR base
        End If
        
        Note: 12-bit unsigned immediate (scaled by 8)
        Let uimm12 be offset divided by 8
        Set inst.encoding to inst.encoding plus reg
        Set inst.encoding to inst.encoding plus (base left_shift 5)
        Set inst.encoding to inst.encoding plus (uimm12 left_shift 10)
    End If
    
    If pre_index:
        Set inst.encoding to inst.encoding plus 0x00000C00  Note: Pre-index bit
    End If
    
    Set inst.rd to reg
    Set inst.rn to base
    Set inst.immediate to offset
    
    Return inst
End Process

Process called "encode_aarch64_branch" that takes is_conditional as Boolean, condition as Integer, target as Integer returns AArch64Instruction:
    Note: Encode branch instruction
    
    @Implementation
    B for unconditional, B.cond for conditional branches.
    PC-relative addressing with different offset ranges.
    @End Implementation
    
    Let inst be AArch64Instruction
    
    If is_conditional:
        Note: B.cond: 0101_0100_iiii_iiii_iiii_iiii_iii0_cccc
        Let imm19 be (target right_shift 2) bitwise_and 0x7FFFF
        Set inst.encoding to 0x54000000
        Set inst.encoding to inst.encoding plus condition
        Set inst.encoding to inst.encoding plus (imm19 left_shift 5)
    Otherwise:
        Note: B: 0001_01ii_iiii_iiii_iiii_iiii_iiii_iiii
        Let imm26 be (target right_shift 2) bitwise_and 0x3FFFFFF
        Set inst.encoding to 0x14000000
        Set inst.encoding to inst.encoding plus imm26
    End If
    
    Set inst.immediate to target
    
    Return inst
End Process

Process called "encode_aarch64_bl" that takes target as Integer returns AArch64Instruction:
    Note: Encode branch with link (call)
    
    @Implementation
    BL saves return address in X30 (LR) and branches.
    26-bit signed offset gives Â±128MB range.
    @End Implementation
    
    Let inst be AArch64Instruction
    
    Note: BL: 1001_01ii_iiii_iiii_iiii_iiii_iiii_iiii
    Let imm26 be (target right_shift 2) bitwise_and 0x3FFFFFF
    Set inst.encoding to 0x94000000
    Set inst.encoding to inst.encoding plus imm26
    
    Set inst.immediate to target
    
    Return inst
End Process

Process called "encode_aarch64_ret" that takes link_reg as Integer returns AArch64Instruction:
    Note: Encode return instruction
    
    @Implementation
    RET branches to address in link register (default X30).
    Can specify different register for computed returns.
    @End Implementation
    
    Let inst be AArch64Instruction
    
    Note: RET: 1101_0110_0101_1111_0000_00nn_nnn0_0000
    Set inst.encoding to 0xD65F0000
    Set inst.encoding to inst.encoding plus (link_reg left_shift 5)
    
    Set inst.rn to link_reg
    
    Return inst
End Process

Process called "encode_aarch64_cmp" that takes reg1 as Integer, reg2 as Integer, is_immediate as Boolean, imm as Integer returns AArch64Instruction:
    Note: Encode compare instruction
    
    @Implementation
    CMP is an alias for SUBS with XZR destination.
    Sets condition flags without storing result.
    @End Implementation
    
    Let inst be AArch64Instruction
    
    If is_immediate:
        Note: CMP immediate (SUBS XZR, Xn, #imm)
        Let imm12 be imm bitwise_and 0xFFF
        Set inst.encoding to 0xF1000000  Note: SUBS immediate with XZR
        Set inst.encoding to inst.encoding plus 31  Note: XZR destination
        Set inst.encoding to inst.encoding plus (reg1 left_shift 5)
        Set inst.encoding to inst.encoding plus (imm12 left_shift 10)
    Otherwise:
        Note: CMP register (SUBS XZR, Xn, Xm)
        Set inst.encoding to 0xEB00001F  Note: SUBS register with XZR
        Set inst.encoding to inst.encoding plus (reg1 left_shift 5)
        Set inst.encoding to inst.encoding plus (reg2 left_shift 16)
    End If
    
    Set inst.rd to 31  Note: XZR
    Set inst.rn to reg1
    Set inst.rm to reg2
    
    Return inst
End Process

Process called "encode_aarch64_logical" that takes op_type as Integer, dest as Integer, src1 as Integer, src2 as Integer returns AArch64Instruction:
    Note: Encode logical operations (AND, ORR, EOR)
    
    @Implementation
    Logical operations support register and immediate forms.
    Immediate encoding uses complex bitmask pattern.
    @End Implementation
    
    Let inst be AArch64Instruction
    
    Note: Register form
    Match op_type:
        When 0:  Note: AND
            Set inst.encoding to 0x8A000000
        When 1:  Note: ORR
            Set inst.encoding to 0xAA000000
        When 2:  Note: EOR
            Set inst.encoding to 0xCA000000
    End Match
    
    Set inst.encoding to inst.encoding plus dest
    Set inst.encoding to inst.encoding plus (src1 left_shift 5)
    Set inst.encoding to inst.encoding plus (src2 left_shift 16)
    
    Set inst.rd to dest
    Set inst.rn to src1
    Set inst.rm to src2
    
    Return inst
End Process

Process called "encode_aarch64_shift" that takes op_type as Integer, dest as Integer, src as Integer, shift_amount as Integer returns AArch64Instruction:
    Note: Encode shift operations (LSL, LSR, ASR)
    
    @Implementation
    Shifts are aliases for UBFM/SBFM instructions with specific patterns.
    LSL is special case using different encoding.
    @End Implementation
    
    Let inst be AArch64Instruction
    
    Match op_type:
        When 0:  Note: LSL
            Note: LSL is alias for UBFM with specific pattern
            Set inst.encoding to 0xD3400000
            Let imms be 63 minus shift_amount
            Let immr be (64 minus shift_amount) bitwise_and 63
            Set inst.encoding to inst.encoding plus dest
            Set inst.encoding to inst.encoding plus (src left_shift 5)
            Set inst.encoding to inst.encoding plus (immr left_shift 16)
            Set inst.encoding to inst.encoding plus (imms left_shift 10)
        When 1:  Note: LSR
            Set inst.encoding to 0xD340FC00
            Set inst.encoding to inst.encoding plus dest
            Set inst.encoding to inst.encoding plus (src left_shift 5)
            Set inst.encoding to inst.encoding plus (shift_amount left_shift 16)
        When 2:  Note: ASR
            Set inst.encoding to 0x9340FC00
            Set inst.encoding to inst.encoding plus dest
            Set inst.encoding to inst.encoding plus (src left_shift 5)
            Set inst.encoding to inst.encoding plus (shift_amount left_shift 16)
    End Match
    
    Set inst.rd to dest
    Set inst.rn to src
    Set inst.shift_amount to shift_amount
    
    Return inst
End Process

Process called "encode_aarch64_stp_ldp" that takes is_load as Boolean, reg1 as Integer, reg2 as Integer, base as Integer, offset as Integer returns AArch64Instruction:
    Note: Encode store/load pair instructions
    
    @Implementation
    STP/LDP efficiently transfer two registers to/from memory.
    Supports pre-index, post-index, and signed offset modes.
    @End Implementation
    
    Let inst be AArch64Instruction
    
    Note: Calculate 7-bit signed immediate (scaled by 8)
    Let simm7 be (offset divided by 8) bitwise_and 0x7F
    
    If is_load:
        Set inst.encoding to 0xA9400000  Note: LDP base
    Otherwise:
        Set inst.encoding to 0xA9000000  Note: STP base
    End If
    
    Set inst.encoding to inst.encoding plus reg1
    Set inst.encoding to inst.encoding plus (reg2 left_shift 10)
    Set inst.encoding to inst.encoding plus (base left_shift 5)
    Set inst.encoding to inst.encoding plus (simm7 left_shift 15)
    
    Set inst.rd to reg1
    Set inst.rn to base
    Set inst.rm to reg2
    Set inst.immediate to offset
    
    Return inst
End Process

Process called "write_aarch64_instruction" that takes inst as AArch64Instruction, buffer as Pointer returns Integer:
    Note: Write encoded instruction to buffer
    
    @Implementation
    AArch64 instructions are always 32-bit little-endian.
    Simple write compared to variable-length x86_64.
    @End Implementation
    
    Inline Assembly:
        "mov eax, %0\n"              Note: Load instruction encoding
        "mov [%1], eax\n"            Note: Store to buffer
        :
        : "r"(inst.encoding), "r"(buffer)
        : "rax", "memory"
    End Assembly
    
    Return 4  Note: Always 4 bytes
End Process

Process called "get_condition_code" that takes cond_name as Pointer returns Integer:
    Note: Get condition code from mnemonic
    
    @Implementation
    Maps condition names to 4-bit condition codes.
    EQ=0000, NE=0001, CS=0010, CC=0011, etc.
    @End Implementation
    
    Inline Assembly:
        "mov rsi, %1\n"              Note: Load condition name
        "\n"                         Note: Check EQ
        "lea rdi, [eq_str]\n"        Note: Load EQ string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_0\n"             Note: Jump if equal
        "\n"                         Note: Check NE
        "lea rdi, [ne_str]\n"        Note: Load NE string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_1\n"             Note: Jump if equal
        "\n"                         Note: Check CS
        "lea rdi, [cs_str]\n"        Note: Load CS string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_2\n"             Note: Jump if equal
        "\n"                         Note: Check CC
        "lea rdi, [cc_str]\n"        Note: Load CC string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_3\n"             Note: Jump if equal
        "\n"                         Note: Check MI
        "lea rdi, [mi_str]\n"        Note: Load MI string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_4\n"             Note: Jump if equal
        "\n"                         Note: Check PL
        "lea rdi, [pl_str]\n"        Note: Load PL string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_5\n"             Note: Jump if equal
        "\n"                         Note: Check VS
        "lea rdi, [vs_str]\n"        Note: Load VS string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_6\n"             Note: Jump if equal
        "\n"                         Note: Check VC
        "lea rdi, [vc_str]\n"        Note: Load VC string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_7\n"             Note: Jump if equal
        "\n"                         Note: Check HI
        "lea rdi, [hi_str]\n"        Note: Load HI string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_8\n"             Note: Jump if equal
        "\n"                         Note: Check LS
        "lea rdi, [ls_str]\n"        Note: Load LS string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_9\n"             Note: Jump if equal
        "\n"                         Note: Check GE
        "lea rdi, [ge_str]\n"        Note: Load GE string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_10\n"            Note: Jump if equal
        "\n"                         Note: Check LT
        "lea rdi, [lt_str]\n"        Note: Load LT string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_11\n"            Note: Jump if equal
        "\n"                         Note: Check GT
        "lea rdi, [gt_str]\n"        Note: Load GT string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_12\n"            Note: Jump if equal
        "\n"                         Note: Check LE
        "lea rdi, [le_str]\n"        Note: Load LE string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_13\n"            Note: Jump if equal
        "\n"                         Note: Check AL
        "lea rdi, [al_str]\n"        Note: Load AL string
        "call strcmp\n"              Note: Compare strings
        "test rax, rax\n"            Note: Check result
        "jz .return_14\n"            Note: Jump if equal
        "\n"                         Note: Not found - return NV
        "mov rax, 15\n"              Note: NV (never) - reserved
        "jmp .done\n"                Note: Jump to end
        "\n"                         Note: Return labels
        ".return_0:\n"               Note: Return 0 (EQ)
        "xor rax, rax\n"             Note: Clear RAX
        "jmp .done\n"                Note: Jump to end
        ".return_1:\n"               Note: Return 1 (NE)
        "mov rax, 1\n"               Note: Set RAX to 1
        "jmp .done\n"                Note: Jump to end
        ".return_2:\n"               Note: Return 2 (CS)
        "mov rax, 2\n"               Note: Set RAX to 2
        "jmp .done\n"                Note: Jump to end
        ".return_3:\n"               Note: Return 3 (CC)
        "mov rax, 3\n"               Note: Set RAX to 3
        "jmp .done\n"                Note: Jump to end
        ".return_4:\n"               Note: Return 4 (MI)
        "mov rax, 4\n"               Note: Set RAX to 4
        "jmp .done\n"                Note: Jump to end
        ".return_5:\n"               Note: Return 5 (PL)
        "mov rax, 5\n"               Note: Set RAX to 5
        "jmp .done\n"                Note: Jump to end
        ".return_6:\n"               Note: Return 6 (VS)
        "mov rax, 6\n"               Note: Set RAX to 6
        "jmp .done\n"                Note: Jump to end
        ".return_7:\n"               Note: Return 7 (VC)
        "mov rax, 7\n"               Note: Set RAX to 7
        "jmp .done\n"                Note: Jump to end
        ".return_8:\n"               Note: Return 8 (HI)
        "mov rax, 8\n"               Note: Set RAX to 8
        "jmp .done\n"                Note: Jump to end
        ".return_9:\n"               Note: Return 9 (LS)
        "mov rax, 9\n"               Note: Set RAX to 9
        "jmp .done\n"                Note: Jump to end
        ".return_10:\n"              Note: Return 10 (GE)
        "mov rax, 10\n"              Note: Set RAX to 10
        "jmp .done\n"                Note: Jump to end
        ".return_11:\n"              Note: Return 11 (LT)
        "mov rax, 11\n"              Note: Set RAX to 11
        "jmp .done\n"                Note: Jump to end
        ".return_12:\n"              Note: Return 12 (GT)
        "mov rax, 12\n"              Note: Set RAX to 12
        "jmp .done\n"                Note: Jump to end
        ".return_13:\n"              Note: Return 13 (LE)
        "mov rax, 13\n"              Note: Set RAX to 13
        "jmp .done\n"                Note: Jump to end
        ".return_14:\n"              Note: Return 14 (AL)
        "mov rax, 14\n"              Note: Set RAX to 14
        ".done:\n"                   Note: End label
        "mov %0, rax\n"              Note: Store result
        : "=r"(result)
        : "r"(cond_name)
        : "rax", "rdi", "rsi", "memory"
    End Assembly
    
    Let result as Integer
    Return result
End Process

Note: Condition code strings
Inline Assembly:
    "section .rodata\n"           Note: Read-only data section
    "eq_str: db 'eq', 0\n"       Note: Equal condition
    "ne_str: db 'ne', 0\n"       Note: Not equal condition
    "cs_str: db 'cs', 0\n"       Note: Carry set (unsigned >=)
    "cc_str: db 'cc', 0\n"       Note: Carry clear (unsigned <)
    "mi_str: db 'mi', 0\n"       Note: Minus (negative)
    "pl_str: db 'pl', 0\n"       Note: Plus (positive or zero)
    "vs_str: db 'vs', 0\n"       Note: Overflow set
    "vc_str: db 'vc', 0\n"       Note: Overflow clear
    "hi_str: db 'hi', 0\n"       Note: Unsigned higher
    "ls_str: db 'ls', 0\n"       Note: Unsigned lower or same
    "ge_str: db 'ge', 0\n"       Note: Signed greater or equal
    "lt_str: db 'lt', 0\n"       Note: Signed less than
    "gt_str: db 'gt', 0\n"       Note: Signed greater than
    "le_str: db 'le', 0\n"       Note: Signed less or equal
    "al_str: db 'al', 0\n"       Note: Always (unconditional)
    "\n"                         Note: Separator
    "strcmp:\n"                  Note: String comparison function
    "    push rbx\n"              Note: Save rbx
    ".loop:\n"                   Note: Comparison loop
    "    mov al, [rdi]\n"         Note: Load byte from first string
    "    mov bl, [rsi]\n"         Note: Load byte from second string
    "    cmp al, bl\n"            Note: Compare bytes
    "    jne .not_equal\n"        Note: Jump if not equal
    "    test al, al\n"           Note: Check for null terminator
    "    jz .equal\n"             Note: Jump if end of string
    "    inc rdi\n"               Note: Next character in first string
    "    inc rsi\n"               Note: Next character in second string
    "    jmp .loop\n"             Note: Continue loop
    ".equal:\n"                  Note: Strings are equal
    "    xor rax, rax\n"          Note: Return 0 (equal)
    "    pop rbx\n"               Note: Restore rbx
    "    ret\n"                   Note: Return
    ".not_equal:\n"              Note: Strings not equal
    "    mov rax, 1\n"            Note: Return 1 (not equal)
    "    pop rbx\n"               Note: Restore rbx
    "    ret\n"                   Note: Return
    :
    :
    : "memory"
End Assembly