Note: Runtime platform detection and selection

Import "./x86_64/registers.runa" as X86Registers
Import "./x86_64/instructions.runa" as X86Instructions
Import "./x86_64/calling_convention.runa" as X86ABI
Import "./aarch64/registers.runa" as ARM64Registers
Import "./aarch64/instructions.runa" as ARM64Instructions
Import "./aarch64/calling_convention.runa" as ARM64ABI

@Reasoning
The compiler needs to detect the target platform at runtime or compile-time
and select the appropriate backend. This module provides platform detection,
feature detection, and a unified interface for platform-specific operations.
@End Reasoning

Type called "Platform":
    Note: Target platform information
    
    @Implementation
    Contains all information needed to select the correct code generation
    backend and configure platform-specific optimizations.
    @End Implementation
    
    arch_type as Integer      Note: 0=x86_64, 1=aarch64, 2=riscv, 3=wasm
    os_type as Integer        Note: 0=linux, 1=macos, 2=windows, 3=bsd
    abi_type as Integer       Note: 0=sysv, 1=ms, 2=aapcs
    word_size as Integer      Note: 4 or 8 bytes
    endianness as Integer     Note: 0=little, 1=big
    has_sse as Boolean
    has_avx as Boolean
    has_avx512 as Boolean
    has_neon as Boolean
    has_sve as Boolean
End Type

Type called "PlatformInterface":
    Note: Unified interface for platform operations
    
    @Implementation
    Provides function pointers to platform-specific implementations,
    allowing the compiler to use a single interface for all targets.
    @End Implementation
    
    encode_mov as Pointer
    encode_arithmetic as Pointer
    encode_branch as Pointer
    encode_call as Pointer
    encode_return as Pointer
    setup_frame as Pointer
    generate_prologue as Pointer
    generate_epilogue as Pointer
    allocate_register as Pointer
    free_register as Pointer
End Type

Process called "detect_current_platform" returns Platform:
    Note: Detect the current compilation platform
    
    @Implementation
    Uses compile-time macros and runtime detection to determine
    the target platform and available features.
    @End Implementation
    
    Let platform be Platform
    
    Note: Detect architecture using CPUID on x86 or system calls
    Inline Assembly:
        "mov %0, %1"                   Note: Try CPUID first (x86_64)
        "cpuid"                        Note: Execute CPUID instruction
        "cmp %2, %3"                   Note: Compare EBX to 'Genu'
        "jne .try_arm"                 Note: Jump if not Intel
        "cmp %4, %5"                   Note: Compare EDX to 'ineI'
        "jne .try_arm"                 Note: Jump if not Intel
        "cmp %6, %7"                   Note: Compare ECX to 'ntel'
        "jne .check_amd"               Note: Jump to check AMD
        "mov dword ptr [platform_arch], %8" Note: Set Intel x86_64
        "jmp .detect_features"         Note: Jump to feature detection
        ".check_amd:"                   Note: Check AMD signature
        "cmp %9, %10"                  Note: Compare EBX to 'Auth'
        "jne .try_arm"                 Note: Jump if not AMD
        "cmp %11, %12"                 Note: Compare EDX to 'enti'
        "jne .try_arm"                 Note: Jump if not AMD
        "cmp %13, %14"                 Note: Compare ECX to 'cAMD'
        "jne .try_arm"                 Note: Jump if not AMD
        "mov dword ptr [platform_arch], %15" Note: Set AMD x86_64
        "jmp .detect_features"         Note: Jump to feature detection
        ".try_arm:"                     Note: Check for ARM architecture
        "mov dword ptr [platform_arch], %16" Note: Assume ARM if not x86
        ".detect_features:"             Note: Load detected architecture
        "mov %17, dword ptr [platform_arch]" Note: Get architecture type
        "mov %18, %17"                 Note: Store in platform
        : "=r"(platform.arch_type)
        : "i"(0), "r"(ebx), "i"(0x756E6547), "r"(edx), "i"(0x49656E69), "r"(ecx), "i"(0x6C65746E), "i"(0), "r"(ebx), "i"(0x68747541), "r"(edx), "i"(0x69746E65), "r"(ecx), "i"(0x444D4163), "i"(0), "i"(1), "r"(eax), "r"(platform.arch_type)
        : "eax", "ebx", "ecx", "edx", "memory"
    End Assembly
    
    Note: Detect operating system
    Inline Assembly:
        "mov %0, %1"                   Note: Load sys_uname syscall number
        "mov %2, uname_buffer"         Note: Load buffer address
        "syscall"                      Note: Execute system call
        "test %3, %3"                  Note: Check return value
        "jns .is_linux"                Note: Jump if successful
        "mov %4, %5"                   Note: Try macOS sys_write
        "xor %6, %6"                   Note: Clear RDI
        "test %7, %7"                  Note: Check return value
        "jz .is_macos"                 Note: Jump if macOS
        ".is_linux:"                    Note: Set Linux OS type
        "mov dword ptr [platform_os], %8" Note: Store Linux ID
        "jmp .os_done"                 Note: Jump to completion
        ".is_macos:"                    Note: Set macOS OS type
        "mov dword ptr [platform_os], %9" Note: Store macOS ID
        ".os_done:"                     Note: Load OS type
        "mov %10, dword ptr [platform_os]" Note: Get OS type
        "mov %11, %10"                 Note: Store in platform
        : "=r"(platform.os_type)
        : "i"(63), "r"(rdi), "r"(rax), "r"(rax), "i"(0x2000004), "r"(rdi), "r"(rax), "i"(0), "i"(1), "r"(eax), "r"(platform.os_type)
        : "rax", "rdi", "memory"
    End Assembly
    
    Note: Set ABI based on OS and arch
    If platform.arch_type equals 0:  Note: x86_64
        If platform.os_type equals 2:  Note: Windows
            Set platform.abi_type to 1  Note: MS ABI
        Otherwise:
            Set platform.abi_type to 0  Note: System V ABI
        End If
    Otherwise:
        If platform.arch_type equals 1:  Note: AArch64
            Set platform.abi_type to 2  Note: AAPCS
        End If
    End If
    
    Note: Set architecture properties
    If platform.arch_type equals 0 or platform.arch_type equals 1:
        Set platform.word_size to 8
    Otherwise:
        Set platform.word_size to 4
    End If
    
    Set platform.endianness to 0  Note: Little endian default
    
    Note: Detect CPU features for x86_64
    If platform.arch_type equals 0:
        Inline Assembly:
            "mov %0, %1"                   Note: Load CPUID leaf 1
            "cpuid"                        Note: Execute CPUID
            "test %2, %3"                  Note: Test SSE bit (bit 25)
            "setnz %4"                     Note: Set SSE support flag
            "test %5, %6"                  Note: Test AVX bit (bit 28)
            "setnz %7"                     Note: Set AVX support flag
            "mov %8, %9"                   Note: Load CPUID leaf 7
            "xor %10, %10"                 Note: Clear ECX
            "cpuid"                        Note: Execute CPUID
            "test %11, %12"                Note: Test AVX512F bit (bit 16)
            "setnz %13"                    Note: Set AVX-512 support flag
            : "=r"(platform.has_sse), "=r"(platform.has_avx), "=r"(platform.has_avx512)
            : "i"(1), "r"(edx), "i"(0x02000000), "r"(platform.has_sse), "r"(ecx), "i"(0x10000000), "r"(platform.has_avx), "i"(7), "r"(ecx), "r"(ebx), "i"(0x00010000), "r"(platform.has_avx512)
            : "eax", "ebx", "ecx", "edx", "memory"
        End Assembly
    End If
    
    Note: Detect CPU features for AArch64
    If platform.arch_type equals 1:
        Set platform.has_neon to true  Note: NEON is mandatory in AArch64
        Set platform.has_sve to false  Note: Would check ID_AA64PFR0_EL1
    End If
    
    Return platform
End Process

Process called "create_platform_interface" that takes platform as Platform returns PlatformInterface:
    Note: Create platform-specific function interface
    
    @Implementation
    Selects and configures the appropriate backend functions based on
    the detected platform, providing a unified interface.
    @End Implementation
    
    Let interface be PlatformInterface
    
    If platform.arch_type equals 0:  Note: x86_64
        Note: Set x86_64 function pointers
        Inline Assembly:
            "lea %0, [x86_encode_mov]"     Note: Load x86 MOV encoder address
            "mov %1, %0"                  Note: Store encode_mov pointer
            "lea %2, [x86_encode_arithmetic]" Note: Load arithmetic encoder address
            "mov %3, %2"                  Note: Store encode_arithmetic pointer
            "lea %4, [x86_encode_branch]"  Note: Load branch encoder address
            "mov %5, %4"                  Note: Store encode_branch pointer
            "lea %6, [x86_encode_call]"    Note: Load call encoder address
            "mov %7, %6"                  Note: Store encode_call pointer
            "lea %8, [x86_encode_return]"  Note: Load return encoder address
            "mov %9, %8"                  Note: Store encode_return pointer
            "lea %10, [x86_setup_frame]"   Note: Load frame setup address
            "mov %11, %10"                Note: Store setup_frame pointer
            "lea %12, [x86_generate_prologue]" Note: Load prologue generator address
            "mov %13, %12"                Note: Store generate_prologue pointer
            "lea %14, [x86_generate_epilogue]" Note: Load epilogue generator address
            "mov %15, %14"                Note: Store generate_epilogue pointer
            "lea %16, [x86_allocate_register]" Note: Load register allocator address
            "mov %17, %16"                Note: Store allocate_register pointer
            "lea %18, [x86_free_register]" Note: Load register freeer address
            "mov %19, %18"                Note: Store free_register pointer
            : "=r"(interface.encode_mov), "=r"(interface.encode_arithmetic), "=r"(interface.encode_branch), "=r"(interface.encode_call), "=r"(interface.encode_return), "=r"(interface.setup_frame), "=r"(interface.generate_prologue), "=r"(interface.generate_epilogue), "=r"(interface.allocate_register), "=r"(interface.free_register)
            : 
            : "rax", "memory"
        End Assembly
    Otherwise:
        If platform.arch_type equals 1:  Note: AArch64
            Inline Assembly:
                "lea %0, [arm64_encode_mov]"    Note: Load ARM64 MOV encoder address
                "mov %1, %0"                   Note: Store encode_mov pointer
                "lea %2, [arm64_encode_arithmetic]" Note: Load arithmetic encoder address
                "mov %3, %2"                   Note: Store encode_arithmetic pointer
                "lea %4, [arm64_encode_branch]" Note: Load branch encoder address
                "mov %5, %4"                   Note: Store encode_branch pointer
                "lea %6, [arm64_encode_call]"   Note: Load call encoder address
                "mov %7, %6"                   Note: Store encode_call pointer
                "lea %8, [arm64_encode_return]" Note: Load return encoder address
                "mov %9, %8"                   Note: Store encode_return pointer
                "lea %10, [arm64_setup_frame]"  Note: Load frame setup address
                "mov %11, %10"                 Note: Store setup_frame pointer
                "lea %12, [arm64_generate_prologue]" Note: Load prologue generator address
                "mov %13, %12"                 Note: Store generate_prologue pointer
                "lea %14, [arm64_generate_epilogue]" Note: Load epilogue generator address
                "mov %15, %14"                 Note: Store generate_epilogue pointer
                "lea %16, [arm64_allocate_register]" Note: Load register allocator address
                "mov %17, %16"                 Note: Store allocate_register pointer
                "lea %18, [arm64_free_register]" Note: Load register freeer address
                "mov %19, %18"                 Note: Store free_register pointer
                : "=r"(interface.encode_mov), "=r"(interface.encode_arithmetic), "=r"(interface.encode_branch), "=r"(interface.encode_call), "=r"(interface.encode_return), "=r"(interface.setup_frame), "=r"(interface.generate_prologue), "=r"(interface.generate_epilogue), "=r"(interface.allocate_register), "=r"(interface.free_register)
                : 
                : "rax", "memory"
            End Assembly
        End If
    End If
    
    Return interface
End Process

Process called "get_platform_name" that takes platform as Platform returns Pointer:
    Note: Get human-readable platform name
    
    @Implementation
    Returns a string describing the platform for diagnostics and logging.
    Combines architecture, OS, and ABI information.
    @End Implementation
    
    Let arch_name as Pointer
    Let os_name as Pointer
    Let abi_name as Pointer
    
    Match platform.arch_type:
        When 0:
            Inline Assembly:
                "lea %0, [x86_64_str]"         Note: Load x86_64 string address
                : "=r"(arch_name)
                : 
                : "memory"
            End Assembly
        When 1:
            Inline Assembly:
                "lea %0, [aarch64_str]"        Note: Load aarch64 string address
                : "=r"(arch_name)
                : 
                : "memory"
            End Assembly
        When 2:
            Inline Assembly:
                "lea %0, [riscv_str]"          Note: Load riscv string address
                : "=r"(arch_name)
                : 
                : "memory"
            End Assembly
        When 3:
            Inline Assembly:
                "lea %0, [wasm_str]"           Note: Load wasm string address
                : "=r"(arch_name)
                : 
                : "memory"
            End Assembly
    End Match
    
    Match platform.os_type:
        When 0:
            Inline Assembly:
                "lea %0, [linux_str]"          Note: Load linux string address
                : "=r"(os_name)
                : 
                : "memory"
            End Assembly
        When 1:
            Inline Assembly:
                "lea %0, [macos_str]"          Note: Load macos string address
                : "=r"(os_name)
                : 
                : "memory"
            End Assembly
        When 2:
            Inline Assembly:
                "lea %0, [windows_str]"        Note: Load windows string address
                : "=r"(os_name)
                : 
                : "memory"
            End Assembly
        When 3:
            Inline Assembly:
                "lea %0, [bsd_str]"            Note: Load bsd string address
                : "=r"(os_name)
                : 
                : "memory"
            End Assembly
    End Match
    
    Match platform.abi_type:
        When 0:
            Inline Assembly:
                "lea %0, [sysv_str]"           Note: Load sysv string address
                : "=r"(abi_name)
                : 
                : "memory"
            End Assembly
        When 1:
            Inline Assembly:
                "lea %0, [ms_str]"             Note: Load ms string address
                : "=r"(abi_name)
                : 
                : "memory"
            End Assembly
        When 2:
            Inline Assembly:
                "lea %0, [aapcs_str]"          Note: Load aapcs string address
                : "=r"(abi_name)
                : 
                : "memory"
            End Assembly
    End Match
    
    Note: Build platform string
    Inline Assembly:
        "lea %0, [platform_name_buffer]" Note: Load buffer address
        "mov %1, %2"                    Note: Load arch_name
        "call strcpy"                   Note: Copy arch string
        "mov byte ptr [%3], '-'"        Note: Add separator
        "inc %4"                        Note: Advance pointer
        "mov %5, %6"                    Note: Load os_name
        "call strcpy"                   Note: Copy OS string
        "mov byte ptr [%7], '-'"        Note: Add separator
        "inc %8"                        Note: Advance pointer
        "mov %9, %10"                   Note: Load abi_name
        "call strcpy"                   Note: Copy ABI string
        "lea %11, [platform_name_buffer]" Note: Load result address
        "mov %12, %11"                  Note: Store result
        : "=r"(result)
        : "r"(rdi), "r"(arch_name), "r"(rdi), "r"(rdi), "r"(rsi), "r"(os_name), "r"(rdi), "r"(rdi), "r"(rsi), "r"(abi_name), "r"(rax), "r"(result)
        : "rdi", "rsi", "rax", "memory"
    End Assembly
    
    Let result as Pointer
    Return result
End Process

Process called "is_platform_supported" that takes platform as Platform returns Boolean:
    Note: Check if platform is supported by compiler
    
    @Implementation
    Validates that the compiler has full support for the target platform.
    Some platforms may be detected but not fully implemented.
    @End Implementation
    
    Note: Currently support x86_64 and AArch64
    If platform.arch_type equals 0 or platform.arch_type equals 1:
        Note: Check OS support
        If platform.os_type is less than or equal to 3:
            Return true
        End If
    End If
    
    Return false
End Process

Process called "get_register_count" that takes platform as Platform, is_float as Boolean returns Integer:
    Note: Get number of available registers
    
    @Implementation
    Returns the count of general purpose or floating point registers
    available for the target platform's calling convention.
    @End Implementation
    
    If platform.arch_type equals 0:  Note: x86_64
        If is_float:
            Return 16  Note: XMM0-XMM15
        Otherwise:
            Return 16  Note: RAX-R15
        End If
    Otherwise:
        If platform.arch_type equals 1:  Note: AArch64
            If is_float:
                Return 32  Note: V0-V31
            Otherwise:
                Return 31  Note: X0-X30
            End If
        End If
    End If
    
    Return 0
End Process

Process called "get_stack_alignment" that takes platform as Platform returns Integer:
    Note: Get required stack alignment
    
    @Implementation
    Returns the stack alignment requirement for the target ABI.
    Critical for correct function calls and local variable access.
    @End Implementation
    
    If platform.arch_type equals 0:  Note: x86_64
        Return 16  Note: System V requires 16-byte alignment
    Otherwise:
        If platform.arch_type equals 1:  Note: AArch64
            Return 16  Note: AAPCS64 requires 16-byte alignment
        End If
    End If
    
    Return 8  Note: Default minimum alignment
End Process

Process called "supports_vector_ops" that takes platform as Platform returns Boolean:
    Note: Check if platform supports vector operations
    
    @Implementation
    Determines if the platform has SIMD/vector instruction support
    that the compiler can utilize for optimizations.
    @End Implementation
    
    If platform.arch_type equals 0:  Note: x86_64
        Return platform.has_sse or platform.has_avx
    Otherwise:
        If platform.arch_type equals 1:  Note: AArch64
            Return platform.has_neon or platform.has_sve
        End If
    End If
    
    Return false
End Process

Note: Platform name strings
Inline Assembly:
    ".section .data"                    Note: Data section for variables
    "platform_arch: .long 0"           Note: Architecture storage
    "platform_os: .long 0"             Note: OS type storage
    "uname_buffer: .skip 256"          Note: Buffer for uname syscall
    "platform_name_buffer: .skip 64"   Note: Buffer for platform name
    ".section .rodata"                  Note: Read-only data section
    "x86_64_str: .asciz 'x86_64'"      Note: x86_64 architecture string
    "aarch64_str: .asciz 'aarch64'"    Note: aarch64 architecture string
    "riscv_str: .asciz 'riscv'"        Note: riscv architecture string
    "wasm_str: .asciz 'wasm'"          Note: wasm architecture string
    "linux_str: .asciz 'linux'"        Note: Linux OS string
    "macos_str: .asciz 'macos'"        Note: macOS OS string
    "windows_str: .asciz 'windows'"    Note: Windows OS string
    "bsd_str: .asciz 'bsd'"            Note: BSD OS string
    "sysv_str: .asciz 'sysv'"          Note: System V ABI string
    "ms_str: .asciz 'ms'"              Note: Microsoft ABI string
    "aapcs_str: .asciz 'aapcs'"        Note: AAPCS ABI string
    "strcpy:"                          Note: String copy function
    "push %rsi"                        Note: Save source pointer
    "push %rdi"                        Note: Save dest pointer
    ".strcpy_loop:"                     Note: Copy loop
    "mov (%rsi), %al"                  Note: Load source byte
    "mov %al, (%rdi)"                  Note: Store to destination
    "test %al, %al"                    Note: Check for null terminator
    "jz .strcpy_done"                  Note: Jump if end of string
    "inc %rsi"                         Note: Advance source
    "inc %rdi"                         Note: Advance destination
    "jmp .strcpy_loop"                 Note: Continue loop
    ".strcpy_done:"                     Note: Cleanup and return
    "pop %rdi"                         Note: Restore destination
    "pop %rsi"                         Note: Restore source
    "ret"                              Note: Return to caller
    "x86_encode_mov:"                  Note: x86 MOV wrapper
    "jmp X86Instructions.encode_mov"   Note: Jump to implementation
    "x86_encode_arithmetic:"           Note: x86 arithmetic wrapper
    "jmp X86Instructions.encode_arithmetic" Note: Jump to implementation
    "x86_encode_branch:"               Note: x86 branch wrapper
    "jmp X86Instructions.encode_jump" Note: Jump to implementation
    "x86_encode_call:"                 Note: x86 call wrapper
    "jmp X86Instructions.encode_call" Note: Jump to implementation
    "x86_encode_return:"               Note: x86 return wrapper
    "ret"                              Note: Placeholder return
    "x86_setup_frame:"                 Note: x86 frame setup wrapper
    "jmp X86ABI.setup_call_frame"     Note: Jump to implementation
    "x86_generate_prologue:"           Note: x86 prologue wrapper
    "jmp X86ABI.generate_prologue"    Note: Jump to implementation
    "x86_generate_epilogue:"           Note: x86 epilogue wrapper
    "jmp X86ABI.generate_epilogue"    Note: Jump to implementation
    "x86_allocate_register:"           Note: x86 register allocator wrapper
    "jmp X86Registers.allocate_gpr"   Note: Jump to implementation
    "x86_free_register:"               Note: x86 register freeer wrapper
    "jmp X86Registers.free_gpr"       Note: Jump to implementation
    "arm64_encode_mov:"                Note: ARM64 MOV wrapper
    "jmp ARM64Instructions.encode_aarch64_mov" Note: Jump to implementation
    "arm64_encode_arithmetic:"         Note: ARM64 arithmetic wrapper
    "jmp ARM64Instructions.encode_aarch64_add_sub" Note: Jump to implementation
    "arm64_encode_branch:"             Note: ARM64 branch wrapper
    "jmp ARM64Instructions.encode_aarch64_branch" Note: Jump to implementation
    "arm64_encode_call:"               Note: ARM64 call wrapper
    "jmp ARM64Instructions.encode_aarch64_bl" Note: Jump to implementation
    "arm64_encode_return:"             Note: ARM64 return wrapper
    "jmp ARM64Instructions.encode_aarch64_ret" Note: Jump to implementation
    "arm64_setup_frame:"               Note: ARM64 frame setup wrapper
    "jmp ARM64ABI.setup_aapcs64_frame" Note: Jump to implementation
    "arm64_generate_prologue:"         Note: ARM64 prologue wrapper
    "jmp ARM64ABI.generate_aapcs64_prologue" Note: Jump to implementation
    "arm64_generate_epilogue:"         Note: ARM64 epilogue wrapper
    "jmp ARM64ABI.generate_aapcs64_epilogue" Note: Jump to implementation
    "arm64_allocate_register:"         Note: ARM64 register allocator wrapper
    "jmp ARM64Registers.allocate_aarch64_gpr" Note: Jump to implementation
    "arm64_free_register:"             Note: ARM64 register freeer wrapper
    "jmp ARM64Registers.free_aarch64_gpr" Note: Jump to implementation
    : 
    : 
    : "memory"
End Assembly