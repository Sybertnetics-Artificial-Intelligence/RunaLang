Note:
intrinsics/alignof.runa - Zero-Dependency Type Alignment Intrinsics

This module provides fundamental type alignment calculation operations using direct assembly instructions.
These primitives have ZERO dependencies and compile to efficient alignment computation.

@Reasoning:
- Provides low-level type alignment information for compiler code generation
- All operations use inline assembly for true self-hosting capabilities
- No external dependencies - we generate the machine code directly
- Essential for implementing memory layout, struct packing, and performance optimization
@End Reasoning

@Implementation:
- Inline Assembly statements using immediate alignment values
- Compile-time alignment calculation for known types
- Support for complex type alignment computation
- Zero-cost abstraction through compile-time optimization
@End Implementation

@Performance_Hints:
- Type alignments resolved at compile time when possible
- Immediate values used for primitive type alignments
- Complex types computed using maximum alignment rules
- No runtime overhead for alignment calculations
@End Performance_Hints
:End Note

Note: =====================================================================
Note: PRIMITIVE TYPE ALIGNMENTS
Note: =====================================================================

Process called "alignof_boolean" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $1"                     Note: Load alignment value 1 for boolean
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_integer8" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $1"                     Note: Load alignment value 1 for 8-bit integer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_unsigned8" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $1"                     Note: Load alignment value 1 for unsigned 8-bit
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_integer16" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $2"                     Note: Load alignment value 2 for 16-bit integer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_unsigned16" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $2"                     Note: Load alignment value 2 for unsigned 16-bit
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_integer32" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $4"                     Note: Load alignment value 4 for 32-bit integer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_unsigned32" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $4"                     Note: Load alignment value 4 for unsigned 32-bit
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_integer64" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for 64-bit integer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_unsigned64" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for unsigned 64-bit
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_integer" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for default integer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_float32" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $4"                     Note: Load alignment value 4 for 32-bit float
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_float64" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for 64-bit float
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_float" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for default float
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_pointer" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_char" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $1"                     Note: Load alignment value 1 for character
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: COMPOUND TYPE ALIGNMENTS
Note: =====================================================================

Process called "alignof_array" that takes element_alignment as Integer returns Integer:
    Note: Array alignment is same as element alignment
    Return element_alignment
End Process

Process called "alignof_fixed_array" that takes element_alignment as Integer returns Integer:
    Note: Fixed array alignment is same as element alignment
    Return element_alignment
End Process

Process called "alignof_dynamic_array" returns Integer:
    Note: Dynamic array alignment is pointer alignment
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for dynamic array (pointer)
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_slice" returns Integer:
    Note: Slice alignment is pointer alignment
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for slice (pointer)
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_string" returns Integer:
    Note: String alignment is pointer alignment
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for string (pointer)
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_string_view" returns Integer:
    Note: String view alignment is pointer alignment
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for string view (pointer)
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: STRUCT ALIGNMENT CALCULATION
Note: =====================================================================

Process called "alignof_struct" that takes field_alignments as Pointer, field_count as Integer returns Integer:
    Let max_alignment be 1
    Let i be 0
    While i is less than field_count:
        Let field_offset be multiply_by_8(i)
        Let field_align_ptr be add_pointer_offset(field_alignments, field_offset)
        Let field_alignment be load_integer_from_pointer(field_align_ptr)
        If field_alignment is greater than max_alignment:
            Let max_alignment be field_alignment
        End If
        Let i be add_integers(i, 1)
    End While
    Return max_alignment
End Process

Process called "alignof_packed_struct" returns Integer:
    Note: Packed struct has alignment of 1 (no padding)
    Let result be 0
    Inline Assembly:
        "mov %0, $1"                     Note: Load alignment value 1 for packed struct
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_aligned_struct" that takes explicit_alignment as Integer returns Integer:
    Note: Explicitly aligned struct uses specified alignment
    Return explicit_alignment
End Process

Note: =====================================================================
Note: UNION ALIGNMENT CALCULATION
Note: =====================================================================

Process called "alignof_union" that takes variant_alignments as Pointer, variant_count as Integer returns Integer:
    Let max_alignment be 1
    Let i be 0
    While i is less than variant_count:
        Let variant_offset be multiply_by_8(i)
        Let variant_align_ptr be add_pointer_offset(variant_alignments, variant_offset)
        Let variant_alignment be load_integer_from_pointer(variant_align_ptr)
        If variant_alignment is greater than max_alignment:
            Let max_alignment be variant_alignment
        End If
        Let i be add_integers(i, 1)
    End While
    Return max_alignment
End Process

Process called "alignof_tagged_union" that takes tag_alignment as Integer, union_alignment as Integer returns Integer:
    Return max_integer(tag_alignment, union_alignment)
End Process

Process called "alignof_enum" that takes base_type_alignment as Integer returns Integer:
    Return base_type_alignment
End Process

Note: =====================================================================
Note: FUNCTION AND CLOSURE ALIGNMENTS
Note: =====================================================================

Process called "alignof_function_pointer" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for function pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_closure" that takes capture_alignment as Integer returns Integer:
    Note: Closure alignment is max of function pointer and captured data
    Return max_integer(8, capture_alignment)
End Process

Process called "alignof_virtual_function_table" returns Integer:
    Note: VTable alignment is pointer alignment
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for vtable (pointer)
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_object_with_vtable" that takes object_alignment as Integer returns Integer:
    Note: Object with vtable alignment is max of pointer and object alignment
    Return max_integer(8, object_alignment)
End Process

Note: =====================================================================
Note: CONTAINER ALIGNMENTS
Note: =====================================================================

Process called "alignof_vector" returns Integer:
    Note: Vector alignment is pointer alignment
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for vector (pointer)
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_list_node" that takes data_alignment as Integer returns Integer:
    Note: List node alignment is max of data and pointer alignment
    Return max_integer(data_alignment, 8)
End Process

Process called "alignof_hash_table_entry" that takes key_alignment as Integer, value_alignment as Integer returns Integer:
    Note: Hash entry alignment is max of key, value, and pointer alignments
    Let max_align be max_integer(key_alignment, value_alignment)
    Return max_integer(max_align, 8)
End Process

Process called "alignof_tree_node" that takes data_alignment as Integer returns Integer:
    Note: Tree node alignment is max of data and pointer alignment
    Return max_integer(data_alignment, 8)
End Process

Note: =====================================================================
Note: GENERIC TYPE ALIGNMENTS
Note: =====================================================================

Process called "alignof_optional" that takes inner_type_alignment as Integer returns Integer:
    Note: Optional alignment is max of tag and inner type alignment
    Return max_integer(8, inner_type_alignment)
End Process

Process called "alignof_result" that takes ok_alignment as Integer, error_alignment as Integer returns Integer:
    Note: Result alignment is max of tag and union alignment
    Let union_alignment be max_integer(ok_alignment, error_alignment)
    Return max_integer(8, union_alignment)
End Process

Process called "alignof_tuple" that takes element_alignments as Pointer, element_count as Integer returns Integer:
    Note: Tuple alignment is maximum of all element alignments
    Return alignof_struct(element_alignments, element_count)
End Process

Note: =====================================================================
Note: PLATFORM-SPECIFIC ALIGNMENTS
Note: =====================================================================

Process called "alignof_word" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for word
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_address" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for address
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_size_type" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for size type
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_ptrdiff_type" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for ptrdiff type
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_register" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load alignment value 8 for register
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_cache_line" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $64"                    Note: Load alignment value 64 for cache line
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_page" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $4096"                  Note: Load alignment value 4096 for page
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: VECTOR/SIMD ALIGNMENTS
Note: =====================================================================

Process called "alignof_vector128" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $16"                    Note: Load alignment value 16 for 128-bit vector
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_vector256" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $32"                    Note: Load alignment value 32 for 256-bit vector
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_vector512" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $64"                    Note: Load alignment value 64 for 512-bit vector
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alignof_simd_type" that takes vector_size as Integer returns Integer:
    Note: SIMD types are aligned to their size
    Return vector_size
End Process

Note: =====================================================================
Note: DYNAMIC ALIGNMENT CALCULATION
Note: =====================================================================

Process called "calculate_alignment_at_runtime" that takes type_info_ptr as Pointer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, [%1 + 16]"              Note: Load alignment from type info structure
        : "=r"(result)
        : "r"(type_info_ptr)
        :
    End Assembly
    Return result
End Process

Process called "calculate_array_alignment_runtime" that takes element_type_ptr as Pointer returns Integer:
    Let element_alignment be calculate_alignment_at_runtime(element_type_ptr)
    Return element_alignment
End Process

Process called "calculate_struct_alignment_runtime" that takes struct_type_ptr as Pointer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, [%1 + 24]"              Note: Load struct alignment from type structure
        : "=r"(result)
        : "r"(struct_type_ptr)
        :
    End Assembly
    Return result
End Process

Process called "calculate_union_alignment_runtime" that takes union_type_ptr as Pointer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, [%1 + 32]"              Note: Load union alignment from type structure
        : "=r"(result)
        : "r"(union_type_ptr)
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ALIGNMENT VALIDATION
Note: =====================================================================

Process called "validate_alignment_power_of_two" that takes alignment as Integer returns Boolean:
    If alignment is less than or equal to 0:
        Return false
    End If
    Let and_result be bitwise_and(alignment, subtract_integers(alignment, 1))
    If and_result is 0:
        Return true
    End If
    Return false
End Process

Process called "validate_alignment_within_limits" that takes alignment as Integer, max_alignment as Integer returns Boolean:
    If alignment is less than or equal to max_alignment:
        Return true
    End If
    Return false
End Process

Process called "validate_address_aligned" that takes address as Pointer, alignment as Integer returns Boolean:
    Let addr_value be convert_pointer_to_integer(address)
    Let remainder be modulo_integers(addr_value, alignment)
    If remainder is 0:
        Return true
    End If
    Return false
End Process

Process called "is_naturally_aligned" that takes address as Pointer, type_size as Integer returns Boolean:
    Let natural_alignment be get_natural_alignment(type_size)
    Return validate_address_aligned(address, natural_alignment)
End Process

Note: =====================================================================
Note: ALIGNMENT UTILITIES
Note: =====================================================================

Process called "align_address_up" that takes address as Pointer, alignment as Integer returns Pointer:
    Let addr_value be convert_pointer_to_integer(address)
    Let aligned_value be align_up_integer(addr_value, alignment)
    Return convert_integer_to_pointer(aligned_value)
End Process

Process called "align_address_down" that takes address as Pointer, alignment as Integer returns Pointer:
    Let addr_value be convert_pointer_to_integer(address)
    Let aligned_value be align_down_integer(addr_value, alignment)
    Return convert_integer_to_pointer(aligned_value)
End Process

Process called "get_alignment_offset" that takes address as Pointer, alignment as Integer returns Integer:
    Let addr_value be convert_pointer_to_integer(address)
    Let remainder be modulo_integers(addr_value, alignment)
    If remainder is 0:
        Return 0
    End If
    Return subtract_integers(alignment, remainder)
End Process

Process called "calculate_padding" that takes current_offset as Integer, required_alignment as Integer returns Integer:
    Let remainder be modulo_integers(current_offset, required_alignment)
    If remainder is 0:
        Return 0
    End If
    Return subtract_integers(required_alignment, remainder)
End Process

Note: =====================================================================
Note: ALIGNMENT OPTIMIZATION
Note: =====================================================================

Process called "optimize_struct_alignment" that takes field_alignments as Pointer, field_count as Integer returns Integer:
    Note: Find optimal alignment that minimizes padding
    Let struct_alignment be alignof_struct(field_alignments, field_count)
    Return struct_alignment
End Process

Process called "minimize_alignment_waste" that takes required_alignment as Integer, preferred_alignment as Integer returns Integer:
    Note: Choose smaller alignment that still satisfies requirements
    If required_alignment is less than or equal to preferred_alignment:
        Return required_alignment
    End If
    Return preferred_alignment
End Process

Process called "get_cache_friendly_alignment" that takes base_alignment as Integer returns Integer:
    Note: Align to cache line boundary if beneficial
    If base_alignment is greater than or equal to 64:
        Return base_alignment
    End If
    Return 64
End Process

Process called "get_natural_alignment" that takes type_size as Integer returns Integer:
    Note: Natural alignment is typically the size for primitive types
    If type_size is less than or equal to 1:
        Return 1
    End If
    If type_size is less than or equal to 2:
        Return 2
    End If
    If type_size is less than or equal to 4:
        Return 4
    End If
    If type_size is less than or equal to 8:
        Return 8
    End If
    Return 16
End Process

Note: =====================================================================
Note: BITFIELD ALIGNMENT
Note: =====================================================================

Process called "alignof_bitfield" that takes base_type_alignment as Integer returns Integer:
    Note: Bitfield alignment is same as base type
    Return base_type_alignment
End Process

Process called "calculate_bitfield_alignment" that takes bitfield_sizes as Pointer, base_alignments as Pointer, field_count as Integer returns Integer:
    Note: Bitfield container alignment is max of base type alignments
    Let max_alignment be 1
    Let i be 0
    While i is less than field_count:
        Let field_offset be multiply_by_8(i)
        Let base_align_ptr be add_pointer_offset(base_alignments, field_offset)
        Let base_alignment be load_integer_from_pointer(base_align_ptr)
        If base_alignment is greater than max_alignment:
            Let max_alignment be base_alignment
        End If
        Let i be add_integers(i, 1)
    End While
    Return max_alignment
End Process

Note: Helper functions using existing primitives

Process called "multiply_by_8" that takes value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load input value
        "shl %0, $3"                     Note: Shift left by 3 (multiply by 8)
        : "=r"(result)
        : "r"(value)
        :
    End Assembly
    Return result
End Process

Process called "add_pointer_offset" that takes ptr as Pointer, offset as Integer returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load pointer
        "add %0, %2"                     Note: Add offset to pointer
        : "=r"(result)
        : "r"(ptr), "r"(offset)
        :
    End Assembly
    Return result
End Process

Process called "load_integer_from_pointer" that takes ptr as Pointer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, [%1]"                   Note: Load integer from memory address
        : "=r"(result)
        : "r"(ptr)
        :
    End Assembly
    Return result
End Process

Process called "add_integers" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load left operand
        "add %0, %2"                     Note: Add right operand
        : "=r"(result)
        : "r"(left), "r"(right)
        :
    End Assembly
    Return result
End Process

Process called "subtract_integers" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load left operand
        "sub %0, %2"                     Note: Subtract right operand
        : "=r"(result)
        : "r"(left), "r"(right)
        :
    End Assembly
    Return result
End Process

Process called "modulo_integers" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %%rax, %1"                  Note: Load dividend into rax
        "cqo"                            Note: Sign extend rax to rdx:rax
        "idiv %2"                        Note: Signed divide by divisor
        "mov %0, %%rdx"                  Note: Remainder is in rdx
        : "=r"(result)
        : "r"(left), "r"(right)
        : "rax", "rdx"
    End Assembly
    Return result
End Process

Process called "max_integer" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load left value
        "cmp %0, %2"                     Note: Compare with right value
        "cmovl %0, %2"                   Note: Conditional move if left < right
        : "=r"(result)
        : "r"(left), "r"(right)
        :
    End Assembly
    Return result
End Process

Process called "bitwise_and" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load left operand
        "and %0, %2"                     Note: Bitwise AND with right operand
        : "=r"(result)
        : "r"(left), "r"(right)
        :
    End Assembly
    Return result
End Process

Process called "align_up_integer" that takes value as Integer, alignment as Integer returns Integer:
    Let result be 0
    Let mask be 0
    Inline Assembly:
        "mov %0, %2"                     Note: Load value
        "add %0, %3"                     Note: Add alignment
        "dec %0"                         Note: Subtract 1
        "mov %1, %3"                     Note: Load alignment for mask
        "dec %1"                         Note: Subtract 1 from alignment
        "not %1"                         Note: Bitwise NOT to create mask
        "and %0, %1"                     Note: Apply alignment mask
        : "=&r"(result), "=&r"(mask)
        : "r"(value), "r"(alignment)
        :
    End Assembly
    Return result
End Process

Process called "align_down_integer" that takes value as Integer, alignment as Integer returns Integer:
    Let result be 0
    Let mask be 0
    Inline Assembly:
        "mov %0, %2"                     Note: Load value
        "mov %1, %3"                     Note: Load alignment for mask
        "dec %1"                         Note: Subtract 1 from alignment
        "not %1"                         Note: Bitwise NOT to create mask
        "and %0, %1"                     Note: Apply alignment mask
        : "=&r"(result), "=&r"(mask)
        : "r"(value), "r"(alignment)
        :
    End Assembly
    Return result
End Process

Process called "convert_pointer_to_integer" that takes ptr as Pointer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Convert pointer to integer
        : "=r"(result)
        : "r"(ptr)
        :
    End Assembly
    Return result
End Process

Process called "convert_integer_to_pointer" that takes value as Integer returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Convert integer to pointer
        : "=r"(result)
        : "r"(value)
        :
    End Assembly
    Return result
End Process