Note:
intrinsics/sizeof.runa - Zero-Dependency Type Size Intrinsics

This module provides fundamental type size calculation operations using direct assembly instructions.
These primitives have ZERO dependencies and compile to efficient size computation.

@Reasoning:
- Provides low-level type size information for compiler code generation
- All operations use inline assembly for true self-hosting capabilities
- No external dependencies - we generate the machine code directly
- Essential for implementing memory allocation, struct layout, and type safety
@End Reasoning

@Implementation:
- Inline Assembly statements using immediate size values
- Compile-time size calculation for known types
- Support for complex type size computation
- Zero-cost abstraction through compile-time optimization
@End Implementation

@Performance_Hints:
- Type sizes resolved at compile time when possible
- Immediate values used for primitive type sizes
- Complex types computed using addition and alignment
- No runtime overhead for size calculations
@End Performance_Hints
:End Note

Note: =====================================================================
Note: PRIMITIVE TYPE SIZES
Note: =====================================================================

Process called "sizeof_boolean" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $1"                     Note: Load size 1 for boolean
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_integer8" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $1"                     Note: Load size 1 for 8-bit integer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_unsigned8" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $1"                     Note: Load size 1 for unsigned 8-bit
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_integer16" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $2"                     Note: Load size 2 for 16-bit integer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_unsigned16" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $2"                     Note: Load size 2 for unsigned 16-bit
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_integer32" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $4"                     Note: Load size 4 for 32-bit integer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_unsigned32" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $4"                     Note: Load size 4 for unsigned 32-bit
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_integer64" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load size 8 for 64-bit integer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_unsigned64" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load size 8 for unsigned 64-bit
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_integer" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load size 8 for default integer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_float32" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $4"                     Note: Load size 4 for 32-bit float
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_float64" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load size 8 for 64-bit float
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_float" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load size 8 for default float
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_pointer" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load size 8 for pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_char" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $1"                     Note: Load size 1 for character
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: COMPOUND TYPE SIZES
Note: =====================================================================

Process called "sizeof_array" that takes element_size as Integer, element_count as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load element size
        "imul %0, %2"                    Note: Multiply by element count
        : "=r"(result)
        : "r"(element_size), "r"(element_count)
        :
    End Assembly
    Return result
End Process

Process called "sizeof_fixed_array" that takes element_size as Integer, length as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load element size
        "imul %0, %2"                    Note: Multiply by array length
        : "=r"(result)
        : "r"(element_size), "r"(length)
        :
    End Assembly
    Return result
End Process

Process called "sizeof_dynamic_array" returns Integer:
    Note: Dynamic array is pointer + length + capacity
    Let result be 0
    Inline Assembly:
        "mov %0, $24"                    Note: Load size 24 (3 x 8-byte fields)
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_slice" returns Integer:
    Note: Slice is pointer + length
    Let result be 0
    Inline Assembly:
        "mov %0, $16"                    Note: Load size 16 (2 x 8-byte fields)
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_string" returns Integer:
    Note: String is pointer + length + capacity
    Let result be 0
    Inline Assembly:
        "mov %0, $24"                    Note: Load size 24 (3 x 8-byte fields)
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_string_view" returns Integer:
    Note: String view is pointer + length
    Let result be 0
    Inline Assembly:
        "mov %0, $16"                    Note: Load size 16 (2 x 8-byte fields)
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: STRUCT SIZE CALCULATION
Note: =====================================================================

Process called "sizeof_struct_unaligned" that takes field_sizes as Pointer, field_count as Integer returns Integer:
    Let total_size be 0
    Let i be 0
    While i is less than field_count:
        Let field_offset be multiply_by_8(i)
        Let field_size_ptr be add_pointer_offset(field_sizes, field_offset)
        Let field_size be load_integer_from_pointer(field_size_ptr)
        Let total_size be add_integers(total_size, field_size)
        Let i be add_integers(i, 1)
    End While
    Return total_size
End Process

Process called "sizeof_struct_aligned" that takes field_sizes as Pointer, field_alignments as Pointer, field_count as Integer returns Integer:
    Let total_size be 0
    Let max_alignment be 1
    Let i be 0
    While i is less than field_count:
        Let field_offset be multiply_by_8(i)
        Let field_size_ptr be add_pointer_offset(field_sizes, field_offset)
        Let field_align_ptr be add_pointer_offset(field_alignments, field_offset)
        Let field_size be load_integer_from_pointer(field_size_ptr)
        Let field_alignment be load_integer_from_pointer(field_align_ptr)
        
        Note: Update maximum alignment
        If field_alignment is greater than max_alignment:
            Let max_alignment be field_alignment
        End If
        
        Note: Align current position
        Let aligned_size be align_up(total_size, field_alignment)
        Let total_size be add_integers(aligned_size, field_size)
        Let i be add_integers(i, 1)
    End While
    
    Note: Align final struct size
    Let final_size be align_up(total_size, max_alignment)
    Return final_size
End Process

Process called "sizeof_packed_struct" that takes field_sizes as Pointer, field_count as Integer returns Integer:
    Note: Packed struct has no padding between fields
    Return sizeof_struct_unaligned(field_sizes, field_count)
End Process

Note: =====================================================================
Note: UNION SIZE CALCULATION
Note: =====================================================================

Process called "sizeof_union" that takes variant_sizes as Pointer, variant_count as Integer returns Integer:
    Let max_size be 0
    Let i be 0
    While i is less than variant_count:
        Let variant_offset be multiply_by_8(i)
        Let variant_size_ptr be add_pointer_offset(variant_sizes, variant_offset)
        Let variant_size be load_integer_from_pointer(variant_size_ptr)
        If variant_size is greater than max_size:
            Let max_size be variant_size
        End If
        Let i be add_integers(i, 1)
    End While
    Return max_size
End Process

Process called "sizeof_tagged_union" that takes variant_sizes as Pointer, variant_count as Integer, tag_size as Integer returns Integer:
    Let union_size be sizeof_union(variant_sizes, variant_count)
    Let total_size be add_integers(tag_size, union_size)
    Return total_size
End Process

Process called "sizeof_enum" that takes base_type_size as Integer returns Integer:
    Return base_type_size
End Process

Note: =====================================================================
Note: FUNCTION AND CLOSURE SIZES
Note: =====================================================================

Process called "sizeof_function_pointer" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load size 8 for function pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_closure" that takes capture_size as Integer returns Integer:
    Note: Closure is function pointer + captured data
    Let closure_size be add_integers(8, capture_size)
    Return closure_size
End Process

Process called "sizeof_virtual_function_table" that takes method_count as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load method count
        "imul %0, $8"                    Note: Multiply by 8 (pointer size)
        : "=r"(result)
        : "r"(method_count)
        :
    End Assembly
    Return result
End Process

Process called "sizeof_object_with_vtable" that takes object_size as Integer returns Integer:
    Note: Object with vtable has vtable pointer + data
    Let total_size be add_integers(8, object_size)
    Return total_size
End Process

Note: =====================================================================
Note: CONTAINER SIZES
Note: =====================================================================

Process called "sizeof_vector" returns Integer:
    Note: Vector is pointer + length + capacity
    Let result be 0
    Inline Assembly:
        "mov %0, $24"                    Note: Load size 24 (3 x 8-byte fields)
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_list_node" that takes data_size as Integer returns Integer:
    Note: List node is data + next pointer + prev pointer
    Let node_size be add_integers(data_size, 16)
    Return node_size
End Process

Process called "sizeof_hash_table_entry" that takes key_size as Integer, value_size as Integer returns Integer:
    Note: Hash entry is key + value + hash + next pointer
    Let entry_size be add_integers(key_size, value_size)
    Let entry_size be add_integers(entry_size, 8)
    Let entry_size be add_integers(entry_size, 8)
    Return entry_size
End Process

Process called "sizeof_tree_node" that takes data_size as Integer returns Integer:
    Note: Tree node is data + left pointer + right pointer + parent pointer
    Let node_size be add_integers(data_size, 24)
    Return node_size
End Process

Note: =====================================================================
Note: GENERIC TYPE SIZES
Note: =====================================================================

Process called "sizeof_optional" that takes inner_type_size as Integer returns Integer:
    Note: Optional is tag byte + data (aligned)
    Let aligned_size be align_up(inner_type_size, 8)
    Let total_size be add_integers(8, aligned_size)
    Return total_size
End Process

Process called "sizeof_result" that takes ok_size as Integer, error_size as Integer returns Integer:
    Note: Result is tag + union of ok/error types
    Let union_size be max_integer(ok_size, error_size)
    Let total_size be add_integers(8, union_size)
    Return total_size
End Process

Process called "sizeof_tuple" that takes element_sizes as Pointer, element_count as Integer returns Integer:
    Note: Tuple is like a struct with natural alignment
    Let element_alignments be compute_natural_alignments(element_sizes, element_count)
    Return sizeof_struct_aligned(element_sizes, element_alignments, element_count)
End Process

Note: =====================================================================
Note: PLATFORM-SPECIFIC SIZES
Note: =====================================================================

Process called "sizeof_word" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load size 8 for word
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_address" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load size 8 for address
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_size_type" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load size 8 for size type
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_ptrdiff_type" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load size 8 for ptrdiff type
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_register" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $8"                     Note: Load size 8 for register
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_cache_line" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $64"                    Note: Load size 64 for cache line
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "sizeof_page" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, $4096"                  Note: Load size 4096 for page
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: DYNAMIC SIZE CALCULATION
Note: =====================================================================

Process called "calculate_size_at_runtime" that takes type_info_ptr as Pointer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, [%1 + 8]"               Note: Load size from type info structure
        : "=r"(result)
        : "r"(type_info_ptr)
        :
    End Assembly
    Return result
End Process

Process called "calculate_array_size_runtime" that takes element_type_ptr as Pointer, length as Integer returns Integer:
    Let element_size be calculate_size_at_runtime(element_type_ptr)
    Return multiply_integers(element_size, length)
End Process

Process called "calculate_struct_size_runtime" that takes struct_type_ptr as Pointer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, [%1 + 16]"              Note: Load struct size from type structure
        : "=r"(result)
        : "r"(struct_type_ptr)
        :
    End Assembly
    Return result
End Process

Process called "calculate_union_size_runtime" that takes union_type_ptr as Pointer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, [%1 + 24]"              Note: Load union size from type structure
        : "=r"(result)
        : "r"(union_type_ptr)
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: SIZE VALIDATION
Note: =====================================================================

Process called "validate_size_positive" that takes size as Integer returns Boolean:
    If size is greater than 0:
        Return true
    End If
    Return false
End Process

Process called "validate_size_aligned" that takes size as Integer, alignment as Integer returns Boolean:
    Let remainder be modulo_integers(size, alignment)
    If remainder is 0:
        Return true
    End If
    Return false
End Process

Process called "validate_size_within_limits" that takes size as Integer, max_size as Integer returns Boolean:
    If size is less than or equal to max_size:
        Return true
    End If
    Return false
End Process

Process called "is_size_power_of_two" that takes size as Integer returns Boolean:
    If size is less than or equal to 0:
        Return false
    End If
    Let and_result be bitwise_and(size, subtract_integers(size, 1))
    If and_result is 0:
        Return true
    End If
    Return false
End Process

Note: =====================================================================
Note: SIZE OPTIMIZATION
Note: =====================================================================

Process called "optimize_struct_layout" that takes field_sizes as Pointer, field_count as Integer returns Integer:
    Note: Sort fields by size (largest first) for optimal packing
    Let sorted_sizes be sort_sizes_descending(field_sizes, field_count)
    Let natural_alignments be compute_natural_alignments(sorted_sizes, field_count)
    Return sizeof_struct_aligned(sorted_sizes, natural_alignments, field_count)
End Process

Process called "minimize_padding" that takes field_sizes as Pointer, field_alignments as Pointer, field_count as Integer returns Integer:
    Note: Reorder fields to minimize total padding
    Let reordered_info be reorder_fields_for_packing(field_sizes, field_alignments, field_count)
    Return sizeof_struct_aligned(reordered_info, reordered_info, field_count)
End Process

Process called "pack_bitfields" that takes bit_counts as Pointer, field_count as Integer returns Integer:
    Let total_bits be 0
    Let i be 0
    While i is less than field_count:
        Let bit_offset be multiply_by_8(i)
        Let bit_count_ptr be add_pointer_offset(bit_counts, bit_offset)
        Let bit_count be load_integer_from_pointer(bit_count_ptr)
        Let total_bits be add_integers(total_bits, bit_count)
        Let i be add_integers(i, 1)
    End While
    Let total_bytes be divide_and_round_up(total_bits, 8)
    Return total_bytes
End Process

Note: Helper functions using existing primitives

Process called "multiply_by_8" that takes value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load input value
        "shl %0, $3"                     Note: Shift left by 3 (multiply by 8)
        : "=r"(result)
        : "r"(value)
        :
    End Assembly
    Return result
End Process

Process called "add_pointer_offset" that takes ptr as Pointer, offset as Integer returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load pointer
        "add %0, %2"                     Note: Add offset to pointer
        : "=r"(result)
        : "r"(ptr), "r"(offset)
        :
    End Assembly
    Return result
End Process

Process called "load_integer_from_pointer" that takes ptr as Pointer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, [%1]"                   Note: Load integer from memory address
        : "=r"(result)
        : "r"(ptr)
        :
    End Assembly
    Return result
End Process

Process called "add_integers" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load left operand
        "add %0, %2"                     Note: Add right operand
        : "=r"(result)
        : "r"(left), "r"(right)
        :
    End Assembly
    Return result
End Process

Process called "subtract_integers" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load left operand
        "sub %0, %2"                     Note: Subtract right operand
        : "=r"(result)
        : "r"(left), "r"(right)
        :
    End Assembly
    Return result
End Process

Process called "multiply_integers" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load left operand
        "imul %0, %2"                    Note: Multiply by right operand
        : "=r"(result)
        : "r"(left), "r"(right)
        :
    End Assembly
    Return result
End Process

Process called "modulo_integers" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %%rax, %1"                  Note: Load dividend into rax
        "cqo"                            Note: Sign extend rax to rdx:rax
        "idiv %2"                        Note: Signed divide by divisor
        "mov %0, %%rdx"                  Note: Remainder is in rdx
        : "=r"(result)
        : "r"(left), "r"(right)
        : "rax", "rdx"
    End Assembly
    Return result
End Process

Process called "max_integer" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load left value
        "cmp %0, %2"                     Note: Compare with right value
        "cmovl %0, %2"                   Note: Conditional move if left < right
        : "=r"(result)
        : "r"(left), "r"(right)
        :
    End Assembly
    Return result
End Process

Process called "align_up" that takes value as Integer, alignment as Integer returns Integer:
    Let result be 0
    Let mask be 0
    Inline Assembly:
        "mov %0, %2"                     Note: Load value
        "add %0, %3"                     Note: Add alignment
        "dec %0"                         Note: Subtract 1
        "mov %1, %3"                     Note: Load alignment for mask
        "dec %1"                         Note: Subtract 1 from alignment
        "not %1"                         Note: Bitwise NOT to create mask
        "and %0, %1"                     Note: Apply alignment mask
        : "=&r"(result), "=&r"(mask)
        : "r"(value), "r"(alignment)
        :
    End Assembly
    Return result
End Process

Process called "bitwise_and" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load left operand
        "and %0, %2"                     Note: Bitwise AND with right operand
        : "=r"(result)
        : "r"(left), "r"(right)
        :
    End Assembly
    Return result
End Process

Process called "divide_and_round_up" that takes dividend as Integer, divisor as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %%rax, %1"                  Note: Load dividend
        "add %%rax, %2"                  Note: Add divisor for rounding up
        "dec %%rax"                      Note: Subtract 1
        "cqo"                            Note: Sign extend for division
        "idiv %2"                        Note: Divide by divisor
        "mov %0, %%rax"                  Note: Store quotient
        : "=r"(result)
        : "r"(dividend), "r"(divisor)
        : "rax", "rdx"
    End Assembly
    Return result
End Process

Process called "compute_natural_alignments" that takes sizes as Pointer, count as Integer returns Pointer:
    Note: Compute natural alignments based on type sizes with proper alignment rules
    If sizes is create_null_pointer():
        Return create_null_pointer()
    End If
    
    If count <= 0:
        Return create_null_pointer()
    End If
    
    Note: Allocate memory for alignment array (assuming 8-byte integers)
    Let alignment_bytes be multiply_integers(count, 8)
    Let alignments be allocate_memory(alignment_bytes)
    
    If alignments is create_null_pointer():
        Return create_null_pointer()
    End If
    
    Let i be 0
    While i < count:
        Let size_offset be multiply_integers(i, 8)
        Let size_ptr be add_pointer_offset(sizes, size_offset)
        Let size_value be load_integer_from_pointer(size_ptr)
        
        Note: Calculate natural alignment using power-of-2 rules
        Let alignment be compute_single_natural_alignment(size_value)
        
        Let alignment_offset be multiply_integers(i, 8)
        Let alignment_ptr be add_pointer_offset(alignments, alignment_offset)
        Let store_result be store_integer_to_pointer(alignment_ptr, alignment)
        
        Let i be add_integers(i, 1)
    End While
    
    Return alignments
End Process

Process called "multiply_integers" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load left operand
        "imul %0, %2"                    Note: Multiply by right operand
        : "=r"(result)
        : "r"(left), "r"(right)
        :
    End Assembly
    Return result
End Process

Process called "allocate_memory" that takes bytes as Integer returns Pointer:
    Note: Simple memory allocation using system call
    Let result be create_null_pointer()
    Inline Assembly:
        "mov %%rax, $9"                  Note: mmap system call number
        "xor %%rdi, %%rdi"               Note: addr = NULL (let kernel choose)
        "mov %%rsi, %1"                  Note: length = bytes
        "mov %%rdx, $3"                  Note: prot = PROT_READ | PROT_WRITE
        "mov %%r10, $34"                 Note: flags = MAP_PRIVATE | MAP_ANONYMOUS
        "mov %%r8, $-1"                  Note: fd = -1 (no file)
        "xor %%r9, %%r9"                 Note: offset = 0
        "syscall"                        Note: Call mmap
        "mov %0, %%rax"                  Note: Store result pointer
        : "=r"(result)
        : "r"(bytes)
        : "rax", "rdi", "rsi", "rdx", "r8", "r9", "r10"
    End Assembly
    Return result
End Process

Process called "add_pointer_offset" that takes base_ptr as Pointer, offset as Integer returns Pointer:
    Let result be create_null_pointer()
    Inline Assembly:
        "mov %0, %1"                     Note: Load base pointer
        "add %0, %2"                     Note: Add byte offset
        : "=r"(result)
        : "r"(base_ptr), "r"(offset)
        :
    End Assembly
    Return result
End Process

Process called "load_integer_from_pointer" that takes ptr as Pointer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, [%1]"                   Note: Load integer from memory address
        : "=r"(result)
        : "r"(ptr)
        :
    End Assembly
    Return result
End Process

Process called "store_integer_to_pointer" that takes ptr as Pointer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov [%1], %2"                   Note: Store integer to memory address
        "mov %0, $1"                     Note: Return success (1)
        : "=r"(result)
        : "r"(ptr), "r"(value)
        :
    End Assembly
    Return result
End Process

Process called "compute_single_natural_alignment" that takes size as Integer returns Integer:
    Note: Compute natural alignment for a single type size using standard rules
    If size <= 0:
        Return 1
    End If
    
    Note: Natural alignment rules: alignment = min(size, max_alignment)
    Let max_alignment be 8
    
    If size >= max_alignment:
        Return max_alignment
    End If
    
    Note: Find largest power of 2 that divides size
    If size >= 4:
        If is_power_of_two(size):
            Return size
        End If
        Return 4
    End If
    
    If size >= 2:
        If is_power_of_two(size):
            Return size
        End If
        Return 2
    End If
    
    Return 1
End Process

Process called "is_power_of_two" that takes value as Integer returns Boolean:
    Note: Check if value is a power of 2
    If value <= 0:
        Return false
    End If
    
    Let value_minus_one be subtract_integers(value, 1)
    Let and_result be bitwise_and(value, value_minus_one)
    
    If and_result is 0:
        Return true
    End If
    Return false
End Process

Process called "sort_sizes_descending" that takes sizes as Pointer, count as Integer returns Pointer:
    Note: Sort array of integers in descending order using bubble sort algorithm
    If sizes is create_null_pointer():
        Return create_null_pointer()
    End If
    
    If count <= 1:
        Return sizes
    End If
    
    Note: Allocate memory for sorted copy
    Let sorted_bytes be multiply_integers(count, 8)
    Let sorted_array be allocate_memory(sorted_bytes)
    
    If sorted_array is create_null_pointer():
        Return create_null_pointer()
    End If
    
    Note: Copy original array to sorted array
    Let copy_result be copy_integer_array(sizes, sorted_array, count)
    
    Note: Bubble sort implementation for descending order
    Let outer_index be 0
    While outer_index < count:
        Let inner_index be 0
        Let max_inner be subtract_integers(count, 1)
        Let max_inner_adjusted be subtract_integers(max_inner, outer_index)
        
        While inner_index < max_inner_adjusted:
            Let current_offset be multiply_integers(inner_index, 8)
            Let next_index be add_integers(inner_index, 1)
            Let next_offset be multiply_integers(next_index, 8)
            
            Let current_ptr be add_pointer_offset(sorted_array, current_offset)
            Let next_ptr be add_pointer_offset(sorted_array, next_offset)
            
            Let current_value be load_integer_from_pointer(current_ptr)
            Let next_value be load_integer_from_pointer(next_ptr)
            
            Note: Swap if current < next (for descending order)
            If current_value < next_value:
                Let swap_result be swap_integers_at_pointers(current_ptr, next_ptr)
            End If
            
            Let inner_index be add_integers(inner_index, 1)
        End While
        
        Let outer_index be add_integers(outer_index, 1)
    End While
    
    Return sorted_array
End Process

Process called "copy_integer_array" that takes source as Pointer, destination as Pointer, count as Integer returns Integer:
    Note: Copy count integers from source to destination array
    If source is create_null_pointer():
        Return 0
    End If
    
    If destination is create_null_pointer():
        Return 0
    End If
    
    Let i be 0
    While i < count:
        Let offset be multiply_integers(i, 8)
        Let src_ptr be add_pointer_offset(source, offset)
        Let dest_ptr be add_pointer_offset(destination, offset)
        
        Let value be load_integer_from_pointer(src_ptr)
        Let store_result be store_integer_to_pointer(dest_ptr, value)
        
        Let i be add_integers(i, 1)
    End While
    
    Return count
End Process

Process called "swap_integers_at_pointers" that takes ptr1 as Pointer, ptr2 as Pointer returns Integer:
    Note: Swap integers at two memory locations
    Let value1 be load_integer_from_pointer(ptr1)
    Let value2 be load_integer_from_pointer(ptr2)
    
    Let store1_result be store_integer_to_pointer(ptr1, value2)
    Let store2_result be store_integer_to_pointer(ptr2, value1)
    
    Return 1
End Process

Process called "reorder_fields_for_packing" that takes sizes as Pointer, alignments as Pointer, count as Integer returns Pointer:
    Note: Reorder fields to minimize padding using largest-first packing strategy
    If sizes is create_null_pointer():
        Return create_null_pointer()
    End If
    
    If alignments is create_null_pointer():
        Return create_null_pointer()
    End If
    
    If count <= 1:
        Return sizes
    End If
    
    Note: Allocate memory for reordered indices array
    Let indices_bytes be multiply_integers(count, 8)
    Let field_indices be allocate_memory(indices_bytes)
    
    If field_indices is create_null_pointer():
        Return create_null_pointer()
    End If
    
    Note: Initialize indices array (0, 1, 2, ...)
    Let i be 0
    While i < count:
        Let offset be multiply_integers(i, 8)
        Let index_ptr be add_pointer_offset(field_indices, offset)
        Let store_result be store_integer_to_pointer(index_ptr, i)
        Let i be add_integers(i, 1)
    End While
    
    Note: Sort indices by descending alignment, then by descending size
    Let sort_result be sort_field_indices_by_priority(field_indices, sizes, alignments, count)
    
    Note: Create reordered sizes array based on sorted indices
    Let reordered_bytes be multiply_integers(count, 8)
    Let reordered_sizes be allocate_memory(reordered_bytes)
    
    If reordered_sizes is create_null_pointer():
        Return create_null_pointer()
    End If
    
    Let j be 0
    While j < count:
        Let index_offset be multiply_integers(j, 8)
        Let index_ptr be add_pointer_offset(field_indices, index_offset)
        Let original_index be load_integer_from_pointer(index_ptr)
        
        Let original_size_offset be multiply_integers(original_index, 8)
        Let original_size_ptr be add_pointer_offset(sizes, original_size_offset)
        Let size_value be load_integer_from_pointer(original_size_ptr)
        
        Let reordered_offset be multiply_integers(j, 8)
        Let reordered_ptr be add_pointer_offset(reordered_sizes, reordered_offset)
        Let store_result be store_integer_to_pointer(reordered_ptr, size_value)
        
        Let j be add_integers(j, 1)
    End While
    
    Return reordered_sizes
End Process

Process called "sort_field_indices_by_priority" that takes indices as Pointer, sizes as Pointer, alignments as Pointer, count as Integer returns Integer:
    Note: Sort field indices by alignment priority (alignment desc, then size desc)
    Let outer_index be 0
    While outer_index < count:
        Let inner_index be 0
        Let max_inner be subtract_integers(count, 1)
        Let max_inner_adjusted be subtract_integers(max_inner, outer_index)
        
        While inner_index < max_inner_adjusted:
            Let current_index_offset be multiply_integers(inner_index, 8)
            Let next_index_offset be multiply_integers(add_integers(inner_index, 1), 8)
            
            Let current_index_ptr be add_pointer_offset(indices, current_index_offset)
            Let next_index_ptr be add_pointer_offset(indices, next_index_offset)
            
            Let current_field_index be load_integer_from_pointer(current_index_ptr)
            Let next_field_index be load_integer_from_pointer(next_index_ptr)
            
            Note: Get alignment and size for current field
            Let current_alignment_offset be multiply_integers(current_field_index, 8)
            Let current_alignment_ptr be add_pointer_offset(alignments, current_alignment_offset)
            Let current_alignment be load_integer_from_pointer(current_alignment_ptr)
            
            Let current_size_offset be multiply_integers(current_field_index, 8)
            Let current_size_ptr be add_pointer_offset(sizes, current_size_offset)
            Let current_size be load_integer_from_pointer(current_size_ptr)
            
            Note: Get alignment and size for next field
            Let next_alignment_offset be multiply_integers(next_field_index, 8)
            Let next_alignment_ptr be add_pointer_offset(alignments, next_alignment_offset)
            Let next_alignment be load_integer_from_pointer(next_alignment_ptr)
            
            Let next_size_offset be multiply_integers(next_field_index, 8)
            Let next_size_ptr be add_pointer_offset(sizes, next_size_offset)
            Let next_size be load_integer_from_pointer(next_size_ptr)
            
            Note: Compare priority: alignment first, then size
            Let should_swap be false
            
            If next_alignment > current_alignment:
                Let should_swap be true
            Otherwise:
                If next_alignment is current_alignment:
                    If next_size > current_size:
                        Let should_swap be true
                    End If
                End If
            End If
            
            If should_swap:
                Let swap_result be swap_integers_at_pointers(current_index_ptr, next_index_ptr)
            End If
            
            Let inner_index be add_integers(inner_index, 1)
        End While
        
        Let outer_index be add_integers(outer_index, 1)
    End While
    
    Return 1
End Process

Process called "add_integers" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load left operand
        "add %0, %2"                     Note: Add right operand
        : "=r"(result)
        : "r"(left), "r"(right)
        :
    End Assembly
    Return result
End Process

Process called "subtract_integers" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load left operand
        "sub %0, %2"                     Note: Subtract right operand
        : "=r"(result)
        : "r"(left), "r"(right)
        :
    End Assembly
    Return result
End Process

Process called "bitwise_and" that takes left as Integer, right as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1"                     Note: Load left operand
        "and %0, %2"                     Note: Bitwise AND with right operand
        : "=r"(result)
        : "r"(left), "r"(right)
        :
    End Assembly
    Return result
End Process

Process called "create_null_pointer" returns Pointer:
    Let result be 0 as Pointer
    Inline Assembly:
        "xor %0, %0"                     Note: Clear register to create null pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process