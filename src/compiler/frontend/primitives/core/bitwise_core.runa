Note:
bitwise_core.runa - Zero-Dependency Bitwise Operation Primitives

This module provides unified bitwise operations across all integer types.
These primitives have ZERO dependencies and compile to direct bit manipulation instructions.

@Reasoning:
- Provides generic bitwise interface for all integer types
- All operations use inline assembly for true self-hosting
- No external dependencies - we generate the machine code directly
- Essential for low-level bit manipulation and flags

@Implementation:
- Inline Assembly statements with direct bit operations
- Works on any integer size (8/16/32/64 bit)
- No overflow possible in bitwise operations
- Zero-cost abstraction through compile-time dispatch

@Performance_Hints:
- Each operation maps to single CPU instruction
- No branching in basic operations
- Direct ALU bit manipulation
- Highly efficient for flag and mask operations
:End Note

Note: =====================================================================
Note: BASIC BITWISE OPERATIONS
Note: =====================================================================

Process called "bit_and" that takes a as Integer, b as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "and %0, %2\n"        Note: Bitwise AND with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bit_or" that takes a as Integer, b as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "or %0, %2\n"         Note: Bitwise OR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bit_xor" that takes a as Integer, b as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "xor %0, %2\n"        Note: Bitwise XOR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bit_not" that takes a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move operand to result register
        "not %0\n"            Note: Bitwise NOT operation
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bit_nand" that takes a as Integer, b as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "and %0, %2\n"        Note: Bitwise AND with second operand
        "not %0\n"            Note: Bitwise NOT to complete NAND
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bit_nor" that takes a as Integer, b as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "or %0, %2\n"         Note: Bitwise OR with second operand
        "not %0\n"            Note: Bitwise NOT to complete NOR
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bit_xnor" that takes a as Integer, b as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "xor %0, %2\n"        Note: Bitwise XOR with second operand
        "not %0\n"            Note: Bitwise NOT to complete XNOR
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: BIT SHIFTING OPERATIONS
Note: =====================================================================

Process called "shl" that takes a as Integer, b as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rcx, %2\n"       Note: Move shift count to RCX
        "mov %1, %0\n"        Note: Move value to result register
        "shl %0, cl\n"        Note: Shift left by CL
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "shr" that takes a as Integer, b as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rcx, %2\n"       Note: Move shift count to RCX
        "mov %1, %0\n"        Note: Move value to result register
        "sar %0, cl\n"        Note: Arithmetic shift right by CL
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "ushr" that takes a as Integer, b as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rcx, %2\n"       Note: Move shift count to RCX
        "mov %1, %0\n"        Note: Move value to result register
        "shr %0, cl\n"        Note: Logical shift right by CL
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "rotl" that takes a as Integer, b as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rcx, %2\n"       Note: Move rotation count to RCX
        "mov %1, %0\n"        Note: Move value to result register
        "rol %0, cl\n"        Note: Rotate left by CL
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "rotr" that takes a as Integer, b as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rcx, %2\n"       Note: Move rotation count to RCX
        "mov %1, %0\n"        Note: Move value to result register
        "ror %0, cl\n"        Note: Rotate right by CL
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "shl1" that takes a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "shl %0, 1\n"         Note: Shift left by 1
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "shr1" that takes a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "sar %0, 1\n"         Note: Arithmetic shift right by 1
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ushr1" that takes a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "shr %0, 1\n"         Note: Logical shift right by 1
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: BIT MANIPULATION OPERATIONS
Note: =====================================================================

Process called "bit_set" that takes val as Integer, bit as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "bts %0, %2\n"        Note: Set bit at specified position
        : "=r"(result)
        : "r"(val), "r"(bit)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bit_clear" that takes val as Integer, bit as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "btr %0, %2\n"        Note: Clear bit at specified position
        : "=r"(result)
        : "r"(val), "r"(bit)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bit_toggle" that takes val as Integer, bit as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "btc %0, %2\n"        Note: Toggle bit at specified position
        : "=r"(result)
        : "r"(val), "r"(bit)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bit_test" that takes val as Integer, bit as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "bt %1, %2\n"         Note: Test bit at specified position
        "setc %0\n"           Note: Set result if carry flag is set
        : "=r"(result)
        : "r"(val), "r"(bit)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bit_scan_forward" that takes val as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "bsf %0, %1\n"        Note: Bit scan forward
        "jnz 1f\n"            Note: Jump if not zero
        "mov %0, -1\n"        Note: Return -1 if no bits set
        "1:\n"                Note: End label
        : "=r"(result)
        : "r"(val)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bit_scan_reverse" that takes val as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "bsr %0, %1\n"        Note: Bit scan reverse
        "jnz 1f\n"            Note: Jump if not zero
        "mov %0, -1\n"        Note: Return -1 if no bits set
        "1:\n"                Note: End label
        : "=r"(result)
        : "r"(val)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: BIT COUNTING OPERATIONS
Note: =====================================================================

Process called "popcount" that takes a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "popcnt %0, %1\n"     Note: Population count (count set bits)
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "clz" that takes a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "lzcnt %0, %1\n"      Note: Count leading zeros
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ctz" that takes a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "tzcnt %0, %1\n"      Note: Count trailing zeros
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "parity" that takes a as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "popcnt rax, %1\n"    Note: Count set bits
        "and rax, 1\n"        Note: Check if odd number of bits
        "mov %0, al\n"        Note: Move result to output
        : "=r"(result)
        : "r"(a)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "hamming_weight" that takes a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "popcnt %0, %1\n"     Note: Hamming weight (population count)
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: BYTE OPERATIONS
Note: =====================================================================

Process called "bswap" that takes a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "bswap %0\n"          Note: Byte swap operation
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "bswap16" that takes a as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "rol %0, 8\n"         Note: Rotate left by 8 to swap bytes
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bswap32" that takes a as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "bswap %0\n"          Note: Byte swap 32-bit value
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "bswap64" that takes a as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "bswap %0\n"          Note: Byte swap 64-bit value
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "reverse_bits" that takes a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rcx, 64\n"       Note: Load bit count
        "xor %0, %0\n"        Note: Clear result register
        "1: shr %1, 1\n"      Note: Shift input right
        "rcl %0, 1\n"         Note: Rotate result left with carry
        "loop 1b\n"           Note: Loop until RCX is zero
        : "=r"(result)
        : "r"(a)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: MASK OPERATIONS
Note: =====================================================================

Process called "make_mask" that takes bits as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, 1\n"         Note: Load value 1
        "shl %0, %1\n"        Note: Shift left by bit count
        "dec %0\n"            Note: Decrement to create mask
        : "=r"(result)
        : "r"(bits)
        : "flags"
    End Assembly
    Return result
End Process

Process called "extract_bits" that takes val as Integer, pos as Integer, len as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rcx, %2\n"       Note: Load position
        "mov %1, %0\n"        Note: Move value to result
        "shr %0, cl\n"        Note: Shift right by position
        "mov rcx, %3\n"       Note: Load length
        "mov rdx, 1\n"        Note: Load value 1
        "shl rdx, cl\n"       Note: Shift left by length
        "dec rdx\n"           Note: Create mask
        "and %0, rdx\n"       Note: Apply mask
        : "=r"(result)
        : "r"(val), "r"(pos), "r"(len)
        : "rcx", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "deposit_bits" that takes val as Integer, bits as Integer, pos as Integer, len as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rcx, %3\n"       Note: Load length
        "mov rdx, 1\n"        Note: Load value 1
        "shl rdx, cl\n"       Note: Shift left by length
        "dec rdx\n"           Note: Create mask
        "and rdx, %2\n"       Note: Mask bits to deposit
        "mov rcx, %4\n"       Note: Load position
        "shl rdx, cl\n"       Note: Shift mask to position
        "not rdx\n"           Note: Invert mask
        "and %1, rdx\n"       Note: Clear target bits in val
        "mov %0, %1\n"        Note: Move to result
        "mov rcx, %4\n"       Note: Load position again
        "shl %2, cl\n"        Note: Shift bits to position
        "or %0, %2\n"         Note: OR in the bits
        : "=r"(result)
        : "r"(val), "r"(bits), "r"(pos), "r"(len)
        : "rcx", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "clear_lowest_set" that takes a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1-1]\n"    Note: Calculate a-1
        "and %0, %1\n"        Note: AND with original value
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "isolate_lowest_set" that takes a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result
        "neg rax\n"           Note: Negate value in RAX
        "and %0, rax\n"       Note: AND to isolate lowest set bit
        : "=r"(result)
        : "r"(a)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "set_lowest_clear" that takes a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1+1]\n"    Note: Calculate a+1
        "or %0, %1\n"         Note: OR with original value
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: PARALLEL BIT OPERATIONS
Note: =====================================================================

Process called "parallel_bit_extract" that takes val as Integer, mask as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "pext %0, %1, %2\n"   Note: Parallel bit extract using mask
        : "=r"(result)
        : "r"(val), "r"(mask)
        :
    End Assembly
    Return result
End Process

Process called "parallel_bit_deposit" that takes val as Integer, mask as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "pdep %0, %1, %2\n"   Note: Parallel bit deposit using mask
        : "=r"(result)
        : "r"(val), "r"(mask)
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ATOMIC BITWISE OPERATIONS
Note: =====================================================================

Process called "atomic_fetch_and" that takes ptr as Pointer, val as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rax, [%1]\n"     Note: Load current value
        "1: mov rcx, rax\n"   Note: Copy to RCX
        "and rcx, %2\n"       Note: AND with value
        "lock cmpxchg [%1], rcx\n" Note: Atomic compare and exchange
        "jnz 1b\n"            Note: Retry if failed
        "mov %0, rax\n"       Note: Return original value
        : "=r"(result)
        : "r"(ptr), "r"(val)
        : "rax", "rcx", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "atomic_fetch_or" that takes ptr as Pointer, val as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rax, [%1]\n"     Note: Load current value
        "1: mov rcx, rax\n"   Note: Copy to RCX
        "or rcx, %2\n"        Note: OR with value
        "lock cmpxchg [%1], rcx\n" Note: Atomic compare and exchange
        "jnz 1b\n"            Note: Retry if failed
        "mov %0, rax\n"       Note: Return original value
        : "=r"(result)
        : "r"(ptr), "r"(val)
        : "rax", "rcx", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "atomic_fetch_xor" that takes ptr as Pointer, val as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rax, [%1]\n"     Note: Load current value
        "1: mov rcx, rax\n"   Note: Copy to RCX
        "xor rcx, %2\n"       Note: XOR with value
        "lock cmpxchg [%1], rcx\n" Note: Atomic compare and exchange
        "jnz 1b\n"            Note: Retry if failed
        "mov %0, rax\n"       Note: Return original value
        : "=r"(result)
        : "r"(ptr), "r"(val)
        : "rax", "rcx", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "atomic_bit_set" that takes ptr as Pointer, bit as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "lock bts [%1], %2\n" Note: Atomic bit test and set
        "setc %0\n"           Note: Set result to previous bit value
        : "=r"(result)
        : "r"(ptr), "r"(bit)
        : "memory", "flags"
    End Assembly
    Return result
End Process

Process called "atomic_bit_clear" that takes ptr as Pointer, bit as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "lock btr [%1], %2\n" Note: Atomic bit test and reset
        "setc %0\n"           Note: Set result to previous bit value
        : "=r"(result)
        : "r"(ptr), "r"(bit)
        : "memory", "flags"
    End Assembly
    Return result
End Process

Process called "atomic_bit_toggle" that takes ptr as Pointer, bit as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "lock btc [%1], %2\n" Note: Atomic bit test and complement
        "setc %0\n"           Note: Set result to previous bit value
        : "=r"(result)
        : "r"(ptr), "r"(bit)
        : "memory", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: BIT FIELD OPERATIONS
Note: =====================================================================

Process called "pack_bits" that takes a as Integer, b as Integer, bits_a as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rcx, %3\n"       Note: Load bits_a count
        "mov rdx, 1\n"        Note: Load value 1
        "shl rdx, cl\n"       Note: Shift left by bits_a
        "dec rdx\n"           Note: Create mask for a
        "and %1, rdx\n"       Note: Mask a to bits_a bits
        "mov %0, %1\n"        Note: Move masked a to result
        "shl %2, cl\n"        Note: Shift b left by bits_a
        "or %0, %2\n"         Note: OR b into result
        : "=r"(result)
        : "r"(a), "r"(b), "r"(bits_a)
        : "rcx", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "unpack_low" that takes val as Integer, bits as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rcx, %2\n"       Note: Load bit count
        "mov %0, 1\n"         Note: Load value 1
        "shl %0, cl\n"        Note: Shift left by bit count
        "dec %0\n"            Note: Create mask
        "and %0, %1\n"        Note: Extract low bits from val
        : "=r"(result)
        : "r"(val), "r"(bits)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "unpack_high" that takes val as Integer, bits as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rcx, %2\n"       Note: Load bit count
        "mov %1, %0\n"        Note: Move val to result
        "shr %0, cl\n"        Note: Shift right by bit count
        : "=r"(result)
        : "r"(val), "r"(bits)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: SPECIAL BIT PATTERNS
Note: =====================================================================

Process called "all_ones" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, -1\n"        Note: Load all ones pattern
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "all_zeros" returns Integer:
    Let result be 0
    Inline Assembly:
        "xor %0, %0\n"        Note: Clear register to all zeros
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Process called "alternating_bits" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, 0xAAAAAAAAAAAAAAAA\n" Note: Load alternating bit pattern
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alternating_bits_inv" returns Integer:
    Let result be 0
    Inline Assembly:
        "mov %0, 0x5555555555555555\n" Note: Load inverted alternating bit pattern
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process