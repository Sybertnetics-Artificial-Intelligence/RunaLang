Note:
stack_core.runa - Zero-Dependency Stack Manipulation Primitives

This module provides the foundational stack pointer operations and stack frame management.
These primitives have ZERO dependencies and compile to direct stack manipulation instructions.

@Reasoning:
- Provides raw stack access for function calls and local storage
- All operations use inline assembly for true self-hosting
- No external dependencies - we generate the machine code directly
- Essential for function prologue/epilogue and alloca

@Implementation:
- Inline Assembly statements for stack pointer manipulation
- Direct RSP/RBP register access on x86_64
- Stack growth direction aware (grows downward)
- Zero-cost abstraction over stack operations

@Performance_Hints:
- Single instruction stack operations
- No validation or overflow checks
- Direct register manipulation
- Critical for function call performance
:End Note

Note: =====================================================================
Note: STACK POINTER ACCESS
Note: =====================================================================

Process called "get_stack_pointer" returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, rsp\n"             Note: Get current stack pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "set_stack_pointer" that takes new_sp as Pointer:
    Inline Assembly:
        "mov rsp, %0\n"             Note: Set new stack pointer
        :
        : "r"(new_sp)
        : "rsp"
    End Assembly
End Process

Process called "get_frame_pointer" returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, rbp\n"             Note: Get current frame pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "set_frame_pointer" that takes new_fp as Pointer:
    Inline Assembly:
        "mov rbp, %0\n"             Note: Set new frame pointer
        :
        : "r"(new_fp)
        : "rbp"
    End Assembly
End Process

Process called "get_stack_base" returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, rbp\n"             Note: Get stack base from frame pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "get_stack_limit" returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, qword ptr gs:[0x10]\n" Note: Get stack limit from thread segment
        : "=r"(result)
        :
        : "memory"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: STACK ALLOCATION
Note: =====================================================================

Process called "stack_alloc" that takes size as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "sub rsp, %1\n"             Note: Allocate space on stack
        "mov %0, rsp\n"             Note: Return new stack pointer
        : "=r"(result)
        : "r"(size)
        : "rsp"
    End Assembly
    Return result
End Process

Process called "stack_free" that takes size as Integer64:
    Inline Assembly:
        "add rsp, %0\n"             Note: Free space from stack
        :
        : "r"(size)
        : "rsp"
    End Assembly
End Process

Process called "stack_alloc_aligned" that takes size as Integer64, alignment as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov rax, %1\n"             Note: Load size into RAX
        "add rax, %2\n"             Note: Add alignment for padding
        "sub rsp, rax\n"            Note: Allocate space with padding
        "mov %0, rsp\n"             Note: Get stack pointer
        "add %0, %2\n"              Note: Add alignment
        "dec %0\n"                  Note: Adjust for alignment calculation
        "mov rcx, %2\n"             Note: Load alignment into RCX
        "neg rcx\n"                 Note: Negate alignment for mask
        "and %0, rcx\n"             Note: Apply alignment mask
        : "=r"(result)
        : "r"(size), "r"(alignment)
        : "rax", "rcx", "rsp"
    End Assembly
    Return result
End Process

Process called "alloca_bytes" that takes size as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "sub rsp, %1\n"             Note: Allocate bytes on stack
        "mov %0, rsp\n"             Note: Return stack pointer
        : "=r"(result)
        : "r"(size)
        : "rsp"
    End Assembly
    Return result
End Process

Process called "alloca_aligned" that takes size as Integer64, alignment as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov rax, %1\n"             Note: Load size into RAX
        "add rax, %2\n"             Note: Add alignment for padding
        "sub rsp, rax\n"            Note: Allocate space with padding
        "mov %0, rsp\n"             Note: Get stack pointer
        "add %0, %2\n"              Note: Add alignment
        "dec %0\n"                  Note: Adjust for alignment calculation
        "mov rcx, %2\n"             Note: Load alignment into RCX
        "neg rcx\n"                 Note: Negate alignment for mask
        "and %0, rcx\n"             Note: Apply alignment mask
        : "=r"(result)
        : "r"(size), "r"(alignment)
        : "rax", "rcx", "rsp"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: STACK PUSH/POP OPERATIONS
Note: =====================================================================

Process called "push8" that takes val as Integer8:
    Inline Assembly:
        "push %0\n"                 Note: Push 8-bit value to stack
        :
        : "r"(val)
        : "rsp", "memory"
    End Assembly
End Process

Process called "push16" that takes val as Integer16:
    Inline Assembly:
        "push %0\n"                 Note: Push 16-bit value to stack
        :
        : "r"(val)
        : "rsp", "memory"
    End Assembly
End Process

Process called "push32" that takes val as Integer32:
    Inline Assembly:
        "push %0\n"                 Note: Push 32-bit value to stack
        :
        : "r"(val)
        : "rsp", "memory"
    End Assembly
End Process

Process called "push64" that takes val as Integer64:
    Inline Assembly:
        "push %0\n"                 Note: Push 64-bit value to stack
        :
        : "r"(val)
        : "rsp", "memory"
    End Assembly
End Process

Process called "push_ptr" that takes val as Pointer:
    Inline Assembly:
        "push %0\n"                 Note: Push pointer value to stack
        :
        : "r"(val)
        : "rsp", "memory"
    End Assembly
End Process

Process called "pop8" returns Integer8:
    Let result be 0
    Inline Assembly:
        "pop %0\n"                  Note: Pop 8-bit value from stack
        : "=r"(result)
        :
        : "rsp", "memory"
    End Assembly
    Return result
End Process

Process called "pop16" returns Integer16:
    Let result be 0
    Inline Assembly:
        "pop %0\n"                  Note: Pop 16-bit value from stack
        : "=r"(result)
        :
        : "rsp", "memory"
    End Assembly
    Return result
End Process

Process called "pop32" returns Integer32:
    Let result be 0
    Inline Assembly:
        "pop %0\n"                  Note: Pop 32-bit value from stack
        : "=r"(result)
        :
        : "rsp", "memory"
    End Assembly
    Return result
End Process

Process called "pop64" returns Integer64:
    Let result be 0
    Inline Assembly:
        "pop %0\n"                  Note: Pop 64-bit value from stack
        : "=r"(result)
        :
        : "rsp", "memory"
    End Assembly
    Return result
End Process

Process called "pop_ptr" returns Pointer:
    Let result be 0
    Inline Assembly:
        "pop %0\n"                  Note: Pop pointer value from stack
        : "=r"(result)
        :
        : "rsp", "memory"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: STACK FRAME OPERATIONS
Note: =====================================================================

Process called "enter_frame" that takes locals_size as Integer64:
    Inline Assembly:
        "push rbp\n"                Note: Save old frame pointer
        "mov rbp, rsp\n"            Note: Set new frame pointer
        "sub rsp, %0\n"             Note: Allocate space for locals
        :
        : "r"(locals_size)
        : "rbp", "rsp", "memory"
    End Assembly
End Process

Process called "leave_frame":
    Inline Assembly:
        "mov rsp, rbp\n"            Note: Restore stack pointer
        "pop rbp\n"                 Note: Restore old frame pointer
        :
        :
        : "rbp", "rsp", "memory"
    End Assembly
End Process

Process called "setup_frame" that takes locals as Integer64, params as Integer64:
    Inline Assembly:
        "enter %0, %1\n"            Note: Setup stack frame with ENTER instruction
        :
        : "i"(locals), "i"(params)
        : "rbp", "rsp", "memory"
    End Assembly
End Process

Process called "teardown_frame":
    Inline Assembly:
        "leave\n"                   Note: Teardown stack frame with LEAVE instruction
        :
        :
        : "rbp", "rsp", "memory"
    End Assembly
End Process

Process called "save_frame_pointer" returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, rbp\n"             Note: Save current frame pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "restore_frame_pointer" that takes saved_fp as Pointer:
    Inline Assembly:
        "mov rbp, %0\n"             Note: Restore saved frame pointer
        :
        : "r"(saved_fp)
        : "rbp"
    End Assembly
End Process

Note: =====================================================================
Note: STACK INSPECTION
Note: =====================================================================

Process called "stack_depth" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov rax, rbp\n"            Note: Load frame pointer
        "sub rax, rsp\n"            Note: Calculate depth
        "mov %0, rax\n"             Note: Store result
        : "=r"(result)
        :
        : "rax"
    End Assembly
    Return result
End Process

Process called "stack_available" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov rax, rsp\n"            Note: Get current stack pointer
        "mov rcx, qword ptr gs:[0x10]\n" Note: Get stack limit
        "sub rax, rcx\n"            Note: Calculate available space
        "mov %0, rax\n"             Note: Store result
        : "=r"(result)
        :
        : "rax", "rcx", "memory"
    End Assembly
    Return result
End Process

Process called "is_stack_aligned" that takes alignment as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, rsp\n"            Note: Get stack pointer
        "mov rcx, %1\n"             Note: Load alignment
        "dec rcx\n"                 Note: Create alignment mask
        "test rax, rcx\n"           Note: Test alignment
        "setz %0\n"                 Note: Set result if aligned
        : "=r"(result)
        : "r"(alignment)
        : "rax", "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "stack_offset_from_base" that takes addr as Pointer returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, rbp\n"             Note: Get frame pointer
        "sub %0, %1\n"              Note: Calculate offset from address
        : "=r"(result)
        : "r"(addr)
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: STACK WALKING
Note: =====================================================================

Process called "get_return_address" returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, qword ptr [rbp + 8]\n" Note: Get return address from stack
        : "=r"(result)
        :
        : "memory"
    End Assembly
    Return result
End Process

Process called "get_caller_frame" returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, qword ptr [rbp]\n" Note: Get caller's frame pointer
        : "=r"(result)
        :
        : "memory"
    End Assembly
    Return result
End Process

Process called "get_frame_at" that takes depth as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, rbp\n"             Note: Start at current frame
        "mov rcx, %1\n"             Note: Load depth counter
        "1:\n"                      Note: Loop label
        "test rcx, rcx\n"           Note: Check if depth is zero
        "jz 2f\n"                   Note: Jump to end if zero
        "mov %0, qword ptr [%0]\n"  Note: Move to parent frame
        "dec rcx\n"                 Note: Decrement depth
        "jmp 1b\n"                  Note: Continue loop
        "2:\n"                      Note: End label
        : "=r"(result)
        : "r"(depth)
        : "rcx", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "get_return_address_at" that takes depth as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov rax, rbp\n"            Note: Start at current frame
        "mov rcx, %1\n"             Note: Load depth counter
        "1:\n"                      Note: Loop label
        "test rcx, rcx\n"           Note: Check if depth is zero
        "jz 2f\n"                   Note: Jump to end if zero
        "mov rax, qword ptr [rax]\n" Note: Move to parent frame
        "dec rcx\n"                 Note: Decrement depth
        "jmp 1b\n"                  Note: Continue loop
        "2:\n"                      Note: End label
        "mov %0, qword ptr [rax + 8]\n" Note: Get return address at depth
        : "=r"(result)
        : "r"(depth)
        : "rax", "rcx", "memory", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: STACK CANARY OPERATIONS (for security)
Note: =====================================================================

Process called "set_stack_canary" that takes canary as Integer64:
    Inline Assembly:
        "mov qword ptr [rbp - 8], %0\n" Note: Set stack canary value
        :
        : "r"(canary)
        : "memory"
    End Assembly
End Process

Process called "check_stack_canary" that takes expected as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp qword ptr [rbp - 8], %1\n" Note: Compare canary with expected
        "sete %0\n"                 Note: Set result if equal
        : "=r"(result)
        : "r"(expected)
        : "flags", "memory"
    End Assembly
    Return result
End Process

Process called "get_stack_canary" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, qword ptr [rbp - 8]\n" Note: Get stack canary value
        : "=r"(result)
        :
        : "memory"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: STACK RED ZONE (x86_64 specific)
Note: =====================================================================

Process called "use_red_zone" that takes offset as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov rax, %1\n"             Note: Load offset into RAX
        "neg rax\n"                 Note: Negate offset for subtraction
        "lea %0, [rsp + rax]\n"     Note: Calculate red zone address
        : "=r"(result)
        : "r"(offset)
        : "rax"
    End Assembly
    Return result
End Process

Process called "red_zone_store" that takes offset as Integer64, val as Integer64:
    Inline Assembly:
        "mov rax, %0\n"             Note: Load offset into RAX
        "neg rax\n"                 Note: Negate offset
        "mov qword ptr [rsp + rax], %1\n" Note: Store value in red zone
        :
        : "r"(offset), "r"(val)
        : "rax", "memory"
    End Assembly
End Process

Process called "red_zone_load" that takes offset as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov rax, %1\n"             Note: Load offset into RAX
        "neg rax\n"                 Note: Negate offset
        "mov %0, qword ptr [rsp + rax]\n" Note: Load value from red zone
        : "=r"(result)
        : "r"(offset)
        : "rax", "memory"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: STACK ALIGNMENT
Note: =====================================================================

Process called "align_stack_pointer" that takes alignment as Integer64:
    Inline Assembly:
        "mov rax, %0\n"             Note: Load alignment into RAX
        "neg rax\n"                 Note: Negate to create mask
        "and rsp, rax\n"            Note: Align stack pointer
        :
        : "r"(alignment)
        : "rax", "rsp"
    End Assembly
End Process

Process called "save_and_align_stack" that takes alignment as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, rsp\n"             Note: Save current stack pointer
        "mov rax, %1\n"             Note: Load alignment
        "neg rax\n"                 Note: Negate to create mask
        "and rsp, rax\n"            Note: Align stack pointer
        : "=r"(result)
        : "r"(alignment)
        : "rax", "rsp"
    End Assembly
    Return result
End Process

Process called "restore_stack_alignment" that takes saved_sp as Pointer:
    Inline Assembly:
        "mov rsp, %0\n"             Note: Restore saved stack pointer
        :
        : "r"(saved_sp)
        : "rsp"
    End Assembly
End Process

Note: =====================================================================
Note: STACK PROBING (for large allocations)
Note: =====================================================================

Process called "probe_stack" that takes size as Integer64:
    Inline Assembly:
        "mov rcx, %0\n"             Note: Load size into RCX
        "1:\n"                      Note: Loop label
        "sub rsp, 4096\n"           Note: Allocate one page
        "test dword ptr [rsp], 0\n" Note: Touch the page
        "sub rcx, 4096\n"           Note: Decrement remaining size
        "cmp rcx, 4096\n"           Note: Check if more than one page left
        "ja 1b\n"                   Note: Continue if more pages needed
        "sub rsp, rcx\n"            Note: Allocate remaining bytes
        :
        : "r"(size)
        : "rcx", "rsp", "memory", "flags"
    End Assembly
End Process

Process called "touch_stack_page" that takes addr as Pointer:
    Inline Assembly:
        "test dword ptr [%0], 0\n"  Note: Touch memory page to trigger fault if needed
        :
        : "r"(addr)
        : "memory", "flags"
    End Assembly
End Process

Note: =====================================================================
Note: STACK UNWINDING SUPPORT
Note: =====================================================================

Process called "unwind_to_frame" that takes target_fp as Pointer:
    Inline Assembly:
        "mov rsp, %0\n"             Note: Set stack pointer to target frame
        "pop rbp\n"                 Note: Restore frame pointer
        :
        : "r"(target_fp)
        : "rsp", "rbp", "memory"
    End Assembly
End Process

Process called "capture_stack_state" that takes buffer as Pointer:
    Inline Assembly:
        "mov qword ptr [%0], rsp\n"     Note: Save stack pointer
        "mov qword ptr [%0 + 8], rbp\n" Note: Save frame pointer
        :
        : "r"(buffer)
        : "memory"
    End Assembly
End Process

Process called "restore_stack_state" that takes buffer as Pointer:
    Inline Assembly:
        "mov rsp, qword ptr [%0]\n"     Note: Restore stack pointer
        "mov rbp, qword ptr [%0 + 8]\n" Note: Restore frame pointer
        :
        : "r"(buffer)
        : "rsp", "rbp", "memory"
    End Assembly
End Process

Note: =====================================================================
Note: VARIABLE ARGUMENT SUPPORT
Note: =====================================================================

Process called "va_start" that takes count as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "lea %0, [rbp + 16]\n"      Note: Get address of first variadic argument
        : "=r"(result)
        : "0"(count)
        :
    End Assembly
    Return result
End Process

Process called "va_arg_ptr" that takes va_list as Pointer, offset as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + %2]\n"       Note: Calculate address of variadic argument
        : "=r"(result)
        : "r"(va_list), "r"(offset)
        :
    End Assembly
    Return result
End Process

Process called "va_end" that takes va_list as Pointer:
    Inline Assembly:
        ""                          Note: No-op for va_end on x86_64
        :
        : "r"(va_list)
        :
    End Assembly
End Process