Note:
register_core.runa - Zero-Dependency Register Allocation Hint Primitives

This module provides register allocation hints and direct register access.
These primitives have ZERO dependencies and compile to register manipulation instructions.

@Reasoning:
- Provides hints to compiler for register allocation
- Direct register access for critical performance paths
- All operations use inline assembly for true self-hosting
- Essential for optimized code generation

@Implementation:
- Inline Assembly with explicit register specifications
- Compiler hints for register pressure management
- Direct access to specific registers when needed
- Zero-cost abstraction over register operations

@Performance_Hints:
- Zero-cycle register moves (renamed in hardware)
- Direct register-to-register operations
- Helps compiler make optimal allocation decisions
- Critical for inner loop optimization
:End Note

Note: =====================================================================
Note: REGISTER HINTS
Note: =====================================================================

Process called "hint_register" that takes val as Any returns Any:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"              Note: Register allocation hint
        : "=r"(result)
        : "r"(val)
        :
    End Assembly
    Return result
End Process

Process called "hint_keep_in_register" that takes val as Any returns Any:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"              Note: Hint to keep value in register
        : "=r"(result)
        : "r"(val)
        :
    End Assembly
    Return result
End Process

Process called "hint_spill_to_memory" that takes val as Any returns Any:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"              Note: Hint to spill value to memory
        : "=m"(result)
        : "r"(val)
        : "memory"
    End Assembly
    Return result
End Process

Process called "hint_volatile" that takes val as Any returns Any:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"              Note: Volatile register hint
        : "=r"(result)
        : "r"(val)
        : "memory"
    End Assembly
    Return result
End Process

Process called "hint_preserve" that takes val as Any returns Any:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"              Note: Hint to preserve value across calls
        : "=r"(result)
        : "r"(val)
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: GENERAL PURPOSE REGISTER ACCESS (x86_64)
Note: =====================================================================

Process called "read_rax" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, rax\n"             Note: Read RAX register
        : "=r"(result)
        :
        : "rax"
    End Assembly
    Return result
End Process

Process called "write_rax" that takes val as Integer64:
    Inline Assembly:
        "mov rax, %0\n"             Note: Write to RAX register
        :
        : "r"(val)
        : "rax"
    End Assembly
End Process

Process called "read_rbx" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, rbx\n"             Note: Read RBX register
        : "=r"(result)
        :
        : "rbx"
    End Assembly
    Return result
End Process

Process called "write_rbx" that takes val as Integer64:
    Inline Assembly:
        "mov rbx, %0\n"             Note: Write to RBX register
        :
        : "r"(val)
        : "rbx"
    End Assembly
End Process

Process called "read_rcx" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, rcx\n"             Note: Read RCX register
        : "=r"(result)
        :
        : "rcx"
    End Assembly
    Return result
End Process

Process called "write_rcx" that takes val as Integer64:
    Inline Assembly:
        "mov rcx, %0\n"             Note: Write to RCX register
        :
        : "r"(val)
        : "rcx"
    End Assembly
End Process

Process called "read_rdx" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, rdx\n"             Note: Read RDX register
        : "=r"(result)
        :
        : "rdx"
    End Assembly
    Return result
End Process

Process called "write_rdx" that takes val as Integer64:
    Inline Assembly:
        "mov rdx, %0\n"             Note: Write to RDX register
        :
        : "r"(val)
        : "rdx"
    End Assembly
End Process

Process called "read_rsi" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, rsi\n"             Note: Read RSI register
        : "=r"(result)
        :
        : "rsi"
    End Assembly
    Return result
End Process

Process called "write_rsi" that takes val as Integer64:
    Inline Assembly:
        "mov rsi, %0\n"             Note: Write to RSI register
        :
        : "r"(val)
        : "rsi"
    End Assembly
End Process

Process called "read_rdi" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, rdi\n"             Note: Read RDI register
        : "=r"(result)
        :
        : "rdi"
    End Assembly
    Return result
End Process

Process called "write_rdi" that takes val as Integer64:
    Inline Assembly:
        "mov rdi, %0\n"             Note: Write to RDI register
        :
        : "r"(val)
        : "rdi"
    End Assembly
End Process

Note: =====================================================================
Note: EXTENDED REGISTERS (x86_64)
Note: =====================================================================

Process called "read_r8" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, r8\n"              Note: Read R8 register
        : "=r"(result)
        :
        : "r8"
    End Assembly
    Return result
End Process

Process called "write_r8" that takes val as Integer64:
    Inline Assembly:
        "mov r8, %0\n"              Note: Write to R8 register
        :
        : "r"(val)
        : "r8"
    End Assembly
End Process

Process called "read_r9" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, r9\n"              Note: Read R9 register
        : "=r"(result)
        :
        : "r9"
    End Assembly
    Return result
End Process

Process called "write_r9" that takes val as Integer64:
    Inline Assembly:
        "mov r9, %0\n"              Note: Write to R9 register
        :
        : "r"(val)
        : "r9"
    End Assembly
End Process

Process called "read_r10" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, r10\n"             Note: Read R10 register
        : "=r"(result)
        :
        : "r10"
    End Assembly
    Return result
End Process

Process called "write_r10" that takes val as Integer64:
    Inline Assembly:
        "mov r10, %0\n"             Note: Write to R10 register
        :
        : "r"(val)
        : "r10"
    End Assembly
End Process

Process called "read_r11" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, r11\n"             Note: Read R11 register
        : "=r"(result)
        :
        : "r11"
    End Assembly
    Return result
End Process

Process called "write_r11" that takes val as Integer64:
    Inline Assembly:
        "mov r11, %0\n"             Note: Write to R11 register
        :
        : "r"(val)
        : "r11"
    End Assembly
End Process

Process called "read_r12" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, r12\n"             Note: Read R12 register
        : "=r"(result)
        :
        : "r12"
    End Assembly
    Return result
End Process

Process called "write_r12" that takes val as Integer64:
    Inline Assembly:
        "mov r12, %0\n"             Note: Write to R12 register
        :
        : "r"(val)
        : "r12"
    End Assembly
End Process

Process called "read_r13" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, r13\n"             Note: Read R13 register
        : "=r"(result)
        :
        : "r13"
    End Assembly
    Return result
End Process

Process called "write_r13" that takes val as Integer64:
    Inline Assembly:
        "mov r13, %0\n"             Note: Write to R13 register
        :
        : "r"(val)
        : "r13"
    End Assembly
End Process

Process called "read_r14" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, r14\n"             Note: Read R14 register
        : "=r"(result)
        :
        : "r14"
    End Assembly
    Return result
End Process

Process called "write_r14" that takes val as Integer64:
    Inline Assembly:
        "mov r14, %0\n"             Note: Write to R14 register
        :
        : "r"(val)
        : "r14"
    End Assembly
End Process

Process called "read_r15" returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, r15\n"             Note: Read R15 register
        : "=r"(result)
        :
        : "r15"
    End Assembly
    Return result
End Process

Process called "write_r15" that takes val as Integer64:
    Inline Assembly:
        "mov r15, %0\n"             Note: Write to R15 register
        :
        : "r"(val)
        : "r15"
    End Assembly
End Process

Note: =====================================================================
Note: FLAGS REGISTER ACCESS
Note: =====================================================================

Process called "read_flags" returns Integer64:
    Let result be 0
    Inline Assembly:
        "pushfq\n"                  Note: Push flags to stack
        "pop %0\n"                  Note: Pop flags to result
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Process called "write_flags" that takes val as Integer64:
    Inline Assembly:
        "push %0\n"                 Note: Push value to stack
        "popfq\n"                   Note: Pop stack to flags
        :
        : "r"(val)
        : "flags"
    End Assembly
End Process

Process called "save_flags" returns Integer64:
    Let result be 0
    Inline Assembly:
        "pushfq\n"                  Note: Push flags to stack
        "pop %0\n"                  Note: Pop flags to result
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Process called "restore_flags" that takes flags as Integer64:
    Inline Assembly:
        "push %0\n"                 Note: Push flags value to stack
        "popfq\n"                   Note: Pop stack to flags register
        :
        : "r"(flags)
        : "flags"
    End Assembly
End Process

Process called "get_carry" returns Boolean:
    Let result be false
    Inline Assembly:
        "setc %0\n"                 Note: Set if carry flag is set
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Process called "get_zero" returns Boolean:
    Let result be false
    Inline Assembly:
        "setz %0\n"                 Note: Set if zero flag is set
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Process called "get_sign" returns Boolean:
    Let result be false
    Inline Assembly:
        "sets %0\n"                 Note: Set if sign flag is set
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Process called "get_overflow" returns Boolean:
    Let result be false
    Inline Assembly:
        "seto %0\n"                 Note: Set if overflow flag is set
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Process called "get_parity" returns Boolean:
    Let result be false
    Inline Assembly:
        "setp %0\n"                 Note: Set if parity flag is set
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: REGISTER SAVE/RESTORE
Note: =====================================================================

Process called "save_all_registers" that takes buffer as Pointer:
    Inline Assembly:
        "mov qword ptr [%0], rax\n"     Note: Save RAX
        "mov qword ptr [%0+8], rbx\n"   Note: Save RBX
        "mov qword ptr [%0+16], rcx\n"  Note: Save RCX
        "mov qword ptr [%0+24], rdx\n"  Note: Save RDX
        "mov qword ptr [%0+32], rsi\n"  Note: Save RSI
        "mov qword ptr [%0+40], rdi\n"  Note: Save RDI
        "mov qword ptr [%0+48], r8\n"   Note: Save R8
        "mov qword ptr [%0+56], r9\n"   Note: Save R9
        "mov qword ptr [%0+64], r10\n"  Note: Save R10
        "mov qword ptr [%0+72], r11\n"  Note: Save R11
        "mov qword ptr [%0+80], r12\n"  Note: Save R12
        "mov qword ptr [%0+88], r13\n"  Note: Save R13
        "mov qword ptr [%0+96], r14\n"  Note: Save R14
        "mov qword ptr [%0+104], r15\n" Note: Save R15
        :
        : "r"(buffer)
        : "rax", "rbx", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15", "memory"
    End Assembly
End Process

Process called "restore_all_registers" that takes buffer as Pointer:
    Inline Assembly:
        "mov rax, qword ptr [%0]\n"     Note: Restore RAX
        "mov rbx, qword ptr [%0+8]\n"   Note: Restore RBX
        "mov rcx, qword ptr [%0+16]\n"  Note: Restore RCX
        "mov rdx, qword ptr [%0+24]\n"  Note: Restore RDX
        "mov rsi, qword ptr [%0+32]\n"  Note: Restore RSI
        "mov rdi, qword ptr [%0+40]\n"  Note: Restore RDI
        "mov r8, qword ptr [%0+48]\n"   Note: Restore R8
        "mov r9, qword ptr [%0+56]\n"   Note: Restore R9
        "mov r10, qword ptr [%0+64]\n"  Note: Restore R10
        "mov r11, qword ptr [%0+72]\n"  Note: Restore R11
        "mov r12, qword ptr [%0+80]\n"  Note: Restore R12
        "mov r13, qword ptr [%0+88]\n"  Note: Restore R13
        "mov r14, qword ptr [%0+96]\n"  Note: Restore R14
        "mov r15, qword ptr [%0+104]\n" Note: Restore R15
        :
        : "r"(buffer)
        : "rax", "rbx", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15", "memory"
    End Assembly
End Process

Process called "save_callee_saved" that takes buffer as Pointer:
    Inline Assembly:
        "mov qword ptr [%0], rbx\n"     Note: Save RBX (callee-saved)
        "mov qword ptr [%0+8], r12\n"   Note: Save R12 (callee-saved)
        "mov qword ptr [%0+16], r13\n"  Note: Save R13 (callee-saved)
        "mov qword ptr [%0+24], r14\n"  Note: Save R14 (callee-saved)
        "mov qword ptr [%0+32], r15\n"  Note: Save R15 (callee-saved)
        :
        : "r"(buffer)
        : "rbx", "r12", "r13", "r14", "r15", "memory"
    End Assembly
End Process

Process called "restore_callee_saved" that takes buffer as Pointer:
    Inline Assembly:
        "mov rbx, qword ptr [%0]\n"     Note: Restore RBX (callee-saved)
        "mov r12, qword ptr [%0+8]\n"   Note: Restore R12 (callee-saved)
        "mov r13, qword ptr [%0+16]\n"  Note: Restore R13 (callee-saved)
        "mov r14, qword ptr [%0+24]\n"  Note: Restore R14 (callee-saved)
        "mov r15, qword ptr [%0+32]\n"  Note: Restore R15 (callee-saved)
        :
        : "r"(buffer)
        : "rbx", "r12", "r13", "r14", "r15", "memory"
    End Assembly
End Process

Process called "save_caller_saved" that takes buffer as Pointer:
    Inline Assembly:
        "mov qword ptr [%0], rax\n"     Note: Save RAX (caller-saved)
        "mov qword ptr [%0+8], rcx\n"   Note: Save RCX (caller-saved)
        "mov qword ptr [%0+16], rdx\n"  Note: Save RDX (caller-saved)
        "mov qword ptr [%0+24], rsi\n"  Note: Save RSI (caller-saved)
        "mov qword ptr [%0+32], rdi\n"  Note: Save RDI (caller-saved)
        "mov qword ptr [%0+40], r8\n"   Note: Save R8 (caller-saved)
        "mov qword ptr [%0+48], r9\n"   Note: Save R9 (caller-saved)
        "mov qword ptr [%0+56], r10\n"  Note: Save R10 (caller-saved)
        "mov qword ptr [%0+64], r11\n"  Note: Save R11 (caller-saved)
        :
        : "r"(buffer)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "memory"
    End Assembly
End Process

Process called "restore_caller_saved" that takes buffer as Pointer:
    Inline Assembly:
        "mov rax, qword ptr [%0]\n"     Note: Restore RAX (caller-saved)
        "mov rcx, qword ptr [%0+8]\n"   Note: Restore RCX (caller-saved)
        "mov rdx, qword ptr [%0+16]\n"  Note: Restore RDX (caller-saved)
        "mov rsi, qword ptr [%0+24]\n"  Note: Restore RSI (caller-saved)
        "mov rdi, qword ptr [%0+32]\n"  Note: Restore RDI (caller-saved)
        "mov r8, qword ptr [%0+40]\n"   Note: Restore R8 (caller-saved)
        "mov r9, qword ptr [%0+48]\n"   Note: Restore R9 (caller-saved)
        "mov r10, qword ptr [%0+56]\n"  Note: Restore R10 (caller-saved)
        "mov r11, qword ptr [%0+64]\n"  Note: Restore R11 (caller-saved)
        :
        : "r"(buffer)
        : "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "memory"
    End Assembly
End Process

Note: =====================================================================
Note: REGISTER EXCHANGE AND SWAP
Note: =====================================================================

Process called "xchg_registers" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov rax, %1\n"             Note: Load first value into RAX
        "mov rbx, %2\n"             Note: Load second value into RBX
        "xchg rax, rbx\n"           Note: Exchange the values
        "mov %0, rax\n"             Note: Return first value (now contains second)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rbx"
    End Assembly
    Return result
End Process

Process called "swap_rax_rbx":
    Inline Assembly:
        "xchg rax, rbx\n"           Note: Exchange RAX and RBX registers
        :
        :
        : "rax", "rbx"
    End Assembly
End Process

Process called "swap_rcx_rdx":
    Inline Assembly:
        "xchg rcx, rdx\n"           Note: Exchange RCX and RDX registers
        :
        :
        : "rcx", "rdx"
    End Assembly
End Process

Process called "swap_rsi_rdi":
    Inline Assembly:
        "xchg rsi, rdi\n"           Note: Exchange RSI and RDI registers
        :
        :
        : "rsi", "rdi"
    End Assembly
End Process

Note: =====================================================================
Note: REGISTER ZEROING
Note: =====================================================================

Process called "zero_rax":
    Inline Assembly:
        "xor rax, rax\n"            Note: Zero RAX register
        :
        :
        : "rax"
    End Assembly
End Process

Process called "zero_rbx":
    Inline Assembly:
        "xor rbx, rbx\n"            Note: Zero RBX register
        :
        :
        : "rbx"
    End Assembly
End Process

Process called "zero_rcx":
    Inline Assembly:
        "xor rcx, rcx\n"            Note: Zero RCX register
        :
        :
        : "rcx"
    End Assembly
End Process

Process called "zero_rdx":
    Inline Assembly:
        "xor rdx, rdx\n"            Note: Zero RDX register
        :
        :
        : "rdx"
    End Assembly
End Process

Process called "zero_register" that takes reg as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "xor %0, %0\n"              Note: Zero the register efficiently
        : "=r"(result)
        : "0"(reg)
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: SPECIAL PURPOSE REGISTERS
Note: =====================================================================

Process called "read_rip" returns Pointer:
    Let result be 0
    Inline Assembly:
        "lea %0, [rip]\n"           Note: Load effective address of instruction pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "cpuid" that takes func as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov eax, %1\n"             Note: Load function code into EAX
        "cpuid\n"                   Note: Execute CPUID instruction
        "mov %0, eax\n"             Note: Move result from EAX
        : "=r"(result)
        : "r"(func)
        : "eax", "ebx", "ecx", "edx"
    End Assembly
    Return result
End Process

Process called "rdtsc" returns Integer64:
    Let result be 0
    Inline Assembly:
        "rdtsc\n"                   Note: Read timestamp counter
        "shl rdx, 32\n"             Note: Shift high 32 bits left
        "or rax, rdx\n"             Note: Combine high and low parts
        "mov %0, rax\n"             Note: Move result to output
        : "=r"(result)
        :
        : "rax", "rdx"
    End Assembly
    Return result
End Process

Process called "rdtscp" returns Integer64:
    Let result be 0
    Inline Assembly:
        "rdtscp\n"                  Note: Read timestamp counter with processor ID
        "shl rdx, 32\n"             Note: Shift high 32 bits left
        "or rax, rdx\n"             Note: Combine high and low parts
        "mov %0, rax\n"             Note: Move result to output
        : "=r"(result)
        :
        : "rax", "rcx", "rdx"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: REGISTER PRESSURE MANAGEMENT
Note: =====================================================================

Process called "hint_high_pressure":
    Inline Assembly:
        ""                          Note: Compiler hint for high register pressure
        :
        :
        : "memory"
    End Assembly
End Process

Process called "hint_low_pressure":
    Inline Assembly:
        ""                          Note: Compiler hint for low register pressure
        :
        :
        : "memory"
    End Assembly
End Process

Process called "hint_critical_section_begin":
    Inline Assembly:
        ""                          Note: Mark beginning of critical section
        :
        :
        : "memory"
    End Assembly
End Process

Process called "hint_critical_section_end":
    Inline Assembly:
        ""                          Note: Mark end of critical section
        :
        :
        : "memory"
    End Assembly
End Process

Process called "hint_loop_invariant" that takes val as Any returns Any:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"              Note: Hint that value is loop invariant
        : "=r"(result)
        : "r"(val)
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: REGISTER ALLOCATION CONSTRAINTS
Note: =====================================================================

Process called "force_to_rax" that takes val as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov rax, %1\n"             Note: Force value into RAX register
        "mov %0, rax\n"             Note: Move from RAX to result
        : "=r"(result)
        : "r"(val)
        : "rax"
    End Assembly
    Return result
End Process

Process called "force_to_memory" that takes val as Integer64, addr as Pointer:
    Inline Assembly:
        "mov qword ptr [%0], %1\n"  Note: Force value to memory location
        :
        : "r"(addr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "force_from_memory" that takes addr as Pointer returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, qword ptr [%1]\n"  Note: Force load from memory location
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "pin_to_register" that takes val as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"              Note: Pin value to register
        : "=r"(result)
        : "r"(val)
        :
    End Assembly
    Return result
End Process