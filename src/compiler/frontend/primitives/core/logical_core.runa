Note:
logical_core.runa - Zero-Dependency Logical Operation Primitives

This module provides unified logical operations for boolean and control flow logic.
These primitives have ZERO dependencies and compile to direct CPU flag and branch operations.

@Reasoning:
- Provides logical operations with short-circuit evaluation
- All operations use inline assembly for true self-hosting
- No external dependencies - we generate the machine code directly
- Essential for control flow and conditional logic

@Implementation:
- Inline Assembly statements using flag operations
- Short-circuit evaluation for efficiency
- Branchless implementations where possible
- Zero-cost abstraction through compile-time optimization

@Performance_Hints:
- Branchless operations use conditional moves
- Short-circuit versions use minimal branching
- Direct flag register manipulation
- Optimized for prediction-friendly patterns
:End Note

Note: =====================================================================
Note: BASIC LOGICAL OPERATIONS (with short-circuit)
Note: =====================================================================

Process called "logical_and" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test first operand
        "jz 1f\n"            Note: Jump to false result if zero
        "test %2, %2\n"      Note: Test second operand
        "setnz %0\n"         Note: Set result if non-zero
        "jmp 2f\n"           Note: Jump to end
        "1: xor %0, %0\n"    Note: Set result to false
        "2:\n"               Note: End label
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "logical_or" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test first operand
        "jnz 1f\n"           Note: Jump to true result if non-zero
        "test %2, %2\n"      Note: Test second operand
        "setnz %0\n"         Note: Set result if non-zero
        "jmp 2f\n"           Note: Jump to end
        "1: mov %0, 1\n"     Note: Set result to true
        "2:\n"               Note: End label
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "logical_not" that takes a as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test operand
        "setz %0\n"          Note: Set result if zero (logical NOT)
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "logical_xor" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "xor %0, %2\n"       Note: XOR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: BRANCHLESS LOGICAL OPERATIONS
Note: =====================================================================

Process called "and_branchless" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "and %0, %2\n"       Note: Branchless AND with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "or_branchless" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "or %0, %2\n"        Note: Branchless OR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "xor_branchless" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "xor %0, %2\n"       Note: Branchless XOR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "nand_branchless" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "and %0, %2\n"       Note: AND with second operand
        "xor %0, 1\n"        Note: Invert result for NAND
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "nor_branchless" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "or %0, %2\n"        Note: OR with second operand
        "xor %0, 1\n"        Note: Invert result for NOR
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "xnor_branchless" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "xor %0, %2\n"       Note: XOR with second operand
        "xor %0, 1\n"        Note: Invert result for XNOR
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: IMPLICATION AND EQUIVALENCE
Note: =====================================================================

Process called "implies" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test first operand
        "jz 1f\n"            Note: Jump if false (implication is true)
        "mov %0, %2\n"       Note: Result equals second operand
        "jmp 2f\n"           Note: Jump to end
        "1: mov %0, 1\n"     Note: Implication is true when antecedent is false
        "2:\n"               Note: End label
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "iff" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "xor %0, %2\n"       Note: XOR with second operand
        "xor %0, 1\n"        Note: Invert for equivalence (if and only if)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "material_conditional" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov cl, %1\n"       Note: Move first operand to CL
        "not cl\n"           Note: Negate first operand
        "or cl, %2\n"        Note: OR with second operand
        "movzx %0, cl\n"     Note: Zero-extend result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "cl", "flags"
    End Assembly
    Return result
End Process

Process called "material_biconditional" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "xor %0, %2\n"       Note: XOR with second operand
        "xor %0, 1\n"        Note: Invert for biconditional
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: TERNARY LOGICAL OPERATIONS
Note: =====================================================================

Process called "logical_select" that takes cond as Boolean, true_val as Boolean, false_val as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, %3\n"       Note: Start with false_val in result
        "test %1, %1\n"      Note: Test condition
        "cmovnz %0, %2\n"    Note: Move true_val if condition is non-zero
        : "=r"(result)
        : "r"(cond), "r"(true_val), "r"(false_val)
        : "flags"
    End Assembly
    Return result
End Process

Process called "logical_mux" that takes sel as Boolean, a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, %3\n"       Note: Start with b in result
        "test %1, %1\n"      Note: Test selector
        "cmovnz %0, %2\n"    Note: Move a if selector is non-zero
        : "=r"(result)
        : "r"(sel), "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "majority" that takes a as Boolean, b as Boolean, c as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "movzx eax, %1\n"    Note: Zero-extend first operand
        "movzx ecx, %2\n"    Note: Zero-extend second operand
        "movzx edx, %3\n"    Note: Zero-extend third operand
        "add eax, ecx\n"     Note: Add first two values
        "add eax, edx\n"     Note: Add third value
        "cmp eax, 2\n"       Note: Compare sum with 2
        "setge %0\n"         Note: Set result if sum >= 2 (majority)
        : "=r"(result)
        : "r"(a), "r"(b), "r"(c)
        : "eax", "ecx", "edx", "flags"
    End Assembly
    Return result
End Process

Process called "minority" that takes a as Boolean, b as Boolean, c as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "movzx eax, %1\n"    Note: Zero-extend first operand
        "movzx ecx, %2\n"    Note: Zero-extend second operand
        "movzx edx, %3\n"    Note: Zero-extend third operand
        "add eax, ecx\n"     Note: Add first two values
        "add eax, edx\n"     Note: Add third value
        "cmp eax, 2\n"       Note: Compare sum with 2
        "setl %0\n"          Note: Set result if sum < 2 (minority)
        : "=r"(result)
        : "r"(a), "r"(b), "r"(c)
        : "eax", "ecx", "edx", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: N-ARY LOGICAL OPERATIONS
Note: =====================================================================

Process called "all_true" that takes ptr as Pointer, count as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rcx, %2\n"      Note: Load count into RCX
        "mov rsi, %1\n"      Note: Load pointer into RSI
        "1: test rcx, rcx\n" Note: Test if count is zero
        "jz 2f\n"            Note: Jump to success if done
        "lodsb\n"            Note: Load byte and increment RSI
        "test al, al\n"      Note: Test if byte is zero
        "jz 3f\n"            Note: Jump to failure if false found
        "dec rcx\n"          Note: Decrement count
        "jmp 1b\n"           Note: Loop back
        "2: mov %0, 1\n"     Note: All were true
        "jmp 4f\n"           Note: Jump to end
        "3: xor %0, %0\n"    Note: Found a false value
        "4:\n"               Note: End label
        : "=r"(result)
        : "r"(ptr), "r"(count)
        : "rcx", "rsi", "al", "flags"
    End Assembly
    Return result
End Process

Process called "any_true" that takes ptr as Pointer, count as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rcx, %2\n"      Note: Load count into RCX
        "mov rsi, %1\n"      Note: Load pointer into RSI
        "1: test rcx, rcx\n" Note: Test if count is zero
        "jz 2f\n"            Note: Jump to failure if done
        "lodsb\n"            Note: Load byte and increment RSI
        "test al, al\n"      Note: Test if byte is non-zero
        "jnz 3f\n"           Note: Jump to success if true found
        "dec rcx\n"          Note: Decrement count
        "jmp 1b\n"           Note: Loop back
        "2: xor %0, %0\n"    Note: None were true
        "jmp 4f\n"           Note: Jump to end
        "3: mov %0, 1\n"     Note: Found a true value
        "4:\n"               Note: End label
        : "=r"(result)
        : "r"(ptr), "r"(count)
        : "rcx", "rsi", "al", "flags"
    End Assembly
    Return result
End Process

Process called "none_true" that takes ptr as Pointer, count as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rcx, %2\n"      Note: Load count into RCX
        "mov rsi, %1\n"      Note: Load pointer into RSI
        "1: test rcx, rcx\n" Note: Test if count is zero
        "jz 2f\n"            Note: Jump to success if done
        "lodsb\n"            Note: Load byte and increment RSI
        "test al, al\n"      Note: Test if byte is non-zero
        "jnz 3f\n"           Note: Jump to failure if true found
        "dec rcx\n"          Note: Decrement count
        "jmp 1b\n"           Note: Loop back
        "2: mov %0, 1\n"     Note: None were true
        "jmp 4f\n"           Note: Jump to end
        "3: xor %0, %0\n"    Note: Found a true value
        "4:\n"               Note: End label
        : "=r"(result)
        : "r"(ptr), "r"(count)
        : "rcx", "rsi", "al", "flags"
    End Assembly
    Return result
End Process

Process called "count_true" that takes ptr as Pointer, count as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "mov rcx, %2\n"      Note: Load count into RCX
        "mov rsi, %1\n"      Note: Load pointer into RSI
        "xor %0, %0\n"       Note: Clear result counter
        "1: test rcx, rcx\n" Note: Test if count is zero
        "jz 2f\n"            Note: Jump to end if done
        "lodsb\n"            Note: Load byte and increment RSI
        "movzx eax, al\n"    Note: Zero-extend byte to EAX
        "add %0, rax\n"      Note: Add to result counter
        "dec rcx\n"          Note: Decrement count
        "jmp 1b\n"           Note: Loop back
        "2:\n"               Note: End label
        : "=r"(result)
        : "r"(ptr), "r"(count)
        : "rcx", "rsi", "al", "eax", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: PREDICATE OPERATIONS
Note: =====================================================================

Process called "is_true" that takes a as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "movzx %0, %1\n"     Note: Zero-extend boolean to result
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "is_false" that takes a as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test if value is zero
        "setz %0\n"          Note: Set result if zero (false)
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "to_bool" that takes a as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test if value is non-zero
        "setnz %0\n"         Note: Set result if non-zero
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "from_bool" that takes a as Boolean returns Integer:
    Let result be 0
    Inline Assembly:
        "movzx %0, %1\n"     Note: Zero-extend boolean to integer
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: CONDITIONAL EXECUTION
Note: =====================================================================

Process called "when_true" that takes cond as Boolean, action as Pointer:
    Inline Assembly:
        "test %0, %0\n"      Note: Test condition
        "jz 1f\n"            Note: Jump if condition is false
        "call %1\n"          Note: Call action function
        "1:\n"               Note: End label
        :
        : "r"(cond), "r"(action)
        : "flags", "memory"
    End Assembly
End Process

Process called "when_false" that takes cond as Boolean, action as Pointer:
    Inline Assembly:
        "test %0, %0\n"      Note: Test condition
        "jnz 1f\n"           Note: Jump if condition is true
        "call %1\n"          Note: Call action function
        "1:\n"               Note: End label
        :
        : "r"(cond), "r"(action)
        : "flags", "memory"
    End Assembly
End Process

Process called "if_then_else" that takes cond as Boolean, true_action as Pointer, false_action as Pointer:
    Inline Assembly:
        "test %0, %0\n"      Note: Test condition
        "jz 1f\n"            Note: Jump to false action if condition is false
        "call %1\n"          Note: Call true action
        "jmp 2f\n"           Note: Jump to end
        "1: call %2\n"       Note: Call false action
        "2:\n"               Note: End label
        :
        : "r"(cond), "r"(true_action), "r"(false_action)
        : "flags", "memory"
    End Assembly
End Process

Note: =====================================================================
Note: LAZY EVALUATION OPERATIONS
Note: =====================================================================

Process called "lazy_and" that takes a as Boolean, b_thunk as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test first operand
        "jz 1f\n"            Note: Jump to false if first is false
        "call %2\n"          Note: Call thunk for second operand
        "movzx %0, al\n"     Note: Move result from AL
        "jmp 2f\n"           Note: Jump to end
        "1: xor %0, %0\n"    Note: Set result to false
        "2:\n"               Note: End label
        : "=r"(result)
        : "r"(a), "r"(b_thunk)
        : "al", "flags", "memory"
    End Assembly
    Return result
End Process

Process called "lazy_or" that takes a as Boolean, b_thunk as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test first operand
        "jnz 1f\n"           Note: Jump to true if first is true
        "call %2\n"          Note: Call thunk for second operand
        "movzx %0, al\n"     Note: Move result from AL
        "jmp 2f\n"           Note: Jump to end
        "1: mov %0, 1\n"     Note: Set result to true
        "2:\n"               Note: End label
        : "=r"(result)
        : "r"(a), "r"(b_thunk)
        : "al", "flags", "memory"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: BITWISE TO LOGICAL CONVERSIONS
Note: =====================================================================

Process called "bits_to_bool" that takes a as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test if integer is non-zero
        "setnz %0\n"         Note: Set result if non-zero
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_to_bits" that takes a as Boolean returns Integer:
    Let result be 0
    Inline Assembly:
        "movzx %0, %1\n"     Note: Zero-extend boolean to integer
        "neg %0\n"           Note: Negate to get all bits set if true
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_to_mask" that takes a as Boolean returns Integer:
    Let result be 0
    Inline Assembly:
        "movzx %0, %1\n"     Note: Zero-extend boolean to integer
        "neg %0\n"           Note: Negate to create bit mask
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ATOMIC LOGICAL OPERATIONS
Note: =====================================================================

Process called "atomic_test_and_set" that takes ptr as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov al, 1\n"        Note: Load 1 into AL
        "xchg [%1], al\n"    Note: Atomic exchange with memory location
        "movzx %0, al\n"     Note: Zero-extend previous value to result
        : "=r"(result)
        : "r"(ptr)
        : "al", "memory"
    End Assembly
    Return result
End Process

Process called "atomic_clear" that takes ptr as Pointer:
    Inline Assembly:
        "mov byte [%0], 0\n" Note: Atomically clear byte at memory location
        :
        : "r"(ptr)
        : "memory"
    End Assembly
End Process

Process called "atomic_flip" that takes ptr as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov al, [%1]\n"     Note: Load current value
        "xor al, 1\n"        Note: Flip the bit
        "xchg [%1], al\n"    Note: Atomic exchange with flipped value
        "movzx %0, al\n"     Note: Zero-extend previous value to result
        : "=r"(result)
        : "r"(ptr)
        : "al", "memory"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: CONTROL FLOW HELPERS
Note: =====================================================================

Process called "likely" that takes a as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, %1\n"         Note: Move input to result with likely hint
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "unlikely" that takes a as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, %1\n"         Note: Move input to result with unlikely hint
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "assume" that takes a as Boolean:
    Inline Assembly:
        "test %0, %0\n"        Note: Test condition
        "jnz 1f\n"             Note: Jump if condition is true
        "ud2\n"                Note: Undefined instruction if false
        "1:\n"                 Note: Continue execution label
        :
        : "r"(a)
        : "flags"
    End Assembly
End Process

Process called "unreachable_if_false" that takes a as Boolean:
    Inline Assembly:
        "test %0, %0\n"        Note: Test condition
        "jnz 1f\n"             Note: Jump if condition is true
        "ud2\n"                Note: Undefined instruction if condition is false
        "1:\n"                 Note: Continue execution label
        :
        : "r"(a)
        : "flags"
    End Assembly
End Process