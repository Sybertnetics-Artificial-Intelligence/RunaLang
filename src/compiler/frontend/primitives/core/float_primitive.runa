Note:
float_primitive.runa - Zero-Dependency Floating-Point Primitives

This module provides the foundational floating-point operations that map directly to FPU/SIMD instructions.
These primitives have ZERO dependencies and compile to 1-3 machine instructions maximum.

@Reasoning:
- All operations use inline assembly for true self-hosting
- No external dependencies - we generate the machine code directly
- No error checking or NaN/Inf validation - those are stdlib responsibilities
- Support for 32-bit (single) and 64-bit (double) precision
- Operations are IEEE 754 compliant through hardware

@Implementation:
- Inline Assembly statements define exact FPU/SIMD instructions
- Compiler replaces %[param] placeholders with register allocations
- Platform-specific optimizations handled by instruction selection (SSE, AVX, NEON)
- No software emulation - relies on hardware FPU

@Performance_Hints:
- Each operation maps to 1-3 FPU instructions
- No branching except for comparison operations
- Direct FPU register operations where possible
- SIMD instructions used when available
:End Note

Note: =====================================================================
Note: 64-BIT FLOATING-POINT OPERATIONS (IEEE 754 Double Precision)
Note: =====================================================================

Process called "add_f64" that takes a as Float64, b as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "movsd %0, %1\n"     Note: Move first operand to result
        "addsd %0, %2\n"     Note: Add second operand to result
        : "=x"(result)
        : "x"(a), "x"(b)
        :
    End Assembly
    Return result
End Process

Process called "sub_f64" that takes a as Float64, b as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "movsd %0, %1\n"     Note: Move first operand to result
        "subsd %0, %2\n"     Note: Subtract second operand from result
        : "=x"(result)
        : "x"(a), "x"(b)
        :
    End Assembly
    Return result
End Process

Process called "mul_f64" that takes a as Float64, b as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "movsd %0, %1\n"     Note: Move first operand to result
        "mulsd %0, %2\n"     Note: Multiply result by second operand
        : "=x"(result)
        : "x"(a), "x"(b)
        :
    End Assembly
    Return result
End Process

Process called "div_f64" that takes a as Float64, b as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "movsd %0, %1\n"     Note: Move first operand to result
        "divsd %0, %2\n"     Note: Divide result by second operand
        : "=x"(result)
        : "x"(a), "x"(b)
        :
    End Assembly
    Return result
End Process

Process called "neg_f64" that takes a as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "movsd %0, %1\n"     Note: Move operand to result
        "mov rax, 0x8000000000000000\n" Note: Load sign bit mask
        "movq xmm1, rax\n"   Note: Move mask to XMM register
        "xorpd %0, xmm1\n"   Note: XOR with sign mask to negate
        : "=x"(result)
        : "x"(a)
        : "rax", "xmm1"
    End Assembly
    Return result
End Process

Process called "abs_f64" that takes a as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "movsd %0, %1\n"     Note: Move operand to result
        "mov rax, 0x7FFFFFFFFFFFFFFF\n" Note: Load absolute value mask
        "movq xmm1, rax\n"   Note: Move mask to XMM register
        "andpd %0, xmm1\n"   Note: AND with mask to clear sign bit
        : "=x"(result)
        : "x"(a)
        : "rax", "xmm1"
    End Assembly
    Return result
End Process

Process called "sqrt_f64" that takes a as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "sqrtsd %0, %1\n"    Note: Calculate square root
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "min_f64" that takes a as Float64, b as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "movsd %0, %1\n"     Note: Move first operand to result
        "minsd %0, %2\n"     Note: Calculate minimum with second operand
        : "=x"(result)
        : "x"(a), "x"(b)
        :
    End Assembly
    Return result
End Process

Process called "max_f64" that takes a as Float64, b as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "movsd %0, %1\n"     Note: Move first operand to result
        "maxsd %0, %2\n"     Note: Calculate maximum with second operand
        : "=x"(result)
        : "x"(a), "x"(b)
        :
    End Assembly
    Return result
End Process

Process called "floor_f64" that takes a as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "roundsd %0, %1, 0x01\n" Note: Round down to negative infinity
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "ceil_f64" that takes a as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "roundsd %0, %1, 0x02\n" Note: Round up to positive infinity
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "round_f64" that takes a as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "roundsd %0, %1, 0x00\n" Note: Round to nearest even
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "trunc_f64" that takes a as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "roundsd %0, %1, 0x03\n" Note: Round toward zero (truncate)
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "fma_f64" that takes a as Float64, b as Float64, c as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "movsd %0, %1\n"     Note: Move a to result
        "vfmadd132sd %0, %3, %2\n" Note: result = a * b + c
        : "=x"(result)
        : "x"(a), "x"(b), "x"(c)
        :
    End Assembly
    Return result
End Process

Process called "copysign_f64" that takes mag as Float64, sign as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "movq rax, %1\n"     Note: Move magnitude to RAX
        "movq rcx, %2\n"     Note: Move sign value to RCX
        "mov rdx, 0x7FFFFFFFFFFFFFFF\n" Note: Load magnitude mask
        "and rax, rdx\n"     Note: Clear sign bit from magnitude
        "mov rdx, 0x8000000000000000\n" Note: Load sign mask
        "and rcx, rdx\n"     Note: Extract sign bit
        "or rax, rcx\n"      Note: Combine magnitude with sign
        "movq %0, rax\n"     Note: Move result to output
        : "=x"(result)
        : "x"(mag), "x"(sign)
        : "rax", "rcx", "rdx"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: 32-BIT FLOATING-POINT OPERATIONS (IEEE 754 Single Precision)
Note: =====================================================================

Process called "add_f32" that takes a as Float32, b as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "movss %0, %1\n"     Note: Move first operand to result
        "addss %0, %2\n"     Note: Add second operand to result
        : "=x"(result)
        : "x"(a), "x"(b)
        :
    End Assembly
    Return result
End Process

Process called "sub_f32" that takes a as Float32, b as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "movss %0, %1\n"     Note: Move first operand to result
        "subss %0, %2\n"     Note: Subtract second operand from result
        : "=x"(result)
        : "x"(a), "x"(b)
        :
    End Assembly
    Return result
End Process

Process called "mul_f32" that takes a as Float32, b as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "movss %0, %1\n"     Note: Move first operand to result
        "mulss %0, %2\n"     Note: Multiply result by second operand
        : "=x"(result)
        : "x"(a), "x"(b)
        :
    End Assembly
    Return result
End Process

Process called "div_f32" that takes a as Float32, b as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "movss %0, %1\n"     Note: Move first operand to result
        "divss %0, %2\n"     Note: Divide result by second operand
        : "=x"(result)
        : "x"(a), "x"(b)
        :
    End Assembly
    Return result
End Process

Process called "neg_f32" that takes a as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "movss %0, %1\n"     Note: Move operand to result
        "mov eax, 0x80000000\n" Note: Load sign bit mask
        "movd xmm1, eax\n"   Note: Move mask to XMM register
        "xorps %0, xmm1\n"   Note: XOR with sign mask to negate
        : "=x"(result)
        : "x"(a)
        : "eax", "xmm1"
    End Assembly
    Return result
End Process

Process called "abs_f32" that takes a as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "movss %0, %1\n"     Note: Move operand to result
        "mov eax, 0x7FFFFFFF\n" Note: Load absolute value mask
        "movd xmm1, eax\n"   Note: Move mask to XMM register
        "andps %0, xmm1\n"   Note: AND with mask to clear sign bit
        : "=x"(result)
        : "x"(a)
        : "eax", "xmm1"
    End Assembly
    Return result
End Process

Process called "sqrt_f32" that takes a as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "sqrtss %0, %1\n"    Note: Calculate square root
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "min_f32" that takes a as Float32, b as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "movss %0, %1\n"     Note: Move first operand to result
        "minss %0, %2\n"     Note: Calculate minimum with second operand
        : "=x"(result)
        : "x"(a), "x"(b)
        :
    End Assembly
    Return result
End Process

Process called "max_f32" that takes a as Float32, b as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "movss %0, %1\n"     Note: Move first operand to result
        "maxss %0, %2\n"     Note: Calculate maximum with second operand
        : "=x"(result)
        : "x"(a), "x"(b)
        :
    End Assembly
    Return result
End Process

Process called "floor_f32" that takes a as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "roundss %0, %1, 0x01\n" Note: Round down to negative infinity
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "ceil_f32" that takes a as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "roundss %0, %1, 0x02\n" Note: Round up to positive infinity
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "round_f32" that takes a as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "roundss %0, %1, 0x00\n" Note: Round to nearest even
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "trunc_f32" that takes a as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "roundss %0, %1, 0x03\n" Note: Round toward zero (truncate)
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "fma_f32" that takes a as Float32, b as Float32, c as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "movss %0, %1\n"     Note: Move a to result
        "vfmadd132ss %0, %3, %2\n" Note: result = a * b + c
        : "=x"(result)
        : "x"(a), "x"(b), "x"(c)
        :
    End Assembly
    Return result
End Process

Process called "copysign_f32" that takes mag as Float32, sign as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "movd eax, %1\n"     Note: Move magnitude to EAX
        "movd ecx, %2\n"     Note: Move sign value to ECX
        "and eax, 0x7FFFFFFF\n" Note: Clear sign bit from magnitude
        "and ecx, 0x80000000\n" Note: Extract sign bit
        "or eax, ecx\n"      Note: Combine magnitude with sign
        "movd %0, eax\n"     Note: Move result to output
        : "=x"(result)
        : "x"(mag), "x"(sign)
        : "eax", "ecx"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: FLOATING-POINT COMPARISON OPERATIONS
Note: =====================================================================

Process called "eq_f64" that takes a as Float64, b as Float64 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "sete %0\n"          Note: Set result if equal
        "setnp cl\n"         Note: Set CL if not parity (not NaN)
        "and %0, cl\n"       Note: AND with parity check
        : "=r"(result)
        : "x"(a), "x"(b)
        : "cl", "flags"
    End Assembly
    Return result
End Process

Process called "ne_f64" that takes a as Float64, b as Float64 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "setne %0\n"         Note: Set result if not equal
        "setp cl\n"          Note: Set CL if parity (NaN)
        "or %0, cl\n"        Note: OR with parity check
        : "=r"(result)
        : "x"(a), "x"(b)
        : "cl", "flags"
    End Assembly
    Return result
End Process

Process called "lt_f64" that takes a as Float64, b as Float64 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "setb %0\n"          Note: Set result if below (less than)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "le_f64" that takes a as Float64, b as Float64 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "setbe %0\n"         Note: Set result if below or equal (less than or equal)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "gt_f64" that takes a as Float64, b as Float64 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "seta %0\n"          Note: Set result if above (greater than)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ge_f64" that takes a as Float64, b as Float64 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "setae %0\n"         Note: Set result if above or equal (greater than or equal)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "eq_f32" that takes a as Float32, b as Float32 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomiss %1, %2\n"   Note: Unordered compare scalar single precision
        "sete %0\n"          Note: Set result if equal
        "setnp cl\n"         Note: Set CL if not parity (not NaN)
        "and %0, cl\n"       Note: AND with parity check
        : "=r"(result)
        : "x"(a), "x"(b)
        : "cl", "flags"
    End Assembly
    Return result
End Process

Process called "ne_f32" that takes a as Float32, b as Float32 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomiss %1, %2\n"   Note: Unordered compare scalar single precision
        "setne %0\n"         Note: Set result if not equal
        "setp cl\n"          Note: Set CL if parity (NaN)
        "or %0, cl\n"        Note: OR with parity check
        : "=r"(result)
        : "x"(a), "x"(b)
        : "cl", "flags"
    End Assembly
    Return result
End Process

Process called "lt_f32" that takes a as Float32, b as Float32 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomiss %1, %2\n"   Note: Unordered compare scalar single precision
        "setb %0\n"          Note: Set result if below (less than)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "le_f32" that takes a as Float32, b as Float32 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomiss %1, %2\n"   Note: Unordered compare scalar single precision
        "setbe %0\n"         Note: Set result if below or equal (less than or equal)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "gt_f32" that takes a as Float32, b as Float32 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomiss %1, %2\n"   Note: Unordered compare scalar single precision
        "seta %0\n"          Note: Set result if above (greater than)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ge_f32" that takes a as Float32, b as Float32 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomiss %1, %2\n"   Note: Unordered compare scalar single precision
        "setae %0\n"         Note: Set result if above or equal (greater than or equal)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: CONVERSION OPERATIONS
Note: =====================================================================

Process called "f32_to_f64" that takes a as Float32 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "cvtss2sd %0, %1\n"  Note: Convert single precision to double precision
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "f64_to_f32" that takes a as Float64 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "cvtsd2ss %0, %1\n"  Note: Convert double precision to single precision
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "f32_to_i32" that takes a as Float32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "cvttss2si %0, %1\n" Note: Convert single precision to 32-bit integer (truncate)
        : "=r"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "f32_to_i64" that takes a as Float32 returns Integer64:
    Let result be 0
    Inline Assembly:
        "cvttss2si %0, %1\n" Note: Convert single precision to 64-bit integer (truncate)
        : "=r"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "f64_to_i32" that takes a as Float64 returns Integer32:
    Let result be 0
    Inline Assembly:
        "cvttsd2si %0, %1\n" Note: Convert double precision to 32-bit integer (truncate)
        : "=r"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "f64_to_i64" that takes a as Float64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "cvttsd2si %0, %1\n" Note: Convert double precision to 64-bit integer (truncate)
        : "=r"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "i32_to_f32" that takes a as Integer32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "cvtsi2ss %0, %1\n"  Note: Convert 32-bit integer to single precision
        : "=x"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "i64_to_f32" that takes a as Integer64 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "cvtsi2ss %0, %1\n"  Note: Convert 64-bit integer to single precision
        : "=x"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "i32_to_f64" that takes a as Integer32 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "cvtsi2sd %0, %1\n"  Note: Convert 32-bit integer to double precision
        : "=x"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "i64_to_f64" that takes a as Integer64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "cvtsi2sd %0, %1\n"  Note: Convert 64-bit integer to double precision
        : "=x"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: BIT MANIPULATION FOR FLOATS
Note: =====================================================================

Process called "f32_to_bits" that takes a as Float32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "movd %0, %1\n"      Note: Move float bits to integer register
        : "=r"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "bits_to_f32" that takes a as Integer32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "movd %0, %1\n"      Note: Move integer bits to float register
        : "=x"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "f64_to_bits" that takes a as Float64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "movq %0, %1\n"      Note: Move double bits to integer register
        : "=r"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "bits_to_f64" that takes a as Integer64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "movq %0, %1\n"      Note: Move integer bits to double register
        : "=x"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: SPECIAL VALUE CHECKS
Note: =====================================================================

Process called "is_nan_f64" that takes a as Float64 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %1\n"   Note: Compare value with itself
        "setp %0\n"          Note: Set result if parity flag (NaN)
        : "=r"(result)
        : "x"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "is_nan_f32" that takes a as Float32 returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomiss %1, %1\n"   Note: Compare value with itself
        "setp %0\n"          Note: Set result if parity flag (NaN)
        : "=r"(result)
        : "x"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "is_inf_f64" that takes a as Float64 returns Boolean:
    Let result be false
    Inline Assembly:
        "movq rax, %1\n"     Note: Move double to RAX
        "shl rax, 1\n"       Note: Shift left to remove sign bit
        "mov rcx, 0xFFE0000000000000\n" Note: Load infinity pattern
        "cmp rax, rcx\n"     Note: Compare with infinity
        "sete %0\n"          Note: Set result if equal
        : "=r"(result)
        : "x"(a)
        : "rax", "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "is_inf_f32" that takes a as Float32 returns Boolean:
    Let result be false
    Inline Assembly:
        "movd eax, %1\n"     Note: Move float to EAX
        "shl eax, 1\n"       Note: Shift left to remove sign bit
        "cmp eax, 0xFF000000\n" Note: Compare with infinity pattern
        "sete %0\n"          Note: Set result if equal
        : "=r"(result)
        : "x"(a)
        : "eax", "flags"
    End Assembly
    Return result
End Process

Process called "is_finite_f64" that takes a as Float64 returns Boolean:
    Let result be false
    Inline Assembly:
        "movq rax, %1\n"     Note: Move double to RAX
        "shl rax, 1\n"       Note: Shift left to remove sign bit
        "mov rcx, 0xFFE0000000000000\n" Note: Load infinity pattern
        "cmp rax, rcx\n"     Note: Compare with infinity
        "setb %0\n"          Note: Set result if below (finite)
        : "=r"(result)
        : "x"(a)
        : "rax", "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "is_finite_f32" that takes a as Float32 returns Boolean:
    Let result be false
    Inline Assembly:
        "movd eax, %1\n"     Note: Move float to EAX
        "shl eax, 1\n"       Note: Shift left to remove sign bit
        "cmp eax, 0xFF000000\n" Note: Compare with infinity pattern
        "setb %0\n"          Note: Set result if below (finite)
        : "=r"(result)
        : "x"(a)
        : "eax", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: SPECIAL VALUES AND CONSTANTS
Note: =====================================================================

Process called "f32_nan" returns Float32:
    Let result be 0.0
    Inline Assembly:
        "mov eax, 0x7FC00000\n" Note: Load NaN bit pattern
        "movd %0, eax\n"     Note: Move to float register
        : "=x"(result)
        :
        : "eax"
    End Assembly
    Return result
End Process

Process called "f32_inf" returns Float32:
    Let result be 0.0
    Inline Assembly:
        "mov eax, 0x7F800000\n" Note: Load positive infinity bit pattern
        "movd %0, eax\n"     Note: Move to float register
        : "=x"(result)
        :
        : "eax"
    End Assembly
    Return result
End Process

Process called "f32_neg_inf" returns Float32:
    Let result be 0.0
    Inline Assembly:
        "mov eax, 0xFF800000\n" Note: Load negative infinity bit pattern
        "movd %0, eax\n"     Note: Move to float register
        : "=x"(result)
        :
        : "eax"
    End Assembly
    Return result
End Process

Process called "f32_epsilon" returns Float32:
    Let result be 0.0
    Inline Assembly:
        "mov eax, 0x34000000\n" Note: Load epsilon bit pattern
        "movd %0, eax\n"     Note: Move to float register
        : "=x"(result)
        :
        : "eax"
    End Assembly
    Return result
End Process

Process called "f64_nan" returns Float64:
    Let result be 0.0
    Inline Assembly:
        "mov rax, 0x7FF8000000000000\n" Note: Load NaN bit pattern
        "movq %0, rax\n"     Note: Move to double register
        : "=x"(result)
        :
        : "rax"
    End Assembly
    Return result
End Process

Process called "f64_inf" returns Float64:
    Let result be 0.0
    Inline Assembly:
        "mov rax, 0x7FF0000000000000\n" Note: Load positive infinity bit pattern
        "movq %0, rax\n"     Note: Move to double register
        : "=x"(result)
        :
        : "rax"
    End Assembly
    Return result
End Process

Process called "f64_neg_inf" returns Float64:
    Let result be 0.0
    Inline Assembly:
        "mov rax, 0xFFF0000000000000\n" Note: Load negative infinity bit pattern
        "movq %0, rax\n"     Note: Move to double register
        : "=x"(result)
        :
        : "rax"
    End Assembly
    Return result
End Process

Process called "f64_epsilon" returns Float64:
    Let result be 0.0
    Inline Assembly:
        "mov rax, 0x3CB0000000000000\n" Note: Load epsilon bit pattern
        "movq %0, rax\n"     Note: Move to double register
        : "=x"(result)
        :
        : "rax"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ADVANCED FLOATING-POINT OPERATIONS
Note: =====================================================================

Process called "reciprocal_f32" that takes a as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "rcpss %0, %1\n"     Note: Approximate reciprocal of single precision
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "reciprocal_f64" that takes a as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "mov rax, 0x3FF0000000000000\n" Note: Load 1.0 constant
        "movq xmm1, rax\n"   Note: Move to XMM register
        "divsd xmm1, %1\n"   Note: Divide 1.0 by input
        "movsd %0, xmm1\n"   Note: Move result to output
        : "=x"(result)
        : "x"(a)
        : "rax", "xmm1"
    End Assembly
    Return result
End Process

Process called "rsqrt_f32" that takes a as Float32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "rsqrtss %0, %1\n"   Note: Approximate reciprocal square root
        : "=x"(result)
        : "x"(a)
        :
    End Assembly
    Return result
End Process

Process called "rsqrt_f64" that takes a as Float64 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "sqrtsd xmm0, %1\n"  Note: Calculate square root
        "mov rax, 0x3FF0000000000000\n" Note: Load 1.0 constant
        "movq xmm1, rax\n"   Note: Move to XMM register
        "divsd xmm1, xmm0\n" Note: Divide 1.0 by square root
        "movsd %0, xmm1\n"   Note: Move result to output
        : "=x"(result)
        : "x"(a)
        : "rax", "xmm0", "xmm1"
    End Assembly
    Return result
End Process

Process called "scalbn_f32" that takes x as Float32, n as Integer32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "cvtsi2ss xmm1, %2\n" Note: Convert n to float
        "mov eax, 0x3F800000\n" Note: Load 1.0 constant
        "movd xmm2, eax\n"   Note: Move to XMM register
        "addss xmm1, xmm2\n" Note: Add 1.0 to n
        "movss %0, %1\n"     Note: Move x to result
        "mulss %0, xmm1\n"   Note: Multiply by scaled exponent
        : "=x"(result)
        : "x"(x), "r"(n)
        : "eax", "xmm1", "xmm2"
    End Assembly
    Return result
End Process

Process called "scalbn_f64" that takes x as Float64, n as Integer32 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "cvtsi2sd xmm1, %2\n" Note: Convert n to double
        "mov rax, 0x3FF0000000000000\n" Note: Load 1.0 constant
        "movq xmm2, rax\n"   Note: Move to XMM register
        "addsd xmm1, xmm2\n" Note: Add 1.0 to n
        "movsd %0, %1\n"     Note: Move x to result
        "mulsd %0, xmm1\n"   Note: Multiply by scaled exponent
        : "=x"(result)
        : "x"(x), "r"(n)
        : "rax", "xmm1", "xmm2"
    End Assembly
    Return result
End Process

Process called "ldexp_f32" that takes x as Float32, exp as Integer32 returns Float32:
    Let result be 0.0
    Inline Assembly:
        "cvtsi2ss xmm1, %2\n" Note: Convert exp to float
        "mov eax, 0x3F800000\n" Note: Load 1.0 constant
        "movd xmm2, eax\n"   Note: Move to XMM register
        "addss xmm1, xmm2\n" Note: Add 1.0 to exp
        "movss %0, %1\n"     Note: Move x to result
        "mulss %0, xmm1\n"   Note: Multiply by scaled exponent
        : "=x"(result)
        : "x"(x), "r"(exp)
        : "eax", "xmm1", "xmm2"
    End Assembly
    Return result
End Process

Process called "ldexp_f64" that takes x as Float64, exp as Integer32 returns Float64:
    Let result be 0.0
    Inline Assembly:
        "cvtsi2sd xmm1, %2\n" Note: Convert exp to double
        "mov rax, 0x3FF0000000000000\n" Note: Load 1.0 constant
        "movq xmm2, rax\n"   Note: Move to XMM register
        "addsd xmm1, xmm2\n" Note: Add 1.0 to exp
        "movsd %0, %1\n"     Note: Move x to result
        "mulsd %0, xmm1\n"   Note: Multiply by scaled exponent
        : "=x"(result)
        : "x"(x), "r"(exp)
        : "rax", "xmm1", "xmm2"
    End Assembly
    Return result
End Process

Process called "frexp_f32" that takes x as Float32, exp_out as Pointer returns Float32:
    Let result be 0.0
    Inline Assembly:
        "movd eax, %1\n"     Note: Move float to EAX
        "mov ecx, eax\n"     Note: Copy to ECX
        "shr ecx, 23\n"      Note: Shift to get exponent
        "and ecx, 0xFF\n"    Note: Mask exponent bits
        "sub ecx, 126\n"     Note: Subtract bias - 1
        "mov [%2], ecx\n"    Note: Store exponent to output pointer
        "and eax, 0x807FFFFF\n" Note: Clear exponent, keep sign and mantissa
        "or eax, 0x3F000000\n" Note: Set exponent to 0.5 range
        "movd %0, eax\n"     Note: Move result to output
        : "=x"(result)
        : "x"(x), "r"(exp_out)
        : "eax", "ecx", "memory"
    End Assembly
    Return result
End Process

Process called "frexp_f64" that takes x as Float64, exp_out as Pointer returns Float64:
    Let result be 0.0
    Inline Assembly:
        "movq rax, %1\n"     Note: Move double to RAX
        "mov rcx, rax\n"     Note: Copy to RCX
        "shr rcx, 52\n"      Note: Shift to get exponent
        "and rcx, 0x7FF\n"   Note: Mask exponent bits
        "sub rcx, 1022\n"    Note: Subtract bias - 1
        "mov [%2], rcx\n"    Note: Store exponent to output pointer
        "mov rdx, 0x800FFFFFFFFFFFFF\n" Note: Load mantissa and sign mask
        "and rax, rdx\n"     Note: Clear exponent, keep sign and mantissa
        "mov rdx, 0x3FE0000000000000\n" Note: Load 0.5 range exponent
        "or rax, rdx\n"      Note: Set exponent to 0.5 range
        "movq %0, rax\n"     Note: Move result to output
        : "=x"(result)
        : "x"(x), "r"(exp_out)
        : "rax", "rcx", "rdx", "memory"
    End Assembly
    Return result
End Process