Note:
alignment_core.runa - Zero-Dependency Alignment Calculation Primitives

This module provides memory alignment calculations and operations.
These primitives have ZERO dependencies and compile to efficient bit manipulation instructions.

@Reasoning:
- Essential for proper memory layout and performance
- All operations use inline assembly for true self-hosting
- No external dependencies - we generate the machine code directly
- Critical for cache line optimization and SIMD operations

@Implementation:
- Inline Assembly with bit manipulation for alignment
- Power-of-2 alignment calculations
- Efficient rounding operations
- Zero-cost abstraction over alignment math

@Performance_Hints:
- Single instruction alignment operations
- Bit manipulation instead of division
- Branch-free implementations
- Cache-friendly memory access patterns
:End Note

Note: =====================================================================
Note: BASIC ALIGNMENT OPERATIONS
Note: =====================================================================

Process called "align_up" that takes value as Integer64, alignment as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + %2 - 1]\n"    Note: Calculate value + alignment - 1
        "neg %2\n"                   Note: Negate alignment for mask
        "and %0, %2\n"               Note: Apply alignment mask
        : "=r"(result)
        : "r"(value), "r"(alignment)
        : "flags"
    End Assembly
    Return result
End Process

Process called "align_down" that takes value as Integer64, alignment as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "neg %2\n"            Note: Negate alignment for mask
        "and %0, %2\n"        Note: Apply alignment mask
        : "=r"(result)
        : "r"(value), "r"(alignment)
        : "flags"
    End Assembly
    Return result
End Process

Process called "align_offset" that takes value as Integer64, alignment as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "neg %2\n"            Note: Negate alignment for mask
        "and %0, %2\n"        Note: Apply alignment mask
        "sub %0, %1\n"        Note: Subtract original value
        "neg %0\n"            Note: Negate to get offset
        : "=r"(result)
        : "r"(value), "r"(alignment)
        : "flags"
    End Assembly
    Return result
End Process

Process called "is_aligned" that takes value as Integer64, alignment as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, %1\n"       Note: Move value to RAX
        "dec %2\n"            Note: Decrement alignment (make mask)
        "test rax, %2\n"      Note: Test value against alignment mask
        "setz %0\n"           Note: Set result if zero (aligned)
        : "=r"(result)
        : "r"(value), "r"(alignment)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "alignment_padding" that takes value as Integer64, alignment as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %2, %0\n"        Note: Move alignment to result register
        "dec %0\n"            Note: Decrement alignment
        "add %0, %1\n"        Note: Add value
        "neg %2\n"            Note: Negate alignment for mask
        "and %0, %2\n"        Note: Apply alignment mask
        "sub %0, %1\n"        Note: Subtract original value to get padding
        : "=r"(result)
        : "r"(value), "r"(alignment)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: POINTER ALIGNMENT
Note: =====================================================================

Process called "align_ptr_up" that takes ptr as Pointer, alignment as Integer64 returns Pointer:
    Let result be null
    Inline Assembly:
        "lea %0, [%1 + %2 - 1]\n"    Note: Calculate ptr + alignment - 1
        "neg %2\n"                   Note: Negate alignment for mask
        "and %0, %2\n"               Note: Apply alignment mask
        : "=r"(result)
        : "r"(ptr), "r"(alignment)
        : "flags"
    End Assembly
    Return result
End Process

Process called "align_ptr_down" that takes ptr as Pointer, alignment as Integer64 returns Pointer:
    Let result be null
    Inline Assembly:
        "mov %1, %0\n"        Note: Move pointer to result register
        "neg %2\n"            Note: Negate alignment for mask
        "and %0, %2\n"        Note: Apply alignment mask
        : "=r"(result)
        : "r"(ptr), "r"(alignment)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ptr_alignment_offset" that takes ptr as Pointer, alignment as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move pointer to result register
        "dec %2\n"            Note: Decrement alignment to make mask
        "and %0, %2\n"        Note: Apply offset mask
        : "=r"(result)
        : "r"(ptr), "r"(alignment)
        : "flags"
    End Assembly
    Return result
End Process

Process called "is_ptr_aligned" that takes ptr as Pointer, alignment as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, %1\n"       Note: Move pointer to RAX
        "dec %2\n"            Note: Decrement alignment (make mask)
        "test rax, %2\n"      Note: Test pointer against alignment mask
        "setz %0\n"           Note: Set result if zero (aligned)
        : "=r"(result)
        : "r"(ptr), "r"(alignment)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: COMMON ALIGNMENTS
Note: =====================================================================

Process called "align_to_byte" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result (byte alignment is no-op)
        : "=r"(result)
        : "r"(value)
        :
    End Assembly
    Return result
End Process

Process called "align_to_word" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + 1]\n"   Note: Add 1 to value
        "and %0, -2\n"        Note: Align to 2-byte boundary
        : "=r"(result)
        : "r"(value)
        : "flags"
    End Assembly
    Return result
End Process

Process called "align_to_dword" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + 3]\n"   Note: Add 3 to value
        "and %0, -4\n"        Note: Align to 4-byte boundary
        : "=r"(result)
        : "r"(value)
        : "flags"
    End Assembly
    Return result
End Process

Process called "align_to_qword" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + 7]\n"   Note: Add 7 to value
        "and %0, -8\n"        Note: Align to 8-byte boundary
        : "=r"(result)
        : "r"(value)
        : "flags"
    End Assembly
    Return result
End Process

Process called "align_to_paragraph" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + 15]\n"  Note: Add 15 to value
        "and %0, -16\n"       Note: Align to 16-byte boundary
        : "=r"(result)
        : "r"(value)
        : "flags"
    End Assembly
    Return result
End Process

Process called "align_to_cache_line" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + 63]\n"  Note: Add 63 to value
        "and %0, -64\n"       Note: Align to 64-byte cache line boundary
        : "=r"(result)
        : "r"(value)
        : "flags"
    End Assembly
    Return result
End Process

Process called "align_to_page" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + 4095]\n" Note: Add 4095 to value
        "and %0, -4096\n"      Note: Align to 4096-byte page boundary
        : "=r"(result)
        : "r"(value)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ALIGNMENT CHECKS
Note: =====================================================================

Process called "is_power_of_two" that takes value as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rcx, %1\n"       Note: Move value to RCX
        "lea rax, [rcx - 1]\n" Note: Calculate value - 1
        "test rax, rcx\n"     Note: Test (value-1) & value
        "setz %0\n"           Note: Set if zero (power of 2 property)
        "test rcx, rcx\n"     Note: Test if value is zero
        "setnz cl\n"          Note: Set CL if not zero
        "and %0, cl\n"        Note: AND with non-zero check
        : "=r"(result)
        : "r"(value)
        : "rax", "rcx", "cl", "flags"
    End Assembly
    Return result
End Process

Process called "next_power_of_two" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "bsr rcx, %1\n"       Note: Find highest set bit
        "jz 1f\n"             Note: Jump if value is zero
        "mov %0, 2\n"         Note: Start with base value 2
        "shl %0, cl\n"        Note: Shift to get 2^(bit+1)
        "cmp %0, %1\n"        Note: Compare with input
        "ja 2f\n"             Note: Jump if already greater
        "shl %0, 1\n"         Note: Double if equal
        "jmp 2f\n"            Note: Jump to end
        "1: mov %0, 1\n"      Note: Return 1 if input was 0
        "2:\n"                Note: End label
        : "=r"(result)
        : "r"(value)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "prev_power_of_two" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "bsr rcx, %1\n"       Note: Find highest set bit
        "jz 1f\n"             Note: Jump if value is zero
        "mov %0, 1\n"         Note: Start with base value 1
        "shl %0, cl\n"        Note: Shift to get 2^bit
        "jmp 2f\n"            Note: Jump to end
        "1: xor %0, %0\n"     Note: Return 0 if input was 0
        "2:\n"                Note: End label
        : "=r"(result)
        : "r"(value)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "log2_floor" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "bsr %0, %1\n"        Note: Find highest set bit (log2)
        "jnz 1f\n"            Note: Jump if not zero
        "mov %0, -1\n"        Note: Return -1 if value was 0
        "1:\n"                Note: End label
        : "=r"(result)
        : "r"(value)
        : "flags"
    End Assembly
    Return result
End Process

Process called "log2_ceil" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "dec %1\n"            Note: Decrement value
        "bsr %0, %1\n"        Note: Find highest set bit (log2)
        "inc %0\n"            Note: Increment for ceiling
        : "=r"(result)
        : "r"(value)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: SIZE ALIGNMENT
Note: =====================================================================

Process called "align_size" that takes size as Integer64, alignment as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + %2 - 1]\n"    Note: Calculate size + alignment - 1
        "neg %2\n"                   Note: Negate alignment for mask
        "and %0, %2\n"               Note: Apply alignment mask
        : "=r"(result)
        : "r"(size), "r"(alignment)
        : "flags"
    End Assembly
    Return result
End Process

Process called "round_up_to_multiple" that takes value as Integer64, multiple as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov rax, %1\n"       Note: Move value to RAX
        "add rax, %2\n"       Note: Add multiple
        "dec rax\n"           Note: Subtract 1
        "xor rdx, rdx\n"      Note: Clear RDX
        "div %2\n"            Note: Divide by multiple
        "mul %2\n"            Note: Multiply back
        "mov %0, rax\n"       Note: Move result
        : "=r"(result)
        : "r"(value), "r"(multiple)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "round_down_to_multiple" that takes value as Integer64, multiple as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov rax, %1\n"       Note: Move value to RAX
        "xor rdx, rdx\n"      Note: Clear RDX
        "div %2\n"            Note: Divide by multiple
        "mul %2\n"            Note: Multiply back
        "mov %0, rax\n"       Note: Move result
        : "=r"(result)
        : "r"(value), "r"(multiple)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "is_multiple_of" that takes value as Integer64, multiple as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, %1\n"       Note: Move value to RAX
        "xor rdx, rdx\n"      Note: Clear RDX
        "div %2\n"            Note: Divide by multiple
        "test rdx, rdx\n"     Note: Test remainder
        "setz %0\n"           Note: Set if zero (is multiple)
        : "=r"(result)
        : "r"(value), "r"(multiple)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: STRUCTURE ALIGNMENT
Note: =====================================================================

Process called "struct_alignment" that takes field_alignments as Pointer, count as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "xor %0, %0\n"        Note: Clear result register
        "mov rcx, %2\n"       Note: Load count
        "mov rsi, %1\n"       Note: Load field alignments pointer
        "1: test rcx, rcx\n"  Note: Test if count is zero
        "jz 2f\n"             Note: Jump if done
        "lodsq\n"             Note: Load next alignment
        "cmp rax, %0\n"       Note: Compare with current max
        "cmova %0, rax\n"     Note: Update max if greater
        "dec rcx\n"           Note: Decrement count
        "jmp 1b\n"            Note: Loop back
        "2:\n"                Note: End label
        : "=r"(result)
        : "r"(field_alignments), "r"(count)
        : "rax", "rcx", "rsi", "flags"
    End Assembly
    Return result
End Process

Process called "struct_size" that takes last_offset as Integer64, last_size as Integer64, alignment as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + %2]\n"  Note: Calculate last_offset + last_size
        "add %0, %3\n"        Note: Add alignment
        "dec %0\n"            Note: Subtract 1
        "neg %3\n"            Note: Negate alignment for mask
        "and %0, %3\n"        Note: Apply alignment mask
        : "=r"(result)
        : "r"(last_offset), "r"(last_size), "r"(alignment)
        : "flags"
    End Assembly
    Return result
End Process

Process called "field_offset" that takes current_offset as Integer64, field_alignment as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + %2 - 1]\n"    Note: Calculate current_offset + field_alignment - 1
        "neg %2\n"                   Note: Negate field_alignment for mask
        "and %0, %2\n"               Note: Apply alignment mask
        : "=r"(result)
        : "r"(current_offset), "r"(field_alignment)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: SIMD ALIGNMENT
Note: =====================================================================

Process called "align_for_sse" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + 15]\n"  Note: Add 15 to value
        "and %0, -16\n"       Note: Align to 16-byte SSE boundary
        : "=r"(result)
        : "r"(value)
        : "flags"
    End Assembly
    Return result
End Process

Process called "align_for_avx" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + 31]\n"  Note: Add 31 to value
        "and %0, -32\n"       Note: Align to 32-byte AVX boundary
        : "=r"(result)
        : "r"(value)
        : "flags"
    End Assembly
    Return result
End Process

Process called "align_for_avx512" that takes value as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + 63]\n"  Note: Add 63 to value
        "and %0, -64\n"       Note: Align to 64-byte AVX512 boundary
        : "=r"(result)
        : "r"(value)
        : "flags"
    End Assembly
    Return result
End Process

Process called "is_sse_aligned" that takes ptr as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, 15\n"       Note: Test pointer against 16-byte mask
        "setz %0\n"           Note: Set result if zero (SSE aligned)
        : "=r"(result)
        : "r"(ptr)
        : "flags"
    End Assembly
    Return result
End Process

Process called "is_avx_aligned" that takes ptr as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, 31\n"       Note: Test pointer against 32-byte mask
        "setz %0\n"           Note: Set result if zero (AVX aligned)
        : "=r"(result)
        : "r"(ptr)
        : "flags"
    End Assembly
    Return result
End Process

Process called "is_avx512_aligned" that takes ptr as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, 63\n"       Note: Test pointer against 64-byte mask
        "setz %0\n"           Note: Set result if zero (AVX512 aligned)
        : "=r"(result)
        : "r"(ptr)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: MEMORY LAYOUT HELPERS
Note: =====================================================================

Process called "cache_line_offset" that takes addr as Pointer returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move address to result register
        "and %0, 63\n"        Note: Get offset within cache line
        : "=r"(result)
        : "r"(addr)
        : "flags"
    End Assembly
    Return result
End Process

Process called "page_offset" that takes addr as Pointer returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move address to result register
        "and %0, 4095\n"      Note: Get offset within page
        : "=r"(result)
        : "r"(addr)
        : "flags"
    End Assembly
    Return result
End Process

Process called "cache_lines_needed" that takes size as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + 63]\n"  Note: Add 63 to size
        "shr %0, 6\n"         Note: Divide by 64 (cache line size)
        : "=r"(result)
        : "r"(size)
        : "flags"
    End Assembly
    Return result
End Process

Process called "pages_needed" that takes size as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + 4095]\n" Note: Add 4095 to size
        "shr %0, 12\n"        Note: Divide by 4096 (page size)
        : "=r"(result)
        : "r"(size)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ALIGNMENT ARITHMETIC
Note: =====================================================================

Process called "gcd_alignment" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "1: test %2, %2\n"    Note: Test if b is zero
        "jz 2f\n"             Note: Jump if b is zero
        "mov rax, %1\n"       Note: Move a to RAX
        "xor rdx, rdx\n"      Note: Clear RDX
        "div %2\n"            Note: Divide a by b
        "mov %1, %2\n"        Note: a = b
        "mov %2, rdx\n"       Note: b = remainder
        "jmp 1b\n"            Note: Loop back
        "2: mov %0, %1\n"     Note: Move final a to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "lcm_alignment" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov r8, %1\n"        Note: Copy a to R8
        "mov r9, %2\n"        Note: Copy b to R9
        "1: test r9, r9\n"    Note: Test if R9 is zero
        "jz 2f\n"             Note: Jump if R9 is zero
        "mov rax, r8\n"       Note: Move R8 to RAX
        "xor rdx, rdx\n"      Note: Clear RDX
        "div r9\n"            Note: Divide R8 by R9
        "mov r8, r9\n"        Note: R8 = R9
        "mov r9, rdx\n"       Note: R9 = remainder
        "jmp 1b\n"            Note: Loop back
        "2: mov rax, %1\n"    Note: Move original a to RAX
        "mul %2\n"            Note: Multiply a * b
        "div r8\n"            Note: Divide by GCD
        "mov %0, rax\n"       Note: Move result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "r8", "r9", "flags"
    End Assembly
    Return result
End Process

Process called "combine_alignments" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move a to result register
        "cmp %0, %2\n"        Note: Compare result with b
        "cmovb %0, %2\n"      Note: Move b if a is less than b
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ALIGNMENT MASKS
Note: =====================================================================

Process called "make_alignment_mask" that takes alignment as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move alignment to result register
        "neg %0\n"            Note: Negate to create alignment mask
        : "=r"(result)
        : "r"(alignment)
        : "flags"
    End Assembly
    Return result
End Process

Process called "make_offset_mask" that takes alignment as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move alignment to result register
        "dec %0\n"            Note: Decrement to create offset mask
        : "=r"(result)
        : "r"(alignment)
        : "flags"
    End Assembly
    Return result
End Process

Process called "apply_alignment_mask" that takes value as Integer64, mask as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "and %0, %2\n"        Note: Apply alignment mask
        : "=r"(result)
        : "r"(value), "r"(mask)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: COMPILER ALIGNMENT DIRECTIVES
Note: =====================================================================

Process called "assume_aligned" that takes ptr as Pointer, alignment as Integer64 returns Pointer:
    Let result be null
    Inline Assembly:
        "mov %1, %0\n"        Note: Move pointer to result (assume aligned)
        : "=r"(result)
        : "r"(ptr)
        :
    End Assembly
    Return result
End Process

Process called "hint_alignment" that takes ptr as Pointer, alignment as Integer64 returns Pointer:
    Let result be null
    Inline Assembly:
        "mov %1, %0\n"        Note: Move pointer to result (hint alignment)
        : "=r"(result)
        : "r"(ptr)
        :
    End Assembly
    Return result
End Process

Process called "force_alignment" that takes ptr as Pointer, alignment as Integer64 returns Pointer:
    Let result be null
    Inline Assembly:
        "lea %0, [%1 + %2 - 1]\n"    Note: Calculate ptr + alignment - 1
        "neg %2\n"                   Note: Negate alignment for mask
        "and %0, %2\n"               Note: Apply alignment mask
        : "=r"(result)
        : "r"(ptr), "r"(alignment)
        : "flags"
    End Assembly
    Return result
End Process