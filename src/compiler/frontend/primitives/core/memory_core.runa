Note:
memory_core.runa - Zero-Dependency Memory Operation Primitives

This module provides the foundational memory load/store operations.
These primitives have ZERO dependencies and compile to direct memory access instructions.

@Reasoning:
- Provides raw memory access without safety checks
- All operations use inline assembly for true self-hosting
- No external dependencies - we generate the machine code directly
- Foundation for all higher-level memory management

@Implementation:
- Inline Assembly statements for direct memory access
- Supports all standard data sizes (8/16/32/64-bit)
- Both aligned and unaligned access patterns
- Zero-cost abstraction over raw memory

@Performance_Hints:
- Single instruction memory operations
- No bounds checking or validation
- Direct addressing modes used
- Cache-friendly access patterns supported
:End Note

Note: =====================================================================
Note: BASIC LOAD OPERATIONS
Note: =====================================================================

Process called "load8" that takes addr as Pointer returns Integer8:
    Let result be 0
    Inline Assembly:
        "movzx %0, byte ptr [%1]\n"     Note: Zero-extend 8-bit load to result
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "load16" that takes addr as Pointer returns Integer16:
    Let result be 0
    Inline Assembly:
        "movzx %0, word ptr [%1]\n"     Note: Zero-extend 16-bit load to result
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "load32" that takes addr as Pointer returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, dword ptr [%1]\n"      Note: Load 32-bit value from memory
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "load64" that takes addr as Pointer returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, qword ptr [%1]\n"      Note: Load 64-bit value from memory
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "load8_signed" that takes addr as Pointer returns Integer8:
    Let result be 0
    Inline Assembly:
        "movsx %0, byte ptr [%1]\n"     Note: Sign-extend 8-bit load to result
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "load16_signed" that takes addr as Pointer returns Integer16:
    Let result be 0
    Inline Assembly:
        "movsx %0, word ptr [%1]\n"     Note: Sign-extend 16-bit load to result
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "load32_signed" that takes addr as Pointer returns Integer32:
    Let result be 0
    Inline Assembly:
        "movsxd %0, dword ptr [%1]\n"   Note: Sign-extend 32-bit load to 64-bit register
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "load_ptr" that takes addr as Pointer returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, qword ptr [%1]\n"      Note: Load pointer value from memory
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: BASIC STORE OPERATIONS
Note: =====================================================================

Process called "store8" that takes addr as Pointer, val as Integer8:
    Inline Assembly:
        "mov byte ptr [%0], %1\n"       Note: Store 8-bit value to memory
        :
        : "r"(addr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "store16" that takes addr as Pointer, val as Integer16:
    Inline Assembly:
        "mov word ptr [%0], %1\n"       Note: Store 16-bit value to memory
        :
        : "r"(addr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "store32" that takes addr as Pointer, val as Integer32:
    Inline Assembly:
        "mov dword ptr [%0], %1\n"      Note: Store 32-bit value to memory
        :
        : "r"(addr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "store64" that takes addr as Pointer, val as Integer64:
    Inline Assembly:
        "mov qword ptr [%0], %1\n"      Note: Store 64-bit value to memory
        :
        : "r"(addr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "store_ptr" that takes addr as Pointer, val as Pointer:
    Inline Assembly:
        "mov qword ptr [%0], %1\n"      Note: Store pointer value to memory
        :
        : "r"(addr), "r"(val)
        : "memory"
    End Assembly
End Process

Note: =====================================================================
Note: INDEXED MEMORY ACCESS
Note: =====================================================================

Process called "load8_indexed" that takes base as Pointer, index as Integer64 returns Integer8:
    Let result be 0
    Inline Assembly:
        "movzx %0, byte ptr [%1 + %2]\n" Note: Zero-extend indexed 8-bit load
        : "=r"(result)
        : "r"(base), "r"(index)
        : "memory"
    End Assembly
    Return result
End Process

Process called "load16_indexed" that takes base as Pointer, index as Integer64 returns Integer16:
    Let result be 0
    Inline Assembly:
        "movzx %0, word ptr [%1 + %2]\n" Note: Zero-extend indexed 16-bit load
        : "=r"(result)
        : "r"(base), "r"(index)
        : "memory"
    End Assembly
    Return result
End Process

Process called "load32_indexed" that takes base as Pointer, index as Integer64 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, dword ptr [%1 + %2]\n"  Note: Load indexed 32-bit value
        : "=r"(result)
        : "r"(base), "r"(index)
        : "memory"
    End Assembly
    Return result
End Process

Process called "load64_indexed" that takes base as Pointer, index as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, qword ptr [%1 + %2]\n"  Note: Load indexed 64-bit value
        : "=r"(result)
        : "r"(base), "r"(index)
        : "memory"
    End Assembly
    Return result
End Process

Process called "store8_indexed" that takes base as Pointer, index as Integer64, val as Integer8:
    Inline Assembly:
        "mov byte ptr [%0 + %1], %2\n"  Note: Store indexed 8-bit value
        :
        : "r"(base), "r"(index), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "store16_indexed" that takes base as Pointer, index as Integer64, val as Integer16:
    Inline Assembly:
        "mov word ptr [%0 + %1], %2\n"  Note: Store indexed 16-bit value
        :
        : "r"(base), "r"(index), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "store32_indexed" that takes base as Pointer, index as Integer64, val as Integer32:
    Inline Assembly:
        "mov dword ptr [%0 + %1], %2\n" Note: Store indexed 32-bit value
        :
        : "r"(base), "r"(index), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "store64_indexed" that takes base as Pointer, index as Integer64, val as Integer64:
    Inline Assembly:
        "mov qword ptr [%0 + %1], %2\n" Note: Store indexed 64-bit value
        :
        : "r"(base), "r"(index), "r"(val)
        : "memory"
    End Assembly
End Process

Note: =====================================================================
Note: SCALED INDEX ACCESS (for arrays)
Note: =====================================================================

Process called "load_scaled" that takes base as Pointer, index as Integer64, scale as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, qword ptr [%1 + %2 * %3]\n" Note: Load with scaled index addressing
        : "=r"(result)
        : "r"(base), "r"(index), "r"(scale)
        : "memory"
    End Assembly
    Return result
End Process

Process called "store_scaled" that takes base as Pointer, index as Integer64, scale as Integer64, val as Integer64:
    Inline Assembly:
        "mov qword ptr [%0 + %1 * %2], %3\n" Note: Store with scaled index addressing
        :
        : "r"(base), "r"(index), "r"(scale), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "load32_scaled" that takes base as Pointer, index as Integer64, scale as Integer64 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, dword ptr [%1 + %2 * %3]\n" Note: Load 32-bit with scaled index addressing
        : "=r"(result)
        : "r"(base), "r"(index), "r"(scale)
        : "memory"
    End Assembly
    Return result
End Process

Process called "store32_scaled" that takes base as Pointer, index as Integer64, scale as Integer64, val as Integer32:
    Inline Assembly:
        "mov dword ptr [%0 + %1 * %2], %3\n" Note: Store 32-bit with scaled index addressing
        :
        : "r"(base), "r"(index), "r"(scale), "r"(val)
        : "memory"
    End Assembly
End Process

Note: =====================================================================
Note: ATOMIC MEMORY OPERATIONS
Note: =====================================================================

Process called "atomic_load8" that takes addr as Pointer returns Integer8:
    Let result be 0
    Inline Assembly:
        "movzx %0, byte ptr [%1]\n"     Note: Atomic load 8-bit value
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "atomic_load16" that takes addr as Pointer returns Integer16:
    Let result be 0
    Inline Assembly:
        "movzx %0, word ptr [%1]\n"     Note: Atomic load 16-bit value
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "atomic_load32" that takes addr as Pointer returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, dword ptr [%1]\n"      Note: Atomic load 32-bit value
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "atomic_load64" that takes addr as Pointer returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, qword ptr [%1]\n"      Note: Atomic load 64-bit value
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "atomic_store8" that takes addr as Pointer, val as Integer8:
    Inline Assembly:
        "mov byte ptr [%0], %1\n"       Note: Atomic store 8-bit value
        :
        : "r"(addr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "atomic_store16" that takes addr as Pointer, val as Integer16:
    Inline Assembly:
        "mov word ptr [%0], %1\n"       Note: Atomic store 16-bit value
        :
        : "r"(addr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "atomic_store32" that takes addr as Pointer, val as Integer32:
    Inline Assembly:
        "mov dword ptr [%0], %1\n"      Note: Atomic store 32-bit value
        :
        : "r"(addr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "atomic_store64" that takes addr as Pointer, val as Integer64:
    Inline Assembly:
        "mov qword ptr [%0], %1\n"      Note: Atomic store 64-bit value
        :
        : "r"(addr), "r"(val)
        : "memory"
    End Assembly
End Process

Note: =====================================================================
Note: COMPARE AND SWAP OPERATIONS
Note: =====================================================================

Process called "cas8" that takes addr as Pointer, expected as Integer8, desired as Integer8 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov al, %2\n"              Note: Load expected value into AL
        "lock cmpxchg byte ptr [%1], %3\n" Note: Atomic compare and swap
        "sete %0\n"                 Note: Set result if equal
        : "=r"(result)
        : "r"(addr), "r"(expected), "r"(desired)
        : "al", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "cas16" that takes addr as Pointer, expected as Integer16, desired as Integer16 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov ax, %2\n"              Note: Load expected value into AX
        "lock cmpxchg word ptr [%1], %3\n" Note: Atomic compare and swap
        "sete %0\n"                 Note: Set result if equal
        : "=r"(result)
        : "r"(addr), "r"(expected), "r"(desired)
        : "ax", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "cas32" that takes addr as Pointer, expected as Integer32, desired as Integer32 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov eax, %2\n"             Note: Load expected value into EAX
        "lock cmpxchg dword ptr [%1], %3\n" Note: Atomic compare and swap
        "sete %0\n"                 Note: Set result if equal
        : "=r"(result)
        : "r"(addr), "r"(expected), "r"(desired)
        : "eax", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "cas64" that takes addr as Pointer, expected as Integer64, desired as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, %2\n"             Note: Load expected value into RAX
        "lock cmpxchg qword ptr [%1], %3\n" Note: Atomic compare and swap
        "sete %0\n"                 Note: Set result if equal
        : "=r"(result)
        : "r"(addr), "r"(expected), "r"(desired)
        : "rax", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "cas_ptr" that takes addr as Pointer, expected as Pointer, desired as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, %2\n"             Note: Load expected pointer into RAX
        "lock cmpxchg qword ptr [%1], %3\n" Note: Atomic pointer compare and swap
        "sete %0\n"                 Note: Set result if equal
        : "=r"(result)
        : "r"(addr), "r"(expected), "r"(desired)
        : "rax", "memory", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: MEMORY EXCHANGE OPERATIONS
Note: =====================================================================

Process called "xchg8" that takes addr as Pointer, val as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov al, %2\n"              Note: Load value into AL
        "xchg byte ptr [%1], al\n"  Note: Atomic exchange with memory
        "movzx %0, al\n"            Note: Zero-extend result
        : "=r"(result)
        : "r"(addr), "r"(val)
        : "al", "memory"
    End Assembly
    Return result
End Process

Process called "xchg16" that takes addr as Pointer, val as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov ax, %2\n"              Note: Load value into AX
        "xchg word ptr [%1], ax\n"  Note: Atomic exchange with memory
        "movzx %0, ax\n"            Note: Zero-extend result
        : "=r"(result)
        : "r"(addr), "r"(val)
        : "ax", "memory"
    End Assembly
    Return result
End Process

Process called "xchg32" that takes addr as Pointer, val as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov eax, %2\n"             Note: Load value into EAX
        "xchg dword ptr [%1], eax\n" Note: Atomic exchange with memory
        "mov %0, eax\n"             Note: Move result to output
        : "=r"(result)
        : "r"(addr), "r"(val)
        : "eax", "memory"
    End Assembly
    Return result
End Process

Process called "xchg64" that takes addr as Pointer, val as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov rax, %2\n"             Note: Load value into RAX
        "xchg qword ptr [%1], rax\n" Note: Atomic exchange with memory
        "mov %0, rax\n"             Note: Move result to output
        : "=r"(result)
        : "r"(addr), "r"(val)
        : "rax", "memory"
    End Assembly
    Return result
End Process

Process called "xchg_ptr" that takes addr as Pointer, val as Pointer returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov rax, %2\n"             Note: Load pointer into RAX
        "xchg qword ptr [%1], rax\n" Note: Atomic exchange pointer with memory
        "mov %0, rax\n"             Note: Move result to output
        : "=r"(result)
        : "r"(addr), "r"(val)
        : "rax", "memory"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: BULK MEMORY OPERATIONS
Note: =====================================================================

Process called "memcpy" that takes dest as Pointer, src as Pointer, size as Integer64:
    Inline Assembly:
        "mov rcx, %2\n"             Note: Load size into RCX counter
        "mov rdi, %0\n"             Note: Load destination into RDI
        "mov rsi, %1\n"             Note: Load source into RSI
        "rep movsb\n"               Note: Repeat move byte operation
        :
        : "r"(dest), "r"(src), "r"(size)
        : "rcx", "rdi", "rsi", "memory"
    End Assembly
End Process

Process called "memset" that takes dest as Pointer, val as Integer8, size as Integer64:
    Inline Assembly:
        "mov rcx, %2\n"             Note: Load size into RCX counter
        "mov rdi, %0\n"             Note: Load destination into RDI
        "mov al, %1\n"              Note: Load value into AL
        "rep stosb\n"               Note: Repeat store byte operation
        :
        : "r"(dest), "r"(val), "r"(size)
        : "rcx", "rdi", "al", "memory"
    End Assembly
End Process

Process called "memcmp" that takes a as Pointer, b as Pointer, size as Integer64 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov rcx, %3\n"             Note: Load size into RCX counter
        "mov rdi, %1\n"             Note: Load first pointer into RDI
        "mov rsi, %2\n"             Note: Load second pointer into RSI
        "repe cmpsb\n"              Note: Repeat compare bytes while equal
        "mov %0, 0\n"               Note: Default result is 0 (equal)
        "ja 1f\n"                   Note: Jump if first > second
        "jb 2f\n"                   Note: Jump if first < second
        "jmp 3f\n"                  Note: Jump to end (equal case)
        "1: mov %0, 1\n"            Note: Set result to 1 (first > second)
        "jmp 3f\n"                  Note: Jump to end
        "2: mov %0, -1\n"           Note: Set result to -1 (first < second)
        "3:\n"                      Note: End label
        : "=r"(result)
        : "r"(a), "r"(b), "r"(size)
        : "rcx", "rdi", "rsi", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "memmove" that takes dest as Pointer, src as Pointer, size as Integer64:
    Inline Assembly:
        "mov rcx, %2\n"             Note: Load size into RCX counter
        "mov rdi, %0\n"             Note: Load destination into RDI
        "mov rsi, %1\n"             Note: Load source into RSI
        "cmp rdi, rsi\n"            Note: Compare destination and source
        "jbe 1f\n"                  Note: Jump if dest <= src (forward copy)
        "add rdi, rcx\n"            Note: Point to end of destination
        "add rsi, rcx\n"            Note: Point to end of source
        "dec rdi\n"                 Note: Adjust for byte addressing
        "dec rsi\n"                 Note: Adjust for byte addressing
        "std\n"                     Note: Set direction flag for reverse copy
        "1: rep movsb\n"            Note: Repeat move bytes
        "cld\n"                     Note: Clear direction flag
        :
        : "r"(dest), "r"(src), "r"(size)
        : "rcx", "rdi", "rsi", "memory", "flags"
    End Assembly
End Process

Process called "memzero" that takes dest as Pointer, size as Integer64:
    Inline Assembly:
        "mov rcx, %1\n"             Note: Load size into RCX counter
        "mov rdi, %0\n"             Note: Load destination into RDI
        "xor al, al\n"              Note: Clear AL to zero
        "rep stosb\n"               Note: Repeat store zero bytes
        :
        : "r"(dest), "r"(size)
        : "rcx", "rdi", "al", "memory"
    End Assembly
End Process

Note: =====================================================================
Note: MEMORY BARRIER OPERATIONS
Note: =====================================================================

Process called "memory_fence":
    Inline Assembly:
        "mfence\n"                  Note: Memory fence instruction
        :
        :
        : "memory"
    End Assembly
End Process

Process called "load_fence":
    Inline Assembly:
        "lfence\n"                  Note: Load fence instruction
        :
        :
        : "memory"
    End Assembly
End Process

Process called "store_fence":
    Inline Assembly:
        "sfence\n"                  Note: Store fence instruction
        :
        :
        : "memory"
    End Assembly
End Process

Process called "compiler_fence":
    Inline Assembly:
        ""                          Note: Compiler barrier (no instruction)
        :
        :
        : "memory"
    End Assembly
End Process

Note: =====================================================================
Note: PREFETCH OPERATIONS
Note: =====================================================================

Process called "prefetch0" that takes addr as Pointer:
    Inline Assembly:
        "prefetcht0 [%0]\n"         Note: Prefetch to L1 cache
        :
        : "r"(addr)
        :
    End Assembly
End Process

Process called "prefetch1" that takes addr as Pointer:
    Inline Assembly:
        "prefetcht1 [%0]\n"         Note: Prefetch to L2 cache
        :
        : "r"(addr)
        :
    End Assembly
End Process

Process called "prefetch2" that takes addr as Pointer:
    Inline Assembly:
        "prefetcht2 [%0]\n"         Note: Prefetch to L3 cache
        :
        : "r"(addr)
        :
    End Assembly
End Process

Process called "prefetch_nta" that takes addr as Pointer:
    Inline Assembly:
        "prefetchnta [%0]\n"        Note: Prefetch non-temporal access
        :
        : "r"(addr)
        :
    End Assembly
End Process

Process called "prefetch_write" that takes addr as Pointer:
    Inline Assembly:
        "prefetchw [%0]\n"          Note: Prefetch for write access
        :
        : "r"(addr)
        :
    End Assembly
End Process

Note: =====================================================================
Note: CACHE CONTROL
Note: =====================================================================

Process called "clflush" that takes addr as Pointer:
    Inline Assembly:
        "clflush [%0]\n"            Note: Flush cache line
        :
        : "r"(addr)
        : "memory"
    End Assembly
End Process

Process called "clflushopt" that takes addr as Pointer:
    Inline Assembly:
        "clflushopt [%0]\n"         Note: Optimized flush cache line
        :
        : "r"(addr)
        : "memory"
    End Assembly
End Process

Process called "clwb" that takes addr as Pointer:
    Inline Assembly:
        "clwb [%0]\n"               Note: Cache line write back
        :
        : "r"(addr)
        : "memory"
    End Assembly
End Process