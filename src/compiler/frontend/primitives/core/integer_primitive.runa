Note:
integer_primitive.runa - Zero-Dependency Integer Primitives

This module provides the foundational integer operations that map directly to CPU instructions.
These primitives have ZERO dependencies and compile to 1-3 machine instructions maximum.

@Reasoning:
- All operations use inline assembly for true self-hosting
- No external dependencies - we generate the machine code directly
- No error checking or overflow detection - those are stdlib responsibilities  
- Support for 8, 16, 32, and 64-bit integer types
- Operations are unsafe/unchecked for maximum performance

@Implementation:
- Inline Assembly statements define the exact CPU instructions
- Compiler replaces %[param] placeholders with register allocations
- Platform-specific assembly syntax (x86_64 shown, ARM64 variants exist)
- No memory allocation or complex logic

@Performance_Hints:
- Each operation maps to 1-3 CPU instructions
- No branching or validation overhead
- Direct register operations where possible
- Zero-cost abstraction over raw assembly
:End Note

Note: =====================================================================
Note: 64-BIT INTEGER OPERATIONS (Primary implementation)
Note: =====================================================================

Process called "add_i64" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "add %0, %2\n"       Note: Add second operand to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "sub_i64" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "sub %0, %2\n"       Note: Subtract second operand from result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "mul_i64" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "imul %0, %2\n"      Note: Signed multiply with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "div_i64" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov rax, %1\n"      Note: Move dividend to RAX
        "cqo\n"              Note: Sign-extend RAX to RDX:RAX
        "idiv %2\n"          Note: Signed divide RDX:RAX by divisor
        "mov %0, rax\n"      Note: Move quotient to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "mod_i64" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov rax, %1\n"      Note: Move dividend to RAX
        "cqo\n"              Note: Sign-extend RAX to RDX:RAX
        "idiv %2\n"          Note: Signed divide RDX:RAX by divisor
        "mov %0, rdx\n"      Note: Move remainder to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "neg_i64" that takes a as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "neg %0\n"           Note: Negate the result
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "abs_i64" that takes a as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "mov rax, %0\n"      Note: Copy to temporary register
        "neg %0\n"           Note: Negate the result
        "cmovl %0, rax\n"    Note: Use original if result was negative
        : "=r"(result)
        : "r"(a)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "and_i64" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "and %0, %2\n"       Note: Bitwise AND with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "or_i64" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "or %0, %2\n"        Note: Bitwise OR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "xor_i64" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "xor %0, %2\n"       Note: Bitwise XOR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "not_i64" that takes a as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "not %0\n"           Note: Bitwise NOT of the result
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "shl_i64" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "mov rcx, %2\n"      Note: Move shift count to RCX
        "shl %0, cl\n"       Note: Shift left by CL bits
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "shr_i64" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "mov rcx, %2\n"      Note: Move shift count to RCX
        "sar %0, cl\n"       Note: Arithmetic shift right by CL bits
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "ushr_i64" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "mov rcx, %2\n"      Note: Move shift count to RCX
        "shr %0, cl\n"       Note: Logical shift right by CL bits
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: 32-BIT INTEGER OPERATIONS
Note: =====================================================================

Process called "add_i32" that takes a as Integer32, b as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "add %0, %2\n"       Note: Add second operand to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "sub_i32" that takes a as Integer32, b as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "sub %0, %2\n"       Note: Subtract second operand from result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "mul_i32" that takes a as Integer32, b as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "imul %0, %2\n"      Note: Signed multiply with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "div_i32" that takes a as Integer32, b as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov eax, %1\n"      Note: Move dividend to EAX
        "cdq\n"              Note: Sign-extend EAX to EDX:EAX
        "idiv %2\n"          Note: Signed divide EDX:EAX by divisor
        "mov %0, eax\n"      Note: Move quotient to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "eax", "edx", "flags"
    End Assembly
    Return result
End Process

Process called "mod_i32" that takes a as Integer32, b as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov eax, %1\n"      Note: Move dividend to EAX
        "cdq\n"              Note: Sign-extend EAX to EDX:EAX
        "idiv %2\n"          Note: Signed divide EDX:EAX by divisor
        "mov %0, edx\n"      Note: Move remainder to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "eax", "edx", "flags"
    End Assembly
    Return result
End Process

Process called "neg_i32" that takes a as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "neg %0\n"           Note: Negate the result
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "abs_i32" that takes a as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "mov eax, %0\n"      Note: Copy to temporary register
        "neg %0\n"           Note: Negate the result
        "cmovl %0, eax\n"    Note: Use original if result was negative
        : "=r"(result)
        : "r"(a)
        : "eax", "flags"
    End Assembly
    Return result
End Process

Process called "and_i32" that takes a as Integer32, b as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "and %0, %2\n"       Note: Bitwise AND with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "or_i32" that takes a as Integer32, b as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "or %0, %2\n"        Note: Bitwise OR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "xor_i32" that takes a as Integer32, b as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "xor %0, %2\n"       Note: Bitwise XOR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "not_i32" that takes a as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "not %0\n"           Note: Bitwise NOT of the result
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "shl_i32" that takes a as Integer32, b as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "mov ecx, %2\n"      Note: Move shift count to ECX
        "shl %0, cl\n"       Note: Shift left by CL bits
        : "=r"(result)
        : "r"(a), "r"(b)
        : "ecx", "flags"
    End Assembly
    Return result
End Process

Process called "shr_i32" that takes a as Integer32, b as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "mov ecx, %2\n"      Note: Move shift count to ECX
        "sar %0, cl\n"       Note: Arithmetic shift right by CL bits
        : "=r"(result)
        : "r"(a), "r"(b)
        : "ecx", "flags"
    End Assembly
    Return result
End Process

Process called "ushr_i32" that takes a as Integer32, b as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "mov ecx, %2\n"      Note: Move shift count to ECX
        "shr %0, cl\n"       Note: Logical shift right by CL bits
        : "=r"(result)
        : "r"(a), "r"(b)
        : "ecx", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: 16-BIT INTEGER OPERATIONS
Note: =====================================================================

Process called "add_i16" that takes a as Integer16, b as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "add %0, %2\n"       Note: Add second operand to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "sub_i16" that takes a as Integer16, b as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "sub %0, %2\n"       Note: Subtract second operand from result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "mul_i16" that takes a as Integer16, b as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "imul %0, %2\n"      Note: Signed multiply with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "div_i16" that takes a as Integer16, b as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov ax, %1\n"       Note: Move dividend to AX
        "cwd\n"              Note: Sign-extend AX to DX:AX
        "idiv %2\n"          Note: Signed divide DX:AX by divisor
        "mov %0, ax\n"       Note: Move quotient to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "ax", "dx", "flags"
    End Assembly
    Return result
End Process

Process called "mod_i16" that takes a as Integer16, b as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov ax, %1\n"       Note: Move dividend to AX
        "cwd\n"              Note: Sign-extend AX to DX:AX
        "idiv %2\n"          Note: Signed divide DX:AX by divisor
        "mov %0, dx\n"       Note: Move remainder to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "ax", "dx", "flags"
    End Assembly
    Return result
End Process

Process called "neg_i16" that takes a as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "neg %0\n"           Note: Negate the result
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "abs_i16" that takes a as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "mov ax, %0\n"       Note: Copy to temporary register
        "neg %0\n"           Note: Negate the result
        "cmovl %0, ax\n"     Note: Use original if result was negative
        : "=r"(result)
        : "r"(a)
        : "ax", "flags"
    End Assembly
    Return result
End Process

Process called "and_i16" that takes a as Integer16, b as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "and %0, %2\n"       Note: Bitwise AND with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "or_i16" that takes a as Integer16, b as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "or %0, %2\n"        Note: Bitwise OR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "xor_i16" that takes a as Integer16, b as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "xor %0, %2\n"       Note: Bitwise XOR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "not_i16" that takes a as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "not %0\n"           Note: Bitwise NOT of the result
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "shl_i16" that takes a as Integer16, b as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "mov cx, %2\n"       Note: Move shift count to CX
        "shl %0, cl\n"       Note: Shift left by CL bits
        : "=r"(result)
        : "r"(a), "r"(b)
        : "cx", "flags"
    End Assembly
    Return result
End Process

Process called "shr_i16" that takes a as Integer16, b as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "mov cx, %2\n"       Note: Move shift count to CX
        "sar %0, cl\n"       Note: Arithmetic shift right by CL bits
        : "=r"(result)
        : "r"(a), "r"(b)
        : "cx", "flags"
    End Assembly
    Return result
End Process

Process called "ushr_i16" that takes a as Integer16, b as Integer16 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "mov cx, %2\n"       Note: Move shift count to CX
        "shr %0, cl\n"       Note: Logical shift right by CL bits
        : "=r"(result)
        : "r"(a), "r"(b)
        : "cx", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: 8-BIT INTEGER OPERATIONS
Note: =====================================================================

Process called "add_i8" that takes a as Integer8, b as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "add %0, %2\n"       Note: Add second operand to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "sub_i8" that takes a as Integer8, b as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "sub %0, %2\n"       Note: Subtract second operand from result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "mul_i8" that takes a as Integer8, b as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov al, %1\n"       Note: Move first operand to AL
        "imul %2\n"          Note: Signed multiply AL with second operand
        "mov %0, al\n"       Note: Move result from AL
        : "=r"(result)
        : "r"(a), "r"(b)
        : "al", "flags"
    End Assembly
    Return result
End Process

Process called "div_i8" that takes a as Integer8, b as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov al, %1\n"       Note: Move dividend to AL
        "cbw\n"              Note: Sign-extend AL to AX
        "idiv %2\n"          Note: Signed divide AX by divisor
        "mov %0, al\n"       Note: Move quotient to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "al", "ah", "flags"
    End Assembly
    Return result
End Process

Process called "mod_i8" that takes a as Integer8, b as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov al, %1\n"       Note: Move dividend to AL
        "cbw\n"              Note: Sign-extend AL to AX
        "idiv %2\n"          Note: Signed divide AX by divisor
        "mov %0, ah\n"       Note: Move remainder to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "al", "ah", "flags"
    End Assembly
    Return result
End Process

Process called "neg_i8" that takes a as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "neg %0\n"           Note: Negate the result
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "abs_i8" that takes a as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "mov al, %0\n"       Note: Copy to temporary register
        "neg %0\n"           Note: Negate the result
        "cmovl %0, al\n"     Note: Use original if result was negative
        : "=r"(result)
        : "r"(a)
        : "al", "flags"
    End Assembly
    Return result
End Process

Process called "and_i8" that takes a as Integer8, b as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "and %0, %2\n"       Note: Bitwise AND with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "or_i8" that takes a as Integer8, b as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "or %0, %2\n"        Note: Bitwise OR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "xor_i8" that takes a as Integer8, b as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "xor %0, %2\n"       Note: Bitwise XOR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "not_i8" that takes a as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "not %0\n"           Note: Bitwise NOT of the result
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "shl_i8" that takes a as Integer8, b as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "mov cl, %2\n"       Note: Move shift count to CL
        "shl %0, cl\n"       Note: Shift left by CL bits
        : "=r"(result)
        : "r"(a), "r"(b)
        : "cl", "flags"
    End Assembly
    Return result
End Process

Process called "shr_i8" that takes a as Integer8, b as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "mov cl, %2\n"       Note: Move shift count to CL
        "sar %0, cl\n"       Note: Arithmetic shift right by CL bits
        : "=r"(result)
        : "r"(a), "r"(b)
        : "cl", "flags"
    End Assembly
    Return result
End Process

Process called "ushr_i8" that takes a as Integer8, b as Integer8 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move first operand to result
        "mov cl, %2\n"       Note: Move shift count to CL
        "shr %0, cl\n"       Note: Logical shift right by CL bits
        : "=r"(result)
        : "r"(a), "r"(b)
        : "cl", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: COMPARISON OPERATIONS
Note: =====================================================================

Process called "eq_i64" that takes a as Integer64, b as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "sete %0\n"          Note: Set result if equal
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ne_i64" that takes a as Integer64, b as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setne %0\n"         Note: Set result if not equal
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "lt_i64" that takes a as Integer64, b as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setl %0\n"          Note: Set result if less than (signed)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "le_i64" that takes a as Integer64, b as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setle %0\n"         Note: Set result if less than or equal (signed)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "gt_i64" that takes a as Integer64, b as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setg %0\n"          Note: Set result if greater than (signed)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ge_i64" that takes a as Integer64, b as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setge %0\n"         Note: Set result if greater than or equal (signed)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "eq_i32" that takes a as Integer32, b as Integer32 returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "sete %0\n"          Note: Set result if equal
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ne_i32" that takes a as Integer32, b as Integer32 returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setne %0\n"         Note: Set result if not equal
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "lt_i32" that takes a as Integer32, b as Integer32 returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setl %0\n"          Note: Set result if less than (signed)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "le_i32" that takes a as Integer32, b as Integer32 returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setle %0\n"         Note: Set result if less than or equal (signed)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "gt_i32" that takes a as Integer32, b as Integer32 returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setg %0\n"          Note: Set result if greater than (signed)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ge_i32" that takes a as Integer32, b as Integer32 returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setge %0\n"         Note: Set result if greater than or equal (signed)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: CONVERSION OPERATIONS
Note: =====================================================================

Process called "i8_to_i16" that takes a as Integer8 returns Integer16:
    Let result be 0
    Inline Assembly:
        "movsx %0, %1\n"     Note: Sign-extend 8-bit to 16-bit
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "i8_to_i32" that takes a as Integer8 returns Integer32:
    Let result be 0
    Inline Assembly:
        "movsx %0, %1\n"     Note: Sign-extend 8-bit to 32-bit
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "i8_to_i64" that takes a as Integer8 returns Integer64:
    Let result be 0
    Inline Assembly:
        "movsx %0, %1\n"     Note: Sign-extend 8-bit to 64-bit
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "i16_to_i32" that takes a as Integer16 returns Integer32:
    Let result be 0
    Inline Assembly:
        "movsx %0, %1\n"     Note: Sign-extend 16-bit to 32-bit
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "i16_to_i64" that takes a as Integer16 returns Integer64:
    Let result be 0
    Inline Assembly:
        "movsx %0, %1\n"     Note: Sign-extend 16-bit to 64-bit
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "i32_to_i64" that takes a as Integer32 returns Integer64:
    Let result be 0
    Inline Assembly:
        "movsxd %0, %1\n"    Note: Sign-extend 32-bit to 64-bit
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "i64_to_i32" that takes a as Integer64 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Truncate 64-bit to 32-bit
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "i32_to_i16" that takes a as Integer32 returns Integer16:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Truncate 32-bit to 16-bit
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "i32_to_i8" that takes a as Integer32 returns Integer8:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Truncate 32-bit to 8-bit
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: BIT MANIPULATION OPERATIONS
Note: =====================================================================

Process called "popcount_i32" that takes a as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "popcnt %0, %1\n"    Note: Population count (number of set bits)
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "popcount_i64" that takes a as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "popcnt %0, %1\n"    Note: Population count (number of set bits)
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "clz_i32" that takes a as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "lzcnt %0, %1\n"     Note: Leading zero count
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "clz_i64" that takes a as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lzcnt %0, %1\n"     Note: Leading zero count
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "ctz_i32" that takes a as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "tzcnt %0, %1\n"     Note: Trailing zero count
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "ctz_i64" that takes a as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "tzcnt %0, %1\n"     Note: Trailing zero count
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "bswap_i32" that takes a as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "bswap %0\n"         Note: Byte swap for endian conversion
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "bswap_i64" that takes a as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"       Note: Move operand to result
        "bswap %0\n"         Note: Byte swap for endian conversion
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ATOMIC OPERATIONS (for future concurrent support)
Note: =====================================================================

Process called "atomic_add_i32" that takes ptr as Pointer, val as Integer32 returns Integer32:
    Let result be 0
    Inline Assembly:
        "lock xadd [%1], %2\n" Note: Atomic exchange and add
        "mov %0, %2\n"       Note: Return previous value
        : "=r"(result)
        : "r"(ptr), "r"(val)
        : "memory"
    End Assembly
    Return result
End Process

Process called "atomic_add_i64" that takes ptr as Pointer, val as Integer64 returns Integer64:
    Let result be 0
    Inline Assembly:
        "lock xadd [%1], %2\n" Note: Atomic exchange and add
        "mov %0, %2\n"       Note: Return previous value
        : "=r"(result)
        : "r"(ptr), "r"(val)
        : "memory"
    End Assembly
    Return result
End Process

Process called "atomic_cas_i32" that takes ptr as Pointer, expected as Integer32, desired as Integer32 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov eax, %2\n"      Note: Load expected value to EAX
        "lock cmpxchg [%1], %3\n" Note: Atomic compare and exchange
        "sete %0\n"          Note: Set result if exchange succeeded
        : "=r"(result)
        : "r"(ptr), "r"(expected), "r"(desired)
        : "eax", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "atomic_cas_i64" that takes ptr as Pointer, expected as Integer64, desired as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, %2\n"      Note: Load expected value to RAX
        "lock cmpxchg [%1], %3\n" Note: Atomic compare and exchange
        "sete %0\n"          Note: Set result if exchange succeeded
        : "=r"(result)
        : "r"(ptr), "r"(expected), "r"(desired)
        : "rax", "memory", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: SYSTEM STATE MANAGEMENT (for runtime support)
Note: =====================================================================

@Reasoning
These functions provide system state management required by the runtime syscall
compatibility layers. They manage global state, handle mappings, and process
tracking needed for POSIX compatibility on non-POSIX systems.
@End Reasoning

Note: Global counter for unique ID generation
Let global_counter_value be 1000

Process called "get_global_counter" that returns Integer:
    @Implementation
    Returns and increments a global counter for generating unique identifiers
    used in pipe naming, process tracking, and other system operations.
    @End Implementation
    
    Let current_value be global_counter_value
    Set global_counter_value to (global_counter_value + 1)
    Return current_value
End Process

Note: Global heap break pointer for brk/sbrk emulation
Let global_heap_break be 0x10000000

Process called "get_global_heap_break" that returns Integer:
    @Implementation
    Returns the current heap break pointer for POSIX brk/sbrk emulation.
    @End Implementation
    
    Return global_heap_break
End Process

Process called "set_global_heap_break" that takes addr as Integer returns Nothing:
    @Implementation
    Sets the global heap break pointer for POSIX brk/sbrk emulation.
    @End Implementation
    
    Set global_heap_break to addr
End Process

Note: Global umask value for file creation permissions
Let global_umask_value be 0x022

Process called "get_global_umask" that returns Integer:
    @Implementation
    Returns the current umask value for POSIX file permission calculations.
    @End Implementation
    
    Return global_umask_value
End Process

Process called "set_global_umask" that takes mask as Integer returns Nothing:
    @Implementation
    Sets the global umask value for POSIX file permission calculations.
    @End Implementation
    
    Set global_umask_value to mask
End Process

Note: Socket handle mapping table (sockfd -> actual_handle)
Let socket_handle_table be Array[1024] of Integer
Let socket_handle_count be 0

Process called "update_socket_handle" that takes sockfd as Integer, new_handle as Integer returns Nothing:
    @Implementation
    Updates the socket handle mapping table to associate a socket file descriptor
    with its actual system handle for Unix domain socket operations.
    @End Implementation
    
    If sockfd is greater than 0 and sockfd is less than 1024:
        Set socket_handle_table[sockfd] to new_handle
    End If
End Process

Note: Child process tracking for wait operations
Let child_handle_table be Array[64] of Integer
Let child_pid_table be Array[64] of Integer
Let child_process_count be 0

Process called "store_child_handle" that takes pid as Integer, handle as Integer returns Nothing:
    @Implementation
    Stores a child process handle and PID for later wait operations.
    Used by fork emulation and process management.
    @End Implementation
    
    If child_process_count is less than 64:
        Set child_pid_table[child_process_count] to pid
        Set child_handle_table[child_process_count] to handle
        Set child_process_count to (child_process_count + 1)
    End If
End Process

Process called "get_child_handles" that takes handles_array as Integer, pids_array as Integer, max_count as Integer returns Integer:
    @Implementation
    Retrieves all stored child process handles and PIDs for wait operations.
    Returns the actual count of child processes.
    @End Implementation
    
    Let copy_count be child_process_count
    If max_count is less than child_process_count:
        Set copy_count to max_count
    End If
    
    For i from 0 to (copy_count - 1):
        write_memory(handles_array + (i * 8), child_handle_table[i])
        write_memory(pids_array + (i * 4), child_pid_table[i])
    End For
    
    Return child_process_count
End Process

Process called "get_child_handle" that takes pid as Integer returns Integer:
    @Implementation
    Retrieves the handle for a specific child process by PID.
    Returns the actual handle if found, or -1 to indicate process not found.
    @End Implementation
    
    Note: Validate input PID
    If pid less_than_or_equal_to 0:
        Return -1
    End If
    
    For i from 0 to (child_process_count - 1):
        If child_pid_table[i] equals pid:
            Return child_handle_table[i]
        End If
    End For
    
    Note: Process not found in child table
    Return -1
End Process

Process called "remove_child_handle" that takes pid as Integer returns Nothing:
    @Implementation
    Removes a child process from tracking when it exits.
    @End Implementation
    
    For i from 0 to (child_process_count - 1):
        If child_pid_table[i] equals pid:
            Note: Shift remaining entries down
            For j from i to (child_process_count - 2):
                Set child_pid_table[j] to child_pid_table[j + 1]
                Set child_handle_table[j] to child_handle_table[j + 1]
            End For
            Set child_process_count to (child_process_count - 1)
            Break
        End If
    End For
End Process

Note: Process job handle for session management
Let process_job_handle be 0

Process called "set_process_job_handle" that takes handle as Integer returns Nothing:
    @Implementation
    Sets the current process job object handle for Windows session management.
    @End Implementation
    
    Set process_job_handle to handle
End Process

Note: Command line access for fork detection
Let command_line_buffer be Array[1024] of Integer8
Let command_line_length be 0

Process called "get_command_line" that returns Integer:
    @Implementation
    Returns a pointer to the command line string buffer for fork child detection.
    The buffer is allocated as a static 1024-byte array and gets populated
    during program initialization with command line arguments.
    @End Implementation
    
    Return command_line_buffer
End Process

Note: Memory operations for syscall infrastructure
Process called "allocate" that takes size as Integer returns Integer:
    @Implementation
    Allocates memory for syscall operations using inline assembly.
    Maps to platform-specific allocation (malloc equivalent).
    @End Implementation
    
    Let result be 0
    Inline Assembly:
        "mov rdi, %1\n"      Note: Move size parameter to RDI
        "call malloc\n"      Note: Call system malloc
        "mov %0, rax\n"      Note: Return pointer from RAX
        : "=r"(result)
        : "r"(size)
        : "rdi", "rax", "memory"
    End Assembly
    Return result
End Process

Process called "read_memory" that takes addr as Integer returns Integer:
    @Implementation
    Reads an integer value from memory address using inline assembly.
    @End Implementation
    
    Let result be 0
    Inline Assembly:
        "mov %0, [%1]\n"     Note: Load value from memory address
        : "=r"(result)
        : "r"(addr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "write_memory" that takes addr as Integer, value as Integer returns Nothing:
    @Implementation
    Writes an integer value to memory address using inline assembly.
    @End Implementation
    
    Inline Assembly:
        "mov [%0], %1\n"     Note: Store value to memory address
        :
        : "r"(addr), "r"(value)
        : "memory"
    End Assembly
End Process