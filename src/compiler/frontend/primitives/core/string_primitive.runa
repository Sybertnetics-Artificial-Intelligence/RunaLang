Note:
string_primitive.runa - Zero-Dependency String Primitives

This module provides foundational string operations for syscall infrastructure.
These primitives have minimal dependencies and provide basic string manipulation
needed for POSIX compatibility layers and system operation.

@Reasoning
String operations are essential for syscall compatibility, especially for
path manipulation, command line processing, and system interface operations.
These primitives focus on memory-based string operations needed by the runtime.
@End Reasoning

@Implementation
String operations work directly with memory pointers and lengths, using
inline assembly for performance-critical operations and simple algorithms
for correctness-critical operations.
@End Implementation

@Performance_Hints
These operations prioritize correctness over optimization. They are designed
for syscall infrastructure use, not high-performance string processing.
@End Performance_Hints
:End Note

Note: =====================================================================
Note: STRING MEMORY OPERATIONS
Note: =====================================================================

Process called "copy_to_memory" that takes dest_ptr as Integer, src_string as String returns Nothing:
    @Implementation
    Copies a Runa string to a memory buffer pointed to by dest_ptr.
    Used for converting Runa strings to C-style null-terminated strings.
    @End Implementation
    
    Let src_length be String.length(src_string)
    
    For i from 0 to (src_length - 1):
        Let char_code be String.char_at(src_string, i)
        Inline Assembly:
            "movzx eax, %2\n"         Note: Load character code
            "mov byte ptr [%0 + %1], al\n" Note: Store character at destination
            :
            : "r"(dest_ptr), "r"(i), "r"(char_code)
            : "eax", "memory"
        End Assembly
    End For
    
    Note: Add null terminator
    Inline Assembly:
        "mov byte ptr [%0 + %1], 0\n" Note: Add null terminator
        :
        : "r"(dest_ptr), "r"(src_length)
        : "memory"
    End Assembly
End Process

Process called "append_to_memory" that takes dest_ptr as Integer, src_string as String returns Nothing:
    @Implementation
    Appends a Runa string to an existing null-terminated string in memory.
    Finds the end of the existing string and appends the new content.
    @End Implementation
    
    Note: Find the end of existing string
    Let dest_length be 0
    While true:
        Let current_char be 0
        Inline Assembly:
            "movzx %0, byte ptr [%1 + %2]\n" Note: Load character from destination
            : "=r"(current_char)
            : "r"(dest_ptr), "r"(dest_length)
            : "memory"
        End Assembly
        If current_char equals 0:
            Break
        End If
        Set dest_length to (dest_length + 1)
    End While
    
    Note: Append new string starting at the null terminator position
    Let src_length be String.length(src_string)
    
    For i from 0 to (src_length - 1):
        Let char_code be String.char_at(src_string, i)
        Let offset_val be (dest_length + i)
        Inline Assembly:
            "movzx eax, %2\n"         Note: Load character code
            "mov byte ptr [%0 + %1], al\n" Note: Store character at destination
            :
            : "r"(dest_ptr), "r"(offset_val), "r"(char_code)
            : "eax", "memory"
        End Assembly
    End For
    
    Note: Add new null terminator
    Let final_offset be (dest_length + src_length)
    Inline Assembly:
        "mov byte ptr [%0 + %1], 0\n" Note: Add null terminator
        :
        : "r"(dest_ptr), "r"(final_offset)
        : "memory"
    End Assembly
End Process

Process called "length_from_memory" that takes src_ptr as Integer returns Integer:
    @Implementation
    Calculates the length of a null-terminated string in memory.
    Returns the number of characters before the null terminator.
    @End Implementation
    
    Let length be 0
    While true:
        Let current_char be 0
        Inline Assembly:
            "movzx %0, byte ptr [%1 + %2]\n" Note: Load character from source
            : "=r"(current_char)
            : "r"(src_ptr), "r"(length)
            : "memory"
        End Assembly
        If current_char equals 0:
            Break
        End If
        Set length to (length + 1)
    End While
    
    Return length
End Process

Note: =====================================================================
Note: STRING MANIPULATION OPERATIONS  
Note: =====================================================================

Process called "contains" that takes haystack as String, needle as String returns Boolean:
    @Implementation
    Checks if haystack contains needle as a substring.
    Uses simple string search algorithm for correctness.
    @End Implementation
    
    Let haystack_len be String.length(haystack)
    Let needle_len be String.length(needle)
    
    If needle_len equals 0:
        Return true
    End If
    
    If needle_len is greater than haystack_len:
        Return false
    End If
    
    Let search_limit be (haystack_len - needle_len)
    
    For i from 0 to search_limit:
        Let match_found be true
        
        For j from 0 to (needle_len - 1):
            Let haystack_char be String.char_at(haystack, i + j)
            Let needle_char be String.char_at(needle, j)
            
            If haystack_char not equals needle_char:
                Set match_found to false
                Break
            End If
        End For
        
        If match_found:
            Return true
        End If
    End For
    
    Return false
End Process

Process called "allocate" that takes size as Integer returns String:
    @Implementation
    Allocates a new string with the specified size in characters.
    Returns an empty string buffer ready for character assignment.
    @End Implementation
    
    Return String.create_with_capacity(size)
End Process

Process called "copy" that takes dest as String, src as String returns Nothing:
    @Implementation
    Copies the contents of src string into dest string.
    Assumes dest has sufficient capacity.
    @End Implementation
    
    Let src_length be String.length(src)
    
    For i from 0 to (src_length - 1):
        Let char_code be String.char_at(src, i)
        String.set_char_at(dest, i, char_code)
    End For
    
    String.set_length(dest, src_length)
End Process

Process called "append" that takes dest as String, src as String returns Nothing:
    @Implementation
    Appends src string to the end of dest string.
    Extends dest string as needed.
    @End Implementation
    
    Let dest_length be String.length(dest)
    Let src_length be String.length(src)
    
    For i from 0 to (src_length - 1):
        Let char_code be String.char_at(src, i)
        String.set_char_at(dest, dest_length + i, char_code)
    End For
    
    String.set_length(dest, dest_length + src_length)
End Process

Process called "append_integer" that takes dest as String, value as Integer returns Nothing:
    @Implementation
    Appends the string representation of an integer to dest string.
    Converts integer to decimal string representation.
    @End Implementation
    
    Note: Handle negative numbers
    Let working_value be value
    Let is_negative be false
    If value is less than 0:
        Set is_negative to true
        Set working_value to (0 - value)
    End If
    
    Note: Convert to string by extracting digits
    Let digit_buffer be Array[20] of Integer8  Note: Enough for 64-bit integer
    Let digit_count be 0
    
    If working_value equals 0:
        Set digit_buffer[0] to 48  Note: ASCII '0'
        Set digit_count to 1
    Otherwise:
        While working_value is greater than 0:
            Let digit be (working_value mod 10)
            Set digit_buffer[digit_count] to (48 + digit)  Note: Convert to ASCII
            Set working_value to (working_value / 10)
            Set digit_count to (digit_count + 1)
        End While
    End If
    
    Note: Add negative sign if needed
    If is_negative:
        String.append_char(dest, 45)  Note: ASCII '-'
    End If
    
    Note: Append digits in reverse order (they were collected backwards)
    For i from (digit_count - 1) down to 0:
        String.append_char(dest, digit_buffer[i])
    End For
End Process

Process called "append_char" that takes dest as String, char_code as Integer returns Nothing:
    @Implementation
    Appends a single character to the end of dest string.
    @End Implementation
    
    Let dest_length be String.length(dest)
    String.set_char_at(dest, dest_length, char_code)
    String.set_length(dest, dest_length + 1)
End Process

Process called "set_char_at" that takes str as String, index as Integer, char_code as Integer returns Nothing:
    @Implementation
    Sets the character at the specified index to the given character code.
    Uses direct memory access through the string's data pointer with bounds validation.
    @End Implementation
    
    Note: Validate index bounds against string length
    Let str_length be length(str)
    If index is less than 0 or index is greater than or equal to str_length:
        Return Note: Invalid index - no modification performed
    End If
    
    Note: Calculate character data offset (skip length field)
    Let data_offset be 8
    Let char_address be (str + data_offset + index)
    
    Note: Store character at calculated position
    Inline Assembly:
        "mov rsi, %0\n"             Note: Load character address
        "mov al, %1\n"              Note: Load character code
        "mov byte ptr [rsi], al\n"  Note: Store character at position
        :
        : "r"(char_address), "r"(char_code)
        : "rsi", "al", "memory"
    End Assembly
End Process

Note: =====================================================================
Note: STRING QUERY OPERATIONS
Note: =====================================================================

Process called "length" that takes str as String returns Integer:
    @Implementation
    Returns the length of the string in characters.
    @End Implementation
    
    Let result be 0
    Inline Assembly:
        "mov rsi, %1\n"             Note: Load string pointer
        "mov %0, qword ptr [rsi]\n" Note: Length is stored at beginning
        : "=r"(result)
        : "r"(str)
        : "rsi", "memory"
    End Assembly
    Return result
End Process

Process called "char_at" that takes str as String, index as Integer returns Integer:
    @Implementation
    Returns the character code at the specified index.
    @End Implementation
    
    Let result be 0
    Inline Assembly:
        "mov rsi, %1\n"             Note: Load string pointer
        "add rsi, 8\n"              Note: Skip length field
        "mov rdi, %2\n"             Note: Load index
        "movzx eax, byte ptr [rsi + rdi]\n" Note: Load character at index
        "mov %0, eax\n"             Note: Return character code
        : "=r"(result)
        : "r"(str), "r"(index)
        : "rsi", "rdi", "eax", "memory"
    End Assembly
    Return result
End Process

Process called "create_with_capacity" that takes capacity as Integer returns String:
    @Implementation
    Creates a new string with specified character capacity.
    @End Implementation
    
    Let result be 0
    Inline Assembly:
        "mov rdi, %1\n"             Note: Load capacity parameter
        "add rdi, 8\n"              Note: Add space for length field
        "call malloc\n"             Note: Allocate memory
        "mov qword ptr [rax], 0\n"  Note: Initialize length to 0
        "mov %0, rax\n"             Note: Return string pointer
        : "=r"(result)
        : "r"(capacity)
        : "rdi", "rax", "memory"
    End Assembly
    Return result
End Process

Process called "set_length" that takes str as String, new_length as Integer returns Nothing:
    @Implementation
    Sets the length field of the string.
    @End Implementation
    
    Inline Assembly:
        "mov rsi, %0\n"             Note: Load string pointer
        "mov rdi, %1\n"             Note: Load new length
        "mov qword ptr [rsi], rdi\n" Note: Store new length at beginning
        :
        : "r"(str), "r"(new_length)
        : "rsi", "rdi", "memory"
    End Assembly
End Process