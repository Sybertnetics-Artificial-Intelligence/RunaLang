Note:
comparison_core.runa - Zero-Dependency Comparison Operation Primitives

This module provides unified comparison operations across all types.
These primitives have ZERO dependencies and compile to direct CPU comparison instructions.

@Reasoning:
- Provides generic comparison interface for all comparable types
- All operations use inline assembly for true self-hosting
- No external dependencies - we generate the machine code directly
- Supports signed, unsigned, and floating-point comparisons

@Implementation:
- Inline Assembly statements using CPU flags
- Branchless comparisons using SETcc instructions
- Type-specific comparison handling at compile time
- Zero-cost abstraction through compile-time dispatch

@Performance_Hints:
- Each operation maps to CMP + SETcc (2 instructions)
- No branching - uses conditional set instructions
- Direct flag register usage
- Highly efficient for conditional logic
:End Note

Note: =====================================================================
Note: EQUALITY COMPARISONS
Note: =====================================================================

Process called "eq" that takes a as Any, b as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "sete %0\n"          Note: Set result if equal
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ne" that takes a as Any, b as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setne %0\n"         Note: Set result if not equal
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "identity" that takes a as Pointer, b as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare pointer addresses
        "sete %0\n"          Note: Set result if identical
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "not_identity" that takes a as Pointer, b as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare pointer addresses
        "setne %0\n"         Note: Set result if not identical
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ORDERED COMPARISONS (Signed)
Note: =====================================================================

Process called "lt" that takes a as Any, b as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setl %0\n"          Note: Set result if less than (signed)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "le" that takes a as Any, b as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setle %0\n"         Note: Set result if less than or equal (signed)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "gt" that takes a as Any, b as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setg %0\n"          Note: Set result if greater than (signed)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ge" that takes a as Any, b as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setge %0\n"         Note: Set result if greater than or equal (signed)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: UNSIGNED COMPARISONS
Note: =====================================================================

Process called "ult" that takes a as Integer, b as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setb %0\n"          Note: Set result if less than (unsigned)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ule" that takes a as Integer, b as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setbe %0\n"         Note: Set result if less than or equal (unsigned)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ugt" that takes a as Integer, b as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "seta %0\n"          Note: Set result if greater than (unsigned)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "uge" that takes a as Integer, b as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare operands
        "setae %0\n"         Note: Set result if greater than or equal (unsigned)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: THREE-WAY COMPARISON
Note: =====================================================================

Process called "cmp" that takes a as Any, b as Any returns Integer:
    Let result be 0
    Inline Assembly:
        "xor %0, %0\n"       Note: Clear result register
        "cmp %1, %2\n"       Note: Compare operands
        "setl cl\n"          Note: Set CL if less than
        "setg ch\n"          Note: Set CH if greater than
        "sub cl, ch\n"       Note: Calculate difference (CL - CH)
        "movsx %0, cl\n"     Note: Sign-extend result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "cl", "ch", "flags"
    End Assembly
    Return result
End Process

Process called "ucmp" that takes a as Integer, b as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        "xor %0, %0\n"       Note: Clear result register
        "cmp %1, %2\n"       Note: Compare operands
        "setb cl\n"          Note: Set CL if below (unsigned)
        "seta ch\n"          Note: Set CH if above (unsigned)
        "sub cl, ch\n"       Note: Calculate difference (CL - CH)
        "movsx %0, cl\n"     Note: Sign-extend result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "cl", "ch", "flags"
    End Assembly
    Return result
End Process

Process called "spaceship" that takes a as Any, b as Any returns Integer:
    Let result be 0
    Inline Assembly:
        "xor %0, %0\n"       Note: Clear result register
        "cmp %1, %2\n"       Note: Compare operands
        "setl cl\n"          Note: Set CL if less than
        "setg ch\n"          Note: Set CH if greater than
        "sub cl, ch\n"       Note: Calculate difference (CL - CH)
        "movsx %0, cl\n"     Note: Sign-extend result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "cl", "ch", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ZERO COMPARISONS
Note: =====================================================================

Process called "is_zero" that takes a as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test if value is zero
        "setz %0\n"          Note: Set result if zero
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "is_not_zero" that takes a as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test if value is zero
        "setnz %0\n"         Note: Set result if not zero
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "is_positive" that takes a as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test if value is positive
        "setg %0\n"          Note: Set result if greater than zero
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "is_negative" that takes a as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test if value is negative
        "sets %0\n"          Note: Set result if sign flag is set
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "is_non_negative" that takes a as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test if value is non-negative
        "setns %0\n"         Note: Set result if sign flag is not set
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "is_non_positive" that takes a as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"      Note: Test if value is non-positive
        "setle %0\n"         Note: Set result if less than or equal to zero
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: RANGE COMPARISONS
Note: =====================================================================

Process called "in_range" that takes val as Any, min as Any, max as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare val with min
        "setge cl\n"         Note: Set CL if val >= min
        "cmp %1, %3\n"       Note: Compare val with max
        "setle ch\n"         Note: Set CH if val <= max
        "and cl, ch\n"       Note: AND both conditions
        "movzx %0, cl\n"     Note: Zero-extend result
        : "=r"(result)
        : "r"(val), "r"(min), "r"(max)
        : "cl", "ch", "flags"
    End Assembly
    Return result
End Process

Process called "in_range_exclusive" that takes val as Any, min as Any, max as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare val with min
        "setg cl\n"          Note: Set CL if val > min
        "cmp %1, %3\n"       Note: Compare val with max
        "setl ch\n"          Note: Set CH if val < max
        "and cl, ch\n"       Note: AND both conditions
        "movzx %0, cl\n"     Note: Zero-extend result
        : "=r"(result)
        : "r"(val), "r"(min), "r"(max)
        : "cl", "ch", "flags"
    End Assembly
    Return result
End Process

Process called "out_of_range" that takes val as Any, min as Any, max as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"       Note: Compare val with min
        "setl cl\n"          Note: Set CL if val < min
        "cmp %1, %3\n"       Note: Compare val with max
        "setg ch\n"          Note: Set CH if val > max
        "or cl, ch\n"        Note: OR both conditions
        "movzx %0, cl\n"     Note: Zero-extend result
        : "=r"(result)
        : "r"(val), "r"(min), "r"(max)
        : "cl", "ch", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: BIT TEST COMPARISONS
Note: =====================================================================

Process called "test_bit" that takes val as Integer, bit as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "bt %1, %2\n"        Note: Test bit at specified position
        "setc %0\n"          Note: Set result if carry flag is set
        : "=r"(result)
        : "r"(val), "r"(bit)
        : "flags"
    End Assembly
    Return result
End Process

Process called "test_any_bit" that takes val as Integer, mask as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %2\n"      Note: Test value against mask
        "setnz %0\n"         Note: Set result if any bits are set
        : "=r"(result)
        : "r"(val), "r"(mask)
        : "flags"
    End Assembly
    Return result
End Process

Process called "test_all_bits" that takes val as Integer, mask as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, %1\n"      Note: Move value to temporary register
        "and rax, %2\n"      Note: AND with mask
        "cmp rax, %2\n"      Note: Compare result with mask
        "sete %0\n"          Note: Set result if all bits are set
        : "=r"(result)
        : "r"(val), "r"(mask)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "test_no_bits" that takes val as Integer, mask as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %2\n"      Note: Test value against mask
        "setz %0\n"          Note: Set result if no bits are set
        : "=r"(result)
        : "r"(val), "r"(mask)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: FLOATING POINT COMPARISONS
Note: =====================================================================

Process called "fcmp_eq" that takes a as Float, b as Float returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "sete %0\n"          Note: Set result if equal
        "setnp cl\n"         Note: Set CL if not parity (not NaN)
        "and %0, cl\n"       Note: AND with parity check
        : "=r"(result)
        : "x"(a), "x"(b)
        : "cl", "flags"
    End Assembly
    Return result
End Process

Process called "fcmp_ne" that takes a as Float, b as Float returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "setne %0\n"         Note: Set result if not equal
        "setp cl\n"          Note: Set CL if parity (NaN)
        "or %0, cl\n"        Note: OR with parity check
        : "=r"(result)
        : "x"(a), "x"(b)
        : "cl", "flags"
    End Assembly
    Return result
End Process

Process called "fcmp_lt" that takes a as Float, b as Float returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "setb %0\n"          Note: Set result if below (less than)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "fcmp_le" that takes a as Float, b as Float returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "setbe %0\n"         Note: Set result if below or equal (less than or equal)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "fcmp_gt" that takes a as Float, b as Float returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "seta %0\n"          Note: Set result if above (greater than)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "fcmp_ge" that takes a as Float, b as Float returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "setae %0\n"         Note: Set result if above or equal (greater than or equal)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "fcmp_ordered" that takes a as Float, b as Float returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "setnp %0\n"         Note: Set result if not parity (both operands are ordered)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "fcmp_unordered" that takes a as Float, b as Float returns Boolean:
    Let result be false
    Inline Assembly:
        "ucomisd %1, %2\n"   Note: Unordered compare scalar double precision
        "setp %0\n"          Note: Set result if parity (at least one operand is NaN)
        : "=r"(result)
        : "x"(a), "x"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: CONDITIONAL MOVE OPERATIONS
Note: =====================================================================

Process called "select_eq" that takes a as Any, b as Any, true_val as Any, false_val as Any returns Any:
    Let result be false_val
    Inline Assembly:
        "mov %0, %4\n"       Note: Initialize result with false_val
        "cmp %1, %2\n"       Note: Compare a and b
        "cmove %0, %3\n"     Note: Conditionally move true_val if equal
        : "=r"(result)
        : "r"(a), "r"(b), "r"(true_val), "r"(false_val)
        : "flags"
    End Assembly
    Return result
End Process

Process called "select_ne" that takes a as Any, b as Any, true_val as Any, false_val as Any returns Any:
    Let result be false_val
    Inline Assembly:
        "mov %0, %4\n"       Note: Initialize result with false_val
        "cmp %1, %2\n"       Note: Compare a and b
        "cmovne %0, %3\n"    Note: Conditionally move true_val if not equal
        : "=r"(result)
        : "r"(a), "r"(b), "r"(true_val), "r"(false_val)
        : "flags"
    End Assembly
    Return result
End Process

Process called "select_lt" that takes a as Any, b as Any, true_val as Any, false_val as Any returns Any:
    Let result be false_val
    Inline Assembly:
        "mov %0, %4\n"       Note: Initialize result with false_val
        "cmp %1, %2\n"       Note: Compare a and b
        "cmovl %0, %3\n"     Note: Conditionally move true_val if less than
        : "=r"(result)
        : "r"(a), "r"(b), "r"(true_val), "r"(false_val)
        : "flags"
    End Assembly
    Return result
End Process

Process called "select_le" that takes a as Any, b as Any, true_val as Any, false_val as Any returns Any:
    Let result be false_val
    Inline Assembly:
        "mov %0, %4\n"       Note: Initialize result with false_val
        "cmp %1, %2\n"       Note: Compare a and b
        "cmovle %0, %3\n"    Note: Conditionally move true_val if less than or equal
        : "=r"(result)
        : "r"(a), "r"(b), "r"(true_val), "r"(false_val)
        : "flags"
    End Assembly
    Return result
End Process

Process called "select_gt" that takes a as Any, b as Any, true_val as Any, false_val as Any returns Any:
    Let result be false_val
    Inline Assembly:
        "mov %0, %4\n"       Note: Initialize result with false_val
        "cmp %1, %2\n"       Note: Compare a and b
        "cmovg %0, %3\n"     Note: Conditionally move true_val if greater than
        : "=r"(result)
        : "r"(a), "r"(b), "r"(true_val), "r"(false_val)
        : "flags"
    End Assembly
    Return result
End Process

Process called "select_ge" that takes a as Any, b as Any, true_val as Any, false_val as Any returns Any:
    Let result be false_val
    Inline Assembly:
        "mov %0, %4\n"       Note: Initialize result with false_val
        "cmp %1, %2\n"       Note: Compare a and b
        "cmovge %0, %3\n"    Note: Conditionally move true_val if greater than or equal
        : "=r"(result)
        : "r"(a), "r"(b), "r"(true_val), "r"(false_val)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ATOMIC COMPARISONS
Note: =====================================================================

Process called "atomic_compare_exchange" that takes ptr as Pointer, expected as Any, desired as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, %2\n"      Note: Load expected value into RAX
        "lock cmpxchg [%1], %3\n" Note: Atomic compare and exchange
        "sete %0\n"          Note: Set result if exchange succeeded
        : "=r"(result)
        : "r"(ptr), "r"(expected), "r"(desired)
        : "rax", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "atomic_compare_exchange_weak" that takes ptr as Pointer, expected as Any, desired as Any returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, %2\n"      Note: Load expected value into RAX
        "lock cmpxchg [%1], %3\n" Note: Atomic compare and exchange (weak variant)
        "sete %0\n"          Note: Set result if exchange succeeded
        : "=r"(result)
        : "r"(ptr), "r"(expected), "r"(desired)
        : "rax", "memory", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: STRING/MEMORY COMPARISONS
Note: =====================================================================

Process called "mem_eq" that takes a as Pointer, b as Pointer, size as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rcx, %3\n"      Note: Load size into RCX
        "mov rdi, %1\n"      Note: Load first pointer into RDI
        "mov rsi, %2\n"      Note: Load second pointer into RSI
        "repe cmpsb\n"       Note: Repeat compare strings byte by byte
        "setz %0\n"          Note: Set result if all bytes were equal
        : "=r"(result)
        : "r"(a), "r"(b), "r"(size)
        : "rcx", "rdi", "rsi", "flags", "memory"
    End Assembly
    Return result
End Process

Process called "mem_ne" that takes a as Pointer, b as Pointer, size as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rcx, %3\n"      Note: Load size into RCX
        "mov rdi, %1\n"      Note: Load first pointer into RDI
        "mov rsi, %2\n"      Note: Load second pointer into RSI
        "repe cmpsb\n"       Note: Repeat compare strings byte by byte
        "setnz %0\n"         Note: Set result if any bytes were different
        : "=r"(result)
        : "r"(a), "r"(b), "r"(size)
        : "rcx", "rdi", "rsi", "flags", "memory"
    End Assembly
    Return result
End Process

Process called "mem_lt" that takes a as Pointer, b as Pointer, size as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rcx, %3\n"      Note: Load size into RCX
        "mov rdi, %1\n"      Note: Load first pointer into RDI
        "mov rsi, %2\n"      Note: Load second pointer into RSI
        "repe cmpsb\n"       Note: Repeat compare strings byte by byte
        "setb %0\n"          Note: Set result if first string is less than second
        : "=r"(result)
        : "r"(a), "r"(b), "r"(size)
        : "rcx", "rdi", "rsi", "flags", "memory"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: SPECIAL COMPARISONS
Note: =====================================================================

Process called "is_power_of_two" that takes a as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rcx, %1\n"      Note: Load value into RCX
        "lea rax, [rcx-1]\n" Note: Calculate value - 1
        "test rax, rcx\n"    Note: Test (value-1) & value
        "setz %0\n"          Note: Set result if zero (power of two property)
        "test rcx, rcx\n"    Note: Test if original value is zero
        "setnz cl\n"         Note: Set CL if not zero
        "and %0, cl\n"       Note: AND with non-zero check
        : "=r"(result)
        : "r"(a)
        : "rcx", "rax", "cl", "flags"
    End Assembly
    Return result
End Process

Process called "is_aligned" that takes ptr as Pointer, alignment as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, %1\n"      Note: Load pointer into RAX
        "dec %2\n"           Note: Decrement alignment to create mask
        "test rax, %2\n"     Note: Test pointer against alignment mask
        "setz %0\n"          Note: Set result if aligned (mask bits are zero)
        : "=r"(result)
        : "r"(ptr), "r"(alignment)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "same_sign" that takes a as Integer, b as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, %1\n"      Note: Load first value
        "xor rax, %2\n"      Note: XOR with second value
        "test rax, rax\n"    Note: Test XOR result
        "setns %0\n"         Note: Set result if sign flag not set (same sign)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "opposite_sign" that takes a as Integer, b as Integer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, %1\n"      Note: Load first value
        "xor rax, %2\n"      Note: XOR with second value
        "test rax, rax\n"    Note: Test XOR result
        "sets %0\n"          Note: Set result if sign flag is set (opposite signs)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "flags"
    End Assembly
    Return result
End Process