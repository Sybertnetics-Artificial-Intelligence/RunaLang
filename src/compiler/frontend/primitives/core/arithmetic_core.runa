Note:
arithmetic_core.runa - Zero-Dependency Arithmetic Operation Primitives

This module provides unified arithmetic operations across all numeric types.
These primitives have ZERO dependencies and compile to type-specific machine instructions.

@Reasoning:
- Provides generic arithmetic interface that dispatches to type-specific implementations
- All operations use inline assembly for true self-hosting
- No external dependencies - we generate the machine code directly
- Supports integer and floating-point arithmetic uniformly

@Implementation:
- Inline Assembly statements with type-based instruction selection
- Compiler selects appropriate instruction based on operand types
- Overflow/underflow behavior is architecture-defined (no checks)
- Zero-cost abstraction through compile-time dispatch

@Performance_Hints:
- Each operation maps to 1-3 CPU instructions
- Type dispatch resolved at compile time
- No runtime overhead for generic interface
- Direct CPU arithmetic unit usage
:End Note

Note: =====================================================================
Note: GENERIC ADDITION OPERATIONS
Note: =====================================================================

Process called "add" that takes a as Any, b as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "add %0, %2\n"        Note: Add second operand to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "add_wrap" that takes a as Any, b as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "add %0, %2\n"        Note: Add second operand with wrapping
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "add_sat" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "add %0, %2\n"        Note: Add second operand
        "cmovo %0, %3\n"       Note: Saturate to max value on overflow
        : "=r"(result)
        : "r"(a), "r"(b), "i"(0x7FFFFFFF)
        : "flags"
    End Assembly
    Return result
End Process

Process called "add_carry" that takes a as Integer, b as Integer, carry as Boolean returns Integer:
    Let result as Integer
    Inline Assembly:
        "bt %3, 0\n"          Note: Test carry bit
        "adc %1, %2\n"        Note: Add with carry
        "mov %0, %1\n"        Note: Move result to output
        : "=r"(result)
        : "r"(a), "r"(b), "r"(carry)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: GENERIC SUBTRACTION OPERATIONS
Note: =====================================================================

Process called "sub" that takes a as Any, b as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "sub %0, %2\n"        Note: Subtract second operand from result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "sub_wrap" that takes a as Any, b as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "sub %0, %2\n"        Note: Subtract second operand with wrapping
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "sub_sat" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "sub %0, %2\n"        Note: Subtract second operand
        "cmovo %0, %3\n"       Note: Saturate to zero on underflow
        : "=r"(result)
        : "r"(a), "r"(b), "i"(0)
        : "flags"
    End Assembly
    Return result
End Process

Process called "sub_borrow" that takes a as Integer, b as Integer, borrow as Boolean returns Integer:
    Let result as Integer
    Inline Assembly:
        "bt %3, 0\n"          Note: Test borrow bit
        "sbb %1, %2\n"        Note: Subtract with borrow
        "mov %0, %1\n"        Note: Move result to output
        : "=r"(result)
        : "r"(a), "r"(b), "r"(borrow)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: GENERIC MULTIPLICATION OPERATIONS
Note: =====================================================================

Process called "mul" that takes a as Any, b as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "imul %0, %2\n"       Note: Signed multiply with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "mul_wrap" that takes a as Any, b as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "imul %0, %2\n"       Note: Signed multiply with wrapping
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "mul_high" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result as Integer64
    Inline Assembly:
        "mov rax, %1\n"       Note: Move first operand to RAX
        "imul %2\n"           Note: Multiply with second operand
        "mov %0, rdx\n"       Note: Move high 64 bits to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "mul_wide" that takes a as Integer32, b as Integer32 returns Integer64:
    Let result as Integer64
    Inline Assembly:
        "movsxd rax, %1\n"    Note: Sign extend first operand to 64-bit
        "movsxd rcx, %2\n"    Note: Sign extend second operand to 64-bit
        "imul rax, rcx\n"     Note: Multiply 64-bit values
        "mov %0, rax\n"       Note: Move result to output
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "umul" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"       Note: Move first operand to RAX
        "mul %2\n"            Note: Unsigned multiply with second operand
        "mov %0, rax\n"       Note: Move low result to output
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "umul_high" that takes a as Integer64, b as Integer64 returns Integer64:
    Let result as Integer64
    Inline Assembly:
        "mov rax, %1\n"       Note: Move first operand to RAX
        "mul %2\n"            Note: Unsigned multiply with second operand
        "mov %0, rdx\n"       Note: Move high 64 bits to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: GENERIC DIVISION OPERATIONS
Note: =====================================================================

Process called "div" that takes a as Any, b as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov rax, %1\n"       Note: Move dividend to RAX
        "cqo\n"               Note: Sign extend RAX to RDX:RAX
        "idiv %2\n"           Note: Signed divide by divisor
        "mov %0, rax\n"       Note: Move quotient to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "div_exact" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"       Note: Move dividend to RAX
        "cqo\n"               Note: Sign extend RAX to RDX:RAX
        "idiv %2\n"           Note: Exact signed divide by divisor
        "mov %0, rax\n"       Note: Move quotient to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "div_trunc" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"       Note: Move dividend to RAX
        "cqo\n"               Note: Sign extend RAX to RDX:RAX
        "idiv %2\n"           Note: Truncating signed divide by divisor
        "mov %0, rax\n"       Note: Move quotient to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "div_floor" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"       Note: Move dividend to RAX
        "cqo\n"               Note: Sign extend RAX to RDX:RAX
        "idiv %2\n"           Note: Signed divide by divisor
        "test rdx, rdx\n"     Note: Check if remainder is zero
        "jz 1f\n"             Note: Jump if no remainder
        "xor rax, %2\n"       Note: XOR quotient with divisor
        "js 2f\n"             Note: Jump if signs differ
        "1: mov %0, rax\n"    Note: Move quotient to result
        "jmp 3f\n"            Note: Jump to end
        "2: dec rax\n"        Note: Decrement for floor division
        "mov %0, rax\n"       Note: Move adjusted result
        "3:\n"                Note: End label
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "div_ceil" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"       Note: Move dividend to RAX
        "cqo\n"               Note: Sign extend RAX to RDX:RAX
        "idiv %2\n"           Note: Signed divide by divisor
        "test rdx, rdx\n"     Note: Check if remainder is zero
        "jz 1f\n"             Note: Jump if no remainder
        "xor rax, %2\n"       Note: XOR quotient with divisor
        "jns 2f\n"            Note: Jump if signs same
        "1: mov %0, rax\n"    Note: Move quotient to result
        "jmp 3f\n"            Note: Jump to end
        "2: inc rax\n"        Note: Increment for ceiling division
        "mov %0, rax\n"       Note: Move adjusted result
        "3:\n"                Note: End label
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "udiv" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"       Note: Move dividend to RAX
        "xor rdx, rdx\n"      Note: Clear high 64 bits
        "div %2\n"            Note: Unsigned divide by divisor
        "mov %0, rax\n"       Note: Move quotient to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: GENERIC REMAINDER/MODULO OPERATIONS
Note: =====================================================================

Process called "rem" that takes a as Any, b as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov rax, %1\n"       Note: Move dividend to RAX
        "cqo\n"               Note: Sign extend RAX to RDX:RAX
        "idiv %2\n"           Note: Signed divide by divisor
        "mov %0, rdx\n"       Note: Move remainder to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "mod" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"       Note: Move dividend to RAX
        "cqo\n"               Note: Sign extend RAX to RDX:RAX
        "idiv %2\n"           Note: Signed divide by divisor
        "test rdx, rdx\n"     Note: Check if remainder is zero
        "jz 1f\n"             Note: Jump if remainder is zero
        "xor rdx, %2\n"       Note: XOR remainder with divisor
        "jns 1f\n"            Note: Jump if signs same
        "add rdx, %2\n"       Note: Adjust remainder for modulo
        "1: mov %0, rdx\n"    Note: Move remainder to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "rem_euclid" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"       Note: Move dividend to RAX
        "cqo\n"               Note: Sign extend RAX to RDX:RAX
        "idiv %2\n"           Note: Signed divide by divisor
        "test rdx, rdx\n"     Note: Check remainder sign
        "jns 1f\n"            Note: Jump if remainder non-negative
        "add rdx, %2\n"       Note: Make remainder positive (Euclidean)
        "1: mov %0, rdx\n"    Note: Move remainder to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Process called "urem" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"       Note: Move dividend to RAX
        "xor rdx, rdx\n"      Note: Clear high 64 bits
        "div %2\n"            Note: Unsigned divide by divisor
        "mov %0, rdx\n"       Note: Move remainder to result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "rdx", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: NEGATION AND ABSOLUTE VALUE
Note: =====================================================================

Process called "neg" that takes a as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move operand to result register
        "neg %0\n"            Note: Negate the value
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "abs" that takes a as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move operand to result register
        "test %0, %0\n"       Note: Test if value is negative
        "jns 1f\n"            Note: Jump if not negative
        "neg %0\n"            Note: Negate if negative
        "1:\n"                Note: End label
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "sign" that takes a as Any returns Integer:
    Let result as Integer
    Inline Assembly:
        "xor %0, %0\n"        Note: Clear result register
        "test %1, %1\n"       Note: Test if value is zero
        "jz 1f\n"             Note: Jump if zero
        "sets cl\n"           Note: Set CL if negative
        "movzx %0, cl\n"      Note: Zero-extend to result
        "lea %0, [%0*2-1]\n"  Note: Convert to -1/+1
        "1:\n"                Note: End label
        : "=r"(result)
        : "r"(a)
        : "cl", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: POWER OPERATIONS
Note: =====================================================================

Process called "pow2" that takes exp as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov %0, 1\n"         Note: Load value 1 into result
        "shl %0, %1\n"        Note: Shift left by exponent (2^exp)
        : "=r"(result)
        : "r"(exp)
        : "flags"
    End Assembly
    Return result
End Process

Process called "is_pow2" that takes a as Integer returns Boolean:
    Let result as Boolean
    Inline Assembly:
        "mov rcx, %1\n"       Note: Move value to temporary register
        "lea rax, [rcx-1]\n"  Note: Calculate value-1
        "test rax, rcx\n"     Note: Test (value-1) & value
        "setz %0\n"           Note: Set result if zero (power of 2)
        : "=r"(result)
        : "r"(a)
        : "rax", "rcx", "flags"
    End Assembly
    Return result
End Process

Process called "next_pow2" that takes a as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "bsr rcx, %1\n"       Note: Find highest set bit
        "jz 1f\n"             Note: Jump if value is zero
        "mov %0, 2\n"         Note: Start with base value 2
        "shl %0, cl\n"        Note: Shift to get 2^(bit+1)
        "cmp %0, %1\n"        Note: Compare with input
        "ja 2f\n"             Note: Jump if already greater
        "shl %0, 1\n"         Note: Double if equal
        "jmp 2f\n"            Note: Jump to end
        "1: mov %0, 1\n"      Note: Return 1 if input was 0
        "2:\n"                Note: End label
        : "=r"(result)
        : "r"(a)
        : "rcx", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: MIN/MAX OPERATIONS
Note: =====================================================================

Process called "min" that takes a as Any, b as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result
        "cmp %0, %2\n"        Note: Compare with second operand
        "cmovg %0, %2\n"      Note: Move second if first is greater
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "max" that takes a as Any, b as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result
        "cmp %0, %2\n"        Note: Compare with second operand
        "cmovl %0, %2\n"      Note: Move second if first is less
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "clamp" that takes val as Any, min as Any, max as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result
        "cmp %0, %2\n"        Note: Compare with minimum
        "cmovl %0, %2\n"      Note: Use min if value < min
        "cmp %0, %3\n"        Note: Compare with maximum
        "cmovg %0, %3\n"      Note: Use max if value > max
        : "=r"(result)
        : "r"(val), "r"(min), "r"(max)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: INCREMENT/DECREMENT OPERATIONS
Note: =====================================================================

Process called "inc" that takes a as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move operand to result register
        "inc %0\n"            Note: Increment the value
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "dec" that takes a as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move operand to result register
        "dec %0\n"            Note: Decrement the value
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "pre_inc" that takes ptr as Pointer returns Any:
    Let result as Any
    Inline Assembly:
        "inc qword [%1]\n"    Note: Increment value at pointer
        "mov [%1], %0\n"      Note: Load incremented value
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "post_inc" that takes ptr as Pointer returns Any:
    Let result as Any
    Inline Assembly:
        "mov [%1], %0\n"      Note: Load current value
        "inc qword [%1]\n"    Note: Increment value at pointer
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "pre_dec" that takes ptr as Pointer returns Any:
    Let result as Any
    Inline Assembly:
        "dec qword [%1]\n"    Note: Decrement value at pointer
        "mov [%1], %0\n"      Note: Load decremented value
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "post_dec" that takes ptr as Pointer returns Any:
    Let result as Any
    Inline Assembly:
        "mov [%1], %0\n"      Note: Load current value
        "dec qword [%1]\n"    Note: Decrement value at pointer
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: FUSED OPERATIONS
Note: =====================================================================

Process called "add_mul" that takes a as Any, b as Any, c as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result
        "add %0, %2\n"        Note: Add second operand
        "imul %0, %3\n"       Note: Multiply by third operand
        : "=r"(result)
        : "r"(a), "r"(b), "r"(c)
        : "flags"
    End Assembly
    Return result
End Process

Process called "mul_add" that takes a as Any, b as Any, c as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result
        "imul %0, %2\n"       Note: Multiply by second operand
        "add %0, %3\n"        Note: Add third operand
        : "=r"(result)
        : "r"(a), "r"(b), "r"(c)
        : "flags"
    End Assembly
    Return result
End Process

Process called "mul_sub" that takes a as Any, b as Any, c as Any returns Any:
    Let result as Any
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result
        "imul %0, %2\n"       Note: Multiply by second operand
        "sub %0, %3\n"        Note: Subtract third operand
        : "=r"(result)
        : "r"(a), "r"(b), "r"(c)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: CHECKED ARITHMETIC (sets flags for overflow detection)
Note: =====================================================================

Process called "add_overflow" that takes a as Integer, b as Integer, overflow as Pointer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result
        "add %0, %2\n"        Note: Add second operand
        "seto byte [%3]\n"    Note: Set overflow flag in memory
        : "=r"(result)
        : "r"(a), "r"(b), "r"(overflow)
        : "flags", "memory"
    End Assembly
    Return result
End Process

Process called "sub_overflow" that takes a as Integer, b as Integer, overflow as Pointer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result
        "sub %0, %2\n"        Note: Subtract second operand
        "seto byte [%3]\n"    Note: Set overflow flag in memory
        : "=r"(result)
        : "r"(a), "r"(b), "r"(overflow)
        : "flags", "memory"
    End Assembly
    Return result
End Process

Process called "mul_overflow" that takes a as Integer, b as Integer, overflow as Pointer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result
        "imul %0, %2\n"       Note: Multiply by second operand
        "seto byte [%3]\n"    Note: Set overflow flag in memory
        : "=r"(result)
        : "r"(a), "r"(b), "r"(overflow)
        : "flags", "memory"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ATOMIC ARITHMETIC OPERATIONS
Note: =====================================================================

Process called "atomic_fetch_add" that takes ptr as Pointer, val as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "lock xadd [%1], %2\n" Note: Atomic exchange and add
        "mov %2, %0\n"        Note: Move original value to result
        : "=r"(result)
        : "r"(ptr), "r"(val)
        : "memory"
    End Assembly
    Return result
End Process

Process called "atomic_fetch_sub" that takes ptr as Pointer, val as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "neg %2\n"            Note: Negate value for subtraction
        "lock xadd [%1], %2\n" Note: Atomic exchange and add (subtract)
        "mov %2, %0\n"        Note: Move original value to result
        : "=r"(result)
        : "r"(ptr), "r"(val)
        : "memory"
    End Assembly
    Return result
End Process

Process called "atomic_inc" that takes ptr as Pointer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov %0, 1\n"         Note: Load increment value
        "lock xadd [%1], %0\n" Note: Atomic exchange and add
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "atomic_dec" that takes ptr as Pointer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov %0, -1\n"        Note: Load decrement value
        "lock xadd [%1], %0\n" Note: Atomic exchange and add (subtract)
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process