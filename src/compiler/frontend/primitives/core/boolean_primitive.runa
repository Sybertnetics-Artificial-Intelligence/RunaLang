Note:
boolean_primitive.runa - Zero-Dependency Boolean Primitives

This module provides the foundational boolean operations that map directly to CPU flag operations.
These primitives have ZERO dependencies and compile to 1-3 machine instructions maximum.

@Reasoning:
- All operations use inline assembly for true self-hosting
- No external dependencies - we generate the machine code directly
- Boolean values represented as 0 (false) and 1 (true) in a byte
- Operations map to CPU flag register manipulations

@Implementation:
- Inline Assembly statements define exact CPU instructions
- Compiler replaces %[param] placeholders with register allocations
- Uses x86_64 flag operations and conditional moves
- Zero-cost abstraction over raw assembly

@Performance_Hints:
- Each operation maps to 1-3 CPU instructions
- No branching - uses conditional moves where possible
- Direct flag register operations
- Byte-sized operations for memory efficiency
:End Note

Note: =====================================================================
Note: CORE BOOLEAN OPERATIONS
Note: =====================================================================

Process called "bool_and" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "and %0, %2\n"        Note: Boolean AND with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_or" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "or %0, %2\n"         Note: Boolean OR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_xor" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "xor %0, %2\n"        Note: Boolean XOR with second operand
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_not" that takes a as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %1, %0\n"        Note: Move operand to result register
        "xor %0, 1\n"         Note: Boolean NOT by XORing with 1
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_nand" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "and %0, %2\n"        Note: Boolean AND with second operand
        "xor %0, 1\n"         Note: Invert result for NAND
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_nor" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "or %0, %2\n"         Note: Boolean OR with second operand
        "xor %0, 1\n"         Note: Invert result for NOR
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_xnor" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "xor %0, %2\n"        Note: Boolean XOR with second operand
        "xor %0, 1\n"         Note: Invert result for XNOR
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_implies" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %1, %0\n"        Note: Move first operand to result register
        "xor %0, 1\n"         Note: NOT first operand
        "or %0, %2\n"         Note: OR with second operand (A implies B = NOT A OR B)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: COMPARISON OPERATIONS
Note: =====================================================================

Process called "bool_eq" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"        Note: Compare boolean values
        "sete %0\n"           Note: Set result if equal
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_ne" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"        Note: Compare boolean values
        "setne %0\n"          Note: Set result if not equal
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_lt" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"        Note: Compare boolean values
        "setb %0\n"           Note: Set result if a < b (unsigned)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_le" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"        Note: Compare boolean values
        "setbe %0\n"          Note: Set result if a <= b (unsigned)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_gt" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"        Note: Compare boolean values
        "seta %0\n"           Note: Set result if a > b (unsigned)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_ge" that takes a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"        Note: Compare boolean values
        "setae %0\n"          Note: Set result if a >= b (unsigned)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: CONDITIONAL OPERATIONS (branchless)
Note: =====================================================================

Process called "bool_select" that takes cond as Boolean, true_val as Boolean, false_val as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %3, %0\n"        Note: Start with false_val in result
        "test %1, %1\n"       Note: Test condition
        "cmovnz %0, %2\n"     Note: Move true_val if condition is non-zero
        : "=r"(result)
        : "r"(cond), "r"(true_val), "r"(false_val)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_mux" that takes sel as Boolean, a as Boolean, b as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %3, %0\n"        Note: Start with b in result
        "test %1, %1\n"       Note: Test selector
        "cmovnz %0, %2\n"     Note: Move a if selector is non-zero
        : "=r"(result)
        : "r"(sel), "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: CONVERSION OPERATIONS
Note: =====================================================================

Process called "bool_to_i8" that takes a as Boolean returns Integer8:
    Let result be 0
    Inline Assembly:
        "movzx %0, %1\n"      Note: Zero-extend boolean to 8-bit integer
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "bool_to_i16" that takes a as Boolean returns Integer16:
    Let result be 0
    Inline Assembly:
        "movzx %0, %1\n"      Note: Zero-extend boolean to 16-bit integer
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "bool_to_i32" that takes a as Boolean returns Integer32:
    Let result be 0
    Inline Assembly:
        "movzx %0, %1\n"      Note: Zero-extend boolean to 32-bit integer
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "bool_to_i64" that takes a as Boolean returns Integer64:
    Let result be 0
    Inline Assembly:
        "movzx %0, %1\n"      Note: Zero-extend boolean to 64-bit integer
        : "=r"(result)
        : "r"(a)
        :
    End Assembly
    Return result
End Process

Process called "i8_to_bool" that takes a as Integer8 returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"       Note: Test if value is non-zero
        "setne %0\n"          Note: Set result if not equal to zero
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "i16_to_bool" that takes a as Integer16 returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"       Note: Test if value is non-zero
        "setne %0\n"          Note: Set result if not equal to zero
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "i32_to_bool" that takes a as Integer32 returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"       Note: Test if value is non-zero
        "setne %0\n"          Note: Set result if not equal to zero
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "i64_to_bool" that takes a as Integer64 returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"       Note: Test if value is non-zero
        "setne %0\n"          Note: Set result if not equal to zero
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ptr_to_bool" that takes a as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"       Note: Test if pointer is non-null
        "setne %0\n"          Note: Set result if not equal to zero
        : "=r"(result)
        : "r"(a)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: BIT MANIPULATION FOR BOOLEANS
Note: =====================================================================

Process called "bool_set_bit" that takes val as Boolean, bit as Integer8 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "bts %0, %2\n"        Note: Set bit at specified position
        : "=r"(result)
        : "r"(val), "r"(bit)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_clear_bit" that takes val as Boolean, bit as Integer8 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "btr %0, %2\n"        Note: Clear bit at specified position
        : "=r"(result)
        : "r"(val), "r"(bit)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_toggle_bit" that takes val as Boolean, bit as Integer8 returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %1, %0\n"        Note: Move value to result register
        "btc %0, %2\n"        Note: Toggle bit at specified position
        : "=r"(result)
        : "r"(val), "r"(bit)
        : "flags"
    End Assembly
    Return result
End Process

Process called "bool_test_bit" that takes val as Boolean, bit as Integer8 returns Boolean:
    Let result be false
    Inline Assembly:
        "bt %1, %2\n"         Note: Test bit at specified position
        "setc %0\n"           Note: Set result if carry flag is set
        : "=r"(result)
        : "r"(val), "r"(bit)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: SPECIAL VALUES
Note: =====================================================================

Process called "bool_true" returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %0, 1\n"         Note: Load boolean true value
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "bool_false" returns Boolean:
    Let result be false
    Inline Assembly:
        "xor %0, %0\n"        Note: Clear register to boolean false
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ATOMIC BOOLEAN OPERATIONS
Note: =====================================================================

Process called "atomic_bool_load" that takes ptr as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov [%1], %0\n"      Note: Atomic load from memory
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "atomic_bool_store" that takes ptr as Pointer, val as Boolean:
    Inline Assembly:
        "mov [%0], %1\n"      Note: Atomic store to memory
        :
        : "r"(ptr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "atomic_bool_exchange" that takes ptr as Pointer, val as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov %2, %0\n"        Note: Copy val to result
        "xchg [%1], %0\n"     Note: Atomic exchange with memory
        : "=r"(result)
        : "r"(ptr), "r"(val)
        : "memory"
    End Assembly
    Return result
End Process

Process called "atomic_bool_cas" that takes ptr as Pointer, expected as Boolean, desired as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov al, %1\n"        Note: Load expected value to AL
        "lock cmpxchg [%1], %3\n" Note: Atomic compare and exchange
        "sete %0\n"           Note: Set result if exchange succeeded
        : "=r"(result)
        : "r"(ptr), "r"(expected), "r"(desired)
        : "al", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "atomic_bool_fetch_and" that takes ptr as Pointer, val as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov al, [%1]\n"      Note: Load current value
        "mov %0, al\n"        Note: Store original value in result
        "and al, %2\n"        Note: AND with new value
        "lock cmpxchg [%1], al\n" Note: Atomic compare and exchange
        : "=r"(result)
        : "r"(ptr), "r"(val)
        : "al", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "atomic_bool_fetch_or" that takes ptr as Pointer, val as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov al, [%1]\n"      Note: Load current value
        "mov %0, al\n"        Note: Store original value in result
        "or al, %2\n"         Note: OR with new value
        "lock cmpxchg [%1], al\n" Note: Atomic compare and exchange
        : "=r"(result)
        : "r"(ptr), "r"(val)
        : "al", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "atomic_bool_fetch_xor" that takes ptr as Pointer, val as Boolean returns Boolean:
    Let result be false
    Inline Assembly:
        "mov al, [%1]\n"      Note: Load current value
        "mov %0, al\n"        Note: Store original value in result
        "xor al, %2\n"        Note: XOR with new value
        "lock cmpxchg [%1], al\n" Note: Atomic compare and exchange
        : "=r"(result)
        : "r"(ptr), "r"(val)
        : "al", "memory", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: FLAG REGISTER OPERATIONS
Note: =====================================================================

Process called "get_carry_flag" returns Boolean:
    Let result be false
    Inline Assembly:
        "setc %0\n"         Note: Set result if carry flag is set
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Process called "get_zero_flag" returns Boolean:
    Let result be false
    Inline Assembly:
        "setz %0\n"         Note: Set result if zero flag is set
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Process called "get_sign_flag" returns Boolean:
    Let result be false
    Inline Assembly:
        "sets %0\n"         Note: Set result if sign flag is set
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Process called "get_overflow_flag" returns Boolean:
    Let result be false
    Inline Assembly:
        "seto %0\n"         Note: Set result if overflow flag is set
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Process called "get_parity_flag" returns Boolean:
    Let result be false
    Inline Assembly:
        "setp %0\n"         Note: Set result if parity flag is set
        : "=r"(result)
        :
        : "flags"
    End Assembly
    Return result
End Process

Process called "set_carry_flag" that takes val as Boolean:
    Inline Assembly:
        "test %0, %0\n"      Note: Test if value is non-zero
        "jz 1f\n"            Note: Jump if zero to clear carry
        "stc\n"              Note: Set carry flag
        "jmp 2f\n"           Note: Jump to end
        "1: clc\n"           Note: Clear carry flag
        "2:\n"               Note: End label
        :
        : "r"(val)
        : "flags"
    End Assembly
End Process

Process called "clear_carry_flag":
    Inline Assembly:
        "clc\n"              Note: Clear carry flag
        :
        :
        : "flags"
    End Assembly
End Process

Process called "complement_carry_flag":
    Inline Assembly:
        "cmc\n"              Note: Complement carry flag
        :
        :
        : "flags"
    End Assembly
End Process