Note:
pointer_primitive.runa - Zero-Dependency Pointer Primitives

This module provides the foundational pointer operations that map directly to memory addressing instructions.
These primitives have ZERO dependencies and compile to 1-3 machine instructions maximum.

@Reasoning:
- All operations use inline assembly for true self-hosting  
- No external dependencies - we generate the machine code directly
- Raw memory operations without safety checks
- Support for all pointer arithmetic and dereferencing

@Implementation:
- Inline Assembly statements define exact memory instructions
- Compiler replaces %[param] placeholders with register allocations
- Uses x86_64 addressing modes (can be adapted for ARM64)
- Zero-cost abstraction over raw assembly

@Performance_Hints:
- Each operation maps to 1-3 CPU instructions
- Direct memory addressing with no overhead
- Efficient pointer arithmetic using LEA instruction
- No bounds checking or validation
:End Note

Note: =====================================================================
Note: CORE POINTER OPERATIONS
Note: =====================================================================

Process called "ptr_load" that takes ptr as Pointer returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, qword ptr [%1]\n"      Note: Load pointer value from memory
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "ptr_store" that takes ptr as Pointer, val as Pointer:
    Inline Assembly:
        "mov qword ptr [%0], %1\n"      Note: Store pointer value to memory
        :
        : "r"(ptr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "ptr_offset" that takes base as Pointer, offset as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + %2]\n"           Note: Load effective address with offset
        : "=r"(result)
        : "r"(base), "r"(offset)
        :
    End Assembly
    Return result
End Process

Process called "ptr_add" that takes ptr as Pointer, offset as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "lea %0, [%1 + %2]\n"           Note: Add offset to pointer using LEA
        : "=r"(result)
        : "r"(ptr), "r"(offset)
        :
    End Assembly
    Return result
End Process

Process called "ptr_sub" that takes ptr as Pointer, offset as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"              Note: Copy pointer to result
        "sub %0, %2\n"              Note: Subtract offset from pointer
        : "=r"(result)
        : "r"(ptr), "r"(offset)
        :
    End Assembly
    Return result
End Process

Process called "ptr_diff" that takes a as Pointer, b as Pointer returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"              Note: Copy first pointer to result
        "sub %0, %2\n"              Note: Subtract second pointer
        : "=r"(result)
        : "r"(a), "r"(b)
        :
    End Assembly
    Return result
End Process

Process called "ptr_align" that takes ptr as Pointer, alignment as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"              Note: Copy pointer to result
        "add %0, %2\n"              Note: Add alignment-1
        "dec %0\n"                  Note: Subtract 1
        "mov rax, %2\n"             Note: Load alignment into temp register
        "neg rax\n"                 Note: Negate alignment to create mask
        "and %0, rax\n"             Note: Apply alignment mask
        : "=r"(result)
        : "r"(ptr), "r"(alignment)
        : "rax"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: MEMORY ACCESS OPERATIONS
Note: =====================================================================

Process called "load_i8" that takes ptr as Pointer returns Integer8:
    Let result be 0
    Inline Assembly:
        "movzx %0, byte ptr [%1]\n"     Note: Zero-extend 8-bit load
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "load_i16" that takes ptr as Pointer returns Integer16:
    Let result be 0
    Inline Assembly:
        "movzx %0, word ptr [%1]\n"     Note: Zero-extend 16-bit load
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "load_i32" that takes ptr as Pointer returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, dword ptr [%1]\n"      Note: Load 32-bit value
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "load_i64" that takes ptr as Pointer returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, qword ptr [%1]\n"      Note: Load 64-bit value
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "store_i8" that takes ptr as Pointer, val as Integer8:
    Inline Assembly:
        "mov byte ptr [%0], %1\n"       Note: Store 8-bit value
        :
        : "r"(ptr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "store_i16" that takes ptr as Pointer, val as Integer16:
    Inline Assembly:
        "mov word ptr [%0], %1\n"       Note: Store 16-bit value
        :
        : "r"(ptr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "store_i32" that takes ptr as Pointer, val as Integer32:
    Inline Assembly:
        "mov dword ptr [%0], %1\n"      Note: Store 32-bit value
        :
        : "r"(ptr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "store_i64" that takes ptr as Pointer, val as Integer64:
    Inline Assembly:
        "mov qword ptr [%0], %1\n"      Note: Store 64-bit value
        :
        : "r"(ptr), "r"(val)
        : "memory"
    End Assembly
End Process

Note: =====================================================================
Note: POINTER COMPARISON OPERATIONS
Note: =====================================================================

Process called "ptr_eq" that takes a as Pointer, b as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"              Note: Compare pointers
        "sete %0\n"                 Note: Set if equal
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ptr_ne" that takes a as Pointer, b as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"              Note: Compare pointers
        "setne %0\n"                Note: Set if not equal
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ptr_lt" that takes a as Pointer, b as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"              Note: Compare pointers
        "setb %0\n"                 Note: Set if below (unsigned less than)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ptr_le" that takes a as Pointer, b as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"              Note: Compare pointers
        "setbe %0\n"                Note: Set if below or equal
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ptr_gt" that takes a as Pointer, b as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"              Note: Compare pointers
        "seta %0\n"                 Note: Set if above (unsigned greater than)
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ptr_ge" that takes a as Pointer, b as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "cmp %1, %2\n"              Note: Compare pointers
        "setae %0\n"                Note: Set if above or equal
        : "=r"(result)
        : "r"(a), "r"(b)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ptr_is_null" that takes ptr as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"             Note: Test pointer against itself
        "setz %0\n"                 Note: Set if zero (null)
        : "=r"(result)
        : "r"(ptr)
        : "flags"
    End Assembly
    Return result
End Process

Process called "ptr_is_not_null" that takes ptr as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "test %1, %1\n"             Note: Test pointer against itself
        "setnz %0\n"                Note: Set if not zero (not null)
        : "=r"(result)
        : "r"(ptr)
        : "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: POINTER CONVERSION OPERATIONS
Note: =====================================================================

Process called "ptr_to_i64" that takes ptr as Pointer returns Integer64:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"              Note: Convert pointer to 64-bit integer
        : "=r"(result)
        : "r"(ptr)
        :
    End Assembly
    Return result
End Process

Process called "i64_to_ptr" that takes val as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"              Note: Convert 64-bit integer to pointer
        : "=r"(result)
        : "r"(val)
        :
    End Assembly
    Return result
End Process

Process called "ptr_to_i32" that takes ptr as Pointer returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov %0, %1\n"              Note: Convert pointer to 32-bit integer (truncated)
        : "=r"(result)
        : "r"(ptr)
        :
    End Assembly
    Return result
End Process

Process called "i32_to_ptr" that takes val as Integer32 returns Pointer:
    Let result be 0
    Inline Assembly:
        "movzx %0, %1\n"            Note: Zero-extend 32-bit integer to pointer
        : "=r"(result)
        : "r"(val)
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: SPECIAL POINTER VALUES
Note: =====================================================================

Process called "null_ptr" returns Pointer:
    Let result be 0
    Inline Assembly:
        "xor %0, %0\n"              Note: Clear register to create null pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "invalid_ptr" returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, -1\n"              Note: Set all bits to create invalid pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: ATOMIC POINTER OPERATIONS
Note: =====================================================================

Process called "atomic_ptr_load" that takes ptr as Pointer returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, qword ptr [%1]\n"      Note: Atomic load pointer from memory
        : "=r"(result)
        : "r"(ptr)
        : "memory"
    End Assembly
    Return result
End Process

Process called "atomic_ptr_store" that takes ptr as Pointer, val as Pointer:
    Inline Assembly:
        "mov qword ptr [%0], %1\n"      Note: Atomic store pointer to memory
        :
        : "r"(ptr), "r"(val)
        : "memory"
    End Assembly
End Process

Process called "atomic_ptr_exchange" that takes ptr as Pointer, val as Pointer returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov rax, %2\n"             Note: Load value into RAX
        "xchg qword ptr [%1], rax\n" Note: Atomic exchange with memory
        "mov %0, rax\n"             Note: Move old value to result
        : "=r"(result)
        : "r"(ptr), "r"(val)
        : "rax", "memory"
    End Assembly
    Return result
End Process

Process called "atomic_ptr_cas" that takes ptr as Pointer, expected as Pointer, desired as Pointer returns Boolean:
    Let result be false
    Inline Assembly:
        "mov rax, %2\n"             Note: Load expected value into RAX
        "lock cmpxchg qword ptr [%1], %3\n" Note: Atomic compare and swap
        "sete %0\n"                 Note: Set result if equal
        : "=r"(result)
        : "r"(ptr), "r"(expected), "r"(desired)
        : "rax", "memory", "flags"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: MEMORY OPERATIONS
Note: =====================================================================

Process called "mem_copy" that takes dest as Pointer, src as Pointer, size as Integer64:
    Inline Assembly:
        "mov rcx, %2\n"             Note: Load size into RCX counter
        "mov rdi, %0\n"             Note: Load destination into RDI
        "mov rsi, %1\n"             Note: Load source into RSI
        "rep movsb\n"               Note: Repeat move bytes
        :
        : "r"(dest), "r"(src), "r"(size)
        : "rcx", "rdi", "rsi", "memory"
    End Assembly
End Process

Process called "mem_set" that takes dest as Pointer, val as Integer8, size as Integer64:
    Inline Assembly:
        "mov rcx, %2\n"             Note: Load size into RCX counter
        "mov rdi, %0\n"             Note: Load destination into RDI
        "mov al, %1\n"              Note: Load value into AL
        "rep stosb\n"               Note: Repeat store bytes
        :
        : "r"(dest), "r"(val), "r"(size)
        : "rcx", "rdi", "al", "memory"
    End Assembly
End Process

Process called "mem_compare" that takes a as Pointer, b as Pointer, size as Integer64 returns Integer32:
    Let result be 0
    Inline Assembly:
        "mov rcx, %3\n"             Note: Load size into RCX counter
        "mov rdi, %1\n"             Note: Load first pointer into RDI
        "mov rsi, %2\n"             Note: Load second pointer into RSI
        "repe cmpsb\n"              Note: Repeat compare bytes while equal
        "setz al\n"                 Note: Set AL if equal (zero flag)
        "movzx %0, al\n"            Note: Zero-extend result to 32-bit
        : "=r"(result)
        : "r"(a), "r"(b), "r"(size)
        : "rcx", "rdi", "rsi", "al", "memory", "flags"
    End Assembly
    Return result
End Process

Process called "mem_move" that takes dest as Pointer, src as Pointer, size as Integer64:
    Inline Assembly:
        "mov rcx, %2\n"             Note: Load size into RCX counter
        "mov rdi, %0\n"             Note: Load destination into RDI
        "mov rsi, %1\n"             Note: Load source into RSI
        "cmp rdi, rsi\n"            Note: Compare destination and source
        "jbe 1f\n"                  Note: Jump if dest <= src (forward copy)
        "add rdi, rcx\n"            Note: Point to end of destination
        "add rsi, rcx\n"            Note: Point to end of source
        "std\n"                     Note: Set direction flag for reverse copy
        "1: rep movsb\n"            Note: Repeat move bytes
        "cld\n"                     Note: Clear direction flag
        :
        : "r"(dest), "r"(src), "r"(size)
        : "rcx", "rdi", "rsi", "memory", "flags"
    End Assembly
End Process

Note: =====================================================================
Note: STACK POINTER OPERATIONS
Note: =====================================================================

Process called "get_stack_ptr" returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, rsp\n"             Note: Get current stack pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "get_frame_ptr" returns Pointer:
    Let result be 0
    Inline Assembly:
        "mov %0, rbp\n"             Note: Get current frame pointer
        : "=r"(result)
        :
        :
    End Assembly
    Return result
End Process

Process called "alloca_bytes" that takes size as Integer64 returns Pointer:
    Let result be 0
    Inline Assembly:
        "sub rsp, %1\n"             Note: Allocate space on stack
        "mov %0, rsp\n"             Note: Return new stack pointer
        : "=r"(result)
        : "r"(size)
        : "rsp"
    End Assembly
    Return result
End Process

Note: =====================================================================
Note: PREFETCH OPERATIONS (for optimization)
Note: =====================================================================

Process called "prefetch_t0" that takes ptr as Pointer:
    Inline Assembly:
        "prefetcht0 [%0]\n"         Note: Prefetch to L1 cache
        :
        : "r"(ptr)
        :
    End Assembly
End Process

Process called "prefetch_t1" that takes ptr as Pointer:
    Inline Assembly:
        "prefetcht1 [%0]\n"         Note: Prefetch to L2 cache
        :
        : "r"(ptr)
        :
    End Assembly
End Process

Process called "prefetch_t2" that takes ptr as Pointer:
    Inline Assembly:
        "prefetcht2 [%0]\n"         Note: Prefetch to L3 cache
        :
        : "r"(ptr)
        :
    End Assembly
End Process

Process called "prefetch_nta" that takes ptr as Pointer:
    Inline Assembly:
        "prefetchnta [%0]\n"        Note: Prefetch non-temporal access
        :
        : "r"(ptr)
        :
    End Assembly
End Process