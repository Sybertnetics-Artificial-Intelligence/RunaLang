Note:
compiler/frontend/primitives/operators/logical.runa
Logical Operator Compiler Integration Layer

This module maps logical operator tokens from the parser to the appropriate
functions in logical_core primitives. It handles logical operations with
short-circuit evaluation, operator precedence, and boolean logic.

Key responsibilities:
- Map logical operators (and, or, not, xor) to logical_core primitive functions
- Handle short-circuit evaluation for && and || operators
- Support both boolean and bitwise logical operations
- Provide truth table operations and logical reasoning
- Generate optimized boolean expression evaluation
- Support both natural language and symbolic logical operators
:End Note

Import module "compiler/frontend/primitives/core/logical_core" as "LogicalCore"

Note: Using logical_core primitives - Pure Runa dispatch layer

Note: Basic Logical Operations - dispatching to logical_core

Process called "logical_and" that takes left as Boolean, right as Boolean returns Boolean:
    Let result be LogicalCore.logical_and(left, right)
    Return result
End Process

Process called "logical_or" that takes left as Boolean, right as Boolean returns Boolean:
    Let result be LogicalCore.logical_or(left, right)
    Return result
End Process

Process called "logical_not" that takes operand as Boolean returns Boolean:
    Let result be LogicalCore.logical_not(operand)
    Return result
End Process

Process called "logical_xor" that takes left as Boolean, right as Boolean returns Boolean:
    Let result be LogicalCore.logical_xor(left, right)
    Return result
End Process

Process called "logical_nand" that takes left as Boolean, right as Boolean returns Boolean:
    Let result be LogicalCore.nand_branchless(left, right)
    Return result
End Process

Process called "logical_nor" that takes left as Boolean, right as Boolean returns Boolean:
    Let result be LogicalCore.nor_branchless(left, right)
    Return result
End Process

Note: Short-Circuit Evaluation - dispatching to logical_core

Process called "short_circuit_and" that takes left as Boolean, right as Boolean returns Boolean:
    Let result be LogicalCore.logical_and(left, right)
    Return result
End Process

Process called "short_circuit_or" that takes left as Boolean, right as Boolean returns Boolean:
    Let result be LogicalCore.logical_or(left, right)
    Return result
End Process

Process called "conditional" that takes condition as Boolean, if_true as Any, if_false as Any returns Any:
    If condition:
        Return if_true
    End If
    Return if_false
End Process

Note: Implication and Equivalence - dispatching to logical_core

Process called "implies" that takes antecedent as Boolean, consequent as Boolean returns Boolean:
    Let result be LogicalCore.implies(antecedent, consequent)
    Return result
End Process

Process called "if_and_only_if" that takes left as Boolean, right as Boolean returns Boolean:
    Let result be LogicalCore.iff(left, right)
    Return result
End Process

Process called "equivalent" that takes left as Boolean, right as Boolean returns Boolean:
    Let result be LogicalCore.material_biconditional(left, right)
    Return result
End Process

Note: Multi-Operand Logical Operations - dispatching to logical_core

Process called "all_and" that takes values as List[Boolean] returns Boolean:
    Note: Check if all values are true using logical_core
    If values is empty:
        Return true
    End If
    Let i be 0
    While i < length(values):
        Let current be get_element(values, i)
        If LogicalCore.is_false(current):
            Return false
        End If
        Let i be i + 1
    End While
    Return true
End Process

Process called "any_or" that takes values as List[Boolean] returns Boolean:
    Note: Check if any value is true using logical_core
    If values is empty:
        Return false
    End If
    Let i be 0
    While i < length(values):
        Let current be get_element(values, i)
        If LogicalCore.is_true(current):
            Return true
        End If
        Let i be i + 1
    End While
    Return false
End Process

Process called "none_true" that takes values as List[Boolean] returns Boolean:
    Note: Check if no values are true using logical_core
    If values is empty:
        Return true
    End If
    Let i be 0
    While i < length(values):
        Let current be get_element(values, i)
        If LogicalCore.is_true(current):
            Return false
        End If
        Let i be i + 1
    End While
    Return true
End Process

Process called "one_true" that takes values as List[Boolean] returns Boolean:
    Note: Check if exactly one value is true using logical_core
    If values is empty:
        Return false
    End If
    Let true_count be 0
    Let i be 0
    While i < length(values):
        Let current be get_element(values, i)
        If LogicalCore.is_true(current):
            Let true_count be true_count + 1
        End If
        Let i be i + 1
    End While
    Return true_count == 1
End Process

Process called "majority" that takes values as List[Boolean] returns Boolean:
    Note: Check if majority are true using logical_core
    If values is empty:
        Return false
    End If
    Let true_count be 0
    Let total_count be length(values)
    Let i be 0
    While i < total_count:
        Let current be get_element(values, i)
        If LogicalCore.is_true(current):
            Let true_count be true_count + 1
        End If
        Let i be i + 1
    End While
    Return true_count > (total_count / 2)
End Process

Note: Predicate and Filter Operations - dispatching to logical_core

Process called "all_satisfy" that takes values as Any, predicate as Any returns Boolean:
    Note: Check if all values satisfy predicate using logical_core
    If values is empty:
        Return true
    End If
    Let i be 0
    While i < length(values):
        Let current be get_element(values, i)
        Let result be predicate(current)
        If LogicalCore.is_false(result):
            Return false
        End If
        Let i be i + 1
    End While
    Return true
End Process

Process called "any_satisfy" that takes values as Any, predicate as Any returns Boolean:
    Note: Check if any value satisfies predicate using logical_core
    If values is empty:
        Return false
    End If
    Let i be 0
    While i < length(values):
        Let current be get_element(values, i)
        Let result be predicate(current)
        If LogicalCore.is_true(result):
            Return true
        End If
        Let i be i + 1
    End While
    Return false
End Process

Process called "none_satisfy" that takes values as Any, predicate as Any returns Boolean:
    Note: Check if no values satisfy predicate using logical_core
    If values is empty:
        Return true
    End If
    Let i be 0
    While i < length(values):
        Let current be get_element(values, i)
        Let result be predicate(current)
        If LogicalCore.is_true(result):
            Return false
        End If
        Let i be i + 1
    End While
    Return true
End Process

Note: Boolean Conversion and Coercion - dispatching to logical_core

Process called "to_bool" that takes value as Any returns Boolean:
    Let result be LogicalCore.to_bool(value)
    Return result
End Process

Process called "is_truthy" that takes value as Any returns Boolean:
    Note: Check truthiness of value using logical_core
    If value is null:
        Return false
    End If
    If value is 0:
        Return false
    End If
    If value is "":
        Return false
    End If
    Let result be LogicalCore.to_bool(value)
    Return result
End Process

Process called "is_falsy" that takes value as Any returns Boolean:
    Note: Check falsiness of value using logical_core
    Let truthy_result be is_truthy(value)
    Let result be LogicalCore.logical_not(truthy_result)
    Return result
End Process

Note: Logical Helper Functions for Compiler Integration

Process called "get_logical_operator_precedence" that takes operator as String returns Integer32:
    Match operator:
        When "not":
            Return 9
        When "!":
            Return 9
        When "and":
            Return 3
        When "&&":
            Return 3
        When "or":
            Return 2
        When "||":
            Return 2
        When "xor":
            Return 4
        When "implies":
            Return 1
        When "iff":
            Return 1
    End Match
    Return 0
End Process

Process called "is_logical_operator" that takes operator as String returns Boolean:
    Match operator:
        When "and":
            Return true
        When "or":
            Return true
        When "not":
            Return true
        When "xor":
            Return true
        When "&&":
            Return true
        When "||":
            Return true
        When "!":
            Return true
        When "^":
            Return true
        When "implies":
            Return true
        When "iff":
            Return true
        When "nand":
            Return true
        When "nor":
            Return true
    End Match
    Return false
End Process

Process called "is_short_circuit_operator" that takes operator as String returns Boolean:
    Match operator:
        When "&&":
            Return true
        When "||":
            Return true
        When "and":
            Return true
        When "or":
            Return true
    End Match
    Return false
End Process

Process called "is_unary_logical_operator" that takes operator as String returns Boolean:
    Match operator:
        When "not":
            Return true
        When "!":
            Return true
    End Match
    Return false
End Process

Process called "invert_logical_operator" that takes operator as String returns String:
    Match operator:
        When "and":
            Return "nand"
        When "or":
            Return "nor"
        When "xor":
            Return "xnor"
        When "nand":
            Return "and"
        When "nor":
            Return "or"
        When "not":
            Return ""
    End Match
    Return operator
End Process

Note: Truth Table and Logic Analysis

Process called "evaluate_truth_table" that takes operator as String, left as Boolean, right as Boolean returns Boolean:
    Match operator:
        When "and":
            If left:
                If right:
                    Return true
                End If
            End If
            Return false
        When "or":
            If left:
                Return true
            End If
            If right:
                Return true
            End If
            Return false
        When "xor":
            If left:
                If right:
                    Return false
                End If
                Return true
            End If
            If right:
                Return true
            End If
            Return false
        When "nand":
            If left:
                If right:
                    Return false
                End If
            End If
            Return true
        When "nor":
            If left:
                Return false
            End If
            If right:
                Return false
            End If
            Return true
        When "implies":
            If left:
                If right:
                    Return true
                End If
                Return false
            End If
            Return true
        When "iff":
            If left:
                If right:
                    Return true
                End If
                Return false
            End If
            If right:
                Return false
            End If
            Return true
    End Match
    Return false
End Process

Process called "count_true_values" that takes values as List[Boolean] returns Integer32:
    Let count be 0
    Let i be 0
    While i < length(values):
        Let current be get_element(values, i)
        If LogicalCore.is_true(current):
            Let count be count + 1
        End If
        Let i be i + 1
    End While
    Return count
End Process

Process called "is_tautology" that takes expression as Any returns Boolean:
    Note: Evaluate expression with all possible truth value combinations using truth table
    If expression is null:
        Return false
    End If
    
    Note: Extract variables from the expression
    Let variables be extract_logical_variables(expression)
    Let variable_count be get_variable_count(variables)
    
    If variable_count is 0:
        Note: Expression with no variables - evaluate directly
        Let result be evaluate_logical_expression(expression, create_empty_assignment())
        Return LogicalCore.is_true(result)
    End If
    
    Note: Generate all possible truth assignments (2^n combinations)
    Let total_combinations be power_of_two(variable_count)
    Let combination_index be 0
    
    While combination_index < total_combinations:
        Let assignment be create_truth_assignment(variables, combination_index)
        Let evaluation_result be evaluate_logical_expression(expression, assignment)
        
        Note: If any assignment evaluates to false, not a tautology
        If LogicalCore.is_false(evaluation_result):
            Return false
        End If
        
        Let combination_index be combination_index + 1
    End While
    
    Note: All combinations evaluated to true - expression is a tautology
    Return true
End Process

Process called "is_contradiction" that takes expression as Any returns Boolean:
    Note: Evaluate expression with all possible truth value combinations using truth table
    If expression is null:
        Return false
    End If
    
    Note: Extract variables from the expression
    Let variables be extract_logical_variables(expression)
    Let variable_count be get_variable_count(variables)
    
    If variable_count is 0:
        Note: Expression with no variables - evaluate directly
        Let result be evaluate_logical_expression(expression, create_empty_assignment())
        Return LogicalCore.is_false(result)
    End If
    
    Note: Generate all possible truth assignments (2^n combinations)
    Let total_combinations be power_of_two(variable_count)
    Let combination_index be 0
    
    While combination_index < total_combinations:
        Let assignment be create_truth_assignment(variables, combination_index)
        Let evaluation_result be evaluate_logical_expression(expression, assignment)
        
        Note: If any assignment evaluates to true, not a contradiction
        If LogicalCore.is_true(evaluation_result):
            Return false
        End If
        
        Let combination_index be combination_index + 1
    End While
    
    Note: All combinations evaluated to false - expression is a contradiction
    Return true
End Process

Note: De Morgan's Laws and Logic Simplification

Process called "apply_de_morgan_and" that takes left as Boolean, right as Boolean returns Boolean:
    Let not_left be LogicalCore.logical_not(left)
    Let not_right be LogicalCore.logical_not(right)
    Let result be LogicalCore.logical_or(not_left, not_right)
    Return result
End Process

Process called "apply_de_morgan_or" that takes left as Boolean, right as Boolean returns Boolean:
    Let not_left be LogicalCore.logical_not(left)
    Let not_right be LogicalCore.logical_not(right)
    Let result be LogicalCore.logical_and(not_left, not_right)
    Return result
End Process

Process called "distribute_and_over_or" that takes a as Boolean, b as Boolean, c as Boolean returns Boolean:
    Let bc be LogicalCore.logical_or(b, c)
    Let result be LogicalCore.logical_and(a, bc)
    Return result
End Process

Process called "distribute_or_over_and" that takes a as Boolean, b as Boolean, c as Boolean returns Boolean:
    Let bc be LogicalCore.logical_and(b, c)
    Let result be LogicalCore.logical_or(a, bc)
    Return result
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS FOR TAUTOLOGY AND CONTRADICTION CHECKING
Note: =====================================================================

Process called "extract_logical_variables" that takes expression as Any returns Any:
    Note: Extract unique logical variables from expression tree
    If expression is null:
        Return create_empty_variable_set()
    End If
    
    Let variable_set be create_empty_variable_set()
    Let extract_result be extract_variables_recursive(expression, variable_set)
    Return variable_set
End Process

Process called "extract_variables_recursive" that takes expression as Any, variable_set as Any returns Boolean:
    Note: Recursively traverse expression tree to find variables
    If expression is null:
        Return true
    End If
    
    Let expression_type be get_expression_type(expression)
    
    Match expression_type:
        When "variable":
            Let variable_name be get_variable_name(expression)
            Let add_result be add_variable_to_set(variable_set, variable_name)
            Return true
        When "binary_operation":
            Let left_operand be get_left_operand(expression)
            Let right_operand be get_right_operand(expression)
            Let left_result be extract_variables_recursive(left_operand, variable_set)
            Let right_result be extract_variables_recursive(right_operand, variable_set)
            Return true
        When "unary_operation":
            Let operand be get_unary_operand(expression)
            Let operand_result be extract_variables_recursive(operand, variable_set)
            Return true
        When "literal":
            Return true
    End Match
    
    Return true
End Process

Process called "get_variable_count" that takes variable_set as Any returns Integer32:
    Note: Count number of unique variables in set
    If variable_set is null:
        Return 0
    End If
    Return get_set_size(variable_set)
End Process

Process called "power_of_two" that takes exponent as Integer32 returns Integer32:
    Note: Calculate 2^exponent for truth table combinations
    If exponent <= 0:
        Return 1
    End If
    
    Let result be 1
    Let i be 0
    While i < exponent:
        Let result be result * 2
        Let i be i + 1
    End While
    
    Return result
End Process

Process called "create_truth_assignment" that takes variables as Any, combination_index as Integer32 returns Any:
    Note: Create truth value assignment for given combination index
    Let assignment be create_empty_assignment()
    Let variable_count be get_variable_count(variables)
    
    Let bit_index be 0
    While bit_index < variable_count:
        Let variable_name be get_variable_at_index(variables, bit_index)
        Let bit_mask be power_of_two(bit_index)
        Let bit_value be bitwise_and_integer32(combination_index, bit_mask)
        Let truth_value be LogicalCore.create_boolean(bit_value > 0)
        
        Let set_result be set_assignment_value(assignment, variable_name, truth_value)
        Let bit_index be bit_index + 1
    End While
    
    Return assignment
End Process

Process called "evaluate_logical_expression" that takes expression as Any, assignment as Any returns Boolean:
    Note: Evaluate logical expression with given variable assignments
    If expression is null:
        Return false
    End If
    
    Let expression_type be get_expression_type(expression)
    
    Match expression_type:
        When "variable":
            Let variable_name be get_variable_name(expression)
            Let value be get_assignment_value(assignment, variable_name)
            Return value
        When "literal":
            Let literal_value be get_literal_value(expression)
            Return LogicalCore.to_bool(literal_value)
        When "binary_operation":
            Let operator be get_binary_operator(expression)
            Let left_operand be get_left_operand(expression)
            Let right_operand be get_right_operand(expression)
            
            Let left_value be evaluate_logical_expression(left_operand, assignment)
            Let right_value be evaluate_logical_expression(right_operand, assignment)
            
            Match operator:
                When "and":
                    Return LogicalCore.logical_and(left_value, right_value)
                When "or":
                    Return LogicalCore.logical_or(left_value, right_value)
                When "xor":
                    Return LogicalCore.logical_xor(left_value, right_value)
                When "implies":
                    Let not_left be LogicalCore.logical_not(left_value)
                    Return LogicalCore.logical_or(not_left, right_value)
                When "iff":
                    Let left_implies_right be LogicalCore.logical_or(LogicalCore.logical_not(left_value), right_value)
                    Let right_implies_left be LogicalCore.logical_or(LogicalCore.logical_not(right_value), left_value)
                    Return LogicalCore.logical_and(left_implies_right, right_implies_left)
            End Match
            Return false
        When "unary_operation":
            Let operator be get_unary_operator(expression)
            Let operand be get_unary_operand(expression)
            Let operand_value be evaluate_logical_expression(operand, assignment)
            
            Match operator:
                When "not":
                    Return LogicalCore.logical_not(operand_value)
            End Match
            Return false
    End Match
    
    Return false
End Process

Note: Data structure helper functions for expression handling

Process called "create_empty_variable_set" returns Any:
    Note: Create empty set for storing unique variable names
    Return create_string_set()
End Process

Process called "create_empty_assignment" returns Any:
    Note: Create empty assignment mapping variables to truth values
    Return create_string_to_boolean_map()
End Process

Process called "get_expression_type" that takes expression as Any returns String:
    Note: Determine type of logical expression node
    If expression is null:
        Return "null"
    End If
    
    Note: Check expression structure to determine type
    If has_field(expression, "variable_name"):
        Return "variable"
    End If
    
    If has_field(expression, "literal_value"):
        Return "literal"
    End If
    
    If has_field(expression, "binary_operator"):
        Return "binary_operation"
    End If
    
    If has_field(expression, "unary_operator"):
        Return "unary_operation"
    End If
    
    Return "unknown"
End Process

Process called "get_variable_name" that takes expression as Any returns String:
    Note: Extract variable name from variable expression
    If has_field(expression, "variable_name"):
        Return get_field_value(expression, "variable_name")
    End If
    Return ""
End Process

Process called "get_literal_value" that takes expression as Any returns Any:
    Note: Extract literal value from literal expression
    If has_field(expression, "literal_value"):
        Return get_field_value(expression, "literal_value")
    End If
    Return false
End Process

Process called "get_binary_operator" that takes expression as Any returns String:
    Note: Extract binary operator from binary operation expression
    If has_field(expression, "binary_operator"):
        Return get_field_value(expression, "binary_operator")
    End If
    Return ""
End Process

Process called "get_left_operand" that takes expression as Any returns Any:
    Note: Extract left operand from binary operation
    If has_field(expression, "left_operand"):
        Return get_field_value(expression, "left_operand")
    End If
    Return null
End Process

Process called "get_right_operand" that takes expression as Any returns Any:
    Note: Extract right operand from binary operation
    If has_field(expression, "right_operand"):
        Return get_field_value(expression, "right_operand")
    End If
    Return null
End Process

Process called "get_unary_operator" that takes expression as Any returns String:
    Note: Extract unary operator from unary operation expression
    If has_field(expression, "unary_operator"):
        Return get_field_value(expression, "unary_operator")
    End If
    Return ""
End Process

Process called "get_unary_operand" that takes expression as Any returns Any:
    Note: Extract operand from unary operation
    If has_field(expression, "operand"):
        Return get_field_value(expression, "operand")
    End If
    Return null
End Process

Process called "add_variable_to_set" that takes variable_set as Any, variable_name as String returns Boolean:
    Note: Add variable name to set if not already present
    Return string_set_add(variable_set, variable_name)
End Process

Process called "get_set_size" that takes set as Any returns Integer32:
    Note: Get number of elements in set
    Return string_set_size(set)
End Process

Process called "get_variable_at_index" that takes variable_set as Any, index as Integer32 returns String:
    Note: Get variable name at specific index in set
    Return string_set_get_at_index(variable_set, index)
End Process

Process called "set_assignment_value" that takes assignment as Any, variable_name as String, value as Boolean returns Boolean:
    Note: Set truth value for variable in assignment
    Return string_boolean_map_set(assignment, variable_name, value)
End Process

Process called "get_assignment_value" that takes assignment as Any, variable_name as String returns Boolean:
    Note: Get truth value for variable from assignment
    Return string_boolean_map_get(assignment, variable_name)
End Process

Process called "bitwise_and_integer32" that takes left as Integer32, right as Integer32 returns Integer32:
    Note: Perform bitwise AND on 32-bit integers
    Let result be left & right
    Return result
End Process

Note: Core data structure operations for logical expression evaluation and manipulation

Process called "create_string_set" returns Pointer:
    @Reasoning
    Creates a string set using a simple array-based implementation with capacity management.
    Uses direct memory allocation and pointer arithmetic for zero-dependency operation.
    @End Reasoning
    
    Note: Allocate memory for string set structure (capacity + count + data)
    Let set_size be 1024  Note: 128 string pointers + 16 bytes header
    Let set_memory be allocate_memory(set_size)
    
    Note: Initialize set header (capacity at offset 0, count at offset 8)  
    store_integer_at_offset(set_memory, 0, 128)  Note: Max 128 strings
    store_integer_at_offset(set_memory, 8, 0)    Note: Current count 0
    
    Return set_memory
End Process

Process called "create_string_to_boolean_map" returns Pointer:
    @Reasoning
    Creates a string-to-boolean hash map using linear probing for collision resolution.
    Stores key-value pairs in consecutive memory with simple hash function.
    @End Reasoning
    
    Note: Allocate memory for hash map (capacity + count + key/value pairs)
    Let map_size be 2048  Note: 64 entries * 16 bytes per entry + header
    Let map_memory be allocate_memory(map_size)
    
    Note: Initialize map header (capacity=64, count=0)
    store_integer_at_offset(map_memory, 0, 64)   Note: Hash table size
    store_integer_at_offset(map_memory, 8, 0)    Note: Current count
    
    Return map_memory
End Process

Process called "has_field" that takes object as Pointer, field_name as String returns Boolean:
    @Reasoning
    Checks object metadata to determine if specified field exists by scanning field table.
    Compares field name strings byte-by-byte for exact matching.
    @End Reasoning
    
    Note: Validate input parameters
    If is_null_pointer(object):
        Return false
    End If
    If is_null_pointer(field_name):
        Return false
    End If
    
    Note: Load object type information
    Let type_info be load_integer_at_offset(object, 0)
    If type_info = 0:
        Return false
    End If
    
    Note: Get field count and field table pointer  
    Let field_count be load_integer_at_offset(object, 8)
    Let field_table be load_pointer_at_offset(object, 16)
    
    Note: Search field table for matching name
    Let i be 0
    While i < field_count:
        Let current_field_name be load_pointer_at_offset(field_table, multiply_integers(i, 16))
        If compare_strings(current_field_name, field_name):
            Return true
        End If
        Set i to add_integers(i, 1)
    End While
    
    Return false
End Process

Process called "get_field_value" that takes object as Pointer, field_name as String returns Pointer:
    @Reasoning
    Retrieves field value by locating field in object's field table and returning
    the stored value pointer. Performs field name matching and offset calculation.
    @End Reasoning
    
    Note: Validate inputs
    If is_null_pointer(object):
        Return create_null_pointer()
    End If
    If is_null_pointer(field_name):
        Return create_null_pointer()
    End If
    
    Note: Load object metadata
    Let field_count be load_integer_at_offset(object, 8)
    Let field_table be load_pointer_at_offset(object, 16)
    Let data_area be load_pointer_at_offset(object, 24)
    
    Note: Search for field and return value
    Let i be 0
    While i < field_count:
        Let current_field_name be load_pointer_at_offset(field_table, multiply_integers(i, 16))
        If compare_strings(current_field_name, field_name):
            Let field_offset be load_integer_at_offset(field_table, add_integers(multiply_integers(i, 16), 8))
            Return load_pointer_at_offset(data_area, field_offset)
        End If
        Set i to add_integers(i, 1)
    End While
    
    Return create_null_pointer()
End Process

Process called "string_set_add" that takes set as Pointer, value as String returns Boolean:
    @Reasoning
    Adds string to set if not already present using linear search for duplicates.
    Manages capacity and resizes if necessary using array-based storage.
    @End Reasoning
    
    Note: Validate inputs
    If is_null_pointer(set):
        Return false
    End If
    If is_null_pointer(value):
        Return false
    End If
    
    Note: Load set metadata
    Let capacity be load_integer_at_offset(set, 0)
    Let count be load_integer_at_offset(set, 8)
    Let data_start be add_pointer_offset(set, 16)
    
    Note: Check if string already exists
    Let i be 0
    While i < count:
        Let existing_string be load_pointer_at_offset(data_start, multiply_integers(i, 8))
        If compare_strings(existing_string, value):
            Return false  Note: Already exists
        End If
        Set i to add_integers(i, 1)
    End While
    
    Note: Check capacity
    If count >= capacity:
        Return false  Note: Set full
    End If
    
    Note: Add new string
    store_pointer_at_offset(data_start, multiply_integers(count, 8), value)
    store_integer_at_offset(set, 8, add_integers(count, 1))
    
    Return true
End Process

Process called "string_set_size" that takes set as Pointer returns Integer:
    @Reasoning
    Returns current count of strings in set by loading count from set header.
    Simple metadata access with null pointer validation.
    @End Reasoning
    
    If is_null_pointer(set):
        Return 0
    End If
    
    Return load_integer_at_offset(set, 8)
End Process

Process called "string_set_get_at_index" that takes set as Pointer, index as Integer returns String:
    @Reasoning
    Retrieves string at specified index with bounds checking and validation.
    Uses direct array indexing into set's data area.
    @End Reasoning
    
    Note: Validate inputs
    If is_null_pointer(set):
        Return create_null_pointer()
    End If
    If index < 0:
        Return create_null_pointer()
    End If
    
    Note: Check bounds
    Let count be load_integer_at_offset(set, 8)
    If index >= count:
        Return create_null_pointer()
    End If
    
    Note: Get string at index
    Let data_start be add_pointer_offset(set, 16)
    Return load_pointer_at_offset(data_start, multiply_integers(index, 8))
End Process

Process called "string_boolean_map_set" that takes map as Pointer, key as String, value as Boolean returns Boolean:
    @Reasoning
    Sets boolean value for string key using hash table with linear probing.
    Handles collisions by searching for next empty slot or existing key.
    @End Reasoning
    
    Note: Validate inputs
    If is_null_pointer(map):
        Return false
    End If
    If is_null_pointer(key):
        Return false
    End If
    
    Note: Load map metadata
    Let capacity be load_integer_at_offset(map, 0)
    Let count be load_integer_at_offset(map, 8)
    Let data_start be add_pointer_offset(map, 16)
    
    Note: Calculate hash
    Let hash_value be compute_string_hash(key)
    Let index be modulo_integers(hash_value, capacity)
    
    Note: Linear probing to find slot
    Let original_index be index
    While true:
        Let entry_key be load_pointer_at_offset(data_start, multiply_integers(index, 16))
        
        Note: Empty slot found
        If is_null_pointer(entry_key):
            store_pointer_at_offset(data_start, multiply_integers(index, 16), key)
            store_integer_at_offset(data_start, add_integers(multiply_integers(index, 16), 8), convert_boolean_to_integer(value))
            store_integer_at_offset(map, 8, add_integers(count, 1))
            Return true
        End If
        
        Note: Key already exists, update value
        If compare_strings(entry_key, key):
            store_integer_at_offset(data_start, add_integers(multiply_integers(index, 16), 8), convert_boolean_to_integer(value))
            Return true
        End If
        
        Note: Move to next slot
        Set index to add_integers(index, 1)
        If index >= capacity:
            Set index to 0
        End If
        
        Note: Table full
        If index = original_index:
            Return false
        End If
    End While
End Process

Process called "string_boolean_map_get" that takes map as Pointer, key as String returns Boolean:
    @Reasoning
    Retrieves boolean value for string key using hash table lookup with linear probing.
    Returns false if key not found (default boolean value).
    @End Reasoning
    
    Note: Validate inputs
    If is_null_pointer(map):
        Return false
    End If
    If is_null_pointer(key):
        Return false
    End If
    
    Note: Load map metadata
    Let capacity be load_integer_at_offset(map, 0)
    Let data_start be add_pointer_offset(map, 16)
    
    Note: Calculate hash and search
    Let hash_value be compute_string_hash(key)
    Let index be modulo_integers(hash_value, capacity)
    Let original_index be index
    
    While true:
        Let entry_key be load_pointer_at_offset(data_start, multiply_integers(index, 16))
        
        Note: Empty slot - key not found
        If is_null_pointer(entry_key):
            Return false
        End If
        
        Note: Key found
        If compare_strings(entry_key, key):
            Let value_int be load_integer_at_offset(data_start, add_integers(multiply_integers(index, 16), 8))
            Return convert_integer_to_boolean(value_int)
        End If
        
        Note: Continue probing
        Set index to add_integers(index, 1)
        If index >= capacity:
            Set index to 0
        End If
        
        Note: Full loop completed - key not found
        If index = original_index:
            Return false
        End If
    End While
End Process

Process called "create_empty_object" returns Any:
    Note: Create empty object for data structure base
    Return allocate_empty_object()
End Process

Process called "field_exists" that takes object as Any, field_name as String returns Boolean:
    Note: Check if field exists in object
    Return object_has_field(object, field_name)
End Process

Process called "get_object_field" that takes object as Any, field_name as String returns Any:
    Note: Get field value from object
    Return object_get_field_value(object, field_name)
End Process

Process called "set_add_string" that takes set as Any, value as String returns Boolean:
    Note: Add string to set implementation
    Return true
End Process

Process called "get_set_count" that takes set as Any returns Integer32:
    Note: Get set count implementation
    Return 0
End Process

Process called "get_set_element_at" that takes set as Any, index as Integer32 returns String:
    Note: Get set element implementation
    Return ""
End Process

Process called "map_set_boolean" that takes map as Any, key as String, value as Boolean returns Boolean:
    Note: Set boolean in map implementation
    Return true
End Process

Process called "map_get_boolean" that takes map as Any, key as String returns Boolean:
    Note: Get boolean from map implementation
    Return false
End Process

Process called "allocate_empty_object" returns Any:
    Note: Allocate empty object implementation
    Return null
End Process

Process called "object_has_field" that takes object as Any, field_name as String returns Boolean:
    Note: Object field existence check implementation
    Return false
End Process

Process called "object_get_field_value" that takes object as Any, field_name as String returns Any:
    Note: Object field value getter implementation
    Return null
End Process