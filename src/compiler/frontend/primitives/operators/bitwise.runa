Note:
compiler/frontend/primitives/operators/bitwise.runa
Bitwise Operator Compiler Integration Layer

This module maps bitwise operator tokens from the parser to the appropriate
functions in bitwise_core primitives. It handles bitwise operations for
integer types, bit manipulation, and shift operations.

Key responsibilities:
- Map bitwise operators (&, |, ^, ~, <<, >>) to bitwise_core primitive functions
- Handle bit shift operations with overflow protection
- Support bit field manipulation and flag operations
- Provide bit counting and population operations
- Handle endianness considerations for multi-byte operations
- Support both symbolic and natural language bitwise operators
:End Note

Import module "compiler/frontend/primitives/core/bitwise_core" as "BitwiseCore"

Note: Using bitwise_core primitives - Pure Runa dispatch layer

Note: Basic Bitwise Operations - dispatching to bitwise_core

Process called "bitwise_and" that takes left as Integer, right as Integer returns Integer:
    Let result be BitwiseCore.bit_and(left, right)
    Return result
End Process

Process called "bitwise_or" that takes left as Integer, right as Integer returns Integer:
    Let result be BitwiseCore.bit_or(left, right)
    Return result
End Process

Process called "bitwise_xor" that takes left as Integer, right as Integer returns Integer:
    Let result be BitwiseCore.bit_xor(left, right)
    Return result
End Process

Process called "bitwise_not" that takes operand as Integer returns Integer:
    Let result be BitwiseCore.bit_not(operand)
    Return result
End Process

Process called "bitwise_nand" that takes left as Integer, right as Integer returns Integer:
    Let result be BitwiseCore.bit_nand(left, right)
    Return result
End Process

Process called "bitwise_nor" that takes left as Integer, right as Integer returns Integer:
    Let result be BitwiseCore.bit_nor(left, right)
    Return result
End Process

Note: Bit Shift Operations - dispatching to bitwise_core

Process called "left_shift" that takes value as Integer, positions as Integer returns Integer:
    Let result be BitwiseCore.shl(value, positions)
    Return result
End Process

Process called "right_shift" that takes value as Integer, positions as Integer returns Integer:
    Let result be BitwiseCore.shr(value, positions)
    Return result
End Process

Process called "arithmetic_right_shift" that takes value as Integer, positions as Integer returns Integer:
    Let result be BitwiseCore.shr(value, positions)
    Return result
End Process

Process called "unsigned_right_shift" that takes value as Integer, positions as Integer returns Integer:
    Let result be BitwiseCore.ushr(value, positions)
    Return result
End Process

Process called "left_rotate" that takes value as Integer, positions as Integer returns Integer:
    Let result be BitwiseCore.rotl(value, positions)
    Return result
End Process

Process called "right_rotate" that takes value as Integer, positions as Integer returns Integer:
    Let result be BitwiseCore.rotr(value, positions)
    Return result
End Process

Note: Bit Manipulation Operations - dispatching to bitwise_core

Process called "set_bit" that takes value as Integer, position as Integer returns Integer:
    Let result be BitwiseCore.bit_set(value, position)
    Return result
End Process

Process called "clear_bit" that takes value as Integer, position as Integer returns Integer:
    Let result be BitwiseCore.bit_clear(value, position)
    Return result
End Process

Process called "toggle_bit" that takes value as Integer, position as Integer returns Integer:
    Let result be BitwiseCore.bit_toggle(value, position)
    Return result
End Process

Process called "test_bit" that takes value as Integer, position as Integer returns Boolean:
    Let result be BitwiseCore.bit_test(value, position)
    Return result
End Process

Note: Bit Field Operations - dispatching to bitwise_core

Process called "extract_bits" that takes value as Integer, start as Integer, length as Integer returns Integer:
    Let result be BitwiseCore.extract_bits(value, start, length)
    Return result
End Process

Process called "insert_bits" that takes value as Integer, bits as Integer, start as Integer, length as Integer returns Integer:
    Let result be BitwiseCore.deposit_bits(value, bits, start, length)
    Return result
End Process

Process called "mask_bits" that takes start as Integer, length as Integer returns Integer:
    Let result be BitwiseCore.make_mask(length)
    Let shifted_result be BitwiseCore.shl(result, start)
    Return shifted_result
End Process

Note: Bit Counting Operations - dispatching to bitwise_core

Process called "count_ones" that takes value as Integer returns Integer:
    Let result be BitwiseCore.popcount(value)
    Return result
End Process

Process called "count_zeros" that takes value as Integer returns Integer:
    Let total_bits be 64
    Let ones be BitwiseCore.popcount(value)
    Let result be total_bits - ones
    Return result
End Process

Process called "leading_zeros" that takes value as Integer returns Integer:
    Let result be BitwiseCore.clz(value)
    Return result
End Process

Process called "trailing_zeros" that takes value as Integer returns Integer:
    Let result be BitwiseCore.ctz(value)
    Return result
End Process

Process called "leading_ones" that takes value as Integer returns Integer:
    Let inverted be BitwiseCore.bit_not(value)
    Let result be BitwiseCore.clz(inverted)
    Return result
End Process

Process called "trailing_ones" that takes value as Integer returns Integer:
    Let inverted be BitwiseCore.bit_not(value)
    Let result be BitwiseCore.ctz(inverted)
    Return result
End Process

Note: Bit Reversal and Byte Swapping - dispatching to bitwise_core

Process called "reverse_bits" that takes value as Integer returns Integer:
    Let result be BitwiseCore.reverse_bits(value)
    Return result
End Process

Process called "byte_swap" that takes value as Integer returns Integer:
    Let result be BitwiseCore.bswap(value)
    Return result
End Process

Note: Parity and Check Operations - dispatching to bitwise_core

Process called "parity" that takes value as Integer returns Boolean:
    Let result be BitwiseCore.parity(value)
    Return result
End Process

Process called "even_parity" that takes value as Integer returns Boolean:
    Let parity_bit be BitwiseCore.parity(value)
    Let result be not parity_bit
    Return result
End Process

Process called "odd_parity" that takes value as Integer returns Boolean:
    Let result be BitwiseCore.parity(value)
    Return result
End Process

Note: Multi-Precision Bitwise Operations - dispatching to bitwise_core

Process called "wide_and" that takes left_low as Integer, left_high as Integer, right_low as Integer, right_high as Integer returns Integer:
    Note: Return low part of wide AND operation
    Let result_low be BitwiseCore.bit_and(left_low, right_low)
    Let result_high be BitwiseCore.bit_and(left_high, right_high)
    Return result_low
End Process

Process called "wide_or" that takes left_low as Integer, left_high as Integer, right_low as Integer, right_high as Integer returns Integer:
    Note: Return low part of wide OR operation
    Let result_low be BitwiseCore.bit_or(left_low, right_low)
    Let result_high be BitwiseCore.bit_or(left_high, right_high)
    Return result_low
End Process

Process called "wide_xor" that takes left_low as Integer, left_high as Integer, right_low as Integer, right_high as Integer returns Integer:
    Note: Return low part of wide XOR operation
    Let result_low be BitwiseCore.bit_xor(left_low, right_low)
    Let result_high be BitwiseCore.bit_xor(left_high, right_high)
    Return result_low
End Process

Note: Bitwise Helper Functions for Compiler Integration

Process called "get_bitwise_operator_precedence" that takes operator as String returns Integer32:
    Match operator:
        When "<<":
            Return 5
        When ">>":
            Return 5
        When "&":
            Return 4
        When "^":
            Return 3
        When "|":
            Return 2
        When "~":
            Return 6
    End Match
    Return 0
End Process

Process called "is_bitwise_operator" that takes operator as String returns Boolean:
    Match operator:
        When "&":
            Return true
        When "|":
            Return true
        When "^":
            Return true
        When "~":
            Return true
        When "<<":
            Return true
        When ">>":
            Return true
        When ">>>":
            Return true
        When "<<<":
            Return true
    End Match
    Return false
End Process

Process called "is_shift_operator" that takes operator as String returns Boolean:
    Match operator:
        When "<<":
            Return true
        When ">>":
            Return true
        When ">>>":
            Return true
        When "<<<":
            Return true
    End Match
    Return false
End Process

Process called "validate_shift_amount" that takes value as Integer, shift_amount as Integer, bit_width as Integer returns Boolean:
    If shift_amount < 0:
        Return false
    End If
    If shift_amount >= bit_width:
        Return false
    End If
    Return true
End Process

Process called "get_integer_bit_width" that takes type_name as String returns Integer32:
    Match type_name:
        When "Integer8":
            Return 8
        When "Integer16":
            Return 16
        When "Integer32":
            Return 32
        When "Integer64":
            Return 64
        When "Unsigned8":
            Return 8
        When "Unsigned16":
            Return 16
        When "Unsigned32":
            Return 32
        When "Unsigned64":
            Return 64
    End Match
    Return 32
End Process

Note: Flag and Mask Helper Operations

Process called "create_bit_mask" that takes bit_position as Integer returns Integer:
    Let mask be BitwiseCore.shl(1, bit_position)
    Return mask
End Process

Process called "create_range_mask" that takes start_bit as Integer, end_bit as Integer returns Integer:
    Let length be end_bit - start_bit
    Let length_plus_one be length + 1
    Let base_mask be BitwiseCore.make_mask(length_plus_one)
    Let positioned_mask be BitwiseCore.shl(base_mask, start_bit)
    Return positioned_mask
End Process

Process called "extract_flag_set" that takes value as Integer, flags as Integer returns Boolean:
    Let masked be BitwiseCore.bit_and(value, flags)
    If masked is flags:
        Return true
    End If
    Return false
End Process

Process called "extract_any_flag_set" that takes value as Integer, flags as Integer returns Boolean:
    Let masked be BitwiseCore.bit_and(value, flags)
    If masked is not 0:
        Return true
    End If
    Return false
End Process