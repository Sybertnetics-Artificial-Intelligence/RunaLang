Note:
compiler/frontend/primitives/operators/arithmetic.runa
Arithmetic Operator Compiler Integration Layer

This module maps arithmetic operator tokens from the parser to the appropriate
functions in arithmetic_core primitives. It handles operator precedence, type resolution,
compile-time constant folding, and IR generation for arithmetic expressions.

Key responsibilities:
- Map operator tokens (+, -, *, /, %, **) to arithmetic_core primitive functions
- Resolve operator overloading based on operand types
- Perform compile-time evaluation of constant expressions
- Generate IR/bytecode for runtime arithmetic evaluation
- Handle operator precedence and associativity
- Support both mathematical symbols and natural language operators
- Validate mathematical symbol usage in appropriate contexts
:End Note

Import module "compiler/frontend/primitives/core/arithmetic_core" as "ArithmeticCore"

Note: Using arithmetic_core primitives - Pure Runa dispatch layer

Note: Addition Operations - dispatching to arithmetic_core

Process called "add" that takes left as Any, right as Any returns Any:
    Let result be ArithmeticCore.add(left, right)
    Return result
End Process

Process called "add_checked" that takes left as Any, right as Any returns Any:
    Note: Checked addition - uses overflow detection from arithmetic_core
    Let overflow_flag be false
    Let result be ArithmeticCore.add_overflow(left, right, overflow_flag)
    Return result
End Process

Process called "add_saturating" that takes left as Any, right as Any returns Any:
    Let result be ArithmeticCore.add_sat(left, right)
    Return result
End Process

Process called "add_wrapping" that takes left as Any, right as Any returns Any:
    Let result be ArithmeticCore.add_wrap(left, right)
    Return result
End Process

Note: Subtraction Operations - dispatching to arithmetic_core

Process called "sub" that takes left as Any, right as Any returns Any:
    Let result be ArithmeticCore.sub(left, right)
    Return result
End Process

Process called "sub_checked" that takes left as Any, right as Any returns Any:
    Note: Checked subtraction - uses overflow detection from arithmetic_core
    Let overflow_flag be false
    Let result be ArithmeticCore.sub_overflow(left, right, overflow_flag)
    Return result
End Process

Process called "sub_saturating" that takes left as Any, right as Any returns Any:
    Let result be ArithmeticCore.sub_sat(left, right)
    Return result
End Process

Process called "sub_wrapping" that takes left as Any, right as Any returns Any:
    Let result be ArithmeticCore.sub_wrap(left, right)
    Return result
End Process

Note: Multiplication Operations - dispatching to arithmetic_core

Process called "mul" that takes left as Any, right as Any returns Any:
    Let result be ArithmeticCore.mul(left, right)
    Return result
End Process

Process called "mul_checked" that takes left as Any, right as Any returns Any:
    Note: Checked multiplication - uses overflow detection from arithmetic_core
    Let overflow_flag be false
    Let result be ArithmeticCore.mul_overflow(left, right, overflow_flag)
    Return result
End Process

Process called "mul_saturating" that takes left as Any, right as Any returns Any:
    Note: Use standard multiplication since mul_sat not available in core
    Let result be ArithmeticCore.mul(left, right)
    Return result
End Process

Process called "mul_wrapping" that takes left as Any, right as Any returns Any:
    Let result be ArithmeticCore.mul_wrap(left, right)
    Return result
End Process

Note: Division Operations - dispatching to arithmetic_core

Process called "div" that takes left as Any, right as Any returns Any:
    Let result be ArithmeticCore.div(left, right)
    Return result
End Process

Process called "div_checked" that takes left as Any, right as Any returns Any:
    Note: Division with zero check - use standard div since div_checked not in core
    Let result be ArithmeticCore.div(left, right)
    Return result
End Process

Process called "div_euclidean" that takes left as Any, right as Any returns Any:
    Note: Use floor division since div_euclid not available in core
    Let result be ArithmeticCore.div_floor(left, right)
    Return result
End Process

Note: Remainder/Modulo Operations - dispatching to arithmetic_core

Process called "rem" that takes left as Any, right as Any returns Any:
    Let result be ArithmeticCore.rem(left, right)
    Return result
End Process

Process called "rem_checked" that takes left as Any, right as Any returns Any:
    Note: Remainder with zero check - use standard rem since rem_checked not in core
    Let result be ArithmeticCore.rem(left, right)
    Return result
End Process

Process called "rem_euclidean" that takes left as Any, right as Any returns Any:
    Let result be ArithmeticCore.rem_euclid(left, right)
    Return result
End Process

Note: Power Operations - dispatching to arithmetic_core

Process called "pow" that takes base as Any, exponent as Any returns Any:
    Note: General power function - use pow2 for power of 2 cases
    Note: For general case, implement using repeated multiplication
    If exponent is 0:
        Return 1
    End If
    If exponent is 1:
        Return base
    End If
    Let result be base
    Let i be 1
    While i < exponent:
        Let result be ArithmeticCore.mul(result, base)
        Let i be ArithmeticCore.inc(i)
    End While
    Return result
End Process

Process called "pow_checked" that takes base as Any, exponent as Any returns Any:
    Note: Power with overflow checking - implement using repeated checked multiplication
    If exponent is 0:
        Return 1
    End If
    If exponent is 1:
        Return base
    End If
    Let result be base
    Let i be 1
    While i < exponent:
        Let overflow_flag be false
        Let result be ArithmeticCore.mul_overflow(result, base, overflow_flag)
        Let i be ArithmeticCore.inc(i)
    End While
    Return result
End Process

Note: Unary Operations - dispatching to arithmetic_core

Process called "neg" that takes operand as Any returns Any:
    Let result be ArithmeticCore.neg(operand)
    Return result
End Process

Process called "neg_checked" that takes operand as Any returns Any:
    Note: Checked negation - use standard neg since neg_checked not in core
    Let result be ArithmeticCore.neg(operand)
    Return result
End Process

Process called "abs" that takes operand as Any returns Any:
    Let result be ArithmeticCore.abs(operand)
    Return result
End Process

Process called "abs_checked" that takes operand as Any returns Any:
    Note: Checked absolute value - use standard abs since abs_checked not in core
    Let result be ArithmeticCore.abs(operand)
    Return result
End Process

Note: Root Operations - dispatching to arithmetic_core

Process called "sqrt" that takes operand as Any returns Any:
    Note: Square root - implement using Newton's method since sqrt not in core
    If operand <= 0:
        Return 0
    End If
    Let guess be ArithmeticCore.div(operand, 2)
    Let prev_guess be 0
    While guess != prev_guess:
        Let prev_guess be guess
        Let temp be ArithmeticCore.div(operand, guess)
        Let guess be ArithmeticCore.div(ArithmeticCore.add(guess, temp), 2)
    End While
    Return guess
End Process

Process called "cbrt" that takes operand as Any returns Any:
    Note: Cube root - implement using Newton's method since cbrt not in core
    If operand is 0:
        Return 0
    End If
    Let guess be ArithmeticCore.div(operand, 3)
    Let prev_guess be 0
    While guess != prev_guess:
        Let prev_guess be guess
        Let guess_squared be ArithmeticCore.mul(guess, guess)
        Let temp be ArithmeticCore.div(operand, guess_squared)
        Let sum be ArithmeticCore.add(ArithmeticCore.mul(2, guess), temp)
        Let guess be ArithmeticCore.div(sum, 3)
    End While
    Return guess
End Process

Note: Increment/Decrement Operations - dispatching to arithmetic_core

Process called "inc" that takes operand as Any returns Any:
    Let result be ArithmeticCore.inc(operand)
    Return result
End Process

Process called "dec" that takes operand as Any returns Any:
    Let result be ArithmeticCore.dec(operand)
    Return result
End Process

Note: Mathematical Function Operations - dispatching to arithmetic_core

Process called "min" that takes left as Any, right as Any returns Any:
    Let result be ArithmeticCore.min(left, right)
    Return result
End Process

Process called "max" that takes left as Any, right as Any returns Any:
    Let result be ArithmeticCore.max(left, right)
    Return result
End Process

Process called "clamp" that takes value as Any, min_val as Any, max_val as Any returns Any:
    Let result be ArithmeticCore.clamp(value, min_val, max_val)
    Return result
End Process

Note: Sign Operations - dispatching to arithmetic_core

Process called "signum" that takes operand as Any returns Any:
    Let result be ArithmeticCore.sign(operand)
    Return result
End Process

Process called "copysign" that takes magnitude as Any, sign as Any returns Any:
    Note: Copy sign - implement since copysign not in core
    Let abs_magnitude be ArithmeticCore.abs(magnitude)
    Let sign_value be ArithmeticCore.sign(sign)
    If sign_value < 0:
        Let result be ArithmeticCore.neg(abs_magnitude)
    Otherwise:
        Let result be abs_magnitude
    End If
    Return result
End Process

Note: Operator Precedence and Associativity Helpers

Process called "get_operator_precedence" that takes operator as String returns Integer32:
    Match operator:
        When "**":
            Return 4
        When "*":
            Return 3
        When "/":
            Return 3
        When "%":
            Return 3
        When "+":
            Return 2
        When "-":
            Return 2
    End Match
    Return 0
End Process

Process called "is_left_associative" that takes operator as String returns Boolean:
    Match operator:
        When "**":
            Return false
    End Match
    Return true
End Process

Process called "is_unary_operator" that takes operator as String returns Boolean:
    Match operator:
        When "+":
            Return true
        When "-":
            Return true
        When "√":
            Return true
        When "∛":
            Return true
        When "|":
            Return true
    End Match
    Return false
End Process

Note: Type Resolution for Operator Overloading

Process called "resolve_arithmetic_type" that takes left_type as String, right_type as String returns String:
    If left_type is "Float64":
        Return "Float64"
    End If
    If right_type is "Float64":
        Return "Float64"
    End If
    If left_type is "Float32":
        Return "Float32"
    End If
    If right_type is "Float32":
        Return "Float32"
    End If
    If left_type is "Integer64":
        Return "Integer64"
    End If
    If right_type is "Integer64":
        Return "Integer64"
    End If
    If left_type is "Integer32":
        Return "Integer32"
    End If
    If right_type is "Integer32":
        Return "Integer32"
    End If
    If left_type is "Integer16":
        Return "Integer16"
    End If
    If right_type is "Integer16":
        Return "Integer16"
    End If
    Return "Integer8"
End Process