Note: System call primitive for direct OS interaction

@Reasoning
System calls are the fundamental interface between user programs and the operating system.
This primitive provides direct syscall access without any dependencies, allowing the
compiler and runtime to interact with the OS for file I/O, memory management, process
control, and other kernel services. Different platforms have different syscall conventions.
@End Reasoning

Type called "SyscallResult":
    Note: Result from a system call
    
    @Implementation
    System calls return values in specific registers. Negative values typically
    indicate errors, with the absolute value being the error code.
    @End Implementation
    
    value as Integer      Note: Return value or negative error code
    is_error as Boolean   Note: True if syscall failed
    error_code as Integer Note: Error code if failed
End Type

Type called "SyscallRegisters":
    Note: Register state for syscall
    
    @Implementation
    Different architectures use different registers for syscall parameters.
    This structure abstracts the register layout for syscall conventions.
    @End Implementation
    
    syscall_number as Integer
    arg1 as Integer
    arg2 as Integer
    arg3 as Integer
    arg4 as Integer
    arg5 as Integer
    arg6 as Integer
End Type

Process called "make_syscall_x86_64" that takes number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer, arg5 as Integer, arg6 as Integer returns SyscallResult:
    Note: Make system call on x86_64 Linux
    
    @Implementation
    Linux x86_64 syscall convention:
    - RAX: syscall number
    - RDI: first argument
    - RSI: second argument
    - RDX: third argument
    - R10: fourth argument (not RCX due to syscall instruction)
    - R8: fifth argument
    - R9: sixth argument
    - Return value in RAX, negative for errors
    @End Implementation
    
    Let result be SyscallResult
    Let return_value as Integer
    
    Inline Assembly:
        "mov %0, %1"                   Note: Load syscall number
        "mov %2, %3"                   Note: Load first argument
        "mov %4, %5"                   Note: Load second argument
        "mov %6, %7"                   Note: Load third argument
        "mov %8, %9"                   Note: Load fourth argument (r10, not rcx!)
        "mov %10, %11"                 Note: Load fifth argument
        "mov %12, %13"                 Note: Load sixth argument
        "syscall"                      Note: Invoke kernel
        "mov %14, rax"                 Note: Store return value
        : "=r"(return_value)
        : "r"(rax), "r"(number), "r"(rdi), "r"(arg1), "r"(rsi), "r"(arg2), "r"(rdx), "r"(arg3), "r"(r10), "r"(arg4), "r"(r8), "r"(arg5), "r"(r9), "r"(arg6), "r"(return_value)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "memory"
    End Assembly
    
    Set result.value to return_value
    
    Note: Check for error (negative return value)
    If return_value is less than 0 and return_value is greater than -4096:
        Set result.is_error to true
        Set result.error_code to 0 minus return_value
    Otherwise:
        Set result.is_error to false
        Set result.error_code to 0
    End If
    
    Return result
End Process

Process called "make_syscall_aarch64" that takes number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer, arg5 as Integer, arg6 as Integer returns SyscallResult:
    Note: Make system call on AArch64 Linux
    
    @Implementation
    Linux AArch64 syscall convention:
    - X8: syscall number
    - X0: first argument and return value
    - X1: second argument
    - X2: third argument
    - X3: fourth argument
    - X4: fifth argument
    - X5: sixth argument
    - SVC #0 instruction to invoke kernel
    @End Implementation
    
    Let result be SyscallResult
    Let return_value as Integer
    
    Inline Assembly:
        "mov x8, %0"                   Note: Load syscall number
        "mov x0, %1"                   Note: Load first argument
        "mov x1, %2"                   Note: Load second argument
        "mov x2, %3"                   Note: Load third argument
        "mov x3, %4"                   Note: Load fourth argument
        "mov x4, %5"                   Note: Load fifth argument
        "mov x5, %6"                   Note: Load sixth argument
        "svc #0"                       Note: Supervisor call
        "mov %7, x0"                   Note: Store return value
        : "=r"(return_value)
        : "r"(number), "r"(arg1), "r"(arg2), "r"(arg3), "r"(arg4), "r"(arg5), "r"(arg6), "r"(return_value)
        : "x0", "x1", "x2", "x3", "x4", "x5", "x8", "memory"
    End Assembly
    
    Set result.value to return_value
    
    Note: Check for error
    If return_value is less than 0 and return_value is greater than -4096:
        Set result.is_error to true
        Set result.error_code to 0 minus return_value
    Otherwise:
        Set result.is_error to false
        Set result.error_code to 0
    End If
    
    Return result
End Process

Process called "make_syscall" that takes number as Integer returns SyscallResult:
    Note: Make system call with no arguments
    
    @Implementation
    Convenience wrapper for syscalls that take no arguments,
    like getpid, getuid, etc.
    @End Implementation
    
    Return make_syscall_1(number, 0)
End Process

Process called "make_syscall_1" that takes number as Integer, arg1 as Integer returns SyscallResult:
    Note: Make system call with one argument
    
    @Implementation
    Common case for syscalls with single argument like close(fd).
    Detects platform and calls appropriate implementation.
    @End Implementation
    
    Note: Platform detection via compile-time or runtime check
    Inline Assembly:
        "#ifdef __x86_64__"            Note: Check for x86_64 platform
        "mov %0, %1"                   Note: Set platform to x86_64
        "#else"                        Note: Not x86_64, check AArch64
        "#ifdef __aarch64__"           Note: Check for AArch64 platform
        "mov %0, %2"                   Note: Set platform to AArch64
        "#else"                        Note: Unknown platform
        "mov %0, %3"                   Note: Set platform to unknown
        "#endif"                       Note: End AArch64 check
        "#endif"                       Note: End x86_64 check
        "mov %4, %0"                   Note: Store platform result
        : "=r"(platform)
        : "i"(1), "i"(2), "i"(0), "r"(platform)
        : "memory"
    End Assembly
    
    Let platform as Integer
    If platform equals 1:
        Return make_syscall_x86_64(number, arg1, 0, 0, 0, 0, 0)
    Otherwise:
        If platform equals 2:
            Return make_syscall_aarch64(number, arg1, 0, 0, 0, 0, 0)
        End If
    End If
    
    Note: Fallback for unknown platform
    Let result be SyscallResult
    Set result.value to -1
    Set result.is_error to true
    Set result.error_code to 38  Note: ENOSYS - Function not implemented
    Return result
End Process

Process called "make_syscall_2" that takes number as Integer, arg1 as Integer, arg2 as Integer returns SyscallResult:
    Note: Make system call with two arguments
    
    @Implementation
    Common case for syscalls like rename(old, new), kill(pid, sig).
    @End Implementation
    
    Inline Assembly:
        "#ifdef __x86_64__"            Note: Check for x86_64 platform
        "mov %0, %1"                   Note: Set platform to x86_64
        "#else"                        Note: Not x86_64, check AArch64
        "#ifdef __aarch64__"           Note: Check for AArch64 platform
        "mov %0, %2"                   Note: Set platform to AArch64
        "#else"                        Note: Unknown platform
        "mov %0, %3"                   Note: Set platform to unknown
        "#endif"                       Note: End AArch64 check
        "#endif"                       Note: End x86_64 check
        "mov %4, %0"                   Note: Store platform result
        : "=r"(platform)
        : "i"(1), "i"(2), "i"(0), "r"(platform)
        : "memory"
    End Assembly
    
    Let platform as Integer
    If platform equals 1:
        Return make_syscall_x86_64(number, arg1, arg2, 0, 0, 0, 0)
    Otherwise:
        If platform equals 2:
            Return make_syscall_aarch64(number, arg1, arg2, 0, 0, 0, 0)
        End If
    End If
    
    Let result be SyscallResult
    Set result.value to -1
    Set result.is_error to true
    Set result.error_code to 38
    Return result
End Process

Process called "make_syscall_3" that takes number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer returns SyscallResult:
    Note: Make system call with three arguments
    
    @Implementation
    Common case for syscalls like read(fd, buf, count), write(fd, buf, count).
    @End Implementation
    
    Inline Assembly:
        "#ifdef __x86_64__"            Note: Check for x86_64 platform
        "mov %0, %1"                   Note: Set platform to x86_64
        "#else"                        Note: Not x86_64, check AArch64
        "#ifdef __aarch64__"           Note: Check for AArch64 platform
        "mov %0, %2"                   Note: Set platform to AArch64
        "#else"                        Note: Unknown platform
        "mov %0, %3"                   Note: Set platform to unknown
        "#endif"                       Note: End AArch64 check
        "#endif"                       Note: End x86_64 check
        "mov %4, %0"                   Note: Store platform result
        : "=r"(platform)
        : "i"(1), "i"(2), "i"(0), "r"(platform)
        : "memory"
    End Assembly
    
    Let platform as Integer
    If platform equals 1:
        Return make_syscall_x86_64(number, arg1, arg2, arg3, 0, 0, 0)
    Otherwise:
        If platform equals 2:
            Return make_syscall_aarch64(number, arg1, arg2, arg3, 0, 0, 0)
        End If
    End If
    
    Let result be SyscallResult
    Set result.value to -1
    Set result.is_error to true
    Set result.error_code to 38
    Return result
End Process

Process called "make_syscall_4" that takes number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer returns SyscallResult:
    Note: Make system call with four arguments
    
    @Implementation
    Used for syscalls like openat(dirfd, pathname, flags, mode).
    @End Implementation
    
    Inline Assembly:
        "#ifdef __x86_64__"            Note: Check for x86_64 platform
        "mov %0, %1"                   Note: Set platform to x86_64
        "#else"                        Note: Not x86_64, check AArch64
        "#ifdef __aarch64__"           Note: Check for AArch64 platform
        "mov %0, %2"                   Note: Set platform to AArch64
        "#else"                        Note: Unknown platform
        "mov %0, %3"                   Note: Set platform to unknown
        "#endif"                       Note: End AArch64 check
        "#endif"                       Note: End x86_64 check
        "mov %4, %0"                   Note: Store platform result
        : "=r"(platform)
        : "i"(1), "i"(2), "i"(0), "r"(platform)
        : "memory"
    End Assembly
    
    Let platform as Integer
    If platform equals 1:
        Return make_syscall_x86_64(number, arg1, arg2, arg3, arg4, 0, 0)
    Otherwise:
        If platform equals 2:
            Return make_syscall_aarch64(number, arg1, arg2, arg3, arg4, 0, 0)
        End If
    End If
    
    Let result be SyscallResult
    Set result.value to -1
    Set result.is_error to true
    Set result.error_code to 38
    Return result
End Process

Process called "make_syscall_5" that takes number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer, arg5 as Integer returns SyscallResult:
    Note: Make system call with five arguments
    
    @Implementation
    Used for syscalls like prctl, mount, etc.
    @End Implementation
    
    Inline Assembly:
        "#ifdef __x86_64__"            Note: Check for x86_64 platform
        "mov %0, %1"                   Note: Set platform to x86_64
        "#else"                        Note: Not x86_64, check AArch64
        "#ifdef __aarch64__"           Note: Check for AArch64 platform
        "mov %0, %2"                   Note: Set platform to AArch64
        "#else"                        Note: Unknown platform
        "mov %0, %3"                   Note: Set platform to unknown
        "#endif"                       Note: End AArch64 check
        "#endif"                       Note: End x86_64 check
        "mov %4, %0"                   Note: Store platform result
        : "=r"(platform)
        : "i"(1), "i"(2), "i"(0), "r"(platform)
        : "memory"
    End Assembly
    
    Let platform as Integer
    If platform equals 1:
        Return make_syscall_x86_64(number, arg1, arg2, arg3, arg4, arg5, 0)
    Otherwise:
        If platform equals 2:
            Return make_syscall_aarch64(number, arg1, arg2, arg3, arg4, arg5, 0)
        End If
    End If
    
    Let result be SyscallResult
    Set result.value to -1
    Set result.is_error to true
    Set result.error_code to 38
    Return result
End Process

Process called "make_syscall_6" that takes number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer, arg5 as Integer, arg6 as Integer returns SyscallResult:
    Note: Make system call with six arguments
    
    @Implementation
    Maximum number of syscall arguments. Used for mmap and similar calls.
    @End Implementation
    
    Inline Assembly:
        "#ifdef __x86_64__"            Note: Check for x86_64 platform
        "mov %0, %1"                   Note: Set platform to x86_64
        "#else"                        Note: Not x86_64, check AArch64
        "#ifdef __aarch64__"           Note: Check for AArch64 platform
        "mov %0, %2"                   Note: Set platform to AArch64
        "#else"                        Note: Unknown platform
        "mov %0, %3"                   Note: Set platform to unknown
        "#endif"                       Note: End AArch64 check
        "#endif"                       Note: End x86_64 check
        "mov %4, %0"                   Note: Store platform result
        : "=r"(platform)
        : "i"(1), "i"(2), "i"(0), "r"(platform)
        : "memory"
    End Assembly
    
    Let platform as Integer
    If platform equals 1:
        Return make_syscall_x86_64(number, arg1, arg2, arg3, arg4, arg5, arg6)
    Otherwise:
        If platform equals 2:
            Return make_syscall_aarch64(number, arg1, arg2, arg3, arg4, arg5, arg6)
        End If
    End If
    
    Let result be SyscallResult
    Set result.value to -1
    Set result.is_error to true
    Set result.error_code to 38
    Return result
End Process

Process called "get_syscall_number" that takes name as Pointer returns Integer:
    Note: Get syscall number by name
    
    @Implementation
    Maps syscall names to numbers for the current platform.
    Supports the core set of essential syscalls: exit, read, write,
    open, close, mmap, and munmap. Returns -1 for unknown syscalls.
    Each syscall name is compared via string matching and returns
    the corresponding x86_64 Linux syscall number.
    @End Implementation
    
    Inline Assembly:
        "mov %1, %2"                   Note: Load syscall name
        "lea %3, [exit_str]"           Note: Load exit string address
        "call strcmp_syscall"          Note: Compare with exit
        "test %0, %0"                  Note: Check comparison result
        "jz .return_exit"              Note: Jump if exit match
        "lea %4, [read_str]"           Note: Load read string address
        "call strcmp_syscall"          Note: Compare with read
        "test %0, %0"                  Note: Check comparison result
        "jz .return_read"              Note: Jump if read match
        "lea %5, [write_str]"          Note: Load write string address
        "call strcmp_syscall"          Note: Compare with write
        "test %0, %0"                  Note: Check comparison result
        "jz .return_write"             Note: Jump if write match
        "lea %6, [open_str]"           Note: Load open string address
        "call strcmp_syscall"          Note: Compare with open
        "test %0, %0"                  Note: Check comparison result
        "jz .return_open"              Note: Jump if open match
        "lea %7, [close_str]"          Note: Load close string address
        "call strcmp_syscall"          Note: Compare with close
        "test %0, %0"                  Note: Check comparison result
        "jz .return_close"             Note: Jump if close match
        "lea %8, [mmap_str]"           Note: Load mmap string address
        "call strcmp_syscall"          Note: Compare with mmap
        "test %0, %0"                  Note: Check comparison result
        "jz .return_mmap"              Note: Jump if mmap match
        "lea %9, [munmap_str]"         Note: Load munmap string address
        "call strcmp_syscall"          Note: Compare with munmap
        "test %0, %0"                  Note: Check comparison result
        "jz .return_munmap"            Note: Jump if munmap match
        "mov %0, %10"                  Note: Unknown syscall
        "jmp .done"                    Note: Jump to completion
        ".return_exit:"                 Note: Return exit syscall number
        "mov %0, %11"                  Note: sys_exit = 60
        "jmp .done"                    Note: Jump to completion
        ".return_read:"                 Note: Return read syscall number
        "mov %0, %12"                  Note: sys_read = 0
        "jmp .done"                    Note: Jump to completion
        ".return_write:"                Note: Return write syscall number
        "mov %0, %13"                  Note: sys_write = 1
        "jmp .done"                    Note: Jump to completion
        ".return_open:"                 Note: Return open syscall number
        "mov %0, %14"                  Note: sys_open = 2
        "jmp .done"                    Note: Jump to completion
        ".return_close:"                Note: Return close syscall number
        "mov %0, %15"                  Note: sys_close = 3
        "jmp .done"                    Note: Jump to completion
        ".return_mmap:"                 Note: Return mmap syscall number
        "mov %0, %16"                  Note: sys_mmap = 9
        "jmp .done"                    Note: Jump to completion
        ".return_munmap:"               Note: Return munmap syscall number
        "mov %0, %17"                  Note: sys_munmap = 11
        ".done:"                        Note: Store result
        "mov %18, %0"                  Note: Store final result
        : "=r"(result)
        : "r"(rsi), "r"(name), "r"(rdi), "r"(rdi), "r"(rdi), "r"(rdi), "r"(rdi), "r"(rdi), "r"(rdi), "i"(-1), "i"(60), "i"(0), "i"(1), "i"(2), "i"(3), "i"(9), "i"(11), "r"(result)
        : "rsi", "rdi", "rax", "memory"
    End Assembly
    
    Let result as Integer
    Return result
End Process

Process called "is_syscall_error" that takes result as SyscallResult returns Boolean:
    Note: Check if syscall resulted in error
    
    @Implementation
    Convenience function to check syscall success.
    @End Implementation
    
    Return result.is_error
End Process

Process called "get_errno" that takes result as SyscallResult returns Integer:
    Note: Get error code from failed syscall
    
    @Implementation
    Returns the error code (errno) from a failed syscall.
    Returns 0 if syscall succeeded.
    @End Implementation
    
    If result.is_error:
        Return result.error_code
    Otherwise:
        Return 0
    End If
End Process

Process called "make_syscall_windows" that takes number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer, arg5 as Integer, arg6 as Integer returns SyscallResult:
    Note: Make Windows NT system call
    
    @Implementation
    Windows x64 syscall convention:
    - R10: syscall number
    - RCX: first argument
    - RDX: second argument
    - R8: third argument
    - R9: fourth argument
    - Stack: fifth and sixth arguments
    - SYSCALL instruction to enter kernel
    - Return value in RAX, NTSTATUS format
    @End Implementation
    
    Let result be SyscallResult
    Let return_value as Integer
    
    Inline Assembly:
        "push %rbp"                    Note: Save base pointer
        "mov %rbp, %rsp"               Note: Setup frame pointer
        "sub %rsp, 32"                 Note: Shadow space for Windows calling convention
        "mov %0, %1"                   Note: Load syscall number in R10
        "mov %2, %3"                   Note: Load first argument
        "mov %4, %5"                   Note: Load second argument
        "mov %6, %7"                   Note: Load third argument
        "mov %8, %9"                   Note: Load fourth argument
        "mov %10, %11"                 Note: Load fifth argument for stack
        "mov [%rsp+32], %10"           Note: Store fifth argument on stack
        "mov %12, %13"                 Note: Load sixth argument for stack
        "mov [%rsp+40], %12"           Note: Store sixth argument on stack
        "syscall"                      Note: Invoke Windows kernel
        "mov %14, %rax"                Note: Store return value
        "add %rsp, 32"                 Note: Restore stack
        "pop %rbp"                     Note: Restore base pointer
        : "=r"(return_value)
        : "r"(r10), "r"(number), "r"(rcx), "r"(arg1), "r"(rdx), "r"(arg2), "r"(r8), "r"(arg3), "r"(r9), "r"(arg4), "r"(rax), "r"(arg5), "r"(rax), "r"(arg6), "r"(return_value)
        : "rbp", "rsp", "r10", "rcx", "rdx", "r8", "r9", "rax", "memory"
    End Assembly
    
    Set result.value to return_value
    
    Note: Check for error (NTSTATUS format)
    Note: NTSTATUS error codes have high bit set (0x80000000 and above)
    If return_value is greater than or equal to 0x80000000:
        Set result.is_error to true
        Set result.error_code to (return_value and 0x0000FFFF)  Note: Extract error code
    Otherwise:
        Set result.is_error to false
        Set result.error_code to 0
    End If
    
    Return result
End Process

Process called "detect_platform" that returns Integer:
    Note: Detect current platform for syscall routing
    
    @Implementation
    Returns 1 for Linux x86_64, 2 for Linux AArch64, 3 for Windows, 0 for unknown.
    @End Implementation
    
    Inline Assembly:
        "#ifdef _WIN32"                Note: Check for Windows platform
        "mov %0, %1"                   Note: Set platform to Windows
        "#else"                        Note: Not Windows, check others
        "#ifdef __x86_64__"            Note: Check for x86_64 platform
        "mov %0, %2"                   Note: Set platform to x86_64
        "#else"                        Note: Not x86_64, check AArch64
        "#ifdef __aarch64__"           Note: Check for AArch64 platform
        "mov %0, %3"                   Note: Set platform to AArch64
        "#else"                        Note: Unknown platform
        "mov %0, %4"                   Note: Set platform to unknown
        "#endif"                       Note: End AArch64 check
        "#endif"                       Note: End x86_64 check
        "#endif"                       Note: End Windows check
        "mov %5, %0"                   Note: Store platform result
        : "=r"(platform)
        : "i"(3), "i"(1), "i"(2), "i"(0), "r"(platform)
        : "memory"
    End Assembly
    
    Let platform as Integer
    Return platform
End Process

Note: =====================================================================
Note: WINDOWS NT SYSCALL NUMBERS (Additional)
Note: =====================================================================

@Reasoning
These are additional Windows NT syscall numbers needed by the POSIX compatibility
layer. They supplement the core syscalls with pipe operations, process management,
and security functions.
@End Reasoning

Note: Named Pipe Operations
Let NT_CREATE_NAMED_PIPE be 0x1115
Let NT_CONNECT_NAMED_PIPE be 0x1116

Note: Process and Thread Management
Let NT_GET_CURRENT_PROCESS_ID be 0x1127
Let NT_QUERY_INFORMATION_PROCESS be 0x1128
Let NT_CREATE_JOB_OBJECT be 0x1129
Let NT_ASSIGN_PROCESS_TO_JOB_OBJECT be 0x112A
Let NT_FREE_CONSOLE be 0x112B
Let NT_OPEN_PROCESS be 0x112C

Note: Synchronization Objects
Let NT_WAIT_FOR_SINGLE_OBJECT be 0x1001
Let NT_WAIT_FOR_MULTIPLE_OBJECTS be 0x1125
Let NT_GET_EXIT_CODE_PROCESS be 0x1126
Let NT_CREATE_SEMAPHORE be 0x1102
Let NT_RELEASE_SEMAPHORE be 0x1103

Note: System Information
Let NT_GET_SYSTEM_INFO be 0x1105
Let NT_SET_PROCESS_WORKING_SET_SIZE be 0x1106
Let NT_GET_CURRENT_TEB be 0x1007

Note: Process Creation and Control
Let NT_CREATE_PROCESS_EX be 0x1120
Let NT_GET_MODULE_FILE_NAME be 0x1121
Let NT_RESUME_THREAD be 0x1124

Note: Time and Sleep Operations  
Let NT_DELAY_EXECUTION be 0x1130

Note: Security and Token Operations
Let NT_OPEN_PROCESS_TOKEN be 0x31
Let NT_QUERY_INFORMATION_TOKEN be 0x32
Let NT_GET_SECURITY_INFO be 0x33
Let NT_SET_SECURITY_INFO be 0x34
Let NT_ADJUST_PRIVILEGES_TOKEN be 0x35

Note: Helper function to get specific syscall numbers
Process called "get_windows_syscall_number" that takes operation_name as String returns Integer:
    @Implementation
    Returns the Windows NT syscall number for a given operation name.
    Used for dynamic syscall resolution.
    @End Implementation
    
    Match operation_name:
        When "CreateNamedPipe":
            Return NT_CREATE_NAMED_PIPE
        When "ConnectNamedPipe":
            Return NT_CONNECT_NAMED_PIPE
        When "GetCurrentProcessId":
            Return NT_GET_CURRENT_PROCESS_ID
        When "QueryInformationProcess":
            Return NT_QUERY_INFORMATION_PROCESS
        When "CreateJobObject":
            Return NT_CREATE_JOB_OBJECT
        When "AssignProcessToJobObject":
            Return NT_ASSIGN_PROCESS_TO_JOB_OBJECT
        When "FreeConsole":
            Return NT_FREE_CONSOLE
        When "OpenProcess":
            Return NT_OPEN_PROCESS
        When "WaitForSingleObject":
            Return NT_WAIT_FOR_SINGLE_OBJECT
        When "WaitForMultipleObjects":
            Return NT_WAIT_FOR_MULTIPLE_OBJECTS
        When "GetExitCodeProcess":
            Return NT_GET_EXIT_CODE_PROCESS
        When "CreateSemaphore":
            Return NT_CREATE_SEMAPHORE
        When "ReleaseSemaphore":
            Return NT_RELEASE_SEMAPHORE
        When "GetSystemInfo":
            Return NT_GET_SYSTEM_INFO
        When "SetProcessWorkingSetSize":
            Return NT_SET_PROCESS_WORKING_SET_SIZE
        When "DelayExecution":
            Return NT_DELAY_EXECUTION
        When "OpenProcessToken":
            Return NT_OPEN_PROCESS_TOKEN
        When "QueryInformationToken":
            Return NT_QUERY_INFORMATION_TOKEN
        When "AdjustPrivilegesToken":
            Return NT_ADJUST_PRIVILEGES_TOKEN
        Otherwise:
            Return 0  Note: Unknown operation
    End Match
End Process

Note: Syscall name strings
Inline Assembly:
    ".section .rodata"              Note: Read-only data section
    "exit_str: .asciz 'exit'"       Note: Exit syscall name string
    "read_str: .asciz 'read'"       Note: Read syscall name string
    "write_str: .asciz 'write'"     Note: Write syscall name string
    "open_str: .asciz 'open'"       Note: Open syscall name string
    "close_str: .asciz 'close'"     Note: Close syscall name string
    "mmap_str: .asciz 'mmap'"       Note: Mmap syscall name string
    "munmap_str: .asciz 'munmap'"   Note: Munmap syscall name string
    "strcmp_syscall:"               Note: String comparison function
    "push %rbx"                     Note: Save RBX register
    ".strcmp_loop:"                  Note: Start of comparison loop
    "mov %al, [%rdi]"               Note: Load byte from first string
    "mov %bl, [%rsi]"               Note: Load byte from second string
    "cmp %al, %bl"                  Note: Compare bytes
    "jne .strcmp_not_equal"         Note: Jump if not equal
    "test %al, %al"                 Note: Check for null terminator
    "jz .strcmp_equal"              Note: Jump if end of string
    "inc %rdi"                      Note: Advance first string pointer
    "inc %rsi"                      Note: Advance second string pointer
    "jmp .strcmp_loop"              Note: Continue loop
    ".strcmp_equal:"                 Note: Strings are equal
    "xor %rax, %rax"                Note: Return 0 for equal
    "pop %rbx"                      Note: Restore RBX register
    "ret"                           Note: Return from function
    ".strcmp_not_equal:"             Note: Strings are not equal
    "mov %rax, 1"                   Note: Return 1 for not equal
    "pop %rbx"                      Note: Restore RBX register
    "ret"                           Note: Return from function
    : 
    : 
    : "memory"
End Assembly