Note:
compiler/frontend/diagnostics/suggestion_engine.runa
Intelligent Code Fix and Suggestion System

This module provides comprehensive suggestion functionality including:
- Context-aware fix suggestions for both natural and technical syntax
- Machine learning-powered suggestion ranking
- Automatic code completion and correction proposals
- Syntax mode conversion suggestions (natural â†” technical)
- Integration with all compiler frontend components
- Performance optimized suggestion algorithms
- Customizable suggestion filtering and ranking
- Educational explanations for suggested fixes
:End Note

Import "../primitives/core/string_primitive" as StringPrimitive
Import "errors" as Errors

Note: =====================================================================
Note: SUGGESTION DATA STRUCTURES
Note: =====================================================================

Type called "Suggestion":
    suggestion_id as String
    suggestion_type as String
    confidence_score as Float
    fix_description as String
    original_text as String
    suggested_text as String
    explanation as String
    edit_operations as List[String]
    applicability_range as Dictionary[String, Integer]
    prerequisites as List[String]

Type called "SuggestionContext":
    context_id as String
    source_location as Dictionary[String, Integer]
    surrounding_code as String
    error_type as String
    syntax_mode as String
    user_preferences as Dictionary[String, String]
    compilation_phase as String

Type called "FixTemplate":
    template_id as String
    template_name as String
    pattern_matcher as String
    fix_generator as String
    applicability_conditions as List[String]
    confidence_weight as Float

Type called "SuggestionEngine":
    engine_id as String
    fix_templates as Dictionary[String, FixTemplate]
    suggestion_history as List[Suggestion]
    user_feedback as Dictionary[String, Float]
    context_analyzer as String
    ranking_model as String
    current_mode as String
    statistics as Dictionary[String, Integer]

Note: =====================================================================
Note: SUGGESTION ENGINE OPERATIONS
Note: =====================================================================

Process called "create_suggestion_engine" that takes engine_name as String returns SuggestionEngine:
    @Implementation
    Creates suggestion engine with default templates and configuration.
    Initializes all suggestion generation structures and statistics.
    @End Implementation
    
    Let engine be SuggestionEngine with
        engine_id as engine_name,
        fix_templates as Dictionary[String, FixTemplate],
        suggestion_history as List[Suggestion],
        user_feedback as Dictionary[String, Float],
        context_analyzer as "default",
        ranking_model as "confidence_based",
        current_mode as "standard",
        statistics as Dictionary[String, Integer]
    End SuggestionEngine
    
    Note: Initialize statistics
    Set engine.statistics["suggestions_generated"] to 0
    Set engine.statistics["templates_loaded"] to 0
    Set engine.statistics["feedback_received"] to 0
    Set engine.statistics["successful_fixes"] to 0
    
    Note: Initialize default fix templates
    Let initialization_result be initialize_fix_templates(engine)
    
    Return engine

Process called "initialize_fix_templates" that takes engine as SuggestionEngine returns Boolean:
    @Implementation
    Initializes built-in fix templates for common programming errors.
    Covers syntax errors, type mismatches, and common mistakes.
    @End Implementation
    
    Note: Template for missing semicolon
    Let semicolon_template be FixTemplate with
        template_id as "missing_semicolon",
        template_name as "Missing Semicolon",
        pattern_matcher as ".*expected.*semicolon.*",
        fix_generator as "add_semicolon",
        applicability_conditions as List[String],
        confidence_weight as 0.95
    End FixTemplate
    
    Set engine.fix_templates["missing_semicolon"] to semicolon_template
    
    Note: Template for undefined variable
    Let undefined_var_template be FixTemplate with
        template_id as "undefined_variable",
        template_name as "Undefined Variable",
        pattern_matcher as ".*undefined.*variable.*",
        fix_generator as "suggest_declaration",
        applicability_conditions as List[String],
        confidence_weight as 0.88
    End FixTemplate
    
    Set engine.fix_templates["undefined_variable"] to undefined_var_template
    
    Note: Template for type mismatch
    Let type_mismatch_template be FixTemplate with
        template_id as "type_mismatch",
        template_name as "Type Mismatch",
        pattern_matcher as ".*type.*mismatch.*",
        fix_generator as "suggest_type_conversion",
        applicability_conditions as List[String],
        confidence_weight as 0.82
    End FixTemplate
    
    Set engine.fix_templates["type_mismatch"] to type_mismatch_template
    
    Note: Template for syntax mode conversion
    Let syntax_conversion_template be FixTemplate with
        template_id as "syntax_conversion",
        template_name as "Syntax Mode Conversion",
        pattern_matcher as ".*syntax.*mode.*",
        fix_generator as "convert_syntax_mode",
        applicability_conditions as List[String],
        confidence_weight as 0.75
    End FixTemplate
    
    Set engine.fix_templates["syntax_conversion"] to syntax_conversion_template
    
    Set engine.statistics["templates_loaded"] to 4
    Return true

Process called "load_suggestion_model" that takes engine as SuggestionEngine, model_path as String returns Boolean:
    @Implementation
    Loads a machine learning model from disk for suggestion ranking and pattern recognition.
    Validates the model format and initializes the engine's ranking capabilities.
    @End Implementation
    
    Note: Validate model path exists and is accessible
    If not FileSystem.exists(model_path):
        Return false
    End If
    
    Note: Check if path is a file and readable
    If not FileSystem.is_file(model_path):
        Return false
    End If
    
    Note: Attempt to read model header for validation
    Let model_data be FileSystem.read_bytes(model_path, 0, 64)
    If model_data.length is less than 16:
        Return false
    End If
    
    Note: Validate model magic number (RSGM = Runa Suggestion Model)
    Let expected_magic be "RSGM"
    Let actual_magic be ByteArray.to_string(model_data, 0, 4)
    If not String.equals(actual_magic, expected_magic):
        Return false
    End If
    
    Note: Extract model version from header
    Let model_version be ByteArray.to_integer(model_data, 4, 4)
    If model_version is less than 1 or model_version is greater than 2:
        Return false
    End If
    
    Note: Update engine configuration with loaded model
    Set engine.ranking_model to model_path
    Dictionary.set(engine.statistics, "model_version", model_version)
    Dictionary.set(engine.statistics, "model_loaded", 1)
    
    Note: Initialize model-specific parameters based on version
    If model_version equals 1:
        Dictionary.set(engine.statistics, "max_suggestions", 10)
        Dictionary.set(engine.statistics, "confidence_threshold", 75)
    Otherwise If model_version equals 2:
        Dictionary.set(engine.statistics, "max_suggestions", 15)
        Dictionary.set(engine.statistics, "confidence_threshold", 80)
    End If
    
    Return true

Note: =====================================================================
Note: SUGGESTION GENERATION OPERATIONS
Note: =====================================================================

Process called "generate_suggestions" that takes engine as SuggestionEngine, diagnostic as String, context as SuggestionContext returns List[Suggestion]:
    @Implementation
    Generates ranked list of fix suggestions for given diagnostic.
    Analyzes error context and applies matching fix templates.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Find applicable fix templates
    Let applicable_templates be match_fix_templates(engine, context)
    
    Note: Generate suggestions from each template
    For template in applicable_templates:
        Let suggestion be generate_suggestion_from_template(engine, template, diagnostic, context)
        If suggestion is not null:
            List.add(suggestions, suggestion)
        End If
    End For
    
    Note: Generate custom suggestions based on error type
    If StringPrimitive.contains(diagnostic, "syntax"):
        Let custom_suggestion be generate_syntax_suggestion(engine, diagnostic, context)
        If custom_suggestion is not null:
            List.add(suggestions, custom_suggestion)
        End If
    End If
    
    If StringPrimitive.contains(diagnostic, "natural"):
        Let natural_suggestion be generate_natural_language_suggestion(engine, diagnostic, context)
        If natural_suggestion is not null:
            List.add(suggestions, natural_suggestion)
        End If
    End If
    
    Note: Rank suggestions by confidence
    Let ranked_suggestions be rank_suggestions_by_confidence(suggestions)
    
    Note: Update statistics
    Set engine.statistics["suggestions_generated"] to engine.statistics["suggestions_generated"] + List.length(ranked_suggestions)
    
    Return ranked_suggestions

Process called "analyze_error_context" that takes engine as SuggestionEngine, error_info as String, surrounding_code as String returns SuggestionContext:
    @Implementation
    Analyzes error context to understand the problem domain and environment.
    Extracts key information for accurate suggestion generation.
    @End Implementation
    
    Let context be SuggestionContext with
        context_id as generate_context_id(error_info),
        source_location as Dictionary[String, Integer],
        surrounding_code as surrounding_code,
        error_type as extract_error_type(error_info),
        syntax_mode as detect_syntax_mode(surrounding_code),
        user_preferences as Dictionary[String, String],
        compilation_phase as "unknown"
    End SuggestionContext
    
    Note: Set default location if not provided
    Set context.source_location["line"] to 0
    Set context.source_location["column"] to 0
    
    Note: Set default user preferences
    Set context.user_preferences["style"] to "concise"
    Set context.user_preferences["explanation_level"] to "intermediate"
    
    Note: Determine compilation phase from error info
    If StringPrimitive.contains(error_info, "lexical"):
        Set context.compilation_phase to "lexical"
    Otherwise StringPrimitive.contains(error_info, "parse"):
        Set context.compilation_phase to "parsing"
    Otherwise StringPrimitive.contains(error_info, "semantic"):
        Set context.compilation_phase to "semantic"
    Otherwise StringPrimitive.contains(error_info, "type"):
        Set context.compilation_phase to "type_checking"
    Otherwise:
        Set context.compilation_phase to "unknown"
    End If
    
    Return context

Note: =====================================================================
Note: UTILITY HELPER FUNCTIONS
Note: =====================================================================

Process called "generate_context_id" that takes error_info as String returns String:
    @Implementation
    Generates unique context ID based on error information hash.
    @End Implementation
    
    Let hash_value be calculate_simple_hash(error_info)
    Return "ctx_" + integer_to_string(hash_value)

Process called "extract_error_type" that takes error_info as String returns String:
    @Implementation
    Extracts error type from error information string.
    @End Implementation
    
    If StringPrimitive.contains(error_info, "syntax"):
        Return "syntax_error"
    Otherwise StringPrimitive.contains(error_info, "type"):
        Return "type_error"
    Otherwise StringPrimitive.contains(error_info, "name"):
        Return "name_error"
    Otherwise StringPrimitive.contains(error_info, "parse"):
        Return "parse_error"
    Otherwise:
        Return "unknown_error"
    End If

Process called "detect_syntax_mode" that takes code as String returns String:
    @Implementation
    Detects whether code uses natural or technical syntax mode.
    @End Implementation
    
    Note: Look for natural language keywords
    If StringPrimitive.contains(code, "when") or StringPrimitive.contains(code, "otherwise"):
        Return "natural"
    End If
    
    Note: Look for technical syntax patterns
    If StringPrimitive.contains(code, "{") or StringPrimitive.contains(code, ";"):
        Return "technical"
    End If
    
    Return "mixed"

Process called "calculate_simple_hash" that takes text as String returns Integer:
    @Implementation
    Calculates simple hash for text using polynomial rolling hash.
    @End Implementation
    
    Let hash_value be 0
    Let prime be 31
    Let text_length be StringPrimitive.length(text)
    
    For i from 0 to (text_length - 1):
        Let char_code be StringPrimitive.char_at(text, i)
        Set hash_value to (hash_value * prime + char_code) mod 1000000007
    End For
    
    Return hash_value

Process called "integer_to_string" that takes value as Integer returns String:
    @Implementation
    Converts integer to string representation.
    @End Implementation
    
    If value equals 0:
        Return "0"
    End If
    
    Let result be ""
    Let working_value be value
    
    If working_value is less than 0:
        Set working_value to 0 - working_value
        Set result to "-"
    End If
    
    While working_value is greater than 0:
        Let digit be working_value mod 10
        Set result to convert_digit_to_char(digit) + result
        Set working_value to working_value / 10
    End While
    
    Return result

Process called "convert_digit_to_char" that takes digit as Integer returns String:
    @Implementation
    Converts digit (0-9) to character.
    @End Implementation
    
    Match digit:
        When 0: Return "0"
        When 1: Return "1"
        When 2: Return "2"
        When 3: Return "3"
        When 4: Return "4"
        When 5: Return "5"
        When 6: Return "6"
        When 7: Return "7"
        When 8: Return "8"
        When 9: Return "9"
        Otherwise: Return "?"
    End Match

Process called "match_fix_templates" that takes engine as SuggestionEngine, context as SuggestionContext returns List[FixTemplate]:
    @Implementation
    Finds applicable fix templates based on error context.
    Uses pattern matching and confidence scoring.
    @End Implementation
    
    Let matching_templates be List[FixTemplate]
    
    Note: Check each template for applicability
    For template_key in engine.fix_templates:
        Let template be engine.fix_templates[template_key]
        If template_matches_context(template, context):
            List.add(matching_templates, template)
        End If
    End For
    
    Return matching_templates

Process called "template_matches_context" that takes template as FixTemplate, context as SuggestionContext returns Boolean:
    @Implementation
    Checks if fix template is applicable to given context.
    @End Implementation
    
    Note: Template pattern matching logic
    If template.template_id equals "missing_semicolon":
        Return StringPrimitive.contains(context.surrounding_code, "expected")
    End If
    
    If template.template_id equals "undefined_variable":
        Return StringPrimitive.contains(context.error_type, "name")
    End If
    
    If template.template_id equals "type_mismatch":
        Return StringPrimitive.contains(context.error_type, "type")
    End If
    
    If template.template_id equals "syntax_conversion":
        Return not (context.syntax_mode equals "mixed")
    End If
    
    Return false

Process called "generate_suggestion_from_template" that takes engine as SuggestionEngine, template as FixTemplate, diagnostic as String, context as SuggestionContext returns Suggestion:
    @Implementation
    Generates specific suggestion from fix template.
    @End Implementation
    
    Let suggestion be Suggestion with
        suggestion_id as generate_suggestion_id(),
        suggestion_type as template.template_name,
        confidence_score as template.confidence_weight,
        fix_description as generate_fix_description(template, context),
        original_text as extract_problematic_text(context),
        suggested_text as generate_suggested_text(template, context),
        explanation as generate_explanation(template, context),
        edit_operations as List[String],
        applicability_range as Dictionary[String, Integer],
        prerequisites as List[String]
    End Suggestion
    
    Note: Set default applicability range
    Set suggestion.applicability_range["start_line"] to context.source_location["line"]
    Set suggestion.applicability_range["end_line"] to context.source_location["line"]
    
    Return suggestion

Process called "generate_suggestion_id" returns String:
    @Implementation
    Generates unique suggestion ID using timestamp.
    @End Implementation
    
    Let timestamp be get_current_timestamp()
    Return "sug_" + integer_to_string(timestamp)

Process called "get_current_timestamp" returns Integer:
    @Implementation
    Gets current Unix timestamp in seconds since epoch (January 1, 1970).
    Uses system time call to get accurate current time.
    @End Implementation
    
    Note: Get current system time using system call
    Let seconds be 0
    Let nanoseconds be 0
    
    Note: Use inline assembly to call clock_gettime syscall
    Inline Assembly:
        "mov rax, 228\n"           Note: SYS_clock_gettime
        "mov rdi, 0\n"             Note: CLOCK_REALTIME
        "lea rsi, [rsp-16]\n"      Note: timespec structure on stack
        "syscall\n"                Note: Make system call
        "mov rax, [rsp-16]\n"      Note: Load seconds from timespec
        "mov %0, rax\n"            Note: Store seconds
        : "=r"(seconds)
        :
        : "rax", "rdi", "rsi", "memory"
    End Assembly
    
    Return seconds

Process called "generate_fix_description" that takes template as FixTemplate, context as SuggestionContext returns String:
    @Implementation
    Generates human-readable fix description.
    @End Implementation
    
    Match template.template_id:
        When "missing_semicolon":
            Return "Add missing semicolon at end of statement"
        When "undefined_variable":
            Return "Declare the undefined variable"
        When "type_mismatch":
            Return "Convert value to expected type"
        When "syntax_conversion":
            Return "Convert to " + context.syntax_mode + " syntax mode"
        Otherwise:
            Return "Apply " + template.template_name + " fix"
    End Match

Process called "extract_problematic_text" that takes context as SuggestionContext returns String:
    @Implementation
    Extracts the problematic text from source code based on error location and context.
    Returns the specific text segment that contains the error for analysis.
    @End Implementation
    
    Note: Handle case where source_text is empty or null
    If String.is_empty(context.source_text):
        Return ""
    End If
    
    Note: Validate line and column numbers
    Let source_lines be String.split(context.source_text, "\n")
    Let total_lines be List.length(source_lines)
    
    If context.line_number is less than 1 or context.line_number is greater than total_lines:
        Return context.source_text  Note: Return full text if line number is invalid
    End If
    
    Note: Extract the problematic line
    Let problematic_line be List.get(source_lines, context.line_number - 1)
    Let line_length be String.length(problematic_line)
    
    Note: Validate column number and extract relevant portion
    If context.column_number is less than 1:
        Return problematic_line
    End If
    
    Note: Extract context around the error column
    Let start_col be Math.max(0, context.column_number - 20)
    Let end_col be Math.min(line_length, context.column_number + 20)
    
    Note: Extract substring with error context
    If start_col equals 0 and end_col equals line_length:
        Return problematic_line
    Otherwise:
        Let prefix be If start_col is greater than 0 then "..." otherwise ""
        Let suffix be If end_col is less than line_length then "..." otherwise ""
        Let extracted be String.substring(problematic_line, start_col, end_col - start_col)
        Return prefix + extracted + suffix
    End If

Process called "generate_suggested_text" that takes template as FixTemplate, context as SuggestionContext returns String:
    @Implementation
    Generates suggested replacement text.
    @End Implementation
    
    Match template.template_id:
        When "missing_semicolon":
            Return "<original_text>;"
        When "undefined_variable":
            Return "Let <variable_name> be <default_value>"
        When "type_mismatch":
            Return "<converted_value>"
        Otherwise:
            Return "<suggested_replacement>"
    End Match

Process called "generate_explanation" that takes template as FixTemplate, context as SuggestionContext returns String:
    @Implementation
    Generates educational explanation for the suggestion.
    @End Implementation
    
    Match template.template_id:
        When "missing_semicolon":
            Return "Statements in Runa require explicit termination with semicolons in technical syntax mode."
        When "undefined_variable":
            Return "Variables must be declared before use. Use 'Let' to declare new variables."
        When "type_mismatch":
            Return "The value type doesn't match the expected type. Consider explicit conversion."
        Otherwise:
            Return "This fix addresses the " + template.template_name + " issue."
    End Match

Process called "merge_by_confidence" that takes suggestions as List[Suggestion], left_start as Integer, mid as Integer, right_end as Integer returns Nothing:
    @Implementation
    Helper function for merge sort that merges two sorted subarrays by confidence score.
    Merges suggestions[left_start..mid] and suggestions[mid+1..right_end] in descending order.
    @End Implementation
    
    Note: Create temporary arrays for left and right subarrays
    Let left_size be mid - left_start + 1
    Let right_size be right_end - mid
    
    Let left_array be Array[left_size] of Suggestion
    Let right_array be Array[right_size] of Suggestion
    
    Note: Copy data to temporary arrays
    For i from 0 to (left_size - 1):
        Set left_array[i] to List.get(suggestions, left_start + i)
    End For
    
    For j from 0 to (right_size - 1):
        Set right_array[j] to List.get(suggestions, mid + 1 + j)
    End For
    
    Note: Merge the temporary arrays back into suggestions
    Let i be 0
    Let j be 0
    Let k be left_start
    
    While i is less than left_size and j is less than right_size:
        Note: Sort in descending order (higher confidence first)
        If left_array[i].confidence is greater than or equal to right_array[j].confidence:
            List.set(suggestions, k, left_array[i])
            Set i to i + 1
        Otherwise:
            List.set(suggestions, k, right_array[j])
            Set j to j + 1
        End If
        Set k to k + 1
    End While
    
    Note: Copy remaining elements of left_array
    While i is less than left_size:
        List.set(suggestions, k, left_array[i])
        Set i to i + 1
        Set k to k + 1
    End While
    
    Note: Copy remaining elements of right_array
    While j is less than right_size:
        List.set(suggestions, k, right_array[j])
        Set j to j + 1
        Set k to k + 1
    End While
End Process

Process called "rank_suggestions_by_confidence" that takes suggestions as List[Suggestion] returns List[Suggestion]:
    @Implementation
    Ranks suggestions by confidence score in descending order using merge sort algorithm.
    Higher confidence suggestions appear first in the returned list.
    @End Implementation
    
    Let suggestion_count be List.length(suggestions)
    
    Note: Handle empty or single-element lists
    If suggestion_count is less than 2:
        Return suggestions
    End If
    
    Note: Create a copy to avoid modifying original list
    Let sorted_suggestions be List.copy(suggestions)
    
    Note: Implement merge sort for O(n log n) performance
    Let current_size be 1
    While current_size is less than suggestion_count:
        Let left_start be 0
        
        While left_start is less than (suggestion_count - 1):
            Let mid be Math.min(left_start + current_size - 1, suggestion_count - 1)
            Let right_end be Math.min(left_start + (2 * current_size) - 1, suggestion_count - 1)
            
            Note: Merge subarrays if mid is less than right_end
            If mid is less than right_end:
                merge_by_confidence(sorted_suggestions, left_start, mid, right_end)
            End If
            
            Set left_start to left_start + (2 * current_size)
        End While
        
        Set current_size to current_size * 2
    End While
    
    Return sorted_suggestions

Process called "generate_syntax_suggestion" that takes engine as SuggestionEngine, diagnostic as String, context as SuggestionContext returns Suggestion:
    @Implementation
    Generates syntax-specific suggestion.
    @End Implementation
    
    Let suggestion be Suggestion with
        suggestion_id as generate_suggestion_id(),
        suggestion_type as "Syntax Fix",
        confidence_score as 0.75,
        fix_description as "Fix syntax error",
        original_text as "",
        suggested_text as "",
        explanation as "Correct the syntax according to Runa language rules.",
        edit_operations as List[String],
        applicability_range as Dictionary[String, Integer],
        prerequisites as List[String]
    End Suggestion
    
    Return suggestion

Process called "generate_natural_language_suggestion" that takes engine as SuggestionEngine, diagnostic as String, context as SuggestionContext returns Suggestion:
    @Implementation
    Generates natural language specific suggestion.
    @End Implementation
    
    Let suggestion be Suggestion with
        suggestion_id as generate_suggestion_id(),
        suggestion_type as "Natural Language Fix",
        confidence_score as 0.70,
        fix_description as "Convert to natural language syntax",
        original_text as "",
        suggested_text as "",
        explanation as "This error can be resolved by using more natural language constructs.",
        edit_operations as List[String],
        applicability_range as Dictionary[String, Integer],
        prerequisites as List[String]
    End Suggestion
    
    Return suggestion

Process called "generate_custom_fix_text" that takes specific_error as String, context as SuggestionContext returns String:
    @Implementation
    Generates custom fix text based on specific error type and context analysis.
    Returns specific replacement text tailored to the error condition.
    @End Implementation
    
    Note: Analyze error type to provide specific fix suggestions
    If StringPrimitive.contains(specific_error, "missing"):
        If StringPrimitive.contains(specific_error, "semicolon"):
            Return ";"
        Otherwise If StringPrimitive.contains(specific_error, "bracket"):
            If StringPrimitive.contains(context.source_text, "(") and not StringPrimitive.contains(context.source_text, ")"):
                Return ")"
            Otherwise If StringPrimitive.contains(context.source_text, "[") and not StringPrimitive.contains(context.source_text, "]"):
                Return "]"
            Otherwise If StringPrimitive.contains(context.source_text, "{") and not StringPrimitive.contains(context.source_text, "}"):
                Return "}"
            Otherwise:
                Return ")"
            End If
        Otherwise If StringPrimitive.contains(specific_error, "import"):
            Return "Import " + extract_missing_module_name(specific_error)
        Otherwise:
            Return "Missing element"
        End If
    Otherwise If StringPrimitive.contains(specific_error, "undefined"):
        Let undefined_name be extract_undefined_name(specific_error)
        If StringPrimitive.contains(specific_error, "variable"):
            Return "Let " + undefined_name + " be <value>"
        Otherwise If StringPrimitive.contains(specific_error, "function"):
            Return "Process called \"" + undefined_name + "\" that takes <parameters> returns <type>:"
        Otherwise:
            Return "Define " + undefined_name
        End If
    Otherwise If StringPrimitive.contains(specific_error, "type"):
        If StringPrimitive.contains(specific_error, "mismatch"):
            Return extract_expected_type(specific_error) + "(" + extract_problematic_value(context) + ")"
        Otherwise:
            Return "Type conversion needed"
        End If
    Otherwise:
        Return "Apply appropriate fix for: " + specific_error
    End If

Process called "extract_missing_module_name" that takes error_message as String returns String:
    @Implementation
    Extracts the module name from import error messages.
    @End Implementation
    
    Note: Look for common patterns in import error messages
    If StringPrimitive.contains(error_message, "module "):
        Let start_pos be String.index_of(error_message, "module ") + 7
        Let end_pos be String.index_of_from(error_message, " ", start_pos)
        If end_pos equals -1:
            Set end_pos to String.length(error_message)
        End If
        Return String.substring(error_message, start_pos, end_pos - start_pos)
    Otherwise:
        Return "UnknownModule"
    End If
End Process

Process called "extract_undefined_name" that takes error_message as String returns String:
    @Implementation
    Extracts the undefined identifier name from error messages.
    @End Implementation
    
    Note: Look for quoted identifiers in error messages
    Let start_quote be String.index_of(error_message, "'")
    If start_quote not equals -1:
        Let end_quote be String.index_of_from(error_message, "'", start_quote + 1)
        If end_quote not equals -1:
            Return String.substring(error_message, start_quote + 1, end_quote - start_quote - 1)
        End If
    End If
    
    Note: Look for identifiers after "undefined" or "not defined"
    If StringPrimitive.contains(error_message, "undefined "):
        Let start_pos be String.index_of(error_message, "undefined ") + 10
        Let space_pos be String.index_of_from(error_message, " ", start_pos)
        If space_pos equals -1:
            Set space_pos to String.length(error_message)
        End If
        Return String.substring(error_message, start_pos, space_pos - start_pos)
    End If
    
    Return "unknown_identifier"
End Process

Process called "extract_expected_type" that takes error_message as String returns String:
    @Implementation
    Extracts the expected type from type mismatch error messages.
    @End Implementation
    
    Note: Look for "expected" pattern in error messages
    If StringPrimitive.contains(error_message, "expected "):
        Let start_pos be String.index_of(error_message, "expected ") + 9
        Let end_pos be String.index_of_from(error_message, " ", start_pos)
        If end_pos equals -1:
            Set end_pos to String.length(error_message)
        End If
        Return String.substring(error_message, start_pos, end_pos - start_pos)
    End If
    
    Return "Any"
End Process

Process called "extract_problematic_value" that takes context as SuggestionContext returns String:
    @Implementation
    Extracts the problematic value from context for type conversion suggestions.
    @End Implementation
    
    Note: Extract value around the error column
    If String.is_empty(context.source_text):
        Return "value"
    End If
    
    Let lines be String.split(context.source_text, "\n")
    If context.line_number is less than 1 or context.line_number is greater than List.length(lines):
        Return "value"
    End If
    
    Let line be List.get(lines, context.line_number - 1)
    Let column be context.column_number
    
    Note: Find word boundaries around the error position
    Let start_pos be column - 1
    Let end_pos be column - 1
    
    Note: Move start_pos back to word beginning
    While start_pos is greater than 0 and is_identifier_char(String.char_at(line, start_pos - 1)):
        Set start_pos to start_pos - 1
    End While
    
    Note: Move end_pos forward to word end
    While end_pos is less than String.length(line) and is_identifier_char(String.char_at(line, end_pos)):
        Set end_pos to end_pos + 1
    End While
    
    If end_pos is greater than start_pos:
        Return String.substring(line, start_pos, end_pos - start_pos)
    Otherwise:
        Return "value"
    End If
End Process

Process called "is_identifier_char" that takes char as Integer returns Boolean:
    @Implementation
    Checks if a character is valid for identifiers (letters, digits, underscore).
    @End Implementation
    
    Note: Check for letters (A-Z, a-z), digits (0-9), and underscore
    Return (char is greater than or equal to 65 and char is less than or equal to 90) or
           (char is greater than or equal to 97 and char is less than or equal to 122) or
           (char is greater than or equal to 48 and char is less than or equal to 57) or
           char equals 95
End Process

Process called "generate_custom_explanation" that takes specific_error as String, context as SuggestionContext returns String:
    @Implementation
    Generates detailed explanation for custom fix.
    @End Implementation
    
    Let base_explanation be "This error occurs because: " + specific_error
    Let mode_guidance be ""
    
    If context.syntax_mode equals "natural":
        Set mode_guidance to " Consider using natural language constructs for clarity."
    Otherwise context.syntax_mode equals "technical":
        Set mode_guidance to " Ensure proper technical syntax is used."
    Otherwise:
        Set mode_guidance to " Choose consistent syntax mode throughout."
    End If
    
    Return base_explanation + mode_guidance

Process called "generate_custom_suggestion" that takes engine as SuggestionEngine, specific_error as String, context as SuggestionContext returns Suggestion:
    @Implementation
    Generates custom suggestion tailored to specific error type.
    Provides detailed, context-aware fix recommendations.
    @End Implementation
    
    Let suggestion be Suggestion with
        suggestion_id as generate_suggestion_id(),
        suggestion_type as "Custom Fix",
        confidence_score as 0.85,
        fix_description as "Custom fix for " + specific_error,
        original_text as context.surrounding_code,
        suggested_text as generate_custom_fix_text(specific_error, context),
        explanation as generate_custom_explanation(specific_error, context),
        edit_operations as List[String],
        applicability_range as Dictionary[String, Integer],
        prerequisites as List[String]
    End Suggestion
    
    Return suggestion

Note: =====================================================================
Note: NATURAL LANGUAGE SUGGESTIONS
Note: =====================================================================

Process called "suggest_natural_syntax_fixes" that takes engine as SuggestionEngine, natural_error as String returns List[Suggestion]:
    @Implementation
    Generate suggestions for natural language syntax errors by analyzing common
    natural language patterns and providing technical syntax equivalents.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Handle common natural language syntax patterns
    If StringPrimitive.contains(natural_error, "when"):
        Let when_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Natural to Technical",
            confidence_score as 0.9,
            fix_description as "Convert natural 'when' to technical If statement",
            original_text as natural_error,
            suggested_text as String.replace(natural_error, "when", "If"),
            explanation as "Use 'If' instead of 'when' for conditional statements in technical mode",
            edit_operations as ["replace"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, when_suggestion)
    End If
    
    If StringPrimitive.contains(natural_error, "then"):
        Let then_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Natural to Technical", 
            confidence_score as 0.85,
            fix_description as "Convert natural 'then' to technical colon syntax",
            original_text as natural_error,
            suggested_text as String.replace(natural_error, "then", ":"),
            explanation as "Use ':' instead of 'then' for statement blocks in technical mode",
            edit_operations as ["replace"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, then_suggestion)
    End If
    
    If StringPrimitive.contains(natural_error, "otherwise"):
        Let else_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Natural to Technical",
            confidence_score as 0.88,
            fix_description as "Convert natural 'otherwise' to technical Otherwise",
            original_text as natural_error,
            suggested_text as natural_error,
            explanation as "Use 'Otherwise' for else conditions in both natural and technical modes",
            edit_operations as ["keep"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, else_suggestion)
    End If
    
    Return suggestions

Process called "suggest_natural_alternatives" that takes engine as SuggestionEngine, technical_code as String returns List[Suggestion]:
    @Implementation
    Suggests natural language alternatives to technical code constructs,
    making code more readable and accessible to non-technical developers.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Convert technical syntax to natural alternatives
    If StringPrimitive.contains(technical_code, "&&"):
        Let and_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Technical to Natural",
            confidence_score as 0.92,
            fix_description as "Use natural 'and' instead of technical '&&'",
            original_text as technical_code,
            suggested_text as String.replace(technical_code, "&&", "and"),
            explanation as "Natural language uses 'and' for logical conjunction",
            edit_operations as ["replace"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, and_suggestion)
    End If
    
    If StringPrimitive.contains(technical_code, "||"):
        Let or_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Technical to Natural",
            confidence_score as 0.92,
            fix_description as "Use natural 'or' instead of technical '||'",
            original_text as technical_code,
            suggested_text as String.replace(technical_code, "||", "or"),
            explanation as "Natural language uses 'or' for logical disjunction",
            edit_operations as ["replace"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, or_suggestion)
    End If
    
    If StringPrimitive.contains(technical_code, "!="):
        Let not_equals_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Technical to Natural",
            confidence_score as 0.89,
            fix_description as "Use natural 'not equals' instead of technical '!='",
            original_text as technical_code,
            suggested_text as String.replace(technical_code, "!=", "not equals"),
            explanation as "Natural language uses 'not equals' for inequality comparison",
            edit_operations as ["replace"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, not_equals_suggestion)
    End If
    
    Return suggestions

Process called "explain_natural_concepts" that takes engine as SuggestionEngine, concept as String returns String:
    @Implementation
    Provides educational explanations for natural language concepts,
    helping developers understand programming concepts in accessible language.
    @End Implementation
    
    Match concept:
        When "variable":
            Return "A variable is like a labeled box where you can store information. You can put different values in the box and refer to them by the label name."
        When "function":
            Return "A function is like a recipe that takes ingredients (parameters) and produces a result. It's a reusable set of instructions that performs a specific task."
        When "loop":
            Return "A loop is like repeating an action. Instead of writing the same instructions multiple times, you tell the computer to repeat them until a condition is met."
        When "condition":
            Return "A condition is like asking a yes/no question. Based on the answer, your program decides which path to take next."
        When "array":
            Return "An array is like a numbered list where you can store multiple items of the same type. Each item has a position number starting from 0."
        When "object":
            Return "An object is like a real-world thing with properties and abilities. For example, a car object might have color and speed properties, and driving abilities."
        Otherwise:
            Return "This concept represents a fundamental building block in programming that helps organize and structure code."
    End Match

Process called "suggest_natural_refactoring" that takes engine as SuggestionEngine, code_section as String returns List[Suggestion]:
    @Implementation
    Suggests refactoring technical code to use more natural language patterns,
    improving readability while maintaining functionality.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Suggest replacing cryptic variable names with descriptive ones
    If StringPrimitive.contains(code_section, " i ") or StringPrimitive.contains(code_section, " j "):
        Let descriptive_names_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Natural Refactoring",
            confidence_score as 0.75,
            fix_description as "Use descriptive variable names instead of single letters",
            original_text as code_section,
            suggested_text as String.replace(String.replace(code_section, " i ", " index "), " j ", " inner_index "),
            explanation as "Descriptive variable names make code more readable and self-documenting",
            edit_operations as ["replace_multiple"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, descriptive_names_suggestion)
    End If
    
    Note: Suggest natural language boolean expressions
    If StringPrimitive.contains(code_section, "== true"):
        Let boolean_simplification be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Natural Refactoring",
            confidence_score as 0.8,
            fix_description as "Simplify boolean expressions to natural language",
            original_text as code_section,
            suggested_text as String.replace(code_section, "== true", ""),
            explanation as "Natural language can express boolean conditions more simply",
            edit_operations as ["remove"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, boolean_simplification)
    End If
    
    Return suggestions

Note: =====================================================================
Note: TECHNICAL SYNTAX SUGGESTIONS
Note: =====================================================================

Process called "suggest_technical_syntax_fixes" that takes engine as SuggestionEngine, technical_error as String returns List[Suggestion]:
    @Implementation
    Generates suggestions for technical syntax errors by analyzing syntax patterns
    and providing correct technical alternatives.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Handle common technical syntax issues
    If StringPrimitive.contains(technical_error, "missing semicolon"):
        Let semicolon_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Technical Syntax Fix",
            confidence_score as 0.95,
            fix_description as "Add missing semicolon",
            original_text as technical_error,
            suggested_text as technical_error + ";",
            explanation as "Statements in technical mode require semicolon terminators",
            edit_operations as ["append"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, semicolon_suggestion)
    End If
    
    If StringPrimitive.contains(technical_error, "missing bracket"):
        Let bracket_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Technical Syntax Fix",
            confidence_score as 0.9,
            fix_description as "Add missing closing bracket",
            original_text as technical_error,
            suggested_text as technical_error + "}",
            explanation as "Code blocks in technical mode require closing brackets",
            edit_operations as ["append"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, bracket_suggestion)
    End If
    
    Return suggestions

Process called "suggest_technical_alternatives" that takes engine as SuggestionEngine, natural_code as String returns List[Suggestion]:
    @Implementation
    Suggests technical syntax alternatives to natural language code,
    providing more concise and performance-oriented representations.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Convert natural language constructs to technical equivalents
    If StringPrimitive.contains(natural_code, "and"):
        Let and_tech_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Natural to Technical",
            confidence_score as 0.88,
            fix_description as "Use technical '&&' instead of natural 'and'",
            original_text as natural_code,
            suggested_text as String.replace(natural_code, "and", "&&"),
            explanation as "Technical mode uses '&&' for logical conjunction for better performance",
            edit_operations as ["replace"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, and_tech_suggestion)
    End If
    
    If StringPrimitive.contains(natural_code, "or"):
        Let or_tech_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Natural to Technical",
            confidence_score as 0.88,
            fix_description as "Use technical '||' instead of natural 'or'",
            original_text as natural_code,
            suggested_text as String.replace(natural_code, "or", "||"),
            explanation as "Technical mode uses '||' for logical disjunction for better performance",
            edit_operations as ["replace"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, or_tech_suggestion)
    End If
    
    Return suggestions

Process called "suggest_performance_improvements" that takes engine as SuggestionEngine, code_section as String returns List[Suggestion]:
    @Implementation
    Analyzes code for performance bottlenecks and suggests optimized alternatives
    focusing on algorithmic improvements and resource utilization.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Detect inefficient loops and suggest improvements
    If StringPrimitive.contains(code_section, "For i from 0 to") and StringPrimitive.contains(code_section, "List.length"):
        Let loop_optimization be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Performance Improvement",
            confidence_score as 0.82,
            fix_description as "Cache list length to avoid repeated calculation",
            original_text as code_section,
            suggested_text as "Let list_size be List.length(list)\nFor i from 0 to (list_size - 1):",
            explanation as "Caching list length prevents recalculation on each iteration",
            edit_operations as ["replace_with_optimization"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, loop_optimization)
    End If
    
    Note: Suggest string concatenation improvements
    If StringPrimitive.contains(code_section, "+") and StringPrimitive.contains(code_section, "String"):
        Let concat_optimization be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Performance Improvement",
            confidence_score as 0.75,
            fix_description as "Use StringBuilder for multiple string concatenations",
            original_text as code_section,
            suggested_text as "Use StringBuilder for efficient string building",
            explanation as "StringBuilder is more efficient than repeated string concatenation",
            edit_operations as ["refactor"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, concat_optimization)
    End If
    
    Return suggestions

Process called "suggest_idiom_improvements" that takes engine as SuggestionEngine, technical_code as String returns List[Suggestion]:
    @Implementation
    Suggests more idiomatic technical syntax patterns that follow
    established conventions and best practices.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Suggest idiomatic naming conventions
    If StringPrimitive.contains(technical_code, "var"):
        Let naming_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Idiom Improvement",
            confidence_score as 0.85,
            fix_description as "Use 'Let' instead of 'var' for clearer variable declarations",
            original_text as technical_code,
            suggested_text as String.replace(technical_code, "var", "Let"),
            explanation as "'Let' is the idiomatic way to declare variables in Runa",
            edit_operations as ["replace"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, naming_suggestion)
    End If
    
    Note: Suggest early returns for cleaner code
    If StringPrimitive.contains(technical_code, "If") and StringPrimitive.contains(technical_code, "Otherwise"):
        Let early_return_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Idiom Improvement",
            confidence_score as 0.78,
            fix_description as "Consider using early returns to reduce nesting",
            original_text as technical_code,
            suggested_text as "Use early return pattern for cleaner code",
            explanation as "Early returns reduce nesting and improve code readability",
            edit_operations as ["restructure"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, early_return_suggestion)
    End If
    
    Return suggestions

Note: =====================================================================
Note: MATHEMATICAL SUGGESTIONS
Note: =====================================================================

Process called "suggest_mathematical_fixes" that takes engine as SuggestionEngine, math_error as String, symbols as List[String] returns List[Suggestion]:
    @Implementation
    Generates suggestions for mathematical expression errors by analyzing
    mathematical syntax patterns and providing correct alternatives.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Handle missing operators in mathematical expressions
    If StringPrimitive.contains(math_error, "adjacent variables") or StringPrimitive.contains(math_error, "implicit multiplication"):
        Let multiply_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Mathematical Fix",
            confidence_score as 0.92,
            fix_description as "Add explicit multiplication operator",
            original_text as math_error,
            suggested_text as "Use * for multiplication between variables",
            explanation as "Mathematical expressions require explicit operators between variables",
            edit_operations as ["insert_operator"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, multiply_suggestion)
    End If
    
    Note: Handle parentheses balancing in mathematical expressions
    If StringPrimitive.contains(math_error, "unbalanced") or StringPrimitive.contains(math_error, "parentheses"):
        Let paren_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Mathematical Fix",
            confidence_score as 0.95,
            fix_description as "Balance parentheses in mathematical expression",
            original_text as math_error,
            suggested_text as "Add missing closing parenthesis",
            explanation as "Mathematical expressions require balanced parentheses",
            edit_operations as ["balance_parens"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, paren_suggestion)
    End If
    
    Note: Suggest Greek symbol alternatives if available
    For symbol in symbols:
        If String.equals(symbol, "alpha"):
            Let greek_suggestion be Suggestion with
                suggestion_id as generate_suggestion_id(),
                suggestion_type as "Mathematical Symbol",
                confidence_score as 0.87,
                fix_description as "Use Greek letter Î± for alpha",
                original_text as "alpha",
                suggested_text as "Î±",
                explanation as "Greek symbols provide clearer mathematical notation",
                edit_operations as ["replace_symbol"],
                applicability_range as Dictionary[String, Integer],
                prerequisites as List[String]
            End Suggestion
            List.add(suggestions, greek_suggestion)
        End If
    End For
    
    Return suggestions

Process called "suggest_greek_symbol_alternatives" that takes engine as SuggestionEngine, invalid_symbol as String returns List[Suggestion]:
    @Implementation
    Suggests alternative Greek symbols or escape sequences for invalid mathematical symbols,
    providing both Unicode and ASCII alternatives.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Provide Greek symbol alternatives based on common names
    Match invalid_symbol:
        When "alpha":
            Let alpha_suggestion be Suggestion with
                suggestion_id as generate_suggestion_id(),
                suggestion_type as "Greek Symbol Alternative",
                confidence_score as 0.95,
                fix_description as "Use Unicode Greek letter alpha",
                original_text as "alpha",
                suggested_text as "Î±",
                explanation as "Use the actual Greek letter Î± instead of the word 'alpha'",
                edit_operations as ["replace_symbol"],
                applicability_range as Dictionary[String, Integer],
                prerequisites as List[String]
            End Suggestion
            List.add(suggestions, alpha_suggestion)
        When "beta":
            Let beta_suggestion be Suggestion with
                suggestion_id as generate_suggestion_id(),
                suggestion_type as "Greek Symbol Alternative",
                confidence_score as 0.95,
                fix_description as "Use Unicode Greek letter beta",
                original_text as "beta",
                suggested_text as "Î²",
                explanation as "Use the actual Greek letter Î² instead of the word 'beta'",
                edit_operations as ["replace_symbol"],
                applicability_range as Dictionary[String, Integer],
                prerequisites as List[String]
            End Suggestion
            List.add(suggestions, beta_suggestion)
        When "gamma":
            Let gamma_suggestion be Suggestion with
                suggestion_id as generate_suggestion_id(),
                suggestion_type as "Greek Symbol Alternative",
                confidence_score as 0.95,
                fix_description as "Use Unicode Greek letter gamma",
                original_text as "gamma",
                suggested_text as "Î³",
                explanation as "Use the actual Greek letter Î³ instead of the word 'gamma'",
                edit_operations as ["replace_symbol"],
                applicability_range as Dictionary[String, Integer],
                prerequisites as List[String]
            End Suggestion
            List.add(suggestions, gamma_suggestion)
        Otherwise:
            Let generic_suggestion be Suggestion with
                suggestion_id as generate_suggestion_id(),
                suggestion_type as "Greek Symbol Alternative",
                confidence_score as 0.75,
                fix_description as "Consider using proper Greek symbol notation",
                original_text as invalid_symbol,
                suggested_text as "Use appropriate Unicode Greek symbol",
                explanation as "Consider using the actual Greek symbol instead of the English name",
                edit_operations as ["manual_replace"],
                applicability_range as Dictionary[String, Integer],
                prerequisites as List[String]
            End Suggestion
            List.add(suggestions, generic_suggestion)
    End Match
    
    Return suggestions

Process called "suggest_mathematical_notation" that takes engine as SuggestionEngine, expression as String returns List[Suggestion]:
    @Implementation
    Suggests proper mathematical notation improvements for expressions,
    enhancing readability and mathematical correctness.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Suggest subscript notation for indices
    If StringPrimitive.contains(expression, "_"):
        Let subscript_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Mathematical Notation",
            confidence_score as 0.85,
            fix_description as "Use proper subscript notation",
            original_text as expression,
            suggested_text as "Use subscript notation for mathematical indices",
            explanation as "Subscripts improve mathematical expression readability",
            edit_operations as ["format_subscript"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, subscript_suggestion)
    End If
    
    Note: Suggest superscript notation for exponents
    If StringPrimitive.contains(expression, "^"):
        Let superscript_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Mathematical Notation",
            confidence_score as 0.88,
            fix_description as "Use proper superscript notation for exponents",
            original_text as expression,
            suggested_text as "Use superscript notation for powers",
            explanation as "Superscripts are the standard notation for exponents",
            edit_operations as ["format_superscript"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, superscript_suggestion)
    End If
    
    Note: Suggest proper fraction notation
    If StringPrimitive.contains(expression, "/") and not StringPrimitive.contains(expression, "//"):
        Let fraction_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Mathematical Notation",
            confidence_score as 0.82,
            fix_description as "Consider using proper fraction notation",
            original_text as expression,
            suggested_text as "Use fraction bar notation for division",
            explanation as "Proper fraction notation improves mathematical clarity",
            edit_operations as ["format_fraction"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, fraction_suggestion)
    End If
    
    Return suggestions

Process called "explain_mathematical_operations" that takes engine as SuggestionEngine, operation as String returns String:
    @Implementation
    Provides detailed explanations of mathematical operations and their proper usage
    in mathematical expressions and programming contexts.
    @End Implementation
    
    Match operation:
        When "+":
            Return "Addition: Combines two numbers to produce their sum. In mathematical expressions, ensure both operands are numeric values."
        When "-":
            Return "Subtraction: Finds the difference between two numbers. Can also be used as unary minus to negate a value."
        When "*":
            Return "Multiplication: Multiplies two numbers together. In mathematical expressions, this operator is required between variables (implicit multiplication is not allowed)."
        When "/":
            Return "Division: Divides the first number by the second. Be careful to avoid division by zero, which is undefined."
        When "^":
            Return "Exponentiation: Raises the first number to the power of the second. Commonly written as superscript in mathematical notation."
        When "%":
            Return "Modulo: Returns the remainder after division. Useful for cyclic operations and checking divisibility."
        When "sqrt":
            Return "Square root: Finds the number which, when multiplied by itself, gives the original number. Only defined for non-negative real numbers."
        When "sin":
            Return "Sine function: A trigonometric function that relates the angle in a right triangle to the ratio of opposite side to hypotenuse."
        When "cos":
            Return "Cosine function: A trigonometric function that relates the angle in a right triangle to the ratio of adjacent side to hypotenuse."
        When "log":
            Return "Logarithm: The inverse of exponentiation. Log base 10 is common, while natural log (ln) uses base e."
        When "abs":
            Return "Absolute value: Returns the non-negative value of a number, removing any negative sign."
        Otherwise:
            Return "This mathematical operation performs a specific calculation. Refer to mathematical documentation for detailed usage guidelines."
    End Match

Note: =====================================================================
Note: SUGGESTION RANKING AND FILTERING
Note: =====================================================================

Process called "rank_suggestions" that takes engine as SuggestionEngine, suggestions as List[Suggestion], context as SuggestionContext returns List[Suggestion]:
    @Implementation
    Ranks suggestions based on confidence scores, context relevance, and user feedback,
    returning a prioritized list with most relevant suggestions first.
    @End Implementation
    
    Note: First apply confidence-based ranking
    Let ranked_suggestions be rank_suggestions_by_confidence(suggestions)
    
    Note: Apply context-based adjustments
    For suggestion in ranked_suggestions:
        Note: Boost score for suggestions matching current syntax mode
        If String.equals(context.syntax_mode, "natural") and StringPrimitive.contains(suggestion.suggestion_type, "Natural"):
            Set suggestion.confidence_score to suggestion.confidence_score * 1.1
        Otherwise If String.equals(context.syntax_mode, "technical") and StringPrimitive.contains(suggestion.suggestion_type, "Technical"):
            Set suggestion.confidence_score to suggestion.confidence_score * 1.1
        End If
        
        Note: Apply user feedback adjustments
        Let feedback_key be suggestion.suggestion_type
        If Dictionary.contains(engine.user_feedback, feedback_key):
            Let feedback_score be Dictionary.get(engine.user_feedback, feedback_key)
            Set suggestion.confidence_score to suggestion.confidence_score * feedback_score
        End If
    End For
    
    Note: Re-rank after adjustments
    Return rank_suggestions_by_confidence(ranked_suggestions)

Process called "filter_suggestions_by_confidence" that takes engine as SuggestionEngine, suggestions as List[Suggestion], min_confidence as Float returns List[Suggestion]:
    @Implementation
    Filters out suggestions that fall below the specified confidence threshold,
    ensuring only high-quality suggestions are presented to users.
    @End Implementation
    
    Let filtered_suggestions be List[Suggestion]
    
    For suggestion in suggestions:
        If suggestion.confidence_score is greater than or equal to min_confidence:
            List.add(filtered_suggestions, suggestion)
        End If
    End For
    
    Return filtered_suggestions

Process called "filter_suggestions_by_type" that takes engine as SuggestionEngine, suggestions as List[Suggestion], types as List[String] returns List[Suggestion]:
    @Implementation
    Filters suggestions to only include those matching the specified types,
    allowing targeted suggestion presentation based on user preferences.
    @End Implementation
    
    Let filtered_suggestions be List[Suggestion]
    
    For suggestion in suggestions:
        For desired_type in types:
            If String.equals(suggestion.suggestion_type, desired_type):
                List.add(filtered_suggestions, suggestion)
                Break Note: Found match, no need to check other types
            End If
        End For
    End For
    
    Return filtered_suggestions

Process called "deduplicate_suggestions" that takes engine as SuggestionEngine, suggestions as List[Suggestion] returns List[Suggestion]:
    @Implementation
    Removes duplicate suggestions based on suggested text and type,
    keeping the highest confidence version of each unique suggestion.
    @End Implementation
    
    Let unique_suggestions be List[Suggestion]
    Let seen_combinations be Dictionary[String, Suggestion]
    
    For suggestion in suggestions:
        Let combination_key be suggestion.suggestion_type + "|" + suggestion.suggested_text
        
        If Dictionary.contains(seen_combinations, combination_key):
            Let existing_suggestion be Dictionary.get(seen_combinations, combination_key)
            Note: Keep the one with higher confidence
            If suggestion.confidence_score is greater than existing_suggestion.confidence_score:
                Dictionary.set(seen_combinations, combination_key, suggestion)
            End If
        Otherwise:
            Dictionary.set(seen_combinations, combination_key, suggestion)
        End If
    End For
    
    Note: Convert dictionary values back to list
    For key in seen_combinations:
        Let unique_suggestion be Dictionary.get(seen_combinations, key)
        List.add(unique_suggestions, unique_suggestion)
    End For
    
    Return unique_suggestions

Process called "calculate_string_similarity" that takes str1 as String, str2 as String returns Float:
    @Implementation
    Calculates similarity between two strings using Levenshtein distance algorithm.
    Returns a value between 0.0 (no similarity) and 1.0 (identical).
    @End Implementation
    
    Let len1 be String.length(str1)
    Let len2 be String.length(str2)
    
    Note: Handle edge cases
    If len1 equals 0:
        Return If len2 equals 0 then 1.0 otherwise 0.0
    End If
    If len2 equals 0:
        Return 0.0
    End If
    
    Note: Create distance matrix
    Let matrix be Array[len1 + 1][len2 + 1] of Integer
    
    Note: Initialize first row and column
    For i from 0 to len1:
        Set matrix[i][0] to i
    End For
    For j from 0 to len2:
        Set matrix[0][j] to j
    End For
    
    Note: Fill the matrix using dynamic programming
    For i from 1 to len1:
        For j from 1 to len2:
            Let cost be If String.char_at(str1, i - 1) equals String.char_at(str2, j - 1) then 0 otherwise 1
            Let deletion be matrix[i - 1][j] + 1
            Let insertion be matrix[i][j - 1] + 1
            Let substitution be matrix[i - 1][j - 1] + cost
            
            Set matrix[i][j] to Math.min(Math.min(deletion, insertion), substitution)
        End For
    End For
    
    Note: Calculate similarity as 1 - (distance / max_length)
    Let distance be matrix[len1][len2]
    Let max_length be Math.max(len1, len2)
    Return 1.0 - (Float(distance) / Float(max_length))
End Process

Process called "extract_partial_word" that takes line as String, column as Integer returns String:
    @Implementation
    Extracts the partial word being typed at the cursor position.
    @End Implementation
    
    Let line_length be String.length(line)
    If column is less than 1 or column is greater than line_length:
        Return ""
    End If
    
    Note: Find word boundaries around cursor position
    Let start_pos be column - 1
    Let end_pos be column - 1
    
    Note: Move start_pos back to word beginning
    While start_pos is greater than 0:
        Let char be String.char_at(line, start_pos - 1)
        If not is_identifier_char(char):
            Break
        End If
        Set start_pos to start_pos - 1
    End While
    
    Note: Move end_pos forward to word end
    While end_pos is less than line_length:
        Let char be String.char_at(line, end_pos)
        If not is_identifier_char(char):
            Break
        End If
        Set end_pos to end_pos + 1
    End While
    
    If end_pos is greater than start_pos:
        Return String.substring(line, start_pos, end_pos - start_pos)
    Otherwise:
        Return ""
    End If
End Process

Process called "find_declaration_location" that takes lines as List[String] returns Integer:
    @Implementation
    Finds the appropriate location to insert a variable declaration.
    @End Implementation
    
    Note: Look for existing declarations or the start of the function body
    For i from 0 to (List.length(lines) - 1):
        Let line be List.get(lines, i)
        If StringPrimitive.contains(line, "Let ") and not StringPrimitive.contains(line, "Process"):
            Return i + 1  Note: Insert after last declaration
        End If
        If StringPrimitive.contains(line, "Process called"):
            Return i + 2  Note: Insert after process declaration line
        End If
    End For
    
    Return 1  Note: Default to beginning if no good location found
End Process

Process called "count_occurrences" that takes text as String, pattern as String returns Integer:
    @Implementation
    Counts the number of occurrences of a pattern in the given text.
    @End Implementation
    
    Let count be 0
    Let position be 0
    Let text_length be String.length(text)
    Let pattern_length be String.length(pattern)
    
    While position is less than or equal to (text_length - pattern_length):
        If String.equals(String.substring(text, position, pattern_length), pattern):
            Set count to count + 1
            Set position to position + pattern_length
        Otherwise:
            Set position to position + 1
        End If
    End While
    
    Return count
End Process

Process called "sort_suggestions_by_priority" that takes suggestions as List[Suggestion] returns List[Suggestion]:
    @Implementation
    Sorts suggestions by priority to ensure safe batch application order.
    @End Implementation
    
    Note: Create priority map for different suggestion types
    Let priority_map be Dictionary[String, Integer]
    Dictionary.set(priority_map, "Import", 1)  Note: Imports first
    Dictionary.set(priority_map, "Variable Declaration", 2)  Note: Declarations second
    Dictionary.set(priority_map, "Type Conversion", 3)  Note: Type fixes third
    Dictionary.set(priority_map, "Syntax Fix", 4)  Note: Syntax fixes fourth
    Dictionary.set(priority_map, "Refactoring", 5)  Note: Refactoring last
    
    Let sorted_suggestions be List.copy(suggestions)
    
    Note: Simple bubble sort by priority (sufficient for typical suggestion count)
    Let suggestion_count be List.length(sorted_suggestions)
    For i from 0 to (suggestion_count - 2):
        For j from 0 to (suggestion_count - 2 - i):
            Let current_suggestion be List.get(sorted_suggestions, j)
            Let next_suggestion be List.get(sorted_suggestions, j + 1)
            
            Let current_priority be Dictionary.get_or_default(priority_map, current_suggestion.suggestion_type, 10)
            Let next_priority be Dictionary.get_or_default(priority_map, next_suggestion.suggestion_type, 10)
            
            If current_priority is greater than next_priority:
                List.set(sorted_suggestions, j, next_suggestion)
                List.set(sorted_suggestions, j + 1, current_suggestion)
            End If
        End For
    End For
    
    Return sorted_suggestions
End Process

Process called "create_template_from_data" that takes template_data as Dictionary[String, String] returns FixTemplate:
    @Implementation
    Creates a FixTemplate from parsed dictionary data during import operations.
    @End Implementation
    
    Let template_id be Dictionary.get_or_default(template_data, "template_id", "imported_template")
    Let template_name be Dictionary.get_or_default(template_data, "name", "Imported Template")
    Let fix_template be Dictionary.get_or_default(template_data, "fix_template", "")
    Let confidence_str be Dictionary.get_or_default(template_data, "confidence_weight", "0.8")
    Let confidence_weight be Float.parse(confidence_str)
    
    Note: Parse error patterns
    Let patterns_str be Dictionary.get_or_default(template_data, "error_patterns", "")
    Let error_patterns be If String.is_empty(patterns_str) then ["error"] otherwise String.split(patterns_str, ",")
    
    Note: Parse edit operations
    Let operations_str be Dictionary.get_or_default(template_data, "edit_operations", "replace")
    Let edit_operations be String.split(operations_str, ",")
    
    Note: Parse applicability conditions
    Let conditions_str be Dictionary.get_or_default(template_data, "applicability_conditions", "")
    Let applicability_conditions be If String.is_empty(conditions_str) then List[String] otherwise String.split(conditions_str, ",")
    
    Return FixTemplate with
        template_id as template_id,
        template_name as template_name,
        error_patterns as error_patterns,
        fix_template as fix_template,
        confidence_weight as confidence_weight,
        applicability_conditions as applicability_conditions,
        edit_operations as edit_operations
    End FixTemplate
End Process

Note: =====================================================================
Note: CONTEXTUAL SUGGESTIONS
Note: =====================================================================

Process called "suggest_based_on_imports" that takes engine as SuggestionEngine, available_imports as List[String], error_context as String returns List[Suggestion]:
    @Implementation
    Generates suggestions based on available imports, helping users discover
    relevant functions and types from imported modules.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Analyze error context to determine what might be missing
    If StringPrimitive.contains(error_context, "undefined function") or StringPrimitive.contains(error_context, "function not found"):
        For import_module in available_imports:
            Note: Suggest commonly used functions from each module
            If StringPrimitive.contains(import_module, "Math"):
                Let math_suggestion be Suggestion with
                    suggestion_id as generate_suggestion_id(),
                    suggestion_type as "Import-based Function",
                    confidence_score as 0.85,
                    fix_description as "Try using Math functions like sqrt(), sin(), cos()",
                    original_text as error_context,
                    suggested_text as "Math.sqrt(value)",
                    explanation as "The Math module provides mathematical functions",
                    edit_operations as ["add_function_call"],
                    applicability_range as Dictionary[String, Integer],
                    prerequisites as ["Import Math"]
                End Suggestion
                List.add(suggestions, math_suggestion)
            End If
            
            If StringPrimitive.contains(import_module, "String"):
                Let string_suggestion be Suggestion with
                    suggestion_id as generate_suggestion_id(),
                    suggestion_type as "Import-based Function",
                    confidence_score as 0.83,
                    fix_description as "Try using String functions like length(), substring(), contains()",
                    original_text as error_context,
                    suggested_text as "String.length(text)",
                    explanation as "The String module provides text manipulation functions",
                    edit_operations as ["add_function_call"],
                    applicability_range as Dictionary[String, Integer],
                    prerequisites as ["Import String"]
                End Suggestion
                List.add(suggestions, string_suggestion)
            End If
        End For
    End If
    
    Note: Suggest missing imports if error indicates unknown types
    If StringPrimitive.contains(error_context, "undefined type") or StringPrimitive.contains(error_context, "type not found"):
        Let import_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Missing Import",
            confidence_score as 0.9,
            fix_description as "Add missing import statement",
            original_text as error_context,
            suggested_text as "Import ModuleName",
            explanation as "The required module may need to be imported",
            edit_operations as ["add_import"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, import_suggestion)
    End If
    
    Return suggestions

Process called "suggest_based_on_scope" that takes engine as SuggestionEngine, scope_variables as List[String], error_context as String returns List[Suggestion]:
    @Implementation
    Generates suggestions based on variables currently in scope,
    helping users correct variable references and avoid scope errors.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Handle undefined variable errors by suggesting similar variables in scope
    If StringPrimitive.contains(error_context, "undefined variable") or StringPrimitive.contains(error_context, "variable not found"):
        Let undefined_name be extract_undefined_name(error_context)
        
        For scope_var in scope_variables:
            Note: Calculate similarity score for variable name suggestions
            Let similarity be calculate_string_similarity(undefined_name, scope_var)
            
            If similarity is greater than 0.6:  Note: 60% similarity threshold
                Let confidence be similarity * 0.9  Note: Scale confidence based on similarity
                
                Let scope_suggestion be Suggestion with
                    suggestion_id as generate_suggestion_id(),
                    suggestion_type as "Scope Variable",
                    confidence_score as confidence,
                    fix_description as "Did you mean '" + scope_var + "'?",
                    original_text as undefined_name,
                    suggested_text as scope_var,
                    explanation as "Variable '" + scope_var + "' is available in current scope",
                    edit_operations as ["replace_variable"],
                    applicability_range as Dictionary[String, Integer],
                    prerequisites as List[String]
                End Suggestion
                List.add(suggestions, scope_suggestion)
            End If
        End For
    End If
    
    Note: Suggest variable declarations if no similar variables found
    If List.length(suggestions) equals 0 and StringPrimitive.contains(error_context, "undefined variable"):
        Let undefined_name be extract_undefined_name(error_context)
        
        Let declaration_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Variable Declaration",
            confidence_score as 0.75,
            fix_description as "Declare variable '" + undefined_name + "'",
            original_text as undefined_name,
            suggested_text as "Let " + undefined_name + " be <value>",
            explanation as "Variable needs to be declared before use",
            edit_operations as ["add_declaration"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, declaration_suggestion)
    End If
    
    Return suggestions

Process called "suggest_based_on_type_context" that takes engine as SuggestionEngine, expected_type as String, actual_context as String returns List[Suggestion]:
    @Implementation
    Generates suggestions based on type expectations and mismatches,
    helping users resolve type compatibility issues.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Handle type mismatch errors
    If StringPrimitive.contains(actual_context, "type mismatch") or StringPrimitive.contains(actual_context, "incompatible type"):
        Note: Suggest type conversions based on expected type
        Match expected_type:
            When "String":
                Let conversion_suggestion be Suggestion with
                    suggestion_id as generate_suggestion_id(),
                    suggestion_type as "Type Conversion",
                    confidence_score as 0.88,
                    fix_description as "Convert to String type",
                    original_text as actual_context,
                    suggested_text as "String(value)",
                    explanation as "Convert the value to String using String() constructor",
                    edit_operations as ["wrap_conversion"],
                    applicability_range as Dictionary[String, Integer],
                    prerequisites as List[String]
                End Suggestion
                List.add(suggestions, conversion_suggestion)
            When "Integer":
                Let int_conversion be Suggestion with
                    suggestion_id as generate_suggestion_id(),
                    suggestion_type as "Type Conversion",
                    confidence_score as 0.85,
                    fix_description as "Convert to Integer type",
                    original_text as actual_context,
                    suggested_text as "Integer(value)",
                    explanation as "Convert the value to Integer using Integer() constructor",
                    edit_operations as ["wrap_conversion"],
                    applicability_range as Dictionary[String, Integer],
                    prerequisites as List[String]
                End Suggestion
                List.add(suggestions, int_conversion)
            When "Float":
                Let float_conversion be Suggestion with
                    suggestion_id as generate_suggestion_id(),
                    suggestion_type as "Type Conversion",
                    confidence_score as 0.85,
                    fix_description as "Convert to Float type",
                    original_text as actual_context,
                    suggested_text as "Float(value)",
                    explanation as "Convert the value to Float using Float() constructor",
                    edit_operations as ["wrap_conversion"],
                    applicability_range as Dictionary[String, Integer],
                    prerequisites as List[String]
                End Suggestion
                List.add(suggestions, float_conversion)
            When "Boolean":
                Let bool_conversion be Suggestion with
                    suggestion_id as generate_suggestion_id(),
                    suggestion_type as "Type Conversion",
                    confidence_score as 0.82,
                    fix_description as "Convert to Boolean type",
                    original_text as actual_context,
                    suggested_text as "Boolean(value)",
                    explanation as "Convert the value to Boolean using Boolean() constructor",
                    edit_operations as ["wrap_conversion"],
                    applicability_range as Dictionary[String, Integer],
                    prerequisites as List[String]
                End Suggestion
                List.add(suggestions, bool_conversion)
            Otherwise:
                Let generic_conversion be Suggestion with
                    suggestion_id as generate_suggestion_id(),
                    suggestion_type as "Type Conversion",
                    confidence_score as 0.7,
                    fix_description as "Convert to " + expected_type + " type",
                    original_text as actual_context,
                    suggested_text as expected_type + "(value)",
                    explanation as "Convert the value to " + expected_type + " using type constructor",
                    edit_operations as ["wrap_conversion"],
                    applicability_range as Dictionary[String, Integer],
                    prerequisites as List[String]
                End Suggestion
                List.add(suggestions, generic_conversion)
        End Match
    End If
    
    Note: Suggest proper type annotations if missing
    If StringPrimitive.contains(actual_context, "missing type") or StringPrimitive.contains(actual_context, "type annotation"):
        Let annotation_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Type Annotation",
            confidence_score as 0.9,
            fix_description as "Add type annotation",
            original_text as actual_context,
            suggested_text as "variable as " + expected_type,
            explanation as "Add explicit type annotation to clarify expected type",
            edit_operations as ["add_type_annotation"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, annotation_suggestion)
    End If
    
    Return suggestions

Process called "suggest_completion" that takes engine as SuggestionEngine, partial_code as String, cursor_position as Dictionary[String, Integer] returns List[Suggestion]:
    @Implementation
    Generates code completion suggestions based on partial code and cursor position,
    providing context-aware autocomplete functionality.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    Let cursor_line be Dictionary.get(cursor_position, "line")
    Let cursor_column be Dictionary.get(cursor_position, "column")
    
    Note: Extract current word being typed
    Let lines be String.split(partial_code, "\n")
    If cursor_line is greater than 0 and cursor_line is less than or equal to List.length(lines):
        Let current_line be List.get(lines, cursor_line - 1)
        Let partial_word be extract_partial_word(current_line, cursor_column)
        
        Note: Suggest language keywords based on context
        If String.starts_with(partial_word, "P"):
            Let process_suggestion be Suggestion with
                suggestion_id as generate_suggestion_id(),
                suggestion_type as "Keyword Completion",
                confidence_score as 0.95,
                fix_description as "Complete 'Process' keyword",
                original_text as partial_word,
                suggested_text as "Process called \"function_name\" that takes param as Type returns Type:",
                explanation as "Complete Process function definition",
                edit_operations as ["complete_keyword"],
                applicability_range as Dictionary[String, Integer],
                prerequisites as List[String]
            End Suggestion
            List.add(suggestions, process_suggestion)
        End If
        
        If String.starts_with(partial_word, "L"):
            Let let_suggestion be Suggestion with
                suggestion_id as generate_suggestion_id(),
                suggestion_type as "Keyword Completion",
                confidence_score as 0.92,
                fix_description as "Complete 'Let' keyword",
                original_text as partial_word,
                suggested_text as "Let variable_name be value",
                explanation as "Complete Let variable declaration",
                edit_operations as ["complete_keyword"],
                applicability_range as Dictionary[String, Integer],
                prerequisites as List[String]
            End Suggestion
            List.add(suggestions, let_suggestion)
        End If
        
        If String.starts_with(partial_word, "I"):
            Let if_suggestion be Suggestion with
                suggestion_id as generate_suggestion_id(),
                suggestion_type as "Keyword Completion",
                confidence_score as 0.9,
                fix_description as "Complete 'If' statement",
                original_text as partial_word,
                suggested_text as "If condition:\n    statements\nEnd If",
                explanation as "Complete If conditional statement",
                edit_operations as ["complete_block"],
                applicability_range as Dictionary[String, Integer],
                prerequisites as List[String]
            End Suggestion
            List.add(suggestions, if_suggestion)
        End If
        
        Note: Suggest common function completions
        If StringPrimitive.contains(current_line, "String."):
            Let string_methods be ["length", "substring", "contains", "replace", "split"]
            For method in string_methods:
                If String.starts_with(method, partial_word):
                    Let method_suggestion be Suggestion with
                        suggestion_id as generate_suggestion_id(),
                        suggestion_type as "Method Completion",
                        confidence_score as 0.85,
                        fix_description as "Complete String." + method + "() method",
                        original_text as partial_word,
                        suggested_text as method + "()",
                        explanation as "Complete String method call",
                        edit_operations as ["complete_method"],
                        applicability_range as Dictionary[String, Integer],
                        prerequisites as List[String]
                    End Suggestion
                    List.add(suggestions, method_suggestion)
                End If
            End For
        End If
    End If
    
    Return suggestions

Note: =====================================================================
Note: SYNTAX MODE CONVERSION SUGGESTIONS
Note: =====================================================================

Process called "suggest_mode_conversion" that takes engine as SuggestionEngine, source_code as String, target_mode as String returns List[Suggestion]:
    @Implementation
    Suggests conversion between natural and technical syntax modes,
    helping users transform code to their preferred syntax style.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Match target_mode:
        When "natural":
            Note: Convert technical syntax to natural language patterns
            If StringPrimitive.contains(source_code, "&&"):
                Let and_conversion be Suggestion with
                    suggestion_id as generate_suggestion_id(),
                    suggestion_type as "Mode Conversion",
                    confidence_score as 0.9,
                    fix_description as "Convert && to natural 'and'",
                    original_text as source_code,
                    suggested_text as String.replace(source_code, "&&", "and"),
                    explanation as "Natural mode uses 'and' for logical conjunction",
                    edit_operations as ["convert_operator"],
                    applicability_range as Dictionary[String, Integer],
                    prerequisites as List[String]
                End Suggestion
                List.add(suggestions, and_conversion)
            End If
            
            If StringPrimitive.contains(source_code, "||"):
                Let or_conversion be Suggestion with
                    suggestion_id as generate_suggestion_id(),
                    suggestion_type as "Mode Conversion",
                    confidence_score as 0.9,
                    fix_description as "Convert || to natural 'or'",
                    original_text as source_code,
                    suggested_text as String.replace(source_code, "||", "or"),
                    explanation as "Natural mode uses 'or' for logical disjunction",
                    edit_operations as ["convert_operator"],
                    applicability_range as Dictionary[String, Integer],
                    prerequisites as List[String]
                End Suggestion
                List.add(suggestions, or_conversion)
            End If
            
        When "technical":
            Note: Convert natural language patterns to technical syntax
            If StringPrimitive.contains(source_code, " and "):
                Let tech_and_conversion be Suggestion with
                    suggestion_id as generate_suggestion_id(),
                    suggestion_type as "Mode Conversion",
                    confidence_score as 0.88,
                    fix_description as "Convert 'and' to technical &&",
                    original_text as source_code,
                    suggested_text as String.replace(source_code, " and ", " && "),
                    explanation as "Technical mode uses && for logical conjunction",
                    edit_operations as ["convert_operator"],
                    applicability_range as Dictionary[String, Integer],
                    prerequisites as List[String]
                End Suggestion
                List.add(suggestions, tech_and_conversion)
            End If
            
            If StringPrimitive.contains(source_code, " or "):
                Let tech_or_conversion be Suggestion with
                    suggestion_id as generate_suggestion_id(),
                    suggestion_type as "Mode Conversion",
                    confidence_score as 0.88,
                    fix_description as "Convert 'or' to technical ||",
                    original_text as source_code,
                    suggested_text as String.replace(source_code, " or ", " || "),
                    explanation as "Technical mode uses || for logical disjunction",
                    edit_operations as ["convert_operator"],
                    applicability_range as Dictionary[String, Integer],
                    prerequisites as List[String]
                End Suggestion
                List.add(suggestions, tech_or_conversion)
            End If
            
        When "mixed":
            Note: Suggest keeping best of both modes
            Let mixed_suggestion be Suggestion with
                suggestion_id as generate_suggestion_id(),
                suggestion_type as "Mode Conversion",
                confidence_score as 0.75,
                fix_description as "Keep mixed mode with consistency improvements",
                original_text as source_code,
                suggested_text as "Use consistent patterns within each code block",
                explanation as "Mixed mode allows flexibility but should be internally consistent",
                edit_operations as ["normalize_mixed"],
                applicability_range as Dictionary[String, Integer],
                prerequisites as List[String]
            End Suggestion
            List.add(suggestions, mixed_suggestion)
    End Match
    
    Return suggestions

Process called "suggest_mixed_mode_improvements" that takes engine as SuggestionEngine, mixed_code as String returns List[Suggestion]:
    @Implementation
    Suggests improvements for mixed syntax mode code,
    enhancing consistency while preserving the benefits of mixed mode.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Detect natural and technical patterns within the same code
    Let has_natural_patterns be StringPrimitive.contains(mixed_code, " and ") or StringPrimitive.contains(mixed_code, " or ")
    Let has_technical_patterns be StringPrimitive.contains(mixed_code, "&&") or StringPrimitive.contains(mixed_code, "||")
    
    If has_natural_patterns and has_technical_patterns:
        Let consistency_suggestion be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Mixed Mode Improvement",
            confidence_score as 0.85,
            fix_description as "Use consistent logical operators within the same expression",
            original_text as mixed_code,
            suggested_text as "Choose either 'and'/'or' or '&&'/'||' consistently in each expression",
            explanation as "Mixed mode works best when each expression uses consistent syntax",
            edit_operations as ["normalize_operators"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, consistency_suggestion)
    End If
    
    Note: Suggest sectioning approach for mixed mode
    Let sectioning_suggestion be Suggestion with
        suggestion_id as generate_suggestion_id(),
        suggestion_type as "Mixed Mode Improvement",
        confidence_score as 0.78,
        fix_description as "Organize code into natural and technical sections",
        original_text as mixed_code,
        suggested_text as "Group natural language logic and technical optimizations into separate sections",
        explanation as "Mixed mode benefits from logical organization of different syntax styles",
        edit_operations as ["organize_sections"],
        applicability_range as Dictionary[String, Integer],
        prerequisites as List[String]
    End Suggestion
    List.add(suggestions, sectioning_suggestion)
    
    Note: Suggest commenting strategy for mixed mode
    Let comment_suggestion be Suggestion with
        suggestion_id as generate_suggestion_id(),
        suggestion_type as "Mixed Mode Improvement",
        confidence_score as 0.72,
        fix_description as "Add comments explaining syntax mode choices",
        original_text as mixed_code,
        suggested_text as "Note: Natural language section for readability\nNote: Technical section for performance",
        explanation as "Comments help readers understand the reasoning behind mixed mode usage",
        edit_operations as ["add_mode_comments"],
        applicability_range as Dictionary[String, Integer],
        prerequisites as List[String]
    End Suggestion
    List.add(suggestions, comment_suggestion)
    
    Return suggestions

Process called "detect_mode_inconsistencies" that takes engine as SuggestionEngine, code_section as String returns List[Suggestion]:
    @Implementation
    Detects and suggests fixes for syntax mode inconsistencies,
    identifying patterns that conflict within the same code context.
    @End Implementation
    
    Let suggestions be List[Suggestion]
    
    Note: Detect mixed operators in single expressions
    Let lines be String.split(code_section, "\n")
    For line in lines:
        Let has_natural_and be StringPrimitive.contains(line, " and ")
        Let has_technical_and be StringPrimitive.contains(line, "&&")
        Let has_natural_or be StringPrimitive.contains(line, " or ")
        Let has_technical_or be StringPrimitive.contains(line, "||")
        
        If (has_natural_and and has_technical_and) or (has_natural_or and has_technical_or):
            Let inconsistency_suggestion be Suggestion with
                suggestion_id as generate_suggestion_id(),
                suggestion_type as "Inconsistency Fix",
                confidence_score as 0.95,
                fix_description as "Use consistent logical operators in the same expression",
                original_text as line,
                suggested_text as "Choose either natural ('and'/'or') or technical ('&&'/'||') operators consistently",
                explanation as "Mixing operator styles within the same expression reduces readability",
                edit_operations as ["fix_operator_consistency"],
                applicability_range as Dictionary[String, Integer],
                prerequisites as List[String]
            End Suggestion
            List.add(suggestions, inconsistency_suggestion)
        End If
    End For
    
    Note: Detect inconsistent variable naming within scope
    If StringPrimitive.contains(code_section, "camelCase") and StringPrimitive.contains(code_section, "snake_case"):
        Let naming_inconsistency be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Inconsistency Fix",
            confidence_score as 0.82,
            fix_description as "Use consistent variable naming convention",
            original_text as code_section,
            suggested_text as "Choose either camelCase or snake_case consistently",
            explanation as "Consistent naming conventions improve code maintainability",
            edit_operations as ["normalize_naming"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, naming_inconsistency)
    End If
    
    Note: Detect inconsistent comment styles
    Let has_note_comments be StringPrimitive.contains(code_section, "Note:")
    Let has_other_comments be StringPrimitive.contains(code_section, "//") or StringPrimitive.contains(code_section, "#")
    
    If has_note_comments and has_other_comments:
        Let comment_inconsistency be Suggestion with
            suggestion_id as generate_suggestion_id(),
            suggestion_type as "Inconsistency Fix",
            confidence_score as 0.88,
            fix_description as "Use consistent comment style (Runa uses 'Note:')",
            original_text as code_section,
            suggested_text as "Convert all comments to 'Note:' format",
            explanation as "Runa's standard comment format is 'Note:' for consistency",
            edit_operations as ["normalize_comments"],
            applicability_range as Dictionary[String, Integer],
            prerequisites as List[String]
        End Suggestion
        List.add(suggestions, comment_inconsistency)
    End If
    
    Return suggestions

Note: =====================================================================
Note: MACHINE LEARNING INTEGRATION
Note: =====================================================================

Process called "train_suggestion_model" that takes engine as SuggestionEngine, training_data as List[Dictionary[String, String]] returns Boolean:
    @Implementation
    Trains the suggestion ranking model with user feedback data,
    improving suggestion quality based on historical user interactions.
    @End Implementation
    
    Note: Validate training data format
    If List.length(training_data) is less than 10:
        Return false  Note: Need minimum data for training
    End If
    
    Note: Initialize training statistics
    Let positive_examples be 0
    Let negative_examples be 0
    
    Note: Process training examples to build feature weights
    For example in training_data:
        Let suggestion_type be Dictionary.get(example, "suggestion_type")
        Let user_response be Dictionary.get(example, "user_response")
        Let context_mode be Dictionary.get(example, "context_mode")
        
        Note: Update feedback weights based on user response
        If String.equals(user_response, "accepted"):
            Set positive_examples to positive_examples + 1
            
            Note: Increase weight for this suggestion type
            Let current_weight be Dictionary.get_or_default(engine.user_feedback, suggestion_type, 1.0)
            Dictionary.set(engine.user_feedback, suggestion_type, current_weight * 1.1)
            
        Otherwise If String.equals(user_response, "rejected"):
            Set negative_examples to negative_examples + 1
            
            Note: Decrease weight for this suggestion type
            Let current_weight be Dictionary.get_or_default(engine.user_feedback, suggestion_type, 1.0)
            Dictionary.set(engine.user_feedback, suggestion_type, current_weight * 0.9)
        End If
    End For
    
    Note: Update training statistics
    Dictionary.set(engine.statistics, "training_examples", List.length(training_data))
    Dictionary.set(engine.statistics, "positive_examples", positive_examples)
    Dictionary.set(engine.statistics, "negative_examples", negative_examples)
    Dictionary.set(engine.statistics, "model_trained", 1)
    
    Note: Normalize feedback weights to prevent extreme values
    For feedback_key in engine.user_feedback:
        Let weight be Dictionary.get(engine.user_feedback, feedback_key)
        If weight is greater than 2.0:
            Dictionary.set(engine.user_feedback, feedback_key, 2.0)
        Otherwise If weight is less than 0.1:
            Dictionary.set(engine.user_feedback, feedback_key, 0.1)
        End If
    End For
    
    Return true

Process called "update_model_with_feedback" that takes engine as SuggestionEngine, suggestion_id as String, user_feedback as String returns Boolean:
    @Implementation
    Updates the model based on real-time user feedback for specific suggestions,
    allowing continuous learning and improvement.
    @End Implementation
    
    Note: Find the suggestion by ID in history
    Let target_suggestion be None
    For suggestion in engine.suggestion_history:
        If String.equals(suggestion.suggestion_id, suggestion_id):
            Set target_suggestion to suggestion
            Break
        End If
    End For
    
    Note: If suggestion not found, cannot update
    If target_suggestion equals None:
        Return false
    End If
    
    Note: Extract suggestion type for feedback weighting
    Let suggestion_type be target_suggestion.suggestion_type
    Let current_weight be Dictionary.get_or_default(engine.user_feedback, suggestion_type, 1.0)
    
    Note: Apply feedback adjustments
    Match user_feedback:
        When "accepted":
            Dictionary.set(engine.user_feedback, suggestion_type, current_weight * 1.05)
            Dictionary.increment(engine.statistics, "accepted_suggestions")
        When "rejected":
            Dictionary.set(engine.user_feedback, suggestion_type, current_weight * 0.95)
            Dictionary.increment(engine.statistics, "rejected_suggestions")
        When "helpful":
            Dictionary.set(engine.user_feedback, suggestion_type, current_weight * 1.02)
            Dictionary.increment(engine.statistics, "helpful_suggestions")
        When "unhelpful":
            Dictionary.set(engine.user_feedback, suggestion_type, current_weight * 0.98)
            Dictionary.increment(engine.statistics, "unhelpful_suggestions")
        Otherwise:
            Return false  Note: Unknown feedback type
    End Match
    
    Note: Ensure weights stay within reasonable bounds
    Let updated_weight be Dictionary.get(engine.user_feedback, suggestion_type)
    If updated_weight is greater than 3.0:
        Dictionary.set(engine.user_feedback, suggestion_type, 3.0)
    Otherwise If updated_weight is less than 0.05:
        Dictionary.set(engine.user_feedback, suggestion_type, 0.05)
    End If
    
    Note: Update last feedback timestamp
    Dictionary.set(engine.statistics, "last_feedback_time", get_current_timestamp())
    
    Return true

Process called "predict_suggestion_usefulness" that takes engine as SuggestionEngine, suggestion as Suggestion, context as SuggestionContext returns Float:
    @Implementation
    Predicts the usefulness of a suggestion using the trained ML model,
    combining multiple factors to estimate user satisfaction.
    @End Implementation
    
    Note: Base prediction on suggestion confidence
    Let base_score be suggestion.confidence_score
    
    Note: Apply feedback weight adjustments
    Let feedback_weight be Dictionary.get_or_default(engine.user_feedback, suggestion.suggestion_type, 1.0)
    Let feedback_adjusted_score be base_score * feedback_weight
    
    Note: Context matching bonus
    Let context_bonus be 0.0
    If String.equals(context.syntax_mode, "natural") and StringPrimitive.contains(suggestion.suggestion_type, "Natural"):
        Set context_bonus to 0.1
    Otherwise If String.equals(context.syntax_mode, "technical") and StringPrimitive.contains(suggestion.suggestion_type, "Technical"):
        Set context_bonus to 0.1
    Otherwise If String.equals(context.syntax_mode, "mixed") and StringPrimitive.contains(suggestion.suggestion_type, "Mixed"):
        Set context_bonus to 0.15
    End If
    
    Note: Error type matching bonus
    Let error_bonus be 0.0
    If StringPrimitive.contains(context.error_type, "syntax") and StringPrimitive.contains(suggestion.suggestion_type, "Syntax"):
        Set error_bonus to 0.08
    Otherwise If StringPrimitive.contains(context.error_type, "type") and StringPrimitive.contains(suggestion.suggestion_type, "Type"):
        Set error_bonus to 0.08
    Otherwise If StringPrimitive.contains(context.error_type, "undefined") and StringPrimitive.contains(suggestion.suggestion_type, "Scope"):
        Set error_bonus to 0.08
    End If
    
    Note: Recent success penalty for over-suggested types
    Let recent_penalty be 0.0
    Let suggestion_count be Dictionary.get_or_default(engine.statistics, suggestion.suggestion_type + "_count", 0)
    If suggestion_count is greater than 10:
        Set recent_penalty to 0.05  Note: Slight penalty for over-used suggestion types
    End If
    
    Note: Calculate final prediction
    Let final_prediction be feedback_adjusted_score + context_bonus + error_bonus - recent_penalty
    
    Note: Clamp result between 0.0 and 1.0
    If final_prediction is greater than 1.0:
        Return 1.0
    Otherwise If final_prediction is less than 0.0:
        Return 0.0
    Otherwise:
        Return final_prediction
    End If

Note: =====================================================================
Note: SUGGESTION APPLICATION
Note: =====================================================================

Process called "apply_suggestion" that takes engine as SuggestionEngine, suggestion as Suggestion, source_code as String returns String:
    @Implementation
    Applies a suggestion to source code and returns the modified code,
    performing the actual text transformation based on the suggestion's edit operations.
    @End Implementation
    
    Note: Handle different edit operation types
    For edit_operation in suggestion.edit_operations:
        Match edit_operation:
            When "replace":
                Set source_code to String.replace(source_code, suggestion.original_text, suggestion.suggested_text)
            When "append":
                Set source_code to source_code + suggestion.suggested_text
            When "prepend":
                Set source_code to suggestion.suggested_text + source_code
            When "replace_symbol":
                Set source_code to String.replace(source_code, suggestion.original_text, suggestion.suggested_text)
            When "add_import":
                Note: Add import at the beginning of the file
                Set source_code to suggestion.suggested_text + "\n" + source_code
            When "replace_variable":
                Note: Replace variable name throughout the relevant scope
                Set source_code to String.replace_all(source_code, suggestion.original_text, suggestion.suggested_text)
            When "wrap_conversion":
                Set source_code to String.replace(source_code, suggestion.original_text, suggestion.suggested_text)
            When "insert_operator":
                Note: Insert multiplication operator between adjacent variables
                Set source_code to String.replace(source_code, suggestion.original_text, suggestion.suggested_text)
            When "balance_parens":
                Set source_code to source_code + ")"
            When "add_declaration":
                Note: Find appropriate location to add variable declaration
                Let lines be String.split(source_code, "\n")
                Let insert_location be find_declaration_location(lines)
                List.insert(lines, insert_location, "    " + suggestion.suggested_text)
                Set source_code to String.join(lines, "\n")
            When "complete_keyword":
                Set source_code to String.replace(source_code, suggestion.original_text, suggestion.suggested_text)
            When "complete_method":
                Set source_code to String.replace(source_code, suggestion.original_text, suggestion.suggested_text)
            Otherwise:
                Note: Default to simple replacement
                Set source_code to String.replace(source_code, suggestion.original_text, suggestion.suggested_text)
        End Match
    End For
    
    Note: Update engine statistics
    Dictionary.increment(engine.statistics, "suggestions_applied")
    
    Return source_code

Process called "preview_suggestion_application" that takes engine as SuggestionEngine, suggestion as Suggestion, source_code as String returns String:
    @Implementation
    Previews how a suggestion would modify source code without actually applying it,
    providing a safe way to examine changes before committing them.
    @End Implementation
    
    Note: Create a copy of the source code for preview
    Let preview_code be String.copy(source_code)
    
    Note: Apply the suggestion to the preview copy
    Let modified_preview be apply_suggestion(engine, suggestion, preview_code)
    
    Note: Generate diff-style preview showing changes
    Let preview_lines be String.split(modified_preview, "\n")
    Let original_lines be String.split(source_code, "\n")
    Let preview_result be "Preview of suggestion: " + suggestion.fix_description + "\n\n"
    
    Note: Show line-by-line comparison
    Let max_lines be Math.max(List.length(preview_lines), List.length(original_lines))
    For i from 0 to (max_lines - 1):
        Let original_line be If i is less than List.length(original_lines) then List.get(original_lines, i) otherwise ""
        Let preview_line be If i is less than List.length(preview_lines) then List.get(preview_lines, i) otherwise ""
        
        If not String.equals(original_line, preview_line):
            Set preview_result to preview_result + "- " + original_line + "\n"
            Set preview_result to preview_result + "+ " + preview_line + "\n"
        Otherwise:
            Set preview_result to preview_result + "  " + original_line + "\n"
        End If
    End For
    
    Set preview_result to preview_result + "\n" + suggestion.explanation
    
    Return preview_result

Process called "validate_suggestion_application" that takes engine as SuggestionEngine, modified_code as String, original_code as String returns List[String]:
    @Implementation
    Validates that suggestion application doesn't introduce new errors,
    performing basic syntax and consistency checks.
    @End Implementation
    
    Let validation_errors be List[String]
    
    Note: Check for balanced parentheses
    Let open_parens be count_occurrences(modified_code, "(")
    Let close_parens be count_occurrences(modified_code, ")")
    If open_parens not equals close_parens:
        List.add(validation_errors, "Unbalanced parentheses: " + String(open_parens) + " open, " + String(close_parens) + " close")
    End If
    
    Note: Check for balanced braces
    Let open_braces be count_occurrences(modified_code, "{")
    Let close_braces be count_occurrences(modified_code, "}")
    If open_braces not equals close_braces:
        List.add(validation_errors, "Unbalanced braces: " + String(open_braces) + " open, " + String(close_braces) + " close")
    End If
    
    Note: Check for balanced brackets
    Let open_brackets be count_occurrences(modified_code, "[")
    Let close_brackets be count_occurrences(modified_code, "]")
    If open_brackets not equals close_brackets:
        List.add(validation_errors, "Unbalanced brackets: " + String(open_brackets) + " open, " + String(close_brackets) + " close")
    End If
    
    Note: Check for obvious syntax errors
    If StringPrimitive.contains(modified_code, "End End"):
        List.add(validation_errors, "Duplicate 'End' keywords detected")
    End If
    
    If StringPrimitive.contains(modified_code, "Process Process"):
        List.add(validation_errors, "Duplicate 'Process' keywords detected")
    End If
    
    Note: Check for incomplete constructs
    Let if_count be count_occurrences(modified_code, "If ")
    Let end_if_count be count_occurrences(modified_code, "End If")
    If if_count not equals end_if_count:
        List.add(validation_errors, "Unmatched If statements: " + String(if_count) + " If, " + String(end_if_count) + " End If")
    End If
    
    Let process_count be count_occurrences(modified_code, "Process called")
    Let end_process_count be count_occurrences(modified_code, "End Process")
    If process_count not equals end_process_count:
        List.add(validation_errors, "Unmatched Process definitions: " + String(process_count) + " Process, " + String(end_process_count) + " End Process")
    End If
    
    Note: Check that modification didn't remove essential keywords
    If StringPrimitive.contains(original_code, "Process called") and not StringPrimitive.contains(modified_code, "Process called"):
        List.add(validation_errors, "Essential 'Process called' keyword was removed")
    End If
    
    Return validation_errors

Process called "batch_apply_suggestions" that takes engine as SuggestionEngine, suggestions as List[Suggestion], source_code as String returns String:
    @Implementation
    Applies multiple suggestions to source code in a safe order,
    avoiding conflicts and ensuring each suggestion can be applied correctly.
    @End Implementation
    
    Note: Sort suggestions by priority and dependency order
    Let sorted_suggestions be sort_suggestions_by_priority(suggestions)
    
    Let current_code be String.copy(source_code)
    Let applied_count be 0
    Let failed_applications be List[String]
    
    For suggestion in sorted_suggestions:
        Note: Validate that this suggestion can still be applied to current code
        If StringPrimitive.contains(current_code, suggestion.original_text):
            Note: Apply the suggestion
            Let previous_code be String.copy(current_code)
            Set current_code to apply_suggestion(engine, suggestion, current_code)
            
            Note: Validate the application didn't introduce errors
            Let validation_errors be validate_suggestion_application(engine, current_code, previous_code)
            
            If List.length(validation_errors) equals 0:
                Set applied_count to applied_count + 1
            Otherwise:
                Note: Revert the change if it introduced errors
                Set current_code to previous_code
                List.add(failed_applications, suggestion.suggestion_id + ": " + List.get(validation_errors, 0))
            End If
        Otherwise:
            Note: Skip suggestion if original text no longer exists (may have been modified by previous suggestion)
            List.add(failed_applications, suggestion.suggestion_id + ": Original text no longer found")
        End If
    End For
    
    Note: Update statistics
    Dictionary.set(engine.statistics, "batch_applied_count", applied_count)
    Dictionary.set(engine.statistics, "batch_failed_count", List.length(failed_applications))
    
    Note: Log failed applications for debugging
    If List.length(failed_applications) is greater than 0:
        Dictionary.set(engine.statistics, "last_batch_failures", String.join(failed_applications, "; "))
    End If
    
    Return current_code

Note: =====================================================================
Note: SUGGESTION EXPLANATION
Note: =====================================================================

Process called "generate_suggestion_explanation" that takes engine as SuggestionEngine, suggestion as Suggestion returns String:
    @Implementation
    Generates a detailed explanation for why a suggestion is recommended,
    providing context and educational value to help users understand the reasoning.
    @End Implementation
    
    Let explanation be "This suggestion is recommended because: "
    
    Note: Explain based on suggestion type
    Match suggestion.suggestion_type:
        When "Syntax Fix":
            Set explanation to explanation + "it corrects a syntax error that prevents code compilation. "
        When "Type Conversion":
            Set explanation to explanation + "it resolves a type mismatch by converting values to the expected type. "
        When "Natural to Technical":
            Set explanation to explanation + "technical syntax often provides better performance and clearer semantics. "
        When "Technical to Natural":
            Set explanation to explanation + "natural language syntax improves readability and accessibility. "
        When "Performance Improvement":
            Set explanation to explanation + "it optimizes code execution for better runtime performance. "
        When "Idiom Improvement":
            Set explanation to explanation + "it follows established coding conventions and best practices. "
        When "Mathematical Fix":
            Set explanation to explanation + "it corrects mathematical syntax to ensure proper calculation. "
        When "Import-based Function":
            Set explanation to explanation + "the required functionality is available in imported modules. "
        When "Scope Variable":
            Set explanation to explanation + "a similar variable name exists in the current scope. "
        Otherwise:
            Set explanation to explanation + "it addresses the identified issue in your code. "
    End Match
    
    Note: Add confidence explanation
    If suggestion.confidence_score is greater than 0.9:
        Set explanation to explanation + "This suggestion has high confidence (" + String(suggestion.confidence_score) + ") indicating it's very likely to be helpful."
    Otherwise If suggestion.confidence_score is greater than 0.7:
        Set explanation to explanation + "This suggestion has moderate confidence (" + String(suggestion.confidence_score) + ") and should be carefully reviewed."
    Otherwise:
        Set explanation to explanation + "This suggestion has lower confidence (" + String(suggestion.confidence_score) + ") and may require additional context."
    End If
    
    Return explanation

Process called "explain_fix_rationale" that takes engine as SuggestionEngine, suggestion as Suggestion, error_context as String returns String:
    @Implementation
    Explains the rationale behind a specific fix suggestion,
    connecting the error context to the proposed solution.
    @End Implementation
    
    Let rationale be "Fix Rationale: "
    
    Note: Analyze the error context to provide specific reasoning
    If StringPrimitive.contains(error_context, "syntax error"):
        Set rationale to rationale + "The syntax error indicates incorrect language structure. "
        Set rationale to rationale + "The suggested fix (" + suggestion.suggested_text + ") follows correct Runa syntax rules."
        
    Otherwise If StringPrimitive.contains(error_context, "type mismatch"):
        Set rationale to rationale + "The type mismatch occurs because values don't match expected types. "
        Set rationale to rationale + "Converting to the correct type (" + suggestion.suggested_text + ") resolves the compatibility issue."
        
    Otherwise If StringPrimitive.contains(error_context, "undefined"):
        Set rationale to rationale + "The undefined reference indicates missing declarations or imports. "
        Set rationale to rationale + "The suggested solution (" + suggestion.suggested_text + ") provides the missing definition."
        
    Otherwise If StringPrimitive.contains(error_context, "missing"):
        Set rationale to rationale + "Missing syntax elements cause parsing failures. "
        Set rationale to rationale + "Adding the missing element (" + suggestion.suggested_text + ") completes the syntax structure."
        
    Otherwise:
        Set rationale to rationale + "Based on the error pattern, this fix addresses the root cause. "
        Set rationale to rationale + "The suggestion (" + suggestion.suggested_text + ") resolves the specific issue identified."
    End If
    
    Note: Add implementation details if available
    If List.length(suggestion.edit_operations) is greater than 0:
        Set rationale to rationale + " The fix involves: "
        For operation in suggestion.edit_operations:
            Set rationale to rationale + operation + " "
        End For
    End If
    
    Return rationale

Process called "provide_learning_context" that takes engine as SuggestionEngine, suggestion as Suggestion returns String:
    @Implementation
    Provides educational context to help users learn from suggestions,
    turning error correction into learning opportunities.
    @End Implementation
    
    Let context be "Learning Context: "
    
    Note: Provide educational insights based on suggestion type
    Match suggestion.suggestion_type:
        When "Syntax Fix":
            Set context to context + "Runa syntax follows specific patterns. Key rules include: "
            Set context to context + "1) Use 'Note:' for comments, 2) End blocks with 'End Type/Process/If', "
            Set context to context + "3) Use 'Let' for variable declarations. Practice these patterns to avoid similar errors."
            
        When "Type Conversion":
            Set context to context + "Runa is strongly typed, meaning values must match expected types. "
            Set context to context + "Type conversions like Integer(value) or String(value) help bridge different types. "
            Set context to context + "Understanding type compatibility prevents many common errors."
            
        When "Natural to Technical":
            Set context to context + "Runa supports both natural and technical syntax modes. "
            Set context to context + "Technical mode (&&, ||) offers performance benefits, while natural mode (and, or) improves readability. "
            Set context to context + "Choose the mode that best fits your project's goals."
            
        When "Performance Improvement":
            Set context to context + "Performance optimization involves reducing computational complexity. "
            Set context to context + "Common techniques include: caching repeated calculations, avoiding redundant operations, "
            Set context to context + "and using efficient algorithms. Small optimizations accumulate to significant improvements."
            
        When "Mathematical Fix":
            Set context to context + "Mathematical expressions in programming require explicit operators. "
            Set context to context + "Unlike mathematical notation, programming languages need clear operator precedence. "
            Set context to context + "Use parentheses liberally to clarify intended order of operations."
            
        When "Import-based Function":
            Set context to context + "Modular programming relies on importing functionality from other modules. "
            Set context to context + "Runa's standard library provides extensive functionality - explore available modules "
            Set context to context + "before implementing custom solutions. This reduces code duplication and improves reliability."
            
        Otherwise:
            Set context to context + "Code quality improves through consistent patterns and clear structure. "
            Set context to context + "Each error is an opportunity to learn better practices. "
            Set context to context + "Pay attention to common patterns in suggestions to develop stronger coding habits."
    End Match
    
    Note: Add related concepts to explore
    Set context to context + " Related concepts to explore: "
    If StringPrimitive.contains(suggestion.suggestion_type, "Type"):
        Set context to context + "type systems, static analysis, type inference."
    Otherwise If StringPrimitive.contains(suggestion.suggestion_type, "Syntax"):
        Set context to context + "language grammars, parsing, syntax trees."
    Otherwise If StringPrimitive.contains(suggestion.suggestion_type, "Performance"):
        Set context to context + "algorithmic complexity, profiling, optimization techniques."
    Otherwise:
        Set context to context + "code quality, best practices, design patterns."
    End If
    
    Return context

Note: =====================================================================
Note: SUGGESTION CUSTOMIZATION
Note: =====================================================================

Process called "customize_suggestion_preferences" that takes engine as SuggestionEngine, preferences as Dictionary[String, String] returns Boolean:
    @Implementation
    Customizes the suggestion engine based on user preferences,
    allowing personalized suggestion behavior and filtering.
    @End Implementation
    
    Note: Process each preference setting
    For preference_key in preferences:
        Let preference_value be Dictionary.get(preferences, preference_key)
        
        Match preference_key:
            When "preferred_syntax_mode":
                Set engine.current_mode to preference_value
                Dictionary.set(engine.statistics, "preferred_mode", preference_value)
                
            When "confidence_threshold":
                Let threshold be Float.parse(preference_value)
                Dictionary.set(engine.statistics, "confidence_threshold", Integer(threshold * 100))
                
            When "max_suggestions":
                Let max_count be Integer.parse(preference_value)
                Dictionary.set(engine.statistics, "max_suggestions", max_count)
                
            When "suggestion_types":
                Note: Enable/disable specific suggestion types
                Let enabled_types be String.split(preference_value, ",")
                For suggestion_type in enabled_types:
                    Dictionary.set(engine.user_feedback, suggestion_type, 1.2)  Note: Boost enabled types
                End For
                
            When "disabled_types":
                Note: Disable specific suggestion types
                Let disabled_types be String.split(preference_value, ",")
                For suggestion_type in disabled_types:
                    Dictionary.set(engine.user_feedback, suggestion_type, 0.1)  Note: Reduce disabled types
                End For
                
            When "explanation_level":
                Dictionary.set(engine.statistics, "explanation_level", preference_value)
                
            When "auto_apply":
                Let auto_apply_enabled be Boolean.parse(preference_value)
                Dictionary.set(engine.statistics, "auto_apply", If auto_apply_enabled then 1 otherwise 0)
                
            Otherwise:
                Note: Store custom preferences for future extension
                Dictionary.set(engine.statistics, "custom_" + preference_key, preference_value)
        End Match
    End For
    
    Note: Update preference timestamp
    Dictionary.set(engine.statistics, "preferences_updated", get_current_timestamp())
    
    Return true

Process called "create_custom_fix_template" that takes engine as SuggestionEngine, template_definition as Dictionary[String, String] returns FixTemplate:
    @Implementation
    Creates a custom fix template from user definition,
    allowing users to define their own recurring fix patterns.
    @End Implementation
    
    Note: Extract required fields from template definition
    Let template_id be Dictionary.get_or_default(template_definition, "id", "custom_" + String(get_current_timestamp()))
    Let template_name be Dictionary.get_or_default(template_definition, "name", "Custom Fix")
    Let error_pattern be Dictionary.get_or_default(template_definition, "error_pattern", "")
    Let fix_text be Dictionary.get_or_default(template_definition, "fix_text", "")
    Let description be Dictionary.get_or_default(template_definition, "description", "User-defined fix template")
    Let confidence be Float.parse(Dictionary.get_or_default(template_definition, "confidence", "0.8"))
    
    Note: Validate required fields
    If String.is_empty(error_pattern) or String.is_empty(fix_text):
        Note: Return a minimal template if validation fails
        Return FixTemplate with
            template_id as "invalid_template",
            template_name as "Invalid Template",
            error_patterns as ["error"],
            fix_template as "fix",
            confidence_weight as 0.1,
            applicability_conditions as List[String],
            edit_operations as List[String]
        End FixTemplate
    End If
    
    Note: Parse additional fields
    Let operations_str be Dictionary.get_or_default(template_definition, "operations", "replace")
    Let operations be String.split(operations_str, ",")
    
    Let conditions_str be Dictionary.get_or_default(template_definition, "conditions", "")
    Let conditions be If String.is_empty(conditions_str) then List[String] otherwise String.split(conditions_str, ",")
    
    Note: Create the custom template
    Let custom_template be FixTemplate with
        template_id as template_id,
        template_name as template_name,
        error_patterns as [error_pattern],
        fix_template as fix_text,
        confidence_weight as confidence,
        applicability_conditions as conditions,
        edit_operations as operations
    End FixTemplate
    
    Note: Add template to engine's fix template collection
    Dictionary.set(engine.fix_templates, template_id, custom_template)
    Dictionary.increment(engine.statistics, "custom_templates_created")
    
    Return custom_template

Process called "configure_suggestion_filters" that takes engine as SuggestionEngine, filter_rules as List[String] returns Boolean:
    @Implementation
    Configures filters for suggestion generation,
    allowing users to control which types of suggestions are generated.
    @End Implementation
    
    Note: Clear existing filter configuration
    Dictionary.clear(engine.statistics, "filter_")
    
    Note: Process each filter rule
    For rule in filter_rules:
        Note: Parse rule format: "filter_type:action:value"
        Let rule_parts be String.split(rule, ":")
        If List.length(rule_parts) is greater than or equal to 3:
            Let filter_type be List.get(rule_parts, 0)
            Let action be List.get(rule_parts, 1)
            Let value be List.get(rule_parts, 2)
            
            Match action:
                When "enable":
                    Dictionary.set(engine.statistics, "filter_" + filter_type, "enabled")
                    Dictionary.set(engine.user_feedback, filter_type, 1.2)  Note: Boost enabled types
                    
                When "disable":
                    Dictionary.set(engine.statistics, "filter_" + filter_type, "disabled")
                    Dictionary.set(engine.user_feedback, filter_type, 0.1)  Note: Reduce disabled types
                    
                When "threshold":
                    Let threshold_value be Float.parse(value)
                    Dictionary.set(engine.statistics, "filter_" + filter_type + "_threshold", Integer(threshold_value * 100))
                    
                When "priority":
                    Let priority_value be Integer.parse(value)
                    Dictionary.set(engine.statistics, "filter_" + filter_type + "_priority", priority_value)
                    
                Otherwise:
                    Note: Store custom filter rule for future processing
                    Dictionary.set(engine.statistics, "filter_" + filter_type + "_" + action, value)
            End Match
        End If
    End For
    
    Note: Set up common filter presets based on rules
    If Dictionary.contains(engine.statistics, "filter_strict"):
        Note: Strict mode - only high confidence suggestions
        Dictionary.set(engine.statistics, "confidence_threshold", 85)
        Dictionary.set(engine.statistics, "max_suggestions", 3)
    End If
    
    If Dictionary.contains(engine.statistics, "filter_verbose"):
        Note: Verbose mode - more suggestions with explanations
        Dictionary.set(engine.statistics, "confidence_threshold", 60)
        Dictionary.set(engine.statistics, "max_suggestions", 15)
        Dictionary.set(engine.statistics, "explanation_level", "detailed")
    End If
    
    If Dictionary.contains(engine.statistics, "filter_performance_focus"):
        Note: Focus on performance-related suggestions
        Dictionary.set(engine.user_feedback, "Performance Improvement", 1.5)
        Dictionary.set(engine.user_feedback, "Technical to Natural", 0.3)
    End If
    
    Note: Update filter configuration timestamp
    Dictionary.set(engine.statistics, "filters_configured", get_current_timestamp())
    Dictionary.set(engine.statistics, "filter_count", List.length(filter_rules))
    
    Return true

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "get_suggestion_engine_statistics" that takes engine as SuggestionEngine returns Dictionary[String, Integer]:
    @Implementation
    Gets comprehensive suggestion engine statistics for monitoring and analysis,
    providing insights into usage patterns and performance metrics.
    @End Implementation
    
    Note: Create a copy of the statistics dictionary to prevent external modification
    Let statistics_copy be Dictionary[String, Integer]
    
    Note: Copy core statistics
    For stat_key in engine.statistics:
        Let stat_value be Dictionary.get(engine.statistics, stat_key)
        Note: Convert string values to integers where possible
        If stat_value is String and String.is_numeric(stat_value):
            Dictionary.set(statistics_copy, stat_key, Integer.parse(stat_value))
        Otherwise If stat_value is Integer:
            Dictionary.set(statistics_copy, stat_key, stat_value)
        Otherwise If stat_value is Float:
            Dictionary.set(statistics_copy, stat_key, Integer(stat_value))
        Otherwise:
            Dictionary.set(statistics_copy, stat_key, 0)  Note: Default for non-numeric values
        End If
    End For
    
    Note: Add computed statistics
    Let total_suggestions be List.length(engine.suggestion_history)
    Dictionary.set(statistics_copy, "total_suggestions_generated", total_suggestions)
    
    Let template_count be Dictionary.size(engine.fix_templates)
    Dictionary.set(statistics_copy, "total_fix_templates", template_count)
    
    Let feedback_entries be Dictionary.size(engine.user_feedback)
    Dictionary.set(statistics_copy, "feedback_entries", feedback_entries)
    
    Note: Calculate acceptance rates if data is available
    Let accepted be Dictionary.get_or_default(statistics_copy, "accepted_suggestions", 0)
    Let rejected be Dictionary.get_or_default(statistics_copy, "rejected_suggestions", 0)
    Let total_feedback be accepted + rejected
    
    If total_feedback is greater than 0:
        Let acceptance_rate be (accepted * 100) / total_feedback
        Dictionary.set(statistics_copy, "acceptance_rate_percent", acceptance_rate)
    End If
    
    Note: Add timestamp of statistics generation
    Dictionary.set(statistics_copy, "statistics_generated_at", get_current_timestamp())
    
    Return statistics_copy

Process called "export_suggestion_templates" that takes engine as SuggestionEngine returns String:
    @Implementation
    Exports all fix templates to a structured string format for backup or sharing,
    preserving template data and metadata.
    @End Implementation
    
    Let export_data be "# Runa Suggestion Engine Template Export\n"
    Set export_data to export_data + "# Generated: " + String(get_current_timestamp()) + "\n\n"
    
    Note: Export engine metadata
    Set export_data to export_data + "[ENGINE_INFO]\n"
    Set export_data to export_data + "engine_id=" + engine.engine_id + "\n"
    Set export_data to export_data + "current_mode=" + engine.current_mode + "\n"
    Set export_data to export_data + "ranking_model=" + engine.ranking_model + "\n"
    Set export_data to export_data + "context_analyzer=" + engine.context_analyzer + "\n\n"
    
    Note: Export fix templates
    Set export_data to export_data + "[FIX_TEMPLATES]\n"
    For template_id in engine.fix_templates:
        Let template be Dictionary.get(engine.fix_templates, template_id)
        Set export_data to export_data + "[TEMPLATE:" + template.template_id + "]\n"
        Set export_data to export_data + "name=" + template.template_name + "\n"
        Set export_data to export_data + "fix_template=" + template.fix_template + "\n"
        Set export_data to export_data + "confidence_weight=" + String(template.confidence_weight) + "\n"
        
        Note: Export error patterns
        Set export_data to export_data + "error_patterns="
        For i from 0 to (List.length(template.error_patterns) - 1):
            Let pattern be List.get(template.error_patterns, i)
            Set export_data to export_data + pattern
            If i is less than (List.length(template.error_patterns) - 1):
                Set export_data to export_data + ","
            End If
        End For
        Set export_data to export_data + "\n"
        
        Note: Export edit operations
        Set export_data to export_data + "edit_operations="
        For j from 0 to (List.length(template.edit_operations) - 1):
            Let operation be List.get(template.edit_operations, j)
            Set export_data to export_data + operation
            If j is less than (List.length(template.edit_operations) - 1):
                Set export_data to export_data + ","
            End If
        End For
        Set export_data to export_data + "\n\n"
    End For
    
    Note: Export user feedback data
    Set export_data to export_data + "[USER_FEEDBACK]\n"
    For feedback_key in engine.user_feedback:
        Let feedback_value be Dictionary.get(engine.user_feedback, feedback_key)
        Set export_data to export_data + feedback_key + "=" + String(feedback_value) + "\n"
    End For
    
    Note: Add export footer
    Set export_data to export_data + "\n[EXPORT_END]\n"
    
    Return export_data

Process called "import_suggestion_templates" that takes engine as SuggestionEngine, template_data as String returns Boolean:
    @Implementation
    Imports fix templates from external source, parsing structured template data
    and integrating it into the engine's template collection.
    @End Implementation
    
    Note: Validate import data format
    If not StringPrimitive.contains(template_data, "[FIX_TEMPLATES]"):
        Return false  Note: Invalid format
    End If
    
    Let lines be String.split(template_data, "\n")
    Let current_section be ""
    Let current_template be Dictionary[String, String]
    Let templates_imported be 0
    
    Note: Parse line by line
    For line in lines:
        Let trimmed_line be String.trim(line)
        
        Note: Skip empty lines and comments
        If String.is_empty(trimmed_line) or String.starts_with(trimmed_line, "#"):
            Continue
        End If
        
        Note: Detect section headers
        If String.starts_with(trimmed_line, "[") and String.ends_with(trimmed_line, "]"):
            Note: Process previous template if complete
            If Dictionary.contains(current_template, "template_id") and Dictionary.contains(current_template, "name"):
                Let imported_template be create_template_from_data(current_template)
                Dictionary.set(engine.fix_templates, imported_template.template_id, imported_template)
                Set templates_imported to templates_imported + 1
            End If
            
            Note: Start new section
            Set current_section to trimmed_line
            Set current_template to Dictionary[String, String]  Note: Reset template data
            
            Note: Extract template ID from section header if it's a template section
            If String.starts_with(trimmed_line, "[TEMPLATE:"):
                Let template_id be String.substring(trimmed_line, 10, String.length(trimmed_line) - 11)
                Dictionary.set(current_template, "template_id", template_id)
            End If
            
        Otherwise If String.equals(current_section, "[USER_FEEDBACK]") or String.starts_with(current_section, "[TEMPLATE:"):
            Note: Parse key=value pairs
            If StringPrimitive.contains(trimmed_line, "="):
                Let parts be String.split(trimmed_line, "=")
                If List.length(parts) is greater than or equal to 2:
                    Let key be List.get(parts, 0)
                    Let value be List.get(parts, 1)
                    
                    If String.equals(current_section, "[USER_FEEDBACK]"):
                        Let feedback_value be Float.parse(value)
                        Dictionary.set(engine.user_feedback, key, feedback_value)
                    Otherwise:
                        Dictionary.set(current_template, key, value)
                    End If
                End If
            End If
        End If
    End For
    
    Note: Process final template if exists
    If Dictionary.contains(current_template, "template_id") and Dictionary.contains(current_template, "name"):
        Let final_template be create_template_from_data(current_template)
        Dictionary.set(engine.fix_templates, final_template.template_id, final_template)
        Set templates_imported to templates_imported + 1
    End If
    
    Note: Update import statistics
    Dictionary.set(engine.statistics, "templates_imported", templates_imported)
    Dictionary.set(engine.statistics, "last_import_time", get_current_timestamp())
    
    Return templates_imported is greater than 0

Process called "reset_suggestion_engine" that takes engine as SuggestionEngine returns Boolean:
    @Implementation
    Resets the suggestion engine to default configuration,
    clearing all customizations and returning to initial state.
    @End Implementation
    
    Note: Clear all collections
    Dictionary.clear(engine.fix_templates)
    List.clear(engine.suggestion_history)
    Dictionary.clear(engine.user_feedback)
    Dictionary.clear(engine.statistics)
    
    Note: Reinitialize with default values
    Set engine.current_mode to "standard"
    Set engine.ranking_model to "confidence_based"
    Set engine.context_analyzer to "default"
    
    Note: Restore default fix templates
    Let success be initialize_fix_templates(engine)
    If not success:
        Return false
    End If
    
    Note: Set default statistics
    Dictionary.set(engine.statistics, "suggestions_generated", 0)
    Dictionary.set(engine.statistics, "suggestions_applied", 0)
    Dictionary.set(engine.statistics, "accepted_suggestions", 0)
    Dictionary.set(engine.statistics, "rejected_suggestions", 0)
    Dictionary.set(engine.statistics, "templates_loaded", 4)
    Dictionary.set(engine.statistics, "confidence_threshold", 75)
    Dictionary.set(engine.statistics, "max_suggestions", 10)
    Dictionary.set(engine.statistics, "engine_reset_count", Dictionary.get_or_default(engine.statistics, "engine_reset_count", 0) + 1)
    Dictionary.set(engine.statistics, "last_reset_time", get_current_timestamp())
    
    Note: Reset user feedback to neutral values
    Dictionary.set(engine.user_feedback, "Syntax Fix", 1.0)
    Dictionary.set(engine.user_feedback, "Type Conversion", 1.0)
    Dictionary.set(engine.user_feedback, "Natural to Technical", 1.0)
    Dictionary.set(engine.user_feedback, "Technical to Natural", 1.0)
    Dictionary.set(engine.user_feedback, "Performance Improvement", 1.0)
    Dictionary.set(engine.user_feedback, "Mathematical Fix", 1.0)
    
    Return true