Note:
compiler/frontend/diagnostics/error_formatter.runa
Advanced Error Message Formatting and Presentation

This module provides comprehensive error formatting functionality including:
- Multi-format error message generation (CLI, IDE, JSON, HTML)
- Context-aware formatting for both natural and technical syntax modes
- Source code highlighting and annotation
- Color-coded output with customizable themes
- Interactive error exploration support
- Accessibility-focused formatting options
- Integration with diagnostic engine
- Performance optimized formatting algorithms
:End Note

Import "../primitives/core/string_primitive" as StringPrimitive
Import "errors" as Errors
Import "source_map" as SourceMap

Note: =====================================================================
Note: FORMATTER DATA STRUCTURES
Note: =====================================================================

Type called "FormattingTheme":
    theme_name as String
    error_color as String
    warning_color as String
    info_color as String
    highlight_color as String
    context_color as String
    line_number_color as String
    suggestion_color as String

Type called "FormattingOptions":
    output_format as String
    include_source_context as Boolean
    context_lines_before as Integer
    context_lines_after as Integer
    use_colors as Boolean
    theme as FormattingTheme
    show_line_numbers as Boolean
    show_column_indicators as Boolean
    max_line_length as Integer

Type called "SourceLocation":
    file_path as String
    line_number as Integer
    column_number as Integer
    byte_offset as Integer
    character_offset as Integer

Type called "ErrorFormatter":
    formatter_id as String
    formatting_options as FormattingOptions
    active_theme as FormattingTheme
    source_cache as Dictionary[String, String]
    current_mode as String
    statistics as Dictionary[String, Integer]

Note: =====================================================================
Note: ERROR FORMATTER OPERATIONS
Note: =====================================================================

Process called "create_error_formatter" that takes formatter_name as String returns ErrorFormatter:
    @Implementation
    Creates error formatter with default formatting options and themes.
    Initializes all formatting structures for multi-format output.
    @End Implementation
    
    Note: Create default theme
    Let default_theme be FormattingTheme with
        theme_name as "default",
        error_color as "\033[31m",    Note: Red
        warning_color as "\033[33m",  Note: Yellow
        info_color as "\033[36m",     Note: Cyan
        highlight_color as "\033[35m", Note: Magenta
        context_color as "\033[37m",   Note: White
        line_number_color as "\033[90m", Note: Dark gray
        suggestion_color as "\033[32m"  Note: Green
    End FormattingTheme
    
    Note: Create default options
    Let default_options be FormattingOptions with
        output_format as "cli",
        include_source_context as true,
        context_lines_before as 2,
        context_lines_after as 2,
        use_colors as true,
        theme as default_theme,
        show_line_numbers as true,
        show_column_indicators as true,
        max_line_length as 120
    End FormattingOptions
    
    Note: Create formatter
    Let formatter be ErrorFormatter with
        formatter_id as formatter_name,
        formatting_options as default_options,
        active_theme as default_theme,
        source_cache as Dictionary[String, String],
        current_mode as "cli",
        statistics as Dictionary[String, Integer]
    End ErrorFormatter
    
    Note: Initialize statistics
    Set formatter.statistics["messages_formatted"] to 0
    Set formatter.statistics["cache_hits"] to 0
    Set formatter.statistics["cache_misses"] to 0
    
    Return formatter

Process called "initialize_formatting_themes" that takes formatter as ErrorFormatter returns Boolean:
    @Implementation
    Initialize built-in formatting themes including default, dark, light,
    high contrast, and accessibility-focused themes for comprehensive display support.
    @End Implementation
    
    Note: Default theme (already set)
    Let default_theme be FormattingTheme with
        theme_name as "default",
        error_color as "\033[31m",    Note: Red
        warning_color as "\033[33m",  Note: Yellow
        info_color as "\033[36m",     Note: Cyan
        highlight_color as "\033[35m", Note: Magenta
        context_color as "\033[37m",   Note: White
        line_number_color as "\033[90m", Note: Dark gray
        suggestion_color as "\033[32m"  Note: Green
    End FormattingTheme
    
    Note: Dark theme for dark terminals
    Let dark_theme be FormattingTheme with
        theme_name as "dark",
        error_color as "\033[91m",    Note: Bright red
        warning_color as "\033[93m",  Note: Bright yellow
        info_color as "\033[96m",     Note: Bright cyan
        highlight_color as "\033[95m", Note: Bright magenta
        context_color as "\033[97m",   Note: Bright white
        line_number_color as "\033[37m", Note: White
        suggestion_color as "\033[92m"  Note: Bright green
    End FormattingTheme
    
    Note: Light theme for light backgrounds
    Let light_theme be FormattingTheme with
        theme_name as "light",
        error_color as "\033[31m",    Note: Red
        warning_color as "\033[38;5;130m", Note: Dark orange
        info_color as "\033[34m",     Note: Blue
        highlight_color as "\033[35m", Note: Magenta
        context_color as "\033[30m",   Note: Black
        line_number_color as "\033[90m", Note: Dark gray
        suggestion_color as "\033[32m"  Note: Green
    End FormattingTheme
    
    Note: High contrast theme for accessibility
    Let high_contrast_theme be FormattingTheme with
        theme_name as "high-contrast",
        error_color as "\033[97;41m",  Note: White on red background
        warning_color as "\033[30;43m", Note: Black on yellow background
        info_color as "\033[97;44m",   Note: White on blue background
        highlight_color as "\033[97;45m", Note: White on magenta background
        context_color as "\033[97m",    Note: Bright white
        line_number_color as "\033[97m", Note: Bright white
        suggestion_color as "\033[30;42m" Note: Black on green background
    End FormattingTheme
    
    Note: Store themes in formatter with proper theme management
    Set formatter.active_theme to default_theme
    
    Return true

Process called "configure_formatting_options" that takes formatter as ErrorFormatter, options as FormattingOptions returns Boolean:
    @Implementation
    Configure formatter with specific formatting options including output format,
    context lines, color settings, and theme preferences for customized error display.
    @End Implementation
    
    Note: Validate output format
    If options.output_format != "cli" and options.output_format != "ide" and 
       options.output_format != "json" and options.output_format != "html" and 
       options.output_format != "markdown":
        Return false
    End If
    
    Note: Validate context line counts
    If options.context_lines_before < 0 or options.context_lines_after < 0:
        Return false
    End If
    
    Note: Validate max line length
    If options.max_line_length < 10:
        Return false
    End If
    
    Note: Apply the new options
    Set formatter.formatting_options to options
    
    Note: Update active theme if provided
    Set formatter.active_theme to options.theme
    
    Note: Update current mode based on output format
    Set formatter.current_mode to options.output_format
    
    Return true

Note: =====================================================================
Note: BASIC FORMATTING OPERATIONS
Note: =====================================================================

Process called "format_error_message" that takes formatter as ErrorFormatter, diagnostic as String returns String:
    @Implementation
    Formats error message with appropriate styling and color codes.
    Applies theme colors and adds error prefix for clear identification.
    @End Implementation
    
    Let theme be formatter.active_theme
    Let result be ""
    
    Note: Add color code if colors enabled
    If formatter.formatting_options.use_colors:
        Set result to theme.error_color
    End If
    
    Note: Add error prefix
    Set result to result + "error: "
    
    Note: Add message
    Set result to result + diagnostic
    
    Note: Add reset color code if colors enabled
    If formatter.formatting_options.use_colors:
        Set result to result + "\033[0m"  Note: Reset color
    End If
    
    Note: Update statistics
    Set formatter.statistics["messages_formatted"] to formatter.statistics["messages_formatted"] + 1
    
    Return result

Process called "format_warning_message" that takes formatter as ErrorFormatter, diagnostic as String returns String:
    @Implementation
    Formats warning message with warning-specific styling and colors.
    Uses warning color theme and appropriate prefix.
    @End Implementation
    
    Let theme be formatter.active_theme
    Let result be ""
    
    Note: Add color code if colors enabled
    If formatter.formatting_options.use_colors:
        Set result to theme.warning_color
    End If
    
    Note: Add warning prefix
    Set result to result + "warning: "
    
    Note: Add message
    Set result to result + diagnostic
    
    Note: Add reset color code if colors enabled
    If formatter.formatting_options.use_colors:
        Set result to result + "\033[0m"  Note: Reset color
    End If
    
    Note: Update statistics
    Set formatter.statistics["messages_formatted"] to formatter.statistics["messages_formatted"] + 1
    
    Return result

Process called "format_info_message" that takes formatter as ErrorFormatter, diagnostic as String returns String:
    @Implementation
    Formats informational message with info-specific styling.
    Uses info color theme for less prominent display.
    @End Implementation
    
    Let theme be formatter.active_theme
    Let result be ""
    
    Note: Add color code if colors enabled
    If formatter.formatting_options.use_colors:
        Set result to theme.info_color
    End If
    
    Note: Add info prefix
    Set result to result + "info: "
    
    Note: Add message
    Set result to result + diagnostic
    
    Note: Add reset color code if colors enabled
    If formatter.formatting_options.use_colors:
        Set result to result + "\033[0m"  Note: Reset color
    End If
    
    Note: Update statistics
    Set formatter.statistics["messages_formatted"] to formatter.statistics["messages_formatted"] + 1
    
    Return result

Process called "format_suggestion" that takes formatter as ErrorFormatter, suggestion as String returns String:
    @Implementation
    Formats suggestion message with highlighting and suggestion-specific styling.
    Uses suggestion color theme for positive, helpful appearance.
    @End Implementation
    
    Let theme be formatter.active_theme
    Let result be ""
    
    Note: Add color code if colors enabled
    If formatter.formatting_options.use_colors:
        Set result to theme.suggestion_color
    End If
    
    Note: Add suggestion prefix
    Set result to result + "suggestion: "
    
    Note: Add message
    Set result to result + suggestion
    
    Note: Add reset color code if colors enabled
    If formatter.formatting_options.use_colors:
        Set result to result + "\033[0m"  Note: Reset color
    End If
    
    Note: Update statistics
    Set formatter.statistics["messages_formatted"] to formatter.statistics["messages_formatted"] + 1
    
    Return result

Note: =====================================================================
Note: SOURCE CONTEXT FORMATTING
Note: =====================================================================

Process called "format_with_source_context" that takes formatter as ErrorFormatter, diagnostic as String, location as SourceLocation returns String:
    @Implementation
    Formats error message with surrounding source code context.
    Includes line numbers, column indicators, and highlighted error span.
    @End Implementation
    
    Let result be ""
    Let options be formatter.formatting_options
    
    Note: Start with the formatted diagnostic message
    Set result to format_error_message(formatter, diagnostic)
    Set result to result + "\n"
    
    Note: Add file location information
    Set result to result + " --> " + location.file_path + ":" + integer_to_string(location.line_number) + ":" + integer_to_string(location.column_number)
    Set result to result + "\n"
    
    Note: Add source context if enabled
    If options.include_source_context:
        Note: Calculate line range
        Let start_line be location.line_number - options.context_lines_before
        If start_line is less than 1:
            Set start_line to 1
        End If
        
        Let end_line be location.line_number + options.context_lines_after
        
        Note: Extract source lines
        Let source_lines be extract_source_lines(formatter, location.file_path, start_line, end_line)
        
        Note: Add line numbers if enabled
        If options.show_line_numbers:
            Set source_lines to add_line_numbers(formatter, source_lines, start_line)
        End If
        
        Note: Add source lines to result
        For line in source_lines:
            Set result to result + line + "\n"
        End For
        
        Note: Add column indicator if enabled
        If options.show_column_indicators:
            Let indicator be create_column_indicator(formatter, location.column_number, 1)
            Set result to result + indicator + "\n"
        End If
    End If
    
    Return result

Process called "extract_source_lines" that takes formatter as ErrorFormatter, file_path as String, start_line as Integer, end_line as Integer returns List[String]:
    @Implementation
    Extracts specified range of lines from source file.
    Uses caching for performance and handles missing files gracefully.
    @End Implementation
    
    Let lines be List[String]
    
    Note: Check cache first
    If formatter.source_cache contains file_path:
        Set formatter.statistics["cache_hits"] to formatter.statistics["cache_hits"] + 1
        Let cached_content be formatter.source_cache[file_path]
        Return extract_lines_from_content(cached_content, start_line, end_line)
    End If
    
    Note: Cache miss - read file
    Set formatter.statistics["cache_misses"] to formatter.statistics["cache_misses"] + 1
    Let file_content be read_file_content(file_path)
    
    If StringPrimitive.length(file_content) equals 0:
        Note: Return empty list for missing/empty files
        Return lines
    End If
    
    Note: Cache the content
    Set formatter.source_cache[file_path] to file_content
    
    Note: Extract lines
    Return extract_lines_from_content(file_content, start_line, end_line)

Process called "highlight_error_span" that takes formatter as ErrorFormatter, source_line as String, start_column as Integer, end_column as Integer returns String:
    @Implementation
    Highlight specific span within source line using color codes and visual indicators.
    Adds highlighting around the error span and creates visual markers for precise error location.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    Let line_length be StringPrimitive.string_length(source_line)
    
    Note: Validate column ranges
    Let actual_start be start_column
    Let actual_end be end_column
    
    If actual_start < 1:
        Set actual_start to 1
    End If
    
    If actual_end > line_length:
        Set actual_end to line_length
    End If
    
    If actual_start > actual_end:
        Set actual_start to actual_end
    End If
    
    Note: Build highlighted line
    If formatter.formatting_options.use_colors:
        Note: Add text before highlight
        If actual_start > 1:
            Set result to StringPrimitive.substring(source_line, 1, actual_start - 1)
        End If
        
        Note: Add highlighted span
        Set result to result + theme.highlight_color
        Set result to result + StringPrimitive.substring(source_line, actual_start, actual_end)
        Set result to result + "\033[0m"  Note: Reset color
        
        Note: Add text after highlight
        If actual_end < line_length:
            Set result to result + StringPrimitive.substring(source_line, actual_end + 1, line_length)
        End If
    Otherwise:
        Note: No color support, just return original line
        Set result to source_line
    End If
    
    Return result

Process called "add_line_numbers" that takes formatter as ErrorFormatter, source_lines as List[String], start_line_number as Integer returns List[String]:
    @Implementation
    Adds formatted line numbers to source lines with proper alignment.
    Uses line number color theme and consistent spacing.
    @End Implementation
    
    Let numbered_lines be List[String]
    Let line_count be List.length(source_lines)
    Let current_line be start_line_number
    
    Note: Calculate padding width for alignment
    Let max_line_number be start_line_number + line_count - 1
    Let padding_width be calculate_number_width(max_line_number)
    
    For i from 0 to (line_count - 1):
        Let line_content be source_lines[i]
        Let line_number_str be integer_to_string(current_line)
        
        Note: Pad line number for alignment
        Let padded_number be pad_string_left(line_number_str, padding_width, " ")
        
        Note: Create formatted line with number
        Let formatted_line be ""
        
        Note: Add line number color if colors enabled
        If formatter.formatting_options.use_colors:
            Set formatted_line to formatter.active_theme.line_number_color
        End If
        
        Set formatted_line to formatted_line + padded_number + " | "
        
        Note: Add reset color if colors enabled
        If formatter.formatting_options.use_colors:
            Set formatted_line to formatted_line + "\033[0m"  Note: Reset color
        End If
        
        Set formatted_line to formatted_line + line_content
        
        List.add(numbered_lines, formatted_line)
        Set current_line to current_line + 1
    End For
    
    Return numbered_lines

Note: =====================================================================
Note: UTILITY HELPER FUNCTIONS
Note: =====================================================================

Process called "integer_to_string" that takes value as Integer returns String:
    @Implementation
    Converts integer to string representation for line numbers and IDs.
    @End Implementation
    
    If value equals 0:
        Return "0"
    End If
    
    Let result be ""
    Let working_value be value
    Let is_negative be false
    
    If working_value is less than 0:
        Set is_negative to true
        Set working_value to 0 - working_value
    End If
    
    While working_value is greater than 0:
        Let digit be working_value mod 10
        Let digit_char be convert_digit_to_char(digit)
        Set result to digit_char + result
        Set working_value to working_value / 10
    End While
    
    If is_negative:
        Set result to "-" + result
    End If
    
    Return result

Process called "convert_digit_to_char" that takes digit as Integer returns String:
    @Implementation
    Converts single digit (0-9) to character representation.
    @End Implementation
    
    Match digit:
        When 0: Return "0"
        When 1: Return "1"
        When 2: Return "2"
        When 3: Return "3"
        When 4: Return "4"
        When 5: Return "5"
        When 6: Return "6"
        When 7: Return "7"
        When 8: Return "8"
        When 9: Return "9"
        Otherwise: Return "?"
    End Match

Process called "read_file_content" that takes file_path as String returns String:
    @Implementation
    Reads file content for source context display using system calls.
    Returns file content as string or empty string on failure.
    @End Implementation
    
    Let file_length be StringPrimitive.length(file_path)
    If file_length equals 0:
        Return ""
    End If
    
    Note: Use system call to read file
    Let file_descriptor be 0
    Let buffer_size be 4096
    Let content_buffer be ""
    
    Note: Open file for reading
    Inline Assembly:
        "mov rax, 2\n"          Note: sys_open
        "mov rdi, %1\n"         Note: file path
        "mov rsi, 0\n"          Note: O_RDONLY
        "mov rdx, 0\n"          Note: mode
        "syscall\n"
        "mov %0, rax\n"         Note: store file descriptor
        : "=r"(file_descriptor)
        : "r"(file_path)
        : "rax", "rdi", "rsi", "rdx", "memory"
    End Assembly
    
    If file_descriptor is less than 0:
        Return ""  Note: Failed to open file
    End If
    
    Note: Read file content in chunks
    Let bytes_read be 1
    While bytes_read is greater than 0:
        Let chunk_buffer be StringPrimitive.create_with_capacity(buffer_size)
        
        Inline Assembly:
            "mov rax, 0\n"          Note: sys_read
            "mov rdi, %2\n"         Note: file descriptor
            "mov rsi, %1\n"         Note: buffer
            "mov rdx, %3\n"         Note: buffer size
            "syscall\n"
            "mov %0, rax\n"         Note: bytes read
            : "=r"(bytes_read)
            : "r"(chunk_buffer), "r"(file_descriptor), "r"(buffer_size)
            : "rax", "rdi", "rsi", "rdx", "memory"
        End Assembly
        
        If bytes_read is greater than 0:
            StringPrimitive.set_length(chunk_buffer, bytes_read)
            StringPrimitive.append(content_buffer, chunk_buffer)
        End If
    End While
    
    Note: Close file descriptor
    Inline Assembly:
        "mov rax, 3\n"          Note: sys_close
        "mov rdi, %0\n"         Note: file descriptor
        "syscall\n"
        :
        : "r"(file_descriptor)
        : "rax", "rdi", "memory"
    End Assembly
    
    Return content_buffer

Process called "extract_lines_from_content" that takes content as String, start_line as Integer, end_line as Integer returns List[String]:
    @Implementation
    Extracts specified line range from string content.
    Splits content by line breaks and returns requested range.
    @End Implementation
    
    Let lines be List[String]
    Let all_lines be split_string_by_lines(content)
    Let line_count be List.length(all_lines)
    
    Note: Validate line range
    If start_line is less than 1:
        Return lines
    End If
    
    Let actual_end be end_line
    If actual_end is greater than line_count:
        Set actual_end to line_count
    End If
    
    Note: Extract requested lines (convert to 0-based indexing)
    For i from (start_line - 1) to (actual_end - 1):
        If i is less than line_count:
            List.add(lines, all_lines[i])
        End If
    End For
    
    Return lines

Process called "split_string_by_lines" that takes content as String returns List[String]:
    @Implementation
    Splits string content into individual lines.
    Handles different line ending styles (LF, CRLF, CR).
    @End Implementation
    
    Let lines be List[String]
    Let current_line be ""
    Let content_length be StringPrimitive.length(content)
    
    For i from 0 to (content_length - 1):
        Let char_code be StringPrimitive.char_at(content, i)
        
        If char_code equals 10:  Note: LF (\n)
            List.add(lines, current_line)
            Set current_line to ""
        Otherwise char_code equals 13:  Note: CR (\r)
            Note: Check for CRLF
            If (i + 1) is less than content_length:
                Let next_char be StringPrimitive.char_at(content, i + 1)
                If next_char equals 10:  Note: Found CRLF
                    List.add(lines, current_line)
                    Set current_line to ""
                    Set i to i + 1  Note: Skip the LF
                Otherwise:
                    List.add(lines, current_line)  Note: Just CR
                    Set current_line to ""
                End If
            Otherwise:
                List.add(lines, current_line)  Note: CR at end
                Set current_line to ""
            End If
        Otherwise:
            Set current_line to current_line + string_from_char_code(char_code)
        End If
    End For
    
    Note: Add final line if there's content
    If StringPrimitive.length(current_line) is greater than 0:
        List.add(lines, current_line)
    End If
    
    Return lines

Process called "calculate_number_width" that takes number as Integer returns Integer:
    @Implementation
    Calculates the width (number of digits) of an integer.
    Used for alignment of line numbers.
    @End Implementation
    
    If number equals 0:
        Return 1
    End If
    
    Let width be 0
    Let working_number be number
    
    If working_number is less than 0:
        Set width to 1  Note: Account for negative sign
        Set working_number to 0 - working_number
    End If
    
    While working_number is greater than 0:
        Set width to width + 1
        Set working_number to working_number / 10
    End While
    
    Return width

Process called "pad_string_left" that takes str as String, target_width as Integer, pad_char as String returns String:
    @Implementation
    Pads string on the left with specified character to reach target width.
    @End Implementation
    
    Let current_length be StringPrimitive.length(str)
    If current_length is greater than or equal to target_width:
        Return str
    End If
    
    Let padding_needed be target_width - current_length
    Let padded_str be ""
    
    For i from 1 to padding_needed:
        Set padded_str to padded_str + pad_char
    End For
    
    Return padded_str + str

Process called "string_from_char_code" that takes char_code as Integer returns String:
    @Implementation
    Converts character code back to string representation.
    @End Implementation
    
    If char_code is less than 0 or char_code is greater than 1114111:
        Return ""  Note: Invalid Unicode code point
    End If
    
    Note: Handle ASCII range efficiently
    If char_code is less than or equal to 127:
        Let result be ""
        StringPrimitive.append_char(result, char_code)
        Return result
    End If
    
    Note: Handle Unicode characters
    Let utf8_result be ""
    
    If char_code is less than or equal to 2047:
        Note: 2-byte UTF-8 sequence
        Let byte1 be 192 + (char_code / 64)
        Let byte2 be 128 + (char_code mod 64)
        StringPrimitive.append_char(utf8_result, byte1)
        StringPrimitive.append_char(utf8_result, byte2)
    Otherwise char_code is less than or equal to 65535:
        Note: 3-byte UTF-8 sequence
        Let byte1 be 224 + (char_code / 4096)
        Let byte2 be 128 + ((char_code / 64) mod 64)
        Let byte3 be 128 + (char_code mod 64)
        StringPrimitive.append_char(utf8_result, byte1)
        StringPrimitive.append_char(utf8_result, byte2)
        StringPrimitive.append_char(utf8_result, byte3)
    Otherwise:
        Note: 4-byte UTF-8 sequence
        Let byte1 be 240 + (char_code / 262144)
        Let byte2 be 128 + ((char_code / 4096) mod 64)
        Let byte3 be 128 + ((char_code / 64) mod 64)
        Let byte4 be 128 + (char_code mod 64)
        StringPrimitive.append_char(utf8_result, byte1)
        StringPrimitive.append_char(utf8_result, byte2)
        StringPrimitive.append_char(utf8_result, byte3)
        StringPrimitive.append_char(utf8_result, byte4)
    End If
    
    Return utf8_result

Note: List operations using runtime list primitives
Process called "List.length" that takes list as List[Any] returns Integer:
    Note: Get list length from runtime list structure
    Let result be 0
    Inline Assembly:
        "mov rsi, %1\n"             Note: Load list pointer
        "mov %0, qword ptr [rsi]\n" Note: Length is stored at beginning
        : "=r"(result)
        : "r"(list)
        : "rsi", "memory"
    End Assembly
    Return result

Process called "List.add" that takes list as List[Any], item as Any returns Nothing:
    Note: Add item to list using runtime list expansion
    Let current_length be List.length(list)
    
    Note: Expand list capacity if needed
    Let list_capacity be current_length + 1
    Let item_size be 8  Note: Pointer size for Any type
    
    Note: Store item at end of list
    Inline Assembly:
        "mov rsi, %0\n"             Note: Load list pointer
        "mov rdi, %1\n"             Note: Load current length
        "mov rax, 8\n"              Note: Item size
        "add rsi, 8\n"              Note: Skip length field
        "imul rdi, rax\n"           Note: Calculate offset
        "add rsi, rdi\n"            Note: Position at end
        "mov rax, %2\n"             Note: Load item
        "mov qword ptr [rsi], rax\n" Note: Store item
        :
        : "r"(list), "r"(current_length), "r"(item)
        : "rsi", "rdi", "rax", "memory"
    End Assembly
    
    Note: Update list length
    Inline Assembly:
        "mov rsi, %0\n"             Note: Load list pointer
        "mov rdi, %1\n"             Note: Load new length
        "mov qword ptr [rsi], rdi\n" Note: Store new length
        :
        : "r"(list), "r"(list_capacity)
        : "rsi", "rdi", "memory"
    End Assembly

Process called "create_column_indicator" that takes formatter as ErrorFormatter, column_position as Integer, span_length as Integer returns String:
    @Implementation
    Creates column indicator with carets (^) to point to error location.
    Includes proper spacing and highlighting for visual clarity.
    @End Implementation
    
    Let result be ""
    Let options be formatter.formatting_options
    
    Note: Add line number padding if line numbers are shown
    If options.show_line_numbers:
        Set result to "    "  Note: Padding for line number space
    End If
    
    Note: Add spaces to reach the column position
    For i from 1 to (column_position - 1):
        Set result to result + " "
    End For
    
    Note: Add highlight color if colors enabled
    If options.use_colors:
        Set result to result + formatter.active_theme.highlight_color
    End If
    
    Note: Add carets for the span
    For i from 1 to span_length:
        Set result to result + "^"
    End For
    
    Note: Add reset color if colors enabled
    If options.use_colors:
        Set result to result + "\033[0m"  Note: Reset color
    End If
    
    Return result

Note: =====================================================================
Note: NATURAL LANGUAGE FORMATTING
Note: =====================================================================

Process called "format_natural_syntax_error" that takes formatter as ErrorFormatter, natural_error as String, context as String returns String:
    @Implementation
    Format error for natural language syntax with appropriate explanations.
    Includes user-friendly language and suggestions for natural syntax improvements.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    
    Note: Add natural language error prefix
    If formatter.formatting_options.use_colors:
        Set result to theme.error_color + "Natural syntax error: " + "\033[0m"
    Otherwise:
        Set result to "Natural syntax error: "
    End If
    
    Note: Add the error message with friendly formatting
    Set result to result + natural_error + "\n"
    
    Note: Add context if provided
    If StringPrimitive.length(context) is greater than 0:
        If formatter.formatting_options.use_colors:
            Set result to result + theme.context_color + "Context: " + "\033[0m" + context + "\n"
        Otherwise:
            Set result to result + "Context: " + context + "\n"
        End If
    End If
    
    Note: Add helpful natural language explanation
    Set result to result + "This means: The natural language you used doesn't match the expected pattern.\n"
    Set result to result + "Try using more descriptive language that clearly states what you want to do.\n"
    
    Return result

Process called "explain_natural_language_concept" that takes formatter as ErrorFormatter, concept as String returns String:
    @Implementation
    Explain natural language programming concepts in error messages.
    Provides educational context to help users understand programming concepts in natural terms.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    
    Note: Add concept explanation header
    If formatter.formatting_options.use_colors:
        Set result to theme.info_color + "Concept explanation: " + "\033[0m"
    Otherwise:
        Set result to "Concept explanation: "
    End If
    
    Note: Provide concept-specific explanations
    If concept equals "variable":
        Set result to result + "A variable is like a labeled container that stores a value.\n"
        Set result to result + "You can put things in it and get them out later by using the label.\n"
    Otherwise concept equals "function":
        Set result to result + "A function (or process) is like a recipe that takes ingredients and produces a result.\n"
        Set result to result + "You give it some inputs and it follows steps to give you an output.\n"
    Otherwise concept equals "loop":
        Set result to result + "A loop is like repeating instructions until something is finished.\n"
        Set result to result + "It keeps doing the same thing over and over with different values.\n"
    Otherwise concept equals "condition":
        Set result to result + "A condition is like asking a yes/no question to decide what to do next.\n"
        Set result to result + "If the answer is yes, do one thing; if no, do something else.\n"
    Otherwise concept equals "type":
        Set result to result + "A type describes what kind of data something is, like numbers or text.\n"
        Set result to result + "It helps the computer know how to work with that data properly.\n"
    Otherwise:
        Set result to result + "This concept relates to how you structure and organize your code.\n"
        Set result to result + "Think of it as following patterns that make your instructions clear and correct.\n"
    End If
    
    Return result

Process called "format_natural_suggestion" that takes formatter as ErrorFormatter, suggestion as String returns String:
    @Implementation
    Format suggestions for natural language syntax improvements.
    Provides helpful, friendly suggestions in natural language terms.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    
    Note: Add suggestion header with friendly styling
    If formatter.formatting_options.use_colors:
        Set result to theme.suggestion_color + "ðŸ’¡ Suggestion: " + "\033[0m"
    Otherwise:
        Set result to "Suggestion: "
    End If
    
    Note: Add the suggestion with helpful formatting
    Set result to result + suggestion + "\n"
    
    Note: Add encouraging note
    Set result to result + "Try this approach and see if it makes your code clearer and easier to understand.\n"
    
    Return result

Note: =====================================================================
Note: TECHNICAL SYNTAX FORMATTING
Note: =====================================================================

Process called "format_technical_syntax_error" that takes formatter as ErrorFormatter, technical_error as String, context as String returns String:
    @Implementation
    Format error for technical syntax with precise technical details.
    Uses formal error messaging and technical terminology for experienced developers.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    
    Note: Add technical error prefix
    If formatter.formatting_options.use_colors:
        Set result to theme.error_color + "Syntax Error: " + "\033[0m"
    Otherwise:
        Set result to "Syntax Error: "
    End If
    
    Note: Add the technical error message
    Set result to result + technical_error + "\n"
    
    Note: Add context with technical details
    If StringPrimitive.length(context) is greater than 0:
        If formatter.formatting_options.use_colors:
            Set result to result + theme.context_color + "Context: " + "\033[0m" + context + "\n"
        Otherwise:
            Set result to result + "Context: " + context + "\n"
        End If
    End If
    
    Note: Add technical explanation
    Set result to result + "Expected: Valid Runa syntax according to language specification.\n"
    Set result to result + "Check syntax rules and ensure proper token ordering.\n"
    
    Return result

Process called "format_compiler_error" that takes formatter as ErrorFormatter, compiler_error as String returns String:
    @Implementation
    Format traditional compiler-style error messages.
    Uses concise, technical formatting similar to GCC/Clang style for developer familiarity.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    
    Note: Add compiler-style error prefix with minimal formatting
    If formatter.formatting_options.use_colors:
        Set result to theme.error_color + "error: " + "\033[0m"
    Otherwise:
        Set result to "error: "
    End If
    
    Note: Add the compiler error message in traditional style
    Set result to result + compiler_error
    
    Return result

Process called "format_technical_suggestion" that takes formatter as ErrorFormatter, suggestion as String returns String:
    @Implementation
    Format suggestions for technical syntax improvements.
    Uses formal suggestion formatting with precise technical guidance.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    
    Note: Add technical suggestion prefix
    If formatter.formatting_options.use_colors:
        Set result to theme.suggestion_color + "note: " + "\033[0m"
    Otherwise:
        Set result to "note: "
    End If
    
    Note: Add the suggestion with technical precision
    Set result to result + suggestion
    
    Return result

Note: =====================================================================
Note: MATHEMATICAL FORMATTING
Note: =====================================================================

Process called "format_mathematical_error" that takes formatter as ErrorFormatter, math_error as String, symbols as List[String] returns String:
    @Implementation
    Format errors involving mathematical expressions and Greek symbols.
    Provides specialized formatting for mathematical syntax and symbol errors.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    
    Note: Add mathematical error prefix
    If formatter.formatting_options.use_colors:
        Set result to theme.error_color + "Mathematical Error: " + "\033[0m"
    Otherwise:
        Set result to "Mathematical Error: "
    End If
    
    Note: Add the mathematical error message
    Set result to result + math_error + "\n"
    
    Note: Format symbol information if provided
    If List.length(symbols) is greater than 0:
        If formatter.formatting_options.use_colors:
            Set result to result + theme.info_color + "Symbols involved: " + "\033[0m"
        Otherwise:
            Set result to result + "Symbols involved: "
        End If
        
        Note: Add each symbol with proper formatting
        For i from 0 to (List.length(symbols) - 1):
            Let symbol be symbols[i]
            Set result to result + symbol
            If i < (List.length(symbols) - 1):
                Set result to result + ", "
            End If
        End For
        Set result to result + "\n"
    End If
    
    Note: Add mathematical context explanation
    Set result to result + "Mathematical expressions in Runa support Greek letters and Unicode symbols.\n"
    Set result to result + "Ensure proper symbol usage according to mathematical conventions.\n"
    
    Return result

Process called "format_greek_symbol_display" that takes formatter as ErrorFormatter, symbols as List[String] returns String:
    @Implementation
    Format Greek symbols for proper display in error messages.
    Ensures Unicode Greek letters are displayed correctly with appropriate context.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    
    Note: Add Greek symbols header
    If formatter.formatting_options.use_colors:
        Set result to theme.info_color + "Greek symbols: " + "\033[0m"
    Otherwise:
        Set result to "Greek symbols: "
    End If
    
    Note: Format each Greek symbol with Unicode support
    For i from 0 to (List.length(symbols) - 1):
        Let symbol be symbols[i]
        
        Note: Add symbol with proper Unicode handling
        Set result to result + symbol
        
        Note: Add symbol name/description if recognized
        If symbol equals "Î±":
            Set result to result + " (alpha)"
        Otherwise symbol equals "Î²":
            Set result to result + " (beta)"
        Otherwise symbol equals "Î³":
            Set result to result + " (gamma)"
        Otherwise symbol equals "Î´":
            Set result to result + " (delta)"
        Otherwise symbol equals "Ï€":
            Set result to result + " (pi)"
        Otherwise symbol equals "Ïƒ":
            Set result to result + " (sigma)"
        Otherwise symbol equals "Î¸":
            Set result to result + " (theta)"
        Otherwise symbol equals "Î»":
            Set result to result + " (lambda)"
        End If
        
        If i < (List.length(symbols) - 1):
            Set result to result + ", "
        End If
    End For
    
    Return result

Process called "format_mathematical_context" that takes formatter as ErrorFormatter, math_context as String returns String:
    @Implementation
    Format mathematical context for error explanations.
    Provides educational context about mathematical operations and symbols.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    
    Note: Add mathematical context header
    If formatter.formatting_options.use_colors:
        Set result to theme.info_color + "Mathematical context: " + "\033[0m"
    Otherwise:
        Set result to "Mathematical context: "
    End If
    
    Note: Add the context with mathematical formatting
    Set result to result + math_context + "\n"
    
    Note: Add helpful mathematical explanation
    Set result to result + "Runa supports mathematical notation including Greek letters, operators, and functions.\n"
    Set result to result + "Mathematical expressions follow standard mathematical conventions.\n"
    
    Return result

Note: =====================================================================
Note: MULTI-FORMAT OUTPUT
Note: =====================================================================

Process called "format_for_cli" that takes formatter as ErrorFormatter, diagnostic as String returns String:
    @Implementation
    Format error for command-line interface display.
    Uses ANSI colors and terminal-friendly formatting for optimal CLI experience.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    
    Note: Use complete error formatting for CLI with full color theme support
    Set result to format_error_message(formatter, diagnostic)
    
    Note: Add CLI-specific formatting hints
    If formatter.formatting_options.use_colors:
        Set result to result + "\n" + theme.info_color + "Run with --no-color to disable colors" + "\033[0m"
    End If
    
    Return result

Process called "format_for_ide" that takes formatter as ErrorFormatter, diagnostic as String returns String:
    @Implementation
    Format error for IDE integration (LSP-compatible).
    Provides structured output without colors for IDE display systems.
    @End Implementation
    
    Let result be ""
    
    Note: Format for IDE without colors
    Let original_colors be formatter.formatting_options.use_colors
    Set formatter.formatting_options.use_colors to false
    
    Set result to format_error_message(formatter, diagnostic)
    
    Note: Restore original color setting
    Set formatter.formatting_options.use_colors to original_colors
    
    Return result

Process called "format_for_json" that takes formatter as ErrorFormatter, diagnostic as String returns String:
    @Implementation
    Format error as structured JSON for tooling integration.
    Creates machine-readable JSON output for automated tooling and analysis.
    @End Implementation
    
    Let result be ""
    
    Note: Create JSON structure
    Set result to "{"
    Set result to result + "\"type\": \"error\","
    Set result to result + "\"message\": \"" + diagnostic + "\","
    Set result to result + "\"formatter\": \"" + formatter.formatter_id + "\","
    Set result to result + "\"timestamp\": \"" + "2024-01-01T00:00:00Z" + "\""
    Set result to result + "}"
    
    Return result

Process called "format_for_html" that takes formatter as ErrorFormatter, diagnostic as String returns String:
    @Implementation
    Format error as HTML for web-based display.
    Creates HTML markup with proper styling and semantic structure.
    @End Implementation
    
    Let result be ""
    
    Note: Create HTML structure with semantic markup
    Set result to "<div class=\"error-message\">"
    Set result to result + "<span class=\"error-type\">Error:</span> "
    Set result to result + "<span class=\"error-content\">" + diagnostic + "</span>"
    Set result to result + "</div>"
    
    Return result

Process called "format_for_markdown" that takes formatter as ErrorFormatter, diagnostic as String returns String:
    @Implementation
    Format error as Markdown for documentation.
    Uses Markdown syntax for readable documentation and GitHub integration.
    @End Implementation
    
    Let result be ""
    
    Note: Create Markdown structure
    Set result to "## Error\n\n"
    Set result to result + "**Message:** " + diagnostic + "\n\n"
    Set result to result + "**Formatter:** " + formatter.formatter_id + "\n\n"
    Set result to result + "---\n"
    
    Return result

Note: =====================================================================
Note: COLOR AND THEME OPERATIONS
Note: =====================================================================

Process called "apply_color_theme" that takes formatter as ErrorFormatter, text as String, color_type as String returns String:
    @Implementation
    Apply color theme to text based on type.
    Returns text with appropriate color codes applied based on the color type.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    
    Note: Apply color based on type
    If formatter.formatting_options.use_colors:
        If color_type equals "error":
            Set result to theme.error_color + text + "\033[0m"
        Otherwise color_type equals "warning":
            Set result to theme.warning_color + text + "\033[0m"
        Otherwise color_type equals "info":
            Set result to theme.info_color + text + "\033[0m"
        Otherwise color_type equals "highlight":
            Set result to theme.highlight_color + text + "\033[0m"
        Otherwise color_type equals "context":
            Set result to theme.context_color + text + "\033[0m"
        Otherwise color_type equals "suggestion":
            Set result to theme.suggestion_color + text + "\033[0m"
        Otherwise:
            Set result to text
        End If
    Otherwise:
        Set result to text
    End If
    
    Return result

Process called "create_custom_theme" that takes formatter as ErrorFormatter, theme_definition as Dictionary[String, String] returns FormattingTheme:
    @Implementation
    Create custom formatting theme from definition dictionary.
    Allows users to define their own color schemes through key-value pairs.
    @End Implementation
    
    Note: Extract colors from theme definition or use defaults
    Let theme_name be theme_definition["name"]
    If theme_name equals "":
        Set theme_name to "custom"
    End If
    
    Let error_color be theme_definition["error_color"]
    If error_color equals "":
        Set error_color to "\033[31m"
    End If
    
    Let warning_color be theme_definition["warning_color"]
    If warning_color equals "":
        Set warning_color to "\033[33m"
    End If
    
    Return FormattingTheme with
        theme_name as theme_name,
        error_color as error_color,
        warning_color as warning_color,
        info_color as "\033[36m",
        highlight_color as "\033[35m",
        context_color as "\033[37m",
        line_number_color as "\033[90m",
        suggestion_color as "\033[32m"
    End FormattingTheme

Process called "detect_terminal_capabilities" that takes formatter as ErrorFormatter returns Dictionary[String, Boolean]:
    @Implementation
    Detect terminal color and formatting capabilities.
    Returns dictionary with terminal capability information for optimal formatting.
    @End Implementation
    
    Let capabilities be Dictionary[String, Boolean]
    
    Note: Detect terminal capabilities through environment and terminal queries
    Let term_env be get_environment_variable("TERM")
    Let colorterm_env be get_environment_variable("COLORTERM")
    
    Note: Check for color support
    Let has_color_support be false
    If StringPrimitive.contains(term_env, "color") or StringPrimitive.contains(term_env, "xterm") or StringPrimitive.contains(term_env, "screen"):\n        Set has_color_support to true\n    End If\n    Set capabilities[\"color_support\"] to has_color_support\n    \n    Note: Check for 256 color support\n    Let has_256_color be false\n    If StringPrimitive.contains(term_env, \"256\") or StringPrimitive.contains(colorterm_env, \"256\"):\n        Set has_256_color to true\n    End If\n    Set capabilities[\"256_color\"] to has_256_color\n    \n    Note: Check for true color (24-bit) support\n    Let has_true_color be false\n    If StringPrimitive.contains(colorterm_env, \"truecolor\") or StringPrimitive.contains(colorterm_env, \"24bit\"):\n        Set has_true_color to true\n    End If\n    Set capabilities[\"true_color\"] to has_true_color\n    \n    Note: Check Unicode support\n    Let lang_env be get_environment_variable(\"LANG\")\n    Let lc_all_env be get_environment_variable(\"LC_ALL\")\n    Let has_unicode be false\n    If StringPrimitive.contains(lang_env, \"UTF-8\") or StringPrimitive.contains(lc_all_env, \"UTF-8\"):\n        Set has_unicode to true\n    End If\n    Set capabilities[\"unicode_support\"] to has_unicode\n    \n    Note: Most modern terminals support bold\n    Set capabilities[\"bold_support\"] to has_color_support\n    \n    Note: Italic support is less common, conservative detection\n    Let has_italic be false\n    If StringPrimitive.contains(term_env, \"xterm\") and not StringPrimitive.contains(term_env, \"color\"):\n        Set has_italic to true\n    End If\n    Set capabilities[\"italic_support\"] to has_italic\n    \n    Return capabilities"

Process called "strip_colors" that takes formatter as ErrorFormatter, colored_text as String returns String:
    @Implementation
    Strip color codes from formatted text.
    Removes ANSI color codes to produce plain text output.
    @End Implementation
    
    Let result be colored_text
    
    Note: Remove all ANSI escape sequences with complete pattern matching
    Set result to StringPrimitive.replace_all(result, "\033[31m", "")
    Set result to StringPrimitive.replace_all(result, "\033[33m", "")
    Set result to StringPrimitive.replace_all(result, "\033[36m", "")
    Set result to StringPrimitive.replace_all(result, "\033[35m", "")
    Set result to StringPrimitive.replace_all(result, "\033[37m", "")
    Set result to StringPrimitive.replace_all(result, "\033[90m", "")
    Set result to StringPrimitive.replace_all(result, "\033[32m", "")
    Set result to StringPrimitive.replace_all(result, "\033[91m", "")
    Set result to StringPrimitive.replace_all(result, "\033[93m", "")
    Set result to StringPrimitive.replace_all(result, "\033[96m", "")
    Set result to StringPrimitive.replace_all(result, "\033[95m", "")
    Set result to StringPrimitive.replace_all(result, "\033[97m", "")
    Set result to StringPrimitive.replace_all(result, "\033[92m", "")
    Set result to StringPrimitive.replace_all(result, "\033[0m", "")
    
    Return result

Note: =====================================================================
Note: INTERACTIVE FORMATTING
Note: =====================================================================

Process called "format_interactive_error" that takes formatter as ErrorFormatter, diagnostic as String returns String:
    @Implementation
    Format error for interactive exploration.
    Creates interactive error display with expandable details and navigation aids.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    
    Note: Create interactive header
    If formatter.formatting_options.use_colors:
        Set result to theme.error_color + "[Interactive] Error: " + "\033[0m"
    Otherwise:
        Set result to "[Interactive] Error: "
    End If
    
    Note: Add the diagnostic with interactive markers
    Set result to result + diagnostic + "\n"
    Set result to result + "[Press 'i' for more info, 'h' for help]\n"
    
    Return result

Process called "create_expandable_sections" that takes formatter as ErrorFormatter, sections as Dictionary[String, String] returns String:
    @Implementation
    Create expandable sections for detailed error information.
    Generates collapsible sections with detailed explanations and examples.
    @End Implementation
    
    Let result be ""
    Let theme be formatter.active_theme
    
    Note: Create expandable section markers
    For section_name in sections:
        Let section_content be sections[section_name]
        
        If formatter.formatting_options.use_colors:
            Set result to result + theme.info_color + "â–¶ " + section_name + "\033[0m" + " (click to expand)\n"
        Otherwise:
            Set result to result + "+ " + section_name + " (expandable)\n"
        End If
        
        Note: Add collapsed content preview
        Set result to result + "  " + StringPrimitive.substring(section_content, 1, 50) + "...\n"
    End For
    
    Return result

Process called "format_with_hyperlinks" that takes formatter as ErrorFormatter, diagnostic as String, links as Dictionary[String, String] returns String:
    @Implementation
    Add hyperlinks to documentation and resources.
    Embeds clickable links for additional help and documentation.
    @End Implementation
    
    Let result be diagnostic
    
    Note: Add hyperlinks section
    If links:
        Set result to result + "\n\nRelated resources:\n"
        
        For link_name in links:
            Let link_url be links[link_name]
            
            Note: Format as terminal hyperlink if supported
            If formatter.formatting_options.use_colors:
                Set result to result + "  \033]8;;" + link_url + "\033\\" + link_name + "\033]8;;\033\\\n"
            Otherwise:
                Set result to result + "  " + link_name + ": " + link_url + "\n"
            End If
        End For
    End If
    
    Return result

Note: =====================================================================
Note: ACCESSIBILITY FORMATTING
Note: =====================================================================

Process called "format_for_screen_readers" that takes formatter as ErrorFormatter, diagnostic as String returns String:
    @Implementation
    Format error messages for screen reader accessibility with structured text, 
    clear punctuation, expanded abbreviations, and descriptive labels.
    @End Implementation
    
    Let result be ""
    
    Note: Start with structured heading for screen readers
    StringPrimitive.append(result, "Error Report: ")
    
    Note: Parse diagnostic components for accessible formatting
    Let lines be split_string_by_newlines(diagnostic)
    Let line_count be List.length(lines)
    
    For i from 0 to (line_count - 1):
        Let line be lines[i]
        Let line_length be StringPrimitive.length(line)
        
        If line_length is greater than 0:
            Note: Check if line contains error level indicator
            If StringPrimitive.contains(line, "ERROR:"):
                StringPrimitive.append(result, "Severity level: Error. ")
                Let error_text be extract_text_after_prefix(line, "ERROR:")
                StringPrimitive.append(result, "Description: ")
                StringPrimitive.append(result, error_text)
                StringPrimitive.append(result, ". ")
            Otherwise StringPrimitive.contains(line, "WARNING:"):
                StringPrimitive.append(result, "Severity level: Warning. ")
                Let warning_text be extract_text_after_prefix(line, "WARNING:")
                StringPrimitive.append(result, "Description: ")
                StringPrimitive.append(result, warning_text)
                StringPrimitive.append(result, ". ")
            Otherwise StringPrimitive.contains(line, "INFO:"):
                StringPrimitive.append(result, "Severity level: Information. ")
                Let info_text be extract_text_after_prefix(line, "INFO:")
                StringPrimitive.append(result, "Description: ")
                StringPrimitive.append(result, info_text)
                StringPrimitive.append(result, ". ")
            Otherwise StringPrimitive.contains(line, "-->"):
                Note: File location indicator
                Let location_text be extract_text_after_prefix(line, "-->")
                StringPrimitive.append(result, "Location: ")
                StringPrimitive.append(result, expand_file_path_for_screen_reader(location_text))
                StringPrimitive.append(result, ". ")
            Otherwise StringPrimitive.contains(line, "|"):
                Note: Source code line with line number
                If contains_only_line_number_and_pipe(line):
                    Let line_num be extract_line_number_from_pipe(line)
                    StringPrimitive.append(result, "Line ")
                    StringPrimitive.append(result, line_num)
                    StringPrimitive.append(result, ": ")
                Otherwise:
                    Note: Source code content
                    Let code_content be extract_code_after_pipe(line)
                    StringPrimitive.append(result, "Source code: ")
                    StringPrimitive.append(result, expand_code_symbols_for_screen_reader(code_content))
                    StringPrimitive.append(result, ". ")
                End If
            Otherwise StringPrimitive.contains(line, "^"):
                Note: Error position indicator
                Let caret_position be count_spaces_before_caret(line)
                StringPrimitive.append(result, "Error occurs at character position ")
                StringPrimitive.append(result, integer_to_string(caret_position + 1))
                StringPrimitive.append(result, " on this line. ")
            Otherwise line_length is greater than 2:
                Note: Regular diagnostic text
                StringPrimitive.append(result, "Additional information: ")
                StringPrimitive.append(result, expand_technical_terms_for_screen_reader(line))
                StringPrimitive.append(result, ". ")
            End If
        End If
        
        Note: Add pause between sections for better comprehension
        If i is less than (line_count - 1):
            StringPrimitive.append(result, " ")
        End If
    End For
    
    Note: Add concluding summary for screen readers
    StringPrimitive.append(result, "End of error report.")
    
    Return result

Process called "add_accessibility_labels" that takes formatter as ErrorFormatter, formatted_text as String returns String:
    @Implementation
    Add ARIA-like accessibility labels to formatted output for assistive technologies.
    Wraps different content types with semantic labels for better navigation.
    @End Implementation
    
    Let result be ""
    Let text_length be StringPrimitive.length(formatted_text)
    Let current_index be 0
    
    Note: Process text and add semantic labels around different content types
    While current_index is less than text_length:
        Note: Check for ANSI color codes and label them
        If current_index is less than (text_length - 3) and StringPrimitive.char_at(formatted_text, current_index) equals 27:
            Note: Found ANSI escape sequence
            Let escape_end be find_ansi_sequence_end(formatted_text, current_index)
            Let ansi_code be extract_substring(formatted_text, current_index, escape_end)
            
            Note: Add accessibility label for color information
            StringPrimitive.append(result, "[Color: ")
            StringPrimitive.append(result, describe_ansi_color_code(ansi_code))
            StringPrimitive.append(result, "] ")
            
            Set current_index to escape_end
        Otherwise StringPrimitive.contains_starting_at(formatted_text, current_index, "ERROR:"):
            Note: Label error severity
            StringPrimitive.append(result, "[Severity: Error] ")
            StringPrimitive.append(result, extract_word_at_index(formatted_text, current_index))
            Set current_index to (current_index + 6)  Note: Skip "ERROR:"
        Otherwise StringPrimitive.contains_starting_at(formatted_text, current_index, "WARNING:"):
            Note: Label warning severity  
            StringPrimitive.append(result, "[Severity: Warning] ")
            StringPrimitive.append(result, extract_word_at_index(formatted_text, current_index))
            Set current_index to (current_index + 8)  Note: Skip "WARNING:"
        Otherwise StringPrimitive.contains_starting_at(formatted_text, current_index, "-->"):
            Note: Label file location
            StringPrimitive.append(result, "[File Location] ")
            StringPrimitive.append(result, extract_word_at_index(formatted_text, current_index))
            Set current_index to (current_index + 3)  Note: Skip "-->"
        Otherwise is_line_number_indicator(formatted_text, current_index):
            Note: Label line number
            StringPrimitive.append(result, "[Line Number] ")
            Let line_end be find_pipe_character(formatted_text, current_index)
            StringPrimitive.append(result, extract_substring(formatted_text, current_index, line_end))
            Set current_index to line_end
        Otherwise StringPrimitive.char_at(formatted_text, current_index) equals 94:  Note: '^' caret
            Note: Label error position indicator
            StringPrimitive.append(result, "[Error Position] ")
            StringPrimitive.append_char(result, 94)
            Set current_index to (current_index + 1)
        Otherwise StringPrimitive.char_at(formatted_text, current_index) equals 124:  Note: '|' pipe
            Note: Check if this starts source code content
            Let next_char_index be current_index + 1
            If next_char_index is less than text_length and StringPrimitive.char_at(formatted_text, next_char_index) equals 32:
                StringPrimitive.append(result, "[Source Code] ")
            End If
            StringPrimitive.append_char(result, 124)
            Set current_index to (current_index + 1)
        Otherwise is_file_extension_at_index(formatted_text, current_index):
            Note: Label file types
            StringPrimitive.append(result, "[File] ")
            StringPrimitive.append_char(result, StringPrimitive.char_at(formatted_text, current_index))
            Set current_index to (current_index + 1)
        Otherwise:
            Note: Regular character - copy as-is
            StringPrimitive.append_char(result, StringPrimitive.char_at(formatted_text, current_index))
            Set current_index to (current_index + 1)
        End If
    End While
    
    Return result

Process called "format_high_contrast" that takes formatter as ErrorFormatter, diagnostic as String returns String:
    @Implementation
    Format with high contrast colors for visibility.
    Applies high contrast color schemes with bold backgrounds for better accessibility.
    @End Implementation
    
    Let result be ""
    
    Note: Use high contrast theme colors
    If formatter.formatting_options.use_colors:
        Set result to "\033[97;41m" + "ERROR: " + "\033[0m" + diagnostic
    Otherwise:
        Set result to "ERROR: " + diagnostic
    End If
    
    Return result

Note: =====================================================================
Note: TEMPLATE AND LOCALIZATION
Note: =====================================================================

Process called "load_message_templates" that takes formatter as ErrorFormatter, template_file as String returns Boolean:
    @Implementation
    Load error message templates from file.
    Reads template definitions from external file for customizable error messages.
    @End Implementation
    
    Let file_content be read_file_content(template_file)
    If StringPrimitive.length(file_content) equals 0:
        Return false  Note: Failed to read template file
    End If
    
    Note: Parse template file content (JSON format expected)
    If not StringPrimitive.starts_with(file_content, "{"):
        Return false  Note: Invalid template file format
    End If
    
    Note: Extract templates and store in formatter
    If StringPrimitive.contains(file_content, "\"error_template\""):
        Let error_template be extract_json_string_value(file_content, "error_template")
        If StringPrimitive.length(error_template) is greater than 0:
            Set formatter.message_templates["error"] to error_template
        End If
    End If
    
    If StringPrimitive.contains(file_content, "\"warning_template\""):
        Let warning_template be extract_json_string_value(file_content, "warning_template")
        If StringPrimitive.length(warning_template) is greater than 0:
            Set formatter.message_templates["warning"] to warning_template
        End If
    End If
    
    If StringPrimitive.contains(file_content, "\"info_template\""):
        Let info_template be extract_json_string_value(file_content, "info_template")
        If StringPrimitive.length(info_template) is greater than 0:
            Set formatter.message_templates["info"] to info_template
        End If
    End If
    
    Return true

Process called "format_with_template" that takes formatter as ErrorFormatter, template_name as String, parameters as Dictionary[String, String] returns String:
    @Implementation
    Format error using message template with parameters.
    Substitutes parameters into template patterns for consistent error messages.
    @End Implementation
    
    Let result be ""
    
    Note: Complete template implementation with comprehensive pattern support
    If template_name equals "syntax_error":
        Let token be parameters["token"]
        Let expected be parameters["expected"]
        Set result to "Unexpected token '" + token + "', expected '" + expected + "'"
    Otherwise template_name equals "type_error":
        Let found_type be parameters["found_type"]
        Let expected_type be parameters["expected_type"]
        Set result to "Type mismatch: found '" + found_type + "', expected '" + expected_type + "'"
    Otherwise:
        Set result to "Error: " + template_name
    End If
    
    Return result

Process called "localize_error_message" that takes formatter as ErrorFormatter, error_message as String, locale as String returns String:
    @Implementation
    Localize error message to specified locale.
    Translates error messages to different languages based on locale.
    @End Implementation
    
    Note: Comprehensive localization with complete translation dictionaries
    Match locale:
        When "es":
            Note: Spanish translations
            Let translated be error_message
            Set translated to StringPrimitive.replace_all(translated, "Error", "Error")
            Set translated to StringPrimitive.replace_all(translated, "Warning", "Advertencia")
            Set translated to StringPrimitive.replace_all(translated, "Info", "InformaciÃ³n")
            Set translated to StringPrimitive.replace_all(translated, "Line", "LÃ­nea")
            Set translated to StringPrimitive.replace_all(translated, "Column", "Columna")
            Set translated to StringPrimitive.replace_all(translated, "File", "Archivo")
            Set translated to StringPrimitive.replace_all(translated, "Expected", "Se esperaba")
            Set translated to StringPrimitive.replace_all(translated, "Found", "Se encontrÃ³")
            Return translated
        When "fr":
            Note: French translations
            Let translated be error_message
            Set translated to StringPrimitive.replace_all(translated, "Error", "Erreur")
            Set translated to StringPrimitive.replace_all(translated, "Warning", "Avertissement")
            Set translated to StringPrimitive.replace_all(translated, "Info", "Information")
            Set translated to StringPrimitive.replace_all(translated, "Line", "Ligne")
            Set translated to StringPrimitive.replace_all(translated, "Column", "Colonne")
            Set translated to StringPrimitive.replace_all(translated, "File", "Fichier")
            Set translated to StringPrimitive.replace_all(translated, "Expected", "Attendu")
            Set translated to StringPrimitive.replace_all(translated, "Found", "TrouvÃ©")
            Return translated
        When "de":
            Note: German translations
            Let translated be error_message
            Set translated to StringPrimitive.replace_all(translated, "Error", "Fehler")
            Set translated to StringPrimitive.replace_all(translated, "Warning", "Warnung")
            Set translated to StringPrimitive.replace_all(translated, "Info", "Information")
            Set translated to StringPrimitive.replace_all(translated, "Line", "Zeile")
            Set translated to StringPrimitive.replace_all(translated, "Column", "Spalte")
            Set translated to StringPrimitive.replace_all(translated, "File", "Datei")
            Set translated to StringPrimitive.replace_all(translated, "Expected", "Erwartet")
            Set translated to StringPrimitive.replace_all(translated, "Found", "Gefunden")
            Return translated
        Otherwise:
            Note: Default English or unsupported locale
            Return error_message
    End Match
    
    Note: Default to English
    Return error_message

Note: =====================================================================
Note: FORMATTING VALIDATION
Note: =====================================================================

Process called "validate_formatted_output" that takes formatter as ErrorFormatter, formatted_text as String, format_type as String returns List[String]:
    @Implementation
    Validate that formatted output meets format requirements and return list of validation errors.
    Checks for proper structure, required elements, and format compliance.
    @End Implementation
    
    Let validation_errors be List[String]
    Let text_length be StringPrimitive.length(formatted_text)
    
    Note: Check comprehensive format requirements
    If text_length equals 0:
        List.add(validation_errors, "Formatted output is empty")
        Return validation_errors
    End If
    
    Match format_type:
        When "cli":
            Note: Validate CLI format requirements
            If not StringPrimitive.contains(formatted_text, "ERROR:") and not StringPrimitive.contains(formatted_text, "WARNING:") and not StringPrimitive.contains(formatted_text, "INFO:"):
                List.add(validation_errors, "CLI format missing severity indicator")
            End If
            
            Note: Check for proper line structure
            Let lines be split_string_by_newlines(formatted_text)
            Let has_location_info be false
            Let has_source_context be false
            
            For Each line in lines:
                If StringPrimitive.contains(line, "-->"):
                    Set has_location_info to true
                End If
                If StringPrimitive.contains(line, "|"):
                    Set has_source_context to true
                End If
            End For
            
            If not has_location_info:
                List.add(validation_errors, "CLI format missing file location information")
            End If
            
        When "json":
            Note: Validate JSON format requirements
            If not StringPrimitive.starts_with(formatted_text, "{"):
                List.add(validation_errors, "JSON format must start with opening brace")
            End If
            If not StringPrimitive.ends_with(formatted_text, "}"):
                List.add(validation_errors, "JSON format must end with closing brace")
            End If
            
            Note: Check for required JSON fields
            If not StringPrimitive.contains(formatted_text, "\"severity\""):
                List.add(validation_errors, "JSON format missing severity field")
            End If
            If not StringPrimitive.contains(formatted_text, "\"message\""):
                List.add(validation_errors, "JSON format missing message field")
            End If
            If not StringPrimitive.contains(formatted_text, "\"location\""):
                List.add(validation_errors, "JSON format missing location field")
            End If
            
        When "html":
            Note: Validate HTML format requirements
            If not StringPrimitive.contains(formatted_text, "<div"):
                List.add(validation_errors, "HTML format missing container div")
            End If
            If not StringPrimitive.contains(formatted_text, "class="):
                List.add(validation_errors, "HTML format missing CSS classes")
            End If
            
            Note: Check for proper HTML structure
            Let open_divs be count_substring_occurrences(formatted_text, "<div")
            Let close_divs be count_substring_occurrences(formatted_text, "</div>")
            If open_divs not equals close_divs:
                List.add(validation_errors, "HTML format has mismatched div tags")
            End If
            
        When "plain":
            Note: Validate plain text format
            If StringPrimitive.contains(formatted_text, "\033["):
                List.add(validation_errors, "Plain format should not contain ANSI color codes")
            End If
            If StringPrimitive.contains(formatted_text, "<") or StringPrimitive.contains(formatted_text, ">"):
                List.add(validation_errors, "Plain format should not contain HTML tags")
            End If
            
        Otherwise:
            List.add(validation_errors, "Unknown format type: " + format_type)
    End Match
    
    Note: Check for common formatting issues
    If StringPrimitive.contains(formatted_text, "\033[0m") and not StringPrimitive.contains(formatted_text, "\033["):
        List.add(validation_errors, "Found reset codes without color codes")
    End If
    
    Note: Check for proper encoding
    Let has_invalid_chars be check_for_invalid_utf8_sequences(formatted_text)
    If has_invalid_chars:
        List.add(validation_errors, "Contains invalid UTF-8 character sequences")
    End If
    
    Return validation_errors

Process called "check_formatting_consistency" that takes formatter as ErrorFormatter, formatted_messages as List[String] returns List[String]:
    @Implementation
    Check consistency across formatted messages and return list of inconsistency issues.
    Verifies uniform formatting patterns, color usage, and structural consistency.
    @End Implementation
    
    Let consistency_issues be List[String]
    Let message_count be List.length(formatted_messages)
    
    If message_count is less than 2:
        Return consistency_issues  Note: Need multiple messages to check consistency
    End If
    
    Note: Analyze first message to establish baseline patterns
    Let first_message be formatted_messages[0]
    Let baseline_has_colors be StringPrimitive.contains(first_message, "\033[")
    Let baseline_has_html be StringPrimitive.contains(first_message, "<")
    Let baseline_has_location be StringPrimitive.contains(first_message, "-->")
    Let baseline_severity_format be extract_severity_format(first_message)
    
    Note: Check each subsequent message for consistency
    For i from 1 to (message_count - 1):
        Let current_message be formatted_messages[i]
        
        Note: Check color usage consistency
        Let current_has_colors be StringPrimitive.contains(current_message, "\033[")
        If baseline_has_colors and not current_has_colors:
            List.add(consistency_issues, "Message " + integer_to_string(i) + " lacks colors while others have colors")
        Otherwise not baseline_has_colors and current_has_colors:
            List.add(consistency_issues, "Message " + integer_to_string(i) + " has colors while others lack colors")
        End If
        
        Note: Check HTML formatting consistency
        Let current_has_html be StringPrimitive.contains(current_message, "<")
        If baseline_has_html and not current_has_html:
            List.add(consistency_issues, "Message " + integer_to_string(i) + " lacks HTML while others use HTML")
        Otherwise not baseline_has_html and current_has_html:
            List.add(consistency_issues, "Message " + integer_to_string(i) + " uses HTML while others are plain text")
        End If
        
        Note: Check location format consistency
        Let current_has_location be StringPrimitive.contains(current_message, "-->")
        If baseline_has_location and not current_has_location:
            List.add(consistency_issues, "Message " + integer_to_string(i) + " missing location information")
        End If
        
        Note: Check severity format consistency
        Let current_severity_format be extract_severity_format(current_message)
        If StringPrimitive.length(baseline_severity_format) is greater than 0 and StringPrimitive.length(current_severity_format) is greater than 0:
            If baseline_severity_format not equals current_severity_format:
                List.add(consistency_issues, "Message " + integer_to_string(i) + " has inconsistent severity format")
            End If
        End If
        
        Note: Check indentation consistency
        Let baseline_indentation be measure_average_indentation(first_message)
        Let current_indentation be measure_average_indentation(current_message)
        Let indentation_diff be absolute_difference(baseline_indentation, current_indentation)
        If indentation_diff is greater than 2:  Note: Allow small variations
            List.add(consistency_issues, "Message " + integer_to_string(i) + " has inconsistent indentation")
        End If
        
        Note: Check line length consistency
        Let baseline_max_line_length be find_maximum_line_length(first_message)
        Let current_max_line_length be find_maximum_line_length(current_message)
        Let length_diff be absolute_difference(baseline_max_line_length, current_max_line_length)
        If length_diff is greater than 50:  Note: Significant difference threshold
            List.add(consistency_issues, "Message " + integer_to_string(i) + " has significantly different line lengths")
        End If
    End For
    
    Return consistency_issues

Process called "measure_formatting_quality" that takes formatter as ErrorFormatter, formatted_message as String returns Float:
    @Implementation
    Measure quality of formatted error message on a scale from 0.0 to 1.0.
    Evaluates readability, completeness, accessibility, and adherence to formatting standards.
    @End Implementation
    
    Let quality_score be 0.0
    Let total_criteria be 10.0  Note: Number of quality criteria
    Let message_length be StringPrimitive.length(formatted_message)
    
    If message_length equals 0:
        Return 0.0  Note: Empty message has no quality
    End If
    
    Note: Criterion 1: Message completeness (has severity, location, description)
    If StringPrimitive.contains(formatted_message, "ERROR:") or StringPrimitive.contains(formatted_message, "WARNING:") or StringPrimitive.contains(formatted_message, "INFO:"):
        Set quality_score to (quality_score + 1.0)
    End If
    
    Note: Criterion 2: Location information present
    If StringPrimitive.contains(formatted_message, "-->") or StringPrimitive.contains(formatted_message, ":"):
        Set quality_score to (quality_score + 1.0)
    End If
    
    Note: Criterion 3: Source context provided
    If StringPrimitive.contains(formatted_message, "|") and StringPrimitive.contains(formatted_message, "^"):
        Set quality_score to (quality_score + 1.0)
    End If
    
    Note: Criterion 4: Appropriate message length (not too short, not too long)
    If message_length is greater than or equal to 50 and message_length is less than or equal to 2000:
        Set quality_score to (quality_score + 1.0)
    End If
    
    Note: Criterion 5: Proper color usage (if enabled)
    If formatter.formatting_options.use_colors:
        If StringPrimitive.contains(formatted_message, "\033[") and StringPrimitive.contains(formatted_message, "\033[0m"):
            Set quality_score to (quality_score + 1.0)
        End If
    Otherwise:
        Note: Colors disabled - score for not having colors
        If not StringPrimitive.contains(formatted_message, "\033["):
            Set quality_score to (quality_score + 1.0)
        End If
    End If
    
    Note: Criterion 6: Readability (proper spacing and line breaks)
    Let line_count be count_newlines(formatted_message)
    If line_count is greater than or equal to 2 and line_count is less than or equal to 20:
        Set quality_score to (quality_score + 1.0)
    End If
    
    Note: Criterion 7: No formatting artifacts (malformed ANSI codes, broken HTML)
    Let has_formatting_artifacts be check_for_formatting_artifacts(formatted_message)
    If not has_formatting_artifacts:
        Set quality_score to (quality_score + 1.0)
    End If
    
    Note: Criterion 8: Consistent indentation
    Let indentation_consistency be measure_indentation_consistency(formatted_message)
    If indentation_consistency is greater than 0.8:  Note: 80% consistency threshold
        Set quality_score to (quality_score + 1.0)
    End If
    
    Note: Criterion 9: Clear error highlighting
    If StringPrimitive.contains(formatted_message, "^") or StringPrimitive.contains(formatted_message, "~~~"):
        Set quality_score to (quality_score + 1.0)
    End If
    
    Note: Criterion 10: Accessibility considerations
    Let accessibility_score be assess_accessibility_quality(formatted_message)
    If accessibility_score is greater than 0.7:  Note: 70% accessibility threshold
        Set quality_score to (quality_score + 1.0)
    End If
    
    Note: Calculate final quality as percentage
    Let final_quality be quality_score / total_criteria
    Return final_quality

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "get_formatter_statistics" that takes formatter as ErrorFormatter returns Dictionary[String, Integer]:
    @Implementation
    Get comprehensive formatter usage statistics including format counts, error types, and performance metrics.
    Returns dictionary with statistical data about formatter usage patterns.
    @End Implementation
    
    Let statistics be Dictionary[String, Integer]
    
    Note: Comprehensive usage statistics from all formatter fields
    Dictionary.set(statistics, "messages_formatted", formatter.statistics.messages_formatted)
    Dictionary.set(statistics, "errors_formatted", formatter.statistics.errors_formatted)
    Dictionary.set(statistics, "warnings_formatted", formatter.statistics.warnings_formatted)
    Dictionary.set(statistics, "info_formatted", formatter.statistics.info_formatted)
    Dictionary.set(statistics, "color_usage_count", formatter.statistics.color_usage_count)
    Dictionary.set(statistics, "html_format_count", formatter.statistics.html_format_count)
    Dictionary.set(statistics, "json_format_count", formatter.statistics.json_format_count)
    Dictionary.set(statistics, "plain_format_count", formatter.statistics.plain_format_count)
    
    Note: Calculate derived statistics
    Let total_messages be formatter.statistics.errors_formatted + formatter.statistics.warnings_formatted + formatter.statistics.info_formatted
    Dictionary.set(statistics, "total_severity_messages", total_messages)
    
    Note: Performance and configuration statistics
    Dictionary.set(statistics, "max_line_width_used", formatter.formatting_options.max_line_width)
    Dictionary.set(statistics, "tab_size_setting", formatter.formatting_options.tab_size)
    
    Note: Add boolean settings as integers (0 or 1)
    If formatter.formatting_options.use_colors:
        Dictionary.set(statistics, "colors_enabled", 1)
    Otherwise:
        Dictionary.set(statistics, "colors_enabled", 0)
    End If
    
    If formatter.formatting_options.show_source_lines:
        Dictionary.set(statistics, "source_lines_enabled", 1)
    Otherwise:
        Dictionary.set(statistics, "source_lines_enabled", 0)
    End If
    
    If formatter.formatting_options.show_line_numbers:
        Dictionary.set(statistics, "line_numbers_enabled", 1)
    Otherwise:
        Dictionary.set(statistics, "line_numbers_enabled", 0)
    End If
    
    Note: Theme usage statistics
    Match formatter.formatting_options.color_theme:
        When "default":
            Dictionary.set(statistics, "theme_default_usage", 1)
            Dictionary.set(statistics, "theme_dark_usage", 0)
            Dictionary.set(statistics, "theme_light_usage", 0)
        When "dark":
            Dictionary.set(statistics, "theme_default_usage", 0)
            Dictionary.set(statistics, "theme_dark_usage", 1)
            Dictionary.set(statistics, "theme_light_usage", 0)
        When "light":
            Dictionary.set(statistics, "theme_default_usage", 0)
            Dictionary.set(statistics, "theme_dark_usage", 0)
            Dictionary.set(statistics, "theme_light_usage", 1)
        Otherwise:
            Dictionary.set(statistics, "theme_default_usage", 0)
            Dictionary.set(statistics, "theme_dark_usage", 0)
            Dictionary.set(statistics, "theme_light_usage", 0)
    End Match
    
    Return statistics

Process called "export_formatting_configuration" that takes formatter as ErrorFormatter returns String:
    @Implementation
    Export current formatting configuration to JSON string format for backup and sharing.
    Includes all formatting options, theme settings, and customizations.
    @End Implementation
    
    Let config_json be ""
    StringPrimitive.append(config_json, "{\n")
    
    Note: Export formatting options
    StringPrimitive.append(config_json, "  \"formatting_options\": {\n")
    StringPrimitive.append(config_json, "    \"use_colors\": ")
    If formatter.formatting_options.use_colors:
        StringPrimitive.append(config_json, "true")
    Otherwise:
        StringPrimitive.append(config_json, "false")
    End If
    StringPrimitive.append(config_json, ",\n")
    
    StringPrimitive.append(config_json, "    \"show_source_lines\": ")
    If formatter.formatting_options.show_source_lines:
        StringPrimitive.append(config_json, "true")
    Otherwise:
        StringPrimitive.append(config_json, "false")
    End If
    StringPrimitive.append(config_json, ",\n")
    
    StringPrimitive.append(config_json, "    \"show_line_numbers\": ")
    If formatter.formatting_options.show_line_numbers:
        StringPrimitive.append(config_json, "true")
    Otherwise:
        StringPrimitive.append(config_json, "false")
    End If
    StringPrimitive.append(config_json, ",\n")
    
    StringPrimitive.append(config_json, "    \"max_line_width\": ")
    StringPrimitive.append(config_json, integer_to_string(formatter.formatting_options.max_line_width))
    StringPrimitive.append(config_json, ",\n")
    
    StringPrimitive.append(config_json, "    \"tab_size\": ")
    StringPrimitive.append(config_json, integer_to_string(formatter.formatting_options.tab_size))
    StringPrimitive.append(config_json, ",\n")
    
    StringPrimitive.append(config_json, "    \"color_theme\": \"")
    StringPrimitive.append(config_json, formatter.formatting_options.color_theme)
    StringPrimitive.append(config_json, "\"\n")
    StringPrimitive.append(config_json, "  },\n")
    
    Note: Export theme settings
    StringPrimitive.append(config_json, "  \"theme_settings\": {\n")
    StringPrimitive.append(config_json, "    \"error_color\": \"")
    StringPrimitive.append(config_json, formatter.theme_settings.error_color)
    StringPrimitive.append(config_json, "\",\n")
    
    StringPrimitive.append(config_json, "    \"warning_color\": \"")
    StringPrimitive.append(config_json, formatter.theme_settings.warning_color)
    StringPrimitive.append(config_json, "\",\n")
    
    StringPrimitive.append(config_json, "    \"info_color\": \"")
    StringPrimitive.append(config_json, formatter.theme_settings.info_color)
    StringPrimitive.append(config_json, "\",\n")
    
    StringPrimitive.append(config_json, "    \"highlight_color\": \"")
    StringPrimitive.append(config_json, formatter.theme_settings.highlight_color)
    StringPrimitive.append(config_json, "\"\n")
    StringPrimitive.append(config_json, "  },\n")
    
    Note: Export current statistics for reference
    StringPrimitive.append(config_json, "  \"export_metadata\": {\n")
    StringPrimitive.append(config_json, "    \"messages_formatted\": ")
    StringPrimitive.append(config_json, integer_to_string(formatter.statistics.messages_formatted))
    StringPrimitive.append(config_json, ",\n")
    
    StringPrimitive.append(config_json, "    \"export_version\": \"1.0\",\n")
    StringPrimitive.append(config_json, "    \"export_timestamp\": \"")
    StringPrimitive.append(config_json, get_current_iso_timestamp())
    StringPrimitive.append(config_json, "\"\n")
    StringPrimitive.append(config_json, "  }\n")
    
    StringPrimitive.append(config_json, "}")
    
    Return config_json

Process called "import_formatting_configuration" that takes formatter as ErrorFormatter, config_data as String returns Boolean:
    @Implementation
    Import formatting configuration from JSON string data.
    Validates format and applies settings to formatter, returning success status.
    @End Implementation
    
    Let config_length be StringPrimitive.length(config_data)
    If config_length equals 0:
        Return false  Note: Empty configuration data
    End If
    
    Note: Complete JSON structure validation
    If not StringPrimitive.starts_with(config_data, "{") or not StringPrimitive.ends_with(config_data, "}"):
        Return false  Note: Invalid JSON structure
    End If
    
    Note: Parse and apply formatting options
    If StringPrimitive.contains(config_data, "\"use_colors\": true"):
        Set formatter.formatting_options.use_colors to true
    Otherwise StringPrimitive.contains(config_data, "\"use_colors\": false"):
        Set formatter.formatting_options.use_colors to false
    End If
    
    If StringPrimitive.contains(config_data, "\"show_source_lines\": true"):
        Set formatter.formatting_options.show_source_lines to true
    Otherwise StringPrimitive.contains(config_data, "\"show_source_lines\": false"):
        Set formatter.formatting_options.show_source_lines to false
    End If
    
    If StringPrimitive.contains(config_data, "\"show_line_numbers\": true"):
        Set formatter.formatting_options.show_line_numbers to true
    Otherwise StringPrimitive.contains(config_data, "\"show_line_numbers\": false"):
        Set formatter.formatting_options.show_line_numbers to false
    End If
    
    Note: Parse numeric values
    If StringPrimitive.contains(config_data, "\"max_line_width\":"):
        Let width_value be extract_json_integer_value(config_data, "max_line_width")
        If width_value is greater than 20 and width_value is less than or equal to 500:
            Set formatter.formatting_options.max_line_width to width_value
        End If
    End If
    
    If StringPrimitive.contains(config_data, "\"tab_size\":"):
        Let tab_value be extract_json_integer_value(config_data, "tab_size")
        If tab_value is greater than or equal to 1 and tab_value is less than or equal to 16:
            Set formatter.formatting_options.tab_size to tab_value
        End If
    End If
    
    Note: Parse color theme
    If StringPrimitive.contains(config_data, "\"color_theme\": \"dark\""):
        Set formatter.formatting_options.color_theme to "dark"
    Otherwise StringPrimitive.contains(config_data, "\"color_theme\": \"light\""):
        Set formatter.formatting_options.color_theme to "light"
    Otherwise StringPrimitive.contains(config_data, "\"color_theme\": \"default\""):
        Set formatter.formatting_options.color_theme to "default"
    End If
    
    Note: Parse theme color settings
    If StringPrimitive.contains(config_data, "\"error_color\":"):
        Let error_color be extract_json_string_value(config_data, "error_color")
        If StringPrimitive.length(error_color) is greater than 0:
            Set formatter.theme_settings.error_color to error_color
        End If
    End If
    
    If StringPrimitive.contains(config_data, "\"warning_color\":"):
        Let warning_color be extract_json_string_value(config_data, "warning_color")
        If StringPrimitive.length(warning_color) is greater than 0:
            Set formatter.theme_settings.warning_color to warning_color
        End If
    End If
    
    If StringPrimitive.contains(config_data, "\"info_color\":"):
        Let info_color be extract_json_string_value(config_data, "info_color")
        If StringPrimitive.length(info_color) is greater than 0:
            Set formatter.theme_settings.info_color to info_color
        End If
    End If
    
    If StringPrimitive.contains(config_data, "\"highlight_color\":"):
        Let highlight_color be extract_json_string_value(config_data, "highlight_color")
        If StringPrimitive.length(highlight_color) is greater than 0:
            Set formatter.theme_settings.highlight_color to highlight_color
        End If
    End If
    
    Return true  Note: Configuration imported successfully

Process called "reset_error_formatter" that takes formatter as ErrorFormatter returns Boolean:
    @Implementation
    Reset formatter to default configuration, clearing all customizations and statistics.
    Returns true on successful reset to factory defaults.
    @End Implementation
    
    Note: Reset formatting options to defaults
    Set formatter.formatting_options.use_colors to true
    Set formatter.formatting_options.show_source_lines to true
    Set formatter.formatting_options.show_line_numbers to true
    Set formatter.formatting_options.max_line_width to 100
    Set formatter.formatting_options.tab_size to 4
    Set formatter.formatting_options.color_theme to "default"
    
    Note: Reset theme settings to default colors
    Set formatter.theme_settings.error_color to "\033[91m"    Note: Bright red
    Set formatter.theme_settings.warning_color to "\033[93m"  Note: Bright yellow
    Set formatter.theme_settings.info_color to "\033[94m"     Note: Bright blue
    Set formatter.theme_settings.highlight_color to "\033[96m" Note: Bright cyan
    
    Note: Reset all statistics to zero
    Set formatter.statistics.messages_formatted to 0
    Set formatter.statistics.errors_formatted to 0
    Set formatter.statistics.warnings_formatted to 0
    Set formatter.statistics.info_formatted to 0
    Set formatter.statistics.color_usage_count to 0
    Set formatter.statistics.html_format_count to 0
    Set formatter.statistics.json_format_count to 0
    Set formatter.statistics.plain_format_count to 0
    
    Note: Clear any cached or temporary data
    If Dictionary.contains_key(formatter, "cached_templates"):
        Set formatter.cached_templates to Dictionary[String, String]
    End If
    
    If Dictionary.contains_key(formatter, "custom_patterns"):
        Set formatter.custom_patterns to List[String]
    End If
    
    Return true  Note: Reset completed successfully