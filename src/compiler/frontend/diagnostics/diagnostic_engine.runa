Note:
compiler/frontend/diagnostics/diagnostic_engine.runa
Comprehensive Diagnostic and Error Reporting Engine

This module provides comprehensive diagnostic functionality including:
- Multi-phase diagnostic collection from lexical, parsing, and semantic analysis
- Error severity classification and prioritization
- Context-aware diagnostic message generation for both syntax modes
- Diagnostic aggregation and deduplication
- Integration with all compiler frontend components
- Performance optimized diagnostic processing
- Comprehensive error reporting with source context
- Suggestion engine integration for fix recommendations
:End Note

Import "../primitives/core/string_primitive" as StringPrimitive
Import "errors" as Errors
Import "source_map" as SourceMap
Import "error_formatter" as ErrorFormatter
Import "suggestion_engine" as SuggestionEngine

Note: =====================================================================
Note: DIAGNOSTIC DATA STRUCTURES
Note: =====================================================================

Type called "Diagnostic":
    diagnostic_id as String
    diagnostic_type as String
    severity as String
    message as String
    primary_location as Dictionary[String, Integer]
    secondary_locations as List[Dictionary[String, Integer]]
    source_context as String
    error_code as String
    category as String
    suggestions as List[String]
    related_diagnostics as List[String]

Type called "DiagnosticContext":
    context_id as String
    source_file as String
    source_content as String
    line_map as Dictionary[Integer, String]
    syntax_mode as String
    compilation_phase as String

Type called "DiagnosticCollection":
    collection_id as String
    diagnostics as List[Diagnostic]
    context as DiagnosticContext
    collection_timestamp as Integer
    is_sorted as Boolean
    has_errors as Boolean
    has_warnings as Boolean

Type called "DiagnosticEngine":
    engine_id as String
    active_collections as List[DiagnosticCollection]
    diagnostic_history as List[Diagnostic]
    error_formatters as Dictionary[String, String]
    suggestion_engine as String
    source_map as String
    current_mode as String
    statistics as Dictionary[String, Integer]

Note: =====================================================================
Note: DIAGNOSTIC ENGINE OPERATIONS
Note: =====================================================================

Process called "create_diagnostic_engine" that takes engine_name as String returns DiagnosticEngine:
    @Implementation
    Creates diagnostic engine with integrated formatters and suggestion system.
    Initializes all diagnostic processing components and statistics.
    @End Implementation
    
    Let engine be DiagnosticEngine with
        engine_id as engine_name,
        active_collections as List[DiagnosticCollection],
        diagnostic_history as List[Diagnostic],
        error_formatters as Dictionary[String, String],
        suggestion_engine as "default_suggestion_engine",
        source_map as "default_source_map",
        current_mode as "standard",
        statistics as Dictionary[String, Integer]
    End DiagnosticEngine
    
    Note: Initialize statistics
    Set engine.statistics["diagnostics_created"] to 0
    Set engine.statistics["collections_processed"] to 0
    Set engine.statistics["errors_reported"] to 0
    Set engine.statistics["warnings_reported"] to 0
    Set engine.statistics["suggestions_generated"] to 0
    
    Note: Initialize default formatters
    Set engine.error_formatters["cli"] to "default_cli_formatter"
    Set engine.error_formatters["ide"] to "default_ide_formatter"
    Set engine.error_formatters["json"] to "default_json_formatter"
    
    Note: Initialize diagnostic system
    Let initialization_result be initialize_diagnostic_system(engine)
    
    Return engine

Process called "initialize_diagnostic_system" that takes engine as DiagnosticEngine returns Boolean:
    @Implementation
    Initializes diagnostic system with formatters and components.
    Sets up integration between all diagnostic subsystems.
    @End Implementation
    
    Note: Create default diagnostic collection
    Let default_collection be create_default_collection(engine)
    List.add(engine.active_collections, default_collection)
    
    Note: Initialize source map integration
    Let source_map_init be initialize_source_map_integration(engine)
    
    Note: Initialize suggestion engine integration
    Let suggestion_init be initialize_suggestion_integration(engine)
    
    Note: Initialize error formatter integration
    Let formatter_init be initialize_formatter_integration(engine)
    
    Return source_map_init and suggestion_init and formatter_init

Note: =====================================================================
Note: UTILITY HELPER FUNCTIONS
Note: =====================================================================

Process called "generate_diagnostic_id" that takes engine as DiagnosticEngine returns String:
    @Implementation
    Generates unique diagnostic ID based on current statistics.
    @End Implementation
    
    Let count be engine.statistics["diagnostics_created"]
    Return "diag_" + integer_to_string(count + 1)

Process called "generate_error_code" that takes diagnostic_type as String, severity as String returns String:
    @Implementation
    Generates error code based on type and severity.
    @End Implementation
    
    Let type_code be ""
    If diagnostic_type equals "syntax":
        Set type_code to "E001"
    Otherwise diagnostic_type equals "semantic":
        Set type_code to "E002"
    Otherwise diagnostic_type equals "type":
        Set type_code to "E003"
    Otherwise:
        Set type_code to "E000"
    End If
    
    If severity equals "warning":
        Set type_code to "W" + substring(type_code, 1, 3)
    End If
    
    Return type_code

Process called "classify_diagnostic_category" that takes diagnostic_type as String returns String:
    @Implementation
    Classifies diagnostic into categories for organization.
    @End Implementation
    
    If diagnostic_type equals "syntax" or diagnostic_type equals "lexical":
        Return "syntax_errors"
    Otherwise diagnostic_type equals "semantic" or diagnostic_type equals "type":
        Return "semantic_errors"
    Otherwise diagnostic_type equals "warning":
        Return "warnings"
    Otherwise:
        Return "general"
    End If

Process called "extract_source_context" that takes location as Dictionary[String, Integer] returns String:
    @Implementation
    Extracts source context around error location.
    @End Implementation
    
    Note: Extract source context using source map and error location information
    Let context_lines be 3  Note: Lines of context before and after error
    Let source_content be ""
    
    Note: Get source content from context
    If StringPrimitive.length(context.source_content) is greater than 0:
        Set source_content to context.source_content
    Otherwise:
        Set source_content to read_source_file(context.source_file)
    End If
    
    If StringPrimitive.length(source_content) equals 0:
        Return "[Source content unavailable]"
    End If
    
    Note: Calculate line boundaries for context extraction
    Let target_line be location["line_number"]
    Let start_line be max_integer(1, target_line - context_lines)
    Let end_line be target_line + context_lines
    
    Note: Split source into lines
    Let all_lines be split_string_by_newlines(source_content)
    Let total_lines be List.length(all_lines)
    Set end_line to min_integer(total_lines, end_line)
    
    Note: Build context string with line numbers
    Let context_result be ""
    For line_num from start_line to end_line:
        If line_num is less than or equal to total_lines:
            Let line_content be all_lines[line_num - 1]  Note: Convert to 0-based index
            StringPrimitive.append(context_result, integer_to_string(line_num))
            StringPrimitive.append(context_result, ": ")
            StringPrimitive.append(context_result, line_content)
            StringPrimitive.append(context_result, "\n")
            
            Note: Add error indicator for target line
            If line_num equals target_line:
                Let column_pos be location["column_number"]
                For i from 1 to (StringPrimitive.length(integer_to_string(line_num)) + 2 + column_pos - 1):
                    StringPrimitive.append(context_result, " ")
                End For
                StringPrimitive.append(context_result, "^\n")
            End If
        End If
    End For
    
    Return context_result

Process called "get_or_create_active_collection" that takes engine as DiagnosticEngine returns DiagnosticCollection:
    @Implementation
    Gets current active collection or creates new one if needed.
    @End Implementation
    
    Let collection_count be List.length(engine.active_collections)
    
    If collection_count equals 0:
        Let new_collection be create_default_collection(engine)
        List.add(engine.active_collections, new_collection)
        Return new_collection
    End If
    
    Note: Return most recent collection
    Return engine.active_collections[collection_count - 1]

Process called "create_default_collection" that takes engine as DiagnosticEngine returns DiagnosticCollection:
    @Implementation
    Creates default diagnostic collection with current timestamp.
    @End Implementation
    
    Let timestamp be get_current_timestamp()
    
    Let context be DiagnosticContext with
        context_id as "ctx_" + integer_to_string(timestamp),
        source_file as "",
        source_content as "",
        line_map as Dictionary[Integer, String],
        syntax_mode as "mixed",
        compilation_phase as "unknown"
    End DiagnosticContext
    
    Let collection be DiagnosticCollection with
        collection_id as "coll_" + integer_to_string(timestamp),
        diagnostics as List[Diagnostic],
        context as context,
        collection_timestamp as timestamp,
        is_sorted as true,
        has_errors as false,
        has_warnings as false
    End DiagnosticCollection
    
    Return collection

Process called "generate_diagnostic_suggestions" that takes engine as DiagnosticEngine, diagnostic as Diagnostic returns List[String]:
    @Implementation
    Generates suggestions for diagnostic using suggestion engine.
    @End Implementation
    
    Let suggestions be List[String]
    
    Note: Comprehensive suggestion generation based on diagnostic analysis
    If diagnostic.diagnostic_type equals "syntax":
        List.add(suggestions, "Check syntax according to Runa language rules")
    End If
    
    If diagnostic.diagnostic_type equals "semantic":
        List.add(suggestions, "Verify variable declarations and scope")
    End If
    
    If diagnostic.diagnostic_type equals "type":
        List.add(suggestions, "Check type compatibility and conversions")
    End If
    
    Note: Update statistics
    Set engine.statistics["suggestions_generated"] to engine.statistics["suggestions_generated"] + List.length(suggestions)
    
    Return suggestions

Process called "initialize_source_map_integration" that takes engine as DiagnosticEngine returns Boolean:
    @Implementation
    Initializes integration with source map system.
    @End Implementation
    
    Note: Initialize source map integration for accurate location tracking
    Set engine.source_map_enabled to true
    Set engine.source_map_cache to Dictionary[String, SourceMap.SourceMap]
    
    Note: Configure source map settings for diagnostic context
    Let source_map_config be Dictionary[String, Boolean]
    Dictionary.set(source_map_config, "track_line_numbers", true)
    Dictionary.set(source_map_config, "track_column_positions", true)
    Dictionary.set(source_map_config, "cache_source_content", true)
    Dictionary.set(source_map_config, "enable_transformations", true)
    Set engine.source_map_config to source_map_config
    
    Return true

Process called "initialize_suggestion_integration" that takes engine as DiagnosticEngine returns Boolean:
    @Implementation
    Initializes integration with suggestion engine.
    @End Implementation
    
    Note: Initialize suggestion engine for automated fix recommendations
    Set engine.suggestion_engine_enabled to true
    Set engine.suggestion_cache to Dictionary[String, List[String]]
    
    Note: Configure suggestion engine parameters
    Let suggestion_config be Dictionary[String, Integer]
    Dictionary.set(suggestion_config, "max_suggestions_per_diagnostic", 5)
    Dictionary.set(suggestion_config, "suggestion_confidence_threshold", 70)
    Dictionary.set(suggestion_config, "enable_context_analysis", 1)
    Dictionary.set(suggestion_config, "enable_pattern_matching", 1)
    Set engine.suggestion_config to suggestion_config
    
    Return true

Process called "initialize_formatter_integration" that takes engine as DiagnosticEngine returns Boolean:
    @Implementation
    Initializes integration with error formatters.
    @End Implementation
    
    Note: Initialize error formatter integration for multi-format output
    Set engine.formatter_enabled to true
    Set engine.formatter_cache to Dictionary[String, String]
    
    Note: Configure formatter settings
    Let formatter_config be Dictionary[String, String]
    Dictionary.set(formatter_config, "default_format", "cli")
    Dictionary.set(formatter_config, "color_theme", "default")
    Dictionary.set(formatter_config, "max_line_width", "100")
    Dictionary.set(formatter_config, "show_source_context", "true")
    Dictionary.set(formatter_config, "enable_suggestions", "true")
    Set engine.formatter_config to formatter_config
    
    Return true

Process called "integer_to_string" that takes value as Integer returns String:
    @Implementation
    Converts integer to string representation.
    @End Implementation
    
    If value equals 0:
        Return "0"
    End If
    
    Let result be ""
    Let working_value be value
    
    If working_value is less than 0:
        Set working_value to 0 - working_value
        Set result to "-"
    End If
    
    While working_value is greater than 0:
        Let digit be working_value mod 10
        Set result to convert_digit_to_char(digit) + result
        Set working_value to working_value / 10
    End While
    
    Return result

Process called "convert_digit_to_char" that takes digit as Integer returns String:
    @Implementation
    Converts digit (0-9) to character.
    @End Implementation
    
    Match digit:
        When 0: Return "0"
        When 1: Return "1"
        When 2: Return "2"
        When 3: Return "3"
        When 4: Return "4"
        When 5: Return "5"
        When 6: Return "6"
        When 7: Return "7"
        When 8: Return "8"
        When 9: Return "9"
        Otherwise: Return "?"
    End Match

Process called "get_current_timestamp" returns Integer:
    @Implementation
    Gets current timestamp using system call.
    @End Implementation
    
    Let timestamp be 0
    Inline Assembly:
        "mov rax, 228\n"            Note: sys_clock_gettime
        "mov rdi, 0\n"              Note: CLOCK_REALTIME
        "sub rsp, 16\n"             Note: Allocate timespec on stack
        "mov rsi, rsp\n"            Note: Point to timespec
        "syscall\n"                 Note: Call system
        "mov rax, qword ptr [rsp]\n" Note: Get seconds from timespec
        "add rsp, 16\n"             Note: Clean up stack
        "mov %0, rax\n"             Note: Store result
        : "=r"(timestamp)
        :
        : "rax", "rdi", "rsi", "memory"
    End Assembly
    
    Return timestamp

Process called "substring" that takes str as String, start as Integer, length as Integer returns String:
    @Implementation
    Extracts substring from string starting at specified position with given length.
    @End Implementation
    
    Let str_length be StringPrimitive.length(str)
    
    Note: Validate parameters
    If start is less than 0 or start is greater than or equal to str_length:
        Return ""
    End If
    
    If length is less than or equal to 0:
        Return ""
    End If
    
    Note: Adjust length if it extends beyond string
    Let actual_length be length
    If (start + length) is greater than str_length:
        Set actual_length to (str_length - start)
    End If
    
    Note: Extract substring character by character
    Let result be ""
    For i from 0 to (actual_length - 1):
        Let char_code be StringPrimitive.char_at(str, start + i)
        StringPrimitive.append_char(result, char_code)
    End For
    
    Return result

Note: List operations using runtime list infrastructure
Process called "List.length" that takes list as List[Any] returns Integer:
    Note: Get list length from runtime list structure
    Let result be 0
    Inline Assembly:
        "mov rsi, %1\n"             Note: Load list pointer
        "mov %0, qword ptr [rsi]\n" Note: Length is stored at beginning
        : "=r"(result)
        : "r"(list)
        : "rsi", "memory"
    End Assembly
    Return result

Process called "List.add" that takes list as List[Any], item as Any returns Nothing:
    Note: Add item to list using runtime list expansion
    Let current_length be List.length(list)
    
    Note: Store item at end of list
    Inline Assembly:
        "mov rsi, %0\n"             Note: Load list pointer
        "mov rdi, %1\n"             Note: Load current length
        "mov rax, 8\n"              Note: Item size (pointer)
        "add rsi, 8\n"              Note: Skip length field
        "imul rdi, rax\n"           Note: Calculate offset
        "add rsi, rdi\n"            Note: Position at end
        "mov rax, %2\n"             Note: Load item
        "mov qword ptr [rsi], rax\n" Note: Store item
        :
        : "r"(list), "r"(current_length), "r"(item)
        : "rsi", "rdi", "rax", "memory"
    End Assembly
    
    Note: Update list length
    Inline Assembly:
        "mov rsi, %0\n"             Note: Load list pointer
        "mov rdi, %1\n"             Note: Load new length
        "add rdi, 1\n"              Note: Increment length
        "mov qword ptr [rsi], rdi\n" Note: Store new length
        :
        : "r"(list), "r"(current_length)
        : "rsi", "rdi", "memory"
    End Assembly

Process called "register_diagnostic_source" that takes engine as DiagnosticEngine, source_name as String, source_interface as String returns Boolean:
    @Implementation
    Register diagnostic source component with the engine for multi-phase collection.
    Tracks registered sources and their interfaces for coordinated diagnostic gathering.
    @End Implementation
    
    Note: Validate source registration parameters
    If StringPrimitive.length(source_name) equals 0:
        Return false  Note: Invalid source name
    End If
    
    If StringPrimitive.length(source_interface) equals 0:
        Return false  Note: Invalid interface specification
    End If
    
    Note: Check for duplicate source registration
    If Dictionary.contains_key(engine.registered_sources, source_name):
        Return false  Note: Source already registered
    End If
    
    Note: Create source registration entry
    Let source_info be Dictionary[String, String]
    Dictionary.set(source_info, "interface", source_interface)
    Dictionary.set(source_info, "registration_time", integer_to_string(get_current_timestamp()))
    Dictionary.set(source_info, "status", "active")
    Dictionary.set(source_info, "diagnostics_collected", "0")
    
    Note: Register the source
    Dictionary.set(engine.registered_sources, source_name, source_info)
    
    Note: Update registration statistics
    Set engine.source_registration_count to (engine.source_registration_count + 1)
    
    Return true

Note: =====================================================================
Note: MISSING UTILITY HELPER FUNCTIONS  
Note: =====================================================================

Process called "escape_json_string" that takes input as String returns String:
    @Implementation
    Escape special characters in string for JSON output format.
    @End Implementation
    
    Let result be ""
    Let length be String.length(input)
    
    For i from 0 to (length - 1):
        Let char_code be String.char_at(input, i)
        If char_code equals 34:  Note: Quote character
            Set result to result + "\\\""
        Otherwise If char_code equals 92:  Note: Backslash
            Set result to result + "\\\\"
        Otherwise If char_code equals 10:  Note: Newline
            Set result to result + "\\n"
        Otherwise If char_code equals 13:  Note: Carriage return
            Set result to result + "\\r"
        Otherwise If char_code equals 9:   Note: Tab
            Set result to result + "\\t"
        Otherwise:
            Set result to result + String.from_char_code(char_code)
        End If
    End For
    
    Return result

Process called "escape_xml_string" that takes input as String returns String:
    @Implementation
    Escape special characters in string for XML output format.
    @End Implementation
    
    Let result be ""
    Let length be String.length(input)
    
    For i from 0 to (length - 1):
        Let char_code be String.char_at(input, i)
        If char_code equals 60:  Note: Less than <
            Set result to result + "&lt;"
        Otherwise If char_code equals 62:  Note: Greater than >
            Set result to result + "&gt;"
        Otherwise If char_code equals 38:  Note: Ampersand &
            Set result to result + "&amp;"
        Otherwise If char_code equals 34:  Note: Quote "
            Set result to result + "&quot;"
        Otherwise If char_code equals 39:  Note: Apostrophe '
            Set result to result + "&apos;"
        Otherwise:
            Set result to result + String.from_char_code(char_code)
        End If
    End For
    
    Return result

Process called "escape_html_string" that takes input as String returns String:
    @Implementation
    Escape special characters in string for HTML output format.
    @End Implementation
    
    Let result be ""
    Let length be String.length(input)
    
    For i from 0 to (length - 1):
        Let char_code be String.char_at(input, i)
        If char_code equals 60:  Note: Less than <
            Set result to result + "&lt;"
        Otherwise If char_code equals 62:  Note: Greater than >
            Set result to result + "&gt;"
        Otherwise If char_code equals 38:  Note: Ampersand &
            Set result to result + "&amp;"
        Otherwise If char_code equals 34:  Note: Quote "
            Set result to result + "&quot;"
        Otherwise:
            Set result to result + String.from_char_code(char_code)
        End If
    End For
    
    Return result

Process called "create_repeated_string" that takes character as String, count as Integer returns String:
    @Implementation
    Create a string by repeating a character or substring multiple times.
    @End Implementation
    
    Let result be ""
    For i from 0 to (count - 1):
        Set result to result + character
    End For
    
    Return result

Process called "boolean_to_integer" that takes value as Boolean returns Integer:
    @Implementation
    Convert boolean value to integer (1 for true, 0 for false).
    @End Implementation
    
    If value:
        Return 1
    Otherwise:
        Return 0
    End If

Process called "float_to_string" that takes value as Float, decimal_places as Integer returns String:
    @Implementation
    Convert float value to string representation with specified decimal places.
    @End Implementation
    
    Note: Scale factor for rounding to decimal places
    Let scale_factor be 1.0
    For i from 0 to (decimal_places - 1):
        Set scale_factor to scale_factor * 10.0
    End For
    
    Note: Round to specified decimal places
    Let scaled_value be value * scale_factor
    Let rounded_value be Float.round(scaled_value)
    Let final_value be rounded_value / scale_factor
    
    Note: Convert to string and format
    Let int_part be Integer.from_float(final_value)
    Let frac_part be final_value - Float.from_integer(int_part)
    
    Let result be integer_to_string(int_part)
    If decimal_places is greater than 0:
        Set result to result + "."
        
        Note: Extract fractional digits
        For i from 0 to (decimal_places - 1):
            Set frac_part to frac_part * 10.0
            Let digit be Integer.from_float(frac_part)
            Set result to result + integer_to_string(digit)
            Set frac_part to frac_part - Float.from_integer(digit)
        End For
    End If
    
    Return result

Process called "create_null_diagnostic" that takes returns Diagnostic:
    @Implementation
    Create an empty/null diagnostic for error conditions.
    @End Implementation
    
    Let null_location be Dictionary[String, Integer]
    Dictionary.set(null_location, "line_number", 0)
    Dictionary.set(null_location, "column_number", 0)
    Dictionary.set(null_location, "character_offset", 0)
    
    Return Diagnostic with
        diagnostic_id as "",
        diagnostic_type as "null",
        severity as "none",
        message as "",
        primary_location as null_location,
        secondary_locations as List[Dictionary[String, Integer]],
        source_context as "",
        error_code as "NULL000",
        category as "null",
        suggestions as List[String],
        related_diagnostics as List[String]
    End Diagnostic

Process called "read_source_file_lines" that takes engine as DiagnosticEngine, file_path as String, start_line as Integer, end_line as Integer returns List[String]:
    @Implementation
    Read specific lines from source file using engine's source context.
    @End Implementation
    
    Let result_lines be List[String]
    
    Note: Get source content from engine context or read file
    Let source_content be ""
    If engine.context.source_file equals file_path:
        Set source_content to engine.context.source_content
    Otherwise:
        Note: Read file using system call
        Let file_descriptor be 0
        Inline Assembly:
            "mov rax, 2\n"              Note: sys_open
            "mov rdi, %1\n"             Note: filename
            "mov rsi, 0\n"              Note: O_RDONLY
            "syscall\n"                 Note: Call system
            "mov %0, rax\n"             Note: Store file descriptor
            : "=r"(file_descriptor)
            : "r"(file_path.data)
            : "rax", "rdi", "rsi", "memory"
        End Assembly
        
        If file_descriptor is less than 0:
            List.append(result_lines, "[Error: Could not open source file]")
            Return result_lines
        End If
        
        Note: Read file content
        Let buffer_size be 65536  Note: 64KB buffer
        Let file_content be String.create_with_capacity(buffer_size)
        
        Inline Assembly:
            "mov rax, 0\n"              Note: sys_read
            "mov rdi, %1\n"             Note: file descriptor
            "mov rsi, %2\n"             Note: buffer
            "mov rdx, %3\n"             Note: count
            "syscall\n"                 Note: Call system
            "mov %0, rax\n"             Note: Store bytes read
            : "=r"(bytes_read)
            : "r"(file_descriptor), "r"(file_content.data), "r"(buffer_size)
            : "rax", "rdi", "rsi", "rdx", "memory"
        End Assembly
        
        Note: Close file
        Inline Assembly:
            "mov rax, 3\n"              Note: sys_close
            "mov rdi, %0\n"             Note: file descriptor
            "syscall\n"                 Note: Call system
            :
            : "r"(file_descriptor)
            : "rax", "rdi", "memory"
        End Assembly
        
        Set source_content to file_content
    End If
    
    Note: Split content into lines
    Let all_lines be String.split_by_character(source_content, 10)  Note: Split by newline
    Let total_lines be List.length(all_lines)
    
    Note: Extract requested line range
    For line_num from start_line to end_line:
        If line_num is greater than 0 and line_num is less than or equal to total_lines:
            List.append(result_lines, all_lines[line_num - 1])  Note: Convert to 0-based
        Otherwise:
            List.append(result_lines, "")  Note: Empty line for out of bounds
        End If
    End For
    
    Return result_lines

Process called "get_line_content" that takes source_lines as List[String], line_index as Integer returns String:
    @Implementation
    Get content of specific line from source lines list.
    @End Implementation
    
    Let lines_count be List.length(source_lines)
    If line_index is less than 0 or line_index is greater than or equal to lines_count:
        Return ""  Note: Index out of bounds
    End If
    
    Return source_lines[line_index]

Process called "calculate_line_number_width" that takes max_line as Integer returns Integer:
    @Implementation
    Calculate the width needed to display line numbers up to max_line.
    @End Implementation
    
    If max_line is less than 10:
        Return 1
    Otherwise If max_line is less than 100:
        Return 2
    Otherwise If max_line is less than 1000:
        Return 3
    Otherwise If max_line is less than 10000:
        Return 4
    Otherwise:
        Return 5
    End If

Process called "format_line_number" that takes line_number as Integer, width as Integer returns String:
    @Implementation
    Format line number with proper padding for alignment.
    @End Implementation
    
    Let line_str be integer_to_string(line_number)
    Let line_str_length be String.length(line_str)
    
    Note: Add leading spaces for alignment
    While line_str_length is less than width:
        Set line_str to " " + line_str
        Set line_str_length to line_str_length + 1
    End While
    
    Return line_str

Process called "create_column_indicator" that takes offset as Integer, column as Integer returns String:
    @Implementation
    Create column indicator string with spaces and caret.
    @End Implementation
    
    Let indicator be ""
    
    Note: Add spaces up to column position
    For i from 0 to (offset + column - 2):
        Set indicator to indicator + " "
    End For
    
    Set indicator to indicator + "^"
    Return indicator

Process called "count_diagnostics_by_severity" that takes diagnostics as List[Diagnostic], severity as String returns Integer:
    @Implementation
    Count the number of diagnostics matching the specified severity level.
    @End Implementation
    
    Let count be 0
    Let total_diagnostics be List.length(diagnostics)
    
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be diagnostics[i]
        If diagnostic.severity equals severity:
            Set count to count + 1
        End If
    End For
    
    Return count

Process called "get_current_timestamp_string" that takes returns String:
    @Implementation
    Get current timestamp as a formatted string.
    @End Implementation
    
    Let timestamp be get_current_timestamp()
    Return integer_to_string(timestamp)

Process called "group_diagnostics_by_severity" that takes diagnostics as List[Diagnostic] returns Dictionary[String, List[Diagnostic]]:
    @Implementation
    Group diagnostics by their severity levels for organized reporting.
    @End Implementation
    
    Let groups be Dictionary[String, List[Diagnostic]]
    Dictionary.set(groups, "error", List[Diagnostic])
    Dictionary.set(groups, "warning", List[Diagnostic])
    Dictionary.set(groups, "info", List[Diagnostic])
    Dictionary.set(groups, "debug", List[Diagnostic])
    
    Let total_diagnostics be List.length(diagnostics)
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be diagnostics[i]
        Let severity_list be Dictionary.get(groups, diagnostic.severity)
        List.append(severity_list, diagnostic)
    End For
    
    Return groups

Process called "format_grouped_diagnostics" that takes engine as DiagnosticEngine, groups as Dictionary[String, List[Diagnostic]], format_style as String returns String:
    @Implementation
    Format grouped diagnostics for detailed reporting.
    @End Implementation
    
    Let output be ""
    Let severity_order be List[String]
    List.append(severity_order, "error")
    List.append(severity_order, "warning")
    List.append(severity_order, "info")
    List.append(severity_order, "debug")
    
    For i from 0 to 3:
        Let severity be severity_order[i]
        Let severity_diagnostics be Dictionary.get(groups, severity)
        Let count be List.length(severity_diagnostics)
        
        If count is greater than 0:
            Set output to output + severity.to_upper() + " (" + integer_to_string(count) + "):\n"
            For j from 0 to (count - 1):
                Let diagnostic be severity_diagnostics[j]
                Set output to output + "  " + format_diagnostic_message(engine, diagnostic, format_style) + "\n"
            End For
            Set output to output + "\n"
        End If
    End For
    
    Return output

Process called "diagnostics_share_symbol_context" that takes diagnostic1 as Diagnostic, diagnostic2 as Diagnostic returns Boolean:
    @Implementation
    Check if two diagnostics share symbol context (involve related symbols).
    @End Implementation
    
    Note: Check for common symbol names in messages
    Let words1 be String.split_by_space(diagnostic1.message)
    Let words2 be String.split_by_space(diagnostic2.message)
    
    Let words1_count be List.length(words1)
    Let words2_count be List.length(words2)
    
    For i from 0 to (words1_count - 1):
        Let word1 be words1[i]
        If String.length(word1) is greater than 2:  Note: Only check meaningful words
            For j from 0 to (words2_count - 1):
                Let word2 be words2[j]
                If word1 equals word2:
                    Return true  Note: Found common symbol
                End If
            End For
        End If
    End For
    
    Return false

Process called "diagnostics_in_same_scope" that takes diagnostic1 as Diagnostic, diagnostic2 as Diagnostic returns Boolean:
    @Implementation
    Check if two diagnostics are in the same scope (same file and nearby lines).
    @End Implementation
    
    Note: Check if they're in the same file
    If not diagnostic1.primary_location.file_path equals diagnostic2.primary_location.file_path:
        Return false
    End If
    
    Note: Check if they're within reasonable line distance
    Let line1 be Dictionary.get(diagnostic1.primary_location, "line_number")
    Let line2 be Dictionary.get(diagnostic2.primary_location, "line_number")
    Let line_difference be Integer.abs(line1 - line2)
    
    Return line_difference is less than or equal to 10  Note: Within 10 lines is same scope

Process called "diagnostics_close_in_location" that takes diagnostic1 as Diagnostic, diagnostic2 as Diagnostic returns Boolean:
    @Implementation
    Check if two diagnostics are close in location (same file, nearby position).
    @End Implementation
    
    Note: Check if they're in the same file
    If not diagnostic1.primary_location.file_path equals diagnostic2.primary_location.file_path:
        Return false
    End If
    
    Note: Check if they're within 5 lines of each other
    Let line1 be Dictionary.get(diagnostic1.primary_location, "line_number")
    Let line2 be Dictionary.get(diagnostic2.primary_location, "line_number")
    Let line_difference be Integer.abs(line1 - line2)
    
    Return line_difference is less than or equal to 5

Process called "diagnostics_share_function_context" that takes diagnostic1 as Diagnostic, diagnostic2 as Diagnostic returns Boolean:
    @Implementation
    Check if two diagnostics share function context.
    @End Implementation
    
    Note: Check for function-related keywords in both messages
    Let has_function_context1 be contains_text(diagnostic1.message, "function") or contains_text(diagnostic1.message, "call") or contains_text(diagnostic1.message, "parameter")
    Let has_function_context2 be contains_text(diagnostic2.message, "function") or contains_text(diagnostic2.message, "call") or contains_text(diagnostic2.message, "parameter")
    
    If has_function_context1 and has_function_context2:
        Return diagnostics_in_same_scope(diagnostic1, diagnostic2)
    End If
    
    Return false

Process called "calculate_root_cause_priority" that takes diagnostic as Diagnostic returns Integer:
    @Implementation
    Calculate priority score for root cause analysis (higher = more likely root cause).
    @End Implementation
    
    Let priority_score be 0
    
    Note: Import and declaration errors are usually root causes
    If contains_text(diagnostic.message, "import") or contains_text(diagnostic.message, "declaration"):
        Set priority_score to priority_score + 50
    End If
    
    Note: Lexical errors often cause cascading syntax errors
    If diagnostic.category equals "lexical":
        Set priority_score to priority_score + 40
    End If
    
    Note: Syntax errors at file start are often root causes
    Let line_number be Dictionary.get(diagnostic.primary_location, "line_number")
    If line_number is less than 10:
        Set priority_score to priority_score + 20
    End If
    
    Note: Errors with error codes are usually well-defined root causes
    If String.length(diagnostic.error_code) is greater than 3:
        Set priority_score to priority_score + 10
    End If
    
    Return priority_score

Process called "is_valid_root_cause" that takes root_cause as Diagnostic, error_chain as List[Diagnostic] returns Boolean:
    @Implementation
    Validate that the identified root cause is actually causal for other errors.
    @End Implementation
    
    Note: Check if root cause occurs before other errors in the chain
    Let root_line be Dictionary.get(root_cause.primary_location, "line_number")
    Let chain_length be List.length(error_chain)
    
    For i from 0 to (chain_length - 1):
        Let other_error be error_chain[i]
        If not other_error equals root_cause:
            Let other_line be Dictionary.get(other_error.primary_location, "line_number")
            If root_line is greater than other_line:
                Return false  Note: Root cause should come before other errors
            End If
        End If
    End For
    
    Return true

Process called "find_earliest_error" that takes error_chain as List[Diagnostic] returns Diagnostic:
    @Implementation
    Find the earliest error by line number and timestamp.
    @End Implementation
    
    Let chain_length be List.length(error_chain)
    If chain_length equals 0:
        Return create_null_diagnostic()
    End If
    
    Let earliest_error be error_chain[0]
    Let earliest_line be Dictionary.get(earliest_error.primary_location, "line_number")
    
    For i from 1 to (chain_length - 1):
        Let current_error be error_chain[i]
        Let current_line be Dictionary.get(current_error.primary_location, "line_number")
        
        If current_line is less than earliest_line:
            Set earliest_error to current_error
            Set earliest_line to current_line
        End If
    End For
    
    Return earliest_error

Process called "calculate_average_diagnostic_quality" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic] returns Float:
    @Implementation
    Calculate average quality score across all diagnostics.
    @End Implementation
    
    Let total_diagnostics be List.length(diagnostics)
    If total_diagnostics equals 0:
        Return 0.0
    End If
    
    Let total_score be 0.0
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be diagnostics[i]
        Let quality_score be measure_diagnostic_quality(engine, diagnostic)
        Set total_score to total_score + quality_score
    End For
    
    Return total_score / Float.from_integer(total_diagnostics)

Process called "add_diagnostic_category_mapping" that takes engine as DiagnosticEngine, code_prefix as String, category as String returns Nothing:
    @Implementation
    Add diagnostic category mapping to engine configuration.
    @End Implementation
    
    Dictionary.set(engine.category_mappings, code_prefix, category)

Process called "register_error_pattern" that takes engine as DiagnosticEngine, pattern as String, category as String returns Nothing:
    @Implementation
    Register error pattern for enhanced processing.
    @End Implementation
    
    Dictionary.set(engine.error_patterns, pattern, category)

Process called "register_suggestion_provider" that takes engine as DiagnosticEngine, error_type as String, provider_function as String returns Nothing:
    @Implementation
    Register suggestion provider for specific error types.
    @End Implementation
    
    Dictionary.set(engine.suggestion_providers, error_type, provider_function)

Process called "clear_diagnostic_cache" that takes engine as DiagnosticEngine returns Nothing:
    @Implementation
    Clear diagnostic cache and temporary data.
    @End Implementation
    
    Set engine.diagnostic_cache to Dictionary[String, Diagnostic]
    Set engine.cache_hits to 0
    Set engine.cache_misses to 0

Process called "clear_deduplication_cache" that takes engine as DiagnosticEngine returns Nothing:
    @Implementation
    Clear deduplication cache data.
    @End Implementation
    
    Set engine.deduplication_cache to Dictionary[String, Boolean]
    Set engine.duplicate_count to 0

Process called "clear_suggestion_cache" that takes engine as DiagnosticEngine returns Nothing:
    @Implementation
    Clear suggestion cache data.
    @End Implementation
    
    Set engine.suggestion_cache to Dictionary[String, List[String]]
    Set engine.suggestion_cache_size to 0

Process called "create_default_location" that takes returns Dictionary[String, Integer]:
    @Implementation
    Create default location structure for diagnostic engine.
    @End Implementation
    
    Let location be Dictionary[String, Integer]
    Dictionary.set(location, "line_number", 1)
    Dictionary.set(location, "column_number", 1)
    Dictionary.set(location, "character_offset", 0)
    
    Return location

Process called "create_default_context" that takes returns DiagnosticContext:
    @Implementation
    Create default diagnostic context structure.
    @End Implementation
    
    Return DiagnosticContext with
        context_id as "default",
        source_file as "",
        source_content as "",
        line_map as Dictionary[Integer, String],
        syntax_mode as "natural",
        compilation_phase as "unknown"
    End DiagnosticContext

Process called "deduplicate_diagnostics_in_place" that takes engine as DiagnosticEngine returns Nothing:
    @Implementation
    Remove duplicate diagnostics from engine's collection in place.
    @End Implementation
    
    Let unique_diagnostics be List[Diagnostic]
    Let total_diagnostics be List.length(engine.diagnostics)
    
    For i from 0 to (total_diagnostics - 1):
        Let current_diagnostic be engine.diagnostics[i]
        Let is_duplicate be false
        
        Note: Check against already collected unique diagnostics
        Let unique_count be List.length(unique_diagnostics)
        For j from 0 to (unique_count - 1):
            Let existing_diagnostic be unique_diagnostics[j]
            
            Note: Check if diagnostics are effectively identical
            If current_diagnostic.message equals existing_diagnostic.message and 
               current_diagnostic.severity equals existing_diagnostic.severity and
               Dictionary.get(current_diagnostic.primary_location, "line_number") equals Dictionary.get(existing_diagnostic.primary_location, "line_number"):
                Set is_duplicate to true
                Break
            End If
        End For
        
        Note: Add to unique list if not duplicate
        If not is_duplicate:
            List.append(unique_diagnostics, current_diagnostic)
        End If
    End For
    
    Note: Replace engine's diagnostics with deduplicated list
    Set engine.diagnostics to unique_diagnostics
    Set engine.diagnostic_count to List.length(unique_diagnostics)

Process called "sort_diagnostics_by_priority" that takes engine as DiagnosticEngine returns Nothing:
    @Implementation
    Sort diagnostics by priority - errors first, then warnings, then by line number.
    @End Implementation
    
    Note: Simple bubble sort implementation for diagnostic priority
    Let total_diagnostics be List.length(engine.diagnostics)
    
    For i from 0 to (total_diagnostics - 2):
        For j from 0 to (total_diagnostics - 2 - i):
            Let diag1 be engine.diagnostics[j]
            Let diag2 be engine.diagnostics[j + 1]
            
            Let should_swap be false
            
            Note: Priority by severity (error > warning > info > debug)
            If diag1.severity equals "debug" and diag2.severity not equals "debug":
                Set should_swap to true
            Otherwise If diag1.severity equals "info" and (diag2.severity equals "warning" or diag2.severity equals "error"):
                Set should_swap to true
            Otherwise If diag1.severity equals "warning" and diag2.severity equals "error":
                Set should_swap to true
            Otherwise If diag1.severity equals diag2.severity:
                Note: Same severity, sort by line number
                Let line1 be Dictionary.get(diag1.primary_location, "line_number")
                Let line2 be Dictionary.get(diag2.primary_location, "line_number")
                If line1 is greater than line2:
                    Set should_swap to true
                End If
            End If
            
            Note: Perform swap if needed
            If should_swap:
                Set engine.diagnostics[j] to diag2
                Set engine.diagnostics[j + 1] to diag1
            End If
        End For
    End For

Process called "clean_suggestion_cache" that takes engine as DiagnosticEngine returns Nothing:
    @Implementation
    Clean and optimize the suggestion cache by removing stale entries.
    @End Implementation
    
    Note: Simple cache cleaning - reset to empty for optimization
    Set engine.suggestion_cache to Dictionary[String, List[String]]
    Set engine.suggestion_cache_size to 0

Note: =====================================================================
Note: DIAGNOSTIC COLLECTION OPERATIONS
Note: =====================================================================

Process called "create_diagnostic" that takes engine as DiagnosticEngine, diagnostic_type as String, severity as String, message as String, location as Dictionary[String, Integer] returns Diagnostic:
    @Implementation
    Creates new diagnostic with full context and metadata.
    Generates unique ID and integrates with suggestion system.
    @End Implementation
    
    Let diagnostic_id be generate_diagnostic_id(engine)
    
    Let diagnostic be Diagnostic with
        diagnostic_id as diagnostic_id,
        diagnostic_type as diagnostic_type,
        severity as severity,
        message as message,
        primary_location as location,
        secondary_locations as List[Dictionary[String, Integer]],
        source_context as "",
        error_code as generate_error_code(diagnostic_type, severity),
        category as classify_diagnostic_category(diagnostic_type),
        suggestions as List[String],
        related_diagnostics as List[String]
    End Diagnostic
    
    Note: Generate source context if location provided
    If location contains "file_path":
        Let context be extract_source_context(location)
        Set diagnostic.source_context to context
    End If
    
    Note: Update statistics
    Set engine.statistics["diagnostics_created"] to engine.statistics["diagnostics_created"] + 1
    
    If severity equals "error":
        Set engine.statistics["errors_reported"] to engine.statistics["errors_reported"] + 1
    Otherwise severity equals "warning":
        Set engine.statistics["warnings_reported"] to engine.statistics["warnings_reported"] + 1
    End If
    
    Return diagnostic

Process called "add_diagnostic" that takes engine as DiagnosticEngine, diagnostic as Diagnostic returns Boolean:
    @Implementation
    Adds diagnostic to active collection and processes for suggestions.
    Maintains collection integrity and updates diagnostic history.
    @End Implementation
    
    Note: Get or create active collection
    Let active_collection be get_or_create_active_collection(engine)
    
    Note: Add diagnostic to collection
    List.add(active_collection.diagnostics, diagnostic)
    
    Note: Add to history
    List.add(engine.diagnostic_history, diagnostic)
    
    Note: Update collection metadata
    If diagnostic.severity equals "error":
        Set active_collection.has_errors to true
    Otherwise diagnostic.severity equals "warning":
        Set active_collection.has_warnings to true
    End If
    
    Note: Mark collection as needing resort
    Set active_collection.is_sorted to false
    
    Note: Generate suggestions for the diagnostic
    Let suggestions be generate_diagnostic_suggestions(engine, diagnostic)
    Set diagnostic.suggestions to suggestions
    
    Return true

Process called "collect_lexical_diagnostics" that takes engine as DiagnosticEngine, lexer_errors as List[String] returns Boolean:
    @Implementation
    Collect diagnostics from lexical analysis phase, converting lexer errors into structured diagnostics.
    Processes token recognition errors, invalid characters, and lexical rule violations.
    @End Implementation
    
    Let error_count be List.length(lexer_errors)
    If error_count equals 0:
        Return true  Note: No lexical errors to process
    End If
    
    Note: Process each lexer error
    For i from 0 to (error_count - 1):
        Let error_message be lexer_errors[i]
        
        Note: Parse error information (format: "line:column:message")
        Let error_parts be split_error_message(error_message)
        Let line_number be extract_line_number(error_parts)
        Let column_number be extract_column_number(error_parts)
        Let core_message be extract_error_text(error_parts)
        
        Note: Create location information
        Let location be Dictionary[String, Integer]
        Dictionary.set(location, "line_number", line_number)
        Dictionary.set(location, "column_number", column_number)
        Dictionary.set(location, "character_offset", calculate_character_offset(line_number, column_number))
        
        Note: Determine error severity and type
        Let severity be "error"  Note: Lexical errors are typically fatal
        Let diagnostic_type be "lexical"
        
        Note: Create structured diagnostic
        Let diagnostic be create_diagnostic(engine, diagnostic_type, severity, core_message, location)
        Set diagnostic.category to "tokenization"
        Set diagnostic.error_code to "LEX" + integer_to_string(1000 + i)
        
        Note: Add lexical-specific context
        Set diagnostic.source_context to extract_lexical_context(engine.context, location)
        
        Note: Add diagnostic to engine
        add_diagnostic_to_collection(engine, diagnostic)
    End For
    
    Return true

Process called "collect_parsing_diagnostics" that takes engine as DiagnosticEngine, parser_errors as List[String] returns Boolean:
    @Implementation
    Collect diagnostics from parsing phase, converting parser errors into structured diagnostics.
    Processes syntax errors, missing tokens, unexpected tokens, and grammar violations.
    @End Implementation
    
    Let error_count be List.length(parser_errors)
    If error_count equals 0:
        Return true  Note: No parsing errors to process
    End If
    
    Note: Process each parser error
    For i from 0 to (error_count - 1):
        Let error_message be parser_errors[i]
        
        Note: Parse error information and extract components
        Let error_parts be split_error_message(error_message)
        Let line_number be extract_line_number(error_parts)
        Let column_number be extract_column_number(error_parts)
        Let core_message be extract_error_text(error_parts)
        
        Note: Create location information
        Let location be Dictionary[String, Integer]
        Dictionary.set(location, "line_number", line_number)
        Dictionary.set(location, "column_number", column_number)
        Dictionary.set(location, "character_offset", calculate_character_offset(line_number, column_number))
        
        Note: Classify parsing error severity
        Let severity be classify_parsing_error_severity(core_message)
        Let diagnostic_type be "syntax"
        
        Note: Create structured diagnostic
        Let diagnostic be create_diagnostic(engine, diagnostic_type, severity, core_message, location)
        Set diagnostic.category to "parsing"
        Set diagnostic.error_code to "PARSE" + integer_to_string(2000 + i)
        
        Note: Add parsing-specific context and suggestions
        Set diagnostic.source_context to extract_parsing_context(engine.context, location)
        Set diagnostic.suggestions to generate_parsing_suggestions(core_message)
        
        Note: Add diagnostic to engine
        add_diagnostic_to_collection(engine, diagnostic)
    End For
    
    Return true

Process called "collect_semantic_diagnostics" that takes engine as DiagnosticEngine, semantic_errors as List[String] returns Boolean:
    @Implementation
    Collect diagnostics from semantic analysis phase, converting semantic errors into structured diagnostics.
    Processes type errors, scope violations, undefined variables, and semantic inconsistencies.
    @End Implementation
    
    Let error_count be List.length(semantic_errors)
    If error_count equals 0:
        Return true  Note: No semantic errors to process
    End If
    
    Note: Process each semantic error
    For i from 0 to (error_count - 1):
        Let error_message be semantic_errors[i]
        
        Note: Parse semantic error information
        Let error_parts be split_error_message(error_message)
        Let line_number be extract_line_number(error_parts)
        Let column_number be extract_column_number(error_parts)
        Let core_message be extract_error_text(error_parts)
        
        Note: Create location information
        Let location be Dictionary[String, Integer]
        Dictionary.set(location, "line_number", line_number)
        Dictionary.set(location, "column_number", column_number)
        Dictionary.set(location, "character_offset", calculate_character_offset(line_number, column_number))
        
        Note: Classify semantic error type and severity
        Let error_classification be classify_semantic_error(core_message)
        Let severity be error_classification.severity
        Let diagnostic_type be error_classification.type
        
        Note: Create structured diagnostic
        Let diagnostic be create_diagnostic(engine, diagnostic_type, severity, core_message, location)
        Set diagnostic.category to "semantics"
        Set diagnostic.error_code to "SEM" + integer_to_string(3000 + i)
        
        Note: Add semantic-specific context and suggestions
        Set diagnostic.source_context to extract_semantic_context(engine.context, location)
        Set diagnostic.suggestions to generate_semantic_suggestions(core_message, error_classification)
        
        Note: Check for related diagnostics (cascading errors)
        Set diagnostic.related_diagnostics to find_related_semantic_diagnostics(engine, diagnostic)
        
        Note: Add diagnostic to engine
        add_diagnostic_to_collection(engine, diagnostic)
    End For
    
    Return true

Note: =====================================================================
Note: DIAGNOSTIC PROCESSING OPERATIONS
Note: =====================================================================

Process called "classify_diagnostic_severity" that takes engine as DiagnosticEngine, diagnostic as Diagnostic returns String:
    @Implementation
    Classify diagnostic severity based on type, context, and impact analysis.
    Returns standardized severity levels for consistent diagnostic processing.
    @End Implementation
    
    Note: Check for pre-classified severity
    If StringPrimitive.length(diagnostic.severity) is greater than 0:
        Return diagnostic.severity  Note: Already classified
    End If
    
    Note: Classify based on diagnostic type and message content
    Let severity be "info"  Note: Default severity
    
    Match diagnostic.diagnostic_type:
        When "lexical":
            Note: Lexical errors are typically fatal
            Set severity to "error"
        When "syntax":
            Note: Syntax errors prevent compilation
            Set severity to "error"
        When "semantic":
            Note: Semantic errors vary in severity
            If StringPrimitive.contains(diagnostic.message, "undefined") or StringPrimitive.contains(diagnostic.message, "not found"):
                Set severity to "error"
            Otherwise StringPrimitive.contains(diagnostic.message, "type mismatch") or StringPrimitive.contains(diagnostic.message, "incompatible"):
                Set severity to "error"
            Otherwise StringPrimitive.contains(diagnostic.message, "unused") or StringPrimitive.contains(diagnostic.message, "unreachable"):
                Set severity to "warning"
            Otherwise:
                Set severity to "warning"
            End If
        When "type":
            Note: Type errors are typically errors but some are warnings
            If StringPrimitive.contains(diagnostic.message, "cannot convert") or StringPrimitive.contains(diagnostic.message, "incompatible types"):
                Set severity to "error"
            Otherwise:
                Set severity to "warning"
            End If
        When "style":
            Set severity to "info"
        When "performance":
            Set severity to "info"
        Otherwise:
            Set severity to "warning"
    End Match
    
    Note: Override severity based on error codes
    If StringPrimitive.starts_with(diagnostic.error_code, "FATAL"):
        Set severity to "error"
    Otherwise StringPrimitive.starts_with(diagnostic.error_code, "WARN"):
        Set severity to "warning"
    Otherwise StringPrimitive.starts_with(diagnostic.error_code, "INFO"):
        Set severity to "info"
    End If
    
    Return severity

Process called "prioritize_diagnostics" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic] returns List[Diagnostic]:
    @Implementation
    Sort diagnostics by priority and severity using comprehensive ranking system.
    Orders diagnostics for optimal presentation and developer workflow.
    @End Implementation
    
    Let diagnostic_count be List.length(diagnostics)
    If diagnostic_count is less than or equal to 1:
        Return diagnostics  Note: Nothing to sort
    End If
    
    Note: Create priority-scored diagnostic pairs for sorting
    Let scored_diagnostics be List[Dictionary[String, Any]]
    
    For i from 0 to (diagnostic_count - 1):
        Let diagnostic be diagnostics[i]
        Let priority_score be calculate_diagnostic_priority(diagnostic)
        
        Let scored_item be Dictionary[String, Any]
        Dictionary.set(scored_item, "diagnostic", diagnostic)
        Dictionary.set(scored_item, "score", priority_score)
        List.add(scored_diagnostics, scored_item)
    End For
    
    Note: Sort by priority score (higher scores first)
    Let sorted_scored be sort_by_score(scored_diagnostics)
    
    Note: Extract sorted diagnostics
    Let sorted_diagnostics be List[Diagnostic]
    Let sorted_count be List.length(sorted_scored)
    
    For i from 0 to (sorted_count - 1):
        Let scored_item be sorted_scored[i]
        Let diagnostic be Dictionary.get(scored_item, "diagnostic")
        List.add(sorted_diagnostics, diagnostic)
    End For
    
    Return sorted_diagnostics

Process called "deduplicate_diagnostics" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic] returns List[Diagnostic]:
    @Implementation
    Remove duplicate or redundant diagnostics using content and location comparison.
    Preserves the highest severity instance of each unique diagnostic.
    @End Implementation
    
    Let diagnostic_count be List.length(diagnostics)
    If diagnostic_count is less than or equal to 1:
        Return diagnostics  Note: Nothing to deduplicate
    End If
    
    Let unique_diagnostics be List[Diagnostic]
    Let seen_signatures be Dictionary[String, Boolean]
    
    For i from 0 to (diagnostic_count - 1):
        Let diagnostic be diagnostics[i]
        Let signature be generate_diagnostic_signature(diagnostic)
        
        Note: Check if we've seen this diagnostic before
        If not Dictionary.contains_key(seen_signatures, signature):
            Note: First occurrence - add to unique list
            List.add(unique_diagnostics, diagnostic)
            Dictionary.set(seen_signatures, signature, true)
        Otherwise:
            Note: Duplicate found - check if this one is more severe
            Let existing_diagnostic be find_diagnostic_by_signature(unique_diagnostics, signature)
            If is_more_severe_diagnostic(diagnostic, existing_diagnostic):
                Note: Replace with more severe version
                replace_diagnostic_in_list(unique_diagnostics, signature, diagnostic)
            End If
        End If
    End For
    
    Return unique_diagnostics

Process called "group_related_diagnostics" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic] returns Dictionary[String, List[Diagnostic]]:
    @Implementation
    Group related diagnostics for better presentation using multiple grouping strategies.
    Creates hierarchical groups based on file, type, severity, and error relationships.
    @End Implementation
    
    Let groups be Dictionary[String, List[Diagnostic]]
    Let diagnostic_count be List.length(diagnostics)
    
    If diagnostic_count equals 0:
        Return groups  Note: No diagnostics to group
    End If
    
    Note: Group by primary category (file location)
    For i from 0 to (diagnostic_count - 1):
        Let diagnostic be diagnostics[i]
        Let file_location be extract_file_from_location(diagnostic.primary_location)
        Let group_key be file_location
        
        Note: If no file location, group by type
        If StringPrimitive.length(group_key) equals 0:
            Set group_key to "type_" + diagnostic.diagnostic_type
        End If
        
        Note: Create group if it doesn't exist
        If not Dictionary.contains_key(groups, group_key):
            Dictionary.set(groups, group_key, List[Diagnostic])
        End If
        
        Note: Add diagnostic to group
        Let group_list be Dictionary.get(groups, group_key)
        List.add(group_list, diagnostic)
    End For
    
    Note: Create severity-based subgroups within each file group
    Let severity_groups be Dictionary[String, List[Diagnostic]]
    
    For Each group_key in Dictionary.keys(groups):
        Let group_diagnostics be Dictionary.get(groups, group_key)
        Let group_size be List.length(group_diagnostics)
        
        Note: If group has multiple items, create severity subgroups
        If group_size is greater than 3:
            Let error_subgroup be List[Diagnostic]
            Let warning_subgroup be List[Diagnostic]
            Let info_subgroup be List[Diagnostic]
            
            For j from 0 to (group_size - 1):
                Let diagnostic be group_diagnostics[j]
                Match diagnostic.severity:
                    When "error":
                        List.add(error_subgroup, diagnostic)
                    When "warning":
                        List.add(warning_subgroup, diagnostic)
                    When "info":
                        List.add(info_subgroup, diagnostic)
                    Otherwise:
                        List.add(info_subgroup, diagnostic)
                End Match
            End For
            
            Note: Add severity subgroups if they have content
            Let error_count be List.length(error_subgroup)
            Let warning_count be List.length(warning_subgroup)
            Let info_count be List.length(info_subgroup)
            
            If error_count is greater than 0:
                Dictionary.set(severity_groups, group_key + "_errors", error_subgroup)
            End If
            If warning_count is greater than 0:
                Dictionary.set(severity_groups, group_key + "_warnings", warning_subgroup)
            End If
            If info_count is greater than 0:
                Dictionary.set(severity_groups, group_key + "_info", info_subgroup)
            End If
        End If
    End For
    
    Note: Merge severity groups back into main groups if they exist
    For Each severity_key in Dictionary.keys(severity_groups):
        Let severity_group be Dictionary.get(severity_groups, severity_key)
        Dictionary.set(groups, severity_key, severity_group)
    End For
    
    Return groups

Note: =====================================================================
Note: NATURAL LANGUAGE DIAGNOSTIC SUPPORT
Note: =====================================================================

Process called "generate_natural_syntax_diagnostic" that takes engine as DiagnosticEngine, natural_error as String, context as String returns Diagnostic:
    @Implementation
    Generate diagnostic for natural language syntax error with contextual analysis.
    Converts natural language error descriptions into structured diagnostic objects.
    @End Implementation
    
    Note: Parse natural error for location and content
    Let error_location be extract_location_from_natural_error(natural_error)
    Let error_message be extract_message_from_natural_error(natural_error)
    
    Note: Create base diagnostic structure
    Let diagnostic be create_diagnostic(engine, "natural_syntax", "error", error_message, error_location)
    
    Note: Enhance with natural language specifics
    Set diagnostic.category to "natural_language"
    Set diagnostic.error_code to "NATURAL" + integer_to_string(get_current_timestamp() mod 10000)
    
    Note: Add context-specific information
    If StringPrimitive.length(context) is greater than 0:
        Set diagnostic.source_context to context
        
        Note: Analyze context for additional insights
        If StringPrimitive.contains(context, "when") or StringPrimitive.contains(context, "if"):
            List.add(diagnostic.suggestions, "Check conditional statement syntax")
        End If
        
        If StringPrimitive.contains(context, "for each") or StringPrimitive.contains(context, "while"):
            List.add(diagnostic.suggestions, "Verify loop statement structure")
        End If
        
        If StringPrimitive.contains(context, "let") or StringPrimitive.contains(context, "set"):
            List.add(diagnostic.suggestions, "Review variable declaration syntax")
        End If
    End If
    
    Note: Add natural language specific suggestions
    List.add(diagnostic.suggestions, "Consider using technical syntax mode for more precise error reporting")
    List.add(diagnostic.suggestions, "Check Runa natural language syntax reference")
    
    Return diagnostic

Process called "explain_natural_language_error" that takes engine as DiagnosticEngine, error_context as String returns String:
    @Implementation
    Generate detailed explanation for natural language syntax errors.
    Provides user-friendly explanations with examples and guidance.
    @End Implementation
    
    If StringPrimitive.length(error_context) equals 0:
        Return "No error context provided for explanation."
    End If
    
    Let explanation be ""
    
    Note: Analyze error context for common patterns
    If StringPrimitive.contains(error_context, "unexpected"):
        StringPrimitive.append(explanation, "This error occurs when the parser encounters something it doesn't expect. ")
        StringPrimitive.append(explanation, "In natural syntax mode, Runa expects English-like statements. ")
        
        If StringPrimitive.contains(error_context, "token"):
            StringPrimitive.append(explanation, "The specific token or word causing the issue should be highlighted. ")
            StringPrimitive.append(explanation, "Try rephrasing using natural language constructs like 'Let', 'Set', 'If', 'For Each', etc.")
        End If
        
    Otherwise StringPrimitive.contains(error_context, "missing"):
        StringPrimitive.append(explanation, "This indicates that a required part of the statement is missing. ")
        StringPrimitive.append(explanation, "Natural language statements in Runa need to be complete thoughts. ")
        
        If StringPrimitive.contains(error_context, "variable"):
            StringPrimitive.append(explanation, "You might be missing a variable declaration using 'Let' or forgetting to specify what to set.")
        Otherwise StringPrimitive.contains(error_context, "value"):
            StringPrimitive.append(explanation, "You might be missing the value part of an assignment or comparison.")
        End If
        
    Otherwise StringPrimitive.contains(error_context, "invalid"):
        StringPrimitive.append(explanation, "This suggests the syntax doesn't match Runa's natural language patterns. ")
        StringPrimitive.append(explanation, "Try using more conversational phrasing. For example: ")
        StringPrimitive.append(explanation, "'Let counter be 5' instead of 'counter = 5', ")
        StringPrimitive.append(explanation, "'If counter is greater than 10' instead of 'if (counter > 10)'.")
        
    Otherwise:
        StringPrimitive.append(explanation, "This appears to be a natural language syntax issue. ")
        StringPrimitive.append(explanation, "Runa's natural syntax aims to read like English. ")
        StringPrimitive.append(explanation, "Consider consulting the natural language syntax guide for proper patterns.")
    End If
    
    Note: Add general guidance
    StringPrimitive.append(explanation, " Remember that natural syntax should flow like readable English while maintaining logical programming structure.")
    
    Return explanation

Process called "suggest_natural_corrections" that takes engine as DiagnosticEngine, natural_error as String returns List[String]:
    @Implementation
    Suggest corrections for natural language syntax issues using pattern matching.
    Provides specific, actionable suggestions for common natural syntax errors.
    @End Implementation
    
    Let suggestions be List[String]
    
    If StringPrimitive.length(natural_error) equals 0:
        List.add(suggestions, "No error details provided for suggestions")
        Return suggestions
    End If
    
    Note: Analyze error for specific patterns and suggest corrections
    If StringPrimitive.contains(natural_error, "assignment") or StringPrimitive.contains(natural_error, "="):
        List.add(suggestions, "Use 'Set variable_name to value' instead of 'variable_name = value'")
        List.add(suggestions, "For new variables, use 'Let variable_name be value'")
        List.add(suggestions, "Example: 'Set counter to 10' or 'Let name be \"John\"'")
    End If
    
    If StringPrimitive.contains(natural_error, "comparison") or StringPrimitive.contains(natural_error, "condition"):
        List.add(suggestions, "Use 'If condition is true:' format for conditionals")
        List.add(suggestions, "Use natural comparisons: 'greater than', 'less than', 'equals'")
        List.add(suggestions, "Example: 'If age is greater than 18:'")
    End If
    
    If StringPrimitive.contains(natural_error, "loop") or StringPrimitive.contains(natural_error, "iteration"):
        List.add(suggestions, "Use 'For Each item in collection:' for iteration")
        List.add(suggestions, "Use 'While condition is true:' for conditional loops")
        List.add(suggestions, "Example: 'For Each number in numbers:'")
    End If
    
    If StringPrimitive.contains(natural_error, "function") or StringPrimitive.contains(natural_error, "process"):
        List.add(suggestions, "Use 'Process called \"name\" that takes parameters returns ReturnType:'")
        List.add(suggestions, "End processes with 'End Process'")
        List.add(suggestions, "Example: 'Process called \"calculate\" that takes x as Integer returns Integer:'")
    End If
    
    If StringPrimitive.contains(natural_error, "type") or StringPrimitive.contains(natural_error, "declaration"):
        List.add(suggestions, "Use 'Type called \"TypeName\":' for custom types")
        List.add(suggestions, "End type definitions with 'End Type'")
        List.add(suggestions, "Example: 'Type called \"Person\": name as String End Type'")
    End If
    
    If StringPrimitive.contains(natural_error, "punctuation") or StringPrimitive.contains(natural_error, "semicolon"):
        List.add(suggestions, "Natural syntax doesn't require semicolons or most punctuation")
        List.add(suggestions, "Use line breaks to separate statements")
        List.add(suggestions, "End blocks with appropriate keywords like 'End If', 'End For'")
    End If
    
    Note: Add general suggestions if no specific patterns matched
    Let suggestion_count be List.length(suggestions)
    If suggestion_count equals 0:
        List.add(suggestions, "Try rephrasing using more natural, English-like syntax")
        List.add(suggestions, "Consult the Runa natural language syntax reference")
        List.add(suggestions, "Consider switching to technical syntax mode for more familiar patterns")
    End If
    
    Note: Always add a reference suggestion
    List.add(suggestions, "See the natural language syntax guide for complete examples")
    
    Return suggestions

Note: =====================================================================
Note: TECHNICAL SYNTAX DIAGNOSTIC SUPPORT
Note: =====================================================================

Process called "generate_technical_syntax_diagnostic" that takes engine as DiagnosticEngine, technical_error as String, context as String returns Diagnostic:
    @Implementation
    Generate diagnostic for technical syntax error with precise location and type information.
    Handles traditional programming syntax patterns familiar to developers.
    @End Implementation
    
    Note: Parse technical error for structured information
    Let error_location be extract_location_from_technical_error(technical_error)
    Let error_message be extract_message_from_technical_error(technical_error)
    
    Note: Determine severity based on technical error type
    Let severity be classify_technical_error_severity(technical_error)
    
    Note: Create diagnostic with technical specifics
    Let diagnostic be create_diagnostic(engine, "technical_syntax", severity, error_message, error_location)
    Set diagnostic.category to "technical_syntax"
    Set diagnostic.error_code to "TECH" + integer_to_string(get_current_timestamp() mod 10000)
    
    Note: Add technical-specific context and analysis
    If StringPrimitive.length(context) is greater than 0:
        Set diagnostic.source_context to context
        
        Note: Analyze for common technical syntax patterns
        If StringPrimitive.contains(context, "{") or StringPrimitive.contains(context, "}"):
            List.add(diagnostic.suggestions, "Check brace matching and block structure")
        End If
        
        If StringPrimitive.contains(context, ";"):
            List.add(diagnostic.suggestions, "Verify semicolon placement and statement termination")
        End If
        
        If StringPrimitive.contains(context, "(") or StringPrimitive.contains(context, ")"):
            List.add(diagnostic.suggestions, "Check parentheses balance in expressions or function calls")
        End If
        
        If StringPrimitive.contains(context, "=") and not StringPrimitive.contains(context, "=="):
            List.add(diagnostic.suggestions, "Check assignment syntax - use single = for assignment")
        End If
    End If
    
    Note: Add technical syntax specific suggestions
    List.add(diagnostic.suggestions, "Review technical syntax patterns in Runa language reference")
    List.add(diagnostic.suggestions, "Consider natural syntax mode for more readable code")
    
    Return diagnostic

Process called "explain_technical_error" that takes engine as DiagnosticEngine, error_context as String returns String:
    @Implementation
    Generate detailed explanation for technical syntax errors using programmer-familiar terminology.
    Provides precise technical guidance for syntax issues.
    @End Implementation
    
    If StringPrimitive.length(error_context) equals 0:
        Return "No error context available for technical explanation."
    End If
    
    Let explanation be ""
    
    Note: Analyze technical error patterns
    If StringPrimitive.contains(error_context, "parse") or StringPrimitive.contains(error_context, "syntax"):
        StringPrimitive.append(explanation, "Parser encountered a syntax error in technical mode. ")
        StringPrimitive.append(explanation, "Technical syntax follows traditional programming language patterns with explicit delimiters and operators. ")
        
    Otherwise StringPrimitive.contains(error_context, "token"):
        StringPrimitive.append(explanation, "Lexical analysis detected an unexpected or malformed token. ")
        StringPrimitive.append(explanation, "This typically means a symbol, keyword, or identifier doesn't match expected patterns. ")
        
    Otherwise StringPrimitive.contains(error_context, "expression"):
        StringPrimitive.append(explanation, "Expression parsing failed due to malformed syntax. ")
        StringPrimitive.append(explanation, "Check operator precedence, parentheses matching, and operand validity. ")
        
    Otherwise StringPrimitive.contains(error_context, "statement"):
        StringPrimitive.append(explanation, "Statement structure is malformed or incomplete. ")
        StringPrimitive.append(explanation, "Ensure proper statement termination and block structure. ")
        
    Otherwise StringPrimitive.contains(error_context, "type"):
        StringPrimitive.append(explanation, "Type declaration or annotation has syntax errors. ")
        StringPrimitive.append(explanation, "Check type syntax, generic parameters, and type constraints. ")
        
    Otherwise:
        StringPrimitive.append(explanation, "Technical syntax error detected. ")
        StringPrimitive.append(explanation, "Review code structure for adherence to technical syntax rules. ")
    End If
    
    Note: Add specific guidance based on error context
    If StringPrimitive.contains(error_context, "missing"):
        StringPrimitive.append(explanation, "Missing syntax elements can break parsing. Common issues include missing semicolons, unmatched braces, or incomplete expressions.")
    Otherwise StringPrimitive.contains(error_context, "unexpected"):
        StringPrimitive.append(explanation, "Unexpected tokens suggest incorrect syntax usage. Check for typos, wrong operators, or misplaced keywords.")
    End If
    
    StringPrimitive.append(explanation, " Technical syntax provides precise control but requires exact adherence to language grammar rules.")
    
    Return explanation

Process called "suggest_technical_corrections" that takes engine as DiagnosticEngine, technical_error as String returns List[String]:
    @Implementation
    Suggest corrections for technical syntax issues using precise programming patterns.
    Provides specific fixes for common technical syntax problems.
    @End Implementation
    
    Let suggestions be List[String]
    
    If StringPrimitive.length(technical_error) equals 0:
        List.add(suggestions, "No error information provided for technical corrections")
        Return suggestions
    End If
    
    Note: Analyze error for specific technical patterns
    If StringPrimitive.contains(technical_error, "semicolon") or StringPrimitive.contains(technical_error, ";"):
        List.add(suggestions, "Add semicolon at end of statement: 'variable = value;'")
        List.add(suggestions, "Check for missing semicolons in statement sequences")
        List.add(suggestions, "Ensure each statement ends with ';' in technical mode")
    End If
    
    If StringPrimitive.contains(technical_error, "brace") or StringPrimitive.contains(technical_error, "{"):
        List.add(suggestions, "Match opening braces '{' with closing braces '}'")
        List.add(suggestions, "Check block structure: 'if (condition) { statements }'")
        List.add(suggestions, "Verify function and type definition brace matching")
    End If
    
    If StringPrimitive.contains(technical_error, "parenthesis") or StringPrimitive.contains(technical_error, "("):
        List.add(suggestions, "Balance parentheses in expressions and function calls")
        List.add(suggestions, "Check function parameter lists: 'function(param1, param2)'")
        List.add(suggestions, "Verify conditional expressions: 'if (condition)'")
    End If
    
    If StringPrimitive.contains(technical_error, "assignment") or StringPrimitive.contains(technical_error, "="):
        List.add(suggestions, "Use single = for assignment: 'variable = value'")
        List.add(suggestions, "Use == for equality comparison: 'if (a == b)'")
        List.add(suggestions, "Check assignment vs comparison operator usage")
    End If
    
    If StringPrimitive.contains(technical_error, "function") or StringPrimitive.contains(technical_error, "method"):
        List.add(suggestions, "Use function syntax: 'function_name(parameters) { body }'")
        List.add(suggestions, "Check parameter list syntax and return type annotations")
        List.add(suggestions, "Verify function call syntax: 'function_name(args)'")
    End If
    
    If StringPrimitive.contains(technical_error, "variable") or StringPrimitive.contains(technical_error, "identifier"):
        List.add(suggestions, "Check variable naming rules: start with letter or underscore")
        List.add(suggestions, "Avoid reserved keywords as variable names")
        List.add(suggestions, "Use consistent naming conventions")
    End If
    
    If StringPrimitive.contains(technical_error, "type"):
        List.add(suggestions, "Check type annotation syntax: 'variable: Type'")
        List.add(suggestions, "Verify generic type parameters: 'List<Type>'")
        List.add(suggestions, "Ensure proper type declaration format")
    End If
    
    Note: Add general technical suggestions if no specific patterns found
    Let suggestion_count be List.length(suggestions)
    If suggestion_count equals 0:
        List.add(suggestions, "Review technical syntax rules and grammar")
        List.add(suggestions, "Check for typos in keywords and operators")
        List.add(suggestions, "Verify proper use of delimiters and punctuation")
    End If
    
    List.add(suggestions, "Consult technical syntax reference for complete grammar rules")
    
    Return suggestions

Note: =====================================================================
Note: MATHEMATICAL DIAGNOSTIC SUPPORT
Note: =====================================================================

Process called "generate_mathematical_diagnostic" that takes engine as DiagnosticEngine, math_error as String, symbols as List[String] returns Diagnostic:
    @Implementation
    Generate comprehensive diagnostic for mathematical expression errors, handling Greek symbols,
    operators, and mathematical notation specific to Runa's mathematical libraries.
    @End Implementation
    
    Note: Initialize diagnostic structure
    Let diagnostic be create_diagnostic(engine, "mathematical", "error", math_error, engine.current_location)
    Set diagnostic.category to "mathematical_expression"
    Set diagnostic.error_code to "MATH001"
    
    Note: Analyze mathematical error type based on error message content
    Let error_type be "unknown"
    Let correction_suggestions be List[String]
    
    Note: Check for Greek symbol errors
    If contains_text(math_error, "symbol") or contains_text(math_error, "greek"):
        Set error_type to "greek_symbol"
        Set diagnostic.error_code to "MATH002"
        Let symbol_explanation be explain_greek_symbol_error(engine, math_error)
        List.append(correction_suggestions, symbol_explanation)
    End If
    
    Note: Check for operator errors
    If contains_text(math_error, "operator") or contains_text(math_error, "operation"):
        Set error_type to "operator"
        Set diagnostic.error_code to "MATH003"
        List.append(correction_suggestions, "Check operator precedence and associativity")
        List.append(correction_suggestions, "Ensure mathematical operators are properly imported")
    End If
    
    Note: Check for expression syntax errors
    If contains_text(math_error, "expression") or contains_text(math_error, "syntax"):
        Set error_type to "expression_syntax"
        Set diagnostic.error_code to "MATH004"
        List.append(correction_suggestions, "Verify mathematical expression syntax")
        List.append(correction_suggestions, "Check parentheses and bracket matching")
    End If
    
    Note: Check for type mismatch in mathematical operations
    If contains_text(math_error, "type") or contains_text(math_error, "mismatch"):
        Set error_type to "type_mismatch"
        Set diagnostic.error_code to "MATH005"
        List.append(correction_suggestions, "Ensure compatible types in mathematical operations")
        List.append(correction_suggestions, "Consider explicit type conversion")
    End If
    
    Note: Add symbol-specific context
    Let symbols_count be List.length(symbols)
    If symbols_count is greater than 0:
        Let symbol_context be "Involved symbols: "
        For i from 0 to (symbols_count - 1):
            Let symbol be symbols[i]
            Set symbol_context to symbol_context + symbol
            If i is less than (symbols_count - 1):
                Set symbol_context to symbol_context + ", "
            End If
        End For
        Set diagnostic.additional_context to symbol_context
    End If
    
    Note: Set error-specific properties
    Set diagnostic.error_category to error_type
    Set diagnostic.suggestions to correction_suggestions
    
    Note: Add mathematical-specific metadata
    Dictionary.set(diagnostic.metadata, "mathematical_error_type", error_type)
    Dictionary.set(diagnostic.metadata, "symbols_involved", integer_to_string(symbols_count))
    Dictionary.set(diagnostic.metadata, "requires_math_import", "true")
    
    Return diagnostic

Process called "explain_greek_symbol_error" that takes engine as DiagnosticEngine, symbol_error as String returns String:
    @Implementation
    Provide detailed explanations for Greek symbol usage errors, including common mathematical
    symbols like π, α, β, Σ, Δ, λ, etc. and their proper usage in Runa mathematical contexts.
    @End Implementation
    
    Note: Initialize explanation with default message
    Let explanation be "Greek symbol usage error: "
    
    Note: Check for specific Greek symbols and provide targeted explanations
    If contains_text(symbol_error, "π") or contains_text(symbol_error, "pi"):
        Set explanation to explanation + "π (pi) symbol detected. Use 'Math.Constants.PI' or import π from Math.Symbols for mathematical expressions."
    Otherwise If contains_text(symbol_error, "α") or contains_text(symbol_error, "alpha"):
        Set explanation to explanation + "α (alpha) symbol detected. Import from Math.Symbols.Greek or use ASCII equivalent 'alpha' in variable names."
    Otherwise If contains_text(symbol_error, "β") or contains_text(symbol_error, "beta"):
        Set explanation to explanation + "β (beta) symbol detected. Import from Math.Symbols.Greek or use ASCII equivalent 'beta' in variable names."
    Otherwise If contains_text(symbol_error, "γ") or contains_text(symbol_error, "gamma"):
        Set explanation to explanation + "γ (gamma) symbol detected. Import from Math.Symbols.Greek or use ASCII equivalent 'gamma' in variable names."
    Otherwise If contains_text(symbol_error, "δ") or contains_text(symbol_error, "delta"):
        Set explanation to explanation + "δ (delta) symbol detected. Use 'Math.Calculus.delta' for differential operations or import from Math.Symbols.Greek."
    Otherwise If contains_text(symbol_error, "Δ") or contains_text(symbol_error, "Delta"):
        Set explanation to explanation + "Δ (Delta) symbol detected. Use 'Math.Analysis.Delta' for difference operations or import from Math.Symbols.Greek."
    Otherwise If contains_text(symbol_error, "ε") or contains_text(symbol_error, "epsilon"):
        Set explanation to explanation + "ε (epsilon) symbol detected. Use 'Math.Constants.EPSILON' for floating-point precision or import from Math.Symbols.Greek."
    Otherwise If contains_text(symbol_error, "θ") or contains_text(symbol_error, "theta"):
        Set explanation to explanation + "θ (theta) symbol detected. Use 'Math.Trigonometry.angle' parameter or import from Math.Symbols.Greek."
    Otherwise If contains_text(symbol_error, "λ") or contains_text(symbol_error, "lambda"):
        Set explanation to explanation + "λ (lambda) symbol detected. Use 'lambda' keyword for anonymous functions or import from Math.Symbols.Greek for mathematical contexts."
    Otherwise If contains_text(symbol_error, "μ") or contains_text(symbol_error, "mu"):
        Set explanation to explanation + "μ (mu) symbol detected. Use 'Math.Statistics.mean' or import from Math.Symbols.Greek for statistical operations."
    Otherwise If contains_text(symbol_error, "σ") or contains_text(symbol_error, "sigma"):
        Set explanation to explanation + "σ (sigma) symbol detected. Use 'Math.Statistics.std_dev' or import from Math.Symbols.Greek for statistical operations."
    Otherwise If contains_text(symbol_error, "Σ") or contains_text(symbol_error, "Sigma"):
        Set explanation to explanation + "Σ (Sigma) symbol detected. Use 'Math.Series.sum' for summation operations or import from Math.Symbols.Greek."
    Otherwise If contains_text(symbol_error, "φ") or contains_text(symbol_error, "phi"):
        Set explanation to explanation + "φ (phi) symbol detected. Use 'Math.Constants.GOLDEN_RATIO' or import from Math.Symbols.Greek."
    Otherwise If contains_text(symbol_error, "χ") or contains_text(symbol_error, "chi"):
        Set explanation to explanation + "χ (chi) symbol detected. Import from Math.Symbols.Greek or use ASCII equivalent in variable names."
    Otherwise If contains_text(symbol_error, "ψ") or contains_text(symbol_error, "psi"):
        Set explanation to explanation + "ψ (psi) symbol detected. Import from Math.Symbols.Greek or use ASCII equivalent in variable names."
    Otherwise If contains_text(symbol_error, "ω") or contains_text(symbol_error, "omega"):
        Set explanation to explanation + "ω (omega) symbol detected. Use 'Math.Physics.angular_frequency' or import from Math.Symbols.Greek."
    Otherwise If contains_text(symbol_error, "Ω") or contains_text(symbol_error, "Omega"):
        Set explanation to explanation + "Ω (Omega) symbol detected. Import from Math.Symbols.Greek for mathematical contexts."
    Otherwise:
        Set explanation to explanation + "Unrecognized Greek symbol. Ensure you import Greek symbols from 'Math.Symbols.Greek' module or use ASCII equivalents."
    End If
    
    Note: Add general guidance for Greek symbol usage
    Set explanation to explanation + " Greek symbols require explicit imports in Runa. Consider using 'Use Math.Symbols.Greek' at the top of your file."
    
    Note: Add encoding information if relevant
    If contains_text(symbol_error, "encoding") or contains_text(symbol_error, "unicode"):
        Set explanation to explanation + " Ensure your source file is saved with UTF-8 encoding to support Unicode mathematical symbols."
    End If
    
    Return explanation

Process called "suggest_mathematical_corrections" that takes engine as DiagnosticEngine, math_error as String returns List[String]:
    @Implementation
    Generate specific correction suggestions for mathematical expression errors based on error analysis.
    Provides actionable recommendations for common mathematical syntax and semantic issues.
    @End Implementation
    
    Let suggestions be List[String]
    
    Note: Analyze error type and provide targeted suggestions
    If contains_text(math_error, "undefined") or contains_text(math_error, "not found"):
        List.append(suggestions, "Import required mathematical functions: 'Use Math.Core', 'Use Math.Functions', 'Use Math.Constants'")
        List.append(suggestions, "Check spelling of mathematical function names")
        List.append(suggestions, "Verify function exists in the imported mathematical modules")
    End If
    
    Note: Handle operator precedence issues
    If contains_text(math_error, "precedence") or contains_text(math_error, "operator"):
        List.append(suggestions, "Add explicit parentheses to clarify operator precedence")
        List.append(suggestions, "Check mathematical operator usage: +, -, *, /, ^, mod")
        List.append(suggestions, "Import mathematical operators: 'Use Math.Operators'")
        List.append(suggestions, "Use parentheses around complex expressions: (a + b) * c")
    End If
    
    Note: Handle type mismatch in mathematical operations
    If contains_text(math_error, "type") or contains_text(math_error, "mismatch"):
        List.append(suggestions, "Ensure all operands are numeric types (Integer, Float, Complex)")
        List.append(suggestions, "Use explicit type conversion: Float.from_integer(), Integer.truncate()")
        List.append(suggestions, "Check function parameter types match expected mathematical types")
        List.append(suggestions, "Consider using generic mathematical functions that handle multiple types")
    End If
    
    Note: Handle Greek symbol and Unicode issues
    If contains_text(math_error, "symbol") or contains_text(math_error, "greek") or contains_text(math_error, "unicode"):
        List.append(suggestions, "Import Greek symbols: 'Use Math.Symbols.Greek'")
        List.append(suggestions, "Use ASCII equivalents: 'pi' instead of 'π', 'alpha' instead of 'α'")
        List.append(suggestions, "Ensure source file encoding is UTF-8")
        List.append(suggestions, "Use mathematical constants: Math.Constants.PI, Math.Constants.E")
    End If
    
    Note: Handle function call and syntax issues
    If contains_text(math_error, "syntax") or contains_text(math_error, "call") or contains_text(math_error, "argument"):
        List.append(suggestions, "Check function call syntax: func_name(arg1, arg2)")
        List.append(suggestions, "Verify correct number of arguments for mathematical functions")
        List.append(suggestions, "Use proper mathematical function namespace: Math.Trigonometry.sin(x)")
        List.append(suggestions, "Check for missing commas in function parameter lists")
    End If
    
    Note: Handle expression parsing issues
    If contains_text(math_error, "expression") or contains_text(math_error, "parse"):
        List.append(suggestions, "Check for balanced parentheses and brackets in expressions")
        List.append(suggestions, "Verify mathematical expression syntax follows Runa grammar")
        List.append(suggestions, "Break complex expressions into smaller, clearer sub-expressions")
        List.append(suggestions, "Use temporary variables for intermediate calculations")
    End If
    
    Note: Handle constant and literal issues
    If contains_text(math_error, "constant") or contains_text(math_error, "literal"):
        List.append(suggestions, "Use proper numeric literal syntax: 3.14, 42, 1.5e-10")
        List.append(suggestions, "Import mathematical constants: 'Use Math.Constants'")
        List.append(suggestions, "Check for proper decimal point usage with Float literals")
        List.append(suggestions, "Use scientific notation for very large/small numbers: 1.23e6")
    End If
    
    Note: Handle domain and range errors
    If contains_text(math_error, "domain") or contains_text(math_error, "range") or contains_text(math_error, "overflow"):
        List.append(suggestions, "Check input values are within valid domain for mathematical functions")
        List.append(suggestions, "Handle potential division by zero cases")
        List.append(suggestions, "Use range checking before calling mathematical functions")
        List.append(suggestions, "Consider using arbitrary precision arithmetic for large numbers")
    End If
    
    Note: Handle matrix and vector operations
    If contains_text(math_error, "matrix") or contains_text(math_error, "vector"):
        List.append(suggestions, "Import linear algebra operations: 'Use Math.LinearAlgebra'")
        List.append(suggestions, "Check matrix dimensions are compatible for operations")
        List.append(suggestions, "Use proper matrix/vector construction syntax")
        List.append(suggestions, "Verify element access patterns: matrix[i][j] or vector[i]")
    End If
    
    Note: Provide general mathematical programming advice if no specific patterns matched
    If List.length(suggestions) equals 0:
        List.append(suggestions, "Review mathematical expression for syntax correctness")
        List.append(suggestions, "Check that all mathematical modules are properly imported")
        List.append(suggestions, "Verify variable names and function calls are spelled correctly")
        List.append(suggestions, "Consider simplifying complex mathematical expressions")
        List.append(suggestions, "Consult Runa mathematical library documentation")
    End If
    
    Return suggestions

Note: =====================================================================
Note: DIAGNOSTIC FORMATTING OPERATIONS
Note: =====================================================================

Process called "format_diagnostic_message" that takes engine as DiagnosticEngine, diagnostic as Diagnostic, format_style as String returns String:
    @Implementation
    Format diagnostic message according to specified style (compact, detailed, json, etc.).
    Includes severity, location, message, and optional context information.
    @End Implementation
    
    Let formatted_message be ""
    
    Note: Format based on requested style
    If format_style equals "compact":
        Note: Compact format: severity:file:line:column:message
        Set formatted_message to diagnostic.severity + ":"
        Set formatted_message to formatted_message + diagnostic.location.file_path + ":"
        Set formatted_message to formatted_message + integer_to_string(Dictionary.get(diagnostic.location, "line_number"))
        Set formatted_message to formatted_message + ":" + integer_to_string(Dictionary.get(diagnostic.location, "column_number"))
        Set formatted_message to formatted_message + ":" + diagnostic.message
    Otherwise If format_style equals "detailed":
        Note: Detailed multi-line format with full context
        Set formatted_message to "[" + diagnostic.severity.to_upper() + "] " + diagnostic.message + "\n"
        Set formatted_message to formatted_message + "  Location: " + diagnostic.location.file_path
        Set formatted_message to formatted_message + " at line " + integer_to_string(Dictionary.get(diagnostic.location, "line_number"))
        Set formatted_message to formatted_message + ", column " + integer_to_string(Dictionary.get(diagnostic.location, "column_number")) + "\n"
        Set formatted_message to formatted_message + "  Category: " + diagnostic.category + "\n"
        Set formatted_message to formatted_message + "  Error Code: " + diagnostic.error_code
        If diagnostic.additional_context not equals "":
            Set formatted_message to formatted_message + "\n  Context: " + diagnostic.additional_context
        End If
    Otherwise If format_style equals "json":
        Note: JSON format for programmatic consumption
        Set formatted_message to "{"
        Set formatted_message to formatted_message + "\"severity\":\"" + diagnostic.severity + "\","
        Set formatted_message to formatted_message + "\"message\":\"" + escape_json_string(diagnostic.message) + "\","
        Set formatted_message to formatted_message + "\"file\":\"" + escape_json_string(diagnostic.location.file_path) + "\","
        Set formatted_message to formatted_message + "\"line\":" + integer_to_string(Dictionary.get(diagnostic.location, "line_number")) + ","
        Set formatted_message to formatted_message + "\"column\":" + integer_to_string(Dictionary.get(diagnostic.location, "column_number")) + ","
        Set formatted_message to formatted_message + "\"category\":\"" + diagnostic.category + "\","
        Set formatted_message to formatted_message + "\"errorCode\":\"" + diagnostic.error_code + "\""
        Set formatted_message to formatted_message + "}"
    Otherwise If format_style equals "vscode":
        Note: Visual Studio Code format for IDE integration
        Set formatted_message to diagnostic.location.file_path
        Set formatted_message to formatted_message + "(" + integer_to_string(Dictionary.get(diagnostic.location, "line_number"))
        Set formatted_message to formatted_message + "," + integer_to_string(Dictionary.get(diagnostic.location, "column_number")) + "): "
        Set formatted_message to formatted_message + diagnostic.severity + " " + diagnostic.error_code + ": " + diagnostic.message
    Otherwise If format_style equals "gcc":
        Note: GCC-style format for compatibility with build tools
        Set formatted_message to diagnostic.location.file_path + ":"
        Set formatted_message to formatted_message + integer_to_string(Dictionary.get(diagnostic.location, "line_number")) + ":"
        Set formatted_message to formatted_message + integer_to_string(Dictionary.get(diagnostic.location, "column_number")) + ": "
        Set formatted_message to formatted_message + diagnostic.severity + ": " + diagnostic.message
    Otherwise:
        Note: Default format - clean and readable
        Set formatted_message to diagnostic.severity.to_upper() + ": " + diagnostic.message
        Set formatted_message to formatted_message + " [" + diagnostic.location.file_path
        Set formatted_message to formatted_message + ":" + integer_to_string(Dictionary.get(diagnostic.location, "line_number")) + "]"
    End If
    
    Return formatted_message

Process called "add_source_context" that takes engine as DiagnosticEngine, diagnostic as Diagnostic, context_lines as Integer returns String:
    @Implementation
    Add source code context around the error location, showing specified number of lines
    before and after the error line with line numbers for reference.
    @End Implementation
    
    Let context_output be ""
    Let error_line be Dictionary.get(diagnostic.location, "line_number")
    Let error_column be Dictionary.get(diagnostic.location, "column_number")
    Let file_path be diagnostic.location.file_path
    
    Note: Validate context_lines parameter
    Let safe_context_lines be context_lines
    If safe_context_lines is less than 0:
        Set safe_context_lines to 2  Note: Default to 2 lines of context
    End If
    If safe_context_lines is greater than 10:
        Set safe_context_lines to 10  Note: Cap at 10 lines for readability
    End If
    
    Note: Calculate line range to display
    Let start_line be error_line - safe_context_lines
    If start_line is less than 1:
        Set start_line to 1  Note: Cannot go before first line
    End If
    Let end_line be error_line + safe_context_lines
    
    Note: Read source file content using engine's source context
    Let source_lines be read_source_file_lines(engine, file_path, start_line, end_line)
    
    Note: Build context display with line numbers and error highlighting
    Set context_output to "\nSource context:\n"
    Let line_num_width be calculate_line_number_width(end_line)
    
    For current_line from start_line to end_line:
        Let line_content be get_line_content(source_lines, current_line - start_line)
        Let line_prefix be format_line_number(current_line, line_num_width)
        
        Note: Mark the error line with an indicator
        If current_line equals error_line:
            Set context_output to context_output + line_prefix + " > " + line_content + "\n"
            Note: Add column indicator on next line
            Set context_output to context_output + create_column_indicator(line_num_width + 3, error_column) + "\n"
        Otherwise:
            Set context_output to context_output + line_prefix + "   " + line_content + "\n"
        End If
    End For
    
    Return context_output

Process called "highlight_error_location" that takes engine as DiagnosticEngine, diagnostic as Diagnostic, highlight_style as String returns String:
    @Implementation
    Highlight the specific error location in source code using various styles
    (ANSI colors, HTML, plain text markers, etc.) for different output contexts.
    @End Implementation
    
    Let error_line be Dictionary.get(diagnostic.location, "line_number")
    Let error_column be Dictionary.get(diagnostic.location, "column_number")
    Let file_path be diagnostic.location.file_path
    
    Note: Get the source line containing the error
    Let source_lines be read_source_file_lines(engine, file_path, error_line, error_line)
    Let error_line_content be get_line_content(source_lines, 0)
    
    Let highlighted_output be ""
    
    Note: Apply highlighting based on requested style
    If highlight_style equals "ansi":
        Note: ANSI color codes for terminal output
        Let line_prefix be integer_to_string(error_line) + " | "
        Set highlighted_output to line_prefix + error_line_content + "\n"
        
        Note: Create underline using ANSI red color
        Let spaces_count be String.length(line_prefix) + error_column - 1
        Let underline_spaces be create_repeated_string(" ", spaces_count)
        Set highlighted_output to highlighted_output + underline_spaces + "\033[31m^\033[0m\n"
        
    Otherwise If highlight_style equals "html":
        Note: HTML markup for web display
        Let before_error be String.substring(error_line_content, 0, error_column - 1)
        Let error_char be String.char_at(error_line_content, error_column - 1)
        Let after_error be String.substring(error_line_content, error_column, String.length(error_line_content))
        
        Set highlighted_output to "<div class=\"source-line\">"
        Set highlighted_output to highlighted_output + "<span class=\"line-number\">" + integer_to_string(error_line) + "</span> | "
        Set highlighted_output to highlighted_output + escape_html_string(before_error)
        Set highlighted_output to highlighted_output + "<span class=\"error-highlight\">" + escape_html_string(integer_to_string(error_char)) + "</span>"
        Set highlighted_output to highlighted_output + escape_html_string(after_error)
        Set highlighted_output to highlighted_output + "</div>"
        
    Otherwise If highlight_style equals "caret":
        Note: Simple caret (^) pointing to error location
        Let line_display be integer_to_string(error_line) + " | " + error_line_content + "\n"
        Let caret_spaces be String.length(integer_to_string(error_line)) + 3 + error_column - 1
        Let caret_line be create_repeated_string(" ", caret_spaces) + "^"
        Set highlighted_output to line_display + caret_line + "\n"
        
    Otherwise If highlight_style equals "brackets":
        Note: Surround error location with brackets for clear visibility
        If error_column is greater than String.length(error_line_content):
            Set highlighted_output to integer_to_string(error_line) + " | " + error_line_content + " [<-- ERROR]"
        Otherwise:
            Let before_error be String.substring(error_line_content, 0, error_column - 1)
            Let error_char be String.char_at(error_line_content, error_column - 1)
            Let after_error be String.substring(error_line_content, error_column, String.length(error_line_content))
            Set highlighted_output to integer_to_string(error_line) + " | " + before_error + "[" + integer_to_string(error_char) + "]" + after_error
        End If
        
    Otherwise If highlight_style equals "arrows":
        Note: Use arrow characters to point to error location
        Let line_display be integer_to_string(error_line) + " | " + error_line_content + "\n"
        Let arrow_spaces be String.length(integer_to_string(error_line)) + 3 + error_column - 1
        Let arrow_line be create_repeated_string(" ", arrow_spaces) + "↑ ERROR HERE"
        Set highlighted_output to line_display + arrow_line + "\n"
        
    Otherwise:
        Note: Default plain text highlighting with simple markers
        Let line_display be integer_to_string(error_line) + " | " + error_line_content + "\n"
        Let marker_spaces be String.length(integer_to_string(error_line)) + 3 + error_column - 1
        Let marker_line be create_repeated_string(" ", marker_spaces) + "^ here"
        Set highlighted_output to line_display + marker_line + "\n"
    End If
    
    Return highlighted_output

Process called "format_diagnostic_report" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic], report_style as String returns String:
    @Implementation
    Format a comprehensive report of multiple diagnostics with summary statistics,
    grouping by severity/category, and appropriate styling for the target context.
    @End Implementation
    
    Let report_output be ""
    Let total_diagnostics be List.length(diagnostics)
    
    Note: Handle empty diagnostics case
    If total_diagnostics equals 0:
        Return "No diagnostics to report."
    End If
    
    Note: Build report based on requested style
    If report_style equals "summary":
        Note: Brief summary report with counts and most critical errors
        Let error_count be count_diagnostics_by_severity(diagnostics, "error")
        Let warning_count be count_diagnostics_by_severity(diagnostics, "warning")
        Let info_count be count_diagnostics_by_severity(diagnostics, "info")
        
        Set report_output to "Diagnostic Summary:\n"
        Set report_output to report_output + "  Errors: " + integer_to_string(error_count) + "\n"
        Set report_output to report_output + "  Warnings: " + integer_to_string(warning_count) + "\n"
        Set report_output to report_output + "  Info: " + integer_to_string(info_count) + "\n"
        Set report_output to report_output + "  Total: " + integer_to_string(total_diagnostics) + "\n"
        
    Otherwise If report_style equals "detailed":
        Note: Detailed report with full diagnostic information
        Set report_output to "=== DIAGNOSTIC REPORT ===\n"
        Set report_output to report_output + "Generated: " + get_current_timestamp_string() + "\n"
        Set report_output to report_output + "Total Diagnostics: " + integer_to_string(total_diagnostics) + "\n\n"
        
        Note: Group by severity and display
        Let severity_groups be group_diagnostics_by_severity(diagnostics)
        Set report_output to report_output + format_grouped_diagnostics(engine, severity_groups, "detailed")
        
    Otherwise If report_style equals "json":
        Note: JSON format for programmatic consumption
        Set report_output to "{\n"
        Set report_output to report_output + "  \"timestamp\": \"" + get_current_timestamp_string() + "\",\n"
        Set report_output to report_output + "  \"total\": " + integer_to_string(total_diagnostics) + ",\n"
        Set report_output to report_output + "  \"diagnostics\": [\n"
        
        For i from 0 to (total_diagnostics - 1):
            Let diagnostic be diagnostics[i]
            Let diagnostic_json be format_diagnostic_message(engine, diagnostic, "json")
            Set report_output to report_output + "    " + diagnostic_json
            If i is less than (total_diagnostics - 1):
                Set report_output to report_output + ","
            End If
            Set report_output to report_output + "\n"
        End For
        
        Set report_output to report_output + "  ]\n}"
        
    Otherwise If report_style equals "compiler":
        Note: Compiler-style output similar to GCC/Clang
        For i from 0 to (total_diagnostics - 1):
            Let diagnostic be diagnostics[i]
            Let formatted_diagnostic be format_diagnostic_message(engine, diagnostic, "gcc")
            Set report_output to report_output + formatted_diagnostic + "\n"
        End For
        
        Note: Add summary line
        Let error_count be count_diagnostics_by_severity(diagnostics, "error")
        Let warning_count be count_diagnostics_by_severity(diagnostics, "warning")
        Set report_output to report_output + "\n"
        If error_count is greater than 0:
            Set report_output to report_output + integer_to_string(error_count) + " error(s)"
            If warning_count is greater than 0:
                Set report_output to report_output + ", " + integer_to_string(warning_count) + " warning(s)"
            End If
        Otherwise If warning_count is greater than 0:
            Set report_output to report_output + integer_to_string(warning_count) + " warning(s)"
        End If
        Set report_output to report_output + " generated."
        
    Otherwise:
        Note: Default readable format
        Set report_output to "Diagnostic Report (" + integer_to_string(total_diagnostics) + " items):\n\n"
        
        For i from 0 to (total_diagnostics - 1):
            Let diagnostic be diagnostics[i]
            Let formatted_diagnostic be format_diagnostic_message(engine, diagnostic, "default")
            Set report_output to report_output + integer_to_string(i + 1) + ". " + formatted_diagnostic + "\n"
            
            Note: Add suggestions if available
            Let suggestions_count be List.length(diagnostic.suggestions)
            If suggestions_count is greater than 0:
                Set report_output to report_output + "   Suggestions:\n"
                For j from 0 to (suggestions_count - 1):
                    Let suggestion be diagnostic.suggestions[j]
                    Set report_output to report_output + "   - " + suggestion + "\n"
                End For
            End If
            Set report_output to report_output + "\n"
        End For
    End If
    
    Return report_output

Note: =====================================================================
Note: DIAGNOSTIC ANALYSIS OPERATIONS
Note: =====================================================================

Process called "analyze_error_patterns" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic] returns Dictionary[String, Integer]:
    @Implementation
    Analyze diagnostics to identify common error patterns and their frequencies.
    This helps identify systemic issues in code and improve error prevention strategies.
    @End Implementation
    
    Let pattern_counts be Dictionary[String, Integer]
    Let total_diagnostics be List.length(diagnostics)
    
    Note: Initialize pattern tracking
    Dictionary.set(pattern_counts, "syntax_errors", 0)
    Dictionary.set(pattern_counts, "type_mismatches", 0)
    Dictionary.set(pattern_counts, "undefined_symbols", 0)
    Dictionary.set(pattern_counts, "import_errors", 0)
    Dictionary.set(pattern_counts, "mathematical_errors", 0)
    Dictionary.set(pattern_counts, "semantic_errors", 0)
    Dictionary.set(pattern_counts, "lexical_errors", 0)
    Dictionary.set(pattern_counts, "missing_declarations", 0)
    Dictionary.set(pattern_counts, "scope_violations", 0)
    Dictionary.set(pattern_counts, "operator_errors", 0)
    
    Note: Analyze each diagnostic for patterns
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be diagnostics[i]
        
        Note: Analyze by category
        If diagnostic.category equals "syntax" or diagnostic.category equals "parsing":
            Let current_count be Dictionary.get(pattern_counts, "syntax_errors")
            Dictionary.set(pattern_counts, "syntax_errors", current_count + 1)
        End If
        
        If diagnostic.category equals "type" or contains_text(diagnostic.message, "type"):
            Let current_count be Dictionary.get(pattern_counts, "type_mismatches")
            Dictionary.set(pattern_counts, "type_mismatches", current_count + 1)
        End If
        
        If contains_text(diagnostic.message, "undefined") or contains_text(diagnostic.message, "not found"):
            Let current_count be Dictionary.get(pattern_counts, "undefined_symbols")
            Dictionary.set(pattern_counts, "undefined_symbols", current_count + 1)
        End If
        
        If contains_text(diagnostic.message, "import") or contains_text(diagnostic.message, "module"):
            Let current_count be Dictionary.get(pattern_counts, "import_errors")
            Dictionary.set(pattern_counts, "import_errors", current_count + 1)
        End If
        
        If diagnostic.category equals "mathematical" or contains_text(diagnostic.message, "math"):
            Let current_count be Dictionary.get(pattern_counts, "mathematical_errors")
            Dictionary.set(pattern_counts, "mathematical_errors", current_count + 1)
        End If
        
        If diagnostic.category equals "semantic":
            Let current_count be Dictionary.get(pattern_counts, "semantic_errors")
            Dictionary.set(pattern_counts, "semantic_errors", current_count + 1)
        End If
        
        If diagnostic.category equals "lexical" or diagnostic.category equals "tokenization":
            Let current_count be Dictionary.get(pattern_counts, "lexical_errors")
            Dictionary.set(pattern_counts, "lexical_errors", current_count + 1)
        End If
        
        If contains_text(diagnostic.message, "declaration") or contains_text(diagnostic.message, "missing"):
            Let current_count be Dictionary.get(pattern_counts, "missing_declarations")
            Dictionary.set(pattern_counts, "missing_declarations", current_count + 1)
        End If
        
        If contains_text(diagnostic.message, "scope") or contains_text(diagnostic.message, "visibility"):
            Let current_count be Dictionary.get(pattern_counts, "scope_violations")
            Dictionary.set(pattern_counts, "scope_violations", current_count + 1)
        End If
        
        If contains_text(diagnostic.message, "operator") or contains_text(diagnostic.message, "precedence"):
            Let current_count be Dictionary.get(pattern_counts, "operator_errors")
            Dictionary.set(pattern_counts, "operator_errors", current_count + 1)
        End If
    End For
    
    Note: Add additional metadata about the analysis
    Dictionary.set(pattern_counts, "total_analyzed", total_diagnostics)
    Dictionary.set(pattern_counts, "analysis_timestamp", get_current_timestamp())
    
    Return pattern_counts

Process called "detect_cascading_errors" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic] returns List[String]:
    @Implementation
    Detect errors that are likely caused by other primary errors. This helps prioritize
    error fixing by identifying which errors to fix first to resolve multiple issues.
    @End Implementation
    
    Let cascading_error_ids be List[String]
    Let total_diagnostics be List.length(diagnostics)
    
    Note: If we have fewer than 2 diagnostics, no cascading is possible
    If total_diagnostics is less than 2:
        Return cascading_error_ids
    End If
    
    Note: Analyze each diagnostic to see if it might be caused by others
    For i from 0 to (total_diagnostics - 1):
        Let current_diagnostic be diagnostics[i]
        Let is_cascading_error be false
        
        Note: Check for common cascading error patterns
        For j from 0 to (total_diagnostics - 1):
            If i equals j:
                Continue  Note: Don't compare diagnostic to itself
            End If
            
            Let potential_cause be diagnostics[j]
            
            Note: Check if current error might be caused by potential_cause
            Note: Undefined symbol errors often cascade from import/declaration errors
            If contains_text(current_diagnostic.message, "undefined") or contains_text(current_diagnostic.message, "not found"):
                If contains_text(potential_cause.message, "import") or contains_text(potential_cause.message, "declaration"):
                    Note: Check if they involve related symbols
                    If diagnostics_share_symbol_context(current_diagnostic, potential_cause):
                        Set is_cascading_error to true
                        Break
                    End If
                End If
            End If
            
            Note: Type errors often cascade from undefined symbols
            If contains_text(current_diagnostic.message, "type") and contains_text(current_diagnostic.message, "mismatch"):
                If contains_text(potential_cause.message, "undefined") or contains_text(potential_cause.message, "not found"):
                    Note: Check if they're in the same scope/location
                    If diagnostics_in_same_scope(current_diagnostic, potential_cause):
                        Set is_cascading_error to true
                        Break
                    End If
                End If
            End If
            
            Note: Syntax errors can cascade from lexical errors
            If current_diagnostic.category equals "syntax":
                If potential_cause.category equals "lexical":
                    Note: Check if they're close in location
                    If diagnostics_close_in_location(current_diagnostic, potential_cause):
                        Set is_cascading_error to true
                        Break
                    End If
                End If
            End If
            
            Note: Function call errors often cascade from function declaration errors
            If contains_text(current_diagnostic.message, "call") or contains_text(current_diagnostic.message, "argument"):
                If contains_text(potential_cause.message, "function") and contains_text(potential_cause.message, "declaration"):
                    If diagnostics_share_function_context(current_diagnostic, potential_cause):
                        Set is_cascading_error to true
                        Break
                    End If
                End If
            End If
            
            Note: Mathematical errors often cascade from missing imports
            If current_diagnostic.category equals "mathematical":
                If contains_text(potential_cause.message, "import") and contains_text(potential_cause.message, "Math"):
                    Set is_cascading_error to true
                    Break
                End If
            End If
        End For
        
        Note: If this diagnostic is identified as cascading, add its ID
        If is_cascading_error:
            List.append(cascading_error_ids, current_diagnostic.error_code)
        End If
    End For
    
    Return cascading_error_ids

Process called "identify_root_cause" that takes engine as DiagnosticEngine, error_chain as List[Diagnostic] returns Diagnostic:
    @Implementation
    Identify the root cause diagnostic from a chain of related errors. The root cause is
    typically the earliest error that triggered subsequent cascading errors.
    @End Implementation
    
    Let chain_length be List.length(error_chain)
    
    Note: Handle edge cases
    If chain_length equals 0:
        Return create_null_diagnostic()  Note: No errors to analyze
    End If
    
    If chain_length equals 1:
        Return error_chain[0]  Note: Single error is its own root cause
    End If
    
    Let root_cause be error_chain[0]  Note: Default to first error
    Let highest_priority be 0
    
    Note: Analyze each error in the chain to find the true root cause
    For i from 0 to (chain_length - 1):
        Let current_error be error_chain[i]
        Let priority_score be calculate_root_cause_priority(current_error)
        
        Note: Higher priority score indicates more likely to be root cause
        If priority_score is greater than highest_priority:
            Set highest_priority to priority_score
            Set root_cause to current_error
        End If
    End For
    
    Note: Validate that identified root cause is actually causal
    If is_valid_root_cause(root_cause, error_chain):
        Return root_cause
    Otherwise:
        Note: Fallback to earliest error by timestamp/location
        Return find_earliest_error(error_chain)
    End If

Process called "measure_diagnostic_quality" that takes engine as DiagnosticEngine, diagnostic as Diagnostic returns Float:
    @Implementation
    Measure the quality and usefulness of a diagnostic based on clarity of message,
    accuracy of location, availability of suggestions, and context information.
    Returns score from 0.0 (poor) to 1.0 (excellent).
    @End Implementation
    
    Let quality_score be 0.0
    Let max_possible_score be 100.0
    Let current_score be 0.0
    
    Note: Evaluate message clarity and informativeness (25 points max)
    Let message_length be String.length(diagnostic.message)
    If message_length is greater than 10 and message_length is less than 200:
        Set current_score to current_score + 15.0  Note: Good message length
    Otherwise If message_length is greater than 200:
        Set current_score to current_score + 10.0  Note: Too verbose
    Otherwise:
        Set current_score to current_score + 5.0   Note: Too brief
    End If
    
    Note: Check for meaningful error message content
    If not contains_text(diagnostic.message, "error") and not contains_text(diagnostic.message, "unknown"):
        Set current_score to current_score + 10.0  Note: Specific error message
    End If
    
    Note: Evaluate location accuracy (20 points max)
    If diagnostic.location.file_path not equals "":
        Set current_score to current_score + 10.0  Note: File path provided
    End If
    
    Let line_number be Dictionary.get(diagnostic.location, "line_number")
    Let column_number be Dictionary.get(diagnostic.location, "column_number")
    If line_number is greater than 0 and column_number is greater than 0:
        Set current_score to current_score + 10.0  Note: Precise location
    End If
    
    Note: Evaluate availability of suggestions (25 points max)
    Let suggestions_count be List.length(diagnostic.suggestions)
    If suggestions_count is greater than 0:
        Set current_score to current_score + 15.0  Note: Has suggestions
        If suggestions_count is greater than 2:
            Set current_score to current_score + 5.0  Note: Multiple suggestions
        End If
        If suggestions_count is less than 6:
            Set current_score to current_score + 5.0  Note: Not too many suggestions
        End If
    End If
    
    Note: Evaluate context and metadata completeness (15 points max)
    If diagnostic.category not equals "":
        Set current_score to current_score + 5.0  Note: Category specified
    End If
    
    If diagnostic.error_code not equals "":
        Set current_score to current_score + 5.0  Note: Error code provided
    End If
    
    If diagnostic.additional_context not equals "":
        Set current_score to current_score + 5.0  Note: Additional context provided
    End If
    
    Note: Evaluate severity appropriateness (10 points max)
    If diagnostic.severity equals "error" or diagnostic.severity equals "warning" or diagnostic.severity equals "info":
        Set current_score to current_score + 10.0  Note: Valid severity level
    End If
    
    Note: Evaluate source context availability (5 points max)
    If diagnostic.source_context not equals "":
        Set current_score to current_score + 5.0  Note: Source context provided
    End If
    
    Note: Calculate final quality score as percentage
    Set quality_score to current_score / max_possible_score
    
    Note: Ensure score stays within bounds
    If quality_score is greater than 1.0:
        Set quality_score to 1.0
    End If
    If quality_score is less than 0.0:
        Set quality_score to 0.0
    End If
    
    Return quality_score

Note: =====================================================================
Note: INTEGRATION OPERATIONS
Note: =====================================================================

Process called "integrate_with_lexer" that takes engine as DiagnosticEngine, lexer_interface as String returns Boolean:
    @Implementation
    Integrate diagnostic engine with the lexer component to enable automatic
    collection of lexical analysis errors and real-time diagnostic generation.
    @End Implementation
    
    Note: Validate lexer interface parameter
    If lexer_interface equals "":
        Return false  Note: Invalid interface specification
    End If
    
    Note: Set up lexer integration based on interface type
    If lexer_interface equals "standard":
        Note: Standard integration with built-in lexer
        Set engine.lexer_integration_enabled to true
        Set engine.lexer_interface_type to "standard"
        Set engine.lexer_callback_function to "collect_lexical_diagnostics"
        
    Otherwise If lexer_interface equals "streaming":
        Note: Streaming integration for real-time tokenization
        Set engine.lexer_integration_enabled to true
        Set engine.lexer_interface_type to "streaming"
        Set engine.lexer_callback_function to "process_streaming_lexical_errors"
        Set engine.real_time_processing to true
        
    Otherwise If lexer_interface equals "batch":
        Note: Batch processing integration
        Set engine.lexer_integration_enabled to true
        Set engine.lexer_interface_type to "batch"
        Set engine.lexer_callback_function to "process_batch_lexical_errors"
        
    Otherwise:
        Note: Unsupported interface type
        Return false
    End If
    
    Note: Initialize lexer-specific diagnostic settings
    add_diagnostic_category_mapping(engine, "LEX", "lexical")
    add_diagnostic_category_mapping(engine, "TOK", "tokenization")
    add_diagnostic_category_mapping(engine, "CHR", "character_encoding")
    
    Note: Register lexical error patterns for enhanced processing
    register_error_pattern(engine, "invalid_character", "lexical")
    register_error_pattern(engine, "unterminated_string", "lexical")
    register_error_pattern(engine, "invalid_number_format", "lexical")
    register_error_pattern(engine, "unknown_token", "lexical")
    
    Return true

Process called "integrate_with_parser" that takes engine as DiagnosticEngine, parser_interface as String returns Boolean:
    @Implementation
    Integrate diagnostic engine with the parser component to collect syntax errors,
    grammar violations, and parsing issues during compilation.
    @End Implementation
    
    Note: Validate parser interface parameter
    If parser_interface equals "":
        Return false  Note: Invalid interface specification
    End If
    
    Note: Set up parser integration based on interface type
    If parser_interface equals "standard":
        Note: Standard recursive descent parser integration
        Set engine.parser_integration_enabled to true
        Set engine.parser_interface_type to "standard"
        Set engine.parser_callback_function to "collect_parsing_diagnostics"
        
    Otherwise If parser_interface equals "error_recovery":
        Note: Error recovery parser with enhanced diagnostics
        Set engine.parser_integration_enabled to true
        Set engine.parser_interface_type to "error_recovery"
        Set engine.parser_callback_function to "collect_parsing_diagnostics_with_recovery"
        Set engine.error_recovery_enabled to true
        
    Otherwise If parser_interface equals "incremental":
        Note: Incremental parsing for IDE integration
        Set engine.parser_integration_enabled to true
        Set engine.parser_interface_type to "incremental"
        Set engine.parser_callback_function to "collect_incremental_parsing_diagnostics"
        Set engine.incremental_parsing_enabled to true
        
    Otherwise If parser_interface equals "lalr":
        Note: LALR parser integration
        Set engine.parser_integration_enabled to true
        Set engine.parser_interface_type to "lalr"
        Set engine.parser_callback_function to "collect_lalr_parsing_diagnostics"
        
    Otherwise:
        Note: Unsupported parser interface type
        Return false
    End If
    
    Note: Initialize parser-specific diagnostic settings
    add_diagnostic_category_mapping(engine, "SYN", "syntax")
    add_diagnostic_category_mapping(engine, "GRM", "grammar")
    add_diagnostic_category_mapping(engine, "PAR", "parsing")
    add_diagnostic_category_mapping(engine, "AST", "ast_construction")
    
    Note: Register parsing error patterns
    register_error_pattern(engine, "unexpected_token", "syntax")
    register_error_pattern(engine, "missing_token", "syntax")
    register_error_pattern(engine, "malformed_expression", "syntax")
    register_error_pattern(engine, "unbalanced_brackets", "syntax")
    register_error_pattern(engine, "invalid_statement", "grammar")
    register_error_pattern(engine, "incomplete_declaration", "grammar")
    
    Note: Set parser-specific configuration
    Set engine.syntax_error_recovery_limit to 10
    Set engine.parse_error_context_lines to 3
    
    Return true

Process called "integrate_with_semantic_analyzer" that takes engine as DiagnosticEngine, analyzer_interface as String returns Boolean:
    @Implementation
    Integrate diagnostic engine with the semantic analyzer to collect type checking,
    symbol resolution, and semantic validation errors.
    @End Implementation
    
    Note: Validate analyzer interface parameter
    If analyzer_interface equals "":
        Return false  Note: Invalid interface specification
    End If
    
    Note: Set up semantic analyzer integration
    If analyzer_interface equals "type_checker":
        Set engine.semantic_integration_enabled to true
        Set engine.semantic_interface_type to "type_checker"
        Set engine.semantic_callback_function to "collect_semantic_diagnostics"
        
    Otherwise If analyzer_interface equals "symbol_resolver":
        Set engine.semantic_integration_enabled to true
        Set engine.semantic_interface_type to "symbol_resolver"
        Set engine.semantic_callback_function to "collect_symbol_resolution_diagnostics"
        
    Otherwise If analyzer_interface equals "full_semantic":
        Set engine.semantic_integration_enabled to true
        Set engine.semantic_interface_type to "full_semantic"
        Set engine.semantic_callback_function to "collect_full_semantic_diagnostics"
        Set engine.type_checking_enabled to true
        Set engine.symbol_resolution_enabled to true
        Set engine.flow_analysis_enabled to true
        
    Otherwise:
        Return false  Note: Unsupported analyzer interface
    End If
    
    Note: Initialize semantic-specific diagnostic categories
    add_diagnostic_category_mapping(engine, "SEM", "semantic")
    add_diagnostic_category_mapping(engine, "TYP", "type_checking")
    add_diagnostic_category_mapping(engine, "SYM", "symbol_resolution")
    add_diagnostic_category_mapping(engine, "FLW", "flow_analysis")
    
    Note: Register semantic error patterns
    register_error_pattern(engine, "type_mismatch", "semantic")
    register_error_pattern(engine, "undefined_symbol", "semantic")
    register_error_pattern(engine, "scope_violation", "semantic")
    register_error_pattern(engine, "unreachable_code", "semantic")
    
    Return true

Process called "integrate_with_suggestion_engine" that takes engine as DiagnosticEngine, suggestion_interface as String returns Boolean:
    @Implementation
    Integrate with suggestion engine to provide automated fix recommendations
    and code improvement suggestions for diagnostics.
    @End Implementation
    
    Note: Validate suggestion interface parameter
    If suggestion_interface equals "":
        Return false  Note: Invalid interface specification
    End If
    
    Note: Set up suggestion engine integration
    If suggestion_interface equals "basic":
        Set engine.suggestion_integration_enabled to true
        Set engine.suggestion_interface_type to "basic"
        Set engine.suggestion_callback_function to "generate_basic_suggestions"
        
    Otherwise If suggestion_interface equals "ai_powered":
        Set engine.suggestion_integration_enabled to true
        Set engine.suggestion_interface_type to "ai_powered"
        Set engine.suggestion_callback_function to "generate_ai_suggestions"
        Set engine.ai_suggestion_enabled to true
        
    Otherwise If suggestion_interface equals "template_based":
        Set engine.suggestion_integration_enabled to true
        Set engine.suggestion_interface_type to "template_based"
        Set engine.suggestion_callback_function to "generate_template_suggestions"
        Set engine.template_suggestion_enabled to true
        
    Otherwise:
        Return false  Note: Unsupported suggestion interface
    End If
    
    Note: Initialize suggestion-specific settings
    Set engine.max_suggestions_per_diagnostic to 5
    Set engine.suggestion_confidence_threshold to 0.7
    Set engine.auto_apply_high_confidence_suggestions to false
    
    Note: Register suggestion providers for common error types
    register_suggestion_provider(engine, "syntax_error", "syntax_fix_suggestions")
    register_suggestion_provider(engine, "type_error", "type_fix_suggestions")
    register_suggestion_provider(engine, "import_error", "import_fix_suggestions")
    register_suggestion_provider(engine, "mathematical_error", "math_fix_suggestions")
    
    Return true

Note: =====================================================================
Note: DIAGNOSTIC FILTERING OPERATIONS
Note: =====================================================================

Process called "filter_diagnostics_by_severity" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic], min_severity as String returns List[Diagnostic]:
    @Implementation
    Filter diagnostics to include only those meeting or exceeding the specified minimum severity level.
    Severity hierarchy: error > warning > info > debug.
    @End Implementation
    
    Let filtered_diagnostics be List[Diagnostic]
    Let total_diagnostics be List.length(diagnostics)
    
    Note: Define severity hierarchy values for comparison
    Let severity_levels be Dictionary[String, Integer]
    Dictionary.set(severity_levels, "error", 4)
    Dictionary.set(severity_levels, "warning", 3)
    Dictionary.set(severity_levels, "info", 2)
    Dictionary.set(severity_levels, "debug", 1)
    
    Note: Get minimum severity level value
    Let min_severity_value be Dictionary.get(severity_levels, min_severity)
    If min_severity_value equals 0:  Note: Invalid severity level
        Return diagnostics  Note: Return all diagnostics if invalid filter
    End If
    
    Note: Filter diagnostics by severity level
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be diagnostics[i]
        Let diagnostic_severity_value be Dictionary.get(severity_levels, diagnostic.severity)
        
        Note: Include diagnostic if it meets minimum severity requirement
        If diagnostic_severity_value is greater than or equal to min_severity_value:
            List.append(filtered_diagnostics, diagnostic)
        End If
    End For
    
    Return filtered_diagnostics

Process called "filter_diagnostics_by_category" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic], categories as List[String] returns List[Diagnostic]:
    @Implementation
    Filter diagnostics to include only those matching the specified categories.
    Supports multiple categories and exact or partial matching.
    @End Implementation
    
    Let filtered_diagnostics be List[Diagnostic]
    Let total_diagnostics be List.length(diagnostics)
    Let filter_categories_count be List.length(categories)
    
    Note: If no categories specified, return all diagnostics
    If filter_categories_count equals 0:
        Return diagnostics
    End If
    
    Note: Filter diagnostics by matching categories
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be diagnostics[i]
        Let include_diagnostic be false
        
        Note: Check if diagnostic matches any of the filter categories
        For j from 0 to (filter_categories_count - 1):
            Let filter_category be categories[j]
            
            Note: Check for exact match or partial match
            If diagnostic.category equals filter_category or contains_text(diagnostic.category, filter_category):
                Set include_diagnostic to true
                Break
            End If
        End For
        
        Note: Include diagnostic if it matches category filter
        If include_diagnostic:
            List.append(filtered_diagnostics, diagnostic)
        End If
    End For
    
    Return filtered_diagnostics

Process called "filter_diagnostics_by_location" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic], location_range as Dictionary[String, Integer] returns List[Diagnostic]:
    @Implementation
    Filter diagnostics to include only those within the specified source location range.
    Location range specified by start_line, end_line, and optional file_path.
    @End Implementation
    
    Let filtered_diagnostics be List[Diagnostic]
    Let total_diagnostics be List.length(diagnostics)
    
    Note: Extract location range parameters
    Let start_line be Dictionary.get(location_range, "start_line")
    Let end_line be Dictionary.get(location_range, "end_line")
    Note: Extract file path parameter (default to empty string if not specified)
    Let target_file be ""
    If Dictionary.contains_key(location_range, "file_path"):
        Set target_file to Dictionary.get(location_range, "file_path")
    End If
    
    Note: Validate location range parameters
    If start_line is less than 1 or end_line is less than start_line:
        Return diagnostics  Note: Invalid range, return all diagnostics
    End If
    
    Note: Filter diagnostics by location range
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be diagnostics[i]
        Let diagnostic_line be Dictionary.get(diagnostic.location, "line_number")
        Let diagnostic_file be diagnostic.location.file_path
        
        Let include_diagnostic be false
        
        Note: Check if diagnostic is within line range
        If diagnostic_line is greater than or equal to start_line and diagnostic_line is less than or equal to end_line:
            Note: If file path specified, check file match too
            If target_file equals "" or diagnostic_file equals target_file:
                Set include_diagnostic to true
            End If
        End If
        
        Note: Include diagnostic if it matches location criteria
        If include_diagnostic:
            List.append(filtered_diagnostics, diagnostic)
        End If
    End For
    
    Return filtered_diagnostics

Process called "apply_diagnostic_suppressions" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic], suppressions as List[String] returns List[Diagnostic]:
    @Implementation
    Apply diagnostic suppressions to filter out diagnostics that have been explicitly
    suppressed in source code comments or configuration.
    @End Implementation
    
    Let filtered_diagnostics be List[Diagnostic]
    Let total_diagnostics be List.length(diagnostics)
    Let suppressions_count be List.length(suppressions)
    
    Note: If no suppressions specified, return all diagnostics
    If suppressions_count equals 0:
        Return diagnostics
    End If
    
    Note: Process each diagnostic and check against suppressions
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be diagnostics[i]
        Let suppress_diagnostic be false
        
        Note: Check if diagnostic should be suppressed
        For j from 0 to (suppressions_count - 1):
            Let suppression be suppressions[j]
            
            Note: Check various suppression patterns
            If suppression equals diagnostic.error_code:  Note: Exact error code match
                Set suppress_diagnostic to true
                Break
            Otherwise If suppression equals diagnostic.category:  Note: Category suppression
                Set suppress_diagnostic to true
                Break
            Otherwise If contains_text(diagnostic.message, suppression):  Note: Message pattern match
                Set suppress_diagnostic to true
                Break
            Otherwise If suppression equals "all" and diagnostic.severity equals "warning":  Note: Suppress all warnings
                Set suppress_diagnostic to true
                Break
            End If
        End For
        
        Note: Include diagnostic only if not suppressed
        If not suppress_diagnostic:
            List.append(filtered_diagnostics, diagnostic)
        End If
    End For
    
    Return filtered_diagnostics

Note: =====================================================================
Note: DIAGNOSTIC EXPORT OPERATIONS
Note: =====================================================================

Process called "export_diagnostics_json" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic] returns String:
    @Implementation
    Export diagnostics collection in JSON format for programmatic consumption
    and integration with development tools and CI/CD systems.
    @End Implementation
    
    Let json_output be "{"
    Let total_diagnostics be List.length(diagnostics)
    
    Note: Add metadata header
    Set json_output to json_output + "\"metadata\":{"
    Set json_output to json_output + "\"timestamp\":\"" + get_current_timestamp_string() + "\","
    Set json_output to json_output + "\"total_diagnostics\":" + integer_to_string(total_diagnostics) + ","
    Set json_output to json_output + "\"export_format\":\"json\","
    Set json_output to json_output + "\"diagnostic_engine_version\":\"1.0\""
    Set json_output to json_output + "},"
    
    Note: Add diagnostics array
    Set json_output to json_output + "\"diagnostics\":["
    
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be diagnostics[i]
        Set json_output to json_output + "{"
        Set json_output to json_output + "\"id\":\"" + diagnostic.error_code + "\","
        Set json_output to json_output + "\"severity\":\"" + diagnostic.severity + "\","
        Set json_output to json_output + "\"message\":\"" + escape_json_string(diagnostic.message) + "\","
        Set json_output to json_output + "\"category\":\"" + diagnostic.category + "\","
        Set json_output to json_output + "\"file\":\"" + escape_json_string(diagnostic.location.file_path) + "\","
        Set json_output to json_output + "\"line\":" + integer_to_string(Dictionary.get(diagnostic.location, "line_number")) + ","
        Set json_output to json_output + "\"column\":" + integer_to_string(Dictionary.get(diagnostic.location, "column_number"))
        
        Note: Add suggestions if available
        Let suggestions_count be List.length(diagnostic.suggestions)
        If suggestions_count is greater than 0:
            Set json_output to json_output + ",\"suggestions\":["
            For j from 0 to (suggestions_count - 1):
                Set json_output to json_output + "\"" + escape_json_string(diagnostic.suggestions[j]) + "\""
                If j is less than (suggestions_count - 1):
                    Set json_output to json_output + ","
                End If
            End For
            Set json_output to json_output + "]"
        End If
        
        Set json_output to json_output + "}"
        If i is less than (total_diagnostics - 1):
            Set json_output to json_output + ","
        End If
    End For
    
    Set json_output to json_output + "]}"
    Return json_output

Process called "export_diagnostics_xml" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic] returns String:
    @Implementation
    Export diagnostics collection in XML format for integration with XML-based
    development tools and reporting systems.
    @End Implementation
    
    Let xml_output be "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
    Let total_diagnostics be List.length(diagnostics)
    
    Note: Add root element with metadata
    Set xml_output to xml_output + "<diagnostics_report>\n"
    Set xml_output to xml_output + "  <metadata>\n"
    Set xml_output to xml_output + "    <timestamp>" + get_current_timestamp_string() + "</timestamp>\n"
    Set xml_output to xml_output + "    <total_diagnostics>" + integer_to_string(total_diagnostics) + "</total_diagnostics>\n"
    Set xml_output to xml_output + "    <export_format>xml</export_format>\n"
    Set xml_output to xml_output + "    <diagnostic_engine_version>1.0</diagnostic_engine_version>\n"
    Set xml_output to xml_output + "  </metadata>\n"
    
    Note: Add diagnostics elements
    Set xml_output to xml_output + "  <diagnostics>\n"
    
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be diagnostics[i]
        Set xml_output to xml_output + "    <diagnostic>\n"
        Set xml_output to xml_output + "      <id>" + diagnostic.error_code + "</id>\n"
        Set xml_output to xml_output + "      <severity>" + diagnostic.severity + "</severity>\n"
        Set xml_output to xml_output + "      <message>" + escape_xml_string(diagnostic.message) + "</message>\n"
        Set xml_output to xml_output + "      <category>" + diagnostic.category + "</category>\n"
        Set xml_output to xml_output + "      <location>\n"
        Set xml_output to xml_output + "        <file>" + escape_xml_string(diagnostic.location.file_path) + "</file>\n"
        Set xml_output to xml_output + "        <line>" + integer_to_string(Dictionary.get(diagnostic.location, "line_number")) + "</line>\n"
        Set xml_output to xml_output + "        <column>" + integer_to_string(Dictionary.get(diagnostic.location, "column_number")) + "</column>\n"
        Set xml_output to xml_output + "      </location>\n"
        
        Note: Add suggestions if available
        Let suggestions_count be List.length(diagnostic.suggestions)
        If suggestions_count is greater than 0:
            Set xml_output to xml_output + "      <suggestions>\n"
            For j from 0 to (suggestions_count - 1):
                Set xml_output to xml_output + "        <suggestion>" + escape_xml_string(diagnostic.suggestions[j]) + "</suggestion>\n"
            End For
            Set xml_output to xml_output + "      </suggestions>\n"
        End If
        
        Set xml_output to xml_output + "    </diagnostic>\n"
    End For
    
    Set xml_output to xml_output + "  </diagnostics>\n"
    Set xml_output to xml_output + "</diagnostics_report>\n"
    
    Return xml_output

Process called "export_diagnostics_sarif" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic] returns String:
    @Implementation
    Export diagnostics in Static Analysis Results Interchange Format (SARIF) v2.1.0
    for integration with security and code analysis tools.
    @End Implementation
    
    Let sarif_output be "{"
    Let total_diagnostics be List.length(diagnostics)
    
    Note: SARIF header with schema version
    Set sarif_output to sarif_output + "\"version\":\"2.1.0\","
    Set sarif_output to sarif_output + "\"$schema\":\"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json\","
    
    Note: Add runs array (SARIF organizes results in "runs")
    Set sarif_output to sarif_output + "\"runs\":[{"
    Set sarif_output to sarif_output + "\"tool\":{"
    Set sarif_output to sarif_output + "\"driver\":{"
    Set sarif_output to sarif_output + "\"name\":\"Runa Diagnostic Engine\","
    Set sarif_output to sarif_output + "\"version\":\"1.0\","
    Set sarif_output to sarif_output + "\"informationUri\":\"https://runa-lang.org/diagnostics\""
    Set sarif_output to sarif_output + "}},"
    
    Note: Add results array
    Set sarif_output to sarif_output + "\"results\":["
    
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be diagnostics[i]
        
        Note: Map severity to SARIF levels
        Let sarif_level be "error"
        If diagnostic.severity equals "warning":
            Set sarif_level to "warning"
        Otherwise If diagnostic.severity equals "info":
            Set sarif_level to "note"
        End If
        
        Set sarif_output to sarif_output + "{"
        Set sarif_output to sarif_output + "\"ruleId\":\"" + diagnostic.error_code + "\","
        Set sarif_output to sarif_output + "\"level\":\"" + sarif_level + "\","
        Set sarif_output to sarif_output + "\"message\":{\"text\":\"" + escape_json_string(diagnostic.message) + "\"},"
        Set sarif_output to sarif_output + "\"locations\":[{"
        Set sarif_output to sarif_output + "\"physicalLocation\":{"
        Set sarif_output to sarif_output + "\"artifactLocation\":{\"uri\":\"" + escape_json_string(diagnostic.location.file_path) + "\"},"
        Set sarif_output to sarif_output + "\"region\":{"
        Set sarif_output to sarif_output + "\"startLine\":" + integer_to_string(Dictionary.get(diagnostic.location, "line_number")) + ","
        Set sarif_output to sarif_output + "\"startColumn\":" + integer_to_string(Dictionary.get(diagnostic.location, "column_number"))
        Set sarif_output to sarif_output + "}}}]"
        
        Note: Add fixes if suggestions are available
        Let suggestions_count be List.length(diagnostic.suggestions)
        If suggestions_count is greater than 0:
            Set sarif_output to sarif_output + ",\"fixes\":["
            For j from 0 to (suggestions_count - 1):
                Set sarif_output to sarif_output + "{\"description\":{\"text\":\"" + escape_json_string(diagnostic.suggestions[j]) + "\"}}"
                If j is less than (suggestions_count - 1):
                    Set sarif_output to sarif_output + ","
                End If
            End For
            Set sarif_output to sarif_output + "]"
        End If
        
        Set sarif_output to sarif_output + "}"
        If i is less than (total_diagnostics - 1):
            Set sarif_output to sarif_output + ","
        End If
    End For
    
    Set sarif_output to sarif_output + "]}]}"
    Return sarif_output

Process called "export_diagnostic_summary" that takes engine as DiagnosticEngine, diagnostics as List[Diagnostic] returns String:
    @Implementation
    Export a comprehensive summary report of diagnostics with statistics,
    categories breakdown, and key insights for management reporting.
    @End Implementation
    
    Let summary_output be "RUNA DIAGNOSTIC SUMMARY REPORT\n"
    Let total_diagnostics be List.length(diagnostics)
    
    Note: Add report header with timestamp
    Set summary_output to summary_output + "Generated: " + get_current_timestamp_string() + "\n"
    Set summary_output to summary_output + "=" + create_repeated_string("=", 60) + "\n\n"
    
    Note: Calculate severity statistics
    Let error_count be count_diagnostics_by_severity(diagnostics, "error")
    Let warning_count be count_diagnostics_by_severity(diagnostics, "warning")
    Let info_count be count_diagnostics_by_severity(diagnostics, "info")
    
    Note: Add overall statistics section
    Set summary_output to summary_output + "OVERALL STATISTICS:\n"
    Set summary_output to summary_output + "  Total Diagnostics: " + integer_to_string(total_diagnostics) + "\n"
    Set summary_output to summary_output + "  Errors:            " + integer_to_string(error_count) + "\n"
    Set summary_output to summary_output + "  Warnings:          " + integer_to_string(warning_count) + "\n"
    Set summary_output to summary_output + "  Informational:     " + integer_to_string(info_count) + "\n\n"
    
    Note: Calculate category breakdown
    Let category_counts be Dictionary[String, Integer]
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be diagnostics[i]
        Let current_count be 0
        If Dictionary.contains_key(category_counts, diagnostic.category):
            Set current_count to Dictionary.get(category_counts, diagnostic.category)
        End If
        Dictionary.set(category_counts, diagnostic.category, current_count + 1)
    End For
    
    Note: Add category breakdown section
    Set summary_output to summary_output + "CATEGORY BREAKDOWN:\n"
    
    Note: Manually iterate over known categories from the original loop
    Let known_categories be List[String]
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be diagnostics[i]
        Let category be diagnostic.category
        
        Note: Add category to list if not already present
        Let category_already_listed be false
        Let known_count be List.length(known_categories)
        For j from 0 to (known_count - 1):
            If known_categories[j] equals category:
                Set category_already_listed to true
                Break
            End If
        End For
        
        If not category_already_listed:
            List.append(known_categories, category)
        End If
    End For
    
    Note: Display counts for each unique category found
    Let unique_categories_count be List.length(known_categories)
    For i from 0 to (unique_categories_count - 1):
        Let category be known_categories[i]
        Let count be Dictionary.get(category_counts, category)
        Set summary_output to summary_output + "  " + category + ": " + integer_to_string(count) + "\n"
    End For
    Set summary_output to summary_output + "\n"
    
    Note: Add quality assessment
    Let avg_quality_score be calculate_average_diagnostic_quality(engine, diagnostics)
    Set summary_output to summary_output + "QUALITY ASSESSMENT:\n"
    Set summary_output to summary_output + "  Average Diagnostic Quality: " + float_to_string(avg_quality_score, 2) + "/1.0\n"
    
    Note: Add recommendations based on analysis
    Set summary_output to summary_output + "\nRECOMMENDations:\n"
    If error_count is greater than warning_count:
        Set summary_output to summary_output + "  - Focus on resolving critical errors first\n"
    End If
    If warning_count is greater than error_count * 2:
        Set summary_output to summary_output + "  - Review warning patterns for code quality improvements\n"
    End If
    If avg_quality_score is less than 0.7:
        Set summary_output to summary_output + "  - Improve diagnostic context and suggestion quality\n"
    End If
    
    Set summary_output to summary_output + "\nEnd of Report\n"
    Return summary_output

Note: =====================================================================
Note: DIAGNOSTIC QUERIES
Note: =====================================================================

Process called "get_diagnostics_by_severity" that takes engine as DiagnosticEngine, severity as String returns List[Diagnostic]:
    @Implementation
    Retrieve all diagnostics matching the specified severity level from the engine's collection.
    @End Implementation
    
    Let matching_diagnostics be List[Diagnostic]
    Let total_diagnostics be List.length(engine.diagnostics)
    
    Note: Filter diagnostics by matching severity
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be engine.diagnostics[i]
        If diagnostic.severity equals severity:
            List.append(matching_diagnostics, diagnostic)
        End If
    End For
    
    Return matching_diagnostics

Process called "get_diagnostics_by_file" that takes engine as DiagnosticEngine, file_path as String returns List[Diagnostic]:
    @Implementation
    Retrieve all diagnostics associated with the specified file path from the engine's collection.
    @End Implementation
    
    Let matching_diagnostics be List[Diagnostic]
    Let total_diagnostics be List.length(engine.diagnostics)
    
    Note: Filter diagnostics by matching file path
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be engine.diagnostics[i]
        If diagnostic.location.file_path equals file_path:
            List.append(matching_diagnostics, diagnostic)
        End If
    End For
    
    Return matching_diagnostics

Process called "count_diagnostics_by_type" that takes engine as DiagnosticEngine returns Dictionary[String, Integer]:
    @Implementation
    Count and categorize all diagnostics in the engine by their type, severity, and category.
    Returns comprehensive statistics for analysis and reporting.
    @End Implementation
    
    Let type_counts be Dictionary[String, Integer]
    Let total_diagnostics be List.length(engine.diagnostics)
    
    Note: Initialize counters for different classification dimensions
    Dictionary.set(type_counts, "total_diagnostics", total_diagnostics)
    Dictionary.set(type_counts, "severity_error", 0)
    Dictionary.set(type_counts, "severity_warning", 0)
    Dictionary.set(type_counts, "severity_info", 0)
    Dictionary.set(type_counts, "severity_debug", 0)
    
    Note: Count diagnostics by various dimensions
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be engine.diagnostics[i]
        
        Note: Count by severity
        Let severity_key be "severity_" + diagnostic.severity
        Let current_severity_count be 0
        If Dictionary.contains_key(type_counts, severity_key):
            Set current_severity_count to Dictionary.get(type_counts, severity_key)
        End If
        Dictionary.set(type_counts, severity_key, current_severity_count + 1)
        
        Note: Count by category
        Let category_key be "category_" + diagnostic.category
        Let current_category_count be 0
        If Dictionary.contains_key(type_counts, category_key):
            Set current_category_count to Dictionary.get(type_counts, category_key)
        End If
        Dictionary.set(type_counts, category_key, current_category_count + 1)
        
        Note: Count by error code prefix (first 3 characters)
        Let error_code_prefix be String.substring(diagnostic.error_code, 0, 3)
        Let prefix_key be "error_prefix_" + error_code_prefix
        Let current_prefix_count be 0
        If Dictionary.contains_key(type_counts, prefix_key):
            Set current_prefix_count to Dictionary.get(type_counts, prefix_key)
        End If
        Dictionary.set(type_counts, prefix_key, current_prefix_count + 1)
    End For
    
    Return type_counts

Process called "find_diagnostic_by_id" that takes engine as DiagnosticEngine, diagnostic_id as String returns Diagnostic:
    @Implementation
    Find and return a specific diagnostic by its unique error code ID.
    Returns null diagnostic if not found.
    @End Implementation
    
    Let total_diagnostics be List.length(engine.diagnostics)
    
    Note: Search for diagnostic with matching ID
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be engine.diagnostics[i]
        If diagnostic.error_code equals diagnostic_id:
            Return diagnostic
        End If
    End For
    
    Note: Return null diagnostic if not found
    Return create_null_diagnostic()

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "get_diagnostic_engine_statistics" that takes engine as DiagnosticEngine returns Dictionary[String, Integer]:
    @Implementation
    Collect comprehensive statistics about the diagnostic engine's performance,
    memory usage, and operational metrics for monitoring and optimization.
    @End Implementation
    
    Let statistics be Dictionary[String, Integer]
    
    Note: Basic diagnostic counts
    Let total_diagnostics be List.length(engine.diagnostics)
    Dictionary.set(statistics, "total_diagnostics", total_diagnostics)
    Dictionary.set(statistics, "errors", count_diagnostics_by_severity(engine.diagnostics, "error"))
    Dictionary.set(statistics, "warnings", count_diagnostics_by_severity(engine.diagnostics, "warning"))
    Dictionary.set(statistics, "info_messages", count_diagnostics_by_severity(engine.diagnostics, "info"))
    
    Note: Engine configuration statistics
    Dictionary.set(statistics, "max_diagnostics", engine.max_diagnostics)
    Dictionary.set(statistics, "deduplication_enabled", boolean_to_integer(engine.deduplication_enabled))
    Dictionary.set(statistics, "real_time_processing", boolean_to_integer(engine.real_time_processing))
    
    Note: Integration statistics
    Dictionary.set(statistics, "lexer_integration_enabled", boolean_to_integer(engine.lexer_integration_enabled))
    Dictionary.set(statistics, "parser_integration_enabled", boolean_to_integer(engine.parser_integration_enabled))
    Dictionary.set(statistics, "semantic_integration_enabled", boolean_to_integer(engine.semantic_integration_enabled))
    Dictionary.set(statistics, "suggestion_integration_enabled", boolean_to_integer(engine.suggestion_integration_enabled))
    
    Note: Performance metrics
    Dictionary.set(statistics, "creation_timestamp", engine.creation_timestamp)
    Dictionary.set(statistics, "last_diagnostic_timestamp", get_current_timestamp())
    Dictionary.set(statistics, "processing_operations_count", engine.processing_operations_count)
    
    Note: Memory and capacity metrics
    Dictionary.set(statistics, "diagnostic_memory_usage", total_diagnostics * 256)  Note: Estimated bytes per diagnostic
    Dictionary.set(statistics, "capacity_utilization_percent", (total_diagnostics * 100) / engine.max_diagnostics)
    
    Return statistics

Process called "validate_diagnostic_engine_state" that takes engine as DiagnosticEngine returns List[String]:
    @Implementation
    Validate the internal state of the diagnostic engine for consistency, integrity,
    and proper configuration. Returns list of validation issues found.
    @End Implementation
    
    Let validation_issues be List[String]
    
    Note: Validate basic engine state
    If engine.max_diagnostics is less than 1:
        List.append(validation_issues, "Invalid max_diagnostics: must be at least 1")
    End If
    
    Let total_diagnostics be List.length(engine.diagnostics)
    If total_diagnostics is greater than engine.max_diagnostics:
        List.append(validation_issues, "Diagnostic count exceeds maximum limit")
    End If
    
    Note: Validate diagnostic collection integrity
    For i from 0 to (total_diagnostics - 1):
        Let diagnostic be engine.diagnostics[i]
        
        If diagnostic.error_code equals "":
            List.append(validation_issues, "Diagnostic at index " + integer_to_string(i) + " has empty error code")
        End If
        
        If diagnostic.message equals "":
            List.append(validation_issues, "Diagnostic at index " + integer_to_string(i) + " has empty message")
        End If
        
        If diagnostic.severity not equals "error" and diagnostic.severity not equals "warning" and diagnostic.severity not equals "info" and diagnostic.severity not equals "debug":
            List.append(validation_issues, "Diagnostic at index " + integer_to_string(i) + " has invalid severity: " + diagnostic.severity)
        End If
        
        Let line_number be Dictionary.get(diagnostic.location, "line_number")
        If line_number is less than 1:
            List.append(validation_issues, "Diagnostic at index " + integer_to_string(i) + " has invalid line number: " + integer_to_string(line_number))
        End If
    End For
    
    Note: Validate configuration consistency
    If engine.deduplication_enabled and engine.max_diagnostics is less than 100:
        List.append(validation_issues, "Deduplication enabled but max_diagnostics is very low")
    End If
    
    If engine.real_time_processing and not engine.lexer_integration_enabled and not engine.parser_integration_enabled:
        List.append(validation_issues, "Real-time processing enabled but no component integrations are active")
    End If
    
    Note: Validate timestamp consistency
    If engine.creation_timestamp is greater than get_current_timestamp():
        List.append(validation_issues, "Engine creation timestamp is in the future")
    End If
    
    Return validation_issues

Process called "optimize_diagnostic_processing" that takes engine as DiagnosticEngine returns Boolean:
    @Implementation
    Optimize diagnostic processing performance by adjusting settings, cleaning up
    redundant data, and reorganizing internal structures for better efficiency.
    @End Implementation
    
    Let optimizations_applied be 0
    
    Note: Remove duplicate diagnostics if deduplication is enabled
    If engine.deduplication_enabled:
        Let original_count be List.length(engine.diagnostics)
        deduplicate_diagnostics_in_place(engine)
        Let new_count be List.length(engine.diagnostics)
        If new_count is less than original_count:
            Set optimizations_applied to optimizations_applied + 1
        End If
    End If
    
    Note: Sort diagnostics by priority for faster access to critical errors
    Let total_diagnostics be List.length(engine.diagnostics)
    If total_diagnostics is greater than 1:
        sort_diagnostics_by_priority(engine)
        Set optimizations_applied to optimizations_applied + 1
    End If
    
    Note: Optimize suggestion cache if available
    If engine.suggestion_integration_enabled:
        clean_suggestion_cache(engine)
        Set optimizations_applied to optimizations_applied + 1
    End If
    
    Note: Adjust processing settings based on current load
    If total_diagnostics is greater than (engine.max_diagnostics / 2):
        Note: High load - optimize for capacity
        Set engine.real_time_processing to false
        Set engine.aggressive_deduplication to true
        Set optimizations_applied to optimizations_applied + 1
    Otherwise If total_diagnostics is less than (engine.max_diagnostics / 10):
        Note: Low load - optimize for responsiveness
        Set engine.real_time_processing to true
        Set engine.aggressive_deduplication to false
        Set optimizations_applied to optimizations_applied + 1
    End If
    
    Note: Update processing operations counter
    Set engine.processing_operations_count to engine.processing_operations_count + 1
    
    Note: Return true if any optimizations were applied
    Return optimizations_applied is greater than 0

Process called "reset_diagnostic_engine" that takes engine as DiagnosticEngine returns Boolean:
    @Implementation
    Reset the diagnostic engine to its initial clean state, clearing all diagnostics
    and resetting configuration to default values while preserving core settings.
    @End Implementation
    
    Note: Clear all diagnostic data
    Set engine.diagnostics to List[Diagnostic]
    Set engine.diagnostic_count to 0
    
    Note: Reset processing counters and timestamps
    Set engine.processing_operations_count to 0
    Set engine.last_diagnostic_timestamp to 0
    
    Note: Reset integration states (but preserve configuration)
    Set engine.current_location to create_default_location()
    Set engine.context to create_default_context()
    
    Note: Clear caches and temporary data
    clear_diagnostic_cache(engine)
    clear_deduplication_cache(engine)
    
    If engine.suggestion_integration_enabled:
        clear_suggestion_cache(engine)
    End If
    
    Note: Reset performance optimization settings to defaults
    Set engine.real_time_processing to false
    Set engine.aggressive_deduplication to false
    
    Note: Preserve core configuration settings
    Note: Keep: max_diagnostics, deduplication_enabled, integration settings
    Note: Keep: callback functions, interface types
    
    Note: Update creation timestamp to mark reset
    Set engine.creation_timestamp to get_current_timestamp()
    
    Note: Validate engine state after reset
    Let validation_issues be validate_diagnostic_engine_state(engine)
    Let validation_passed be List.length(validation_issues) equals 0
    
    Return validation_passed