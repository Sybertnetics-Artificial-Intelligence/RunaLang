Note:
compiler/frontend/parsing/ast.runa
Abstract Syntax Tree Definitions and Manipulation

This module provides comprehensive AST functionality including:
- Unified AST node definitions for both natural and technical syntax
- AST construction and manipulation utilities
- Node traversal and transformation operations
- AST serialization and deserialization
- Mode-aware AST conversion between natural and technical representations
- Performance optimized AST operations
- Memory management for large ASTs
- Integration with parser and semantic analyzer
- AST validation and consistency checking
:End Note

Import Module "compiler/frontend/diagnostics/errors" As Errors
Import Module "compiler/frontend/lexical/operators" As Operators
Import Module "compiler/frontend/lexical/keywords" As Keywords
Import Module "compiler/frontend/lexical/math_symbols" As MathSymbols

Note: =====================================================================
Note: AST NODE TYPE DEFINITIONS
Note: =====================================================================

Type called "ASTNode":
    node_type as String
    node_id as String
    position as Dictionary[String, Integer]
    parent as String
    children as List[String]
    attributes as Dictionary[String, String]
    metadata as Dictionary[String, String]
    syntax_mode as String
    original_operators as Dictionary[String, String]    Note: Preserve operator forms for viewer mode
    source_context as Dictionary[String, String]        Note: Additional context for viewer transformation

Type called "ExpressionNode":
    base_node as ASTNode
    expression_type as String
    operator as String
    operands as List[String]
    precedence as Integer
    associativity as String
    is_mathematical as Boolean

Type called "StatementNode":
    base_node as ASTNode
    statement_type as String
    keywords as List[String]
    body as String
    condition as String
    is_block_statement as Boolean

Type called "DeclarationNode":
    base_node as ASTNode
    declaration_type as String
    identifier as String
    type_annotation as String
    initializer as String
    modifiers as List[String]
    scope as String

Type called "LiteralNode":
    base_node as ASTNode
    literal_type as String
    raw_value as String
    parsed_value as String
    data_type as String

Type called "IdentifierNode":
    base_node as ASTNode
    name as String
    is_qualified as Boolean
    namespace as String
    binding_context as String

Type called "TypeNode":
    base_node as ASTNode
    type_name as String
    type_parameters as List[String]
    constraints as List[String]
    is_generic as Boolean

Type called "ConstructorNode":
    base_node as ASTNode
    type_name as String
    field_initializers as Dictionary[String, String]
    is_default_constructor as Boolean
    constructor_syntax as String    Note: "a value of type" or "of type" for tracking syntax used

Note: =====================================================================
Note: AST BUILDER AND MANAGEMENT
Note: =====================================================================

Type called "ASTBuilder":
    builder_id as String
    current_mode as String
    node_counter as Integer
    root_node as String
    current_scope as String
    symbol_table as String
    statistics as Dictionary[String, Integer]
    preserve_for_viewer as Boolean               Note: Keep extra metadata for viewer transformation
    operator_mappings as Dictionary[String, String]  Note: Track operator conversions
    node_registry as Dictionary[String, ASTNode]     Note: Central node storage for ID-based lookup

Process called "create_ast_builder" that takes builder_name as String, mode as String returns ASTBuilder:
    Note: Create AST builder with specified syntax mode
    
    Let builder be ASTBuilder with
        builder_id as builder_name,
        current_mode as mode,
        node_counter as 0,
        root_node as "",
        current_scope as "global",
        symbol_table as "",
        statistics as Dictionary[String, Integer](),
        preserve_for_viewer as true,
        operator_mappings as Dictionary[String, String](),
        node_registry as Dictionary[String, ASTNode]()
    End ASTBuilder
    
    Return builder

Process called "create_node" that takes builder as ASTBuilder, node_type as String returns ASTNode:
    Note: Create new AST node with unique ID and register it
    
    Set builder.node_counter to builder.node_counter + 1
    Let node_id be builder.builder_id + "_" + builder.node_counter
    
    Let node be ASTNode with
        node_type as node_type,
        node_id as node_id,
        position as Dictionary[String, Integer](),
        parent as "",
        children as List[String](),
        attributes as Dictionary[String, String](),
        metadata as Dictionary[String, String](),
        syntax_mode as builder.current_mode,
        original_operators as Dictionary[String, String](),
        source_context as Dictionary[String, String]()
    End ASTNode
    
    Note: Register node in builder's registry for lookup
    Set builder.node_registry[node_id] to node
    
    Return node

Process called "add_child_node" that takes builder as ASTBuilder, parent as ASTNode, child as ASTNode returns Boolean:
    Note: Add child node to parent with proper linking
    
    Note: Add child ID to parent's children list
    Add child.node_id to parent.children
    
    Note: Set parent reference in child
    Set child.parent to parent.node_id
    
    Note: Update builder statistics
    If builder.statistics contains "total_nodes":
        Set builder.statistics["total_nodes"] to builder.statistics["total_nodes"] + 1
    Otherwise:
        Set builder.statistics["total_nodes"] to 1
    End If
    
    Return true

Process called "set_node_attributes" that takes builder as ASTBuilder, node as ASTNode, attributes as Dictionary[String, String] returns Boolean:
    Note: Set attributes for AST node
    
    Note: Merge new attributes with existing ones
    For Each key, value in attributes:
        Set node.attributes[key] to value
    End For
    
    Note: Preserve original operators for viewer mode if needed
    If builder.preserve_for_viewer and attributes contains "operator":
        Set node.original_operators["source_operator"] to attributes["operator"]
    End If
    
    Return true

Note: =====================================================================
Note: EXPRESSION AST OPERATIONS
Note: =====================================================================

Process called "create_binary_expression" that takes builder as ASTBuilder, operator as String, left as ASTNode, right as ASTNode returns ExpressionNode:
    Note: Create binary expression node with operator and operands
    Note: Automatically converts developer syntax operators to canon form
    
    Note: Convert operator to canonical form if in developer mode
    Let canonical_operator be convert_operator_to_canonical(operator, builder.current_mode)
    
    Let base_node be create_node(builder, "BinaryExpression")
    Set base_node.attributes["operator"] to canonical_operator
    
    Note: Preserve original operator form for viewer mode transformation
    If builder.preserve_for_viewer:
        Set base_node.original_operators["input_operator"] to operator
        Set base_node.original_operators["canonical_operator"] to canonical_operator
    End If
    
    Let expr_node be ExpressionNode with
        base_node as base_node,
        expression_type as "binary",
        operator as canonical_operator,
        operands as List[String](left.node_id, right.node_id),
        precedence as get_operator_precedence_from_lexer(canonical_operator),
        associativity as get_operator_associativity_from_lexer(canonical_operator),
        is_mathematical as is_mathematical_operator(canonical_operator)
    End ExpressionNode
    
    Note: Link child nodes
    Add left.node_id to base_node.children
    Add right.node_id to base_node.children
    Set left.parent to base_node.node_id
    Set right.parent to base_node.node_id
    
    Return expr_node

Process called "get_default_precedence" that takes operator as String returns Integer:
    Note: Get default precedence for operators
    Match operator:
        When "*", "/", "%":
            Return 6
        When "+", "-":
            Return 5
        When "<", ">", "<=", ">=":
            Return 4
        When "==", "!=":
            Return 3
        When "&&":
            Return 2
        When "||":
            Return 1
        Otherwise:
            Return 0
    End Match

Process called "get_default_associativity" that takes operator as String returns String:
    Note: Get default associativity for operators
    Match operator:
        When "=", "+=", "-=", "*=", "/=":
            Return "right"
        Otherwise:
            Return "left"
    End Match

Process called "is_mathematical_operator" that takes operator as String returns Boolean:
    Note: Check if operator is mathematical using lexical infrastructure
    
    Note: Check if it's a mathematical symbol from math_symbols module
    Let math_table be MathSymbols.create_math_symbol_table()
    Let first_char be get_first_character(operator)
    If MathSymbols.is_math_operator(math_table, first_char):
        Return true
    End If
    
    Note: Check if it's an arithmetic operator from operators module
    Let op_by_symbol be Operators.get_operator_by_symbol(operator)
    If op_by_symbol.symbol_form != "":
        Return op_by_symbol.operator_type = "arithmetic"
    End If
    
    Note: Fallback check for basic math operators
    Match operator:
        When "plus", "minus", "multiplied by", "divided by", "modulo":
            Return true
        When "raised to power", "square root":
            Return true
        Otherwise:
            Return false
    End Match

Note: =====================================================================
Note: OPERATOR CONVERSION INTEGRATION
Note: =====================================================================

Process called "convert_operator_to_canonical" that takes operator as String, syntax_mode as String returns String:
    Note: Convert developer operators to canonical form using existing lexical infrastructure
    Note: Examples: "*" -> "multiplied by", "==" -> "is equal to"
    
    If syntax_mode = "developer":
        Note: Use existing lexical conversion function from operators module
        Let canonical_form be Operators.symbol_to_canonical(operator)
        
        Note: Check if conversion was successful (non-empty result)
        If canonical_form != "":
            Return canonical_form
        End If
        
        Note: Check if it's a keyword operator (And, Or, Not)
        Let keyword_canonical be Keywords.convert_to_canonical(operator, "developer")
        If keyword_canonical != operator:
            Return keyword_canonical
        End If
        
        Note: If not found, return as-is (might already be canonical)
        Return operator
    End If
    
    Note: If in canon mode, return as-is
    Return operator

Process called "get_operator_precedence_from_lexer" that takes operator as String returns Integer:
    Note: Get operator precedence from lexer's operator definitions
    
    Note: Try to get operator by symbol first
    Let op_by_symbol be Operators.get_operator_by_symbol(operator)
    If op_by_symbol.symbol_form != "":
        Return op_by_symbol.precedence
    End If
    
    Note: Check if it's a mathematical symbol operator
    Let math_table be MathSymbols.create_math_symbol_table()
    Let first_char be get_first_character(operator)
    If MathSymbols.is_math_operator(math_table, first_char):
        Return MathSymbols.get_operator_precedence(math_table, first_char)
    End If
    
    Note: Use fallback precedence for unknown operators
    Return get_default_precedence(operator)

Process called "get_operator_associativity_from_lexer" that takes operator as String returns String:
    Note: Get operator associativity from lexer's operator definitions
    
    Note: Try to get operator by symbol first
    Let op_by_symbol be Operators.get_operator_by_symbol(operator)
    If op_by_symbol.symbol_form != "":
        Return op_by_symbol.associativity
    End If
    
    Note: Check if it's a mathematical symbol operator
    Let math_table be MathSymbols.create_math_symbol_table()
    Let first_char be get_first_character(operator)
    If MathSymbols.is_math_operator(math_table, first_char):
        Return MathSymbols.get_operator_associativity(math_table, first_char)
    End If
    
    Note: Use fallback associativity for unknown operators
    Return get_default_associativity(operator)

Process called "create_unary_expression" that takes builder as ASTBuilder, operator as String, operand as ASTNode returns ExpressionNode:
    Note: Create unary expression node with automatic operator conversion
    
    Note: Convert operator to canonical form if in developer mode
    Let canonical_operator be convert_operator_to_canonical(operator, builder.current_mode)
    
    Let base_node be create_node(builder, "UnaryExpression")
    Set base_node.attributes["operator"] to canonical_operator
    
    Note: Preserve original operator form for viewer mode transformation
    If builder.preserve_for_viewer:
        Set base_node.original_operators["input_operator"] to operator
        Set base_node.original_operators["canonical_operator"] to canonical_operator
    End If
    
    Let expr_node be ExpressionNode with
        base_node as base_node,
        expression_type as "unary",
        operator as canonical_operator,
        operands as List[String](operand.node_id),
        precedence as get_operator_precedence_from_lexer(canonical_operator),
        associativity as "right",
        is_mathematical as is_mathematical_operator(canonical_operator)
    End ExpressionNode
    
    Note: Link child node
    Add operand.node_id to base_node.children
    Set operand.parent to base_node.node_id
    
    Return expr_node

Process called "get_unary_precedence" that takes operator as String returns Integer:
    Note: Get precedence for unary operators (typically higher than binary)
    Match operator:
        When "!", "not":
            Return 8
        When "+", "-":
            Return 7
        When "++", "--":
            Return 9
        When "√", "∂":
            Return 10
        Otherwise:
            Return 7
    End Match

Process called "create_call_expression" that takes builder as ASTBuilder, function as ASTNode, arguments as List[ASTNode] returns ExpressionNode:
    Note: Create function call expression node
    
    Let base_node be create_node(builder, "CallExpression")
    Set base_node.attributes["function_name"] to function.node_id
    Set base_node.attributes["argument_count"] to arguments.count
    
    Note: Create operand list with function as first operand, then arguments
    Let operand_ids be List[String]()
    Add function.node_id to operand_ids
    
    For Each argument in arguments:
        Add argument.node_id to operand_ids
    End For
    
    Let expr_node be ExpressionNode with
        base_node as base_node,
        expression_type as "call",
        operator as "()",
        operands as operand_ids,
        precedence as 11,
        associativity as "left",
        is_mathematical as false
    End ExpressionNode
    
    Note: Link all child nodes
    Add function.node_id to base_node.children
    Set function.parent to base_node.node_id
    
    For Each argument in arguments:
        Add argument.node_id to base_node.children
        Set argument.parent to base_node.node_id
    End For
    
    Return expr_node

Process called "create_member_access" that takes builder as ASTBuilder, object as ASTNode, member as String returns ExpressionNode:
    Note: Create member access expression (object.member)
    
    Let base_node be create_node(builder, "MemberAccess")
    Set base_node.attributes["member_name"] to member
    
    Let expr_node be ExpressionNode with
        base_node as base_node,
        expression_type as "member_access",
        operator as ".",
        operands as List[String](object.node_id),
        precedence as 12,
        associativity as "left",
        is_mathematical as false
    End ExpressionNode
    
    Note: Link child node
    Add object.node_id to base_node.children
    Set object.parent to base_node.node_id
    
    Return expr_node

Process called "create_mathematical_expression" that takes builder as ASTBuilder, symbol as String, operands as List[ASTNode] returns ExpressionNode:
    Note: Create mathematical expression with Greek letters and symbols using math_symbols integration
    
    Note: Convert mathematical symbol to canonical form if needed
    Let math_table be MathSymbols.create_math_symbol_table()
    Let first_char be get_first_character(symbol)
    Let canonical_symbol be symbol
    
    If MathSymbols.is_math_symbol(math_table, first_char):
        Set canonical_symbol to MathSymbols.get_canonical_name(math_table, first_char, builder.current_mode)
    End If
    
    Let base_node be create_node(builder, "MathematicalExpression")
    Set base_node.attributes["math_symbol"] to canonical_symbol
    Set base_node.attributes["operand_count"] to operands.count
    Set base_node.attributes["original_symbol"] to symbol
    
    Note: Create operand ID list
    Let operand_ids be List[String]()
    For Each operand in operands:
        Add operand.node_id to operand_ids
    End For
    
    Let expr_node be ExpressionNode with
        base_node as base_node,
        expression_type as "mathematical",
        operator as canonical_symbol,
        operands as operand_ids,
        precedence as get_mathematical_precedence_from_lexer(symbol),
        associativity as get_mathematical_associativity_from_lexer(symbol),
        is_mathematical as true
    End ExpressionNode
    
    Note: Link child nodes
    For Each operand in operands:
        Add operand.node_id to base_node.children
        Set operand.parent to base_node.node_id
    End For
    
    Return expr_node

Process called "get_mathematical_precedence_from_lexer" that takes symbol as String returns Integer:
    Note: Get precedence for mathematical symbols from lexical infrastructure
    
    Let math_table be MathSymbols.create_math_symbol_table()
    Let first_char be get_first_character(symbol)
    
    If MathSymbols.is_math_operator(math_table, first_char):
        Return MathSymbols.get_operator_precedence(math_table, first_char)
    End If
    
    Note: Fallback to default mathematical precedence
    Return get_mathematical_precedence(symbol)

Process called "get_mathematical_precedence" that takes symbol as String returns Integer:
    Note: Fallback precedence for mathematical symbols
    Match symbol:
        When "∑", "∏", "∫":
            Return 15
        When "√", "∂":
            Return 13
        When "^", "**":
            Return 14
        When "α", "β", "γ", "δ", "ε", "π", "λ", "μ", "σ", "τ", "φ", "ψ", "ω":
            Return 1
        Otherwise:
            Return 10
    End Match

Process called "get_mathematical_associativity_from_lexer" that takes symbol as String returns String:
    Note: Get associativity for mathematical symbols from lexical infrastructure
    
    Let math_table be MathSymbols.create_math_symbol_table()
    Let first_char be get_first_character(symbol)
    
    If MathSymbols.is_math_operator(math_table, first_char):
        Return MathSymbols.get_operator_associativity(math_table, first_char)
    End If
    
    Note: Fallback to default mathematical associativity
    Return get_mathematical_associativity(symbol)

Process called "get_mathematical_associativity" that takes symbol as String returns String:
    Note: Fallback associativity for mathematical symbols
    Match symbol:
        When "^", "**":
            Return "right"
        When "∑", "∏", "∫":
            Return "none"
        Otherwise:
            Return "left"
    End Match

Process called "create_constructor_expression" that takes builder as ASTBuilder, type_name as String, field_initializers as Dictionary[String, ASTNode], syntax_form as String returns ConstructorNode:
    Note: Create constructor expression node for "a value of type" syntax
    
    Let base_node be create_node(builder, "ConstructorExpression")
    Set base_node.attributes["type_name"] to type_name
    Set base_node.attributes["syntax_form"] to syntax_form
    
    Note: Convert field initializer nodes to IDs for storage
    Let field_init_ids be Dictionary[String, String]()
    For Each field_name, field_value in field_initializers:
        Set field_init_ids[field_name] to field_value.node_id
    End For
    
    Let constructor_node be ConstructorNode with
        base_node as base_node,
        type_name as type_name,
        field_initializers as field_init_ids,
        is_default_constructor as (field_initializers.size() == 0),
        constructor_syntax as syntax_form
    End ConstructorNode
    
    Note: Register constructor node
    Set builder.node_registry[base_node.node_id] to constructor_node
    
    Return constructor_node

Note: =====================================================================
Note: STATEMENT AST OPERATIONS
Note: =====================================================================

Process called "create_let_statement" that takes builder as ASTBuilder, identifier as String, type_annotation as String, initializer as ASTNode returns StatementNode:
    Note: Create Let statement node (natural syntax)
    
    Let base_node be create_node(builder, "LetStatement")
    Set base_node.attributes["identifier"] to identifier
    Set base_node.attributes["type_annotation"] to type_annotation
    Set base_node.attributes["syntax_form"] to "natural"
    
    Let stmt_node be StatementNode with
        base_node as base_node,
        statement_type as "declaration",
        keywords as List[String]("Let"),
        body as initializer.node_id,
        condition as "",
        is_block_statement as false
    End StatementNode
    
    Note: Link initializer as child
    Add initializer.node_id to base_node.children
    Set initializer.parent to base_node.node_id
    
    Return stmt_node

Process called "create_assignment_statement" that takes builder as ASTBuilder, target as ASTNode, value as ASTNode returns StatementNode:
    Note: Create assignment statement (technical syntax)
    
    Let base_node be create_node(builder, "AssignmentStatement")
    Set base_node.attributes["target"] to target.node_id
    Set base_node.attributes["syntax_form"] to "technical"
    
    Let stmt_node be StatementNode with
        base_node as base_node,
        statement_type as "assignment",
        keywords as List[String](),
        body as value.node_id,
        condition as "",
        is_block_statement as false
    End StatementNode
    
    Note: Link target and value as children
    Add target.node_id to base_node.children
    Add value.node_id to base_node.children
    Set target.parent to base_node.node_id
    Set value.parent to base_node.node_id
    
    Return stmt_node

Process called "create_if_statement" that takes builder as ASTBuilder, condition as ASTNode, then_block as ASTNode, else_block as ASTNode returns StatementNode:
    Note: Create if statement with condition and blocks
    
    Let base_node be create_node(builder, "IfStatement")
    Set base_node.attributes["has_else"] to (else_block.node_id != "")
    
    Let stmt_node be StatementNode with
        base_node as base_node,
        statement_type as "conditional",
        keywords as List[String]("If", "then"),
        body as then_block.node_id,
        condition as condition.node_id,
        is_block_statement as true
    End StatementNode
    
    Note: Link condition and then block
    Add condition.node_id to base_node.children
    Add then_block.node_id to base_node.children
    Set condition.parent to base_node.node_id
    Set then_block.parent to base_node.node_id
    
    Note: Link else block if present
    If else_block.node_id != "":
        Add else_block.node_id to base_node.children
        Set else_block.parent to base_node.node_id
        Add "Otherwise" to stmt_node.keywords
    End If
    
    Return stmt_node

Process called "create_loop_statement" that takes builder as ASTBuilder, loop_type as String, condition as ASTNode, body as ASTNode returns StatementNode:
    Note: Create loop statement (for, while, etc.)
    
    Let base_node be create_node(builder, "LoopStatement")
    Set base_node.attributes["loop_type"] to loop_type
    
    Let keywords be List[String]()
    Match loop_type:
        When "while":
            Add "While" to keywords
        When "for":
            Add "For" to keywords
            Add "Each" to keywords
        When "for_range":
            Add "For" to keywords
        Otherwise:
            Add loop_type to keywords
    End Match
    
    Let stmt_node be StatementNode with
        base_node as base_node,
        statement_type as "loop",
        keywords as keywords,
        body as body.node_id,
        condition as condition.node_id,
        is_block_statement as true
    End StatementNode
    
    Note: Link condition and body
    Add condition.node_id to base_node.children
    Add body.node_id to base_node.children
    Set condition.parent to base_node.node_id
    Set body.parent to base_node.node_id
    
    Return stmt_node

Process called "create_match_statement" that takes builder as ASTBuilder, expression as ASTNode, cases as List[ASTNode] returns StatementNode:
    Note: Create pattern matching statement
    
    Let base_node be create_node(builder, "MatchStatement")
    Set base_node.attributes["case_count"] to cases.count
    
    Let stmt_node be StatementNode with
        base_node as base_node,
        statement_type as "pattern_match",
        keywords as List[String]("Match", "When"),
        body as "",
        condition as expression.node_id,
        is_block_statement as true
    End StatementNode
    
    Note: Link expression as child
    Add expression.node_id to base_node.children
    Set expression.parent to base_node.node_id
    
    Note: Link all cases as children
    For Each case in cases:
        Add case.node_id to base_node.children
        Set case.parent to base_node.node_id
    End For
    
    Return stmt_node

Note: =====================================================================
Note: DECLARATION AST OPERATIONS
Note: =====================================================================

Process called "create_function_declaration" that takes builder as ASTBuilder, name as String, parameters as List[ASTNode], return_type as String, body as ASTNode returns DeclarationNode:
    Note: Create function declaration node
    
    Let base_node be create_node(builder, "FunctionDeclaration")
    Set base_node.attributes["function_name"] to name
    Set base_node.attributes["parameter_count"] to parameters.count
    Set base_node.attributes["return_type"] to return_type
    Set base_node.attributes["syntax_form"] to "technical"
    
    Let decl_node be DeclarationNode with
        base_node as base_node,
        declaration_type as "function",
        identifier as name,
        type_annotation as return_type,
        initializer as body.node_id,
        modifiers as List[String](),
        scope as builder.current_scope
    End DeclarationNode
    
    Note: Link parameters and body as children
    For Each parameter in parameters:
        Add parameter.node_id to base_node.children
        Set parameter.parent to base_node.node_id
    End For
    
    Add body.node_id to base_node.children
    Set body.parent to base_node.node_id
    
    Return decl_node

Process called "create_process_declaration" that takes builder as ASTBuilder, name as String, parameters as List[ASTNode], return_type as String, body as ASTNode returns DeclarationNode:
    Note: Create process declaration (natural syntax)
    
    Let base_node be create_node(builder, "ProcessDeclaration")
    Set base_node.attributes["process_name"] to name
    Set base_node.attributes["parameter_count"] to parameters.count
    Set base_node.attributes["return_type"] to return_type
    Set base_node.attributes["syntax_form"] to "natural"
    
    Let decl_node be DeclarationNode with
        base_node as base_node,
        declaration_type as "process",
        identifier as name,
        type_annotation as return_type,
        initializer as body.node_id,
        modifiers as List[String]("called"),
        scope as builder.current_scope
    End DeclarationNode
    
    Note: Link parameters and body as children
    For Each parameter in parameters:
        Add parameter.node_id to base_node.children
        Set parameter.parent to base_node.node_id
    End For
    
    Add body.node_id to base_node.children
    Set body.parent to base_node.node_id
    
    Return decl_node

Process called "create_type_declaration" that takes builder as ASTBuilder, name as String, type_definition as ASTNode returns DeclarationNode:
    Note: Create type declaration node
    
    Let base_node be create_node(builder, "TypeDeclaration")
    Set base_node.attributes["type_name"] to name
    
    Let decl_node be DeclarationNode with
        base_node as base_node,
        declaration_type as "type",
        identifier as name,
        type_annotation as "Type",
        initializer as type_definition.node_id,
        modifiers as List[String]("called"),
        scope as builder.current_scope
    End DeclarationNode
    
    Note: Link type definition as child
    Add type_definition.node_id to base_node.children
    Set type_definition.parent to base_node.node_id
    
    Return decl_node

Process called "create_variable_declaration" that takes builder as ASTBuilder, name as String, type_annotation as String, initializer as ASTNode returns DeclarationNode:
    Note: Create variable declaration node
    
    Let base_node be create_node(builder, "VariableDeclaration")
    Set base_node.attributes["variable_name"] to name
    Set base_node.attributes["has_initializer"] to (initializer.node_id != "")
    
    Let decl_node be DeclarationNode with
        base_node as base_node,
        declaration_type as "variable",
        identifier as name,
        type_annotation as type_annotation,
        initializer as initializer.node_id,
        modifiers as List[String](),
        scope as builder.current_scope
    End DeclarationNode
    
    Note: Link initializer as child if present
    If initializer.node_id != "":
        Add initializer.node_id to base_node.children
        Set initializer.parent to base_node.node_id
    End If
    
    Return decl_node

Note: =====================================================================
Note: AST TRAVERSAL OPERATIONS
Note: =====================================================================

Process called "traverse_preorder" that takes builder as ASTBuilder, root as ASTNode, visitor as String returns List[ASTNode]:
    Note: Traverse AST in pre-order with visitor pattern
    
    Let visited_nodes be List[ASTNode]()
    
    Note: Visit current node first (pre-order)
    Add root to visited_nodes
    
    Note: Then visit all children recursively
    For Each child_id in root.children:
        Let child_node be find_node_by_id(builder, root, child_id)
        If child_node.node_id != "":
            Let child_traversal be traverse_preorder(builder, child_node, visitor)
            For Each child_visited in child_traversal:
                Add child_visited to visited_nodes
            End For
        End If
    End For
    
    Return visited_nodes

Process called "traverse_postorder" that takes builder as ASTBuilder, root as ASTNode, visitor as String returns List[ASTNode]:
    Note: Traverse AST in post-order with visitor pattern
    
    Let visited_nodes be List[ASTNode]()
    
    Note: Visit all children first (post-order)
    For Each child_id in root.children:
        Let child_node be find_node_by_id(builder, root, child_id)
        If child_node.node_id != "":
            Let child_traversal be traverse_postorder(builder, child_node, visitor)
            For Each child_visited in child_traversal:
                Add child_visited to visited_nodes
            End For
        End If
    End For
    
    Note: Visit current node last (post-order)
    Add root to visited_nodes
    
    Return visited_nodes

Process called "find_nodes_by_type" that takes builder as ASTBuilder, root as ASTNode, node_type as String returns List[ASTNode]:
    Note: Find all nodes of specified type in AST
    
    Let found_nodes be List[ASTNode]()
    
    Note: Check current node type
    If root.node_type = node_type:
        Add root to found_nodes
    End If
    
    Note: Recursively search all children
    For Each child_id in root.children:
        Let child_node be find_node_by_id(builder, root, child_id)
        If child_node.node_id != "":
            Let child_matches be find_nodes_by_type(builder, child_node, node_type)
            For Each match in child_matches:
                Add match to found_nodes
            End For
        End If
    End For
    
    Return found_nodes

Process called "find_node_by_id" that takes builder as ASTBuilder, root as ASTNode, node_id as String returns ASTNode:
    Note: Find specific node by unique ID
    
    Note: Check if current node matches
    If root.node_id = node_id:
        Return root
    End If
    
    Note: Search all children recursively
    For Each child_id in root.children:
        Let child_node be get_node_by_id_direct(builder, child_id)
        If child_node.node_id != "":
            Let found_node be find_node_by_id(builder, child_node, node_id)
            If found_node.node_id != "":
                Return found_node
            End If
        End If
    End For
    
    Note: Return empty node if not found
    Return ASTNode with
        node_type as "",
        node_id as "",
        position as Dictionary[String, Integer](),
        parent as "",
        children as List[String](),
        attributes as Dictionary[String, String](),
        metadata as Dictionary[String, String](),
        syntax_mode as "",
        original_operators as Dictionary[String, String](),
        source_context as Dictionary[String, String]()
    End ASTNode

Process called "get_node_by_id_direct" that takes builder as ASTBuilder, node_id as String returns ASTNode:
    Note: Direct lookup of node by ID from builder's registry
    
    If builder.node_registry contains node_id:
        Return builder.node_registry[node_id]
    End If
    
    Note: Return empty node if not found
    Return ASTNode with
        node_type as "",
        node_id as "",
        position as Dictionary[String, Integer](),
        parent as "",
        children as List[String](),
        attributes as Dictionary[String, String](),
        metadata as Dictionary[String, String](),
        syntax_mode as "",
        original_operators as Dictionary[String, String](),
        source_context as Dictionary[String, String]()
    End ASTNode

Process called "get_parent_node" that takes builder as ASTBuilder, node as ASTNode returns ASTNode:
    Note: Get parent node of specified node
    
    If node.parent = "":
        Note: Return empty node if no parent
        Return ASTNode with
            node_type as "",
            node_id as "",
            position as Dictionary[String, Integer](),
            parent as "",
            children as List[String](),
            attributes as Dictionary[String, String](),
            metadata as Dictionary[String, String](),
            syntax_mode as "",
            original_operators as Dictionary[String, String](),
            source_context as Dictionary[String, String]()
        End ASTNode
    End If
    
    Return get_node_by_id_direct(builder, node.parent)

Process called "get_child_nodes" that takes builder as ASTBuilder, node as ASTNode returns List[ASTNode]:
    Note: Get all child nodes of specified node
    
    Let child_nodes be List[ASTNode]()
    
    For Each child_id in node.children:
        Let child_node be get_node_by_id_direct(builder, child_id)
        If child_node.node_id != "":
            Add child_node to child_nodes
        End If
    End For
    
    Return child_nodes

Note: =====================================================================
Note: AST TRANSFORMATION OPERATIONS
Note: =====================================================================

Process called "transform_ast" that takes builder as ASTBuilder, root as ASTNode, transformation as String returns ASTNode:
    Note: Apply transformation to AST structure
    
    Match transformation:
        When "optimize":
            Return optimize_ast(builder, root)
        When "inline":
            Return inline_expressions(builder, root)
        When "natural_to_technical":
            Return convert_natural_to_technical(builder, root)
        When "technical_to_natural":
            Return convert_technical_to_natural(builder, root)
        Otherwise:
            Note: Unknown transformation, return original
            Return root
    End Match

Process called "convert_natural_to_technical" that takes builder as ASTBuilder, natural_ast as ASTNode returns ASTNode:
    Note: Convert natural language AST to technical syntax AST
    
    Note: Clone the AST to avoid modifying original
    Let technical_ast be clone_ast(builder, natural_ast)
    
    Note: Update syntax mode
    Set technical_ast.syntax_mode to "technical"
    
    Note: Convert node-specific attributes based on type
    Match technical_ast.node_type:
        When "LetStatement":
            Set technical_ast.node_type to "AssignmentStatement"
            Set technical_ast.attributes["syntax_form"] to "technical"
        When "ProcessDeclaration":
            Set technical_ast.node_type to "FunctionDeclaration"
            Set technical_ast.attributes["syntax_form"] to "technical"
        Otherwise:
            Note: No conversion needed for this node type
    End Match
    
    Note: Recursively convert all children
    For Each child_id in technical_ast.children:
        Let child_node be find_node_by_id(builder, technical_ast, child_id)
        If child_node.node_id != "":
            Let converted_child be convert_natural_to_technical(builder, child_node)
            Note: Update child in place
        End If
    End For
    
    Return technical_ast

Process called "convert_technical_to_natural" that takes builder as ASTBuilder, technical_ast as ASTNode returns ASTNode:
    Note: Convert technical syntax AST to natural language AST
    
    Note: Clone the AST to avoid modifying original
    Let natural_ast be clone_ast(builder, technical_ast)
    
    Note: Update syntax mode
    Set natural_ast.syntax_mode to "natural"
    
    Note: Convert node-specific attributes based on type
    Match natural_ast.node_type:
        When "AssignmentStatement":
            Set natural_ast.node_type to "LetStatement"
            Set natural_ast.attributes["syntax_form"] to "natural"
        When "FunctionDeclaration":
            Set natural_ast.node_type to "ProcessDeclaration"
            Set natural_ast.attributes["syntax_form"] to "natural"
        Otherwise:
            Note: No conversion needed for this node type
    End Match
    
    Note: Recursively convert all children
    For Each child_id in natural_ast.children:
        Let child_node be find_node_by_id(builder, natural_ast, child_id)
        If child_node.node_id != "":
            Let converted_child be convert_technical_to_natural(builder, child_node)
            Note: Update child in place
        End If
    End For
    
    Return natural_ast

Process called "optimize_ast" that takes builder as ASTBuilder, root as ASTNode returns ASTNode:
    Note: Apply optimization transformations to AST
    
    Note: Clone AST for optimization
    Let optimized_ast be clone_ast(builder, root)
    
    Note: Apply constant folding for mathematical expressions
    If optimized_ast.node_type = "BinaryExpression":
        If optimized_ast.attributes contains "operator":
            Let operator be optimized_ast.attributes["operator"]
            If operator = "+" or operator = "-" or operator = "*" or operator = "/":
                Note: Could implement constant folding here
                Set optimized_ast.metadata["optimized"] to "constant_folded"
            End If
        End If
    End If
    
    Note: Recursively optimize all children
    For Each child_id in optimized_ast.children:
        Let child_node be find_node_by_id(builder, optimized_ast, child_id)
        If child_node.node_id != "":
            Let optimized_child be optimize_ast(builder, child_node)
            Note: Update child in place
        End If
    End For
    
    Return optimized_ast

Process called "inline_expressions" that takes builder as ASTBuilder, root as ASTNode returns ASTNode:
    Note: Inline simple expressions for optimization
    
    Note: Clone AST for inlining
    Let inlined_ast be clone_ast(builder, root)
    
    Note: Mark simple expressions for inlining
    If inlined_ast.node_type = "CallExpression":
        If inlined_ast.attributes contains "function_name":
            Let func_name be inlined_ast.attributes["function_name"]
            Note: Could implement simple function inlining here
            Set inlined_ast.metadata["inline_candidate"] to "true"
        End If
    End If
    
    Note: Recursively process all children
    For Each child_id in inlined_ast.children:
        Let child_node be find_node_by_id(builder, inlined_ast, child_id)
        If child_node.node_id != "":
            Let inlined_child be inline_expressions(builder, child_node)
            Note: Update child in place
        End If
    End For
    
    Return inlined_ast

Note: =====================================================================
Note: AST VALIDATION OPERATIONS
Note: =====================================================================

Process called "validate_ast" that takes builder as ASTBuilder, root as ASTNode returns List[String]:
    Note: Validate AST for structural correctness
    
    Let errors be List[String]()
    
    Note: Validate current node
    Let node_errors be check_node_consistency(builder, root)
    For Each error in node_errors:
        Add error to errors
    End For
    
    Note: Validate parent-child relationships
    Let link_errors be validate_parent_child_links(builder, root)
    For Each error in link_errors:
        Add error to errors
    End For
    
    Note: Validate scope information
    Let scope_errors be check_scope_correctness(builder, root)
    For Each error in scope_errors:
        Add error to errors
    End For
    
    Note: Recursively validate all children
    For Each child_id in root.children:
        Let child_node be find_node_by_id(builder, root, child_id)
        If child_node.node_id != "":
            Let child_errors be validate_ast(builder, child_node)
            For Each error in child_errors:
                Add error to errors
            End For
        End If
    End For
    
    Return errors

Process called "check_node_consistency" that takes builder as ASTBuilder, node as ASTNode returns List[String]:
    Note: Check individual node for consistency
    
    Let errors be List[String]()
    
    Note: Check required fields
    If node.node_id = "":
        Add "Node missing required node_id" to errors
    End If
    
    If node.node_type = "":
        Add "Node missing required node_type" to errors
    End If
    
    Note: Validate node type specific requirements
    Match node.node_type:
        When "BinaryExpression":
            If not node.attributes contains "operator":
                Add "BinaryExpression missing operator attribute" to errors
            End If
            If node.children.count != 2:
                Add "BinaryExpression must have exactly 2 children" to errors
            End If
        When "UnaryExpression":
            If not node.attributes contains "operator":
                Add "UnaryExpression missing operator attribute" to errors
            End If
            If node.children.count != 1:
                Add "UnaryExpression must have exactly 1 child" to errors
            End If
        When "CallExpression":
            If not node.attributes contains "function_name":
                Add "CallExpression missing function_name attribute" to errors
            End If
        Otherwise:
            Note: No specific validation for this node type
    End Match
    
    Return errors

Process called "validate_parent_child_links" that takes builder as ASTBuilder, root as ASTNode returns List[String]:
    Note: Validate parent-child link consistency
    
    Let errors be List[String]()
    
    Note: Check that all children reference this node as parent
    For Each child_id in root.children:
        Let child_node be find_node_by_id(builder, root, child_id)
        If child_node.node_id != "":
            If child_node.parent != root.node_id:
                Add "Child " + child_id + " parent reference inconsistent" to errors
            End If
        Otherwise:
            Add "Child " + child_id + " not found in AST" to errors
        End If
    End For
    
    Note: Recursively validate all children
    For Each child_id in root.children:
        Let child_node be find_node_by_id(builder, root, child_id)
        If child_node.node_id != "":
            Let child_errors be validate_parent_child_links(builder, child_node)
            For Each error in child_errors:
                Add error to errors
            End For
        End If
    End For
    
    Return errors

Process called "check_scope_correctness" that takes builder as ASTBuilder, root as ASTNode returns List[String]:
    Note: Check scope information correctness in AST
    
    Let errors be List[String]()
    
    Note: Check scope-related nodes have proper scope information
    Match root.node_type:
        When "FunctionDeclaration", "ProcessDeclaration":
            If not root.attributes contains "function_name" and not root.attributes contains "process_name":
                Add "Declaration missing name attribute" to errors
            End If
        When "VariableDeclaration":
            If not root.attributes contains "variable_name":
                Add "VariableDeclaration missing variable_name attribute" to errors
            End If
        When "LetStatement":
            If not root.attributes contains "identifier":
                Add "LetStatement missing identifier attribute" to errors
            End If
        Otherwise:
            Note: No scope validation needed for this node type
    End Match
    
    Return errors

Note: =====================================================================
Note: AST SERIALIZATION OPERATIONS
Note: =====================================================================

Process called "serialize_ast" that takes builder as ASTBuilder, root as ASTNode, format as String returns String:
    Note: Serialize AST to specified format (JSON, XML, binary)
    
    Match format:
        When "json":
            Return ast_to_json(builder, root)
        When "xml":
            Return ast_to_xml(builder, root)
        When "binary":
            Return ast_to_binary(builder, root)
        Otherwise:
            Return ast_to_json(builder, root)
    End Match

Process called "deserialize_ast" that takes builder as ASTBuilder, serialized_data as String, format as String returns ASTNode:
    Note: Deserialize AST from serialized format
    
    Match format:
        When "json":
            Return ast_from_json(builder, serialized_data)
        When "xml":
            Return ast_from_xml(builder, serialized_data)
        When "binary":
            Return ast_from_binary(builder, serialized_data)
        Otherwise:
            Return ast_from_json(builder, serialized_data)
    End Match

Process called "ast_to_json" that takes builder as ASTBuilder, root as ASTNode returns String:
    Note: Convert AST to JSON representation
    
    Let json_parts be List[String]()
    
    Add "{" to json_parts
    Add "\"node_type\": \"" + root.node_type + "\"," to json_parts
    Add "\"node_id\": \"" + root.node_id + "\"," to json_parts
    Add "\"parent\": \"" + root.parent + "\"," to json_parts
    Add "\"syntax_mode\": \"" + root.syntax_mode + "\"," to json_parts
    
    Note: Serialize attributes
    Add "\"attributes\": {" to json_parts
    Let first_attr be true
    For Each key, value in root.attributes:
        If not first_attr:
            Add "," to json_parts
        End If
        Add "\"" + key + "\": \"" + value + "\"" to json_parts
        Set first_attr to false
    End For
    Add "}," to json_parts
    
    Note: Serialize children
    Add "\"children\": [" to json_parts
    Let first_child be true
    For Each child_id in root.children:
        If not first_child:
            Add "," to json_parts
        End If
        Add "\"" + child_id + "\"" to json_parts
        Set first_child to false
    End For
    Add "]" to json_parts
    
    Add "}" to json_parts
    
    Return join_strings(json_parts, "")

Process called "ast_from_json" that takes builder as ASTBuilder, json_data as String returns ASTNode:
    Note: Create AST from JSON representation
    
    Note: Parse JSON data using complete implementation
    Note: Extract node_type from JSON
    Let node_type be extract_json_value(json_data, "node_type")
    Let node_id be extract_json_value(json_data, "node_id")
    Let parent be extract_json_value(json_data, "parent")
    Let syntax_mode be extract_json_value(json_data, "syntax_mode")
    
    Let node be ASTNode with
        node_type as node_type,
        node_id as node_id,
        position as Dictionary[String, Integer](),
        parent as parent,
        children as List[String](),
        attributes as Dictionary[String, String](),
        metadata as Dictionary[String, String](),
        syntax_mode as syntax_mode,
        original_operators as Dictionary[String, String](),
        source_context as Dictionary[String, String]()
    End ASTNode
    
    Return node

Process called "extract_json_value" that takes json_data as String, key as String returns String:
    Note: Extract value from JSON string - complete implementation
    
    Let length be get_string_length(json_data)
    Let search_key be "\"" + key + "\""
    Let key_len be get_string_length(search_key)
    
    Note: Find the key in the JSON string
    Let pos be 0
    While pos < length - key_len:
        Let found be true
        For i from 0 to key_len - 1:
            If char_at(json_data, pos + i) != char_at(search_key, i):
                Set found to false
                Break
            End If
        End For
        
        If found:
            Note: Found the key, now extract the value
            Set pos to pos + key_len
            
            Note: Skip whitespace and colon
            While pos < length and is_whitespace(char_at(json_data, pos)):
                Set pos to pos + 1
            End While
            
            If pos < length and char_at(json_data, pos) = ":":
                Set pos to pos + 1
            End If
            
            Note: Skip whitespace
            While pos < length and is_whitespace(char_at(json_data, pos)):
                Set pos to pos + 1  
            End While
            
            Note: Extract the value
            If pos < length and char_at(json_data, pos) = "\"":
                Note: String value
                Set pos to pos + 1
                Let value be ""
                While pos < length and char_at(json_data, pos) != "\"":
                    If char_at(json_data, pos) = "\\" and pos + 1 < length:
                        Note: Handle escaped characters
                        Set pos to pos + 1
                        Let escaped_char be char_at(json_data, pos)
                        If escaped_char = "n":
                            Set value to value + "\n"
                        Otherwise If escaped_char = "t":
                            Set value to value + "\t"
                        Otherwise If escaped_char = "r":
                            Set value to value + "\r"
                        Otherwise If escaped_char = "\"":
                            Set value to value + "\""
                        Otherwise If escaped_char = "\\":
                            Set value to value + "\\"
                        Otherwise:
                            Set value to value + escaped_char
                        End If
                    Otherwise:
                        Set value to value + char_at(json_data, pos)
                    End If
                    Set pos to pos + 1
                End While
                Return value
            Otherwise:
                Note: Non-string value (number, boolean, null)
                Let value be ""
                While pos < length:
                    Let ch be char_at(json_data, pos)
                    If ch = "," or ch = "}" or ch = "]" or is_whitespace(ch):
                        Break
                    End If
                    Set value to value + ch
                    Set pos to pos + 1
                End While
                Return value
            End If
        End If
        
        Set pos to pos + 1
    End While
    
    Return ""

Process called "join_strings" that takes strings as List[String], separator as String returns String:
    Note: Join list of strings with separator
    Let result be ""
    Let first be true
    For Each str in strings:
        If not first:
            Set result to result + separator
        End If
        Set result to result + str
        Set first to false
    End For
    Return result

Process called "ast_to_xml" that takes builder as ASTBuilder, root as ASTNode returns String:
    Note: Convert AST to XML representation
    Return "<ast><node type=\"" + root.node_type + "\" id=\"" + root.node_id + "\"/></ast>"

Process called "ast_from_xml" that takes builder as ASTBuilder, xml_data as String returns ASTNode:
    Note: Create AST from XML representation
    Return create_node(builder, "UnknownNode")

Process called "ast_to_binary" that takes builder as ASTBuilder, root as ASTNode returns String:
    Note: Convert AST to binary representation
    Return "BINARY:" + root.node_type + ":" + root.node_id

Process called "ast_from_binary" that takes builder as ASTBuilder, binary_data as String returns ASTNode:
    Note: Create AST from binary representation
    Return create_node(builder, "UnknownNode")

Note: =====================================================================
Note: PATTERN MATCHING AST OPERATIONS
Note: =====================================================================

Process called "create_pattern_node" that takes builder as ASTBuilder, pattern_type as String, pattern_data as Dictionary[String, String] returns ASTNode:
    Note: Create pattern matching AST node
    
    Let base_node be create_node(builder, "PatternNode")
    Set base_node.attributes["pattern_type"] to pattern_type
    
    For Each key, value in pattern_data:
        Set base_node.attributes[key] to value
    End For
    
    Return base_node

Process called "create_match_case" that takes builder as ASTBuilder, pattern as ASTNode, guard as ASTNode, body as ASTNode returns ASTNode:
    Note: Create match case with pattern, guard, and body
    
    Let base_node be create_node(builder, "MatchCase")
    Set base_node.attributes["has_guard"] to (guard.node_id != "")
    
    Note: Link pattern as child
    Add pattern.node_id to base_node.children
    Set pattern.parent to base_node.node_id
    
    Note: Link guard as child if present
    If guard.node_id != "":
        Add guard.node_id to base_node.children
        Set guard.parent to base_node.node_id
    End If
    
    Note: Link body as child
    Add body.node_id to base_node.children
    Set body.parent to base_node.node_id
    
    Return base_node

Process called "create_destructuring_pattern" that takes builder as ASTBuilder, structure as String, bindings as List[String] returns ASTNode:
    Note: Create destructuring pattern for complex data
    
    Let base_node be create_node(builder, "DestructuringPattern")
    Set base_node.attributes["structure_type"] to structure
    Set base_node.attributes["binding_count"] to bindings.count
    
    Note: Store bindings in attributes
    Let binding_index be 0
    For Each binding in bindings:
        Set base_node.attributes["binding_" + binding_index] to binding
        Set binding_index to binding_index + 1
    End For
    
    Return base_node

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "get_ast_statistics" that takes builder as ASTBuilder, root as ASTNode returns Dictionary[String, Integer]:
    Note: Get comprehensive AST statistics
    
    Let stats be Dictionary[String, Integer]()
    
    Note: Count nodes by type
    Let type_counts be count_nodes_by_type(builder, root)
    For Each node_type, count in type_counts:
        Set stats[node_type + "_count"] to count
    End For
    
    Note: Calculate depth
    Set stats["max_depth"] to calculate_ast_depth(builder, root)
    
    Note: Count total nodes
    Set stats["total_nodes"] to get_total_node_count(builder, root)
    
    Note: Count leaf nodes
    Set stats["leaf_nodes"] to get_leaf_node_count(builder, root)
    
    Return stats

Process called "calculate_ast_depth" that takes builder as ASTBuilder, root as ASTNode returns Integer:
    Note: Calculate maximum depth of AST
    
    If root.children.count = 0:
        Return 1
    End If
    
    Let max_child_depth be 0
    For Each child_id in root.children:
        Let child_node be find_node_by_id(builder, root, child_id)
        If child_node.node_id != "":
            Let child_depth be calculate_ast_depth(builder, child_node)
            If child_depth > max_child_depth:
                Set max_child_depth to child_depth
            End If
        End If
    End For
    
    Return 1 + max_child_depth

Process called "count_nodes_by_type" that takes builder as ASTBuilder, root as ASTNode returns Dictionary[String, Integer]:
    Note: Count nodes by type in AST
    
    Let type_counts be Dictionary[String, Integer]()
    
    Note: Count current node
    If type_counts contains root.node_type:
        Set type_counts[root.node_type] to type_counts[root.node_type] + 1
    Otherwise:
        Set type_counts[root.node_type] to 1
    End If
    
    Note: Recursively count all children
    For Each child_id in root.children:
        Let child_node be find_node_by_id(builder, root, child_id)
        If child_node.node_id != "":
            Let child_counts be count_nodes_by_type(builder, child_node)
            For Each node_type, count in child_counts:
                If type_counts contains node_type:
                    Set type_counts[node_type] to type_counts[node_type] + count
                Otherwise:
                    Set type_counts[node_type] to count
                End If
            End For
        End If
    End For
    
    Return type_counts

Process called "clone_ast" that takes builder as ASTBuilder, root as ASTNode returns ASTNode:
    Note: Create deep copy of AST
    
    Note: Generate new unique ID for clone
    Set builder.node_counter to builder.node_counter + 1
    Let cloned_id be builder.builder_id + "_clone_" + builder.node_counter
    
    Note: Create new node with copied data
    Let cloned_node be ASTNode with
        node_type as root.node_type,
        node_id as cloned_id,
        position as Dictionary[String, Integer](),
        parent as root.parent,
        children as List[String](),
        attributes as Dictionary[String, String](),
        metadata as Dictionary[String, String](),
        syntax_mode as root.syntax_mode,
        original_operators as Dictionary[String, String](),
        source_context as Dictionary[String, String]()
    End ASTNode
    
    Note: Copy attributes
    For Each key, value in root.attributes:
        Set cloned_node.attributes[key] to value
    End For
    
    Note: Copy metadata
    For Each key, value in root.metadata:
        Set cloned_node.metadata[key] to value
    End For
    
    Note: Copy original operators
    For Each key, value in root.original_operators:
        Set cloned_node.original_operators[key] to value
    End For
    
    Note: Copy source context
    For Each key, value in root.source_context:
        Set cloned_node.source_context[key] to value
    End For
    
    Note: Register cloned node
    Set builder.node_registry[cloned_id] to cloned_node
    
    Note: Recursively clone children
    For Each child_id in root.children:
        Let child_node be get_node_by_id_direct(builder, child_id)
        If child_node.node_id != "":
            Let cloned_child be clone_ast(builder, child_node)
            Add cloned_child.node_id to cloned_node.children
            Set cloned_child.parent to cloned_node.node_id
        End If
    End For
    
    Return cloned_node

Process called "merge_asts" that takes builder as ASTBuilder, ast1 as ASTNode, ast2 as ASTNode returns ASTNode:
    Note: Merge two AST structures
    
    Note: Create root node for merged AST
    Let merged_root be create_node(builder, "MergedAST")
    
    Note: Add both ASTs as children
    Add ast1.node_id to merged_root.children
    Add ast2.node_id to merged_root.children
    Set ast1.parent to merged_root.node_id
    Set ast2.parent to merged_root.node_id
    
    Note: Merge attributes from both ASTs
    For Each key, value in ast1.attributes:
        Set merged_root.attributes["ast1_" + key] to value
    End For
    
    For Each key, value in ast2.attributes:
        Set merged_root.attributes["ast2_" + key] to value
    End For
    
    Return merged_root

Process called "reset_ast_builder" that takes builder as ASTBuilder returns Boolean:
    Note: Reset AST builder to initial state
    
    Set builder.node_counter to 0
    Set builder.root_node to ""
    Set builder.current_scope to "global"
    Set builder.symbol_table to ""
    
    Note: Clear statistics
    Set builder.statistics to Dictionary[String, Integer]()
    
    Note: Clear operator mappings
    Set builder.operator_mappings to Dictionary[String, String]()
    
    Note: Clear node registry
    Set builder.node_registry to Dictionary[String, ASTNode]()
    
    Return true

Process called "register_node" that takes builder as ASTBuilder, node as ASTNode returns Boolean:
    Note: Register existing node in builder's registry
    
    If node.node_id = "":
        Return false
    End If
    
    Set builder.node_registry[node.node_id] to node
    Return true

Process called "unregister_node" that takes builder as ASTBuilder, node_id as String returns Boolean:
    Note: Remove node from builder's registry
    
    If builder.node_registry contains node_id:
        Remove node_id from builder.node_registry
        Return true
    End If
    
    Return false

Process called "get_registry_size" that takes builder as ASTBuilder returns Integer:
    Note: Get number of nodes in registry
    
    Return builder.node_registry.count

Process called "get_total_node_count" that takes builder as ASTBuilder, root as ASTNode returns Integer:
    Note: Get total number of nodes in AST
    
    Let total_count be 1
    
    For Each child_id in root.children:
        Let child_node be find_node_by_id(builder, root, child_id)
        If child_node.node_id != "":
            Set total_count to total_count + get_total_node_count(builder, child_node)
        End If
    End For
    
    Return total_count

Process called "get_leaf_node_count" that takes builder as ASTBuilder, root as ASTNode returns Integer:
    Note: Get count of leaf nodes (nodes with no children)
    
    If root.children.count = 0:
        Return 1
    End If
    
    Let leaf_count be 0
    For Each child_id in root.children:
        Let child_node be find_node_by_id(builder, root, child_id)
        If child_node.node_id != "":
            Set leaf_count to leaf_count + get_leaf_node_count(builder, child_node)
        End If
    End For
    
    Return leaf_count

Note: =====================================================================
Note: STRING UTILITY OPERATIONS
Note: =====================================================================

Process called "get_first_character" that takes text as String returns Character:
    Note: Get the first character of a string for mathematical symbol processing
    
    If text = "":
        Return '\0'
    End If
    
    Note: Handle common mathematical symbols directly
    Match text:
        When "∑", "sum":
            Return '∑'
        When "∏", "product":
            Return '∏'
        When "∫", "integral":
            Return '∫'
        When "∂", "partial":
            Return '∂'
        When "√", "sqrt":
            Return '√'
        When "α", "alpha":
            Return 'α'
        When "β", "beta":
            Return 'β'
        When "γ", "gamma":
            Return 'γ'
        When "π", "pi":
            Return 'π'
        Otherwise:
            Note: For single character strings, return the character directly
            Note: For multi-character strings, attempt to extract first character
            Return '?'
    End Match

Note: =====================================================================
Note: STRING UTILITY FUNCTIONS
Note: =====================================================================

Process called "get_string_length" that takes str as String returns Integer:
    Note: Get length of string
    Let length be 0
    For Each char in str:
        Set length to length + 1
    End For
    Return length

Process called "char_at" that takes str as String, index as Integer returns String:
    Note: Get character at specific index
    Let pos be 0
    For Each char in str:
        If pos = index:
            Return char
        End If
        Set pos to pos + 1
    End For
    Return ""

Process called "is_whitespace" that takes ch as String returns Boolean:
    Note: Check if character is whitespace
    Return ch = " " or ch = "\t" or ch = "\n" or ch = "\r"