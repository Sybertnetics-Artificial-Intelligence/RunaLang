Note:
compiler/frontend/parsing/ast_builder.runa
High-Level AST Construction Helper Functions

This module provides convenient, high-level functions for building AST structures
that work with the core AST functionality from ast.runa. These functions provide:
- Streamlined AST construction for common patterns
- Error handling and validation during construction
- Type-specific builders for different AST node categories
- Batch operations for building complex AST structures
- Integration with parser components
- Natural language syntax support
- Technical syntax support
- Mathematical expression building
- Pattern matching construction
:End Note

Import Module "compiler/frontend/parsing/ast" As AST
Import Module "compiler/frontend/diagnostics/errors" As Errors

Note: =====================================================================
Note: BUILDER WRAPPER TYPES
Note: =====================================================================

Type called "BuildResult":
    success as Boolean
    node as String
    errors as List[String]
    warnings as List[String]

Type called "ExpressionBuilder":
    ast_builder as String
    current_precedence as Integer
    operator_stack as List[String]
    operand_stack as List[String]

Type called "StatementBuilder":
    ast_builder as String
    current_scope as String
    declaration_context as Boolean

Note: =====================================================================
Note: CONVENIENCE BUILDER CREATION
Note: =====================================================================

Process called "create_expression_builder" that takes builder_name as String, syntax_mode as String returns ExpressionBuilder:
    Note: Create specialized expression builder
    
    Let ast_builder be AST.create_ast_builder(builder_name + "_expr", syntax_mode)
    
    Let expr_builder be ExpressionBuilder with
        ast_builder as ast_builder.builder_id,
        current_precedence as 0,
        operator_stack as List[String](),
        operand_stack as List[String]()
    End ExpressionBuilder
    
    Return expr_builder

Process called "create_statement_builder" that takes builder_name as String, syntax_mode as String returns StatementBuilder:
    Note: Create specialized statement builder
    
    Let ast_builder be AST.create_ast_builder(builder_name + "_stmt", syntax_mode)
    
    Let stmt_builder be StatementBuilder with
        ast_builder as ast_builder.builder_id,
        current_scope as "global",
        declaration_context as false
    End StatementBuilder
    
    Return stmt_builder

Note: =====================================================================
Note: HIGH-LEVEL EXPRESSION BUILDING
Note: =====================================================================

Process called "build_binary_operation" that takes builder as ExpressionBuilder, left_expr as String, operator as String, right_expr as String returns BuildResult:
    Note: Build binary operation with proper precedence handling
    
    Let ast_builder be get_ast_builder_by_id(builder.ast_builder)
    Let left_node be get_node_by_id(left_expr)
    Let right_node be get_node_by_id(right_expr)
    
    If left_node.node_id = "" or right_node.node_id = "":
        Return BuildResult with
            success as false,
            node as "",
            errors as List[String]("Invalid operand nodes"),
            warnings as List[String]()
        End BuildResult
    End If
    
    Let expr_node be AST.create_binary_expression(ast_builder, operator, left_node, right_node)
    
    Return BuildResult with
        success as true,
        node as expr_node.base_node.node_id,
        errors as List[String](),
        warnings as List[String]()
    End BuildResult

Process called "build_function_call" that takes builder as ExpressionBuilder, function_name as String, arguments as List[String] returns BuildResult:
    Note: Build function call expression
    
    Let ast_builder be get_ast_builder_by_id(builder.ast_builder)
    Let function_node be AST.create_node(ast_builder, "Identifier")
    Set function_node.attributes["name"] to function_name
    
    Let argument_nodes be List[String]()
    For Each arg_id in arguments:
        Let arg_node be get_node_by_id(arg_id)
        If arg_node.node_id != "":
            Add arg_node to argument_nodes
        End If
    End For
    
    Let call_expr be AST.create_call_expression(ast_builder, function_node, argument_nodes)
    
    Return BuildResult with
        success as true,
        node as call_expr.base_node.node_id,
        errors as List[String](),
        warnings as List[String]()
    End BuildResult

Process called "build_mathematical_expression" that takes builder as ExpressionBuilder, symbol as String, operands as List[String] returns BuildResult:
    Note: Build mathematical expression with Greek symbols
    
    Let ast_builder be get_ast_builder_by_id(builder.ast_builder)
    
    Let operand_nodes be List[String]()
    For Each operand_id in operands:
        Let operand_node be get_node_by_id(operand_id)
        If operand_node.node_id != "":
            Add operand_node to operand_nodes
        End If
    End For
    
    Let math_expr be AST.create_mathematical_expression(ast_builder, symbol, operand_nodes)
    
    Return BuildResult with
        success as true,
        node as math_expr.base_node.node_id,
        errors as List[String](),
        warnings as List[String]()
    End BuildResult

Note: =====================================================================
Note: HIGH-LEVEL STATEMENT BUILDING
Note: =====================================================================

Process called "build_variable_declaration" that takes builder as StatementBuilder, variable_name as String, type_annotation as String, initial_value as String returns BuildResult:
    Note: Build variable declaration based on syntax mode
    
    Let ast_builder be get_ast_builder_by_id(builder.ast_builder)
    Let initializer_node be get_node_by_id(initial_value)
    
    If initializer_node.node_id = "":
        Set initializer_node to AST.create_node(ast_builder, "EmptyNode")
    End If
    
    Note: Choose declaration style based on syntax mode
    If ast_builder.current_mode = "natural":
        Let stmt_node be AST.create_let_statement(ast_builder, variable_name, type_annotation, initializer_node)
        Return BuildResult with
            success as true,
            node as stmt_node.base_node.node_id,
            errors as List[String](),
            warnings as List[String]()
        End BuildResult
    Otherwise:
        Let var_decl be AST.create_variable_declaration(ast_builder, variable_name, type_annotation, initializer_node)
        Return BuildResult with
            success as true,
            node as var_decl.base_node.node_id,
            errors as List[String](),
            warnings as List[String]()
        End BuildResult
    End If

Process called "build_function_declaration" that takes builder as StatementBuilder, function_name as String, parameters as List[String], return_type as String, body as String returns BuildResult:
    Note: Build function declaration based on syntax mode
    
    Let ast_builder be get_ast_builder_by_id(builder.ast_builder)
    
    Let parameter_nodes be List[String]()
    For Each param_id in parameters:
        Let param_node be get_node_by_id(param_id)
        If param_node.node_id != "":
            Add param_node to parameter_nodes
        End If
    End For
    
    Let body_node be get_node_by_id(body)
    If body_node.node_id = "":
        Set body_node to AST.create_node(ast_builder, "EmptyBlock")
    End If
    
    Note: Choose declaration style based on syntax mode
    If ast_builder.current_mode = "natural":
        Let proc_decl be AST.create_process_declaration(ast_builder, function_name, parameter_nodes, return_type, body_node)
        Return BuildResult with
            success as true,
            node as proc_decl.base_node.node_id,
            errors as List[String](),
            warnings as List[String]()
        End BuildResult
    Otherwise:
        Let func_decl be AST.create_function_declaration(ast_builder, function_name, parameter_nodes, return_type, body_node)
        Return BuildResult with
            success as true,
            node as func_decl.base_node.node_id,
            errors as List[String](),
            warnings as List[String]()
        End BuildResult
    End If

Process called "build_if_statement" that takes builder as StatementBuilder, condition as String, then_body as String, else_body as String returns BuildResult:
    Note: Build if statement with optional else clause
    
    Let ast_builder be get_ast_builder_by_id(builder.ast_builder)
    
    Let condition_node be get_node_by_id(condition)
    Let then_node be get_node_by_id(then_body)
    Let else_node be get_node_by_id(else_body)
    
    If condition_node.node_id = "" or then_node.node_id = "":
        Return BuildResult with
            success as false,
            node as "",
            errors as List[String]("Missing required condition or then body"),
            warnings as List[String]()
        End BuildResult
    End If
    
    If else_node.node_id = "":
        Set else_node to AST.create_node(ast_builder, "EmptyNode")
    End If
    
    Let if_stmt be AST.create_if_statement(ast_builder, condition_node, then_node, else_node)
    
    Return BuildResult with
        success as true,
        node as if_stmt.base_node.node_id,
        errors as List[String](),
        warnings as List[String]()
    End BuildResult

Note: =====================================================================
Note: BATCH BUILDING OPERATIONS
Note: =====================================================================

Process called "build_expression_sequence" that takes builder as ExpressionBuilder, expressions as List[String], operators as List[String] returns BuildResult:
    Note: Build sequence of expressions with operators
    
    If expressions.count != operators.count + 1:
        Return BuildResult with
            success as false,
            node as "",
            errors as List[String]("Expression count must be operator count + 1"),
            warnings as List[String]()
        End BuildResult
    End If
    
    Let current_expr be expressions[0]
    Let operator_index be 0
    
    For Each operator in operators:
        Let next_expr be expressions[operator_index + 1]
        Let binary_result be build_binary_operation(builder, current_expr, operator, next_expr)
        
        If not binary_result.success:
            Return binary_result
        End If
        
        Set current_expr to binary_result.node
        Set operator_index to operator_index + 1
    End For
    
    Return BuildResult with
        success as true,
        node as current_expr,
        errors as List[String](),
        warnings as List[String]()
    End BuildResult

Process called "build_statement_block" that takes builder as StatementBuilder, statements as List[String] returns BuildResult:
    Note: Build block of statements
    
    Let ast_builder be get_ast_builder_by_id(builder.ast_builder)
    Let block_node be AST.create_node(ast_builder, "BlockStatement")
    
    For Each stmt_id in statements:
        Let stmt_node be get_node_by_id(stmt_id)
        If stmt_node.node_id != "":
            Let added be AST.add_child_node(ast_builder, block_node, stmt_node)
            If not added:
                Return BuildResult with
                    success as false,
                    node as "",
                    errors as List[String]("Failed to add statement to block"),
                    warnings as List[String]()
                End BuildResult
            End If
        End If
    End For
    
    Return BuildResult with
        success as true,
        node as block_node.node_id,
        errors as List[String](),
        warnings as List[String]()
    End BuildResult

Note: =====================================================================
Note: PATTERN MATCHING BUILDERS
Note: =====================================================================

Process called "build_match_statement" that takes builder as StatementBuilder, match_expression as String, cases as List[String] returns BuildResult:
    Note: Build pattern matching statement
    
    Let ast_builder be get_ast_builder_by_id(builder.ast_builder)
    
    Let expr_node be get_node_by_id(match_expression)
    If expr_node.node_id = "":
        Return BuildResult with
            success as false,
            node as "",
            errors as List[String]("Missing match expression"),
            warnings as List[String]()
        End BuildResult
    End If
    
    Let case_nodes be List[String]()
    For Each case_id in cases:
        Let case_node be get_node_by_id(case_id)
        If case_node.node_id != "":
            Add case_node to case_nodes
        End If
    End For
    
    Let match_stmt be AST.create_match_statement(ast_builder, expr_node, case_nodes)
    
    Return BuildResult with
        success as true,
        node as match_stmt.base_node.node_id,
        errors as List[String](),
        warnings as List[String]()
    End BuildResult

Process called "build_pattern_case" that takes builder as StatementBuilder, pattern as String, guard as String, body as String returns BuildResult:
    Note: Build individual pattern matching case
    
    Let ast_builder be get_ast_builder_by_id(builder.ast_builder)
    
    Let pattern_node be get_node_by_id(pattern)
    Let body_node be get_node_by_id(body)
    
    If pattern_node.node_id = "" or body_node.node_id = "":
        Return BuildResult with
            success as false,
            node as "",
            errors as List[String]("Missing pattern or body"),
            warnings as List[String]()
        End BuildResult
    End If
    
    Let guard_node be get_node_by_id(guard)
    If guard_node.node_id = "":
        Set guard_node to AST.create_node(ast_builder, "EmptyNode")
    End If
    
    Let case_node be AST.create_match_case(ast_builder, pattern_node, guard_node, body_node)
    
    Return BuildResult with
        success as true,
        node as case_node.node_id,
        errors as List[String](),
        warnings as List[String]()
    End BuildResult

Note: =====================================================================
Note: UTILITY AND HELPER FUNCTIONS
Note: =====================================================================

Note: Global builder registry for multi-builder scenarios
Let global_builder_registry be Dictionary[String, String]()

Process called "get_ast_builder_by_id" that takes builder_id as String returns String:
    Note: Retrieve AST builder by ID from global registry
    
    If global_builder_registry contains builder_id:
        Return global_builder_registry[builder_id]
    End If
    
    Note: Create default builder if not found
    Let default_builder be AST.create_ast_builder("default", "natural")
    Set global_builder_registry[builder_id] to default_builder
    Return default_builder

Process called "register_ast_builder" that takes builder_id as String, builder as String returns Boolean:
    Note: Register AST builder in global registry
    
    Set global_builder_registry[builder_id] to builder
    Return true

Process called "get_node_by_id" that takes node_id as String returns String:
    Note: Retrieve AST node by ID - requires builder context
    Note: Creates a new empty node when no specific context is provided
    Note: For specific builder context, use get_node_by_id_from_builder
    
    Let empty_builder be AST.create_ast_builder("empty", "natural")
    Return AST.create_node(empty_builder, "EmptyNode")

Process called "get_node_by_id_from_builder" that takes builder as String, node_id as String returns String:
    Note: Retrieve AST node by ID from specific builder
    
    Return AST.get_node_by_id_direct(builder, node_id)

Process called "validate_build_result" that takes result as BuildResult returns Boolean:
    Note: Validate that build result is successful and complete
    
    If not result.success:
        Return false
    End If
    
    If result.node = "":
        Return false
    End If
    
    Return true

Process called "merge_build_errors" that takes results as List[BuildResult] returns List[String]:
    Note: Merge errors from multiple build results
    
    Let all_errors be List[String]()
    
    For Each result in results:
        For Each error in result.errors:
            Add error to all_errors
        End For
    End For
    
    Return all_errors

Process called "create_literal_node" that takes builder as ExpressionBuilder, literal_type as String, value as String returns BuildResult:
    Note: Create literal value node (numbers, strings, booleans)
    
    Let ast_builder be get_ast_builder_by_id(builder.ast_builder)
    Let literal_node be AST.create_node(ast_builder, "LiteralNode")
    
    Set literal_node.attributes["literal_type"] to literal_type
    Set literal_node.attributes["value"] to value
    
    Return BuildResult with
        success as true,
        node as literal_node.node_id,
        errors as List[String](),
        warnings as List[String]()
    End BuildResult

Process called "create_identifier_node" that takes builder as ExpressionBuilder, name as String returns BuildResult:
    Note: Create identifier node for variables and functions
    
    Let ast_builder be get_ast_builder_by_id(builder.ast_builder)
    Let identifier_node be AST.create_node(ast_builder, "IdentifierNode")
    
    Set identifier_node.attributes["name"] to name
    Set identifier_node.attributes["is_qualified"] to false
    
    Return BuildResult with
        success as true,
        node as identifier_node.node_id,
        errors as List[String](),
        warnings as List[String]()
    End BuildResult

Note: =====================================================================
Note: SYNTAX MODE HELPERS
Note: =====================================================================

Process called "build_for_natural_syntax" that takes builder as StatementBuilder, construct_type as String, data as Dictionary[String, String] returns BuildResult:
    Note: Build AST node using natural language patterns
    
    Match construct_type:
        When "variable_declaration":
            Return build_variable_declaration(builder, data["name"], data["type"], data["value"])
        When "function_declaration":
            Return build_function_declaration(builder, data["name"], List[String](), data["return_type"], data["body"])
        When "conditional":
            Return build_if_statement(builder, data["condition"], data["then_body"], data["else_body"])
        Otherwise:
            Return BuildResult with
                success as false,
                node as "",
                errors as List[String]("Unknown natural construct type: " + construct_type),
                warnings as List[String]()
            End BuildResult
    End Match

Process called "build_for_technical_syntax" that takes builder as StatementBuilder, construct_type as String, data as Dictionary[String, String] returns BuildResult:
    Note: Build AST node using technical syntax patterns
    
    Match construct_type:
        When "assignment":
            Let ast_builder be get_ast_builder_by_id(builder.ast_builder)
            Let target_node be get_node_by_id(data["target"])
            Let value_node be get_node_by_id(data["value"])
            Let assign_stmt be AST.create_assignment_statement(ast_builder, target_node, value_node)
            Return BuildResult with
                success as true,
                node as assign_stmt.base_node.node_id,
                errors as List[String](),
                warnings as List[String]()
            End BuildResult
        When "function_declaration":
            Return build_function_declaration(builder, data["name"], List[String](), data["return_type"], data["body"])
        Otherwise:
            Return BuildResult with
                success as false,
                node as "",
                errors as List[String]("Unknown technical construct type: " + construct_type),
                warnings as List[String]()
            End BuildResult
    End Match