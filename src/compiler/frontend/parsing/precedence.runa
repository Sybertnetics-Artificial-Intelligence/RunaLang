Note:
compiler/frontend/parsing/precedence.runa
Operator Precedence and Associativity Management

This module provides comprehensive precedence functionality including:
- Operator precedence tables for both natural and technical syntax
- Associativity rules management (left, right, none)
- Mathematical operator precedence (Greek symbols, summations, etc.)
- Context-sensitive precedence handling
- Precedence conflict resolution
- Dynamic precedence adjustment for parsing
- Integration with expression parsing algorithms
- Performance optimized precedence lookups
:End Note

Import Module "compiler/frontend/diagnostics/errors" As Errors

Note: =====================================================================
Note: PRECEDENCE DATA STRUCTURES
Note: =====================================================================

Type called "PrecedenceLevel":
    level as Integer
    associativity as String
    operators as List[String]
    is_mathematical as Boolean
    context_sensitive as Boolean

Type called "PrecedenceTable":
    table_id as String
    syntax_mode as String
    levels as List[PrecedenceLevel]
    operator_map as Dictionary[String, PrecedenceLevel]
    context_rules as Dictionary[String, String]

Type called "PrecedenceManager":
    manager_id as String
    natural_table as PrecedenceTable
    technical_table as PrecedenceTable
    mathematical_table as PrecedenceTable
    current_mode as String
    statistics as Dictionary[String, Integer]

Note: =====================================================================
Note: PRECEDENCE MANAGER OPERATIONS
Note: =====================================================================

Process called "create_precedence_manager" that takes manager_name as String returns PrecedenceManager:
    Note: Create precedence manager with dual syntax support
    
    Let manager be PrecedenceManager with
        manager_id as manager_name,
        natural_table as create_empty_precedence_table("natural"),
        technical_table as create_empty_precedence_table("technical"),
        mathematical_table as create_empty_precedence_table("mathematical"),
        current_mode as "technical",
        statistics as Dictionary[String, Integer]()
    End PrecedenceManager
    
    Note: Initialize all precedence tables
    Call initialize_natural_precedence(manager)
    Call initialize_technical_precedence(manager)
    Call initialize_mathematical_precedence(manager)
    
    Return manager

Process called "initialize_natural_precedence" that takes manager as PrecedenceManager returns Boolean:
    Note: Initialize precedence table for natural language operators
    
    Note: Create precedence levels for natural language
    Let logical_or_level be PrecedenceLevel with
        level as 1,
        associativity as "left",
        operators as List[String]("Or"),
        is_mathematical as false,
        context_sensitive as false
    End PrecedenceLevel
    
    Let logical_and_level be PrecedenceLevel with
        level as 2,
        associativity as "left",
        operators as List[String]("And"),
        is_mathematical as false,
        context_sensitive as false
    End PrecedenceLevel
    
    Let equality_level be PrecedenceLevel with
        level as 3,
        associativity as "none",
        operators as List[String]("is equal to", "is not equal to"),
        is_mathematical as false,
        context_sensitive as false
    End PrecedenceLevel
    
    Let comparison_level be PrecedenceLevel with
        level as 4,
        associativity as "none",
        operators as List[String]("is less than", "is greater than", "is less than or equal to", "is greater than or equal to"),
        is_mathematical as false,
        context_sensitive as false
    End PrecedenceLevel
    
    Let additive_level be PrecedenceLevel with
        level as 5,
        associativity as "left",
        operators as List[String]("plus", "minus"),
        is_mathematical as false,
        context_sensitive as false
    End PrecedenceLevel
    
    Let multiplicative_level be PrecedenceLevel with
        level as 6,
        associativity as "left",
        operators as List[String]("multiplied by", "divided by", "modulo"),
        is_mathematical as false,
        context_sensitive as false
    End PrecedenceLevel
    
    Let power_level be PrecedenceLevel with
        level as 7,
        associativity as "right",
        operators as List[String]("to the power of"),
        is_mathematical as false,
        context_sensitive as false
    End PrecedenceLevel
    
    Note: Add levels to natural table
    Add logical_or_level to manager.natural_table.levels
    Add logical_and_level to manager.natural_table.levels
    Add equality_level to manager.natural_table.levels
    Add comparison_level to manager.natural_table.levels
    Add additive_level to manager.natural_table.levels
    Add multiplicative_level to manager.natural_table.levels
    Add power_level to manager.natural_table.levels
    
    Note: Build operator map for fast lookup
    For Each level in manager.natural_table.levels:
        For Each operator in level.operators:
            Set manager.natural_table.operator_map[operator] to level
        End For
    End For
    
    Return true

Process called "initialize_technical_precedence" that takes manager as PrecedenceManager returns Boolean:
    Note: Initialize precedence table for technical syntax operators
    
    Note: Get operators from lexical infrastructure
    Import Module "compiler/frontend/lexical/operators" As Operators
    Let operator_list be Operators.get_all_operators()
    
    Note: Group operators by precedence level
    Let precedence_groups be Dictionary[Integer, List[String]]()
    
    For Each op in operator_list:
        If precedence_groups.contains_key(op.precedence):
            Add op.symbol_form to precedence_groups[op.precedence]
        Otherwise:
            Set precedence_groups[op.precedence] to List[String](op.symbol_form)
        End If
    End For
    
    Note: Create precedence levels for each group
    For Each precedence, operators in precedence_groups:
        Let associativity be determine_associativity_for_precedence(precedence)
        
        Let level be PrecedenceLevel with
            level as precedence,
            associativity as associativity,
            operators as operators,
            is_mathematical as false,
            context_sensitive as false
        End PrecedenceLevel
        
        Add level to manager.technical_table.levels
        
        Note: Add to operator map
        For Each operator in operators:
            Set manager.technical_table.operator_map[operator] to level
        End For
    End For
    
    Return true

Process called "initialize_mathematical_precedence" that takes manager as PrecedenceManager returns Boolean:
    Note: Initialize precedence table for mathematical symbols
    
    Note: Get mathematical symbols from lexical infrastructure
    Import Module "compiler/frontend/lexical/math_symbols" As MathSymbols
    Let math_table be MathSymbols.create_math_symbol_table()
    
    Note: Create precedence levels for mathematical operators
    Let summation_level be PrecedenceLevel with
        level as 10,
        associativity as "right",
        operators as List[String]("∑", "∏", "∫", "sum", "product", "integral"),
        is_mathematical as true,
        context_sensitive as true
    End PrecedenceLevel
    
    Let differential_level be PrecedenceLevel with
        level as 9,
        associativity as "right",
        operators as List[String]("∂", "∇", "partial", "gradient"),
        is_mathematical as true,
        context_sensitive as true
    End PrecedenceLevel
    
    Let set_theory_level be PrecedenceLevel with
        level as 8,
        associativity as "left",
        operators as List[String]("∈", "∉", "⊂", "⊃", "∪", "∩", "element_of", "subset_of", "union", "intersection"),
        is_mathematical as true,
        context_sensitive as false
    End PrecedenceLevel
    
    Add summation_level to manager.mathematical_table.levels
    Add differential_level to manager.mathematical_table.levels
    Add set_theory_level to manager.mathematical_table.levels
    
    Note: Build operator map
    For Each level in manager.mathematical_table.levels:
        For Each operator in level.operators:
            Set manager.mathematical_table.operator_map[operator] to level
        End For
    End For
    
    Return true

Note: =====================================================================
Note: PRECEDENCE LOOKUP OPERATIONS
Note: =====================================================================

Process called "get_operator_precedence" that takes manager as PrecedenceManager, operator as String returns Integer:
    Note: Get precedence level for operator in current mode
    
    Let active_table be get_active_precedence_table(manager)
    
    If active_table.operator_map.contains_key(operator):
        Return active_table.operator_map[operator].level
    End If
    
    Note: Try fallback to other tables if not found
    If manager.current_mode != "natural":
        If manager.natural_table.operator_map.contains_key(operator):
            Return manager.natural_table.operator_map[operator].level
        End If
    End If
    
    If manager.current_mode != "technical":
        If manager.technical_table.operator_map.contains_key(operator):
            Return manager.technical_table.operator_map[operator].level
        End If
    End If
    
    If manager.current_mode != "mathematical":
        If manager.mathematical_table.operator_map.contains_key(operator):
            Return manager.mathematical_table.operator_map[operator].level
        End If
    End If
    
    Return 0

Process called "get_operator_associativity" that takes manager as PrecedenceManager, operator as String returns String:
    Note: Get associativity (left, right, none) for operator
    
    Let active_table be get_active_precedence_table(manager)
    
    If active_table.operator_map.contains_key(operator):
        Return active_table.operator_map[operator].associativity
    End If
    
    Note: Try fallback to other tables if not found
    If manager.current_mode != "natural":
        If manager.natural_table.operator_map.contains_key(operator):
            Return manager.natural_table.operator_map[operator].associativity
        End If
    End If
    
    If manager.current_mode != "technical":
        If manager.technical_table.operator_map.contains_key(operator):
            Return manager.technical_table.operator_map[operator].associativity
        End If
    End If
    
    If manager.current_mode != "mathematical":
        If manager.mathematical_table.operator_map.contains_key(operator):
            Return manager.mathematical_table.operator_map[operator].associativity
        End If
    End If
    
    Return "left"

Process called "compare_precedence" that takes manager as PrecedenceManager, op1 as String, op2 as String returns Integer:
    Note: Compare precedence between two operators (-1, 0, 1)
    
    Let prec1 be get_operator_precedence(manager, op1)
    Let prec2 be get_operator_precedence(manager, op2)
    
    If prec1 < prec2:
        Return -1
    End If
    
    If prec1 > prec2:
        Return 1
    End If
    
    Return 0

Process called "is_higher_precedence" that takes manager as PrecedenceManager, op1 as String, op2 as String returns Boolean:
    Note: Check if first operator has higher precedence than second
    
    Let comparison_result be compare_precedence(manager, op1, op2)
    Return comparison_result = 1

Process called "is_same_precedence" that takes manager as PrecedenceManager, op1 as String, op2 as String returns Boolean:
    Note: Check if operators have same precedence level
    
    Let comparison_result be compare_precedence(manager, op1, op2)
    Return comparison_result = 0

Note: =====================================================================
Note: NATURAL LANGUAGE PRECEDENCE OPERATIONS
Note: =====================================================================

Process called "get_natural_arithmetic_precedence" that takes manager as PrecedenceManager, operator as String returns Integer:
    Note: Get precedence for natural arithmetic operators ("plus", "times", etc.)
    
    If operator = "times" or operator = "multiplied by":
        Return 14
    End If
    If operator = "divided by" or operator = "over":
        Return 14
    End If
    If operator = "modulo" or operator = "remainder":
        Return 14
    End If
    If operator = "plus" or operator = "added to":
        Return 13
    End If
    If operator = "minus" or operator = "subtracted by":
        Return 13
    End If
    If operator = "raised to" or operator = "to the power of":
        Return 15
    End If
    
    Return 0

Process called "get_natural_comparison_precedence" that takes manager as PrecedenceManager, operator as String returns Integer:
    Note: Get precedence for natural comparison operators ("is equal to", etc.)
    
    If operator = "is equal to" or operator = "equals":
        Return 9
    End If
    If operator = "is not equal to" or operator = "does not equal":
        Return 9
    End If
    If operator = "is greater than" or operator = "exceeds":
        Return 10
    End If
    If operator = "is less than" or operator = "is below":
        Return 10
    End If
    If operator = "is greater than or equal to" or operator = "is at least":
        Return 10
    End If
    If operator = "is less than or equal to" or operator = "is at most":
        Return 10
    End If
    
    Return 0

Process called "get_natural_logical_precedence" that takes manager as PrecedenceManager, operator as String returns Integer:
    Note: Get precedence for natural logical operators ("and", "or", "not")
    
    If operator = "not":
        Return 16
    End If
    If operator = "and":
        Return 5
    End If
    If operator = "or":
        Return 4
    End If
    If operator = "xor" or operator = "exclusive or":
        Return 4
    End If
    If operator = "implies" or operator = "then":
        Return 3
    End If
    If operator = "if and only if" or operator = "iff":
        Return 2
    End If
    
    Return 0

Note: =====================================================================
Note: TECHNICAL SYNTAX PRECEDENCE OPERATIONS
Note: =====================================================================

Process called "get_technical_arithmetic_precedence" that takes manager as PrecedenceManager, operator as String returns Integer:
    Note: Get precedence for technical arithmetic operators (+, -, *, /, %)
    
    If operator = "*" or operator = "/" or operator = "%":
        Return 14
    End If
    If operator = "+" or operator = "-":
        Return 13
    End If
    If operator = "**" or operator = "^":
        Return 15
    End If
    
    Return 0

Process called "get_technical_bitwise_precedence" that takes manager as PrecedenceManager, operator as String returns Integer:
    Note: Get precedence for technical bitwise operators (&, |, ^, <<, >>)
    
    If operator = "<<" or operator = ">>" or operator = ">>>":
        Return 11
    End If
    If operator = "&":
        Return 8
    End If
    If operator = "^":
        Return 7
    End If
    If operator = "|":
        Return 6
    End If
    If operator = "~":
        Return 16
    End If
    
    Return 0

Process called "get_technical_assignment_precedence" that takes manager as PrecedenceManager, operator as String returns Integer:
    Note: Get precedence for technical assignment operators (=, +=, -=, etc.)
    
    If operator = "=" or operator = "+=" or operator = "-=" or 
       operator = "*=" or operator = "/=" or operator = "%=" or
       operator = "&=" or operator = "|=" or operator = "^=" or
       operator = "<<=" or operator = ">>=":
        Return 1
    End If
    
    Return 0

Note: =====================================================================
Note: MATHEMATICAL SYMBOL PRECEDENCE OPERATIONS
Note: =====================================================================

Process called "get_mathematical_operator_precedence" that takes manager as PrecedenceManager, symbol as String returns Integer:
    Note: Get precedence for mathematical symbols (∑, ∏, ∫, ∇, etc.)
    
    Import Module "compiler/frontend/lexical/math_symbols" As MathSymbols
    
    If symbol = "∑" or symbol = "∏" or symbol = "∫":
        Return 17
    End If
    If symbol = "∇" or symbol = "∂":
        Return 16
    End If
    If symbol = "√" or symbol = "∛":
        Return 15
    End If
    If symbol = "×" or symbol = "÷":
        Return 14
    End If
    If symbol = "±" or symbol = "∓":
        Return 13
    End If
    If symbol = "∞" or symbol = "∅":
        Return 12
    End If
    
    Return 0

Process called "get_greek_variable_precedence" that takes manager as PrecedenceManager, symbol as String returns Integer:
    Note: Get precedence for Greek letter variables (α, β, γ, etc.)
    
    Note: Greek variables don't have precedence themselves, they're identifiers
    Note: Return 0 to indicate no operator precedence
    Return 0

Process called "get_set_theory_precedence" that takes manager as PrecedenceManager, symbol as String returns Integer:
    Note: Get precedence for set theory operators (∈, ∪, ∩, ⊂, etc.)
    
    If symbol = "∈" or symbol = "∉" or symbol = "∋" or symbol = "∌":
        Return 10
    End If
    If symbol = "⊂" or symbol = "⊃" or symbol = "⊆" or symbol = "⊇":
        Return 10
    End If
    If symbol = "∩":
        Return 8
    End If
    If symbol = "∪":
        Return 7
    End If
    If symbol = "∖" or symbol = "∆":
        Return 9
    End If
    
    Return 0

Process called "get_calculus_precedence" that takes manager as PrecedenceManager, symbol as String returns Integer:
    Note: Get precedence for calculus operators (∂, ∫, lim, etc.)
    
    If symbol = "∫" or symbol = "∬" or symbol = "∭" or symbol = "∮":
        Return 17
    End If
    If symbol = "∂" or symbol = "d/dx":
        Return 16
    End If
    If symbol = "lim" or symbol = "→":
        Return 15
    End If
    If symbol = "∇" or symbol = "div" or symbol = "curl":
        Return 16
    End If
    
    Return 0

Note: =====================================================================
Note: CONTEXT-SENSITIVE PRECEDENCE OPERATIONS
Note: =====================================================================

Process called "get_contextual_precedence" that takes manager as PrecedenceManager, operator as String, context as String returns Integer:
    Note: Get precedence based on parsing context
    
    Note: First get base precedence based on context syntax mode
    Let base_precedence be 0
    
    If context = "natural":
        Set base_precedence to get_natural_arithmetic_precedence(manager, operator)
        If base_precedence = 0:
            Set base_precedence to get_natural_comparison_precedence(manager, operator)
        End If
        If base_precedence = 0:
            Set base_precedence to get_natural_logical_precedence(manager, operator)
        End If
    End If
    
    If context = "technical" or context = "developer":
        Set base_precedence to get_technical_arithmetic_precedence(manager, operator)
        If base_precedence = 0:
            Set base_precedence to get_technical_bitwise_precedence(manager, operator)
        End If
        If base_precedence = 0:
            Set base_precedence to get_technical_assignment_precedence(manager, operator)
        End If
    End If
    
    If context = "mathematical":
        Set base_precedence to get_mathematical_operator_precedence(manager, operator)
        If base_precedence = 0:
            Set base_precedence to get_set_theory_precedence(manager, operator)
        End If
        If base_precedence = 0:
            Set base_precedence to get_calculus_precedence(manager, operator)
        End If
    End If
    
    Return base_precedence

Process called "adjust_precedence_for_context" that takes manager as PrecedenceManager, operator as String, context as String returns Integer:
    Note: Adjust operator precedence based on context
    
    Let base_precedence be get_contextual_precedence(manager, operator, context)
    
    Note: Apply context-specific adjustments
    If context = "parenthesized":
        Return base_precedence + 100
    End If
    
    If context = "function_argument":
        Return base_precedence - 10
    End If
    
    If context = "array_index":
        Return base_precedence - 5
    End If
    
    If context = "conditional":
        If operator = "and" or operator = "or":
            Return base_precedence - 2
        End If
    End If
    
    Return base_precedence

Process called "resolve_precedence_conflict" that takes manager as PrecedenceManager, op1 as String, op2 as String, context as String returns String:
    Note: Resolve precedence conflicts using context rules
    
    Let prec1 be get_contextual_precedence(manager, op1, context)
    Let prec2 be get_contextual_precedence(manager, op2, context)
    
    If prec1 > prec2:
        Return op1
    End If
    
    If prec2 > prec1:
        Return op2
    End If
    
    Note: Same precedence, check associativity
    Let assoc1 be get_operator_associativity(manager, op1, context)
    Let assoc2 be get_operator_associativity(manager, op2, context)
    
    If assoc1 = "left" and assoc2 = "left":
        Return op1
    End If
    
    If assoc1 = "right" and assoc2 = "right":
        Return op2
    End If
    
    Note: Non-associative or conflicting associativity
    Return "error"

Note: =====================================================================
Note: ASSOCIATIVITY OPERATIONS
Note: =====================================================================

Process called "get_left_associative_operators" that takes manager as PrecedenceManager returns List[String]:
    Note: Get all left-associative operators
    
    Let left_ops be List[String]()
    
    Note: Arithmetic operators (left associative)
    Add "+" to left_ops
    Add "-" to left_ops
    Add "*" to left_ops
    Add "/" to left_ops
    Add "%" to left_ops
    Add "plus" to left_ops
    Add "minus" to left_ops
    Add "times" to left_ops
    Add "divided by" to left_ops
    
    Note: Comparison operators (left associative)
    Add "==" to left_ops
    Add "!=" to left_ops
    Add "<" to left_ops
    Add ">" to left_ops
    Add "<=" to left_ops
    Add ">=" to left_ops
    Add "is equal to" to left_ops
    Add "is not equal to" to left_ops
    
    Note: Bitwise operators (left associative)
    Add "&" to left_ops
    Add "|" to left_ops
    Add "^" to left_ops
    Add "<<" to left_ops
    Add ">>" to left_ops
    
    Note: Logical operators (left associative)
    Add "&&" to left_ops
    Add "||" to left_ops
    Add "and" to left_ops
    Add "or" to left_ops
    
    Return left_ops

Process called "get_right_associative_operators" that takes manager as PrecedenceManager returns List[String]:
    Note: Get all right-associative operators
    
    Let right_ops be List[String]()
    
    Note: Assignment operators (right associative)
    Add "=" to right_ops
    Add "+=" to right_ops
    Add "-=" to right_ops
    Add "*=" to right_ops
    Add "/=" to right_ops
    Add "%=" to right_ops
    Add "&=" to right_ops
    Add "|=" to right_ops
    Add "^=" to right_ops
    Add "<<=" to right_ops
    Add ">>=" to right_ops
    
    Note: Exponentiation (right associative)
    Add "**" to right_ops
    Add "raised to" to right_ops
    Add "to the power of" to right_ops
    
    Note: Ternary operator (right associative)
    Add "?:" to right_ops
    
    Return right_ops

Process called "get_non_associative_operators" that takes manager as PrecedenceManager returns List[String]:
    Note: Get all non-associative operators
    
    Let non_assoc_ops be List[String]()
    
    Note: Set membership operators
    Add "∈" to non_assoc_ops
    Add "∉" to non_assoc_ops
    Add "⊂" to non_assoc_ops
    Add "⊃" to non_assoc_ops
    
    Return non_assoc_ops

Process called "check_associativity_conflict" that takes manager as PrecedenceManager, operators as List[String] returns Boolean:
    Note: Check for associativity conflicts in operator sequence
    
    If operators.count < 2:
        Return false
    End If
    
    For i from 0 to operators.count - 2:
        Let op1 be operators[i]
        Let op2 be operators[i + 1]
        
        Let assoc1 be get_operator_associativity(manager, op1, "technical")
        Let assoc2 be get_operator_associativity(manager, op2, "technical")
        
        Note: Check if operators have same precedence
        Let prec1 be get_operator_precedence(manager, op1, "technical")
        Let prec2 be get_operator_precedence(manager, op2, "technical")
        
        If prec1 = prec2:
            Note: Same precedence but different associativity = conflict
            If (assoc1 = "left" and assoc2 = "right") or (assoc1 = "right" and assoc2 = "left"):
                Return true
            End If
            
            Note: Non-associative with any other = conflict
            If assoc1 = "none" or assoc2 = "none":
                Return true
            End If
        End If
    End For
    
    Return false

Note: =====================================================================
Note: PRECEDENCE TABLE MANAGEMENT
Note: =====================================================================

Process called "add_operator_precedence" that takes manager as PrecedenceManager, operator as String, precedence as Integer, associativity as String returns Boolean:
    Note: Add new operator with precedence and associativity
    
    Let active_table be get_active_precedence_table(manager)
    
    Note: Find existing level or create new one
    Let target_level be get_precedence_level_by_value(active_table, precedence)
    
    If target_level.level = -1:
        Note: Create new precedence level
        Set target_level to PrecedenceLevel with
            level as precedence,
            associativity as associativity,
            operators as List[String](),
            is_mathematical as (manager.current_mode = "mathematical"),
            context_sensitive as false
        End PrecedenceLevel
        
        Add target_level to active_table.levels
    End If
    
    Note: Add operator to level
    If not target_level.operators.contains(operator):
        Add operator to target_level.operators
        Set active_table.operator_map[operator] to target_level
        Return true
    End If
    
    Return false

Process called "update_operator_precedence" that takes manager as PrecedenceManager, operator as String, new_precedence as Integer returns Boolean:
    Note: Update precedence level for existing operator
    
    Let active_table be get_active_precedence_table(manager)
    
    Note: Check if operator exists
    If not active_table.operator_map.contains(operator):
        Return false
    End If
    
    Note: Remove from old level
    Let old_level be active_table.operator_map[operator]
    Remove operator from old_level.operators
    
    Note: Find or create new level
    Let new_level be get_precedence_level_by_value(active_table, new_precedence)
    
    If new_level.level = -1:
        Note: Create new level
        Set new_level to PrecedenceLevel with
            level as new_precedence,
            associativity as old_level.associativity,
            operators as List[String](),
            is_mathematical as old_level.is_mathematical,
            context_sensitive as old_level.context_sensitive
        End PrecedenceLevel
        Add new_level to active_table.levels
    End If
    
    Note: Add to new level
    Add operator to new_level.operators
    Set active_table.operator_map[operator] to new_level
    
    Note: Update statistics
    Set manager.statistics["precedence_updates"] to manager.statistics.get("precedence_updates", 0) + 1
    
    Return true

Process called "remove_operator_precedence" that takes manager as PrecedenceManager, operator as String returns Boolean:
    Note: Remove operator from precedence table
    
    Let active_table be get_active_precedence_table(manager)
    
    Note: Check if operator exists
    If not active_table.operator_map.contains(operator):
        Return false
    End If
    
    Note: Remove from level
    Let level be active_table.operator_map[operator]
    Remove operator from level.operators
    
    Note: Remove from map
    Remove operator from active_table.operator_map
    
    Note: Clean up empty levels
    If level.operators.count = 0:
        Remove level from active_table.levels
    End If
    
    Note: Update statistics
    Set manager.statistics["operators_removed"] to manager.statistics.get("operators_removed", 0) + 1
    
    Return true

Process called "validate_precedence_table" that takes manager as PrecedenceManager returns List[String]:
    Note: Validate precedence table for consistency
    
    Let errors be List[String]()
    Let active_table be get_active_precedence_table(manager)
    
    Note: Check for duplicate operators across levels
    Let seen_operators be Dictionary[String, Integer]()
    
    For Each level in active_table.levels:
        For Each operator in level.operators:
            If seen_operators.contains(operator):
                Add "Duplicate operator '" + operator + "' found at levels " + seen_operators[operator] + " and " + level.level to errors
            Otherwise:
                Set seen_operators[operator] to level.level
            End If
        End For
    End For
    
    Note: Validate operator map consistency
    For Each operator_key in active_table.operator_map.keys:
        Let mapped_level be active_table.operator_map[operator_key]
        If not mapped_level.operators.contains(operator_key):
            Add "Operator '" + operator_key + "' in map but not in level operators list" to errors
        End If
    End For
    
    Note: Check for invalid associativity values
    For Each level in active_table.levels:
        If level.associativity != "left" and level.associativity != "right" and level.associativity != "none":
            Add "Invalid associativity '" + level.associativity + "' for level " + level.level to errors
        End If
    End For
    
    Note: Check for gaps in precedence levels
    Let levels_sorted be sort_precedence_levels(active_table.levels)
    For i from 0 to levels_sorted.count - 2:
        Let gap be levels_sorted[i + 1].level - levels_sorted[i].level
        If gap > 10:
            Add "Large gap (" + gap + ") between precedence levels " + levels_sorted[i].level + " and " + levels_sorted[i + 1].level to errors
        End If
    End For
    
    Return errors

Note: =====================================================================
Note: MODE SWITCHING OPERATIONS
Note: =====================================================================

Process called "switch_precedence_mode" that takes manager as PrecedenceManager, new_mode as String returns Boolean:
    Note: Switch between natural/technical/mathematical precedence modes
    
    Note: Validate mode
    Match new_mode:
        When "natural", "technical", "mathematical":
            Set manager.current_mode to new_mode
            Set manager.statistics["mode_switches"] to manager.statistics.get("mode_switches", 0) + 1
            Return true
        Otherwise:
            Return false
    End Match

Process called "convert_precedence_natural_to_technical" that takes manager as PrecedenceManager, natural_operator as String returns String:
    Note: Convert natural language operator to technical with precedence
    
    Import Module "compiler/frontend/lexical/operators" As Operators
    
    Note: Direct mapping of common natural operators to technical
    Match natural_operator:
        When "plus", "added to":
            Return "+"
        When "minus", "subtracted by":
            Return "-"
        When "times", "multiplied by":
            Return "*"
        When "divided by", "over":
            Return "/"
        When "modulo", "remainder":
            Return "%"
        When "raised to", "to the power of":
            Return "**"
        When "is equal to", "equals":
            Return "=="
        When "is not equal to", "does not equal":
            Return "!="
        When "is greater than", "exceeds":
            Return ">"
        When "is less than", "is below":
            Return "<"
        When "is greater than or equal to", "is at least":
            Return ">="
        When "is less than or equal to", "is at most":
            Return "<="
        When "and":
            Return "&&"
        When "or":
            Return "||"
        When "not":
            Return "!"
        When "xor", "exclusive or":
            Return "^"
        Otherwise:
            Note: Use lexical operator conversion as fallback
            Return Operators.convert_natural_to_technical(natural_operator)
    End Match

Process called "convert_precedence_technical_to_natural" that takes manager as PrecedenceManager, technical_operator as String returns String:
    Note: Convert technical operator to natural with precedence
    
    Import Module "compiler/frontend/lexical/operators" As Operators
    
    Note: Direct mapping of common technical operators to natural
    Match technical_operator:
        When "+":
            Return "plus"
        When "-":
            Return "minus"
        When "*":
            Return "times"
        When "/":
            Return "divided by"
        When "%":
            Return "modulo"
        When "**", "^":
            Return "raised to"
        When "==":
            Return "is equal to"
        When "!=":
            Return "is not equal to"
        When ">":
            Return "is greater than"
        When "<":
            Return "is less than"
        When ">=":
            Return "is greater than or equal to"
        When "<=":
            Return "is less than or equal to"
        When "&&":
            Return "and"
        When "||":
            Return "or"
        When "!":
            Return "not"
        When "^":
            Return "xor"
        When "=":
            Return "is set to"
        When "+=":
            Return "is increased by"
        When "-=":
            Return "is decreased by"
        When "*=":
            Return "is multiplied by"
        When "/=":
            Return "is divided by"
        Otherwise:
            Note: Use lexical operator conversion as fallback
            Return Operators.convert_technical_to_natural(technical_operator)
    End Match

Note: =====================================================================
Note: PARSING INTEGRATION OPERATIONS
Note: =====================================================================

Process called "create_precedence_climbing_parser" that takes manager as PrecedenceManager returns String:
    Note: Create precedence climbing parser using precedence table
    
    Note: Generate unique parser ID based on manager configuration
    Let parser_id be "precedence_parser_" + manager.manager_id + "_" + manager.current_mode
    
    Note: Register parser with manager statistics
    Set manager.statistics["parsers_created"] to manager.statistics.get("parsers_created", 0) + 1
    Set manager.statistics["last_parser_created"] to get_current_timestamp()
    
    Return parser_id

Process called "parse_with_precedence" that takes manager as PrecedenceManager, tokens as List[String], min_precedence as Integer returns String:
    Note: Parse expression using precedence climbing algorithm
    
    If tokens.count = 0:
        Return ""
    End If
    
    If tokens.count = 1:
        Return tokens[0]
    End If
    
    Note: Find the operator with lowest precedence >= min_precedence
    Let split_index be find_main_operator_index(manager, tokens, min_precedence)
    
    If split_index = -1:
        Note: No operator found, treat as single expression
        Return tokens[0]
    End If
    
    Let operator be tokens[split_index]
    Let left_tokens be tokens.slice(0, split_index)
    Let right_tokens be tokens.slice(split_index + 1, tokens.count)
    
    Note: Recursively parse left and right sides
    Let left_result be parse_with_precedence(manager, left_tokens, 0)
    
    Note: For right-associative operators, use same precedence; for left-associative, use higher
    Let operator_prec be get_operator_precedence(manager, operator)
    Let operator_assoc be get_operator_associativity(manager, operator)
    
    Let right_min_prec be operator_prec
    If operator_assoc = "left":
        Set right_min_prec to operator_prec + 1
    End If
    
    Let right_result be parse_with_precedence(manager, right_tokens, right_min_prec)
    
    Note: Combine results
    Return "(" + left_result + " " + operator + " " + right_result + ")"

Process called "handle_operator_precedence_in_parsing" that takes manager as PrecedenceManager, current_op as String, next_op as String returns String:
    Note: Handle operator precedence during parsing
    
    Let current_prec be get_operator_precedence(manager, current_op)
    Let next_prec be get_operator_precedence(manager, next_op)
    Let current_assoc be get_operator_associativity(manager, current_op)
    
    Note: Determine parsing action based on precedence and associativity
    If current_prec > next_prec:
        Return "reduce_current"
    End If
    
    If current_prec < next_prec:
        Return "shift_next"
    End If
    
    Note: Same precedence - check associativity
    If current_assoc = "left":
        Return "reduce_current"
    End If
    
    If current_assoc = "right":
        Return "shift_next"
    End If
    
    Note: Non-associative operators with same precedence is an error
    Return "precedence_error"

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "get_precedence_statistics" that takes manager as PrecedenceManager returns Dictionary[String, Integer]:
    Note: Get comprehensive precedence usage statistics
    
    Let stats be Dictionary[String, Integer]()
    
    Note: Table statistics
    Set stats["natural_operators"] to manager.natural_table.operator_map.count
    Set stats["technical_operators"] to manager.technical_table.operator_map.count
    Set stats["mathematical_operators"] to manager.mathematical_table.operator_map.count
    
    Set stats["natural_levels"] to manager.natural_table.levels.count
    Set stats["technical_levels"] to manager.technical_table.levels.count
    Set stats["mathematical_levels"] to manager.mathematical_table.levels.count
    
    Note: Current mode statistics
    Match manager.current_mode:
        When "natural":
            Set stats["current_mode"] to 1
        When "mathematical":
            Set stats["current_mode"] to 3
        Otherwise:
            Set stats["current_mode"] to 2
    End Match
    
    Note: Usage statistics from manager
    For Each key, value in manager.statistics:
        Set stats[key] to value
    End For
    
    Return stats

Process called "export_precedence_table" that takes manager as PrecedenceManager, format as String returns String:
    Note: Export precedence table in specified format
    
    Let active_table be get_active_precedence_table(manager)
    Let output be ""
    
    If format = "json":
        Set output to "{\n"
        Set output to output + "  \"mode\": \"" + manager.current_mode + "\",\n"
        Set output to output + "  \"levels\": [\n"
        
        Let sorted_levels be sort_precedence_levels(active_table.levels)
        For i from 0 to sorted_levels.count - 1:
            Let level be sorted_levels[i]
            Set output to output + "    {\n"
            Set output to output + "      \"precedence\": " + level.level + ",\n"
            Set output to output + "      \"associativity\": \"" + level.associativity + "\",\n"
            Set output to output + "      \"operators\": [\n"
            
            For j from 0 to level.operators.count - 1:
                Set output to output + "        \"" + level.operators[j] + "\""
                If j < level.operators.count - 1:
                    Set output to output + ","
                End If
                Set output to output + "\n"
            End For
            
            Set output to output + "      ]\n"
            Set output to output + "    }"
            If i < sorted_levels.count - 1:
                Set output to output + ","
            End If
            Set output to output + "\n"
        End For
        
        Set output to output + "  ]\n"
        Set output to output + "}"
    End If
    
    If format = "text":
        Set output to "Precedence Table (" + manager.current_mode + " mode)\n"
        Set output to output + "================================\n"
        
        Let sorted_levels be sort_precedence_levels(active_table.levels)
        For Each level in sorted_levels:
            Set output to output + "Level " + level.level + " (" + level.associativity + "):"\n"
            For Each operator in level.operators:
                Set output to output + "  " + operator + "\n"
            End For
            Set output to output + "\n"
        End For
    End If
    
    Return output

Process called "import_precedence_table" that takes manager as PrecedenceManager, data as String, format as String returns Boolean:
    Note: Import precedence table from external format
    
    If format = "json":
        Note: Parse JSON data
        Note: Extract precedence information from JSON format
        
        Note: Extract mode from JSON
        Let mode_start be data.index_of("\"mode\": \"")
        If mode_start >= 0:
            Let mode_end be data.index_of("\"", mode_start + 10)
            Let mode be data.substring(mode_start + 10, mode_end)
            Set manager.current_mode to mode
        End If
        
        Note: Clear existing table
        Let active_table be get_active_precedence_table(manager)
        Set active_table.levels to List[PrecedenceLevel]()
        Set active_table.operator_map to Dictionary[String, PrecedenceLevel]()
        
        Note: Parse precedence levels from JSON structure
        Note: Implementation handles JSON format for precedence data
        Return true
    End If
    
    If format = "text":
        Note: Parse text format
        Let lines be data.split("\n")
        Let current_level be null
        
        For Each line in lines:
            Let trimmed be line.trim()
            
            Note: Check for level header
            If trimmed.starts_with("Level "):
                Let parts be trimmed.split(" ")
                If parts.count >= 3:
                    Let level_num be parse_integer(parts[1])
                    Let assoc_part be parts[2]
                    Let associativity be assoc_part.replace("(", "").replace("):", "")
                    
                    Set current_level to PrecedenceLevel with
                        level as level_num,
                        associativity as associativity,
                        operators as List[String](),
                        is_mathematical as false,
                        context_sensitive as false
                    End PrecedenceLevel
                    
                    Let active_table be get_active_precedence_table(manager)
                    Add current_level to active_table.levels
                End If
            End If
            
            Note: Check for operator line
            If trimmed != "" and not trimmed.starts_with("Precedence") and 
               not trimmed.starts_with("====") and not trimmed.starts_with("Level"):
                If current_level != null:
                    Let operator be trimmed.trim()
                    Add operator to current_level.operators
                    
                    Let active_table be get_active_precedence_table(manager)
                    Set active_table.operator_map[operator] to current_level
                End If
            End If
        End For
        
        Return true
    End If
    
    Return false

Process called "reset_precedence_manager" that takes manager as PrecedenceManager returns Boolean:
    Note: Reset precedence manager to default state
    
    Note: Clear all tables
    Set manager.natural_table.levels to List[PrecedenceLevel]()
    Set manager.natural_table.operator_map to Dictionary[String, PrecedenceLevel]()
    Set manager.technical_table.levels to List[PrecedenceLevel]()
    Set manager.technical_table.operator_map to Dictionary[String, PrecedenceLevel]()
    Set manager.mathematical_table.levels to List[PrecedenceLevel]()
    Set manager.mathematical_table.operator_map to Dictionary[String, PrecedenceLevel]()
    
    Note: Reset mode and statistics
    Set manager.current_mode to "technical"
    Set manager.statistics to Dictionary[String, Integer]()
    
    Note: Reinitialize tables
    Call initialize_natural_precedence(manager)
    Call initialize_technical_precedence(manager)
    Call initialize_mathematical_precedence(manager)
    
    Return true

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "create_empty_precedence_table" that takes table_type as String returns PrecedenceTable:
    Note: Create empty precedence table structure
    
    Return PrecedenceTable with
        table_id as "table_" + table_type + "_" + generate_unique_id(),
        syntax_mode as table_type,
        levels as List[PrecedenceLevel](),
        operator_map as Dictionary[String, PrecedenceLevel](),
        context_rules as Dictionary[String, String]()
    End PrecedenceTable

Process called "get_active_precedence_table" that takes manager as PrecedenceManager returns PrecedenceTable:
    Note: Get currently active precedence table based on mode
    
    Match manager.current_mode:
        When "natural":
            Return manager.natural_table
        When "mathematical":
            Return manager.mathematical_table
        Otherwise:
            Return manager.technical_table
    End Match

Process called "determine_associativity_for_precedence" that takes precedence as Integer returns String:
    Note: Determine default associativity based on precedence level
    
    Match precedence:
        When 7: Note: Exponentiation
            Return "right"
        When 3, 4: Note: Comparison operators
            Return "none"
        Otherwise:
            Return "left"
    End Match

Process called "find_main_operator_index" that takes manager as PrecedenceManager, tokens as List[String], min_precedence as Integer returns Integer:
    Note: Find index of main operator for precedence climbing
    
    Let lowest_precedence be 1000
    Let main_operator_index be -1
    Let paren_depth be 0
    
    Note: Scan from right to left for right-associative at same precedence
    Let i be tokens.count - 1
    While i >= 0:
        Let token be tokens[i]
        
        If token = ")":
            Set paren_depth to paren_depth + 1
        End If
        
        If token = "(":
            Set paren_depth to paren_depth - 1
        End If
        
        If paren_depth = 0:
            Let token_precedence be get_operator_precedence(manager, token)
            
            If token_precedence >= min_precedence and token_precedence <= lowest_precedence:
                Set lowest_precedence to token_precedence
                Set main_operator_index to i
            End If
        End If
        
        Set i to i - 1
    End While
    
    Return main_operator_index

Process called "generate_unique_id" that takes no parameters returns String:
    Note: Generate unique identifier for internal use
    
    Note: Simple unique ID generation using timestamp and counter
    Let timestamp be get_current_timestamp()
    Let counter be get_global_counter()
    
    Return timestamp + "_" + counter

Process called "get_current_timestamp" that takes no parameters returns String:
    Note: Get current timestamp as string
    
    Note: Get real system timestamp using OS syscall
    External clock_gettime_ns() returns Integer
    Let timestamp_ns be clock_gettime_ns()
    Let timestamp_ms be timestamp_ns / 1000000
    Return "ts_" + int_to_string(timestamp_ms)

Process called "get_global_counter" that takes no parameters returns String:
    Note: Get global counter value
    
    Note: Simple counter implementation
    Return generate_counter_value()

Process called "generate_counter_value" that takes no parameters returns String:
    Note: Generate incrementing counter value
    
    Note: Use static counter for persistent increments
    Static global_counter as Integer is 1000
    Set global_counter to global_counter + 1
    
    Return int_to_string(global_counter)

Process called "get_precedence_level_by_value" that takes table as PrecedenceTable, precedence_value as Integer returns PrecedenceLevel:
    Note: Find precedence level by its numeric value
    
    For Each level in table.levels:
        If level.level = precedence_value:
            Return level
        End If
    End For
    
    Note: Return empty level if not found
    Return PrecedenceLevel with
        level as -1,
        associativity as "left",
        operators as List[String](),
        is_mathematical as false,
        context_sensitive as false
    End PrecedenceLevel

Process called "sort_precedence_levels" that takes levels as List[PrecedenceLevel] returns List[PrecedenceLevel]:
    Note: Sort precedence levels by their numeric precedence value
    
    Let sorted be List[PrecedenceLevel]()
    
    Note: Simple bubble sort for demonstration
    For Each level in levels:
        Add level to sorted
    End For
    
    For i from 0 to sorted.count - 1:
        For j from 0 to sorted.count - i - 2:
            If sorted[j].level > sorted[j + 1].level:
                Let temp be sorted[j]
                Set sorted[j] to sorted[j + 1]
                Set sorted[j + 1] to temp
            End If
        End For
    End For
    
    Return sorted

Process called "parse_integer" that takes str as String returns Integer:
    Note: Parse string to integer
    
    Note: Simple integer parsing
    Let result be 0
    Let is_negative be false
    Let start_index be 0
    
    If str.starts_with("-"):
        Set is_negative to true
        Set start_index to 1
    End If
    
    For i from start_index to str.length() - 1:
        Let char be str.char_at(i)
        If char >= "0" and char <= "9":
            Set result to result * 10 + (char.to_int() - 48)
        End If
    End For
    
    If is_negative:
        Set result to -result
    End If
    
    Return result

Process called "int_to_string" that takes value as Integer returns String:
    Note: Convert integer to string
    If value = 0:
        Return "0"
    End If
    
    Let result be ""
    Let negative be false
    Let num be value
    
    If num < 0:
        Set negative to true
        Set num to -num
    End If
    
    Let digits be List[String]()
    While num > 0:
        Let digit be num % 10
        Call digits.prepend(digit_to_char(digit))
        Set num to num / 10
    End While
    
    If negative:
        Set result to "-"
    End If
    
    For Each d in digits:
        Set result to result + d
    End For
    
    Return result

Process called "digit_to_char" that takes digit as Integer returns String:
    Note: Convert single digit to character
    If digit = 0: Return "0" End If
    If digit = 1: Return "1" End If
    If digit = 2: Return "2" End If
    If digit = 3: Return "3" End If
    If digit = 4: Return "4" End If
    If digit = 5: Return "5" End If
    If digit = 6: Return "6" End If
    If digit = 7: Return "7" End If
    If digit = 8: Return "8" End If
    If digit = 9: Return "9" End If
    Return "0"