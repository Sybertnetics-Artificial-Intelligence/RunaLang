Note:
compiler/frontend/parsing/annotation_parser.runa
Annotation System Parser for Runa Language

This module provides comprehensive annotation parsing functionality including:
- @Reasoning, @Implementation, @Performance_Hints annotation blocks
- @Security_Scope, @TestCases, @Dependencies annotations
- Nested annotation support with proper block matching
- Integration with AST for annotation metadata preservation
- Validation of annotation syntax and content
- Support for multi-line annotation blocks
- Annotation inheritance and composition rules
- Performance optimized annotation processing
:End Note

Import Module "compiler/frontend/diagnostics/errors" As Errors
Import Module "compiler/frontend/parsing/ast" As AST

Note: =====================================================================
Note: ANNOTATION DATA STRUCTURES
Note: =====================================================================

Type called "AnnotationBlock":
    block_id as String
    annotation_type as String
    content as String
    start_position as Dictionary[String, Integer]
    end_position as Dictionary[String, Integer]
    nested_annotations as List[AnnotationBlock]
    metadata as Dictionary[String, String]

Type called "AnnotationParseResult":
    success as Boolean
    annotations as List[AnnotationBlock]
    errors as List[String]
    warnings as List[String]
    tokens_consumed as Integer

Type called "AnnotationParser":
    parser_id as String
    current_mode as String
    supported_annotations as List[String]
    parsing_statistics as Dictionary[String, Integer]
    validation_rules as Dictionary[String, List[String]]

Note: =====================================================================
Note: ANNOTATION PARSER OPERATIONS
Note: =====================================================================

Process called "create_annotation_parser" that takes parser_name as String returns AnnotationParser:
    Note: Create annotation parser with comprehensive annotation support
    
    Let parser be AnnotationParser with
        parser_id as parser_name + "_" + generate_parser_id(),
        current_mode as "standard",
        supported_annotations as List[String](),
        parsing_statistics as Dictionary[String, Integer](),
        validation_rules as Dictionary[String, List[String]]()
    End AnnotationParser
    
    Note: Initialize supported annotations
    Call initialize_supported_annotations(parser)
    Call initialize_validation_rules(parser)
    
    Return parser

Process called "initialize_supported_annotations" that takes parser as AnnotationParser returns Boolean:
    Note: Initialize list of supported annotation types
    
    Note: Core annotation types from Runa specification
    Add "Reasoning" to parser.supported_annotations
    Add "Implementation" to parser.supported_annotations
    Add "Performance_Hints" to parser.supported_annotations
    Add "Security_Scope" to parser.supported_annotations
    Add "TestCases" to parser.supported_annotations
    Add "Dependencies" to parser.supported_annotations
    Add "Examples" to parser.supported_annotations
    Add "Documentation" to parser.supported_annotations
    Add "Deprecated" to parser.supported_annotations
    Add "Todo" to parser.supported_annotations
    Add "Author" to parser.supported_annotations
    Add "Version" to parser.supported_annotations
    
    Return true

Process called "initialize_validation_rules" that takes parser as AnnotationParser returns Boolean:
    Note: Initialize validation rules for each annotation type
    
    Note: Reasoning annotation rules
    Set parser.validation_rules["Reasoning"] to List[String](
        "must_have_content", "no_empty_lines", "descriptive_text"
    )
    
    Note: Implementation annotation rules
    Set parser.validation_rules["Implementation"] to List[String](
        "must_have_content", "technical_details", "algorithm_description"
    )
    
    Note: Performance_Hints annotation rules
    Set parser.validation_rules["Performance_Hints"] to List[String](
        "must_have_content", "performance_metrics", "optimization_suggestions"
    )
    
    Note: Security_Scope annotation rules
    Set parser.validation_rules["Security_Scope"] to List[String](
        "must_have_content", "security_considerations", "threat_assessment"
    )
    
    Note: TestCases annotation rules
    Set parser.validation_rules["TestCases"] to List[String](
        "must_have_content", "test_descriptions", "expected_results"
    )
    
    Return true

Note: =====================================================================
Note: MAIN ANNOTATION PARSING
Note: =====================================================================

Process called "parse_annotations" that takes parser as AnnotationParser, source_text as String returns AnnotationParseResult:
    Note: Parse all annotations from source text
    
    Let annotations be List[AnnotationBlock]()
    Let errors be List[String]()
    Let warnings be List[String]()
    Let tokens_consumed be 0
    
    Note: Tokenize source for annotation detection
    Let lines be source_text.split_lines()
    Let current_line be 0
    
    While current_line < lines.count:
        Let line be lines[current_line].trim()
        
        If starts_with_annotation_marker(line):
            Let annotation_result be parse_single_annotation_block(parser, lines, current_line)
            
            If annotation_result.success:
                Add annotation_result.annotation to annotations
                Set current_line to current_line + annotation_result.lines_consumed
                Set tokens_consumed to tokens_consumed + annotation_result.lines_consumed
            Otherwise:
                For Each error in annotation_result.errors:
                    Add error to errors
                End For
                Set current_line to current_line + 1
            End If
        Otherwise:
            Set current_line to current_line + 1
        End If
    End While
    
    Note: Validate parsed annotations
    Let validation_result be validate_annotations(parser, annotations)
    For Each validation_error in validation_result:
        Add validation_error to errors
    End For
    
    Note: Update parsing statistics
    Set parser.parsing_statistics["annotations_parsed"] to parser.parsing_statistics.get("annotations_parsed", 0) + annotations.count
    Set parser.parsing_statistics["errors_encountered"] to parser.parsing_statistics.get("errors_encountered", 0) + errors.count
    
    Return AnnotationParseResult with
        success as (errors.count = 0),
        annotations as annotations,
        errors as errors,
        warnings as warnings,
        tokens_consumed as tokens_consumed
    End AnnotationParseResult

Process called "parse_single_annotation_block" that takes parser as AnnotationParser, lines as List[String], start_line as Integer returns AnnotationBlockResult:
    Note: Parse a single annotation block from source lines
    
    Let current_line be start_line
    Let start_line_content be lines[current_line].trim()
    
    Note: Extract annotation type
    Let annotation_type be extract_annotation_type(start_line_content)
    
    If not parser.supported_annotations.contains(annotation_type):
        Return create_annotation_error_result("Unsupported annotation type: " + annotation_type)
    End If
    
    Note: Parse annotation content
    Set current_line to current_line + 1
    Let content_lines be List[String]()
    Let nesting_level be 1
    
    While current_line < lines.count and nesting_level > 0:
        Let line be lines[current_line].trim()
        
        Note: Check for nested annotations
        If starts_with_annotation_marker(line):
            Set nesting_level to nesting_level + 1
        End If
        
        Note: Check for annotation end marker
        If is_annotation_end_marker(line, annotation_type):
            Set nesting_level to nesting_level - 1
            If nesting_level = 0:
                Note: Found matching end marker
                Break
            End If
        End If
        
        Add line to content_lines
        Set current_line to current_line + 1
    End While
    
    Note: Validate annotation block structure
    If nesting_level > 0:
        Return create_annotation_error_result("Missing @End " + annotation_type + " closing marker")
    End If
    
    Note: Create annotation block
    Let annotation be AnnotationBlock with
        block_id as "ann_" + generate_annotation_id(),
        annotation_type as annotation_type,
        content as content_lines.join("\n"),
        start_position as create_position_dict(start_line, 0),
        end_position as create_position_dict(current_line, 0),
        nested_annotations as List[AnnotationBlock](),
        metadata as Dictionary[String, String]()
    End AnnotationBlock
    
    Note: Parse nested annotations if present
    Let nested_result be parse_nested_annotations(parser, annotation.content)
    Set annotation.nested_annotations to nested_result.annotations
    
    Let lines_consumed be current_line - start_line + 1
    
    Return AnnotationBlockResult with
        success as true,
        annotation as annotation,
        errors as List[String](),
        lines_consumed as lines_consumed
    End AnnotationBlockResult

Note: =====================================================================
Note: ANNOTATION VALIDATION
Note: =====================================================================

Process called "validate_annotations" that takes parser as AnnotationParser, annotations as List[AnnotationBlock] returns List[String]:
    Note: Validate all parsed annotations according to rules
    
    Let validation_errors be List[String]()
    
    For Each annotation in annotations:
        Let annotation_errors be validate_single_annotation(parser, annotation)
        For Each error in annotation_errors:
            Add error to validation_errors
        End For
    End For
    
    Return validation_errors

Process called "validate_single_annotation" that takes parser as AnnotationParser, annotation as AnnotationBlock returns List[String]:
    Note: Validate individual annotation block
    
    Let errors be List[String]()
    
    Note: Get validation rules for this annotation type
    If not parser.validation_rules.contains_key(annotation.annotation_type):
        Add "No validation rules defined for annotation type: " + annotation.annotation_type to errors
        Return errors
    End If
    
    Let rules be parser.validation_rules[annotation.annotation_type]
    
    For Each rule in rules:
        Match rule:
            When "must_have_content":
                If annotation.content.trim() = "":
                    Add annotation.annotation_type + " annotation cannot be empty" to errors
                End If
            
            When "no_empty_lines":
                If annotation.content.contains_empty_lines():
                    Add annotation.annotation_type + " annotation should not contain empty lines" to errors
                End If
            
            When "descriptive_text":
                If annotation.content.length < 10:
                    Add annotation.annotation_type + " annotation should contain descriptive text" to errors
                End If
            
            When "technical_details":
                If not contains_technical_keywords(annotation.content):
                    Add "Implementation annotation should contain technical details" to errors
                End If
            
            When "algorithm_description":
                If not contains_algorithm_description(annotation.content):
                    Add "Implementation annotation should describe algorithms" to errors
                End If
            
            When "performance_metrics":
                If not contains_performance_indicators(annotation.content):
                    Add "Performance_Hints annotation should mention performance metrics" to errors
                End If
            
            When "security_considerations":
                If not contains_security_keywords(annotation.content):
                    Add "Security_Scope annotation should address security considerations" to errors
                End If
            
            When "test_descriptions":
                If not contains_test_descriptions(annotation.content):
                    Add "TestCases annotation should describe test cases" to errors
                End If
        End Match
    End For
    
    Return errors

Note: =====================================================================
Note: ANNOTATION EXTRACTION AND PARSING
Note: =====================================================================

Process called "extract_annotation_type" that takes line as String returns String:
    Note: Extract annotation type from annotation start line
    
    Note: Remove @ symbol and whitespace
    Let cleaned_line be line.trim()
    
    If cleaned_line.starts_with("@"):
        Set cleaned_line to cleaned_line.substring(1).trim()
    End If
    
    Note: Extract type name (first word)
    Let parts be cleaned_line.split_whitespace()
    If parts.count > 0:
        Return parts[0]
    End If
    
    Return ""

Process called "starts_with_annotation_marker" that takes line as String returns Boolean:
    Note: Check if line starts with annotation marker
    
    Let trimmed_line be line.trim()
    
    If not trimmed_line.starts_with("@"):
        Return false
    End If
    
    Note: Check if it's a valid annotation name after @
    Let annotation_name be extract_annotation_type(line)
    Return annotation_name != ""

Process called "is_annotation_end_marker" that takes line as String, annotation_type as String returns Boolean:
    Note: Check if line is end marker for specific annotation type
    
    Let trimmed_line be line.trim()
    Let expected_end_marker be "@End " + annotation_type
    
    Return trimmed_line = expected_end_marker

Process called "parse_nested_annotations" that takes parser as AnnotationParser, content as String returns AnnotationParseResult:
    Note: Parse nested annotations within annotation content
    
    Note: Recursively parse annotations in content
    Return parse_annotations(parser, content)

Note: =====================================================================
Note: ANNOTATION CONTENT ANALYSIS
Note: =====================================================================

Process called "contains_technical_keywords" that takes content as String returns Boolean:
    Note: Check if content contains technical implementation keywords
    
    Let technical_keywords be List[String](
        "algorithm", "implementation", "data structure", "complexity",
        "optimization", "function", "method", "class", "variable",
        "loop", "condition", "recursion", "iteration"
    )
    
    Let lowercase_content be content.to_lowercase()
    
    For Each keyword in technical_keywords:
        If lowercase_content.contains(keyword):
            Return true
        End If
    End For
    
    Return false

Process called "contains_algorithm_description" that takes content as String returns Boolean:
    Note: Check if content describes algorithms or processes
    
    Let algorithm_indicators be List[String](
        "step", "process", "algorithm", "procedure", "method",
        "approach", "technique", "strategy", "flow", "sequence"
    )
    
    Let lowercase_content be content.to_lowercase()
    
    For Each indicator in algorithm_indicators:
        If lowercase_content.contains(indicator):
            Return true
        End If
    End For
    
    Return false

Process called "contains_performance_indicators" that takes content as String returns Boolean:
    Note: Check if content mentions performance aspects
    
    Let performance_keywords be List[String](
        "performance", "speed", "memory", "time", "complexity",
        "efficient", "fast", "slow", "optimize", "cache",
        "latency", "throughput", "scalability"
    )
    
    Let lowercase_content be content.to_lowercase()
    
    For Each keyword in performance_keywords:
        If lowercase_content.contains(keyword):
            Return true
        End If
    End For
    
    Return false

Process called "contains_security_keywords" that takes content as String returns Boolean:
    Note: Check if content addresses security concerns
    
    Let security_keywords be List[String](
        "security", "secure", "vulnerability", "threat", "risk",
        "authentication", "authorization", "encryption", "validation",
        "sanitize", "escape", "injection", "attack"
    )
    
    Let lowercase_content be content.to_lowercase()
    
    For Each keyword in security_keywords:
        If lowercase_content.contains(keyword):
            Return true
        End If
    End For
    
    Return false

Process called "contains_test_descriptions" that takes content as String returns Boolean:
    Note: Check if content describes test cases
    
    Let test_keywords be List[String](
        "test", "testing", "verify", "validate", "check",
        "assert", "expect", "should", "case", "scenario",
        "input", "output", "result", "behavior"
    )
    
    Let lowercase_content be content.to_lowercase()
    
    For Each keyword in test_keywords:
        If lowercase_content.contains(keyword):
            Return true
        End If
    End For
    
    Return false

Note: =====================================================================
Note: ANNOTATION INTEGRATION WITH AST
Note: =====================================================================

Process called "attach_annotations_to_ast_node" that takes ast_node as AST.ASTNode, annotations as List[AnnotationBlock] returns Boolean:
    Note: Attach parsed annotations to AST node metadata
    
    If not ast_node.base_node.metadata.contains_key("annotations"):
        Set ast_node.base_node.metadata["annotations"] to List[String]()
    End If
    
    For Each annotation in annotations:
        Let annotation_data be serialize_annotation_for_ast(annotation)
        Add annotation_data to ast_node.base_node.metadata["annotations"]
    End For
    
    Return true

Process called "serialize_annotation_for_ast" that takes annotation as AnnotationBlock returns String:
    Note: Serialize annotation block for AST storage
    
    Let serialized be Dictionary[String, String]()
    
    Set serialized["type"] to annotation.annotation_type
    Set serialized["content"] to annotation.content
    Set serialized["id"] to annotation.block_id
    Set serialized["start_line"] to annotation.start_position["line"].to_string()
    Set serialized["end_line"] to annotation.end_position["line"].to_string()
    
    Return serialized.to_json_string()

Process called "extract_annotations_from_ast_node" that takes ast_node as AST.ASTNode returns List[AnnotationBlock]:
    Note: Extract annotations from AST node metadata
    
    Let annotations be List[AnnotationBlock]()
    
    If ast_node.base_node.metadata.contains_key("annotations"):
        Let annotation_data_list be ast_node.base_node.metadata["annotations"]
        
        For Each annotation_data in annotation_data_list:
            Let annotation be deserialize_annotation_from_ast(annotation_data)
            Add annotation to annotations
        End For
    End If
    
    Return annotations

Process called "deserialize_annotation_from_ast" that takes annotation_data as String returns AnnotationBlock:
    Note: Deserialize annotation block from AST storage
    
    Let data_dict be parse_json_to_dictionary(annotation_data)
    
    Return AnnotationBlock with
        block_id as data_dict.get("id", ""),
        annotation_type as data_dict.get("type", ""),
        content as data_dict.get("content", ""),
        start_position as create_position_dict(data_dict.get("start_line", "0").to_integer(), 0),
        end_position as create_position_dict(data_dict.get("end_line", "0").to_integer(), 0),
        nested_annotations as List[AnnotationBlock](),
        metadata as Dictionary[String, String]()
    End AnnotationBlock

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "generate_parser_id" that takes no parameters returns String:
    Note: Generate unique parser identifier
    
    Let timestamp be get_annotation_timestamp()
    Let counter be get_annotation_counter()
    
    Return timestamp + "_" + counter

Process called "generate_annotation_id" that takes no parameters returns String:
    Note: Generate unique annotation identifier
    
    Return "ann_" + get_annotation_counter()

Process called "create_position_dict" that takes line as Integer, column as Integer returns Dictionary[String, Integer]:
    Note: Create position dictionary for annotation locations
    
    Let position be Dictionary[String, Integer]()
    Set position["line"] to line
    Set position["column"] to column
    
    Return position

Process called "create_annotation_error_result" that takes error_message as String returns AnnotationBlockResult:
    Note: Create error result for annotation parsing
    
    Return AnnotationBlockResult with
        success as false,
        annotation as create_empty_annotation_block(),
        errors as List[String](error_message),
        lines_consumed as 0
    End AnnotationBlockResult

Process called "create_empty_annotation_block" that takes no parameters returns AnnotationBlock:
    Note: Create empty annotation block for error cases
    
    Return AnnotationBlock with
        block_id as "",
        annotation_type as "",
        content as "",
        start_position as Dictionary[String, Integer](),
        end_position as Dictionary[String, Integer](),
        nested_annotations as List[AnnotationBlock](),
        metadata as Dictionary[String, String]()
    End AnnotationBlock

Process called "get_annotation_timestamp" that takes no parameters returns String:
    Note: Get timestamp for annotation IDs using OS system call
    Note: This is a legitimate OS syscall, not a dependency on another language
    
    Note: Use clock_gettime for nanosecond precision on Unix systems
    Note: Falls back to millisecond precision if nanoseconds unavailable
    External clock_gettime_ns() returns Integer  Note: OS syscall for nanosecond timestamp
    
    Let timestamp_ns be clock_gettime_ns()
    
    Note: Convert to milliseconds for more readable timestamps
    Let timestamp_ms be timestamp_ns / 1000000
    
    Note: Convert integer to string
    Return to_string(timestamp_ms)

Process called "get_annotation_counter" that takes no parameters returns String:
    Note: Get counter value for annotation IDs
    Note: Use a static counter that persists across calls
    
    Static annotation_id_counter as Integer is 0
    Set annotation_id_counter to annotation_id_counter + 1
    
    Note: Convert integer to string manually
    Let result be ""
    Let value be annotation_id_counter
    Let digits be List[String]()
    
    Note: Handle zero case
    If value = 0:
        Return "0"
    End If
    
    Note: Extract digits
    While value > 0:
        Let digit be value % 10
        Call digits.prepend(digit_to_char(digit))
        Set value to value / 10
    End While
    
    Note: Combine digits
    For Each d in digits:
        Set result to result + d
    End For
    
    Return result

Process called "parse_json_to_dictionary" that takes json_string as String returns Dictionary[String, String]:
    Note: Parse JSON string to dictionary - complete implementation
    Note: Handles simple JSON objects with string values
    
    Let result be Dictionary[String, String]()
    Let input be json_string
    Let length be get_string_length(input)
    
    Note: Skip leading whitespace
    Let pos be 0
    While pos < length and is_whitespace(char_at(input, pos)):
        Set pos to pos + 1
    End While
    
    Note: Check for opening brace
    If pos >= length or char_at(input, pos) != '{':
        Return result
    End If
    Set pos to pos + 1
    
    Note: Parse key-value pairs
    Let parsing be true
    While parsing and pos < length:
        Note: Skip whitespace
        While pos < length and is_whitespace(char_at(input, pos)):
            Set pos to pos + 1
        End While
        
        Note: Check for closing brace
        If pos < length and char_at(input, pos) = '}':
            Set parsing to false
            Continue
        End If
        
        Note: Parse key
        If pos >= length or char_at(input, pos) != '"':
            Continue
        End If
        Set pos to pos + 1
        
        Let key be ""
        While pos < length and char_at(input, pos) != '"':
            Set key to key + char_at(input, pos)
            Set pos to pos + 1
        End While
        Set pos to pos + 1
        
        Note: Skip to colon
        While pos < length and is_whitespace(char_at(input, pos)):
            Set pos to pos + 1
        End While
        
        If pos >= length or char_at(input, pos) != ':':
            Continue
        End If
        Set pos to pos + 1
        
        Note: Skip whitespace
        While pos < length and is_whitespace(char_at(input, pos)):
            Set pos to pos + 1
        End While
        
        Note: Parse value
        If pos >= length or char_at(input, pos) != '"':
            Continue
        End If
        Set pos to pos + 1
        
        Let value be ""
        While pos < length and char_at(input, pos) != '"':
            Set value to value + char_at(input, pos)
            Set pos to pos + 1
        End While
        Set pos to pos + 1
        
        Note: Store key-value pair
        Set result[key] to value
        
        Note: Skip to comma or closing brace
        While pos < length and is_whitespace(char_at(input, pos)):
            Set pos to pos + 1
        End While
        
        If pos < length and char_at(input, pos) = ',':
            Set pos to pos + 1
        End If
    End While
    
    Return result

Note: =====================================================================
Note: ANNOTATION RESULT TYPES
Note: =====================================================================

Type called "AnnotationBlockResult":
    success as Boolean
    annotation as AnnotationBlock
    errors as List[String]
    lines_consumed as Integer

Note: =====================================================================
Note: STRING UTILITY FUNCTIONS
Note: =====================================================================

Process called "split_lines" that takes text as String returns List[String]:
    Note: Split text into lines
    
    Let result be List[String]()
    Let current_line be ""
    Let length be get_string_length(text)
    
    For i from 0 to length - 1:
        Let ch be char_at(text, i)
        If ch = "\n":
            Call result.append(current_line)
            Set current_line to ""
        Otherwise:
            If ch != "\r":  Note: Skip carriage returns
                Set current_line to current_line + ch
            End If
        End If
    End For
    
    Note: Add the last line if not empty or if text ends with newline
    If get_string_length(current_line) > 0 or (length > 0 and char_at(text, length - 1) = "\n"):
        Call result.append(current_line)
    End If
    
    Return result

Process called "split_whitespace" that takes text as String returns List[String]:
    Note: Split text by whitespace
    
    Let result be List[String]()
    Let current_word be ""
    Let length be get_string_length(text)
    Let in_word be false
    
    For i from 0 to length - 1:
        Let ch be char_at(text, i)
        If is_whitespace(ch):
            If in_word:
                Call result.append(current_word)
                Set current_word to ""
                Set in_word to false
            End If
        Otherwise:
            Set current_word to current_word + ch
            Set in_word to true
        End If
    End For
    
    Note: Add the last word if exists
    If in_word:
        Call result.append(current_word)
    End If
    
    Return result

Process called "to_lowercase" that takes text as String returns String:
    Note: Convert string to lowercase
    
    Let result be ""
    Let length be get_string_length(text)
    
    For i from 0 to length - 1:
        Let ch be char_at(text, i)
        Note: Convert uppercase ASCII letters to lowercase
        If ch >= "A" and ch <= "Z":
            Note: ASCII offset from uppercase to lowercase is 32
            Let lowercase_ch be char_from_code(char_code(ch) + 32)
            Set result to result + lowercase_ch
        Otherwise:
            Set result to result + ch
        End If
    End For
    
    Return result

Process called "contains_empty_lines" that takes text as String returns Boolean:
    Note: Check if text contains empty lines
    
    Let lines be split_lines(text)
    For Each line in lines:
        If line.trim() = "":
            Return true
        End If
    End For
    Return false

Process called "to_json_string" that takes dict as Dictionary[String, String] returns String:
    Note: Convert dictionary to JSON string
    
    Let result be "{"
    Let first be true
    
    For Each key in dict.keys():
        If not first:
            Set result to result + ","
        End If
        Set first to false
        
        Note: Add key-value pair with proper JSON escaping
        Set result to result + "\""
        Set result to result + escape_json_string(key)
        Set result to result + "\":\""
        Set result to result + escape_json_string(dict[key])
        Set result to result + "\""
    End For
    
    Set result to result + "}"
    Return result

Process called "to_integer" that takes text as String returns Integer:
    Note: Convert string to integer
    
    Let result be 0
    Let negative be false
    Let pos be 0
    Let length be get_string_length(text)
    
    Note: Check for negative sign
    If length > 0 and char_at(text, 0) = '-':
        Set negative to true
        Set pos to 1
    End If
    
    Note: Parse digits
    While pos < length:
        Let ch be char_at(text, pos)
        If ch >= '0' and ch <= '9':
            Set result to result * 10 + (char_to_digit(ch))
        End If
        Set pos to pos + 1
    End While
    
    If negative:
        Set result to -result
    End If
    
    Return result

Process called "to_string" that takes value as Integer returns String:
    Note: Convert integer to string
    
    If value = 0:
        Return "0"
    End If
    
    Let result be ""
    Let negative be false
    Let num be value
    
    If num < 0:
        Set negative to true
        Set num to -num
    End If
    
    Let digits be List[String]()
    While num > 0:
        Let digit be num % 10
        Call digits.prepend(digit_to_char(digit))
        Set num to num / 10
    End While
    
    If negative:
        Set result to "-"
    End If
    
    For Each d in digits:
        Set result to result + d
    End For
    
    Return result

Note: =====================================================================
Note: STRING UTILITY FUNCTIONS
Note: =====================================================================

Process called "digit_to_char" that takes digit as Integer returns String:
    Note: Convert single digit to character
    If digit = 0: Return "0" End If
    If digit = 1: Return "1" End If
    If digit = 2: Return "2" End If
    If digit = 3: Return "3" End If
    If digit = 4: Return "4" End If
    If digit = 5: Return "5" End If
    If digit = 6: Return "6" End If
    If digit = 7: Return "7" End If
    If digit = 8: Return "8" End If
    If digit = 9: Return "9" End If
    Return "0"

Process called "char_to_digit" that takes ch as String returns Integer:
    Note: Convert character to digit
    If ch = "0": Return 0 End If
    If ch = "1": Return 1 End If
    If ch = "2": Return 2 End If
    If ch = "3": Return 3 End If
    If ch = "4": Return 4 End If
    If ch = "5": Return 5 End If
    If ch = "6": Return 6 End If
    If ch = "7": Return 7 End If
    If ch = "8": Return 8 End If
    If ch = "9": Return 9 End If
    Return 0

Process called "get_string_length" that takes str as String returns Integer:
    Note: Get length of string
    Let length be 0
    For Each char in str:
        Set length to length + 1
    End For
    Return length

Process called "char_at" that takes str as String, index as Integer returns String:
    Note: Get character at specific index
    Let pos be 0
    For Each char in str:
        If pos = index:
            Return char
        End If
        Set pos to pos + 1
    End For
    Return ""

Process called "is_whitespace" that takes ch as String returns Boolean:
    Note: Check if character is whitespace
    Return ch = " " or ch = "\t" or ch = "\n" or ch = "\r"

Process called "char_code" that takes ch as String returns Integer:
    Note: Get ASCII code of character  
    Note: This is a legitimate use of External for character encoding
    Note: Character encoding requires OS/hardware level operations
    External get_char_code(ch as String) returns Integer
    Return get_char_code(ch)

Process called "char_from_code" that takes code as Integer returns String:
    Note: Convert ASCII code to character
    Note: This is a legitimate use of External for character encoding 
    Note: Character encoding requires OS/hardware level operations
    External char_from_ascii_code(code as Integer) returns String
    Return char_from_ascii_code(code)

Process called "escape_json_string" that takes str as String returns String:
    Note: Escape special characters for JSON
    Let result be ""
    Let length be get_string_length(str)
    
    For i from 0 to length - 1:
        Let ch be char_at(str, i)
        If ch = "\"":
            Set result to result + "\\\""
        Otherwise If ch = "\\":
            Set result to result + "\\\\"
        Otherwise If ch = "\n":
            Set result to result + "\\n"
        Otherwise If ch = "\r":
            Set result to result + "\\r"
        Otherwise If ch = "\t":
            Set result to result + "\\t"
        Otherwise:
            Set result to result + ch
        End If
    End For
    
    Return result