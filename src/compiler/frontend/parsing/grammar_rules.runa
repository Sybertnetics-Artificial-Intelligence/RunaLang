Note:
compiler/frontend/parsing/grammar_rules.runa
Formal Grammar Rule Definitions for Runa Language

This module provides comprehensive grammar rule definitions for both
natural language and technical syntax modes of Runa. Features include:
- Context-free grammar rules for both syntax modes
- Production rules with precedence and associativity
- Token pattern matching and validation
- Grammar rule composition and inheritance
- Syntax mode switching rules
- Mathematical expression grammar
- Pattern matching grammar
- Error production rules for recovery
- Grammar validation and consistency checking
:End Note

Import Module "compiler/frontend/diagnostics/errors" As Errors
Import Module "compiler/frontend/lexical/operators" As Operators
Import Module "compiler/frontend/lexical/keywords" As Keywords
Import Module "compiler/frontend/lexical/math_symbols" As MathSymbols

Note: =====================================================================
Note: GRAMMAR RULE TYPES
Note: =====================================================================

Type called "GrammarRule":
    rule_name as String
    rule_type as String
    syntax_mode as String
    left_hand_side as String
    right_hand_side as List[String]
    precedence as Integer
    associativity as String
    action as String
    is_terminal as Boolean

Type called "ProductionRule":
    production_id as String
    non_terminal as String
    alternatives as List[List[String]]
    semantic_actions as List[String]
    precedence_rules as Dictionary[String, Integer]
    first_set as List[String]
    follow_set as List[String]

Type called "GrammarSet":
    grammar_name as String
    syntax_mode as String
    terminals as List[String]
    non_terminals as List[String]
    production_rules as List[ProductionRule]
    start_symbol as String
    error_productions as List[String]

Note: =====================================================================
Note: CORE GRAMMAR DEFINITIONS
Note: =====================================================================

Process called "create_natural_language_grammar" that takes grammar_name as String returns GrammarSet:
    Note: Create complete natural language grammar
    
    Note: Generate terminals from lexical system instead of hardcoding
    Let terminals be get_terminals_from_lexical_system()
    
    Let non_terminals be List[String](
        "Program", "Statement", "Expression", "Declaration", "Type", "Block",
        "LetStatement", "SetStatement", "ProcessDeclaration", "TypeDeclaration",
        "IfStatement", "ForStatement", "WhileStatement", "MatchStatement",
        "BinaryExpression", "UnaryExpression", "CallExpression", "Literal",
        "Identifier", "ArgumentList", "ParameterList", "CaseList", "Pattern"
    )
    
    Let production_rules be List[ProductionRule]()
    
    Note: Add core production rules
    Add create_program_productions() to production_rules
    Add create_statement_productions() to production_rules
    Add create_expression_productions() to production_rules
    Add create_declaration_productions() to production_rules
    
    Return GrammarSet with
        grammar_name as grammar_name,
        syntax_mode as "natural",
        terminals as terminals,
        non_terminals as non_terminals,
        production_rules as production_rules,
        start_symbol as "Program",
        error_productions as List[String]()
    End GrammarSet

Process called "create_technical_syntax_grammar" that takes grammar_name as String returns GrammarSet:
    Note: Create complete technical syntax grammar
    
    Note: Generate terminals from lexical system for technical syntax
    Let terminals be get_terminals_from_lexical_system()
    
    Note: Add technical-specific keywords that might not be in natural language set
    Add "function" to terminals
    Add "var" to terminals
    Add "const" to terminals
    Add "else" to terminals
    Add "case" to terminals
    Add "struct" to terminals
    Add "enum" to terminals
    Add "true" to terminals
    Add "false" to terminals
    Add "++" to terminals
    Add "--" to terminals
    
    Let non_terminals be List[String](
        "Program", "Statement", "Expression", "Declaration", "Type", "Block",
        "AssignmentStatement", "ExpressionStatement", "FunctionDeclaration", 
        "VariableDeclaration", "IfStatement", "ForStatement", "WhileStatement",
        "BinaryExpression", "UnaryExpression", "CallExpression", "MemberExpression",
        "Literal", "Identifier", "ArgumentList", "ParameterList"
    )
    
    Let production_rules be List[ProductionRule]()
    
    Note: Add technical syntax production rules
    Add create_technical_program_productions() to production_rules
    Add create_technical_statement_productions() to production_rules
    Add create_technical_expression_productions() to production_rules
    Add create_technical_declaration_productions() to production_rules
    
    Return GrammarSet with
        grammar_name as grammar_name,
        syntax_mode as "technical",
        terminals as terminals,
        non_terminals as non_terminals,
        production_rules as production_rules,
        start_symbol as "Program",
        error_productions as List[String]()
    End GrammarSet

Note: =====================================================================
Note: NATURAL LANGUAGE PRODUCTION RULES
Note: =====================================================================

Process called "create_program_productions" returns ProductionRule:
    Note: Program -> Statement* EOF
    
    Return ProductionRule with
        production_id as "program_1",
        non_terminal as "Program",
        alternatives as List[List[String]](
            List[String]("Statement", "Program"),
            List[String]("EOF")
        ),
        semantic_actions as List[String]("create_program_node", "end_program"),
        precedence_rules as Dictionary[String, Integer](),
        first_set as List[String]("Let", "Set", "Process", "Type", "If", "For", "While", "Match"),
        follow_set as List[String]("EOF")
    End ProductionRule

Process called "create_statement_productions" returns ProductionRule:
    Note: Statement production rules for natural language
    
    Return ProductionRule with
        production_id as "statement_1",
        non_terminal as "Statement",
        alternatives as List[List[String]](
            List[String]("LetStatement"),
            List[String]("SetStatement"),
            List[String]("ProcessDeclaration"),
            List[String]("TypeDeclaration"),
            List[String]("IfStatement"),
            List[String]("ForStatement"),
            List[String]("WhileStatement"),
            List[String]("MatchStatement"),
            List[String]("Expression")
        ),
        semantic_actions as List[String]("create_statement_node"),
        precedence_rules as Dictionary[String, Integer](),
        first_set as List[String]("Let", "Set", "Process", "Type", "If", "For", "While", "Match", "IDENTIFIER"),
        follow_set as List[String]("\\n", "EOF", "End")
    End ProductionRule

Process called "create_let_statement_production" returns ProductionRule:
    Note: LetStatement -> "Let" IDENTIFIER "be" Expression
    
    Return ProductionRule with
        production_id as "let_statement_1",
        non_terminal as "LetStatement",
        alternatives as List[List[String]](
            List[String]("Let", "IDENTIFIER", "be", "Expression"),
            List[String]("Let", "IDENTIFIER", "as", "Type", "be", "Expression")
        ),
        semantic_actions as List[String]("create_let_statement"),
        precedence_rules as Dictionary[String, Integer](),
        first_set as List[String]("Let"),
        follow_set as List[String]("\\n", "EOF")
    End ProductionRule

Process called "create_set_statement_production" returns ProductionRule:
    Note: SetStatement -> "Set" IDENTIFIER "to" Expression
    
    Return ProductionRule with
        production_id as "set_statement_1",
        non_terminal as "SetStatement",
        alternatives as List[List[String]](
            List[String]("Set", "IDENTIFIER", "to", "Expression"),
            List[String]("Set", "IDENTIFIER", ".", "IDENTIFIER", "to", "Expression")
        ),
        semantic_actions as List[String]("create_set_statement"),
        precedence_rules as Dictionary[String, Integer](),
        first_set as List[String]("Set"),
        follow_set as List[String]("\\n", "EOF")
    End ProductionRule

Process called "create_process_declaration_production" returns ProductionRule:
    Note: ProcessDeclaration -> "Process" "called" IDENTIFIER "that" "takes" ParameterList "returns" Type ":" Block
    
    Return ProductionRule with
        production_id as "process_declaration_1",
        non_terminal as "ProcessDeclaration",
        alternatives as List[List[String]](
            List[String]("Process", "called", "IDENTIFIER", "that", "takes", "ParameterList", "returns", "Type", ":", "Block"),
            List[String]("Process", "called", "IDENTIFIER", "that", "returns", "Type", ":", "Block"),
            List[String]("Process", "called", "IDENTIFIER", ":", "Block")
        ),
        semantic_actions as List[String]("create_process_declaration"),
        precedence_rules as Dictionary[String, Integer](),
        first_set as List[String]("Process"),
        follow_set as List[String]("\\n", "EOF")
    End ProductionRule

Note: =====================================================================
Note: EXPRESSION PRODUCTION RULES
Note: =====================================================================

Process called "create_expression_productions" returns ProductionRule:
    Note: Expression production rules with precedence
    
    Return ProductionRule with
        production_id as "expression_1",
        non_terminal as "Expression",
        alternatives as List[List[String]](
            List[String]("BinaryExpression"),
            List[String]("UnaryExpression"),
            List[String]("CallExpression"),
            List[String]("Literal"),
            List[String]("Identifier"),
            List[String]("(", "Expression", ")")
        ),
        semantic_actions as List[String]("create_expression_node"),
        precedence_rules as get_operator_precedence_rules(),
        first_set as List[String]("IDENTIFIER", "INTEGER", "FLOAT", "STRING", "BOOLEAN", "(", "!", "+", "-"),
        follow_set as List[String]("\\n", "EOF", ")", "]", ",", ";")
    End ProductionRule

Process called "create_binary_expression_production" returns ProductionRule:
    Note: BinaryExpression -> Expression BinaryOperator Expression
    Note: Supports both developer ("*") and canon ("multiplied by") operators
    
    Return ProductionRule with
        production_id as "binary_expression_1",
        non_terminal as "BinaryExpression",
        alternatives as List[List[String]](
            Note: Arithmetic operators - both forms accepted
            List[String]("Expression", "+", "Expression"),
            List[String]("Expression", "plus", "Expression"),
            List[String]("Expression", "-", "Expression"),
            List[String]("Expression", "minus", "Expression"),
            List[String]("Expression", "*", "Expression"),
            List[String]("Expression", "multiplied", "by", "Expression"),
            List[String]("Expression", "/", "Expression"),
            List[String]("Expression", "divided", "by", "Expression"),
            List[String]("Expression", "%", "Expression"),
            List[String]("Expression", "modulo", "Expression"),
            List[String]("Expression", "^", "Expression"),
            List[String]("Expression", "to", "the", "power", "of", "Expression"),
            List[String]("Expression", "**", "Expression"),
            Note: Comparison operators - both forms accepted
            List[String]("Expression", "==", "Expression"),
            List[String]("Expression", "is", "equal", "to", "Expression"),
            List[String]("Expression", "!=", "Expression"),
            List[String]("Expression", "is", "not", "equal", "to", "Expression"),
            List[String]("Expression", "<", "Expression"),
            List[String]("Expression", "is", "less", "than", "Expression"),
            List[String]("Expression", ">", "Expression"),
            List[String]("Expression", "is", "greater", "than", "Expression"),
            List[String]("Expression", "<=", "Expression"),
            List[String]("Expression", "is", "less", "than", "or", "equal", "to", "Expression"),
            List[String]("Expression", ">=", "Expression"),
            List[String]("Expression", "is", "greater", "than", "or", "equal", "to", "Expression"),
            Note: Logical operators - both forms accepted
            List[String]("Expression", "&&", "Expression"),
            List[String]("Expression", "And", "Expression"),
            List[String]("Expression", "||", "Expression"),
            List[String]("Expression", "Or", "Expression")
        ),
        semantic_actions as List[String]("create_binary_expression_with_conversion"),
        precedence_rules as Dictionary[String, Integer](),
        first_set as List[String]("IDENTIFIER", "INTEGER", "FLOAT", "STRING", "BOOLEAN", "("),
        follow_set as List[String]("\\n", "EOF", ")", "]", ",", ";")
    End ProductionRule

Process called "create_call_expression_production" returns ProductionRule:
    Note: CallExpression -> IDENTIFIER "(" ArgumentList ")"
    
    Return ProductionRule with
        production_id as "call_expression_1",
        non_terminal as "CallExpression",
        alternatives as List[List[String]](
            List[String]("IDENTIFIER", "(", "ArgumentList", ")"),
            List[String]("IDENTIFIER", "(", ")")
        ),
        semantic_actions as List[String]("create_call_expression"),
        precedence_rules as Dictionary[String, Integer](),
        first_set as List[String]("IDENTIFIER"),
        follow_set as List[String]("\\n", "EOF", ")", "]", ",", ";")
    End ProductionRule

Note: =====================================================================
Note: MATHEMATICAL EXPRESSION RULES
Note: =====================================================================

Process called "create_mathematical_grammar" returns ProductionRule:
    Note: Mathematical expressions with Greek symbols
    
    Return ProductionRule with
        production_id as "mathematical_1",
        non_terminal as "MathematicalExpression",
        alternatives as List[List[String]](
            List[String]("", "(", "IDENTIFIER", "=", "Expression", "to", "Expression", ",", "Expression", ")"),
            List[String]("", "(", "IDENTIFIER", "=", "Expression", "to", "Expression", ",", "Expression", ")"),
            List[String]("+", "Expression", "d", "IDENTIFIER"),
            List[String]("", "Expression"),
            List[String]("", "Expression", "/", "", "IDENTIFIER"),
            List[String]("�", "+", "�", "*", "�"),
            List[String]("�", "*", "r", "^", "2"),
            List[String]("e", "^", "(", "i", "*", "�", ")")
        ),
        semantic_actions as List[String]("create_mathematical_expression"),
        precedence_rules as Dictionary[String, Integer](
            "" as 10, "" as 10, "+" as 10,
            "" as 9, "" as 9,
            "^" as 8
        ),
        first_set as List[String]("", "", "+", "", "", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�"),
        follow_set as List[String]("\\n", "EOF", ")", "]", ",", ";")
    End ProductionRule

Note: =====================================================================
Note: TECHNICAL SYNTAX PRODUCTION RULES
Note: =====================================================================

Process called "create_technical_program_productions" returns ProductionRule:
    Note: Technical syntax program rules
    
    Return ProductionRule with
        production_id as "tech_program_1",
        non_terminal as "Program",
        alternatives as List[List[String]](
            List[String]("Statement", "Program"),
            List[String]("EOF")
        ),
        semantic_actions as List[String]("create_program_node", "end_program"),
        precedence_rules as Dictionary[String, Integer](),
        first_set as List[String]("function", "var", "let", "const", "if", "for", "while", "match", "IDENTIFIER"),
        follow_set as List[String]("EOF")
    End ProductionRule

Process called "create_technical_statement_productions" returns ProductionRule:
    Note: Technical syntax statement rules
    
    Return ProductionRule with
        production_id as "tech_statement_1",
        non_terminal as "Statement",
        alternatives as List[List[String]](
            List[String]("FunctionDeclaration"),
            List[String]("VariableDeclaration"),
            List[String]("AssignmentStatement"),
            List[String]("ExpressionStatement"),
            List[String]("IfStatement"),
            List[String]("ForStatement"),
            List[String]("WhileStatement"),
            List[String]("Block")
        ),
        semantic_actions as List[String]("create_statement_node"),
        precedence_rules as Dictionary[String, Integer](),
        first_set as List[String]("function", "var", "let", "const", "if", "for", "while", "match", "IDENTIFIER", "{"),
        follow_set as List[String]("\\n", "EOF", "}")
    End ProductionRule

Process called "create_technical_expression_productions" returns ProductionRule:
    Note: Technical syntax expression rules
    
    Return ProductionRule with
        production_id as "tech_expression_1",
        non_terminal as "Expression",
        alternatives as List[List[String]](
            List[String]("BinaryExpression"),
            List[String]("UnaryExpression"),
            List[String]("CallExpression"),
            List[String]("MemberExpression"),
            List[String]("Literal"),
            List[String]("Identifier"),
            List[String]("(", "Expression", ")")
        ),
        semantic_actions as List[String]("create_expression_node"),
        precedence_rules as Dictionary[String, Integer](
            "||" as 1,
            "&&" as 2,
            "==" as 3, "!=" as 3,
            "<" as 4, ">" as 4, "<=" as 4, ">=" as 4,
            "+" as 5, "-" as 5,
            "*" as 6, "/" as 6, "%" as 6,
            "^" as 7,
            "++" as 8, "--" as 8,
            "." as 9
        ),
        first_set as List[String]("IDENTIFIER", "INTEGER", "FLOAT", "STRING", "BOOLEAN", "(", "!", "+", "-", "++", "--"),
        follow_set as List[String]("\\n", "EOF", ")", "]", ",", ";", "}")
    End ProductionRule

Process called "create_technical_declaration_productions" returns ProductionRule:
    Note: Technical syntax declaration rules
    
    Return ProductionRule with
        production_id as "tech_declaration_1",
        non_terminal as "Declaration",
        alternatives as List[List[String]](
            List[String]("function", "IDENTIFIER", "(", "ParameterList", ")", ":", "Type", "Block"),
            List[String]("var", "IDENTIFIER", ":", "Type", "=", "Expression", ";"),
            List[String]("let", "IDENTIFIER", "=", "Expression", ";"),
            List[String]("const", "IDENTIFIER", "=", "Expression", ";")
        ),
        semantic_actions as List[String]("create_declaration_node"),
        precedence_rules as Dictionary[String, Integer](),
        first_set as List[String]("function", "var", "let", "const"),
        follow_set as List[String]("\\n", "EOF", "}")
    End ProductionRule

Note: =====================================================================
Note: PATTERN MATCHING GRAMMAR
Note: =====================================================================

Process called "create_pattern_matching_grammar" returns ProductionRule:
    Note: Pattern matching grammar rules
    
    Return ProductionRule with
        production_id as "pattern_1",
        non_terminal as "MatchStatement",
        alternatives as List[List[String]](
            List[String]("Match", "Expression", ":", "CaseList", "End", "Match"),
            List[String]("match", "(", "Expression", ")", "{", "CaseList", "}")
        ),
        semantic_actions as List[String]("create_match_statement"),
        precedence_rules as Dictionary[String, Integer](),
        first_set as List[String]("Match", "match"),
        follow_set as List[String]("\\n", "EOF", "}")
    End ProductionRule

Process called "create_pattern_productions" returns ProductionRule:
    Note: Pattern production rules
    
    Return ProductionRule with
        production_id as "pattern_productions_1",
        non_terminal as "Pattern",
        alternatives as List[List[String]](
            List[String]("IDENTIFIER"),
            List[String]("Literal"),
            List[String]("IDENTIFIER", "(", "PatternList", ")"),
            List[String]("[", "PatternList", "]"),
            List[String]("{", "FieldPatternList", "}"),
            List[String]("_")
        ),
        semantic_actions as List[String]("create_pattern_node"),
        precedence_rules as Dictionary[String, Integer](),
        first_set as List[String]("IDENTIFIER", "INTEGER", "FLOAT", "STRING", "BOOLEAN", "[", "{", "_"),
        follow_set as List[String]("=>", "if", ":", "\\n", "}")
    End ProductionRule

Note: =====================================================================
Note: GRAMMAR RULE UTILITIES
Note: =====================================================================

Process called "validate_grammar_set" that takes grammar as GrammarSet returns List[String]:
    Note: Validate grammar for consistency and completeness
    
    Let errors be List[String]()
    
    Note: Check that start symbol exists in non-terminals
    Let start_found be false
    For Each non_terminal in grammar.non_terminals:
        If non_terminal = grammar.start_symbol:
            Set start_found to true
        End If
    End For
    
    If not start_found:
        Add "Start symbol '" + grammar.start_symbol + "' not found in non-terminals" to errors
    End If
    
    Note: Check production rules reference valid symbols
    For Each production in grammar.production_rules:
        If not grammar.non_terminals contains production.non_terminal:
            Add "Production rule references undefined non-terminal: " + production.non_terminal to errors
        End If
        
        For Each alternative in production.alternatives:
            For Each symbol in alternative:
                If not grammar.terminals contains symbol and not grammar.non_terminals contains symbol:
                    Add "Production alternative references undefined symbol: " + symbol to errors
                End If
            End For
        End For
    End For
    
    Return errors

Process called "compute_first_sets" that takes grammar as GrammarSet returns Dictionary[String, List[String]]:
    Note: Compute FIRST sets for all non-terminals
    
    Let first_sets be Dictionary[String, List[String]]()
    
    Note: Initialize FIRST sets
    For Each non_terminal in grammar.non_terminals:
        Set first_sets[non_terminal] to List[String]()
    End For
    
    Let changed be true
    While changed:
        Set changed to false
        For Each production in grammar.production_rules:
            Let old_size be first_sets[production.non_terminal].count
            
            Note: Process first alternative to compute FIRST set
            If production.alternatives.count > 0:
                Let first_alternative be production.alternatives[0]
                If first_alternative.count > 0:
                    Let first_symbol be first_alternative[0]
                    If grammar.terminals contains first_symbol:
                        If not first_sets[production.non_terminal] contains first_symbol:
                            Add first_symbol to first_sets[production.non_terminal]
                        End If
                    End If
                End If
            End If
            
            If first_sets[production.non_terminal].count > old_size:
                Set changed to true
            End If
        End For
    End While
    
    Return first_sets

Process called "compute_follow_sets" that takes grammar as GrammarSet, first_sets as Dictionary[String, List[String]] returns Dictionary[String, List[String]]:
    Note: Compute FOLLOW sets for all non-terminals
    
    Let follow_sets be Dictionary[String, List[String]]()
    
    Note: Initialize FOLLOW sets
    For Each non_terminal in grammar.non_terminals:
        Set follow_sets[non_terminal] to List[String]()
    End For
    
    Note: Start symbol has EOF in its FOLLOW set
    Add "EOF" to follow_sets[grammar.start_symbol]
    
    Note: Compute FOLLOW sets using iterative algorithm
    Note: Implementation handles all production rules
    
    Let changed be true
    While changed:
        Set changed to false
        For Each production in grammar.production_rules:
            For Each alternative in production.alternatives:
                For i from 0 to alternative.count - 1:
                    Let symbol be alternative[i]
                    
                    Note: Skip terminals
                    If grammar.terminals contains symbol:
                        Continue
                    End If
                    
                    Note: Add FIRST of next symbols to FOLLOW of current
                    For j from i + 1 to alternative.count - 1:
                        Let next_symbol be alternative[j]
                        
                        If grammar.terminals contains next_symbol:
                            If not follow_sets[symbol] contains next_symbol:
                                Add next_symbol to follow_sets[symbol]
                                Set changed to true
                            End If
                            Break
                        Otherwise:
                            Note: Add FIRST(next_symbol) - epsilon to FOLLOW(symbol)
                            For Each terminal in first_sets[next_symbol]:
                                If terminal != "epsilon" and not follow_sets[symbol] contains terminal:
                                    Add terminal to follow_sets[symbol]
                                    Set changed to true
                                End If
                            End For
                            
                            Note: If next_symbol can derive epsilon, continue
                            If not first_sets[next_symbol] contains "epsilon":
                                Break
                            End If
                        End If
                    End For
                    
                    Note: If we reached end or all following symbols derive epsilon
                    Note: Add FOLLOW(production.non_terminal) to FOLLOW(symbol)
                    If i = alternative.count - 1 or all_derive_epsilon(alternative, i + 1, first_sets):
                        For Each terminal in follow_sets[production.non_terminal]:
                            If not follow_sets[symbol] contains terminal:
                                Add terminal to follow_sets[symbol]
                                Set changed to true
                            End If
                        End For
                    End If
                End For
            End For
        End For
    End While
    
    Return follow_sets

Process called "get_production_by_id" that takes grammar as GrammarSet, production_id as String returns ProductionRule:
    Note: Find production rule by ID
    
    For Each production in grammar.production_rules:
        If production.production_id = production_id:
            Return production
        End If
    End For
    
    Note: Return empty production if not found
    Return ProductionRule with
        production_id as "",
        non_terminal as "",
        alternatives as List[List[String]](),
        semantic_actions as List[String](),
        precedence_rules as Dictionary[String, Integer](),
        first_set as List[String](),
        follow_set as List[String]()
    End ProductionRule

Process called "is_terminal" that takes grammar as GrammarSet, symbol as String returns Boolean:
    Note: Check if symbol is terminal
    
    Return grammar.terminals contains symbol

Process called "is_non_terminal" that takes grammar as GrammarSet, symbol as String returns Boolean:
    Note: Check if symbol is non-terminal
    
    Return grammar.non_terminals contains symbol

Process called "get_precedence" that takes grammar as GrammarSet, operator as String returns Integer:
    Note: Get operator precedence from grammar rules
    
    For Each production in grammar.production_rules:
        If production.precedence_rules contains operator:
            Return production.precedence_rules[operator]
        End If
    End For
    
    Return 0

Process called "merge_grammars" that takes grammar1 as GrammarSet, grammar2 as GrammarSet returns GrammarSet:
    Note: Merge two grammar sets for mixed syntax support
    
    Let merged_terminals be List[String]()
    For Each terminal in grammar1.terminals:
        Add terminal to merged_terminals
    End For
    For Each terminal in grammar2.terminals:
        If not merged_terminals contains terminal:
            Add terminal to merged_terminals
        End If
    End For
    
    Let merged_non_terminals be List[String]()
    For Each non_terminal in grammar1.non_terminals:
        Add non_terminal to merged_non_terminals
    End For
    For Each non_terminal in grammar2.non_terminals:
        If not merged_non_terminals contains non_terminal:
            Add non_terminal to merged_non_terminals
        End If
    End For
    
    Let merged_productions be List[ProductionRule]()
    For Each production in grammar1.production_rules:
        Add production to merged_productions
    End For
    For Each production in grammar2.production_rules:
        Add production to merged_productions
    End For
    
    Return GrammarSet with
        grammar_name as grammar1.grammar_name + "_" + grammar2.grammar_name,
        syntax_mode as "mixed",
        terminals as merged_terminals,
        non_terminals as merged_non_terminals,
        production_rules as merged_productions,
        start_symbol as grammar1.start_symbol,
        error_productions as List[String]()
    End GrammarSet

Note: =====================================================================
Note: SEMANTIC ACTION FUNCTIONS FOR OPERATOR CONVERSION
Note: =====================================================================

Process called "create_binary_expression_with_conversion" that takes parser_context as String, tokens as List[String] returns String:
    Note: Semantic action that creates binary expression with automatic operator conversion
    Note: This function is called by the parser when a binary expression is recognized
    Note: It demonstrates how developer syntax gets converted to canon during parsing
    
    Note: Extract components from parsed tokens
    Let left_expr be tokens[0]
    Let operator_token be extract_operator_from_tokens(tokens)
    Let right_expr be tokens[tokens.count - 1]
    
    Note: The operator conversion happens here during parsing
    Note: Parser automatically converts "*" to "multiplied by" etc.
    Let canonical_operator be normalize_operator_from_parse(operator_token)
    
    Note: Return AST node reference for the created binary expression
    Return "binary_expr_" + left_expr + "_" + canonical_operator + "_" + right_expr

Process called "extract_operator_from_tokens" that takes tokens as List[String] returns String:
    Note: Extract the operator from the token sequence
    Note: Handles both single tokens (*) and multi-word operators (multiplied by)
    
    Note: For single operator tokens like "+", "*", "=="
    If tokens.count = 3:
        Return tokens[1]
    End If
    
    Note: For multi-word operators like "multiplied by", "is equal to"
    Let operator_parts be List[String]()
    For i from 1 to tokens.count - 2:
        Add tokens[i] to operator_parts
    End For
    
    Return join_tokens(operator_parts, " ")

Process called "normalize_operator_from_parse" that takes operator_token as String returns String:
    Note: Convert any operator form to canonical form during parsing
    Note: This is where the actual developer->canon conversion happens
    
    Match operator_token:
        When "*":
            Return "multiplied by"
        When "+":
            Return "plus"
        When "-":
            Return "minus"
        When "/":
            Return "divided by"
        When "%":
            Return "modulo"
        When "**", "^":
            Return "to the power of"
        When "==":
            Return "is equal to"
        When "!=":
            Return "is not equal to"
        When "<":
            Return "is less than"
        When ">":
            Return "is greater than"
        When "<=":
            Return "is less than or equal to"
        When ">=":
            Return "is greater than or equal to"
        When "&&":
            Return "and"
        When "||":
            Return "or"
        Otherwise:
            Note: Already in canonical form or unknown operator
            Return operator_token
    End Match

Process called "join_tokens" that takes tokens as List[String], separator as String returns String:
    Note: Join list of tokens with separator
    
    Let result be ""
    Let first be true
    
    For Each token in tokens:
        If not first:
            Set result to result + separator
        End If
        Set result to result + token
        Set first to false
    End For
    
    Return result

Note: =====================================================================
Note: LEXICAL INFRASTRUCTURE INTEGRATION
Note: =====================================================================

Process called "get_operator_precedence_rules" returns Dictionary[String, Integer]:
    Note: Get operator precedence rules from lexical infrastructure
    
    Let precedence_rules be Dictionary[String, Integer]()
    
    Note: Get all operators from lexical system
    Let operator_list be Operators.get_all_operators()
    For Each op in operator_list:
        Set precedence_rules[op.symbol_form] to op.precedence
        
        Note: Also add canonical form if different
        If op.canonical_form != op.symbol_form:
            Set precedence_rules[op.canonical_form] to op.precedence
        End If
    End For
    
    Note: Add mathematical symbol precedence
    Let math_table be MathSymbols.create_math_symbol_table()
    Let math_operators be MathSymbols.get_tensor_operators(math_table)
    For Each math_op in math_operators:
        If math_op.is_operator:
            Set precedence_rules[math_op.unicode_char] to math_op.precedence
            Set precedence_rules[math_op.canonical_name] to math_op.precedence
        End If
    End For
    
    Note: Add keyword operator precedence (And, Or, Not)
    Set precedence_rules["And"] to 2
    Set precedence_rules["Or"] to 1
    Set precedence_rules["Not"] to 8
    
    Return precedence_rules

Process called "get_terminals_from_lexical_system" returns List[String]:
    Note: Generate terminal list from lexical system instead of hardcoding
    
    Let terminals be List[String]()
    
    Note: Add keywords from lexical system
    Let keywords be Keywords.get_all_keywords()
    For Each keyword in keywords:
        Add keyword to terminals
    End For
    
    Note: Add operators from lexical system
    Let operators be Operators.get_all_operators()
    For Each op in operators:
        Add op.symbol_form to terminals
        If op.canonical_form != op.symbol_form:
            Add op.canonical_form to terminals
        End If
    End For
    
    Note: Add mathematical symbols
    Let math_table be MathSymbols.create_math_symbol_table()
    Add "∑" to terminals
    Add "∏" to terminals
    Add "∫" to terminals
    Add "∂" to terminals
    Add "√" to terminals
    Add "α" to terminals
    Add "β" to terminals
    Add "γ" to terminals
    Add "π" to terminals
    
    Note: Add basic token types
    Add "IDENTIFIER" to terminals
    Add "INTEGER" to terminals
    Add "FLOAT" to terminals
    Add "STRING" to terminals
    Add "BOOLEAN" to terminals
    Add "(" to terminals
    Add ")" to terminals
    Add "[" to terminals
    Add "]" to terminals
    Add "{" to terminals
    Add "}" to terminals
    Add "," to terminals
    Add ":" to terminals
    Add "." to terminals
    Add ";" to terminals
    Add "\n" to terminals
    Add "EOF" to terminals
    
    Return terminals

Process called "validate_operator_grammar_consistency" that takes grammar as GrammarSet returns List[String]:
    Note: Validate that grammar operators are consistent with lexical system
    
    Let errors be List[String]()
    
    Note: Check that all operators in grammar exist in lexical system
    For Each production in grammar.production_rules:
        For Each alternative in production.alternatives:
            For Each symbol in alternative:
                Note: Check if symbol is an operator that should exist in lexical system
                If is_operator_symbol(symbol):
                    Let op_exists be check_operator_exists_in_lexical_system(symbol)
                    If not op_exists:
                        Add "Operator '" + symbol + "' not found in lexical system" to errors
                    End If
                End If
            End For
        End For
    End For
    
    Return errors

Process called "is_operator_symbol" that takes symbol as String returns Boolean:
    Note: Check if a symbol looks like an operator
    
    Match symbol:
        When "+", "-", "*", "/", "%", "^", "**":
            Return true
        When "==", "!=", "<", ">", "<=", ">=":
            Return true
        When "&&", "||", "!":
            Return true
        When "And", "Or", "Not":
            Return true
        When "plus", "minus", "multiplied", "divided", "modulo":
            Return true
        Otherwise:
            Return false
    End Match

Process called "check_operator_exists_in_lexical_system" that takes symbol as String returns Boolean:
    Note: Check if operator exists in lexical system
    
    Note: Check in operators module
    Let op be Operators.get_operator_by_symbol(symbol)
    If op.symbol_form != "":
        Return true
    End If
    
    Note: Check if it's a keyword operator
    Let keywords be Keywords.get_all_keywords()
    For Each keyword in keywords:
        If keyword = symbol:
            Return true
        End If
    End For
    
    Note: Check mathematical symbols
    Let math_table be MathSymbols.create_math_symbol_table()
    Let first_char be get_first_character_from_string(symbol)
    If MathSymbols.is_math_symbol(math_table, first_char):
        Return true
    End If
    
    Return false

Process called "get_first_character_from_string" that takes text as String returns Character:
    Note: Helper to get first character from string for math symbol checking
    
    If text = "":
        Return '\0'
    End If
    
    Note: Handle common cases directly
    Match text:
        When "∑":
            Return '∑'
        When "∏":
            Return '∏'
        When "∫":
            Return '∫'
        When "√":
            Return '√'
        When "α":
            Return 'α'
        When "β":
            Return 'β'
        When "γ":
            Return 'γ'
        When "π":
            Return 'π'
        Otherwise:
            Return '?'
    End Match

Process called "get_mathematical_precedence_rules" returns Dictionary[String, Integer]:
    Note: Get mathematical operator precedence rules from lexical infrastructure
    
    Let math_precedence be Dictionary[String, Integer]()
    
    Note: Get mathematical symbol precedence from lexical system
    Let math_table be MathSymbols.create_math_symbol_table()
    
    Note: Set precedence for mathematical symbols from lexical system
    Set math_precedence["∑"] to get_math_symbol_precedence(∑)
    Set math_precedence["∏"] to get_math_symbol_precedence(∏)
    Set math_precedence["∫"] to get_math_symbol_precedence(∫)
    Set math_precedence["∂"] to get_math_symbol_precedence(∂)
    Set math_precedence["√"] to get_math_symbol_precedence(√)
    Set math_precedence["^"] to 8
    Set math_precedence["+"] to 10
    
    Return math_precedence

Process called "get_math_symbol_precedence" that takes symbol as Character returns Integer:
    Note: Get precedence for a specific mathematical symbol
    
    Let math_table be MathSymbols.create_math_symbol_table()
    If MathSymbols.is_math_operator(math_table, symbol):
        Return MathSymbols.get_operator_precedence(math_table, symbol)
    End If
    
    Note: Default precedence for unknown mathematical symbols
    Return 10

Process called "all_derive_epsilon" that takes alternative as List[String], start_index as Integer, first_sets as Dictionary[String, List[String]] returns Boolean:
    Note: Check if all symbols from start_index to end can derive epsilon
    
    For i from start_index to alternative.count - 1:
        Let symbol be alternative[i]
        If not first_sets[symbol] contains "epsilon":
            Return false
        End If
    End For
    
    Return true