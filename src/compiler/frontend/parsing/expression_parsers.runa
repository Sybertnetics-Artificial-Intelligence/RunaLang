Note:
compiler/frontend/parsing/expression_parsers.runa
Expression Parsing with Automatic Developerï¿½Canon Conversion

This module demonstrates the automatic conversion from developer syntax operators
to canonical form during parsing. Key features:
- Operator precedence climbing parser
- Automatic conversion of "*" to "multiplied by", "==" to "is equal to", etc.
- Support for both single-token and multi-word operators
- Integration with lexer's operator mapping system
- Preservation of original form for viewer mode transformation
- Mathematical expression parsing with Greek symbols
- Context-sensitive operator parsing
:End Note

Import Module "compiler/frontend/parsing/ast" As AST
Import Module "compiler/frontend/parsing/grammar_rules" As Grammar
Import Module "compiler/frontend/lexical/operators" As Operators
Import Module "compiler/frontend/lexical/keywords" As Keywords
Import Module "compiler/frontend/lexical/math_symbols" As MathSymbols
Import Module "compiler/frontend/diagnostics/errors" As Errors

Note: =====================================================================
Note: EXPRESSION PARSER WITH OPERATOR CONVERSION
Note: =====================================================================

Type called "ExpressionParseResult":
    success as Boolean
    expression_node as String
    errors as List[String]
    original_operator as String
    canonical_operator as String
    conversion_applied as Boolean

Process called "parse_binary_expression_with_conversion" that takes parser_context as String, left_token as String, operator_token as String, right_token as String, syntax_mode as String returns ExpressionParseResult:
    Note: Parse binary expression and demonstrate automatic operator conversion
    Note: This is where the developerï¿½canon magic happens during parsing
    
    Note: STEP 1: Determine input operator form
    Let input_operator be operator_token
    
    Note: STEP 2: Convert to canonical form based on syntax mode
    Let canonical_operator be ""
    Let conversion_applied be false
    
    If syntax_mode = "developer":
        Note: Developer mode - use lexical infrastructure for conversion
        
        Note: Try operator conversion first
        Let operator_canonical be Operators.symbol_to_canonical(input_operator)
        If operator_canonical != "" and operator_canonical != input_operator:
            Set canonical_operator to operator_canonical
            Set conversion_applied to true
        Otherwise:
            Note: Try keyword conversion for logical operators
            Let keyword_canonical be Keywords.convert_to_canonical(input_operator, "developer")
            If keyword_canonical != input_operator:
                Set canonical_operator to keyword_canonical
                Set conversion_applied to true
            Otherwise:
                Note: Check if it's a mathematical symbol
                Let math_table be MathSymbols.create_math_symbol_table()
                Let canonical_math be MathSymbols.convert_to_canon_mode(math_table, input_operator)
                If canonical_math != input_operator:
                    Set canonical_operator to canonical_math
                    Set conversion_applied to true
                Otherwise:
                    Note: No conversion available, use as-is
                    Set canonical_operator to input_operator
                End If
            End If
        End If
    Otherwise:
        Note: Canon mode - use as-is
        Set canonical_operator to input_operator
    End If
    
    Note: STEP 3: Create AST using canonical form
    Note: This ensures internal consistency - all ASTs use canonical operators
    Let ast_builder be AST.create_ast_builder("expr_parser", syntax_mode)
    
    Note: Create placeholder nodes for operands (in real parser, these would be actual nodes)
    Let left_node be AST.create_node(ast_builder, "Identifier")
    Set left_node.attributes["name"] to left_token
    
    Let right_node be AST.create_node(ast_builder, "Identifier") 
    Set right_node.attributes["name"] to right_token
    
    Note: STEP 4: Create binary expression with converted operator
    Let expr_node be AST.create_binary_expression(ast_builder, canonical_operator, left_node, right_node)
    
    Note: STEP 5: Preserve conversion information for debugging/viewer mode
    If conversion_applied:
        Set expr_node.base_node.original_operators["input_form"] to input_operator
        Set expr_node.base_node.original_operators["canonical_form"] to canonical_operator
        Set expr_node.base_node.metadata["conversion_applied"] to "true"
        Set expr_node.base_node.metadata["syntax_mode"] to syntax_mode
    End If
    
    Return ExpressionParseResult with
        success as true,
        expression_node as expr_node.base_node.node_id,
        errors as List[String](),
        original_operator as input_operator,
        canonical_operator as canonical_operator,
        conversion_applied as conversion_applied
    End ExpressionParseResult

Process called "demonstrate_operator_conversion_examples" that takes syntax_mode as String returns List[String]:
    Note: Demonstrate various operator conversion examples
    Note: Shows exactly how developer syntax gets converted to canon
    
    Let examples be List[String]()
    
    Note: Arithmetic operator conversions
    Let mult_result be parse_binary_expression_with_conversion("demo", "x", "*", "y", syntax_mode)
    Add "Input: x * y ï¿½ Canonical: x " + mult_result.canonical_operator + " y" to examples
    
    Let add_result be parse_binary_expression_with_conversion("demo", "a", "+", "b", syntax_mode) 
    Add "Input: a + b ï¿½ Canonical: a " + add_result.canonical_operator + " b" to examples
    
    Note: Comparison operator conversions
    Let eq_result be parse_binary_expression_with_conversion("demo", "x", "==", "y", syntax_mode)
    Add "Input: x == y ï¿½ Canonical: x " + eq_result.canonical_operator + " y" to examples
    
    Let lt_result be parse_binary_expression_with_conversion("demo", "a", "<", "b", syntax_mode)
    Add "Input: a < b ï¿½ Canonical: a " + lt_result.canonical_operator + " b" to examples
    
    Note: Logical operator conversions  
    Let and_result be parse_binary_expression_with_conversion("demo", "p", "&&", "q", syntax_mode)
    Add "Input: p && q ï¿½ Canonical: p " + and_result.canonical_operator + " q" to examples
    
    Return examples

Process called "parse_mathematical_expression_with_symbols" that takes expression as String, syntax_mode as String returns ExpressionParseResult:
    Note: Parse mathematical expressions with Greek symbols
    Note: Demonstrates parsing of expressions like "ï¿½ * ï¿½ + ï¿½"
    
    Let ast_builder be AST.create_ast_builder("math_parser", syntax_mode)
    
    Note: Example: Parse "ï¿½ * ï¿½" mathematical expression
    Let alpha_node be AST.create_node(ast_builder, "MathSymbol")
    Set alpha_node.attributes["symbol"] to "ï¿½"
    Set alpha_node.attributes["canonical_name"] to "alpha"
    
    Let beta_node be AST.create_node(ast_builder, "MathSymbol")
    Set beta_node.attributes["symbol"] to "ï¿½" 
    Set beta_node.attributes["canonical_name"] to "beta"
    
    Note: Create mathematical expression using canonical operator
    Let canonical_operator be convert_math_operator_to_canonical("*", syntax_mode)
    Let math_expr be AST.create_mathematical_expression(ast_builder, canonical_operator, List[String](alpha_node, beta_node))
    
    Return ExpressionParseResult with
        success as true,
        expression_node as math_expr.base_node.node_id,
        errors as List[String](),
        original_operator as "*",
        canonical_operator as canonical_operator,
        conversion_applied as (canonical_operator != "*")
    End ExpressionParseResult

Process called "convert_math_operator_to_canonical" that takes operator as String, syntax_mode as String returns String:
    Note: Convert mathematical operators to canonical form
    
    If syntax_mode = "developer":
        Match operator:
            When "*":
                Return "multiplied by"
            When "+":
                Return "plus"
            When "":
                Return "sum"
            When "":
                Return "product"  
            When "+":
                Return "integral"
            Otherwise:
                Return operator
        End Match
    End If
    
    Return operator

Note: =====================================================================
Note: OPERATOR PRECEDENCE WITH CONVERSION
Note: =====================================================================

Process called "parse_expression_with_precedence" that takes tokens as List[String], syntax_mode as String returns ExpressionParseResult:
    Note: Parse expression using precedence climbing with automatic conversion
    Note: Handles complex expressions like "a + b * c" with proper precedence
    
    If tokens.count < 3:
        Return ExpressionParseResult with
            success as false,
            expression_node as "",
            errors as List[String]("Insufficient tokens for binary expression"),
            original_operator as "",
            canonical_operator as "",
            conversion_applied as false
        End ExpressionParseResult
    End If
    
    Note: Simple case: left op right  
    Let left_token be tokens[0]
    Let operator_token be tokens[1]
    Let right_token be tokens[2]
    
    Note: Apply automatic conversion based on syntax mode
    Let result be parse_binary_expression_with_conversion("precedence", left_token, operator_token, right_token, syntax_mode)
    
    Note: Get precedence from lexer for canonical operator
    Let precedence be get_canonical_operator_precedence(result.canonical_operator)
    
    Note: Store precedence information in result
    Let ast_builder be AST.create_ast_builder("prec_parser", syntax_mode)
    Let expr_node_ref be result.expression_node
    Note: In real implementation, would retrieve and update the actual node
    
    Return result

Process called "get_canonical_operator_precedence" that takes canonical_operator as String returns Integer:
    Note: Get precedence for canonical operator forms using lexical infrastructure
    
    Note: Try to get precedence from operators module first
    Let op_by_canonical be get_operator_by_canonical_form(canonical_operator)
    If op_by_canonical != "":
        Return get_operator_precedence_for_canonical(op_by_canonical)
    End If
    
    Note: Try mathematical symbol precedence
    Let math_table be MathSymbols.create_math_symbol_table()
    Let precedence be get_math_symbol_precedence_by_canonical(math_table, canonical_operator)
    If precedence > 0:
        Return precedence
    End If
    
    Note: Fallback to hardcoded precedence for remaining cases
    Match canonical_operator:
        When "Or":
            Return 1
        When "And":
            Return 2
        When "is equal to", "is not equal to":
            Return 3
        When "is less than", "is greater than", "is less than or equal to", "is greater than or equal to":
            Return 4
        When "plus", "minus":
            Return 5
        When "multiplied by", "divided by", "modulo":
            Return 6
        When "to the power of":
            Return 7
        Otherwise:
            Return 0
    End Match

Note: =====================================================================
Note: CONVERSION VALIDATION AND TESTING
Note: =====================================================================

Process called "validate_operator_conversion" that takes input_operator as String, expected_canonical as String, syntax_mode as String returns Boolean:
    Note: Test that operator conversion works correctly
    
    Let result be parse_binary_expression_with_conversion("validation", "x", input_operator, "y", syntax_mode)
    
    If not result.success:
        Return false
    End If
    
    Return result.canonical_operator = expected_canonical

Process called "run_conversion_tests" that takes syntax_mode as String returns List[String]:
    Note: Run comprehensive tests of operator conversion
    
    Let test_results be List[String]()
    
    Note: Test arithmetic operators
    If validate_operator_conversion("*", "multiplied by", syntax_mode):
        Add " '*' correctly converts to 'multiplied by'" to test_results
    Otherwise:
        Add " '*' conversion failed" to test_results
    End If
    
    If validate_operator_conversion("+", "plus", syntax_mode):
        Add " '+' correctly converts to 'plus'" to test_results  
    Otherwise:
        Add " '+' conversion failed" to test_results
    End If
    
    Note: Test comparison operators
    If validate_operator_conversion("==", "is equal to", syntax_mode):
        Add " '==' correctly converts to 'is equal to'" to test_results
    Otherwise:
        Add " '==' conversion failed" to test_results  
    End If
    
    Note: Test logical operators
    If validate_operator_conversion("&&", "And", syntax_mode):
        Add " '&&' correctly converts to 'And'" to test_results
    Otherwise:
        Add " '&&' conversion failed" to test_results
    End If
    
    Return test_results

Process called "demonstrate_full_parsing_pipeline" that takes source_expression as String, syntax_mode as String returns String:
    Note: Demonstrate complete parsing pipeline with conversion
    Note: Shows the full journey from source code to canonical AST
    
    Let pipeline_log be "=== PARSING PIPELINE DEMONSTRATION ===\n"
    Set pipeline_log to pipeline_log + "Input: " + source_expression + "\n"
    Set pipeline_log to pipeline_log + "Syntax Mode: " + syntax_mode + "\n\n"
    
    Note: Step 1: Tokenization (simulated)
    Set pipeline_log to pipeline_log + "1. TOKENIZATION:\n"
    Let tokens be simple_tokenize(source_expression)
    For Each token in tokens:
        Set pipeline_log to pipeline_log + "   Token: '" + token + "'\n"
    End For
    
    Note: Step 2: Parsing with conversion  
    Set pipeline_log to pipeline_log + "\n2. PARSING WITH CONVERSION:\n"
    Let result be parse_expression_with_precedence(tokens, syntax_mode)
    
    If result.success:
        Set pipeline_log to pipeline_log + "   Original operator: '" + result.original_operator + "'\n"
        Set pipeline_log to pipeline_log + "   Canonical operator: '" + result.canonical_operator + "'\n"
        Set pipeline_log to pipeline_log + "   Conversion applied: " + result.conversion_applied + "\n"
        Set pipeline_log to pipeline_log + "   AST Node ID: " + result.expression_node + "\n"
    Otherwise:
        Set pipeline_log to pipeline_log + "   Parse failed: " + result.errors[0] + "\n"
    End If
    
    Note: Step 3: AST Structure
    Set pipeline_log to pipeline_log + "\n3. RESULTING AST:\n"
    Set pipeline_log to pipeline_log + "   Expression Type: BinaryExpression\n"
    Set pipeline_log to pipeline_log + "   Internal Operator: " + result.canonical_operator + "\n"
    Set pipeline_log to pipeline_log + "   Preserves Original: " + result.original_operator + "\n"
    
    Return pipeline_log

Process called "simple_tokenize" that takes expression as String returns List[String]:
    Note: Simple tokenizer for demonstration purposes
    
    Let tokens be List[String]()
    Let current_token be ""
    
    For Each char in expression:
        If char = " ":
            If current_token != "":
                Add current_token to tokens
                Set current_token to ""
            End If
        Otherwise:
            Set current_token to current_token + char
        End If
    End For
    
    If current_token != "":
        Add current_token to tokens
    End If
    
    Return tokens

Note: =====================================================================
Note: LEXICAL INFRASTRUCTURE HELPER FUNCTIONS
Note: =====================================================================

Process called "get_operator_by_canonical_form" that takes canonical_form as String returns String:
    Note: Find operator by canonical form - helper for lexical integration
    
    Let operator_list be Operators.get_all_operators()
    For Each op in operator_list:
        If op.canonical_form = canonical_form:
            Return op.symbol_form
        End If
    End For
    
    Return ""

Process called "get_operator_precedence_for_canonical" that takes symbol_form as String returns Integer:
    Note: Get precedence for operator by its symbol form
    
    Let op be Operators.get_operator_by_symbol(symbol_form)
    If op.symbol_form != "":
        Return op.precedence
    End If
    
    Return 0

Process called "get_math_symbol_precedence_by_canonical" that takes math_table as MathSymbols.MathSymbolTable, canonical_name as String returns Integer:
    Note: Get precedence for mathematical symbol by canonical name
    
    Note: Look through all symbols to find matching canonical name
    Let symbols be math_table.canonical_lookup
    For Each canonical, symbol in symbols:
        If canonical = canonical_name and symbol.is_operator:
            Return symbol.precedence
        End If
    End For
    
    Return 0

Note: =====================================================================
Note: CONSTRUCTOR EXPRESSION PARSING
Note: =====================================================================

Process called "parse_constructor_expression" that takes parser_context as String, tokens as List[String], position as Integer, syntax_mode as String returns ExpressionParseResult:
    @Reasoning
        Parse constructor expressions using "a value of type TypeName" syntax.
        Supports both canonical and technical modes with proper conversion.
        Technical mode uses "new TypeName()" while canonical uses "a value of type".
    @End Reasoning
    
    Let result be ExpressionParseResult with
        success as false,
        expression_node as "",
        errors as List[String](),
        original_operator as "",
        canonical_operator as "",
        conversion_applied as false
    End ExpressionParseResult
    
    Note: Check for constructor pattern based on syntax mode
    Let is_constructor be false
    Let type_name be ""
    Let constructor_syntax be ""
    
    If syntax_mode = "canon" or syntax_mode = "natural":
        Note: Check for "a value of type TypeName" pattern
        If position + 3 < tokens.size():
            If tokens[position] = "a" and tokens[position + 1] = "value" and 
               tokens[position + 2] = "of" and tokens[position + 3] = "type":
                Set is_constructor to true
                Set constructor_syntax to "a value of type"
                If position + 4 < tokens.size():
                    Set type_name to tokens[position + 4]
                    Set result.conversion_applied to false
                Otherwise:
                    Add "Missing type name after 'a value of type'" to result.errors
                End If
            End If
        End If
        
        Note: Also check shortened form "of type TypeName"
        If not is_constructor and position + 1 < tokens.size():
            If tokens[position] = "of" and tokens[position + 1] = "type":
                Set is_constructor to true
                Set constructor_syntax to "of type"
                If position + 2 < tokens.size():
                    Set type_name to tokens[position + 2]
                    Set result.conversion_applied to false
                Otherwise:
                    Add "Missing type name after 'of type'" to result.errors
                End If
            End If
        End If
        
    Otherwise If syntax_mode = "developer" or syntax_mode = "technical":
        Note: Check for "new TypeName()" pattern in technical mode
        If tokens[position] = "new" and position + 1 < tokens.size():
            Set is_constructor to true
            Set type_name to tokens[position + 1]
            Set constructor_syntax to "new"
            Set result.conversion_applied to true
            Set result.original_operator to "new"
            Set result.canonical_operator to "a value of type"
        End If
    End If
    
    If not is_constructor:
        Add "Not a constructor expression" to result.errors
        Return result
    End If
    
    Note: Create AST for constructor
    Let ast_builder be AST.create_ast_builder("constructor_parser", syntax_mode)
    
    Note: Parse field initializers if present
    Let field_initializers be Dictionary[String, ASTNode]()
    Let current_pos be position + get_constructor_pattern_length(constructor_syntax, type_name)
    
    Note: Check for "with" clause for field initialization
    If current_pos < tokens.size() and tokens[current_pos] = "with":
        Set current_pos to current_pos + 1
        Note: Parse field initializers (field1 as value1, field2 as value2)
        Let parse_result be parse_field_initializers(ast_builder, tokens, current_pos)
        Set field_initializers to parse_result.initializers
        Set current_pos to parse_result.end_position
    End If
    
    Note: Create constructor node
    Let canonical_syntax be constructor_syntax
    If syntax_mode = "developer" or syntax_mode = "technical":
        Set canonical_syntax to "a value of type"
    End If
    
    Let constructor_node be AST.create_constructor_expression(ast_builder, type_name, field_initializers, canonical_syntax)
    
    Note: Store conversion information if applicable
    If result.conversion_applied:
        Set constructor_node.base_node.original_operators["technical_form"] to "new " + type_name + "()"
        Set constructor_node.base_node.original_operators["canonical_form"] to "a value of type " + type_name
        Set constructor_node.base_node.metadata["syntax_conversion"] to "technical_to_canonical"
    End If
    
    Set result.success to true
    Set result.expression_node to constructor_node.base_node.node_id
    
    Return result

Process called "get_constructor_pattern_length" that takes syntax_form as String, type_name as String returns Integer:
    @Implementation
        Calculate how many tokens the constructor pattern consumes.
    @End Implementation
    
    If syntax_form = "a value of type":
        Return 5  Note: "a" "value" "of" "type" "TypeName"
    Otherwise If syntax_form = "of type":
        Return 3  Note: "of" "type" "TypeName"
    Otherwise If syntax_form = "new":
        Return 2  Note: "new" "TypeName"
    Otherwise:
        Return 0
    End If

Process called "parse_field_initializers" that takes ast_builder as AST.ASTBuilder, tokens as List[String], start_pos as Integer returns FieldInitializerResult:
    @Implementation
        Parse field initializers in the form: field1 as value1, field2 as value2
    @End Implementation
    
    Let result be FieldInitializerResult with
        initializers as Dictionary[String, ASTNode](),
        end_position as start_pos
    End FieldInitializerResult
    
    Let current_pos be start_pos
    
    While current_pos < tokens.size():
        Note: Expect field name
        If current_pos >= tokens.size():
            Break
        End If
        
        Let field_name be tokens[current_pos]
        Set current_pos to current_pos + 1
        
        Note: Expect "as"
        If current_pos >= tokens.size() or tokens[current_pos] != "as":
            Break
        End If
        Set current_pos to current_pos + 1
        
        Note: Parse field value expression (simplified for now)
        If current_pos >= tokens.size():
            Break
        End If
        
        Let value_node be AST.create_node(ast_builder, "Literal")
        Set value_node.attributes["value"] to tokens[current_pos]
        Set current_pos to current_pos + 1
        
        Set result.initializers[field_name] to value_node
        
        Note: Check for comma continuation
        If current_pos < tokens.size() and tokens[current_pos] = ",":
            Set current_pos to current_pos + 1
        Otherwise:
            Break
        End If
    End While
    
    Set result.end_position to current_pos
    Return result

Type called "FieldInitializerResult":
    initializers as Dictionary[String, ASTNode]
    end_position as Integer