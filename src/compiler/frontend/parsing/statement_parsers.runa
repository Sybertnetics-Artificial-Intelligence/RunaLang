Note:
compiler/frontend/parsing/statement_parsers.runa
Statement Parsing with Dual Syntax Support

This module provides comprehensive statement parsing functionality including:
- Natural language statement parsing ("Let x be 5", "Process called foo")
- Technical syntax statement parsing (x = 5, function foo()) 
- Dual syntax mode support with automatic syntax detection
- AST generation using unified internal representation
- Integration with lexical infrastructure for operator conversion
- Support for all Runa statement types (declarations, assignments, control flow)
- Error recovery with context-aware error messages
- Performance optimized parsing algorithms
- Mathematical statement parsing with symbol support
:End Note

Import Module "compiler/frontend/diagnostics/errors" As Errors
Import Module "compiler/frontend/parsing/ast" As AST
Import Module "compiler/frontend/parsing/expression_parsers" As ExpressionParsers
Import Module "compiler/frontend/lexical/operators" As Operators
Import Module "compiler/frontend/lexical/keywords" As Keywords
Import Module "compiler/frontend/lexical/math_symbols" As MathSymbols

Note: =====================================================================
Note: STATEMENT PARSING RESULT TYPES
Note: =====================================================================

Type called "StatementParseResult":
    success as Boolean
    statement_node as String
    errors as List[String]
    tokens_consumed as Integer
    syntax_mode_detected as String
    requires_end_keyword as Boolean

Type called "ParserContext":
    current_position as Integer
    tokens as List[String]
    syntax_mode as String
    ast_builder as AST.ASTBuilder
    error_recovery_enabled as Boolean
    scope_stack as List[String]

Note: =====================================================================
Note: CORE STATEMENT PARSING FUNCTIONS
Note: =====================================================================

Process called "parse_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Main entry point for parsing any statement type
    
    If context.current_position >= context.tokens.count:
        Return StatementParseResult with
            success as false,
            statement_node as "",
            errors as List[String]("Unexpected end of input"),
            tokens_consumed as 0,
            syntax_mode_detected as context.syntax_mode,
            requires_end_keyword as false
        End StatementParseResult
    End If
    
    Let current_token be context.tokens[context.current_position]
    Let detected_mode be detect_statement_syntax_mode(current_token, context)
    
    Note: Parse based on detected syntax mode and statement type (case-insensitive)
    Let lowercase_token be String.to_lowercase(current_token)
    Match lowercase_token:
        When "let":
            Return parse_let_statement(context)
        When "set":
            Return parse_set_statement(context)
        When "process":
            Return parse_process_declaration(context)
        When "type":
            Return parse_type_declaration(context)
        When "if":
            Return parse_if_statement(context)
        When "for":
            Return parse_for_statement(context)
        When "while":
            Return parse_while_statement(context)
        When "match":
            Return parse_match_statement(context)
        When "return":
            Return parse_return_statement(context)
        When "import":
            Return parse_import_statement(context)
        When "constant":
            Return parse_constant_declaration(context)
        When "function":
            Note: Technical syntax detected
            Return parse_technical_statement(context, current_token)
        Otherwise:
            Note: Try expression statement or technical assignment
            Return parse_expression_or_assignment_statement(context)
    End Match

Process called "detect_statement_syntax_mode" that takes token as String, context as ParserContext returns String:
    Note: Detect whether statement uses natural or technical syntax
    
    Note: Check if token is a natural language keyword (case-insensitive)
    Let keywords be Keywords.get_all_keywords()
    Let lowercase_token be String.to_lowercase(token)
    For Each keyword in keywords:
        If String.to_lowercase(keyword) = lowercase_token:
            Return "natural"
        End If
    End For
    
    Note: Check for technical syntax indicators
    Match token:
        When "function", "if", "else", "for", "while":
            Return "technical"
        When "{", "(", "[":
            Return "technical"
        Otherwise:
            Note: Check if next tokens suggest assignment (x = value)
            If context.current_position + 2 < context.tokens.count:
                Let next_token be context.tokens[context.current_position + 1]
                If next_token = "=" or next_token = "+=" or next_token = "-=" or next_token = "*=" or next_token = "/=":
                    Return "technical"
                End If
            End If
            
            Note: Default to natural language mode
            Return "natural"
    End Match

Note: =====================================================================
Note: NATURAL LANGUAGE STATEMENT PARSERS
Note: =====================================================================

Process called "parse_let_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "Let identifier be expression" or "Let identifier as Type be expression"
    
    If context.current_position + 2 >= context.tokens.count:
        Return create_parse_error("Incomplete Let statement", 1)
    End If
    
    Let start_position be context.current_position
    Set context.current_position to context.current_position + 1  Note: Skip "Let"
    
    Let identifier be context.tokens[context.current_position]
    Set context.current_position to context.current_position + 1
    
    Note: Check for optional type annotation
    Let type_annotation be ""
    If context.current_position < context.tokens.count and context.tokens[context.current_position] = "as":
        Set context.current_position to context.current_position + 1  Note: Skip "as"
        If context.current_position >= context.tokens.count:
            Return create_parse_error("Expected type after 'as'", context.current_position - start_position)
        End If
        Set type_annotation to context.tokens[context.current_position]
        Set context.current_position to context.current_position + 1
    End If
    
    Note: Expect "be"
    If context.current_position >= context.tokens.count or context.tokens[context.current_position] != "be":
        Return create_parse_error("Expected 'be' in Let statement", context.current_position - start_position)
    End If
    Set context.current_position to context.current_position + 1  Note: Skip "be"
    
    Note: Parse expression
    Let expression_result be parse_expression_from_tokens(context)
    If not expression_result.success:
        Return StatementParseResult with
            success as false,
            statement_node as "",
            errors as expression_result.errors,
            tokens_consumed as context.current_position - start_position,
            syntax_mode_detected as "natural",
            requires_end_keyword as false
        End StatementParseResult
    End If
    
    Note: Create AST node
    Let identifier_node be AST.create_node(context.ast_builder, "Identifier")
    Set identifier_node.attributes["name"] to identifier
    
    Let expression_node be get_expression_node_by_id(context.ast_builder, expression_result.expression_node)
    
    Let let_statement be AST.create_let_statement(context.ast_builder, identifier, type_annotation, expression_node)
    
    Return StatementParseResult with
        success as true,
        statement_node as let_statement.base_node.node_id,
        errors as List[String](),
        tokens_consumed as context.current_position - start_position,
        syntax_mode_detected as "natural",
        requires_end_keyword as false
    End StatementParseResult

Process called "parse_set_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "Set identifier to expression" or "Set object.field to expression"
    
    If context.current_position + 3 >= context.tokens.count:
        Return create_parse_error("Incomplete Set statement", 1)
    End If
    
    Let start_position be context.current_position
    Set context.current_position to context.current_position + 1  Note: Skip "Set"
    
    Note: Parse target (could be simple identifier or member access)
    Let target_result be parse_assignment_target(context)
    If not target_result.success:
        Return StatementParseResult with
            success as false,
            statement_node as "",
            errors as target_result.errors,
            tokens_consumed as context.current_position - start_position,
            syntax_mode_detected as "natural",
            requires_end_keyword as false
        End StatementParseResult
    End If
    
    Note: Expect "to"
    If context.current_position >= context.tokens.count or context.tokens[context.current_position] != "to":
        Return create_parse_error("Expected 'to' in Set statement", context.current_position - start_position)
    End If
    Set context.current_position to context.current_position + 1  Note: Skip "to"
    
    Note: Parse expression
    Let expression_result be parse_expression_from_tokens(context)
    If not expression_result.success:
        Return StatementParseResult with
            success as false,
            statement_node as "",
            errors as expression_result.errors,
            tokens_consumed as context.current_position - start_position,
            syntax_mode_detected as "natural",
            requires_end_keyword as false
        End StatementParseResult
    End If
    
    Note: Create AST node
    Let target_node be get_expression_node_by_id(context.ast_builder, target_result.expression_node)
    Let value_node be get_expression_node_by_id(context.ast_builder, expression_result.expression_node)
    
    Let set_statement be AST.create_assignment_statement(context.ast_builder, target_node, value_node)
    
    Return StatementParseResult with
        success as true,
        statement_node as set_statement.base_node.node_id,
        errors as List[String](),
        tokens_consumed as context.current_position - start_position,
        syntax_mode_detected as "natural",
        requires_end_keyword as false
    End StatementParseResult

Process called "parse_process_declaration" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "Process called name that takes params returns Type: body End Process"
    
    Let start_position be context.current_position
    Set context.current_position to context.current_position + 1  Note: Skip "Process"
    
    Note: Expect "called"
    If context.current_position >= context.tokens.count or context.tokens[context.current_position] != "called":
        Return create_parse_error("Expected 'called' after 'Process'", context.current_position - start_position)
    End If
    Set context.current_position to context.current_position + 1  Note: Skip "called"
    
    Note: Parse function name
    If context.current_position >= context.tokens.count:
        Return create_parse_error("Expected process name", context.current_position - start_position)
    End If
    Let process_name be context.tokens[context.current_position]
    Set context.current_position to context.current_position + 1
    
    Note: Parse optional parameters
    Let parameters be List[AST.ASTNode]()
    Let return_type be ""
    
    If context.current_position < context.tokens.count and context.tokens[context.current_position] = "that":
        Set context.current_position to context.current_position + 1  Note: Skip "that"
        
        If context.current_position < context.tokens.count and context.tokens[context.current_position] = "takes":
            Set context.current_position to context.current_position + 1  Note: Skip "takes"
            
            Note: Parse parameter list
            Let param_result be parse_parameter_list(context)
            If not param_result.success:
                Return StatementParseResult with
                    success as false,
                    statement_node as "",
                    errors as param_result.errors,
                    tokens_consumed as context.current_position - start_position,
                    syntax_mode_detected as "natural",
                    requires_end_keyword as true
                End StatementParseResult
            End If
            Set parameters to param_result.parameters
        End If
        
        Note: Parse return type
        If context.current_position < context.tokens.count and context.tokens[context.current_position] = "returns":
            Set context.current_position to context.current_position + 1  Note: Skip "returns"
            If context.current_position >= context.tokens.count:
                Return create_parse_error("Expected return type", context.current_position - start_position)
            End If
            Set return_type to context.tokens[context.current_position]
            Set context.current_position to context.current_position + 1
        End If
    End If
    
    Note: Expect ":"
    If context.current_position >= context.tokens.count or context.tokens[context.current_position] != ":":
        Return create_parse_error("Expected ':' after process declaration", context.current_position - start_position)
    End If
    Set context.current_position to context.current_position + 1  Note: Skip ":"
    
    Note: Parse body
    Let body_result be parse_process_body(context)
    If not body_result.success:
        Return StatementParseResult with
            success as false,
            statement_node as "",
            errors as body_result.errors,
            tokens_consumed as context.current_position - start_position,
            syntax_mode_detected as "natural",
            requires_end_keyword as true
        End StatementParseResult
    End If
    
    Note: Create AST node
    Let body_node be get_statement_node_by_id(context.ast_builder, body_result.statement_node)
    Let process_decl be AST.create_process_declaration(context.ast_builder, process_name, parameters, return_type, body_node)
    
    Return StatementParseResult with
        success as true,
        statement_node as process_decl.base_node.node_id,
        errors as List[String](),
        tokens_consumed as context.current_position - start_position,
        syntax_mode_detected as "natural",
        requires_end_keyword as true
    End StatementParseResult

Process called "parse_if_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "If condition: then_block Otherwise: else_block End If"
    
    Let start_position be context.current_position
    Set context.current_position to context.current_position + 1  Note: Skip "If"
    
    Note: Parse condition
    Let condition_result be parse_expression_from_tokens(context)
    If not condition_result.success:
        Return StatementParseResult with
            success as false,
            statement_node as "",
            errors as condition_result.errors,
            tokens_consumed as context.current_position - start_position,
            syntax_mode_detected as "natural",
            requires_end_keyword as true
        End StatementParseResult
    End If
    
    Note: Expect ":"
    If context.current_position >= context.tokens.count or context.tokens[context.current_position] != ":":
        Return create_parse_error("Expected ':' after If condition", context.current_position - start_position)
    End If
    Set context.current_position to context.current_position + 1  Note: Skip ":"
    
    Note: Parse then block
    Let then_result be parse_statement_block(context, "End")
    If not then_result.success:
        Return StatementParseResult with
            success as false,
            statement_node as "",
            errors as then_result.errors,
            tokens_consumed as context.current_position - start_position,
            syntax_mode_detected as "natural",
            requires_end_keyword as true
        End StatementParseResult
    End If
    
    Note: Check for optional Otherwise clause
    Let else_node be AST.create_node(context.ast_builder, "EmptyStatement")
    If context.current_position < context.tokens.count and context.tokens[context.current_position] = "Otherwise":
        Set context.current_position to context.current_position + 1  Note: Skip "Otherwise"
        
        Note: Expect ":"
        If context.current_position >= context.tokens.count or context.tokens[context.current_position] != ":":
            Return create_parse_error("Expected ':' after 'Otherwise'", context.current_position - start_position)
        End If
        Set context.current_position to context.current_position + 1  Note: Skip ":"
        
        Note: Parse else block
        Let else_result be parse_statement_block(context, "End")
        If not else_result.success:
            Return StatementParseResult with
                success as false,
                statement_node as "",
                errors as else_result.errors,
                tokens_consumed as context.current_position - start_position,
                syntax_mode_detected as "natural",
                requires_end_keyword as true
            End StatementParseResult
        End If
        Set else_node to get_statement_node_by_id(context.ast_builder, else_result.statement_node)
    End If
    
    Note: Expect "End If"
    If not expect_end_keyword(context, "If"):
        Return create_parse_error("Expected 'End If'", context.current_position - start_position)
    End If
    
    Note: Create AST node
    Let condition_node be get_expression_node_by_id(context.ast_builder, condition_result.expression_node)
    Let then_node be get_statement_node_by_id(context.ast_builder, then_result.statement_node)
    
    Let if_statement be AST.create_if_statement(context.ast_builder, condition_node, then_node, else_node)
    
    Return StatementParseResult with
        success as true,
        statement_node as if_statement.base_node.node_id,
        errors as List[String](),
        tokens_consumed as context.current_position - start_position,
        syntax_mode_detected as "natural",
        requires_end_keyword as false
    End StatementParseResult

Note: =====================================================================
Note: TECHNICAL SYNTAX STATEMENT PARSERS  
Note: =====================================================================

Process called "parse_technical_statement" that takes context as ParserContext, keyword as String returns StatementParseResult:
    Note: Parse technical syntax statements (function, etc.)
    
    Match keyword:
        When "function":
            Return parse_technical_function_declaration(context)
        When "if":
            Return parse_technical_if_statement(context)
        When "for":
            Return parse_technical_for_statement(context)
        When "while":
            Return parse_technical_while_statement(context)
        Otherwise:
            Return create_parse_error("Unknown technical syntax keyword: " + keyword, 1)
    End Match

Process called "parse_technical_function_declaration" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "function name(params): return_type { body }"
    
    Let start_position be context.current_position
    Set context.current_position to context.current_position + 1  Note: Skip "function"
    
    Note: Parse function name
    If context.current_position >= context.tokens.count:
        Return create_parse_error("Expected function name", context.current_position - start_position)
    End If
    Let function_name be context.tokens[context.current_position]
    Set context.current_position to context.current_position + 1
    
    Note: Parse parameter list "(params)"
    Let param_result be parse_technical_parameter_list(context)
    If not param_result.success:
        Return StatementParseResult with
            success as false,
            statement_node as "",
            errors as param_result.errors,
            tokens_consumed as context.current_position - start_position,
            syntax_mode_detected as "technical",
            requires_end_keyword as false
        End StatementParseResult
    End If
    
    Note: Parse optional return type
    Let return_type be ""
    If context.current_position < context.tokens.count and context.tokens[context.current_position] = ":":
        Set context.current_position to context.current_position + 1  Note: Skip ":"
        If context.current_position >= context.tokens.count:
            Return create_parse_error("Expected return type", context.current_position - start_position)
        End If
        Set return_type to context.tokens[context.current_position]
        Set context.current_position to context.current_position + 1
    End If
    
    Note: Parse body block
    Let body_result be parse_technical_block(context)
    If not body_result.success:
        Return StatementParseResult with
            success as false,
            statement_node as "",
            errors as body_result.errors,
            tokens_consumed as context.current_position - start_position,
            syntax_mode_detected as "technical",
            requires_end_keyword as false
        End StatementParseResult
    End If
    
    Note: Create AST node
    Let body_node be get_statement_node_by_id(context.ast_builder, body_result.statement_node)
    Let func_decl be AST.create_function_declaration(context.ast_builder, function_name, param_result.parameters, return_type, body_node)
    
    Return StatementParseResult with
        success as true,
        statement_node as func_decl.base_node.node_id,
        errors as List[String](),
        tokens_consumed as context.current_position - start_position,
        syntax_mode_detected as "technical",
        requires_end_keyword as false
    End StatementParseResult

Process called "parse_expression_or_assignment_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Parse either expression statement or assignment statement
    
    Let start_position be context.current_position
    
    Note: Look ahead to determine if this is assignment
    Let is_assignment be false
    Let lookahead_pos be context.current_position
    
    Note: Skip identifier and check for assignment operator
    If lookahead_pos < context.tokens.count:
        Set lookahead_pos to lookahead_pos + 1
        
        Note: Skip potential member access (obj.field)
        While lookahead_pos < context.tokens.count and context.tokens[lookahead_pos] = ".":
            Set lookahead_pos to lookahead_pos + 2  Note: Skip "." and field name
        End While
        
        Note: Check for assignment operator
        If lookahead_pos < context.tokens.count:
            Let potential_op be context.tokens[lookahead_pos]
            If potential_op = "=" or potential_op = "+=" or potential_op = "-=" or potential_op = "*=" or potential_op = "/=":
                Set is_assignment to true
            End If
        End If
    End If
    
    If is_assignment:
        Return parse_technical_assignment(context)
    Otherwise:
        Return parse_expression_statement(context)
    End If

Note: =====================================================================
Note: PARSING HELPER FUNCTIONS
Note: =====================================================================

Process called "parse_expression_from_tokens" that takes context as ParserContext returns ExpressionParsers.ExpressionParseResult:
    Note: Parse expression starting from current position using expression parser
    
    Let remaining_tokens be List[String]()
    For i from context.current_position to context.tokens.count - 1:
        Add context.tokens[i] to remaining_tokens
    End For
    
    Let result be ExpressionParsers.parse_expression_with_precedence(remaining_tokens, context.syntax_mode)
    Set context.current_position to context.current_position + result.tokens_consumed
    
    Return result

Process called "parse_assignment_target" that takes context as ParserContext returns ExpressionParsers.ExpressionParseResult:
    Note: Parse assignment target (identifier or member access)
    
    Let start_position be context.current_position
    
    If context.current_position >= context.tokens.count:
        Return ExpressionParsers.ExpressionParseResult with
            success as false,
            expression_node as "",
            errors as List[String]("Expected assignment target"),
            original_operator as "",
            canonical_operator as "",
            conversion_applied as false
        End ExpressionParsers.ExpressionParseResult
    End If
    
    Let identifier be context.tokens[context.current_position]
    Set context.current_position to context.current_position + 1
    
    Note: Create identifier node
    Let target_node be AST.create_node(context.ast_builder, "Identifier")
    Set target_node.attributes["name"] to identifier
    
    Note: Check for member access
    While context.current_position + 1 < context.tokens.count and context.tokens[context.current_position] = ".":
        Set context.current_position to context.current_position + 1  Note: Skip "."
        Let member_name be context.tokens[context.current_position]
        Set context.current_position to context.current_position + 1
        
        Note: Create member access node
        Let member_node be AST.create_member_access(context.ast_builder, target_node, member_name)
        Set target_node to member_node.base_node
    End While
    
    Return ExpressionParsers.ExpressionParseResult with
        success as true,
        expression_node as target_node.node_id,
        errors as List[String](),
        original_operator as "",
        canonical_operator as "",
        conversion_applied as false
    End ExpressionParsers.ExpressionParseResult

Process called "parse_parameter_list" that takes context as ParserContext returns ParameterListResult:
    Note: Parse natural language parameter list "param1 as Type, param2 as Type"
    
    Let parameters be List[AST.ASTNode]()
    
    While context.current_position < context.tokens.count and context.tokens[context.current_position] != "returns":
        If context.current_position + 2 >= context.tokens.count:
            Return ParameterListResult with
                success as false,
                parameters as parameters,
                errors as List[String]("Incomplete parameter declaration")
            End ParameterListResult
        End If
        
        Let param_name be context.tokens[context.current_position]
        Set context.current_position to context.current_position + 1
        
        Note: Expect "as"
        If context.tokens[context.current_position] != "as":
            Return ParameterListResult with
                success as false,
                parameters as parameters,
                errors as List[String]("Expected 'as' in parameter declaration")
            End ParameterListResult
        End If
        Set context.current_position to context.current_position + 1
        
        Let param_type be context.tokens[context.current_position]
        Set context.current_position to context.current_position + 1
        
        Note: Create parameter node
        Let param_node be AST.create_variable_declaration(context.ast_builder, param_name, param_type, AST.create_node(context.ast_builder, "EmptyExpression"))
        Add param_node to parameters
        
        Note: Skip comma if present
        If context.current_position < context.tokens.count and context.tokens[context.current_position] = ",":
            Set context.current_position to context.current_position + 1
        End If
    End While
    
    Return ParameterListResult with
        success as true,
        parameters as parameters,
        errors as List[String]()
    End ParameterListResult

Process called "parse_statement_block" that takes context as ParserContext, end_token as String returns StatementParseResult:
    Note: Parse block of statements until end token
    
    Let statements be List[AST.ASTNode]()
    Let block_errors be List[String]()
    Let start_position be context.current_position
    
    While context.current_position < context.tokens.count and context.tokens[context.current_position] != end_token:
        Let stmt_result be parse_statement(context)
        If stmt_result.success:
            Let stmt_node be get_statement_node_by_id(context.ast_builder, stmt_result.statement_node)
            Add stmt_node to statements
        Otherwise:
            For Each error in stmt_result.errors:
                Add error to block_errors
            End For
            Note: Skip to next statement for error recovery
            Set context.current_position to context.current_position + 1
        End If
    End While
    
    Note: Create block node
    Let block_node be AST.create_node(context.ast_builder, "Block")
    For Each stmt in statements:
        Add stmt.node_id to block_node.children
        Set stmt.parent to block_node.node_id
    End For
    
    Return StatementParseResult with
        success as (block_errors.count = 0),
        statement_node as block_node.node_id,
        errors as block_errors,
        tokens_consumed as context.current_position - start_position,
        syntax_mode_detected as context.syntax_mode,
        requires_end_keyword as false
    End StatementParseResult

Process called "expect_end_keyword" that takes context as ParserContext, keyword as String returns Boolean:
    Note: Expect "End" followed by specific keyword
    
    If context.current_position + 1 >= context.tokens.count:
        Return false
    End If
    
    If context.tokens[context.current_position] != "End":
        Return false
    End If
    
    If context.tokens[context.current_position + 1] != keyword:
        Return false
    End If
    
    Set context.current_position to context.current_position + 2
    Return true

Note: =====================================================================
Note: UTILITY FUNCTIONS
Note: =====================================================================

Process called "create_parse_error" that takes message as String, tokens_consumed as Integer returns StatementParseResult:
    Note: Create standardized parse error result
    
    Return StatementParseResult with
        success as false,
        statement_node as "",
        errors as List[String](message),
        tokens_consumed as tokens_consumed,
        syntax_mode_detected as "unknown",
        requires_end_keyword as false
    End StatementParseResult

Process called "get_expression_node_by_id" that takes builder as AST.ASTBuilder, node_id as String returns AST.ASTNode:
    Note: Retrieve expression node from builder registry
    
    Return AST.get_node_by_id_direct(builder, node_id)

Process called "get_statement_node_by_id" that takes builder as AST.ASTBuilder, node_id as String returns AST.ASTNode:
    Note: Retrieve statement node from builder registry
    
    Return AST.get_node_by_id_direct(builder, node_id)

Process called "create_parser_context" that takes tokens as List[String], syntax_mode as String, ast_builder as AST.ASTBuilder returns ParserContext:
    Note: Create parser context with given parameters
    
    Return ParserContext with
        current_position as 0,
        tokens as tokens,
        syntax_mode as syntax_mode,
        ast_builder as ast_builder,
        error_recovery_enabled as true,
        scope_stack as List[String]("global")
    End ParserContext

Note: =====================================================================
Note: ADDITIONAL RESULT TYPES
Note: =====================================================================

Type called "ParameterListResult":
    success as Boolean
    parameters as List[AST.ASTNode]
    errors as List[String]

Note: =====================================================================
Note: REMAINING STATEMENT PARSERS (STUBS FOR COMPLETION)
Note: =====================================================================

Process called "parse_type_declaration" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "Type called Name: fields End Type"
    Return create_parse_error("Type declaration parsing not yet implemented", 1)

Process called "parse_for_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "For Each item in collection: body End For"
    Return create_parse_error("For statement parsing not yet implemented", 1)

Process called "parse_while_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "While condition: body End While"
    Return create_parse_error("While statement parsing not yet implemented", 1)

Process called "parse_match_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "Match expression: cases End Match"
    Return create_parse_error("Match statement parsing not yet implemented", 1)

Process called "parse_return_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "Return expression"
    Return create_parse_error("Return statement parsing not yet implemented", 1)

Process called "parse_import_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "Import module as alias"
    Return create_parse_error("Import statement parsing not yet implemented", 1)

Process called "parse_constant_declaration" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "Constant name as Type is value"
    Return create_parse_error("Constant declaration parsing not yet implemented", 1)

Note: Removed parse_technical_variable_declaration - developer syntax uses bare assignment only

Process called "parse_technical_if_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "if (condition) { body } else { body }"
    Return create_parse_error("Technical if statement parsing not yet implemented", 1)

Process called "parse_technical_for_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "for (init; condition; update) { body }"
    Return create_parse_error("Technical for statement parsing not yet implemented", 1)

Process called "parse_technical_while_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "while (condition) { body }"
    Return create_parse_error("Technical while statement parsing not yet implemented", 1)

Process called "parse_technical_parameter_list" that takes context as ParserContext returns ParameterListResult:
    Note: Parse "(param1: Type, param2: Type)"
    Return ParameterListResult with
        success as false,
        parameters as List[AST.ASTNode](),
        errors as List[String]("Technical parameter list parsing not yet implemented")
    End ParameterListResult

Process called "parse_technical_block" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "{ statements }"
    Return create_parse_error("Technical block parsing not yet implemented", 1)

Process called "parse_technical_assignment" that takes context as ParserContext returns StatementParseResult:
    Note: Parse "target = value" or "target += value"
    Return create_parse_error("Technical assignment parsing not yet implemented", 1)

Process called "parse_expression_statement" that takes context as ParserContext returns StatementParseResult:
    Note: Parse standalone expression as statement
    Return create_parse_error("Expression statement parsing not yet implemented", 1)

Process called "parse_process_body" that takes context as ParserContext returns StatementParseResult:
    Note: Parse process body statements until "End Process"
    Return parse_statement_block(context, "End")