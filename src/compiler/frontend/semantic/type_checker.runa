Note:
compiler/frontend/semantic/type_checker.runa
Type System and Type Checking Engine

This module provides comprehensive type checking functionality including:
- Static type checking for both natural and technical syntax
- Type inference and constraint solving
- Generic type parameter resolution
- Subtyping and type compatibility checking
- Type coercion and conversion validation
- Integration with mathematical symbols and Greek variables
- Performance optimized type checking algorithms
- Comprehensive error reporting with suggestions
:End Note

Import "compiler/frontend/diagnostics/errors" as Errors
Import "compiler/frontend/parsing/expression_parsers" as ExpressionParsers
Import "compiler/frontend/parsing/statement_parsers" as StatementParsers
Import "compiler/frontend/semantic/symbol_table" as SymbolTable
Import "../primitives/core/string_primitive" as StringPrimitive

Note: =====================================================================
Note: TYPE SYSTEM DATA STRUCTURES
Note: =====================================================================

Type called "TypeInfo":
    type_id as String
    type_name as String
    type_kind as String
    base_types as List[String]
    type_parameters as List[String]
    constraints as List[String]
    size_bytes as Integer
    is_primitive as Boolean
    is_generic as Boolean
    is_nullable as Boolean

Type called "TypeConstraint":
    constraint_id as String
    constraint_type as String
    constrained_type as String
    constraint_expression as String
    satisfaction_conditions as List[String]

Type called "TypeContext":
    context_id as String
    current_scope as String
    type_variables as Dictionary[String, TypeInfo]
    active_constraints as List[TypeConstraint]
    inference_stack as List[String]
    substitutions as Dictionary[String, String]

Type called "TypeChecker":
    checker_id as String
    symbol_table as SymbolTable.SymbolTable
    type_context as TypeContext
    builtin_types as Dictionary[String, TypeInfo]
    current_mode as String
    statistics as Dictionary[String, Integer]
    current_function_name as String

Note: =====================================================================
Note: TYPE CHECKER OPERATIONS
Note: =====================================================================

Process called "create_type_checker" that takes checker_name as String, symbol_table as SymbolTable.SymbolTable returns TypeChecker:
    @Implementation
    Creates a new type checker with initialized type context and builtin types.
    Sets up the type checking environment for both natural and technical syntax modes.
    @End Implementation
    
    Note: Create type context
    Let context_id be "context_" + checker_name
    Let type_context be TypeContext with
        context_id as context_id,
        current_scope as "",
        type_variables as Dictionary[String, TypeInfo],
        active_constraints as List[TypeConstraint],
        inference_stack as List[String],
        substitutions as Dictionary[String, String]
    End TypeContext
    
    Note: Create type checker
    Let checker be TypeChecker with
        checker_id as checker_name,
        symbol_table as symbol_table,
        type_context as type_context,
        builtin_types as Dictionary[String, TypeInfo],
        current_mode as "natural",
        statistics as Dictionary[String, Integer],
        current_function_name as ""
    End TypeChecker
    
    Note: Initialize statistics
    Set checker.statistics["expressions_checked"] to 0
    Set checker.statistics["types_inferred"] to 0
    Set checker.statistics["errors_found"] to 0
    Set checker.statistics["constraints_solved"] to 0
    
    Note: Initialize builtin types
    Let initialization_success be initialize_builtin_types(checker)
    If initialization_success equals false:
        Throw Errors.TypeSystemError with "Failed to initialize builtin types"
    End If
    
    Return checker

Process called "initialize_builtin_types" that takes checker as TypeChecker returns Boolean:
    @Implementation
    Initializes all built-in primitive and collection types in the type checker.
    Creates TypeInfo structures for each builtin type with proper metadata.
    @End Implementation
    
    Note: Initialize primitive types
    Let integer_type be TypeInfo with
        type_id as "builtin_integer",
        type_name as "Integer",
        type_kind as "primitive",
        base_types as List[String],
        type_parameters as List[String],
        constraints as List[String],
        size_bytes as 8,
        is_primitive as true,
        is_generic as false,
        is_nullable as false
    End TypeInfo
    Set checker.builtin_types["Integer"] to integer_type
    
    Let float_type be TypeInfo with
        type_id as "builtin_float",
        type_name as "Float",
        type_kind as "primitive",
        base_types as List[String],
        type_parameters as List[String],
        constraints as List[String],
        size_bytes as 8,
        is_primitive as true,
        is_generic as false,
        is_nullable as false
    End TypeInfo
    Set checker.builtin_types["Float"] to float_type
    
    Let string_type be TypeInfo with
        type_id as "builtin_string",
        type_name as "String",
        type_kind as "primitive",
        base_types as List[String],
        type_parameters as List[String],
        constraints as List[String],
        size_bytes as 16,
        is_primitive as true,
        is_generic as false,
        is_nullable as false
    End TypeInfo
    Set checker.builtin_types["String"] to string_type
    
    Let boolean_type be TypeInfo with
        type_id as "builtin_boolean",
        type_name as "Boolean",
        type_kind as "primitive",
        base_types as List[String],
        type_parameters as List[String],
        constraints as List[String],
        size_bytes as 1,
        is_primitive as true,
        is_generic as false,
        is_nullable as false
    End TypeInfo
    Set checker.builtin_types["Boolean"] to boolean_type
    
    Note: Initialize collection types
    Let list_type be TypeInfo with
        type_id as "builtin_list",
        type_name as "List",
        type_kind as "collection",
        base_types as List[String],
        type_parameters as ["T"],
        constraints as List[String],
        size_bytes as 24,
        is_primitive as false,
        is_generic as true,
        is_nullable as false
    End TypeInfo
    Set checker.builtin_types["List"] to list_type
    
    Let dictionary_type be TypeInfo with
        type_id as "builtin_dictionary",
        type_name as "Dictionary",
        type_kind as "collection",
        base_types as List[String],
        type_parameters as ["K", "V"],
        constraints as List[String],
        size_bytes as 32,
        is_primitive as false,
        is_generic as true,
        is_nullable as false
    End TypeInfo
    Set checker.builtin_types["Dictionary"] to dictionary_type
    
    Note: Initialize special types
    Let nothing_type be TypeInfo with
        type_id as "builtin_nothing",
        type_name as "Nothing",
        type_kind as "unit",
        base_types as List[String],
        type_parameters as List[String],
        constraints as List[String],
        size_bytes as 0,
        is_primitive as true,
        is_generic as false,
        is_nullable as false
    End TypeInfo
    Set checker.builtin_types["Nothing"] to nothing_type
    
    Let optional_type be TypeInfo with
        type_id as "builtin_optional",
        type_name as "Optional",
        type_kind as "wrapper",
        base_types as List[String],
        type_parameters as ["T"],
        constraints as List[String],
        size_bytes as 16,
        is_primitive as false,
        is_generic as true,
        is_nullable as true
    End TypeInfo
    Set checker.builtin_types["Optional"] to optional_type
    
    Return true

Process called "register_user_defined_type" that takes checker as TypeChecker, type_info as TypeInfo returns Boolean:
    @Implementation
    Registers a user-defined type in the type system with validation.
    Checks for type conflicts and ensures proper type metadata.
    @End Implementation
    
    Note: Validate type info
    If type_info.type_name equals "":
        Return false
    End If
    
    Note: Check for existing type conflicts
    If checker.builtin_types contains key type_info.type_name:
        Return false
    End If
    
    Note: Validate type parameters if generic
    If type_info.is_generic equals true:
        If type_info.type_parameters.length equals 0:
            Return false
        End If
        
        For Each param in type_info.type_parameters:
            If param equals "":
                Return false
            End If
        End For
    End If
    
    Note: Validate constraints
    For Each constraint in type_info.constraints:
        If constraint equals "":
            Return false
        End If
    End For
    
    Note: Set unique type ID if not provided
    If type_info.type_id equals "":
        Set type_info.type_id to "user_" + type_info.type_name + "_" + get_timestamp_string()
    End If
    
    Note: Register type in builtin types for unified access
    Set checker.builtin_types[type_info.type_name] to type_info
    
    Return true

Note: =====================================================================
Note: TYPE CHECKING OPERATIONS
Note: =====================================================================

Process called "check_expression_type" that takes checker as TypeChecker, expression_ast as String returns TypeInfo:
    @Implementation
    Analyzes expression AST and determines the resulting type through pattern matching.
    Handles literals, variables, operations, function calls, and complex expressions.
    @End Implementation
    
    Note: Increment statistics
    Set checker.statistics["expressions_checked"] to checker.statistics["expressions_checked"] + 1
    
    Note: Handle different expression types
    If expression_ast starts with "literal_integer":
        Return checker.builtin_types["Integer"]
    End If
    
    If expression_ast starts with "literal_float":
        Return checker.builtin_types["Float"]
    End If
    
    If expression_ast starts with "literal_string":
        Return checker.builtin_types["String"]
    End If
    
    If expression_ast starts with "literal_boolean":
        Return checker.builtin_types["Boolean"]
    End If
    
    If expression_ast starts with "variable_reference":
        Let variable_name be extract_variable_name(expression_ast)
        Return lookup_variable_type(checker, variable_name)
    End If
    
    If expression_ast starts with "binary_operation":
        Let operation_info be parse_binary_operation(expression_ast)
        Let left_type be check_expression_type(checker, operation_info["left"])
        Let right_type be check_expression_type(checker, operation_info["right"])
        Let operator be operation_info["operator"]
        Return resolve_binary_operation_type(checker, left_type, right_type, operator)
    End If
    
    If expression_ast starts with "function_call":
        Let call_info be parse_function_call(expression_ast)
        Return check_function_call_type(checker, call_info["name"], call_info["arguments"])
    End If
    
    If expression_ast starts with "list_literal":
        Let elements be parse_list_elements(expression_ast)
        If elements.length equals 0:
            Note: Empty list defaults to List[Nothing]
            Return create_generic_type_instance(checker, "List", ["Nothing"])
        End If
        
        Let element_type be check_expression_type(checker, elements[0])
        For Each element in elements[1:]:
            Let current_type be check_expression_type(checker, element)
            element_type = find_common_type(checker, element_type, current_type)
        End For
        
        Return create_generic_type_instance(checker, "List", [element_type.type_name])
    End If
    
    If expression_ast starts with "dictionary_literal":
        Let pairs be parse_dictionary_pairs(expression_ast)
        If pairs.length equals 0:
            Note: Empty dictionary defaults to Dictionary[String, Nothing]
            Return create_generic_type_instance(checker, "Dictionary", ["String", "Nothing"])
        End If
        
        Let key_type be check_expression_type(checker, pairs[0]["key"])
        Let value_type be check_expression_type(checker, pairs[0]["value"])
        
        For Each pair in pairs[1:]:
            Let current_key_type be check_expression_type(checker, pair["key"])
            Let current_value_type be check_expression_type(checker, pair["value"])
            key_type = find_common_type(checker, key_type, current_key_type)
            value_type = find_common_type(checker, value_type, current_value_type)
        End For
        
        Return create_generic_type_instance(checker, "Dictionary", [key_type.type_name, value_type.type_name])
    End If
    
    Note: Unknown expression type - return error type
    Return create_error_type("UnknownExpressionType")

Process called "check_statement_types" that takes checker as TypeChecker, statement_ast as String returns List[String]:
    @Implementation
    Analyzes statement AST for type consistency and returns any type errors found.
    Handles variable declarations, assignments, control flow, and function definitions.
    @End Implementation
    
    Let errors be List[String]
    
    If statement_ast starts with "variable_declaration":
        Let declaration_info be parse_variable_declaration(statement_ast)
        Let declared_type_name be declaration_info["type"]
        Let initializer_expr be declaration_info["initializer"]
        
        If initializer_expr not equals "":
            Let inferred_type be check_expression_type(checker, initializer_expr)
            If declared_type_name not equals "":
                Let declared_type be get_type_info(checker, declared_type_name)
                If not are_types_compatible(checker, inferred_type, declared_type):
                    List.add(errors, "Type mismatch: Cannot assign " + inferred_type.type_name + " to " + declared_type.type_name)
                End If
            End If
        End If
    End If
    
    If statement_ast starts with "assignment":
        Let assignment_info be parse_assignment(statement_ast)
        Let variable_name be assignment_info["variable"]
        Let value_expr be assignment_info["value"]
        
        Let variable_type be lookup_variable_type(checker, variable_name)
        Let value_type be check_expression_type(checker, value_expr)
        
        If not are_types_compatible(checker, value_type, variable_type):
            List.add(errors, "Type mismatch in assignment: Cannot assign " + value_type.type_name + " to " + variable_type.type_name)
        End If
    End If
    
    If statement_ast starts with "if_statement":
        Let if_info be parse_if_statement(statement_ast)
        Let condition_type be check_expression_type(checker, if_info["condition"])
        
        If not are_types_compatible(checker, condition_type, checker.builtin_types["Boolean"]):
            List.add(errors, "If condition must be Boolean, found " + condition_type.type_name)
        End If
        
        Let then_errors be check_statement_types(checker, if_info["then_body"])
        List.extend(errors, then_errors)
        
        If if_info contains key "else_body":
            Let else_errors be check_statement_types(checker, if_info["else_body"])
            List.extend(errors, else_errors)
        End If
    End If
    
    If statement_ast starts with "while_statement":
        Let while_info be parse_while_statement(statement_ast)
        Let condition_type be check_expression_type(checker, while_info["condition"])
        
        If not are_types_compatible(checker, condition_type, checker.builtin_types["Boolean"]):
            List.add(errors, "While condition must be Boolean, found " + condition_type.type_name)
        End If
        
        Let body_errors be check_statement_types(checker, while_info["body"])
        List.extend(errors, body_errors)
    End If
    
    If statement_ast starts with "return_statement":
        Let return_info be parse_return_statement(statement_ast)
        If return_info contains key "value":
            Let return_type be check_expression_type(checker, return_info["value"])
            Note: Check return type compatibility
            Let function_sig be get_function_signature_from_symbol_table(checker, checker.current_function_name)
            Let expected_return_type be extract_return_type(function_sig)
            Let actual_return_type be check_expression_type(checker, return_expr_ast)
            
            If not check_type_compatibility(checker, actual_return_type, get_type_info(checker, expected_return_type)):
                List.add(errors, "Return type mismatch: expected " + expected_return_type + " but got " + actual_return_type.type_name)
            End If
        End If
    End If
    
    Return errors

Process called "check_function_signature" that takes checker as TypeChecker, function_ast as String returns List[String]:
    @Implementation
    Validates function signature for parameter and return type consistency.
    Checks parameter type annotations and return type compatibility.
    @End Implementation
    
    Let errors be List[String]
    Let function_info be parse_function_signature(function_ast)
    
    Note: Check parameter types
    For Each param in function_info["parameters"]:
        Let param_type_name be param["type"]
        If param_type_name not equals "":
            If not checker.builtin_types contains key param_type_name:
                List.add(errors, "Unknown parameter type: " + param_type_name)
            End If
        End If
    End For
    
    Note: Check return type
    Let return_type_name be function_info["return_type"]
    If return_type_name not equals "":
        If not checker.builtin_types contains key return_type_name:
            List.add(errors, "Unknown return type: " + return_type_name)
        End If
    End If
    
    Note: Check for duplicate parameter names
    Let param_names be List[String]
    For Each param in function_info["parameters"]:
        If param_names contains param["name"]:
            List.add(errors, "Duplicate parameter name: " + param["name"])
        End If
        List.add(param_names, param["name"])
    End For
    
    Return errors

Process called "check_variable_declaration" that takes checker as TypeChecker, declaration_ast as String returns List[String]:
    @Implementation
    Validates variable declaration for type consistency between annotation and initializer.
    Handles both explicit type annotations and type inference scenarios.
    @End Implementation
    
    Let errors be List[String]
    Let declaration_info be parse_variable_declaration(declaration_ast)
    
    Let variable_name be declaration_info["name"]
    Let declared_type_name be declaration_info["type"]
    Let initializer_expr be declaration_info["initializer"]
    
    Note: Validate variable name
    If variable_name equals "":
        List.add(errors, "Variable name cannot be empty")
        Return errors
    End If
    
    Note: Check declared type exists if specified
    If declared_type_name not equals "":
        If not checker.builtin_types contains key declared_type_name:
            List.add(errors, "Unknown type: " + declared_type_name)
        End If
    End If
    
    Note: Check initializer if present
    If initializer_expr not equals "":
        Let inferred_type be check_expression_type(checker, initializer_expr)
        
        If inferred_type.type_name equals "UnknownExpressionType":
            List.add(errors, "Cannot determine type of initializer expression")
        End If
        
        Note: Check type compatibility if both declared and inferred
        If declared_type_name not equals "" and inferred_type.type_name not equals "UnknownExpressionType":
            Let declared_type be checker.builtin_types[declared_type_name]
            If not are_types_compatible(checker, inferred_type, declared_type):
                List.add(errors, "Type mismatch: Cannot initialize " + declared_type_name + " with " + inferred_type.type_name)
            End If
        End If
    Otherwise:
        Note: No initializer - must have explicit type
        If declared_type_name equals "":
            List.add(errors, "Variable declaration must have either type annotation or initializer")
        End If
    End If
    
    Return errors

Note: =====================================================================
Note: TYPE INFERENCE OPERATIONS
Note: =====================================================================

Process called "infer_expression_type" that takes checker as TypeChecker, expression_ast as String returns TypeInfo:
    @Implementation
    Infers the type of expressions using pattern matching and context analysis.
    Same as check_expression_type but focused on inference rather than validation.
    @End Implementation
    
    Note: Increment statistics
    Set checker.statistics["types_inferred"] to checker.statistics["types_inferred"] + 1
    
    Note: Delegate to expression type checking (same logic)
    Return check_expression_type(checker, expression_ast)

Process called "infer_variable_type" that takes checker as TypeChecker, variable_name as String, initializer_expr as String returns TypeInfo:
    @Implementation
    Infers variable type from its initializer expression.
    Returns the most specific type that can be determined from the initializer.
    @End Implementation
    
    If initializer_expr equals "":
        Return create_error_type("NoInitializerForInference")
    End If
    
    Let inferred_type be check_expression_type(checker, initializer_expr)
    
    Note: Handle error cases
    If inferred_type.type_name equals "UnknownExpressionType":
        Return create_error_type("CannotInferFromExpression")
    End If
    
    Note: Store inferred type in context for future reference
    Set checker.type_context.type_variables[variable_name] to inferred_type
    
    Return inferred_type

Process called "infer_function_return_type" that takes checker as TypeChecker, function_body_ast as String returns TypeInfo:
    @Implementation
    Analyzes function body to infer the return type from all return statements.
    Finds the common type that unifies all possible return values.
    @End Implementation
    
    Let return_statements be extract_return_statements(function_body_ast)
    
    If return_statements.length equals 0:
        Return checker.builtin_types["Nothing"]
    End If
    
    Note: Check first return statement
    Let first_return_expr be return_statements[0]
    If first_return_expr equals "":
        Note: Empty return statement
        Let unified_type be checker.builtin_types["Nothing"]
    Otherwise:
        Let unified_type be check_expression_type(checker, first_return_expr)
    End If
    
    Note: Unify with remaining return statements
    For Each return_expr in return_statements[1:]:
        If return_expr equals "":
            Let current_type be checker.builtin_types["Nothing"]
        Otherwise:
            Let current_type be check_expression_type(checker, return_expr)
        End If
        
        unified_type = find_common_type(checker, unified_type, current_type)
    End For
    
    Return unified_type

Note: =====================================================================
Note: TYPE UNIFICATION AND CONSTRAINTS
Note: =====================================================================

Process called "unify_types" that takes checker as TypeChecker, type1 as TypeInfo, type2 as TypeInfo returns TypeInfo:
    @Implementation
    Unifies two types and finds the most general unifier.
    Returns the unified type or an error type if unification fails.
    @End Implementation
    
    Note: Identical types unify to themselves
    If type1.type_name equals type2.type_name:
        Return type1
    End If
    
    Note: Nothing can unify with any type (bottom type)
    If type1.type_name equals "Nothing":
        Return type2
    End If
    If type2.type_name equals "Nothing":
        Return type1
    End If
    
    Note: Numeric type unification
    If type1.type_name equals "Integer" and type2.type_name equals "Float":
        Return checker.builtin_types["Float"]
    End If
    If type1.type_name equals "Float" and type2.type_name equals "Integer":
        Return checker.builtin_types["Float"]
    End If
    
    Note: Generic type unification
    If type1.is_generic equals true and type2.is_generic equals true:
        If type1.type_name equals type2.type_name:
            Note: Same generic type - unify type parameters
            If type1.type_parameters.length equals type2.type_parameters.length:
                Note: Unify generic type parameters
                Let unified_params be List[String]
                For i from 0 to (type1.type_parameters.length - 1):
                    Let param1 be type1.type_parameters[i]
                    Let param2 be type2.type_parameters[i]
                    Note: For identical type parameters, use the first one
                    List.add(unified_params, param1)
                End For
                
                Return TypeInfo with
                    type_id as type1.type_id,
                    type_name as type1.type_name,
                    type_kind as type1.type_kind,
                    base_types as type1.base_types,
                    type_parameters as unified_params,
                    constraints as type1.constraints,
                    size_bytes as type1.size_bytes,
                    is_primitive as type1.is_primitive,
                    is_generic as type1.is_generic,
                    is_nullable as type1.is_nullable
                End TypeInfo
            End If
        End If
    End If
    
    Note: Subtype relationships
    If is_subtype(checker, type1, type2):
        Return type2
    End If
    If is_subtype(checker, type2, type1):
        Return type1
    End If
    
    Note: Types cannot be unified
    Return create_error_type("UnificationFailure")

Process called "generate_type_constraints" that takes checker as TypeChecker, expression_ast as String returns List[TypeConstraint]:
    @Implementation
    Generates type constraints from expression AST for constraint-based type inference.
    Creates constraints that must be satisfied for the expression to be well-typed.
    @End Implementation
    
    Let constraints be List[TypeConstraint]
    
    If expression_ast starts with "binary_operation":
        Let operation_info be parse_binary_operation(expression_ast)
        Let operator be operation_info["operator"]
        
        Note: Arithmetic operations require numeric types
        If operator equals "+" or operator equals "-" or operator equals "*" or operator equals "/":
            Let constraint1 be TypeConstraint with
                constraint_id as "arithmetic_left_" + get_timestamp_string(),
                constraint_type as "numeric",
                constrained_type as operation_info["left"],
                constraint_expression as "must be Integer or Float",
                satisfaction_conditions as ["Integer", "Float"]
            End TypeConstraint
            List.add(constraints, constraint1)
            
            Let constraint2 be TypeConstraint with
                constraint_id as "arithmetic_right_" + get_timestamp_string(),
                constraint_type as "numeric",
                constrained_type as operation_info["right"],
                constraint_expression as "must be Integer or Float",
                satisfaction_conditions as ["Integer", "Float"]
            End TypeConstraint
            List.add(constraints, constraint2)
        End If
        
        Note: Comparison operations
        If operator equals "<" or operator equals ">" or operator equals "<=" or operator equals ">=":
            Let constraint1 be TypeConstraint with
                constraint_id as "comparison_left_" + get_timestamp_string(),
                constraint_type as "comparable",
                constrained_type as operation_info["left"],
                constraint_expression as "must be comparable",
                satisfaction_conditions as ["Integer", "Float", "String"]
            End TypeConstraint
            List.add(constraints, constraint1)
            
            Let constraint2 be TypeConstraint with
                constraint_id as "comparison_right_" + get_timestamp_string(),
                constraint_type as "comparable",
                constrained_type as operation_info["right"],
                constraint_expression as "must be comparable",
                satisfaction_conditions as ["Integer", "Float", "String"]
            End TypeConstraint
            List.add(constraints, constraint2)
        End If
    End If
    
    If expression_ast starts with "function_call":
        Let call_info be parse_function_call(expression_ast)
        Note: Generate constraints for function arguments matching parameters
        For i from 0 to (call_info["arguments"].length - 1):
            Let constraint be TypeConstraint with
                constraint_id as "function_arg_" + integer_to_string(i) + "_" + get_timestamp_string(),
                constraint_type as "parameter_match",
                constrained_type as call_info["arguments"][i],
                constraint_expression as "must match parameter type",
                satisfaction_conditions as List[String]
            End TypeConstraint
            List.add(constraints, constraint)
        End For
    End If
    
    Return constraints

Process called "solve_type_constraints" that takes checker as TypeChecker, constraints as List[TypeConstraint] returns Dictionary[String, TypeInfo]:
    @Implementation
    Solves type constraints using unification algorithm.
    Returns a substitution mapping from type variables to concrete types.
    @End Implementation
    
    Let substitutions be Dictionary[String, TypeInfo]
    Set checker.statistics["constraints_solved"] to checker.statistics["constraints_solved"] + constraints.length
    
    For Each constraint in constraints:
        If constraint.constraint_type equals "numeric":
            Note: Check if constrained type can be numeric
            Let constrained_expr_type be check_expression_type(checker, constraint.constrained_type)
            If constrained_expr_type.type_name equals "Integer" or constrained_expr_type.type_name equals "Float":
                Set substitutions[constraint.constrained_type] to constrained_expr_type
            Otherwise:
                Note: Generate constraint violation error
                Let error_msg be "Type constraint violation: " + constraint.constrained_type + " must be numeric but found " + constrained_expr_type.type_name
                Throw Errors.create_type_error(error_msg)
                Set substitutions[constraint.constrained_type] to create_error_type("NumericConstraintViolation")
            End If
        End If
        
        If constraint.constraint_type equals "comparable":
            Let constrained_expr_type be check_expression_type(checker, constraint.constrained_type)
            If constraint.satisfaction_conditions contains constrained_expr_type.type_name:
                Set substitutions[constraint.constrained_type] to constrained_expr_type
            Otherwise:
                Set substitutions[constraint.constrained_type] to create_error_type("ComparableConstraintViolation")
            End If
        End If
        
        If constraint.constraint_type equals "parameter_match":
            Note: Get function signature and check parameter compatibility
            Let function_sig be get_function_signature_from_symbol_table(checker, constraint.constraint_expression)
            Let parameter_types be extract_parameter_types(function_sig)
            Let expr_type be check_expression_type(checker, constraint.constrained_type)
            
            Note: Verify parameter type matches expected type
            Let parameter_index be extract_parameter_index(constraint.constraint_id)
            If parameter_index < parameter_types.length:
                Let expected_type be parameter_types[parameter_index]
                Let expected_type_info be get_type_info(checker, expected_type)
                If check_type_compatibility(checker, expr_type, expected_type_info):
                    Set substitutions[constraint.constrained_type] to expr_type
                Otherwise:
                    Set substitutions[constraint.constrained_type] to create_error_type("ParameterTypeMismatch")
                End If
            Otherwise:
                Set substitutions[constraint.constrained_type] to create_error_type("InvalidParameterIndex")
            End If
            Let expr_type be check_expression_type(checker, constraint.constrained_type)
            Set substitutions[constraint.constrained_type] to expr_type
        End If
    End For
    
    Return substitutions

Note: =====================================================================
Note: SUBTYPING AND COMPATIBILITY
Note: =====================================================================

Process called "is_subtype" that takes checker as TypeChecker, subtype as TypeInfo, supertype as TypeInfo returns Boolean:
    @Implementation
    Checks if subtype is a subtype of supertype according to Runa's type hierarchy.
    Handles primitive type coercion and structural subtyping rules.
    @End Implementation
    
    Note: Every type is a subtype of itself
    If subtype.type_name equals supertype.type_name:
        Return true
    End If
    
    Note: Nothing is a subtype of all types (bottom type)
    If subtype.type_name equals "Nothing":
        Return true
    End If
    
    Note: Numeric subtyping: Integer is subtype of Float
    If subtype.type_name equals "Integer" and supertype.type_name equals "Float":
        Return true
    End If
    
    Note: Generic type subtyping (covariant for collections)
    If subtype.is_generic equals true and supertype.is_generic equals true:
        If subtype.type_name equals supertype.type_name:
            Note: Same generic type - check parameter variance
            If subtype.type_name equals "List":
                Note: List is covariant in its element type
                If subtype.type_parameters.length equals 1 and supertype.type_parameters.length equals 1:
                    Let sub_element_type be get_type_info(checker, subtype.type_parameters[0])
                    Let super_element_type be get_type_info(checker, supertype.type_parameters[0])
                    Return is_subtype(checker, sub_element_type, super_element_type)
                End If
            End If
        End If
    End If
    
    Note: Check explicit subtype relationships from base_types
    For Each base_type_name in subtype.base_types:
        If base_type_name equals supertype.type_name:
            Return true
        End If
        Note: Recursive check for transitive subtyping
        Let base_type be get_type_info(checker, base_type_name)
        If is_subtype(checker, base_type, supertype):
            Return true
        End If
    End For
    
    Return false

Process called "find_common_supertype" that takes checker as TypeChecker, types as List[TypeInfo] returns TypeInfo:
    @Implementation
    Finds the most specific common supertype of multiple types.
    Used for unifying types in conditional expressions and collections.
    @End Implementation
    
    If types.length equals 0:
        Return checker.builtin_types["Nothing"]
    End If
    
    If types.length equals 1:
        Return types[0]
    End If
    
    Note: Start with first type as candidate
    Let common_type be types[0]
    
    Note: Find common type with each remaining type
    For Each type in types[1:]:
        common_type = find_common_type(checker, common_type, type)
    End For
    
    Return common_type

Process called "check_type_compatibility" that takes checker as TypeChecker, type1 as TypeInfo, type2 as TypeInfo returns Boolean:
    @Implementation
    Checks if two types are compatible for operations like assignment or parameter passing.
    More permissive than exact type equality, allows safe conversions.
    @End Implementation
    
    Note: Same types are always compatible
    If type1.type_name equals type2.type_name:
        Return true
    End If
    
    Note: Check subtype relationships
    If is_subtype(checker, type1, type2) or is_subtype(checker, type2, type1):
        Return true
    End If
    
    Note: Numeric compatibility
    If (type1.type_name equals "Integer" or type1.type_name equals "Float") and (type2.type_name equals "Integer" or type2.type_name equals "Float"):
        Return true
    End If
    
    Note: Nothing is compatible with all types
    If type1.type_name equals "Nothing" or type2.type_name equals "Nothing":
        Return true
    End If
    
    Return false

Process called "can_convert_type" that takes checker as TypeChecker, from_type as TypeInfo, to_type as TypeInfo returns Boolean:
    @Implementation
    Checks if a type can be converted to another type through implicit or explicit conversion.
    Handles safe numeric conversions and type coercion rules.
    @End Implementation
    
    Note: Same types can always be converted
    If from_type.type_name equals to_type.type_name:
        Return true
    End If
    
    Note: Nothing can be converted to any type
    If from_type.type_name equals "Nothing":
        Return true
    End If
    
    Note: Numeric conversions
    If from_type.type_name equals "Integer" and to_type.type_name equals "Float":
        Return true  Note: Safe widening conversion
    End If
    If from_type.type_name equals "Float" and to_type.type_name equals "Integer":
        Return true  Note: Explicit narrowing conversion (may lose precision)
    End If
    
    Note: String conversions (most types can convert to String)
    If to_type.type_name equals "String":
        If from_type.type_name equals "Integer" or from_type.type_name equals "Float" or from_type.type_name equals "Boolean":
            Return true
        End If
    End If
    
    Note: Boolean conversions
    If to_type.type_name equals "Boolean":
        Note: Most types have truthiness conversion
        Return true
    End If
    
    Note: Subtype relationships allow conversion
    If is_subtype(checker, from_type, to_type):
        Return true
    End If
    
    Return false

Note: =====================================================================
Note: GENERIC TYPE OPERATIONS
Note: =====================================================================

Process called "resolve_generic_parameters" that takes checker as TypeChecker, generic_type as TypeInfo, type_arguments as List[TypeInfo] returns TypeInfo:
    @Implementation
    Resolves a generic type by substituting concrete type arguments for type parameters.
    Creates a specialized instance of the generic type.
    @End Implementation
    
    Note: Validate argument count matches parameter count
    If type_arguments.length not equals generic_type.type_parameters.length:
        Return create_error_type("GenericArityMismatch")
    End If
    
    Note: Create specialized type instance
    Let specialized_type be TypeInfo with
        type_id as generic_type.type_id + "_specialized_" + get_timestamp_string(),
        type_name as generic_type.type_name,
        type_kind as generic_type.type_kind,
        base_types as generic_type.base_types,
        type_parameters as List[String],
        constraints as List[String],
        size_bytes as generic_type.size_bytes,
        is_primitive as false,
        is_generic as false,
        is_nullable as generic_type.is_nullable
    End TypeInfo
    
    Note: Store type argument mapping for substitution
    For i from 0 to (type_arguments.length - 1):
        Let param_name be generic_type.type_parameters[i]
        Let arg_type be type_arguments[i]
        Note: Apply substitutions to all type parameters in the generic type
        For Each type_param in generic_type.type_parameters:
            For i from 0 to (type_arguments.length - 1):
                If type_param equals generic_type.type_parameters[i]:
                    Note: Found matching parameter - apply substitution
                    Set specialized_type.constraints to substitute_in_constraints(specialized_type.constraints, type_param, type_arguments[i].type_name)
                End If
            End For
        End For
        List.add(specialized_type.type_parameters, arg_type.type_name)
    End For
    
    Return specialized_type

Process called "check_generic_constraints" that takes checker as TypeChecker, type_parameter as String, constraints as List[TypeConstraint] returns Boolean:
    @Implementation
    Checks if a type parameter satisfies all its generic constraints.
    Validates trait bounds and type requirements for generic instantiation.
    @End Implementation
    
    Note: No constraints means no restrictions
    If constraints.length equals 0:
        Return true
    End If
    
    Note: Get the concrete type for the parameter
    If not checker.type_context.type_variables contains key type_parameter:
        Return false  Note: Type parameter not bound
    End If
    
    Let concrete_type be checker.type_context.type_variables[type_parameter]
    
    Note: Check each constraint
    For Each constraint in constraints:
        If constraint.constraint_type equals "numeric":
            If not (concrete_type.type_name equals "Integer" or concrete_type.type_name equals "Float"):
                Return false
            End If
        End If
        
        If constraint.constraint_type equals "comparable":
            If not constraint.satisfaction_conditions contains concrete_type.type_name:
                Return false
            End If
        End If
        
        If constraint.constraint_type equals "trait":
            Note: Check trait implementation constraints
            Let trait_name be extract_trait_name(constraint.constraint_expression)
            Let type_implements_trait be check_trait_implementation(checker, concrete_type, trait_name)
            If not type_implements_trait:
                Return false
            End If
        End If
    End For
    
    Return true

Process called "instantiate_generic_function" that takes checker as TypeChecker, function_signature as String, type_arguments as List[TypeInfo] returns String:
    @Implementation
    Creates a specialized instance of a generic function by substituting concrete types.
    Returns the instantiated function signature with type parameters resolved.
    @End Implementation
    
    Let signature_parts be parse_function_signature(function_signature)
    Let function_name be signature_parts["name"]
    Let parameters be signature_parts["parameters"]
    Let return_type_name be signature_parts["return_type"]
    
    Note: Create specialized function name
    Let specialized_name be function_name + "_specialized"
    For Each type_arg in type_arguments:
        Set specialized_name to specialized_name + "_" + type_arg.type_name
    End For
    
    Note: Substitute type parameters in parameters
    Let specialized_params be List[String]
    For Each param in parameters:
        Let param_type be param["type"]
        Note: Perform type parameter substitution in parameter type
        Let original_param_type be param["type"]
        Let substituted_param_type be substitute_type_parameters(original_param_type, type_arguments)
        Set param["type"] to substituted_param_type
        Let specialized_param be param["name"] + " as " + param_type
        List.add(specialized_params, specialized_param)
    End For
    
    Note: Build specialized signature
    Let specialized_signature be "Process called \"" + specialized_name + "\" that takes "
    For i from 0 to (specialized_params.length - 1):
        Set specialized_signature to specialized_signature + specialized_params[i]
        If i < (specialized_params.length - 1):
            Set specialized_signature to specialized_signature + ", "
        End If
    End For
    Set specialized_signature to specialized_signature + " returns " + return_type_name
    
    Return specialized_signature

Process called "infer_generic_arguments" that takes checker as TypeChecker, generic_call as String, argument_types as List[TypeInfo] returns List[TypeInfo]:
    @Implementation
    Infers generic type arguments from function call by analyzing argument types.
    Uses unification to determine the most specific type arguments.
    @End Implementation
    
    Let call_info be parse_function_call(generic_call)
    Let function_name be call_info["name"]
    
    Note: Look up generic function signature
    Note: Get function signature from symbol table
    Let function_signature be get_function_signature_from_symbol_table(checker, function_name)
    If function_signature equals "":
        Note: Function not found - return empty list
        Return List[TypeInfo]
    End If
    
    Note: Simple type argument inference based on argument types
    Let inferred_types be List[TypeInfo]
    
    Note: For each argument, infer the most general type needed
    For Each arg_type in argument_types:
        If arg_type.type_name equals "Integer" or arg_type.type_name equals "Float":
            Note: Numeric arguments suggest numeric type parameter
            List.add(inferred_types, checker.builtin_types["Float"])  Note: Use most general numeric type
        Otherwise:
            Note: Non-numeric arguments keep their specific type
            List.add(inferred_types, arg_type)
        End If
    End For
    
    Return inferred_types

Note: =====================================================================
Note: MATHEMATICAL TYPE CHECKING
Note: =====================================================================

Process called "check_mathematical_expression_type" that takes checker as TypeChecker, math_expr as String returns TypeInfo:
    @Implementation
    Checks types of mathematical expressions including Greek symbols and mathematical operators.
    Handles mathematical notation like α, β, Σ, ∫, derivatives, and complex mathematical constructs.
    @End Implementation
    
    Note: Check for Greek variable references
    If math_expr contains "α" or math_expr contains "β" or math_expr contains "γ":
        Let greek_type be infer_greek_variable_type(checker, math_expr)
        If greek_type.type_name not equals "UnknownExpressionType":
            Return greek_type
        End If
    End If
    
    Note: Check for summation expressions
    If math_expr contains "Σ" or math_expr contains "sum(":
        Return check_summation_type(checker, math_expr)
    End If
    
    Note: Check for integral expressions
    If math_expr contains "∫" or math_expr contains "integral(":
        Return check_integral_type(checker, math_expr)
    End If
    
    Note: Check for mathematical functions
    If math_expr contains "sin(" or math_expr contains "cos(" or math_expr contains "tan(":
        Return checker.builtin_types["Float"]  Note: Trigonometric functions return Float
    End If
    
    If math_expr contains "log(" or math_expr contains "exp(" or math_expr contains "sqrt(":
        Return checker.builtin_types["Float"]  Note: Mathematical functions return Float
    End If
    
    Note: Check for derivatives
    If math_expr contains "d/dx" or math_expr contains "∂/∂":
        Return checker.builtin_types["Float"]  Note: Derivatives are typically Float-valued
    End If
    
    Note: Default to standard expression checking
    Return check_expression_type(checker, math_expr)

Process called "infer_greek_variable_type" that takes checker as TypeChecker, greek_symbol as String returns TypeInfo:
    @Implementation
    Infers types for Greek mathematical variables based on mathematical context and conventions.
    Uses mathematical conventions to determine appropriate types for Greek symbols.
    @End Implementation
    
    Note: Common Greek variables and their conventional types
    If greek_symbol contains "α" or greek_symbol contains "alpha":
        Note: Alpha often represents angles, coefficients, or scalars
        Return checker.builtin_types["Float"]
    End If
    
    If greek_symbol contains "β" or greek_symbol contains "beta":
        Note: Beta often represents parameters or coefficients
        Return checker.builtin_types["Float"]
    End If
    
    If greek_symbol contains "γ" or greek_symbol contains "gamma":
        Note: Gamma often represents parameters or Euler-Mascheroni constant
        Return checker.builtin_types["Float"]
    End If
    
    If greek_symbol contains "θ" or greek_symbol contains "theta":
        Note: Theta represents angles
        Return checker.builtin_types["Float"]
    End If
    
    If greek_symbol contains "λ" or greek_symbol contains "lambda":
        Note: Lambda represents eigenvalues, wavelengths, or parameters
        Return checker.builtin_types["Float"]
    End If
    
    If greek_symbol contains "μ" or greek_symbol contains "mu":
        Note: Mu represents mean, friction coefficient, or parameters
        Return checker.builtin_types["Float"]
    End If
    
    If greek_symbol contains "π" or greek_symbol contains "pi":
        Note: Pi is a mathematical constant
        Return checker.builtin_types["Float"]
    End If
    
    If greek_symbol contains "σ" or greek_symbol contains "sigma":
        Note: Sigma represents standard deviation or summation index
        Return checker.builtin_types["Float"]
    End If
    
    Note: Default for unknown Greek symbols
    Return checker.builtin_types["Float"]

Process called "check_summation_type" that takes checker as TypeChecker, summation_expr as String returns TypeInfo:
    @Implementation
    Checks types in summation expressions including bounds, index variables, and summand expressions.
    Validates that summation components are properly typed for mathematical correctness.
    @End Implementation
    
    Note: Parse summation components
    Let summation_parts be parse_summation_expression(summation_expr)
    
    Note: Check index variable type (usually Integer)
    Let index_var be summation_parts["index_variable"]
    If index_var not equals "":
        Note: Index variables in summations are typically Integer
        Set checker.type_context.type_variables[index_var] to checker.builtin_types["Integer"]
    End If
    
    Note: Check lower bound type
    Let lower_bound be summation_parts["lower_bound"]
    If lower_bound not equals "":
        Let lower_type be check_expression_type(checker, lower_bound)
        If not are_types_compatible(checker, lower_type, checker.builtin_types["Integer"]):
            Return create_error_type("SummationLowerBoundMustBeInteger")
        End If
    End If
    
    Note: Check upper bound type
    Let upper_bound be summation_parts["upper_bound"]
    If upper_bound not equals "":
        Let upper_type be check_expression_type(checker, upper_bound)
        If not are_types_compatible(checker, upper_type, checker.builtin_types["Integer"]):
            Return create_error_type("SummationUpperBoundMustBeInteger")
        End If
    End If
    
    Note: Check summand expression type
    Let summand_expr be summation_parts["summand"]
    If summand_expr not equals "":
        Let summand_type be check_expression_type(checker, summand_expr)
        
        Note: Summation result type depends on summand type
        If summand_type.type_name equals "Integer":
            Return checker.builtin_types["Integer"]
        End If
        If summand_type.type_name equals "Float":
            Return checker.builtin_types["Float"]
        End If
        
        Note: For other numeric types, default to Float
        Return checker.builtin_types["Float"]
    End If
    
    Note: Default summation type
    Return checker.builtin_types["Float"]

Process called "check_integral_type" that takes checker as TypeChecker, integral_expr as String returns TypeInfo:
    @Implementation
    Checks types in integral expressions including bounds, integration variable, and integrand.
    Validates mathematical correctness of integral components and determines result type.
    @End Implementation
    
    Note: Parse integral components
    Let integral_parts be parse_integral_expression(integral_expr)
    
    Note: Check integration variable type (usually Float for continuous integration)
    Let integration_var be integral_parts["integration_variable"]
    If integration_var not equals "":
        Note: Integration variables are typically continuous (Float)
        Set checker.type_context.type_variables[integration_var] to checker.builtin_types["Float"]
    End If
    
    Note: Check lower bound type
    Let lower_bound be integral_parts["lower_bound"]
    If lower_bound not equals "":
        Let lower_type be check_expression_type(checker, lower_bound)
        If not (lower_type.type_name equals "Integer" or lower_type.type_name equals "Float"):
            Return create_error_type("IntegralLowerBoundMustBeNumeric")
        End If
    End If
    
    Note: Check upper bound type
    Let upper_bound be integral_parts["upper_bound"]
    If upper_bound not equals "":
        Let upper_type be check_expression_type(checker, upper_bound)
        If not (upper_type.type_name equals "Integer" or upper_type.type_name equals "Float"):
            Return create_error_type("IntegralUpperBoundMustBeNumeric")
        End If
    End If
    
    Note: Check integrand expression type
    Let integrand_expr be integral_parts["integrand"]
    If integrand_expr not equals "":
        Let integrand_type be check_expression_type(checker, integrand_expr)
        If not (integrand_type.type_name equals "Integer" or integrand_type.type_name equals "Float"):
            Return create_error_type("IntegrandMustBeNumeric")
        End If
    End If
    
    Note: Integrals always result in Float type (continuous mathematics)
    Return checker.builtin_types["Float"]

Note: =====================================================================
Note: NATURAL LANGUAGE TYPE CHECKING
Note: =====================================================================

Process called "check_natural_language_type" that takes checker as TypeChecker, nl_expr as String returns TypeInfo:
    @Implementation
    Checks types in natural language expressions using pattern matching for Runa's natural syntax.
    Handles "Let X be Y" constructs and other natural language patterns.
    @End Implementation
    
    Note: Handle "Let X be Y" patterns
    If nl_expr contains "Let " and nl_expr contains " be ":
        Let let_parts be parse_let_statement(nl_expr)
        Let value_expr be let_parts["value"]
        Return check_expression_type(checker, value_expr)
    End If
    
    Note: Handle "Set X to Y" patterns
    If nl_expr contains "Set " and nl_expr contains " to ":
        Let set_parts be parse_set_statement(nl_expr)
        Let value_expr be set_parts["value"]
        Return check_expression_type(checker, value_expr)
    End If
    
    Note: Handle natural comparisons
    If nl_expr contains " equals " or nl_expr contains " is ":
        Return checker.builtin_types["Boolean"]
    End If
    
    Note: Default to standard expression checking
    Return check_expression_type(checker, nl_expr)

Process called "infer_type_from_natural_pattern" that takes checker as TypeChecker, pattern as String returns TypeInfo:
    @Implementation
    Infers types from natural language patterns by analyzing context and keywords.
    @End Implementation
    
    Return check_natural_language_type(checker, pattern)

Process called "check_natural_let_statement_type" that takes checker as TypeChecker, statement as String returns List[String]:
    @Implementation
    Validates types in natural language Let statements.
    @End Implementation
    
    Let errors be List[String]
    Let let_parts be parse_let_statement(statement)
    Let variable_name be let_parts["variable"]
    Let value_expr be let_parts["value"]
    
    If value_expr not equals "":
        Let inferred_type be check_expression_type(checker, value_expr)
        Set checker.type_context.type_variables[variable_name] to inferred_type
    End If
    
    Return errors

Process called "check_natural_assignment_type" that takes checker as TypeChecker, assignment as String returns List[String]:
    @Implementation
    Validates types in natural language assignment statements.
    @End Implementation
    
    Let errors be List[String]
    Let assignment_parts be parse_assignment(assignment)
    Let variable_name be assignment_parts["variable"]
    Let value_expr be assignment_parts["value"]
    
    Let variable_type be lookup_variable_type(checker, variable_name)
    Let value_type be check_expression_type(checker, value_expr)
    
    If not are_types_compatible(checker, value_type, variable_type):
        List.add(errors, "Type mismatch in assignment")
    End If
    
    Return errors

Note: =====================================================================
Note: TECHNICAL SYNTAX TYPE CHECKING
Note: =====================================================================

Process called "check_technical_expression_type" that takes checker as TypeChecker, tech_expr as String returns TypeInfo:
    @Implementation
    Checks types in technical syntax expressions (C-style syntax).
    @End Implementation
    
    Note: Technical syntax uses same logic as standard expressions
    Return check_expression_type(checker, tech_expr)

Process called "check_technical_function_call" that takes checker as TypeChecker, call_expr as String returns TypeInfo:
    @Implementation
    Checks types in technical function calls (C-style syntax).
    @End Implementation
    
    Return check_expression_type(checker, call_expr)

Process called "check_technical_variable_access" that takes checker as TypeChecker, access_expr as String returns TypeInfo:
    @Implementation
    Checks types in technical variable access (C-style syntax).
    @End Implementation
    
    Return check_expression_type(checker, access_expr)

Note: =====================================================================
Note: TYPE COERCION AND CONVERSION
Note: =====================================================================

Process called "apply_implicit_conversion" that takes checker as TypeChecker, from_type as TypeInfo, to_type as TypeInfo returns Boolean:
    @Implementation
    Applies implicit type conversions if they are safe and valid.
    @End Implementation
    
    Return can_convert_type(checker, from_type, to_type)

Process called "check_explicit_conversion" that takes checker as TypeChecker, from_type as TypeInfo, to_type as TypeInfo returns Boolean:
    @Implementation
    Checks if explicit conversion between types is valid and safe.
    @End Implementation
    
    Return can_convert_type(checker, from_type, to_type)

Process called "calculate_conversion_cost" that takes checker as TypeChecker, from_type as TypeInfo, to_type as TypeInfo returns Integer:
    @Implementation
    Calculates the cost of type conversion for overload resolution (lower cost = better match).
    @End Implementation
    
    Note: Identical types have zero cost
    If from_type.type_name equals to_type.type_name:
        Return 0
    End If
    
    Note: Subtype conversions have low cost
    If is_subtype(checker, from_type, to_type):
        Return 1
    End If
    
    Note: Numeric promotions have medium cost
    If from_type.type_name equals "Integer" and to_type.type_name equals "Float":
        Return 2
    End If
    
    Note: General conversions have high cost
    If can_convert_type(checker, from_type, to_type):
        Return 10
    End If
    
    Note: Impossible conversion has maximum cost
    Return 1000

Process called "is_numeric_promotion_valid" that takes checker as TypeChecker, from_type as TypeInfo, to_type as TypeInfo returns Boolean:
    @Implementation
    Checks if numeric promotion from one type to another is valid and safe.
    @End Implementation
    
    Note: Integer to Float promotion is always valid
    If from_type.type_name equals "Integer" and to_type.type_name equals "Float":
        Return true
    End If
    
    Note: Same types don't need promotion
    If from_type.type_name equals to_type.type_name:
        Return true
    End If
    
    Note: Float to Integer is not a safe promotion (narrowing)
    Return false

Note: =====================================================================
Note: ERROR REPORTING AND DIAGNOSTICS
Note: =====================================================================

Process called "generate_type_error_message" that takes checker as TypeChecker, error_type as String, context as String returns String:
    @Implementation
    Generates descriptive type error messages for user-friendly diagnostics.
    @End Implementation
    
    If error_type equals "TypeMismatch":
        Return "Type mismatch in " + context
    End If
    
    If error_type equals "UnknownType":
        Return "Unknown type in " + context
    End If
    
    If error_type equals "GenericConstraintViolation":
        Return "Generic constraint violation in " + context
    End If
    
    Return "Type error in " + context

Process called "suggest_type_fix" that takes checker as TypeChecker, error_context as String, expected_type as TypeInfo, actual_type as TypeInfo returns String:
    @Implementation
    Suggests possible fixes for type errors to help users resolve issues.
    @End Implementation
    
    If can_convert_type(checker, actual_type, expected_type):
        Return "Try converting " + actual_type.type_name + " to " + expected_type.type_name
    End If
    
    If actual_type.type_name equals "Integer" and expected_type.type_name equals "Float":
        Return "Integer will be automatically promoted to Float"
    End If
    
    Return "Change type from " + actual_type.type_name + " to " + expected_type.type_name

Process called "validate_type_annotations" that takes checker as TypeChecker, annotations as List[String] returns List[String]:
    @Implementation
    Validates type annotations for syntax and semantic correctness.
    @End Implementation
    
    Let errors be List[String]
    
    For Each annotation in annotations:
        If annotation equals "":
            List.add(errors, "Empty type annotation")
        End If
        
        If not checker.builtin_types contains key annotation:
            List.add(errors, "Unknown type: " + annotation)
        End If
    End For
    
    Return errors

Process called "check_generic_type_compatibility" that takes checker as TypeChecker, generic_type as TypeInfo, concrete_args as List[TypeInfo] returns List[String]:
    @Implementation
    Checks compatibility of generic types with concrete type arguments.
    @End Implementation
    
    Let errors be List[String]
    
    If concrete_args.length not equals generic_type.type_parameters.length:
        List.add(errors, "Generic argument count mismatch")
        Return errors
    End If
    
    Note: Check each concrete argument against constraints
    For i from 0 to (concrete_args.length - 1):
        Let constraint_satisfied be check_generic_constraints(checker, generic_type.type_parameters[i], generic_type.constraints)
        If not constraint_satisfied:
            List.add(errors, "Generic constraint violated for parameter " + generic_type.type_parameters[i])
        End If
    End For
    
    Return errors

Note: =====================================================================
Note: TYPE SYSTEM QUERIES
Note: =====================================================================

Process called "get_type_information" that takes checker as TypeChecker, type_name as String returns TypeInfo:
    @Implementation
    Gets complete type information for a given type name.
    @End Implementation
    
    Return get_type_info(checker, type_name)

Process called "list_available_types" that takes checker as TypeChecker returns List[String]:
    @Implementation
    Lists all available types in the current scope.
    @End Implementation
    
    Let type_names be List[String]
    
    Note: Add builtin types
    For Each type_name as String, type_info as TypeInfo in checker.builtin_types:
        List.add(type_names, type_name)
    End For
    
    Note: Add context types
    For Each var_name as String, var_type as TypeInfo in checker.type_context.type_variables:
        If not type_names contains var_type.type_name:
            List.add(type_names, var_type.type_name)
        End If
    End For
    
    Return type_names

Process called "check_type_completeness" that takes checker as TypeChecker, type_info as TypeInfo returns Boolean:
    @Implementation
    Checks if a type definition is complete and fully specified.
    @End Implementation
    
    Note: Check required fields are present
    If type_info.type_id equals "" or type_info.type_name equals "":
        Return false
    End If
    
    Note: Check type kind is valid
    If type_info.type_kind equals "":
        Return false
    End If
    
    Return true

Process called "get_type_hierarchy" that takes checker as TypeChecker, type_name as String returns List[String]:
    @Implementation
    Gets the type hierarchy showing supertypes and subtypes for a given type.
    @End Implementation
    
    Let hierarchy be List[String]
    
    If not checker.builtin_types contains key type_name:
        Return hierarchy
    End If
    
    Let type_info be checker.builtin_types[type_name]
    
    Note: Add base types
    For Each base_type in type_info.base_types:
        List.add(hierarchy, base_type)
    End For
    
    Return hierarchy

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "reset_type_checker_state" that takes checker as TypeChecker returns Nothing:
    @Implementation
    Resets the type checker state for a new analysis session.
    Clears type context, statistics, and temporary state.
    @End Implementation
    
    Note: Reset type context
    Set checker.type_context.current_scope to ""
    Set checker.type_context.type_variables to Dictionary[String, TypeInfo]
    Set checker.type_context.active_constraints to List[TypeConstraint]
    Set checker.type_context.inference_stack to List[String]
    Set checker.type_context.substitutions to Dictionary[String, String]
    
    Note: Reset statistics
    Set checker.statistics["expressions_checked"] to 0
    Set checker.statistics["types_inferred"] to 0
    Set checker.statistics["errors_found"] to 0
    Set checker.statistics["constraints_solved"] to 0

Process called "get_type_statistics" that takes checker as TypeChecker returns Dictionary[String, Integer]:
    @Implementation
    Returns comprehensive statistics about type checking operations.
    Useful for performance monitoring and debugging.
    @End Implementation
    
    Return checker.statistics

Process called "optimize_type_checking" that takes checker as TypeChecker returns Nothing:
    @Implementation
    Optimizes type checking performance by clearing caches and optimizing data structures.
    @End Implementation
    
    Note: Clear inference stack to free memory
    Set checker.type_context.inference_stack to List[String]
    
    Note: Clear old substitutions
    Set checker.type_context.substitutions to Dictionary[String, String]
    
    Note: Optimization complete

Process called "validate_type_checker_integrity" that takes checker as TypeChecker returns Boolean:
    @Implementation
    Validates the internal consistency of the type checker state.
    Checks for corrupted data structures and invalid state.
    @End Implementation
    
    Note: Validate builtin types are present
    If not checker.builtin_types contains key "Integer":
        Return false
    End If
    If not checker.builtin_types contains key "String":
        Return false
    End If
    If not checker.builtin_types contains key "Boolean":
        Return false
    End If
    
    Note: Validate type context is consistent
    If checker.type_context.context_id equals "":
        Return false
    End If
    
    Return true

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "get_timestamp_string" returns String:
    @Implementation
    Returns a timestamp string for generating unique IDs.
    @End Implementation
    
    Let timestamp be get_current_timestamp()
    Return integer_to_string(timestamp)

Process called "create_error_type" that takes error_message as String returns TypeInfo:
    @Implementation
    Creates an error type to represent type checking failures.
    @End Implementation
    
    Return TypeInfo with
        type_id as "error_" + error_message,
        type_name as error_message,
        type_kind as "error",
        base_types as List[String],
        type_parameters as List[String],
        constraints as List[String],
        size_bytes as 0,
        is_primitive as false,
        is_generic as false,
        is_nullable as false
    End TypeInfo

Process called "extract_variable_name" that takes expression_ast as String returns String:
    @Implementation
    Extracts variable name from variable reference AST node.
    @End Implementation
    
    If expression_ast starts with "variable_reference:":
        Let name_part be expression_ast[18:]  Note: Skip "variable_reference:"
        Return name_part
    End If
    Return ""

Process called "lookup_variable_type" that takes checker as TypeChecker, variable_name as String returns TypeInfo:
    @Implementation
    Looks up the type of a variable from the type context or symbol table.
    @End Implementation
    
    If checker.type_context.type_variables contains key variable_name:
        Return checker.type_context.type_variables[variable_name]
    End If
    
    Note: Variable type not found - return error type
    Return create_error_type("VariableTypeNotFound")

Process called "find_common_type" that takes checker as TypeChecker, type1 as TypeInfo, type2 as TypeInfo returns TypeInfo:
    @Implementation
    Finds the common type that both input types can be unified to.
    @End Implementation
    
    Note: Try unification first
    Let unified_type be unify_types(checker, type1, type2)
    If unified_type.type_name not equals "UnificationFailure":
        Return unified_type
    End If
    
    Note: Try finding common supertype
    Let types be [type1, type2]
    Return find_common_supertype(checker, types)

Process called "get_type_info" that takes checker as TypeChecker, type_name as String returns TypeInfo:
    @Implementation
    Gets type information for a given type name.
    @End Implementation
    
    If checker.builtin_types contains key type_name:
        Return checker.builtin_types[type_name]
    End If
    
    Return create_error_type("TypeNotFound")

Process called "are_types_compatible" that takes checker as TypeChecker, type1 as TypeInfo, type2 as TypeInfo returns Boolean:
    @Implementation
    Checks if two types are compatible (delegates to check_type_compatibility).
    @End Implementation
    
    Return check_type_compatibility(checker, type1, type2)

Process called "create_generic_type_instance" that takes checker as TypeChecker, generic_name as String, type_args as List[String] returns TypeInfo:
    @Implementation
    Creates an instance of a generic type with the given type arguments.
    @End Implementation
    
    Let generic_type be get_type_info(checker, generic_name)
    If generic_type.type_name equals "TypeNotFound":
        Return create_error_type("GenericTypeNotFound")
    End If
    
    Note: Convert string type args to TypeInfo
    Let type_arguments be List[TypeInfo]
    For Each type_arg_name in type_args:
        Let type_arg be get_type_info(checker, type_arg_name)
        List.add(type_arguments, type_arg)
    End For
    
    Return resolve_generic_parameters(checker, generic_type, type_arguments)

Note: =====================================================================
Note: PARSING INTERFACE FUNCTIONS
Note: =====================================================================

Process called "parse_binary_operation" that takes expression_ast as String returns Dictionary[String, String]:
    @Implementation
    Parse binary operation AST using expression parser infrastructure.
    Extracts operator and operands from the expression AST representation.
    @End Implementation
    
    Note: Create tokens from AST representation
    Let tokens be tokenize_ast_expression(expression_ast)
    
    Note: Use expression parser to parse the binary operation
    Let parse_result be ExpressionParsers.parse_binary_expression_with_conversion(
        "type_checker", tokens[0], tokens[1], tokens[2], "natural"
    )
    
    Let result be Dictionary[String, String]
    If parse_result.success:
        Set result["operator"] to parse_result.canonical_operator
        Set result["left"] to tokens[0]
        Set result["right"] to tokens[2]
    Otherwise:
        Note: Default fallback if parsing fails
        Set result["operator"] to "unknown"
        Set result["left"] to "unknown"
        Set result["right"] to "unknown"
    End If
    
    Return result

Process called "parse_function_call" that takes expression_ast as String returns Dictionary[String, List[String]]:
    @Implementation
    Parse function call AST using statement parser infrastructure.
    Extracts function name and arguments from the call expression.
    @End Implementation
    
    Note: Create tokens from AST representation  
    Let tokens be tokenize_ast_expression(expression_ast)
    
    Let result be Dictionary[String, List[String]]
    
    Note: Extract function name and arguments from tokens
    If tokens.length > 0:
        Set result["name"] to tokens[0]
        
        Note: Extract arguments (skip function name and parentheses)
        Let arguments be List[String]
        Let in_args be false
        For i from 1 to (tokens.length - 1):
            If tokens[i] equals "(":
                Set in_args to true
            Otherwise If tokens[i] equals ")":
                Set in_args to false
            Otherwise If in_args and tokens[i] not equals ",":
                List.add(arguments, tokens[i])
            End If
        End For
        
        Set result["arguments"] to arguments
    Otherwise:
        Set result["name"] to "unknown"
        Set result["arguments"] to List[String]
    End If
    
    Return result

Process called "parse_function_signature" that takes signature_ast as String returns Dictionary[String, Any]:
    @Implementation
    Parse function signature AST to extract name, parameters, and return type.
    Uses statement parser infrastructure for proper parsing.
    @End Implementation
    
    Note: Create tokens from signature AST
    Let tokens be tokenize_ast_expression(signature_ast)
    
    Let result be Dictionary[String, Any]
    Let parameters be List[Dictionary[String, String]]
    
    Note: Parse signature components
    Let function_name be ""
    Let return_type be ""
    Let current_state be "expecting_process"
    
    Let i be 0
    While i < tokens.length:
        If current_state equals "expecting_process" and tokens[i] equals "Process":
            Set current_state to "expecting_called"
        Otherwise If current_state equals "expecting_called" and tokens[i] equals "called":
            Set current_state to "expecting_name"
        Otherwise If current_state equals "expecting_name":
            Set function_name to tokens[i]
            Set current_state to "expecting_that"
        Otherwise If current_state equals "expecting_that" and tokens[i] equals "that":
            Set current_state to "expecting_takes"
        Otherwise If current_state equals "expecting_takes" and tokens[i] equals "takes":
            Set current_state to "parsing_params"
        Otherwise If current_state equals "parsing_params":
            Note: Parse parameter: name as Type
            If i + 2 < tokens.length and tokens[i + 1] equals "as":
                Let param be Dictionary[String, String]
                Set param["name"] to tokens[i]
                Set param["type"] to tokens[i + 2]
                List.add(parameters, param)
                Set i to i + 2
                
                Note: Check for returns keyword
                If i + 1 < tokens.length and tokens[i + 1] equals "returns":
                    Set current_state to "expecting_return_type"
                    Set i to i + 1
                End If
            End If
        Otherwise If current_state equals "expecting_return_type":
            Set return_type to tokens[i]
            Break
        End If
        Set i to i + 1
    End While
    
    Set result["name"] to function_name
    Set result["parameters"] to parameters
    Set result["return_type"] to return_type
    
    Return result

Process called "get_current_timestamp" returns Integer:
    Note: Get actual system timestamp using primitive operations
    Let timestamp be 0
    Assembly "
        mov rax, 201        ; sys_time syscall number
        mov rdi, 0          ; time_t *tloc = NULL
        syscall             ; invoke system call
        mov %[result], rax  ; store result
    " with outputs [timestamp]
    Return timestamp

Process called "tokenize_ast_expression" that takes ast_expression as String returns List[String]:
    @Implementation
    Tokenize AST expression string into individual tokens for parsing.
    Handles basic whitespace separation and preserves operators.
    @End Implementation
    
    Let tokens be List[String]
    Let current_token be ""
    
    For i from 0 to (ast_expression.length - 1):
        Let char be ast_expression[i]
        
        If char equals " ":
            If current_token not equals "":
                List.add(tokens, current_token)
                Set current_token to ""
            End If
        Otherwise If char equals "(" or char equals ")" or char equals ",":
            If current_token not equals "":
                List.add(tokens, current_token)
                Set current_token to ""
            End If
            List.add(tokens, char)
        Otherwise:
            Set current_token to current_token + char
        End If
    End For
    
    If current_token not equals "":
        List.add(tokens, current_token)
    End If
    
    Return tokens

Process called "get_function_signature_from_symbol_table" that takes checker as TypeChecker, function_name as String returns String:
    @Implementation
    Retrieve function signature from symbol table for type checking.
    Returns empty string if function not found.
    @End Implementation
    
    Note: Look up the function symbol in the symbol table
    Let symbol be SymbolTable.lookup_symbol(checker.symbol_table, function_name)
    
    Note: Check if symbol exists and is a function
    If symbol.symbol_id equals "":
        Return ""
    End If
    
    If symbol.symbol_type not equals "function":
        Return ""
    End If
    
    Note: Build the signature string from symbol attributes
    Let signature be "Process called \"" + function_name + "\""
    
    Note: Get parameter count
    Let param_count_str be symbol.attributes["parameter_count"]
    If param_count_str equals "":
        Set param_count_str to "0"
    End If
    Let param_count be string_to_integer(param_count_str)
    
    Note: Add parameters if any
    If param_count > 0:
        Set signature to signature + " that takes "
        For i from 0 to (param_count - 1):
            Let param_key be "param_" + integer_to_string(i)
            Let param_info be symbol.attributes[param_key]
            Set signature to signature + param_info
            If i < (param_count - 1):
                Set signature to signature + ", "
            End If
        End For
    End If
    
    Note: Add return type
    Let return_type be symbol.data_type
    If return_type equals "":
        Set return_type to "Nothing"
    End If
    Set signature to signature + " returns " + return_type
    
    Return signature

Process called "extract_parameter_types" that takes function_signature as String returns List[String]:
    @Implementation
    Extract parameter types from a function signature string.
    @End Implementation
    
    Let signature_info be parse_function_signature(function_signature)
    Let parameter_types be List[String]
    
    For Each param in signature_info["parameters"]:
        List.add(parameter_types, param["type"])
    End For
    
    Return parameter_types

Process called "extract_parameter_index" that takes constraint_id as String returns Integer:
    @Implementation
    Extract parameter index from constraint ID string.
    @End Implementation
    
    Note: Extract index from constraint_id format "function_arg_N_timestamp"
    Let parts be constraint_id split by "_"
    If parts.length >= 3:
        Let index_str be parts[2]
        Let index be string_to_integer(index_str)
        Return index
    End If
    
    Return 0

Process called "extract_trait_name" that takes constraint_expression as String returns String:
    @Implementation
    Extract trait name from constraint expression.
    @End Implementation
    
    Note: Parse trait constraint expression "implements TraitName"
    If constraint_expression contains "implements ":
        Let trait_part be constraint_expression after "implements "
        Return trait_part
    End If
    
    Return "Unknown"

Process called "check_trait_implementation" that takes checker as TypeChecker, type_info as TypeInfo, trait_name as String returns Boolean:
    @Implementation
    Check if a type implements a given trait.
    @End Implementation
    
    Note: Check type constraints for trait implementation
    For Each constraint in type_info.constraints:
        If constraint contains trait_name:
            Return true
        End If
    End For
    
    Return false

Process called "substitute_type_parameters" that takes type_string as String, type_arguments as List[TypeInfo] returns String:
    @Implementation
    Substitute generic type parameters with concrete types.
    @End Implementation
    
    Let result be type_string
    
    Note: Replace generic parameters T, U, V etc. with concrete types
    Let generic_params be ["T", "U", "V", "W", "X", "Y", "Z"]
    
    For i from 0 to (type_arguments.length - 1):
        If i < generic_params.length:
            Let param_name be generic_params[i]
            Let concrete_type be type_arguments[i].type_name
            Set result to result replace param_name with concrete_type
        End If
    End For
    
    Return result

Process called "string_to_integer" that takes str as String returns Integer:
    @Implementation
    Convert string to integer using character-by-character parsing.
    @End Implementation
    
    Let result be 0
    Let multiplier be 1
    Let is_negative be false
    
    Note: Handle negative numbers
    If str.length > 0 and str[0] equals "-":
        Set is_negative to true
        Set str to str[1:]  Note: Remove minus sign
    End If
    
    Note: Parse digits from right to left
    For i from (str.length - 1) down to 0:
        Let char be str[i]
        Let digit be char_to_digit(char)
        If digit >= 0 and digit <= 9:
            Set result to result + (digit * multiplier)
            Set multiplier to multiplier * 10
        End If
    End For
    
    If is_negative:
        Set result to 0 - result
    End If
    
    Return result

Process called "char_to_digit" that takes char as String returns Integer:
    @Implementation
    Convert character to digit value.
    @End Implementation
    
    If char equals "0": Return 0
    Otherwise If char equals "1": Return 1
    Otherwise If char equals "2": Return 2
    Otherwise If char equals "3": Return 3
    Otherwise If char equals "4": Return 4
    Otherwise If char equals "5": Return 5
    Otherwise If char equals "6": Return 6
    Otherwise If char equals "7": Return 7
    Otherwise If char equals "8": Return 8
    Otherwise If char equals "9": Return 9
    Otherwise: Return -1
    End If

Process called "integer_to_string" that takes value as Integer returns String:
    If value equals 0:
        Return "0"
    End If
    Note: Convert integer to string using string primitive
    Let result_string be StringPrimitive.allocate(20)  Note: Enough for 64-bit integer
    StringPrimitive.append_integer(result_string, value)
    Return result_string

Process called "extract_return_type" that takes function_signature as String returns String:
    @Implementation
    Extract return type from function signature string.
    @End Implementation
    
    Let signature_info be parse_function_signature(function_signature)
    Return signature_info["return_type"]

Process called "substitute_in_constraints" that takes constraints as List[String], type_param as String, concrete_type as String returns List[String]:
    @Implementation
    Substitute type parameter with concrete type in constraint list.
    @End Implementation
    
    Let result be List[String]
    For Each constraint in constraints:
        Let updated_constraint be constraint replace type_param with concrete_type
        List.add(result, updated_constraint)
    End For
    
    Return result

Process called "set_current_function_context" that takes checker as TypeChecker, function_name as String returns Nothing:
    @Implementation
    Sets the current function name context for return type checking.
    This is called when entering a function body for type checking.
    @End Implementation
    
    Set checker.current_function_name to function_name

Process called "clear_current_function_context" that takes checker as TypeChecker returns Nothing:
    @Implementation
    Clears the current function context when exiting function type checking.
    @End Implementation
    
    Set checker.current_function_name to ""