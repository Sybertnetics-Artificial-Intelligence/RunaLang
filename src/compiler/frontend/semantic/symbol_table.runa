Note:
compiler/frontend/semantic/symbol_table.runa
Symbol Table Management and Scope Resolution

This module provides comprehensive symbol table functionality including:
- Hierarchical scope management for both syntax modes
- Symbol definition and lookup operations
- Variable, function, and type symbol tracking
- Scope nesting with proper shadowing rules
- Symbol visibility and accessibility control
- Cross-reference tracking and dependency analysis
- Integration with both natural and technical syntax
- Performance optimized symbol resolution
:End Note

Import "../diagnostics/errors" as Errors
Import "../primitives/core/string_primitive" as StringPrimitive

Note: =====================================================================
Note: SYMBOL DATA STRUCTURES
Note: =====================================================================

Type called "Symbol":
    symbol_id as String
    symbol_name as String
    symbol_type as String
    data_type as String
    scope_id as String
    position as Dictionary[String, Integer]
    is_mutable as Boolean
    visibility as String
    attributes as Dictionary[String, String]
    references as List[Dictionary[String, Integer]]

Type called "Scope":
    scope_id as String
    scope_type as String
    parent_scope as String
    child_scopes as List[String]
    symbols as Dictionary[String, Symbol]
    scope_depth as Integer
    is_function_scope as Boolean
    is_block_scope as Boolean

Type called "SymbolTable":
    table_id as String
    root_scope as Scope
    current_scope as String
    scope_stack as List[String]
    global_symbols as Dictionary[String, Symbol]
    builtin_symbols as Dictionary[String, Symbol]
    statistics as Dictionary[String, Integer]
    scope_registry as Dictionary[String, Scope]

Note: =====================================================================
Note: SYMBOL TABLE OPERATIONS
Note: =====================================================================

Process called "create_symbol_table" that takes table_name as String returns SymbolTable:
    @Implementation
    Creates a new symbol table with initialized root scope and built-in symbols.
    Sets up the hierarchical scope structure for symbol resolution.
    @End Implementation
    
    Note: Create root scope
    Let root_scope_id be "scope_global_" + generate_unique_id()
    Let root be Scope with
        scope_id as root_scope_id,
        scope_type as "global",
        parent_scope as "",
        child_scopes as List[String],
        symbols as Dictionary[String, Symbol],
        scope_depth as 0,
        is_function_scope as false,
        is_block_scope as false
    End Scope
    
    Note: Create symbol table
    Let table be SymbolTable with
        table_id as table_name,
        root_scope as root,
        current_scope as root_scope_id,
        scope_stack as List[String],
        global_symbols as Dictionary[String, Symbol],
        builtin_symbols as Dictionary[String, Symbol],
        statistics as Dictionary[String, Integer],
        scope_registry as Dictionary[String, Scope]
    End SymbolTable
    
    Note: Register root scope
    Set table.scope_registry[root_scope_id] to root
    
    Note: Initialize scope stack with root
    List.add(table.scope_stack, root_scope_id)
    
    Note: Initialize statistics
    Set table.statistics["total_symbols"] to 0
    Set table.statistics["total_scopes"] to 1
    Set table.statistics["max_scope_depth"] to 0
    Set table.statistics["total_lookups"] to 0
    Set table.statistics["total_definitions"] to 0
    
    Note: Initialize built-in symbols
    Let builtin_result be initialize_builtin_symbols(table)
    
    Return table

Process called "initialize_builtin_symbols" that takes table as SymbolTable returns Boolean:
    @Implementation
    Initializes built-in types and symbols that are available in all scopes.
    Includes primitive types, constants, and built-in functions.
    @End Implementation
    
    Note: Define primitive types
    Let int_symbol be create_builtin_type_symbol("Integer", "primitive")
    Set table.builtin_symbols["Integer"] to int_symbol
    
    Let float_symbol be create_builtin_type_symbol("Float", "primitive")
    Set table.builtin_symbols["Float"] to float_symbol
    
    Let string_symbol be create_builtin_type_symbol("String", "primitive")
    Set table.builtin_symbols["String"] to string_symbol
    
    Let bool_symbol be create_builtin_type_symbol("Boolean", "primitive")
    Set table.builtin_symbols["Boolean"] to bool_symbol
    
    Let void_symbol be create_builtin_type_symbol("Nothing", "primitive")
    Set table.builtin_symbols["Nothing"] to void_symbol
    
    Let any_symbol be create_builtin_type_symbol("Any", "primitive")
    Set table.builtin_symbols["Any"] to any_symbol
    
    Note: Define built-in constants
    Let true_symbol be create_builtin_constant_symbol("true", "Boolean", "true")
    Set table.builtin_symbols["true"] to true_symbol
    
    Let false_symbol be create_builtin_constant_symbol("false", "Boolean", "false")
    Set table.builtin_symbols["false"] to false_symbol
    
    Let null_symbol be create_builtin_constant_symbol("null", "Any", "null")
    Set table.builtin_symbols["null"] to null_symbol
    
    Note: Update statistics
    Set table.statistics["builtin_symbols"] to 9
    
    Return true

Process called "create_global_scope" that takes table as SymbolTable returns Scope:
    @Implementation
    Creates the global scope for program-level symbol definitions.
    This is typically the outermost scope after built-ins.
    @End Implementation
    
    Return table.root_scope

Note: =====================================================================
Note: SCOPE MANAGEMENT OPERATIONS
Note: =====================================================================

Process called "enter_scope" that takes table as SymbolTable, scope_type as String returns String:
    @Implementation
    Creates and enters a new scope, maintaining the scope hierarchy.
    Returns the ID of the newly created scope.
    @End Implementation
    
    Note: Generate new scope ID
    Let new_scope_id be "scope_" + scope_type + "_" + generate_unique_id()
    
    Note: Get current scope depth
    Let parent_scope be get_scope_by_id(table, table.current_scope)
    Let new_depth be parent_scope.scope_depth + 1
    
    Note: Create new scope
    Let new_scope be Scope with
        scope_id as new_scope_id,
        scope_type as scope_type,
        parent_scope as table.current_scope,
        child_scopes as List[String],
        symbols as Dictionary[String, Symbol],
        scope_depth as new_depth,
        is_function_scope as (scope_type equals "function"),
        is_block_scope as (scope_type equals "block")
    End Scope
    
    Note: Add to parent's child scopes
    List.add(parent_scope.child_scopes, new_scope_id)
    
    Note: Store scope in table
    store_scope(table, new_scope)
    
    Note: Update current scope and stack
    Set table.current_scope to new_scope_id
    List.add(table.scope_stack, new_scope_id)
    
    Note: Update statistics
    Set table.statistics["total_scopes"] to table.statistics["total_scopes"] + 1
    If new_depth is greater than table.statistics["max_scope_depth"]:
        Set table.statistics["max_scope_depth"] to new_depth
    End If
    
    Return new_scope_id

Process called "exit_scope" that takes table as SymbolTable returns String:
    @Implementation
    Exits the current scope and returns to the parent scope.
    Returns the ID of the scope that was exited.
    @End Implementation
    
    Note: Check if we're at root scope
    Let stack_size be List.length(table.scope_stack)
    If stack_size equals 1:
        Throw Errors.create_semantic_error("Cannot exit root scope")
    End If
    
    Note: Save current scope ID
    Let exited_scope_id be table.current_scope
    
    Note: Pop from scope stack
    List.remove_last(table.scope_stack)
    
    Note: Update current scope to parent
    Let current_scope_obj be get_scope_by_id(table, table.current_scope)
    Set table.current_scope to current_scope_obj.parent_scope
    
    Return exited_scope_id

Process called "create_function_scope" that takes table as SymbolTable, function_name as String returns String:
    @Implementation
    Creates a specialized scope for function definitions.
    Handles parameter and local variable scoping.
    @End Implementation
    
    Note: Enter function scope
    Let scope_id be enter_scope(table, "function")
    
    Note: Mark scope with function name
    Let scope be get_scope_by_id(table, scope_id)
    Set scope.attributes["function_name"] to function_name
    
    Return scope_id

Process called "create_block_scope" that takes table as SymbolTable returns String:
    @Implementation
    Creates a scope for block statements (if, while, for, etc.).
    Provides isolated namespace for block-local variables.
    @End Implementation
    
    Return enter_scope(table, "block")

Process called "create_loop_scope" that takes table as SymbolTable returns String:
    @Implementation
    Creates a specialized scope for loop constructs.
    Tracks loop variables and iteration context.
    @End Implementation
    
    Return enter_scope(table, "loop")

Process called "get_current_scope" that takes table as SymbolTable returns Scope:
    @Implementation
    Returns the currently active scope object.
    @End Implementation
    
    Return get_scope_by_id(table, table.current_scope)

Process called "get_parent_scope" that takes table as SymbolTable, scope_id as String returns Scope:
    @Implementation
    Returns the parent scope of the specified scope.
    Returns null for root scope.
    @End Implementation
    
    Let scope be get_scope_by_id(table, scope_id)
    
    If StringPrimitive.length(scope.parent_scope) equals 0:
        Return null
    End If
    
    Return get_scope_by_id(table, scope.parent_scope)

Note: =====================================================================
Note: SYMBOL DEFINITION OPERATIONS
Note: =====================================================================

Process called "define_symbol" that takes table as SymbolTable, symbol as Symbol returns Boolean:
    @Implementation
    Defines a new symbol in the current scope with duplicate checking.
    Updates symbol table statistics and maintains symbol registry.
    @End Implementation
    
    Note: Get current scope
    Let current_scope be get_current_scope(table)
    
    Note: Check for duplicate definition in current scope
    If Dictionary.contains_key(current_scope.symbols, symbol.symbol_name):
        Return false
    End If
    
    Note: Set symbol's scope
    Set symbol.scope_id to current_scope.scope_id
    
    Note: Add symbol to current scope
    Set current_scope.symbols[symbol.symbol_name] to symbol
    
    Note: Add to global symbols if in global scope
    If current_scope.scope_type equals "global":
        Set table.global_symbols[symbol.symbol_name] to symbol
    End If
    
    Note: Update statistics
    Set table.statistics["total_symbols"] to table.statistics["total_symbols"] + 1
    Set table.statistics["total_definitions"] to table.statistics["total_definitions"] + 1
    
    Return true

Process called "define_variable" that takes table as SymbolTable, name as String, data_type as String, is_mutable as Boolean returns Boolean:
    @Implementation
    Defines a variable symbol with specified type and mutability.
    Performs type validation and scope-appropriate registration.
    @End Implementation
    
    Note: Create variable symbol
    Let symbol be Symbol with
        symbol_id as "var_" + name + "_" + generate_unique_id(),
        symbol_name as name,
        symbol_type as "variable",
        data_type as data_type,
        scope_id as table.current_scope,
        position as Dictionary[String, Integer],
        is_mutable as is_mutable,
        visibility as "private",
        attributes as Dictionary[String, String],
        references as List[Dictionary[String, Integer]]
    End Symbol
    
    Note: Set default position
    Set symbol.position["line"] to 0
    Set symbol.position["column"] to 0
    
    Note: Define the symbol
    Return define_symbol(table, symbol)

Process called "define_function" that takes table as SymbolTable, name as String, parameters as List[String], return_type as String returns Boolean:
    @Implementation
    Defines a function symbol with its signature including parameters and return type.
    Creates a function scope for parameter definitions.
    @End Implementation
    
    Note: Create function symbol
    Let symbol be Symbol with
        symbol_id as "func_" + name + "_" + generate_unique_id(),
        symbol_name as name,
        symbol_type as "function",
        data_type as return_type,
        scope_id as table.current_scope,
        position as Dictionary[String, Integer],
        is_mutable as false,
        visibility as "public",
        attributes as Dictionary[String, String],
        references as List[Dictionary[String, Integer]]
    End Symbol
    
    Note: Store parameter information
    Let param_count be List.length(parameters)
    Set symbol.attributes["parameter_count"] to integer_to_string(param_count)
    
    For i from 0 to (param_count - 1):
        Let param_key be "param_" + integer_to_string(i)
        Set symbol.attributes[param_key] to parameters[i]
    End For
    
    Note: Store return type
    Set symbol.attributes["return_type"] to return_type
    
    Note: Define the symbol
    Return define_symbol(table, symbol)

Process called "define_type" that takes table as SymbolTable, name as String, type_definition as String returns Boolean:
    @Implementation
    Defines a custom type symbol (struct, enum, alias, etc.).
    Registers the type for use in variable and function declarations.
    @End Implementation
    
    Note: Create type symbol
    Let symbol be Symbol with
        symbol_id as "type_" + name + "_" + generate_unique_id(),
        symbol_name as name,
        symbol_type as "type",
        data_type as "custom",
        scope_id as table.current_scope,
        position as Dictionary[String, Integer],
        is_mutable as false,
        visibility as "public",
        attributes as Dictionary[String, String],
        references as List[Dictionary[String, Integer]]
    End Symbol
    
    Note: Store type definition
    Set symbol.attributes["definition"] to type_definition
    
    Note: Define the symbol
    Return define_symbol(table, symbol)

Process called "define_constant" that takes table as SymbolTable, name as String, value as String, data_type as String returns Boolean:
    @Implementation
    Defines a constant symbol with an immutable value.
    Constants are compile-time evaluated and cannot be reassigned.
    @End Implementation
    
    Note: Create constant symbol
    Let symbol be Symbol with
        symbol_id as "const_" + name + "_" + generate_unique_id(),
        symbol_name as name,
        symbol_type as "constant",
        data_type as data_type,
        scope_id as table.current_scope,
        position as Dictionary[String, Integer],
        is_mutable as false,
        visibility as "public",
        attributes as Dictionary[String, String],
        references as List[Dictionary[String, Integer]]
    End Symbol
    
    Note: Store constant value
    Set symbol.attributes["value"] to value
    
    Note: Define the symbol
    Return define_symbol(table, symbol)

Note: =====================================================================
Note: SYMBOL LOOKUP OPERATIONS
Note: =====================================================================

Process called "lookup_symbol" that takes table as SymbolTable, name as String returns Symbol:
    @Implementation
    Looks up a symbol by name, searching from current scope up through parent scopes.
    Returns the first matching symbol found or null if not found.
    @End Implementation
    
    Note: Update lookup statistics
    Set table.statistics["total_lookups"] to table.statistics["total_lookups"] + 1
    
    Note: First check built-in symbols
    If Dictionary.contains_key(table.builtin_symbols, name):
        Return table.builtin_symbols[name]
    End If
    
    Note: Search from current scope up through parent scopes
    Let current_scope_id be table.current_scope
    
    While StringPrimitive.length(current_scope_id) is greater than 0:
        Let scope be get_scope_by_id(table, current_scope_id)
        
        If scope equals null:
            Break
        End If
        
        Note: Check if symbol exists in this scope
        If Dictionary.contains_key(scope.symbols, name):
            Let symbol be scope.symbols[name]
            
            Note: Add reference tracking
            Let reference_position be Dictionary[String, Integer]
            Set reference_position["line"] to 0
            Set reference_position["column"] to 0
            List.add(symbol.references, reference_position)
            
            Return symbol
        End If
        
        Note: Move to parent scope
        Set current_scope_id to scope.parent_scope
    End While
    
    Note: Check global symbols as last resort
    If Dictionary.contains_key(table.global_symbols, name):
        Return table.global_symbols[name]
    End If
    
    Return null

Process called "lookup_symbol_in_scope" that takes table as SymbolTable, name as String, scope_id as String returns Symbol:
    @Implementation
    Looks up a symbol in a specific scope only, without traversing parent scopes.
    Used for checking local definitions and avoiding scope pollution.
    @End Implementation
    
    Note: Get the specified scope
    Let scope be get_scope_by_id(table, scope_id)
    
    If scope equals null:
        Return null
    End If
    
    Note: Check if symbol exists in this scope only
    If Dictionary.contains_key(scope.symbols, name):
        Return scope.symbols[name]
    End If
    
    Return null

Process called "lookup_qualified_symbol" that takes table as SymbolTable, qualified_name as String returns Symbol:
    @Implementation
    Looks up a qualified symbol using namespace or module path (e.g., module::symbol).
    Supports hierarchical namespace resolution.
    @End Implementation
    
    Note: Parse qualified name
    Let separator_index be find_string_index(qualified_name, "::")
    
    If separator_index equals -1:
        Note: No qualification, do regular lookup
        Return lookup_symbol(table, qualified_name)
    End If
    
    Note: Extract namespace and symbol parts
    Let namespace_part be substring(qualified_name, 0, separator_index)
    Let symbol_part be substring(qualified_name, separator_index + 2, StringPrimitive.length(qualified_name))
    
    Note: Look up namespace first
    Let namespace_symbol be lookup_symbol(table, namespace_part)
    
    If namespace_symbol equals null:
        Return null
    End If
    
    Note: If namespace is a module/type, search within its scope
    If namespace_symbol.symbol_type equals "module" or namespace_symbol.symbol_type equals "type":
        Note: Get or create namespace scope
        Let namespace_scope_id be "scope_" + namespace_symbol.symbol_type + "_" + namespace_symbol.symbol_id
        Let namespace_scope be get_scope_by_id(table, namespace_scope_id)
        
        If namespace_scope not equals null:
            Note: Look for symbol in namespace scope
            If Dictionary.contains_key(namespace_scope.symbols, symbol_part):
                Return namespace_scope.symbols[symbol_part]
            End If
        End If
        
        Note: Try composite name as fallback
        Let composite_name be namespace_part + "_" + symbol_part
        Return lookup_symbol(table, composite_name)
    End If
    
    Return null

Process called "find_symbols_by_type" that takes table as SymbolTable, symbol_type as String returns List[Symbol]:
    @Implementation
    Finds all symbols of a specified type across all visible scopes.
    Useful for IDE features like "find all functions" or "list all variables".
    @End Implementation
    
    Let matching_symbols be List[Symbol]
    
    Note: Search built-in symbols
    For Each name in Dictionary.keys(table.builtin_symbols):
        Let symbol be table.builtin_symbols[name]
        If symbol.symbol_type equals symbol_type:
            List.add(matching_symbols, symbol)
        End If
    End For
    
    Note: Search all scopes recursively
    find_symbols_by_type_recursive(table.root_scope, symbol_type, matching_symbols, table)
    
    Return matching_symbols

Process called "check_symbol_visibility" that takes table as SymbolTable, symbol as Symbol, access_scope as String returns Boolean:
    @Implementation
    Checks if a symbol is visible and accessible from a given scope.
    Considers visibility modifiers and scope hierarchy.
    @End Implementation
    
    Note: Public symbols are always visible
    If symbol.visibility equals "public":
        Return true
    End If
    
    Note: Check if access scope is the same as symbol's scope
    If access_scope equals symbol.scope_id:
        Return true
    End If
    
    Note: Private symbols are only visible in their defining scope
    If symbol.visibility equals "private":
        Return false
    End If
    
    Note: Protected symbols are visible in child scopes
    If symbol.visibility equals "protected":
        Return is_child_scope(table, access_scope, symbol.scope_id)
    End If
    
    Note: Default to private visibility
    Return false

Note: =====================================================================
Note: SYMBOL SHADOWING AND CONFLICTS
Note: =====================================================================

Process called "check_symbol_shadowing" that takes table as SymbolTable, name as String returns Boolean:
    @Implementation
    Checks if defining a symbol with the given name would shadow an existing symbol.
    Returns true if shadowing would occur.
    @End Implementation
    
    Note: Check if symbol exists in parent scopes
    Let current_scope be get_current_scope(table)
    Let parent_scope_id be current_scope.parent_scope
    
    While StringPrimitive.length(parent_scope_id) is greater than 0:
        Let parent_scope be get_scope_by_id(table, parent_scope_id)
        
        If parent_scope equals null:
            Break
        End If
        
        Note: Check if symbol exists in parent scope
        If Dictionary.contains_key(parent_scope.symbols, name):
            Return true
        End If
        
        Set parent_scope_id to parent_scope.parent_scope
    End While
    
    Note: Check built-in symbols
    If Dictionary.contains_key(table.builtin_symbols, name):
        Return true
    End If
    
    Return false

Process called "resolve_symbol_conflict" that takes table as SymbolTable, name as String, conflicting_symbols as List[Symbol] returns Symbol:
    @Implementation
    Resolves conflicts between multiple symbol definitions using scope precedence.
    Returns the symbol that should be used based on scoping rules.
    @End Implementation
    
    Let symbol_count be List.length(conflicting_symbols)
    
    If symbol_count equals 0:
        Return null
    End If
    
    If symbol_count equals 1:
        Return conflicting_symbols[0]
    End If
    
    Note: Find the symbol in the nearest scope
    Let current_scope_id be table.current_scope
    
    While StringPrimitive.length(current_scope_id) is greater than 0:
        For Each symbol in conflicting_symbols:
            If symbol.scope_id equals current_scope_id:
                Return symbol
            End If
        End For
        
        Let scope be get_scope_by_id(table, current_scope_id)
        If scope equals null:
            Break
        End If
        
        Set current_scope_id to scope.parent_scope
    End While
    
    Note: Return first symbol as fallback
    Return conflicting_symbols[0]

Process called "get_shadowed_symbols" that takes table as SymbolTable, name as String returns List[Symbol]:
    @Implementation
    Returns all symbols that are shadowed by a symbol with the given name.
    Useful for warning about shadowing and understanding scope issues.
    @End Implementation
    
    Let shadowed_symbols be List[Symbol]
    Let current_scope be get_current_scope(table)
    Let parent_scope_id be current_scope.parent_scope
    
    While StringPrimitive.length(parent_scope_id) is greater than 0:
        Let parent_scope be get_scope_by_id(table, parent_scope_id)
        
        If parent_scope equals null:
            Break
        End If
        
        Note: Check if symbol exists in parent scope
        If Dictionary.contains_key(parent_scope.symbols, name):
            List.add(shadowed_symbols, parent_scope.symbols[name])
        End If
        
        Set parent_scope_id to parent_scope.parent_scope
    End While
    
    Note: Check built-in symbols
    If Dictionary.contains_key(table.builtin_symbols, name):
        List.add(shadowed_symbols, table.builtin_symbols[name])
    End If
    
    Return shadowed_symbols

Process called "validate_symbol_redefinition" that takes table as SymbolTable, symbol as Symbol returns List[String]:
    @Implementation
    Validates whether a symbol can be redefined in the current scope.
    Returns list of validation errors if redefinition is not allowed.
    @End Implementation
    
    Let errors be List[String]
    Let current_scope be get_current_scope(table)
    
    Note: Check if symbol already exists in current scope
    If Dictionary.contains_key(current_scope.symbols, symbol.symbol_name):
        Let existing_symbol be current_scope.symbols[symbol.symbol_name]
        
        Note: Functions cannot be redefined (no overloading yet)
        If existing_symbol.symbol_type equals "function":
            List.add(errors, "Function '" + symbol.symbol_name + "' is already defined in this scope")
        End If
        
        Note: Types cannot be redefined
        If existing_symbol.symbol_type equals "type":
            List.add(errors, "Type '" + symbol.symbol_name + "' is already defined in this scope")
        End If
        
        Note: Constants cannot be redefined
        If existing_symbol.symbol_type equals "constant":
            List.add(errors, "Constant '" + symbol.symbol_name + "' is already defined in this scope")
        End If
        
        Note: Variables can be redefined in some cases (shadowing)
        If existing_symbol.symbol_type equals "variable" and symbol.symbol_type equals "variable":
            If current_scope.is_function_scope or current_scope.is_block_scope:
                Note: Allow shadowing in nested scopes
            Otherwise:
                List.add(errors, "Variable '" + symbol.symbol_name + "' is already defined in this scope")
            End If
        End If
    End If
    
    Note: Check if redefining built-in symbols
    If Dictionary.contains_key(table.builtin_symbols, symbol.symbol_name):
        List.add(errors, "Cannot redefine built-in symbol '" + symbol.symbol_name + "'")
    End If
    
    Return errors

Note: =====================================================================
Note: NATURAL LANGUAGE SYMBOL SUPPORT
Note: =====================================================================

Process called "define_natural_variable" that takes table as SymbolTable, natural_declaration as String returns Boolean:
    @Implementation
    Parses and defines a variable from natural language declaration.
    Supports patterns like "Let x be Integer" or "Let name be String".
    @End Implementation
    
    Note: Parse natural language pattern "Let <name> be <type>"
    Let let_index be find_string_index(natural_declaration, "Let ")
    Let be_index be find_string_index(natural_declaration, " be ")
    
    If let_index not equals 0 or be_index equals -1:
        Return false
    End If
    
    Note: Extract variable name and type
    Let var_name be substring(natural_declaration, 4, be_index)
    Let var_type be substring(natural_declaration, be_index + 4, StringPrimitive.length(natural_declaration))
    
    Note: Trim whitespace from extracted parts
    Let var_name_trimmed be trim_string(var_name)
    Let var_type_trimmed be trim_string(var_type)
    
    Note: Define as mutable variable by default in natural mode
    Return define_variable(table, var_name_trimmed, var_type_trimmed, true)

Process called "define_natural_process" that takes table as SymbolTable, process_declaration as String returns Boolean:
    @Implementation
    Parses and defines a process/function from natural language declaration.
    Supports pattern: "Process called <name> that takes <params> returns <type>".
    @End Implementation
    
    Note: Parse natural language pattern
    Let called_index be find_string_index(process_declaration, "called ")
    Let takes_index be find_string_index(process_declaration, " that takes ")
    Let returns_index be find_string_index(process_declaration, " returns ")
    
    If called_index equals -1:
        Return false
    End If
    
    Note: Extract function name
    Let name_start be called_index + 7
    Let name_end be takes_index
    If takes_index equals -1:
        Set name_end to returns_index
        If returns_index equals -1:
            Set name_end to StringPrimitive.length(process_declaration)
        End If
    End If
    
    Let func_name be substring(process_declaration, name_start, name_end)
    Let func_name_trimmed be trim_string(func_name)
    
    Note: Extract parameters if present
    Let parameters be List[String]
    If takes_index not equals -1 and returns_index not equals -1:
        Let params_start be takes_index + 12
        Let params_text be substring(process_declaration, params_start, returns_index)
        Note: Parse comma-separated parameters
        parse_parameter_list(params_text, parameters)
    End If
    
    Note: Extract return type
    Let return_type be "Nothing"
    If returns_index not equals -1:
        Let return_start be returns_index + 9
        Let return_text be substring(process_declaration, return_start, StringPrimitive.length(process_declaration))
        Set return_type to trim_string(return_text)
    End If
    
    Return define_function(table, func_name_trimmed, parameters, return_type)

Process called "lookup_natural_symbol" that takes table as SymbolTable, natural_reference as String returns Symbol:
    @Implementation
    Looks up a symbol using natural language reference patterns.
    Supports references like "the variable x" or "the function foo".
    @End Implementation
    
    Note: Handle direct name reference
    Let symbol be lookup_symbol(table, natural_reference)
    If symbol not equals null:
        Return symbol
    End If
    
    Note: Handle "the <type> <name>" pattern
    Let the_index be find_string_index(natural_reference, "the ")
    If the_index equals 0:
        Let remaining be substring(natural_reference, 4, StringPrimitive.length(natural_reference))
        
        Note: Try extracting type and name
        Let space_index be find_string_index(remaining, " ")
        If space_index not equals -1:
            Let symbol_name be substring(remaining, space_index + 1, StringPrimitive.length(remaining))
            Let symbol_name_trimmed be trim_string(symbol_name)
            Return lookup_symbol(table, symbol_name_trimmed)
        End If
    End If
    
    Return null

Note: =====================================================================
Note: TECHNICAL SYNTAX SYMBOL SUPPORT
Note: =====================================================================

Process called "define_technical_variable" that takes table as SymbolTable, technical_declaration as String returns Boolean:
    @Implementation
    Parses and defines a variable from technical syntax declaration.
    Supports patterns like "int x = 5" or "string name".
    @End Implementation
    
    Note: Parse technical pattern "<type> <name> [= <value>]"
    Let space_index be find_string_index(technical_declaration, " ")
    If space_index equals -1:
        Return false
    End If
    
    Note: Extract type and rest
    Let var_type be substring(technical_declaration, 0, space_index)
    Let remaining be substring(technical_declaration, space_index + 1, StringPrimitive.length(technical_declaration))
    
    Note: Check for assignment
    Let equals_index be find_string_index(remaining, " = ")
    Let var_name be remaining
    
    If equals_index not equals -1:
        Set var_name to substring(remaining, 0, equals_index)
    End If
    
    Let var_name_trimmed be trim_string(var_name)
    Let var_type_mapped be map_technical_type(var_type)
    
    Note: Technical syntax variables are mutable by default
    Return define_variable(table, var_name_trimmed, var_type_mapped, true)

Process called "define_technical_function" that takes table as SymbolTable, function_declaration as String returns Boolean:
    @Implementation
    Parses and defines a function from technical syntax declaration.
    Supports pattern: "function <name>(<params>) -> <return_type>".
    @End Implementation
    
    Note: Parse technical function pattern
    Let function_index be find_string_index(function_declaration, "function ")
    If function_index not equals 0:
        Return false
    End If
    
    Note: Find parentheses for parameters
    Let paren_open be find_string_index(function_declaration, "(")
    Let paren_close be find_string_index(function_declaration, ")")
    
    If paren_open equals -1 or paren_close equals -1:
        Return false
    End If
    
    Note: Extract function name
    Let func_name be substring(function_declaration, 9, paren_open)
    Let func_name_trimmed be trim_string(func_name)
    
    Note: Extract and parse parameters
    Let parameters be List[String]
    If paren_close is greater than (paren_open + 1):
        Let params_text be substring(function_declaration, paren_open + 1, paren_close)
        parse_technical_parameters(params_text, parameters)
    End If
    
    Note: Extract return type
    Let return_type be "void"
    Let arrow_index be find_string_index(function_declaration, " -> ")
    If arrow_index not equals -1:
        Let return_start be arrow_index + 4
        Let return_text be substring(function_declaration, return_start, StringPrimitive.length(function_declaration))
        Set return_type to map_technical_type(trim_string(return_text))
    End If
    
    Return define_function(table, func_name_trimmed, parameters, return_type)

Process called "lookup_technical_symbol" that takes table as SymbolTable, technical_reference as String returns Symbol:
    @Implementation
    Looks up a symbol using technical syntax references.
    Supports patterns like direct names, qualified names (module.symbol), etc.
    @End Implementation
    
    Note: Handle qualified reference (module.symbol)
    Let dot_index be find_string_index(technical_reference, ".")
    If dot_index not equals -1:
        Note: Convert dot notation to double-colon for qualified lookup
        Let module_part be substring(technical_reference, 0, dot_index)
        Let symbol_part be substring(technical_reference, dot_index + 1, StringPrimitive.length(technical_reference))
        Let qualified_name be module_part + "::" + symbol_part
        Return lookup_qualified_symbol(table, qualified_name)
    End If
    
    Note: Direct lookup for unqualified names
    Return lookup_symbol(table, technical_reference)

Note: =====================================================================
Note: REFERENCE TRACKING OPERATIONS
Note: =====================================================================

Process called "add_symbol_reference" that takes table as SymbolTable, symbol_name as String, reference_position as Dictionary[String, Integer] returns Boolean:
    @Implementation
    Adds a reference location to a symbol for cross-reference tracking.
    Used for "find all references" and dependency analysis.
    @End Implementation
    
    Note: Look up the symbol
    Let symbol be lookup_symbol(table, symbol_name)
    
    If symbol equals null:
        Return false
    End If
    
    Note: Add the reference position
    List.add(symbol.references, reference_position)
    
    Return true

Process called "get_symbol_references" that takes table as SymbolTable, symbol_name as String returns List[Dictionary[String, Integer]]:
    @Implementation
    Returns all recorded references to a specified symbol.
    Useful for refactoring and understanding symbol usage.
    @End Implementation
    
    Note: Look up the symbol
    Let symbol be lookup_symbol(table, symbol_name)
    
    If symbol equals null:
        Return List[Dictionary[String, Integer]]
    End If
    
    Return symbol.references

Process called "find_unused_symbols" that takes table as SymbolTable returns List[Symbol]:
    @Implementation
    Finds all symbols that are defined but have no references.
    Useful for dead code elimination and cleanup.
    @End Implementation
    
    Let unused_symbols be List[Symbol]
    
    Note: Check all scopes recursively
    find_unused_symbols_recursive(table.root_scope, unused_symbols, table)
    
    Note: Check global symbols
    For Each name in Dictionary.keys(table.global_symbols):
        Let symbol be table.global_symbols[name]
        If List.length(symbol.references) equals 0:
            Note: Skip built-in symbols
            If not Dictionary.contains_key(symbol.attributes, "builtin"):
                List.add(unused_symbols, symbol)
            End If
        End If
    End For
    
    Return unused_symbols

Process called "find_unused_symbols_recursive" that takes scope as Scope, unused_list as List[Symbol], table as SymbolTable returns Nothing:
    @Implementation
    Recursively finds unused symbols in scope hierarchy.
    @End Implementation
    
    Note: Check symbols in current scope
    For Each name in Dictionary.keys(scope.symbols):
        Let symbol be scope.symbols[name]
        If List.length(symbol.references) equals 0:
            Note: Skip function parameters and loop variables
            If symbol.symbol_type not equals "parameter" and not Dictionary.contains_key(symbol.attributes, "loop_variable"):
                List.add(unused_list, symbol)
            End If
        End If
    End For
    
    Note: Recursively check child scopes
    For Each child_id in scope.child_scopes:
        Let child_scope be get_scope_by_id(table, child_id)
        If child_scope not equals null:
            find_unused_symbols_recursive(child_scope, unused_list, table)
        End If
    End For

Process called "analyze_symbol_dependencies" that takes table as SymbolTable, symbol_name as String returns List[String]:
    @Implementation
    Analyzes which other symbols a given symbol depends on.
    Useful for understanding code dependencies and impact analysis.
    @End Implementation
    
    Let dependencies be List[String]
    Let symbol be lookup_symbol(table, symbol_name)
    
    If symbol equals null:
        Return dependencies
    End If
    
    Note: For functions, analyze parameter and return types
    If symbol.symbol_type equals "function":
        Note: Add return type dependency
        If not is_primitive_type(symbol.data_type):
            List.add(dependencies, symbol.data_type)
        End If
        
        Note: Add parameter type dependencies
        Let param_count_str be Dictionary.get(symbol.attributes, "parameter_count")
        If param_count_str not equals null:
            Let param_count be string_to_integer(param_count_str)
            For i from 0 to (param_count - 1):
                Let param_key be "param_" + integer_to_string(i)
                Let param_info be Dictionary.get(symbol.attributes, param_key)
                Note: Extract type from parameter info
                If param_info not equals null:
                    extract_type_dependencies(param_info, dependencies)
                End If
            End For
        End If
    End If
    
    Note: For variables, analyze data type
    If symbol.symbol_type equals "variable":
        If not is_primitive_type(symbol.data_type):
            List.add(dependencies, symbol.data_type)
        End If
    End If
    
    Note: For types, analyze field types
    If symbol.symbol_type equals "type":
        Let definition be Dictionary.get(symbol.attributes, "definition")
        If definition not equals null:
            extract_type_dependencies(definition, dependencies)
        End If
    End If
    
    Return dependencies

Note: =====================================================================
Note: SYMBOL TABLE QUERIES
Note: =====================================================================

Process called "get_all_symbols_in_scope" that takes table as SymbolTable, scope_id as String returns List[Symbol]:
    @Implementation
    Returns all symbols defined directly in the specified scope.
    Does not include inherited symbols from parent scopes.
    @End Implementation
    
    Let symbols be List[Symbol]
    Let scope be get_scope_by_id(table, scope_id)
    
    If scope equals null:
        Return symbols
    End If
    
    Note: Add all symbols from this scope
    For Each name in Dictionary.keys(scope.symbols):
        List.add(symbols, scope.symbols[name])
    End For
    
    Return symbols

Process called "get_visible_symbols" that takes table as SymbolTable, from_scope as String returns List[Symbol]:
    @Implementation
    Returns all symbols visible from a specified scope.
    Includes symbols from parent scopes and built-ins.
    @End Implementation
    
    Let visible_symbols be List[Symbol]
    Let seen_names be Dictionary[String, Boolean]
    
    Note: Add built-in symbols first
    For Each name in Dictionary.keys(table.builtin_symbols):
        Let symbol be table.builtin_symbols[name]
        List.add(visible_symbols, symbol)
        Set seen_names[name] to true
    End For
    
    Note: Traverse from current scope up to root
    Let current_scope_id be from_scope
    
    While StringPrimitive.length(current_scope_id) is greater than 0:
        Let scope be get_scope_by_id(table, current_scope_id)
        
        If scope equals null:
            Break
        End If
        
        Note: Add symbols from this scope if not shadowed
        For Each name in Dictionary.keys(scope.symbols):
            If not Dictionary.contains_key(seen_names, name):
                Let symbol be scope.symbols[name]
                
                Note: Check visibility
                If check_symbol_visibility(table, symbol, from_scope):
                    List.add(visible_symbols, symbol)
                    Set seen_names[name] to true
                End If
            End If
        End For
        
        Set current_scope_id to scope.parent_scope
    End While
    
    Return visible_symbols

Process called "search_symbols_by_pattern" that takes table as SymbolTable, pattern as String returns List[Symbol]:
    @Implementation
    Searches for symbols whose names match a given pattern.
    Supports simple wildcard patterns with * for matching.
    @End Implementation
    
    Let matching_symbols be List[Symbol]
    
    Note: Search in built-in symbols
    For Each name in Dictionary.keys(table.builtin_symbols):
        If matches_pattern(name, pattern):
            List.add(matching_symbols, table.builtin_symbols[name])
        End If
    End For
    
    Note: Search in all scopes
    search_symbols_by_pattern_recursive(table.root_scope, pattern, matching_symbols, table)
    
    Return matching_symbols

Process called "search_symbols_by_pattern_recursive" that takes scope as Scope, pattern as String, result_list as List[Symbol], table as SymbolTable returns Nothing:
    @Implementation
    Recursively searches for symbols matching a pattern.
    @End Implementation
    
    Note: Search in current scope
    For Each name in Dictionary.keys(scope.symbols):
        If matches_pattern(name, pattern):
            List.add(result_list, scope.symbols[name])
        End If
    End For
    
    Note: Recursively search child scopes
    For Each child_id in scope.child_scopes:
        Let child_scope be get_scope_by_id(table, child_id)
        If child_scope not equals null:
            search_symbols_by_pattern_recursive(child_scope, pattern, result_list, table)
        End If
    End For

Process called "matches_pattern" that takes text as String, pattern as String returns Boolean:
    @Implementation
    Checks if text matches a simple wildcard pattern.
    Supports * as wildcard for zero or more characters.
    @End Implementation
    
    Note: Handle exact match
    If find_string_index(pattern, "*") equals -1:
        Return string_equals(text, pattern)
    End If
    
    Note: Handle wildcard at start
    If StringPrimitive.char_at(pattern, 0) equals 42:  Note: Asterisk
        Let suffix be substring(pattern, 1, StringPrimitive.length(pattern))
        Return string_ends_with(text, suffix)
    End If
    
    Note: Handle wildcard at end
    Let pattern_length be StringPrimitive.length(pattern)
    If StringPrimitive.char_at(pattern, pattern_length - 1) equals 42:
        Let prefix be substring(pattern, 0, pattern_length - 1)
        Return string_starts_with(text, prefix)
    End If
    
    Note: Handle wildcard in middle
    Let star_index be find_string_index(pattern, "*")
    Let prefix be substring(pattern, 0, star_index)
    Let suffix be substring(pattern, star_index + 1, pattern_length)
    
    Note: Check if text contains the pattern parts in order
    If not string_starts_with(text, prefix):
        Return false
    End If
    
    If not string_ends_with(text, suffix):
        Return false
    End If
    
    Note: Ensure suffix appears after prefix
    Let text_length be StringPrimitive.length(text)
    Let prefix_length be StringPrimitive.length(prefix)
    Let suffix_length be StringPrimitive.length(suffix)
    
    If prefix_length + suffix_length is greater than text_length:
        Return false
    End If
    
    Return true

Process called "get_symbol_scope_chain" that takes table as SymbolTable, symbol_name as String returns List[String]:
    @Implementation
    Returns the scope chain traversed when resolving a symbol.
    Useful for understanding symbol resolution order.
    @End Implementation
    
    Let scope_chain be List[String]
    Let current_scope_id be table.current_scope
    
    Note: Build scope chain from current to root
    While StringPrimitive.length(current_scope_id) is greater than 0:
        List.add(scope_chain, current_scope_id)
        
        Let scope be get_scope_by_id(table, current_scope_id)
        If scope equals null:
            Break
        End If
        
        Note: Check if symbol exists in this scope
        If Dictionary.contains_key(scope.symbols, symbol_name):
            Note: Symbol found, chain is complete
            Return scope_chain
        End If
        
        Set current_scope_id to scope.parent_scope
    End While
    
    Note: Add built-in scope if symbol is built-in
    If Dictionary.contains_key(table.builtin_symbols, symbol_name):
        List.add(scope_chain, "builtin")
    End If
    
    Return scope_chain

Note: =====================================================================
Note: SYMBOL TABLE VALIDATION
Note: =====================================================================

Process called "validate_symbol_table" that takes table as SymbolTable returns List[String]:
    @Implementation
    Validates the entire symbol table for consistency and correctness.
    Returns list of validation errors found.
    @End Implementation
    
    Let errors be List[String]
    
    Note: Validate root scope exists
    If table.root_scope equals null:
        List.add(errors, "Symbol table has no root scope")
        Return errors
    End If
    
    Note: Validate current scope is valid
    Let current_scope be get_scope_by_id(table, table.current_scope)
    If current_scope equals null:
        List.add(errors, "Current scope ID '" + table.current_scope + "' is invalid")
    End If
    
    Note: Validate scope stack consistency
    Let stack_size be List.length(table.scope_stack)
    If stack_size equals 0:
        List.add(errors, "Scope stack is empty")
    End If
    
    Note: Validate scope hierarchy
    Let scope_errors be check_scope_consistency(table)
    For Each error in scope_errors:
        List.add(errors, error)
    End For
    
    Note: Validate symbol types
    Let type_errors be validate_symbol_types(table)
    For Each error in type_errors:
        List.add(errors, error)
    End For
    
    Note: Check for circular dependencies
    Let circular_errors be check_circular_dependencies(table)
    For Each error in circular_errors:
        List.add(errors, error)
    End For
    
    Return errors

Process called "check_scope_consistency" that takes table as SymbolTable returns List[String]:
    @Implementation
    Checks the consistency of the scope hierarchy.
    Ensures parent-child relationships are valid.
    @End Implementation
    
    Let errors be List[String]
    
    Note: Check root scope
    If StringPrimitive.length(table.root_scope.parent_scope) not equals 0:
        List.add(errors, "Root scope has non-empty parent scope")
    End If
    
    If table.root_scope.scope_depth not equals 0:
        List.add(errors, "Root scope depth is not 0")
    End If
    
    Note: Recursively check scope consistency
    check_scope_consistency_recursive(table.root_scope, errors, table)
    
    Return errors

Process called "check_scope_consistency_recursive" that takes scope as Scope, errors as List[String], table as SymbolTable returns Nothing:
    @Implementation
    Recursively validates scope consistency.
    @End Implementation
    
    Note: Check each child scope
    For Each child_id in scope.child_scopes:
        Let child_scope be get_scope_by_id(table, child_id)
        
        If child_scope equals null:
            List.add(errors, "Child scope '" + child_id + "' not found")
            Continue
        End If
        
        Note: Verify parent-child relationship
        If child_scope.parent_scope not equals scope.scope_id:
            List.add(errors, "Scope '" + child_id + "' has incorrect parent")
        End If
        
        Note: Verify depth
        If child_scope.scope_depth not equals (scope.scope_depth + 1):
            List.add(errors, "Scope '" + child_id + "' has incorrect depth")
        End If
        
        Note: Recurse to check child's children
        check_scope_consistency_recursive(child_scope, errors, table)
    End For

Process called "validate_symbol_types" that takes table as SymbolTable returns List[String]:
    @Implementation
    Validates that all symbols have valid types and type references.
    Checks for undefined types and type consistency.
    @End Implementation
    
    Let errors be List[String]
    
    Note: Collect all symbols to validate
    Let all_symbols be List[Symbol]
    collect_all_symbols(table, all_symbols)
    
    Note: Validate each symbol's type
    For Each symbol in all_symbols:
        Note: Check if data type is defined
        If StringPrimitive.length(symbol.data_type) is greater than 0:
            If not is_primitive_type(symbol.data_type):
                Note: Check if custom type exists
                Let type_symbol be lookup_symbol(table, symbol.data_type)
                If type_symbol equals null:
                    List.add(errors, "Symbol '" + symbol.symbol_name + "' has undefined type '" + symbol.data_type + "'")
                Otherwise:
                    If type_symbol.symbol_type not equals "type":
                        List.add(errors, "Symbol '" + symbol.symbol_name + "' references '" + symbol.data_type + "' which is not a type")
                    End If
                End If
            End If
        End If
        
        Note: Validate symbol type field
        If not is_valid_symbol_type(symbol.symbol_type):
            List.add(errors, "Symbol '" + symbol.symbol_name + "' has invalid symbol type '" + symbol.symbol_type + "'")
        End If
    End For
    
    Return errors

Process called "check_circular_dependencies" that takes table as SymbolTable returns List[String]:
    @Implementation
    Detects circular dependencies between type definitions.
    Important for preventing infinite recursion in type resolution.
    @End Implementation
    
    Let errors be List[String]
    Let visited be Dictionary[String, Boolean]
    Let recursion_stack be Dictionary[String, Boolean]
    
    Note: Check each type symbol for circular dependencies
    For Each name in Dictionary.keys(table.global_symbols):
        Let symbol be table.global_symbols[name]
        If symbol.symbol_type equals "type":
            If not Dictionary.contains_key(visited, name):
                check_type_circular_dependency(table, symbol, visited, recursion_stack, errors)
            End If
        End If
    End For
    
    Return errors

Process called "check_type_circular_dependency" that takes table as SymbolTable, type_symbol as Symbol, visited as Dictionary[String, Boolean], recursion_stack as Dictionary[String, Boolean], errors as List[String] returns Nothing:
    @Implementation
    Recursively checks for circular dependencies in type definitions.
    @End Implementation
    
    Note: Mark as visited and add to recursion stack
    Set visited[type_symbol.symbol_name] to true
    Set recursion_stack[type_symbol.symbol_name] to true
    
    Note: Get dependencies of this type
    Let dependencies be analyze_symbol_dependencies(table, type_symbol.symbol_name)
    
    For Each dep_name in dependencies:
        If Dictionary.contains_key(recursion_stack, dep_name):
            List.add(errors, "Circular dependency detected: '" + type_symbol.symbol_name + "' -> '" + dep_name + "'")
        Otherwise:
            If not Dictionary.contains_key(visited, dep_name):
                Let dep_symbol be lookup_symbol(table, dep_name)
                If dep_symbol not equals null and dep_symbol.symbol_type equals "type":
                    check_type_circular_dependency(table, dep_symbol, visited, recursion_stack, errors)
                End If
            End If
        End If
    End For
    
    Note: Remove from recursion stack
    Dictionary.remove(recursion_stack, type_symbol.symbol_name)

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "get_symbol_table_statistics" that takes table as SymbolTable returns Dictionary[String, Integer]:
    @Implementation
    Returns comprehensive statistics about the symbol table.
    Useful for performance monitoring and debugging.
    @End Implementation
    
    Note: Return existing statistics plus computed values
    Let stats be Dictionary[String, Integer]
    
    Note: Copy existing statistics
    For Each key in Dictionary.keys(table.statistics):
        Set stats[key] to table.statistics[key]
    End For
    
    Note: Count total symbols across all scopes
    Let total_symbols be count_all_symbols(table)
    Set stats["total_symbols_actual"] to total_symbols
    
    Note: Count symbols by type
    Let type_counts be Dictionary[String, Integer]
    count_symbols_by_type(table, type_counts)
    
    Set stats["variables"] to Dictionary.get_or_default(type_counts, "variable", 0)
    Set stats["functions"] to Dictionary.get_or_default(type_counts, "function", 0)
    Set stats["types"] to Dictionary.get_or_default(type_counts, "type", 0)
    Set stats["constants"] to Dictionary.get_or_default(type_counts, "constant", 0)
    
    Note: Add scope stack depth
    Set stats["current_scope_depth"] to List.length(table.scope_stack)
    
    Return stats

Process called "export_symbol_table" that takes table as SymbolTable, format as String returns String:
    @Implementation
    Exports the symbol table in the specified format.
    Supports "json", "text", and "debug" formats.
    @End Implementation
    
    Match format:
        When "text":
            Return export_symbol_table_text(table)
        When "json":
            Return export_symbol_table_json(table)
        When "debug":
            Return export_symbol_table_debug(table)
        Otherwise:
            Return "Unsupported export format: " + format
    End Match

Process called "export_symbol_table_text" that takes table as SymbolTable returns String:
    @Implementation
    Exports symbol table in human-readable text format.
    @End Implementation
    
    Let output be "Symbol Table Export\n"
    Set output to output + "==================\n\n"
    
    Note: Export built-in symbols
    Set output to output + "Built-in Symbols:\n"
    For Each name in Dictionary.keys(table.builtin_symbols):
        Let symbol be table.builtin_symbols[name]
        Set output to output + "  " + name + " (" + symbol.symbol_type + ") : " + symbol.data_type + "\n"
    End For
    
    Set output to output + "\nGlobal Symbols:\n"
    For Each name in Dictionary.keys(table.global_symbols):
        Let symbol be table.global_symbols[name]
        Set output to output + "  " + name + " (" + symbol.symbol_type + ") : " + symbol.data_type + "\n"
    End For
    
    Set output to output + "\nStatistics:\n"
    For Each key in Dictionary.keys(table.statistics):
        Set output to output + "  " + key + ": " + integer_to_string(table.statistics[key]) + "\n"
    End For
    
    Return output

Process called "export_symbol_table_json" that takes table as SymbolTable returns String:
    @Implementation
    Exports symbol table in JSON format.
    @End Implementation
    
    Let output be "{\n"
    Set output to output + "  \"table_id\": \"" + table.table_id + "\",\n"
    Set output to output + "  \"current_scope\": \"" + table.current_scope + "\",\n"
    
    Note: Export statistics
    Set output to output + "  \"statistics\": {\n"
    Let first be true
    For Each key in Dictionary.keys(table.statistics):
        If not first:
            Set output to output + ",\n"
        End If
        Set output to output + "    \"" + key + "\": " + integer_to_string(table.statistics[key])
        Set first to false
    End For
    Set output to output + "\n  },\n"
    
    Note: Export symbol count
    Let symbol_count be count_all_symbols(table)
    Set output to output + "  \"total_symbols\": " + integer_to_string(symbol_count) + "\n"
    Set output to output + "}\n"
    
    Return output

Process called "export_symbol_table_debug" that takes table as SymbolTable returns String:
    @Implementation
    Exports detailed debug information about the symbol table.
    @End Implementation
    
    Let output be "=== Symbol Table Debug Export ===\n\n"
    
    Note: Export scope hierarchy
    Set output to output + "Scope Hierarchy:\n"
    Set output to output + export_scope_hierarchy(table.root_scope, 0, table)
    
    Note: Export scope stack
    Set output to output + "\nScope Stack:\n"
    For Each scope_id in table.scope_stack:
        Set output to output + "  - " + scope_id + "\n"
    End For
    
    Note: Export all symbols with details
    Set output to output + "\nAll Symbols (Detailed):\n"
    Let all_symbols be List[Symbol]
    collect_all_symbols(table, all_symbols)
    
    For Each symbol in all_symbols:
        Set output to output + "  " + symbol.symbol_name + ":\n"
        Set output to output + "    Type: " + symbol.symbol_type + "\n"
        Set output to output + "    Data Type: " + symbol.data_type + "\n"
        Set output to output + "    Scope: " + symbol.scope_id + "\n"
        Set output to output + "    Mutable: " + boolean_to_string(symbol.is_mutable) + "\n"
        Set output to output + "    References: " + integer_to_string(List.length(symbol.references)) + "\n"
    End For
    
    Return output

Process called "import_symbol_definitions" that takes table as SymbolTable, definitions as String, format as String returns Boolean:
    @Implementation
    Imports symbol definitions from an external source.
    Supports various formats for module imports and symbol sharing.
    @End Implementation
    
    Match format:
        When "text":
            Return import_text_definitions(table, definitions)
        When "json":
            Return import_json_definitions(table, definitions)
        When "module":
            Return import_module_definitions(table, definitions)
        Otherwise:
            Return false
    End Match

Process called "import_text_definitions" that takes table as SymbolTable, definitions as String returns Boolean:
    @Implementation
    Imports symbol definitions from text format.
    @End Implementation
    
    Note: Parse line-by-line
    Let lines be split_string_lines(definitions)
    
    For Each line in lines:
        Let trimmed be trim_string(line)
        
        Note: Skip empty lines and comments
        If StringPrimitive.length(trimmed) equals 0:
            Continue
        End If
        
        Note: Parse variable definitions
        If string_starts_with(trimmed, "var "):
            Let var_def be substring(trimmed, 4, StringPrimitive.length(trimmed))
            define_technical_variable(table, var_def)
        End If
        
        Note: Parse function definitions
        If string_starts_with(trimmed, "function "):
            define_technical_function(table, trimmed)
        End If
        
        Note: Parse type definitions
        If string_starts_with(trimmed, "type "):
            Let type_def be substring(trimmed, 5, StringPrimitive.length(trimmed))
            Let space_index be find_string_index(type_def, " ")
            If space_index not equals -1:
                Let type_name be substring(type_def, 0, space_index)
                Let type_body be substring(type_def, space_index + 1, StringPrimitive.length(type_def))
                define_type(table, type_name, type_body)
            End If
        End If
    End For
    
    Return true

Process called "import_json_definitions" that takes table as SymbolTable, definitions as String returns Boolean:
    @Implementation
    Imports symbol definitions from JSON format.
    Parses JSON structure to extract and define symbols.
    @End Implementation
    
    Note: Parse JSON object (basic parser)
    Let lines be split_string_lines(definitions)
    Let in_symbol be false
    Let current_name be ""
    Let current_type be ""
    Let current_data_type be ""
    
    For Each line in lines:
        Let trimmed be trim_string(line)
        
        Note: Look for symbol definitions in JSON
        If StringPrimitive.contains(trimmed, "\"name\":"):
            Let start be find_string_index(trimmed, ":\"")
            Let end be find_string_index_from(trimmed, "\"", start + 3)
            If start not equals -1 and end not equals -1:
                Set current_name to substring(trimmed, start + 3, end)
            End If
        End If
        
        If StringPrimitive.contains(trimmed, "\"type\":"):
            Let start be find_string_index(trimmed, ":\"")
            Let end be find_string_index_from(trimmed, "\"", start + 3)
            If start not equals -1 and end not equals -1:
                Set current_type to substring(trimmed, start + 3, end)
            End If
        End If
        
        If StringPrimitive.contains(trimmed, "\"data_type\":"):
            Let start be find_string_index(trimmed, ":\"")
            Let end be find_string_index_from(trimmed, "\"", start + 3)
            If start not equals -1 and end not equals -1:
                Set current_data_type to substring(trimmed, start + 3, end)
            End If
        End If
        
        Note: When we have all fields, create the symbol
        If StringPrimitive.length(current_name) is greater than 0 and StringPrimitive.contains(trimmed, "}"):
            If current_type equals "variable":
                define_variable(table, current_name, current_data_type, true)
            Otherwise current_type equals "function":
                define_function(table, current_name, List[String], current_data_type)
            Otherwise current_type equals "type":
                define_type(table, current_name, current_data_type)
            End If
            
            Note: Reset for next symbol
            Set current_name to ""
            Set current_type to ""
            Set current_data_type to ""
        End If
    End For
    
    Return true

Process called "find_string_index_from" that takes text as String, substring as String, start_pos as Integer returns Integer:
    @Implementation
    Finds the index of a substring starting from a specific position.
    @End Implementation
    
    Let text_length be StringPrimitive.length(text)
    Let sub_length be StringPrimitive.length(substring)
    
    If start_pos + sub_length is greater than text_length:
        Return -1
    End If
    
    For i from start_pos to (text_length - sub_length):
        Let match be true
        For j from 0 to (sub_length - 1):
            If StringPrimitive.char_at(text, i + j) not equals StringPrimitive.char_at(substring, j):
                Set match to false
                Break
            End If
        End For
        
        If match:
            Return i
        End If
    End For
    
    Return -1

Process called "import_module_definitions" that takes table as SymbolTable, module_path as String returns Boolean:
    @Implementation
    Imports symbols from a module file.
    Creates a module scope and imports exported symbols.
    @End Implementation
    
    Note: Extract module name from path
    Let last_slash be find_last_char(module_path, 47)  Note: Forward slash
    Let module_name be module_path
    If last_slash not equals -1:
        Set module_name to substring(module_path, last_slash + 1, StringPrimitive.length(module_path))
    End If
    
    Note: Remove file extension if present
    Let dot_index be find_last_char(module_name, 46)  Note: Dot
    If dot_index not equals -1:
        Set module_name to substring(module_name, 0, dot_index)
    End If
    
    Note: Create module symbol
    Let module_symbol be Symbol with
        symbol_id as "module_" + module_name + "_" + generate_unique_id(),
        symbol_name as module_name,
        symbol_type as "module",
        data_type as "module",
        scope_id as table.current_scope,
        position as Dictionary[String, Integer],
        is_mutable as false,
        visibility as "public",
        attributes as Dictionary[String, String],
        references as List[Dictionary[String, Integer]]
    End Symbol
    
    Set module_symbol.attributes["path"] to module_path
    
    Note: Define module symbol
    Let defined be define_symbol(table, module_symbol)
    
    Note: Create module scope for imported symbols
    Let module_scope_id be "scope_module_" + module_symbol.symbol_id
    Let module_scope be Scope with
        scope_id as module_scope_id,
        scope_type as "module",
        parent_scope as table.current_scope,
        child_scopes as List[String],
        symbols as Dictionary[String, Symbol],
        scope_depth as 1,
        is_function_scope as false,
        is_block_scope as false
    End Scope
    
    Note: Store module scope
    store_scope(table, module_scope)
    
    Return defined

Process called "find_last_char" that takes text as String, char_code as Integer returns Integer:
    @Implementation
    Finds the last occurrence of a character in a string.
    @End Implementation
    
    Let length be StringPrimitive.length(text)
    
    For i from (length - 1) down to 0:
        If StringPrimitive.char_at(text, i) equals char_code:
            Return i
        End If
    End For
    
    Return -1

Process called "clone_symbol_table" that takes table as SymbolTable returns SymbolTable:
    @Implementation
    Creates a deep copy of the symbol table.
    Useful for speculative compilation and rollback scenarios.
    @End Implementation
    
    Note: Create new symbol table
    Let cloned be create_symbol_table(table.table_id + "_clone")
    
    Note: Copy statistics
    For Each key in Dictionary.keys(table.statistics):
        Set cloned.statistics[key] to table.statistics[key]
    End For
    
    Note: Copy built-in symbols (reference copy, as they're immutable)
    For Each key in Dictionary.keys(table.builtin_symbols):
        Set cloned.builtin_symbols[key] to table.builtin_symbols[key]
    End For
    
    Note: Deep copy scope hierarchy
    Set cloned.root_scope to clone_scope(table.root_scope)
    
    Note: Clone scope registry
    For Each scope_id in Dictionary.keys(table.scope_registry):
        Let original_scope be table.scope_registry[scope_id]
        Set cloned.scope_registry[scope_id] to clone_scope(original_scope)
    End For
    
    Note: Copy current scope and stack
    Set cloned.current_scope to table.current_scope
    
    List.clear(cloned.scope_stack)
    For Each scope_id in table.scope_stack:
        List.add(cloned.scope_stack, scope_id)
    End For
    
    Note: Deep copy global symbols
    For Each name in Dictionary.keys(table.global_symbols):
        Set cloned.global_symbols[name] to clone_symbol(table.global_symbols[name])
    End For
    
    Return cloned

Process called "clone_scope" that takes scope as Scope returns Scope:
    @Implementation
    Creates a deep copy of a scope.
    @End Implementation
    
    Let cloned be Scope with
        scope_id as scope.scope_id,
        scope_type as scope.scope_type,
        parent_scope as scope.parent_scope,
        child_scopes as List[String],
        symbols as Dictionary[String, Symbol],
        scope_depth as scope.scope_depth,
        is_function_scope as scope.is_function_scope,
        is_block_scope as scope.is_block_scope
    End Scope
    
    Note: Copy child scope IDs
    For Each child_id in scope.child_scopes:
        List.add(cloned.child_scopes, child_id)
    End For
    
    Note: Deep copy symbols
    For Each name in Dictionary.keys(scope.symbols):
        Set cloned.symbols[name] to clone_symbol(scope.symbols[name])
    End For
    
    Return cloned

Process called "clone_symbol" that takes symbol as Symbol returns Symbol:
    @Implementation
    Creates a deep copy of a symbol.
    @End Implementation
    
    Let cloned be Symbol with
        symbol_id as symbol.symbol_id,
        symbol_name as symbol.symbol_name,
        symbol_type as symbol.symbol_type,
        data_type as symbol.data_type,
        scope_id as symbol.scope_id,
        position as Dictionary[String, Integer],
        is_mutable as symbol.is_mutable,
        visibility as symbol.visibility,
        attributes as Dictionary[String, String],
        references as List[Dictionary[String, Integer]]
    End Symbol
    
    Note: Copy position
    For Each key in Dictionary.keys(symbol.position):
        Set cloned.position[key] to symbol.position[key]
    End For
    
    Note: Copy attributes
    For Each key in Dictionary.keys(symbol.attributes):
        Set cloned.attributes[key] to symbol.attributes[key]
    End For
    
    Note: Copy references
    For Each ref in symbol.references:
        Let ref_copy be Dictionary[String, Integer]
        For Each key in Dictionary.keys(ref):
            Set ref_copy[key] to ref[key]
        End For
        List.add(cloned.references, ref_copy)
    End For
    
    Return cloned

Process called "merge_symbol_tables" that takes table1 as SymbolTable, table2 as SymbolTable returns SymbolTable:
    @Implementation
    Merges two symbol tables with conflict resolution.
    Table1 symbols take precedence in conflicts.
    @End Implementation
    
    Note: Clone table1 as base for merging
    Let merged be clone_symbol_table(table1)
    
    Note: Merge global symbols from table2
    For Each name in Dictionary.keys(table2.global_symbols):
        If not Dictionary.contains_key(merged.global_symbols, name):
            Let symbol be clone_symbol(table2.global_symbols[name])
            Set merged.global_symbols[name] to symbol
            
            Note: Add to root scope if appropriate
            If not Dictionary.contains_key(merged.root_scope.symbols, name):
                Set merged.root_scope.symbols[name] to symbol
            End If
        End If
    End For
    
    Note: Merge statistics
    Set merged.statistics["merged_from_table2"] to Dictionary.size(table2.global_symbols)
    
    Return merged

Note: =====================================================================
Note: ADDITIONAL HELPER FUNCTIONS
Note: =====================================================================

Process called "is_primitive_type" that takes type_name as String returns Boolean:
    @Implementation
    Checks if a type name is a primitive/built-in type.
    @End Implementation
    
    Match type_name:
        When "Integer": Return true
        When "Float": Return true
        When "String": Return true
        When "Boolean": Return true
        When "Nothing": Return true
        When "Any": Return true
        When "Byte": Return true
        When "Char": Return true
        Otherwise: Return false
    End Match

Process called "string_to_integer" that takes str as String returns Integer:
    @Implementation
    Converts a string to an integer.
    @End Implementation
    
    Let result be 0
    Let length be StringPrimitive.length(str)
    Let is_negative be false
    Let start_index be 0
    
    If length equals 0:
        Return 0
    End If
    
    Note: Check for negative sign
    If StringPrimitive.char_at(str, 0) equals 45:  Note: Minus sign
        Set is_negative to true
        Set start_index to 1
    End If
    
    For i from start_index to (length - 1):
        Let char_code be StringPrimitive.char_at(str, i)
        Let digit be char_code - 48  Note: Convert ASCII to digit
        
        If digit is less than 0 or digit is greater than 9:
            Return result  Note: Invalid character, return what we have
        End If
        
        Set result to (result * 10) + digit
    End For
    
    If is_negative:
        Set result to 0 - result
    End If
    
    Return result

Process called "extract_type_dependencies" that takes text as String, dependencies as List[String] returns Nothing:
    @Implementation
    Extracts type names from text and adds them to dependencies list.
    Parses type expressions to find all referenced types.
    @End Implementation
    
    Note: Parse all type patterns comprehensively
    Let text_length be StringPrimitive.length(text)
    Let pos be 0
    
    While pos is less than text_length:
        Note: Check for List type
        If check_and_extract_type_at_position(text, pos, "List[", 5, dependencies):
            Set pos to find_next_type_position(text, pos)
            Continue
        End If
        
        Note: Check for Dictionary type
        If pos + 11 is less than or equal to text_length:
            Let dict_check be substring(text, pos, pos + 11)
            If string_equals(dict_check, "Dictionary["):
                Let bracket_end be find_matching_bracket(text, pos + 10)
                If bracket_end not equals -1:
                    Let inner_types be substring(text, pos + 11, bracket_end)
                    parse_dictionary_types(inner_types, dependencies)
                    Set pos to bracket_end + 1
                    Continue
                End If
            End If
        End If
        
        Note: Check for Optional type
        If check_and_extract_type_at_position(text, pos, "Optional[", 9, dependencies):
            Set pos to find_next_type_position(text, pos)
            Continue
        End If
        
        Note: Check for Array type  
        If check_and_extract_type_at_position(text, pos, "Array[", 6, dependencies):
            Set pos to find_next_type_position(text, pos)
            Continue
        End If
        
        Note: Check for Set type
        If check_and_extract_type_at_position(text, pos, "Set[", 4, dependencies):
            Set pos to find_next_type_position(text, pos)
            Continue
        End If
        
        Note: Check for plain type names
        Let type_name be extract_plain_type_at_position(text, pos)
        If StringPrimitive.length(type_name) is greater than 0:
            If not is_primitive_type(type_name) and not is_in_list(dependencies, type_name):
                List.add(dependencies, type_name)
            End If
            Set pos to pos + StringPrimitive.length(type_name)
            Continue
        End If
        
        Set pos to pos + 1
    End While

Process called "check_and_extract_type_at_position" that takes text as String, pos as Integer, type_prefix as String, prefix_length as Integer, dependencies as List[String] returns Boolean:
    @Implementation
    Checks for a specific type pattern at position and extracts inner type.
    @End Implementation
    
    Let text_length be StringPrimitive.length(text)
    
    If pos + prefix_length is greater than text_length:
        Return false
    End If
    
    Let check_text be substring(text, pos, pos + prefix_length)
    If not string_equals(check_text, type_prefix):
        Return false
    End If
    
    Let bracket_pos be pos + prefix_length - 1
    Let bracket_end be find_matching_bracket(text, bracket_pos)
    
    If bracket_end equals -1:
        Return false
    End If
    
    Let inner_type be substring(text, bracket_pos + 1, bracket_end)
    Let trimmed be trim_string(inner_type)
    
    If StringPrimitive.length(trimmed) is greater than 0:
        If not is_primitive_type(trimmed) and not is_in_list(dependencies, trimmed):
            List.add(dependencies, trimmed)
        End If
    End If
    
    Return true

Process called "parse_dictionary_types" that takes inner_types as String, dependencies as List[String] returns Nothing:
    @Implementation
    Parses key and value types from Dictionary type specification.
    @End Implementation
    
    Let comma_index be find_string_index(inner_types, ", ")
    
    If comma_index not equals -1:
        Let key_type be substring(inner_types, 0, comma_index)
        Let value_type be substring(inner_types, comma_index + 2, StringPrimitive.length(inner_types))
        
        Let key_trimmed be trim_string(key_type)
        Let value_trimmed be trim_string(value_type)
        
        If not is_primitive_type(key_trimmed) and not is_in_list(dependencies, key_trimmed):
            List.add(dependencies, key_trimmed)
        End If
        
        If not is_primitive_type(value_trimmed) and not is_in_list(dependencies, value_trimmed):
            List.add(dependencies, value_trimmed)
        End If
    Otherwise:
        Let trimmed be trim_string(inner_types)
        If not is_primitive_type(trimmed) and not is_in_list(dependencies, trimmed):
            List.add(dependencies, trimmed)
        End If
    End If

Process called "extract_plain_type_at_position" that takes text as String, pos as Integer returns String:
    @Implementation
    Extracts a plain type name starting at the given position.
    @End Implementation
    
    Let text_length be StringPrimitive.length(text)
    
    If pos is greater than or equal to text_length:
        Return ""
    End If
    
    Let first_char be StringPrimitive.char_at(text, pos)
    
    Note: Check if starts with uppercase letter (type names)
    If first_char is less than 65 or first_char is greater than 90:
        Return ""
    End If
    
    Let end_pos be pos + 1
    While end_pos is less than text_length:
        Let char_code be StringPrimitive.char_at(text, end_pos)
        
        Note: Continue if alphanumeric or underscore
        If (char_code is greater than or equal to 65 and char_code is less than or equal to 90) or
           (char_code is greater than or equal to 97 and char_code is less than or equal to 122) or
           (char_code is greater than or equal to 48 and char_code is less than or equal to 57) or
           char_code equals 95:
            Set end_pos to end_pos + 1
        Otherwise:
            Break
        End If
    End While
    
    Return substring(text, pos, end_pos)

Process called "find_next_type_position" that takes text as String, current_pos as Integer returns Integer:
    @Implementation
    Finds the next position to check for types after processing current type.
    @End Implementation
    
    Let text_length be StringPrimitive.length(text)
    Let pos be current_pos
    
    Note: Skip past current type construct
    While pos is less than text_length:
        Let char_code be StringPrimitive.char_at(text, pos)
        
        Note: Stop at potential type boundary characters
        If char_code equals 44 or char_code equals 59 or char_code equals 32 or char_code equals 10:
            Return pos + 1
        End If
        
        Note: Skip past brackets
        If char_code equals 91:  Note: Opening bracket
            Let closing be find_matching_bracket(text, pos)
            If closing not equals -1:
                Set pos to closing + 1
                Continue
            End If
        End If
        
        Set pos to pos + 1
    End While
    
    Return pos

Process called "is_in_list" that takes list as List[String], item as String returns Boolean:
    @Implementation
    Checks if an item is already in the list.
    @End Implementation
    
    For Each element in list:
        If string_equals(element, item):
            Return true
        End If
    End For
    
    Return false

Process called "find_matching_bracket" that takes text as String, start_pos as Integer returns Integer:
    @Implementation
    Finds the matching closing bracket for an opening bracket.
    @End Implementation
    
    Let depth be 1
    Let length be StringPrimitive.length(text)
    
    For i from (start_pos + 1) to (length - 1):
        Let char_code be StringPrimitive.char_at(text, i)
        
        If char_code equals 91:  Note: Opening bracket [
            Set depth to depth + 1
        Otherwise char_code equals 93:  Note: Closing bracket ]
            Set depth to depth - 1
            If depth equals 0:
                Return i
            End If
        End If
    End For
    
    Return -1

Process called "string_equals" that takes str1 as String, str2 as String returns Boolean:
    @Implementation
    Checks if two strings are equal.
    @End Implementation
    
    Let len1 be StringPrimitive.length(str1)
    Let len2 be StringPrimitive.length(str2)
    
    If len1 not equals len2:
        Return false
    End If
    
    For i from 0 to (len1 - 1):
        If StringPrimitive.char_at(str1, i) not equals StringPrimitive.char_at(str2, i):
            Return false
        End If
    End For
    
    Return true

Process called "string_starts_with" that takes text as String, prefix as String returns Boolean:
    @Implementation
    Checks if a string starts with a given prefix.
    @End Implementation
    
    Let text_len be StringPrimitive.length(text)
    Let prefix_len be StringPrimitive.length(prefix)
    
    If prefix_len is greater than text_len:
        Return false
    End If
    
    For i from 0 to (prefix_len - 1):
        If StringPrimitive.char_at(text, i) not equals StringPrimitive.char_at(prefix, i):
            Return false
        End If
    End For
    
    Return true

Process called "string_ends_with" that takes text as String, suffix as String returns Boolean:
    @Implementation
    Checks if a string ends with a given suffix.
    @End Implementation
    
    Let text_len be StringPrimitive.length(text)
    Let suffix_len be StringPrimitive.length(suffix)
    
    If suffix_len is greater than text_len:
        Return false
    End If
    
    Let start_pos be text_len - suffix_len
    
    For i from 0 to (suffix_len - 1):
        If StringPrimitive.char_at(text, start_pos + i) not equals StringPrimitive.char_at(suffix, i):
            Return false
        End If
    End For
    
    Return true

Process called "count_all_symbols" that takes table as SymbolTable returns Integer:
    @Implementation
    Counts all symbols across all scopes.
    @End Implementation
    
    Let count be Dictionary.size(table.builtin_symbols)
    Set count to count + Dictionary.size(table.global_symbols)
    
    Note: Count symbols in all scopes
    Set count to count + count_scope_symbols_recursive(table.root_scope, table)
    
    Return count

Process called "count_scope_symbols_recursive" that takes scope as Scope, table as SymbolTable returns Integer:
    @Implementation
    Recursively counts symbols in a scope and its children.
    @End Implementation
    
    Let count be Dictionary.size(scope.symbols)
    
    Note: Recursively count symbols in child scopes
    For Each child_id in scope.child_scopes:
        Let child_scope be get_scope_by_id(table, child_id)
        If child_scope not equals null:
            Set count to count + count_scope_symbols_recursive(child_scope, table)
        End If
    End For
    
    Return count

Process called "count_symbols_by_type" that takes table as SymbolTable, type_counts as Dictionary[String, Integer] returns Nothing:
    @Implementation
    Counts symbols grouped by their type.
    @End Implementation
    
    Note: Count built-in symbols
    For Each name in Dictionary.keys(table.builtin_symbols):
        Let symbol be table.builtin_symbols[name]
        Let current_count be Dictionary.get_or_default(type_counts, symbol.symbol_type, 0)
        Set type_counts[symbol.symbol_type] to current_count + 1
    End For
    
    Note: Count all other symbols
    count_symbols_by_type_recursive(table.root_scope, type_counts, table)

Process called "count_symbols_by_type_recursive" that takes scope as Scope, type_counts as Dictionary[String, Integer], table as SymbolTable returns Nothing:
    @Implementation
    Recursively counts symbols by type in scope hierarchy.
    @End Implementation
    
    For Each name in Dictionary.keys(scope.symbols):
        Let symbol be scope.symbols[name]
        Let current_count be Dictionary.get_or_default(type_counts, symbol.symbol_type, 0)
        Set type_counts[symbol.symbol_type] to current_count + 1
    End For
    
    Note: Recursively count in child scopes
    For Each child_id in scope.child_scopes:
        Let child_scope be get_scope_by_id(table, child_id)
        If child_scope not equals null:
            count_symbols_by_type_recursive(child_scope, type_counts, table)
        End If
    End For

Process called "collect_all_symbols" that takes table as SymbolTable, result_list as List[Symbol] returns Nothing:
    @Implementation
    Collects all symbols from the symbol table.
    @End Implementation
    
    Note: Add built-in symbols
    For Each name in Dictionary.keys(table.builtin_symbols):
        List.add(result_list, table.builtin_symbols[name])
    End For
    
    Note: Add all scope symbols
    collect_scope_symbols_recursive(table.root_scope, result_list, table)

Process called "collect_scope_symbols_recursive" that takes scope as Scope, result_list as List[Symbol], table as SymbolTable returns Nothing:
    @Implementation
    Recursively collects symbols from scope hierarchy.
    @End Implementation
    
    For Each name in Dictionary.keys(scope.symbols):
        List.add(result_list, scope.symbols[name])
    End For
    
    Note: Recursively collect from child scopes
    For Each child_id in scope.child_scopes:
        Let child_scope be get_scope_by_id(table, child_id)
        If child_scope not equals null:
            collect_scope_symbols_recursive(child_scope, result_list, table)
        End If
    End For

Process called "is_valid_symbol_type" that takes symbol_type as String returns Boolean:
    @Implementation
    Checks if a symbol type is valid.
    @End Implementation
    
    Match symbol_type:
        When "variable": Return true
        When "function": Return true
        When "type": Return true
        When "constant": Return true
        When "parameter": Return true
        When "module": Return true
        Otherwise: Return false
    End Match

Process called "export_scope_hierarchy" that takes scope as Scope, indent_level as Integer, table as SymbolTable returns String:
    @Implementation
    Exports the scope hierarchy as a string.
    @End Implementation
    
    Let output be ""
    
    Note: Add indentation
    For i from 0 to (indent_level - 1):
        Set output to output + "  "
    End For
    
    Set output to output + "- " + scope.scope_id + " (" + scope.scope_type + ")\n"
    
    Note: Recursively export child scopes
    For Each child_id in scope.child_scopes:
        Let child_scope be get_scope_by_id(table, child_id)
        If child_scope not equals null:
            Set output to output + export_scope_hierarchy(child_scope, indent_level + 1, table)
        End If
    End For
    
    Return output

Process called "boolean_to_string" that takes value as Boolean returns String:
    @Implementation
    Converts a boolean to string representation.
    @End Implementation
    
    If value:
        Return "true"
    Otherwise:
        Return "false"
    End If

Process called "split_string_lines" that takes text as String returns List[String]:
    @Implementation
    Splits a string into lines.
    @End Implementation
    
    Let lines be List[String]
    Let current_line be ""
    Let length be StringPrimitive.length(text)
    
    For i from 0 to (length - 1):
        Let char_code be StringPrimitive.char_at(text, i)
        
        If char_code equals 10:  Note: Newline
            List.add(lines, current_line)
            Set current_line to ""
        Otherwise:
            If char_code not equals 13:  Note: Skip carriage return
                Let char_str be char_code_to_string(char_code)
                Set current_line to current_line + char_str
            End If
        End If
    End For
    
    Note: Add last line if not empty
    If StringPrimitive.length(current_line) is greater than 0:
        List.add(lines, current_line)
    End If
    
    Return lines

Process called "char_code_to_string" that takes char_code as Integer returns String:
    @Implementation
    Converts a character code to a single-character string.
    @End Implementation
    
    Let result be StringPrimitive.allocate(1)
    StringPrimitive.set_char_at(result, 0, char_code)
    StringPrimitive.set_length(result, 1)
    Return result

Process called "reset_symbol_table" that takes table as SymbolTable returns Boolean:
    @Implementation
    Resets the symbol table to its initial state, preserving only built-in symbols.
    Clears all user-defined symbols and resets scope to root.
    @End Implementation
    
    Note: Clear all user-defined symbols
    Dictionary.clear(table.global_symbols)
    Dictionary.clear(table.root_scope.symbols)
    
    Note: Clear child scopes
    List.clear(table.root_scope.child_scopes)
    
    Note: Reset scope stack
    List.clear(table.scope_stack)
    List.add(table.scope_stack, table.root_scope.scope_id)
    
    Note: Reset current scope to root
    Set table.current_scope to table.root_scope.scope_id
    
    Note: Clear symbol history
    List.clear(table.suggestion_history)
    
    Note: Reset statistics
    Set table.statistics["total_symbols"] to 0
    Set table.statistics["total_scopes"] to 1
    Set table.statistics["max_scope_depth"] to 0
    Set table.statistics["total_lookups"] to 0
    Set table.statistics["total_definitions"] to 0
    
    Return true

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "generate_unique_id" returns String:
    @Implementation
    Generates a unique identifier using timestamp and counter.
    Ensures uniqueness across the compilation session.
    @End Implementation
    
    Note: Use timestamp and counter for uniqueness
    Let timestamp be get_current_timestamp()
    Let counter be get_and_increment_counter()
    
    Return integer_to_string(timestamp) + "_" + integer_to_string(counter)

Process called "get_current_timestamp" returns Integer:
    @Implementation
    Returns current Unix timestamp in microseconds for unique ID generation.
    Uses system time for proper timestamp values.
    @End Implementation
    
    Note: Get system time in microseconds
    Let seconds be 0
    Let microseconds be 0
    
    Inline Assembly:
        "mov rax, 96\n"           Note: sys_gettimeofday syscall
        "sub rsp, 16\n"           Note: Allocate timeval struct on stack
        "mov rdi, rsp\n"          Note: timeval pointer
        "xor rsi, rsi\n"          Note: NULL timezone
        "syscall\n"               Note: Get current time
        "mov %0, qword ptr [rsp]\n"   Note: Get seconds
        "mov %1, qword ptr [rsp+8]\n" Note: Get microseconds
        "add rsp, 16\n"           Note: Clean up stack
        : "=r"(seconds), "=r"(microseconds)
        :
        : "rax", "rdi", "rsi", "memory"
    End Assembly
    
    Note: Convert to microseconds timestamp
    Let timestamp be (seconds * 1000000) + microseconds
    Return timestamp

Process called "get_and_increment_counter" returns Integer:
    @Implementation
    Returns and increments a global counter for ID generation.
    @End Implementation
    
    Static id_counter as Integer is 0
    Set id_counter to id_counter + 1
    Return id_counter

Process called "integer_to_string" that takes value as Integer returns String:
    @Implementation
    Converts integer to string representation.
    @End Implementation
    
    If value equals 0:
        Return "0"
    End If
    
    Let result be ""
    Let working_value be value
    Let is_negative be false
    
    If working_value is less than 0:
        Set is_negative to true
        Set working_value to 0 - working_value
    End If
    
    While working_value is greater than 0:
        Let digit be working_value mod 10
        Let digit_char be convert_digit_to_char(digit)
        Set result to digit_char + result
        Set working_value to working_value / 10
    End While
    
    If is_negative:
        Set result to "-" + result
    End If
    
    Return result

Process called "convert_digit_to_char" that takes digit as Integer returns String:
    @Implementation
    Converts a single digit (0-9) to its character representation.
    @End Implementation
    
    Match digit:
        When 0: Return "0"
        When 1: Return "1"
        When 2: Return "2"
        When 3: Return "3"
        When 4: Return "4"
        When 5: Return "5"
        When 6: Return "6"
        When 7: Return "7"
        When 8: Return "8"
        When 9: Return "9"
        Otherwise: Return "?"
    End Match

Process called "create_builtin_type_symbol" that takes name as String, type_category as String returns Symbol:
    @Implementation
    Creates a built-in type symbol for primitive types.
    @End Implementation
    
    Let symbol be Symbol with
        symbol_id as "builtin_" + name,
        symbol_name as name,
        symbol_type as "type",
        data_type as type_category,
        scope_id as "builtin",
        position as Dictionary[String, Integer],
        is_mutable as false,
        visibility as "public",
        attributes as Dictionary[String, String],
        references as List[Dictionary[String, Integer]]
    End Symbol
    
    Note: Set built-in attribute
    Set symbol.attributes["builtin"] to "true"
    Set symbol.attributes["category"] to type_category
    
    Return symbol

Process called "create_builtin_constant_symbol" that takes name as String, data_type as String, value as String returns Symbol:
    @Implementation
    Creates a built-in constant symbol.
    @End Implementation
    
    Let symbol be Symbol with
        symbol_id as "builtin_" + name,
        symbol_name as name,
        symbol_type as "constant",
        data_type as data_type,
        scope_id as "builtin",
        position as Dictionary[String, Integer],
        is_mutable as false,
        visibility as "public",
        attributes as Dictionary[String, String],
        references as List[Dictionary[String, Integer]]
    End Symbol
    
    Note: Set built-in attributes
    Set symbol.attributes["builtin"] to "true"
    Set symbol.attributes["value"] to value
    
    Return symbol

Process called "get_scope_by_id" that takes table as SymbolTable, scope_id as String returns Scope:
    @Implementation
    Retrieves a scope by its ID from the symbol table's scope registry.
    @End Implementation
    
    Note: Look up scope in registry
    If Dictionary.contains_key(table.scope_registry, scope_id):
        Return table.scope_registry[scope_id]
    End If
    
    Return null

Process called "find_scope_recursive" that takes parent_scope as Scope, target_id as String returns Scope:
    @Implementation
    Legacy function for backward compatibility. Use get_scope_by_id instead.
    @End Implementation
    
    Note: This function is deprecated - scopes are now in registry
    Return null

Process called "store_scope" that takes table as SymbolTable, scope as Scope returns Nothing:
    @Implementation
    Stores a scope in the symbol table's scope registry.
    @End Implementation
    
    Note: Add scope to registry
    Set table.scope_registry[scope.scope_id] to scope

Process called "find_string_index" that takes text as String, substring as String returns Integer:
    @Implementation
    Finds the index of a substring within a string.
    Returns -1 if not found.
    @End Implementation
    
    Let text_length be StringPrimitive.length(text)
    Let sub_length be StringPrimitive.length(substring)
    
    If sub_length is greater than text_length:
        Return -1
    End If
    
    For i from 0 to (text_length - sub_length):
        Let match be true
        For j from 0 to (sub_length - 1):
            If StringPrimitive.char_at(text, i + j) not equals StringPrimitive.char_at(substring, j):
                Set match to false
                Break
            End If
        End For
        
        If match:
            Return i
        End If
    End For
    
    Return -1

Process called "substring" that takes text as String, start as Integer, end as Integer returns String:
    @Implementation
    Extracts a substring from start index to end index.
    @End Implementation
    
    Let length be end - start
    Let result be StringPrimitive.allocate(length)
    
    For i from 0 to (length - 1):
        Let char_code be StringPrimitive.char_at(text, start + i)
        StringPrimitive.set_char_at(result, i, char_code)
    End For
    
    StringPrimitive.set_length(result, length)
    Return result

Process called "find_symbols_by_type_recursive" that takes scope as Scope, symbol_type as String, result_list as List[Symbol], table as SymbolTable returns Nothing:
    @Implementation
    Recursively searches for symbols of a specific type in scope hierarchy.
    @End Implementation
    
    Note: Search symbols in current scope
    For Each name in Dictionary.keys(scope.symbols):
        Let symbol be scope.symbols[name]
        If symbol.symbol_type equals symbol_type:
            List.add(result_list, symbol)
        End If
    End For
    
    Note: Recursively search child scopes
    For Each child_id in scope.child_scopes:
        Let child_scope be get_scope_by_id(table, child_id)
        If child_scope not equals null:
            find_symbols_by_type_recursive(child_scope, symbol_type, result_list, table)
        End If
    End For

Process called "is_child_scope" that takes table as SymbolTable, potential_child as String, potential_parent as String returns Boolean:
    @Implementation
    Checks if one scope is a descendant of another scope.
    @End Implementation
    
    Let current_scope_id be potential_child
    
    While StringPrimitive.length(current_scope_id) is greater than 0:
        If current_scope_id equals potential_parent:
            Return true
        End If
        
        Let scope be get_scope_by_id(table, current_scope_id)
        If scope equals null:
            Return false
        End If
        
        Set current_scope_id to scope.parent_scope
    End While
    
    Return false

Process called "trim_string" that takes text as String returns String:
    @Implementation
    Removes leading and trailing whitespace from a string.
    @End Implementation
    
    Let length be StringPrimitive.length(text)
    If length equals 0:
        Return text
    End If
    
    Note: Find first non-whitespace character
    Let start be 0
    While start is less than length:
        Let char_code be StringPrimitive.char_at(text, start)
        If char_code not equals 32 and char_code not equals 9:  Note: Not space or tab
            Break
        End If
        Set start to start + 1
    End While
    
    Note: Find last non-whitespace character
    Let end be length - 1
    While end is greater than or equal to start:
        Let char_code be StringPrimitive.char_at(text, end)
        If char_code not equals 32 and char_code not equals 9:
            Break
        End If
        Set end to end - 1
    End While
    
    Note: Extract trimmed substring
    If start is greater than end:
        Return ""
    End If
    
    Return substring(text, start, end + 1)

Process called "parse_parameter_list" that takes params_text as String, parameters as List[String] returns Nothing:
    @Implementation
    Parses comma-separated parameter list from natural language.
    @End Implementation
    
    Let current_start be 0
    Let text_length be StringPrimitive.length(params_text)
    
    For i from 0 to text_length:
        If i equals text_length or StringPrimitive.char_at(params_text, i) equals 44:  Note: Comma
            Let param be substring(params_text, current_start, i)
            Let param_trimmed be trim_string(param)
            If StringPrimitive.length(param_trimmed) is greater than 0:
                List.add(parameters, param_trimmed)
            End If
            Set current_start to i + 1
        End If
    End For

Process called "map_technical_type" that takes technical_type as String returns String:
    @Implementation
    Maps technical syntax types to Runa types.
    @End Implementation
    
    Match technical_type:
        When "int": Return "Integer"
        When "float": Return "Float"
        When "double": Return "Float"
        When "string": Return "String"
        When "bool": Return "Boolean"
        When "boolean": Return "Boolean"
        When "void": Return "Nothing"
        When "any": Return "Any"
        Otherwise: Return technical_type
    End Match

Process called "parse_technical_parameters" that takes params_text as String, parameters as List[String] returns Nothing:
    @Implementation
    Parses technical syntax parameters (name: type, name2: type2).
    @End Implementation
    
    Let current_start be 0
    Let text_length be StringPrimitive.length(params_text)
    
    For i from 0 to text_length:
        If i equals text_length or StringPrimitive.char_at(params_text, i) equals 44:  Note: Comma
            Let param be substring(params_text, current_start, i)
            Let param_trimmed be trim_string(param)
            
            Note: Parse "name: type" format
            Let colon_index be find_string_index(param_trimmed, ": ")
            If colon_index not equals -1:
                Let param_name be substring(param_trimmed, 0, colon_index)
                Let param_type be substring(param_trimmed, colon_index + 2, StringPrimitive.length(param_trimmed))
                Let mapped_type be map_technical_type(trim_string(param_type))
                Let full_param be trim_string(param_name) + " as " + mapped_type
                List.add(parameters, full_param)
            Otherwise:
                List.add(parameters, param_trimmed)
            End If
            
            Set current_start to i + 1
        End If
    End For