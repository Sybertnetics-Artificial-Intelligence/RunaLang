Note:
compiler/frontend/semantic/borrow_checker.runa
Memory Safety and Borrow Checking System

This module provides comprehensive borrow checking functionality including:
- Memory safety analysis for both syntax modes
- Ownership tracking and transfer validation
- Mutable and immutable borrow conflict detection
- Lifetime analysis for borrowed references
- Move semantics validation and enforcement
- Integration with Runa's memory management system
- Performance optimized borrow checking algorithms
- Comprehensive error reporting with suggestions
:End Note

Import "compiler/frontend/diagnostics/errors" as Errors
Import "compiler/frontend/semantic/symbol_table" as SymbolTable
Import "compiler/frontend/semantic/scope_analyzer" as ScopeAnalyzer

Note: =====================================================================
Note: BORROW CHECKER DATA STRUCTURES
Note: =====================================================================

Type called "OwnershipInfo":
    variable_name as String
    owner_scope as String
    ownership_type as String
    is_moved as Boolean
    move_position as Dictionary[String, Integer]
    original_declaration as Dictionary[String, Integer]

Type called "BorrowInfo":
    borrow_id as String
    borrowed_variable as String
    borrow_type as String
    borrower_scope as String
    borrow_position as Dictionary[String, Integer]
    borrow_lifetime as String
    is_active as Boolean

Type called "LifetimeInfo":
    lifetime_id as String
    lifetime_name as String
    lifetime_bounds as Dictionary[String, String]
    dependent_lifetimes as List[String]
    scope_constraints as List[String]

Type called "BorrowChecker":
    checker_id as String
    symbol_table as String
    scope_analyzer as String
    ownership_map as Dictionary[String, OwnershipInfo]
    active_borrows as List[BorrowInfo]
    lifetime_constraints as List[LifetimeInfo]
    current_mode as String
    statistics as Dictionary[String, Integer]

Note: =====================================================================
Note: BORROW CHECKER OPERATIONS
Note: =====================================================================

Process called "create_borrow_checker" that takes checker_name as String, symbol_table as String, scope_analyzer as String returns BorrowChecker:
    @Implementation
    Creates a new borrow checker with integration to symbol table and scope analyzer.
    Initializes all tracking structures for comprehensive ownership analysis.
    @End Implementation
    
    Let checker be BorrowChecker with
        checker_id as checker_name,
        symbol_table as symbol_table,
        scope_analyzer as scope_analyzer,
        ownership_map as Dictionary[String, OwnershipInfo],
        active_borrows as List[BorrowInfo],
        lifetime_constraints as List[LifetimeInfo],
        current_mode as "natural",
        statistics as Dictionary[String, Integer]
    End BorrowChecker
    
    Note: Initialize statistics
    Set checker.statistics["total_ownership_checks"] to 0
    Set checker.statistics["active_borrows"] to 0
    Set checker.statistics["lifetime_errors"] to 0
    Set checker.statistics["ownership_violations"] to 0
    Set checker.statistics["move_errors"] to 0
    Set checker.statistics["borrow_conflicts"] to 0
    
    Return checker

Process called "analyze_program_ownership" that takes checker as BorrowChecker, program_ast as String returns List[String]:
    @Implementation
    Performs comprehensive ownership analysis on the entire program AST.
    Returns list of ownership violations and borrow checking errors.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Initialize ownership tracking
    Let initialization_success be initialize_ownership_tracking(checker)
    If initialization_success equals false:
        List.add(issues, "Failed to initialize ownership tracking")
        Return issues
    End If
    
    Note: Analyze ownership for all variables in the program
    Let all_variables be extract_all_variables_from_ast(program_ast)
    For Each variable_info in all_variables:
        Let variable_name be extract_variable_name_from_info(variable_info)
        Let declaration_pos be extract_declaration_position(variable_info)
        Let tracking_success be track_variable_ownership(checker, variable_name, declaration_pos)
        If tracking_success equals false:
            List.add(issues, "Failed to track ownership for variable: " + variable_name)
        End If
    End For
    
    Note: Check all borrowing operations
    Let all_borrows be extract_all_borrows_from_ast(program_ast)
    For Each borrow_info in all_borrows:
        Let borrow_issues be check_borrow_validity(checker, borrow_info)
        For Each issue in borrow_issues:
            List.add(issues, issue)
        End For
    End For
    
    Note: Detect memory safety violations
    Let safety_violations be detect_memory_safety_violations(checker)
    For Each violation in safety_violations:
        List.add(issues, violation)
    End For
    
    Note: Update statistics
    Set checker.statistics["total_ownership_checks"] to checker.statistics["total_ownership_checks"] + 1
    Set checker.statistics["ownership_violations"] to List.length(issues)
    
    Return issues

Process called "initialize_ownership_tracking" that takes checker as BorrowChecker returns Boolean:
    @Implementation
    Initializes the ownership tracking system for comprehensive borrow checking.
    Sets up data structures and prepares for program analysis.
    @End Implementation
    
    Note: Clear any existing ownership information
    Set checker.ownership_map to Dictionary[String, OwnershipInfo]
    Set checker.active_borrows to List[BorrowInfo]
    Set checker.lifetime_constraints to List[LifetimeInfo]
    
    Note: Reset statistics
    Set checker.statistics["active_borrows"] to 0
    Set checker.statistics["lifetime_errors"] to 0
    Set checker.statistics["move_errors"] to 0
    Set checker.statistics["borrow_conflicts"] to 0
    
    Note: Initialize built-in lifetime constraints
    Let static_lifetime be LifetimeInfo with
        lifetime_id as "static",
        lifetime_name as "static",
        lifetime_bounds as Dictionary[String, String],
        dependent_lifetimes as List[String],
        scope_constraints as List[String]
    End LifetimeInfo
    List.add(checker.lifetime_constraints, static_lifetime)
    
    Return true

Note: =====================================================================
Note: OWNERSHIP ANALYSIS OPERATIONS
Note: =====================================================================

Process called "track_variable_ownership" that takes checker as BorrowChecker, variable_name as String, declaration_position as Dictionary[String, Integer] returns Boolean:
    @Implementation
    Starts tracking ownership for a newly declared variable.
    Registers the variable in the ownership map with initial ownership state.
    @End Implementation
    
    Note: Check if variable is already tracked
    If Dictionary.contains_key(checker.ownership_map, variable_name):
        Return false
    End If
    
    Note: Determine owner scope from declaration position
    Let file_name be string_cast(declaration_position["file"])
    Let line_number be declaration_position["line"]
    Let owner_scope be determine_scope_from_position(checker.scope_analyzer, file_name, line_number)
    
    Note: Create ownership information
    Let ownership_info be OwnershipInfo with
        variable_name as variable_name,
        owner_scope as owner_scope,
        ownership_type as "owned",
        is_moved as false,
        move_position as Dictionary[String, Integer],
        original_declaration as declaration_position
    End OwnershipInfo
    
    Note: Register in ownership map
    Set checker.ownership_map[variable_name] to ownership_info
    
    Return true

Process called "check_ownership_transfer" that takes checker as BorrowChecker, from_variable as String, to_variable as String, transfer_position as Dictionary[String, Integer] returns List[String]:
    @Implementation
    Checks the validity of ownership transfer between variables.
    Validates move semantics and detects ownership violations.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Check if source variable exists and is owned
    If not Dictionary.contains_key(checker.ownership_map, from_variable):
        List.add(issues, "Cannot transfer ownership from undeclared variable: " + from_variable)
        Return issues
    End If
    
    Let source_ownership be checker.ownership_map[from_variable]
    
    Note: Check if source variable has already been moved
    If source_ownership.is_moved equals true:
        List.add(issues, "Cannot transfer ownership from moved variable: " + from_variable + " (moved at line " + integer_to_string(source_ownership.move_position["line"]) + ")")
        Return issues
    End If
    
    Note: Check for active borrows on source variable
    Let active_source_borrows be find_active_borrows_for_variable(checker, from_variable)
    If List.length(active_source_borrows) greater than 0:
        List.add(issues, "Cannot move variable " + from_variable + " while it has active borrows")
        Return issues
    End If
    
    Note: Perform the ownership transfer
    Set source_ownership.is_moved to true
    Set source_ownership.move_position to transfer_position
    
    Note: Track ownership for destination variable if it's new
    If not Dictionary.contains_key(checker.ownership_map, to_variable):
        Let track_success be track_variable_ownership(checker, to_variable, transfer_position)
        If track_success equals false:
            List.add(issues, "Failed to track ownership for destination variable: " + to_variable)
        End If
    End If
    
    Note: Update statistics
    Set checker.statistics["move_errors"] to checker.statistics["move_errors"] + List.length(issues)
    
    Return issues

Process called "validate_move_semantics" that takes checker as BorrowChecker, move_expression as String returns List[String]:
    @Implementation
    Validates move semantics in assignments and function calls.
    Ensures proper ownership transfer and detects move violations.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Parse move expression to extract variables involved
    Let move_components be parse_move_expression(move_expression)
    Let source_variable be move_components["source"]
    Let destination_variable be move_components["destination"]
    Let move_position be move_components["position"]
    
    Note: Validate the ownership transfer
    Let transfer_issues be check_ownership_transfer(checker, source_variable, destination_variable, move_position)
    For Each issue in transfer_issues:
        List.add(issues, issue)
    End For
    
    Note: Check if this is an explicit move or implicit move
    Let is_explicit_move be contains_move_keyword(move_expression)
    If is_explicit_move equals false:
        Note: For implicit moves, check if the type requires move semantics
        Let source_type be get_variable_type_from_symbol_table(checker.symbol_table, source_variable)
        Let requires_move be type_requires_move_semantics(source_type)
        If requires_move equals false:
            List.add(issues, "Implicit move detected for copyable type " + source_type + ". Consider using copy semantics instead.")
        End If
    End If
    
    Note: Validate that move is allowed in current context
    Let current_scope be get_current_scope_from_position(checker.scope_analyzer, move_position)
    Let move_allowed be is_move_allowed_in_scope(checker, source_variable, current_scope)
    If move_allowed equals false:
        List.add(issues, "Move of variable " + source_variable + " not allowed in current scope context")
    End If
    
    Return issues

Process called "detect_use_after_move" that takes checker as BorrowChecker, variable_name as String, use_position as Dictionary[String, Integer] returns Boolean:
    @Implementation
    Detects attempts to use a variable after it has been moved.
    Critical for memory safety and ownership correctness.
    @End Implementation
    
    Note: Check if variable is tracked
    If not Dictionary.contains_key(checker.ownership_map, variable_name):
        Return false
    End If
    
    Let ownership_info be checker.ownership_map[variable_name]
    
    Note: Check if variable has been moved
    If ownership_info.is_moved equals false:
        Return false
    End If
    
    Note: Check if use occurs after move
    Let move_line be ownership_info.move_position["line"]
    Let use_line be use_position["line"]
    Let move_file be string_cast(ownership_info.move_position["file"])
    Let use_file be string_cast(use_position["file"])
    
    Note: Same file comparison and line number check
    If strings_equal(move_file, use_file) and use_line greater than move_line:
        Return true
    End If
    
    Note: For different files, check if use scope comes after move scope
    If not strings_equal(move_file, use_file):
        Let move_scope be determine_scope_from_position(checker.scope_analyzer, move_file, move_line)
        Let use_scope be determine_scope_from_position(checker.scope_analyzer, use_file, use_line)
        Let use_after_move be is_scope_after_scope(checker.scope_analyzer, use_scope, move_scope)
        Return use_after_move
    End If
    
    Return false

Note: =====================================================================
Note: BORROW ANALYSIS OPERATIONS
Note: =====================================================================

Process called "check_borrow_validity" that takes checker as BorrowChecker, borrow_expression as String returns List[String]:
    @Implementation
    Checks the validity of a borrowing operation.
    Validates borrow rules and detects conflicts.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Parse borrow expression
    Let borrow_info be parse_borrow_expression(borrow_expression)
    Let variable_name be borrow_info["variable"]
    Let borrow_type be borrow_info["borrow_type"]
    Let borrow_position be borrow_info["position"]
    
    Note: Check if variable exists and is owned
    If not Dictionary.contains_key(checker.ownership_map, variable_name):
        List.add(issues, "Cannot borrow undeclared variable: " + variable_name)
        Return issues
    End If
    
    Let ownership_info be checker.ownership_map[variable_name]
    
    Note: Check if variable has been moved
    If ownership_info.is_moved equals true:
        List.add(issues, "Cannot borrow moved variable: " + variable_name)
        Return issues
    End If
    
    Note: Create borrow info based on type
    Let new_borrow be BorrowInfo
    If strings_equal(borrow_type, "mutable"):
        Set new_borrow to track_mutable_borrow(checker, variable_name, borrow_position)
    Otherwise:
        Set new_borrow to track_immutable_borrow(checker, variable_name, borrow_position)
    End If
    
    Note: Check for borrow conflicts
    Let conflict_issues be detect_borrow_conflicts(checker, new_borrow)
    For Each conflict in conflict_issues:
        List.add(issues, conflict)
    End For
    
    Note: If no conflicts, add to active borrows
    If List.length(conflict_issues) equals 0:
        List.add(checker.active_borrows, new_borrow)
        Set checker.statistics["active_borrows"] to checker.statistics["active_borrows"] + 1
    End If
    
    Return issues

Process called "track_mutable_borrow" that takes checker as BorrowChecker, variable_name as String, borrow_position as Dictionary[String, Integer] returns BorrowInfo:
    @Implementation
    Creates and tracks a new mutable borrow.
    Generates unique borrow ID and registers the borrow.
    @End Implementation
    
    Note: Generate unique borrow ID
    Let borrow_count be List.length(checker.active_borrows)
    Let borrow_id be "mutable_borrow_" + variable_name + "_" + integer_to_string(borrow_count)
    
    Note: Determine borrower scope
    Let file_name be string_cast(borrow_position["file"])
    Let line_number be borrow_position["line"]
    Let borrower_scope be determine_scope_from_position(checker.scope_analyzer, file_name, line_number)
    
    Note: Infer lifetime for this borrow
    Let lifetime_info be infer_borrow_lifetime(checker, variable_name, borrower_scope)
    
    Note: Create borrow info
    Let borrow_info be BorrowInfo with
        borrow_id as borrow_id,
        borrowed_variable as variable_name,
        borrow_type as "mutable",
        borrower_scope as borrower_scope,
        borrow_position as borrow_position,
        borrow_lifetime as lifetime_info.lifetime_id,
        is_active as true
    End BorrowInfo
    
    Return borrow_info

Process called "track_immutable_borrow" that takes checker as BorrowChecker, variable_name as String, borrow_position as Dictionary[String, Integer] returns BorrowInfo:
    @Implementation
    Creates and tracks a new immutable borrow.
    Generates unique borrow ID and registers the immutable borrow.
    @End Implementation
    
    Note: Generate unique borrow ID
    Let borrow_count be List.length(checker.active_borrows)
    Let borrow_id be "immutable_borrow_" + variable_name + "_" + integer_to_string(borrow_count)
    
    Note: Determine borrower scope
    Let file_name be string_cast(borrow_position["file"])
    Let line_number be borrow_position["line"]
    Let borrower_scope be determine_scope_from_position(checker.scope_analyzer, file_name, line_number)
    
    Note: Infer lifetime for this borrow
    Let lifetime_info be infer_borrow_lifetime(checker, variable_name, borrower_scope)
    
    Note: Create borrow info
    Let borrow_info be BorrowInfo with
        borrow_id as borrow_id,
        borrowed_variable as variable_name,
        borrow_type as "immutable",
        borrower_scope as borrower_scope,
        borrow_position as borrow_position,
        borrow_lifetime as lifetime_info.lifetime_id,
        is_active as true
    End BorrowInfo
    
    Return borrow_info

Process called "detect_borrow_conflicts" that takes checker as BorrowChecker, new_borrow as BorrowInfo returns List[String]:
    @Implementation
    Detects conflicts between a new borrow and existing active borrows.
    Implements Rust-like borrow checking rules for memory safety.
    @End Implementation
    
    Let conflicts be List[String]
    
    Note: Check each active borrow for conflicts
    For Each existing_borrow in checker.active_borrows:
        Note: Skip if not the same variable
        If not strings_equal(existing_borrow.borrowed_variable, new_borrow.borrowed_variable):
            Continue
        End If
        
        Note: Check for mutable borrow conflicts
        If strings_equal(new_borrow.borrow_type, "mutable"):
            Note: Mutable borrow conflicts with any existing borrow
            List.add(conflicts, "Cannot create mutable borrow of " + new_borrow.borrowed_variable + " while " + existing_borrow.borrow_type + " borrow exists (created at line " + integer_to_string(existing_borrow.borrow_position["line"]) + ")")
        Otherwise:
            Note: Immutable borrow conflicts with existing mutable borrow
            If strings_equal(existing_borrow.borrow_type, "mutable"):
                List.add(conflicts, "Cannot create immutable borrow of " + new_borrow.borrowed_variable + " while mutable borrow exists (created at line " + integer_to_string(existing_borrow.borrow_position["line"]) + ")")
            End If
        End If
        
        Note: Check lifetime compatibility
        Let lifetimes_compatible be check_lifetime_compatibility(checker, new_borrow.borrow_lifetime, existing_borrow.borrow_lifetime)
        If lifetimes_compatible equals false:
            List.add(conflicts, "Lifetime conflict between borrows of " + new_borrow.borrowed_variable)
        End If
    End For
    
    Return conflicts

Process called "end_borrow" that takes checker as BorrowChecker, borrow_id as String, end_position as Dictionary[String, Integer] returns Boolean:
    @Implementation
    Ends an active borrow at the specified position.
    Updates borrow tracking and validates proper borrow lifecycle.
    @End Implementation
    
    Note: Find the borrow to end
    Let borrow_index be -1
    For i from 0 to (List.length(checker.active_borrows) - 1):
        Let current_borrow be checker.active_borrows[i]
        If strings_equal(current_borrow.borrow_id, borrow_id):
            Set borrow_index to i
            Break
        End If
    End For
    
    Note: Check if borrow was found
    If borrow_index equals -1:
        Return false
    End If
    
    Note: Mark borrow as inactive and remove from active list
    Let ending_borrow be checker.active_borrows[borrow_index]
    Set ending_borrow.is_active to false
    List.remove_at(checker.active_borrows, borrow_index)
    
    Note: Update statistics
    Set checker.statistics["active_borrows"] to checker.statistics["active_borrows"] - 1
    
    Return true

Note: =====================================================================
Note: LIFETIME ANALYSIS OPERATIONS
Note: =====================================================================

Process called "infer_reference_lifetimes" that takes checker as BorrowChecker, reference_expression as String returns LifetimeInfo:
    @Implementation
    Infers lifetimes from reference expressions.
    Analyzes scope and variable lifetimes to determine appropriate lifetime bounds.
    @End Implementation
    
    Note: Parse the reference expression
    Let referenced_variable be extract_referenced_variable(reference_expression)
    Let reference_position be extract_reference_position(reference_expression)
    
    Note: Determine the scope of the reference
    Let file_name be string_cast(reference_position["file"])
    Let line_number be reference_position["line"]
    Let reference_scope be determine_scope_from_position(checker.scope_analyzer, file_name, line_number)
    
    Note: Create lifetime info for this reference
    Let reference_count be List.length(checker.lifetime_constraints)
    Let lifetime_id be "ref_" + referenced_variable + "_" + integer_to_string(reference_count)
    
    Let lifetime_info be LifetimeInfo with
        lifetime_id as lifetime_id,
        lifetime_name as "'" + lifetime_id,
        lifetime_bounds as Dictionary[String, String],
        dependent_lifetimes as List[String],
        scope_constraints as List[String]
    End LifetimeInfo
    
    Note: Set bounds based on variable scope
    List.add(lifetime_info.scope_constraints, reference_scope)
    
    Note: Add to lifetime constraints
    List.add(checker.lifetime_constraints, lifetime_info)
    
    Return lifetime_info

Process called "validate_lifetime_constraints" that takes checker as BorrowChecker, constraint_set as List[LifetimeInfo] returns List[String]:
    @Implementation
    Validates a set of lifetime constraints for consistency.
    Checks for circular dependencies and impossible constraints.
    @End Implementation
    
    Let validation_errors be List[String]
    
    Note: Check each constraint for validity
    For Each constraint in constraint_set:
        Note: Check for circular dependencies
        Let has_circular_dependency be check_circular_lifetime_dependency(constraint, constraint_set)
        If has_circular_dependency equals true:
            List.add(validation_errors, "Circular lifetime dependency detected in " + constraint.lifetime_name)
        End If
        
        Note: Check if all dependent lifetimes exist
        For Each dependent_lifetime in constraint.dependent_lifetimes:
            Let dependent_exists be lifetime_exists_in_set(dependent_lifetime, constraint_set)
            If dependent_exists equals false:
                List.add(validation_errors, "Undefined lifetime dependency: " + dependent_lifetime + " in " + constraint.lifetime_name)
            End If
        End For
        
        Note: Check scope constraint validity
        For Each scope_constraint in constraint.scope_constraints:
            Let scope_valid be validate_scope_exists(checker.scope_analyzer, scope_constraint)
            If scope_valid equals false:
                List.add(validation_errors, "Invalid scope constraint: " + scope_constraint + " in " + constraint.lifetime_name)
            End If
        End For
    End For
    
    Return validation_errors

Process called "check_lifetime_outlives" that takes checker as BorrowChecker, lifetime1 as String, lifetime2 as String returns Boolean:
    @Implementation
    Checks if lifetime1 outlives lifetime2.
    Analyzes scope relationships and lifetime bounds.
    @End Implementation
    
    Note: Handle static lifetime
    If strings_equal(lifetime1, "static"):
        Return true
    End If
    If strings_equal(lifetime2, "static"):
        Return false
    End If
    
    Note: Find lifetime constraints for both lifetimes
    Let lifetime1_constraint be find_lifetime_constraint(checker, lifetime1)
    Let lifetime2_constraint be find_lifetime_constraint(checker, lifetime2)
    
    Note: If either constraint not found, cannot determine relationship
    If lifetime1_constraint equals null or lifetime2_constraint equals null:
        Return false
    End If
    
    Note: Check scope-based outliving
    For Each scope1 in lifetime1_constraint.scope_constraints:
        For Each scope2 in lifetime2_constraint.scope_constraints:
            Let scope1_contains_scope2 be is_scope_ancestor(checker.scope_analyzer, scope1, scope2)
            If scope1_contains_scope2 equals true:
                Return true
            End If
        End For
    End For
    
    Note: Check explicit bounds
    If Dictionary.contains_key(lifetime1_constraint.lifetime_bounds, "outlives"):
        Let outlives_target be lifetime1_constraint.lifetime_bounds["outlives"]
        If strings_equal(outlives_target, lifetime2):
            Return true
        End If
    End If
    
    Return false

Process called "solve_lifetime_constraints" that takes checker as BorrowChecker, constraints as List[LifetimeInfo] returns Dictionary[String, String]:
    @Implementation
    Solves a system of lifetime constraints.
    Returns mapping of lifetime variables to their resolved values.
    @End Implementation
    
    Let solution be Dictionary[String, String]
    
    Note: Initialize all lifetime variables
    For Each constraint in constraints:
        Set solution[constraint.lifetime_id] to "unresolved"
    End For
    
    Note: Resolve constraints iteratively
    Let max_iterations be List.length(constraints) * 2
    Let iteration_count be 0
    Let changed be true
    
    While changed equals true and iteration_count less than max_iterations:
        Set changed to false
        Set iteration_count to iteration_count + 1
        
        For Each constraint in constraints:
            Note: Try to resolve this constraint
            Let current_resolution be solution[constraint.lifetime_id]
            If strings_equal(current_resolution, "unresolved"):
                Let new_resolution be attempt_constraint_resolution(constraint, solution)
                If not strings_equal(new_resolution, "unresolved"):
                    Set solution[constraint.lifetime_id] to new_resolution
                    Set changed to true
                End If
            End If
        End For
    End While
    
    Note: Mark any remaining unresolved constraints as errors
    For Each constraint in constraints:
        If strings_equal(solution[constraint.lifetime_id], "unresolved"):
            Set solution[constraint.lifetime_id] to "error_unresolvable"
        End If
    End For
    
    Return solution

Note: =====================================================================
Note: NATURAL LANGUAGE BORROW CHECKING
Note: =====================================================================

Process called "check_natural_let_borrowing" that takes checker as BorrowChecker, let_statement as String returns List[String]:
    @Implementation
    Checks borrowing rules for natural language Let statements.
    Validates borrow semantics in Runa's natural syntax.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Parse the Let statement
    Let let_components be parse_natural_let_statement(let_statement)
    Let variable_name be let_components["variable"]
    Let initialization_expr be let_components["expression"]
    Let position be let_components["position"]
    
    Note: Check if initialization involves borrowing
    Let involves_borrowing be contains_borrow_syntax(initialization_expr)
    If involves_borrowing equals false:
        Return issues
    End If
    
    Note: Extract borrow information from expression
    Let borrow_info be parse_borrow_expression(initialization_expr)
    Let borrowed_variable be borrow_info["variable"]
    Let borrow_type be borrow_info["borrow_type"]
    
    Note: Check if borrowed variable exists
    If not Dictionary.contains_key(checker.ownership_map, borrowed_variable):
        List.add(issues, "Cannot borrow undeclared variable: " + borrowed_variable + " in Let statement")
        Return issues
    End If
    
    Note: Check ownership status
    Let ownership_info be checker.ownership_map[borrowed_variable]
    If ownership_info.is_moved equals true:
        List.add(issues, "Cannot borrow moved variable: " + borrowed_variable + " in Let statement")
        Return issues
    End If
    
    Note: Create borrow tracking
    Let new_borrow be BorrowInfo
    If strings_equal(borrow_type, "mutable"):
        Set new_borrow to track_mutable_borrow(checker, borrowed_variable, position)
    Otherwise:
        Set new_borrow to track_immutable_borrow(checker, borrowed_variable, position)
    End If
    
    Note: Check for conflicts
    Let conflict_issues be detect_borrow_conflicts(checker, new_borrow)
    For Each conflict in conflict_issues:
        List.add(issues, conflict)
    End For
    
    Return issues

Process called "analyze_natural_process_ownership" that takes checker as BorrowChecker, process_definition as String returns List[String]:
    @Implementation
    Analyzes ownership patterns in natural language process definitions.
    Validates parameter borrowing and return value ownership.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Parse the process definition
    Let process_components be parse_natural_process_definition(process_definition)
    Let process_name be process_components["name"]
    Let parameters be process_components["parameters"]
    Let return_type be process_components["return_type"]
    Let process_body be process_components["body"]
    
    Note: Check parameter ownership
    For Each parameter in parameters:
        Let param_name be extract_parameter_name(parameter)
        Let param_type be extract_parameter_type(parameter)
        Let involves_borrow be parameter_involves_borrowing(parameter)
        
        If involves_borrow equals true:
            Note: Track parameter as borrowed
            Let param_position be extract_parameter_position(parameter)
            Let param_borrow_type be extract_parameter_borrow_type(parameter)
            
            Let param_borrow be BorrowInfo
            If strings_equal(param_borrow_type, "mutable"):
                Set param_borrow to track_mutable_borrow(checker, param_name, param_position)
            Otherwise:
                Set param_borrow to track_immutable_borrow(checker, param_name, param_position)
            End If
            
            Note: Check for parameter borrow conflicts
            Let param_conflicts be detect_borrow_conflicts(checker, param_borrow)
            For Each conflict in param_conflicts:
                List.add(issues, "Parameter borrow conflict: " + conflict)
            End For
        Otherwise:
            Note: Track parameter as owned
            Let param_position be extract_parameter_position(parameter)
            Let ownership_success be track_variable_ownership(checker, param_name, param_position)
            If ownership_success equals false:
                List.add(issues, "Failed to track ownership for parameter: " + param_name)
            End If
        End If
    End For
    
    Note: Analyze process body for ownership violations
    Let body_issues be analyze_process_body_ownership(checker, process_body)
    For Each body_issue in body_issues:
        List.add(issues, body_issue)
    End For
    
    Return issues

Process called "handle_natural_reference_syntax" that takes checker as BorrowChecker, natural_reference as String returns BorrowInfo:
    @Implementation
    Handles reference creation in natural language syntax.
    Parses natural reference patterns and creates appropriate borrow tracking.
    @End Implementation
    
    Note: Parse the natural reference expression
    Let reference_components be parse_natural_reference(natural_reference)
    Let referenced_variable be reference_components["variable"]
    Let reference_type be reference_components["reference_type"]
    Let reference_position be reference_components["position"]
    
    Note: Determine if this is a mutable or immutable reference
    Let is_mutable_ref be strings_equal(reference_type, "mutable")
    
    Note: Create appropriate borrow tracking
    Let borrow_info be BorrowInfo
    If is_mutable_ref equals true:
        Set borrow_info to track_mutable_borrow(checker, referenced_variable, reference_position)
    Otherwise:
        Set borrow_info to track_immutable_borrow(checker, referenced_variable, reference_position)
    End If
    
    Return borrow_info

Note: =====================================================================
Note: TECHNICAL SYNTAX BORROW CHECKING
Note: =====================================================================

Process called "check_technical_borrowing" that takes checker as BorrowChecker, technical_expression as String returns List[String]:
    @Implementation
    Checks borrowing rules for technical syntax expressions.
    Validates C-style pointer and reference operations.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Parse technical expression for borrow patterns
    Let expression_type be determine_technical_expression_type(technical_expression)
    
    Match expression_type:
        When "pointer_dereference":
            Let pointer_issues be analyze_pointer_operations(checker, technical_expression)
            For Each issue in pointer_issues:
                List.add(issues, issue)
            End For
        When "address_of":
            Let address_variable be extract_address_target(technical_expression)
            Let address_position be extract_expression_position(technical_expression)
            Let address_issues be validate_address_taking(checker, address_variable, address_position)
            For Each issue in address_issues:
                List.add(issues, issue)
            End For
        When "array_access":
            Let array_access_issues be validate_array_access_borrowing(checker, technical_expression)
            For Each issue in array_access_issues:
                List.add(issues, issue)
            End For
        When "field_access":
            Let field_issues be validate_field_access_borrowing(checker, technical_expression)
            For Each issue in field_issues:
                List.add(issues, issue)
            End For
        Otherwise:
            List.add(issues, "Unknown technical expression type for borrow checking: " + expression_type)
    End Match
    
    Return issues

Process called "analyze_pointer_operations" that takes checker as BorrowChecker, pointer_expression as String returns List[String]:
    @Implementation
    Analyzes pointer operations for memory safety violations.
    Checks pointer arithmetic, dereferencing, and null pointer access.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Parse pointer expression
    Let pointer_components be parse_pointer_expression(pointer_expression)
    Let operation_type be pointer_components["operation"]
    Let target_pointer be pointer_components["pointer"]
    Let expression_position be pointer_components["position"]
    
    Note: Check if pointer variable exists and is valid
    If not Dictionary.contains_key(checker.ownership_map, target_pointer):
        List.add(issues, "Pointer operation on undeclared variable: " + target_pointer)
        Return issues
    End If
    
    Let pointer_ownership be checker.ownership_map[target_pointer]
    
    Note: Check if pointer has been moved
    If pointer_ownership.is_moved equals true:
        List.add(issues, "Cannot perform pointer operation on moved variable: " + target_pointer)
        Return issues
    End If
    
    Note: Analyze specific pointer operations
    Match operation_type:
        When "dereference":
            Note: Check for null pointer dereference
            Let null_check_issues be check_null_pointer_dereference(checker, target_pointer, expression_position)
            For Each issue in null_check_issues:
                List.add(issues, issue)
            End For
            
            Note: Track access through pointer
            Let deref_borrow be track_immutable_borrow(checker, target_pointer, expression_position)
            Let deref_conflicts be detect_borrow_conflicts(checker, deref_borrow)
            For Each conflict in deref_conflicts:
                List.add(issues, "Pointer dereference conflict: " + conflict)
            End For
            
        When "arithmetic":
            Note: Check pointer arithmetic bounds
            Let bounds_issues be check_pointer_arithmetic_bounds(checker, pointer_expression)
            For Each issue in bounds_issues:
                List.add(issues, issue)
            End For
            
        When "assignment":
            Note: Check pointer assignment validity
            Let assignment_issues be validate_pointer_assignment(checker, pointer_expression)
            For Each issue in assignment_issues:
                List.add(issues, issue)
            End For
            
        Otherwise:
            List.add(issues, "Unknown pointer operation type: " + operation_type)
    End Match
    
    Return issues

Process called "validate_c_style_memory_access" that takes checker as BorrowChecker, memory_access as String returns List[String]:
    @Implementation
    Validates C-style memory access patterns for safety.
    Checks array bounds, pointer validity, and memory ownership.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Parse C-style memory access
    Let access_components be parse_c_style_access(memory_access)
    Let access_type be access_components["type"]
    Let target_variable be access_components["variable"]
    Let access_position be access_components["position"]
    
    Note: Check if target variable exists
    If not Dictionary.contains_key(checker.ownership_map, target_variable):
        List.add(issues, "C-style access to undeclared variable: " + target_variable)
        Return issues
    End If
    
    Let variable_ownership be checker.ownership_map[target_variable]
    
    Note: Check if variable has been moved
    If variable_ownership.is_moved equals true:
        List.add(issues, "Cannot access moved variable with C-style syntax: " + target_variable)
        Return issues
    End If
    
    Note: Validate specific access patterns
    Match access_type:
        When "array_index":
            Let index_expr be access_components["index"]
            Let bounds_issues be validate_array_bounds_access(checker, target_variable, index_expr)
            For Each issue in bounds_issues:
                List.add(issues, issue)
            End For
            
        When "struct_field":
            Let field_name be access_components["field"]
            Let field_issues be validate_struct_field_access(checker, target_variable, field_name)
            For Each issue in field_issues:
                List.add(issues, issue)
            End For
            
        When "pointer_offset":
            Let offset_expr be access_components["offset"]
            Let offset_issues be validate_pointer_offset_access(checker, target_variable, offset_expr)
            For Each issue in offset_issues:
                List.add(issues, issue)
            End For
            
        Otherwise:
            List.add(issues, "Unknown C-style memory access pattern: " + access_type)
    End Match
    
    Return issues

Note: =====================================================================
Note: MEMORY SAFETY VALIDATION
Note: =====================================================================

Process called "detect_memory_safety_violations" that takes checker as BorrowChecker returns List[String]:
    @Implementation
    Detects all memory safety violations in the program.
    Comprehensive check for use-after-move, dangling references, and double-free.
    @End Implementation
    
    Let violations be List[String]
    
    Note: Check for use-after-move violations
    For Each ownership_entry in checker.ownership_map:
        Let variable_name be ownership_entry.key
        Let ownership_info be ownership_entry.value
        
        If ownership_info.is_moved equals true:
            Note: Check if this moved variable is used anywhere
            Let usage_positions be find_variable_usage_after_move(checker, variable_name, ownership_info.move_position)
            For Each usage_pos in usage_positions:
                Let usage_line be integer_to_string(usage_pos["line"])
                List.add(violations, "Use after move: variable '" + variable_name + "' used at line " + usage_line + " after being moved")
            End For
        End If
    End For
    
    Note: Check for dangling reference violations
    Let dangling_refs be check_dangling_references(checker)
    For Each dangling_ref in dangling_refs:
        Let ref_line be integer_to_string(dangling_ref["line"])
        List.add(violations, "Dangling reference detected at line " + ref_line)
    End For
    
    Note: Check for double-free violations
    Let double_frees be detect_double_free(checker)
    For Each double_free in double_frees:
        Let free_line be integer_to_string(double_free["line"])
        List.add(violations, "Double-free detected at line " + free_line)
    End For
    
    Note: Check for borrow checker violations
    For Each active_borrow in checker.active_borrows:
        Note: Check if borrowed variable was moved while borrowed
        If Dictionary.contains_key(checker.ownership_map, active_borrow.borrowed_variable):
            Let borrowed_ownership be checker.ownership_map[active_borrow.borrowed_variable]
            If borrowed_ownership.is_moved equals true:
                Let move_line be integer_to_string(borrowed_ownership.move_position["line"])
                Let borrow_line be integer_to_string(active_borrow.borrow_position["line"])
                List.add(violations, "Variable '" + active_borrow.borrowed_variable + "' moved at line " + move_line + " while borrowed (borrow created at line " + borrow_line + ")")
            End If
        End If
    End For
    
    Return violations

Process called "check_dangling_references" that takes checker as BorrowChecker returns List[Dictionary[String, Integer]]:
    @Implementation
    Checks for dangling reference creation.
    Detects references that outlive their referenced data.
    @End Implementation
    
    Let dangling_references be List[Dictionary[String, Integer]]
    
    Note: Check each active borrow for potential dangling
    For Each borrow in checker.active_borrows:
        Let borrowed_variable be borrow.borrowed_variable
        Let borrower_scope be borrow.borrower_scope
        
        Note: Get the scope of the borrowed variable
        If Dictionary.contains_key(checker.ownership_map, borrowed_variable):
            Let ownership_info be checker.ownership_map[borrowed_variable]
            Let owner_scope be ownership_info.owner_scope
            
            Note: Check if borrower scope outlives owner scope
            Let borrower_outlives_owner be does_scope_outlive(checker.scope_analyzer, borrower_scope, owner_scope)
            If borrower_outlives_owner equals true:
                Let dangling_position be Dictionary[String, Integer]
                Set dangling_position["line"] to borrow.borrow_position["line"]
                Set dangling_position["column"] to borrow.borrow_position["column"]
                Set dangling_position["file"] to borrow.borrow_position["file"]
                List.add(dangling_references, dangling_position)
            End If
        End If
    End For
    
    Note: Check for references to local variables that escape their scope
    For Each lifetime_constraint in checker.lifetime_constraints:
        For Each scope_constraint in lifetime_constraint.scope_constraints:
            Let constraint_valid be validate_lifetime_scope_constraint(checker, lifetime_constraint, scope_constraint)
            If constraint_valid equals false:
                Let dangling_position be Dictionary[String, Integer]
                Set dangling_position["line"] to extract_constraint_line(lifetime_constraint)
                Set dangling_position["column"] to extract_constraint_column(lifetime_constraint)
                Set dangling_position["file"] to extract_constraint_file(lifetime_constraint)
                List.add(dangling_references, dangling_position)
            End If
        End For
    End For
    
    Return dangling_references

Process called "validate_memory_deallocation" that takes checker as BorrowChecker, deallocation_point as Dictionary[String, Integer] returns List[String]:
    @Implementation
    Validates that memory deallocation is safe and legal.
    Checks for active borrows and ensures proper cleanup order.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Extract deallocation information
    Let dealloc_file be string_cast(deallocation_point["file"])
    Let dealloc_line be deallocation_point["line"]
    Let deallocated_variable be extract_deallocated_variable_at_position(checker, dealloc_file, dealloc_line)
    
    Note: Check if variable exists in ownership map
    If not Dictionary.contains_key(checker.ownership_map, deallocated_variable):
        List.add(issues, "Attempting to deallocate undeclared variable: " + deallocated_variable)
        Return issues
    End If
    
    Let ownership_info be checker.ownership_map[deallocated_variable]
    
    Note: Check if variable has already been moved or deallocated
    If ownership_info.is_moved equals true:
        List.add(issues, "Cannot deallocate already moved variable: " + deallocated_variable)
        Return issues
    End If
    
    Note: Check for active borrows on the variable being deallocated
    Let active_borrows_on_variable be find_active_borrows_for_variable(checker, deallocated_variable)
    If List.length(active_borrows_on_variable) greater than 0:
        For Each active_borrow in active_borrows_on_variable:
            Let borrow_line be integer_to_string(active_borrow.borrow_position["line"])
            List.add(issues, "Cannot deallocate variable '" + deallocated_variable + "' while it has active borrow (created at line " + borrow_line + ")")
        End For
    End If
    
    Note: Mark variable as moved/deallocated to prevent further use
    Set ownership_info.is_moved to true
    Set ownership_info.move_position to deallocation_point
    
    Return issues

Process called "detect_double_free" that takes checker as BorrowChecker returns List[Dictionary[String, Integer]]:
    @Implementation
    Detects potential double-free vulnerabilities.
    Tracks deallocation history to find multiple frees of same memory.
    @End Implementation
    
    Let double_frees be List[Dictionary[String, Integer]]
    
    Note: Track all deallocation operations
    Let deallocation_history be Dictionary[String, List[Dictionary[String, Integer]]]
    
    Note: Scan through all moved variables to find deallocations
    For Each ownership_entry in checker.ownership_map:
        Let variable_name be ownership_entry.key
        Let ownership_info be ownership_entry.value
        
        If ownership_info.is_moved equals true:
            Note: Check if this represents a deallocation
            Let is_deallocation be is_move_actually_deallocation(ownership_info.move_position)
            If is_deallocation equals true:
                Note: Track this deallocation
                If not Dictionary.contains_key(deallocation_history, variable_name):
                    Set deallocation_history[variable_name] to List[Dictionary[String, Integer]]
                End If
                List.add(deallocation_history[variable_name], ownership_info.move_position)
            End If
        End If
    End For
    
    Note: Check for multiple deallocations of same variable
    For Each dealloc_entry in deallocation_history:
        Let variable_name be dealloc_entry.key
        Let deallocations be dealloc_entry.value
        
        If List.length(deallocations) greater than 1:
            Note: Multiple deallocations detected - this is a double-free
            For i from 1 to (List.length(deallocations) - 1):
                Let duplicate_dealloc be deallocations[i]
                List.add(double_frees, duplicate_dealloc)
            End For
        End If
    End For
    
    Note: Check for deallocations of already freed memory through aliases
    Let alias_double_frees be detect_alias_double_frees(checker, deallocation_history)
    For Each alias_double_free in alias_double_frees:
        List.add(double_frees, alias_double_free)
    End For
    
    Return double_frees

Note: =====================================================================
Note: BORROWING CONFLICT RESOLUTION
Note: =====================================================================

Process called "resolve_borrow_conflict" that takes checker as BorrowChecker, conflict_description as String returns List[String]:
    @Implementation
    Suggests resolutions for borrow conflicts.
    Analyzes conflict patterns and provides actionable solutions.
    @End Implementation
    
    Let suggestions be List[String]
    
    Note: Parse conflict description to understand the issue
    Let conflict_type be extract_conflict_type(conflict_description)
    Let involved_variables be extract_conflict_variables(conflict_description)
    Let conflict_location be extract_conflict_location(conflict_description)
    
    Match conflict_type:
        When "mutable_immutable_conflict":
            List.add(suggestions, "Consider ending the immutable borrow before creating the mutable borrow")
            List.add(suggestions, "Use block scoping to limit the lifetime of borrows")
            List.add(suggestions, "Consider using RefCell for interior mutability if appropriate")
            
        When "multiple_mutable_borrows":
            List.add(suggestions, "Only one mutable borrow is allowed at a time")
            List.add(suggestions, "End the first mutable borrow before creating the second")
            List.add(suggestions, "Consider restructuring code to avoid simultaneous mutable borrows")
            List.add(suggestions, "Use separate scopes or split the operation into sequential steps")
            
        When "borrow_across_function_call":
            List.add(suggestions, "The borrow may be ending at the function call boundary")
            List.add(suggestions, "Consider passing the borrowed value as a parameter")
            List.add(suggestions, "Use explicit lifetime annotations if needed")
            
        When "lifetime_conflict":
            List.add(suggestions, "The borrowed value does not live long enough")
            List.add(suggestions, "Consider moving the variable to a longer-lived scope")
            List.add(suggestions, "Use explicit lifetime parameters to clarify relationships")
            List.add(suggestions, "Clone the value if ownership transfer is appropriate")
            
        Otherwise:
            List.add(suggestions, "General borrow conflict resolution strategies:")
            List.add(suggestions, "1. Reduce the scope of borrows by using block expressions")
            List.add(suggestions, "2. Reorganize code to avoid overlapping borrows")
            List.add(suggestions, "3. Consider using different data structures or ownership patterns")
            List.add(suggestions, "4. Split complex operations into simpler, sequential steps")
    End Match
    
    Note: Add specific suggestions based on involved variables
    If List.length(involved_variables) greater than 0:
        Let primary_variable be involved_variables[0]
        List.add(suggestions, "For variable '" + primary_variable + "': Check if the borrow is still needed at the conflict point")
    End If
    
    Return suggestions

Process called "suggest_ownership_restructuring" that takes checker as BorrowChecker, ownership_issue as String returns List[String]:
    @Implementation
    Suggests code restructuring to resolve ownership issues.
    Provides architectural recommendations for better ownership patterns.
    @End Implementation
    
    Let suggestions be List[String]
    
    Note: Parse ownership issue to understand the problem
    Let issue_type be extract_ownership_issue_type(ownership_issue)
    Let problematic_variables be extract_ownership_issue_variables(ownership_issue)
    
    Match issue_type:
        When "complex_ownership_chain":
            List.add(suggestions, "Consider simplifying the ownership chain by using fewer intermediate variables")
            List.add(suggestions, "Break complex operations into smaller, focused functions")
            List.add(suggestions, "Use composition instead of deep ownership hierarchies")
            
        When "circular_ownership":
            List.add(suggestions, "Circular ownership detected - consider using weak references")
            List.add(suggestions, "Restructure data relationships to avoid cycles")
            List.add(suggestions, "Use reference counting (Rc) with weak references for cycles")
            
        When "premature_move":
            List.add(suggestions, "Variable is moved too early - delay the move operation")
            List.add(suggestions, "Consider borrowing instead of moving if full ownership isn't needed")
            List.add(suggestions, "Clone the value if multiple ownership is required")
            
        When "ownership_fragmentation":
            List.add(suggestions, "Ownership is too fragmented - consider consolidating related data")
            List.add(suggestions, "Use structs or tuples to group related owned values")
            List.add(suggestions, "Reduce the number of separate ownership transfers")
            
        When "borrowed_data_escaping":
            List.add(suggestions, "Borrowed data is trying to escape its scope")
            List.add(suggestions, "Consider cloning the data if it needs to outlive the borrow")
            List.add(suggestions, "Restructure scopes to contain the borrowed data properly")
            List.add(suggestions, "Use owned data instead of borrowed data for long-term storage")
            
        Otherwise:
            List.add(suggestions, "General ownership restructuring strategies:")
            List.add(suggestions, "1. Minimize the number of ownership transfers")
            List.add(suggestions, "2. Use borrowing when full ownership isn't needed")
            List.add(suggestions, "3. Group related data into single owned structures")
            List.add(suggestions, "4. Consider using smart pointers for shared ownership")
    End Match
    
    Note: Add variable-specific suggestions
    For Each variable in problematic_variables:
        List.add(suggestions, "For variable '" + variable + "': Review its ownership lifetime and usage pattern")
    End For
    
    Return suggestions

Process called "recommend_lifetime_annotations" that takes checker as BorrowChecker, lifetime_issue as String returns List[String]:
    @Implementation
    Recommends explicit lifetime annotations to resolve lifetime issues.
    Provides specific annotation syntax and placement guidance.
    @End Implementation
    
    Let recommendations be List[String]
    
    Note: Parse lifetime issue details
    Let issue_type be extract_lifetime_issue_type(lifetime_issue)
    Let affected_functions be extract_lifetime_issue_functions(lifetime_issue)
    Let problematic_references be extract_lifetime_issue_references(lifetime_issue)
    
    Match issue_type:
        When "ambiguous_lifetime":
            List.add(recommendations, "Add explicit lifetime parameters to clarify relationships")
            List.add(recommendations, "Example: Process called 'function_name' with lifetime 'a that takes param as &'a Type returns &'a ReturnType")
            List.add(recommendations, "Specify which input lifetime the return value is tied to")
            
        When "insufficient_lifetime":
            List.add(recommendations, "The reference does not live long enough")
            List.add(recommendations, "Consider using a longer-lived lifetime parameter")
            List.add(recommendations, "Example: Change 'a to 'static if the reference should live for the entire program")
            List.add(recommendations, "Or extend the scope of the referenced data")
            
        When "lifetime_mismatch":
            List.add(recommendations, "Lifetime parameters do not match between function signature and usage")
            List.add(recommendations, "Ensure all related references use the same lifetime parameter")
            List.add(recommendations, "Example: Use 'a for both input and output parameters that are related")
            
        When "complex_lifetime_relationships":
            List.add(recommendations, "Multiple lifetime parameters may be needed")
            List.add(recommendations, "Example: Process with lifetime 'a, 'b that takes x as &'a Type, y as &'b Type returns ComplexType['a, 'b]")
            List.add(recommendations, "Use lifetime bounds when one lifetime must outlive another")
            List.add(recommendations, "Example: where 'a: 'b (lifetime 'a outlives lifetime 'b)")
            
        Otherwise:
            List.add(recommendations, "General lifetime annotation guidelines:")
            List.add(recommendations, "1. Start with single lifetime parameter 'a for simple cases")
            List.add(recommendations, "2. Add more lifetime parameters when references have different sources")
            List.add(recommendations, "3. Use 'static for references that should live for the entire program")
            List.add(recommendations, "4. Consider using owned data instead of references if lifetimes are too complex")
    End Match
    
    Note: Add function-specific recommendations
    For Each affected_function in affected_functions:
        List.add(recommendations, "For function '" + affected_function + "': Review parameter and return type lifetime relationships")
    End For
    
    Return recommendations

Note: =====================================================================
Note: MATHEMATICAL EXPRESSION BORROW CHECKING
Note: =====================================================================

Process called "check_mathematical_variable_borrowing" that takes checker as BorrowChecker, math_expression as String returns List[String]:
    @Implementation
    Checks borrowing rules for mathematical variables and Greek symbols.
    Handles special scoping rules for mathematical notation.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Parse mathematical expression for variables
    Let math_variables be extract_mathematical_variables(math_expression)
    Let greek_symbols be extract_greek_symbols(math_expression)
    Let expression_position be extract_math_expression_position(math_expression)
    
    Note: Check borrowing for regular mathematical variables
    For Each math_var in math_variables:
        Note: Check if variable exists in ownership map
        If Dictionary.contains_key(checker.ownership_map, math_var):
            Let ownership_info be checker.ownership_map[math_var]
            
            Note: Check if variable has been moved
            If ownership_info.is_moved equals true:
                List.add(issues, "Cannot use moved mathematical variable: " + math_var + " in expression")
                Continue
            End If
            
            Note: Mathematical usage typically creates immutable borrow
            Let math_borrow be track_immutable_borrow(checker, math_var, expression_position)
            Let conflicts be detect_borrow_conflicts(checker, math_borrow)
            For Each conflict in conflicts:
                List.add(issues, "Mathematical expression borrow conflict: " + conflict)
            End For
        Otherwise:
            Note: Check if it's a mathematical constant or bound variable
            Let is_math_constant be is_mathematical_constant(math_var)
            Let is_bound_variable be is_bound_in_mathematical_context(math_var, math_expression)
            
            If is_math_constant equals false and is_bound_variable equals false:
                List.add(issues, "Undefined mathematical variable: " + math_var)
            End If
        End If
    End For
    
    Note: Check Greek symbol borrowing
    For Each greek_symbol in greek_symbols:
        Let symbol_issues be analyze_greek_symbol_ownership(checker, greek_symbol)
        For Each issue in symbol_issues:
            List.add(issues, issue)
        End For
    End For
    
    Note: Check for mathematical operation-specific borrowing rules
    Let operation_type be extract_mathematical_operation_type(math_expression)
    Match operation_type:
        When "summation":
            Let summation_issues be validate_summation_variable_access(checker, math_expression)
            For Each issue in summation_issues:
                List.add(issues, issue)
            End For
        When "integration":
            Let integration_issues be validate_integration_variable_borrowing(checker, math_expression)
            For Each issue in integration_issues:
                List.add(issues, issue)
            End For
        When "product":
            Let product_issues be validate_product_variable_borrowing(checker, math_expression)
            For Each issue in product_issues:
                List.add(issues, issue)
            End For
        Otherwise:
            Note: Standard mathematical expression - no special rules
    End Match
    
    Return issues

Process called "analyze_greek_symbol_ownership" that takes checker as BorrowChecker, greek_symbol as String returns OwnershipInfo:
    @Implementation
    Analyzes ownership of Greek letter variables used in mathematical contexts.
    Handles special scoping rules for mathematical notation symbols.
    @End Implementation
    
    Note: Check if Greek symbol is already tracked in ownership map
    If Dictionary.contains_key(checker.ownership_map, greek_symbol):
        Return checker.ownership_map[greek_symbol]
    End If
    
    Note: Determine context and scope for Greek symbol
    Let symbol_context be determine_greek_symbol_context(greek_symbol)
    Let symbol_scope be determine_mathematical_symbol_scope(checker.scope_analyzer, greek_symbol)
    
    Note: Create ownership info for Greek symbol
    Let greek_ownership be OwnershipInfo with
        variable_name as greek_symbol,
        owner_scope as symbol_scope,
        ownership_type as "mathematical",
        is_moved as false,
        move_position as Dictionary[String, Integer],
        original_declaration as create_mathematical_declaration_position(greek_symbol)
    End OwnershipInfo
    
    Note: Greek symbols in mathematical contexts have special rules
    Match symbol_context:
        When "summation_index":
            Note: Summation indices are locally scoped and owned
            Set greek_ownership.ownership_type to "locally_bound"
        When "integration_variable":
            Note: Integration variables are bound within the integral
            Set greek_ownership.ownership_type to "integration_bound"
        When "function_parameter":
            Note: Greek symbols as function parameters follow normal rules
            Set greek_ownership.ownership_type to "parameter"
        When "free_variable":
            Note: Free mathematical variables need to be declared
            Set greek_ownership.ownership_type to "free_mathematical"
        Otherwise:
            Note: Default mathematical variable
            Set greek_ownership.ownership_type to "mathematical"
    End Match
    
    Note: Register Greek symbol in ownership map
    Set checker.ownership_map[greek_symbol] to greek_ownership
    
    Return greek_ownership

Process called "validate_summation_variable_access" that takes checker as BorrowChecker, summation_expr as String returns List[String]:
    @Implementation
    Validates variable access within summation expressions.
    Checks index variable scoping and summand variable borrowing.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Parse summation expression components
    Let summation_components be parse_summation_expression(summation_expr)
    Let index_variable be summation_components["index"]
    Let lower_bound be summation_components["lower_bound"]
    Let upper_bound be summation_components["upper_bound"]
    Let summand_expression be summation_components["summand"]
    Let summation_position be summation_components["position"]
    
    Note: Validate index variable scoping
    Let index_ownership be analyze_greek_symbol_ownership(checker, index_variable)
    If not strings_equal(index_ownership.ownership_type, "locally_bound"):
        Note: Track index variable as locally bound for summation scope
        Set index_ownership.ownership_type to "locally_bound"
        Set index_ownership.owner_scope to "summation_" + integer_to_string(summation_position["line"])
    End If
    
    Note: Validate bound expressions
    Let lower_bound_variables be extract_variables_from_expression(lower_bound)
    For Each bound_var in lower_bound_variables:
        If Dictionary.contains_key(checker.ownership_map, bound_var):
            Let bound_ownership be checker.ownership_map[bound_var]
            If bound_ownership.is_moved equals true:
                List.add(issues, "Cannot use moved variable '" + bound_var + "' in summation lower bound")
            End If
        Otherwise:
            List.add(issues, "Undefined variable '" + bound_var + "' in summation lower bound")
        End If
    End For
    
    Let upper_bound_variables be extract_variables_from_expression(upper_bound)
    For Each bound_var in upper_bound_variables:
        If Dictionary.contains_key(checker.ownership_map, bound_var):
            Let bound_ownership be checker.ownership_map[bound_var]
            If bound_ownership.is_moved equals true:
                List.add(issues, "Cannot use moved variable '" + bound_var + "' in summation upper bound")
            End If
        Otherwise:
            List.add(issues, "Undefined variable '" + bound_var + "' in summation upper bound")
        End If
    End For
    
    Note: Validate summand expression variables
    Let summand_variables be extract_variables_from_expression(summand_expression)
    For Each summand_var in summand_variables:
        Note: Skip the index variable as it's locally bound
        If strings_equal(summand_var, index_variable):
            Continue
        End If
        
        If Dictionary.contains_key(checker.ownership_map, summand_var):
            Let summand_ownership be checker.ownership_map[summand_var]
            If summand_ownership.is_moved equals true:
                List.add(issues, "Cannot use moved variable '" + summand_var + "' in summation expression")
            Otherwise:
                Note: Create immutable borrow for summand variable usage
                Let summand_borrow be track_immutable_borrow(checker, summand_var, summation_position)
                Let conflicts be detect_borrow_conflicts(checker, summand_borrow)
                For Each conflict in conflicts:
                    List.add(issues, "Summation variable borrow conflict: " + conflict)
                End For
            End If
        Otherwise:
            List.add(issues, "Undefined variable '" + summand_var + "' in summation expression")
        End If
    End For
    
    Return issues

Note: =====================================================================
Note: ERROR REPORTING AND DIAGNOSTICS
Note: =====================================================================

Process called "generate_borrow_error" that takes checker as BorrowChecker, error_type as String, position as Dictionary[String, Integer] returns String:
    @Implementation
    Generates comprehensive borrow checking error messages.
    Provides context, explanation, and suggestions for resolution.
    @End Implementation
    
    Let error_message be ""
    Let file_name be string_cast(position["file"])
    Let line_number be integer_to_string(position["line"])
    Let column_number be integer_to_string(position["column"])
    
    Note: Create error header with location
    Set error_message to "Borrow checking error at " + file_name + ":" + line_number + ":" + column_number + "\n"
    
    Note: Add specific error message based on type
    Match error_type:
        When "use_after_move":
            Set error_message to error_message + "Error: Use of moved value\n"
            Set error_message to error_message + "The value has been moved and can no longer be used.\n"
            
        When "multiple_mutable_borrows":
            Set error_message to error_message + "Error: Cannot borrow as mutable more than once\n"
            Set error_message to error_message + "Only one mutable borrow is allowed at a time.\n"
            
        When "mutable_immutable_conflict":
            Set error_message to error_message + "Error: Cannot borrow as mutable while immutable borrow exists\n"
            Set error_message to error_message + "Mutable and immutable borrows cannot coexist.\n"
            
        When "dangling_reference":
            Set error_message to error_message + "Error: Reference outlives its data\n"
            Set error_message to error_message + "The referenced value does not live long enough.\n"
            
        When "double_free":
            Set error_message to error_message + "Error: Double-free detected\n"
            Set error_message to error_message + "Attempt to free already freed memory.\n"
            
        Otherwise:
            Set error_message to error_message + "Error: " + error_type + "\n"
            Set error_message to error_message + "A borrow checking violation occurred.\n"
    End Match
    
    Note: Add contextual information
    Set error_message to error_message + "\nContext:\n"
    Set error_message to error_message + "Active borrows: " + integer_to_string(List.length(checker.active_borrows)) + "\n"
    Set error_message to error_message + "Tracked variables: " + integer_to_string(Dictionary.size(checker.ownership_map)) + "\n"
    
    Note: Add suggestions
    Let suggestions be suggest_borrow_fixes(checker, error_type)
    If List.length(suggestions) greater than 0:
        Set error_message to error_message + "\nSuggestions:\n"
        For Each suggestion in suggestions:
            Set error_message to error_message + "- " + suggestion + "\n"
        End For
    End If
    
    Return error_message

Process called "explain_ownership_violation" that takes checker as BorrowChecker, violation as String returns String:
    @Implementation
    Provides detailed explanation of ownership violations.
    Breaks down complex ownership issues into understandable terms.
    @End Implementation
    
    Let explanation be ""
    
    Note: Parse violation to understand the specific issue
    Let violation_type be extract_violation_type(violation)
    Let involved_variables be extract_violation_variables(violation)
    Let violation_context be extract_violation_context(violation)
    
    Note: Create detailed explanation based on violation type
    Match violation_type:
        When "moved_value_used":
            Set explanation to "Ownership Violation: Use After Move\n\n"
            Set explanation to explanation + "What happened:\n"
            Set explanation to explanation + "A variable was moved (ownership transferred) but then used again.\n"
            Set explanation to explanation + "In Runa, when a value is moved, the original variable becomes invalid.\n\n"
            
            If List.length(involved_variables) greater than 0:
                Let moved_var be involved_variables[0]
                Set explanation to explanation + "The variable '" + moved_var + "' was moved and then accessed.\n"
            End If
            
        When "borrow_conflict":
            Set explanation to "Ownership Violation: Borrow Conflict\n\n"
            Set explanation to explanation + "What happened:\n"
            Set explanation to explanation + "Multiple conflicting borrows were attempted on the same data.\n"
            Set explanation to explanation + "Runa enforces exclusive access: either one mutable borrow OR multiple immutable borrows.\n\n"
            
        When "lifetime_violation":
            Set explanation to "Ownership Violation: Lifetime Issue\n\n"
            Set explanation to explanation + "What happened:\n"
            Set explanation to explanation + "A reference was created that outlives the data it points to.\n"
            Set explanation to explanation + "This would create a dangling pointer, which Runa prevents.\n\n"
            
        When "double_ownership":
            Set explanation to "Ownership Violation: Double Ownership\n\n"
            Set explanation to explanation + "What happened:\n"
            Set explanation to explanation + "The same data was claimed by multiple owners.\n"
            Set explanation to explanation + "In Runa, each value has exactly one owner at any time.\n\n"
            
        Otherwise:
            Set explanation to "Ownership Violation: " + violation_type + "\n\n"
            Set explanation to explanation + "A complex ownership rule was violated.\n"
    End Match
    
    Note: Add technical details
    Set explanation to explanation + "Technical Details:\n"
    Set explanation to explanation + "Context: " + violation_context + "\n"
    
    If List.length(involved_variables) greater than 0:
        Set explanation to explanation + "Involved variables: "
        For i from 0 to (List.length(involved_variables) - 1):
            Set explanation to explanation + involved_variables[i]
            If i less than (List.length(involved_variables) - 1):
                Set explanation to explanation + ", "
            End If
        End For
        Set explanation to explanation + "\n"
    End If
    
    Note: Add learning guidance
    Set explanation to explanation + "\nUnderstanding Ownership:\n"
    Set explanation to explanation + "- Each value has exactly one owner\n"
    Set explanation to explanation + "- When ownership is moved, the original becomes invalid\n"
    Set explanation to explanation + "- Borrowing allows temporary access without ownership transfer\n"
    Set explanation to explanation + "- Mutable borrows are exclusive, immutable borrows can be shared\n"
    
    Return explanation

Process called "suggest_borrow_fixes" that takes checker as BorrowChecker, borrow_error as String returns List[String]:
    @Implementation
    Suggests specific fixes for borrow checking errors.
    Provides actionable code modifications and patterns.
    @End Implementation
    
    Let fixes be List[String]
    
    Note: Parse error to understand the specific issue
    Let error_pattern be extract_error_pattern(borrow_error)
    Let error_location be extract_error_location(borrow_error)
    Let involved_code be extract_involved_code(borrow_error)
    
    Match error_pattern:
        When "use_after_move":
            List.add(fixes, "Use borrowing instead of moving: &variable instead of variable")
            List.add(fixes, "Clone the value before moving: variable.clone()")
            List.add(fixes, "Restructure code to avoid using the variable after the move")
            List.add(fixes, "Consider using reference counting (Rc) for shared ownership")
            
        When "multiple_mutable_borrows":
            List.add(fixes, "Use block scoping to limit borrow lifetimes: { let x = &mut data; ... }")
            List.add(fixes, "Split the operation into sequential steps")
            List.add(fixes, "Consider using RefCell for interior mutability if needed")
            List.add(fixes, "Restructure code to avoid simultaneous mutable access")
            
        When "mutable_immutable_conflict":
            List.add(fixes, "End the immutable borrow before creating the mutable borrow")
            List.add(fixes, "Use block expressions to control borrow scope")
            List.add(fixes, "Consider if the mutable borrow is actually necessary")
            List.add(fixes, "Reorganize code to separate read and write operations")
            
        When "dangling_reference":
            List.add(fixes, "Move the variable to a longer-lived scope")
            List.add(fixes, "Clone the data instead of borrowing it")
            List.add(fixes, "Use owned data types instead of references")
            List.add(fixes, "Add explicit lifetime annotations to clarify relationships")
            
        When "double_free":
            List.add(fixes, "Ensure memory is only freed once")
            List.add(fixes, "Use RAII (Resource Acquisition Is Initialization) pattern")
            List.add(fixes, "Check for null pointers before freeing")
            List.add(fixes, "Use smart pointers that handle deallocation automatically")
            
        When "invalid_borrow_scope":
            List.add(fixes, "Reduce the scope of the borrow using block expressions")
            List.add(fixes, "Move the borrowed usage closer to the borrow creation")
            List.add(fixes, "Consider if borrowing is necessary or if cloning would be better")
            
        Otherwise:
            List.add(fixes, "General borrow checking fixes:")
            List.add(fixes, "1. Review variable lifetimes and scopes")
            List.add(fixes, "2. Minimize borrow duration using block scoping")
            List.add(fixes, "3. Consider ownership alternatives (cloning, Rc, RefCell)")
            List.add(fixes, "4. Reorganize code to avoid complex borrowing patterns")
    End Match
    
    Note: Add context-specific suggestions
    If not strings_equal(involved_code, ""):
        List.add(fixes, "For the specific code: \"" + involved_code + "\"")
        List.add(fixes, "Consider breaking this into smaller, simpler operations")
    End If
    
    Note: Add learning resources
    List.add(fixes, "")
    List.add(fixes, "For more help with ownership and borrowing:")
    List.add(fixes, "- Review Runa's ownership documentation")
    List.add(fixes, "- Practice with simpler ownership patterns first")
    List.add(fixes, "- Consider using higher-level abstractions when appropriate")
    
    Return fixes

Process called "format_lifetime_error" that takes checker as BorrowChecker, lifetime_error as String returns String:
    @Implementation
    Formats lifetime errors with helpful context and visual aids.
    Makes complex lifetime relationships understandable.
    @End Implementation
    
    Let formatted_error be ""
    
    Note: Parse lifetime error details
    Let error_details be parse_lifetime_error(lifetime_error)
    Let error_type be error_details["type"]
    Let involved_lifetimes be error_details["lifetimes"]
    Let error_location be error_details["location"]
    
    Note: Create formatted header
    Let line_num be integer_to_string(error_location["line"])
    Let file_name be string_cast(error_location["file"])
    Set formatted_error to "Lifetime Error at " + file_name + ":" + line_num + "\n"
    Set formatted_error to formatted_error + "="
    For i from 1 to 50:
        Set formatted_error to formatted_error + "="
    End For
    Set formatted_error to formatted_error + "\n\n"
    
    Note: Add specific error description
    Match error_type:
        When "lifetime_too_short":
            Set formatted_error to formatted_error + "Error: Reference lifetime is too short\n\n"
            Set formatted_error to formatted_error + "The referenced data does not live long enough for the reference.\n"
            
        When "lifetime_mismatch":
            Set formatted_error to formatted_error + "Error: Lifetime parameter mismatch\n\n"
            Set formatted_error to formatted_error + "The lifetime parameters do not match between declaration and usage.\n"
            
        When "circular_lifetime":
            Set formatted_error to formatted_error + "Error: Circular lifetime dependency\n\n"
            Set formatted_error to formatted_error + "Lifetime parameters form a circular dependency which cannot be resolved.\n"
            
        Otherwise:
            Set formatted_error to formatted_error + "Error: " + error_type + "\n\n"
    End Match
    
    Note: Add visual representation of lifetime relationships
    If List.length(involved_lifetimes) greater than 0:
        Set formatted_error to formatted_error + "Lifetime Relationships:\n"
        For Each lifetime in involved_lifetimes:
            Set formatted_error to formatted_error + "  " + lifetime + ": "
            Let lifetime_info be find_lifetime_constraint(checker, lifetime)
            If lifetime_info equals null:
                Set formatted_error to formatted_error + "[unknown scope]\n"
            Otherwise:
                If List.length(lifetime_info.scope_constraints) greater than 0:
                    Set formatted_error to formatted_error + "scope(" + lifetime_info.scope_constraints[0] + ")\n"
                Otherwise:
                    Set formatted_error to formatted_error + "[unbound]\n"
                End If
            End If
        End For
        Set formatted_error to formatted_error + "\n"
    End If
    
    Note: Add suggested resolution
    Set formatted_error to formatted_error + "Suggested Resolution:\n"
    Match error_type:
        When "lifetime_too_short":
            Set formatted_error to formatted_error + "- Extend the lifetime of the referenced data\n"
            Set formatted_error to formatted_error + "- Move the data to a longer-lived scope\n"
            Set formatted_error to formatted_error + "- Use owned data instead of references\n"
            
        When "lifetime_mismatch":
            Set formatted_error to formatted_error + "- Add explicit lifetime annotations\n"
            Set formatted_error to formatted_error + "- Ensure lifetime parameters match between function signature and usage\n"
            Set formatted_error to formatted_error + "- Consider using generic lifetime parameters\n"
            
        Otherwise:
            Set formatted_error to formatted_error + "- Review lifetime relationships in your code\n"
            Set formatted_error to formatted_error + "- Consider simplifying the lifetime requirements\n"
    End Match
    
    Set formatted_error to formatted_error + "\nFor detailed help with lifetimes, consult the Runa lifetime guide.\n"
    
    Return formatted_error

Note: =====================================================================
Note: BORROW CHECKER QUERIES
Note: =====================================================================

Process called "get_ownership_status" that takes checker as BorrowChecker, variable_name as String returns OwnershipInfo:
    @Implementation
    Gets the current ownership status of a variable.
    Returns ownership information or null if variable not tracked.
    @End Implementation
    
    Note: Check if variable exists in ownership map
    If Dictionary.contains_key(checker.ownership_map, variable_name):
        Return checker.ownership_map[variable_name]
    End If
    
    Note: Variable not found - return null or empty ownership info
    Let empty_ownership be OwnershipInfo with
        variable_name as variable_name,
        owner_scope as "",
        ownership_type as "untracked",
        is_moved as false,
        move_position as Dictionary[String, Integer],
        original_declaration as Dictionary[String, Integer]
    End OwnershipInfo
    
    Return empty_ownership

Process called "list_active_borrows" that takes checker as BorrowChecker, scope_id as String returns List[BorrowInfo]:
    @Implementation
    Lists all active borrows within the specified scope.
    Filters borrows by scope and returns only active ones.
    @End Implementation
    
    Let scope_borrows be List[BorrowInfo]
    
    Note: Filter active borrows by scope
    For Each borrow in checker.active_borrows:
        Note: Check if borrow is in the specified scope or a child scope
        Let borrow_in_scope be is_borrow_in_scope(checker.scope_analyzer, borrow, scope_id)
        If borrow_in_scope equals true and borrow.is_active equals true:
            List.add(scope_borrows, borrow)
        End If
    End For
    
    Return scope_borrows

Process called "find_borrowing_conflicts" that takes checker as BorrowChecker, variable_name as String returns List[String]:
    @Implementation
    Finds all borrowing conflicts for a specific variable.
    Returns detailed descriptions of each conflict.
    @End Implementation
    
    Let conflicts be List[String]
    
    Note: Find all borrows of this variable
    Let variable_borrows be List[BorrowInfo]
    For Each borrow in checker.active_borrows:
        If strings_equal(borrow.borrowed_variable, variable_name):
            List.add(variable_borrows, borrow)
        End If
    End For
    
    Note: Check for conflicts between borrows
    For i from 0 to (List.length(variable_borrows) - 1):
        Let borrow1 be variable_borrows[i]
        For j from (i + 1) to (List.length(variable_borrows) - 1):
            Let borrow2 be variable_borrows[j]
            
            Note: Check if these borrows conflict
            Let has_conflict be borrows_conflict(borrow1, borrow2)
            If has_conflict equals true:
                Let line1 be integer_to_string(borrow1.borrow_position["line"])
                Let line2 be integer_to_string(borrow2.borrow_position["line"])
                Let conflict_desc be "Conflict between " + borrow1.borrow_type + " borrow at line " + line1 + " and " + borrow2.borrow_type + " borrow at line " + line2
                List.add(conflicts, conflict_desc)
            End If
        End For
    End For
    
    Note: Check if variable has been moved while borrowed
    If Dictionary.contains_key(checker.ownership_map, variable_name):
        Let ownership_info be checker.ownership_map[variable_name]
        If ownership_info.is_moved equals true and List.length(variable_borrows) greater than 0:
            Let move_line be integer_to_string(ownership_info.move_position["line"])
            List.add(conflicts, "Variable moved at line " + move_line + " while borrows are active")
        End If
    End If
    
    Return conflicts

Process called "get_lifetime_information" that takes checker as BorrowChecker, reference_name as String returns LifetimeInfo:
    @Implementation
    Gets lifetime information for a specific reference.
    Returns lifetime constraints and bounds.
    @End Implementation
    
    Note: Search through lifetime constraints
    For Each lifetime_constraint in checker.lifetime_constraints:
        Note: Check if this constraint matches the reference name
        If strings_equal(lifetime_constraint.lifetime_id, reference_name) or strings_equal(lifetime_constraint.lifetime_name, reference_name):
            Return lifetime_constraint
        End If
    End For
    
    Note: Check if reference_name is associated with any active borrows
    For Each borrow in checker.active_borrows:
        If strings_equal(borrow.borrow_id, reference_name):
            Note: Find the lifetime constraint for this borrow
            Let borrow_lifetime be borrow.borrow_lifetime
            For Each constraint in checker.lifetime_constraints:
                If strings_equal(constraint.lifetime_id, borrow_lifetime):
                    Return constraint
                End If
            End For
        End If
    End For
    
    Note: Return empty lifetime info if not found
    Let empty_lifetime be LifetimeInfo with
        lifetime_id as reference_name,
        lifetime_name as "'unknown",
        lifetime_bounds as Dictionary[String, String],
        dependent_lifetimes as List[String],
        scope_constraints as List[String]
    End LifetimeInfo
    
    Return empty_lifetime

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "get_borrow_checker_statistics" that takes checker as BorrowChecker returns Dictionary[String, Integer]:
    Note: Get comprehensive borrow checker statistics
    Let stats be Dictionary[String, Integer]()
    
    Set stats["total_variables"] to checker.ownership_map.size()
    Set stats["active_borrows"] to checker.active_borrows.size()
    Set stats["lifetime_constraints"] to checker.lifetime_constraints.size()
    
    Let mutable_borrows be 0
    Let immutable_borrows be 0
    For Each borrow in checker.active_borrows:
        If borrow.mutability = "mutable":
            Set mutable_borrows to mutable_borrows + 1
        Otherwise:
            Set immutable_borrows to immutable_borrows + 1
        End If
    End For
    
    Set stats["mutable_borrows"] to mutable_borrows
    Set stats["immutable_borrows"] to immutable_borrows
    
    Let ownership_owned be 0
    Let ownership_borrowed be 0
    Let ownership_moved be 0
    For Each variable_name, ownership_info in checker.ownership_map:
        If ownership_info.status = "owned":
            Set ownership_owned to ownership_owned + 1
        When ownership_info.status = "borrowed":
            Set ownership_borrowed to ownership_borrowed + 1
        When ownership_info.status = "moved":
            Set ownership_moved to ownership_moved + 1
        End If
    End For
    
    Set stats["owned_variables"] to ownership_owned
    Set stats["borrowed_variables"] to ownership_borrowed
    Set stats["moved_variables"] to ownership_moved
    
    Note: Include custom statistics if available
    For Each stat_name, stat_value in checker.statistics:
        Set stats[stat_name] to stat_value
    End For
    
    Return stats

Process called "export_ownership_analysis" that takes checker as BorrowChecker, format as String returns String:
    Note: Export ownership analysis in specified format
    Let output be ""
    
    If format = "text":
        output = export_text_analysis(checker)
    When format = "json":
        output = export_json_analysis(checker)
    When format = "csv":
        output = export_csv_analysis(checker)
    Otherwise:
        output = export_text_analysis(checker)
    End If
    
    Return output

Process called "export_text_analysis" that takes checker as BorrowChecker returns String:
    Let report be StringBuilder()
    
    report.append("=== Borrow Checker Analysis Report ===")
    report.append("\nChecker ID: " + checker.checker_id)
    report.append("\nMode: " + checker.current_mode)
    
    report.append("\n\n=== Ownership Status ===")
    For Each variable_name, ownership_info in checker.ownership_map:
        report.append("\nVariable: " + variable_name)
        report.append("\n  Status: " + ownership_info.status)
        report.append("\n  Type: " + ownership_info.type_name)
        report.append("\n  Scope: " + ownership_info.scope_id)
        If ownership_info.moved_at.size() > 0:
            report.append("\n  Moved at: " + ownership_info.moved_at[ownership_info.moved_at.size() - 1])
        End If
        If ownership_info.lifetime.is_not_empty():
            report.append("\n  Lifetime: " + ownership_info.lifetime)
        End If
    End For
    
    report.append("\n\n=== Active Borrows ===")
    For Each borrow in checker.active_borrows:
        report.append("\nBorrow ID: " + borrow.borrow_id)
        report.append("\n  Variable: " + borrow.variable_name)
        report.append("\n  Mutability: " + borrow.mutability)
        report.append("\n  Location: " + borrow.location)
        report.append("\n  Scope: " + borrow.scope_id)
        If borrow.lifetime.is_not_empty():
            report.append("\n  Lifetime: " + borrow.lifetime)
        End If
    End For
    
    Let stats be get_borrow_checker_statistics(checker)
    report.append("\n\n=== Statistics ===")
    For Each stat_name, stat_value in stats:
        report.append("\n" + stat_name + ": " + stat_value.to_string())
    End For
    
    Return report.to_string()

Process called "export_json_analysis" that takes checker as BorrowChecker returns String:
    Let json be StringBuilder()
    json.append("{")
    json.append("\"checker_id\": \"" + checker.checker_id + "\",")
    json.append("\"mode\": \"" + checker.current_mode + "\",")
    
    json.append("\"ownership_map\": {")
    Let first_var be true
    For Each variable_name, ownership_info in checker.ownership_map:
        If first_var is false:
            json.append(",")
        End If
        json.append("\"" + variable_name + "\": {")
        json.append("\"status\": \"" + ownership_info.status + "\",")
        json.append("\"type_name\": \"" + ownership_info.type_name + "\",")
        json.append("\"scope_id\": \"" + ownership_info.scope_id + "\"")
        json.append("}")
        Set first_var to false
    End For
    json.append("},")
    
    json.append("\"active_borrows\": [")
    Let first_borrow be true
    For Each borrow in checker.active_borrows:
        If first_borrow is false:
            json.append(",")
        End If
        json.append("{")
        json.append("\"borrow_id\": \"" + borrow.borrow_id + "\",")
        json.append("\"variable_name\": \"" + borrow.variable_name + "\",")
        json.append("\"mutability\": \"" + borrow.mutability + "\"")
        json.append("}")
        Set first_borrow to false
    End For
    json.append("]")
    
    json.append("}")
    Return json.to_string()

Process called "export_csv_analysis" that takes checker as BorrowChecker returns String:
    Let csv be StringBuilder()
    
    csv.append("Variable,Status,Type,Scope,Lifetime\n")
    For Each variable_name, ownership_info in checker.ownership_map:
        csv.append(variable_name + ",")
        csv.append(ownership_info.status + ",")
        csv.append(ownership_info.type_name + ",")
        csv.append(ownership_info.scope_id + ",")
        csv.append(ownership_info.lifetime + "\n")
    End For
    
    Return csv.to_string()

Process called "validate_borrow_checker_state" that takes checker as BorrowChecker returns List[String]:
    Note: Validate internal state of borrow checker
    Let validation_errors be List[String]()
    
    Note: Check that all active borrows reference valid variables
    For Each borrow in checker.active_borrows:
        If checker.ownership_map.contains_key(borrow.variable_name) is false:
            validation_errors.add("Active borrow " + borrow.borrow_id + " references non-existent variable " + borrow.variable_name)
        End If
    End For
    
    Note: Check that moved variables have no active borrows
    For Each variable_name, ownership_info in checker.ownership_map:
        If ownership_info.status = "moved":
            For Each borrow in checker.active_borrows:
                If borrow.variable_name = variable_name:
                    validation_errors.add("Variable " + variable_name + " is moved but has active borrow " + borrow.borrow_id)
                End If
            End For
        End If
    End For
    
    Note: Check mutable borrow exclusivity
    Let mutable_borrow_map be Dictionary[String, List[String]]()
    For Each borrow in checker.active_borrows:
        If borrow.mutability = "mutable":
            If mutable_borrow_map.contains_key(borrow.variable_name) is false:
                mutable_borrow_map[borrow.variable_name] = List[String]()
            End If
            mutable_borrow_map[borrow.variable_name].add(borrow.borrow_id)
        End If
    End For
    
    For Each variable_name, mutable_borrows in mutable_borrow_map:
        If mutable_borrows.size() > 1:
            validation_errors.add("Variable " + variable_name + " has multiple mutable borrows: " + mutable_borrows.join(", "))
        End If
    End For
    
    Note: Check that lifetime constraints are consistent
    For Each constraint in checker.lifetime_constraints:
        If constraint.first_lifetime.is_empty() or constraint.second_lifetime.is_empty():
            validation_errors.add("Invalid lifetime constraint with empty lifetime")
        End If
    End For
    
    Note: Check for orphaned ownership info
    For Each variable_name, ownership_info in checker.ownership_map:
        If ownership_info.scope_id.is_empty():
            validation_errors.add("Variable " + variable_name + " has no associated scope")
        End If
    End For
    
    Return validation_errors

Process called "reset_borrow_checker" that takes checker as BorrowChecker returns Boolean:
    Note: Reset borrow checker to initial state
    
    Note: Clear all tracking data while preserving configuration
    checker.ownership_map.clear()
    checker.active_borrows.clear()
    checker.lifetime_constraints.clear()
    checker.statistics.clear()
    
    Note: Reset statistics to initial values
    checker.statistics["resets_performed"] = 1
    checker.statistics["variables_tracked"] = 0
    checker.statistics["borrows_created"] = 0
    checker.statistics["conflicts_detected"] = 0
    checker.statistics["errors_generated"] = 0
    
    Note: Validate the reset was successful
    If checker.ownership_map.size() = 0 and checker.active_borrows.size() = 0 and checker.lifetime_constraints.size() = 0:
        Return true
    Otherwise:
        Return false
    End If

Note: =====================================================================
Note: Helper Functions
Note: =====================================================================

Process called "is_scope_ancestor" that takes scope_analyzer as String, ancestor_scope as String, descendant_scope as String returns Boolean:
    Note: Check if ancestor_scope contains descendant_scope in the scope hierarchy
    
    If ancestor_scope = descendant_scope:
        Return true
    End If
    
    Note: Parse scope paths to check containment
    Let ancestor_parts be ancestor_scope.split(".")
    Let descendant_parts be descendant_scope.split(".")
    
    If ancestor_parts.size() > descendant_parts.size():
        Return false
    End If
    
    For i from 0 to ancestor_parts.size() - 1:
        If ancestor_parts[i] != descendant_parts[i]:
            Return false
        End If
    End For
    
    Return true

Process called "is_borrow_in_scope" that takes scope_analyzer as String, borrow as BorrowInfo, target_scope as String returns Boolean:
    Note: Check if a borrow is active within the target scope
    
    If borrow.scope_id = target_scope:
        Return true
    End If
    
    Note: Check if borrow scope is a child of target scope
    Return is_scope_ancestor(scope_analyzer, target_scope, borrow.scope_id)

Process called "parse_lifetime_error" that takes error_string as String returns Dictionary[String, Any]:
    Note: Parse lifetime error details from error string
    
    Let error_details be Dictionary[String, Any]()
    
    Note: Extract error type
    If error_string.contains("too short"):
        error_details["type"] = "lifetime_too_short"
    When error_string.contains("mismatch"):
        error_details["type"] = "lifetime_mismatch"
    When error_string.contains("circular"):
        error_details["type"] = "circular_lifetime"
    Otherwise:
        error_details["type"] = "unknown_lifetime_error"
    End If
    
    Note: Extract lifetime names using pattern matching
    Let lifetimes be List[String]()
    Let tokens be error_string.split(" ")
    For Each token in tokens:
        If token.starts_with("'"):
            lifetimes.add(token)
        End If
    End For
    error_details["lifetimes"] = lifetimes
    
    Note: Extract location information
    Let location be Dictionary[String, Any]()
    If error_string.contains(":"):
        Let parts be error_string.split(":")
        If parts.size() >= 3:
            location["file"] = parts[0]
            location["line"] = string_to_integer(parts[1])
            location["column"] = string_to_integer(parts[2].split(" ")[0])
        Otherwise:
            location["file"] = "unknown"
            location["line"] = 0
            location["column"] = 0
        End If
    Otherwise:
        location["file"] = "unknown"
        location["line"] = 0  
        location["column"] = 0
    End If
    error_details["location"] = location
    
    Return error_details

Process called "attempt_constraint_resolution" that takes constraint as LifetimeInfo, current_solution as Dictionary[String, String] returns Dictionary[String, String]:
    Note: Attempt to resolve a single lifetime constraint
    
    Let updated_solution be Dictionary[String, String]()
    For Each lifetime, resolution in current_solution:
        updated_solution[lifetime] = resolution
    End For
    
    Match constraint.constraint_type:
        When "outlives":
            Note: First lifetime must outlive second
            Let first be constraint.first_lifetime
            Let second be constraint.second_lifetime
            
            If updated_solution.contains_key(first) is false:
                updated_solution[first] = "'" + first + "_resolved"
            End If
            If updated_solution.contains_key(second) is false:
                updated_solution[second] = "'" + second + "_resolved"
            End If
            
            Note: Ensure first outlives second in resolution
            If constraint.scope_constraints.size() > 0:
                updated_solution[first] = "'static"
            End If
            
        When "equals":
            Note: Both lifetimes must be equal
            Let unified be "'" + constraint.first_lifetime + "_" + constraint.second_lifetime
            updated_solution[constraint.first_lifetime] = unified
            updated_solution[constraint.second_lifetime] = unified
            
        When "bounded":
            Note: Lifetime is bounded by another
            If constraint.lifetime_bounds.contains_key("upper"):
                updated_solution[constraint.first_lifetime] = constraint.lifetime_bounds["upper"]
            End If
            
        Otherwise:
            Note: Unknown constraint type, keep current solution
    End Match
    
    Return updated_solution

Process called "check_lifetime_cycle" that takes constraints as List[LifetimeInfo], current_lifetime as String, visited as Set[String], path as List[String] returns Boolean:
    Note: Check for circular dependencies in lifetime constraints
    
    If visited.contains(current_lifetime):
        path.add(current_lifetime)
        Return true
    End If
    
    visited.add(current_lifetime)
    path.add(current_lifetime)
    
    For Each constraint in constraints:
        If constraint.first_lifetime = current_lifetime:
            If constraint.constraint_type = "outlives" or constraint.constraint_type = "equals":
                Let has_cycle be check_lifetime_cycle(constraints, constraint.second_lifetime, visited, path)
                If has_cycle:
                    Return true
                End If
            End If
        End If
    End For
    
    path.remove(path.size() - 1)
    visited.remove(current_lifetime)
    Return false