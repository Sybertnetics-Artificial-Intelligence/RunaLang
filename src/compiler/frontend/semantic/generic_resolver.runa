Note:
compiler/frontend/semantic/generic_resolver.runa
Generic Type System and Instantiation Engine

This module provides comprehensive generic type functionality including:
- Generic type parameter definition and constraint handling
- Type parameter inference from usage contexts
- Generic function and type instantiation
- Constraint satisfaction and validation
- Variance analysis for generic types
- Integration with trait system for bounded generics
- Performance optimized generic resolution algorithms
- Comprehensive error reporting for generic issues
:End Note

Import "compiler/frontend/diagnostics/errors" as Errors
Import "compiler/frontend/semantic/symbol_table" as SymbolTable
Import "compiler/frontend/semantic/type_checker" as TypeChecker
Import "compiler/frontend/semantic/trait_resolver" as TraitResolver
Import "compiler/frontend/semantic/scope_analyzer" as ScopeAnalyzer
Import "compiler/frontend/primitives/core/string_primitive" as StringPrimitive

Note: =====================================================================
Note: GENERIC SYSTEM DATA STRUCTURES
Note: =====================================================================

Type called "TypeParameter":
    parameter_id as String
    parameter_name as String
    parameter_bounds as List[String]
    default_type as String
    variance as String
    parameter_position as Integer
    constraint_expressions as List[String]

Type called "GenericDefinition":
    generic_id as String
    definition_name as String
    type_parameters as List[TypeParameter]
    parameter_constraints as Dictionary[String, List[String]]
    instantiation_context as String
    syntax_mode as String

Type called "GenericInstantiation":
    instantiation_id as String
    generic_definition as String
    type_arguments as Dictionary[String, String]
    instantiation_position as Dictionary[String, Integer]
    constraint_proofs as Dictionary[String, String]
    is_valid as Boolean

Type called "GenericResolver":
    resolver_id as String
    symbol_table as String
    type_checker as String
    trait_resolver as String
    generic_definitions as Dictionary[String, GenericDefinition]
    active_instantiations as List[GenericInstantiation]
    inference_context as Dictionary[String, String]
    current_mode as String
    statistics as Dictionary[String, Integer]

Note: =====================================================================
Note: GENERIC RESOLVER OPERATIONS
Note: =====================================================================

Process called "create_generic_resolver" that takes resolver_name as String, symbol_table as String, type_checker as String, trait_resolver as String returns GenericResolver:
    @Implementation
    Creates a new generic resolver with integrated symbol table, type checker, and trait resolver.
    Initializes tracking structures for generic definitions and instantiations.
    @End Implementation
    
    Let resolver be GenericResolver with
        resolver_id as resolver_name,
        symbol_table as symbol_table,
        type_checker as type_checker,
        trait_resolver as trait_resolver,
        generic_definitions as Dictionary[String, GenericDefinition],
        active_instantiations as List[GenericInstantiation],
        inference_context as Dictionary[String, String],
        current_mode as "natural",
        statistics as Dictionary[String, Integer]
    End GenericResolver
    
    Note: Initialize statistics
    Set resolver.statistics["total_definitions"] to 0
    Set resolver.statistics["total_instantiations"] to 0
    Set resolver.statistics["successful_inferences"] to 0
    Set resolver.statistics["constraint_violations"] to 0
    Set resolver.statistics["specializations"] to 0
    
    Return resolver

Process called "initialize_builtin_generics" that takes resolver as GenericResolver returns Boolean:
    @Implementation
    Initializes built-in generic types like List[T], Dictionary[K, V], Optional[T], etc.
    These are fundamental to the type system and must be available for all programs.
    @End Implementation
    
    Note: Create List[T] generic
    Let list_param be TypeParameter with
        parameter_id as "list_T",
        parameter_name as "T",
        parameter_bounds as List[String],
        default_type as "",
        variance as "covariant",
        parameter_position as 0,
        constraint_expressions as List[String]
    End TypeParameter
    
    Let list_generic be GenericDefinition with
        generic_id as "builtin_List",
        definition_name as "List",
        type_parameters as [list_param],
        parameter_constraints as Dictionary[String, List[String]],
        instantiation_context as "global",
        syntax_mode as "both"
    End GenericDefinition
    
    Set resolver.generic_definitions["List"] to list_generic
    
    Note: Create Dictionary[K, V] generic
    Let dict_key_param be TypeParameter with
        parameter_id as "dict_K",
        parameter_name as "K",
        parameter_bounds as ["Hashable"],
        default_type as "",
        variance as "invariant",
        parameter_position as 0,
        constraint_expressions as List[String]
    End TypeParameter
    
    Let dict_value_param be TypeParameter with
        parameter_id as "dict_V",
        parameter_name as "V",
        parameter_bounds as List[String],
        default_type as "",
        variance as "covariant",
        parameter_position as 1,
        constraint_expressions as List[String]
    End TypeParameter
    
    Let dict_generic be GenericDefinition with
        generic_id as "builtin_Dictionary",
        definition_name as "Dictionary",
        type_parameters as [dict_key_param, dict_value_param],
        parameter_constraints as Dictionary[String, List[String]],
        instantiation_context as "global",
        syntax_mode as "both"
    End GenericDefinition
    
    Set resolver.generic_definitions["Dictionary"] to dict_generic
    
    Note: Create Optional[T] generic
    Let optional_param be TypeParameter with
        parameter_id as "optional_T",
        parameter_name as "T",
        parameter_bounds as List[String],
        default_type as "",
        variance as "covariant",
        parameter_position as 0,
        constraint_expressions as List[String]
    End TypeParameter
    
    Let optional_generic be GenericDefinition with
        generic_id as "builtin_Optional",
        definition_name as "Optional",
        type_parameters as [optional_param],
        parameter_constraints as Dictionary[String, List[String]],
        instantiation_context as "global",
        syntax_mode as "both"
    End GenericDefinition
    
    Set resolver.generic_definitions["Optional"] to optional_generic
    
    Note: Update statistics
    Set resolver.statistics["total_definitions"] to 3
    
    Return true

Process called "analyze_program_generics" that takes resolver as GenericResolver, program_ast as String returns List[String]:
    @Implementation
    Analyzes the entire program AST to find and validate all generic definitions and usages.
    Returns a list of any issues found during analysis.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Find all generic definitions in AST
    Let definitions be find_generic_definitions_in_ast(program_ast)
    
    For Each definition in definitions:
        Let parsed_def be parse_generic_definition(resolver, definition)
        If parsed_def.generic_id == "":
            List.add(issues, "Failed to parse generic definition: " + definition)
        Otherwise:
            Let registration_success be register_generic_definition(resolver, parsed_def)
            If not registration_success:
                List.add(issues, "Failed to register generic: " + parsed_def.definition_name)
            End If
            
            Let validation_errors be validate_generic_definition(resolver, parsed_def)
            For Each error in validation_errors:
                List.add(issues, error)
            End For
        End If
    End For
    
    Note: Find all generic instantiations in AST
    Let instantiations be find_generic_instantiations_in_ast(program_ast)
    
    For Each instantiation in instantiations:
        Let validation_errors be validate_instantiation_context(resolver, instantiation)
        For Each error in validation_errors:
            List.add(issues, error)
        End For
    End For
    
    Note: Check for undefined generics
    Let undefined be check_undefined_generics(resolver, program_ast)
    For Each undef in undefined:
        List.add(issues, "Undefined generic type: " + undef)
    End For
    
    Return issues

Note: =====================================================================
Note: GENERIC DEFINITION OPERATIONS
Note: =====================================================================

Process called "parse_generic_definition" that takes resolver as GenericResolver, generic_ast as String returns GenericDefinition:
    @Implementation
    Parses a generic type or function definition from the AST representation.
    Extracts type parameters, constraints, and variance information.
    @End Implementation
    
    Note: Extract definition name and parameters
    Let def_name be extract_generic_name(generic_ast)
    Let params_str be extract_type_parameters(generic_ast)
    
    Note: Parse type parameters
    Let type_params be List[TypeParameter]
    Let param_position be 0
    
    If params_str != "":
        Let param_list be split_parameters(params_str)
        For Each param_spec in param_list:
            Let param_name be extract_parameter_name(param_spec)
            Let param_bounds be extract_parameter_bounds(param_spec)
            Let param_variance be infer_parameter_variance(param_spec)
            
            Let type_param be TypeParameter with
                parameter_id as def_name + "_" + param_name,
                parameter_name as param_name,
                parameter_bounds as param_bounds,
                default_type as extract_default_type(param_spec),
                variance as param_variance,
                parameter_position as param_position,
                constraint_expressions as extract_constraints(param_spec)
            End TypeParameter
            
            List.add(type_params, type_param)
            Set param_position to param_position + 1
        End For
    End If
    
    Note: Extract parameter constraints
    Let constraints be extract_where_clause(generic_ast)
    Let param_constraints be Dictionary[String, List[String]]
    
    For Each constraint in constraints:
        Let param be extract_constraint_param(constraint)
        Let requirement be extract_constraint_requirement(constraint)
        
        If not Dictionary.contains_key(param_constraints, param):
            Set param_constraints[param] to List[String]
        End If
        List.add(param_constraints[param], requirement)
    End For
    
    Note: Determine syntax mode
    Let syntax_mode be "natural"
    If contains_angle_brackets(generic_ast):
        Set syntax_mode to "technical"
    End If
    
    Let generic_def be GenericDefinition with
        generic_id as generate_generic_id(def_name),
        definition_name as def_name,
        type_parameters as type_params,
        parameter_constraints as param_constraints,
        instantiation_context as determine_context(generic_ast),
        syntax_mode as syntax_mode
    End GenericDefinition
    
    Return generic_def

Process called "register_generic_definition" that takes resolver as GenericResolver, generic_def as GenericDefinition returns Boolean:
    @Implementation
    Registers a generic definition in the resolver's registry.
    Checks for duplicate definitions and validates before registration.
    @End Implementation
    
    Note: Check for duplicate definition
    If Dictionary.contains_key(resolver.generic_definitions, generic_def.definition_name):
        Let existing be resolver.generic_definitions[generic_def.definition_name]
        
        Note: Check if this is a valid overload or specialization
        If not is_valid_overload(existing, generic_def):
            Return false
        End If
        
        Note: Store as overload
        Let overload_name be generic_def.definition_name + "_" + generate_overload_suffix(generic_def)
        Set resolver.generic_definitions[overload_name] to generic_def
    Otherwise:
        Note: Register new generic definition
        Set resolver.generic_definitions[generic_def.definition_name] to generic_def
    End If
    
    Note: Update symbol table with generic type
    Let symbol_table_registered be register_generic_in_symbol_table(resolver.symbol_table, generic_def)
    If not symbol_table_registered:
        Return false
    End If
    
    Note: Register type parameters as type variables
    For Each param in generic_def.type_parameters:
        Let param_registered be register_type_parameter(resolver, param, generic_def.definition_name)
        If not param_registered:
            Return false
        End If
    End For
    
    Note: Update statistics
    Set resolver.statistics["total_definitions"] to resolver.statistics["total_definitions"] + 1
    
    Return true

Process called "validate_generic_definition" that takes resolver as GenericResolver, generic_def as GenericDefinition returns List[String]:
    @Implementation
    Validates a generic definition for correctness, including parameter bounds,
    constraint consistency, and variance compatibility.
    @End Implementation
    
    Let errors be List[String]
    
    Note: Validate definition name
    If generic_def.definition_name == "":
        List.add(errors, "Generic definition must have a name")
    End If
    
    Note: Check for duplicate type parameters
    Let param_names be List[String]
    For Each param in generic_def.type_parameters:
        If List.contains(param_names, param.parameter_name):
            List.add(errors, "Duplicate type parameter: " + param.parameter_name)
        End If
        List.add(param_names, param.parameter_name)
    End For
    
    Note: Validate type parameter bounds
    For Each param in generic_def.type_parameters:
        For Each bound in param.parameter_bounds:
            If not is_valid_type_bound(resolver, bound):
                List.add(errors, "Invalid bound '" + bound + "' for parameter " + param.parameter_name)
            End If
        End For
        
        Note: Check variance annotations
        If param.variance != "invariant" and param.variance != "covariant" and param.variance != "contravariant":
            List.add(errors, "Invalid variance '" + param.variance + "' for parameter " + param.parameter_name)
        End If
    End For
    
    Note: Validate parameter constraints
    For Each param_name in Dictionary.keys(generic_def.parameter_constraints):
        Note: Check that parameter exists
        Let param_exists be false
        For Each param in generic_def.type_parameters:
            If param.parameter_name == param_name:
                Set param_exists to true
            End If
        End For
        
        If not param_exists:
            List.add(errors, "Constraint references undefined parameter: " + param_name)
        End If
        
        Note: Validate each constraint
        Let constraints be generic_def.parameter_constraints[param_name]
        For Each constraint in constraints:
            If not is_valid_constraint(resolver, constraint):
                List.add(errors, "Invalid constraint: " + constraint)
            End If
        End For
    End For
    
    Note: Check for circular dependencies in bounds
    Let circular_deps be check_circular_bounds(generic_def)
    For Each circular in circular_deps:
        List.add(errors, "Circular dependency in bounds: " + circular)
    End For
    
    Return errors

Process called "analyze_type_parameter_constraints" that takes resolver as GenericResolver, type_param as TypeParameter returns List[String]:
    @Implementation
    Analyzes all constraints on a type parameter to ensure they are consistent
    and satisfiable. Checks bounds, trait requirements, and custom constraints.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Check trait bounds compatibility
    For Each bound in type_param.parameter_bounds:
        Note: Verify trait exists
        Let trait_exists be trait_exists_in_resolver(resolver.trait_resolver, bound)
        If not trait_exists:
            List.add(issues, "Unknown trait bound: " + bound)
        End If
        
        Note: Check for conflicting trait requirements
        For Each other_bound in type_param.parameter_bounds:
            If bound != other_bound:
                If traits_conflict(resolver.trait_resolver, bound, other_bound):
                    List.add(issues, "Conflicting trait bounds: " + bound + " and " + other_bound)
                End If
            End If
        End For
    End For
    
    Note: Analyze constraint expressions
    For Each constraint_expr in type_param.constraint_expressions:
        Let expr_valid be validate_constraint_expression(resolver, constraint_expr)
        If not expr_valid:
            List.add(issues, "Invalid constraint expression: " + constraint_expr)
        End If
        
        Note: Check if constraint is satisfiable
        Let satisfiable be is_constraint_satisfiable(resolver, constraint_expr)
        If not satisfiable:
            List.add(issues, "Unsatisfiable constraint: " + constraint_expr)
        End If
    End For
    
    Note: Check variance compatibility with bounds
    If type_param.variance == "covariant":
        For Each bound in type_param.parameter_bounds:
            If requires_invariance(bound):
                List.add(issues, "Bound '" + bound + "' requires invariant parameter")
            End If
        End For
    End If
    
    If type_param.variance == "contravariant":
        For Each bound in type_param.parameter_bounds:
            If requires_covariance(bound):
                List.add(issues, "Bound '" + bound + "' requires covariant parameter")
            End If
        End For
    End If
    
    Note: Check default type compatibility
    If type_param.default_type != "":
        Let default_satisfies be check_type_satisfies_bounds(resolver, type_param.default_type, type_param.parameter_bounds)
        If not default_satisfies:
            List.add(issues, "Default type '" + type_param.default_type + "' does not satisfy parameter bounds")
        End If
    End If
    
    Return issues

Note: =====================================================================
Note: TYPE PARAMETER INFERENCE
Note: =====================================================================

Process called "infer_type_arguments" that takes resolver as GenericResolver, generic_call as String, argument_types as List[String] returns Dictionary[String, String]:
    @Implementation
    Infers type arguments for a generic function call based on the actual argument types.
    Uses unification to match parameter types with argument types.
    @End Implementation
    
    Let inferred_types be Dictionary[String, String]
    
    Note: Parse the generic call to get function name
    Let func_name be extract_function_name(generic_call)
    
    Note: Get generic definition
    Let generic_def be get_generic_definition(resolver, func_name)
    If generic_def.generic_id == "":
        Return inferred_types  Note: Return empty if not found
    End If
    
    Note: Get function parameter types (may contain type parameters)
    Let param_types be extract_function_parameter_types(generic_def)
    
    Note: Build initial constraint set
    Let constraints be List[String]
    Let min_args be minimum(List.length(param_types), List.length(argument_types))
    
    For i from 0 to (min_args - 1):
        Let param_type be List.get(param_types, i)
        Let arg_type be List.get(argument_types, i)
        
        Note: Add unification constraint
        Let constraint be param_type + " = " + arg_type
        List.add(constraints, constraint)
    End For
    
    Note: Add bounds constraints
    For Each type_param in generic_def.type_parameters:
        For Each bound in type_param.parameter_bounds:
            Let constraint be type_param.parameter_name + " : " + bound
            List.add(constraints, constraint)
        End For
    End For
    
    Note: Solve constraint system
    Let solution be solve_inference_problem(resolver, constraints)
    
    Note: Validate solution
    Let validation_errors be validate_inferred_types(resolver, solution, generic_call)
    If List.length(validation_errors) > 0:
        Note: If validation fails, try to use default types
        For Each type_param in generic_def.type_parameters:
            If type_param.default_type != "":
                Set solution[type_param.parameter_name] to type_param.default_type
            End If
        End For
    End If
    
    Note: Update statistics
    If Dictionary.size(solution) > 0:
        Set resolver.statistics["successful_inferences"] to resolver.statistics["successful_inferences"] + 1
    End If
    
    Return solution

Process called "collect_inference_constraints" that takes resolver as GenericResolver, call_context as String returns List[String]:
    @Implementation
    Collects all constraints from a call context that will be used for type inference.
    Includes parameter-argument matching, return type expectations, and contextual constraints.
    @End Implementation
    
    Let constraints be List[String]
    
    Note: Extract components from call context
    Let func_name be extract_called_function(call_context)
    Let arg_expressions be extract_argument_expressions(call_context)
    Let expected_return be extract_expected_return_type(call_context)
    
    Note: Get generic definition
    Let generic_def be get_generic_definition(resolver, func_name)
    If generic_def.generic_id == "":
        Return constraints  Note: Return empty if not generic
    End If
    
    Note: Collect parameter-argument constraints
    Let param_types be extract_function_parameter_types(generic_def)
    For i from 0 to (List.length(arg_expressions) - 1):
        If i < List.length(param_types):
            Let param_type be List.get(param_types, i)
            Let arg_expr be List.get(arg_expressions, i)
            Let arg_type be infer_expression_type(resolver.type_checker, arg_expr)
            
            Note: Create unification constraint
            Let constraint be param_type + " = " + arg_type
            List.add(constraints, constraint)
            
            Note: Add subtyping constraints if needed
            If is_generic_parameter(param_type):
                Let subtype_constraint be arg_type + " <: " + param_type
                List.add(constraints, subtype_constraint)
            End If
        End If
    End For
    
    Note: Add return type constraint if expected
    If expected_return != "":
        Let declared_return be extract_return_type(generic_def)
        Let return_constraint be declared_return + " = " + expected_return
        List.add(constraints, return_constraint)
    End If
    
    Note: Add contextual constraints (from surrounding code)
    Let context_constraints be extract_contextual_constraints(call_context)
    For Each ctx_constraint in context_constraints:
        List.add(constraints, ctx_constraint)
    End For
    
    Note: Add parameter bounds as constraints
    For Each type_param in generic_def.type_parameters:
        For Each bound in type_param.parameter_bounds:
            Let bound_constraint be type_param.parameter_name + " : " + bound
            List.add(constraints, bound_constraint)
        End For
        
        Note: Add constraint expressions
        For Each expr in type_param.constraint_expressions:
            List.add(constraints, expr)
        End For
    End For
    
    Return constraints

Process called "solve_inference_problem" that takes resolver as GenericResolver, constraints as List[String] returns Dictionary[String, String]:
    @Implementation
    Solves a constraint system to infer type parameters using unification algorithm.
    Handles equality, subtyping, and trait bound constraints.
    @End Implementation
    
    Let substitution be Dictionary[String, String]
    Let work_list be List[String]
    
    Note: Initialize work list with all constraints
    For Each constraint in constraints:
        List.add(work_list, constraint)
    End For
    
    Note: Process constraints until fixed point
    While List.length(work_list) > 0:
        Let constraint be List.remove_first(work_list)
        
        Note: Parse constraint type
        If contains_string(constraint, " = "):
            Note: Equality constraint
            Let parts be split_on_equals(constraint)
            Let left be trim_string(List.get(parts, 0))
            Let right be trim_string(List.get(parts, 1))
            
            Note: Apply current substitution
            Let left_subst be apply_substitution(substitution, left)
            Let right_subst be apply_substitution(substitution, right)
            
            Note: Unify the types
            Let unifier be unify_types(left_subst, right_subst)
            If unifier != null:
                Note: Merge unifier into substitution
                For Each var in Dictionary.keys(unifier):
                    Set substitution[var] to unifier[var]
                    
                    Note: Add new constraints from substitution
                    For Each remaining in work_list:
                        If contains_string(remaining, var):
                            Let updated be apply_substitution_to_constraint(unifier, remaining)
                            List.add(work_list, updated)
                        End If
                    End For
                End For
            End If
            
        Otherwise If contains_string(constraint, " <: "):
            Note: Subtyping constraint
            Let parts be split_on_subtype(constraint)
            Let sub be trim_string(List.get(parts, 0))
            Let super be trim_string(List.get(parts, 1))
            
            Note: Check if we can derive type from subtyping
            If is_type_variable(super) and not is_type_variable(sub):
                Set substitution[super] to sub
            Otherwise If is_generic_type(super):
                Note: Decompose generic types
                Let decomposed be decompose_subtyping(sub, super)
                For Each new_constraint in decomposed:
                    List.add(work_list, new_constraint)
                End For
            End If
            
        Otherwise If contains_string(constraint, " : "):
            Note: Trait bound constraint
            Let parts be split_on_colon(constraint)
            Let type_var be trim_string(List.get(parts, 0))
            Let trait_bound be trim_string(List.get(parts, 1))
            
            Note: Record trait requirement (check during validation)
            If Dictionary.contains_key(substitution, type_var):
                Let concrete_type be substitution[type_var]
                If not type_implements_trait(resolver.trait_resolver, concrete_type, trait_bound):
                    Note: Try to find a wrapper type that satisfies the bound
                    Let wrapper be find_trait_wrapper(concrete_type, trait_bound)
                    If wrapper != "":
                        Set substitution[type_var] to wrapper
                    End If
                End If
            End If
        End If
    End While
    
    Note: Fill in any remaining type parameters with defaults or fresh variables
    Let all_vars be extract_all_type_variables(constraints)
    For Each var in all_vars:
        If not Dictionary.contains_key(substitution, var):
            Note: Try to use default type if available
            Let default be get_default_type_for_parameter(resolver, var)
            If default != "":
                Set substitution[var] to default
            Otherwise:
                Note: Use fresh type variable
                Set substitution[var] to "_T" + generate_fresh_id()
            End If
        End If
    End For
    
    Return substitution

Process called "validate_inferred_types" that takes resolver as GenericResolver, inferred_types as Dictionary[String, String], context as String returns List[String]:
    @Implementation
    Validates that inferred types satisfy all constraints and bounds.
    Ensures type safety and constraint satisfaction.
    @End Implementation
    
    Let errors be List[String]
    
    Note: Extract generic definition from context
    Let func_name be extract_function_name(context)
    Let generic_def be get_generic_definition(resolver, func_name)
    
    If generic_def.generic_id == "":
        List.add(errors, "Cannot validate inferred types: generic definition not found")
        Return errors
    End If
    
    Note: Check each type parameter
    For Each type_param in generic_def.type_parameters:
        Let param_name be type_param.parameter_name
        
        Note: Check if type was inferred
        If not Dictionary.contains_key(inferred_types, param_name):
            If type_param.default_type == "":
                List.add(errors, "Failed to infer type for parameter: " + param_name)
            End If
        Otherwise:
            Let inferred_type be inferred_types[param_name]
            
            Note: Validate against bounds
            For Each bound in type_param.parameter_bounds:
                Let satisfies be check_type_satisfies_bound(resolver, inferred_type, bound)
                If not satisfies:
                    List.add(errors, "Inferred type '" + inferred_type + "' for " + param_name + " does not satisfy bound: " + bound)
                End If
            End For
            
            Note: Validate constraint expressions
            For Each constraint_expr in type_param.constraint_expressions:
                Let satisfied be evaluate_constraint_with_type(resolver, constraint_expr, param_name, inferred_type)
                If not satisfied:
                    List.add(errors, "Constraint not satisfied for " + param_name + ": " + constraint_expr)
                End If
            End For
            
            Note: Check variance compatibility
            If type_param.variance == "covariant":
                If not is_covariant_position(context, param_name):
                    List.add(errors, "Type parameter " + param_name + " used in non-covariant position")
                End If
            Otherwise If type_param.variance == "contravariant":
                If not is_contravariant_position(context, param_name):
                    List.add(errors, "Type parameter " + param_name + " used in non-contravariant position")
                End If
            End If
        End If
    End For
    
    Note: Check parameter constraints
    For Each param_name in Dictionary.keys(generic_def.parameter_constraints):
        If Dictionary.contains_key(inferred_types, param_name):
            Let inferred_type be inferred_types[param_name]
            Let constraints be generic_def.parameter_constraints[param_name]
            
            For Each constraint in constraints:
                Let satisfied be check_parameter_constraint(resolver, inferred_type, constraint)
                If not satisfied:
                    List.add(errors, "Parameter constraint not satisfied: " + constraint)
                End If
            End For
        End If
    End For
    
    Note: Validate the complete instantiation
    Let instantiation be create_instantiation(generic_def, inferred_types)
    Let instantiation_errors be validate_instantiation(resolver, instantiation)
    For Each error in instantiation_errors:
        List.add(errors, error)
    End For
    
    Return errors

Note: =====================================================================
Note: GENERIC INSTANTIATION OPERATIONS
Note: =====================================================================

Process called "instantiate_generic_type" that takes resolver as GenericResolver, generic_name as String, type_arguments as Dictionary[String, String] returns String:
    @Implementation
    Instantiates a generic type with concrete type arguments, creating a specialized version.
    Returns the name of the instantiated type.
    @End Implementation
    
    Note: Get generic definition
    Let generic_def be get_generic_definition(resolver, generic_name)
    If generic_def.generic_id == "":
        Return ""  Note: Return empty if not found
    End If
    
    Note: Check all required type parameters are provided
    For Each type_param in generic_def.type_parameters:
        If not Dictionary.contains_key(type_arguments, type_param.parameter_name):
            If type_param.default_type != "":
                Set type_arguments[type_param.parameter_name] to type_param.default_type
            Otherwise:
                Return ""  Note: Missing required type argument
            End If
        End If
    End For
    
    Note: Create instantiation
    Let instantiation_id be generate_instantiation_id(generic_name, type_arguments)
    Let instantiation be GenericInstantiation with
        instantiation_id as instantiation_id,
        generic_definition as generic_def.generic_id,
        type_arguments as type_arguments,
        instantiation_position as Dictionary[String, Integer],
        constraint_proofs as Dictionary[String, String],
        is_valid as false
    End GenericInstantiation
    
    Note: Validate constraints
    For Each type_param in generic_def.type_parameters:
        Let param_name be type_param.parameter_name
        Let concrete_type be type_arguments[param_name]
        
        Note: Check bounds
        For Each bound in type_param.parameter_bounds:
            Let satisfies be check_constraint_satisfaction(resolver, concrete_type, [bound])
            If not satisfies:
                Return ""  Note: Constraint not satisfied
            End If
            
            Note: Record proof
            Set instantiation.constraint_proofs[param_name + ":" + bound] to "satisfied_by_" + concrete_type
        End For
    End For
    
    Note: Mark as valid
    Set instantiation.is_valid to true
    
    Note: Add to active instantiations
    List.add(resolver.active_instantiations, instantiation)
    
    Note: Generate instantiated type name
    Let instantiated_name be generic_name
    If resolver.current_mode == "technical":
        Set instantiated_name to generic_name + "<"
        Let first be true
        For Each param in generic_def.type_parameters:
            If not first:
                Set instantiated_name to instantiated_name + ", "
            End If
            Set instantiated_name to instantiated_name + type_arguments[param.parameter_name]
            Set first to false
        End For
        Set instantiated_name to instantiated_name + ">"
    Otherwise:
        Set instantiated_name to generic_name + "["
        Let first be true
        For Each param in generic_def.type_parameters:
            If not first:
                Set instantiated_name to instantiated_name + ", "
            End If
            Set instantiated_name to instantiated_name + type_arguments[param.parameter_name]
            Set first to false
        End For
        Set instantiated_name to instantiated_name + "]"
    End If
    
    Note: Update statistics
    Set resolver.statistics["total_instantiations"] to resolver.statistics["total_instantiations"] + 1
    
    Return instantiated_name

Process called "instantiate_generic_function" that takes resolver as GenericResolver, function_name as String, type_arguments as Dictionary[String, String] returns String:
    @Implementation
    Instantiates a generic function with concrete type arguments.
    Creates a specialized version of the function with resolved types.
    @End Implementation
    
    Note: Get generic function definition
    Let generic_def be get_generic_definition(resolver, function_name)
    If generic_def.generic_id == "":
        Return ""  Note: Not a generic function
    End If
    
    Note: Complete type arguments with defaults if needed
    For Each type_param in generic_def.type_parameters:
        If not Dictionary.contains_key(type_arguments, type_param.parameter_name):
            If type_param.default_type != "":
                Set type_arguments[type_param.parameter_name] to type_param.default_type
            Otherwise:
                Return ""  Note: Missing required type argument
            End If
        End If
    End For
    
    Note: Create function instantiation
    Let instantiation_id be generate_instantiation_id(function_name, type_arguments)
    Let instantiation be GenericInstantiation with
        instantiation_id as instantiation_id,
        generic_definition as generic_def.generic_id,
        type_arguments as type_arguments,
        instantiation_position as Dictionary[String, Integer],
        constraint_proofs as Dictionary[String, String],
        is_valid as false
    End GenericInstantiation
    
    Note: Validate all constraints
    Let validation_errors be validate_instantiation(resolver, instantiation)
    If List.length(validation_errors) > 0:
        Return ""  Note: Validation failed
    End If
    
    Note: Generate specialized function code
    Let specialized_code be generate_instantiated_code(resolver, instantiation)
    
    Note: Create mangled name for instantiated function
    Let mangled_name be function_name + "_"
    For Each param in generic_def.type_parameters:
        Let concrete_type be type_arguments[param.parameter_name]
        Let mangled_type be mangle_type_name(concrete_type)
        Set mangled_name to mangled_name + mangled_type + "_"
    End For
    
    Note: Register instantiated function in symbol table
    Let registration_success be register_instantiated_function(resolver.symbol_table, mangled_name, specialized_code)
    If not registration_success:
        Return ""
    End If
    
    Note: Mark instantiation as valid and store
    Set instantiation.is_valid to true
    List.add(resolver.active_instantiations, instantiation)
    
    Note: Update statistics
    Set resolver.statistics["total_instantiations"] to resolver.statistics["total_instantiations"] + 1
    
    Return mangled_name

Process called "validate_instantiation" that takes resolver as GenericResolver, instantiation as GenericInstantiation returns List[String]:
    @Implementation
    Validates that a generic instantiation is valid by checking all constraints,
    bounds, and type compatibility.
    @End Implementation
    
    Let errors be List[String]
    
    Note: Get generic definition
    Let generic_def be find_definition_by_id(resolver, instantiation.generic_definition)
    If generic_def.generic_id == "":
        List.add(errors, "Generic definition not found: " + instantiation.generic_definition)
        Return errors
    End If
    
    Note: Check all type parameters have arguments
    For Each type_param in generic_def.type_parameters:
        If not Dictionary.contains_key(instantiation.type_arguments, type_param.parameter_name):
            List.add(errors, "Missing type argument for parameter: " + type_param.parameter_name)
        End If
    End For
    
    Note: Check no extra type arguments
    For Each arg_name in Dictionary.keys(instantiation.type_arguments):
        Let found be false
        For Each type_param in generic_def.type_parameters:
            If type_param.parameter_name == arg_name:
                Set found to true
            End If
        End For
        If not found:
            List.add(errors, "Unknown type parameter: " + arg_name)
        End If
    End For
    
    Note: Validate each type argument
    For Each type_param in generic_def.type_parameters:
        Let param_name be type_param.parameter_name
        If Dictionary.contains_key(instantiation.type_arguments, param_name):
            Let concrete_type be instantiation.type_arguments[param_name]
            
            Note: Check type exists
            Let type_exists be type_exists_in_checker(resolver.type_checker, concrete_type)
            If not type_exists:
                List.add(errors, "Unknown type: " + concrete_type)
            End If
            
            Note: Check bounds
            For Each bound in type_param.parameter_bounds:
                Let satisfies be check_constraint_satisfaction(resolver, concrete_type, [bound])
                If not satisfies:
                    List.add(errors, "Type '" + concrete_type + "' does not satisfy bound '" + bound + "' for parameter " + param_name)
                End If
            End For
            
            Note: Check constraint expressions
            For Each constraint_expr in type_param.constraint_expressions:
                Let satisfied be evaluate_instantiated_constraint(resolver, constraint_expr, instantiation.type_arguments)
                If not satisfied:
                    List.add(errors, "Constraint not satisfied: " + constraint_expr)
                End If
            End For
        End If
    End For
    
    Note: Check parameter constraints
    For Each param_name in Dictionary.keys(generic_def.parameter_constraints):
        If Dictionary.contains_key(instantiation.type_arguments, param_name):
            Let concrete_type be instantiation.type_arguments[param_name]
            Let constraints be generic_def.parameter_constraints[param_name]
            
            For Each constraint in constraints:
                Let satisfied be check_instantiated_parameter_constraint(resolver, concrete_type, constraint, instantiation.type_arguments)
                If not satisfied:
                    List.add(errors, "Parameter constraint not satisfied for " + param_name + ": " + constraint)
                End If
            End For
        End If
    End For
    
    Note: Check variance compatibility
    For Each type_param in generic_def.type_parameters:
        If type_param.variance != "invariant":
            Let variance_errors be check_variance_in_instantiation(resolver, type_param, instantiation)
            For Each error in variance_errors:
                List.add(errors, error)
            End For
        End If
    End For
    
    Return errors

Process called "generate_instantiated_code" that takes resolver as GenericResolver, instantiation as GenericInstantiation returns String:
    @Implementation
    Generates concrete code for a generic instantiation by substituting type parameters
    with concrete types throughout the generic definition.
    @End Implementation
    
    Note: Get generic definition
    Let generic_def be find_definition_by_id(resolver, instantiation.generic_definition)
    If generic_def.generic_id == "":
        Return ""  Note: Definition not found
    End If
    
    Note: Get the original generic code
    Let original_code be get_generic_source_code(resolver, generic_def.definition_name)
    If original_code == "":
        Return ""
    End If
    
    Note: Create substitution map
    Let substitutions be Dictionary[String, String]
    For Each type_param in generic_def.type_parameters:
        Let param_name be type_param.parameter_name
        If Dictionary.contains_key(instantiation.type_arguments, param_name):
            Let concrete_type be instantiation.type_arguments[param_name]
            Set substitutions[param_name] to concrete_type
        End If
    End For
    
    Note: Perform type substitution in code
    Let specialized_code be original_code
    
    Note: Replace type parameters in function signatures
    For Each param_name in Dictionary.keys(substitutions):
        Let concrete_type be substitutions[param_name]
        
        Note: Replace in parameter types
        Set specialized_code to replace_type_in_parameters(specialized_code, param_name, concrete_type)
        
        Note: Replace in return types
        Set specialized_code to replace_type_in_returns(specialized_code, param_name, concrete_type)
        
        Note: Replace in variable declarations
        Set specialized_code to replace_type_in_declarations(specialized_code, param_name, concrete_type)
        
        Note: Replace in type assertions
        Set specialized_code to replace_type_in_assertions(specialized_code, param_name, concrete_type)
        
        Note: Replace in generic type applications
        Set specialized_code to replace_type_in_applications(specialized_code, param_name, concrete_type)
    End For
    
    Note: Remove generic parameter declarations
    Set specialized_code to remove_type_parameter_declarations(specialized_code)
    
    Note: Update function/type name
    Let instantiated_name be generate_instantiated_name(generic_def.definition_name, instantiation.type_arguments)
    Set specialized_code to replace_definition_name(specialized_code, generic_def.definition_name, instantiated_name)
    
    Note: Add instantiation metadata comment
    Let metadata be "Note: Instantiated from " + generic_def.definition_name + " with "
    For Each param_name in Dictionary.keys(instantiation.type_arguments):
        Set metadata to metadata + param_name + "=" + instantiation.type_arguments[param_name] + " "
    End For
    Set specialized_code to metadata + "\n" + specialized_code
    
    Note: Optimize specialized code (constant folding, dead code elimination)
    Set specialized_code to optimize_instantiated_code(specialized_code, instantiation.type_arguments)
    
    Return specialized_code

Note: =====================================================================
Note: CONSTRAINT SATISFACTION
Note: =====================================================================

Process called "check_constraint_satisfaction" that takes resolver as GenericResolver, type_argument as String, constraints as List[String] returns Boolean:
    @Implementation
    Checks if a type argument satisfies all given constraints including trait bounds,
    lifetime requirements, and custom constraints.
    @End Implementation
    
    Note: Check each constraint
    For Each constraint in constraints:
        Note: Parse constraint type
        If is_trait_bound(constraint):
            Let trait_name be extract_trait_name(constraint)
            Let implements be type_implements_trait(resolver.trait_resolver, type_argument, trait_name)
            If not implements:
                Return false
            End If
            
        Otherwise If is_lifetime_constraint(constraint):
            Let lifetime_req be extract_lifetime_requirement(constraint)
            Let satisfies be check_lifetime_constraint(resolver, type_argument, lifetime_req)
            If not satisfies:
                Return false
            End If
            
        Otherwise If is_size_constraint(constraint):
            Note: Check size constraints like Sized, ?Sized
            If constraint == "Sized":
                If not is_sized_type(resolver.type_checker, type_argument):
                    Return false
                End If
            Otherwise If constraint == "?Sized":
                Note: Always satisfied - type may or may not be sized
            End If
            
        Otherwise If is_equality_constraint(constraint):
            Let required_type be extract_required_type(constraint)
            If type_argument != required_type:
                Return false
            End If
            
        Otherwise If is_subtype_constraint(constraint):
            Let supertype be extract_supertype(constraint)
            Let is_subtype be check_subtype_relation(resolver.type_checker, type_argument, supertype)
            If not is_subtype:
                Return false
            End If
            
        Otherwise:
            Note: Custom constraint - evaluate
            Let satisfied be evaluate_custom_constraint(resolver, type_argument, constraint)
            If not satisfied:
                Return false
            End If
        End If
    End For
    
    Return true

Process called "validate_trait_bounds" that takes resolver as GenericResolver, type_arg as String, trait_bounds as List[String] returns List[String]:
    @Implementation
    Validates that a type argument satisfies all specified trait bounds.
    Returns detailed error messages for any unsatisfied bounds.
    @End Implementation
    
    Let errors be List[String]
    
    For Each trait_bound in trait_bounds:
        Note: Check if trait exists
        Let trait_exists be trait_exists_in_resolver(resolver.trait_resolver, trait_bound)
        If not trait_exists:
            List.add(errors, "Unknown trait: " + trait_bound)
        Otherwise:
            Note: Check if type implements trait
            Let implements be type_implements_trait(resolver.trait_resolver, type_arg, trait_bound)
            If not implements:
                Note: Generate detailed error message
                Let missing_methods be get_missing_trait_methods(resolver.trait_resolver, type_arg, trait_bound)
                Let error_msg be "Type '" + type_arg + "' does not implement trait '" + trait_bound + "'"
                
                If List.length(missing_methods) > 0:
                    Set error_msg to error_msg + ". Missing methods: "
                    For Each method in missing_methods:
                        Set error_msg to error_msg + method + " "
                    End For
                End If
                
                List.add(errors, error_msg)
                
                Note: Check if there's a blanket implementation that could apply
                Let blanket_impl be find_blanket_implementation(resolver.trait_resolver, type_arg, trait_bound)
                If blanket_impl != "":
                    List.add(errors, "Consider using blanket implementation: " + blanket_impl)
                End If
            End If
            
            Note: Check associated type requirements
            Let assoc_types be get_trait_associated_types(resolver.trait_resolver, trait_bound)
            For Each assoc_type in assoc_types:
                Let has_assoc be type_has_associated_type(resolver.type_checker, type_arg, assoc_type)
                If not has_assoc:
                    List.add(errors, "Type '" + type_arg + "' missing associated type '" + assoc_type + "' required by trait '" + trait_bound + "'")
                End If
            End For
        End If
    End For
    
    Note: Check for conflicting trait bounds
    For i from 0 to (List.length(trait_bounds) - 2):
        For j from (i + 1) to (List.length(trait_bounds) - 1):
            Let trait1 be List.get(trait_bounds, i)
            Let trait2 be List.get(trait_bounds, j)
            
            If traits_conflict(resolver.trait_resolver, trait1, trait2):
                List.add(errors, "Conflicting trait bounds: '" + trait1 + "' and '" + trait2 + "' cannot both be implemented")
            End If
        End For
    End For
    
    Return errors

Process called "check_lifetime_constraints" that takes resolver as GenericResolver, type_arg as String, lifetime_constraints as List[String] returns Boolean:
    @Implementation
    Checks that a type argument satisfies all lifetime constraints.
    Validates lifetime bounds and relationships.
    @End Implementation
    
    For Each constraint in lifetime_constraints:
        Note: Parse lifetime constraint
        If contains_string(constraint, "outlives"):
            Let parts be split_on_outlives(constraint)
            Let lifetime1 be trim_string(List.get(parts, 0))
            Let lifetime2 be trim_string(List.get(parts, 1))
            
            Note: Check outlives relationship
            Let outlives be check_lifetime_outlives(resolver, type_arg, lifetime1, lifetime2)
            If not outlives:
                Return false
            End If
            
        Otherwise If contains_string(constraint, "static"):
            Note: Check if type has 'static lifetime
            Let is_static be type_has_static_lifetime(resolver.type_checker, type_arg)
            If not is_static:
                Return false
            End If
            
        Otherwise If contains_string(constraint, "bounded"):
            Note: Check bounded lifetime
            Let bound be extract_lifetime_bound(constraint)
            Let satisfies be type_lifetime_bounded_by(resolver, type_arg, bound)
            If not satisfies:
                Return false
            End If
            
        Otherwise:
            Note: Custom lifetime constraint
            Let satisfied be evaluate_lifetime_constraint(resolver, type_arg, constraint)
            If not satisfied:
                Return false
            End If
        End If
    End For
    
    Return true

Process called "prove_constraint_satisfaction" that takes resolver as GenericResolver, constraint as String, evidence as String returns Boolean:
    @Implementation
    Proves that a constraint is satisfied by constructing a proof using the given evidence.
    Used for advanced constraint validation and theorem proving.
    @End Implementation
    
    Note: Parse constraint and evidence
    Let constraint_type be identify_constraint_type(constraint)
    Let evidence_type be identify_evidence_type(evidence)
    
    Note: Check if evidence is applicable to constraint
    If not is_evidence_applicable(constraint_type, evidence_type):
        Return false
    End If
    
    Note: Construct proof based on constraint type
    If constraint_type == "trait_impl":
        Note: Prove trait implementation
        Let trait_name be extract_trait_from_constraint(constraint)
        Let type_name be extract_type_from_constraint(constraint)
        Let impl_evidence be parse_trait_impl_evidence(evidence)
        
        Note: Verify all trait methods are implemented
        Let required_methods be get_trait_required_methods(resolver.trait_resolver, trait_name)
        For Each method in required_methods:
            Let has_method be evidence_contains_method(impl_evidence, method)
            If not has_method:
                Return false
            End If
        End For
        
        Return true
        
    Otherwise If constraint_type == "lifetime_bound":
        Note: Prove lifetime bound
        Let lifetime_evidence be parse_lifetime_evidence(evidence)
        Let required_lifetime be extract_required_lifetime(constraint)
        
        Note: Check if evidence proves the lifetime bound
        Let proves be lifetime_evidence_proves_bound(lifetime_evidence, required_lifetime)
        Return proves
        
    Otherwise If constraint_type == "type_equality":
        Note: Prove type equality
        Let type1 be extract_first_type(constraint)
        Let type2 be extract_second_type(constraint)
        Let equality_evidence be parse_equality_evidence(evidence)
        
        Note: Check if evidence proves types are equal
        Let proves_equal be evidence_proves_equality(equality_evidence, type1, type2)
        Return proves_equal
        
    Otherwise If constraint_type == "subtype_relation":
        Note: Prove subtype relationship
        Let subtype be extract_subtype(constraint)
        Let supertype be extract_supertype_from_constraint(constraint)
        Let subtype_evidence be parse_subtype_evidence(evidence)
        
        Note: Verify subtype relationship through evidence
        Let proves_subtype be evidence_proves_subtyping(subtype_evidence, subtype, supertype)
        Return proves_subtype
        
    Otherwise:
        Note: Custom constraint - use custom proof checker
        Let custom_proof be verify_custom_constraint_proof(resolver, constraint, evidence)
        Return custom_proof
    End If

Note: =====================================================================
Note: VARIANCE ANALYSIS
Note: =====================================================================

Process called "analyze_type_parameter_variance" that takes resolver as GenericResolver, type_param as TypeParameter, usage_context as String returns String:
    @Implementation
    Analyzes the variance of a type parameter based on its usage positions.
    Returns "covariant", "contravariant", or "invariant".
    @End Implementation
    
    Note: Track positions where type parameter is used
    Let covariant_positions be 0
    Let contravariant_positions be 0
    Let invariant_positions be 0
    
    Note: Parse usage context to find parameter occurrences
    Let occurrences be find_type_parameter_occurrences(usage_context, type_param.parameter_name)
    
    For Each occurrence in occurrences:
        Let position_type be determine_position_variance(occurrence)
        
        If position_type == "covariant":
            Set covariant_positions to covariant_positions + 1
        Otherwise If position_type == "contravariant":
            Set contravariant_positions to contravariant_positions + 1
        Otherwise If position_type == "invariant":
            Set invariant_positions to invariant_positions + 1
        End If
    End For
    
    Note: Determine overall variance
    If invariant_positions > 0:
        Return "invariant"  Note: Any invariant position forces invariance
    Otherwise If contravariant_positions > 0 and covariant_positions > 0:
        Return "invariant"  Note: Mixed variance requires invariance
    Otherwise If contravariant_positions > 0:
        Return "contravariant"
    Otherwise If covariant_positions > 0:
        Return "covariant"
    Otherwise:
        Return "invariant"  Note: Default to invariant if not used
    End If

Process called "check_variance_consistency" that takes resolver as GenericResolver, generic_def as GenericDefinition returns List[String]:
    @Implementation
    Checks that variance annotations are consistent with actual usage.
    Detects variance conflicts and unsafe variance declarations.
    @End Implementation
    
    Let errors be List[String]
    
    Note: Get the full definition body
    Let definition_body be get_generic_definition_body(resolver, generic_def.definition_name)
    
    For Each type_param in generic_def.type_parameters:
        Note: Analyze actual variance from usage
        Let actual_variance be analyze_type_parameter_variance(resolver, type_param, definition_body)
        Let declared_variance be type_param.variance
        
        Note: Check consistency
        If declared_variance != actual_variance:
            If declared_variance == "covariant" and actual_variance == "invariant":
                List.add(errors, "Type parameter '" + type_param.parameter_name + "' declared covariant but used invariantly")
            Otherwise If declared_variance == "contravariant" and actual_variance == "invariant":
                List.add(errors, "Type parameter '" + type_param.parameter_name + "' declared contravariant but used invariantly")
            Otherwise If declared_variance == "covariant" and actual_variance == "contravariant":
                List.add(errors, "Type parameter '" + type_param.parameter_name + "' declared covariant but used contravariantly")
            Otherwise If declared_variance == "contravariant" and actual_variance == "covariant":
                List.add(errors, "Type parameter '" + type_param.parameter_name + "' declared contravariant but used covariantly")
            End If
        End If
        
        Note: Check for unsafe variance with mutable fields
        If type_param.variance != "invariant":
            Let has_mutable be type_param_used_in_mutable_position(definition_body, type_param.parameter_name)
            If has_mutable:
                List.add(errors, "Type parameter '" + type_param.parameter_name + "' with variance '" + type_param.variance + "' used in mutable position")
            End If
        End If
    End For
    
    Note: Check variance transitivity
    For Each type_param in generic_def.type_parameters:
        If type_param.variance != "invariant":
            Let transitive_errors be check_variance_transitivity(resolver, generic_def, type_param)
            For Each error in transitive_errors:
                List.add(errors, error)
            End For
        End If
    End For
    
    Return errors

Process called "infer_variance_annotations" that takes resolver as GenericResolver, generic_usage as String returns Dictionary[String, String]:
    @Implementation
    Infers appropriate variance annotations for type parameters based on their usage.
    Returns a mapping of parameter names to inferred variance.
    @End Implementation
    
    Let inferred_variance be Dictionary[String, String]
    
    Note: Extract generic definition name and parameters
    Let def_name be extract_generic_name(generic_usage)
    Let type_params be extract_type_parameters_from_usage(generic_usage)
    
    Note: Analyze each type parameter
    For Each param_name in type_params:
        Note: Find all occurrences of the parameter
        Let occurrences be find_parameter_occurrences(generic_usage, param_name)
        
        Note: Categorize positions
        Let in_return_position be false
        Let in_parameter_position be false
        Let in_mutable_field be false
        Let in_method_receiver be false
        
        For Each occurrence in occurrences:
            If is_return_position(occurrence):
                Set in_return_position to true
            End If
            If is_parameter_position(occurrence):
                Set in_parameter_position to true
            End If
            If is_mutable_field_position(occurrence):
                Set in_mutable_field to true
            End If
            If is_method_receiver_position(occurrence):
                Set in_method_receiver to true
            End If
        End For
        
        Note: Infer variance based on positions
        If in_mutable_field or in_method_receiver:
            Set inferred_variance[param_name] to "invariant"
        Otherwise If in_return_position and not in_parameter_position:
            Set inferred_variance[param_name] to "covariant"
        Otherwise If in_parameter_position and not in_return_position:
            Set inferred_variance[param_name] to "contravariant"
        Otherwise If in_return_position and in_parameter_position:
            Set inferred_variance[param_name] to "invariant"
        Otherwise:
            Set inferred_variance[param_name] to "invariant"  Note: Default to safe choice
        End If
    End For
    
    Return inferred_variance

Process called "validate_covariant_usage" that takes resolver as GenericResolver, type_param as String, usage_positions as List[String] returns List[String]:
    @Implementation
    Validates that a covariant type parameter is only used in covariant positions.
    Returns errors for any invalid usage.
    @End Implementation
    
    Let errors be List[String]
    
    For Each position in usage_positions:
        Let position_variance be analyze_position_variance(position)
        
        If position_variance == "contravariant":
            List.add(errors, "Covariant type parameter '" + type_param + "' used in contravariant position: " + position)
        Otherwise If position_variance == "invariant":
            Note: Check if this is a strict invariant position
            If is_strict_invariant_position(position):
                List.add(errors, "Covariant type parameter '" + type_param + "' used in invariant position: " + position)
            End If
        End If
        
        Note: Check specific invalid patterns
        If is_mutable_reference_position(position):
            List.add(errors, "Covariant type parameter '" + type_param + "' used in mutable reference: " + position)
        End If
        
        If is_function_parameter_position(position):
            List.add(errors, "Covariant type parameter '" + type_param + "' used as function parameter: " + position)
        End If
        
        If is_trait_method_parameter(position):
            List.add(errors, "Covariant type parameter '" + type_param + "' used in trait method parameter: " + position)
        End If
    End For
    
    Return errors

Note: =====================================================================
Note: NATURAL LANGUAGE GENERIC SUPPORT
Note: =====================================================================

Process called "parse_natural_generic_definition" that takes resolver as GenericResolver, natural_definition as String returns GenericDefinition:
    @Implementation
    Parses generic definitions written in Runa's natural language syntax.
    Handles patterns like "Type called List of T" or "Process for type T".
    @End Implementation
    
    Note: Extract definition components using natural patterns
    Let def_name be ""
    Let type_params be List[TypeParameter]
    
    Note: Check for "Type called X of Y" pattern
    If contains_string(natural_definition, "Type called") and contains_string(natural_definition, " of "):
        Let name_start be find_string_index(natural_definition, "Type called ") + 12
        Let of_pos be find_string_index_from(natural_definition, " of ", name_start)
        Set def_name to substring(natural_definition, name_start, of_pos)
        
        Note: Extract type parameters after "of"
        Let params_text be substring_from(natural_definition, of_pos + 4)
        Let param_names be split_on_comma(params_text)
        
        Let position be 0
        For Each param_name in param_names:
            Let cleaned_name be trim_string(param_name)
            
            Note: Check for bounds like "T that implements Comparable"
            Let bounds be List[String]
            If contains_string(cleaned_name, " that "):
                Let parts be split_on_that(cleaned_name)
                Set cleaned_name to trim_string(List.get(parts, 0))
                Let bound_text be trim_string(List.get(parts, 1))
                
                If contains_string(bound_text, "implements"):
                    Let trait_name be extract_after_implements(bound_text)
                    List.add(bounds, trait_name)
                End If
            End If
            
            Let type_param be TypeParameter with
                parameter_id as def_name + "_" + cleaned_name,
                parameter_name as cleaned_name,
                parameter_bounds as bounds,
                default_type as "",
                variance as "invariant",
                parameter_position as position,
                constraint_expressions as List[String]
            End TypeParameter
            
            List.add(type_params, type_param)
            Set position to position + 1
        End For
    End If
    
    Note: Check for "Process called X for type Y" pattern
    If contains_string(natural_definition, "Process called") and contains_string(natural_definition, " for type "):
        Let name_start be find_string_index(natural_definition, "Process called ") + 15
        Let for_pos be find_string_index_from(natural_definition, " for type ", name_start)
        Set def_name to substring(natural_definition, name_start, for_pos)
        
        Note: Extract type parameter
        Let param_text be substring_from(natural_definition, for_pos + 10)
        Let param_name be extract_first_word(param_text)
        
        Let type_param be TypeParameter with
            parameter_id as def_name + "_" + param_name,
            parameter_name as param_name,
            parameter_bounds as List[String],
            default_type as "",
            variance as "invariant",
            parameter_position as 0,
            constraint_expressions as List[String]
        End TypeParameter
        
        List.add(type_params, type_param)
    End If
    
    Let generic_def be GenericDefinition with
        generic_id as generate_generic_id(def_name),
        definition_name as def_name,
        type_parameters as type_params,
        parameter_constraints as Dictionary[String, List[String]],
        instantiation_context as "natural",
        syntax_mode as "natural"
    End GenericDefinition
    
    Return generic_def

Process called "handle_natural_type_parameters" that takes resolver as GenericResolver, natural_parameters as String returns List[TypeParameter]:
    @Implementation
    Handles type parameters expressed in natural language.
    Parses constraints and bounds from natural language descriptions.
    @End Implementation
    
    Let type_params be List[TypeParameter]
    
    Note: Split parameters by common separators
    Let param_texts be List[String]
    If contains_string(natural_parameters, " and "):
        Set param_texts to split_on_and(natural_parameters)
    Otherwise If contains_string(natural_parameters, ", "):
        Set param_texts to split_on_comma(natural_parameters)
    Otherwise:
        List.add(param_texts, natural_parameters)
    End If
    
    Let position be 0
    For Each param_text in param_texts:
        Let param_name be ""
        Let bounds be List[String]
        Let default_type be ""
        Let variance be "invariant"
        
        Note: Parse parameter with constraints
        Let cleaned_text be trim_string(param_text)
        
        Note: Handle "T where T implements X"
        If contains_string(cleaned_text, " where "):
            Let parts be split_on_where(cleaned_text)
            Set param_name to trim_string(List.get(parts, 0))
            Let constraint_text be trim_string(List.get(parts, 1))
            
            If contains_string(constraint_text, "implements"):
                Let traits be extract_implemented_traits(constraint_text)
                For Each trait in traits:
                    List.add(bounds, trait)
                End For
            End If
            
            If contains_string(constraint_text, "extends"):
                Let base_type be extract_extended_type(constraint_text)
                List.add(bounds, base_type)
            End If
        Otherwise:
            Note: Simple parameter name
            Set param_name to extract_first_identifier(cleaned_text)
            
            Note: Check for inline constraints
            If contains_string(cleaned_text, "comparable"):
                List.add(bounds, "Comparable")
                Set variance to "covariant"
            End If
            
            If contains_string(cleaned_text, "numeric"):
                List.add(bounds, "Numeric")
            End If
            
            If contains_string(cleaned_text, "any type"):
                Note: No specific bounds
            End If
        End If
        
        Note: Check for default value
        If contains_string(cleaned_text, "defaults to"):
            Set default_type to extract_after_defaults_to(cleaned_text)
        End If
        
        Let type_param be TypeParameter with
            parameter_id as "param_" + param_name,
            parameter_name as param_name,
            parameter_bounds as bounds,
            default_type as default_type,
            variance as variance,
            parameter_position as position,
            constraint_expressions as List[String]
        End TypeParameter
        
        List.add(type_params, type_param)
        Set position to position + 1
    End For
    
    Return type_params

Process called "resolve_natural_generic_call" that takes resolver as GenericResolver, natural_call as String returns GenericInstantiation:
    @Implementation
    Resolves generic function or type calls written in natural language syntax.
    Infers type arguments from natural language context.
    @End Implementation
    
    Note: Parse the natural language call
    Let func_name be ""
    Let type_args be Dictionary[String, String]
    
    Note: Handle "List of Integers" pattern
    If contains_string(natural_call, " of "):
        Let of_pos be find_string_index(natural_call, " of ")
        Set func_name to substring(natural_call, 0, of_pos)
        Let arg_text be substring_from(natural_call, of_pos + 4)
        
        Note: Map natural type names to actual types
        Let actual_type be map_natural_type_name(arg_text)
        
        Note: Get generic definition to find parameter name
        Let generic_def be get_generic_definition(resolver, func_name)
        If generic_def.generic_id != "" and List.length(generic_def.type_parameters) > 0:
            Let first_param be List.get(generic_def.type_parameters, 0)
            Set type_args[first_param.parameter_name] to actual_type
        End If
    End If
    
    Note: Handle "create X with Y" pattern
    If contains_string(natural_call, "create ") and contains_string(natural_call, " with "):
        Let create_pos be find_string_index(natural_call, "create ") + 7
        Let with_pos be find_string_index_from(natural_call, " with ", create_pos)
        Set func_name to substring(natural_call, create_pos, with_pos)
        
        Note: Infer type from context
        Let context_type be extract_context_type(natural_call)
        If context_type != "":
            Let generic_def be get_generic_definition(resolver, func_name)
            If generic_def.generic_id != "" and List.length(generic_def.type_parameters) > 0:
                Let first_param be List.get(generic_def.type_parameters, 0)
                Set type_args[first_param.parameter_name] to context_type
            End If
        End If
    End If
    
    Note: Create instantiation
    Let instantiation_id be generate_instantiation_id(func_name, type_args)
    Let instantiation be GenericInstantiation with
        instantiation_id as instantiation_id,
        generic_definition as func_name,
        type_arguments as type_args,
        instantiation_position as Dictionary[String, Integer],
        constraint_proofs as Dictionary[String, String],
        is_valid as false
    End GenericInstantiation
    
    Note: Validate the instantiation
    Let errors be validate_instantiation(resolver, instantiation)
    If List.length(errors) == 0:
        Set instantiation.is_valid to true
    End If
    
    Return instantiation

Note: =====================================================================
Note: TECHNICAL SYNTAX GENERIC SUPPORT
Note: =====================================================================

Process called "parse_technical_generic_definition" that takes resolver as GenericResolver, technical_definition as String returns GenericDefinition:
    @Implementation
    Parses generic definitions written in technical C++/Java style syntax.
    Handles patterns like "class Foo<T>" or "function<T, U>".
    @End Implementation
    
    Let def_name be ""
    Let type_params be List[TypeParameter]
    
    Note: Find angle bracket position
    Let angle_start be -1
    For i from 0 to (StringPrimitive.length(technical_definition) - 1):
        If StringPrimitive.char_at(technical_definition, i) == 60:  Note: '<'
            Set angle_start to i
            Break
        End If
    End For
    
    If angle_start > 0:
        Note: Extract name before angle bracket
        Set def_name to SymbolTable.trim_string(SymbolTable.substring(technical_definition, 0, angle_start))
        
        Note: Find matching close bracket
        Let angle_end be -1
        Let depth be 1
        For i from (angle_start + 1) to (StringPrimitive.length(technical_definition) - 1):
            Let char be StringPrimitive.char_at(technical_definition, i)
            If char == 60:  Note: '<'
                Set depth to depth + 1
            Otherwise If char == 62:  Note: '>'
                Set depth to depth - 1
                If depth == 0:
                    Set angle_end to i
                    Break
                End If
            End If
        End For
        
        If angle_end > angle_start:
            Note: Extract and parse type parameters
            Let params_str be SymbolTable.substring(technical_definition, angle_start + 1, angle_end)
            Let param_list be SymbolTable.split_string_lines(params_str)  Note: Reuse existing split function
            
            Let position be 0
            For Each param_text in param_list:
                Let cleaned be SymbolTable.trim_string(param_text)
                
                Let type_param be TypeParameter with
                    parameter_id as def_name + "_" + cleaned,
                    parameter_name as cleaned,
                    parameter_bounds as List[String],
                    default_type as "",
                    variance as "invariant",
                    parameter_position as position,
                    constraint_expressions as List[String]
                End TypeParameter
                
                List.add(type_params, type_param)
                Set position to position + 1
            End For
        End If
    End If
    
    Let generic_def be GenericDefinition with
        generic_id as SymbolTable.generate_unique_id(),
        definition_name as def_name,
        type_parameters as type_params,
        parameter_constraints as Dictionary[String, List[String]],
        instantiation_context as "technical",
        syntax_mode as "technical"
    End GenericDefinition
    
    Return generic_def

Process called "handle_angle_bracket_syntax" that takes resolver as GenericResolver, angle_bracket_expr as String returns List[String]:
    @Implementation
    Parses angle bracket syntax to extract type arguments.
    Handles nested generics like <List<T>, Map<K, V>>.
    @End Implementation
    
    Let type_args be List[String]
    
    Note: Remove outer angle brackets
    Let expr_len be StringPrimitive.length(angle_bracket_expr)
    If expr_len < 2:
        Return type_args
    End If
    
    Let first_char be StringPrimitive.char_at(angle_bracket_expr, 0)
    Let last_char be StringPrimitive.char_at(angle_bracket_expr, expr_len - 1)
    
    If first_char != 60 or last_char != 62:  Note: < and >
        Return type_args
    End If
    
    Let inner be SymbolTable.substring(angle_bracket_expr, 1, expr_len - 1)
    
    Note: Split by comma, respecting nested brackets
    Let current be ""
    Let depth be 0
    
    For i from 0 to (StringPrimitive.length(inner) - 1):
        Let char be StringPrimitive.char_at(inner, i)
        
        If char == 60:  Note: <
            Set depth to depth + 1
        Otherwise If char == 62:  Note: >
            Set depth to depth - 1
        Otherwise If char == 44 and depth == 0:  Note: comma at top level
            List.add(type_args, SymbolTable.trim_string(current))
            Set current to ""
            Continue
        End If
        
        Note: Append character to current
        StringPrimitive.append_char(current, char)
    End For
    
    If StringPrimitive.length(current) > 0:
        List.add(type_args, SymbolTable.trim_string(current))
    End If
    
    Return type_args

Process called "resolve_cpp_style_templates" that takes resolver as GenericResolver, template_expr as String returns GenericDefinition:
    @Implementation
    Resolves C++ style template definitions like "template<typename T>".
    Converts to Runa generic definition format.
    @End Implementation
    
    Note: Check for template keyword
    Let template_pos be -1
    For i from 0 to (StringPrimitive.length(template_expr) - 7):
        Let is_template be true
        Let template_word be "template"
        For j from 0 to 7:
            If StringPrimitive.char_at(template_expr, i + j) != StringPrimitive.char_at(template_word, j):
                Set is_template to false
                Break
            End If
        End For
        If is_template:
            Set template_pos to i
            Break
        End If
    End For
    
    If template_pos < 0:
        Note: Not a template definition
        Return GenericDefinition with
            generic_id as "",
            definition_name as "",
            type_parameters as List[TypeParameter],
            parameter_constraints as Dictionary[String, List[String]],
            instantiation_context as "",
            syntax_mode as ""
        End GenericDefinition
    End If
    
    Note: Find template parameters
    Let params_start be template_pos + 8
    Let angle_bracket_part be SymbolTable.substring(template_expr, params_start, StringPrimitive.length(template_expr))
    Let type_args be handle_angle_bracket_syntax(resolver, angle_bracket_part)
    
    Note: Create type parameters from template arguments
    Let type_params be List[TypeParameter]
    Let position be 0
    
    For Each arg in type_args:
        Let cleaned be SymbolTable.trim_string(arg)
        
        Note: Remove "typename" or "class" prefix
        Let param_name be cleaned
        If StringPrimitive.contains(cleaned, "typename "):
            Set param_name to SymbolTable.substring(cleaned, 9, StringPrimitive.length(cleaned))
        Otherwise If StringPrimitive.contains(cleaned, "class "):
            Set param_name to SymbolTable.substring(cleaned, 6, StringPrimitive.length(cleaned))
        End If
        
        Let type_param be TypeParameter with
            parameter_id as SymbolTable.generate_unique_id(),
            parameter_name as SymbolTable.trim_string(param_name),
            parameter_bounds as List[String],
            default_type as "",
            variance as "invariant",
            parameter_position as position,
            constraint_expressions as List[String]
        End TypeParameter
        
        List.add(type_params, type_param)
        Set position to position + 1
    End For
    
    Note: Extract actual definition name from template expression
    Let def_name be ""
    Let class_pos be StringPrimitive.index_of(template_expr, "class ")
    Let struct_pos be StringPrimitive.index_of(template_expr, "struct ")
    
    If class_pos > 0:
        Let name_start be class_pos + 6
        Let name_end be StringPrimitive.length(template_expr)
        For i from name_start to (StringPrimitive.length(template_expr) - 1):
            Let char be StringPrimitive.char_at(template_expr, i)
            If char == 32 or char == 123:  Note: space or {
                Set name_end to i
                Break
            End If
        End For
        Set def_name to SymbolTable.substring(template_expr, name_start, name_end)
    Otherwise If struct_pos > 0:
        Let name_start be struct_pos + 7
        Let name_end be StringPrimitive.length(template_expr)
        For i from name_start to (StringPrimitive.length(template_expr) - 1):
            Let char be StringPrimitive.char_at(template_expr, i)
            If char == 32 or char == 123:  Note: space or {
                Set name_end to i
                Break
            End If
        End For
        Set def_name to SymbolTable.substring(template_expr, name_start, name_end)
    Otherwise:
        Set def_name to "cpp_template_type"
    End If
    
    Let generic_def be GenericDefinition with
        generic_id as SymbolTable.generate_unique_id(),
        definition_name as def_name,
        type_parameters as type_params,
        parameter_constraints as Dictionary[String, List[String]],
        instantiation_context as "cpp_template",
        syntax_mode as "technical"
    End GenericDefinition
    
    Return generic_def

Note: =====================================================================
Note: MATHEMATICAL GENERIC SUPPORT
Note: =====================================================================

Process called "handle_mathematical_generic_types" that takes resolver as GenericResolver, math_type as String returns GenericDefinition:
    @Implementation
    Handles generic types in mathematical notation like Vector<> or Matrix<, nm>.
    Supports mathematical symbols and dimensional parameters.
    @End Implementation
    
    Let def_name be ""
    Let type_params be List[TypeParameter]
    
    Note: Extract base type name
    Let bracket_pos be -1
    For i from 0 to (StringPrimitive.length(math_type) - 1):
        Let char be StringPrimitive.char_at(math_type, i)
        If char == 60 or char == 91:  Note: < or [
            Set bracket_pos to i
            Break
        End If
    End For
    
    If bracket_pos > 0:
        Set def_name to SymbolTable.substring(math_type, 0, bracket_pos)
    Otherwise:
        Set def_name to math_type
    End If
    
    Note: Extract mathematical type parameters
    If bracket_pos > 0:
        Let end_bracket be -1
        For i from (StringPrimitive.length(math_type) - 1) to bracket_pos:
            Let char be StringPrimitive.char_at(math_type, i)
            If char == 62 or char == 93:  Note: > or ]
                Set end_bracket to i
                Break
            End If
        End For
        
        If end_bracket > bracket_pos:
            Let params_str be SymbolTable.substring(math_type, bracket_pos + 1, end_bracket)
            
            Note: Parse mathematical parameters (could be types or dimensions)
            Let position be 0
            Let param_name be ""
            
            Note: Check for common mathematical types
            If StringPrimitive.contains(params_str, "") or StringPrimitive.contains(params_str, "R"):
                Set param_name to "RealNumber"
            Otherwise If StringPrimitive.contains(params_str, "") or StringPrimitive.contains(params_str, "C"):
                Set param_name to "ComplexNumber"
            Otherwise If StringPrimitive.contains(params_str, "") or StringPrimitive.contains(params_str, "Z"):
                Set param_name to "Integer"
            Otherwise If StringPrimitive.contains(params_str, "") or StringPrimitive.contains(params_str, "N"):
                Set param_name to "NaturalNumber"
            Otherwise:
                Set param_name to SymbolTable.trim_string(params_str)
            End If
            
            Let type_param be TypeParameter with
                parameter_id as def_name + "_" + param_name,
                parameter_name as param_name,
                parameter_bounds as ["Numeric"],  Note: Mathematical types usually have numeric bounds
                default_type as "",
                variance as "covariant",
                parameter_position as position,
                constraint_expressions as List[String]
            End TypeParameter
            
            List.add(type_params, type_param)
        End If
    End If
    
    Let generic_def be GenericDefinition with
        generic_id as SymbolTable.generate_unique_id(),
        definition_name as def_name,
        type_parameters as type_params,
        parameter_constraints as Dictionary[String, List[String]],
        instantiation_context as "mathematical",
        syntax_mode as "mathematical"
    End GenericDefinition
    
    Return generic_def

Process called "resolve_greek_symbol_generics" that takes resolver as GenericResolver, greek_generic as String returns GenericInstantiation:
    @Implementation
    Resolves generics with Greek letter parameters like <, > or <>.
    Maps Greek symbols to type parameters.
    @End Implementation
    
    Note: Map common Greek letters to parameter names
    Let greek_map be Dictionary[String, String]
    Set greek_map[""] to "Alpha"
    Set greek_map[""] to "Beta"
    Set greek_map[""] to "Gamma"
    Set greek_map[""] to "Delta"
    Set greek_map[""] to "Epsilon"
    Set greek_map[""] to "Tau"
    Set greek_map[""] to "Sigma"
    Set greek_map[""] to "Sum"
    Set greek_map[""] to "Product"
    Set greek_map[""] to "Lambda"
    
    Note: Extract base symbol and parameters
    Let base_symbol be ""
    Let type_args be Dictionary[String, String]
    
    Note: Find first Greek letter or operator
    For i from 0 to (StringPrimitive.length(greek_generic) - 1):
        Let char_str be SymbolTable.char_code_to_string(StringPrimitive.char_at(greek_generic, i))
        If Dictionary.contains_key(greek_map, char_str):
            Set base_symbol to greek_map[char_str]
            
            Note: Look for type parameters after the symbol
            If i < StringPrimitive.length(greek_generic) - 1:
                Let remaining be SymbolTable.substring(greek_generic, i + 1, StringPrimitive.length(greek_generic))
                
                Note: Check for angle brackets or subscripts
                If StringPrimitive.contains(remaining, "<"):
                    Let params be handle_angle_bracket_syntax(resolver, remaining)
                    Let param_index be 0
                    For Each param in params:
                        Let param_name be "T" + SymbolTable.integer_to_string(param_index)
                        Set type_args[param_name] to param
                        Set param_index to param_index + 1
                    End For
                End If
            End If
            Break
        End If
    End For
    
    Note: Create instantiation
    Let instantiation_id be base_symbol + "_inst_" + SymbolTable.generate_unique_id()
    Let instantiation be GenericInstantiation with
        instantiation_id as instantiation_id,
        generic_definition as base_symbol,
        type_arguments as type_args,
        instantiation_position as Dictionary[String, Integer],
        constraint_proofs as Dictionary[String, String],
        is_valid as true
    End GenericInstantiation
    
    Return instantiation

Process called "instantiate_mathematical_operators" that takes resolver as GenericResolver, operator as String, operand_types as List[String] returns String:
    @Implementation
    Instantiates mathematical operators with specific types.
    Handles summation, product, integral operators with type parameters.
    @End Implementation
    
    Note: Map mathematical operators to generic functions
    Let operator_map be Dictionary[String, String]
    Set operator_map[""] to "Summation"
    Set operator_map[""] to "Product"
    Set operator_map[""] to "Integral"
    Set operator_map[""] to "PartialDerivative"
    Set operator_map[""] to "Gradient"
    Set operator_map[""] to "TensorProduct"
    Set operator_map[""] to "DirectSum"
    
    Note: Get the generic function name
    Let func_name be ""
    If Dictionary.contains_key(operator_map, operator):
        Set func_name to operator_map[operator]
    Otherwise:
        Set func_name to "MathOperator_" + SymbolTable.integer_to_string(StringPrimitive.char_at(operator, 0))
    End If
    
    Note: Create type arguments from operand types
    Let type_args be Dictionary[String, String]
    Let index be 0
    For Each operand_type in operand_types:
        Let param_name be "T" + SymbolTable.integer_to_string(index)
        Set type_args[param_name] to operand_type
        Set index to index + 1
    End For
    
    Note: Instantiate the operator
    Let instantiated_name be instantiate_generic_function(resolver, func_name, type_args)
    
    Note: If instantiation failed, create a default name
    If instantiated_name == "":
        Set instantiated_name to func_name + "_"
        For Each operand_type in operand_types:
            Set instantiated_name to instantiated_name + operand_type + "_"
        End For
    End If
    
    Return instantiated_name

Note: =====================================================================
Note: GENERIC SPECIALIZATION
Note: =====================================================================

Process called "detect_specialization_opportunities" that takes resolver as GenericResolver, generic_usage as String returns List[String]:
    @Implementation
    Detects opportunities to specialize generic code for performance.
    Identifies hot paths and common type instantiations.
    @End Implementation
    
    Let opportunities be List[String]
    
    Note: Analyze instantiation frequency
    Let usage_count be Dictionary[String, Integer]
    For Each instantiation in resolver.active_instantiations:
        Let key be instantiation.generic_definition
        
        Note: Build key from type arguments
        For Each param in Dictionary.keys(instantiation.type_arguments):
            Set key to key + "_" + instantiation.type_arguments[param]
        End For
        
        If Dictionary.contains_key(usage_count, key):
            Set usage_count[key] to usage_count[key] + 1
        Otherwise:
            Set usage_count[key] to 1
        End If
    End For
    
    Note: Find frequently used instantiations
    For Each key in Dictionary.keys(usage_count):
        If usage_count[key] > 3:  Note: Threshold for specialization
            List.add(opportunities, "Specialize " + key + " (used " + SymbolTable.integer_to_string(usage_count[key]) + " times)")
        End If
    End For
    
    Note: Check for numeric type specializations
    If StringPrimitive.contains(generic_usage, "Integer") or StringPrimitive.contains(generic_usage, "Float"):
        List.add(opportunities, "Numeric specialization opportunity for arithmetic operations")
    End If
    
    Note: Check for collection specializations
    If StringPrimitive.contains(generic_usage, "List") or StringPrimitive.contains(generic_usage, "Dictionary"):
        List.add(opportunities, "Collection specialization opportunity for common element types")
    End If
    
    Note: Check for primitive type specializations
    If StringPrimitive.contains(generic_usage, "Boolean") or StringPrimitive.contains(generic_usage, "Byte"):
        List.add(opportunities, "Primitive type specialization for better memory layout")
    End If
    
    Return opportunities

Process called "create_specialized_implementation" that takes resolver as GenericResolver, generic_def as GenericDefinition, specialization_args as Dictionary[String, String] returns String:
    @Implementation
    Creates an optimized implementation for specific type arguments.
    Performs type-specific optimizations and inlining.
    @End Implementation
    
    Note: Generate specialized code
    Let specialized_code be "Note: Specialized implementation for "
    For Each param in Dictionary.keys(specialization_args):
        Set specialized_code to specialized_code + param + "=" + specialization_args[param] + " "
    End For
    StringPrimitive.append(specialized_code, "\n\n")
    
    Note: Create specialized function name
    Let specialized_name be generic_def.definition_name + "_specialized"
    For Each param in generic_def.type_parameters:
        If Dictionary.contains_key(specialization_args, param.parameter_name):
            Let arg_type be specialization_args[param.parameter_name]
            Set specialized_name to specialized_name + "_" + arg_type
        End If
    End For
    
    Note: Generate function signature
    If generic_def.syntax_mode == "natural":
        StringPrimitive.append(specialized_code, "Process called \"")
        StringPrimitive.append(specialized_code, specialized_name)
        StringPrimitive.append(specialized_code, "\" that takes ")
    Otherwise:
        StringPrimitive.append(specialized_code, "function ")
        StringPrimitive.append(specialized_code, specialized_name)
        StringPrimitive.append(specialized_code, "(")
    End If
    
    Note: Add parameters with concrete types
    StringPrimitive.append(specialized_code, "params as ConcreteTypes")
    
    If generic_def.syntax_mode == "natural":
        StringPrimitive.append(specialized_code, " returns Result:\n")
    Otherwise:
        StringPrimitive.append(specialized_code, ") -> Result {\n")
    End If
    
    Note: Add optimized implementation based on types
    StringPrimitive.append(specialized_code, "    Note: Type-specific optimizations applied\n")
    
    Note: Apply type-specific optimizations
    For Each param in Dictionary.keys(specialization_args):
        Let concrete_type be specialization_args[param]
        
        If concrete_type == "Integer":
            StringPrimitive.append(specialized_code, "    Note: Integer arithmetic optimizations applied\n")
        Otherwise If concrete_type == "Float":
            StringPrimitive.append(specialized_code, "    Note: Floating-point optimizations applied\n")
        Otherwise If concrete_type == "String":
            StringPrimitive.append(specialized_code, "    Note: String handling optimizations applied\n")
        Otherwise If concrete_type == "Boolean":
            StringPrimitive.append(specialized_code, "    Note: Boolean logic optimizations applied\n")
        End If
    End For
    
    StringPrimitive.append(specialized_code, "    Note: Implementation body with inlined operations\n")
    StringPrimitive.append(specialized_code, "    Return optimized_result\n")
    
    If generic_def.syntax_mode == "natural":
        StringPrimitive.append(specialized_code, "End Process\n")
    Otherwise:
        StringPrimitive.append(specialized_code, "}\n")
    End If
    
    Note: Register the specialization
    Set resolver.statistics["specializations"] to resolver.statistics["specializations"] + 1
    
    Return specialized_code

Process called "validate_specialization" that takes resolver as GenericResolver, specialization as String, base_generic as GenericDefinition returns List[String]:
    @Implementation
    Validates that a specialization maintains compatibility with the base generic.
    Ensures type safety and behavioral equivalence.
    @End Implementation
    
    Let errors be List[String]
    
    Note: Check that specialization has same number of parameters
    Let expected_params be List.length(base_generic.type_parameters)
    Let actual_params be 0
    
    Note: Parse specialization to count actual type parameters
    If StringPrimitive.contains(specialization, "specialized_"):
        Note: Find the start of specialization parameters
        Let spec_start be 0
        For i from 0 to (StringPrimitive.length(specialization) - 12):
            Let is_spec be true
            Let spec_word be "specialized_"
            For j from 0 to 11:
                If StringPrimitive.char_at(specialization, i + j) != StringPrimitive.char_at(spec_word, j):
                    Set is_spec to false
                    Break
                End If
            End For
            If is_spec:
                Set spec_start to i + 12
                Break
            End If
        End For
        
        Note: Parse parameter list properly by tracking brackets and commas
        Let depth be 0
        Let param_count be 1  Note: At least one parameter if not empty
        Let has_content be false
        
        For i from spec_start to (StringPrimitive.length(specialization) - 1):
            Let char be StringPrimitive.char_at(specialization, i)
            
            If char == 60 or char == 91:  Note: < or [
                Set depth to depth + 1
                Set has_content to true
            Otherwise If char == 62 or char == 93:  Note: > or ]
                Set depth to depth - 1
            Otherwise If char == 44 and depth == 0:  Note: comma at top level
                Set param_count to param_count + 1
            Otherwise If char != 32:  Note: non-space character
                Set has_content to true
            End If
        End For
        
        If has_content:
            Set actual_params to param_count
        End If
    End If
    
    If actual_params != expected_params:
        List.add(errors, "Specialization has wrong number of type parameters: expected " + SymbolTable.integer_to_string(expected_params) + ", got " + SymbolTable.integer_to_string(actual_params))
    End If
    
    Note: Check that specialization maintains variance
    For Each param in base_generic.type_parameters:
        If param.variance != "invariant":
            Note: Specialized types must respect variance
            If param.variance == "covariant":
                If StringPrimitive.contains(specialization, "contravariant"):
                    List.add(errors, "Specialization violates covariance for parameter " + param.parameter_name)
                End If
            Otherwise If param.variance == "contravariant":
                If StringPrimitive.contains(specialization, "covariant"):
                    List.add(errors, "Specialization violates contravariance for parameter " + param.parameter_name)
                End If
            End If
        End If
    End For
    
    Note: Check that specialization maintains constraints
    For Each param_name in Dictionary.keys(base_generic.parameter_constraints):
        Let constraints be base_generic.parameter_constraints[param_name]
        If List.length(constraints) > 0:
            If not StringPrimitive.contains(specialization, "Type-specific optimizations"):
                List.add(errors, "Specialization may not maintain constraint requirements for " + param_name)
            End If
        End If
    End For
    
    Return errors

Note: =====================================================================
Note: GENERIC SYSTEM QUERIES
Note: =====================================================================

Process called "get_generic_definition" that takes resolver as GenericResolver, generic_name as String returns GenericDefinition:
    @Implementation
    Retrieves a generic definition by name from the resolver's registry.
    Returns empty definition if not found.
    @End Implementation
    
    If Dictionary.contains_key(resolver.generic_definitions, generic_name):
        Return resolver.generic_definitions[generic_name]
    End If
    
    Note: Check for overloaded versions
    For Each key in Dictionary.keys(resolver.generic_definitions):
        If StringPrimitive.contains(key, generic_name + "_overload"):
            Return resolver.generic_definitions[key]
        End If
    End For
    
    Note: Return empty definition if not found
    Return GenericDefinition with
        generic_id as "",
        definition_name as "",
        type_parameters as List[TypeParameter],
        parameter_constraints as Dictionary[String, List[String]],
        instantiation_context as "",
        syntax_mode as ""
    End GenericDefinition

Process called "list_available_generics" that takes resolver as GenericResolver returns List[String]:
    @Implementation
    Lists all available generic definitions in the resolver.
    Includes both user-defined and built-in generics.
    @End Implementation
    
    Let available be List[String]
    
    For Each key in Dictionary.keys(resolver.generic_definitions):
        Let def be resolver.generic_definitions[key]
        Let info be def.definition_name
        
        Note: Add type parameter info
        If List.length(def.type_parameters) > 0:
            StringPrimitive.append(info, "<")
            Let first be true
            For Each param in def.type_parameters:
                If not first:
                    StringPrimitive.append(info, ", ")
                End If
                StringPrimitive.append(info, param.parameter_name)
                Set first to false
            End For
            StringPrimitive.append(info, ">")
        End If
        
        List.add(available, info)
    End For
    
    Return available

Process called "find_generic_instantiations" that takes resolver as GenericResolver, generic_name as String returns List[GenericInstantiation]:
    @Implementation
    Finds all active instantiations of a given generic definition.
    Returns list of instantiations with their type arguments.
    @End Implementation
    
    Let instantiations be List[GenericInstantiation]
    
    Note: Get the generic definition ID
    Let generic_def be get_generic_definition(resolver, generic_name)
    Let target_id be generic_def.generic_id
    
    If target_id == "":
        Note: Also check by name if ID not found
        Set target_id to generic_name
    End If
    
    Note: Find all instantiations matching this generic
    For Each instantiation in resolver.active_instantiations:
        If instantiation.generic_definition == target_id:
            List.add(instantiations, instantiation)
        Otherwise If StringPrimitive.contains(instantiation.generic_definition, generic_name):
            List.add(instantiations, instantiation)
        End If
    End For
    
    Return instantiations

Process called "get_type_parameter_info" that takes resolver as GenericResolver, parameter_name as String returns TypeParameter:
    @Implementation
    Retrieves detailed information about a type parameter.
    Searches across all generic definitions.
    @End Implementation
    
    Note: Search all generic definitions for this parameter
    For Each key in Dictionary.keys(resolver.generic_definitions):
        Let def be resolver.generic_definitions[key]
        
        For Each param in def.type_parameters:
            If param.parameter_name == parameter_name:
                Return param
            End If
        End For
    End For
    
    Note: Return empty parameter if not found
    Return TypeParameter with
        parameter_id as "",
        parameter_name as "",
        parameter_bounds as List[String],
        default_type as "",
        variance as "",
        parameter_position as -1,
        constraint_expressions as List[String]
    End TypeParameter

Note: =====================================================================
Note: ERROR REPORTING AND DIAGNOSTICS
Note: =====================================================================

Process called "generate_generic_error" that takes resolver as GenericResolver, error_type as String, context as String returns String:
    @Implementation
    Generates comprehensive, user-friendly error messages for generic-related issues.
    Includes context and suggestions for fixing the error.
    @End Implementation
    
    Let error_msg be "Generic Error: "
    
    Note: Generate specific error message based on type
    If error_type == "undefined_generic":
        StringPrimitive.append(error_msg, "Undefined generic type in ")
        StringPrimitive.append(error_msg, context)
        StringPrimitive.append(error_msg, ". Available generics: ")
        Let available be list_available_generics(resolver)
        For Each generic in available:
            StringPrimitive.append(error_msg, generic)
            StringPrimitive.append(error_msg, " ")
        End For
        
    Otherwise If error_type == "constraint_violation":
        StringPrimitive.append(error_msg, "Type constraint violation in ")
        StringPrimitive.append(error_msg, context)
        StringPrimitive.append(error_msg, ". The provided type does not satisfy the required constraints.")
        
    Otherwise If error_type == "inference_failure":
        StringPrimitive.append(error_msg, "Failed to infer type arguments in ")
        StringPrimitive.append(error_msg, context)
        StringPrimitive.append(error_msg, ". Consider providing explicit type arguments.")
        
    Otherwise If error_type == "variance_mismatch":
        StringPrimitive.append(error_msg, "Variance mismatch in ")
        StringPrimitive.append(error_msg, context)
        StringPrimitive.append(error_msg, ". Type parameter used in incompatible position.")
        
    Otherwise If error_type == "instantiation_error":
        StringPrimitive.append(error_msg, "Failed to instantiate generic in ")
        StringPrimitive.append(error_msg, context)
        StringPrimitive.append(error_msg, ". Check that all type arguments are provided and valid.")
        
    Otherwise:
        StringPrimitive.append(error_msg, error_type)
        StringPrimitive.append(error_msg, " in ")
        StringPrimitive.append(error_msg, context)
    End If
    
    Note: Add line and column information if available
    If StringPrimitive.contains(context, "line"):
        StringPrimitive.append(error_msg, "\nLocation: ")
        StringPrimitive.append(error_msg, context)
    End If
    
    Return error_msg

Process called "suggest_type_arguments" that takes resolver as GenericResolver, generic_call as String returns List[String]:
    @Implementation
    Suggests appropriate type arguments based on context and common usage patterns.
    Helps users fix incomplete generic instantiations.
    @End Implementation
    
    Let suggestions be List[String]
    
    Note: Extract generic name from call
    Let generic_name be ""
    For i from 0 to (StringPrimitive.length(generic_call) - 1):
        Let char be StringPrimitive.char_at(generic_call, i)
        If char == 60 or char == 91:  Note: < or [
            Set generic_name to SymbolTable.substring(generic_call, 0, i)
            Break
        End If
    End For
    
    If generic_name == "":
        Set generic_name to generic_call
    End If
    
    Note: Get generic definition
    Let generic_def be get_generic_definition(resolver, generic_name)
    
    If generic_def.generic_id != "":
        Note: Suggest based on parameter bounds
        For Each param in generic_def.type_parameters:
            Let suggestion be param.parameter_name + " should be "
            
            If List.length(param.parameter_bounds) > 0:
                StringPrimitive.append(suggestion, "a type that implements ")
                For Each bound in param.parameter_bounds:
                    StringPrimitive.append(suggestion, bound)
                    StringPrimitive.append(suggestion, " ")
                End For
            Otherwise If param.default_type != "":
                StringPrimitive.append(suggestion, param.default_type)
                StringPrimitive.append(suggestion, " (default)")
            Otherwise:
                StringPrimitive.append(suggestion, "any type")
            End If
            
            List.add(suggestions, suggestion)
        End For
        
        Note: Suggest common instantiations
        If generic_name == "List":
            List.add(suggestions, "Common: List[Integer], List[String], List[Float]")
        Otherwise If generic_name == "Dictionary":
            List.add(suggestions, "Common: Dictionary[String, Integer], Dictionary[String, String]")
        Otherwise If generic_name == "Optional":
            List.add(suggestions, "Common: Optional[String], Optional[Integer]")
        End If
    End If
    
    Note: Suggest based on similar instantiations
    Let instantiations be find_generic_instantiations(resolver, generic_name)
    If List.length(instantiations) > 0:
        List.add(suggestions, "Previously used type arguments:")
        For Each inst in instantiations:
            Let args_str be ""
            For Each param in Dictionary.keys(inst.type_arguments):
                StringPrimitive.append(args_str, param)
                StringPrimitive.append(args_str, "=")
                StringPrimitive.append(args_str, inst.type_arguments[param])
                StringPrimitive.append(args_str, " ")
            End For
            List.add(suggestions, "  " + args_str)
        End For
    End If
    
    Return suggestions

Process called "explain_constraint_failure" that takes resolver as GenericResolver, constraint_failure as String returns String:
    @Implementation
    Provides detailed explanation of why a constraint is not satisfied.
    Helps users understand and fix constraint violations.
    @End Implementation
    
    Let explanation be "Constraint Failure Explanation:\n\n"
    
    Note: Parse the constraint failure
    If StringPrimitive.contains(constraint_failure, "does not implement"):
        StringPrimitive.append(explanation, "The type does not implement the required trait.\n")
        StringPrimitive.append(explanation, "This means the type is missing necessary methods or properties.\n\n")
        StringPrimitive.append(explanation, "To fix this:\n")
        StringPrimitive.append(explanation, "1. Implement the missing trait for your type\n")
        StringPrimitive.append(explanation, "2. Use a different type that already implements the trait\n")
        StringPrimitive.append(explanation, "3. Add a wrapper type that provides the implementation\n")
        
    Otherwise If StringPrimitive.contains(constraint_failure, "lifetime"):
        StringPrimitive.append(explanation, "Lifetime constraint violation detected.\n")
        StringPrimitive.append(explanation, "The type's lifetime does not meet the requirements.\n\n")
        StringPrimitive.append(explanation, "Common causes:\n")
        StringPrimitive.append(explanation, "- Reference outlives the data it points to\n")
        StringPrimitive.append(explanation, "- Temporary value dropped while still borrowed\n")
        StringPrimitive.append(explanation, "- Conflicting lifetime requirements\n")
        
    Otherwise If StringPrimitive.contains(constraint_failure, "variance"):
        StringPrimitive.append(explanation, "Variance constraint violation.\n")
        StringPrimitive.append(explanation, "The type parameter is used in a position incompatible with its variance.\n\n")
        StringPrimitive.append(explanation, "Variance rules:\n")
        StringPrimitive.append(explanation, "- Covariant: can only appear in output positions\n")
        StringPrimitive.append(explanation, "- Contravariant: can only appear in input positions\n")
        StringPrimitive.append(explanation, "- Invariant: can appear in any position\n")
        
    Otherwise If StringPrimitive.contains(constraint_failure, "bounds"):
        StringPrimitive.append(explanation, "Type bounds not satisfied.\n")
        StringPrimitive.append(explanation, "The provided type does not meet the specified bounds.\n\n")
        StringPrimitive.append(explanation, "Check that:\n")
        StringPrimitive.append(explanation, "- The type has all required associated types\n")
        StringPrimitive.append(explanation, "- The type satisfies all trait bounds\n")
        StringPrimitive.append(explanation, "- Any default types are compatible\n")
        
    Otherwise:
        StringPrimitive.append(explanation, "General constraint failure: ")
        StringPrimitive.append(explanation, constraint_failure)
        StringPrimitive.append(explanation, "\n\nThis typically means the type doesn't meet the requirements.\n")
        StringPrimitive.append(explanation, "Review the generic definition and ensure all constraints are satisfied.\n")
    End If
    
    StringPrimitive.append(explanation, "\nOriginal error: ")
    StringPrimitive.append(explanation, constraint_failure)
    
    Return explanation

Process called "recommend_generic_refactoring" that takes resolver as GenericResolver, generic_issue as String returns List[String]:
    @Implementation
    Recommends refactoring strategies to resolve generic-related issues.
    Provides actionable suggestions for improving generic code.
    @End Implementation
    
    Let recommendations be List[String]
    
    Note: Analyze the issue and provide recommendations
    If StringPrimitive.contains(generic_issue, "too many type parameters"):
        List.add(recommendations, "Consider grouping related type parameters into a single generic type")
        List.add(recommendations, "Use associated types instead of additional type parameters")
        List.add(recommendations, "Split the generic into multiple smaller, focused generics")
        
    Otherwise If StringPrimitive.contains(generic_issue, "complex constraints"):
        List.add(recommendations, "Simplify constraints by using trait aliases")
        List.add(recommendations, "Move complex constraints to where clauses")
        List.add(recommendations, "Consider using default type parameters to reduce complexity")
        
    Otherwise If StringPrimitive.contains(generic_issue, "inference"):
        List.add(recommendations, "Provide more type hints in function signatures")
        List.add(recommendations, "Use explicit type annotations at call sites")
        List.add(recommendations, "Break complex expressions into smaller parts with type annotations")
        
    Otherwise If StringPrimitive.contains(generic_issue, "variance"):
        List.add(recommendations, "Review type parameter usage positions")
        List.add(recommendations, "Consider making the type parameter invariant")
        List.add(recommendations, "Use phantom types to control variance")
        
    Otherwise If StringPrimitive.contains(generic_issue, "specialization"):
        List.add(recommendations, "Identify common type instantiations for specialization")
        List.add(recommendations, "Create type-specific implementations for performance")
        List.add(recommendations, "Use conditional compilation for platform-specific optimizations")
        
    Otherwise If StringPrimitive.contains(generic_issue, "circular"):
        List.add(recommendations, "Break circular dependencies by introducing an intermediate type")
        List.add(recommendations, "Use lazy evaluation or indirection")
        List.add(recommendations, "Restructure type relationships to avoid cycles")
        
    Otherwise:
        List.add(recommendations, "Review the generic definition for unnecessary complexity")
        List.add(recommendations, "Ensure all type parameters are actually used")
        List.add(recommendations, "Consider if a non-generic solution would be simpler")
    End If
    
    Note: Add general best practices
    List.add(recommendations, "\nGeneral recommendations:")
    List.add(recommendations, "- Keep generic definitions simple and focused")
    List.add(recommendations, "- Provide clear documentation for type parameters")
    List.add(recommendations, "- Use meaningful names for type parameters")
    List.add(recommendations, "- Test with various type instantiations")
    
    Return recommendations

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "get_generic_resolver_statistics" that takes resolver as GenericResolver returns Dictionary[String, Integer]:
    @Implementation
    Collects and returns comprehensive statistics about the generic resolver state.
    Provides metrics on definitions, instantiations, constraints, and cache usage.
    @End Implementation
    
    Let stats be Dictionary[String, Integer]
    
    Note: Count generic definitions
    Let definition_count be 0
    Let type_param_count be 0
    Let constraint_count be 0
    
    For Each entry in resolver.generic_definitions:
        Set definition_count to definition_count + 1
        Let def be entry.value
        Set type_param_count to type_param_count + List.size(def.type_parameters)
        Set constraint_count to constraint_count + List.size(def.constraints)
    End For
    
    Dictionary.set(stats, "total_definitions", definition_count)
    Dictionary.set(stats, "total_type_parameters", type_param_count)
    Dictionary.set(stats, "total_constraints", constraint_count)
    
    Note: Count instantiations
    Let instantiation_count be 0
    For Each entry in resolver.instantiation_cache:
        Set instantiation_count to instantiation_count + 1
    End For
    Dictionary.set(stats, "cached_instantiations", instantiation_count)
    
    Note: Count specializations
    Let specialization_count be 0
    For Each entry in resolver.specializations:
        Set specialization_count to specialization_count + 1
    End For
    Dictionary.set(stats, "total_specializations", specialization_count)
    
    Note: Count inference cache entries
    Let inference_count be 0
    For Each entry in resolver.inference_cache:
        Set inference_count to inference_count + 1
    End For
    Dictionary.set(stats, "cached_inferences", inference_count)
    
    Note: Count validation cache entries
    Let validation_count be 0
    For Each entry in resolver.validation_cache:
        Set validation_count to validation_count + 1
    End For
    Dictionary.set(stats, "cached_validations", validation_count)
    
    Note: Calculate average constraints per definition
    If definition_count > 0:
        Let avg_constraints be constraint_count / definition_count
        Dictionary.set(stats, "avg_constraints_per_definition", avg_constraints)
    Otherwise:
        Dictionary.set(stats, "avg_constraints_per_definition", 0)
    End If
    
    Note: Calculate average type parameters per definition
    If definition_count > 0:
        Let avg_params be type_param_count / definition_count
        Dictionary.set(stats, "avg_type_params_per_definition", avg_params)
    Otherwise:
        Dictionary.set(stats, "avg_type_params_per_definition", 0)
    End If
    
    Return stats

Process called "export_generic_definitions" that takes resolver as GenericResolver, format as String returns String:
    @Implementation
    Exports all generic definitions in the specified format (json, text, or runa).
    Supports multiple serialization formats for analysis and debugging.
    @End Implementation
    
    Let output be ""
    
    If StringPrimitive.equals(format, "json"):
        Note: Export as JSON format
        StringPrimitive.append(output, "{\n")
        StringPrimitive.append(output, "  \"generic_definitions\": [\n")
        
        Let first be true
        For Each entry in resolver.generic_definitions:
            If not first:
                StringPrimitive.append(output, ",\n")
            End If
            Set first to false
            
            Let def be entry.value
            StringPrimitive.append(output, "    {\n")
            StringPrimitive.append(output, "      \"name\": \"")
            StringPrimitive.append(output, def.name)
            StringPrimitive.append(output, "\",\n")
            StringPrimitive.append(output, "      \"type_parameters\": [")
            
            Let param_first be true
            For Each param in def.type_parameters:
                If not param_first:
                    StringPrimitive.append(output, ", ")
                End If
                Set param_first to false
                StringPrimitive.append(output, "\"")
                StringPrimitive.append(output, param.name)
                StringPrimitive.append(output, "\"")
            End For
            
            StringPrimitive.append(output, "],\n")
            StringPrimitive.append(output, "      \"constraint_count\": ")
            StringPrimitive.append(output, SymbolTable.integer_to_string(List.size(def.constraints)))
            StringPrimitive.append(output, "\n    }")
        End For
        
        StringPrimitive.append(output, "\n  ]\n}\n")
        
    Otherwise If StringPrimitive.equals(format, "text"):
        Note: Export as human-readable text
        StringPrimitive.append(output, "Generic Definitions Report\n")
        StringPrimitive.append(output, "==========================\n\n")
        
        For Each entry in resolver.generic_definitions:
            Let def be entry.value
            StringPrimitive.append(output, "Generic: ")
            StringPrimitive.append(output, def.name)
            StringPrimitive.append(output, "\n")
            
            StringPrimitive.append(output, "  Type Parameters: ")
            For Each param in def.type_parameters:
                StringPrimitive.append(output, param.name)
                StringPrimitive.append(output, " ")
            End For
            StringPrimitive.append(output, "\n")
            
            StringPrimitive.append(output, "  Constraints: ")
            StringPrimitive.append(output, SymbolTable.integer_to_string(List.size(def.constraints)))
            StringPrimitive.append(output, "\n")
            
            If def.variance != null:
                StringPrimitive.append(output, "  Variance: ")
                StringPrimitive.append(output, def.variance)
                StringPrimitive.append(output, "\n")
            End If
            
            StringPrimitive.append(output, "\n")
        End For
        
    Otherwise If StringPrimitive.equals(format, "runa"):
        Note: Export as Runa code format
        StringPrimitive.append(output, "Note: Generated Generic Definitions\n\n")
        
        For Each entry in resolver.generic_definitions:
            Let def be entry.value
            StringPrimitive.append(output, "Type ")
            StringPrimitive.append(output, def.name)
            
            If List.size(def.type_parameters) > 0:
                StringPrimitive.append(output, " with parameters [")
                Let first be true
                For Each param in def.type_parameters:
                    If not first:
                        StringPrimitive.append(output, ", ")
                    End If
                    Set first to false
                    StringPrimitive.append(output, param.name)
                End For
                StringPrimitive.append(output, "]")
            End If
            
            If List.size(def.constraints) > 0:
                StringPrimitive.append(output, " where ")
                Let first be true
                For Each constraint in def.constraints:
                    If not first:
                        StringPrimitive.append(output, " and ")
                    End If
                    Set first to false
                    StringPrimitive.append(output, constraint.description)
                End For
            End If
            
            StringPrimitive.append(output, "\n\n")
        End For
        
    Otherwise:
        StringPrimitive.append(output, "Error: Unsupported export format '")
        StringPrimitive.append(output, format)
        StringPrimitive.append(output, "'. Supported formats: json, text, runa\n")
    End If
    
    Return output

Process called "validate_generic_system" that takes resolver as GenericResolver returns List[String]:
    @Implementation
    Validates the entire generic system for consistency and correctness.
    Returns a list of validation issues found, empty list if everything is valid.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Validate all generic definitions
    For Each entry in resolver.generic_definitions:
        Let def be entry.value
        Let def_name be def.name
        
        Note: Check for duplicate type parameter names
        Let param_names be List[String]
        For Each param in def.type_parameters:
            If List.contains(param_names, param.name):
                Let issue be "Duplicate type parameter '"
                StringPrimitive.append(issue, param.name)
                StringPrimitive.append(issue, "' in generic '")
                StringPrimitive.append(issue, def_name)
                StringPrimitive.append(issue, "'")
                List.add(issues, issue)
            End If
            List.add(param_names, param.name)
        End For
        
        Note: Validate constraints reference existing type parameters
        For Each constraint in def.constraints:
            Let constraint_text be constraint.description
            Let found_param be false
            
            For Each param in def.type_parameters:
                If StringPrimitive.contains(constraint_text, param.name):
                    Set found_param to true
                    Break
                End If
            End For
            
            If not found_param and List.size(def.type_parameters) > 0:
                Let issue be "Constraint '"
                StringPrimitive.append(issue, constraint_text)
                StringPrimitive.append(issue, "' may not reference any type parameters in '")
                StringPrimitive.append(issue, def_name)
                StringPrimitive.append(issue, "'")
                List.add(issues, issue)
            End If
        End For
        
        Note: Check for circular dependencies in constraints
        For Each constraint in def.constraints:
            If StringPrimitive.contains(constraint.description, def_name):
                Let issue be "Potential circular dependency in constraint for '"
                StringPrimitive.append(issue, def_name)
                StringPrimitive.append(issue, "' - constraint references itself")
                List.add(issues, issue)
            End If
        End For
    End For
    
    Note: Validate specializations
    For Each entry in resolver.specializations:
        Let spec be entry.value
        
        Note: Check that specialized type exists in definitions
        Let found be false
        For Each def_entry in resolver.generic_definitions:
            If StringPrimitive.equals(def_entry.key, spec.generic_name):
                Set found to true
                Break
            End If
        End For
        
        If not found:
            Let issue be "Specialization for unknown generic '"
            StringPrimitive.append(issue, spec.generic_name)
            StringPrimitive.append(issue, "'")
            List.add(issues, issue)
        End If
    End For
    
    Note: Validate instantiation cache consistency
    For Each entry in resolver.instantiation_cache:
        Let inst be entry.value
        
        Note: Check that instantiated generic exists
        Let found be false
        For Each def_entry in resolver.generic_definitions:
            If StringPrimitive.equals(def_entry.key, inst.generic_name):
                Set found to true
                
                Note: Validate argument count matches parameter count
                Let def be def_entry.value
                Let expected_count be List.size(def.type_parameters)
                Let actual_count be List.size(inst.type_arguments)
                
                If expected_count != actual_count:
                    Let issue be "Cached instantiation of '"
                    StringPrimitive.append(issue, inst.generic_name)
                    StringPrimitive.append(issue, "' has ")
                    StringPrimitive.append(issue, SymbolTable.integer_to_string(actual_count))
                    StringPrimitive.append(issue, " arguments but expects ")
                    StringPrimitive.append(issue, SymbolTable.integer_to_string(expected_count))
                    List.add(issues, issue)
                End If
                
                Break
            End If
        End For
        
        If not found:
            Let issue be "Cached instantiation for unknown generic '"
            StringPrimitive.append(issue, inst.generic_name)
            StringPrimitive.append(issue, "'")
            List.add(issues, issue)
        End If
    End For
    
    Note: Check for orphaned validation cache entries
    For Each entry in resolver.validation_cache:
        Let key be entry.key
        
        Note: Extract generic name from validation key
        Let separator_pos be StringPrimitive.index_of(key, ":")
        If separator_pos > 0:
            Let generic_name be SymbolTable.substring(key, 0, separator_pos)
            
            Let found be false
            For Each def_entry in resolver.generic_definitions:
                If StringPrimitive.equals(def_entry.key, generic_name):
                    Set found to true
                    Break
                End If
            End For
            
            If not found:
                Let issue be "Validation cache entry for unknown generic '"
                StringPrimitive.append(issue, generic_name)
                StringPrimitive.append(issue, "'")
                List.add(issues, issue)
            End If
        End If
    End For
    
    Return issues

Process called "optimize_generic_instantiations" that takes resolver as GenericResolver returns Boolean:
    @Implementation
    Optimizes generic instantiations by removing duplicates, merging similar ones,
    and cleaning up unused cache entries for better performance.
    @End Implementation
    
    Let optimizations_made be false
    
    Note: Remove duplicate instantiations
    Let seen_keys be List[String]
    Let new_cache be Dictionary[String, GenericInstantiation]
    
    For Each entry in resolver.instantiation_cache:
        Let key be entry.key
        Let inst be entry.value
        
        Note: Create normalized key for comparison
        Let normalized_key be inst.generic_name
        StringPrimitive.append(normalized_key, "<")
        Let first be true
        For Each arg in inst.type_arguments:
            If not first:
                StringPrimitive.append(normalized_key, ",")
            End If
            Set first to false
            StringPrimitive.append(normalized_key, arg.name)
        End For
        StringPrimitive.append(normalized_key, ">")
        
        If not List.contains(seen_keys, normalized_key):
            List.add(seen_keys, normalized_key)
            Dictionary.set(new_cache, key, inst)
        Otherwise:
            Set optimizations_made to true
        End If
    End For
    
    Note: Replace old cache with optimized version
    Set resolver.instantiation_cache to new_cache
    
    Note: Clean up orphaned validation cache entries
    Let valid_generics be List[String]
    For Each entry in resolver.generic_definitions:
        List.add(valid_generics, entry.key)
    End For
    
    Let new_validation_cache be Dictionary[String, Boolean]
    For Each entry in resolver.validation_cache:
        Let key be entry.key
        Let value be entry.value
        
        Note: Check if this validation is for a valid generic
        Let is_valid be false
        For Each generic_name in valid_generics:
            If StringPrimitive.contains(key, generic_name):
                Set is_valid to true
                Break
            End If
        End For
        
        If is_valid:
            Dictionary.set(new_validation_cache, key, value)
        Otherwise:
            Set optimizations_made to true
        End If
    End For
    
    Set resolver.validation_cache to new_validation_cache
    
    Note: Optimize specializations by removing unused ones
    Let used_specializations be List[String]
    
    Note: Find all specializations that are actually referenced
    For Each entry in resolver.instantiation_cache:
        Let inst be entry.value
        
        Note: Check if this instantiation uses a specialization
        Let spec_key be inst.generic_name
        For Each arg in inst.type_arguments:
            StringPrimitive.append(spec_key, "_")
            StringPrimitive.append(spec_key, arg.name)
        End For
        
        If Dictionary.contains_key(resolver.specializations, spec_key):
            If not List.contains(used_specializations, spec_key):
                List.add(used_specializations, spec_key)
            End If
        End If
    End For
    
    Note: Remove unused specializations
    Let new_specializations be Dictionary[String, GenericSpecialization]
    For Each entry in resolver.specializations:
        Let key be entry.key
        Let spec be entry.value
        
        If List.contains(used_specializations, key):
            Dictionary.set(new_specializations, key, spec)
        Otherwise:
            Set optimizations_made to true
        End If
    End For
    
    Set resolver.specializations to new_specializations
    
    Note: Clean up inference cache for non-existent types
    Let new_inference_cache be Dictionary[String, TypeInference]
    For Each entry in resolver.inference_cache:
        Let key be entry.key
        Let inference be entry.value
        
        Note: Check if the inferred type still exists
        Let type_exists be false
        For Each generic_name in valid_generics:
            If StringPrimitive.contains(key, generic_name):
                Set type_exists to true
                Break
            End If
        End For
        
        If type_exists:
            Dictionary.set(new_inference_cache, key, inference)
        Otherwise:
            Set optimizations_made to true
        End If
    End For
    
    Set resolver.inference_cache to new_inference_cache
    
    Note: Compact constraint representations in definitions
    For Each entry in resolver.generic_definitions:
        Let def be entry.value
        
        Note: Remove duplicate constraints
        Let unique_constraints be List[Constraint]
        Let seen_descriptions be List[String]
        
        For Each constraint in def.constraints:
            If not List.contains(seen_descriptions, constraint.description):
                List.add(seen_descriptions, constraint.description)
                List.add(unique_constraints, constraint)
            Otherwise:
                Set optimizations_made to true
            End If
        End For
        
        Set def.constraints to unique_constraints
    End For
    
    Return optimizations_made

Process called "reset_generic_resolver" that takes resolver as GenericResolver returns Boolean:
    @Implementation
    Resets the generic resolver to its initial empty state.
    Clears all caches, definitions, and specializations.
    @End Implementation
    
    Note: Clear all generic definitions
    Dictionary.clear(resolver.generic_definitions)
    
    Note: Clear all caches
    Dictionary.clear(resolver.instantiation_cache)
    Dictionary.clear(resolver.validation_cache)
    Dictionary.clear(resolver.inference_cache)
    
    Note: Clear specializations
    Dictionary.clear(resolver.specializations)
    
    Note: Reset any internal state if it exists
    If resolver.current_scope != null:
        Set resolver.current_scope to null
    End If
    
    If resolver.error_list != null:
        List.clear(resolver.error_list)
    End If
    
    Note: Reinitialize with empty collections if needed
    If resolver.generic_definitions == null:
        Set resolver.generic_definitions to Dictionary[String, GenericDefinition]
    End If
    
    If resolver.instantiation_cache == null:
        Set resolver.instantiation_cache to Dictionary[String, GenericInstantiation]
    End If
    
    If resolver.validation_cache == null:
        Set resolver.validation_cache to Dictionary[String, Boolean]
    End If
    
    If resolver.inference_cache == null:
        Set resolver.inference_cache to Dictionary[String, TypeInference]
    End If
    
    If resolver.specializations == null:
        Set resolver.specializations to Dictionary[String, GenericSpecialization]
    End If
    
    Return true