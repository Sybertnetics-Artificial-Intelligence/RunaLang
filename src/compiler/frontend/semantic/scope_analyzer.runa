Note:
compiler/frontend/semantic/scope_analyzer.runa
Scope Analysis and Variable Lifetime Management

This module provides comprehensive scope analysis functionality including:
- Variable lifetime and scope boundary analysis
- Lexical scoping rules enforcement for both syntax modes
- Variable accessibility and visibility validation
- Scope nesting depth analysis and optimization
- Variable capture detection for closures
- Dead code and unreachable scope detection
- Integration with symbol table for comprehensive analysis
- Performance optimized scope traversal algorithms
:End Note

Import "../diagnostics/errors" as Errors
Import "symbol_table" as SymbolTable
Import "../primitives/core/string_primitive" as StringPrimitive

Note: =====================================================================
Note: SCOPE ANALYSIS DATA STRUCTURES
Note: =====================================================================

Type called "VariableLifetime":
    variable_name as String
    declaration_position as Dictionary[String, Integer]
    first_use_position as Dictionary[String, Integer]
    last_use_position as Dictionary[String, Integer]
    scope_entry as String
    scope_exit as String
    is_captured as Boolean
    lifetime_duration as Integer

Type called "ScopeInfo":
    scope_id as String
    scope_type as String
    parent_scope as String
    nested_scopes as List[String]
    declared_variables as List[String]
    referenced_variables as List[String]
    captured_variables as List[String]
    scope_depth as Integer
    is_reachable as Boolean

Type called "AccessibilityInfo":
    variable_name as String
    declaring_scope as String
    accessible_scopes as List[String]
    visibility_level as String
    access_restrictions as List[String]

Type called "ScopeAnalyzer":
    analyzer_id as String
    symbol_table as String
    scope_tree as Dictionary[String, ScopeInfo]
    variable_lifetimes as Dictionary[String, VariableLifetime]
    accessibility_map as Dictionary[String, AccessibilityInfo]
    current_mode as String
    statistics as Dictionary[String, Integer]

Note: =====================================================================
Note: SCOPE ANALYZER OPERATIONS
Note: =====================================================================

Process called "create_scope_analyzer" that takes analyzer_name as String, symbol_table_id as String returns ScopeAnalyzer:
    @Implementation
    Creates a new scope analyzer integrated with the symbol table.
    Initializes all tracking structures for comprehensive scope analysis.
    @End Implementation
    
    Let analyzer be ScopeAnalyzer with
        analyzer_id as analyzer_name,
        symbol_table as symbol_table_id,
        scope_tree as Dictionary[String, ScopeInfo],
        variable_lifetimes as Dictionary[String, VariableLifetime],
        accessibility_map as Dictionary[String, AccessibilityInfo],
        current_mode as "natural",
        statistics as Dictionary[String, Integer]
    End ScopeAnalyzer
    
    Note: Initialize statistics
    Set analyzer.statistics["total_scopes"] to 0
    Set analyzer.statistics["total_variables"] to 0
    Set analyzer.statistics["max_depth"] to 0
    Set analyzer.statistics["captured_variables"] to 0
    Set analyzer.statistics["dead_code_regions"] to 0
    Set analyzer.statistics["shadowed_variables"] to 0
    
    Return analyzer

Process called "analyze_program_scopes" that takes analyzer as ScopeAnalyzer, program_ast as String returns List[String]:
    @Implementation
    Performs comprehensive scope analysis on the entire program AST.
    Returns list of any issues or warnings found during analysis.
    @End Implementation
    
    Let issues be List[String]
    
    Note: Build scope tree from AST
    Let tree_built be build_scope_tree(analyzer, program_ast)
    If not tree_built:
        List.add(issues, "Failed to build scope tree from AST")
        Return issues
    End If
    
    Note: Analyze variable lifetimes
    Let lifetimes_analyzed be analyze_variable_lifetimes(analyzer)
    If not lifetimes_analyzed:
        List.add(issues, "Failed to analyze variable lifetimes")
    End If
    
    Note: Analyze variable accessibility
    Let accessibility_analyzed be analyze_variable_accessibility(analyzer)
    If not accessibility_analyzed:
        List.add(issues, "Failed to analyze variable accessibility")
    End If
    
    Note: Detect variable captures
    Let captures_detected be detect_variable_captures(analyzer)
    If not captures_detected:
        List.add(issues, "Failed to detect variable captures")
    End If
    
    Note: Find dead code
    Let dead_code be detect_dead_code(analyzer)
    If List.length(dead_code) is greater than 0:
        List.add(issues, "Found " + integer_to_string(List.length(dead_code)) + " dead code regions")
    End If
    
    Note: Validate scope structure
    Let validation_errors be validate_scope_structure(analyzer)
    For Each error in validation_errors:
        List.add(issues, error)
    End For
    
    Return issues

Process called "build_scope_tree" that takes analyzer as ScopeAnalyzer, ast_root as String returns Boolean:
    @Implementation
    Builds a complete scope tree from the AST representation.
    Tracks all scope boundaries and variable declarations.
    @End Implementation
    
    Note: Create root scope
    Let root_scope be ScopeInfo with
        scope_id as "scope_root",
        scope_type as "global",
        parent_scope as "",
        nested_scopes as List[String],
        declared_variables as List[String],
        referenced_variables as List[String],
        captured_variables as List[String],
        scope_depth as 0,
        is_reachable as true
    End ScopeInfo
    
    Note: Store root scope
    Set analyzer.scope_tree["scope_root"] to root_scope
    Set analyzer.statistics["total_scopes"] to 1
    
    Note: Recursively build scope tree
    Let success be build_scope_tree_recursive(analyzer, ast_root, "scope_root", 0)
    
    Return success

Process called "build_scope_tree_recursive" that takes analyzer as ScopeAnalyzer, ast_node as String, parent_scope_id as String, depth as Integer returns Boolean:
    @Implementation
    Recursively builds the scope tree by traversing the AST.
    @End Implementation
    
    Note: Update max depth statistic
    If depth is greater than analyzer.statistics["max_depth"]:
        Set analyzer.statistics["max_depth"] to depth
    End If
    
    Note: Process different AST node types
    Let node_type be get_ast_node_type(ast_node)
    
    Match node_type:
        When "function":
            Return process_function_scope(analyzer, ast_node, parent_scope_id, depth)
        When "block":
            Return process_block_scope(analyzer, ast_node, parent_scope_id, depth)
        When "loop":
            Return process_loop_scope(analyzer, ast_node, parent_scope_id, depth)
        When "conditional":
            Return process_conditional_scope(analyzer, ast_node, parent_scope_id, depth)
        Otherwise:
            Return process_generic_scope(analyzer, ast_node, parent_scope_id, depth)
    End Match

Note: =====================================================================
Note: VARIABLE LIFETIME ANALYSIS
Note: =====================================================================

Process called "analyze_variable_lifetimes" that takes analyzer as ScopeAnalyzer returns Boolean:
    @Implementation
    Analyzes the lifetime of all variables in the program.
    Tracks declaration, first use, last use, and scope boundaries.
    @End Implementation
    
    Note: Process each scope in the tree
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope be analyzer.scope_tree[scope_id]
        
        Note: Analyze each variable declared in this scope
        For Each var_name in scope.declared_variables:
            Let lifetime be calculate_variable_lifetime(analyzer, var_name)
            
            Note: Store lifetime information
            Let lifetime_key be scope_id + "::" + var_name
            Set analyzer.variable_lifetimes[lifetime_key] to lifetime
            
            Note: Update statistics
            Set analyzer.statistics["total_variables"] to analyzer.statistics["total_variables"] + 1
        End For
    End For
    
    Return true

Process called "calculate_variable_lifetime" that takes analyzer as ScopeAnalyzer, variable_name as String returns VariableLifetime:
    @Implementation
    Calculates the complete lifetime information for a specific variable.
    Includes declaration position, usage positions, and scope boundaries.
    @End Implementation
    
    Let lifetime be VariableLifetime with
        variable_name as variable_name,
        declaration_position as find_variable_declaration(analyzer, variable_name, "scope_root"),
        first_use_position as Dictionary[String, Integer],
        last_use_position as Dictionary[String, Integer],
        scope_entry as "",
        scope_exit as "",
        is_captured as false,
        lifetime_duration as 0
    End VariableLifetime
    
    Note: Find all uses of the variable
    Let uses be find_variable_uses(analyzer, variable_name)
    
    If List.length(uses) is greater than 0:
        Note: Set first use position
        Set lifetime.first_use_position to uses[0]
        
        Note: Set last use position
        Let last_index be List.length(uses) - 1
        Set lifetime.last_use_position to uses[last_index]
        
        Note: Calculate lifetime duration
        Let start_line be Dictionary.get_or_default(lifetime.declaration_position, "line", 0)
        Let end_line be Dictionary.get_or_default(lifetime.last_use_position, "line", 0)
        Set lifetime.lifetime_duration to end_line - start_line
    End If
    
    Note: Determine scope boundaries
    Let declaring_scope be find_variable_scope(analyzer, variable_name)
    Set lifetime.scope_entry to declaring_scope
    Set lifetime.scope_exit to declaring_scope
    
    Return lifetime

Process called "find_variable_declaration" that takes analyzer as ScopeAnalyzer, variable_name as String, scope_context as String returns Dictionary[String, Integer]:
    @Implementation
    Finds the declaration position of a variable within the given scope context.
    Returns position information including line and column.
    @End Implementation
    
    Let position be Dictionary[String, Integer]
    
    Note: Search current scope and parent scopes
    Let current_scope_id be scope_context
    
    While StringPrimitive.length(current_scope_id) is greater than 0:
        If Dictionary.contains_key(analyzer.scope_tree, current_scope_id):
            Let scope be analyzer.scope_tree[current_scope_id]
            
            Note: Check if variable is declared in this scope
            If list_contains(scope.declared_variables, variable_name):
                Note: Found declaration scope, set position
                Set position["line"] to get_scope_start_line(scope)
                Set position["column"] to 0
                Set position["scope"] to hash_string(current_scope_id)
                Return position
            End If
            
            Note: Move to parent scope
            Set current_scope_id to scope.parent_scope
        Otherwise:
            Break
        End If
    End While
    
    Note: Variable not found, return empty position
    Set position["line"] to 0
    Set position["column"] to 0
    Return position

Process called "find_variable_uses" that takes analyzer as ScopeAnalyzer, variable_name as String returns List[Dictionary[String, Integer]]:
    @Implementation
    Finds all positions where a variable is used (referenced) in the program.
    Returns list of position dictionaries with line and column information.
    @End Implementation
    
    Let use_positions be List[Dictionary[String, Integer]]
    
    Note: Search all scopes for variable references
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope be analyzer.scope_tree[scope_id]
        
        Note: Check if this scope references the variable
        If list_contains(scope.referenced_variables, variable_name):
            Let position be Dictionary[String, Integer]
            Set position["line"] to get_scope_start_line(scope) + 1
            Set position["column"] to 0
            Set position["scope"] to hash_string(scope_id)
            List.add(use_positions, position)
        End If
    End For
    
    Return use_positions

Process called "detect_variable_shadowing" that takes analyzer as ScopeAnalyzer, variable_name as String returns List[String]:
    @Implementation
    Detects if a variable shadows another variable in parent scopes.
    Returns list of scope IDs where shadowing occurs.
    @End Implementation
    
    Let shadowing_scopes be List[String]
    Let found_declarations be Dictionary[String, String]
    
    Note: Check each scope for variable declarations
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope be analyzer.scope_tree[scope_id]
        
        If list_contains(scope.declared_variables, variable_name):
            Note: Check if this shadows a parent scope variable
            Let parent_scope_id be scope.parent_scope
            
            While StringPrimitive.length(parent_scope_id) is greater than 0:
                If Dictionary.contains_key(analyzer.scope_tree, parent_scope_id):
                    Let parent_scope be analyzer.scope_tree[parent_scope_id]
                    
                    If list_contains(parent_scope.declared_variables, variable_name):
                        Note: Found shadowing
                        List.add(shadowing_scopes, scope_id)
                        Set analyzer.statistics["shadowed_variables"] to analyzer.statistics["shadowed_variables"] + 1
                        Break
                    End If
                    
                    Set parent_scope_id to parent_scope.parent_scope
                Otherwise:
                    Break
                End If
            End While
        End If
    End For
    
    Return shadowing_scopes

Note: =====================================================================
Note: SCOPE ACCESSIBILITY ANALYSIS
Note: =====================================================================

Process called "analyze_variable_accessibility" that takes analyzer as ScopeAnalyzer returns Boolean:
    @Implementation
    Analyzes accessibility of all variables across scopes.
    Builds comprehensive accessibility map showing which variables
    can be accessed from which scopes based on scope hierarchy.
    @End Implementation
    
    Note: Initialize accessibility analysis
    Set analyzer.statistics["accessibility_checks"] to 0
    
    Note: Process each scope to determine variable accessibility
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        Let accessible_vars be List[String]
        
        Note: Variables declared in current scope are accessible
        For Each var_name in scope_info.declared_variables:
            List.add(accessible_vars, var_name)
        End For
        
        Note: Variables from parent scopes are accessible (unless shadowed)
        Let parent_id be scope_info.parent_scope
        While StringPrimitive.length(parent_id) is greater than 0:
            If Dictionary.contains_key(analyzer.scope_tree, parent_id):
                Let parent_scope be analyzer.scope_tree[parent_id]
                
                For Each parent_var in parent_scope.declared_variables:
                    Note: Check if this variable is not shadowed
                    Let is_shadowed be false
                    For Each accessible_var in accessible_vars:
                        If strings_equal(accessible_var, parent_var):
                            Set is_shadowed to true
                            Break
                        End If
                    End For
                    
                    If not is_shadowed:
                        List.add(accessible_vars, parent_var)
                    End If
                End For
                
                Set parent_id to parent_scope.parent_scope
            Otherwise:
                Break
            End If
        End While
        
        Note: Store accessibility information for this scope
        Let access_info be AccessibilityInfo with
            scope_id as scope_id,
            accessible_variables as accessible_vars,
            access_level as determine_access_level(scope_info),
            restrictions as List[String]
        End AccessibilityInfo
        
        Set analyzer.accessibility_map[scope_id] to access_info
        Set analyzer.statistics["accessibility_checks"] to analyzer.statistics["accessibility_checks"] + 1
    End For
    
    Return true

Process called "check_variable_accessibility" that takes analyzer as ScopeAnalyzer, variable_name as String, access_scope as String returns Boolean:
    @Implementation
    Checks if a specific variable is accessible from the given scope.
    Considers scope hierarchy and variable shadowing rules.
    @End Implementation
    
    Note: Check if accessibility map has been built
    If not Dictionary.contains_key(analyzer.accessibility_map, access_scope):
        Note: Build accessibility for this scope if not available
        analyze_variable_accessibility(analyzer)
    End If
    
    Note: Get accessibility info for the requesting scope
    If Dictionary.contains_key(analyzer.accessibility_map, access_scope):
        Let access_info be analyzer.accessibility_map[access_scope]
        
        Note: Check if variable is in accessible list
        For Each accessible_var in access_info.accessible_variables:
            If strings_equal(accessible_var, variable_name):
                Return true
            End If
        End For
    End If
    
    Note: Variable is not accessible from this scope
    Return false

Process called "find_accessible_variables" that takes analyzer as ScopeAnalyzer, scope_id as String returns List[String]:
    @Implementation
    Finds all variables that are accessible from the given scope.
    Returns a list of variable names that can be referenced.
    @End Implementation
    
    Let accessible_vars be List[String]
    
    Note: Ensure accessibility map is built
    If not Dictionary.contains_key(analyzer.accessibility_map, scope_id):
        analyze_variable_accessibility(analyzer)
    End If
    
    Note: Return accessible variables from map
    If Dictionary.contains_key(analyzer.accessibility_map, scope_id):
        Let access_info be analyzer.accessibility_map[scope_id]
        Return access_info.accessible_variables
    End If
    
    Note: If scope not found, check scope tree directly
    If Dictionary.contains_key(analyzer.scope_tree, scope_id):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        Note: Add variables from current scope
        For Each var_name in scope_info.declared_variables:
            List.add(accessible_vars, var_name)
        End For
        
        Note: Add variables from parent scopes
        Let parent_id be scope_info.parent_scope
        While StringPrimitive.length(parent_id) is greater than 0:
            If Dictionary.contains_key(analyzer.scope_tree, parent_id):
                Let parent_scope be analyzer.scope_tree[parent_id]
                
                For Each parent_var in parent_scope.declared_variables:
                    Note: Check if not already added (avoid duplicates)
                    Let already_added be false
                    For Each existing_var in accessible_vars:
                        If strings_equal(existing_var, parent_var):
                            Set already_added to true
                            Break
                        End If
                    End For
                    
                    If not already_added:
                        List.add(accessible_vars, parent_var)
                    End If
                End For
                
                Set parent_id to parent_scope.parent_scope
            Otherwise:
                Break
            End If
        End While
    End If
    
    Return accessible_vars

Process called "validate_variable_access" that takes analyzer as ScopeAnalyzer, variable_reference as String, access_position as Dictionary[String, Integer] returns List[String]:
    @Implementation
    Validates that a variable access is legal at the given position.
    Returns list of validation errors if access is invalid.
    @End Implementation
    
    Let validation_errors be List[String]
    
    Note: Determine which scope the access is in
    Let access_scope_id be ""
    Let access_line be access_position["line"]
    Let access_column be access_position["column"]
    
    Note: Find the scope containing this position
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        Let scope_start be get_scope_start_line(scope_info)
        Let scope_end be get_scope_end_line(scope_info)
        
        If access_line is greater than or equal to scope_start:
            If access_line is less than or equal to scope_end:
                Set access_scope_id to scope_id
                Break
            End If
        End If
    End For
    
    If StringPrimitive.length(access_scope_id) equals 0:
        List.add(validation_errors, "Cannot determine scope for variable access")
        Return validation_errors
    End If
    
    Note: Check if variable is accessible from this scope
    If not check_variable_accessibility(analyzer, variable_reference, access_scope_id):
        Let error_msg be "Variable '" joined with variable_reference joined with "' is not accessible from scope " joined with access_scope_id
        List.add(validation_errors, error_msg)
    End If
    
    Note: Check if variable is declared before use
    Let var_declaration be find_variable_declaration(analyzer, variable_reference)
    Let declaration_line be var_declaration["line"]
    
    If declaration_line is greater than access_line:
        Let error_msg be "Variable '" joined with variable_reference joined with "' is used before declaration"
        List.add(validation_errors, error_msg)
    End If
    
    Note: Check for additional access restrictions
    If Dictionary.contains_key(analyzer.accessibility_map, access_scope_id):
        Let access_info be analyzer.accessibility_map[access_scope_id]
        
        For Each restriction in access_info.restrictions:
            If StringPrimitive.contains(restriction, variable_reference):
                List.add(validation_errors, restriction)
            End If
        End For
    End If
    
    Return validation_errors

Note: =====================================================================
Note: CLOSURE AND CAPTURE ANALYSIS
Note: =====================================================================

Process called "detect_variable_captures" that takes analyzer as ScopeAnalyzer returns Boolean:
    @Implementation
    Detects variables that are captured by closures or nested functions.
    A variable is captured when it's referenced in a nested scope but
    declared in an outer scope.
    @End Implementation
    
    Let captures_found be false
    Set analyzer.statistics["captured_variables"] to 0
    
    Note: Analyze each scope for variable captures
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        Note: Check if this is a closure/nested function scope
        If strings_equal(scope_info.scope_type, "closure") or strings_equal(scope_info.scope_type, "function"):
            Note: Find variables referenced but not declared in this scope
            For Each ref_var in scope_info.referenced_variables:
                Let is_local be false
                
                Note: Check if variable is declared locally
                For Each decl_var in scope_info.declared_variables:
                    If strings_equal(ref_var, decl_var):
                        Set is_local to true
                        Break
                    End If
                End For
                
                If not is_local:
                    Note: Check if variable is from parent scope (captured)
                    Let parent_id be scope_info.parent_scope
                    While StringPrimitive.length(parent_id) is greater than 0:
                        If Dictionary.contains_key(analyzer.scope_tree, parent_id):
                            Let parent_scope be analyzer.scope_tree[parent_id]
                            
                            For Each parent_var in parent_scope.declared_variables:
                                If strings_equal(parent_var, ref_var):
                                    Note: Found a captured variable
                                    Set captures_found to true
                                    Set analyzer.statistics["captured_variables"] to analyzer.statistics["captured_variables"] + 1
                                    
                                    Note: Record capture information
                                    Let capture_key be scope_id joined with ":" joined with ref_var
                                    Set analyzer.variable_lifetimes[capture_key] to VariableLifetime with
                                        variable_name as ref_var,
                                        scope_id as scope_id,
                                        declaration_position as find_variable_declaration(analyzer, ref_var),
                                        last_use_position as Dictionary[String, Integer],
                                        lifetime_type as "captured",
                                        is_captured as true
                                    End VariableLifetime
                                    Break
                                End If
                            End For
                            
                            Set parent_id to parent_scope.parent_scope
                        Otherwise:
                            Break
                        End If
                    End While
                End If
            End For
        End If
    End For
    
    Return captures_found

Process called "analyze_closure_environment" that takes analyzer as ScopeAnalyzer, closure_scope as String returns List[String]:
    @Implementation
    Analyzes the environment captured by a closure, returning the list
    of all external variables that the closure references.
    @End Implementation
    
    Let captured_vars be List[String]
    
    Note: Get the closure scope information
    If not Dictionary.contains_key(analyzer.scope_tree, closure_scope):
        Return captured_vars  Note: Empty list if scope not found
    End If
    
    Let closure_info be analyzer.scope_tree[closure_scope]
    
    Note: Find all referenced variables not declared locally
    For Each ref_var in closure_info.referenced_variables:
        Let is_local be false
        
        Note: Check if variable is declared in closure scope
        For Each decl_var in closure_info.declared_variables:
            If strings_equal(ref_var, decl_var):
                Set is_local to true
                Break
            End If
        End For
        
        If not is_local:
            Note: Check if variable exists in parent scopes
            Let parent_id be closure_info.parent_scope
            Let found_in_parent be false
            
            While StringPrimitive.length(parent_id) is greater than 0:
                If Dictionary.contains_key(analyzer.scope_tree, parent_id):
                    Let parent_scope be analyzer.scope_tree[parent_id]
                    
                    For Each parent_var in parent_scope.declared_variables:
                        If strings_equal(parent_var, ref_var):
                            Set found_in_parent to true
                            List.add(captured_vars, ref_var)
                            Break
                        End If
                    End For
                    
                    If found_in_parent:
                        Break
                    End If
                    
                    Set parent_id to parent_scope.parent_scope
                Otherwise:
                    Break
                End If
            End While
        End If
    End For
    
    Return captured_vars

Process called "validate_capture_legality" that takes analyzer as ScopeAnalyzer, captured_variable as String, capture_scope as String returns Boolean:
    @Implementation
    Validates that capturing a specific variable in a closure is legal.
    Checks for mutable captures, lifetime issues, and other constraints.
    @End Implementation
    
    Note: Check if capture scope exists
    If not Dictionary.contains_key(analyzer.scope_tree, capture_scope):
        Return false  Note: Invalid scope
    End If
    
    Let capture_scope_info be analyzer.scope_tree[capture_scope]
    
    Note: Check if variable is accessible from capture scope
    If not check_variable_accessibility(analyzer, captured_variable, capture_scope):
        Return false  Note: Variable not accessible
    End If
    
    Note: Find where the variable is declared
    Let declaration_scope_id be ""
    Let parent_id be capture_scope_info.parent_scope
    
    While StringPrimitive.length(parent_id) is greater than 0:
        If Dictionary.contains_key(analyzer.scope_tree, parent_id):
            Let parent_scope be analyzer.scope_tree[parent_id]
            
            For Each decl_var in parent_scope.declared_variables:
                If strings_equal(decl_var, captured_variable):
                    Set declaration_scope_id to parent_id
                    Break
                End If
            End For
            
            If StringPrimitive.length(declaration_scope_id) is greater than 0:
                Break
            End If
            
            Set parent_id to parent_scope.parent_scope
        Otherwise:
            Break
        End If
    End While
    
    If StringPrimitive.length(declaration_scope_id) equals 0:
        Return false  Note: Variable not found in parent scopes
    End If
    
    Note: Check for illegal capture patterns
    Let declaration_scope be analyzer.scope_tree[declaration_scope_id]
    
    Note: Cannot capture variables from conditional scopes that may not execute
    If strings_equal(declaration_scope.scope_type, "conditional"):
        If not is_always_executed(declaration_scope):
            Return false  Note: Cannot capture from potentially unexecuted scope
        End If
    End If
    
    Note: Check for circular capture dependencies
    If has_circular_capture(analyzer, captured_variable, capture_scope):
        Return false  Note: Circular capture detected
    End If
    
    Return true  Note: Capture is legal

Process called "calculate_capture_cost" that takes analyzer as ScopeAnalyzer, captures as List[String] returns Integer:
    @Implementation
    Calculates the estimated memory cost of capturing variables.
    Uses heuristics based on variable types and capture patterns.
    @End Implementation
    
    Let total_cost be 0
    Let base_capture_cost be 8  Note: Base cost per captured variable (pointer size)
    
    For Each var_name in captures:
        Let var_cost be base_capture_cost
        
        Note: Find variable lifetime information
        Let lifetime_key be ""
        For Each key in Dictionary.keys(analyzer.variable_lifetimes):
            If StringPrimitive.contains(key, var_name):
                Set lifetime_key to key
                Break
            End If
        End For
        
        If StringPrimitive.length(lifetime_key) is greater than 0:
            Let lifetime_info be analyzer.variable_lifetimes[lifetime_key]
            
            Note: Adjust cost based on lifetime type
            If strings_equal(lifetime_info.lifetime_type, "captured"):
                Set var_cost to var_cost * 2  Note: Double cost for captured variables
            End If
            
            If lifetime_info.is_captured:
                Note: Additional cost for managing capture references
                Set var_cost to var_cost + 16
            End If
        End If
        
        Note: Add heuristic costs based on variable name patterns
        If StringPrimitive.contains(var_name, "array") or StringPrimitive.contains(var_name, "list"):
            Set var_cost to var_cost + 32  Note: Collection types have higher cost
        End If
        
        If StringPrimitive.contains(var_name, "map") or StringPrimitive.contains(var_name, "dict"):
            Set var_cost to var_cost + 48  Note: Maps/dictionaries have even higher cost
        End If
        
        If StringPrimitive.contains(var_name, "buffer") or StringPrimitive.contains(var_name, "cache"):
            Set var_cost to var_cost + 64  Note: Buffers/caches typically large
        End If
        
        Set total_cost to total_cost + var_cost
    End For
    
    Note: Add overhead for closure environment management
    Let capture_count be List.length(captures)
    If capture_count is greater than 0:
        Set total_cost to total_cost + (capture_count * 4)  Note: Management overhead
    End If
    
    Return total_cost

Note: =====================================================================
Note: DEAD CODE AND UNREACHABLE ANALYSIS
Note: =====================================================================

Process called "detect_dead_code" that takes analyzer as ScopeAnalyzer returns List[Dictionary[String, Integer]]:
    @Implementation
    Detects dead code and unreachable statements in the program.
    Returns positions of dead code segments.
    @End Implementation
    
    Let dead_code_positions be List[Dictionary[String, Integer]]
    Set analyzer.statistics["dead_code_segments"] to 0
    
    Note: Analyze each scope for dead code patterns
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        Note: Check for unconditional returns/breaks that make subsequent code unreachable
        Let has_early_return be false
        Let return_line be 0
        
        Note: Scan scope for early returns (simplified check based on scope metadata)
        If strings_equal(scope_info.scope_type, "function") or strings_equal(scope_info.scope_type, "process"):
            Note: Check if scope has unreachable code after return
            Let scope_start be get_scope_start_line(scope_info)
            Let scope_end be get_scope_end_line(scope_info)
            
            Note: If there are statements after a return, they are dead code
            If scope_info.exit_points is greater than 0:
                Note: Assume exit point is before the end if there are multiple lines
                Let lines_in_scope be scope_end - scope_start
                If lines_in_scope is greater than 10:  Note: Heuristic for detecting potential dead code
                    Let dead_position be Dictionary[String, Integer]
                    Set dead_position["line"] to scope_end - 2
                    Set dead_position["column"] to 0
                    Set dead_position["scope"] to hash_string(scope_id)
                    List.add(dead_code_positions, dead_position)
                    Set analyzer.statistics["dead_code_segments"] to analyzer.statistics["dead_code_segments"] + 1
                End If
            End If
        End If
        
        Note: Check for unreachable conditional branches
        If strings_equal(scope_info.scope_type, "conditional"):
            Note: Check for always-false conditions
            If scope_info.entry_points equals 0:
                Let dead_position be Dictionary[String, Integer]
                Set dead_position["line"] to get_scope_start_line(scope_info)
                Set dead_position["column"] to 0
                Set dead_position["scope"] to hash_string(scope_id)
                List.add(dead_code_positions, dead_position)
                Set analyzer.statistics["dead_code_segments"] to analyzer.statistics["dead_code_segments"] + 1
            End If
        End If
        
        Note: Check for unreachable loop bodies
        If strings_equal(scope_info.scope_type, "loop"):
            Note: Check for loops that never execute
            If scope_info.entry_points equals 0:
                Let dead_position be Dictionary[String, Integer]
                Set dead_position["line"] to get_scope_start_line(scope_info)
                Set dead_position["column"] to 0
                Set dead_position["scope"] to hash_string(scope_id)
                List.add(dead_code_positions, dead_position)
                Set analyzer.statistics["dead_code_segments"] to analyzer.statistics["dead_code_segments"] + 1
            End If
        End If
    End For
    
    Return dead_code_positions

Process called "find_unreachable_scopes" that takes analyzer as ScopeAnalyzer returns List[String]:
    @Implementation
    Finds scopes that are never reached during program execution.
    Uses entry point analysis to determine reachability.
    @End Implementation
    
    Let unreachable_scopes be List[String]
    
    Note: Build reachability map starting from root/main scope
    Let reachable_scopes be Dictionary[String, Boolean]
    Let to_process be List[String]
    
    Note: Find root/main scope as starting point
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        If strings_equal(scope_info.scope_type, "global") or strings_equal(scope_info.scope_type, "main"):
            List.add(to_process, scope_id)
            Set reachable_scopes[scope_id] to true
        End If
    End For
    
    Note: Process reachable scopes transitively
    While List.length(to_process) is greater than 0:
        Let current_scope_id be List.remove_first(to_process)
        
        If Dictionary.contains_key(analyzer.scope_tree, current_scope_id):
            Let current_scope be analyzer.scope_tree[current_scope_id]
            
            Note: Mark all child scopes as reachable
            For Each child_id in current_scope.child_scopes:
                If not Dictionary.contains_key(reachable_scopes, child_id):
                    Set reachable_scopes[child_id] to true
                    List.add(to_process, child_id)
                End If
            End For
            
            Note: Mark scopes referenced by this scope as reachable
            For Each ref_var in current_scope.referenced_variables:
                Note: If referencing a function, mark its scope as reachable
                Let ref_scope_id be find_function_scope(analyzer, ref_var)
                If StringPrimitive.length(ref_scope_id) is greater than 0:
                    If not Dictionary.contains_key(reachable_scopes, ref_scope_id):
                        Set reachable_scopes[ref_scope_id] to true
                        List.add(to_process, ref_scope_id)
                    End If
                End If
            End For
        End If
    End While
    
    Note: Find all unreachable scopes
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        If not Dictionary.contains_key(reachable_scopes, scope_id):
            List.add(unreachable_scopes, scope_id)
            Set analyzer.statistics["unreachable_scopes"] to analyzer.statistics["unreachable_scopes"] + 1
        End If
    End For
    
    Return unreachable_scopes

Process called "analyze_control_flow_reachability" that takes analyzer as ScopeAnalyzer, control_flow_graph as String returns Dictionary[String, Boolean]:
    @Implementation
    Analyzes reachability of scopes through control flow graph.
    Returns map of scope IDs to reachability status.
    @End Implementation
    
    Let reachability_map be Dictionary[String, Boolean]
    
    Note: Parse control flow graph identifier to get starting scope
    Let start_scope_id be control_flow_graph  Note: Simplified: using graph ID as starting scope
    
    Note: Initialize all scopes as unreachable
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Set reachability_map[scope_id] to false
    End For
    
    Note: Mark starting scope as reachable
    If Dictionary.contains_key(analyzer.scope_tree, start_scope_id):
        Set reachability_map[start_scope_id] to true
        
        Note: Perform depth-first traversal to mark reachable scopes
        Let visit_stack be List[String]
        List.add(visit_stack, start_scope_id)
        
        While List.length(visit_stack) is greater than 0:
            Let current_id be List.remove_last(visit_stack)
            
            If Dictionary.contains_key(analyzer.scope_tree, current_id):
                Let current_scope be analyzer.scope_tree[current_id]
                
                Note: Mark all child scopes as reachable
                For Each child_id in current_scope.child_scopes:
                    If not reachability_map[child_id]:
                        Set reachability_map[child_id] to true
                        List.add(visit_stack, child_id)
                    End If
                End For
                
                Note: Handle control flow transitions
                If current_scope.exit_points is greater than 0:
                    Note: Check for jump targets or successor scopes
                    Let successor_id be find_successor_scope(analyzer, current_id)
                    If StringPrimitive.length(successor_id) is greater than 0:
                        If Dictionary.contains_key(reachability_map, successor_id):
                            If not reachability_map[successor_id]:
                                Set reachability_map[successor_id] to true
                                List.add(visit_stack, successor_id)
                            End If
                        End If
                    End If
                End If
            End If
        End While
    End If
    
    Return reachability_map

Process called "detect_unused_variables" that takes analyzer as ScopeAnalyzer returns List[String]:
    @Implementation
    Detects variables that are declared but never used in their scope.
    Returns list of unused variable names with their scope context.
    @End Implementation
    
    Let unused_variables be List[String]
    Set analyzer.statistics["unused_variables"] to 0
    
    Note: Check each scope for unused variables
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        Note: Check each declared variable
        For Each declared_var in scope_info.declared_variables:
            Let is_used be false
            
            Note: Check if variable is referenced in current scope
            For Each ref_var in scope_info.referenced_variables:
                If strings_equal(declared_var, ref_var):
                    Set is_used to true
                    Break
                End If
            End For
            
            If not is_used:
                Note: Check if variable is used in child scopes
                For Each child_id in scope_info.child_scopes:
                    If Dictionary.contains_key(analyzer.scope_tree, child_id):
                        Let child_scope be analyzer.scope_tree[child_id]
                        
                        For Each child_ref in child_scope.referenced_variables:
                            If strings_equal(declared_var, child_ref):
                                Set is_used to true
                                Break
                            End If
                        End For
                        
                        If is_used:
                            Break
                        End If
                    End If
                End For
            End If
            
            If not is_used:
                Note: Check if variable is exported or public
                Let is_exported be false
                For Each exported_var in scope_info.exported_symbols:
                    If strings_equal(declared_var, exported_var):
                        Set is_exported to true
                        Break
                    End If
                End For
                
                If not is_exported:
                    Note: Variable is unused
                    Let unused_desc be scope_id joined with ":" joined with declared_var
                    List.add(unused_variables, unused_desc)
                    Set analyzer.statistics["unused_variables"] to analyzer.statistics["unused_variables"] + 1
                End If
            End If
        End For
    End For
    
    Return unused_variables

Note: =====================================================================
Note: NATURAL LANGUAGE SCOPE ANALYSIS
Note: =====================================================================

Process called "analyze_natural_let_scope" that takes analyzer as ScopeAnalyzer, let_statement as String returns ScopeInfo:
    @Implementation
    Analyzes scope implications of a natural language "Let" statement.
    Creates appropriate scope entry for variable declaration.
    @End Implementation
    
    Note: Create scope info for Let statement
    Let scope_info be ScopeInfo with
        scope_id as generate_scope_id("let", let_statement),
        scope_type as "declaration",
        parent_scope as analyzer.symbol_table,
        child_scopes as List[String],
        declared_variables as List[String],
        referenced_variables as List[String],
        exported_symbols as List[String],
        entry_points as 1,
        exit_points as 1
    End ScopeInfo
    
    Note: Parse Let statement for variable name
    Let var_name be extract_variable_from_let(let_statement)
    If StringPrimitive.length(var_name) is greater than 0:
        List.add(scope_info.declared_variables, var_name)
    End If
    
    Note: Check for references in initialization expression
    Let init_expr be extract_initialization_expr(let_statement)
    If StringPrimitive.length(init_expr) is greater than 0:
        Let referenced_vars be extract_variables_from_expr(init_expr)
        For Each ref_var in referenced_vars:
            List.add(scope_info.referenced_variables, ref_var)
        End For
    End If
    
    Note: Register scope with analyzer
    Set analyzer.scope_tree[scope_info.scope_id] to scope_info
    Set analyzer.statistics["natural_scopes"] to analyzer.statistics["natural_scopes"] + 1
    
    Return scope_info

Process called "analyze_natural_process_scope" that takes analyzer as ScopeAnalyzer, process_definition as String returns ScopeInfo:
    @Implementation
    Analyzes scope for a natural language Process definition.
    Handles parameter scope and body scope creation.
    @End Implementation
    
    Note: Create scope info for Process
    Let scope_info be ScopeInfo with
        scope_id as generate_scope_id("process", process_definition),
        scope_type as "process",
        parent_scope as analyzer.symbol_table,
        child_scopes as List[String],
        declared_variables as List[String],
        referenced_variables as List[String],
        exported_symbols as List[String],
        entry_points as 1,
        exit_points as 0  Note: Will be determined by analyzing Returns
    End ScopeInfo
    
    Note: Extract process name
    Let process_name be extract_process_name(process_definition)
    If StringPrimitive.length(process_name) is greater than 0:
        List.add(scope_info.exported_symbols, process_name)
    End If
    
    Note: Extract and add parameters as declared variables
    Let parameters be extract_process_parameters(process_definition)
    For Each param in parameters:
        List.add(scope_info.declared_variables, param)
    End For
    
    Note: Check for referenced variables in return type
    Let return_type be extract_return_type(process_definition)
    If StringPrimitive.contains(return_type, "[") and StringPrimitive.contains(return_type, "]"):
        Note: Generic type reference, extract type parameters
        Let type_refs be extract_type_references(return_type)
        For Each type_ref in type_refs:
            List.add(scope_info.referenced_variables, type_ref)
        End For
    End If
    
    Note: Register scope with analyzer
    Set analyzer.scope_tree[scope_info.scope_id] to scope_info
    Set analyzer.statistics["process_scopes"] to analyzer.statistics["process_scopes"] + 1
    
    Return scope_info

Process called "handle_natural_scope_keywords" that takes analyzer as ScopeAnalyzer, natural_construct as String returns List[String]:
    @Implementation
    Handles scope implications of natural language keywords like
    "Let", "Set", "For Each", "While", "If", etc.
    @End Implementation
    
    Let scope_implications be List[String]
    
    Note: Check for scope-creating keywords
    If StringPrimitive.contains(natural_construct, "Let "):
        List.add(scope_implications, "creates_variable_scope")
    End If
    
    If StringPrimitive.contains(natural_construct, "Process called"):
        List.add(scope_implications, "creates_function_scope")
    End If
    
    If StringPrimitive.contains(natural_construct, "Type called"):
        List.add(scope_implications, "creates_type_scope")
    End If
    
    If StringPrimitive.contains(natural_construct, "For Each"):
        List.add(scope_implications, "creates_iteration_scope")
        List.add(scope_implications, "declares_iterator_variable")
    End If
    
    If StringPrimitive.contains(natural_construct, "While "):
        List.add(scope_implications, "creates_loop_scope")
    End If
    
    If StringPrimitive.contains(natural_construct, "If ") and StringPrimitive.contains(natural_construct, ":"): 
        List.add(scope_implications, "creates_conditional_scope")
    End If
    
    If StringPrimitive.contains(natural_construct, "Match "):
        List.add(scope_implications, "creates_pattern_scope")
    End If
    
    If StringPrimitive.contains(natural_construct, "When "):
        List.add(scope_implications, "creates_case_scope")
    End If
    
    If StringPrimitive.contains(natural_construct, "Import "):
        List.add(scope_implications, "imports_external_scope")
    End If
    
    If StringPrimitive.contains(natural_construct, "Set "):
        List.add(scope_implications, "modifies_existing_scope")
    End If
    
    If StringPrimitive.contains(natural_construct, "Return "):
        List.add(scope_implications, "exits_current_scope")
    End If
    
    If StringPrimitive.contains(natural_construct, "Throw "):
        List.add(scope_implications, "exits_with_exception")
    End If
    
    If StringPrimitive.contains(natural_construct, "Break"):
        List.add(scope_implications, "exits_loop_scope")
    End If
    
    If StringPrimitive.contains(natural_construct, "Continue"):
        List.add(scope_implications, "restarts_loop_scope")
    End If
    
    Return scope_implications

Note: =====================================================================
Note: TECHNICAL SYNTAX SCOPE ANALYSIS
Note: =====================================================================

Process called "analyze_technical_block_scope" that takes analyzer as ScopeAnalyzer, block_statement as String returns ScopeInfo:
    @Implementation
    Analyzes scope for technical syntax block statements using { }.
    Creates a local block scope with proper nesting.
    @End Implementation
    
    Note: Create scope info for technical block
    Let scope_info be ScopeInfo with
        scope_id as generate_scope_id("block", block_statement),
        scope_type as "block",
        parent_scope as analyzer.symbol_table,
        child_scopes as List[String],
        declared_variables as List[String],
        referenced_variables as List[String],
        exported_symbols as List[String],
        entry_points as 1,
        exit_points as 1
    End ScopeInfo
    
    Note: Extract variables declared in block
    Let block_content be extract_block_content(block_statement)
    
    Note: Find variable declarations in C-style syntax
    If StringPrimitive.contains(block_content, "int ") or StringPrimitive.contains(block_content, "var "):
        Let declarations be extract_c_style_declarations(block_content)
        For Each decl in declarations:
            List.add(scope_info.declared_variables, decl)
        End For
    End If
    
    Note: Find referenced variables
    Let references be extract_variable_references(block_content)
    For Each ref in references:
        Note: Only add if not declared locally
        Let is_local be false
        For Each local_var in scope_info.declared_variables:
            If strings_equal(ref, local_var):
                Set is_local to true
                Break
            End If
        End For
        
        If not is_local:
            List.add(scope_info.referenced_variables, ref)
        End If
    End For
    
    Note: Register scope with analyzer
    Set analyzer.scope_tree[scope_info.scope_id] to scope_info
    Set analyzer.statistics["technical_scopes"] to analyzer.statistics["technical_scopes"] + 1
    
    Return scope_info

Process called "analyze_technical_function_scope" that takes analyzer as ScopeAnalyzer, function_definition as String returns ScopeInfo:
    @Implementation
    Analyzes scope for technical syntax function definitions.
    Handles C-style and other technical syntax patterns.
    @End Implementation
    
    Note: Create scope info for technical function
    Let scope_info be ScopeInfo with
        scope_id as generate_scope_id("function", function_definition),
        scope_type as "function",
        parent_scope as analyzer.symbol_table,
        child_scopes as List[String],
        declared_variables as List[String],
        referenced_variables as List[String],
        exported_symbols as List[String],
        entry_points as 1,
        exit_points as 0  Note: Determined by return statements
    End ScopeInfo
    
    Note: Extract function name from technical syntax
    Let func_name be extract_technical_function_name(function_definition)
    If StringPrimitive.length(func_name) is greater than 0:
        List.add(scope_info.exported_symbols, func_name)
    End If
    
    Note: Extract parameters from technical syntax
    Let params be extract_technical_parameters(function_definition)
    For Each param in params:
        Note: Parse parameter name from type declaration
        Let param_name be extract_param_name(param)
        List.add(scope_info.declared_variables, param_name)
    End For
    
    Note: Count return statements for exit points
    Let return_count be count_return_statements(function_definition)
    Set scope_info.exit_points to return_count
    
    Note: Find variables referenced in function body
    Let body_refs be extract_body_references(function_definition)
    For Each ref in body_refs:
        Note: Only add external references
        Let is_param be false
        For Each param_var in scope_info.declared_variables:
            If strings_equal(ref, param_var):
                Set is_param to true
                Break
            End If
        End For
        
        If not is_param:
            List.add(scope_info.referenced_variables, ref)
        End If
    End For
    
    Note: Register scope with analyzer
    Set analyzer.scope_tree[scope_info.scope_id] to scope_info
    Set analyzer.statistics["function_scopes"] to analyzer.statistics["function_scopes"] + 1
    
    Return scope_info

Process called "handle_c_style_scoping" that takes analyzer as ScopeAnalyzer, c_construct as String returns List[String]:
    @Implementation
    Handles C-style scoping rules for technical mode constructs.
    Returns list of scope implications.
    @End Implementation
    
    Let scope_implications be List[String]
    
    Note: Check for C-style scope constructs
    If StringPrimitive.contains(c_construct, "{") and StringPrimitive.contains(c_construct, "}"):
        List.add(scope_implications, "creates_block_scope")
    End If
    
    If StringPrimitive.contains(c_construct, "for(") or StringPrimitive.contains(c_construct, "for ("):
        List.add(scope_implications, "creates_loop_scope")
        List.add(scope_implications, "declares_loop_variable")
    End If
    
    If StringPrimitive.contains(c_construct, "while(") or StringPrimitive.contains(c_construct, "while ("):
        List.add(scope_implications, "creates_loop_scope")
    End If
    
    If StringPrimitive.contains(c_construct, "if(") or StringPrimitive.contains(c_construct, "if ("):
        List.add(scope_implications, "creates_conditional_scope")
    End If
    
    If StringPrimitive.contains(c_construct, "else if") or StringPrimitive.contains(c_construct, "elif"):
        List.add(scope_implications, "creates_alternative_scope")
    End If
    
    If StringPrimitive.contains(c_construct, "else"):
        List.add(scope_implications, "creates_else_scope")
    End If
    
    If StringPrimitive.contains(c_construct, "switch(") or StringPrimitive.contains(c_construct, "switch ("):
        List.add(scope_implications, "creates_switch_scope")
    End If
    
    If StringPrimitive.contains(c_construct, "case "):
        List.add(scope_implications, "creates_case_scope")
    End If
    
    If StringPrimitive.contains(c_construct, "default:"):
        List.add(scope_implications, "creates_default_scope")
    End If
    
    Note: Check for variable declarations
    If StringPrimitive.contains(c_construct, "int ") or StringPrimitive.contains(c_construct, "float "):
        List.add(scope_implications, "declares_typed_variable")
    End If
    
    If StringPrimitive.contains(c_construct, "const ") or StringPrimitive.contains(c_construct, "static "):
        List.add(scope_implications, "declares_qualified_variable")
    End If
    
    If StringPrimitive.contains(c_construct, "auto ") or StringPrimitive.contains(c_construct, "var "):
        List.add(scope_implications, "declares_inferred_variable")
    End If
    
    Note: Check for scope exit statements
    If StringPrimitive.contains(c_construct, "return"):
        List.add(scope_implications, "exits_function_scope")
    End If
    
    If StringPrimitive.contains(c_construct, "break"):
        List.add(scope_implications, "exits_loop_or_switch")
    End If
    
    If StringPrimitive.contains(c_construct, "continue"):
        List.add(scope_implications, "continues_loop")
    End If
    
    If StringPrimitive.contains(c_construct, "goto"):
        List.add(scope_implications, "jumps_to_label")
    End If
    
    Return scope_implications

Note: =====================================================================
Note: SCOPE VALIDATION OPERATIONS
Note: =====================================================================

Process called "validate_scope_structure" that takes analyzer as ScopeAnalyzer returns List[String]:
    @Implementation
    Validates the overall scope structure for correctness.
    Checks for structural issues like orphan scopes, cycles, etc.
    @End Implementation
    
    Let validation_errors be List[String]
    
    Note: Check for orphan scopes (scopes without valid parent)
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        If StringPrimitive.length(scope_info.parent_scope) is greater than 0:
            If not strings_equal(scope_info.parent_scope, analyzer.symbol_table):
                If not Dictionary.contains_key(analyzer.scope_tree, scope_info.parent_scope):
                    Let error_msg be "Orphan scope detected: " joined with scope_id joined with " has invalid parent"
                    List.add(validation_errors, error_msg)
                End If
            End If
        End If
    End For
    
    Note: Check for circular parent-child relationships
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let visited be Dictionary[String, Boolean]
        Let current_id be scope_id
        
        While StringPrimitive.length(current_id) is greater than 0:
            If Dictionary.contains_key(visited, current_id):
                Let error_msg be "Circular scope hierarchy detected involving: " joined with scope_id
                List.add(validation_errors, error_msg)
                Break
            End If
            
            Set visited[current_id] to true
            
            If Dictionary.contains_key(analyzer.scope_tree, current_id):
                Let current_scope be analyzer.scope_tree[current_id]
                Set current_id to current_scope.parent_scope
                
                If strings_equal(current_id, analyzer.symbol_table):
                    Break  Note: Reached root scope
                End If
            Otherwise:
                Break
            End If
        End While
    End For
    
    Note: Check for inconsistent child-parent relationships
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        For Each child_id in scope_info.child_scopes:
            If Dictionary.contains_key(analyzer.scope_tree, child_id):
                Let child_scope be analyzer.scope_tree[child_id]
                
                If not strings_equal(child_scope.parent_scope, scope_id):
                    Let error_msg be "Inconsistent parent-child relationship: " joined with child_id
                    List.add(validation_errors, error_msg)
                End If
            Otherwise:
                Let error_msg be "Child scope not found: " joined with child_id
                List.add(validation_errors, error_msg)
            End If
        End For
    End For
    
    Return validation_errors

Process called "check_scope_nesting_depth" that takes analyzer as ScopeAnalyzer returns List[String]:
    @Implementation
    Checks for excessive scope nesting depth that could indicate
    structural problems or impact performance.
    @End Implementation
    
    Let depth_warnings be List[String]
    Let max_depth be 20  Note: Maximum recommended nesting depth
    Let warning_depth be 15  Note: Depth at which to warn
    
    Note: Calculate depth for each scope
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let depth be 0
        Let current_id be scope_id
        
        Note: Traverse up to root counting depth
        While StringPrimitive.length(current_id) is greater than 0:
            Set depth to depth + 1
            
            If depth is greater than max_depth:
                Let error_msg be "Excessive nesting depth (" joined with integer_to_string(depth) joined with ") at scope: " joined with scope_id
                List.add(depth_warnings, error_msg)
                Break
            End If
            
            If Dictionary.contains_key(analyzer.scope_tree, current_id):
                Let current_scope be analyzer.scope_tree[current_id]
                Set current_id to current_scope.parent_scope
                
                If strings_equal(current_id, analyzer.symbol_table):
                    Break  Note: Reached root
                End If
            Otherwise:
                Break
            End If
        End While
        
        If depth is greater than warning_depth and depth is less than or equal to max_depth:
            Let warning_msg be "Deep nesting (" joined with integer_to_string(depth) joined with ") at scope: " joined with scope_id
            List.add(depth_warnings, warning_msg)
        End If
    End For
    
    Note: Record maximum depth in statistics
    Set analyzer.statistics["max_nesting_depth"] to 0
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let depth be calculate_scope_depth(analyzer, scope_id)
        If depth is greater than analyzer.statistics["max_nesting_depth"]:
            Set analyzer.statistics["max_nesting_depth"] to depth
        End If
    End For
    
    Return depth_warnings

Process called "validate_variable_declarations" that takes analyzer as ScopeAnalyzer returns List[String]:
    @Implementation
    Validates all variable declarations across scopes.
    Checks for duplicate declarations, invalid names, etc.
    @End Implementation
    
    Let validation_errors be List[String]
    
    Note: Check each scope for declaration issues
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        Let declared_vars be Dictionary[String, Integer]
        
        Note: Check for duplicate declarations within scope
        For Each var_name in scope_info.declared_variables:
            If Dictionary.contains_key(declared_vars, var_name):
                Let count be declared_vars[var_name]
                Set declared_vars[var_name] to count + 1
                Let error_msg be "Duplicate variable declaration: '" joined with var_name joined with "' in scope " joined with scope_id
                List.add(validation_errors, error_msg)
            Otherwise:
                Set declared_vars[var_name] to 1
            End If
            
            Note: Validate variable name
            If not is_valid_variable_name(var_name):
                Let error_msg be "Invalid variable name: '" joined with var_name joined with "' in scope " joined with scope_id
                List.add(validation_errors, error_msg)
            End If
        End For
        
        Note: Check for references to undeclared variables
        For Each ref_var in scope_info.referenced_variables:
            If not is_variable_accessible(analyzer, ref_var, scope_id):
                Let error_msg be "Reference to undeclared variable: '" joined with ref_var joined with "' in scope " joined with scope_id
                List.add(validation_errors, error_msg)
            End If
        End For
        
        Note: Check for reserved word conflicts
        For Each var_name in scope_info.declared_variables:
            If is_reserved_word(var_name):
                Let error_msg be "Variable name conflicts with reserved word: '" joined with var_name joined with "'"
                List.add(validation_errors, error_msg)
            End If
        End For
    End For
    
    Return validation_errors

Process called "check_scope_boundaries" that takes analyzer as ScopeAnalyzer returns List[String]:
    @Implementation
    Checks that scope boundaries are properly defined and consistent.
    Validates entry/exit points and scope transitions.
    @End Implementation
    
    Let boundary_errors be List[String]
    
    Note: Check each scope for boundary issues
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        Note: Validate entry points
        If scope_info.entry_points is less than 0:
            Let error_msg be "Invalid entry points (" joined with integer_to_string(scope_info.entry_points) joined with ") for scope: " joined with scope_id
            List.add(boundary_errors, error_msg)
        End If
        
        Note: Validate exit points
        If scope_info.exit_points is less than 0:
            Let error_msg be "Invalid exit points (" joined with integer_to_string(scope_info.exit_points) joined with ") for scope: " joined with scope_id
            List.add(boundary_errors, error_msg)
        End If
        
        Note: Check scope type consistency
        If strings_equal(scope_info.scope_type, "function") or strings_equal(scope_info.scope_type, "process"):
            If scope_info.exit_points equals 0:
                Let warning_msg be "Function/process scope without exit points: " joined with scope_id
                List.add(boundary_errors, warning_msg)
            End If
        End If
        
        If strings_equal(scope_info.scope_type, "loop"):
            If scope_info.entry_points equals 0:
                Let warning_msg be "Loop scope with no entry points (unreachable): " joined with scope_id
                List.add(boundary_errors, warning_msg)
            End If
        End If
        
        Note: Check for scope overlap (simplified check)
        Let scope_start be get_scope_start_line(scope_info)
        Let scope_end be get_scope_end_line(scope_info)
        
        If scope_end is less than or equal to scope_start:
            Let error_msg be "Invalid scope boundaries (end before start) for: " joined with scope_id
            List.add(boundary_errors, error_msg)
        End If
        
        Note: Check child scope containment
        For Each child_id in scope_info.child_scopes:
            If Dictionary.contains_key(analyzer.scope_tree, child_id):
                Let child_scope be analyzer.scope_tree[child_id]
                Let child_start be get_scope_start_line(child_scope)
                Let child_end be get_scope_end_line(child_scope)
                
                If child_start is less than scope_start or child_end is greater than scope_end:
                    Let error_msg be "Child scope extends beyond parent boundaries: " joined with child_id
                    List.add(boundary_errors, error_msg)
                End If
            End If
        End For
    End For
    
    Return boundary_errors

Note: =====================================================================
Note: MATHEMATICAL SCOPE ANALYSIS
Note: =====================================================================

Process called "analyze_mathematical_variable_scope" that takes analyzer as ScopeAnalyzer, math_expression as String returns List[String]:
    @Implementation
    Analyzes scope of mathematical variables and Greek symbols.
    Identifies bound and free variables in mathematical expressions.
    @End Implementation
    
    Let math_variables be List[String]
    
    Note: Check for Greek letter variables
    Let greek_letters be ["alpha", "beta", "gamma", "delta", "epsilon", "zeta", "eta", "theta", 
                          "iota", "kappa", "lambda", "mu", "nu", "xi", "omicron", "pi", 
                          "rho", "sigma", "tau", "upsilon", "phi", "chi", "psi", "omega",
                          "Gamma", "Delta", "Theta", "Lambda", "Xi", "Pi", "Sigma", "Phi", "Psi", "Omega"]
    
    For Each greek in greek_letters:
        If StringPrimitive.contains(math_expression, greek):
            List.add(math_variables, greek)
        End If
    End For
    
    Note: Check for common math variable patterns
    Let single_letters be "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    Let i be 0
    While i is less than StringPrimitive.length(single_letters):
        Let letter be substring_at_index(single_letters, i, 1)
        
        Note: Look for subscripted variables like x_i, a_n
        Let subscript_pattern be letter joined with "_"
        If StringPrimitive.contains(math_expression, subscript_pattern):
            Let var_with_subscript be extract_subscripted_var(math_expression, letter)
            If StringPrimitive.length(var_with_subscript) is greater than 0:
                List.add(math_variables, var_with_subscript)
            End If
        End If
        
        Note: Look for plain single letter variables
        If StringPrimitive.contains(math_expression, letter):
            List.add(math_variables, letter)
        End If
        
        Set i to i + 1
    End While
    
    Note: Check for summation/product bound variables
    If StringPrimitive.contains(math_expression, "∑") or StringPrimitive.contains(math_expression, "Σ"):
        Let bound_var be extract_summation_variable(math_expression)
        If StringPrimitive.length(bound_var) is greater than 0:
            List.add(math_variables, bound_var joined with "_bound")
        End If
    End If
    
    If StringPrimitive.contains(math_expression, "∏") or StringPrimitive.contains(math_expression, "Π"):
        Let bound_var be extract_product_variable(math_expression)
        If StringPrimitive.length(bound_var) is greater than 0:
            List.add(math_variables, bound_var joined with "_bound")
        End If
    End If
    
    Note: Check for integral bound variables
    If StringPrimitive.contains(math_expression, "∫"):
        Let integration_var be extract_integration_variable(math_expression)
        If StringPrimitive.length(integration_var) is greater than 0:
            List.add(math_variables, "d" joined with integration_var)
        End If
    End If
    
    Return math_variables

Process called "handle_greek_variable_binding" that takes analyzer as ScopeAnalyzer, greek_symbol as String, binding_context as String returns Boolean:
    @Implementation
    Handles scope binding for Greek letter variables in mathematical contexts.
    Determines if binding is valid and updates scope accordingly.
    @End Implementation
    
    Note: Check if Greek symbol is valid
    Let valid_greek be ["alpha", "beta", "gamma", "delta", "epsilon", "zeta", "eta", "theta",
                        "lambda", "mu", "nu", "xi", "pi", "rho", "sigma", "tau", "phi", "psi", "omega"]
    
    Let is_valid be false
    For Each valid_symbol in valid_greek:
        If strings_equal(greek_symbol, valid_symbol) or strings_equal(greek_symbol, capitalize(valid_symbol)):
            Set is_valid to true
            Break
        End If
    End For
    
    If not is_valid:
        Return false  Note: Not a valid Greek symbol
    End If
    
    Note: Determine binding scope based on context
    Let scope_id be ""
    
    If StringPrimitive.contains(binding_context, "summation") or StringPrimitive.contains(binding_context, "∑"):
        Set scope_id to "summation_scope_" joined with greek_symbol
    Otherwise StringPrimitive.contains(binding_context, "product") or StringPrimitive.contains(binding_context, "∏"):
        Set scope_id to "product_scope_" joined with greek_symbol
    Otherwise StringPrimitive.contains(binding_context, "integral") or StringPrimitive.contains(binding_context, "∫"):
        Set scope_id to "integral_scope_" joined with greek_symbol
    Otherwise StringPrimitive.contains(binding_context, "limit") or StringPrimitive.contains(binding_context, "lim"):
        Set scope_id to "limit_scope_" joined with greek_symbol
    Otherwise:
        Set scope_id to "math_scope_" joined with greek_symbol
    End If
    
    Note: Create mathematical scope for the Greek variable
    Let math_scope be ScopeInfo with
        scope_id as scope_id,
        scope_type as "mathematical",
        parent_scope as analyzer.symbol_table,
        child_scopes as List[String],
        declared_variables as List[String],
        referenced_variables as List[String],
        exported_symbols as List[String],
        entry_points as 1,
        exit_points as 1
    End ScopeInfo
    
    Note: Add Greek symbol as declared variable
    List.add(math_scope.declared_variables, greek_symbol)
    
    Note: Register scope with analyzer
    Set analyzer.scope_tree[scope_id] to math_scope
    Set analyzer.statistics["mathematical_variables"] to analyzer.statistics["mathematical_variables"] + 1
    
    Return true

Process called "analyze_summation_scope" that takes analyzer as ScopeAnalyzer, summation_expr as String returns ScopeInfo:
    @Implementation
    Analyzes scope implications of summation expressions.
    Creates scope for bound variables in summations.
    @End Implementation
    
    Note: Create scope for summation expression
    Let scope_info be ScopeInfo with
        scope_id as generate_scope_id("summation", summation_expr),
        scope_type as "summation",
        parent_scope as analyzer.symbol_table,
        child_scopes as List[String],
        declared_variables as List[String],
        referenced_variables as List[String],
        exported_symbols as List[String],
        entry_points as 1,
        exit_points as 1
    End ScopeInfo
    
    Note: Extract summation index variable
    Let index_var be ""
    If StringPrimitive.contains(summation_expr, "="):
        Let parts be split_on_equals(summation_expr)
        If List.length(parts) is greater than 0:
            Set index_var to extract_variable_name(parts[0])
        End If
    End If
    
    Note: Common summation index variables if not found
    If StringPrimitive.length(index_var) equals 0:
        If StringPrimitive.contains(summation_expr, "i"):
            Set index_var to "i"
        Otherwise StringPrimitive.contains(summation_expr, "j"):
            Set index_var to "j"
        Otherwise StringPrimitive.contains(summation_expr, "k"):
            Set index_var to "k"
        Otherwise StringPrimitive.contains(summation_expr, "n"):
            Set index_var to "n"
        End If
    End If
    
    If StringPrimitive.length(index_var) is greater than 0:
        List.add(scope_info.declared_variables, index_var)
    End If
    
    Note: Extract lower and upper bounds as referenced variables
    If StringPrimitive.contains(summation_expr, "to") or StringPrimitive.contains(summation_expr, "..."):
        Let bounds be extract_summation_bounds(summation_expr)
        For Each bound in bounds:
            If is_variable_reference(bound):
                List.add(scope_info.referenced_variables, bound)
            End If
        End For
    End If
    
    Note: Extract variables referenced in summation body
    Let body_vars be extract_variables_from_expr(summation_expr)
    For Each var in body_vars:
        If not strings_equal(var, index_var):  Note: Don't add index variable as reference
            List.add(scope_info.referenced_variables, var)
        End If
    End For
    
    Note: Register scope with analyzer
    Set analyzer.scope_tree[scope_info.scope_id] to scope_info
    Set analyzer.statistics["summation_scopes"] to analyzer.statistics["summation_scopes"] + 1
    
    Return scope_info

Note: =====================================================================
Note: SCOPE OPTIMIZATION ANALYSIS
Note: =====================================================================

Process called "suggest_scope_optimizations" that takes analyzer as ScopeAnalyzer returns List[String]:
    @Implementation
    Suggests optimizations for scope structure to improve performance
    and reduce memory usage.
    @End Implementation
    
    Let optimization_suggestions be List[String]
    
    Note: Check for variables that could be moved to inner scopes
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        For Each var_name in scope_info.declared_variables:
            Note: Check if variable is only used in child scopes
            Let used_in_current be false
            For Each ref in scope_info.referenced_variables:
                If strings_equal(ref, var_name):
                    Set used_in_current to true
                    Break
                End If
            End For
            
            If not used_in_current:
                Let used_in_single_child be check_single_child_usage(analyzer, var_name, scope_id)
                If used_in_single_child:
                    Let suggestion be "Move variable '" joined with var_name joined with "' to inner scope for better locality"
                    List.add(optimization_suggestions, suggestion)
                End If
            End If
        End For
    End For
    
    Note: Check for excessive scope depth
    Let max_depth be 0
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let depth be calculate_scope_depth(analyzer, scope_id)
        If depth is greater than max_depth:
            Set max_depth to depth
        End If
    End For
    
    If max_depth is greater than 10:
        Let suggestion be "Consider flattening scope hierarchy (depth: " joined with integer_to_string(max_depth) joined with ")"
        List.add(optimization_suggestions, suggestion)
    End If
    
    Note: Check for unused exported symbols
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        For Each exported in scope_info.exported_symbols:
            Let is_referenced be false
            
            Note: Check if exported symbol is actually used anywhere
            For Each other_scope_id in Dictionary.keys(analyzer.scope_tree):
                If not strings_equal(other_scope_id, scope_id):
                    Let other_scope be analyzer.scope_tree[other_scope_id]
                    For Each ref in other_scope.referenced_variables:
                        If strings_equal(ref, exported):
                            Set is_referenced to true
                            Break
                        End If
                    End For
                End If
                
                If is_referenced:
                    Break
                End If
            End For
            
            If not is_referenced:
                Let suggestion be "Exported symbol '" joined with exported joined with "' is never referenced - consider removing export"
                List.add(optimization_suggestions, suggestion)
            End If
        End For
    End For
    
    Note: Check for redundant scopes
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        If List.length(scope_info.declared_variables) equals 0:
            If List.length(scope_info.child_scopes) equals 0:
                Let suggestion be "Empty scope '" joined with scope_id joined with "' could be removed"
                List.add(optimization_suggestions, suggestion)
            End If
        End If
    End For
    
    Return optimization_suggestions

Process called "analyze_variable_hoisting_potential" that takes analyzer as ScopeAnalyzer returns Dictionary[String, Boolean]:
    @Implementation
    Analyzes potential for variable hoisting optimizations.
    Returns map of variables that could be hoisted.
    @End Implementation
    
    Let hoisting_candidates be Dictionary[String, Boolean]
    
    Note: Analyze each scope for hoisting opportunities
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        Note: Check variables in loop scopes for hoisting
        If strings_equal(scope_info.scope_type, "loop") or strings_equal(scope_info.scope_type, "iteration"):
            For Each var_name in scope_info.declared_variables:
                Note: Check if variable is loop-invariant
                Let is_invariant be check_loop_invariance(analyzer, var_name, scope_id)
                
                If is_invariant:
                    Let hoist_key be scope_id joined with ":" joined with var_name
                    Set hoisting_candidates[hoist_key] to true
                End If
            End For
        End If
        
        Note: Check for common subexpression variables
        For Each var_name in scope_info.declared_variables:
            Note: Check if variable represents a common subexpression
            Let usage_count be count_variable_uses(analyzer, var_name, scope_id)
            
            If usage_count is greater than 3:  Note: Used multiple times
                Note: Check if it could be computed once at higher scope
                Let parent_scope_id be scope_info.parent_scope
                If StringPrimitive.length(parent_scope_id) is greater than 0:
                    Let can_hoist be check_hoisting_safety(analyzer, var_name, scope_id, parent_scope_id)
                    
                    If can_hoist:
                        Let hoist_key be scope_id joined with ":" joined with var_name
                        Set hoisting_candidates[hoist_key] to true
                    End If
                End If
            End If
        End For
    End For
    
    Note: Record statistics
    Set analyzer.statistics["hoisting_candidates"] to Dictionary.size(hoisting_candidates)
    
    Return hoisting_candidates

Process called "detect_scope_pollution" that takes analyzer as ScopeAnalyzer returns List[String]:
    @Implementation
    Detects unnecessary variables that pollute outer scopes when they
    could be confined to inner scopes.
    @End Implementation
    
    Let pollution_issues be List[String]
    
    Note: Check each scope for pollution
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        Note: Analyze variables declared in this scope
        For Each var_name in scope_info.declared_variables:
            Let usage_scope_ids be List[String]
            
            Note: Find all scopes where variable is used
            For Each other_scope_id in Dictionary.keys(analyzer.scope_tree):
                Let other_scope be analyzer.scope_tree[other_scope_id]
                
                For Each ref in other_scope.referenced_variables:
                    If strings_equal(ref, var_name):
                        List.add(usage_scope_ids, other_scope_id)
                        Break
                    End If
                End For
            End For
            
            Note: Check if variable is only used in a subset of child scopes
            If List.length(usage_scope_ids) is greater than 0:
                Let all_in_children be true
                Let common_child be find_common_child_scope(analyzer, usage_scope_ids, scope_id)
                
                If StringPrimitive.length(common_child) is greater than 0:
                    Let issue be "Variable '" joined with var_name joined with "' in scope " joined with scope_id
                    Set issue to issue joined with " could be moved to child scope " joined with common_child
                    List.add(pollution_issues, issue)
                End If
            End If
            
            Note: Check for overly broad variable scope
            If strings_equal(scope_info.scope_type, "global") or strings_equal(scope_info.scope_type, "module"):
                Let usage_count be count_variable_uses(analyzer, var_name, scope_id)
                
                If usage_count is less than 2:
                    Let issue be "Global/module variable '" joined with var_name joined with "' has minimal usage - consider local scope"
                    List.add(pollution_issues, issue)
                End If
            End If
        End For
        
        Note: Check for excessive exported symbols
        If List.length(scope_info.exported_symbols) is greater than 20:
            Let issue be "Scope " joined with scope_id joined with " exports " joined with integer_to_string(List.length(scope_info.exported_symbols))
            Set issue to issue joined with " symbols - consider reducing public interface"
            List.add(pollution_issues, issue)
        End If
    End For
    
    Return pollution_issues

Process called "recommend_scope_restructuring" that takes analyzer as ScopeAnalyzer returns List[String]:
    @Implementation
    Recommends restructuring for better scope organization and maintainability.
    Suggests refactoring patterns to improve code structure.
    @End Implementation
    
    Let restructuring_recommendations be List[String]
    
    Note: Check for overly complex scopes
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        Note: Check for too many variables in single scope
        If List.length(scope_info.declared_variables) is greater than 15:
            Let recommendation be "Scope " joined with scope_id joined with " has " joined with integer_to_string(List.length(scope_info.declared_variables))
            Set recommendation to recommendation joined with " variables - consider splitting into smaller scopes"
            List.add(restructuring_recommendations, recommendation)
        End If
        
        Note: Check for too many child scopes
        If List.length(scope_info.child_scopes) is greater than 10:
            Let recommendation be "Scope " joined with scope_id joined with " has " joined with integer_to_string(List.length(scope_info.child_scopes))
            Set recommendation to recommendation joined with " child scopes - consider extracting helper functions"
            List.add(restructuring_recommendations, recommendation)
        End If
        
        Note: Check for multiple exit points in functions
        If strings_equal(scope_info.scope_type, "function") or strings_equal(scope_info.scope_type, "process"):
            If scope_info.exit_points is greater than 3:
                Let recommendation be "Function " joined with scope_id joined with " has " joined with integer_to_string(scope_info.exit_points)
                Set recommendation to recommendation joined with " exit points - consider simplifying control flow"
                List.add(restructuring_recommendations, recommendation)
            End If
        End If
    End For
    
    Note: Check for scope depth issues
    Let depth_issues be check_scope_nesting_depth(analyzer)
    For Each issue in depth_issues:
        If StringPrimitive.contains(issue, "Excessive"):
            Let recommendation be "Excessive nesting detected - consider extracting nested logic into separate functions"
            List.add(restructuring_recommendations, recommendation)
            Break  Note: Only add once
        End If
    End For
    
    Note: Check for circular dependencies between scopes
    Let circular_deps be detect_circular_dependencies(analyzer)
    If List.length(circular_deps) is greater than 0:
        Let recommendation be "Circular dependencies detected between scopes - consider dependency injection or interfaces"
        List.add(restructuring_recommendations, recommendation)
    End If
    
    Note: Check for god objects/scopes
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        Let total_symbols be List.length(scope_info.declared_variables) + List.length(scope_info.exported_symbols)
        If total_symbols is greater than 30:
            Let recommendation be "Scope " joined with scope_id joined with " appears to be a 'god object' with too many responsibilities"
            List.add(restructuring_recommendations, recommendation)
        End If
    End For
    
    Note: Check for scope cohesion
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        If List.length(scope_info.referenced_variables) is greater than List.length(scope_info.declared_variables) * 3:
            Let recommendation be "Scope " joined with scope_id joined with " has low cohesion - references many external variables"
            List.add(restructuring_recommendations, recommendation)
        End If
    End For
    
    Return restructuring_recommendations

Note: =====================================================================
Note: SCOPE QUERY OPERATIONS
Note: =====================================================================

Process called "get_scope_information" that takes analyzer as ScopeAnalyzer, scope_id as String returns ScopeInfo:
    @Implementation
    Gets detailed information about a specific scope.
    Returns the complete ScopeInfo structure.
    @End Implementation
    
    Note: Check if scope exists
    If Dictionary.contains_key(analyzer.scope_tree, scope_id):
        Return analyzer.scope_tree[scope_id]
    End If
    
    Note: Return empty scope info if not found
    Return ScopeInfo with
        scope_id as "",
        scope_type as "unknown",
        parent_scope as "",
        child_scopes as List[String],
        declared_variables as List[String],
        referenced_variables as List[String],
        exported_symbols as List[String],
        entry_points as 0,
        exit_points as 0
    End ScopeInfo

Process called "find_variable_scope" that takes analyzer as ScopeAnalyzer, variable_name as String returns String:
    @Implementation
    Finds the scope where a variable is declared.
    Returns the scope ID or empty string if not found.
    @End Implementation
    
    Note: Search all scopes for variable declaration
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        For Each declared_var in scope_info.declared_variables:
            If strings_equal(declared_var, variable_name):
                Return scope_id
            End If
        End For
    End For
    
    Note: Variable not found in any scope
    Return ""

Process called "integer_to_string" that takes value as Integer returns String:
    @Implementation
    Converts an integer to its string representation.
    @End Implementation
    
    If value equals 0:
        Return "0"
    End If
    
    Let result be ""
    Let num be value
    Let is_negative be false
    
    If num is less than 0:
        Set is_negative to true
        Set num to 0 - num
    End If
    
    While num is greater than 0:
        Let digit be num mod 10
        Let digit_char be digit_to_string_char(digit)
        Set result to digit_char joined with result
        Set num to num / 10
    End While
    
    If is_negative:
        Set result to "-" joined with result
    End If
    
    Return result

Process called "digit_to_string_char" that takes digit as Integer returns String:
    @Implementation
    Converts a single digit to its character representation.
    @End Implementation
    
    If digit equals 0: Return "0"
    Otherwise digit equals 1: Return "1"
    Otherwise digit equals 2: Return "2"
    Otherwise digit equals 3: Return "3"
    Otherwise digit equals 4: Return "4"
    Otherwise digit equals 5: Return "5"
    Otherwise digit equals 6: Return "6"
    Otherwise digit equals 7: Return "7"
    Otherwise digit equals 8: Return "8"
    Otherwise digit equals 9: Return "9"
    Otherwise: Return "?"
    End If

Process called "calculate_scope_depth" that takes analyzer as ScopeAnalyzer, scope_id as String returns Integer:
    @Implementation
    Calculates the nesting depth of a scope.
    @End Implementation
    
    Return get_scope_depth(analyzer, scope_id)

Process called "check_single_child_usage" that takes analyzer as ScopeAnalyzer, variable as String, parent_scope as String returns Boolean:
    @Implementation
    Checks if a variable is only used in a single child scope.
    @End Implementation
    
    If not Dictionary.contains_key(analyzer.scope_tree, parent_scope):
        Return false
    End If
    
    Let parent_info be analyzer.scope_tree[parent_scope]
    Let usage_count be 0
    Let usage_scope be ""
    
    For Each child_id in parent_info.child_scopes:
        If Dictionary.contains_key(analyzer.scope_tree, child_id):
            Let child_scope be analyzer.scope_tree[child_id]
            
            If list_contains(child_scope.referenced_variables, variable):
                Set usage_count to usage_count + 1
                Set usage_scope to child_id
            End If
        End If
    End For
    
    Return usage_count equals 1

Process called "check_loop_invariance" that takes analyzer as ScopeAnalyzer, variable as String, loop_scope as String returns Boolean:
    @Implementation
    Checks if a variable is loop-invariant (constant within loop).
    @End Implementation
    
    Note: Simplified check - variable is invariant if not modified in loop
    If Dictionary.contains_key(analyzer.scope_tree, loop_scope):
        Let loop_info be analyzer.scope_tree[loop_scope]
        
        Note: Check if variable is modified in loop (heuristic)
        For Each child_id in loop_info.child_scopes:
            If Dictionary.contains_key(analyzer.scope_tree, child_id):
                Let child_scope be analyzer.scope_tree[child_id]
                
                If list_contains(child_scope.declared_variables, variable):
                    Return false  Note: Variable is redeclared in loop
                End If
            End If
        End For
        
        Return true  Note: Variable appears invariant
    End If
    
    Return false

Process called "count_variable_uses" that takes analyzer as ScopeAnalyzer, variable as String, scope_id as String returns Integer:
    @Implementation
    Counts how many times a variable is used in a scope and its children.
    @End Implementation
    
    Let count be 0
    
    If Dictionary.contains_key(analyzer.scope_tree, scope_id):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        For Each ref in scope_info.referenced_variables:
            If strings_equal(ref, variable):
                Set count to count + 1
            End If
        End For
        
        Note: Count in child scopes
        For Each child_id in scope_info.child_scopes:
            Let child_count be count_variable_uses(analyzer, variable, child_id)
            Set count to count + child_count
        End For
    End If
    
    Return count

Process called "check_hoisting_safety" that takes analyzer as ScopeAnalyzer, variable as String, from_scope as String, to_scope as String returns Boolean:
    @Implementation
    Checks if it's safe to hoist a variable from one scope to another.
    @End Implementation
    
    Note: Check if variable doesn't depend on loop-specific values
    If Dictionary.contains_key(analyzer.scope_tree, from_scope):
        Let from_info be analyzer.scope_tree[from_scope]
        
        Note: Don't hoist if variable depends on loop iterator
        If strings_equal(from_info.scope_type, "loop") or strings_equal(from_info.scope_type, "iteration"):
            For Each ref in from_info.referenced_variables:
                If StringPrimitive.contains(ref, "_iterator") or strings_equal(ref, "i") or strings_equal(ref, "j"):
                    If strings_equal(variable, ref):
                        Return false
                    End If
                End If
            End For
        End If
    End If
    
    Return true

Process called "find_common_child_scope" that takes analyzer as ScopeAnalyzer, usage_scopes as List[String], parent_scope as String returns String:
    @Implementation
    Finds a common child scope that could contain all usages.
    @End Implementation
    
    If List.length(usage_scopes) equals 0:
        Return ""
    End If
    
    If List.length(usage_scopes) equals 1:
        Return usage_scopes[0]
    End If
    
    Note: Find lowest common ancestor scope
    Let common_ancestor be usage_scopes[0]
    
    For Each scope_id in usage_scopes:
        Note: Check if all scopes are children of first scope
        If not is_scope_descendant(analyzer, scope_id, common_ancestor):
            Return ""  Note: No common child scope
        End If
    End For
    
    Return common_ancestor

Process called "is_variable_accessible" that takes analyzer as ScopeAnalyzer, variable as String, from_scope as String returns Boolean:
    @Implementation
    Checks if a variable is accessible from a given scope.
    @End Implementation
    
    Return check_variable_accessibility(analyzer, variable, from_scope)

Process called "is_reserved_word" that takes word as String returns Boolean:
    @Implementation
    Checks if a word is a reserved keyword.
    @End Implementation
    
    Let reserved be ["Let", "Set", "If", "Otherwise", "While", "For", "Return", "Break", "Continue",
                    "Process", "Type", "Import", "Export", "Match", "When", "Throw", "Try", "Catch",
                    "Note", "End", "as", "be", "to", "from", "in", "with", "that", "takes", "returns"]
    
    For Each keyword in reserved:
        If strings_equal(word, keyword):
            Return true
        End If
    End For
    
    Return false

Process called "is_valid_variable_name" that takes name as String returns Boolean:
    @Implementation
    Validates that a variable name follows naming conventions.
    @End Implementation
    
    If StringPrimitive.length(name) equals 0:
        Return false
    End If
    
    Note: Check first character is letter or underscore
    Let first_char be StringPrimitive.char_at(name, 0)
    If not is_letter_or_underscore(first_char):
        Return false
    End If
    
    Note: Check remaining characters are alphanumeric or underscore
    Let i be 1
    While i is less than StringPrimitive.length(name):
        Let char be StringPrimitive.char_at(name, i)
        If not is_alphanumeric_or_underscore(char):
            Return false
        End If
        Set i to i + 1
    End While
    
    Return true

Process called "detect_circular_dependencies" that takes analyzer as ScopeAnalyzer returns List[String]:
    @Implementation
    Detects circular dependencies between scopes.
    @End Implementation
    
    Let circular_deps be List[String]
    
    Note: Check each scope for circular parent references
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let visited be Dictionary[String, Boolean]
        Let current_id be scope_id
        
        While StringPrimitive.length(current_id) is greater than 0:
            If Dictionary.contains_key(visited, current_id):
                List.add(circular_deps, scope_id)
                Break
            End If
            
            Set visited[current_id] to true
            
            If Dictionary.contains_key(analyzer.scope_tree, current_id):
                Let scope be analyzer.scope_tree[current_id]
                Set current_id to scope.parent_scope
                
                If strings_equal(current_id, analyzer.symbol_table):
                    Break
                End If
            Otherwise:
                Break
            End If
        End While
    End For
    
    Return circular_deps

Process called "list_scope_variables" that takes analyzer as ScopeAnalyzer, scope_id as String returns List[String]:
    @Implementation
    Lists all variables declared in a specific scope.
    Returns list of variable names.
    @End Implementation
    
    Note: Check if scope exists
    If Dictionary.contains_key(analyzer.scope_tree, scope_id):
        Let scope_info be analyzer.scope_tree[scope_id]
        Return scope_info.declared_variables
    End If
    
    Note: Return empty list if scope not found
    Return List[String]

Process called "get_scope_depth" that takes analyzer as ScopeAnalyzer, scope_id as String returns Integer:
    @Implementation
    Gets the nesting depth of a specific scope.
    Returns 0 for root scope, increasing with nesting.
    @End Implementation
    
    Let depth be 0
    Let current_id be scope_id
    
    Note: Traverse up to root counting depth
    While StringPrimitive.length(current_id) is greater than 0:
        If Dictionary.contains_key(analyzer.scope_tree, current_id):
            Let current_scope be analyzer.scope_tree[current_id]
            Set current_id to current_scope.parent_scope
            
            If strings_equal(current_id, analyzer.symbol_table):
                Break  Note: Reached root scope
            End If
            
            Set depth to depth + 1
            
            Note: Prevent infinite loops
            If depth is greater than 100:
                Break
            End If
        Otherwise:
            Break
        End If
    End While
    
    Return depth

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "get_scope_analyzer_statistics" that takes analyzer as ScopeAnalyzer returns Dictionary[String, Integer]:
    @Implementation
    Gets comprehensive scope analysis statistics.
    Returns dictionary of statistics metrics.
    @End Implementation
    
    Note: Initialize statistics if not already present
    If not Dictionary.contains_key(analyzer.statistics, "total_scopes"):
        Set analyzer.statistics["total_scopes"] to Dictionary.size(analyzer.scope_tree)
    End If
    
    Note: Calculate various statistics
    Set analyzer.statistics["total_scopes"] to Dictionary.size(analyzer.scope_tree)
    
    Note: Count scope types
    Let function_count be 0
    Let loop_count be 0
    Let conditional_count be 0
    Let block_count be 0
    Let total_variables be 0
    Let total_references be 0
    Let total_exports be 0
    
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        If strings_equal(scope_info.scope_type, "function") or strings_equal(scope_info.scope_type, "process"):
            Set function_count to function_count + 1
        Otherwise strings_equal(scope_info.scope_type, "loop") or strings_equal(scope_info.scope_type, "iteration"):
            Set loop_count to loop_count + 1
        Otherwise strings_equal(scope_info.scope_type, "conditional"):
            Set conditional_count to conditional_count + 1
        Otherwise strings_equal(scope_info.scope_type, "block"):
            Set block_count to block_count + 1
        End If
        
        Set total_variables to total_variables + List.length(scope_info.declared_variables)
        Set total_references to total_references + List.length(scope_info.referenced_variables)
        Set total_exports to total_exports + List.length(scope_info.exported_symbols)
    End For
    
    Set analyzer.statistics["function_scopes"] to function_count
    Set analyzer.statistics["loop_scopes"] to loop_count
    Set analyzer.statistics["conditional_scopes"] to conditional_count
    Set analyzer.statistics["block_scopes"] to block_count
    Set analyzer.statistics["total_variables"] to total_variables
    Set analyzer.statistics["total_references"] to total_references
    Set analyzer.statistics["total_exports"] to total_exports
    
    Note: Calculate average metrics
    If Dictionary.size(analyzer.scope_tree) is greater than 0:
        Set analyzer.statistics["avg_variables_per_scope"] to total_variables / Dictionary.size(analyzer.scope_tree)
        Set analyzer.statistics["avg_references_per_scope"] to total_references / Dictionary.size(analyzer.scope_tree)
    End If
    
    Note: Find maximum nesting depth if not already calculated
    If not Dictionary.contains_key(analyzer.statistics, "max_nesting_depth"):
        Let max_depth be 0
        For Each scope_id in Dictionary.keys(analyzer.scope_tree):
            Let depth be get_scope_depth(analyzer, scope_id)
            If depth is greater than max_depth:
                Set max_depth to depth
            End If
        End For
        Set analyzer.statistics["max_nesting_depth"] to max_depth
    End If
    
    Return analyzer.statistics

Process called "export_scope_analysis_report" that takes analyzer as ScopeAnalyzer, format as String returns String:
    @Implementation
    Exports scope analysis report in the specified format.
    Supports "text", "json", and "summary" formats.
    @End Implementation
    
    Let report be ""
    
    If strings_equal(format, "text"):
        Set report to "SCOPE ANALYSIS REPORT\n"
        Set report to report joined with "=====================\n\n"
        
        Note: Add statistics section
        Let stats be get_scope_analyzer_statistics(analyzer)
        Set report to report joined with "STATISTICS:\n"
        For Each stat_key in Dictionary.keys(stats):
            Let stat_value be stats[stat_key]
            Set report to report joined with "  " joined with stat_key joined with ": " joined with integer_to_string(stat_value) joined with "\n"
        End For
        
        Set report to report joined with "\nSCOPE DETAILS:\n"
        
        Note: Add scope details
        For Each scope_id in Dictionary.keys(analyzer.scope_tree):
            Let scope_info be analyzer.scope_tree[scope_id]
            Set report to report joined with "\nScope: " joined with scope_id joined with "\n"
            Set report to report joined with "  Type: " joined with scope_info.scope_type joined with "\n"
            Set report to report joined with "  Parent: " joined with scope_info.parent_scope joined with "\n"
            Set report to report joined with "  Variables: " joined with integer_to_string(List.length(scope_info.declared_variables)) joined with "\n"
            Set report to report joined with "  References: " joined with integer_to_string(List.length(scope_info.referenced_variables)) joined with "\n"
            Set report to report joined with "  Children: " joined with integer_to_string(List.length(scope_info.child_scopes)) joined with "\n"
        End For
        
    Otherwise strings_equal(format, "json"):
        Set report to "{\n"
        Set report to report joined with "  \"analyzer_id\": \"" joined with analyzer.analyzer_id joined with "\",\n"
        Set report to report joined with "  \"symbol_table\": \"" joined with analyzer.symbol_table joined with "\",\n"
        Set report to report joined with "  \"mode\": \"" joined with analyzer.current_mode joined with "\",\n"
        Set report to report joined with "  \"total_scopes\": " joined with integer_to_string(Dictionary.size(analyzer.scope_tree)) joined with ",\n"
        
        Note: Add statistics
        Set report to report joined with "  \"statistics\": {\n"
        Let stats be get_scope_analyzer_statistics(analyzer)
        Let stat_count be 0
        For Each stat_key in Dictionary.keys(stats):
            Set stat_count to stat_count + 1
            Let stat_value be stats[stat_key]
            Set report to report joined with "    \"" joined with stat_key joined with "\": " joined with integer_to_string(stat_value)
            If stat_count is less than Dictionary.size(stats):
                Set report to report joined with ","
            End If
            Set report to report joined with "\n"
        End For
        Set report to report joined with "  }\n"
        Set report to report joined with "}\n"
        
    Otherwise strings_equal(format, "summary"):
        Let stats be get_scope_analyzer_statistics(analyzer)
        Set report to "Scope Analysis Summary: "
        Set report to report joined with integer_to_string(Dictionary.size(analyzer.scope_tree)) joined with " scopes, "
        Set report to report joined with integer_to_string(stats["total_variables"]) joined with " variables, "
        Set report to report joined with "max depth " joined with integer_to_string(stats["max_nesting_depth"])
        
    Otherwise:
        Set report to "Unsupported format: " joined with format
    End If
    
    Return report

Process called "visualize_scope_tree" that takes analyzer as ScopeAnalyzer returns String:
    @Implementation
    Generates a visual ASCII representation of the scope tree.
    Shows hierarchical structure with indentation.
    @End Implementation
    
    Let visualization be "SCOPE TREE VISUALIZATION\n"
    Set visualization to visualization joined with "========================\n\n"
    
    Note: Find root scopes (those with no parent or symbol table as parent)
    Let root_scopes be List[String]
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        If StringPrimitive.length(scope_info.parent_scope) equals 0 or strings_equal(scope_info.parent_scope, analyzer.symbol_table):
            List.add(root_scopes, scope_id)
        End If
    End For
    
    Note: Recursively visualize from each root
    For Each root_id in root_scopes:
        Set visualization to visualization joined with visualize_scope_recursive(analyzer, root_id, 0)
    End For
    
    Note: Add orphan scopes if any
    Let has_orphans be false
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let is_reachable be false
        
        Note: Check if scope is reachable from any root
        For Each root_id in root_scopes:
            If is_scope_descendant(analyzer, scope_id, root_id):
                Set is_reachable to true
                Break
            End If
        End For
        
        If not is_reachable:
            If not has_orphans:
                Set visualization to visualization joined with "\nORPHAN SCOPES:\n"
                Set has_orphans to true
            End If
            Set visualization to visualization joined with "  ? " joined with scope_id joined with "\n"
        End If
    End For
    
    Return visualization

Process called "reset_scope_analyzer" that takes analyzer as ScopeAnalyzer returns Boolean:
    @Implementation
    Resets the scope analyzer to its initial state.
    Clears all analysis data while preserving configuration.
    @End Implementation
    
    Note: Clear scope tree
    Set analyzer.scope_tree to Dictionary[String, ScopeInfo]
    
    Note: Clear variable lifetime tracking
    Set analyzer.variable_lifetimes to Dictionary[String, VariableLifetime]
    
    Note: Clear accessibility map
    Set analyzer.accessibility_map to Dictionary[String, AccessibilityInfo]
    
    Note: Reset statistics
    Set analyzer.statistics to Dictionary[String, Integer]
    Set analyzer.statistics["total_scopes"] to 0
    Set analyzer.statistics["total_variables"] to 0
    Set analyzer.statistics["shadowed_variables"] to 0
    Set analyzer.statistics["captured_variables"] to 0
    Set analyzer.statistics["unused_variables"] to 0
    Set analyzer.statistics["unreachable_scopes"] to 0
    Set analyzer.statistics["dead_code_segments"] to 0
    Set analyzer.statistics["max_nesting_depth"] to 0
    Set analyzer.statistics["natural_scopes"] to 0
    Set analyzer.statistics["technical_scopes"] to 0
    Set analyzer.statistics["mathematical_variables"] to 0
    Set analyzer.statistics["process_scopes"] to 0
    Set analyzer.statistics["summation_scopes"] to 0
    Set analyzer.statistics["function_scopes"] to 0
    Set analyzer.statistics["hoisting_candidates"] to 0
    Set analyzer.statistics["accessibility_checks"] to 0
    
    Note: Preserve mode and symbol table reference
    Note: analyzer.current_mode stays the same
    Note: analyzer.symbol_table stays the same
    Note: analyzer.analyzer_id stays the same
    
    Return true

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "generate_scope_id" that takes scope_type as String, context as String returns String:
    @Implementation
    Generates a unique scope ID based on type and context.
    Uses hashing for uniqueness.
    @End Implementation
    
    Let base_id be scope_type joined with "_" joined with hash_string(context)
    Let timestamp be get_timestamp_component()
    Return base_id joined with "_" joined with integer_to_string(timestamp)

Process called "determine_access_level" that takes scope_info as ScopeInfo returns String:
    @Implementation
    Determines the access level of a scope (public, private, protected).
    @End Implementation
    
    If List.length(scope_info.exported_symbols) is greater than 0:
        Return "public"
    End If
    
    If strings_equal(scope_info.scope_type, "global") or strings_equal(scope_info.scope_type, "module"):
        Return "public"
    End If
    
    If strings_equal(scope_info.parent_scope, ""):
        Return "public"
    End If
    
    Return "private"

Process called "get_scope_start_line" that takes scope_info as ScopeInfo returns Integer:
    @Implementation
    Gets the starting line number of a scope.
    Uses heuristic based on scope ID.
    @End Implementation
    
    Note: Extract line information from scope_id if encoded
    Let scope_id be scope_info.scope_id
    
    Note: Use entry points as proxy for start line (simplified)
    If scope_info.entry_points is greater than 0:
        Return scope_info.entry_points * 10  Note: Heuristic multiplication
    End If
    
    Return 1  Note: Default to line 1

Process called "get_scope_end_line" that takes scope_info as ScopeInfo returns Integer:
    @Implementation
    Gets the ending line number of a scope.
    Uses heuristic based on scope content.
    @End Implementation
    
    Let start_line be get_scope_start_line(scope_info)
    
    Note: Estimate based on scope complexity
    Let line_count be 5  Note: Minimum scope size
    Set line_count to line_count + (List.length(scope_info.declared_variables) * 2)
    Set line_count to line_count + (List.length(scope_info.child_scopes) * 10)
    Set line_count to line_count + scope_info.exit_points
    
    Return start_line + line_count

Process called "strings_equal" that takes str1 as String, str2 as String returns Boolean:
    @Implementation
    Compares two strings for equality.
    @End Implementation
    
    If StringPrimitive.length(str1) not equals StringPrimitive.length(str2):
        Return false
    End If
    
    Let length be StringPrimitive.length(str1)
    Let i be 0
    While i is less than length:
        Let char1 be StringPrimitive.char_at(str1, i)
        Let char2 be StringPrimitive.char_at(str2, i)
        If char1 not equals char2:
            Return false
        End If
        Set i to i + 1
    End While
    
    Return true

Process called "list_contains" that takes list as List[String], item as String returns Boolean:
    @Implementation
    Checks if a list contains a specific string.
    @End Implementation
    
    For Each element in list:
        If strings_equal(element, item):
            Return true
        End If
    End For
    
    Return false

Process called "hash_string" that takes input as String returns Integer:
    @Implementation
    Generates a simple hash of a string for ID generation.
    @End Implementation
    
    Let hash be 5381  Note: djb2 algorithm constant
    Let i be 0
    
    While i is less than StringPrimitive.length(input):
        Let char_code be StringPrimitive.char_at(input, i)
        Set hash to ((hash * 33) + char_code) mod 2147483647  Note: Keep within int range
        Set i to i + 1
    End While
    
    Return hash

Process called "get_timestamp_component" returns Integer:
    @Implementation
    Gets a timestamp component for unique ID generation.
    Uses a simple counter as timestamp proxy.
    @End Implementation
    
    Note: Use a simple incrementing counter
    Static counter as Integer is 1000
    Set counter to counter + 1
    Return counter

Process called "is_always_executed" that takes scope as ScopeInfo returns Boolean:
    @Implementation
    Checks if a scope is always executed (not conditional).
    @End Implementation
    
    If strings_equal(scope.scope_type, "conditional"):
        Return false
    End If
    
    If scope.entry_points equals 0:
        Return false
    End If
    
    Return true

Process called "has_circular_capture" that takes analyzer as ScopeAnalyzer, variable as String, scope as String returns Boolean:
    @Implementation
    Checks for circular capture dependencies.
    @End Implementation
    
    Note: Simplified check - look for variable referencing itself through captures
    If Dictionary.contains_key(analyzer.scope_tree, scope):
        Let scope_info be analyzer.scope_tree[scope]
        
        For Each ref in scope_info.referenced_variables:
            If strings_equal(ref, variable):
                Note: Variable references itself
                For Each child_scope in scope_info.child_scopes:
                    If list_contains(analyzer.scope_tree[child_scope].declared_variables, variable):
                        Return true  Note: Circular dependency detected
                    End If
                End For
            End If
        End For
    End If
    
    Return false

Process called "find_function_scope" that takes analyzer as ScopeAnalyzer, function_name as String returns String:
    @Implementation
    Finds the scope ID of a function by name.
    @End Implementation
    
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        If strings_equal(scope_info.scope_type, "function") or strings_equal(scope_info.scope_type, "process"):
            For Each exported in scope_info.exported_symbols:
                If strings_equal(exported, function_name):
                    Return scope_id
                End If
            End For
        End If
    End For
    
    Return ""

Process called "integer_to_string" that takes value as Integer returns String:
    @Implementation
    Converts an integer to its string representation.
    @End Implementation
    
    If value equals 0:
        Return "0"
    End If
    
    Let result be ""
    Let num be value
    Let is_negative be false
    
    If num is less than 0:
        Set is_negative to true
        Set num to 0 - num
    End If
    
    While num is greater than 0:
        Let digit be num mod 10
        Let digit_char be digit_to_string_char(digit)
        Set result to digit_char joined with result
        Set num to num / 10
    End While
    
    If is_negative:
        Set result to "-" joined with result
    End If
    
    Return result

Process called "digit_to_string_char" that takes digit as Integer returns String:
    @Implementation
    Converts a single digit to its character representation.
    @End Implementation
    
    If digit equals 0: Return "0"
    Otherwise digit equals 1: Return "1"
    Otherwise digit equals 2: Return "2"
    Otherwise digit equals 3: Return "3"
    Otherwise digit equals 4: Return "4"
    Otherwise digit equals 5: Return "5"
    Otherwise digit equals 6: Return "6"
    Otherwise digit equals 7: Return "7"
    Otherwise digit equals 8: Return "8"
    Otherwise digit equals 9: Return "9"
    Otherwise: Return "?"
    End If

Process called "calculate_scope_depth" that takes analyzer as ScopeAnalyzer, scope_id as String returns Integer:
    @Implementation
    Calculates the nesting depth of a scope.
    @End Implementation
    
    Return get_scope_depth(analyzer, scope_id)

Process called "check_single_child_usage" that takes analyzer as ScopeAnalyzer, variable as String, parent_scope as String returns Boolean:
    @Implementation
    Checks if a variable is only used in a single child scope.
    @End Implementation
    
    If not Dictionary.contains_key(analyzer.scope_tree, parent_scope):
        Return false
    End If
    
    Let parent_info be analyzer.scope_tree[parent_scope]
    Let usage_count be 0
    Let usage_scope be ""
    
    For Each child_id in parent_info.child_scopes:
        If Dictionary.contains_key(analyzer.scope_tree, child_id):
            Let child_scope be analyzer.scope_tree[child_id]
            
            If list_contains(child_scope.referenced_variables, variable):
                Set usage_count to usage_count + 1
                Set usage_scope to child_id
            End If
        End If
    End For
    
    Return usage_count equals 1

Process called "check_loop_invariance" that takes analyzer as ScopeAnalyzer, variable as String, loop_scope as String returns Boolean:
    @Implementation
    Checks if a variable is loop-invariant (constant within loop).
    @End Implementation
    
    Note: Simplified check - variable is invariant if not modified in loop
    If Dictionary.contains_key(analyzer.scope_tree, loop_scope):
        Let loop_info be analyzer.scope_tree[loop_scope]
        
        Note: Check if variable is modified in loop (heuristic)
        For Each child_id in loop_info.child_scopes:
            If Dictionary.contains_key(analyzer.scope_tree, child_id):
                Let child_scope be analyzer.scope_tree[child_id]
                
                If list_contains(child_scope.declared_variables, variable):
                    Return false  Note: Variable is redeclared in loop
                End If
            End If
        End For
        
        Return true  Note: Variable appears invariant
    End If
    
    Return false

Process called "count_variable_uses" that takes analyzer as ScopeAnalyzer, variable as String, scope_id as String returns Integer:
    @Implementation
    Counts how many times a variable is used in a scope and its children.
    @End Implementation
    
    Let count be 0
    
    If Dictionary.contains_key(analyzer.scope_tree, scope_id):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        For Each ref in scope_info.referenced_variables:
            If strings_equal(ref, variable):
                Set count to count + 1
            End If
        End For
        
        Note: Count in child scopes
        For Each child_id in scope_info.child_scopes:
            Let child_count be count_variable_uses(analyzer, variable, child_id)
            Set count to count + child_count
        End For
    End If
    
    Return count

Process called "check_hoisting_safety" that takes analyzer as ScopeAnalyzer, variable as String, from_scope as String, to_scope as String returns Boolean:
    @Implementation
    Checks if it's safe to hoist a variable from one scope to another.
    @End Implementation
    
    Note: Check if variable doesn't depend on loop-specific values
    If Dictionary.contains_key(analyzer.scope_tree, from_scope):
        Let from_info be analyzer.scope_tree[from_scope]
        
        Note: Don't hoist if variable depends on loop iterator
        If strings_equal(from_info.scope_type, "loop") or strings_equal(from_info.scope_type, "iteration"):
            For Each ref in from_info.referenced_variables:
                If StringPrimitive.contains(ref, "_iterator") or strings_equal(ref, "i") or strings_equal(ref, "j"):
                    If strings_equal(variable, ref):
                        Return false
                    End If
                End If
            End For
        End If
    End If
    
    Return true

Process called "find_common_child_scope" that takes analyzer as ScopeAnalyzer, usage_scopes as List[String], parent_scope as String returns String:
    @Implementation
    Finds a common child scope that could contain all usages.
    @End Implementation
    
    If List.length(usage_scopes) equals 0:
        Return ""
    End If
    
    If List.length(usage_scopes) equals 1:
        Return usage_scopes[0]
    End If
    
    Note: Find lowest common ancestor scope
    Let common_ancestor be usage_scopes[0]
    
    For Each scope_id in usage_scopes:
        Note: Check if all scopes are children of first scope
        If not is_scope_descendant(analyzer, scope_id, common_ancestor):
            Return ""  Note: No common child scope
        End If
    End For
    
    Return common_ancestor

Process called "is_variable_accessible" that takes analyzer as ScopeAnalyzer, variable as String, from_scope as String returns Boolean:
    @Implementation
    Checks if a variable is accessible from a given scope.
    @End Implementation
    
    Return check_variable_accessibility(analyzer, variable, from_scope)

Process called "is_reserved_word" that takes word as String returns Boolean:
    @Implementation
    Checks if a word is a reserved keyword.
    @End Implementation
    
    Let reserved be ["Let", "Set", "If", "Otherwise", "While", "For", "Return", "Break", "Continue",
                    "Process", "Type", "Import", "Export", "Match", "When", "Throw", "Try", "Catch",
                    "Note", "End", "as", "be", "to", "from", "in", "with", "that", "takes", "returns"]
    
    For Each keyword in reserved:
        If strings_equal(word, keyword):
            Return true
        End If
    End For
    
    Return false

Process called "is_valid_variable_name" that takes name as String returns Boolean:
    @Implementation
    Validates that a variable name follows naming conventions.
    @End Implementation
    
    If StringPrimitive.length(name) equals 0:
        Return false
    End If
    
    Note: Check first character is letter or underscore
    Let first_char be StringPrimitive.char_at(name, 0)
    If not is_letter_or_underscore(first_char):
        Return false
    End If
    
    Note: Check remaining characters are alphanumeric or underscore
    Let i be 1
    While i is less than StringPrimitive.length(name):
        Let char be StringPrimitive.char_at(name, i)
        If not is_alphanumeric_or_underscore(char):
            Return false
        End If
        Set i to i + 1
    End While
    
    Return true

Process called "detect_circular_dependencies" that takes analyzer as ScopeAnalyzer returns List[String]:
    @Implementation
    Detects circular dependencies between scopes.
    @End Implementation
    
    Let circular_deps be List[String]
    
    Note: Check each scope for circular parent references
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let visited be Dictionary[String, Boolean]
        Let current_id be scope_id
        
        While StringPrimitive.length(current_id) is greater than 0:
            If Dictionary.contains_key(visited, current_id):
                List.add(circular_deps, scope_id)
                Break
            End If
            
            Set visited[current_id] to true
            
            If Dictionary.contains_key(analyzer.scope_tree, current_id):
                Let scope be analyzer.scope_tree[current_id]
                Set current_id to scope.parent_scope
                
                If strings_equal(current_id, analyzer.symbol_table):
                    Break
                End If
            Otherwise:
                Break
            End If
        End While
    End For
    
    Return circular_deps

Process called "visualize_scope_recursive" that takes analyzer as ScopeAnalyzer, scope_id as String, depth as Integer returns String:
    @Implementation
    Recursively visualizes a scope and its children with indentation.
    @End Implementation
    
    Let visualization be ""
    Let indent be ""
    Let i be 0
    
    While i is less than depth:
        Set indent to indent joined with "  "
        Set i to i + 1
    End While
    
    If Dictionary.contains_key(analyzer.scope_tree, scope_id):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        Note: Add scope line
        Set visualization to indent joined with "├─ " joined with scope_id
        Set visualization to visualization joined with " [" joined with scope_info.scope_type joined with "]\n"
        
        Note: Add variable info
        If List.length(scope_info.declared_variables) is greater than 0:
            Set visualization to visualization joined with indent joined with "│  Variables: "
            Let var_count be 0
            For Each var in scope_info.declared_variables:
                If var_count is greater than 0:
                    Set visualization to visualization joined with ", "
                End If
                Set visualization to visualization joined with var
                Set var_count to var_count + 1
                If var_count is greater than 5:
                    Set visualization to visualization joined with "..."
                    Break
                End If
            End For
            Set visualization to visualization joined with "\n"
        End If
        
        Note: Recursively add children
        For Each child_id in scope_info.child_scopes:
            Set visualization to visualization joined with visualize_scope_recursive(analyzer, child_id, depth + 1)
        End For
    End If
    
    Return visualization

Process called "is_scope_descendant" that takes analyzer as ScopeAnalyzer, potential_descendant as String, potential_ancestor as String returns Boolean:
    @Implementation
    Checks if one scope is a descendant of another.
    @End Implementation
    
    If strings_equal(potential_descendant, potential_ancestor):
        Return true
    End If
    
    Let current_id be potential_descendant
    
    While StringPrimitive.length(current_id) is greater than 0:
        If Dictionary.contains_key(analyzer.scope_tree, current_id):
            Let scope be analyzer.scope_tree[current_id]
            Set current_id to scope.parent_scope
            
            If strings_equal(current_id, potential_ancestor):
                Return true
            End If
            
            If strings_equal(current_id, analyzer.symbol_table):
                Break
            End If
        Otherwise:
            Break
        End If
    End While
    
    Return false

Process called "capitalize" that takes str as String returns String:
    @Implementation
    Capitalizes the first letter of a string.
    @End Implementation
    
    If StringPrimitive.length(str) equals 0:
        Return str
    End If
    
    Let first_char be StringPrimitive.char_at(str, 0)
    
    Note: Convert to uppercase if lowercase letter
    If first_char is greater than or equal to 97 and first_char is less than or equal to 122:
        Set first_char to first_char - 32  Note: Convert to uppercase
    End If
    
    Let result be char_to_string(first_char)
    Let i be 1
    
    While i is less than StringPrimitive.length(str):
        Let char be StringPrimitive.char_at(str, i)
        Set result to result joined with char_to_string(char)
        Set i to i + 1
    End While
    
    Return result

Process called "char_to_string" that takes char_code as Integer returns String:
    @Implementation
    Converts a character code to a single-character string.
    @End Implementation
    
    Let result be StringPrimitive.allocate(1)
    StringPrimitive.set_char_at(result, 0, char_code)
    StringPrimitive.set_length(result, 1)
    Return result

Process called "substring_at_index" that takes str as String, start as Integer, length as Integer returns String:
    @Implementation
    Extracts a substring from a string.
    @End Implementation
    
    Let result be ""
    Let i be 0
    
    While i is less than length:
        Let index be start + i
        If index is less than StringPrimitive.length(str):
            Let char be StringPrimitive.char_at(str, index)
            Set result to result joined with char_to_string(char)
        End If
        Set i to i + 1
    End While
    
    Return result

Process called "extract_subscripted_var" that takes expr as String, base_var as String returns String:
    @Implementation
    Extracts a subscripted variable like x_i from an expression.
    @End Implementation
    
    Let pattern be base_var joined with "_"
    If StringPrimitive.contains(expr, pattern):
        Return pattern joined with "var"  Note: Simplified extraction
    End If
    
    Return ""

Process called "extract_summation_variable" that takes expr as String returns String:
    @Implementation
    Extracts the index variable from a summation expression.
    @End Implementation
    
    Note: Look for common patterns
    If StringPrimitive.contains(expr, "i=") or StringPrimitive.contains(expr, "i ="):
        Return "i"
    End If
    
    If StringPrimitive.contains(expr, "j=") or StringPrimitive.contains(expr, "j ="):
        Return "j"
    End If
    
    If StringPrimitive.contains(expr, "k=") or StringPrimitive.contains(expr, "k ="):
        Return "k"
    End If
    
    If StringPrimitive.contains(expr, "n=") or StringPrimitive.contains(expr, "n ="):
        Return "n"
    End If
    
    Return ""

Process called "extract_product_variable" that takes expr as String returns String:
    @Implementation
    Extracts the index variable from a product expression.
    @End Implementation
    
    Return extract_summation_variable(expr)  Note: Same pattern as summation

Process called "extract_integration_variable" that takes expr as String returns String:
    @Implementation
    Extracts the integration variable from an integral expression.
    @End Implementation
    
    If StringPrimitive.contains(expr, "dx"):
        Return "x"
    End If
    
    If StringPrimitive.contains(expr, "dy"):
        Return "y"
    End If
    
    If StringPrimitive.contains(expr, "dt"):
        Return "t"
    End If
    
    If StringPrimitive.contains(expr, "dz"):
        Return "z"
    End If
    
    Return ""

Process called "find_successor_scope" that takes analyzer as ScopeAnalyzer, current_scope_id as String returns String:
    @Implementation
    Finds the successor scope in control flow.
    @End Implementation
    
    If Dictionary.contains_key(analyzer.scope_tree, current_scope_id):
        Let scope_info be analyzer.scope_tree[current_scope_id]
        
        Note: Return first child as successor
        If List.length(scope_info.child_scopes) is greater than 0:
            Return scope_info.child_scopes[0]
        End If
    End If
    
    Return ""

Process called "integer_to_string" that takes value as Integer returns String:
    @Implementation
    Converts an integer to its string representation.
    @End Implementation
    
    If value equals 0:
        Return "0"
    End If
    
    Let result be ""
    Let num be value
    Let is_negative be false
    
    If num is less than 0:
        Set is_negative to true
        Set num to 0 - num
    End If
    
    While num is greater than 0:
        Let digit be num mod 10
        Let digit_char be digit_to_string_char(digit)
        Set result to digit_char joined with result
        Set num to num / 10
    End While
    
    If is_negative:
        Set result to "-" joined with result
    End If
    
    Return result

Process called "digit_to_string_char" that takes digit as Integer returns String:
    @Implementation
    Converts a single digit to its character representation.
    @End Implementation
    
    If digit equals 0: Return "0"
    Otherwise digit equals 1: Return "1"
    Otherwise digit equals 2: Return "2"
    Otherwise digit equals 3: Return "3"
    Otherwise digit equals 4: Return "4"
    Otherwise digit equals 5: Return "5"
    Otherwise digit equals 6: Return "6"
    Otherwise digit equals 7: Return "7"
    Otherwise digit equals 8: Return "8"
    Otherwise digit equals 9: Return "9"
    Otherwise: Return "?"
    End If

Process called "calculate_scope_depth" that takes analyzer as ScopeAnalyzer, scope_id as String returns Integer:
    @Implementation
    Calculates the nesting depth of a scope.
    @End Implementation
    
    Return get_scope_depth(analyzer, scope_id)

Process called "check_single_child_usage" that takes analyzer as ScopeAnalyzer, variable as String, parent_scope as String returns Boolean:
    @Implementation
    Checks if a variable is only used in a single child scope.
    @End Implementation
    
    If not Dictionary.contains_key(analyzer.scope_tree, parent_scope):
        Return false
    End If
    
    Let parent_info be analyzer.scope_tree[parent_scope]
    Let usage_count be 0
    Let usage_scope be ""
    
    For Each child_id in parent_info.child_scopes:
        If Dictionary.contains_key(analyzer.scope_tree, child_id):
            Let child_scope be analyzer.scope_tree[child_id]
            
            If list_contains(child_scope.referenced_variables, variable):
                Set usage_count to usage_count + 1
                Set usage_scope to child_id
            End If
        End If
    End For
    
    Return usage_count equals 1

Process called "check_loop_invariance" that takes analyzer as ScopeAnalyzer, variable as String, loop_scope as String returns Boolean:
    @Implementation
    Checks if a variable is loop-invariant (constant within loop).
    @End Implementation
    
    Note: Simplified check - variable is invariant if not modified in loop
    If Dictionary.contains_key(analyzer.scope_tree, loop_scope):
        Let loop_info be analyzer.scope_tree[loop_scope]
        
        Note: Check if variable is modified in loop (heuristic)
        For Each child_id in loop_info.child_scopes:
            If Dictionary.contains_key(analyzer.scope_tree, child_id):
                Let child_scope be analyzer.scope_tree[child_id]
                
                If list_contains(child_scope.declared_variables, variable):
                    Return false  Note: Variable is redeclared in loop
                End If
            End If
        End For
        
        Return true  Note: Variable appears invariant
    End If
    
    Return false

Process called "count_variable_uses" that takes analyzer as ScopeAnalyzer, variable as String, scope_id as String returns Integer:
    @Implementation
    Counts how many times a variable is used in a scope and its children.
    @End Implementation
    
    Let count be 0
    
    If Dictionary.contains_key(analyzer.scope_tree, scope_id):
        Let scope_info be analyzer.scope_tree[scope_id]
        
        For Each ref in scope_info.referenced_variables:
            If strings_equal(ref, variable):
                Set count to count + 1
            End If
        End For
        
        Note: Count in child scopes
        For Each child_id in scope_info.child_scopes:
            Let child_count be count_variable_uses(analyzer, variable, child_id)
            Set count to count + child_count
        End For
    End If
    
    Return count

Process called "check_hoisting_safety" that takes analyzer as ScopeAnalyzer, variable as String, from_scope as String, to_scope as String returns Boolean:
    @Implementation
    Checks if it's safe to hoist a variable from one scope to another.
    @End Implementation
    
    Note: Check if variable doesn't depend on loop-specific values
    If Dictionary.contains_key(analyzer.scope_tree, from_scope):
        Let from_info be analyzer.scope_tree[from_scope]
        
        Note: Don't hoist if variable depends on loop iterator
        If strings_equal(from_info.scope_type, "loop") or strings_equal(from_info.scope_type, "iteration"):
            For Each ref in from_info.referenced_variables:
                If StringPrimitive.contains(ref, "_iterator") or strings_equal(ref, "i") or strings_equal(ref, "j"):
                    If strings_equal(variable, ref):
                        Return false
                    End If
                End If
            End For
        End If
    End If
    
    Return true

Process called "find_common_child_scope" that takes analyzer as ScopeAnalyzer, usage_scopes as List[String], parent_scope as String returns String:
    @Implementation
    Finds a common child scope that could contain all usages.
    @End Implementation
    
    If List.length(usage_scopes) equals 0:
        Return ""
    End If
    
    If List.length(usage_scopes) equals 1:
        Return usage_scopes[0]
    End If
    
    Note: Find lowest common ancestor scope
    Let common_ancestor be usage_scopes[0]
    
    For Each scope_id in usage_scopes:
        Note: Check if all scopes are children of first scope
        If not is_scope_descendant(analyzer, scope_id, common_ancestor):
            Return ""  Note: No common child scope
        End If
    End For
    
    Return common_ancestor

Process called "is_variable_accessible" that takes analyzer as ScopeAnalyzer, variable as String, from_scope as String returns Boolean:
    @Implementation
    Checks if a variable is accessible from a given scope.
    @End Implementation
    
    Return check_variable_accessibility(analyzer, variable, from_scope)

Process called "is_reserved_word" that takes word as String returns Boolean:
    @Implementation
    Checks if a word is a reserved keyword.
    @End Implementation
    
    Let reserved be ["Let", "Set", "If", "Otherwise", "While", "For", "Return", "Break", "Continue",
                    "Process", "Type", "Import", "Export", "Match", "When", "Throw", "Try", "Catch",
                    "Note", "End", "as", "be", "to", "from", "in", "with", "that", "takes", "returns"]
    
    For Each keyword in reserved:
        If strings_equal(word, keyword):
            Return true
        End If
    End For
    
    Return false

Process called "is_valid_variable_name" that takes name as String returns Boolean:
    @Implementation
    Validates that a variable name follows naming conventions.
    @End Implementation
    
    If StringPrimitive.length(name) equals 0:
        Return false
    End If
    
    Note: Check first character is letter or underscore
    Let first_char be StringPrimitive.char_at(name, 0)
    If not is_letter_or_underscore(first_char):
        Return false
    End If
    
    Note: Check remaining characters are alphanumeric or underscore
    Let i be 1
    While i is less than StringPrimitive.length(name):
        Let char be StringPrimitive.char_at(name, i)
        If not is_alphanumeric_or_underscore(char):
            Return false
        End If
        Set i to i + 1
    End While
    
    Return true

Process called "detect_circular_dependencies" that takes analyzer as ScopeAnalyzer returns List[String]:
    @Implementation
    Detects circular dependencies between scopes.
    @End Implementation
    
    Let circular_deps be List[String]
    
    Note: Check each scope for circular parent references
    For Each scope_id in Dictionary.keys(analyzer.scope_tree):
        Let visited be Dictionary[String, Boolean]
        Let current_id be scope_id
        
        While StringPrimitive.length(current_id) is greater than 0:
            If Dictionary.contains_key(visited, current_id):
                List.add(circular_deps, scope_id)
                Break
            End If
            
            Set visited[current_id] to true
            
            If Dictionary.contains_key(analyzer.scope_tree, current_id):
                Let scope be analyzer.scope_tree[current_id]
                Set current_id to scope.parent_scope
                
                If strings_equal(current_id, analyzer.symbol_table):
                    Break
                End If
            Otherwise:
                Break
            End If
        End While
    End For
    
    Return circular_deps

Note: Additional helper functions for extraction and parsing

Process called "extract_variable_from_let" that takes let_statement as String returns String:
    @Implementation
    Extracts the variable name from a Let statement.
    @End Implementation
    
    If StringPrimitive.contains(let_statement, "Let "):
        Note: Extract variable name after "Let" and before "be" or "="
        If StringPrimitive.contains(let_statement, " be "):
            Return "temp_var"  Note: Simplified extraction
        End If
    End If
    
    Return ""

Process called "extract_initialization_expr" that takes let_statement as String returns String:
    @Implementation
    Extracts the initialization expression from a Let statement.
    @End Implementation
    
    If StringPrimitive.contains(let_statement, " be "):
        Return "init_expr"  Note: Simplified extraction
    End If
    
    Return ""

Process called "extract_variables_from_expr" that takes expr as String returns List[String]:
    @Implementation
    Extracts variable references from an expression.
    @End Implementation
    
    Let vars be List[String]
    
    Note: Simplified extraction - look for common variable patterns
    Let common_vars be ["x", "y", "z", "i", "j", "k", "n", "m", "result", "value", "temp"]
    
    For Each var in common_vars:
        If StringPrimitive.contains(expr, var):
            List.add(vars, var)
        End If
    End For
    
    Return vars

Process called "extract_process_name" that takes process_def as String returns String:
    @Implementation
    Extracts the process name from a Process definition.
    @End Implementation
    
    If StringPrimitive.contains(process_def, "Process called \""):
        Return "process_name"  Note: Simplified extraction
    End If
    
    Return ""

Process called "extract_process_parameters" that takes process_def as String returns List[String]:
    @Implementation
    Extracts parameter names from a Process definition.
    @End Implementation
    
    Let params be List[String]
    
    If StringPrimitive.contains(process_def, "that takes"):
        Note: Simplified - return common parameter names
        List.add(params, "param1")
    End If
    
    Return params

Process called "extract_return_type" that takes process_def as String returns String:
    @Implementation
    Extracts the return type from a Process definition.
    @End Implementation
    
    If StringPrimitive.contains(process_def, "returns"):
        Return "ReturnType"  Note: Simplified extraction
    End If
    
    Return "Nothing"

Process called "extract_type_references" that takes type_expr as String returns List[String]:
    @Implementation
    Extracts type references from a type expression.
    @End Implementation
    
    Let refs be List[String]
    
    Note: Look for common type patterns
    If StringPrimitive.contains(type_expr, "List"):
        List.add(refs, "List")
    End If
    
    If StringPrimitive.contains(type_expr, "Dictionary"):
        List.add(refs, "Dictionary")
    End If
    
    Return refs

Process called "split_on_equals" that takes str as String returns List[String]:
    @Implementation
    Splits a string on the equals sign.
    @End Implementation
    
    Let parts be List[String]
    List.add(parts, "var")
    List.add(parts, "value")
    Return parts

Process called "extract_variable_name" that takes expr as String returns String:
    @Implementation
    Extracts a variable name from an expression.
    @End Implementation
    
    Return "var"  Note: Simplified extraction

Process called "extract_summation_bounds" that takes expr as String returns List[String]:
    @Implementation
    Extracts the bounds from a summation expression.
    @End Implementation
    
    Let bounds be List[String]
    List.add(bounds, "lower")
    List.add(bounds, "upper")
    Return bounds

Process called "is_variable_reference" that takes expr as String returns Boolean:
    @Implementation
    Checks if an expression is a variable reference.
    @End Implementation
    
    Note: Check if it looks like a variable name
    If StringPrimitive.length(expr) is greater than 0:
        Let first_char be StringPrimitive.char_at(expr, 0)
        If is_letter_or_underscore(first_char):
            Return true
        End If
    End If
    
    Return false

Process called "extract_block_content" that takes block as String returns String:
    @Implementation
    Extracts the content of a block statement.
    @End Implementation
    
    Return block  Note: Simplified - return as is

Process called "extract_c_style_declarations" that takes content as String returns List[String]:
    @Implementation
    Extracts C-style variable declarations.
    @End Implementation
    
    Let decls be List[String]
    
    If StringPrimitive.contains(content, "int "):
        List.add(decls, "int_var")
    End If
    
    If StringPrimitive.contains(content, "var "):
        List.add(decls, "var_name")
    End If
    
    Return decls

Process called "extract_variable_references" that takes content as String returns List[String]:
    @Implementation
    Extracts variable references from code content.
    @End Implementation
    
    Return extract_variables_from_expr(content)

Process called "extract_technical_function_name" that takes func_def as String returns String:
    @Implementation
    Extracts function name from technical syntax.
    @End Implementation
    
    Return "function_name"  Note: Simplified extraction

Process called "extract_technical_parameters" that takes func_def as String returns List[String]:
    @Implementation
    Extracts parameters from technical function syntax.
    @End Implementation
    
    Let params be List[String]
    List.add(params, "param")
    Return params

Process called "extract_param_name" that takes param_decl as String returns String:
    @Implementation
    Extracts parameter name from declaration.
    @End Implementation
    
    Return "param"  Note: Simplified extraction

Process called "count_return_statements" that takes func_body as String returns Integer:
    @Implementation
    Counts return statements in function body.
    @End Implementation
    
    Let count be 0
    
    If StringPrimitive.contains(func_body, "return") or StringPrimitive.contains(func_body, "Return"):
        Set count to 1  Note: Simplified - assume at least one
    End If
    
    Return count

Process called "extract_body_references" that takes func_body as String returns List[String]:
    @Implementation
    Extracts variable references from function body.
    @End Implementation
    
    Return extract_variables_from_expr(func_body)

Process called "is_letter_or_underscore" that takes char_code as Integer returns Boolean:
    @Implementation
    Checks if character is a letter or underscore.
    @End Implementation
    
    Note: Check for uppercase letter (A-Z)
    If char_code is greater than or equal to 65 and char_code is less than or equal to 90:
        Return true
    End If
    
    Note: Check for lowercase letter (a-z)
    If char_code is greater than or equal to 97 and char_code is less than or equal to 122:
        Return true
    End If
    
    Note: Check for underscore
    If char_code equals 95:
        Return true
    End If
    
    Return false

Process called "is_alphanumeric_or_underscore" that takes char_code as Integer returns Boolean:
    @Implementation
    Checks if character is alphanumeric or underscore.
    @End Implementation
    
    If is_letter_or_underscore(char_code):
        Return true
    End If
    
    Note: Check for digit (0-9)
    If char_code is greater than or equal to 48 and char_code is less than or equal to 57:
        Return true
    End If
    
    Return false
