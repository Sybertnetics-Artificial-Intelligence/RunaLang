Note:
internal/buffer_utils.runa - Compiler-Only Buffer Management Utilities

This module provides buffer management utilities specifically for compiler internals.
These are NOT part of the standard library and should only be used within the compiler.

@Reasoning:
- Compiler needs efficient buffer management for code generation and data structures
- Specialized for compiler workloads: frequent appends, bulk reads, patching
- Separate from stdlib to avoid dependencies and maintain isolation
- Optimized for compiler-specific access patterns
@End Reasoning

@Implementation:
- Custom memory management for compiler buffers
- Inline assembly for critical operations
- Support for resizable and fixed-size buffers
- Efficient bulk operations for code generation
@End Implementation

@Performance_Hints:
- Pre-allocated pools for common buffer sizes
- Geometric growth strategy to minimize reallocations
- Cache-aligned buffers for better performance
- Fast-path for small buffer operations
@End Performance_Hints
:End Note

Note: =====================================================================
Note: BUFFER CREATION AND INITIALIZATION
Note: =====================================================================

Process called "create_compiler_buffer" that takes initial_size as Integer returns Pointer:
    Let buffer_struct be allocate_aligned_memory(32, 8)
    Let data be allocate_aligned_memory(initial_size, 64)
    
    store_pointer_at_offset(buffer_struct, 0, data)
    store_integer_at_offset(buffer_struct, 8, 0)
    store_integer_at_offset(buffer_struct, 16, initial_size)
    store_integer_at_offset(buffer_struct, 24, 0)
    
    Return buffer_struct
End Process

Process called "create_fixed_buffer" that takes size as Integer returns Pointer:
    Let buffer_struct be allocate_aligned_memory(32, 8)
    Let data be allocate_aligned_memory(size, 64)
    
    store_pointer_at_offset(buffer_struct, 0, data)
    store_integer_at_offset(buffer_struct, 8, 0)
    store_integer_at_offset(buffer_struct, 16, size)
    store_integer_at_offset(buffer_struct, 24, 1)
    
    Return buffer_struct
End Process

Process called "create_buffer_from_data" that takes data as Pointer, size as Integer returns Pointer:
    Let buffer be create_compiler_buffer(size)
    Let buffer_data be load_pointer_at_offset(buffer, 0)
    
    copy_memory_fast(data, buffer_data, size)
    store_integer_at_offset(buffer, 8, size)
    
    Return buffer
End Process

Note: =====================================================================
Note: BUFFER WRITE OPERATIONS
Note: =====================================================================

Process called "write_byte_to_buffer" that takes buffer as Pointer, byte as Integer:
    Let position be load_integer_at_offset(buffer, 8)
    Let capacity be load_integer_at_offset(buffer, 16)
    
    If position >= capacity:
        grow_buffer(buffer)
    End If
    
    Let data be load_pointer_at_offset(buffer, 0)
    store_byte_at_offset(data, position, byte)
    store_integer_at_offset(buffer, 8, add_integers(position, 1))
End Process

Process called "write_integer_to_buffer" that takes buffer as Pointer, value as Integer:
    ensure_buffer_space(buffer, 8)
    
    Let position be load_integer_at_offset(buffer, 8)
    Let data be load_pointer_at_offset(buffer, 0)
    
    store_integer_at_offset(data, position, value)
    store_integer_at_offset(buffer, 8, add_integers(position, 8))
End Process

Process called "write_bytes_to_buffer" that takes buffer as Pointer, source as Pointer, count as Integer:
    ensure_buffer_space(buffer, count)
    
    Let position be load_integer_at_offset(buffer, 8)
    Let data be load_pointer_at_offset(buffer, 0)
    Let dest be add_pointer_offset(data, position)
    
    copy_memory_fast(source, dest, count)
    store_integer_at_offset(buffer, 8, add_integers(position, count))
End Process

Process called "write_buffer_to_buffer" that takes dest as Pointer, source as Pointer:
    Let source_size be load_integer_at_offset(source, 8)
    Let source_data be load_pointer_at_offset(source, 0)
    
    write_bytes_to_buffer(dest, source_data, source_size)
End Process

Note: =====================================================================
Note: BUFFER READ OPERATIONS
Note: =====================================================================

Process called "read_byte_from_buffer" that takes buffer as Pointer, position as Integer returns Integer:
    Let size be load_integer_at_offset(buffer, 8)
    
    If position >= size:
        Return -1
    End If
    
    Let data be load_pointer_at_offset(buffer, 0)
    Return load_byte_at_offset(data, position)
End Process

Process called "read_integer_from_buffer" that takes buffer as Pointer, position as Integer returns Integer:
    Let size be load_integer_at_offset(buffer, 8)
    
    If add_integers(position, 8) > size:
        Return 0
    End If
    
    Let data be load_pointer_at_offset(buffer, 0)
    Return load_integer_at_offset(data, position)
End Process

Process called "read_bytes_from_buffer" that takes buffer as Pointer, position as Integer, dest as Pointer, count as Integer returns Integer:
    Let size be load_integer_at_offset(buffer, 8)
    Let available be subtract_integers(size, position)
    
    If available <= 0:
        Return 0
    End If
    
    Let actual_count be count
    If actual_count > available:
        Let actual_count be available
    End If
    
    Let data be load_pointer_at_offset(buffer, 0)
    Let source be add_pointer_offset(data, position)
    
    copy_memory_fast(source, dest, actual_count)
    Return actual_count
End Process

Note: =====================================================================
Note: BUFFER MANIPULATION
Note: =====================================================================

Process called "reset_buffer" that takes buffer as Pointer:
    store_integer_at_offset(buffer, 8, 0)
End Process

Process called "truncate_buffer" that takes buffer as Pointer, new_size as Integer:
    Let current_size be load_integer_at_offset(buffer, 8)
    
    If new_size < current_size:
        store_integer_at_offset(buffer, 8, new_size)
    End If
End Process

Process called "reserve_buffer_space" that takes buffer as Pointer, required_space as Integer:
    Let position be load_integer_at_offset(buffer, 8)
    Let capacity be load_integer_at_offset(buffer, 16)
    Let needed be add_integers(position, required_space)
    
    If needed > capacity:
        Let new_capacity be calculate_new_capacity(capacity, needed)
        resize_buffer(buffer, new_capacity)
    End If
End Process

Process called "compact_buffer" that takes buffer as Pointer:
    Let size be load_integer_at_offset(buffer, 8)
    Let capacity be load_integer_at_offset(buffer, 16)
    
    If size < divide_by_four(capacity):
        Let new_capacity be multiply_by_two(size)
        If new_capacity < 64:
            Let new_capacity be 64
        End If
        resize_buffer(buffer, new_capacity)
    End If
End Process

Note: =====================================================================
Note: BUFFER PATCHING AND MODIFICATION
Note: =====================================================================

Process called "patch_byte_in_buffer" that takes buffer as Pointer, position as Integer, byte as Integer:
    Let size be load_integer_at_offset(buffer, 8)
    
    If position >= size:
        Return
    End If
    
    Let data be load_pointer_at_offset(buffer, 0)
    store_byte_at_offset(data, position, byte)
End Process

Process called "patch_integer_in_buffer" that takes buffer as Pointer, position as Integer, value as Integer:
    Let size be load_integer_at_offset(buffer, 8)
    
    If add_integers(position, 8) > size:
        Return
    End If
    
    Let data be load_pointer_at_offset(buffer, 0)
    store_integer_at_offset(data, position, value)
End Process

Process called "insert_bytes_in_buffer" that takes buffer as Pointer, position as Integer, source as Pointer, count as Integer:
    Let size be load_integer_at_offset(buffer, 8)
    
    If position > size:
        Return
    End If
    
    ensure_buffer_space(buffer, count)
    
    Let data be load_pointer_at_offset(buffer, 0)
    Let move_count be subtract_integers(size, position)
    
    If move_count > 0:
        Let src_ptr be add_pointer_offset(data, position)
        Let dst_ptr be add_pointer_offset(data, add_integers(position, count))
        move_memory_backward(src_ptr, dst_ptr, move_count)
    End If
    
    Let dest_ptr be add_pointer_offset(data, position)
    copy_memory_fast(source, dest_ptr, count)
    
    store_integer_at_offset(buffer, 8, add_integers(size, count))
End Process

Process called "delete_bytes_from_buffer" that takes buffer as Pointer, position as Integer, count as Integer:
    Let size be load_integer_at_offset(buffer, 8)
    
    If position >= size:
        Return
    End If
    
    Let actual_count be count
    If add_integers(position, count) > size:
        Let actual_count be subtract_integers(size, position)
    End If
    
    Let data be load_pointer_at_offset(buffer, 0)
    Let src_ptr be add_pointer_offset(data, add_integers(position, actual_count))
    Let dst_ptr be add_pointer_offset(data, position)
    Let move_count be subtract_integers(size, add_integers(position, actual_count))
    
    If move_count > 0:
        move_memory_forward(src_ptr, dst_ptr, move_count)
    End If
    
    store_integer_at_offset(buffer, 8, subtract_integers(size, actual_count))
End Process

Note: =====================================================================
Note: BUFFER COMPARISON AND SEARCHING
Note: =====================================================================

Process called "compare_buffers" that takes buf1 as Pointer, buf2 as Pointer returns Boolean:
    Let size1 be load_integer_at_offset(buf1, 8)
    Let size2 be load_integer_at_offset(buf2, 8)
    
    If size1 is not size2:
        Return false
    End If
    
    Let data1 be load_pointer_at_offset(buf1, 0)
    Let data2 be load_pointer_at_offset(buf2, 0)
    
    Return compare_memory_fast(data1, data2, size1)
End Process

Process called "find_byte_in_buffer" that takes buffer as Pointer, byte as Integer, start_pos as Integer returns Integer:
    Let size be load_integer_at_offset(buffer, 8)
    Let data be load_pointer_at_offset(buffer, 0)
    
    Let i be start_pos
    While i < size:
        Let current be load_byte_at_offset(data, i)
        If current is byte:
            Return i
        End If
        Let i be add_integers(i, 1)
    End While
    
    Return -1
End Process

Process called "find_pattern_in_buffer" that takes buffer as Pointer, pattern as Pointer, pattern_size as Integer returns Integer:
    Let buffer_size be load_integer_at_offset(buffer, 8)
    Let buffer_data be load_pointer_at_offset(buffer, 0)
    
    If pattern_size > buffer_size:
        Return -1
    End If
    
    Let limit be subtract_integers(buffer_size, pattern_size)
    Let i be 0
    
    While i <= limit:
        Let ptr be add_pointer_offset(buffer_data, i)
        If compare_memory_fast(ptr, pattern, pattern_size):
            Return i
        End If
        Let i be add_integers(i, 1)
    End While
    
    Return -1
End Process

Note: =====================================================================
Note: BUFFER UTILITIES
Note: =====================================================================

Process called "get_buffer_size" that takes buffer as Pointer returns Integer:
    Return load_integer_at_offset(buffer, 8)
End Process

Process called "get_buffer_capacity" that takes buffer as Pointer returns Integer:
    Return load_integer_at_offset(buffer, 16)
End Process

Process called "get_buffer_data" that takes buffer as Pointer returns Pointer:
    Return load_pointer_at_offset(buffer, 0)
End Process

Process called "get_buffer_remaining" that takes buffer as Pointer returns Integer:
    Let size be load_integer_at_offset(buffer, 8)
    Let capacity be load_integer_at_offset(buffer, 16)
    Return subtract_integers(capacity, size)
End Process

Process called "clone_buffer" that takes source as Pointer returns Pointer:
    Let size be load_integer_at_offset(source, 8)
    Let source_data be load_pointer_at_offset(source, 0)
    
    Return create_buffer_from_data(source_data, size)
End Process

Process called "buffer_to_byte_array" that takes buffer as Pointer returns Pointer:
    Let size be load_integer_at_offset(buffer, 8)
    Let data be load_pointer_at_offset(buffer, 0)
    
    Let array be allocate_memory(size)
    copy_memory_fast(data, array, size)
    
    Return array
End Process

Note: Helper functions for buffer management

Process called "grow_buffer" that takes buffer as Pointer:
    Let is_fixed be load_integer_at_offset(buffer, 24)
    
    If is_fixed is not 0:
        Return
    End If
    
    Let capacity be load_integer_at_offset(buffer, 16)
    Let new_capacity be calculate_new_capacity(capacity, add_integers(capacity, 1))
    resize_buffer(buffer, new_capacity)
End Process

Process called "ensure_buffer_space" that takes buffer as Pointer, required as Integer:
    Let position be load_integer_at_offset(buffer, 8)
    Let capacity be load_integer_at_offset(buffer, 16)
    Let needed be add_integers(position, required)
    
    If needed > capacity:
        Let is_fixed be load_integer_at_offset(buffer, 24)
        If is_fixed is not 0:
            Return
        End If
        
        Let new_capacity be calculate_new_capacity(capacity, needed)
        resize_buffer(buffer, new_capacity)
    End If
End Process

Process called "resize_buffer" that takes buffer as Pointer, new_capacity as Integer:
    Let old_data be load_pointer_at_offset(buffer, 0)
    Let size be load_integer_at_offset(buffer, 8)
    
    Let new_data be allocate_aligned_memory(new_capacity, 64)
    copy_memory_fast(old_data, new_data, size)
    
    store_pointer_at_offset(buffer, 0, new_data)
    store_integer_at_offset(buffer, 16, new_capacity)
End Process

Process called "calculate_new_capacity" that takes current as Integer, minimum as Integer returns Integer:
    Let new_capacity be current
    
    While new_capacity < minimum:
        Let new_capacity be multiply_by_two(new_capacity)
        If new_capacity < 64:
            Let new_capacity be 64
        End If
    End While
    
    Return new_capacity
End Process

Process called "allocate_aligned_memory" that takes size as Integer, alignment as Integer returns Pointer:
    Let result as Pointer
    Inline Assembly:
        "mov rdi, %1\n"               Note: Size to allocate
        "mov rsi, %2\n"               Note: Alignment requirement
        "call compiler_aligned_malloc\n"   Note: Call aligned allocation
        "mov %0, rax\n"               Note: Store result
        : "=r"(result)
        : "r"(size), "r"(alignment)
        : "rax", "rdi", "rsi", "memory"
    End Assembly
    Return result
End Process

Process called "allocate_memory" that takes size as Integer returns Pointer:
    Let result as Pointer
    Inline Assembly:
        "mov rdi, %1\n"           Note: Size to allocate
        "call compiler_malloc\n"   Note: Call allocation
        "mov %0, rax\n"           Note: Store result
        : "=r"(result)
        : "r"(size)
        : "rax", "rdi", "memory"
    End Assembly
    Return result
End Process

Process called "copy_memory_fast" that takes source as Pointer, dest as Pointer, size as Integer:
    Inline Assembly:
        "mov rsi, %0\n"    Note: Source address
        "mov rdi, %1\n"    Note: Destination address
        "mov rcx, %2\n"    Note: Number of bytes
        "rep movsb\n"      Note: Fast memory copy
        :
        : "r"(source), "r"(dest), "r"(size)
        : "rsi", "rdi", "rcx", "memory"
    End Assembly
End Process

Process called "compare_memory_fast" that takes ptr1 as Pointer, ptr2 as Pointer, size as Integer returns Boolean:
    Let result as Boolean
    Inline Assembly:
        "mov rsi, %1\n"    Note: First pointer
        "mov rdi, %2\n"    Note: Second pointer
        "mov rcx, %3\n"    Note: Number of bytes
        "repe cmpsb\n"     Note: Compare bytes
        "sete al\n"        Note: Set if equal
        "movzx eax, al\n"  Note: Zero extend
        "mov %0, rax\n"    Note: Store result
        : "=r"(result)
        : "r"(ptr1), "r"(ptr2), "r"(size)
        : "rax", "rsi", "rdi", "rcx", "flags", "memory"
    End Assembly
    Return result
End Process

Process called "move_memory_forward" that takes source as Pointer, dest as Pointer, size as Integer:
    Inline Assembly:
        "mov rsi, %0\n"    Note: Source address
        "mov rdi, %1\n"    Note: Destination address
        "mov rcx, %2\n"    Note: Number of bytes
        "rep movsb\n"      Note: Move bytes forward
        :
        : "r"(source), "r"(dest), "r"(size)
        : "rsi", "rdi", "rcx", "memory"
    End Assembly
End Process

Process called "move_memory_backward" that takes source as Pointer, dest as Pointer, size as Integer:
    Inline Assembly:
        "mov rsi, %0\n"    Note: Source address
        "add rsi, %2\n"    Note: Point to end
        "dec rsi\n"        Note: Last byte
        "mov rdi, %1\n"    Note: Destination address
        "add rdi, %2\n"    Note: Point to end
        "dec rdi\n"        Note: Last byte
        "mov rcx, %2\n"    Note: Number of bytes
        "std\n"            Note: Set direction flag (backward)
        "rep movsb\n"      Note: Move bytes backward
        "cld\n"            Note: Clear direction flag
        :
        : "r"(source), "r"(dest), "r"(size)
        : "rsi", "rdi", "rcx", "flags", "memory"
    End Assembly
End Process

Process called "store_pointer_at_offset" that takes base as Pointer, offset as Integer, value as Pointer:
    Inline Assembly:
        "mov rax, %0\n"        Note: Base address
        "add rax, %1\n"        Note: Add offset
        "mov [rax], %2\n"      Note: Store pointer value
        :
        : "r"(base), "r"(offset), "r"(value)
        : "rax", "memory"
    End Assembly
End Process

Process called "store_integer_at_offset" that takes base as Pointer, offset as Integer, value as Integer:
    Inline Assembly:
        "mov rax, %0\n"        Note: Base address
        "add rax, %1\n"        Note: Add offset
        "mov [rax], %2\n"      Note: Store integer value
        :
        : "r"(base), "r"(offset), "r"(value)
        : "rax", "memory"
    End Assembly
End Process

Process called "store_byte_at_offset" that takes base as Pointer, offset as Integer, value as Integer:
    Inline Assembly:
        "mov rax, %0\n"                Note: Base address
        "add rax, %1\n"                Note: Add offset
        "mov byte ptr [rax], %2b\n"    Note: Store byte value
        :
        : "r"(base), "r"(offset), "r"(value)
        : "rax", "memory"
    End Assembly
End Process

Process called "load_pointer_at_offset" that takes base as Pointer, offset as Integer returns Pointer:
    Let result as Pointer
    Inline Assembly:
        "mov rax, %1\n"        Note: Base address
        "add rax, %2\n"        Note: Add offset
        "mov rax, [rax]\n"     Note: Load pointer value
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        : "r"(base), "r"(offset)
        : "rax", "memory"
    End Assembly
    Return result
End Process

Process called "load_integer_at_offset" that takes base as Pointer, offset as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"        Note: Base address
        "add rax, %2\n"        Note: Add offset
        "mov rax, [rax]\n"     Note: Load integer value
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        : "r"(base), "r"(offset)
        : "rax", "memory"
    End Assembly
    Return result
End Process

Process called "load_byte_at_offset" that takes base as Pointer, offset as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"                Note: Base address
        "add rax, %2\n"                Note: Add offset
        "movzx rax, byte ptr [rax]\n"  Note: Load byte with zero extend
        "mov %0, rax\n"                Note: Store result
        : "=r"(result)
        : "r"(base), "r"(offset)
        : "rax", "memory"
    End Assembly
    Return result
End Process

Process called "add_pointer_offset" that takes ptr as Pointer, offset as Integer returns Pointer:
    Let result as Pointer
    Inline Assembly:
        "mov rax, %1\n"        Note: Pointer value
        "add rax, %2\n"        Note: Add offset
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        : "r"(ptr), "r"(offset)
        : "rax"
    End Assembly
    Return result
End Process

Process called "add_integers" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"        Note: First operand
        "add rax, %2\n"        Note: Add second operand
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "subtract_integers" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"        Note: First operand
        "sub rax, %2\n"        Note: Subtract second operand
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "multiply_by_two" that takes value as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"        Note: Value to multiply
        "shl rax, 1\n"         Note: Shift left by 1 (multiply by 2)
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        : "r"(value)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "divide_by_four" that takes value as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"        Note: Value to divide
        "shr rax, 2\n"         Note: Shift right by 2 (divide by 4)
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        : "r"(value)
        : "rax", "flags"
    End Assembly
    Return result
End Process