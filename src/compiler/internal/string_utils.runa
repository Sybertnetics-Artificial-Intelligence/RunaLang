Note:
internal/string_utils.runa - Compiler-Only String Handling Utilities

This module provides string manipulation utilities specifically for compiler internals.
These are NOT part of the standard library and should only be used within the compiler.

@Reasoning:
- Compiler needs string operations for parsing, error messages, and code generation
- These utilities are optimized for compiler workloads and patterns
- Separate from stdlib to maintain clear boundaries and avoid dependencies
- Minimal, focused implementation for compiler-specific needs
@End Reasoning

@Implementation:
- Direct memory manipulation for string operations
- Inline assembly for performance-critical paths
- No external dependencies or stdlib imports
- Focused on compiler use cases like identifier validation, path manipulation
@End Implementation

@Performance_Hints:
- Optimized for short strings (identifiers, keywords)
- In-place operations where possible to minimize allocations
- Cache-friendly data structures for repeated operations
- Fast path for common compiler patterns
@End Performance_Hints
:End Note

Note: =====================================================================
Note: STRING CREATION AND INITIALIZATION
Note: =====================================================================

Process called "create_compiler_string" that takes initial_capacity as Integer returns Pointer:
    Let string_struct be allocate_memory(24)
    Let buffer be allocate_memory(initial_capacity)
    
    store_pointer_at_offset(string_struct, 0, buffer)
    store_integer_at_offset(string_struct, 8, 0)
    store_integer_at_offset(string_struct, 16, initial_capacity)
    
    Return string_struct
End Process

Process called "create_string_from_literal" that takes literal_ptr as Pointer, length as Integer returns Pointer:
    Let string_struct be create_compiler_string(add_integers(length, 1))
    Let buffer be load_pointer_at_offset(string_struct, 0)
    
    copy_memory(literal_ptr, buffer, length)
    store_byte_at_offset(buffer, length, 0)
    store_integer_at_offset(string_struct, 8, length)
    
    Return string_struct
End Process

Process called "duplicate_compiler_string" that takes source_string as Pointer returns Pointer:
    Let source_length be load_integer_at_offset(source_string, 8)
    Let source_buffer be load_pointer_at_offset(source_string, 0)
    
    Let new_string be create_compiler_string(add_integers(source_length, 1))
    Let new_buffer be load_pointer_at_offset(new_string, 0)
    
    copy_memory(source_buffer, new_buffer, add_integers(source_length, 1))
    store_integer_at_offset(new_string, 8, source_length)
    
    Return new_string
End Process

Note: =====================================================================
Note: STRING COMPARISON AND SEARCHING
Note: =====================================================================

Process called "strings_equal_compiler" that takes str1 as Pointer, str2 as Pointer returns Boolean:
    Let len1 be load_integer_at_offset(str1, 8)
    Let len2 be load_integer_at_offset(str2, 8)
    
    If len1 is not len2:
        Return false
    End If
    
    Let buf1 be load_pointer_at_offset(str1, 0)
    Let buf2 be load_pointer_at_offset(str2, 0)
    
    Return compare_memory(buf1, buf2, len1)
End Process

Process called "find_substring_compiler" that takes haystack as Pointer, needle as Pointer returns Integer:
    Let haystack_len be load_integer_at_offset(haystack, 8)
    Let needle_len be load_integer_at_offset(needle, 8)
    
    If needle_len > haystack_len:
        Return -1
    End If
    
    Let haystack_buf be load_pointer_at_offset(haystack, 0)
    Let needle_buf be load_pointer_at_offset(needle, 0)
    
    Let i be 0
    Let limit be subtract_integers(haystack_len, needle_len)
    
    While i <= limit:
        Let haystack_ptr be add_pointer_offset(haystack_buf, i)
        If compare_memory(haystack_ptr, needle_buf, needle_len):
            Return i
        End If
        Let i be add_integers(i, 1)
    End While
    
    Return -1
End Process

Process called "starts_with_compiler" that takes str as Pointer, prefix as Pointer returns Boolean:
    Let str_len be load_integer_at_offset(str, 8)
    Let prefix_len be load_integer_at_offset(prefix, 8)
    
    If prefix_len > str_len:
        Return false
    End If
    
    Let str_buf be load_pointer_at_offset(str, 0)
    Let prefix_buf be load_pointer_at_offset(prefix, 0)
    
    Return compare_memory(str_buf, prefix_buf, prefix_len)
End Process

Note: =====================================================================
Note: STRING MANIPULATION
Note: =====================================================================

Process called "append_string_compiler" that takes dest as Pointer, source as Pointer:
    Let dest_len be load_integer_at_offset(dest, 8)
    Let dest_capacity be load_integer_at_offset(dest, 16)
    Let source_len be load_integer_at_offset(source, 8)
    
    Let new_len be add_integers(dest_len, source_len)
    
    If new_len >= dest_capacity:
        Let new_capacity be multiply_by_two(add_integers(new_len, 1))
        resize_string_buffer(dest, new_capacity)
    End If
    
    Let dest_buf be load_pointer_at_offset(dest, 0)
    Let source_buf be load_pointer_at_offset(source, 0)
    Let dest_ptr be add_pointer_offset(dest_buf, dest_len)
    
    copy_memory(source_buf, dest_ptr, source_len)
    store_byte_at_offset(dest_buf, new_len, 0)
    store_integer_at_offset(dest, 8, new_len)
End Process

Process called "substring_compiler" that takes source as Pointer, start as Integer, length as Integer returns Pointer:
    Let source_len be load_integer_at_offset(source, 8)
    
    If start >= source_len:
        Return create_compiler_string(1)
    End If
    
    Let actual_length be length
    If add_integers(start, length) > source_len:
        Let actual_length be subtract_integers(source_len, start)
    End If
    
    Let result be create_compiler_string(add_integers(actual_length, 1))
    Let source_buf be load_pointer_at_offset(source, 0)
    Let result_buf be load_pointer_at_offset(result, 0)
    Let source_ptr be add_pointer_offset(source_buf, start)
    
    copy_memory(source_ptr, result_buf, actual_length)
    store_byte_at_offset(result_buf, actual_length, 0)
    store_integer_at_offset(result, 8, actual_length)
    
    Return result
End Process

Process called "trim_whitespace_compiler" that takes str as Pointer returns Pointer:
    Let str_len be load_integer_at_offset(str, 8)
    Let str_buf be load_pointer_at_offset(str, 0)
    
    Let start be 0
    While start < str_len:
        Let char be load_byte_at_offset(str_buf, start)
        If not is_whitespace_char(char):
            Break
        End If
        Let start be add_integers(start, 1)
    End While
    
    Let end be subtract_integers(str_len, 1)
    While end >= start:
        Let char be load_byte_at_offset(str_buf, end)
        If not is_whitespace_char(char):
            Break
        End If
        Let end be subtract_integers(end, 1)
    End While
    
    Let trimmed_length be add_integers(subtract_integers(end, start), 1)
    Return substring_compiler(str, start, trimmed_length)
End Process

Note: =====================================================================
Note: IDENTIFIER AND KEYWORD VALIDATION
Note: =====================================================================

Process called "is_valid_identifier" that takes str as Pointer returns Boolean:
    Let str_len be load_integer_at_offset(str, 8)
    Let str_buf be load_pointer_at_offset(str, 0)
    
    If str_len is 0:
        Return false
    End If
    
    Let first_char be load_byte_at_offset(str_buf, 0)
    If not is_identifier_start_char(first_char):
        Return false
    End If
    
    Let i be 1
    While i < str_len:
        Let char be load_byte_at_offset(str_buf, i)
        If not is_identifier_continue_char(char):
            Return false
        End If
        Let i be add_integers(i, 1)
    End While
    
    Return true
End Process

Process called "is_keyword" that takes str as Pointer returns Boolean:
    Note: Check against compiler's keyword table
    Let keyword_count be get_keyword_table_size()
    Let i be 0
    
    While i < keyword_count:
        Let keyword be get_keyword_at_index(i)
        If strings_equal_compiler(str, keyword):
            Return true
        End If
        Let i be add_integers(i, 1)
    End While
    
    Return false
End Process

Process called "mangle_identifier" that takes prefix as Pointer, name as Pointer returns Pointer:
    Let result be create_compiler_string(128)
    append_string_compiler(result, prefix)
    append_char_compiler(result, 95)
    append_string_compiler(result, name)
    Return result
End Process

Note: =====================================================================
Note: PATH AND FILE NAME UTILITIES
Note: =====================================================================

Process called "extract_file_name" that takes path as Pointer returns Pointer:
    Let path_len be load_integer_at_offset(path, 8)
    Let path_buf be load_pointer_at_offset(path, 0)
    
    Let last_separator be -1
    Let i be 0
    
    While i < path_len:
        Let char be load_byte_at_offset(path_buf, i)
        If char is 47:
            Let last_separator be i
        End If
        Let i be add_integers(i, 1)
    End While
    
    Let start be add_integers(last_separator, 1)
    Let length be subtract_integers(path_len, start)
    Return substring_compiler(path, start, length)
End Process

Process called "extract_file_extension" that takes path as Pointer returns Pointer:
    Let path_len be load_integer_at_offset(path, 8)
    Let path_buf be load_pointer_at_offset(path, 0)
    
    Let last_dot be -1
    Let i be subtract_integers(path_len, 1)
    
    While i >= 0:
        Let char be load_byte_at_offset(path_buf, i)
        If char is 46:
            Let last_dot be i
            Break
        End If
        If char is 47:
            Break
        End If
        Let i be subtract_integers(i, 1)
    End While
    
    If last_dot is -1:
        Return create_compiler_string(1)
    End If
    
    Let start be add_integers(last_dot, 1)
    Let length be subtract_integers(path_len, start)
    Return substring_compiler(path, start, length)
End Process

Note: =====================================================================
Note: STRING BUILDER FOR CODE GENERATION
Note: =====================================================================

Process called "create_string_builder" that takes initial_capacity as Integer returns Pointer:
    Let builder be allocate_memory(32)
    Let buffer be allocate_memory(initial_capacity)
    
    store_pointer_at_offset(builder, 0, buffer)
    store_integer_at_offset(builder, 8, 0)
    store_integer_at_offset(builder, 16, initial_capacity)
    store_integer_at_offset(builder, 24, 0)
    
    Return builder
End Process

Process called "append_to_builder" that takes builder as Pointer, str as Pointer:
    Let current_len be load_integer_at_offset(builder, 8)
    Let capacity be load_integer_at_offset(builder, 16)
    Let str_len be load_integer_at_offset(str, 8)
    
    Let new_len be add_integers(current_len, str_len)
    
    If new_len >= capacity:
        Let new_capacity be multiply_by_two(add_integers(new_len, 1))
        resize_builder_buffer(builder, new_capacity)
    End If
    
    Let buffer be load_pointer_at_offset(builder, 0)
    Let str_buf be load_pointer_at_offset(str, 0)
    Let dest_ptr be add_pointer_offset(buffer, current_len)
    
    copy_memory(str_buf, dest_ptr, str_len)
    store_integer_at_offset(builder, 8, new_len)
End Process

Process called "builder_to_string" that takes builder as Pointer returns Pointer:
    Let length be load_integer_at_offset(builder, 8)
    Let buffer be load_pointer_at_offset(builder, 0)
    
    Let result be create_compiler_string(add_integers(length, 1))
    Let result_buf be load_pointer_at_offset(result, 0)
    
    copy_memory(buffer, result_buf, length)
    store_byte_at_offset(result_buf, length, 0)
    store_integer_at_offset(result, 8, length)
    
    Return result
End Process

Note: =====================================================================
Note: CHARACTER UTILITIES
Note: =====================================================================

Process called "is_whitespace_char" that takes char as Integer returns Boolean:
    If char is 32:
        Return true
    End If
    If char is 9:
        Return true
    End If
    If char is 10:
        Return true
    End If
    If char is 13:
        Return true
    End If
    Return false
End Process

Process called "is_identifier_start_char" that takes char as Integer returns Boolean:
    If char >= 65:
        If char <= 90:
            Return true
        End If
    End If
    If char >= 97:
        If char <= 122:
            Return true
        End If
    End If
    If char is 95:
        Return true
    End If
    Return false
End Process

Process called "is_identifier_continue_char" that takes char as Integer returns Boolean:
    If is_identifier_start_char(char):
        Return true
    End If
    If char >= 48:
        If char <= 57:
            Return true
        End If
    End If
    Return false
End Process

Process called "append_char_compiler" that takes str as Pointer, char as Integer:
    Let str_len be load_integer_at_offset(str, 8)
    Let str_capacity be load_integer_at_offset(str, 16)
    
    Let new_len be add_integers(str_len, 1)
    
    If new_len >= str_capacity:
        Let new_capacity be multiply_by_two(add_integers(new_len, 1))
        resize_string_buffer(str, new_capacity)
    End If
    
    Let str_buf be load_pointer_at_offset(str, 0)
    store_byte_at_offset(str_buf, str_len, char)
    store_byte_at_offset(str_buf, new_len, 0)
    store_integer_at_offset(str, 8, new_len)
End Process

Note: Helper functions using assembly

Process called "allocate_memory" that takes size as Integer returns Pointer:
    Let result as Pointer
    Inline Assembly:
        "mov rdi, %1\n"           Note: Size to allocate
        "call compiler_malloc\n"   Note: Call allocation
        "mov %0, rax\n"           Note: Store result
        : "=r"(result)
        : "r"(size)
        : "rax", "rdi", "memory"
    End Assembly
    Return result
End Process

Process called "copy_memory" that takes source as Pointer, dest as Pointer, size as Integer:
    Inline Assembly:
        "mov rsi, %0\n"    Note: Source address
        "mov rdi, %1\n"    Note: Destination address
        "mov rcx, %2\n"    Note: Number of bytes
        "rep movsb\n"      Note: Fast memory copy
        :
        : "r"(source), "r"(dest), "r"(size)
        : "rsi", "rdi", "rcx", "memory"
    End Assembly
End Process

Process called "compare_memory" that takes ptr1 as Pointer, ptr2 as Pointer, size as Integer returns Boolean:
    Let result as Boolean
    Inline Assembly:
        "mov rsi, %1\n"    Note: First pointer
        "mov rdi, %2\n"    Note: Second pointer
        "mov rcx, %3\n"    Note: Number of bytes
        "repe cmpsb\n"     Note: Compare bytes
        "sete al\n"        Note: Set if equal
        "movzx eax, al\n"  Note: Zero extend
        "mov %0, rax\n"    Note: Store result
        : "=r"(result)
        : "r"(ptr1), "r"(ptr2), "r"(size)
        : "rax", "rsi", "rdi", "rcx", "flags", "memory"
    End Assembly
    Return result
End Process

Process called "store_pointer_at_offset" that takes base as Pointer, offset as Integer, value as Pointer:
    Inline Assembly:
        "mov rax, %0\n"        Note: Base address
        "add rax, %1\n"        Note: Add offset
        "mov [rax], %2\n"      Note: Store pointer value
        :
        : "r"(base), "r"(offset), "r"(value)
        : "rax", "memory"
    End Assembly
End Process

Process called "store_integer_at_offset" that takes base as Pointer, offset as Integer, value as Integer:
    Inline Assembly:
        "mov rax, %0\n"        Note: Base address
        "add rax, %1\n"        Note: Add offset
        "mov [rax], %2\n"      Note: Store integer value
        :
        : "r"(base), "r"(offset), "r"(value)
        : "rax", "memory"
    End Assembly
End Process

Process called "store_byte_at_offset" that takes base as Pointer, offset as Integer, value as Integer:
    Inline Assembly:
        "mov rax, %0\n"                Note: Base address
        "add rax, %1\n"                Note: Add offset
        "mov byte ptr [rax], %2b\n"    Note: Store byte value
        :
        : "r"(base), "r"(offset), "r"(value)
        : "rax", "memory"
    End Assembly
End Process

Process called "load_pointer_at_offset" that takes base as Pointer, offset as Integer returns Pointer:
    Let result as Pointer
    Inline Assembly:
        "mov rax, %1\n"        Note: Base address
        "add rax, %2\n"        Note: Add offset
        "mov rax, [rax]\n"     Note: Load pointer value
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        : "r"(base), "r"(offset)
        : "rax", "memory"
    End Assembly
    Return result
End Process

Process called "load_integer_at_offset" that takes base as Pointer, offset as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"        Note: Base address
        "add rax, %2\n"        Note: Add offset
        "mov rax, [rax]\n"     Note: Load integer value
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        : "r"(base), "r"(offset)
        : "rax", "memory"
    End Assembly
    Return result
End Process

Process called "load_byte_at_offset" that takes base as Pointer, offset as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"                Note: Base address
        "add rax, %2\n"                Note: Add offset
        "movzx rax, byte ptr [rax]\n"  Note: Load byte with zero extend
        "mov %0, rax\n"                Note: Store result
        : "=r"(result)
        : "r"(base), "r"(offset)
        : "rax", "memory"
    End Assembly
    Return result
End Process

Process called "add_pointer_offset" that takes ptr as Pointer, offset as Integer returns Pointer:
    Let result as Pointer
    Inline Assembly:
        "mov rax, %1\n"        Note: Pointer value
        "add rax, %2\n"        Note: Add offset
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        : "r"(ptr), "r"(offset)
        : "rax"
    End Assembly
    Return result
End Process

Process called "add_integers" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"        Note: First operand
        "add rax, %2\n"        Note: Add second operand
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "subtract_integers" that takes a as Integer, b as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"        Note: First operand
        "sub rax, %2\n"        Note: Subtract second operand
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        : "r"(a), "r"(b)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "multiply_by_two" that takes value as Integer returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, %1\n"        Note: Value to multiply
        "shl rax, 1\n"         Note: Shift left by 1 (multiply by 2)
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        : "r"(value)
        : "rax", "flags"
    End Assembly
    Return result
End Process

Process called "resize_string_buffer" that takes str as Pointer, new_capacity as Integer:
    Let old_buffer be load_pointer_at_offset(str, 0)
    Let length be load_integer_at_offset(str, 8)
    Let new_buffer be allocate_memory(new_capacity)
    
    copy_memory(old_buffer, new_buffer, add_integers(length, 1))
    store_pointer_at_offset(str, 0, new_buffer)
    store_integer_at_offset(str, 16, new_capacity)
End Process

Process called "resize_builder_buffer" that takes builder as Pointer, new_capacity as Integer:
    Let old_buffer be load_pointer_at_offset(builder, 0)
    Let length be load_integer_at_offset(builder, 8)
    Let new_buffer be allocate_memory(new_capacity)
    
    copy_memory(old_buffer, new_buffer, length)
    store_pointer_at_offset(builder, 0, new_buffer)
    store_integer_at_offset(builder, 16, new_capacity)
End Process

Process called "get_keyword_table_size" returns Integer:
    Let result as Integer
    Inline Assembly:
        "mov rax, 50\n"        Note: Return constant size
        "mov %0, rax\n"        Note: Store result
        : "=r"(result)
        :
        : "rax"
    End Assembly
    Return result
End Process

Process called "get_keyword_at_index" that takes index as Integer returns Pointer:
    Let result as Pointer
    Inline Assembly:
        "mov rax, keyword_table\n"     Note: Load table address
        "mov rcx, %1\n"                Note: Load index
        "imul rcx, 8\n"                Note: Multiply by pointer size
        "add rax, rcx\n"               Note: Calculate offset
        "mov rax, [rax]\n"             Note: Load pointer
        "mov %0, rax\n"                Note: Store result
        : "=r"(result)
        : "r"(index)
        : "rax", "rcx", "memory"
    End Assembly
    Return result
End Process