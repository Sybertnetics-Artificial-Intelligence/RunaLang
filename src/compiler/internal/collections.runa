Note:
compiler/internal/collections.runa
Internal Collection Types for Compiler Bootstrap

These are minimal collection implementations used internally by the compiler.
They use primitives underneath but provide a clean interface.
Once the compiler is self-hosted, user code will use the stdlib collections.

IMPORTANT: These are NOT the user-facing stdlib collections.
These exist only to bootstrap the compiler without circular dependencies.
:End Note

Import "compiler/frontend/primitives/types/compiler_internals" as Internals
Import "compiler/internal/string_utils" as StringUtils

Note: =====================================================================
Note: LIST IMPLEMENTATION
Note: =====================================================================

@Reasoning
    The compiler needs lists for tokens, AST nodes, etc.
    We implement a simple dynamic array backed by primitive mapping.
    Keys are indices (0, 1, 2...), values are the list elements.
@End Reasoning

Type called "List":
    internal_array as Internals.InternalArray
    size as Integer
End Type

Process called "create_list" returns List:
    Let arr be Internals.create_internal_array(16)
    
    Return List with
        internal_array as arr,
        size as 0
    End List
End Process

Process called "list_append" that takes list as List, item as Any returns Nothing:
    Note: Add item to end of list
    Internals.internal_array_add(list.internal_array, item)
    Set list.size to list.size plus 1
End Process

Process called "list_get" that takes list as List, index as Integer returns Any:
    Note: Get item at index with bounds checking
    If index is less than 0 Or index is greater than or equal to list.size:
        Throw "List index out of bounds"
    End If
    
    Return Internals.internal_array_get(list.internal_array, index)
End Process

Process called "list_set" that takes list as List, index as Integer, value as Any returns Nothing:
    Note: Set item at index with bounds checking
    If index is less than 0 Or index is greater than or equal to list.size:
        Throw "List index out of bounds"
    End If
    
    Internals.internal_array_set(list.internal_array, index, value)
End Process

Process called "list_length" that takes list as List returns Integer:
    Return list.size
End Process

Process called "list_contains" that takes list as List, item as Any returns Boolean:
    For i from 0 to list.size minus 1:
        If list_get(list, i) is equal to item:
            Return True
        End If
    End For
    Return False
End Process

Process called "list_clear" that takes list as List returns Nothing:
    Set list.size to 0
    Set list.internal_array to Internals.create_internal_array(16)
End Process

Note: =====================================================================
Note: DICTIONARY IMPLEMENTATION
Note: =====================================================================

@Reasoning
    The compiler needs dictionaries for symbol tables, keyword lookups, etc.
    We wrap the primitive mapping type with a cleaner interface.
@End Reasoning

Type called "Dictionary":
    internal_map as Internals.InternalMap
    size as Integer
End Type

Process called "create_dictionary" returns Dictionary:
    Return Dictionary with
        internal_map as Internals.create_internal_map(16),
        size as 0
    End Dictionary
End Process

Process called "dict_set" that takes dict as Dictionary, key as String, value as Any returns Nothing:
    Note: Check if this is a new key
    If Not dict_has_key(dict, key):
        Set dict.size to dict.size plus 1
    End If
    
    Internals.internal_map_insert(dict.internal_map, key, value)
End Process

Process called "dict_get" that takes dict as Dictionary, key as String returns Any:
    If Not dict_has_key(dict, key):
        Throw StringUtils.concat_strings("Dictionary key not found: ", key)
    End If
    
    Return Internals.internal_map_get(dict.internal_map, key)
End Process

Process called "dict_has_key" that takes dict as Dictionary, key as String returns Boolean:
    Note: Try to get the value - if it returns null, key doesn't exist
    Return Internals.internal_map_contains(dict.internal_map, key)
End Process

Process called "dict_remove" that takes dict as Dictionary, key as String returns Nothing:
    If dict_has_key(dict, key):
        Internals.internal_map_remove(dict.internal_map, key)
        Set dict.size to dict.size minus 1
    End If
End Process

Process called "dict_keys" that takes dict as Dictionary returns List:
    Note: Get all keys as a list
    Let keys be create_list()
    Let all_keys be Internals.internal_map_keys(dict.internal_map)
    
    For i from 0 to Internals.internal_array_length(all_keys) minus 1:
        Let key be Internals.internal_array_get(all_keys, i)
        list_append(keys, key)
    End For
    
    Return keys
End Process

Process called "dict_values" that takes dict as Dictionary returns List:
    Note: Get all values as a list
    Let values be create_list()
    Let keys be dict_keys(dict)
    
    For i from 0 to list_length(keys) minus 1:
        Let key be list_get(keys, i)
        Let value be dict_get(dict, key)
        list_append(values, value)
    End For
    
    Return values
End Process

Process called "dict_size" that takes dict as Dictionary returns Integer:
    Return dict.size
End Process

Process called "dict_clear" that takes dict as Dictionary returns Nothing:
    Set dict.internal_map to Internals.create_internal_map(16)
    Set dict.size to 0
End Process

Note: =====================================================================
Note: SET IMPLEMENTATION
Note: =====================================================================

@Reasoning
    Sets are useful for keyword tables and unique collections.
    Implemented as a dictionary where we only care about keys.
@End Reasoning

Type called "Set":
    internal_dict as Dictionary
End Type

Process called "create_set" returns Set:
    Return Set with
        internal_dict as create_dictionary()
    End Set
End Process

Process called "set_add" that takes set as Set, item as String returns Nothing:
    dict_set(set.internal_dict, item, True)
End Process

Process called "set_contains" that takes set as Set, item as String returns Boolean:
    Return dict_has_key(set.internal_dict, item)
End Process

Process called "set_remove" that takes set as Set, item as String returns Nothing:
    dict_remove(set.internal_dict, item)
End Process

Process called "set_size" that takes set as Set returns Integer:
    Return dict_size(set.internal_dict)
End Process

Process called "set_to_list" that takes set as Set returns List:
    Return dict_keys(set.internal_dict)
End Process

Process called "set_clear" that takes set as Set returns Nothing:
    dict_clear(set.internal_dict)
End Process

Note: =====================================================================
Note: STACK IMPLEMENTATION
Note: =====================================================================

@Reasoning
    Stacks are essential for parsing and expression evaluation.
    Implemented as a list with push/pop operations.
@End Reasoning

Type called "Stack":
    internal_list as List
End Type

Process called "create_stack" returns Stack:
    Return Stack with
        internal_list as create_list()
    End Stack
End Process

Process called "stack_push" that takes stack as Stack, item as Any returns Nothing:
    list_append(stack.internal_list, item)
End Process

Process called "stack_pop" that takes stack as Stack returns Any:
    Let size be list_length(stack.internal_list)
    
    If size is equal to 0:
        Throw "Cannot pop from empty stack"
    End If
    
    Let item be list_get(stack.internal_list, size minus 1)
    Set stack.internal_list.size to size minus 1
    Return item
End Process

Process called "stack_peek" that takes stack as Stack returns Any:
    Let size be list_length(stack.internal_list)
    
    If size is equal to 0:
        Throw "Cannot peek empty stack"
    End If
    
    Return list_get(stack.internal_list, size minus 1)
End Process

Process called "stack_is_empty" that takes stack as Stack returns Boolean:
    Return list_length(stack.internal_list) is equal to 0
End Process

Process called "stack_size" that takes stack as Stack returns Integer:
    Return list_length(stack.internal_list)
End Process

Note: =====================================================================
Note: UTILITY FUNCTIONS
Note: =====================================================================

@Reasoning
    Helper functions for working with collections in the compiler.
@End Reasoning

Process called "list_from_array" that takes items as Array[Any] returns List:
    Let list be create_list()
    
    For Each item in items:
        list_append(list, item)
    End For
    
    Return list
End Process

Process called "list_map" that takes list as List, transform as Process returns List:
    Let result be create_list()
    
    For i from 0 to list_length(list) minus 1:
        Let item be list_get(list, i)
        Let transformed be transform(item)
        list_append(result, transformed)
    End For
    
    Return result
End Process

Process called "list_filter" that takes list as List, predicate as Process returns List:
    Let result be create_list()
    
    For i from 0 to list_length(list) minus 1:
        Let item be list_get(list, i)
        If predicate(item):
            list_append(result, item)
        End If
    End For
    
    Return result
End Process

Process called "list_find" that takes list as List, predicate as Process returns Any:
    For i from 0 to list_length(list) minus 1:
        Let item be list_get(list, i)
        If predicate(item):
            Return item
        End If
    End For
    
    Return null
End Process