Note: Sandbox manager for controlling syscall execution environments
Note: Provides process isolation and resource limitation capabilities

Import "compiler.frontend.primitives.types.compiler_internals" as Internals
Import "compiler.backend.syscalls.security.permission_checker" as Permissions

Note: Sandbox execution modes
Type SandboxMode is:
    | Strict       Note: Minimal syscalls allowed
    | Development  Note: More permissive for development
    | Testing      Note: Controlled environment for tests
    | Production   Note: Balanced security and functionality
End Type

Note: Resource limits for sandbox
Type called "ResourceLimits":
    max_memory_bytes as Integer
    max_file_descriptors as Integer
    max_processes as Integer
    max_network_connections as Integer
    max_execution_time_ms as Integer
    max_file_size_bytes as Integer
End Type

Note: Sandbox configuration
Type called "SandboxConfig":
    mode as SandboxMode
    permission_level as Permissions.PermissionLevel
    resource_limits as ResourceLimits
    allowed_paths as Internals.InternalArray      Note: String pointers to allowed paths
    allowed_syscalls as Internals.InternalArray   Note: Integer syscall numbers
    blocked_syscalls as Internals.InternalArray   Note: Integer blocked syscall numbers
    temp_directory as String
    enable_seccomp as Boolean
    enable_namespaces as Boolean
End Type

Note: Sandbox execution context
Type called "SandboxContext":
    config as SandboxConfig
    validation_context as Permissions.ValidationContext
    permission_system as Internals.InternalMap
    active_fds as Internals.InternalArray         Note: Currently open file descriptors
    process_count as Integer
    memory_used as Integer
    start_time_ms as Integer
End Type

Note: Create default sandbox configuration for mode
Process called "create_sandbox_config" that takes mode as SandboxMode returns SandboxConfig:
    Let config as SandboxConfig
    config.mode = mode
    config.allowed_paths = Internals.create_internal_array(32)
    config.allowed_syscalls = Internals.create_internal_array(64)
    config.blocked_syscalls = Internals.create_internal_array(16)
    config.temp_directory = "/tmp/runa_sandbox"
    config.enable_seccomp = true
    config.enable_namespaces = true
    
    Note: Set permission level and limits based on mode
    Match mode:
        When Strict:
            config.permission_level = Permissions.ReadOnly
            config.resource_limits = create_strict_limits()
            configure_strict_syscalls(config)
        When Development:
            config.permission_level = Permissions.Sandboxed
            config.resource_limits = create_development_limits()
            configure_development_syscalls(config)
        When Testing:
            config.permission_level = Permissions.Sandboxed
            config.resource_limits = create_testing_limits()
            configure_testing_syscalls(config)
        When Production:
            config.permission_level = Permissions.Sandboxed
            config.resource_limits = create_production_limits()
            configure_production_syscalls(config)
    End Match
    
    Note: Add common safe paths
    add_safe_paths(config)
    
    Return config
End Process

Note: Create strict resource limits
Process called "create_strict_limits" returns ResourceLimits:
    Let limits as ResourceLimits
    limits.max_memory_bytes = 16777216        Note: 16MB
    limits.max_file_descriptors = 8
    limits.max_processes = 1
    limits.max_network_connections = 0
    limits.max_execution_time_ms = 5000       Note: 5 seconds
    limits.max_file_size_bytes = 1048576      Note: 1MB
    Return limits
End Process

Note: Create development resource limits
Process called "create_development_limits" returns ResourceLimits:
    Let limits as ResourceLimits
    limits.max_memory_bytes = 134217728       Note: 128MB
    limits.max_file_descriptors = 64
    limits.max_processes = 4
    limits.max_network_connections = 8
    limits.max_execution_time_ms = 30000      Note: 30 seconds
    limits.max_file_size_bytes = 16777216     Note: 16MB
    Return limits
End Process

Note: Create testing resource limits
Process called "create_testing_limits" returns ResourceLimits:
    Let limits as ResourceLimits
    limits.max_memory_bytes = 67108864        Note: 64MB
    limits.max_file_descriptors = 32
    limits.max_processes = 2
    limits.max_network_connections = 4
    limits.max_execution_time_ms = 15000      Note: 15 seconds
    limits.max_file_size_bytes = 8388608      Note: 8MB
    Return limits
End Process

Note: Create production resource limits
Process called "create_production_limits" returns ResourceLimits:
    Let limits as ResourceLimits
    limits.max_memory_bytes = 268435456       Note: 256MB
    limits.max_file_descriptors = 128
    limits.max_processes = 8
    limits.max_network_connections = 16
    limits.max_execution_time_ms = 60000      Note: 60 seconds
    limits.max_file_size_bytes = 33554432     Note: 32MB
    Return limits
End Process

Note: Configure syscalls for strict mode
Process called "configure_strict_syscalls" that takes config as SandboxConfig:
    Note: Allow only essential syscalls
    Internals.internal_array_add(config.allowed_syscalls, 0)   Note: read
    Internals.internal_array_add(config.allowed_syscalls, 1)   Note: write
    Internals.internal_array_add(config.allowed_syscalls, 3)   Note: close
    Internals.internal_array_add(config.allowed_syscalls, 9)   Note: mmap
    Internals.internal_array_add(config.allowed_syscalls, 11)  Note: munmap
    Internals.internal_array_add(config.allowed_syscalls, 12)  Note: brk
    Internals.internal_array_add(config.allowed_syscalls, 60)  Note: exit
    Internals.internal_array_add(config.allowed_syscalls, 39)  Note: getpid
    
    Note: Block dangerous syscalls
    Internals.internal_array_add(config.blocked_syscalls, 57)  Note: fork
    Internals.internal_array_add(config.blocked_syscalls, 59)  Note: execve
    Internals.internal_array_add(config.blocked_syscalls, 41)  Note: socket
    Internals.internal_array_add(config.blocked_syscalls, 2)   Note: open (use openat with validation)
End Process

Note: Configure syscalls for development mode
Process called "configure_development_syscalls" that takes config as SandboxConfig:
    Note: Allow more syscalls for development workflow
    Internals.internal_array_add(config.allowed_syscalls, 0)   Note: read
    Internals.internal_array_add(config.allowed_syscalls, 1)   Note: write
    Internals.internal_array_add(config.allowed_syscalls, 2)   Note: open
    Internals.internal_array_add(config.allowed_syscalls, 3)   Note: close
    Internals.internal_array_add(config.allowed_syscalls, 4)   Note: stat
    Internals.internal_array_add(config.allowed_syscalls, 5)   Note: fstat
    Internals.internal_array_add(config.allowed_syscalls, 8)   Note: lseek
    Internals.internal_array_add(config.allowed_syscalls, 9)   Note: mmap
    Internals.internal_array_add(config.allowed_syscalls, 11)  Note: munmap
    Internals.internal_array_add(config.allowed_syscalls, 12)  Note: brk
    Internals.internal_array_add(config.allowed_syscalls, 60)  Note: exit
    Internals.internal_array_add(config.allowed_syscalls, 39)  Note: getpid
    Internals.internal_array_add(config.allowed_syscalls, 102) Note: getuid
    Internals.internal_array_add(config.allowed_syscalls, 104) Note: getgid
    
    Note: Allow limited networking for development
    Internals.internal_array_add(config.allowed_syscalls, 41)  Note: socket
    Internals.internal_array_add(config.allowed_syscalls, 42)  Note: connect
    
    Note: Block dangerous operations
    Internals.internal_array_add(config.blocked_syscalls, 57)  Note: fork
    Internals.internal_array_add(config.blocked_syscalls, 59)  Note: execve
End Process

Note: Configure syscalls for testing mode
Process called "configure_testing_syscalls" that takes config as SandboxConfig:
    Note: Allow syscalls needed for testing but controlled
    Internals.internal_array_add(config.allowed_syscalls, 0)   Note: read
    Internals.internal_array_add(config.allowed_syscalls, 1)   Note: write
    Internals.internal_array_add(config.allowed_syscalls, 2)   Note: open
    Internals.internal_array_add(config.allowed_syscalls, 3)   Note: close
    Internals.internal_array_add(config.allowed_syscalls, 4)   Note: stat
    Internals.internal_array_add(config.allowed_syscalls, 5)   Note: fstat
    Internals.internal_array_add(config.allowed_syscalls, 8)   Note: lseek
    Internals.internal_array_add(config.allowed_syscalls, 9)   Note: mmap
    Internals.internal_array_add(config.allowed_syscalls, 11)  Note: munmap
    Internals.internal_array_add(config.allowed_syscalls, 12)  Note: brk
    Internals.internal_array_add(config.allowed_syscalls, 60)  Note: exit
    Internals.internal_array_add(config.allowed_syscalls, 39)  Note: getpid
    
    Note: Block networking and process creation
    Internals.internal_array_add(config.blocked_syscalls, 57)  Note: fork
    Internals.internal_array_add(config.blocked_syscalls, 59)  Note: execve
    Internals.internal_array_add(config.blocked_syscalls, 41)  Note: socket
    Internals.internal_array_add(config.blocked_syscalls, 42)  Note: connect
End Process

Note: Configure syscalls for production mode
Process called "configure_production_syscalls" that takes config as SandboxConfig:
    Note: Balanced syscall access for production use
    Internals.internal_array_add(config.allowed_syscalls, 0)   Note: read
    Internals.internal_array_add(config.allowed_syscalls, 1)   Note: write
    Internals.internal_array_add(config.allowed_syscalls, 2)   Note: open
    Internals.internal_array_add(config.allowed_syscalls, 3)   Note: close
    Internals.internal_array_add(config.allowed_syscalls, 4)   Note: stat
    Internals.internal_array_add(config.allowed_syscalls, 5)   Note: fstat
    Internals.internal_array_add(config.allowed_syscalls, 8)   Note: lseek
    Internals.internal_array_add(config.allowed_syscalls, 9)   Note: mmap
    Internals.internal_array_add(config.allowed_syscalls, 11)  Note: munmap
    Internals.internal_array_add(config.allowed_syscalls, 12)  Note: brk
    Internals.internal_array_add(config.allowed_syscalls, 60)  Note: exit
    Internals.internal_array_add(config.allowed_syscalls, 39)  Note: getpid
    Internals.internal_array_add(config.allowed_syscalls, 41)  Note: socket
    Internals.internal_array_add(config.allowed_syscalls, 42)  Note: connect
    Internals.internal_array_add(config.allowed_syscalls, 44)  Note: sendto
    Internals.internal_array_add(config.allowed_syscalls, 45)  Note: recvfrom
    
    Note: Block dangerous operations
    Internals.internal_array_add(config.blocked_syscalls, 57)  Note: fork
    Internals.internal_array_add(config.blocked_syscalls, 59)  Note: execve
    Internals.internal_array_add(config.blocked_syscalls, 165) Note: mount
    Internals.internal_array_add(config.blocked_syscalls, 166) Note: umount
End Process

Note: Add common safe paths to sandbox configuration
Process called "add_safe_paths" that takes config as SandboxConfig:
    Note: Add standard safe directories
    add_allowed_path(config, "/usr/lib")
    add_allowed_path(config, "/usr/share")
    add_allowed_path(config, "/lib")
    add_allowed_path(config, "/lib64")
    add_allowed_path(config, "/etc/ld.so.cache")
    add_allowed_path(config, "/proc/self/exe")
    add_allowed_path(config, "/dev/null")
    add_allowed_path(config, "/dev/zero")
    add_allowed_path(config, "/dev/urandom")
    add_allowed_path(config, config.temp_directory)
End Process

Note: Add allowed path to sandbox configuration
Process called "add_allowed_path" that takes config as SandboxConfig, path as String:
    Let path_ptr be Internals.string_to_ptr(path)
    Internals.internal_array_add(config.allowed_paths, path_ptr)
End Process

Note: Initialize sandbox context from configuration
Process called "initialize_sandbox" that takes config as SandboxConfig returns SandboxContext:
    Let context as SandboxContext
    context.config = config
    context.validation_context = Permissions.create_validation_context(config.permission_level)
    context.permission_system = Permissions.initialize_permission_system()
    context.active_fds = Internals.create_internal_array(config.resource_limits.max_file_descriptors)
    context.process_count = 1
    context.memory_used = 0
    context.start_time_ms = get_current_time_ms()
    
    Note: Configure validation context with allowed paths
    configure_validation_paths(context)
    
    Note: Setup resource monitoring
    setup_resource_monitoring(context)
    
    Return context
End Process

Note: Configure validation context with allowed paths from config
Process called "configure_validation_paths" that takes context as SandboxContext:
    Let iter be Internals.internal_array_iterator(context.config.allowed_paths)
    While Internals.internal_array_has_next(iter):
        Let path_ptr be Internals.internal_array_next(iter)
        Let path_str be Internals.ptr_to_string(path_ptr)
        Permissions.add_allowed_path(context.validation_context, path_str)
    End While
End Process

Note: Setup resource monitoring for sandbox
Process called "setup_resource_monitoring" that takes context as SandboxContext:
    Note: Initialize memory tracking
    context.memory_used = get_current_memory_usage()
    
    Note: Setup file descriptor tracking
    Note: Standard fds (stdin, stdout, stderr) are pre-allowed
    Permissions.add_allowed_fd(context.validation_context, 0)  Note: stdin
    Permissions.add_allowed_fd(context.validation_context, 1)  Note: stdout
    Permissions.add_allowed_fd(context.validation_context, 2)  Note: stderr
    
    Internals.internal_array_add(context.active_fds, 0)
    Internals.internal_array_add(context.active_fds, 1)
    Internals.internal_array_add(context.active_fds, 2)
End Process

Note: Validate syscall execution in sandbox context
Process called "validate_sandbox_syscall" that takes context as SandboxContext, syscall_num as Integer, args as Internals.InternalArray returns Boolean:
    Note: Check basic permission validation
    If not Permissions.validate_syscall(context.permission_system, context.validation_context, syscall_num):
        Return false
    End If
    
    Note: Check if syscall is explicitly blocked
    If is_syscall_blocked(context.config, syscall_num):
        Return false
    End If
    
    Note: Check if syscall is explicitly allowed (if allowlist is used)
    If not is_syscall_allowed(context.config, syscall_num):
        Return false
    End If
    
    Note: Perform syscall-specific validation
    Return validate_syscall_arguments(context, syscall_num, args)
End Process

Note: Check if syscall is blocked in configuration
Process called "is_syscall_blocked" that takes config as SandboxConfig, syscall_num as Integer returns Boolean:
    Let iter be Internals.internal_array_iterator(config.blocked_syscalls)
    While Internals.internal_array_has_next(iter):
        Let blocked_syscall be Internals.internal_array_next(iter)
        If syscall_num equals blocked_syscall:
            Return true
        End If
    End While
    Return false
End Process

Note: Check if syscall is in allowed list
Process called "is_syscall_allowed" that takes config as SandboxConfig, syscall_num as Integer returns Boolean:
    Note: If no explicit allowlist, everything not blocked is allowed
    Let array_size be Internals.internal_array_size(config.allowed_syscalls)
    If array_size equals 0:
        Return true
    End If
    
    Let iter be Internals.internal_array_iterator(config.allowed_syscalls)
    While Internals.internal_array_has_next(iter):
        Let allowed_syscall be Internals.internal_array_next(iter)
        If syscall_num equals allowed_syscall:
            Return true
        End If
    End While
    Return false
End Process

Note: Validate syscall arguments based on syscall type
Process called "validate_syscall_arguments" that takes context as SandboxContext, syscall_num as Integer, args as Internals.InternalArray returns Boolean:
    Match syscall_num:
        When 2:  Note: open
            Return validate_open_args(context, args)
        When 9:  Note: mmap
            Return validate_mmap_args(context, args)
        When 41: Note: socket
            Return validate_socket_args(context, args)
        When 42: Note: connect
            Return validate_connect_args(context, args)
    End Match
    
    Note: Default validation for other syscalls
    Return validate_resource_limits(context, syscall_num)
End Process

Note: Validate open syscall arguments
Process called "validate_open_args" that takes context as SandboxContext, args as Internals.InternalArray returns Boolean:
    Note: Get path argument (first argument)
    Let path_ptr be Internals.internal_array_get(args, 0)
    Let path_str be Internals.ptr_to_string(path_ptr)
    
    Note: Validate path is allowed
    If not Permissions.validate_path(context.validation_context, path_str):
        Return false
    End If
    
    Note: Check file descriptor limit
    Let current_fds be Internals.internal_array_size(context.active_fds)
    If current_fds >= context.config.resource_limits.max_file_descriptors:
        Return false
    End If
    
    Return true
End Process

Note: Validate mmap syscall arguments  
Process called "validate_mmap_args" that takes context as SandboxContext, args as Internals.InternalArray returns Boolean:
    Note: Get size argument (second argument)
    Let size be Internals.internal_array_get(args, 1)
    
    Note: Check memory limit
    Let new_usage be context.memory_used + size
    If new_usage > context.config.resource_limits.max_memory_bytes:
        Return false
    End If
    
    Return true
End Process

Note: Validate socket syscall arguments
Process called "validate_socket_args" that takes context as SandboxContext, args as Internals.InternalArray returns Boolean:
    Note: Check network permission
    If not context.validation_context.network_allowed:
        Return false
    End If
    
    Note: Check connection limit
    Let current_connections be count_network_connections(context)
    If current_connections >= context.config.resource_limits.max_network_connections:
        Return false
    End If
    
    Return true
End Process

Note: Validate connect syscall arguments
Process called "validate_connect_args" that takes context as SandboxContext, args as Internals.InternalArray returns Boolean:
    Note: Check network permission
    If not context.validation_context.network_allowed:
        Return false
    End If
    
    Note: Validate file descriptor
    Let fd be Internals.internal_array_get(args, 0)
    Return Permissions.validate_fd(context.validation_context, fd)
End Process

Note: Validate resource limits for syscall execution
Process called "validate_resource_limits" that takes context as SandboxContext, syscall_num as Integer returns Boolean:
    Note: Check execution time limit
    Let current_time be get_current_time_ms()
    Let elapsed_time be current_time - context.start_time_ms
    If elapsed_time > context.config.resource_limits.max_execution_time_ms:
        Return false
    End If
    
    Note: Check process count for fork-like operations
    If syscall_num equals 57:  Note: fork
        If context.process_count >= context.config.resource_limits.max_processes:
            Return false
        End If
    End If
    
    Return true
End Process

Note: Count active network connections
Process called "count_network_connections" that takes context as SandboxContext returns Integer:
    Note: Count socket file descriptors
    Let connection_count be 0
    Let iter be Internals.internal_array_iterator(context.active_fds)
    
    While Internals.internal_array_has_next(iter):
        Let fd be Internals.internal_array_next(iter)
        If is_socket_fd(fd):
            connection_count = connection_count + 1
        End If
    End While
    
    Return connection_count
End Process

Note: Check if file descriptor is a socket
Process called "is_socket_fd" that takes fd as Integer returns Boolean:
    Note: Use fstat to check file type
    Let result as Integer
    Inline Assembly:
        "mov rax, 5\n"            Note: fstat syscall
        "mov rdi, %1\n"           Note: fd parameter
        "mov rsi, rsp\n"          Note: stat buffer on stack
        "sub rsi, 144\n"          Note: sizeof(struct stat)
        "syscall\n"
        "test rax, rax\n"         Note: Check if syscall succeeded
        "mov %0, rax\n"
        : "=r"(result)
        : "r"(fd)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    If result < 0:
        Return false
    End If
    
    Note: Check st_mode for socket type (S_IFSOCK = 0140000)
    Let mode as Integer
    Inline Assembly:
        "mov rax, [rsp - 144 + 24]\n"  Note: st_mode offset in struct stat
        "and rax, 0170000\n"           Note: S_IFMT mask
        "mov %0, rax\n"
        : "=r"(mode)
        :
        : "rax"
    End Assembly
    
    Return mode equals 49152  Note: S_IFSOCK = 0140000 = 49152
End Process

Note: Add file descriptor to sandbox tracking
Process called "track_fd" that takes context as SandboxContext, fd as Integer:
    Internals.internal_array_add(context.active_fds, fd)
    Permissions.add_allowed_fd(context.validation_context, fd)
End Process

Note: Remove file descriptor from sandbox tracking
Process called "untrack_fd" that takes context as SandboxContext, fd as Integer:
    Note: Remove from active fds array
    Let iter be Internals.internal_array_iterator(context.active_fds)
    Let index be 0
    
    While Internals.internal_array_has_next(iter):
        Let current_fd be Internals.internal_array_next(iter)
        If current_fd equals fd:
            Internals.internal_array_remove_at(context.active_fds, index)
            Return
        End If
        index = index + 1
    End While
End Process

Note: Update memory usage tracking
Process called "update_memory_usage" that takes context as SandboxContext, delta as Integer:
    context.memory_used = context.memory_used + delta
End Process

Note: Get current system time in milliseconds
Process called "get_current_time_ms" returns Integer:
    Let seconds as Integer
    Let nanoseconds as Integer
    
    Note: Use clock_gettime syscall (syscall 228)
    Inline Assembly:
        "mov rax, 228\n"          Note: clock_gettime syscall
        "mov rdi, 1\n"            Note: CLOCK_MONOTONIC
        "mov rsi, rsp\n"          Note: timespec buffer on stack
        "sub rsi, 16\n"           Note: sizeof(struct timespec)
        "syscall\n"
        "mov rax, [rsp - 16]\n"   Note: tv_sec
        "mov %0, rax\n"
        "mov rax, [rsp - 8]\n"    Note: tv_nsec
        "mov %1, rax\n"
        : "=r"(seconds), "=r"(nanoseconds)
        :
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Note: Convert to milliseconds
    Let milliseconds be seconds * 1000
    milliseconds = milliseconds + (nanoseconds / 1000000)
    Return milliseconds
End Process

Note: Get current memory usage
Process called "get_current_memory_usage" returns Integer:
    Note: Read from /proc/self/status
    Let fd as Integer
    
    Note: Open /proc/self/status
    Inline Assembly:
        "mov rax, 2\n"            Note: open syscall
        "mov rdi, rsp\n"          Note: filename on stack
        "sub rdi, 32\n"
        "mov qword ptr [rdi], 0x636f72702f\n"      Note: "/proc"
        "mov qword ptr [rdi + 5], 0x6c65732f\n"    Note: "/self"
        "mov qword ptr [rdi + 10], 0x7574732f\n"   Note: "/stat"
        "mov qword ptr [rdi + 15], 0x737475\n"     Note: "us"
        "mov byte ptr [rdi + 17], 0\n"             Note: null terminator
        "mov rsi, 0\n"            Note: O_RDONLY
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(fd)
        :
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    If fd < 0:
        Note: Fallback to basic estimation
        Return 4096  Note: One page
    End If
    
    Note: Read and parse VmRSS line - full implementation
    Let buffer be Internals.allocate_raw_memory(4096)
    Let bytes_read as Integer
    
    Inline Assembly:
        "mov rax, 0\n"            Note: read syscall
        "mov rdi, %1\n"           Note: fd
        "mov rsi, %2\n"           Note: buffer
        "mov rdx, 4096\n"         Note: buffer size
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(bytes_read)
        : "r"(fd), "r"(buffer)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
    
    Note: Close file
    Inline Assembly:
        "mov rax, 3\n"            Note: close syscall
        "mov rdi, %0\n"           Note: fd
        "syscall\n"
        :
        : "r"(fd)
        : "rax", "rdi", "rcx", "r11"
    End Assembly
    
    If bytes_read less_than_or_equal 0:
        Internals.free_raw_memory(buffer, 4096)
        Return 4096  Note: Default one page
    End If
    
    Note: Parse memory usage from /proc/self/status
    Note: Look for "VmRSS:" line
    Let i be 0
    Let found_vmrss be false
    Let rss_kb be 0
    
    While i less_than bytes_read minus 6:
        Note: Check for "VmRSS:" at current position
        If Internals.read_integer_at(buffer plus i, 1) equals 86:      Note: 'V'
            If Internals.read_integer_at(buffer plus i plus 1, 1) equals 109:  Note: 'm'
                If Internals.read_integer_at(buffer plus i plus 2, 1) equals 82:   Note: 'R'
                    If Internals.read_integer_at(buffer plus i plus 3, 1) equals 83:   Note: 'S'
                        If Internals.read_integer_at(buffer plus i plus 4, 1) equals 83:   Note: 'S'
                            If Internals.read_integer_at(buffer plus i plus 5, 1) equals 58:   Note: ':'
                                Set found_vmrss to true
                                Set i to i plus 6
                                
                                Note: Skip whitespace
                                While i less_than bytes_read:
                                    Let c be Internals.read_integer_at(buffer plus i, 1)
                                    If c not_equals 32 and c not_equals 9:  Note: Not space or tab
                                        Break
                                    End If
                                    Set i to i plus 1
                                End While
                                
                                Note: Parse numeric value
                                While i less_than bytes_read:
                                    Let c be Internals.read_integer_at(buffer plus i, 1)
                                    If c greater_than_or_equal 48 and c less_than_or_equal 57:  Note: '0' to '9'
                                        Set rss_kb to rss_kb multiplied_by 10
                                        Set rss_kb to rss_kb plus (c minus 48)
                                    Otherwise:
                                        Break
                                    End If
                                    Set i to i plus 1
                                End While
                                Break
                            End If
                        End If
                    End If
                End If
            End If
        End If
        Set i to i plus 1
    End While
    
    Internals.free_raw_memory(buffer, 4096)
    
    If found_vmrss and rss_kb greater_than 0:
        Return rss_kb multiplied_by 1024  Note: Convert KB to bytes
    End If
    
    Return 8192  Note: Two pages as fallback
End Process

Note: Cleanup sandbox resources
Process called "cleanup_sandbox" that takes context as SandboxContext:
    Note: Close all tracked file descriptors except standard ones
    Let iter be Internals.internal_array_iterator(context.active_fds)
    
    While Internals.internal_array_has_next(iter):
        Let fd be Internals.internal_array_next(iter)
        If fd > 2:  Note: Don't close stdin/stdout/stderr
            Inline Assembly:
                "mov rax, 3\n"        Note: close syscall
                "mov rdi, %0\n"       Note: fd
                "syscall\n"
                :
                : "r"(fd)
                : "rax", "rdi", "rcx", "r11"
            End Assembly
        End If
    End While
    
    Note: Free internal data structures
    Internals.free_internal_array(context.active_fds)
    Internals.free_internal_array(context.config.allowed_paths)
    Internals.free_internal_array(context.config.allowed_syscalls)
    Internals.free_internal_array(context.config.blocked_syscalls)
    Internals.free_internal_map(context.permission_system)
End Process