Note:
runa/src/compiler/backend/syscalls/platforms/windows_x64.runa
Windows x86_64 NT Syscall Definitions

This module contains syscall definitions for Windows NT on x86_64 architecture.
Windows uses a different syscall mechanism with NT kernel syscalls that change
between versions and service packs.

Key features and capabilities:
- Complete NT kernel syscall numbers (version-specific)
- Windows x64 calling convention (RCX, RDX, R8, R9)
- IOCP (I/O Completion Ports) for async I/O
- Security token and privilege handling
- Registry operations and hive management
- Named pipe and mailslot IPC
- Windows-specific error codes (NTSTATUS)
- Object Manager handles
- Process and thread management
- Memory section objects
- Synchronization primitives
- Windows Security Descriptors
- Access Control Lists (ACLs)
- Windows Services API
- Event Tracing for Windows (ETW)
- Windows Management Instrumentation (WMI)
- Volume Shadow Copy Service
- Windows Filtering Platform
- Kernel Transaction Manager
- Windows Error Reporting
- Application Compatibility shims
- Windows Subsystem for Linux (WSL) integration
- Hyper-V hypervisor interface
- Windows Defender integration
- UWP app container isolation
- Windows Hello biometric APIs
:End Note

Import "compiler/frontend/diagnostics/errors" as Errors
Import "compiler/backend/syscalls/syscall_definitions" as SyscallDefs
Import "compiler/frontend/primitives/types/ascii_conversion" as ASCII
Import "../../../frontend/primitives/types/compiler_internals" as Internals
Import "platform_interface.runa" as PlatformInterface

Note: =====================================================================
Note: WINDOWS DATA STRUCTURES
Note: =====================================================================

Process called "add_syscall_mapping" that takes syscalls as Internals.InternalMap, name as String, number as Integer:
    Note: Helper function to add syscall mapping
    Internals.internal_map_set(syscalls, name, number)
End Process

Type called "NTSyscallInfo":
    syscall_number as Integer               Note: NT syscall number
    windows_version as String               Note: Windows version (10, 11, Server)
    service_pack as Integer                 Note: Service pack level
    build_number as Integer                 Note: Windows build number
    is_documented as Boolean                Note: Whether publicly documented
    min_privilege as String                 Note: Minimum required privilege
    subsystem as String                     Note: NT, Win32, Console, etc.

Type called "NTStatus":
    code as Integer                         Note: NTSTATUS code
    severity as String                      Note: Success, Information, Warning, Error
    facility as String                      Note: Facility code
    is_customer as Boolean                  Note: Customer-defined code
    message as String                       Note: Status message

Type called "IOCompletionPort":
    handle as Integer                       Note: IOCP handle
    thread_count as Integer                 Note: Associated threads
    concurrent_threads as Integer           Note: Max concurrent threads
    pending_operations as Integer           Note: Queued operations

Type called "SecurityDescriptor":
    owner_sid as String                     Note: Owner security ID
    group_sid as String                     Note: Group security ID
    dacl as Internals.InternalArray   Note: Discretionary ACL
    sacl as Internals.InternalArray   Note: System ACL
    control_flags as Integer                Note: Security descriptor control

Type called "RegistryKey":
    handle as Integer                       Note: Registry key handle
    path as String                          Note: Full registry path
    hive as String                          Note: HKLM, HKCU, etc.
    access_rights as Integer                Note: Granted access rights
    is_volatile as Boolean                  Note: Volatile key flag

Type called "ProcessToken":
    handle as Integer                       Note: Token handle
    user_sid as String                      Note: User SID
    privileges as Internals.InternalArray              Note: Enabled privileges
    integrity_level as String               Note: Low, Medium, High, System
    token_type as String                    Note: Primary or Impersonation
    session_id as Integer                   Note: Terminal Services session

Type called "ObjectAttributes":
    length as Integer                       Note: Structure size
    root_directory as Optional[Integer]     Note: Root directory handle
    object_name as String                   Note: Object name
    attributes as Integer                   Note: Object attributes flags
    security_descriptor as Optional[SecurityDescriptor]  Note: Security info
    security_qos as Optional[Internals.InternalMap]    Note: QoS settings

Note: =====================================================================
Note: WINDOWS PLATFORM IMPLEMENTATION
Note: =====================================================================

Type called "WindowsX64Platform" implements PlatformInterface.PlatformSyscalls:
    Note: Windows x86_64 platform implementation
    
    @Implementation
    Implements the PlatformSyscalls interface for Windows on x86_64 architecture.
    Provides NT syscall numbers, calling conventions, and NTSTATUS error mappings.
    @End Implementation
    
    syscall_table as Internals.InternalMap
    error_mappings as Internals.InternalMap
    calling_convention as PlatformInterface.CallingConvention
    windows_version as String
    build_number as Integer
End Type

Note: =====================================================================
Note: INTERFACE IMPLEMENTATION METHODS
Note: =====================================================================

Process called "create_windows_x64_platform" returns WindowsX64Platform:
    Note: Create and initialize Windows x64 platform
    
    Let platform be WindowsX64Platform
    Set platform.syscall_table to get_windows_x64_syscall_table()
    Set platform.error_mappings to create_error_mappings()
    Set platform.calling_convention to create_calling_convention()
    Set platform.windows_version to get_windows_version()
    Set platform.build_number to get_windows_build_number()
    Return platform
End Process

Process called "get_syscall_number" that takes self as WindowsX64Platform, name as String returns Integer:
    Note: Implementation of PlatformSyscalls.get_syscall_number
    
    Let name_ptr be Internals.string_to_ptr(name)
    Let result be Internals.internal_map_get(self.syscall_table, name_ptr)
    If result equals 0:
        Return -1
    End If
    Return result
End Process

Process called "get_calling_convention" that takes self as WindowsX64Platform returns PlatformInterface.CallingConvention:
    Note: Implementation of PlatformSyscalls.get_calling_convention
    
    Return self.calling_convention
End Process

Process called "supports_syscall" that takes self as WindowsX64Platform, name as String returns Boolean:
    Note: Implementation of PlatformSyscalls.supports_syscall
    
    Let name_ptr be Internals.string_to_ptr(name)
    Let result be Internals.internal_map_get(self.syscall_table, name_ptr)
    Return result does not equal 0
End Process

Process called "get_error_mapping" that takes self as WindowsX64Platform returns Internals.InternalMap:
    Note: Implementation of PlatformSyscalls.get_error_mapping
    
    Return self.error_mappings
End Process

Process called "get_platform_name" that takes self as WindowsX64Platform returns String:
    Note: Implementation of PlatformSyscalls.get_platform_name
    
    Return "windows_x86_64"
End Process

Process called "get_kernel_version" that takes self as WindowsX64Platform returns String:
    Note: Implementation of PlatformSyscalls.get_kernel_version
    
    Return self.windows_version
End Process

Process called "get_architecture" that takes self as WindowsX64Platform returns String:
    Note: Implementation of PlatformSyscalls.get_architecture
    
    Return "x86_64"
End Process

Process called "get_max_syscall_args" that takes self as WindowsX64Platform returns Integer:
    Note: Implementation of PlatformSyscalls.get_max_syscall_args
    
    Return 4  Note: Windows x64 supports up to 4 register arguments
End Process

Note: =====================================================================
Note: WINDOWS VERSION DETECTION
Note: =====================================================================

Process called "get_windows_version" returns String:
    Note: Get Windows version string
    
    @Implementation
    Uses RtlGetVersion to get accurate Windows version information.
    Avoids version lie issues with GetVersionEx.
    @End Implementation
    
    Let version_info_buffer be SyscallDefs.allocate_buffer(284)  Note: RTL_OSVERSIONINFOW size
    SyscallDefs.write_32bit_at(version_info_buffer, 0, 284)      Note: dwOSVersionInfoSize
    
    Note: Use syscall registry to get RtlGetVersion via NtQuerySystemInformation
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtQuerySystemInformation")
    
    Let return_length_buffer be SyscallDefs.allocate_buffer(4)
    Let result be SyscallDefs.runa_syscall4(syscall_num, 1, version_info_buffer.address, 284, return_length_buffer.address)  Note: SystemBasicInformation
    
    If result is greater than or equal to 0:
        Let major_version be SyscallDefs.read_32bit_at(version_info_buffer, 4)
        Let minor_version be SyscallDefs.read_32bit_at(version_info_buffer, 8)
        Let build_number be SyscallDefs.read_32bit_at(version_info_buffer, 12)
        
        Note: Map version numbers to Windows versions
        If major_version equals 10:
            If build_number is greater than or equal to 22000:
                SyscallDefs.free_buffer(version_info_buffer.address, 284)
                SyscallDefs.free_buffer(return_length_buffer.address, 4)
                Return "Windows 11"
            Otherwise:
                SyscallDefs.free_buffer(version_info_buffer.address, 284)
                SyscallDefs.free_buffer(return_length_buffer.address, 4)
                Return "Windows 10"
            End If
        Otherwise major_version equals 6:
            If minor_version equals 3:
                SyscallDefs.free_buffer(version_info_buffer.address, 284)
                SyscallDefs.free_buffer(return_length_buffer.address, 4)
                Return "Windows 8.1"
            Otherwise minor_version equals 2:
                SyscallDefs.free_buffer(version_info_buffer.address, 284)
                SyscallDefs.free_buffer(return_length_buffer.address, 4)
                Return "Windows 8"
            Otherwise minor_version equals 1:
                SyscallDefs.free_buffer(version_info_buffer.address, 284)
                SyscallDefs.free_buffer(return_length_buffer.address, 4)
                Return "Windows 7"
            End If
        End If
    End If
    
    SyscallDefs.free_buffer(version_info_buffer.address, 284)
    SyscallDefs.free_buffer(return_length_buffer.address, 4)
    Return "Unknown Windows"
End Process

Process called "get_windows_build_number" returns Integer:
    Note: Get Windows build number
    
    @Implementation
    Extracts build number from version information structure.
    Used for syscall number version-specific adjustments.
    @End Implementation
    
    Let version_info_buffer be SyscallDefs.allocate_buffer(284)
    SyscallDefs.write_32bit_at(version_info_buffer, 0, 284)
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtQuerySystemInformation")
    
    Let return_length_buffer be SyscallDefs.allocate_buffer(4)
    Let result be SyscallDefs.runa_syscall4(syscall_num, 1, version_info_buffer.address, 284, return_length_buffer.address)
    
    If result is greater than or equal to 0:
        Let build_number be SyscallDefs.read_32bit_at(version_info_buffer, 12)
        SyscallDefs.free_buffer(version_info_buffer.address, 284)
        SyscallDefs.free_buffer(return_length_buffer.address, 4)
        Return build_number
    End If
    
    SyscallDefs.free_buffer(version_info_buffer.address, 284)
    SyscallDefs.free_buffer(return_length_buffer.address, 4)
    Return 0
End Process

Note: =====================================================================
Note: WINDOWS NT SYSCALL NUMBERS
Note: =====================================================================

Process called "get_windows_x64_syscall_table" returns Internals.InternalMap:
    Note: NT kernel syscall numbers for Windows 10/11 x64
    Note: These are approximate numbers that vary by build
    Note: Real implementation needs runtime version detection
    
    Let syscalls be Internals.internal_map_create()
    
    Note: Core NT syscalls (Windows 10 21H2 baseline)
    add_syscall_mapping(syscalls, "NtAcceptConnectPort", 0x0002)
    add_syscall_mapping(syscalls, "NtAccessCheck", 0x0000)
    add_syscall_mapping(syscalls, "NtAccessCheckAndAuditAlarm", 0x0029)
    add_syscall_mapping(syscalls, "NtAddAtom", 0x0047)
    add_syscall_mapping(syscalls, "NtAdjustPrivilegesToken", 0x0041)
    add_syscall_mapping(syscalls, "NtAlertThread", 0x004C)
    add_syscall_mapping(syscalls, "NtAllocateVirtualMemory", 0x0018)
    add_syscall_mapping(syscalls, "NtAllocateVirtualMemoryEx", 0x0076)
    add_syscall_mapping(syscalls, "NtAlpcAcceptConnectPort", 0x0077)
    add_syscall_mapping(syscalls, "NtAlpcCancelMessage", 0x0078)
    add_syscall_mapping(syscalls, "NtAlpcConnectPort", 0x0079)
    add_syscall_mapping(syscalls, "NtAlpcCreatePort", 0x007A)
    add_syscall_mapping(syscalls, "NtAlpcSendWaitReceivePort", 0x007F)
    add_syscall_mapping(syscalls, "NtCancelIoFile", 0x005D)
    add_syscall_mapping(syscalls, "NtQuerySystemInformation", 0x0036)
    add_syscall_mapping(syscalls, "NtCreateIoCompletion", 0x00B2)
    add_syscall_mapping(syscalls, "NtSetInformationFile", 0x0027)
    add_syscall_mapping(syscalls, "NtRemoveIoCompletion", 0x000B)
    add_syscall_mapping(syscalls, "NtOpenKey", 0x0012)
    add_syscall_mapping(syscalls, "NtQueryValueKey", 0x0017)
    add_syscall_mapping(syscalls, "NtSetValueKey", 0x0060)
    add_syscall_mapping(syscalls, "NtOpenProcessToken", 0x0030)
    add_syscall_mapping(syscalls, "NtQueryInformationToken", 0x0021)
    add_syscall_mapping(syscalls, "NtCreateNamedPipeFile", 0x0094)
    add_syscall_mapping(syscalls, "NtFsControlFile", 0x0039)
    add_syscall_mapping(syscalls, "NtCancelTimer", 0x0061)
    add_syscall_mapping(syscalls, "NtClearEvent", 0x003E)
    add_syscall_mapping(syscalls, "NtClose", 0x000F)
    add_syscall_mapping(syscalls, "NtCommitTransaction", 0x00C6)
    add_syscall_mapping(syscalls, "NtCompareTokens", 0x00A3)
    add_syscall_mapping(syscalls, "NtConnectPort", 0x0065)
    add_syscall_mapping(syscalls, "NtContinue", 0x0043)
    add_syscall_mapping(syscalls, "NtCreateEvent", 0x0048)
    add_syscall_mapping(syscalls, "NtCreateFile", 0x0055)
    add_syscall_mapping(syscalls, "NtCreateKey", 0x001D)
    add_syscall_mapping(syscalls, "NtCreateMutant", 0x00A5)
    add_syscall_mapping(syscalls, "NtCreateNamedPipeFile", 0x0094)
    add_syscall_mapping(syscalls, "NtCreatePort", 0x0068)
    add_syscall_mapping(syscalls, "NtCreateProcess", 0x00AA)
    add_syscall_mapping(syscalls, "NtCreateProcessEx", 0x004D)
    add_syscall_mapping(syscalls, "NtCreateSection", 0x004A)
    add_syscall_mapping(syscalls, "NtCreateSemaphore", 0x00AB)
    add_syscall_mapping(syscalls, "NtCreateSymbolicLinkObject", 0x00B7)
    add_syscall_mapping(syscalls, "NtCreateThread", 0x004E)
    add_syscall_mapping(syscalls, "NtCreateThreadEx", 0x00B3)
    add_syscall_mapping(syscalls, "NtCreateTimer", 0x00B8)
    add_syscall_mapping(syscalls, "NtCreateToken", 0x00C0)
    add_syscall_mapping(syscalls, "NtCreateTransaction", 0x00C7)
    add_syscall_mapping(syscalls, "NtCreateUserProcess", 0x00C8)
    add_syscall_mapping(syscalls, "NtDelayExecution", 0x0034)
    add_syscall_mapping(syscalls, "NtDeleteFile", 0x00CA)
    add_syscall_mapping(syscalls, "NtDeleteKey", 0x00CB)
    add_syscall_mapping(syscalls, "NtDeleteValueKey", 0x00CD)
    add_syscall_mapping(syscalls, "NtDeviceIoControlFile", 0x0007)
    add_syscall_mapping(syscalls, "NtDuplicateObject", 0x0027)
    add_syscall_mapping(syscalls, "NtDuplicateToken", 0x0042)
    add_syscall_mapping(syscalls, "NtEnumerateKey", 0x0032)
    add_syscall_mapping(syscalls, "NtEnumerateValueKey", 0x0013)
    add_syscall_mapping(syscalls, "NtFlushBuffersFile", 0x004B)
    add_syscall_mapping(syscalls, "NtFlushKey", 0x00E6)
    add_syscall_mapping(syscalls, "NtFlushVirtualMemory", 0x00E8)
    add_syscall_mapping(syscalls, "NtFreeVirtualMemory", 0x001E)
    add_syscall_mapping(syscalls, "NtFsControlFile", 0x0039)
    add_syscall_mapping(syscalls, "NtGetContextThread", 0x00EE)
    add_syscall_mapping(syscalls, "NtImpersonateAnonymousToken", 0x00FF)
    add_syscall_mapping(syscalls, "NtImpersonateClientOfPort", 0x001F)
    add_syscall_mapping(syscalls, "NtImpersonateThread", 0x002C)
    add_syscall_mapping(syscalls, "NtListenPort", 0x0110)
    add_syscall_mapping(syscalls, "NtLoadDriver", 0x0111)
    add_syscall_mapping(syscalls, "NtLoadKey", 0x0112)
    add_syscall_mapping(syscalls, "NtLockFile", 0x0116)
    add_syscall_mapping(syscalls, "NtLockVirtualMemory", 0x0118)
    add_syscall_mapping(syscalls, "NtMapViewOfSection", 0x0028)
    add_syscall_mapping(syscalls, "NtNotifyChangeKey", 0x011E)
    add_syscall_mapping(syscalls, "NtOpenDirectoryObject", 0x0058)
    add_syscall_mapping(syscalls, "NtOpenEvent", 0x0040)
    add_syscall_mapping(syscalls, "NtOpenFile", 0x0033)
    add_syscall_mapping(syscalls, "NtOpenKey", 0x0012)
    add_syscall_mapping(syscalls, "NtOpenKeyEx", 0x0121)
    add_syscall_mapping(syscalls, "NtOpenMutant", 0x0122)
    add_syscall_mapping(syscalls, "NtOpenProcess", 0x0026)
    add_syscall_mapping(syscalls, "NtOpenProcessToken", 0x0123)
    add_syscall_mapping(syscalls, "NtOpenProcessTokenEx", 0x0030)
    add_syscall_mapping(syscalls, "NtOpenSection", 0x0037)
    add_syscall_mapping(syscalls, "NtOpenSemaphore", 0x0124)
    add_syscall_mapping(syscalls, "NtOpenSymbolicLinkObject", 0x0125)
    add_syscall_mapping(syscalls, "NtOpenThread", 0x0126)
    add_syscall_mapping(syscalls, "NtOpenThreadToken", 0x0024)
    add_syscall_mapping(syscalls, "NtOpenThreadTokenEx", 0x002F)
    add_syscall_mapping(syscalls, "NtOpenTimer", 0x0127)
    add_syscall_mapping(syscalls, "NtProtectVirtualMemory", 0x0050)
    add_syscall_mapping(syscalls, "NtPulseEvent", 0x0129)
    add_syscall_mapping(syscalls, "NtQueryDirectoryFile", 0x0035)
    add_syscall_mapping(syscalls, "NtQueryDirectoryFileEx", 0x012A)
    add_syscall_mapping(syscalls, "NtQueryEvent", 0x0056)
    add_syscall_mapping(syscalls, "NtQueryInformationFile", 0x0011)
    add_syscall_mapping(syscalls, "NtQueryInformationProcess", 0x0019)
    add_syscall_mapping(syscalls, "NtQueryInformationThread", 0x0025)
    add_syscall_mapping(syscalls, "NtQueryInformationToken", 0x0021)
    add_syscall_mapping(syscalls, "NtQueryKey", 0x0016)
    add_syscall_mapping(syscalls, "NtQueryObject", 0x0010)
    add_syscall_mapping(syscalls, "NtQueryPerformanceCounter", 0x0031)
    add_syscall_mapping(syscalls, "NtQuerySection", 0x014D)
    add_syscall_mapping(syscalls, "NtQuerySecurityObject", 0x014E)
    add_syscall_mapping(syscalls, "NtQuerySemaphore", 0x014F)
    add_syscall_mapping(syscalls, "NtQuerySymbolicLinkObject", 0x0150)
    add_syscall_mapping(syscalls, "NtQuerySystemInformation", 0x0036)
    add_syscall_mapping(syscalls, "NtQuerySystemInformationEx", 0x0151)
    add_syscall_mapping(syscalls, "NtQueryTimer", 0x0038)
    add_syscall_mapping(syscalls, "NtQueryValueKey", 0x0017)
    add_syscall_mapping(syscalls, "NtQueryVirtualMemory", 0x0023)
    add_syscall_mapping(syscalls, "NtQueueApcThread", 0x0045)
    add_syscall_mapping(syscalls, "NtRaiseException", 0x0155)
    add_syscall_mapping(syscalls, "NtRaiseHardError", 0x0156)
    add_syscall_mapping(syscalls, "NtReadFile", 0x0006)
    add_syscall_mapping(syscalls, "NtReadVirtualMemory", 0x003F)
    add_syscall_mapping(syscalls, "NtReleaseMutant", 0x0159)
    add_syscall_mapping(syscalls, "NtReleaseSemaphore", 0x000A)
    add_syscall_mapping(syscalls, "NtRemoveIoCompletion", 0x000B)
    add_syscall_mapping(syscalls, "NtRenameKey", 0x015E)
    add_syscall_mapping(syscalls, "NtReplaceKey", 0x0160)
    add_syscall_mapping(syscalls, "NtReplyPort", 0x000C)
    add_syscall_mapping(syscalls, "NtReplyWaitReceivePort", 0x0009)
    add_syscall_mapping(syscalls, "NtRequestPort", 0x0161)
    add_syscall_mapping(syscalls, "NtRequestWaitReplyPort", 0x001C)
    add_syscall_mapping(syscalls, "NtResetEvent", 0x0162)
    add_syscall_mapping(syscalls, "NtRestoreKey", 0x0163)
    add_syscall_mapping(syscalls, "NtResumeThread", 0x0052)
    add_syscall_mapping(syscalls, "NtSaveKey", 0x0166)
    add_syscall_mapping(syscalls, "NtSetContextThread", 0x017B)
    add_syscall_mapping(syscalls, "NtSetEvent", 0x000E)
    add_syscall_mapping(syscalls, "NtSetInformationFile", 0x0027)
    add_syscall_mapping(syscalls, "NtSetInformationKey", 0x017D)
    add_syscall_mapping(syscalls, "NtSetInformationObject", 0x005C)
    add_syscall_mapping(syscalls, "NtSetInformationProcess", 0x001C)
    add_syscall_mapping(syscalls, "NtSetInformationThread", 0x000D)
    add_syscall_mapping(syscalls, "NtSetInformationToken", 0x0180)
    add_syscall_mapping(syscalls, "NtSetIoCompletion", 0x0181)
    add_syscall_mapping(syscalls, "NtSetSecurityObject", 0x018B)
    add_syscall_mapping(syscalls, "NtSetTimer", 0x0062)
    add_syscall_mapping(syscalls, "NtSetValueKey", 0x0060)
    add_syscall_mapping(syscalls, "NtSignalAndWaitForSingleObject", 0x0191)
    add_syscall_mapping(syscalls, "NtSuspendThread", 0x01B6)
    add_syscall_mapping(syscalls, "NtTerminateProcess", 0x002C)
    add_syscall_mapping(syscalls, "NtTerminateThread", 0x0053)
    add_syscall_mapping(syscalls, "NtTestAlert", 0x01BC)
    add_syscall_mapping(syscalls, "NtUnloadDriver", 0x01C6)
    add_syscall_mapping(syscalls, "NtUnlockFile", 0x01C8)
    add_syscall_mapping(syscalls, "NtUnlockVirtualMemory", 0x01CA)
    add_syscall_mapping(syscalls, "NtUnmapViewOfSection", 0x002A)
    add_syscall_mapping(syscalls, "NtWaitForMultipleObjects", 0x0091)
    add_syscall_mapping(syscalls, "NtWaitForSingleObject", 0x0004)
    add_syscall_mapping(syscalls, "NtWriteFile", 0x0008)
    add_syscall_mapping(syscalls, "NtWriteVirtualMemory", 0x003A)
    add_syscall_mapping(syscalls, "NtYieldExecution", 0x0046)
    
    Return syscalls

Process called "get_nt_file_syscalls" returns Internals.InternalMap:
    Note: NtCreateFile, NtOpenFile, NtReadFile, NtWriteFile
    Note: Different from POSIX conventions
    
    Let syscalls be Internals.internal_map_create()
    
    Note: File I/O syscalls
    add_syscall_mapping(syscalls, "NtCreateFile", 0x0055)
    add_syscall_mapping(syscalls, "NtOpenFile", 0x0033)
    add_syscall_mapping(syscalls, "NtReadFile", 0x0006)
    add_syscall_mapping(syscalls, "NtWriteFile", 0x0008)
    add_syscall_mapping(syscalls, "NtDeleteFile", 0x00CA)
    add_syscall_mapping(syscalls, "NtQueryInformationFile", 0x0011)
    add_syscall_mapping(syscalls, "NtSetInformationFile", 0x0027)
    add_syscall_mapping(syscalls, "NtQueryDirectoryFile", 0x0035)
    add_syscall_mapping(syscalls, "NtQueryDirectoryFileEx", 0x012A)
    add_syscall_mapping(syscalls, "NtFlushBuffersFile", 0x004B)
    add_syscall_mapping(syscalls, "NtLockFile", 0x0116)
    add_syscall_mapping(syscalls, "NtUnlockFile", 0x01C8)
    add_syscall_mapping(syscalls, "NtDeviceIoControlFile", 0x0007)
    add_syscall_mapping(syscalls, "NtFsControlFile", 0x0039)
    add_syscall_mapping(syscalls, "NtCancelIoFile", 0x005D)
    add_syscall_mapping(syscalls, "NtCreateNamedPipeFile", 0x0094)
    
    Return syscalls

Process called "get_nt_process_syscalls" returns Internals.InternalMap:
    Note: NtCreateProcess, NtTerminateProcess
    Note: NtQueryInformationProcess
    Note: Process and thread management
    
    Let syscalls be Internals.internal_map_create()
    
    Note: Process management syscalls
    add_syscall_mapping(syscalls, "NtCreateProcess", 0x00AA)
    add_syscall_mapping(syscalls, "NtCreateProcessEx", 0x004D)
    add_syscall_mapping(syscalls, "NtCreateUserProcess", 0x00C8)
    add_syscall_mapping(syscalls, "NtTerminateProcess", 0x002C)
    add_syscall_mapping(syscalls, "NtOpenProcess", 0x0026)
    add_syscall_mapping(syscalls, "NtQueryInformationProcess", 0x0019)
    add_syscall_mapping(syscalls, "NtSetInformationProcess", 0x001C)
    add_syscall_mapping(syscalls, "NtSuspendProcess", 0x01B5)
    add_syscall_mapping(syscalls, "NtResumeProcess", 0x0165)
    
    Note: Thread management syscalls
    add_syscall_mapping(syscalls, "NtCreateThread", 0x004E)
    add_syscall_mapping(syscalls, "NtCreateThreadEx", 0x00B3)
    add_syscall_mapping(syscalls, "NtTerminateThread", 0x0053)
    add_syscall_mapping(syscalls, "NtOpenThread", 0x0126)
    add_syscall_mapping(syscalls, "NtQueryInformationThread", 0x0025)
    add_syscall_mapping(syscalls, "NtSetInformationThread", 0x000D)
    add_syscall_mapping(syscalls, "NtSuspendThread", 0x01B6)
    add_syscall_mapping(syscalls, "NtResumeThread", 0x0052)
    add_syscall_mapping(syscalls, "NtGetContextThread", 0x00EE)
    add_syscall_mapping(syscalls, "NtSetContextThread", 0x017B)
    add_syscall_mapping(syscalls, "NtQueueApcThread", 0x0045)
    add_syscall_mapping(syscalls, "NtAlertThread", 0x004C)
    add_syscall_mapping(syscalls, "NtTestAlert", 0x01BC)
    add_syscall_mapping(syscalls, "NtImpersonateThread", 0x002C)
    
    Return syscalls

Process called "get_nt_memory_syscalls" returns Internals.InternalMap:
    Note: NtAllocateVirtualMemory, NtFreeVirtualMemory
    Note: NtProtectVirtualMemory, NtQueryVirtualMemory
    Note: Section objects and mapping
    
    Let syscalls be Internals.internal_map_create()
    
    Note: Virtual memory syscalls
    add_syscall_mapping(syscalls, "NtAllocateVirtualMemory", 0x0018)
    add_syscall_mapping(syscalls, "NtAllocateVirtualMemoryEx", 0x0076)
    add_syscall_mapping(syscalls, "NtFreeVirtualMemory", 0x001E)
    add_syscall_mapping(syscalls, "NtProtectVirtualMemory", 0x0050)
    add_syscall_mapping(syscalls, "NtQueryVirtualMemory", 0x0023)
    add_syscall_mapping(syscalls, "NtFlushVirtualMemory", 0x00E8)
    add_syscall_mapping(syscalls, "NtLockVirtualMemory", 0x0118)
    add_syscall_mapping(syscalls, "NtUnlockVirtualMemory", 0x01CA)
    add_syscall_mapping(syscalls, "NtReadVirtualMemory", 0x003F)
    add_syscall_mapping(syscalls, "NtWriteVirtualMemory", 0x003A)
    
    Note: Section (memory mapping) syscalls
    add_syscall_mapping(syscalls, "NtCreateSection", 0x004A)
    add_syscall_mapping(syscalls, "NtOpenSection", 0x0037)
    add_syscall_mapping(syscalls, "NtMapViewOfSection", 0x0028)
    add_syscall_mapping(syscalls, "NtUnmapViewOfSection", 0x002A)
    add_syscall_mapping(syscalls, "NtQuerySection", 0x014D)
    add_syscall_mapping(syscalls, "NtExtendSection", 0x00E4)
    
    Return syscalls

Process called "get_nt_security_syscalls" returns Internals.InternalMap:
    Note: NtAccessCheck, NtPrivilegeCheck
    Note: NtAdjustPrivilegesToken
    Note: Security and access control
    
    Let syscalls be Internals.internal_map_create()
    
    Note: Access control syscalls
    add_syscall_mapping(syscalls, "NtAccessCheck", 0x0000)
    add_syscall_mapping(syscalls, "NtAccessCheckAndAuditAlarm", 0x0029)
    add_syscall_mapping(syscalls, "NtPrivilegeCheck", 0x0135)
    add_syscall_mapping(syscalls, "NtQuerySecurityObject", 0x014E)
    add_syscall_mapping(syscalls, "NtSetSecurityObject", 0x018B)
    
    Note: Token management syscalls
    add_syscall_mapping(syscalls, "NtCreateToken", 0x00C0)
    add_syscall_mapping(syscalls, "NtDuplicateToken", 0x0042)
    add_syscall_mapping(syscalls, "NtOpenProcessToken", 0x0123)
    add_syscall_mapping(syscalls, "NtOpenProcessTokenEx", 0x0030)
    add_syscall_mapping(syscalls, "NtOpenThreadToken", 0x0024)
    add_syscall_mapping(syscalls, "NtOpenThreadTokenEx", 0x002F)
    add_syscall_mapping(syscalls, "NtQueryInformationToken", 0x0021)
    add_syscall_mapping(syscalls, "NtSetInformationToken", 0x0180)
    add_syscall_mapping(syscalls, "NtAdjustPrivilegesToken", 0x0041)
    add_syscall_mapping(syscalls, "NtCompareTokens", 0x00A3)
    add_syscall_mapping(syscalls, "NtImpersonateAnonymousToken", 0x00FF)
    
    Return syscalls

Note: =====================================================================
Note: CALLING CONVENTION
Note: =====================================================================

Process called "get_parameter_registers" returns Internals.InternalArray:
    Note: Windows x64 calling convention
    Note: RCX, RDX, R8, R9, then stack
    Note: Shadow space requirement (32 bytes)
    
    Let registers be Internals.internal_array_create()
    Internals.internal_array_add(registers, "RCX")  Note: First parameter
    Internals.internal_array_add(registers, "RDX")  Note: Second parameter
    Internals.internal_array_add(registers, "R8")   Note: Third parameter
    Internals.internal_array_add(registers, "R9")   Note: Fourth parameter
    Note: Additional parameters go on stack
    
    Return registers

Process called "get_return_register" returns String:
    Note: Return value in RAX
    Note: NTSTATUS codes
    Note: Success is >= 0
    
    Return "RAX"  Note: NT syscalls return NTSTATUS in RAX

Process called "get_clobber_list" returns Internals.InternalArray:
    Note: Volatile registers
    Note: RAX, RCX, RDX, R8-R11
    Note: XMM0-XMM5 also volatile
    
    Let clobbers be Internals.internal_array_create()
    
    Note: Volatile integer registers
    Internals.internal_array_add(clobbers, "RAX")
    Internals.internal_array_add(clobbers, "RCX")
    Internals.internal_array_add(clobbers, "RDX")
    Internals.internal_array_add(clobbers, "R8")
    Internals.internal_array_add(clobbers, "R9")
    Internals.internal_array_add(clobbers, "R10")
    Internals.internal_array_add(clobbers, "R11")
    
    Note: Volatile floating-point registers
    Internals.internal_array_add(clobbers, "XMM0")
    Internals.internal_array_add(clobbers, "XMM1")
    Internals.internal_array_add(clobbers, "XMM2")
    Internals.internal_array_add(clobbers, "XMM3")
    Internals.internal_array_add(clobbers, "XMM4")
    Internals.internal_array_add(clobbers, "XMM5")
    
    Return clobbers

Process called "allocate_shadow_space" returns Integer:
    Note: Allocate 32-byte shadow space
    Note: Required for all calls
    Note: Even if fewer than 4 params
    
    Return 32  Note: Always 32 bytes (4 * 8 bytes) for x64

Note: =====================================================================
Note: VERSION DETECTION
Note: =====================================================================

Process called "detect_windows_version" returns Dictionary[String, Any]:
    Note: Detect Windows version
    Note: Query build number
    Note: Determine syscall table
    
    Let version_info be Dictionary[String, Any]()
    
    Note: Use NtQuerySystemInformation to get version
    Note: SystemBasicInformation = 0
    Let info_buffer be SyscallDefs.allocate_buffer(64)
    Let return_length be SyscallDefs.allocate_buffer(8)
    
    Note: NtQuerySystemInformation syscall
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtQuerySystemInformation")
    Let result be SyscallDefs.runa_syscall4(syscall_num, 0, info_buffer.address, 64, return_length.address)
    
    If result is greater than or equal to 0:
        Note: Extract version information from buffer
        Let major_version be SyscallDefs.read_32bit_at(info_buffer, 16)
        Let minor_version be SyscallDefs.read_32bit_at(info_buffer, 20)
        Let build_number be SyscallDefs.read_32bit_at(info_buffer, 24)
        
        version_info.set("major", major_version)
        version_info.set("minor", minor_version)
        version_info.set("build", build_number)
        
        Note: Determine Windows version string
        If major_version is equal to 10:
            If build_number is greater than or equal to 22000:
                version_info.set("version", "Windows 11")
            Otherwise:
                version_info.set("version", "Windows 10")
            End If
        Otherwise major_version is equal to 6:
            If minor_version is equal to 3:
                version_info.set("version", "Windows 8.1")
            Otherwise minor_version is equal to 2:
                version_info.set("version", "Windows 8")
            Otherwise minor_version is equal to 1:
                version_info.set("version", "Windows 7")
            Otherwise:
                version_info.set("version", "Windows Vista")
            End If
        Otherwise:
            version_info.set("version", "Unknown Windows")
        End If
    Otherwise:
        Note: Failed to query, default to Windows 10 baseline
        version_info.set("major", 10)
        version_info.set("minor", 0)
        version_info.set("build", 19041)
        version_info.set("version", "Windows 10")
    End If
    
    SyscallDefs.free_buffer(info_buffer.address, 64)
    SyscallDefs.free_buffer(return_length.address, 8)
    
    Return version_info

Process called "get_syscall_number_for_version" that takes name as String, version as String returns Integer:
    Note: Get version-specific syscall number
    Note: Handle version differences
    Note: Service pack variations
    
    Note: Get base syscall table
    Let syscall_table be get_windows_x64_syscall_table()
    
    Note: Check if syscall exists in base table
    If syscall_table.contains_key(name):
        Let base_number be syscall_table.get(name)
        
        Note: Apply version-specific offsets
        If version is equal to "Windows 11":
            Note: Windows 11 has different syscall numbers
            If name is equal to "NtCreateUserProcess":
                Return 0x00CA  Note: Different in Windows 11
            Otherwise name is equal to "NtAllocateVirtualMemoryEx":
                Return 0x0078  Note: Adjusted for Windows 11
            Otherwise:
                Return base_number  Note: Most remain the same
            End If
        Otherwise version is equal to "Windows 7":
            Note: Windows 7 has older syscall numbers
            Return base_number minus 0x10  Note: General offset
        Otherwise:
            Return base_number  Note: Use base for Windows 10
        End If
    End If
    
    Return minus 1  Note: Syscall not found

Note: =====================================================================
Note: I/O COMPLETION PORTS
Note: =====================================================================

Process called "create_iocp" that takes thread_count as Integer returns IOCompletionPort:
    Note: Create I/O Completion Port
    Note: Configure thread pool
    Note: High-performance async I/O
    
    Let iocp be IOCompletionPort()
    
    Note: NtCreateIoCompletion syscall (0x00B2)
    Let handle_buffer be SyscallDefs.allocate_buffer(8)
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtCreateIoCompletion")
    Let result be SyscallDefs.runa_syscall4(syscall_num, handle_buffer.address, 0x001F0003, 0, thread_count)
    
    If result is greater than or equal to 0:
        iocp.handle = SyscallDefs.read_64bit_at(handle_buffer, 0)
        iocp.thread_count = 0
        iocp.concurrent_threads = thread_count
        iocp.pending_operations = 0
    Otherwise:
        iocp.handle = minus 1  Note: Invalid handle
    End If
    
    SyscallDefs.free_buffer(handle_buffer.address, 8)
    Return iocp

Process called "associate_handle_with_iocp" that takes iocp as IOCompletionPort, handle as Integer, key as Integer returns Boolean:
    Note: Associate handle with IOCP
    Note: Enable async notifications
    Note: Set completion key
    
    Note: NtSetInformationFile with FileCompletionInformation
    Let info_buffer be SyscallDefs.allocate_buffer(16)
    SyscallDefs.write_64bit_at(info_buffer, 0, iocp.handle)
    SyscallDefs.write_64bit_at(info_buffer, 8, key)
    
    Let io_status_buffer be SyscallDefs.allocate_buffer(16)
    
    Note: FileCompletionInformation = 61
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtSetInformationFile")
    Let result be SyscallDefs.runa_syscall5(syscall_num, handle, io_status_buffer.address, info_buffer.address, 16, 61)
    
    SyscallDefs.free_buffer(info_buffer.address, 16)
    SyscallDefs.free_buffer(io_status_buffer.address, 16)
    
    Return result is greater than or equal to 0

Process called "get_queued_completion_status" that takes iocp as IOCompletionPort, timeout as Integer returns Dictionary[String, Any]:
    Note: Retrieve completion status
    Note: Wait for async operations
    Note: Handle timeouts
    
    Let status be Dictionary[String, Any]()
    
    Note: NtRemoveIoCompletion syscall (0x000B)
    Let key_buffer be SyscallDefs.allocate_buffer(8)
    Let bytes_buffer be SyscallDefs.allocate_buffer(8)
    Let overlapped_buffer be SyscallDefs.allocate_buffer(8)
    Let timeout_buffer be SyscallDefs.allocate_buffer(8)
    
    Note: Convert timeout to NT format (negative for relative time)
    If timeout is greater than 0:
        SyscallDefs.write_64bit_at(timeout_buffer, 0, 0 minus (timeout times 10000))  Note: Convert ms to 100ns intervals
    Otherwise:
        SyscallDefs.write_64bit_at(timeout_buffer, 0, 0x8000000000000000)  Note: INFINITE
    End If
    
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtRemoveIoCompletion")
    Let result be SyscallDefs.runa_syscall5(syscall_num, iocp.handle, key_buffer.address, bytes_buffer.address, overlapped_buffer.address, timeout_buffer.address)
    
    If result is greater than or equal to 0:
        status.set("success", true)
        status.set("key", SyscallDefs.read_64bit_at(key_buffer, 0))
        status.set("bytes_transferred", SyscallDefs.read_64bit_at(bytes_buffer, 0))
        status.set("overlapped", SyscallDefs.read_64bit_at(overlapped_buffer, 0))
    Otherwise:
        status.set("success", false)
        status.set("error", result)
    End If
    
    SyscallDefs.free_buffer(key_buffer.address, 8)
    SyscallDefs.free_buffer(bytes_buffer.address, 8)
    SyscallDefs.free_buffer(overlapped_buffer.address, 8)
    SyscallDefs.free_buffer(timeout_buffer.address, 8)
    
    Return status

Note: =====================================================================
Note: REGISTRY OPERATIONS
Note: =====================================================================

Process called "open_registry_key" that takes path as String, access as Integer returns RegistryKey:
    Note: Open registry key
    Note: Specify access rights
    Note: Handle registry redirector
    
    Let key be RegistryKey()
    
    Note: Prepare OBJECT_ATTRIBUTES structure
    Let obj_attr_buffer be SyscallDefs.allocate_buffer(48)
    SyscallDefs.write_32bit_at(obj_attr_buffer, 0, 48)  Note: Length
    
    Note: Convert path to UNICODE_STRING
    Let path_bytes be ASCII.string_to_bytes(path)
    Let unicode_buffer be SyscallDefs.allocate_buffer(path_bytes.length() times 2)
    Let i be 0
    While i is less than path_bytes.length():
        SyscallDefs.write_byte_at(unicode_buffer, i times 2, path_bytes[i])
        SyscallDefs.write_byte_at(unicode_buffer, (i times 2) plus 1, 0)  Note: Wide char
        Set i to i plus 1
    End While
    
    Note: Set up UNICODE_STRING in obj_attr
    SyscallDefs.write_16bit_at(obj_attr_buffer, 8, path_bytes.length() times 2)  Note: Length
    SyscallDefs.write_16bit_at(obj_attr_buffer, 10, path_bytes.length() times 2)  Note: MaximumLength
    SyscallDefs.write_64bit_at(obj_attr_buffer, 16, unicode_buffer.address)  Note: Buffer pointer
    
    Let handle_buffer be SyscallDefs.allocate_buffer(8)
    
    Note: NtOpenKey syscall
    Let platform be PlatformInterface.get_current_platform()
    Let syscall_num be platform.get_syscall_number("NtOpenKey")
    Let result be SyscallDefs.runa_syscall3(syscall_num, handle_buffer.address, access, obj_attr_buffer.address)
    
    If result is greater than or equal to 0:
        key.handle = SyscallDefs.read_64bit_at(handle_buffer, 0)
        key.path = path
        key.access_rights = access
        key.is_volatile = false
        
        Note: Determine hive from path
        If path.starts_with("\\Registry\\Machine"):
            key.hive = "HKLM"
        Otherwise path.starts_with("\\Registry\\User"):
            key.hive = "HKCU"
        Otherwise:
            key.hive = "UNKNOWN"
        End If
    Otherwise:
        key.handle = minus 1
    End If
    
    SyscallDefs.free_buffer(obj_attr_buffer.address, 48)
    SyscallDefs.free_buffer(unicode_buffer.address, path_bytes.length() times 2)
    SyscallDefs.free_buffer(handle_buffer.address, 8)
    
    Return key

Process called "query_registry_value" that takes key as RegistryKey, value_name as String returns Dictionary[String, Any]:
    Note: Query registry value
    Note: Handle different types
    Note: REG_SZ, REG_DWORD, etc.
    
    Let result_dict be Dictionary[String, Any]()
    
    Note: Convert value name to UNICODE_STRING
    Let name_bytes be ASCII.string_to_bytes(value_name)
    Let unicode_name be SyscallDefs.allocate_buffer(name_bytes.length() times 2)
    Let i be 0
    While i is less than name_bytes.length():
        SyscallDefs.write_byte_at(unicode_name, i times 2, name_bytes[i])
        SyscallDefs.write_byte_at(unicode_name, (i times 2) plus 1, 0)
        Set i to i plus 1
    End While
    
    Note: Query value information
    Let info_buffer be SyscallDefs.allocate_buffer(1024)  Note: Max value size
    Let result_length be SyscallDefs.allocate_buffer(8)
    
    Note: NtQueryValueKey syscall (0x0017)
    Note: KeyValueFullInformation = 1
    Let result be SyscallDefs.runa_syscall6(0x0017, key.handle, unicode_name.address, 1, info_buffer.address, 1024, result_length.address)
    
    If result is greater than or equal to 0:
        Note: Parse KEY_VALUE_FULL_INFORMATION structure
        Let type be SyscallDefs.read_32bit_at(info_buffer, 0)
        Let data_length be SyscallDefs.read_32bit_at(info_buffer, 8)
        Let data_offset be SyscallDefs.read_32bit_at(info_buffer, 12)
        
        result_dict.set("success", true)
        result_dict.set("type", type)
        result_dict.set("length", data_length)
        
        Note: Extract data based on type
        If type is equal to 1:  Note: REG_SZ
            result_dict.set("type_name", "REG_SZ")
            Note: Read string data
            Let string_data be ""
            Let j be 0
            While j is less than data_length:
                Let char be SyscallDefs.read_byte_at(info_buffer, data_offset plus j)
                If char is not equal to 0:
                    Set string_data to string_data plus ASCII.byte_to_char(char)
                End If
                Set j to j plus 2  Note: Wide chars
            End While
            result_dict.set("value", string_data)
        Otherwise type is equal to 4:  Note: REG_DWORD
            result_dict.set("type_name", "REG_DWORD")
            Let dword_value be SyscallDefs.read_32bit_at(info_buffer, data_offset)
            result_dict.set("value", dword_value)
        Otherwise:
            result_dict.set("type_name", "UNKNOWN")
            result_dict.set("value", 0)
        End If
    Otherwise:
        result_dict.set("success", false)
        result_dict.set("error", result)
    End If
    
    SyscallDefs.free_buffer(unicode_name.address, name_bytes.length() times 2)
    SyscallDefs.free_buffer(info_buffer.address, 1024)
    SyscallDefs.free_buffer(result_length.address, 8)
    
    Return result_dict

Process called "set_registry_value" that takes key as RegistryKey, value_name as String, data as Any, type as String returns Boolean:
    Note: Set registry value
    Note: Type-specific encoding
    Note: Flush to disk
    
    Note: Convert value name to UNICODE_STRING
    Let name_bytes be ASCII.string_to_bytes(value_name)
    Let unicode_name be SyscallDefs.allocate_buffer(name_bytes.length() times 2)
    Let i be 0
    While i is less than name_bytes.length():
        SyscallDefs.write_byte_at(unicode_name, i times 2, name_bytes[i])
        SyscallDefs.write_byte_at(unicode_name, (i times 2) plus 1, 0)
        Set i to i plus 1
    End While
    
    Note: Prepare data buffer based on type
    Let data_buffer be SyscallDefs.allocate_buffer(256)
    Let data_size be 0
    Let type_code be 0
    
    If type is equal to "REG_SZ":
        Set type_code to 1
        Let string_data be data as String
        Let string_bytes be ASCII.string_to_bytes(string_data)
        Set data_size to (string_bytes.length() plus 1) times 2  Note: Wide string with null
        Let j be 0
        While j is less than string_bytes.length():
            SyscallDefs.write_byte_at(data_buffer, j times 2, string_bytes[j])
            SyscallDefs.write_byte_at(data_buffer, (j times 2) plus 1, 0)
            Set j to j plus 1
        End While
        SyscallDefs.write_16bit_at(data_buffer, string_bytes.length() times 2, 0)  Note: Null terminator
    Otherwise type is equal to "REG_DWORD":
        Set type_code to 4
        Set data_size to 4
        SyscallDefs.write_32bit_at(data_buffer, 0, data as Integer)
    Otherwise:
        SyscallDefs.free_buffer(unicode_name.address, name_bytes.length() times 2)
        SyscallDefs.free_buffer(data_buffer.address, 256)
        Return false  Note: Unsupported type
    End If
    
    Note: NtSetValueKey syscall (0x0060)
    Let result be SyscallDefs.runa_syscall6(0x0060, key.handle, unicode_name.address, 0, type_code, data_buffer.address, data_size)
    
    SyscallDefs.free_buffer(unicode_name.address, name_bytes.length() times 2)
    SyscallDefs.free_buffer(data_buffer.address, 256)
    
    Return result is greater than or equal to 0

Note: =====================================================================
Note: SECURITY AND ACCESS CONTROL
Note: =====================================================================

Process called "get_process_token" that takes desired_access as Integer returns ProcessToken:
    Note: Get process security token
    Note: Query privileges
    Note: Check integrity level
    
    Let token be ProcessToken()
    
    Note: Get current process handle (-1 = current process)
    Let process_handle be minus 1
    Let token_handle_buffer be SyscallDefs.allocate_buffer(8)
    
    Note: NtOpenProcessTokenEx syscall (0x0030)
    Let result be SyscallDefs.runa_syscall4(0x0030, process_handle, desired_access, 0, token_handle_buffer.address)
    
    If result is greater than or equal to 0:
        token.handle = SyscallDefs.read_64bit_at(token_handle_buffer, 0)
        
        Note: Query token information for user SID
        Let info_buffer be SyscallDefs.allocate_buffer(256)
        Let return_length be SyscallDefs.allocate_buffer(8)
        
        Note: TokenUser = 1
        Let query_result be SyscallDefs.runa_syscall5(0x0021, token.handle, 1, info_buffer.address, 256, return_length.address)
        
        If query_result is greater than or equal to 0:
            Note: Extract and format SID from TOKEN_USER structure
            Let sid_ptr be SyscallDefs.read_64bit_at(info_buffer, 0)  Note: Pointer to SID
            
            Note: Read SID structure components
            Let revision be SyscallDefs.read_byte_at(info_buffer, 8)
            Let sub_auth_count be SyscallDefs.read_byte_at(info_buffer, 9)
            Let auth_high be SyscallDefs.read_16bit_at(info_buffer, 10)
            Let auth_low be SyscallDefs.read_32bit_at(info_buffer, 12)
            
            Note: Build SID string S-R-I-S-S-S...
            Let sid_string be "S-" + revision
            Set sid_string to sid_string + "-" + ((auth_high times 0x100000000) plus auth_low)
            
            Note: Add sub-authorities
            Let i be 0
            While i is less than sub_auth_count:
                Let sub_auth be SyscallDefs.read_32bit_at(info_buffer, 16 plus (i times 4))
                Set sid_string to sid_string + "-" + sub_auth
                Set i to i plus 1
            End While
            
            token.user_sid = sid_string
        End If
        
        Note: Set default values
        token.privileges = Internals.internal_array_create()
        Internals.internal_array_add(token.privileges, "SeChangeNotifyPrivilege")
        Internals.internal_array_add(token.privileges, "SeShutdownPrivilege")
        token.integrity_level = "Medium"
        token.token_type = "Primary"
        token.session_id = 1
        
        SyscallDefs.free_buffer(info_buffer.address, 256)
        SyscallDefs.free_buffer(return_length.address, 8)
    Otherwise:
        token.handle = minus 1
    End If
    
    SyscallDefs.free_buffer(token_handle_buffer.address, 8)
    Return token

Process called "adjust_token_privileges" that takes token as ProcessToken, privileges as List[String], enable as Boolean returns Boolean:
    Note: Adjust token privileges
    Note: Enable or disable
    Note: Requires appropriate rights
    
    Note: Prepare TOKEN_PRIVILEGES structure
    Let priv_buffer be SyscallDefs.allocate_buffer(16 plus (privileges.length() times 16))
    SyscallDefs.write_32bit_at(priv_buffer, 0, privileges.length())  Note: PrivilegeCount
    
    Note: Set attributes for each privilege
    Let attributes be 0
    If enable:
        Set attributes to 0x00000002  Note: SE_PRIVILEGE_ENABLED
    Otherwise:
        Set attributes to 0x00000000  Note: Disabled
    End If
    
    Let i be 0
    While i is less than privileges.length():
        Note: Each LUID_AND_ATTRIBUTES is 12 bytes
        Let offset be 4 plus (i times 12)
        
        Note: Map privilege names to actual LUID values
        Let luid_low be 0
        Let luid_high be 0
        
        Let priv_name be privileges[i]
        If priv_name is equal to "SeDebugPrivilege":
            Set luid_low to 20  Note: SE_DEBUG_PRIVILEGE
        Otherwise priv_name is equal to "SeShutdownPrivilege":
            Set luid_low to 19  Note: SE_SHUTDOWN_PRIVILEGE
        Otherwise priv_name is equal to "SeChangeNotifyPrivilege":
            Set luid_low to 23  Note: SE_CHANGE_NOTIFY_PRIVILEGE
        Otherwise priv_name is equal to "SeBackupPrivilege":
            Set luid_low to 17  Note: SE_BACKUP_PRIVILEGE
        Otherwise priv_name is equal to "SeRestorePrivilege":
            Set luid_low to 18  Note: SE_RESTORE_PRIVILEGE
        Otherwise priv_name is equal to "SeSystemtimePrivilege":
            Set luid_low to 12  Note: SE_SYSTEMTIME_PRIVILEGE
        Otherwise priv_name is equal to "SeTakeOwnershipPrivilege":
            Set luid_low to 9  Note: SE_TAKE_OWNERSHIP_PRIVILEGE
        Otherwise priv_name is equal to "SeLoadDriverPrivilege":
            Set luid_low to 10  Note: SE_LOAD_DRIVER_PRIVILEGE
        Otherwise priv_name is equal to "SeManageVolumePrivilege":
            Set luid_low to 28  Note: SE_MANAGE_VOLUME_PRIVILEGE
        Otherwise priv_name is equal to "SeImpersonatePrivilege":
            Set luid_low to 29  Note: SE_IMPERSONATE_PRIVILEGE
        Otherwise priv_name is equal to "SeCreateGlobalPrivilege":
            Set luid_low to 30  Note: SE_CREATE_GLOBAL_PRIVILEGE
        Otherwise:
            Set luid_low to 2  Note: SE_CREATE_TOKEN_PRIVILEGE (default)
        End If
        
        SyscallDefs.write_32bit_at(priv_buffer, offset, luid_low)
        SyscallDefs.write_32bit_at(priv_buffer, offset plus 4, luid_high)
        SyscallDefs.write_32bit_at(priv_buffer, offset plus 8, attributes)
        
        Set i to i plus 1
    End While
    
    Note: NtAdjustPrivilegesToken syscall (0x0041)
    Let result be SyscallDefs.runa_syscall6(0x0041, token.handle, 0, priv_buffer.address, 16 plus (privileges.length() times 16), 0, 0)
    
    SyscallDefs.free_buffer(priv_buffer.address, 16 plus (privileges.length() times 16))
    
    Return result is greater than or equal to 0

Process called "create_security_descriptor" that takes dacl as List[Dictionary[String, Any]], owner as String returns SecurityDescriptor:
    Note: Create security descriptor
    Note: Set access control lists
    Note: Configure inheritance
    
    Let sd be SecurityDescriptor()
    sd.owner_sid = owner
    sd.group_sid = owner  Note: Same as owner for simplicity
    sd.dacl = dacl
    sd.sacl = Internals.internal_array_create()  Note: Empty SACL
    sd.control_flags = 0x8004  Note: SE_DACL_PRESENT | SE_SELF_RELATIVE
    
    Return sd

Process called "perform_access_check" that takes sd as SecurityDescriptor, token as ProcessToken, desired_access as Integer returns Boolean:
    Note: Check access rights
    Note: Evaluate ACLs
    Note: Consider privileges
    
    Note: Build self-relative security descriptor
    Let sd_buffer be SyscallDefs.allocate_buffer(256)
    
    Note: SECURITY_DESCRIPTOR structure
    SyscallDefs.write_byte_at(sd_buffer, 0, 1)  Note: Revision
    SyscallDefs.write_byte_at(sd_buffer, 1, 0)  Note: Sbz1
    SyscallDefs.write_16bit_at(sd_buffer, 2, sd.control_flags)
    
    Note: Generic mapping structure
    Let generic_mapping be SyscallDefs.allocate_buffer(16)
    SyscallDefs.write_32bit_at(generic_mapping, 0, 0x80000000)  Note: GenericRead
    SyscallDefs.write_32bit_at(generic_mapping, 4, 0x40000000)  Note: GenericWrite
    SyscallDefs.write_32bit_at(generic_mapping, 8, 0x20000000)  Note: GenericExecute
    SyscallDefs.write_32bit_at(generic_mapping, 12, 0x10000000)  Note: GenericAll
    
    Let privileges be SyscallDefs.allocate_buffer(8)
    Let granted_access be SyscallDefs.allocate_buffer(8)
    Let access_status be SyscallDefs.allocate_buffer(8)
    
    Note: NtAccessCheck syscall (0x0000)
    Let result be SyscallDefs.runa_syscall8(0x0000, sd_buffer.address, token.handle, desired_access, generic_mapping.address, privileges.address, 8, granted_access.address, access_status.address)
    
    Let status be SyscallDefs.read_32bit_at(access_status, 0)
    
    SyscallDefs.free_buffer(sd_buffer.address, 256)
    SyscallDefs.free_buffer(generic_mapping.address, 16)
    SyscallDefs.free_buffer(privileges.address, 8)
    SyscallDefs.free_buffer(granted_access.address, 8)
    SyscallDefs.free_buffer(access_status.address, 8)
    
    Return status is greater than or equal to 0

Note: =====================================================================
Note: NAMED PIPES AND IPC
Note: =====================================================================

Process called "create_named_pipe" that takes name as String, mode as Integer, max_instances as Integer returns Integer:
    Note: Create named pipe
    Note: Configure pipe mode
    Note: Set instance limit
    
    Note: Convert pipe name to Unicode
    Let name_bytes be ASCII.string_to_bytes(name)
    Let unicode_name be SyscallDefs.allocate_buffer(name_bytes.length() times 2)
    Let i be 0
    While i is less than name_bytes.length():
        SyscallDefs.write_byte_at(unicode_name, i times 2, name_bytes[i])
        SyscallDefs.write_byte_at(unicode_name, (i times 2) plus 1, 0)
        Set i to i plus 1
    End While
    
    Note: Prepare OBJECT_ATTRIBUTES
    Let obj_attr be SyscallDefs.allocate_buffer(48)
    SyscallDefs.write_32bit_at(obj_attr, 0, 48)  Note: Length
    SyscallDefs.write_64bit_at(obj_attr, 16, unicode_name.address)  Note: ObjectName
    
    Let handle_buffer be SyscallDefs.allocate_buffer(8)
    Let io_status be SyscallDefs.allocate_buffer(16)
    
    Note: Default pipe settings
    Let pipe_type be 0x00000001  Note: MESSAGE_TYPE
    Let read_mode be 0x00000001  Note: MESSAGE_MODE
    Let completion_mode be 0x00000000  Note: QUEUE
    Let timeout be minus 500000000  Note: 50 seconds in 100ns units
    Let inbound_quota be 65536
    Let outbound_quota be 65536
    
    Note: NtCreateNamedPipeFile syscall (0x0094)
    Let result be SyscallDefs.runa_syscall14(0x0094, handle_buffer.address, 0x001F0003, obj_attr.address, io_status.address, 3, 0, pipe_type, read_mode, completion_mode, max_instances, inbound_quota, outbound_quota, timeout)
    
    Let pipe_handle be minus 1
    If result is greater than or equal to 0:
        pipe_handle = SyscallDefs.read_64bit_at(handle_buffer, 0)
    End If
    
    SyscallDefs.free_buffer(unicode_name.address, name_bytes.length() times 2)
    SyscallDefs.free_buffer(obj_attr.address, 48)
    SyscallDefs.free_buffer(handle_buffer.address, 8)
    SyscallDefs.free_buffer(io_status.address, 16)
    
    Return pipe_handle

Process called "connect_named_pipe" that takes pipe_handle as Integer, overlapped as Optional[Dictionary[String, Any]] returns Boolean:
    Note: Wait for client connection
    Note: Support overlapped I/O
    Note: Handle multiple instances
    
    Let io_status be SyscallDefs.allocate_buffer(16)
    
    Note: NtFsControlFile for pipe connection (FSCTL_PIPE_LISTEN = 0x00110018)
    Let result be SyscallDefs.runa_syscall10(0x0039, pipe_handle, 0, 0, 0, io_status.address, 0x00110018, 0, 0, 0, 0)
    
    SyscallDefs.free_buffer(io_status.address, 16)
    
    Return result is greater than or equal to 0

Note: =====================================================================
Note: SYNCHRONIZATION PRIMITIVES
Note: =====================================================================

Process called "create_event" that takes manual_reset as Boolean, initial_state as Boolean, name as Optional[String] returns Integer:
    Note: Create event object
    Note: Manual or auto-reset
    Note: Named for cross-process
    
    Note: Prepare OBJECT_ATTRIBUTES
    Let obj_attr be SyscallDefs.allocate_buffer(48)
    SyscallDefs.write_32bit_at(obj_attr, 0, 48)  Note: Length
    
    Note: EVENT_TYPE enumeration
    Let event_type be 0  Note: NotificationEvent (manual reset)
    If not manual_reset:
        event_type = 1  Note: SynchronizationEvent (auto reset)
    End If
    
    Let handle_buffer be SyscallDefs.allocate_buffer(8)
    
    Note: NtCreateEvent syscall (0x0048)
    Let result be SyscallDefs.runa_syscall5(0x0048, handle_buffer.address, 0x001F0003, obj_attr.address, event_type, initial_state as Integer)
    
    Let event_handle be minus 1
    If result is greater than or equal to 0:
        event_handle = SyscallDefs.read_64bit_at(handle_buffer, 0)
    End If
    
    SyscallDefs.free_buffer(obj_attr.address, 48)
    SyscallDefs.free_buffer(handle_buffer.address, 8)
    
    Return event_handle

Process called "wait_for_multiple_objects" that takes handles as List[Integer], wait_all as Boolean, timeout as Integer returns Integer:
    Note: Wait on multiple objects
    Note: Events, mutexes, processes
    Note: Configurable timeout
    
    Let handle_array be SyscallDefs.allocate_buffer(handles.length() times 8)
    
    Let i be 0
    While i is less than handles.length():
        SyscallDefs.write_64bit_at(handle_array, i times 8, handles[i])
        Set i to i plus 1
    End While
    
    Let timeout_buffer be SyscallDefs.allocate_buffer(8)
    If timeout is greater than or equal to 0:
        SyscallDefs.write_64bit_at(timeout_buffer, 0, 0 minus (timeout times 10000))  Note: Convert to 100ns
    Otherwise:
        SyscallDefs.write_64bit_at(timeout_buffer, 0, 0x8000000000000000)  Note: INFINITE
    End If
    
    Let wait_type be 1  Note: WaitAny
    If wait_all:
        wait_type = 0  Note: WaitAll
    End If
    
    Note: NtWaitForMultipleObjects syscall (0x0091)
    Let result be SyscallDefs.runa_syscall6(0x0091, handles.length(), handle_array.address, wait_type, 0, timeout_buffer.address)
    
    SyscallDefs.free_buffer(handle_array.address, handles.length() times 8)
    SyscallDefs.free_buffer(timeout_buffer.address, 8)
    
    Return result

Note: =====================================================================
Note: ETW (EVENT TRACING FOR WINDOWS)
Note: =====================================================================

Process called "start_etw_trace" that takes session_name as String, properties as Dictionary[String, Any] returns Integer:
    Note: Start ETW trace session
    Note: Configure providers
    Note: Set buffer sizes
    
    Note: EVENT_TRACE_PROPERTIES structure
    Let trace_props be SyscallDefs.allocate_buffer(256)
    
    Note: WNODE_HEADER
    SyscallDefs.write_32bit_at(trace_props, 0, 256)  Note: BufferSize
    SyscallDefs.write_32bit_at(trace_props, 4, 0x00000000)  Note: ProviderId
    SyscallDefs.write_64bit_at(trace_props, 8, 0)  Note: HistoricalContext
    
    Note: Trace properties
    SyscallDefs.write_32bit_at(trace_props, 48, 64)  Note: BufferSize (KB)
    SyscallDefs.write_32bit_at(trace_props, 52, 64)  Note: MinimumBuffers
    SyscallDefs.write_32bit_at(trace_props, 56, 128)  Note: MaximumBuffers
    SyscallDefs.write_32bit_at(trace_props, 60, 1)  Note: LogFileMode
    
    Let session_handle be SyscallDefs.allocate_buffer(8)
    
    Note: NtTraceControl syscall for ETW session management
    Note: ControlCode = 1 (StartTrace)
    Let result be SyscallDefs.runa_syscall5(0x01D8, 1, trace_props.address, 256, session_handle.address, 0)
    
    Let trace_handle be minus 1
    If result is greater than or equal to 0:
        trace_handle = SyscallDefs.read_64bit_at(session_handle, 0)
    End If
    
    SyscallDefs.free_buffer(trace_props.address, 256)
    SyscallDefs.free_buffer(session_handle.address, 8)
    
    Return trace_handle

Process called "write_etw_event" that takes provider_guid as String, event_data as Dictionary[String, Any] returns Boolean:
    Note: Write ETW event
    Note: Structured logging
    Note: High-performance tracing
    
    Note: Parse provider GUID string to binary
    Let guid_buffer be SyscallDefs.allocate_buffer(16)
    
    Note: Extract GUID components from string format
    Note: Expected format: "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
    Let guid_parts be provider_guid.split("-")
    If guid_parts.length() is equal to 5:
        Note: Parse each GUID component from hex string
        Note: Parse 8-character hex string to 32-bit value
        Let data1 be 0
        Let hex_chars be ASCII.string_to_bytes(guid_parts[0])
        Let shift be 28
        Let j be 0
        While j is less than 8:
            Let nibble be 0
            Let ch be hex_chars[j]
            If ch is greater than or equal to 48 and ch is less than or equal to 57:
                nibble = ch minus 48
            Otherwise ch is greater than or equal to 65 and ch is less than or equal to 70:
                nibble = ch minus 55
            Otherwise ch is greater than or equal to 97 and ch is less than or equal to 102:
                nibble = ch minus 87
            End If
            data1 = data1 or (nibble times (1 shifted left by shift))
            Set shift to shift minus 4
            Set j to j plus 1
        End While
        
        Note: Parse 4-character hex string to 16-bit value
        Let data2 be 0
        hex_chars = ASCII.string_to_bytes(guid_parts[1])
        shift = 12
        j = 0
        While j is less than 4:
            Let nibble be 0
            Let ch be hex_chars[j]
            If ch is greater than or equal to 48 and ch is less than or equal to 57:
                nibble = ch minus 48
            Otherwise ch is greater than or equal to 65 and ch is less than or equal to 70:
                nibble = ch minus 55
            Otherwise ch is greater than or equal to 97 and ch is less than or equal to 102:
                nibble = ch minus 87
            End If
            data2 = data2 or (nibble times (1 shifted left by shift))
            Set shift to shift minus 4
            Set j to j plus 1
        End While
        
        Note: Parse second 4-character hex string to 16-bit value
        Let data3 be 0
        hex_chars = ASCII.string_to_bytes(guid_parts[2])
        shift = 12
        j = 0
        While j is less than 4:
            Let nibble be 0
            Let ch be hex_chars[j]
            If ch is greater than or equal to 48 and ch is less than or equal to 57:
                nibble = ch minus 48
            Otherwise ch is greater than or equal to 65 and ch is less than or equal to 70:
                nibble = ch minus 55
            Otherwise ch is greater than or equal to 97 and ch is less than or equal to 102:
                nibble = ch minus 87
            End If
            data3 = data3 or (nibble times (1 shifted left by shift))
            Set shift to shift minus 4
            Set j to j plus 1
        End While
        
        SyscallDefs.write_32bit_at(guid_buffer, 0, data1)
        SyscallDefs.write_16bit_at(guid_buffer, 4, data2)
        SyscallDefs.write_16bit_at(guid_buffer, 6, data3)
        
        Note: Parse last 8 bytes
        Let byte_offset be 8
        Let part3_chars be guid_parts[3] + guid_parts[4]
        Let char_index be 0
        While byte_offset is less than 16:
            Note: Convert hex pairs to bytes
            Let byte_val be 0
            If char_index is less than part3_chars.length():
                Note: Calculate hex value from characters
                Let high_nibble be 0
                Let low_nibble be 0
                
                Let high_char be part3_chars[char_index]
                If high_char is greater than or equal to 48 and high_char is less than or equal to 57:
                    high_nibble = high_char minus 48
                Otherwise high_char is greater than or equal to 65 and high_char is less than or equal to 70:
                    high_nibble = high_char minus 55
                Otherwise high_char is greater than or equal to 97 and high_char is less than or equal to 102:
                    high_nibble = high_char minus 87
                End If
                
                Let low_char be part3_chars[char_index plus 1]
                If low_char is greater than or equal to 48 and low_char is less than or equal to 57:
                    low_nibble = low_char minus 48
                Otherwise low_char is greater than or equal to 65 and low_char is less than or equal to 70:
                    low_nibble = low_char minus 55
                Otherwise low_char is greater than or equal to 97 and low_char is less than or equal to 102:
                    low_nibble = low_char minus 87
                End If
                
                byte_val = (high_nibble times 16) plus low_nibble
            End If
            
            SyscallDefs.write_byte_at(guid_buffer, byte_offset, byte_val)
            Set byte_offset to byte_offset plus 1
            Set char_index to char_index plus 2
        End While
    End If
    
    Note: Prepare event data buffer
    Let data_buffer be SyscallDefs.allocate_buffer(256)
    Let data_size be 0
    
    Note: Write event fields from dictionary
    If event_data.contains_key("EventId"):
        SyscallDefs.write_32bit_at(data_buffer, 0, event_data.get("EventId"))
        Set data_size to 4
    End If
    
    If event_data.contains_key("Level"):
        SyscallDefs.write_16bit_at(data_buffer, 4, event_data.get("Level"))
        Set data_size to 6
    End If
    
    Note: EVENT_DATA_DESCRIPTOR structure
    Let event_desc be SyscallDefs.allocate_buffer(16)
    SyscallDefs.write_64bit_at(event_desc, 0, data_buffer.address)
    SyscallDefs.write_32bit_at(event_desc, 8, data_size)
    SyscallDefs.write_32bit_at(event_desc, 12, 0)  Note: Reserved
    
    Note: EVENT_DESCRIPTOR structure
    Let event_header be SyscallDefs.allocate_buffer(16)
    SyscallDefs.write_16bit_at(event_header, 0, event_data.get("EventId", 1))  Note: Id
    SyscallDefs.write_8bit_at(event_header, 2, event_data.get("Version", 0))   Note: Version
    SyscallDefs.write_8bit_at(event_header, 3, event_data.get("Channel", 0))   Note: Channel
    SyscallDefs.write_8bit_at(event_header, 4, event_data.get("Level", 4))     Note: Level
    SyscallDefs.write_8bit_at(event_header, 5, event_data.get("Opcode", 0))    Note: Opcode
    SyscallDefs.write_16bit_at(event_header, 6, event_data.get("Task", 0))     Note: Task
    SyscallDefs.write_64bit_at(event_header, 8, event_data.get("Keyword", 0))  Note: Keyword
    
    Note: NtTraceEvent syscall with proper parameters
    Let registration_handle be event_data.get("RegistrationHandle", 0)
    Let result be SyscallDefs.runa_syscall4(0x01D9, registration_handle, event_header.address, event_desc.address, 1)
    
    SyscallDefs.free_buffer(guid_buffer.address, 16)
    SyscallDefs.free_buffer(data_buffer.address, 256)
    SyscallDefs.free_buffer(event_desc.address, 16)
    SyscallDefs.free_buffer(event_header.address, 16)
    
    Return result is greater than or equal to 0

Note: =====================================================================
Note: ERROR HANDLING
Note: =====================================================================

Process called "is_nt_success" that takes status as Integer returns Boolean:
    Note: Check NTSTATUS success
    Note: Success is >= 0
    Note: Includes informational
    
    Note: NT_SUCCESS macro equivalent
    Return status is greater than or equal to 0

Process called "get_last_error" returns Integer:
    Note: Get last Win32 error
    Note: Thread-local storage
    Note: Convert to NTSTATUS
    
    Note: Read TEB (Thread Environment Block) to get last error
    Note: TEB is accessible via GS segment on x64
    Note: LastErrorValue is at offset 0x68 in TEB
    
    Note: Use NtQueryInformationThread to get TEB address
    Let thread_handle be minus 2  Note: Current thread pseudo-handle
    Let teb_info_buffer be SyscallDefs.allocate_buffer(48)
    Let return_length be SyscallDefs.allocate_buffer(8)
    
    Note: ThreadBasicInformation = 0
    Let result be SyscallDefs.runa_syscall5(0x0025, thread_handle, 0, teb_info_buffer.address, 48, return_length.address)
    
    Let last_error be 0
    If result is greater than or equal to 0:
        Note: TEB address is at offset 8 in THREAD_BASIC_INFORMATION
        Let teb_address be SyscallDefs.read_64bit_at(teb_info_buffer, 8)
        
        Note: Read LastErrorValue from TEB+0x68
        Let error_buffer be SyscallDefs.allocate_buffer(4)
        Let read_result be SyscallDefs.runa_syscall5(0x003F, thread_handle, error_buffer.address, teb_address plus 0x68, 4, 0)
        
        If read_result is greater than or equal to 0:
            last_error = SyscallDefs.read_32bit_at(error_buffer, 0)
            
            Note: Convert Win32 error to NTSTATUS
            If last_error is not equal to 0:
                last_error = 0xC0070000 or last_error  Note: NTSTATUS from Win32 error
            End If
        End If
        
        SyscallDefs.free_buffer(error_buffer.address, 4)
    End If
    
    SyscallDefs.free_buffer(teb_info_buffer.address, 48)
    SyscallDefs.free_buffer(return_length.address, 8)
    
    Return last_error

Process called "format_nt_status" that takes status as Integer returns String:
    Note: Format NTSTATUS message
    Note: Human-readable error
    Note: Include facility info
    
    Note: Extract NTSTATUS components
    Let severity be (status divided by 0x40000000) modulo 4
    Let customer be (status divided by 0x20000000) modulo 2
    Let facility be (status divided by 0x10000) modulo 0xFFF
    Let code be status modulo 0x10000
    
    Note: Format severity
    Let severity_str be "SUCCESS"
    If severity is equal to 1:
        severity_str = "INFORMATIONAL"
    Otherwise severity is equal to 2:
        severity_str = "WARNING"
    Otherwise severity is equal to 3:
        severity_str = "ERROR"
    End If
    
    Note: Common NTSTATUS codes
    Let message be "Unknown status"
    If status is equal to 0:
        message = "The operation completed successfully"
    Otherwise status is equal to 0xC0000001:
        message = "Unsuccessful"
    Otherwise status is equal to 0xC0000005:
        message = "Access is denied"
    Otherwise status is equal to 0xC000000D:
        message = "Invalid parameter"
    Otherwise status is equal to 0xC0000008:
        message = "Invalid handle"
    Otherwise status is equal to 0xC0000022:
        message = "Access denied"
    Otherwise status is equal to 0xC0000034:
        message = "Object name not found"
    Otherwise status is equal to 0xC0000035:
        message = "Object name collision"
    End If
    
    Return severity_str + ": " + message + " (0x" + status + ")"

Note: =====================================================================
Note: WINDOWS SUBSYSTEMS
Note: =====================================================================

Process called "get_wsl_syscalls" returns Dictionary[String, Integer]:
    Note: WSL interop syscalls
    Note: Linux compatibility layer
    Note: pico process support
    
    Let syscalls be Internals.internal_map_create()
    
    Note: WSL-specific NT syscalls
    add_syscall_mapping(syscalls, "NtCreateLowBoxToken", 0x01DA)  Note: Container isolation
    add_syscall_mapping(syscalls, "NtSetInformationProcess", 0x001C)  Note: For pico processes
    add_syscall_mapping(syscalls, "NtCreateWnfStateName", 0x01DC)  Note: Windows Notification Facility
    add_syscall_mapping(syscalls, "NtSubscribeWnfStateChange", 0x01DD)
    add_syscall_mapping(syscalls, "NtQueryWnfStateData", 0x01DE)
    add_syscall_mapping(syscalls, "NtUpdateWnfStateData", 0x01DF)
    
    Note: Pico process management
    add_syscall_mapping(syscalls, "NtCreatePicoProcess", 0x01E0)  Note: WSL process creation
    add_syscall_mapping(syscalls, "NtTerminatePicoProcess", 0x01E1)
    add_syscall_mapping(syscalls, "NtGetPicoProcessInfo", 0x01E2)
    add_syscall_mapping(syscalls, "NtWaitForPicoProcess", 0x01E3)
    
    Return syscalls

Process called "get_hyperv_syscalls" returns Dictionary[String, Integer]:
    Note: Hyper-V hypercalls
    Note: Virtualization support
    Note: Partition management
    
    Let syscalls be Internals.internal_map_create()
    
    Note: Hyper-V hypercall numbers (via VMCALL/VMMCALL)
    add_syscall_mapping(syscalls, "HvCallPostMessage", 0x005C)
    add_syscall_mapping(syscalls, "HvCallSignalEvent", 0x005D)
    add_syscall_mapping(syscalls, "HvCallRetargetDeviceInterrupt", 0x007E)
    add_syscall_mapping(syscalls, "HvCallMapGpaPages", 0x004B)
    add_syscall_mapping(syscalls, "HvCallUnmapGpaPages", 0x004C)
    add_syscall_mapping(syscalls, "HvCallCreatePartition", 0x0040)
    add_syscall_mapping(syscalls, "HvCallDeletePartition", 0x0041)
    add_syscall_mapping(syscalls, "HvCallGetPartitionProperty", 0x0042)
    add_syscall_mapping(syscalls, "HvCallSetPartitionProperty", 0x0043)
    add_syscall_mapping(syscalls, "HvCallGetPartitionId", 0x0046)
    add_syscall_mapping(syscalls, "HvCallDepositMemory", 0x0048)
    add_syscall_mapping(syscalls, "HvCallWithdrawMemory", 0x0049)
    add_syscall_mapping(syscalls, "HvCallMapVpRegisters", 0x0091)
    add_syscall_mapping(syscalls, "HvCallUnmapVpRegisters", 0x0092)
    add_syscall_mapping(syscalls, "HvCallGetVpRegisters", 0x0050)
    add_syscall_mapping(syscalls, "HvCallSetVpRegisters", 0x0051)
    add_syscall_mapping(syscalls, "HvCallTranslateVirtualAddress", 0x0052)
    add_syscall_mapping(syscalls, "HvCallReadGpa", 0x0053)
    add_syscall_mapping(syscalls, "HvCallWriteGpa", 0x0054)
    
    Return syscalls
End Process

Process called "create_error_mappings" returns Dictionary[Integer, PlatformInterface.ErrorMapping]:
    @Reasoning {
        Creates mappings from NTSTATUS codes to POSIX error codes.
        Windows has different error code system than Unix.
    }
    @Implementation {
        Maps common NTSTATUS codes to equivalent POSIX errors.
        Provides descriptive messages for debugging.
    }
    
    Let mappings be Dictionary[Integer, PlatformInterface.ErrorMapping]()
    
    Note: Success codes
    Let success be PlatformInterface.ErrorMapping()
    success.platform_error = 0
    success.posix_error = 0
    success.description = "Success"
    mappings.set(0, success)
    
    Note: Common error codes
    Let access_denied be PlatformInterface.ErrorMapping()
    access_denied.platform_error = 0xC0000022
    access_denied.posix_error = 13  Note: EACCES
    access_denied.description = "Access denied"
    mappings.set(0xC0000022, access_denied)
    
    Let invalid_param be PlatformInterface.ErrorMapping()
    invalid_param.platform_error = 0xC000000D
    invalid_param.posix_error = 22  Note: EINVAL
    invalid_param.description = "Invalid parameter"
    mappings.set(0xC000000D, invalid_param)
    
    Let not_found be PlatformInterface.ErrorMapping()
    not_found.platform_error = 0xC0000034
    not_found.posix_error = 2  Note: ENOENT
    not_found.description = "Object not found"
    mappings.set(0xC0000034, not_found)
    
    Let no_memory be PlatformInterface.ErrorMapping()
    no_memory.platform_error = 0xC0000017
    no_memory.posix_error = 12  Note: ENOMEM
    no_memory.description = "Not enough memory"
    mappings.set(0xC0000017, no_memory)
    
    Let invalid_handle be PlatformInterface.ErrorMapping()
    invalid_handle.platform_error = 0xC0000008
    invalid_handle.posix_error = 9  Note: EBADF
    invalid_handle.description = "Invalid handle"
    mappings.set(0xC0000008, invalid_handle)
    
    Return mappings
End Process

Process called "create_calling_convention" returns PlatformInterface.CallingConvention:
    @Reasoning {
        Defines Windows x64 calling convention.
        Uses RCX, RDX, R8, R9 for args, different from System V.
    }
    @Implementation {
        Sets up register usage and stack requirements.
        Includes shadow space requirement.
    }
    
    Let conv be PlatformInterface.CallingConvention()
    conv.syscall_register = "RAX"
    conv.syscall_instruction = "syscall"
    conv.arg_registers = Internals.internal_array_create()
    conv.arg_Internals.internal_array_add(registers, "RCX")
    conv.arg_Internals.internal_array_add(registers, "RDX")
    conv.arg_Internals.internal_array_add(registers, "R8")
    conv.arg_Internals.internal_array_add(registers, "R9")
    conv.return_register = "RAX"
    conv.stack_alignment = 16
    conv.red_zone_size = 0  Note: No red zone on Windows
    conv.shadow_space = 32  Note: 32-byte shadow space required
    Return conv
End Process

Process called "register_windows_x64_platform" returns Boolean:
    @Reasoning {
        Registers Windows x64 platform with global registry.
        Enables runtime platform selection.
    }
    @Implementation {
        Creates platform instance and registers it.
        Returns success status.
    }
    
    Let platform be create_windows_x64_platform()
    Return PlatformInterface.register_platform("windows_x86_64", platform)
End Process