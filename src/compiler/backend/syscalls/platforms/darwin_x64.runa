Note:
runa/src/compiler/backend/syscalls/platforms/darwin_x64.runa
macOS/Darwin x86_64 Syscall Definitions

This module contains syscall definitions for macOS/Darwin on x86_64 architecture.
All Darwin syscalls are prefixed with 0x2000000 on x86_64 to distinguish them
from Mach trap calls.

Key features and capabilities:
- Complete Darwin x86_64 syscall number mappings
- BSD-derived syscall interface with Darwin extensions
- Mach kernel trap interface
- kqueue/kevent high-performance event system
- Grand Central Dispatch (libdispatch) integration
- Sandbox and entitlement requirements
- macOS-specific extended attributes (xattr)
- APFS and HFS+ specific operations
- Hypervisor framework support
- XPC inter-process communication
- Endpoint Security framework
- System Extension support
- Notarization and code signing
- Gatekeeper and quarantine attributes
- Unified logging system (os_log)
- Metal Performance Shaders support
- CoreML acceleration
- Secure Enclave operations
- T2 security chip integration
- FileVault encryption support
- Time Machine snapshot management
- Spotlight indexing interface
- Launch Services integration
- Network Extension framework
- DriverKit user-space drivers
:End Note

Import "compiler/frontend/diagnostics/errors" as Errors
Import "compiler/frontend/primitives/types/ascii_conversion" as ASCII
Import "compiler/backend/syscalls/syscall_definitions" as SyscallDefs
Import "../../../frontend/primitives/types/compiler_internals" as Internals

Note: Using syscall interfaces from SyscallDefs
Note: All external declarations are now centralized

Note: =====================================================================
Note: DARWIN DATA STRUCTURES
Note: =====================================================================

Type called "DarwinSyscallInfo":
    syscall_number as Integer               Note: Base syscall number
    prefixed_number as Integer              Note: With 0x2000000 prefix
    is_unix_syscall as Boolean              Note: BSD-compatible syscall
    is_mach_trap as Boolean                 Note: Mach kernel trap
    min_macos_version as String             Note: Minimum macOS version
    entitlement_required as Optional[String] Note: Required entitlement
    sandbox_allowed as Boolean               Note: Allowed in sandboxed apps
    deprecated_in as Optional[String]        Note: Deprecation version

Type called "MachPort":
    port_name as Integer                    Note: Mach port name
    port_rights as Integer                  Note: Send/receive rights
    port_type as String                     Note: Task, thread, etc.
    queue_limit as Integer                  Note: Message queue limit

Type called "KqueueEvent":
    ident as Integer                        Note: Event identifier
    filter as String                        Note: Event filter type
    flags as Integer                        Note: Action flags
    fflags as Integer                       Note: Filter-specific flags
    data as Integer                         Note: Filter-specific data
    udata as Integer                        Note: User-defined data

Type called "DarwinSecurityContext":
    entitlements as Internals.InternalArray           Note: App entitlements
    sandbox_profile as String              Note: Sandbox configuration
    code_signature as String               Note: Code signing info
    team_id as String                      Note: Developer team ID
    notarization_ticket as Optional[String] Note: Notarization info
    hardened_runtime as Boolean            Note: Hardened runtime enabled

Type called "XPCConnection":
    connection_name as String               Note: Service name
    connection_type as String               Note: XPC or Mach service
    peer_pid as Integer                     Note: Peer process ID
    peer_entitlements as Internals.InternalArray      Note: Peer's entitlements
    is_privileged as Boolean                Note: Privileged helper
    reply_port as Integer                   Note: Reply port for bidirectional communication
    service_port as Integer                 Note: Service's Mach port

Type called "HypervisorConfig":
    vm_count as Integer                     Note: Number of VMs
    vcpu_count as Integer                   Note: Total vCPUs
    memory_size as Integer                  Note: Allocated memory
    virtualization_type as String           Note: HVF, Virtualization.framework

Note: =====================================================================
Note: DARWIN SYSCALL NUMBERS
Note: =====================================================================

Note: Helper function to add syscall name/number mapping
Process called "add_syscall_mapping" that takes syscalls as Internals.InternalMap, name as String, number as Integer:
    Let name_ptr be Internals.string_to_ptr(name)
    Internals.internal_map_insert(syscalls, name_ptr, number)
End Process

Process called "get_darwin_x64_syscall_table" returns Internals.InternalMap:
    Note: Return Darwin syscall table with 0x2000000 prefix for x86_64
    
    @Implementation
    Provides the complete syscall table for Darwin x86_64. These numbers
    include the 0x2000000 prefix for Unix syscalls on x86_64.
    @End Implementation
    
    Let syscalls be Internals.create_internal_map()
    
    Note: Process management syscalls
    add_syscall_mapping(syscalls, "exit", 0x2000001)
    add_syscall_mapping(syscalls, "fork", 0x2000002)
    add_syscall_mapping(syscalls, "read", 0x2000003)
    add_syscall_mapping(syscalls, "write", 0x2000004)
    add_syscall_mapping(syscalls, "open", 0x2000005)
    add_syscall_mapping(syscalls, "close", 0x2000006)
    add_syscall_mapping(syscalls, "wait4", 0x2000007)
    add_syscall_mapping(syscalls, "link", 0x2000009)
    add_syscall_mapping(syscalls, "unlink", 0x200000a)
    add_syscall_mapping(syscalls, "chdir", 0x200000c)
    add_syscall_mapping(syscalls, "fchdir", 0x200000d)
    add_syscall_mapping(syscalls, "mknod", 0x200000e)
    add_syscall_mapping(syscalls, "chmod", 0x200000f)
    add_syscall_mapping(syscalls, "chown", 0x2000010
    add_syscall_mapping(syscalls, "getpid", 0x2000014
    add_syscall_mapping(syscalls, "setuid", 0x2000017
    add_syscall_mapping(syscalls, "getuid", 0x2000018
    add_syscall_mapping(syscalls, "geteuid", 0x2000019
    add_syscall_mapping(syscalls, "ptrace", 0x200001a
    add_syscall_mapping(syscalls, "recvmsg", 0x200001b
    add_syscall_mapping(syscalls, "sendmsg", 0x200001c
    add_syscall_mapping(syscalls, "recvfrom", 0x200001d
    add_syscall_mapping(syscalls, "accept", 0x200001e
    add_syscall_mapping(syscalls, "getpeername", 0x200001f
    add_syscall_mapping(syscalls, "getsockname", 0x2000020
    
    Note: File operations
    add_syscall_mapping(syscalls, "access", 0x2000021
    add_syscall_mapping(syscalls, "chflags", 0x2000022
    add_syscall_mapping(syscalls, "fchflags", 0x2000023
    add_syscall_mapping(syscalls, "sync", 0x2000024
    add_syscall_mapping(syscalls, "kill", 0x2000025
    add_syscall_mapping(syscalls, "getppid", 0x2000027
    add_syscall_mapping(syscalls, "dup", 0x2000029
    add_syscall_mapping(syscalls, "pipe", 0x200002a
    add_syscall_mapping(syscalls, "getegid", 0x200002b
    add_syscall_mapping(syscalls, "sigaction", 0x200002e
    add_syscall_mapping(syscalls, "getgid", 0x200002f
    add_syscall_mapping(syscalls, "sigprocmask", 0x2000030
    add_syscall_mapping(syscalls, "getlogin", 0x2000031
    add_syscall_mapping(syscalls, "setlogin", 0x2000032
    add_syscall_mapping(syscalls, "acct", 0x2000033
    add_syscall_mapping(syscalls, "sigpending", 0x2000034
    add_syscall_mapping(syscalls, "sigaltstack", 0x2000035
    add_syscall_mapping(syscalls, "ioctl", 0x2000036
    add_syscall_mapping(syscalls, "reboot", 0x2000037
    add_syscall_mapping(syscalls, "revoke", 0x2000038
    add_syscall_mapping(syscalls, "symlink", 0x2000039
    add_syscall_mapping(syscalls, "readlink", 0x200003a
    add_syscall_mapping(syscalls, "execve", 0x200003b
    add_syscall_mapping(syscalls, "umask", 0x200003c
    add_syscall_mapping(syscalls, "chroot", 0x200003d
    
    Note: Memory management
    add_syscall_mapping(syscalls, "msync", 0x2000041
    add_syscall_mapping(syscalls, "munmap", 0x2000049
    add_syscall_mapping(syscalls, "mprotect", 0x200004a
    add_syscall_mapping(syscalls, "madvise", 0x200004b
    add_syscall_mapping(syscalls, "mincore", 0x200004e
    add_syscall_mapping(syscalls, "getgroups", 0x200004f
    add_syscall_mapping(syscalls, "setgroups", 0x2000050
    add_syscall_mapping(syscalls, "getpgrp", 0x2000051
    add_syscall_mapping(syscalls, "setpgid", 0x2000052
    add_syscall_mapping(syscalls, "setitimer", 0x2000053
    add_syscall_mapping(syscalls, "swapon", 0x2000055
    add_syscall_mapping(syscalls, "getitimer", 0x2000056
    add_syscall_mapping(syscalls, "getdtablesize", 0x2000059
    add_syscall_mapping(syscalls, "dup2", 0x200005a
    add_syscall_mapping(syscalls, "fcntl", 0x200005c
    add_syscall_mapping(syscalls, "select", 0x200005d
    add_syscall_mapping(syscalls, "fsync", 0x200005f
    add_syscall_mapping(syscalls, "setpriority", 0x2000060
    add_syscall_mapping(syscalls, "socket", 0x2000061
    add_syscall_mapping(syscalls, "connect", 0x2000062
    
    Note: Network operations
    add_syscall_mapping(syscalls, "getpriority", 0x2000064
    add_syscall_mapping(syscalls, "bind", 0x2000068
    add_syscall_mapping(syscalls, "setsockopt", 0x2000069
    add_syscall_mapping(syscalls, "listen", 0x200006a
    add_syscall_mapping(syscalls, "sigsuspend", 0x200006f
    add_syscall_mapping(syscalls, "gettimeofday", 0x2000074
    add_syscall_mapping(syscalls, "getrusage", 0x2000075
    add_syscall_mapping(syscalls, "getsockopt", 0x2000076
    add_syscall_mapping(syscalls, "readv", 0x2000078
    add_syscall_mapping(syscalls, "writev", 0x2000079
    add_syscall_mapping(syscalls, "settimeofday", 0x200007a
    add_syscall_mapping(syscalls, "fchown", 0x200007b
    add_syscall_mapping(syscalls, "fchmod", 0x200007c
    add_syscall_mapping(syscalls, "setreuid", 0x200007e
    add_syscall_mapping(syscalls, "setregid", 0x200007f
    add_syscall_mapping(syscalls, "rename", 0x2000080
    add_syscall_mapping(syscalls, "flock", 0x2000083
    add_syscall_mapping(syscalls, "mkfifo", 0x2000084
    add_syscall_mapping(syscalls, "sendto", 0x2000085
    add_syscall_mapping(syscalls, "shutdown", 0x2000086
    add_syscall_mapping(syscalls, "socketpair", 0x2000087
    add_syscall_mapping(syscalls, "mkdir", 0x2000088
    add_syscall_mapping(syscalls, "rmdir", 0x2000089
    add_syscall_mapping(syscalls, "utimes", 0x200008a
    add_syscall_mapping(syscalls, "futimes", 0x200008b
    add_syscall_mapping(syscalls, "adjtime", 0x200008c
    add_syscall_mapping(syscalls, "gethostuuid", 0x200008e
    
    Note: Extended attributes and kqueue
    add_syscall_mapping(syscalls, "setsid", 0x2000093
    add_syscall_mapping(syscalls, "getpgid", 0x2000097
    add_syscall_mapping(syscalls, "setprivexec", 0x2000098
    add_syscall_mapping(syscalls, "pread", 0x2000099
    add_syscall_mapping(syscalls, "pwrite", 0x200009a
    add_syscall_mapping(syscalls, "nfssvc", 0x200009b
    add_syscall_mapping(syscalls, "statfs", 0x200009d
    add_syscall_mapping(syscalls, "fstatfs", 0x200009e
    add_syscall_mapping(syscalls, "unmount", 0x200009f
    add_syscall_mapping(syscalls, "getfh", 0x20000a1
    add_syscall_mapping(syscalls, "quotactl", 0x20000a5
    add_syscall_mapping(syscalls, "mount", 0x20000a7
    add_syscall_mapping(syscalls, "csops", 0x20000a9  Note: Code signing operations
    add_syscall_mapping(syscalls, "waitid", 0x20000ad
    add_syscall_mapping(syscalls, "kdebug_trace", 0x20000b4
    add_syscall_mapping(syscalls, "setgid", 0x20000b5
    add_syscall_mapping(syscalls, "setegid", 0x20000b6
    add_syscall_mapping(syscalls, "seteuid", 0x20000b7
    add_syscall_mapping(syscalls, "sigreturn", 0x20000b8
    
    Note: Thread operations
    add_syscall_mapping(syscalls, "thread_selfid", 0x20000ba
    add_syscall_mapping(syscalls, "fdatasync", 0x20000bb
    add_syscall_mapping(syscalls, "stat", 0x20000bc
    add_syscall_mapping(syscalls, "fstat", 0x20000bd
    add_syscall_mapping(syscalls, "lstat", 0x20000be
    add_syscall_mapping(syscalls, "pathconf", 0x20000bf
    add_syscall_mapping(syscalls, "fpathconf", 0x20000c0
    add_syscall_mapping(syscalls, "getrlimit", 0x20000c2
    add_syscall_mapping(syscalls, "setrlimit", 0x20000c3
    add_syscall_mapping(syscalls, "getdirentries", 0x20000c4
    add_syscall_mapping(syscalls, "mmap", 0x20000c5
    add_syscall_mapping(syscalls, "lseek", 0x20000c7
    add_syscall_mapping(syscalls, "truncate", 0x20000c8
    add_syscall_mapping(syscalls, "ftruncate", 0x20000c9
    add_syscall_mapping(syscalls, "sysctl", 0x20000ca
    add_syscall_mapping(syscalls, "mlock", 0x20000cb
    add_syscall_mapping(syscalls, "munlock", 0x20000cc
    add_syscall_mapping(syscalls, "undelete", 0x20000cd
    
    Note: kqueue event system (high-performance I/O)
    add_syscall_mapping(syscalls, "kqueue", 0x2000170  Note: Create kernel event queue
    add_syscall_mapping(syscalls, "kevent", 0x2000171  Note: Register/wait for events
    add_syscall_mapping(syscalls, "kevent64", 0x2000172  Note: 64-bit kevent
    
    Note: Grand Central Dispatch support
    add_syscall_mapping(syscalls, "workq_open", 0x2000176
    add_syscall_mapping(syscalls, "workq_kernreturn", 0x2000177
    
    Note: Process/thread control
    add_syscall_mapping(syscalls, "poll", 0x20000e6
    add_syscall_mapping(syscalls, "sysctlbyname", 0x2000112
    add_syscall_mapping(syscalls, "sem_open", 0x2000118
    add_syscall_mapping(syscalls, "sem_close", 0x2000119
    add_syscall_mapping(syscalls, "sem_unlink", 0x200011a
    add_syscall_mapping(syscalls, "sem_wait", 0x200011b
    add_syscall_mapping(syscalls, "sem_trywait", 0x200011c
    add_syscall_mapping(syscalls, "sem_post", 0x200011d
    add_syscall_mapping(syscalls, "sem_getvalue", 0x200011e
    add_syscall_mapping(syscalls, "sem_init", 0x200011f
    add_syscall_mapping(syscalls, "sem_destroy", 0x2000120
    
    Note: Shared memory
    add_syscall_mapping(syscalls, "shm_open", 0x2000122
    add_syscall_mapping(syscalls, "shm_unlink", 0x2000123
    
    Note: POSIX spawn
    add_syscall_mapping(syscalls, "posix_spawn", 0x20000f4
    
    Note: Guarded file descriptors
    add_syscall_mapping(syscalls, "guarded_open_np", 0x2000184
    add_syscall_mapping(syscalls, "guarded_close_np", 0x2000185
    add_syscall_mapping(syscalls, "guarded_kqueue_np", 0x2000186
    add_syscall_mapping(syscalls, "guarded_pwrite_np", 0x2000187
    add_syscall_mapping(syscalls, "guarded_write_np", 0x2000188
    
    Note: Cloning/copying file descriptors
    add_syscall_mapping(syscalls, "clonefileat", 0x20001d6
    
    Note: macOS specific
    add_syscall_mapping(syscalls, "getattrlist", 0x20000dc
    add_syscall_mapping(syscalls, "setattrlist", 0x20000dd
    add_syscall_mapping(syscalls, "getdirentriesattr", 0x20000de
    add_syscall_mapping(syscalls, "exchangedata", 0x20000df
    add_syscall_mapping(syscalls, "searchfs", 0x20000e1
    add_syscall_mapping(syscalls, "copyfile", 0x20000e2
    
    Return syscalls

Process called "get_darwin_syscall_prefix" returns Integer:
    Note: Return 0x2000000 prefix for x86_64
    Note: This distinguishes Unix syscalls from Mach traps
    
    Return 0x2000000

Note: =====================================================================
Note: CALLING CONVENTION
Note: =====================================================================

Process called "get_parameter_registers" returns Internals.InternalArray:
    Note: Darwin x86_64 uses System V AMD64 ABI like Linux
    
    Let registers be Internals.create_internal_array(6)
    Internals.internal_array_add(registers, Internals.string_to_ptr("rdi"))  Note: First argument
    Internals.internal_array_add(registers, Internals.string_to_ptr("rsi"))  Note: Second argument
    Internals.internal_array_add(registers, Internals.string_to_ptr("rdx"))  Note: Third argument
    Internals.internal_array_add(registers, Internals.string_to_ptr("r10"))  Note: Fourth argument (not rcx!)
    Internals.internal_array_add(registers, Internals.string_to_ptr("r8"))   Note: Fifth argument
    Internals.internal_array_add(registers, Internals.string_to_ptr("r9"))   Note: Sixth argument
    
    Return registers

Process called "get_return_register" returns String:
    Note: Darwin returns values in RAX
    Note: Carry flag indicates error
    
    Return "rax"

Process called "get_clobber_list" returns Internals.InternalArray:
    Note: Registers modified by syscall on Darwin x86_64
    
    Let clobbers be Internals.create_internal_array(8)
    Internals.internal_array_add(clobbers, Internals.string_to_ptr("rcx"))  Note: Used by syscall instruction
    Internals.internal_array_add(clobbers, Internals.string_to_ptr("r11"))  Note: Used to save rflags
    Internals.internal_array_add(clobbers, Internals.string_to_ptr("memory"))  Note: Memory barrier
    Internals.internal_array_add(clobbers, Internals.string_to_ptr("cc"))  Note: Condition codes
    
    Return clobbers

Process called "get_syscall_prefix" returns Integer:
    Note: Return 0x2000000 for x86_64 Darwin
    Note: ARM64 uses 0x2000000 on macOS too
    Note: Distinguishes Unix syscalls from Mach traps
    
    Return 0x2000000

Note: =====================================================================
Note: KQUEUE EVENT SYSTEM
Note: =====================================================================

Process called "create_kqueue" returns Integer:
    Note: Create kernel event queue for high-performance I/O
    
    Note: kqueue syscall is 0x2000170
    External runa_syscall0(syscall_num as Integer) returns Integer
    
    Let kq_fd be runa_syscall0(0x2000170)
    
    If kq_fd is less than 0:
        Throw Errors.create_error("SystemError", "Failed to create kqueue")
    End If
    
    Return kq_fd

Process called "register_kevent" that takes kq as Integer, event as KqueueEvent returns Boolean:
    Note: Register event with kqueue for monitoring
    
    Note: kevent syscall is 0x2000171
    External runa_syscall6(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer, p4 as Integer, p5 as Integer, p6 as Integer) returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External write_64bit_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    External write_32bit_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    External write_16bit_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    
    Note: kevent structure is 64 bytes on Darwin x86_64
    Let kevent_size be 64
    Let kevent_buffer be allocate_buffer(kevent_size)
    
    Note: Fill kevent structure
    write_64bit_at(kevent_buffer, 0, event.ident)   Note: ident
    write_16bit_at(kevent_buffer, 8, get_filter_value(event.filter))  Note: filter
    write_16bit_at(kevent_buffer, 10, event.flags)  Note: flags
    write_32bit_at(kevent_buffer, 12, event.fflags) Note: fflags
    write_64bit_at(kevent_buffer, 16, event.data)   Note: data
    write_64bit_at(kevent_buffer, 24, event.udata)  Note: udata
    
    Note: Register the event (changelist=1, eventlist=0, timeout=NULL)
    Let result be runa_syscall6(0x2000171, kq, kevent_buffer.address, 1, 0, 0, 0)
    
    free_buffer(kevent_buffer.address, kevent_size)
    
    Return result is greater than or equal to 0

Process called "wait_for_kevents" that takes kq as Integer, timeout as Optional[Integer] returns Internals.InternalArray:
    Note: Wait for events on kqueue
    
    External runa_syscall6(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer, p4 as Integer, p5 as Integer, p6 as Integer) returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External read_64bit_at(buffer as Buffer, offset as Integer) returns Integer
    External read_32bit_at(buffer as Buffer, offset as Integer) returns Integer
    External read_16bit_at(buffer as Buffer, offset as Integer) returns Integer
    External write_64bit_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    
    Note: Allocate buffer for up to 64 events
    Let max_events be 64
    Let kevent_size be 64
    Let eventlist_size be max_events multiplied by kevent_size
    Let eventlist_buffer be allocate_buffer(eventlist_size)
    
    Note: Setup timeout if provided
    Let timeout_ptr be 0
    If timeout.is_some():
        Let timeout_buffer be allocate_buffer(16)  Note: struct timespec
        Let timeout_val be timeout.unwrap()
        write_64bit_at(timeout_buffer, 0, timeout_val divided by 1000)  Note: seconds
        write_64bit_at(timeout_buffer, 8, (timeout_val modulo 1000) multiplied by 1000000)  Note: nanoseconds
        Set timeout_ptr to timeout_buffer.address
    End If
    
    Note: Wait for events (changelist=0, eventlist=buffer, timeout)
    Let num_events be runa_syscall6(0x2000171, kq, 0, 0, eventlist_buffer.address, max_events, timeout_ptr)
    
    Let events be Internals.create_internal_array(64)
    
    If num_events is greater than 0:
        Let i be 0
        While i is less than num_events:
            Let offset be i multiplied by kevent_size
            
            Let event be KqueueEvent()
            Set event.ident to read_64bit_at(eventlist_buffer, offset)
            Set event.filter to get_filter_name(read_16bit_at(eventlist_buffer, offset plus 8))
            Set event.flags to read_16bit_at(eventlist_buffer, offset plus 10)
            Set event.fflags to read_32bit_at(eventlist_buffer, offset plus 12)
            Set event.data to read_64bit_at(eventlist_buffer, offset plus 16)
            Set event.udata to read_64bit_at(eventlist_buffer, offset plus 24)
            
            Internals.internal_array_add(events, event)
            Set i to i plus 1
        End While
    End If
    
    free_buffer(eventlist_buffer.address, eventlist_size)
    If timeout_ptr is not equal to 0:
        free_buffer(timeout_ptr, 16)
    End If
    
    Return events

Note: =====================================================================
Note: MACH PORTS AND IPC
Note: =====================================================================

Process called "allocate_mach_port" that takes right_type as String returns MachPort:
    Note: Allocate Mach port with specified rights
    
    Note: mach_port_allocate trap is -26 (0xffffffe6)
    External runa_syscall3(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer) returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External read_32bit_at(buffer as Buffer, offset as Integer) returns Integer
    External write_32bit_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    
    Note: Get current task port (mach_task_self trap is -28)
    Let task_port be runa_syscall0(0xffffffe4)  Note: -28 as unsigned
    
    Note: Determine right type value
    Let right_value be 0
    If right_type is equal to "RECEIVE":
        Set right_value to 1  Note: MACH_PORT_RIGHT_RECEIVE
    Otherwise right_type is equal to "SEND":
        Set right_value to 0  Note: MACH_PORT_RIGHT_SEND
    Otherwise right_type is equal to "SEND_ONCE":
        Set right_value to 2  Note: MACH_PORT_RIGHT_SEND_ONCE
    End If
    
    Note: Allocate buffer for port name
    Let port_buffer be allocate_buffer(4)
    
    Note: Call mach_port_allocate
    Let result be runa_syscall3(0xffffffe6, task_port, right_value, port_buffer.address)
    
    If result is not equal to 0:
        free_buffer(port_buffer.address, 4)
        Throw Errors.create_error("MachError", "Failed to allocate Mach port")
    End If
    
    Let port_name be read_32bit_at(port_buffer, 0)
    free_buffer(port_buffer.address, 4)
    
    Let port be MachPort()
    Set port.port_name to port_name
    Set port.port_rights to right_value
    Set port.port_type to right_type
    Set port.queue_limit to 256  Note: Default queue limit
    
    Return port

Process called "send_mach_message" that takes port as MachPort, message as Internals.InternalMap returns Boolean:
    Note: Send Mach message through port
    
    Note: mach_msg trap is -31 (0xffffffe1)
    External runa_syscall7(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer, p4 as Integer, p5 as Integer, p6 as Integer, p7 as Integer) returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External write_32bit_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    External string_to_bytes(str as String) returns Internals.InternalArray
    External write_byte_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    
    Note: Calculate message size
    Let header_size be 24  Note: mach_msg_header_t
    Let body_size be 256  Note: Space for message data
    Let total_size be header_size plus body_size
    
    Let msg_buffer be allocate_buffer(total_size)
    
    Note: Fill mach_msg_header_t
    write_32bit_at(msg_buffer, 0, 0x80000000)  Note: MACH_MSGH_BITS_REMOTE(SEND)
    write_32bit_at(msg_buffer, 4, total_size)  Note: msgh_size
    write_32bit_at(msg_buffer, 8, port.port_name)  Note: msgh_remote_port
    write_32bit_at(msg_buffer, 12, 0)  Note: msgh_local_port (MACH_PORT_NULL)
    write_32bit_at(msg_buffer, 16, 0)  Note: msgh_voucher_port
    write_32bit_at(msg_buffer, 20, 1001)  Note: msgh_id (arbitrary message ID)
    
    Note: Add message body if present
    If message.contains_key("data"):
        Let data_str be message["data"] as String
        Let data_bytes be string_to_bytes(data_str)
        Let i be 0
        While i is less than data_bytes.length() and i is less than body_size:
            write_byte_at(msg_buffer, header_size plus i, data_bytes[i])
            Set i to i plus 1
        End While
    End If
    
    Note: Send message (MACH_SEND_MSG = 1)
    Let send_result be runa_syscall7(0xffffffe1, msg_buffer.address, 1, 0, total_size, 0, 0, 0)
    
    free_buffer(msg_buffer.address, total_size)
    
    Return send_result is equal to 0

Process called "receive_mach_message" that takes port as MachPort, timeout as Optional[Integer] returns Internals.InternalMap:
    Note: Receive Mach message from port
    
    External runa_syscall7(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer, p4 as Integer, p5 as Integer, p6 as Integer, p7 as Integer) returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External read_32bit_at(buffer as Buffer, offset as Integer) returns Integer
    External read_byte_at(buffer as Buffer, offset as Integer) returns Integer
    External bytes_to_string(bytes as List[Integer]) returns String
    
    Note: Allocate receive buffer
    Let max_size be 512
    Let msg_buffer be allocate_buffer(max_size)
    
    Note: Setup receive options
    Let options be 2  Note: MACH_RCV_MSG
    Let timeout_val be 0
    If timeout.is_some():
        Set options to options plus 256  Note: MACH_RCV_TIMEOUT
        Set timeout_val to timeout.unwrap()
    End If
    
    Note: Receive message
    Let recv_result be runa_syscall7(0xffffffe1, msg_buffer.address, options, max_size, 0, port.port_name, timeout_val, 0)
    
    Let result be Internals.create_internal_map()
    
    If recv_result is equal to 0:
        Note: Parse message header
        Set result["bits", read_32bit_at(msg_buffer, 0)
        Set result["size", read_32bit_at(msg_buffer, 4)
        Set result["remote_port", read_32bit_at(msg_buffer, 8)
        Set result["local_port", read_32bit_at(msg_buffer, 12)
        Set result["id", read_32bit_at(msg_buffer, 20)
        
        Note: Extract message body
        Let header_size be 24
        Let body_size be result["size"] as Integer minus header_size
        If body_size is greater than 0:
            Let body_bytes be Internals.create_internal_array(1024)
            Let i be 0
            While i is less than body_size:
                Internals.internal_array_add(body_bytes, read_byte_at(msg_buffer, header_size plus i))
                Set i to i plus 1
            End While
            Set result["data", bytes_to_string(body_bytes)
        End If
        
        Set result["success", true
    Otherwise:
        Set result["success", false
        Set result["error", recv_result
    End If
    
    free_buffer(msg_buffer.address, max_size)
    
    Return result

Note: =====================================================================
Note: XPC COMMUNICATION
Note: =====================================================================

Process called "create_xpc_connection" that takes service_name as String returns XPCConnection:
    Note: Create XPC connection through launchd bootstrap
    
    External runa_syscall3(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer) returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External write_32bit_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    External read_32bit_at(buffer as Buffer, offset as Integer) returns Integer
    
    Note: Bootstrap port lookup via launchd
    Let bootstrap_port be lookup_launchd_service(service_name)
    
    If bootstrap_port is equal to 0:
        Throw Errors.create_error("XPCError", "Service not found in launchd")
    End If
    
    Note: Allocate local reply port for bidirectional communication
    Let reply_port be allocate_mach_port("RECEIVE")
    
    Let connection be XPCConnection()
    Set connection.connection_name to service_name
    Set connection.connection_type to "XPC"
    Set connection.peer_pid to 0  Note: Will be discovered on handshake
    Set connection.peer_entitlements to Internals.create_internal_array(8)
    Set connection.is_privileged to false
    Set connection.reply_port to reply_port.port_name  Note: Store reply port
    Set connection.service_port to bootstrap_port      Note: Store service port
    
    Note: Perform XPC handshake to establish connection
    Let handshake_msg be Internals.create_internal_map()
    Set handshake_msg["type", "xpc_handshake"
    Set handshake_msg["client_pid", getpid()
    Set handshake_msg["reply_port", reply_port.port_name
    
    Note: Send handshake through Mach messaging
    Let handshake_port be MachPort()
    Set handshake_port.port_name to bootstrap_port
    Set handshake_port.port_rights to 0  Note: SEND right
    Set handshake_port.port_type to "SEND"
    Set handshake_port.queue_limit to 0
    
    If not send_mach_message(handshake_port, handshake_msg):
        Throw Errors.create_error("XPCError", "Failed to establish XPC connection")
    End If
    
    Note: Wait for handshake response
    Let response be receive_mach_message(reply_port, Optional[Integer].Some(5000))
    
    If response["success"] as Boolean:
        Set connection.peer_pid to response["server_pid"] as Integer
        If response.contains_key("privileged"):
            Set connection.is_privileged to response["privileged"] as Boolean
        End If
    End If
    
    Return connection

Process called "send_xpc_message" that takes conn as XPCConnection, message as Internals.InternalMap returns Boolean:
    Note: Send XPC message through established Mach port connection
    
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External write_32bit_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    External write_64bit_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    External write_byte_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    
    Note: Use the service port stored in the connection
    Let service_port be conn.service_port
    
    If service_port is equal to 0:
        Return false  Note: Connection not established
    End If
    
    Note: Create XPC message with binary plist format
    Let msg_buffer be serialize_xpc_message(message)
    
    Note: Create Mach message wrapper for XPC data
    Let mach_msg_size be 512  Note: Sufficient for most XPC messages
    Let mach_buffer be allocate_buffer(mach_msg_size)
    
    Note: Fill mach_msg_header_t for XPC transport
    write_32bit_at(mach_buffer, 0, 0x80001513)  Note: MACH_MSGH_BITS with XPC flags
    write_32bit_at(mach_buffer, 4, mach_msg_size)  Note: Total message size
    write_32bit_at(mach_buffer, 8, service_port)  Note: Destination port
    write_32bit_at(mach_buffer, 12, get_reply_port(conn))  Note: Reply port for responses
    write_32bit_at(mach_buffer, 16, 0)  Note: Voucher port (unused)
    write_32bit_at(mach_buffer, 20, 0x10000000)  Note: XPC message ID marker
    
    Note: Add XPC descriptor
    write_32bit_at(mach_buffer, 24, 0x58504300)  Note: 'XPC\0' magic
    write_32bit_at(mach_buffer, 28, 1)  Note: XPC version
    write_64bit_at(mach_buffer, 32, msg_buffer.address)  Note: Pointer to XPC data
    write_64bit_at(mach_buffer, 40, msg_buffer.size)  Note: XPC data size
    
    Note: Send via Mach messaging
    External runa_syscall7(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer, p4 as Integer, p5 as Integer, p6 as Integer, p7 as Integer) returns Integer
    
    Note: mach_msg trap for sending
    Let send_result be runa_syscall7(0xffffffe1, mach_buffer.address, 1, 0, mach_msg_size, 0, 0, 0)
    
    free_buffer(mach_buffer.address, mach_msg_size)
    free_buffer(msg_buffer.address, msg_buffer.size)
    
    Return send_result is equal to 0

Note: =====================================================================
Note: SECURITY AND SANDBOXING
Note: =====================================================================

Process called "check_entitlement" that takes entitlement as String returns Boolean:
    Note: Check if current process has specified entitlement
    
    Note: csops syscall is 0x20000a9 for code signing operations
    External runa_syscall4(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer, p4 as Integer) returns Integer
    External getpid() returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External read_32bit_at(buffer as Buffer, offset as Integer) returns Integer
    External bytes_contains_string(buffer as Buffer, size as Integer, search as String) returns Boolean
    
    Note: CS_OPS_ENTITLEMENTS_BLOB operation is 7
    Let CS_OPS_ENTITLEMENTS_BLOB be 7
    
    Note: First get size of entitlements blob
    Let size_buffer be allocate_buffer(8)
    Let pid be getpid()
    
    Let size_result be runa_syscall4(0x20000a9, pid, CS_OPS_ENTITLEMENTS_BLOB, 0, size_buffer.address)
    
    If size_result is not equal to 0:
        free_buffer(size_buffer.address, 8)
        Return false  Note: No entitlements or error
    End If
    
    Let blob_size be read_32bit_at(size_buffer, 0)
    free_buffer(size_buffer.address, 8)
    
    If blob_size is equal to 0:
        Return false  Note: No entitlements
    End If
    
    Note: Allocate buffer and get entitlements
    Let entitlements_buffer be allocate_buffer(blob_size)
    Let get_result be runa_syscall4(0x20000a9, pid, CS_OPS_ENTITLEMENTS_BLOB, entitlements_buffer.address, blob_size)
    
    If get_result is not equal to 0:
        free_buffer(entitlements_buffer.address, blob_size)
        Return false
    End If
    
    Note: Parse entitlements plist and check for specific entitlement
    Let has_entitlement be parse_entitlements_blob(entitlements_buffer, blob_size, entitlement)
    
    free_buffer(entitlements_buffer.address, blob_size)
    
    Return has_entitlement

Process called "enter_sandbox" that takes profile as String returns Boolean:
    Note: Enter App Sandbox with specified profile
    Note: This is a one-way operation - cannot exit sandbox
    
    Note: sandbox_init syscall is 0x200017a
    External runa_syscall3(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer) returns Integer
    External allocate_cstring(str as String) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External string_length(str as String) returns Integer
    
    Note: Convert profile to C string
    Let profile_cstr be allocate_cstring(profile)
    Let profile_len be string_length(profile) plus 1
    
    Note: sandbox_init flags
    Let SANDBOX_NAMED be 1  Note: Use named profile
    
    Note: Error buffer for sandbox errors
    Let error_buffer be allocate_buffer(256)
    
    Note: Enter sandbox
    Let result be runa_syscall3(0x200017a, profile_cstr.address, SANDBOX_NAMED, error_buffer.address)
    
    free_buffer(profile_cstr.address, profile_len)
    free_buffer(error_buffer.address, 256)
    
    Return result is equal to 0

Process called "verify_code_signature" that takes path as String returns DarwinSecurityContext:
    Note: Verify code signature and extract security context
    
    External stat_file(path as String) returns StatResult
    External open_file(path as String, flags as Integer) returns Integer
    External close_file(fd as Integer) returns Integer
    External runa_syscall4(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer, p4 as Integer) returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External read_32bit_at(buffer as Buffer, offset as Integer) returns Integer
    External extract_string_from_blob(buffer as Buffer, size as Integer, key as String) returns String
    
    Note: Open file to get file descriptor
    Let fd be open_file(path, 0)  Note: O_RDONLY
    If fd is less than 0:
        Throw Errors.create_error("FileError", "Cannot open file for signature verification")
    End If
    
    Note: CS_OPS_STATUS operation is 0
    Let CS_OPS_STATUS be 0
    Let status_buffer be allocate_buffer(4)
    
    Note: Check code signing status
    Let status_result be runa_syscall4(0x20000a9, fd, CS_OPS_STATUS, status_buffer.address, 4)
    
    Let status be 0
    If status_result is equal to 0:
        Set status to read_32bit_at(status_buffer, 0)
    End If
    free_buffer(status_buffer.address, 4)
    
    Note: Create security context
    Let context be DarwinSecurityContext()
    Set context.entitlements to Internals.create_internal_array(16)
    Set context.sandbox_profile to "none"
    Set context.code_signature to "unsigned"
    Set context.team_id to "unknown"
    Set context.notarization_ticket to Optional[String].None()
    Set context.hardened_runtime to false
    
    Note: Check signature status flags
    If status is not equal to 0:
        Note: CS_VALID flag is 0x0001
        If (status bitwise_and 0x0001) is not equal to 0:
            Set context.code_signature to "valid"
        End If
        
        Note: CS_RUNTIME flag is 0x10000 (hardened runtime)
        If (status bitwise_and 0x10000) is not equal to 0:
            Set context.hardened_runtime to true
        End If
        
        Note: CS_NOTARIZED flag is 0x20000
        If (status bitwise_and 0x20000) is not equal to 0:
            Set context.notarization_ticket to Optional[String].Some("notarized")
        End If
        
        Note: Extract team ID from code signature
        Let team_id be extract_team_id_from_signature(fd)
        If not team_id is equal to "":
            Set context.team_id to team_id
        End If
    End If
    
    close_file(fd)
    
    Return context

Note: =====================================================================
Note: HYPERVISOR FRAMEWORK
Note: =====================================================================

Process called "create_hypervisor_vm" returns Integer:
    Note: Create virtual machine using Hypervisor.framework
    Note: Requires com.apple.vm.hypervisor entitlement
    
    Note: hv_vm_create syscall (private, undocumented)
    Note: hv_vm_create is not a direct syscall but uses IOKit
    External runa_syscall6(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer, p4 as Integer, p5 as Integer, p6 as Integer) returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External read_32bit_at(buffer as Buffer, offset as Integer) returns Integer
    
    Note: HV_VM_DEFAULT flag is 0
    Let HV_VM_DEFAULT be 0
    
    Note: Allocate VM ID buffer
    Let vm_buffer be allocate_buffer(4)
    
    Note: Use IOKit user client trap to create VM
    Note: IOKit trap is 0xffffffe8 with HV service selector
    Let hv_service_selector be 0x100  Note: Hypervisor service
    Let hv_create_vm_selector be 0x0  Note: Create VM operation
    Let result be runa_syscall6(0xffffffe8, hv_service_selector, hv_create_vm_selector, vm_buffer.address, HV_VM_DEFAULT, 0, 0)
    
    If result is less than 0:
        free_buffer(vm_buffer.address, 4)
        Throw Errors.create_error("HypervisorError", "Failed to create VM - check entitlements")
    End If
    
    Let vm_id be result
    free_buffer(vm_buffer.address, 4)
    
    Return vm_id

Process called "map_vm_memory" that takes vm_id as Integer, guest_addr as Integer, host_addr as Integer, size as Integer returns Boolean:
    Note: Map host memory into guest VM address space
    
    Note: hv_vm_map syscall (private)
    External runa_syscall5(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer, p4 as Integer, p5 as Integer) returns Integer
    
    Note: Memory flags
    Let HV_MEMORY_READ be 1
    Let HV_MEMORY_WRITE be 2
    Let HV_MEMORY_EXEC be 4
    Let flags be HV_MEMORY_READ plus HV_MEMORY_WRITE plus HV_MEMORY_EXEC
    
    Note: Use IOKit trap for VM memory mapping
    Let hv_service_selector be 0x100  Note: Hypervisor service
    Let hv_map_memory_selector be 0x1  Note: Map memory operation
    Let result be runa_syscall6(0xffffffe8, hv_service_selector, hv_map_memory_selector, vm_id, guest_addr, host_addr, size)
    
    Return result is equal to 0

Process called "run_vcpu" that takes vm_id as Integer, vcpu_id as Integer returns Internals.InternalMap:
    Note: Run virtual CPU until VM exit
    
    External runa_syscall2(syscall_num as Integer, p1 as Integer, p2 as Integer) returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External read_32bit_at(buffer as Buffer, offset as Integer) returns Integer
    External read_64bit_at(buffer as Buffer, offset as Integer) returns Integer
    
    Note: Allocate buffer for exit reason
    Let exit_buffer be allocate_buffer(256)
    
    Note: Use IOKit trap for VCPU execution
    Let hv_service_selector be 0x100  Note: Hypervisor service  
    Let hv_run_vcpu_selector be 0x2  Note: Run VCPU operation
    Let result be runa_syscall6(0xffffffe8, hv_service_selector, hv_run_vcpu_selector, vm_id, vcpu_id, exit_buffer.address, 0)
    
    Let exit_info be Internals.create_internal_map()
    
    If result is equal to 0:
        Note: Parse exit reason
        Set exit_info["reason", read_32bit_at(exit_buffer, 0)
        Set exit_info["rip", read_64bit_at(exit_buffer, 8)
        Set exit_info["rax", read_64bit_at(exit_buffer, 16)
        Set exit_info["success", true
    Otherwise:
        Set exit_info["success", false
        Set exit_info["error", result
    End If
    
    free_buffer(exit_buffer.address, 256)
    
    Return exit_info

Note: =====================================================================
Note: ENDPOINT SECURITY
Note: =====================================================================

Process called "create_es_client" that takes events as Internals.InternalArray returns Integer:
    Note: Create Endpoint Security client for system monitoring
    Note: Requires com.apple.developer.endpoint-security.client entitlement
    
    External runa_syscall2(syscall_num as Integer, p1 as Integer, p2 as Integer) returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External write_32bit_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    
    Note: Map event names to event types
    Let event_mask be 0
    For Each event in events:
        If event is equal to "ES_EVENT_TYPE_AUTH_EXEC":
            Set event_mask to event_mask plus 1
        Otherwise event is equal to "ES_EVENT_TYPE_AUTH_OPEN":
            Set event_mask to event_mask plus 2
        Otherwise event is equal to "ES_EVENT_TYPE_AUTH_KEXTLOAD":
            Set event_mask to event_mask plus 4
        Otherwise event is equal to "ES_EVENT_TYPE_NOTIFY_FORK":
            Set event_mask to event_mask plus 8
        Otherwise event is equal to "ES_EVENT_TYPE_NOTIFY_EXIT":
            Set event_mask to event_mask plus 16
        End If
    End For
    
    Note: Create client configuration
    Let config_buffer be allocate_buffer(32)
    write_32bit_at(config_buffer, 0, event_mask)
    write_32bit_at(config_buffer, 4, 1000)  Note: Queue size
    
    Note: ES uses IOKit user client for communication
    Let es_service_selector be 0x200  Note: Endpoint Security service
    Let es_create_client_selector be 0x0  Note: Create client operation
    Let client_id be runa_syscall6(0xffffffe8, es_service_selector, es_create_client_selector, config_buffer.address, 32, 0, 0)
    
    free_buffer(config_buffer.address, 32)
    
    If client_id is less than 0:
        Throw Errors.create_error("EndpointSecurityError", "Failed to create ES client")
    End If
    
    Return client_id

Process called "respond_to_es_event" that takes client_id as Integer, event_id as Integer, allow as Boolean returns Boolean:
    Note: Respond to Endpoint Security auth event
    Note: Must respond within deadline to avoid system hang
    
    External runa_syscall3(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer) returns Integer
    
    Note: ES_AUTH_RESULT_ALLOW is 0, ES_AUTH_RESULT_DENY is 1
    Let auth_result be 1  Note: Default deny
    If allow:
        Set auth_result to 0
    End If
    
    Note: Send ES response via IOKit
    Let es_service_selector be 0x200  Note: Endpoint Security service
    Let es_respond_selector be 0x1  Note: Respond to event operation
    Let result be runa_syscall6(0xffffffe8, es_service_selector, es_respond_selector, client_id, event_id, auth_result, 0)
    
    Return result is equal to 0

Note: =====================================================================
Note: ERROR HANDLING
Note: =====================================================================

Process called "is_error_return" that takes value as Integer, carry_flag as Boolean returns Boolean:
    Note: Check if syscall returned error on Darwin
    Note: Darwin sets carry flag on error
    Note: Error value is negative errno
    
    Note: On Darwin x86_64, errors are indicated by:
    Note: 1. Carry flag set
    Note: 2. RAX contains errno (positive value)
    
    If carry_flag:
        Return true  Note: Error occurred
    End If
    
    Note: Also check for negative return values (some syscalls)
    If value is less than 0 and value is greater than -4096:
        Return true  Note: Negative errno range
    End If
    
    Return false

Process called "extract_errno" that takes error_value as Integer returns Integer:
    Note: Extract errno from error return value
    
    Note: If value is already positive, it's the errno
    If error_value is greater than 0:
        Return error_value
    End If
    
    Note: If negative, negate to get errno
    If error_value is less than 0:
        Return 0 minus error_value
    End If
    
    Return 0  Note: No error

Note: =====================================================================
Note: PLATFORM-SPECIFIC FEATURES
Note: =====================================================================

Process called "get_dispatch_queue_syscalls" returns Dictionary[String, Integer]:
    Note: Grand Central Dispatch syscalls for async work
    
    Let syscalls be Internals.create_internal_map()
    
    Note: Workqueue syscalls
    add_syscall_mapping(syscalls, "workq_open", 0x2000176
    add_syscall_mapping(syscalls, "workq_kernreturn", 0x2000177
    add_syscall_mapping(syscalls, "workq_ops", 0x2000178
    
    Note: Thread workqueue syscalls
    add_syscall_mapping(syscalls, "thread_selfid", 0x20000ba
    add_syscall_mapping(syscalls, "bsdthread_create", 0x2000168
    add_syscall_mapping(syscalls, "bsdthread_terminate", 0x2000169
    add_syscall_mapping(syscalls, "bsdthread_register", 0x200016e
    
    Note: Kevent workqueue integration
    add_syscall_mapping(syscalls, "kevent_qos", 0x2000173
    add_syscall_mapping(syscalls, "kevent_id", 0x2000174
    
    Return syscalls

Process called "get_metal_syscalls" returns Dictionary[String, Integer]:
    Note: Metal GPU framework syscalls
    Note: These are accessed through IOKit, not direct syscalls
    
    Let syscalls be Internals.create_internal_map()
    
    Note: IOKit syscalls used by Metal
    add_syscall_mapping(syscalls, "iokit_user_client_trap", 0xffffffe8  Note: Negative trap number
    add_syscall_mapping(syscalls, "mach_port_insert_right", 0xffffffe9
    add_syscall_mapping(syscalls, "mach_port_extract_right", 0xffffffea
    
    Note: GPU memory management uses IOKit traps with Metal service selectors
    add_syscall_mapping(syscalls, "iokit_alloc_memory", 0xffffffe8  Note: IOKit trap
    add_syscall_mapping(syscalls, "iokit_map_memory", 0xffffffe8    Note: IOKit trap
    add_syscall_mapping(syscalls, "iokit_unmap_memory", 0xffffffe8  Note: IOKit trap
    
    Return syscalls

Process called "get_unix_syscalls" returns Dictionary[String, Integer]:
    Note: Return BSD-compatible Unix syscalls with Darwin prefix
    
    Note: Most Unix syscalls are already in main table
    Note: This returns commonly used subset
    Let syscalls be Internals.create_internal_map()
    
    Note: File I/O
    add_syscall_mapping(syscalls, "open", 0x2000005)
    add_syscall_mapping(syscalls, "close", 0x2000006)
    add_syscall_mapping(syscalls, "read", 0x2000003)
    add_syscall_mapping(syscalls, "write", 0x2000004)
    add_syscall_mapping(syscalls, "lseek", 0x20000c7
    add_syscall_mapping(syscalls, "fstat", 0x20000bd
    add_syscall_mapping(syscalls, "stat", 0x20000bc
    add_syscall_mapping(syscalls, "lstat", 0x20000be
    add_syscall_mapping(syscalls, "fcntl", 0x200005c
    add_syscall_mapping(syscalls, "ioctl", 0x2000036
    
    Note: Process control
    add_syscall_mapping(syscalls, "fork", 0x2000002)
    add_syscall_mapping(syscalls, "execve", 0x200003b
    add_syscall_mapping(syscalls, "exit", 0x2000001)
    add_syscall_mapping(syscalls, "wait4", 0x2000007)
    add_syscall_mapping(syscalls, "kill", 0x2000025
    add_syscall_mapping(syscalls, "getpid", 0x2000014
    add_syscall_mapping(syscalls, "getppid", 0x2000027
    
    Note: Memory management
    add_syscall_mapping(syscalls, "mmap", 0x20000c5
    add_syscall_mapping(syscalls, "munmap", 0x2000049
    add_syscall_mapping(syscalls, "mprotect", 0x200004a
    add_syscall_mapping(syscalls, "madvise", 0x200004b
    
    Note: Network
    add_syscall_mapping(syscalls, "socket", 0x2000061
    add_syscall_mapping(syscalls, "connect", 0x2000062
    add_syscall_mapping(syscalls, "bind", 0x2000068
    add_syscall_mapping(syscalls, "listen", 0x200006a
    add_syscall_mapping(syscalls, "accept", 0x200001e
    add_syscall_mapping(syscalls, "sendto", 0x2000085
    add_syscall_mapping(syscalls, "recvfrom", 0x200001d
    
    Return syscalls

Process called "get_private_syscalls" returns Dictionary[String, Integer]:
    Note: Apple private/undocumented syscalls
    Note: These may change between macOS versions
    
    Let syscalls be Internals.create_internal_map()
    
    Note: Code signing and security
    add_syscall_mapping(syscalls, "csops", 0x20000a9           Note: Code signing operations
    add_syscall_mapping(syscalls, "csops_audittoken", 0x20000aa Note: With audit token
    
    Note: Sandbox operations
    add_syscall_mapping(syscalls, "sandbox_init", 0x200017a
    add_syscall_mapping(syscalls, "sandbox_free_error", 0x200017b
    add_syscall_mapping(syscalls, "sandbox_check", 0x200017c
    
    Note: Guarded operations
    add_syscall_mapping(syscalls, "guarded_open_np", 0x2000184
    add_syscall_mapping(syscalls, "guarded_close_np", 0x2000185
    add_syscall_mapping(syscalls, "guarded_kqueue_np", 0x2000186
    add_syscall_mapping(syscalls, "guarded_pwrite_np", 0x2000187
    
    Note: Process management extensions
    add_syscall_mapping(syscalls, "proc_info", 0x2000150
    add_syscall_mapping(syscalls, "proc_uuid_policy", 0x20001ac
    add_syscall_mapping(syscalls, "process_policy", 0x2000143
    
    Note: Memory management extensions
    add_syscall_mapping(syscalls, "mmap_extended", 0x20001e3
    add_syscall_mapping(syscalls, "mremap_encrypted", 0x20001e4
    
    Return syscalls

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "get_filter_value" that takes filter_name as String returns Integer:
    Note: Convert kqueue filter name to numeric value
    
    If filter_name is equal to "EVFILT_READ":
        Return -1  Note: EVFILT_READ
    Otherwise filter_name is equal to "EVFILT_WRITE":
        Return -2  Note: EVFILT_WRITE
    Otherwise filter_name is equal to "EVFILT_AIO":
        Return -3  Note: EVFILT_AIO
    Otherwise filter_name is equal to "EVFILT_VNODE":
        Return -4  Note: EVFILT_VNODE
    Otherwise filter_name is equal to "EVFILT_PROC":
        Return -5  Note: EVFILT_PROC
    Otherwise filter_name is equal to "EVFILT_SIGNAL":
        Return -6  Note: EVFILT_SIGNAL
    Otherwise filter_name is equal to "EVFILT_TIMER":
        Return -7  Note: EVFILT_TIMER
    Otherwise filter_name is equal to "EVFILT_MACHPORT":
        Return -8  Note: EVFILT_MACHPORT
    Otherwise filter_name is equal to "EVFILT_FS":
        Return -9  Note: EVFILT_FS
    Otherwise filter_name is equal to "EVFILT_USER":
        Return -10  Note: EVFILT_USER
    Otherwise filter_name is equal to "EVFILT_VM":
        Return -12  Note: EVFILT_VM
    Otherwise:
        Return 0  Note: Unknown filter
    End If

Process called "get_filter_name" that takes filter_value as Integer returns String:
    Note: Convert kqueue filter value to name
    
    If filter_value is equal to -1:
        Return "EVFILT_READ"
    Otherwise filter_value is equal to -2:
        Return "EVFILT_WRITE"
    Otherwise filter_value is equal to -3:
        Return "EVFILT_AIO"
    Otherwise filter_value is equal to -4:
        Return "EVFILT_VNODE"
    Otherwise filter_value is equal to -5:
        Return "EVFILT_PROC"
    Otherwise filter_value is equal to -6:
        Return "EVFILT_SIGNAL"
    Otherwise filter_value is equal to -7:
        Return "EVFILT_TIMER"
    Otherwise filter_value is equal to -8:
        Return "EVFILT_MACHPORT"
    Otherwise filter_value is equal to -9:
        Return "EVFILT_FS"
    Otherwise filter_value is equal to -10:
        Return "EVFILT_USER"
    Otherwise filter_value is equal to -12:
        Return "EVFILT_VM"
    Otherwise:
        Return "EVFILT_UNKNOWN"
    End If

Process called "getpid" returns Integer:
    Note: Get current process ID
    
    External runa_syscall0(syscall_num as Integer) returns Integer
    
    Note: getpid syscall is 0x2000014
    Return runa_syscall0(0x2000014)

Process called "allocate_cstring" that takes str as String returns Buffer:
    Note: Allocate buffer and copy string as C string
    
    External allocate_buffer(size as Integer) returns Buffer
    External write_byte_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    
    Let bytes be ASCII.string_to_bytes(str)
    Let size be bytes.length() plus 1  Note: Include null terminator
    
    Let buffer be allocate_buffer(size)
    
    Let i be 0
    While i is less than bytes.length():
        write_byte_at(buffer, i, bytes[i])
        Set i to i plus 1
    End While
    
    Note: Add null terminator
    write_byte_at(buffer, bytes.length(), 0)
    
    Return buffer

Process called "string_length" that takes str as String returns Integer:
    Note: Get string length
    
    Let bytes be ASCII.string_to_bytes(str)
    Return bytes.length()

Process called "string_to_bytes" that takes str as String returns Internals.InternalArray:
    Note: Convert string to byte array
    
    Return ASCII.string_to_bytes(str)

Process called "bytes_to_string" that takes bytes as Internals.InternalArray returns String:
    Note: Convert byte array to string
    
    Return ASCII.bytes_to_string(bytes)

Process called "bytes_contains_string" that takes buffer as Buffer, size as Integer, search as String returns Boolean:
    Note: Check if buffer contains string
    
    External read_byte_at(buffer as Buffer, offset as Integer) returns Integer
    
    Let search_bytes be ASCII.string_to_bytes(search)
    Let search_len be search_bytes.length()
    
    If search_len is greater than size:
        Return false
    End If
    
    Let i be 0
    While i is less than or equal to (size minus search_len):
        Let found be true
        Let j be 0
        While j is less than search_len:
            Let buffer_byte be read_byte_at(buffer, i plus j)
            If buffer_byte is not equal to search_bytes[j]:
                Set found to false
                Set j to search_len  Note: Break inner loop
            End If
            Set j to j plus 1
        End While
        
        If found:
            Return true
        End If
        
        Set i to i plus 1
    End While
    
    Return false

Process called "extract_string_from_blob" that takes buffer as Buffer, size as Integer, key as String returns String:
    Note: Extract string value from binary blob by key
    
    External read_byte_at(buffer as Buffer, offset as Integer) returns Integer
    
    Note: Simple extraction - look for key followed by value
    Let key_bytes be ASCII.string_to_bytes(key)
    Let key_len be key_bytes.length()
    
    Let i be 0
    While i is less than (size minus key_len):
        Let found be true
        Let j be 0
        While j is less than key_len:
            If read_byte_at(buffer, i plus j) is not equal to key_bytes[j]:
                Set found to false
                Set j to key_len  Note: Break
            End If
            Set j to j plus 1
        End While
        
        If found:
            Note: Found key, extract value after it
            Let start be i plus key_len
            Let value_bytes be Internals.create_internal_array(256)
            Let k be start
            While k is less than size:
                Let byte_val be read_byte_at(buffer, k)
                If byte_val is equal to 0:  Note: Null terminator
                    Set k to size  Note: Break
                Otherwise:
                    Internals.internal_array_add(value_bytes, byte_val)
                End If
                Set k to k plus 1
            End While
            Return ASCII.bytes_to_string(value_bytes)
        End If
        
        Set i to i plus 1
    End While
    
    Return ""  Note: Key not found

Process called "stat_file" that takes path as String returns StatResult:
    Note: Get file statistics
    
    External runa_syscall2(syscall_num as Integer, p1 as Integer, p2 as Integer) returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External read_32bit_at(buffer as Buffer, offset as Integer) returns Integer
    External read_64bit_at(buffer as Buffer, offset as Integer) returns Integer
    
    Let path_cstr be allocate_cstring(path)
    Let stat_buffer be allocate_buffer(144)  Note: struct stat size on Darwin
    
    Note: stat syscall is 0x20000bc
    Let result be runa_syscall2(0x20000bc, path_cstr.address, stat_buffer.address)
    
    Let stat_result be StatResult()
    
    If result is equal to 0:
        Set stat_result.size to read_64bit_at(stat_buffer, 96)  Note: st_size offset
        Set stat_result.mode to read_32bit_at(stat_buffer, 4)   Note: st_mode offset
        Set stat_result.mtime to read_64bit_at(stat_buffer, 48)  Note: st_mtime offset
        Set stat_result.exists to true
    Otherwise:
        Set stat_result.size to 0
        Set stat_result.mode to 0
        Set stat_result.mtime to 0
        Set stat_result.exists to false
    End If
    
    free_buffer(path_cstr.address, string_length(path) plus 1)
    free_buffer(stat_buffer.address, 144)
    
    Return stat_result

Process called "open_file" that takes path as String, flags as Integer returns Integer:
    Note: Open file with specified flags
    
    External runa_syscall3(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer) returns Integer
    
    Let path_cstr be allocate_cstring(path)
    
    Note: open syscall is 0x2000005)
    Let fd be runa_syscall3(0x2000005, path_cstr.address, flags, 0644)  Note: Default permissions
    
    free_buffer(path_cstr.address, string_length(path) plus 1)
    
    Return fd

Process called "close_file" that takes fd as Integer returns Integer:
    Note: Close file descriptor
    
    External runa_syscall1(syscall_num as Integer, p1 as Integer) returns Integer
    
    Note: close syscall is 0x2000006)
    Return runa_syscall1(0x2000006, fd)

Process called "parse_entitlements_blob" that takes buffer as Buffer, size as Integer, entitlement as String returns Boolean:
    Note: Parse entitlements plist blob and check for entitlement
    
    External read_byte_at(buffer as Buffer, offset as Integer) returns Integer
    
    Note: Entitlements are in XML plist format
    Note: Search for <key>entitlement_name</key><true/>
    Let key_pattern be "<key>" joined with entitlement joined with "</key>"
    Let key_bytes be ASCII.string_to_bytes(key_pattern)
    
    Let i be 0
    While i is less than (size minus key_bytes.length() minus 10):
        Let found_key be true
        Let j be 0
        While j is less than key_bytes.length():
            If read_byte_at(buffer, i plus j) is not equal to key_bytes[j]:
                Set found_key to false
                Set j to key_bytes.length()  Note: Break
            End If
            Set j to j plus 1
        End While
        
        If found_key:
            Note: Check for <true/> after the key
            Let true_pattern be ASCII.string_to_bytes("<true/>")
            Let k be i plus key_bytes.length()
            
            Note: Skip whitespace
            While k is less than size:
                Let byte_val be read_byte_at(buffer, k)
                If byte_val is equal to 32 or byte_val is equal to 9 or byte_val is equal to 10 or byte_val is equal to 13:
                    Set k to k plus 1
                Otherwise:
                    Set k to size  Note: Break
                End If
            End While
            
            Note: Check for true tag
            Let found_true be true
            Let m be 0
            While m is less than true_pattern.length() and (k plus m) is less than size:
                If read_byte_at(buffer, k plus m) is not equal to true_pattern[m]:
                    Set found_true to false
                    Set m to true_pattern.length()  Note: Break
                End If
                Set m to m plus 1
            End While
            
            If found_true:
                Return true
            End If
        End If
        
        Set i to i plus 1
    End While
    
    Return false

Process called "extract_team_id_from_signature" that takes fd as Integer returns String:
    Note: Extract team ID from code signature
    
    External runa_syscall4(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer, p4 as Integer) returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External read_byte_at(buffer as Buffer, offset as Integer) returns Integer
    
    Note: CS_OPS_TEAMID operation is 19
    Let CS_OPS_TEAMID be 19
    Let team_buffer be allocate_buffer(256)
    
    Note: Get team ID
    Let result be runa_syscall4(0x20000a9, fd, CS_OPS_TEAMID, team_buffer.address, 256)
    
    Let team_id be ""
    If result is equal to 0:
        Note: Extract team ID string from buffer
        Let team_bytes be Internals.create_internal_array(256)
        Let i be 0
        While i is less than 256:
            Let byte_val be read_byte_at(team_buffer, i)
            If byte_val is equal to 0:
                Set i to 256  Note: Break on null
            Otherwise:
                Internals.internal_array_add(team_bytes, byte_val)
            End If
            Set i to i plus 1
        End While
        
        If team_bytes.length() is greater than 0:
            Set team_id to ASCII.bytes_to_string(team_bytes)
        End If
    End If
    
    free_buffer(team_buffer.address, 256)
    
    Return team_id

Process called "serialize_xpc_value" that takes value as Any returns Internals.InternalArray:
    Note: Serialize any XPC value type to bytes
    
    Note: Determine value type and serialize accordingly
    Note: This handles strings, integers, booleans, etc.
    
    Note: Check if integer
    If value is Integer:
        Let int_val be value as Integer
        Let bytes be Internals.create_internal_array(256)
        Internals.internal_array_add(bytes, 0x10)  Note: Integer marker
        
        Note: Add 8 bytes for 64-bit integer (big-endian)
        Internals.internal_array_add(bytes, (int_val divided by 0x100000000000000) modulo 256)
        Internals.internal_array_add(bytes, (int_val divided by 0x1000000000000) modulo 256)
        Internals.internal_array_add(bytes, (int_val divided by 0x10000000000) modulo 256)
        Internals.internal_array_add(bytes, (int_val divided by 0x100000000) modulo 256)
        Internals.internal_array_add(bytes, (int_val divided by 0x1000000) modulo 256)
        Internals.internal_array_add(bytes, (int_val divided by 0x10000) modulo 256)
        Internals.internal_array_add(bytes, (int_val divided by 0x100) modulo 256)
        Internals.internal_array_add(bytes, int_val modulo 256)
        
        Return bytes
    End If
    
    Note: Check if boolean
    If value is Boolean:
        Let bool_val be value as Boolean
        Let bytes be Internals.create_internal_array(256)
        If bool_val:
            Internals.internal_array_add(bytes, 0x09)  Note: True marker
        Otherwise:
            Internals.internal_array_add(bytes, 0x08)  Note: False marker
        End If
        Return bytes
    End If
    
    Note: Default to string serialization
    Let str_val be value as String
    Let str_bytes be ASCII.string_to_bytes(str_val)
    Let result be Internals.create_internal_array(1024)
    
    Note: Add string marker with length
    If str_bytes.length() is less than 15:
        Internals.internal_array_add(result, 0x50 plus str_bytes.length())  Note: Short string
    Otherwise:
        Internals.internal_array_add(result, 0x5F)  Note: Long string marker
        Internals.internal_array_add(result, str_bytes.length() divided by 256)
        Internals.internal_array_add(result, str_bytes.length() modulo 256)
    End If
    
    Note: Add string bytes
    Let i be 0
    While i is less than str_bytes.length():
        Internals.internal_array_add(result, Internals.internal_array_get(str_bytes, i))
        Set i to i plus 1
    End While
    
    Return result

Process called "lookup_launchd_service" that takes service_name as String returns Integer:
    Note: Look up Mach port for XPC service via launchd
    
    External runa_syscall3(syscall_num as Integer, p1 as Integer, p2 as Integer, p3 as Integer) returns Integer
    External allocate_buffer(size as Integer) returns Buffer
    External free_buffer(addr as Integer, size as Integer) returns Nothing
    External write_32bit_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    External read_32bit_at(buffer as Buffer, offset as Integer) returns Integer
    
    Note: Get bootstrap port (launchd)
    Note: bootstrap_port trap is -10 (0xfffffff6)
    Let bootstrap_port be runa_syscall0(0xfffffff6)
    
    If bootstrap_port is equal to 0:
        Return 0  Note: No bootstrap port available
    End If
    
    Note: Convert service name to Mach service name format
    Let mach_service_name be "com.apple." joined with service_name
    If service_name.contains("."):
        Set mach_service_name to service_name  Note: Already qualified
    End If
    
    Let name_cstr be allocate_cstring(mach_service_name)
    Let port_buffer be allocate_buffer(4)
    
    Note: bootstrap_look_up trap to find service port
    Note: Using Mach trap for service lookup (implementation specific)
    Let lookup_result be runa_syscall3(0xfffffff5, bootstrap_port, name_cstr.address, port_buffer.address)
    
    Let service_port be 0
    If lookup_result is equal to 0:
        Set service_port to read_32bit_at(port_buffer, 0)
    End If
    
    free_buffer(name_cstr.address, string_length(mach_service_name) plus 1)
    free_buffer(port_buffer.address, 4)
    
    Return service_port

Process called "get_reply_port" that takes conn as XPCConnection returns Integer:
    Note: Get reply port for XPC connection
    
    Note: Return the reply port that was stored during connection setup
    Return conn.reply_port

Process called "serialize_xpc_message" that takes message as Internals.InternalMap returns Buffer:
    Note: Serialize message to XPC binary format
    
    External allocate_buffer(size as Integer) returns Buffer
    External write_32bit_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    External write_64bit_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    External write_byte_at(buffer as Buffer, offset as Integer, value as Integer) returns Nothing
    
    Note: Calculate required buffer size
    Let estimated_size be 1024  Note: Start with 1KB
    Let buffer be allocate_buffer(estimated_size)
    
    Note: Write XPC binary plist header
    write_32bit_at(buffer, 0, 0x62706C69)  Note: 'bpli' magic
    write_32bit_at(buffer, 4, 0x73743030)  Note: 'st00' version
    
    Let offset be 8
    
    Note: Write dictionary marker
    write_byte_at(buffer, offset, 0xD0 plus message.keys().length())  Note: Dict with count
    Set offset to offset plus 1
    
    Note: Write each key-value pair
    For Each key in message.keys():
        Note: Write key as string
        Let key_bytes be ASCII.string_to_bytes(key)
        write_byte_at(buffer, offset, 0x50 plus key_bytes.length())  Note: String marker
        Set offset to offset plus 1
        
        Let i be 0
        While i is less than key_bytes.length():
            write_byte_at(buffer, offset, key_bytes[i])
            Set offset to offset plus 1
            Set i to i plus 1
        End While
        
        Note: Write value based on type
        Let value_bytes be serialize_xpc_value(message[key])
        write_byte_at(buffer, offset, 0x50 plus value_bytes.length())  Note: String marker
        Set offset to offset plus 1
        
        Let j be 0
        While j is less than value_bytes.length():
            write_byte_at(buffer, offset, value_bytes[j])
            Set offset to offset plus 1
            Set j to j plus 1
        End While
    End For
    
    Note: Write offset table (required for binary plist)
    Let table_offset be offset
    write_32bit_at(buffer, offset, 8)  Note: Offset to first object
    Set offset to offset plus 4
    
    Note: Write trailer
    write_64bit_at(buffer, offset, 0)  Note: Sort version
    Set offset to offset plus 8
    write_byte_at(buffer, offset, 1)  Note: Offset int size
    Set offset to offset plus 1
    write_byte_at(buffer, offset, 1)  Note: Object ref size
    Set offset to offset plus 1
    write_64bit_at(buffer, offset, message.keys().length() multiplied by 2)  Note: Num objects
    Set offset to offset plus 8
    write_64bit_at(buffer, offset, 0)  Note: Top object
    Set offset to offset plus 8
    write_64bit_at(buffer, offset, table_offset)  Note: Offset table offset
    Set offset to offset plus 8
    
    Note: Set actual buffer size
    Set buffer.size to offset
    
    Return buffer

Note: =====================================================================
Note: DATA STRUCTURE DEFINITIONS FOR HELPERS
Note: =====================================================================

Type called "Buffer":
    address as Integer
    size as Integer

Type called "StatResult":
    size as Integer
    mode as Integer
    mtime as Integer
    exists as Boolean
End Type

Note: =====================================================================
Note: PLATFORM REGISTRATION
Note: =====================================================================

Process called "register_darwin_x64_platform" returns Nothing:
    Note: Register this platform with the global registry
    
    @Implementation
    Creates an instance of DarwinX64Platform and registers it with the
    global platform registry so it can be used by the syscall layer.
    @End Implementation
    
    Let platform be create_darwin_x64_platform()
    PlatformInterface.register_platform("darwin_x86_64", platform)
End Process