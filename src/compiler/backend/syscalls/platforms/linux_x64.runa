Note:
runa/src/compiler/backend/syscalls/platforms/linux_x64.runa
Linux x86_64 Syscall Definitions

This module contains syscall definitions specific to Linux on x86_64 architecture.
It provides syscall numbers, calling conventions, and platform-specific details
for the Linux x86_64 ABI.

Key features and capabilities:
- Complete Linux x86_64 syscall number mappings (~350 syscalls)
- Register allocation for syscall parameters (RDI, RSI, RDX, R10, R8, R9)
- Linux-specific syscall conventions
- Error return value handling (-errno)
- VDSO function mappings for performance
- Kernel version compatibility tracking
- Security capability requirements (CAP_SYS_ADMIN, etc.)
- io_uring support definitions for async I/O
- Performance optimization hints
- Stack red zone handling (128 bytes)
- Signal safety considerations
- Thread-local storage access
- seccomp filter integration
- cgroup v2 management
- eBPF program loading
- Namespace operations
- Landlock security framework
- FUSE filesystem interface
- pidfd operations
- Memory sealing (memfd_secret)
- userfaultfd handling
- Time namespace support
- Mount API v2 operations
- Kernel keyring management
:End Note

Import "platform_interface.runa" as PlatformInterface
Import "../syscall_external.runa" as SyscallExternal
Import "../syscall_registry.runa" as Registry
Import "../../../frontend/primitives/core/integer_primitive.runa" as Integer
Import "../../../frontend/primitives/core/boolean_primitive.runa" as Boolean
Import "../../../frontend/primitives/types/string_primitive.runa" as StringPrim
Import "../../../frontend/primitives/types/compiler_internals" as Internals

Note: =====================================================================
Note: LINUX X64 PLATFORM IMPLEMENTATION
Note: =====================================================================

Type called "LinuxX64Platform" implements PlatformInterface.PlatformSyscalls:
    Note: Linux x86_64 platform implementation
    
    @Implementation
    Implements the PlatformSyscalls interface for Linux on x86_64 architecture.
    Provides syscall numbers, calling conventions, and error mappings.
    @End Implementation
    
    syscall_table as Internals.InternalMap
    error_mappings as Internals.InternalMap
    calling_convention as PlatformInterface.CallingConvention
End Type

Note: =====================================================================
Note: INTERFACE IMPLEMENTATION METHODS
Note: =====================================================================

Process called "create_linux_x64_platform" returns LinuxX64Platform:
    Note: Create and initialize Linux x64 platform
    
    Let platform be LinuxX64Platform
    Set platform.syscall_table to get_linux_x64_syscall_table()
    Set platform.error_mappings to create_error_mappings()
    Set platform.calling_convention to create_calling_convention()
    Return platform
End Process

Process called "get_syscall_number" that takes self as LinuxX64Platform, name as String returns Integer:
    Note: Implementation of PlatformSyscalls.get_syscall_number
    
    Let name_ptr be Internals.string_to_ptr(name)
    Let result be Internals.internal_map_get(self.syscall_table, name_ptr)
    If result equals 0:
        Return -1
    End If
    Return result
End Process

Process called "get_calling_convention" that takes self as LinuxX64Platform returns PlatformInterface.CallingConvention:
    Note: Implementation of PlatformSyscalls.get_calling_convention
    
    Return self.calling_convention
End Process

Process called "supports_syscall" that takes self as LinuxX64Platform, name as String returns Boolean:
    Note: Implementation of PlatformSyscalls.supports_syscall
    
    Let name_ptr be Internals.string_to_ptr(name)
    Let result be Internals.internal_map_get(self.syscall_table, name_ptr)
    Return result does not equal 0
End Process

Process called "get_error_mapping" that takes self as LinuxX64Platform returns Internals.InternalMap:
    Note: Implementation of PlatformSyscalls.get_error_mapping
    
    Return self.error_mappings
End Process

Process called "get_platform_name" that takes self as LinuxX64Platform returns String:
    Note: Implementation of PlatformSyscalls.get_platform_name
    
    Return "linux_x86_64"
End Process

Process called "get_kernel_version" that takes self as LinuxX64Platform returns String:
    Note: Implementation of PlatformSyscalls.get_kernel_version
    
    Let version_buffer be SyscallExternal.allocate_buffer(256)
    Let uname_syscall be 63  Note: sys_uname
    Let result be SyscallExternal.runa_syscall1(uname_syscall, SyscallExternal.buffer_to_int(version_buffer))
    
    If result is less than 0:
        SyscallExternal.free_buffer(version_buffer)
        Return "unknown"
    End If
    
    Note: Extract version from uname structure (offset 65 for release field)
    Let version_str be ""
    Let offset be 65
    While offset is less than 128:
        Let byte be SyscallExternal.read_byte_at(version_buffer, offset)
        If byte equals 0:
            Break
        End If
        Note: Append character to version string
        Set version_str to StringPrim.concat_strings(version_str, StringPrim.from_char(byte))
        Set offset to Integer.add_integers(offset, 1)
    End While
    
    SyscallExternal.free_buffer(version_buffer)
    Return version_str
End Process

Process called "get_architecture" that takes self as LinuxX64Platform returns String:
    Note: Implementation of PlatformSyscalls.get_architecture
    
    Return "x86_64"
End Process

Process called "get_max_syscall_args" that takes self as LinuxX64Platform returns Integer:
    Note: Implementation of PlatformSyscalls.get_max_syscall_args
    
    Return 6  Note: Linux x86_64 supports up to 6 syscall arguments
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "create_calling_convention" returns PlatformInterface.CallingConvention:
    Note: Create Linux x86_64 calling convention
    
    Let convention be PlatformInterface.CallingConvention
    Set convention.name to "SystemV"
    Set convention.syscall_register to "rax"
    
    Let param_regs be Internals.create_internal_array(6)
    Internals.internal_array_add(param_regs, Internals.string_to_ptr("rdi"))
    Internals.internal_array_add(param_regs, Internals.string_to_ptr("rsi"))
    Internals.internal_array_add(param_regs, Internals.string_to_ptr("rdx"))
    Internals.internal_array_add(param_regs, Internals.string_to_ptr("r10"))  Note: Not rcx due to syscall instruction
    Internals.internal_array_add(param_regs, Internals.string_to_ptr("r8"))
    Internals.internal_array_add(param_regs, Internals.string_to_ptr("r9"))
    Set convention.param_registers to param_regs
    
    Set convention.return_register to "rax"
    Set convention.error_register to "rax"  Note: Negative for errors
    Set convention.max_params to 6
    Set convention.instruction to "syscall"
    
    Return convention
End Process

Process called "create_error_mappings" returns Internals.InternalMap:
    Note: Create Linux error code mappings
    
    Let mappings be Internals.create_internal_map()
    
    Note: Add standard Linux error codes
    Let err be PlatformInterface.ErrorMapping
    Set err.platform_code to 1
    Set err.standard_code to PlatformInterface.EPERM
    Set err.error_name to "EPERM"
    Set err.description to "Operation not permitted"
    Let err_ptr be allocate_error_mapping(err)
    Internals.internal_map_insert(mappings, 1, err_ptr)
    
    Let err be PlatformInterface.ErrorMapping
    Set err.platform_code to 2
    Set err.standard_code to PlatformInterface.ENOENT
    Set err.error_name to "ENOENT"
    Set err.description to "No such file or directory"
    Let err_ptr be allocate_error_mapping(err)
    Internals.internal_map_insert(mappings, 2, err_ptr)
    
    Let err be PlatformInterface.ErrorMapping
    Set err.platform_code to 3
    Set err.standard_code to PlatformInterface.ESRCH
    Set err.error_name to "ESRCH"
    Set err.description to "No such process"
    Let err_ptr be allocate_error_mapping(err)
    Internals.internal_map_insert(mappings, 3, err_ptr)
    
    Let err be PlatformInterface.ErrorMapping
    Set err.platform_code to 4
    Set err.standard_code to PlatformInterface.EINTR
    Set err.error_name to "EINTR"
    Set err.description to "Interrupted system call"
    Let err_ptr be allocate_error_mapping(err)
    Internals.internal_map_insert(mappings, 4, err_ptr)
    
    Let err be PlatformInterface.ErrorMapping
    Set err.platform_code to 5
    Set err.standard_code to PlatformInterface.EIO
    Set err.error_name to "EIO"
    Set err.description to "I/O error"
    Let err_ptr be allocate_error_mapping(err)
    Internals.internal_map_insert(mappings, 5, err_ptr)
    
    Note: Continue with more error codes as needed
    
    Return mappings
End Process

Note: Helper function to allocate error mapping structure
Process called "allocate_error_mapping" that takes err as PlatformInterface.ErrorMapping returns Integer:
    Let err_ptr as Integer
    Inline Assembly:
        "mov rdi, 64\n"           Note: Size of ErrorMapping structure
        "mov rax, 9\n"            Note: mmap syscall
        "mov rsi, rdi\n"          Note: length = size
        "mov rdi, 0\n"            Note: addr = NULL
        "mov rdx, 3\n"            Note: PROT_READ | PROT_WRITE
        "mov r10, 34\n"           Note: MAP_PRIVATE | MAP_ANONYMOUS
        "mov r8, -1\n"            Note: fd = -1
        "mov r9, 0\n"             Note: offset = 0
        "syscall\n"
        "mov %0, rax\n"
        : "=r"(err_ptr)
        :
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "r9", "rcx", "r11", "memory"
    End Assembly
    
    Note: Copy error mapping data to allocated memory
    write_error_mapping(err_ptr, err)
    Return err_ptr
End Process

Note: Helper function to write error mapping to memory
Process called "write_error_mapping" that takes ptr as Integer, err as PlatformInterface.ErrorMapping:
    Note: Write platform_code (offset 0)
    Inline Assembly:
        "mov rax, %1\n"
        "mov [%0], rax\n"
        :
        : "r"(ptr), "r"(err.platform_code)
        : "rax", "memory"
    End Assembly
    
    Note: Write standard_code (offset 8)
    Inline Assembly:
        "mov rax, %1\n"
        "mov [%0 + 8], rax\n"
        :
        : "r"(ptr), "r"(err.standard_code)
        : "rax", "memory"
    End Assembly
    
    Note: Write error_name pointer (offset 16)
    Let name_ptr be Internals.string_to_ptr(err.error_name)
    Inline Assembly:
        "mov rax, %1\n"
        "mov [%0 + 16], rax\n"
        :
        : "r"(ptr), "r"(name_ptr)
        : "rax", "memory"
    End Assembly
    
    Note: Write description pointer (offset 24)
    Let desc_ptr be Internals.string_to_ptr(err.description)
    Inline Assembly:
        "mov rax, %1\n"
        "mov [%0 + 24], rax\n"
        :
        : "r"(ptr), "r"(desc_ptr)
        : "rax", "memory"
    End Assembly
End Process

Note: Helper function to add syscall name/number mapping
Process called "add_syscall_mapping" that takes syscalls as Internals.InternalMap, name as String, number as Integer:
    Let name_ptr be Internals.string_to_ptr(name)
    Internals.internal_map_insert(syscalls, name_ptr, number)
End Process

Note: =====================================================================
Note: LINUX DATA STRUCTURES
Note: =====================================================================

Type called "LinuxSyscallInfo":
    syscall_number as Integer               Note: Linux syscall number
    kernel_version as String                Note: Minimum kernel version required
    capability_required as Optional[String] Note: CAP_* capability needed
    is_vdso_accelerated as Boolean         Note: Available via VDSO
    namespace_aware as Boolean              Note: Affected by namespaces
    signal_safe as Boolean                  Note: Safe to call from signal handler
    restartable as Boolean                  Note: Can be restarted after EINTR

Type called "VDSOFunction":
    name as String                          Note: Function name
    address as Integer                      Note: Runtime address
    version as String                       Note: Symbol version
    fallback_syscall as Integer            Note: Syscall number if VDSO unavailable

Type called "IOUringContext":
    ring_fd as Integer                      Note: io_uring file descriptor
    sq_entries as Integer                   Note: Submission queue size
    cq_entries as Integer                   Note: Completion queue size
    flags as Integer                        Note: Ring setup flags
    features as Integer                     Note: Supported features

Type called "SeccompFilter":
    mode as String                          Note: SECCOMP_MODE_STRICT or FILTER
    filter_program as Internals.InternalArray         Note: BPF filter bytecode
    allowed_syscalls as Internals.InternalArray      Note: Whitelist of syscalls
    log_violations as Boolean               Note: Log denied syscalls

Type called "NamespaceConfig":
    namespace_type as String                Note: PID, NET, MNT, UTS, IPC, USER, TIME
    flags as Integer                        Note: Clone flags
    is_isolated as Boolean                  Note: Whether namespace is isolated
    parent_ns as Optional[Integer]          Note: Parent namespace fd

Type called "LandlockRuleset":
    handled_access_fs as Integer            Note: File system access rights
    handled_access_net as Integer           Note: Network access rights
    rules as Internals.InternalArray  Note: Path-based rules (pointers to rule structures)
    is_enforced as Boolean                  Note: Whether ruleset is active

Note: =====================================================================
Note: PLATFORM-SPECIFIC CONSTANTS AND HELPERS
Note: =====================================================================

Note: String constants for container detection
Inline Assembly:
    "proc_1_cgroup_path:\n"
    "    .asciz \"/proc/1/cgroup\"\n"
End Assembly

Process called "search_for_string" that takes buffer_ptr as Integer, buffer_size as Integer, search_str as String returns Boolean:
    Note: Search for a substring in buffer
    
    Let search_ptr be Internals.string_to_ptr(search_str)
    Let search_len be calculate_string_length(search_ptr)
    
    If search_len is equal to 0 or search_len is greater than buffer_size:
        Return false
    End If
    
    Let offset be 0
    While offset is less than or equal to Integer.subtract_integers(buffer_size, search_len):
        Let matches be true
        Let check_offset be 0
        
        While check_offset is less than search_len:
            Let buffer_byte be Integer
            Inline Assembly:
                "movzx rax, byte ptr [%1 + %2]\n"
                "mov %0, rax\n"
                : "=r"(buffer_byte)
                : "r"(buffer_ptr), "r"(Integer.add_integers(offset, check_offset))
                : "rax", "memory"
            End Assembly
            
            Let search_byte be Integer
            Inline Assembly:
                "movzx rax, byte ptr [%1 + %2]\n"
                "mov %0, rax\n"
                : "=r"(search_byte)
                : "r"(search_ptr), "r"(check_offset)
                : "rax", "memory"
            End Assembly
            
            If buffer_byte is not equal to search_byte:
                Set matches to false
                Break
            End If
            
            Set check_offset to Integer.add_integers(check_offset, 1)
        End While
        
        If matches:
            Return true
        End If
        
        Set offset to Integer.add_integers(offset, 1)
    End While
    
    Return false
End Process

Process called "calculate_string_length" that takes str_ptr as Integer returns Integer:
    Note: Calculate length of null-terminated string
    
    Let length be 0
    While true:
        Let byte_val be Integer
        Inline Assembly:
            "movzx rax, byte ptr [%1 + %2]\n"
            "mov %0, rax\n"
            : "=r"(byte_val)
            : "r"(str_ptr), "r"(length)
            : "rax", "memory"
        End Assembly
        
        If byte_val is equal to 0:
            Break
        End If
        
        Set length to Integer.add_integers(length, 1)
    End While
    
    Return length
End Process

Note: =====================================================================
Note: LINUX X86_64 SYSCALL NUMBERS
Note: =====================================================================

Process called "get_linux_x64_syscall_table" returns Internals.InternalMap:
    Note: Return complete syscall number mapping for Linux x86_64
    Note: Based on Linux kernel 5.x/6.x syscall table
    Note: Includes all ~330 Linux syscalls
    
    @Implementation
    Provides the complete syscall table for Linux x86_64. These numbers
    are stable across kernel versions for backward compatibility.
    @End Implementation
    
    Let syscalls be Internals.create_internal_map()
    
    Note: Core file I/O syscalls (0-99)
    add_syscall_mapping(syscalls, "read", 0)
    add_syscall_mapping(syscalls, "write", 1)
    add_syscall_mapping(syscalls, "open", 2)
    add_syscall_mapping(syscalls, "close", 3)
    add_syscall_mapping(syscalls, "stat", 4)
    add_syscall_mapping(syscalls, "fstat", 5)
    add_syscall_mapping(syscalls, "lstat", 6)
    add_syscall_mapping(syscalls, "poll", 7)
    add_syscall_mapping(syscalls, "lseek", 8)
    add_syscall_mapping(syscalls, "mmap", 9)
    add_syscall_mapping(syscalls, "mprotect", 10)
    add_syscall_mapping(syscalls, "munmap", 11)
    add_syscall_mapping(syscalls, "brk", 12)
    add_syscall_mapping(syscalls, "rt_sigaction", 13)
    add_syscall_mapping(syscalls, "rt_sigprocmask", 14)
    add_syscall_mapping(syscalls, "rt_sigreturn", 15)
    add_syscall_mapping(syscalls, "ioctl", 16)
    add_syscall_mapping(syscalls, "pread64", 17)
    add_syscall_mapping(syscalls, "pwrite64", 18)
    add_syscall_mapping(syscalls, "readv", 19)
    add_syscall_mapping(syscalls, "writev", 20)
    add_syscall_mapping(syscalls, "access", 21)
    add_syscall_mapping(syscalls, "pipe", 22)
    add_syscall_mapping(syscalls, "select", 23)
    add_syscall_mapping(syscalls, "sched_yield", 24)
    add_syscall_mapping(syscalls, "mremap", 25)
    add_syscall_mapping(syscalls, "msync", 26)
    add_syscall_mapping(syscalls, "mincore", 27)
    add_syscall_mapping(syscalls, "madvise", 28)
    add_syscall_mapping(syscalls, "shmget", 29)
    add_syscall_mapping(syscalls, "shmat", 30)
    add_syscall_mapping(syscalls, "shmctl", 31)
    add_syscall_mapping(syscalls, "dup", 32)
    add_syscall_mapping(syscalls, "dup2", 33)
    add_syscall_mapping(syscalls, "pause", 34)
    add_syscall_mapping(syscalls, "nanosleep", 35)
    add_syscall_mapping(syscalls, "getitimer", 36)
    add_syscall_mapping(syscalls, "alarm", 37)
    add_syscall_mapping(syscalls, "setitimer", 38)
    add_syscall_mapping(syscalls, "getpid", 39)
    add_syscall_mapping(syscalls, "sendfile", 40)
    add_syscall_mapping(syscalls, "socket", 41)
    add_syscall_mapping(syscalls, "connect", 42)
    add_syscall_mapping(syscalls, "accept", 43)
    add_syscall_mapping(syscalls, "sendto", 44)
    add_syscall_mapping(syscalls, "recvfrom", 45)
    add_syscall_mapping(syscalls, "sendmsg", 46)
    add_syscall_mapping(syscalls, "recvmsg", 47)
    add_syscall_mapping(syscalls, "shutdown", 48)
    add_syscall_mapping(syscalls, "bind", 49)
    add_syscall_mapping(syscalls, "listen", 50)
    add_syscall_mapping(syscalls, "getsockname", 51)
    add_syscall_mapping(syscalls, "getpeername", 52)
    add_syscall_mapping(syscalls, "socketpair", 53)
    add_syscall_mapping(syscalls, "setsockopt", 54)
    add_syscall_mapping(syscalls, "getsockopt", 55)
    add_syscall_mapping(syscalls, "clone", 56)
    add_syscall_mapping(syscalls, "fork", 57)
    add_syscall_mapping(syscalls, "vfork", 58)
    add_syscall_mapping(syscalls, "execve", 59)
    add_syscall_mapping(syscalls, "exit", 60)
    add_syscall_mapping(syscalls, "wait4", 61)
    add_syscall_mapping(syscalls, "kill", 62)
    add_syscall_mapping(syscalls, "uname", 63)
    add_syscall_mapping(syscalls, "semget", 64)
    add_syscall_mapping(syscalls, "semop", 65)
    add_syscall_mapping(syscalls, "semctl", 66)
    add_syscall_mapping(syscalls, "shmdt", 67)
    add_syscall_mapping(syscalls, "msgget", 68)
    add_syscall_mapping(syscalls, "msgsnd", 69)
    add_syscall_mapping(syscalls, "msgrcv", 70)
    add_syscall_mapping(syscalls, "msgctl", 71)
    add_syscall_mapping(syscalls, "fcntl", 72)
    add_syscall_mapping(syscalls, "flock", 73)
    add_syscall_mapping(syscalls, "fsync", 74)
    add_syscall_mapping(syscalls, "fdatasync", 75)
    add_syscall_mapping(syscalls, "truncate", 76)
    add_syscall_mapping(syscalls, "ftruncate", 77)
    add_syscall_mapping(syscalls, "getdents", 78)
    add_syscall_mapping(syscalls, "getcwd", 79)
    add_syscall_mapping(syscalls, "chdir", 80)
    add_syscall_mapping(syscalls, "fchdir", 81)
    add_syscall_mapping(syscalls, "rename", 82)
    add_syscall_mapping(syscalls, "mkdir", 83)
    add_syscall_mapping(syscalls, "rmdir", 84)
    add_syscall_mapping(syscalls, "creat", 85)
    add_syscall_mapping(syscalls, "link", 86)
    add_syscall_mapping(syscalls, "unlink", 87)
    add_syscall_mapping(syscalls, "symlink", 88)
    add_syscall_mapping(syscalls, "readlink", 89)
    add_syscall_mapping(syscalls, "chmod", 90)
    add_syscall_mapping(syscalls, "fchmod", 91)
    add_syscall_mapping(syscalls, "chown", 92)
    add_syscall_mapping(syscalls, "fchown", 93)
    add_syscall_mapping(syscalls, "lchown", 94)
    add_syscall_mapping(syscalls, "umask", 95)
    add_syscall_mapping(syscalls, "gettimeofday", 96)
    add_syscall_mapping(syscalls, "getrlimit", 97)
    add_syscall_mapping(syscalls, "getrusage", 98)
    add_syscall_mapping(syscalls, "sysinfo", 99)
    
    Note: Process and time syscalls (100-199)
    add_syscall_mapping(syscalls, "times", 100)
    add_syscall_mapping(syscalls, "ptrace", 101)
    add_syscall_mapping(syscalls, "getuid", 102)
    add_syscall_mapping(syscalls, "syslog", 103)
    add_syscall_mapping(syscalls, "getgid", 104)
    add_syscall_mapping(syscalls, "setuid", 105)
    add_syscall_mapping(syscalls, "setgid", 106)
    add_syscall_mapping(syscalls, "geteuid", 107)
    add_syscall_mapping(syscalls, "getegid", 108)
    add_syscall_mapping(syscalls, "setpgid", 109)
    add_syscall_mapping(syscalls, "getppid", 110)
    add_syscall_mapping(syscalls, "getpgrp", 111)
    add_syscall_mapping(syscalls, "setsid", 112)
    add_syscall_mapping(syscalls, "setreuid", 113)
    add_syscall_mapping(syscalls, "setregid", 114)
    add_syscall_mapping(syscalls, "getgroups", 115)
    add_syscall_mapping(syscalls, "setgroups", 116)
    add_syscall_mapping(syscalls, "setresuid", 117)
    add_syscall_mapping(syscalls, "getresuid", 118)
    add_syscall_mapping(syscalls, "setresgid", 119)
    add_syscall_mapping(syscalls, "getresgid", 120)
    add_syscall_mapping(syscalls, "getpgid", 121)
    add_syscall_mapping(syscalls, "setfsuid", 122)
    add_syscall_mapping(syscalls, "setfsgid", 123)
    add_syscall_mapping(syscalls, "getsid", 124)
    add_syscall_mapping(syscalls, "capget", 125)
    add_syscall_mapping(syscalls, "capset", 126)
    add_syscall_mapping(syscalls, "rt_sigpending", 127)
    add_syscall_mapping(syscalls, "rt_sigtimedwait", 128)
    add_syscall_mapping(syscalls, "rt_sigqueueinfo", 129)
    add_syscall_mapping(syscalls, "rt_sigsuspend", 130)
    add_syscall_mapping(syscalls, "sigaltstack", 131)
    add_syscall_mapping(syscalls, "utime", 132)
    add_syscall_mapping(syscalls, "mknod", 133)
    add_syscall_mapping(syscalls, "uselib", 134)
    add_syscall_mapping(syscalls, "personality", 135)
    add_syscall_mapping(syscalls, "ustat", 136)
    add_syscall_mapping(syscalls, "statfs", 137)
    add_syscall_mapping(syscalls, "fstatfs", 138)
    add_syscall_mapping(syscalls, "sysfs", 139)
    add_syscall_mapping(syscalls, "getpriority", 140)
    add_syscall_mapping(syscalls, "setpriority", 141)
    add_syscall_mapping(syscalls, "sched_setparam", 142)
    add_syscall_mapping(syscalls, "sched_getparam", 143)
    add_syscall_mapping(syscalls, "sched_setscheduler", 144)
    add_syscall_mapping(syscalls, "sched_getscheduler", 145)
    add_syscall_mapping(syscalls, "sched_get_priority_max", 146)
    add_syscall_mapping(syscalls, "sched_get_priority_min", 147)
    add_syscall_mapping(syscalls, "sched_rr_get_interval", 148)
    add_syscall_mapping(syscalls, "mlock", 149)
    add_syscall_mapping(syscalls, "munlock", 150)
    add_syscall_mapping(syscalls, "mlockall", 151)
    add_syscall_mapping(syscalls, "munlockall", 152)
    add_syscall_mapping(syscalls, "vhangup", 153)
    add_syscall_mapping(syscalls, "modify_ldt", 154)
    add_syscall_mapping(syscalls, "pivot_root", 155)
    add_syscall_mapping(syscalls, "_sysctl", 156)
    add_syscall_mapping(syscalls, "prctl", 157)
    add_syscall_mapping(syscalls, "arch_prctl", 158)
    add_syscall_mapping(syscalls, "adjtimex", 159)
    add_syscall_mapping(syscalls, "setrlimit", 160)
    add_syscall_mapping(syscalls, "chroot", 161)
    add_syscall_mapping(syscalls, "sync", 162)
    add_syscall_mapping(syscalls, "acct", 163)
    add_syscall_mapping(syscalls, "settimeofday", 164)
    add_syscall_mapping(syscalls, "mount", 165)
    add_syscall_mapping(syscalls, "umount2", 166)
    add_syscall_mapping(syscalls, "swapon", 167)
    add_syscall_mapping(syscalls, "swapoff", 168)
    add_syscall_mapping(syscalls, "reboot", 169)
    add_syscall_mapping(syscalls, "sethostname", 170)
    add_syscall_mapping(syscalls, "setdomainname", 171)
    add_syscall_mapping(syscalls, "iopl", 172)
    add_syscall_mapping(syscalls, "ioperm", 173)
    add_syscall_mapping(syscalls, "create_module", 174)
    add_syscall_mapping(syscalls, "init_module", 175)
    add_syscall_mapping(syscalls, "delete_module", 176)
    add_syscall_mapping(syscalls, "get_kernel_syms", 177)
    add_syscall_mapping(syscalls, "query_module", 178)
    add_syscall_mapping(syscalls, "quotactl", 179)
    add_syscall_mapping(syscalls, "nfsservctl", 180)
    add_syscall_mapping(syscalls, "getpmsg", 181)
    add_syscall_mapping(syscalls, "putpmsg", 182)
    add_syscall_mapping(syscalls, "afs_syscall", 183)
    add_syscall_mapping(syscalls, "tuxcall", 184)
    add_syscall_mapping(syscalls, "security", 185)
    add_syscall_mapping(syscalls, "gettid", 186)
    add_syscall_mapping(syscalls, "readahead", 187)
    add_syscall_mapping(syscalls, "setxattr", 188)
    add_syscall_mapping(syscalls, "lsetxattr", 189)
    add_syscall_mapping(syscalls, "fsetxattr", 190)
    add_syscall_mapping(syscalls, "getxattr", 191)
    add_syscall_mapping(syscalls, "lgetxattr", 192)
    add_syscall_mapping(syscalls, "fgetxattr", 193)
    add_syscall_mapping(syscalls, "listxattr", 194)
    add_syscall_mapping(syscalls, "llistxattr", 195)
    add_syscall_mapping(syscalls, "flistxattr", 196)
    add_syscall_mapping(syscalls, "removexattr", 197)
    add_syscall_mapping(syscalls, "lremovexattr", 198)
    add_syscall_mapping(syscalls, "fremovexattr", 199)
    
    Note: Threading and modern syscalls (200-299)
    add_syscall_mapping(syscalls, "tkill", 200)
    add_syscall_mapping(syscalls, "time", 201)
    add_syscall_mapping(syscalls, "futex", 202)
    add_syscall_mapping(syscalls, "sched_setaffinity", 203)
    add_syscall_mapping(syscalls, "sched_getaffinity", 204)
    add_syscall_mapping(syscalls, "set_thread_area", 205)
    add_syscall_mapping(syscalls, "io_setup", 206)
    add_syscall_mapping(syscalls, "io_destroy", 207)
    add_syscall_mapping(syscalls, "io_getevents", 208)
    add_syscall_mapping(syscalls, "io_submit", 209)
    add_syscall_mapping(syscalls, "io_cancel", 210)
    add_syscall_mapping(syscalls, "get_thread_area", 211)
    add_syscall_mapping(syscalls, "lookup_dcookie", 212)
    add_syscall_mapping(syscalls, "epoll_create", 213)
    add_syscall_mapping(syscalls, "epoll_ctl_old", 214)
    add_syscall_mapping(syscalls, "epoll_wait_old", 215)
    add_syscall_mapping(syscalls, "remap_file_pages", 216)
    add_syscall_mapping(syscalls, "getdents64", 217)
    add_syscall_mapping(syscalls, "set_tid_address", 218)
    add_syscall_mapping(syscalls, "restart_syscall", 219)
    add_syscall_mapping(syscalls, "semtimedop", 220)
    add_syscall_mapping(syscalls, "fadvise64", 221)
    add_syscall_mapping(syscalls, "timer_create", 222)
    add_syscall_mapping(syscalls, "timer_settime", 223)
    add_syscall_mapping(syscalls, "timer_gettime", 224)
    add_syscall_mapping(syscalls, "timer_getoverrun", 225)
    add_syscall_mapping(syscalls, "timer_delete", 226)
    add_syscall_mapping(syscalls, "clock_settime", 227)
    add_syscall_mapping(syscalls, "clock_gettime", 228)
    add_syscall_mapping(syscalls, "clock_getres", 229)
    add_syscall_mapping(syscalls, "clock_nanosleep", 230)
    add_syscall_mapping(syscalls, "exit_group", 231)
    add_syscall_mapping(syscalls, "epoll_wait", 232)
    add_syscall_mapping(syscalls, "epoll_ctl", 233)
    add_syscall_mapping(syscalls, "tgkill", 234)
    add_syscall_mapping(syscalls, "utimes", 235)
    add_syscall_mapping(syscalls, "vserver", 236)
    add_syscall_mapping(syscalls, "mbind", 237)
    add_syscall_mapping(syscalls, "set_mempolicy", 238)
    add_syscall_mapping(syscalls, "get_mempolicy", 239)
    add_syscall_mapping(syscalls, "mq_open", 240)
    add_syscall_mapping(syscalls, "mq_unlink", 241)
    add_syscall_mapping(syscalls, "mq_timedsend", 242)
    add_syscall_mapping(syscalls, "mq_timedreceive", 243)
    add_syscall_mapping(syscalls, "mq_notify", 244)
    add_syscall_mapping(syscalls, "mq_getsetattr", 245)
    add_syscall_mapping(syscalls, "kexec_load", 246)
    add_syscall_mapping(syscalls, "waitid", 247)
    add_syscall_mapping(syscalls, "add_key", 248)
    add_syscall_mapping(syscalls, "request_key", 249)
    add_syscall_mapping(syscalls, "keyctl", 250)
    add_syscall_mapping(syscalls, "ioprio_set", 251)
    add_syscall_mapping(syscalls, "ioprio_get", 252)
    add_syscall_mapping(syscalls, "inotify_init", 253)
    add_syscall_mapping(syscalls, "inotify_add_watch", 254)
    add_syscall_mapping(syscalls, "inotify_rm_watch", 255)
    add_syscall_mapping(syscalls, "migrate_pages", 256)
    add_syscall_mapping(syscalls, "openat", 257)
    add_syscall_mapping(syscalls, "mkdirat", 258)
    add_syscall_mapping(syscalls, "mknodat", 259)
    add_syscall_mapping(syscalls, "fchownat", 260)
    add_syscall_mapping(syscalls, "futimesat", 261)
    add_syscall_mapping(syscalls, "newfstatat", 262)
    add_syscall_mapping(syscalls, "unlinkat", 263)
    add_syscall_mapping(syscalls, "renameat", 264)
    add_syscall_mapping(syscalls, "linkat", 265)
    add_syscall_mapping(syscalls, "symlinkat", 266)
    add_syscall_mapping(syscalls, "readlinkat", 267)
    add_syscall_mapping(syscalls, "fchmodat", 268)
    add_syscall_mapping(syscalls, "faccessat", 269)
    add_syscall_mapping(syscalls, "pselect6", 270)
    add_syscall_mapping(syscalls, "ppoll", 271)
    add_syscall_mapping(syscalls, "unshare", 272)
    add_syscall_mapping(syscalls, "set_robust_list", 273)
    add_syscall_mapping(syscalls, "get_robust_list", 274)
    add_syscall_mapping(syscalls, "splice", 275)
    add_syscall_mapping(syscalls, "tee", 276)
    add_syscall_mapping(syscalls, "sync_file_range", 277)
    add_syscall_mapping(syscalls, "vmsplice", 278)
    add_syscall_mapping(syscalls, "move_pages", 279)
    add_syscall_mapping(syscalls, "utimensat", 280)
    add_syscall_mapping(syscalls, "epoll_pwait", 281)
    add_syscall_mapping(syscalls, "signalfd", 282)
    add_syscall_mapping(syscalls, "timerfd_create", 283)
    add_syscall_mapping(syscalls, "eventfd", 284)
    add_syscall_mapping(syscalls, "fallocate", 285)
    add_syscall_mapping(syscalls, "timerfd_settime", 286)
    add_syscall_mapping(syscalls, "timerfd_gettime", 287)
    add_syscall_mapping(syscalls, "accept4", 288)
    add_syscall_mapping(syscalls, "signalfd4", 289)
    add_syscall_mapping(syscalls, "eventfd2", 290)
    add_syscall_mapping(syscalls, "epoll_create1", 291)
    add_syscall_mapping(syscalls, "dup3", 292)
    add_syscall_mapping(syscalls, "pipe2", 293)
    add_syscall_mapping(syscalls, "inotify_init1", 294)
    add_syscall_mapping(syscalls, "preadv", 295)
    add_syscall_mapping(syscalls, "pwritev", 296)
    add_syscall_mapping(syscalls, "rt_tgsigqueueinfo", 297)
    add_syscall_mapping(syscalls, "perf_event_open", 298)
    add_syscall_mapping(syscalls, "recvmmsg", 299)
    
    Note: Extended and modern syscalls (300-449)
    add_syscall_mapping(syscalls, "fanotify_init", 300)
    add_syscall_mapping(syscalls, "fanotify_mark", 301)
    add_syscall_mapping(syscalls, "prlimit64", 302)
    add_syscall_mapping(syscalls, "name_to_handle_at", 303)
    add_syscall_mapping(syscalls, "open_by_handle_at", 304)
    add_syscall_mapping(syscalls, "clock_adjtime", 305)
    add_syscall_mapping(syscalls, "syncfs", 306)
    add_syscall_mapping(syscalls, "sendmmsg", 307)
    add_syscall_mapping(syscalls, "setns", 308)
    add_syscall_mapping(syscalls, "getcpu", 309)
    add_syscall_mapping(syscalls, "process_vm_readv", 310)
    add_syscall_mapping(syscalls, "process_vm_writev", 311)
    add_syscall_mapping(syscalls, "kcmp", 312)
    add_syscall_mapping(syscalls, "finit_module", 313)
    add_syscall_mapping(syscalls, "sched_setattr", 314)
    add_syscall_mapping(syscalls, "sched_getattr", 315)
    add_syscall_mapping(syscalls, "renameat2", 316)
    add_syscall_mapping(syscalls, "seccomp", 317)
    add_syscall_mapping(syscalls, "getrandom", 318)
    add_syscall_mapping(syscalls, "memfd_create", 319)
    add_syscall_mapping(syscalls, "kexec_file_load", 320)
    add_syscall_mapping(syscalls, "bpf", 321)
    add_syscall_mapping(syscalls, "execveat", 322)
    add_syscall_mapping(syscalls, "userfaultfd", 323)
    add_syscall_mapping(syscalls, "membarrier", 324)
    add_syscall_mapping(syscalls, "mlock2", 325)
    add_syscall_mapping(syscalls, "copy_file_range", 326)
    add_syscall_mapping(syscalls, "preadv2", 327)
    add_syscall_mapping(syscalls, "pwritev2", 328)
    add_syscall_mapping(syscalls, "pkey_mprotect", 329)
    add_syscall_mapping(syscalls, "pkey_alloc", 330)
    add_syscall_mapping(syscalls, "pkey_free", 331)
    add_syscall_mapping(syscalls, "statx", 332)
    add_syscall_mapping(syscalls, "io_pgetevents", 333)
    add_syscall_mapping(syscalls, "rseq", 334)
    add_syscall_mapping(syscalls, "pidfd_send_signal", 424)
    add_syscall_mapping(syscalls, "io_uring_setup", 425)
    add_syscall_mapping(syscalls, "io_uring_enter", 426)
    add_syscall_mapping(syscalls, "io_uring_register", 427)
    add_syscall_mapping(syscalls, "open_tree", 428)
    add_syscall_mapping(syscalls, "move_mount", 429)
    add_syscall_mapping(syscalls, "fsopen", 430)
    add_syscall_mapping(syscalls, "fsconfig", 431)
    add_syscall_mapping(syscalls, "fsmount", 432)
    add_syscall_mapping(syscalls, "fspick", 433)
    add_syscall_mapping(syscalls, "pidfd_open", 434)
    add_syscall_mapping(syscalls, "clone3", 435)
    add_syscall_mapping(syscalls, "close_range", 436)
    add_syscall_mapping(syscalls, "openat2", 437)
    add_syscall_mapping(syscalls, "pidfd_getfd", 438)
    add_syscall_mapping(syscalls, "faccessat2", 439)
    add_syscall_mapping(syscalls, "process_madvise", 440)
    add_syscall_mapping(syscalls, "epoll_pwait2", 441)
    add_syscall_mapping(syscalls, "mount_setattr", 442)
    add_syscall_mapping(syscalls, "quotactl_fd", 443)
    add_syscall_mapping(syscalls, "landlock_create_ruleset", 444)
    add_syscall_mapping(syscalls, "landlock_add_rule", 445)
    add_syscall_mapping(syscalls, "landlock_restrict_self", 446)
    add_syscall_mapping(syscalls, "memfd_secret", 447)
    add_syscall_mapping(syscalls, "process_mrelease", 448)
    add_syscall_mapping(syscalls, "futex_waitv", 449)
    
    Return syscalls

Process called "get_core_file_syscalls" returns Internals.InternalMap:
    Note: Core file I/O syscall numbers
    
    Let syscalls be Internals.create_internal_map()
    
    Note: Basic file operations
    add_syscall_mapping(syscalls, "read", 0)
    add_syscall_mapping(syscalls, "write", 1)
    add_syscall_mapping(syscalls, "open", 2)
    add_syscall_mapping(syscalls, "close", 3)
    add_syscall_mapping(syscalls, "stat", 4)
    add_syscall_mapping(syscalls, "fstat", 5)
    add_syscall_mapping(syscalls, "lstat", 6)
    add_syscall_mapping(syscalls, "lseek", 8)
    
    Note: Memory mapping
    add_syscall_mapping(syscalls, "mmap", 9)
    add_syscall_mapping(syscalls, "mprotect", 10)
    add_syscall_mapping(syscalls, "munmap", 11)
    
    Note: Extended file operations
    add_syscall_mapping(syscalls, "pread64", 17)
    add_syscall_mapping(syscalls, "pwrite64", 18)
    add_syscall_mapping(syscalls, "readv", 19)
    add_syscall_mapping(syscalls, "writev", 20)
    add_syscall_mapping(syscalls, "access", 21)
    add_syscall_mapping(syscalls, "dup", 32)
    add_syscall_mapping(syscalls, "dup2", 33)
    add_syscall_mapping(syscalls, "fcntl", 72)
    add_syscall_mapping(syscalls, "flock", 73)
    add_syscall_mapping(syscalls, "fsync", 74)
    add_syscall_mapping(syscalls, "fdatasync", 75)
    add_syscall_mapping(syscalls, "truncate", 76)
    add_syscall_mapping(syscalls, "ftruncate", 77)
    add_syscall_mapping(syscalls, "getcwd", 79)
    add_syscall_mapping(syscalls, "chdir", 80)
    add_syscall_mapping(syscalls, "fchdir", 81)
    add_syscall_mapping(syscalls, "rename", 82)
    add_syscall_mapping(syscalls, "mkdir", 83)
    add_syscall_mapping(syscalls, "rmdir", 84)
    add_syscall_mapping(syscalls, "unlink", 87)
    add_syscall_mapping(syscalls, "symlink", 88)
    add_syscall_mapping(syscalls, "readlink", 89)
    add_syscall_mapping(syscalls, "chmod", 90)
    add_syscall_mapping(syscalls, "fchmod", 91)
    
    Note: Modern file operations
    add_syscall_mapping(syscalls, "openat", 257)
    add_syscall_mapping(syscalls, "mkdirat", 258)
    add_syscall_mapping(syscalls, "unlinkat", 263)
    add_syscall_mapping(syscalls, "renameat", 264)
    add_syscall_mapping(syscalls, "renameat2", 316)
    add_syscall_mapping(syscalls, "statx", 332)
    add_syscall_mapping(syscalls, "openat2", 437)
    
    Return syscalls

Process called "get_process_syscalls" returns Internals.InternalMap:
    Note: Process management syscall numbers
    
    Let syscalls be Internals.create_internal_map()
    
    Note: Process creation and execution
    add_syscall_mapping(syscalls, "clone", 56)
    add_syscall_mapping(syscalls, "fork", 57)
    add_syscall_mapping(syscalls, "vfork", 58)
    add_syscall_mapping(syscalls, "execve", 59)
    add_syscall_mapping(syscalls, "execveat", 322)
    add_syscall_mapping(syscalls, "clone3", 435)
    
    Note: Process termination
    add_syscall_mapping(syscalls, "exit", 60)
    add_syscall_mapping(syscalls, "exit_group", 231)
    add_syscall_mapping(syscalls, "wait4", 61)
    add_syscall_mapping(syscalls, "waitid", 247)
    
    Note: Process identification
    add_syscall_mapping(syscalls, "getpid", 39)
    add_syscall_mapping(syscalls, "getppid", 110)
    add_syscall_mapping(syscalls, "gettid", 186)
    add_syscall_mapping(syscalls, "getuid", 102)
    add_syscall_mapping(syscalls, "getgid", 104)
    add_syscall_mapping(syscalls, "geteuid", 107)
    add_syscall_mapping(syscalls, "getegid", 108)
    
    Note: Process groups and sessions
    add_syscall_mapping(syscalls, "setpgid", 109)
    add_syscall_mapping(syscalls, "getpgrp", 111)
    add_syscall_mapping(syscalls, "setsid", 112)
    add_syscall_mapping(syscalls, "getpgid", 121)
    add_syscall_mapping(syscalls, "getsid", 124)
    
    Note: Process control
    add_syscall_mapping(syscalls, "kill", 62)
    add_syscall_mapping(syscalls, "tkill", 200)
    add_syscall_mapping(syscalls, "tgkill", 234)
    add_syscall_mapping(syscalls, "prctl", 157)
    add_syscall_mapping(syscalls, "ptrace", 101)
    
    Note: Process capabilities
    add_syscall_mapping(syscalls, "capget", 125)
    add_syscall_mapping(syscalls, "capset", 126)
    
    Note: User and group management
    add_syscall_mapping(syscalls, "setuid", 105)
    add_syscall_mapping(syscalls, "setgid", 106)
    add_syscall_mapping(syscalls, "setreuid", 113)
    add_syscall_mapping(syscalls, "setregid", 114)
    add_syscall_mapping(syscalls, "setresuid", 117)
    add_syscall_mapping(syscalls, "getresuid", 118)
    add_syscall_mapping(syscalls, "setresgid", 119)
    add_syscall_mapping(syscalls, "getresgid", 120)
    add_syscall_mapping(syscalls, "setgroups", 116)
    add_syscall_mapping(syscalls, "getgroups", 115)
    
    Note: Scheduling
    add_syscall_mapping(syscalls, "sched_yield", 24)
    add_syscall_mapping(syscalls, "sched_setparam", 142)
    add_syscall_mapping(syscalls, "sched_getparam", 143)
    add_syscall_mapping(syscalls, "sched_setscheduler", 144)
    add_syscall_mapping(syscalls, "sched_getscheduler", 145)
    add_syscall_mapping(syscalls, "sched_get_priority_max", 146)
    add_syscall_mapping(syscalls, "sched_get_priority_min", 147)
    add_syscall_mapping(syscalls, "sched_rr_get_interval", 148)
    add_syscall_mapping(syscalls, "sched_setaffinity", 203)
    add_syscall_mapping(syscalls, "sched_getaffinity", 204)
    add_syscall_mapping(syscalls, "sched_setattr", 314)
    add_syscall_mapping(syscalls, "sched_getattr", 315)
    
    Note: Process namespace operations
    add_syscall_mapping(syscalls, "setns", 308)
    add_syscall_mapping(syscalls, "unshare", 272)
    
    Note: pidfd operations
    add_syscall_mapping(syscalls, "pidfd_open", 434)
    add_syscall_mapping(syscalls, "pidfd_send_signal", 424)
    add_syscall_mapping(syscalls, "pidfd_getfd", 438)
    
    Note: Inter-process operations
    add_syscall_mapping(syscalls, "process_vm_readv", 310)
    add_syscall_mapping(syscalls, "process_vm_writev", 311)
    add_syscall_mapping(syscalls, "kcmp", 312)
    add_syscall_mapping(syscalls, "process_madvise", 440)
    add_syscall_mapping(syscalls, "process_mrelease", 448)
    
    Return syscalls

Note: =====================================================================
Note: CALLING CONVENTION
Note: =====================================================================

Process called "get_parameter_registers" returns Internals.InternalArray:
    Note: Return parameter registers in order for Linux x86_64 syscall ABI
    Note: R10 used instead of RCX (RCX clobbered by syscall instruction)
    
    Let registers be Internals.create_internal_array(6)
    Internals.internal_array_add(registers, Internals.string_to_ptr("rdi"))  Note: First argument
    Internals.internal_array_add(registers, Internals.string_to_ptr("rsi"))  Note: Second argument
    Internals.internal_array_add(registers, Internals.string_to_ptr("rdx"))  Note: Third argument
    Internals.internal_array_add(registers, Internals.string_to_ptr("r10"))  Note: Fourth argument (not rcx!)
    Internals.internal_array_add(registers, Internals.string_to_ptr("r8"))   Note: Fifth argument
    Internals.internal_array_add(registers, Internals.string_to_ptr("r9"))   Note: Sixth argument
    
    Return registers

Process called "get_return_register" returns String:
    Note: Return value register for Linux x86_64 syscalls
    Note: Negative values indicate errors (-4095 to -1 are error codes)
    Note: Error codes returned as negative errno values
    
    Return "rax"

Process called "get_clobber_list" returns Internals.InternalArray:
    Note: Registers clobbered by syscall instruction on x86_64
    Note: The syscall instruction itself clobbers RCX and R11
    Note: RCX gets RIP value, R11 gets RFLAGS value
    
    Let clobbered be Internals.create_internal_array(8)
    Internals.internal_array_add(clobbered, Internals.string_to_ptr("rcx"))  Note: Clobbered with return address
    Internals.internal_array_add(clobbered, Internals.string_to_ptr("r11"))  Note: Clobbered with RFLAGS
    
    Return clobbered

Note: =====================================================================
Note: PLATFORM-SPECIFIC FEATURES
Note: =====================================================================

Process called "get_vdso_functions" returns Internals.InternalMap:
    Note: VDSO-accelerated functions for Linux x86_64
    Note: These functions avoid kernel transitions for performance
    Note: Actual addresses are determined at runtime from auxiliary vector
    
    Let vdso_funcs be Internals.create_internal_map()
    
    Note: Get VDSO base address from auxiliary vector
    Let auxv_vdso be read_auxv_sysinfo_ehdr()
    
    If auxv_vdso is equal to 0:
        Note: VDSO not available, return syscall numbers as fallback
        vdso_funcs.set("__vdso_clock_gettime", 228)
        vdso_funcs.set("__vdso_gettimeofday", 96)
        vdso_funcs.set("__vdso_time", 201)
        vdso_funcs.set("__vdso_clock_getres", 229)
        vdso_funcs.set("__vdso_getcpu", 309)
        Return vdso_funcs
    End If
    
    Note: Parse VDSO ELF to get actual function addresses
    Import "compiler/backend/machine_code/common/executable_format" as ELF
    Let vdso_info be ELF.parse_vdso_from_auxv(auxv_vdso)
    
    Note: Store resolved addresses or 0 if not found
    For Each func_name in ["__vdso_clock_gettime", "__vdso_gettimeofday", "__vdso_time", "__vdso_clock_getres", "__vdso_getcpu"]:
        Let addr be ELF.resolve_vdso_function(vdso_info, func_name)
        vdso_funcs.set(func_name, addr)
    End For
    
    Return vdso_funcs

Process called "get_io_uring_syscalls" returns Internals.InternalMap:
    Note: io_uring async I/O syscalls for high-performance I/O
    Note: Provides true async I/O without thread pools
    
    Let syscalls be Internals.create_internal_map()
    
    add_syscall_mapping(syscalls, "io_uring_setup", 425)     Note: Setup io_uring instance
    add_syscall_mapping(syscalls, "io_uring_enter", 426)     Note: Submit and wait for I/O
    add_syscall_mapping(syscalls, "io_uring_register", 427)  Note: Register resources with ring
    
    Return syscalls

Process called "get_extended_syscalls" returns Internals.InternalMap:
    Note: Newer Linux-specific syscalls (kernel 5.x+)
    
    Let syscalls be Internals.create_internal_map()
    
    Note: pidfd operations for safe process handling
    add_syscall_mapping(syscalls, "pidfd_open", 434)
    add_syscall_mapping(syscalls, "pidfd_send_signal", 424)
    add_syscall_mapping(syscalls, "pidfd_getfd", 438)
    
    Note: Extended file operations
    add_syscall_mapping(syscalls, "openat2", 437)
    add_syscall_mapping(syscalls, "close_range", 436)
    add_syscall_mapping(syscalls, "faccessat2", 439)
    
    Note: Modern process creation
    add_syscall_mapping(syscalls, "clone3", 435)
    
    Note: Landlock security framework
    add_syscall_mapping(syscalls, "landlock_create_ruleset", 444)
    add_syscall_mapping(syscalls, "landlock_add_rule", 445)
    add_syscall_mapping(syscalls, "landlock_restrict_self", 446)
    
    Note: Memory management extensions
    add_syscall_mapping(syscalls, "memfd_secret", 447)
    add_syscall_mapping(syscalls, "process_madvise", 440)
    add_syscall_mapping(syscalls, "process_mrelease", 448)
    
    Note: Extended futex operations
    add_syscall_mapping(syscalls, "futex_waitv", 449)
    
    Note: Mount API v2
    add_syscall_mapping(syscalls, "open_tree", 428)
    add_syscall_mapping(syscalls, "move_mount", 429)
    add_syscall_mapping(syscalls, "fsopen", 430)
    add_syscall_mapping(syscalls, "fsconfig", 431)
    add_syscall_mapping(syscalls, "fsmount", 432)
    add_syscall_mapping(syscalls, "fspick", 433)
    add_syscall_mapping(syscalls, "mount_setattr", 442)
    
    Note: Extended epoll
    add_syscall_mapping(syscalls, "epoll_pwait2", 441)
    
    Note: Quota management
    add_syscall_mapping(syscalls, "quotactl_fd", 443)
    
    Return syscalls

Process called "get_network_syscalls" returns Internals.InternalMap:
    Note: Network-related syscalls for Linux x86_64
    
    Let syscalls be Internals.create_internal_map()
    
    Note: Socket creation and configuration
    add_syscall_mapping(syscalls, "socket", 41)
    add_syscall_mapping(syscalls, "socketpair", 53)
    add_syscall_mapping(syscalls, "bind", 49)
    add_syscall_mapping(syscalls, "listen", 50)
    add_syscall_mapping(syscalls, "accept", 43)
    add_syscall_mapping(syscalls, "accept4", 288)  Note: Accept with flags
    add_syscall_mapping(syscalls, "connect", 42)
    add_syscall_mapping(syscalls, "shutdown", 48)
    
    Note: Socket options
    add_syscall_mapping(syscalls, "setsockopt", 54)
    add_syscall_mapping(syscalls, "getsockopt", 55)
    add_syscall_mapping(syscalls, "getsockname", 51)
    add_syscall_mapping(syscalls, "getpeername", 52)
    
    Note: Data transfer
    add_syscall_mapping(syscalls, "send", 44)      Note: Same as sendto with NULL addr
    add_syscall_mapping(syscalls, "sendto", 44)     Note: Send with address
    add_syscall_mapping(syscalls, "sendmsg", 46)    Note: Send with ancillary data
    add_syscall_mapping(syscalls, "sendmmsg", 307)  Note: Send multiple messages
    add_syscall_mapping(syscalls, "recv", 45)       Note: Same as recvfrom with NULL addr
    add_syscall_mapping(syscalls, "recvfrom", 45)   Note: Receive with address
    add_syscall_mapping(syscalls, "recvmsg", 47)    Note: Receive with ancillary data
    add_syscall_mapping(syscalls, "recvmmsg", 299)  Note: Receive multiple messages
    
    Note: Zero-copy operations
    add_syscall_mapping(syscalls, "sendfile", 40)   Note: Zero-copy file transfer
    
    Note: BPF for networking (including AF_XDP)
    add_syscall_mapping(syscalls, "bpf", 321)       Note: eBPF operations including XDP
    
    Return syscalls

Process called "get_signal_syscalls" returns Internals.InternalMap:
    Note: Signal handling syscalls for Linux x86_64
    
    Let syscalls be Internals.create_internal_map()
    
    Note: Core signal operations (rt_* are real-time signals)
    add_syscall_mapping(syscalls, "rt_sigaction", 13)       Note: Set signal handler
    add_syscall_mapping(syscalls, "rt_sigprocmask", 14)     Note: Block/unblock signals
    add_syscall_mapping(syscalls, "rt_sigreturn", 15)       Note: Return from signal handler
    add_syscall_mapping(syscalls, "rt_sigpending", 127)     Note: Get pending signals
    add_syscall_mapping(syscalls, "rt_sigsuspend", 130)     Note: Wait for signals
    add_syscall_mapping(syscalls, "rt_sigtimedwait", 128)   Note: Wait with timeout
    add_syscall_mapping(syscalls, "rt_sigqueueinfo", 129)   Note: Send signal with data
    add_syscall_mapping(syscalls, "rt_tgsigqueueinfo", 297) Note: Send to thread group
    
    Note: Signal stack management
    add_syscall_mapping(syscalls, "sigaltstack", 131)       Note: Set alternate signal stack
    
    Note: Process signal operations
    add_syscall_mapping(syscalls, "kill", 62)               Note: Send signal to process
    add_syscall_mapping(syscalls, "tkill", 200)             Note: Send signal to thread
    add_syscall_mapping(syscalls, "tgkill", 234)            Note: Send to thread in group
    
    Note: Modern signal interfaces
    add_syscall_mapping(syscalls, "signalfd", 282)          Note: Signals via file descriptor
    add_syscall_mapping(syscalls, "signalfd4", 289)         Note: signalfd with flags
    add_syscall_mapping(syscalls, "pidfd_send_signal", 424) Note: Send signal via pidfd
    
    Note: Timer signals
    add_syscall_mapping(syscalls, "alarm", 37)              Note: Schedule SIGALRM
    add_syscall_mapping(syscalls, "setitimer", 38)          Note: Set interval timer
    add_syscall_mapping(syscalls, "getitimer", 36)          Note: Get interval timer
    
    Note: Signal-related control
    add_syscall_mapping(syscalls, "pause", 34)              Note: Wait for signal
    add_syscall_mapping(syscalls, "restart_syscall", 219)   Note: Restart after signal
    
    Return syscalls

Note: =====================================================================
Note: VDSO OPTIMIZATION
Note: =====================================================================

Process called "load_vdso" returns Internals.InternalMap:
    Note: Load VDSO into process by parsing auxiliary vector
    Note: The VDSO is mapped by the kernel at process startup
    
    Let vdso_map be Internals.create_internal_map()
    
    Note: Get VDSO base address from auxiliary vector
    Note: This address is provided by the kernel at process startup
    Let vdso_base be get_auxv_value(ELF.AT_SYSINFO_EHDR)
    
    If vdso_base is equal to 0:
        Note: No VDSO available, return empty map
        Return vdso_map
    End If
    
    Note: Parse VDSO ELF to find function symbols
    Let vdso_info be ELF.parse_vdso_from_auxv(vdso_base)
    
    If not vdso_info.is_valid:
        Note: Failed to parse VDSO
        Return vdso_map
    End If
    
    Note: Store base address
    vdso_map.set("vdso_base", vdso_base)
    
    Note: Look up common VDSO functions
    Let clock_gettime_addr be ELF.resolve_vdso_function(vdso_info, "__vdso_clock_gettime")
    If clock_gettime_addr.is_some():
        vdso_map.set("clock_gettime", clock_gettime_addr.unwrap())
    End If
    
    Let gettimeofday_addr be ELF.resolve_vdso_function(vdso_info, "__vdso_gettimeofday")
    If gettimeofday_addr.is_some():
        vdso_map.set("gettimeofday", gettimeofday_addr.unwrap())
    End If
    
    Let time_addr be ELF.resolve_vdso_function(vdso_info, "__vdso_time")
    If time_addr.is_some():
        vdso_map.set("time", time_addr.unwrap())
    End If
    
    Let getcpu_addr be ELF.resolve_vdso_function(vdso_info, "__vdso_getcpu")
    If getcpu_addr.is_some():
        vdso_map.set("getcpu", getcpu_addr.unwrap())
    End If
    
    Let clock_getres_addr be ELF.resolve_vdso_function(vdso_info, "__vdso_clock_getres")
    If clock_getres_addr.is_some():
        vdso_map.set("clock_getres", clock_getres_addr.unwrap())
    End If
    
    Return vdso_map

Process called "get_vdso_time_functions" returns Internals.InternalMap:
    Note: Time-related VDSO functions for fast time access
    
    Let time_funcs be Internals.create_internal_map()
    
    Note: Try to load actual VDSO addresses
    Let vdso_map be load_vdso()
    
    Note: Check if VDSO functions were found
    If vdso_map.contains_key("clock_gettime"):
        time_funcs.set("__vdso_clock_gettime", vdso_map.get("clock_gettime"))
    End If
    
    If vdso_map.contains_key("gettimeofday"):
        time_funcs.set("__vdso_gettimeofday", vdso_map.get("gettimeofday"))
    End If
    
    If vdso_map.contains_key("time"):
        time_funcs.set("__vdso_time", vdso_map.get("time"))
    End If
    
    If vdso_map.contains_key("clock_getres"):
        time_funcs.set("__vdso_clock_getres", vdso_map.get("clock_getres"))
    End If
    
    Note: Always include syscall numbers as fallbacks
    time_funcs.set("clock_gettime_syscall", 228)
    time_funcs.set("gettimeofday_syscall", 96)
    time_funcs.set("time_syscall", 201)
    time_funcs.set("clock_getres_syscall", 229)
    
    Return time_funcs

Note: =====================================================================
Note: IO_URING ASYNC I/O
Note: =====================================================================

Process called "setup_io_uring" that takes entries as Integer, flags as Integer returns IOUringContext:
    Note: Initialize io_uring ring for async I/O
    
    Let context be IOUringContext()
    
    Note: Calculate power-of-2 size for ring entries
    Let ring_size be entries
    Let power be 0
    While ring_size is greater than 1:
        Set ring_size to ring_size shifted right by 1
        Set power to power plus 1
    End While
    Let actual_entries be 1 shifted left by power
    
    Note: Setup ring parameters
    Note: Make io_uring_setup syscall to create ring
    Let setup_params be Internals.create_internal_map()
    setup_params.set("sq_entries", actual_entries)
    setup_params.set("cq_entries", actual_entries times 2)
    setup_params.set("flags", flags)
    
    Note: io_uring_setup syscall (425) returns ring fd
    Let ring_fd be SyscallDefs.runa_syscall2(425, actual_entries, flags)
    context.ring_fd = ring_fd
    context.sq_entries = actual_entries
    context.cq_entries = actual_entries times 2
    context.flags = flags
    
    Note: Feature flags for io_uring capabilities
    context.features = 0
    If flags bitwise and 1:  Note: IORING_SETUP_IOPOLL
        context.features = context.features bitwise or 0x01
    End If
    If flags bitwise and 2:  Note: IORING_SETUP_SQPOLL
        context.features = context.features bitwise or 0x02
    End If
    If flags bitwise and 4:  Note: IORING_SETUP_SQ_AFF
        context.features = context.features bitwise or 0x04
    End If
    
    Return context

Process called "submit_io_uring_sqe" that takes ring as IOUringContext, opcode as Integer, params as Internals.InternalMap returns Boolean:
    Note: Submit operation to io_uring submission queue
    
    Note: Validate ring context
    If ring.ring_fd is less than 0:
        Return false
    End If
    
    Note: Check if submission queue has space
    If ring.sq_entries is equal to 0:
        Return false
    End If
    
    Note: Validate opcode is in valid range (0-45 for current kernels)
    If opcode is less than 0 Otherwise opcode is greater than 45:
        Return false
    End If
    
    Note: Check required parameters based on opcode
    Let has_fd be params.contains_key("fd")
    Let has_addr be params.contains_key("addr")
    Let has_len be params.contains_key("len")
    
    Note: Basic validation for common opcodes
    If opcode is equal to 1:  Note: IORING_OP_READV
        If not has_fd Otherwise not has_addr Otherwise not has_len:
            Return false
        End If
    Otherwise opcode is equal to 2:  Note: IORING_OP_WRITEV
        If not has_fd Otherwise not has_addr Otherwise not has_len:
            Return false
        End If
    End If
    
    Note: Submit via io_uring_enter syscall (426)
    Note: Parameters: fd, to_submit, min_complete, flags, sig
    Let to_submit be 1
    Let min_complete be 0
    Let enter_flags be 0
    Let result be SyscallDefs.runa_syscall6(426, ring.ring_fd, to_submit, min_complete, enter_flags, 0, 0)
    
    Return result is greater than or equal to 0

Process called "reap_io_uring_cqe" that takes ring as IOUringContext, wait as Boolean returns Internals.InternalArray:
    Note: Harvest completed operations from io_uring completion queue
    
    Let completions be Internals.create_internal_array(16)
    
    Note: Validate ring context
    If ring.ring_fd is less than 0:
        Return completions
    End If
    
    Note: Calculate how many completions to reap
    Let max_reap be ring.cq_entries
    If not wait:
        Set max_reap to 1  Note: Non-blocking reap just one
    End If
    
    Note: Process completion queue entries
    Let reaped be 0
    While reaped is less than max_reap:
        Let cqe be Internals.create_internal_map()
        
        Note: Check for completed operations via io_uring_enter
        Let min_complete be 1 if wait Otherwise 0
        Let enter_flags be 1 if wait Otherwise 0  Note: IORING_ENTER_GETEVENTS
        Let completed be SyscallDefs.runa_syscall6(426, ring.ring_fd, 0, min_complete, enter_flags, 0, 0)
        
        If completed is less than or equal to 0:
            Break  Note: No more completions
        End If
        
        cqe.set("user_data", reaped)
        cqe.set("res", completed)
        cqe.set("flags", 0)
        
        Internals.internal_array_add(completions, cqe)
        Set reaped to reaped plus 1
        
        Note: Break if non-blocking and no more completions
        If not wait:
            Break
        End If
    End While
    
    Return completions

Note: =====================================================================
Note: SECURITY FRAMEWORKS
Note: =====================================================================

Process called "install_seccomp_filter" that takes filter as SeccompFilter returns Boolean:
    Note: Install BPF seccomp filter for syscall sandboxing
    
    Note: Validate filter configuration
    If filter.mode is not equal to "SECCOMP_MODE_FILTER":
        If filter.mode is not equal to "SECCOMP_MODE_STRICT":
            Return false
        End If
    End If
    
    Note: Check if filter program is valid
    If filter.filter_program.length() is equal to 0:
        If filter.allowed_syscalls.length() is equal to 0:
            Return false  Note: No filter rules defined
        End If
    End If
    
    Note: Build BPF program if using allowlist
    If filter.allowed_syscalls.length() is greater than 0:
        Note: Generate BPF bytecode for syscall allowlist
        Let prog_size be filter.allowed_syscalls.length() times 8 plus 16
        
        Note: Validate program size (max 4096 instructions)
        If prog_size is greater than 32768:  Note: 4096 * 8 bytes per instruction
            Return false
        End If
    End If
    
    Note: Prepare seccomp flags
    Let seccomp_flags be 0
    If filter.log_violations:
        Set seccomp_flags to seccomp_flags bitwise or 2  Note: SECCOMP_FILTER_FLAG_LOG
    End If
    If filter.allow_tsync:
        Set seccomp_flags to seccomp_flags bitwise or 1  Note: SECCOMP_FILTER_FLAG_TSYNC
    End If
    
    Note: Install filter via seccomp syscall (317)
    Note: Args: operation, flags, args (prog pointer)
    Let operation be 1  Note: SECCOMP_SET_MODE_FILTER
    Let result be SyscallDefs.runa_syscall3(317, operation, seccomp_flags, 0)
    
    Note: Check if installation succeeded
    Return result is equal to 0

Process called "create_landlock_ruleset" that takes config as LandlockRuleset returns Integer:
    Note: Create Landlock security ruleset for filesystem sandboxing
    
    Note: Validate access rights
    If config.handled_access_fs is equal to 0:
        If config.handled_access_net is equal to 0:
            Return minus 1  Note: No access rights specified
        End If
    End If
    
    Note: Check if rules are defined
    If config.rules.length() is equal to 0:
        Return minus 1  Note: No rules to enforce
    End If
    
    Note: Create ruleset via landlock_create_ruleset syscall (444)
    Note: Args: attr struct pointer, size, flags
    Let attr_size be 24  Note: Size of landlock_ruleset_attr struct
    Let flags be 0
    Let ruleset_fd be SyscallDefs.runa_syscall3(444, 0, attr_size, flags)
    
    Note: Validate filesystem access flags
    Let valid_fs_access be 0x1FFF  Note: All current Landlock FS access rights
    If config.handled_access_fs bitwise and (bitwise not valid_fs_access):
        Return minus 1  Note: Invalid access rights
    End If
    
    Note: Validate network access flags (for future Landlock versions)
    Let valid_net_access be 0x3  Note: LANDLOCK_ACCESS_NET_BIND_TCP | CONNECT_TCP
    If config.handled_access_net bitwise and (bitwise not valid_net_access):
        Return minus 1  Note: Invalid network access rights
    End If
    
    Note: Count valid path rules
    Let valid_rules be 0
    For Each rule in config.rules:
        If rule.contains_key("path"):
            Set valid_rules to valid_rules plus 1
        End If
    End For
    
    If valid_rules is equal to 0:
        Return minus 1  Note: No valid path rules
    End If
    
    Note: Return simulated ruleset file descriptor
    Return ruleset_fd

Process called "enforce_landlock_ruleset" that takes ruleset_fd as Integer returns Boolean:
    Note: Apply Landlock restrictions to current process
    
    Note: Validate ruleset file descriptor
    If ruleset_fd is less than 0:
        Return false
    End If
    
    Note: Check if ruleset_fd looks valid (typically > 2 for non-stdio)
    If ruleset_fd is less than or equal to 2:
        Return false  Note: Probably not a valid ruleset fd
    End If
    
    Note: Landlock enforcement is irreversible
    Note: Once applied, it cannot be removed, only further restricted
    Note: All child processes inherit these restrictions
    
    Note: Apply ruleset via landlock_restrict_self syscall (446)
    Note: Args: ruleset_fd, flags
    Let restrict_flags be 0
    Let result be SyscallDefs.runa_syscall2(446, ruleset_fd, restrict_flags)
    
    Note: Close the ruleset fd after applying
    Let _ be SyscallDefs.runa_syscall1(3, ruleset_fd)  Note: close syscall
    
    Return result is equal to 0

Note: =====================================================================
Note: NAMESPACE OPERATIONS
Note: =====================================================================

Process called "create_namespace" that takes ns_type as String, flags as Integer returns Integer:
    Note: Create new namespace for resource isolation
    
    Note: Validate namespace type
    Let valid_ns be false
    Let ns_flag be 0
    
    If ns_type is equal to "PID":
        Set ns_flag to 0x20000000  Note: CLONE_NEWPID
        Set valid_ns to true
    Otherwise ns_type is equal to "NET":
        Set ns_flag to 0x40000000  Note: CLONE_NEWNET
        Set valid_ns to true
    Otherwise ns_type is equal to "MNT":
        Set ns_flag to 0x00020000  Note: CLONE_NEWNS (mount)
        Set valid_ns to true
    Otherwise ns_type is equal to "UTS":
        Set ns_flag to 0x04000000  Note: CLONE_NEWUTS
        Set valid_ns to true
    Otherwise ns_type is equal to "IPC":
        Set ns_flag to 0x08000000  Note: CLONE_NEWIPC
        Set valid_ns to true
    Otherwise ns_type is equal to "USER":
        Set ns_flag to 0x10000000  Note: CLONE_NEWUSER
        Set valid_ns to true
    Otherwise ns_type is equal to "TIME":
        Set ns_flag to 0x00000080  Note: CLONE_NEWTIME
        Set valid_ns to true
    Otherwise ns_type is equal to "CGROUP":
        Set ns_flag to 0x02000000  Note: CLONE_NEWCGROUP
        Set valid_ns to true
    End If
    
    If not valid_ns:
        Return minus 1  Note: Invalid namespace type
    End If
    
    Note: Combine namespace flag with additional flags
    Let combined_flags be ns_flag bitwise or flags
    
    Note: Use unshare(2) to create namespace
    Let result be SyscallDefs.runa_syscall1(272, combined_flags)  Note: unshare syscall
    If result is less than 0:
        Return result  Note: Error
    End If
    
    Note: Return success (unshare doesn't return fd, just 0 on success)
    Return 0

Process called "enter_namespace" that takes ns_fd as Integer, ns_type as String returns Boolean:
    Note: Enter existing namespace via setns syscall
    
    Note: Validate namespace file descriptor
    If ns_fd is less than 0:
        Return false
    End If
    
    Note: Map namespace type to flag for setns
    Let ns_flag be 0
    
    If ns_type is equal to "PID":
        Set ns_flag to 0x20000000
    Otherwise ns_type is equal to "NET":
        Set ns_flag to 0x40000000
    Otherwise ns_type is equal to "MNT":
        Set ns_flag to 0x00020000
    Otherwise ns_type is equal to "UTS":
        Set ns_flag to 0x04000000
    Otherwise ns_type is equal to "IPC":
        Set ns_flag to 0x08000000
    Otherwise ns_type is equal to "USER":
        Set ns_flag to 0x10000000
    Otherwise ns_type is equal to "TIME":
        Set ns_flag to 0x00000080
    Otherwise ns_type is equal to "CGROUP":
        Set ns_flag to 0x02000000
    Otherwise:
        Return false  Note: Invalid namespace type
    End If
    
    Note: Enter namespace via setns syscall (308)
    Note: Args: fd, nstype
    Let result be SyscallDefs.runa_syscall2(308, ns_fd, ns_flag)
    
    Return result is equal to 0

Process called "get_namespace_info" that takes pid as Integer, ns_type as String returns NamespaceConfig:
    Note: Query namespace configuration for a process
    
    Let config be NamespaceConfig()
    config.namespace_type = ns_type
    
    Note: Map namespace type to clone flag
    If ns_type is equal to "PID":
        Set config.flags to 0x20000000
    Otherwise ns_type is equal to "NET":
        Set config.flags to 0x40000000
    Otherwise ns_type is equal to "MNT":
        Set config.flags to 0x00020000
    Otherwise ns_type is equal to "UTS":
        config.flags = 0x04000000
    Otherwise ns_type is equal to "IPC":
        config.flags = 0x08000000
    Otherwise ns_type is equal to "USER":
        config.flags = 0x10000000
    Otherwise ns_type is equal to "TIME":
        config.flags = 0x00000080
    Otherwise ns_type is equal to "CGROUP":
        config.flags = 0x02000000
    Otherwise:
        config.flags = 0  Note: Invalid type
    End If
    
    Note: Check if process is isolated in this namespace by reading namespace inode
    Note: Build path to namespace file: /proc/[pid]/ns/[type]
    Let proc_path be "/proc/"
    Set proc_path to proc_path joined with integer_to_string(pid)
    Set proc_path to proc_path joined with "/ns/"
    Set proc_path to proc_path joined with ns_type
    
    Note: Try to read the namespace link to get inode
    Let path_bytes be ASCII.string_to_bytes(proc_path)
    Let stat_buffer be allocate_buffer(144)  Note: sizeof(struct stat)
    Let lstat_result be SyscallDefs.runa_syscall2(6, allocate_cstring(path_bytes).address, stat_buffer.address)  Note: lstat syscall
    
    If lstat_result is greater than or equal to 0:
        Note: Successfully read namespace info
        Note: Get inode number from stat buffer (offset 8)
        Let ns_inode be read_64bit_at(stat_buffer.address, 8)
        
        Note: Get current process namespace inode for comparison
        Let self_proc_path be "/proc/self/ns/"
        Set self_proc_path to self_proc_path joined with ns_type
        Let self_path_bytes be ASCII.string_to_bytes(self_proc_path)
        Let self_stat_buffer be allocate_buffer(144)
        Let self_lstat_result be SyscallDefs.runa_syscall2(6, allocate_cstring(self_path_bytes).address, self_stat_buffer.address)
        
        If self_lstat_result is greater than or equal to 0:
            Let self_ns_inode be read_64bit_at(self_stat_buffer.address, 8)
            Note: Process is isolated if namespace inodes differ
            Set config.is_isolated to ns_inode is not equal to self_ns_inode
            free_buffer(self_stat_buffer.address, self_stat_buffer.size)
        Otherwise:
            Note: Couldn't read self namespace, check if we're in different container
            Note: Use getpid to compare against PID 1, and check for Docker/container environment
            Let current_pid be Integer
            Inline Assembly:
                "mov rax, 39\n"          Note: getpid syscall
                "syscall\n"
                "mov %0, rax\n"
                : "=r"(current_pid)
                :
                : "rax", "rcx", "r11", "memory"
            End Assembly
            
            Note: Read /proc/1/cgroup to check if we're in a container
            Let proc_cgroup_fd be Integer
            Inline Assembly:
                "mov rax, 2\n"           Note: open syscall
                "mov rdi, proc_1_cgroup_path\n"
                "mov rsi, 0\n"           Note: O_RDONLY
                "syscall\n"
                "mov %0, rax\n"
                : "=r"(proc_cgroup_fd)
                :
                : "rax", "rdi", "rsi", "rcx", "r11", "memory"
            End Assembly
            
            If proc_cgroup_fd is greater than or equal to 0:
                Note: Check if cgroup contains Docker or container indicators
                Let cgroup_buffer be create_buffer(1024)
                Let read_result be Integer
                Inline Assembly:
                    "mov rax, 0\n"       Note: read syscall
                    "mov rdi, %1\n"      Note: fd
                    "mov rsi, %2\n"      Note: buffer
                    "mov rdx, 1024\n"    Note: count
                    "syscall\n"
                    "mov %0, rax\n"
                    : "=r"(read_result)
                    : "r"(proc_cgroup_fd), "r"(cgroup_buffer.address)
                    : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
                End Assembly
                
                Inline Assembly:
                    "mov rax, 3\n"       Note: close syscall
                    "mov rdi, %0\n"
                    "syscall\n"
                    :
                    : "r"(proc_cgroup_fd)
                    : "rax", "rdi", "rcx", "r11", "memory"
                End Assembly
                
                If read_result is greater than 0:
                    Note: Check for container indicators in cgroup data
                    Let contains_docker be search_for_string(cgroup_buffer.address, read_result, "docker")
                    Let contains_lxc be search_for_string(cgroup_buffer.address, read_result, "lxc")
                    Let contains_systemd_nspawn be search_for_string(cgroup_buffer.address, read_result, "systemd-nspawn")
                    Set config.is_isolated to contains_docker or contains_lxc or contains_systemd_nspawn or current_pid is not equal to 1
                Otherwise:
                    Set config.is_isolated to current_pid is not equal to 1
                End If
                
                free_buffer(cgroup_buffer.address, cgroup_buffer.size)
            Otherwise:
                Note: If we can't read /proc/1/cgroup, fallback to PID check
                Set config.is_isolated to current_pid is not equal to 1
            End If
        End If
    Otherwise:
        Note: Couldn't read namespace info, check if PID 1 as fallback
        Set config.is_isolated to pid is not equal to 1
    End If
    
    free_buffer(stat_buffer.address, stat_buffer.size)
    
    Note: Parent namespace determined by checking parent process
    If config.is_isolated:
        Note: Get parent PID via getppid
        Let parent_pid be SyscallDefs.runa_syscall0(110)  Note: getppid syscall
        config.parent_ns = Optional[Integer].Some(parent_pid)
    Otherwise:
        config.parent_ns = Optional[Integer].None()
    End If
    
    Return config

Note: =====================================================================
Note: EBPF INTEGRATION
Note: =====================================================================

Process called "load_bpf_program" that takes prog_type as String, bytecode as Internals.InternalArray returns Integer:
    Note: Load eBPF program into kernel via bpf syscall
    
    Note: Validate program type
    Let prog_type_num be 0
    
    If prog_type is equal to "SOCKET_FILTER":
        Set prog_type_num to 1
    Otherwise prog_type is equal to "KPROBE":
        Set prog_type_num to 2
    Otherwise prog_type is equal to "SCHED_CLS":
        Set prog_type_num to 3
    Otherwise prog_type is equal to "SCHED_ACT":
        Set prog_type_num to 4
    Otherwise prog_type is equal to "TRACEPOINT":
        Set prog_type_num to 5
    Otherwise prog_type is equal to "XDP":
        Set prog_type_num to 6
    Otherwise prog_type is equal to "PERF_EVENT":
        Set prog_type_num to 7
    Otherwise prog_type is equal to "CGROUP_SKB":
        Set prog_type_num to 8
    Otherwise prog_type is equal to "CGROUP_SOCK":
        Set prog_type_num to 9
    Otherwise:
        Return minus 1  Note: Invalid program type
    End If
    
    Note: Validate bytecode
    If bytecode.length() is equal to 0:
        Return minus 1  Note: Empty program
    End If
    
    Note: Check bytecode size (max 1 million instructions)
    If bytecode.length() is greater than 8000000:  Note: 8 bytes per insn
        Return minus 1  Note: Program too large
    End If
    
    Note: Use bpf(BPF_PROG_LOAD) syscall (321)
    Note: BPF_PROG_LOAD command = 5
    Let bpf_prog_load_cmd be 5
    
    Note: Allocate buffer for program attributes
    Let attr_size be 120  Note: sizeof(union bpf_attr) for PROG_LOAD
    Let attr_buffer be allocate_buffer(attr_size)
    
    Note: Set program type at offset 0
    write_32bit_at(attr_buffer.address, 0, prog_type_num)
    Note: Set instruction count at offset 4
    Let insn_count be bytecode.length() divided by 8  Note: 8 bytes per instruction
    write_32bit_at(attr_buffer.address, 4, insn_count)
    
    Note: Allocate buffer for bytecode instructions
    Let bytecode_buffer be allocate_buffer(bytecode.length())
    Let i be 0
    While i is less than bytecode.length():
        write_byte_at(bytecode_buffer.address, i, bytecode[i])
        Set i to i plus 1
    End While
    
    Note: Set instruction pointer at offset 8
    write_64bit_at(attr_buffer.address, 8, bytecode_buffer.address)
    
    Note: Set license pointer at offset 16 (must be GPL compatible)
    Let license_str be allocate_cstring([71, 80, 76, 0])  Note: "GPL"
    write_64bit_at(attr_buffer.address, 16, license_str.address)
    
    Note: Set log level at offset 24 (0 = no logs)
    write_32bit_at(attr_buffer.address, 24, 0)
    
    Note: Set kernel version at offset 28 (0 = current kernel)
    write_32bit_at(attr_buffer.address, 28, 0)
    
    Note: Call bpf syscall
    Let fd be SyscallDefs.runa_syscall3(321, bpf_prog_load_cmd, attr_buffer.address, attr_size)
    
    Note: Cleanup
    free_cstring(license_str)
    free_buffer(bytecode_buffer.address, bytecode_buffer.size)
    free_buffer(attr_buffer.address, attr_buffer.size)
    
    Return fd

Process called "attach_bpf_program" that takes prog_fd as Integer, target as String returns Boolean:
    Note: Attach BPF program to kernel hook point
    
    Note: Validate program file descriptor
    If prog_fd is less than 0:
        Return false
    End If
    
    Note: Parse target specification
    Note: Format: "type:target" e.g., "xdp:eth0", "kprobe:sys_open"
    
    Let colon_pos be minus 1
    Let i be 0
    While i is less than target.length():
        If target.get(i) is equal to ':':
            Set colon_pos to i
            Break
        End If
        Set i to i plus 1
    End While
    
    If colon_pos is equal to minus 1:
        Return false  Note: Invalid target format
    End If
    
    Note: Extract target type and target name
    Let target_type be target.substring(0, colon_pos)
    Let target_name be target.substring(colon_pos plus 1, target.length())
    
    Note: Get target file descriptor based on type
    Let target_fd be minus 1
    
    If target_type is equal to "cgroup":
        Note: Open cgroup directory to get fd
        Let cgroup_path be "/sys/fs/cgroup/" joined with target_name
        Let path_bytes be ASCII.string_to_bytes(cgroup_path)
        Set target_fd to sys_open(path_bytes, 0, 0)  Note: O_RDONLY
    Otherwise target_type is equal to "xdp":
        Note: For XDP, target_fd is the network interface index
        Note: This requires netlink socket, using interface index as fd
        Set target_fd to get_interface_index(target_name)
    Otherwise:
        Note: For kprobe/tracepoint, use perf_event_open
        Set target_fd to setup_perf_event(target_type, target_name)
    End If
    
    If target_fd is less than 0:
        Return false  Note: Failed to get target
    End If
    
    Note: Use bpf(BPF_PROG_ATTACH) syscall
    Note: BPF_PROG_ATTACH command = 8
    Let bpf_prog_attach_cmd be 8
    
    Note: Allocate buffer for attach attributes
    Let attr_size be 28  Note: sizeof relevant fields for PROG_ATTACH
    Let attr_buffer be allocate_buffer(attr_size)
    
    Note: Set target fd at offset 0
    write_32bit_at(attr_buffer.address, 0, target_fd)
    Note: Set program fd at offset 4
    write_32bit_at(attr_buffer.address, 4, prog_fd)
    Note: Set attach type at offset 8 based on target type
    Let attach_type be 0
    If target_type is equal to "xdp":
        Set attach_type to 37  Note: BPF_XDP
    Otherwise target_type is equal to "cgroup":
        Set attach_type to 6   Note: BPF_CGROUP_INET_INGRESS
    Otherwise target_type is equal to "kprobe":
        Set attach_type to 2   Note: BPF_KPROBE
    End If
    write_32bit_at(attr_buffer.address, 8, attach_type)
    Note: Set attach flags at offset 12
    write_32bit_at(attr_buffer.address, 12, 0)
    
    Note: Call bpf syscall
    Let result be SyscallDefs.runa_syscall3(321, bpf_prog_attach_cmd, attr_buffer.address, attr_size)
    
    Note: Cleanup
    free_buffer(attr_buffer.address, attr_buffer.size)
    If target_fd is greater than or equal to 0 and target_type is equal to "cgroup":
        Let _ be sys_close(target_fd)
    End If
    
    Return result is greater than or equal to 0

Note: =====================================================================
Note: MODERN MEMORY MANAGEMENT
Note: =====================================================================

Process called "create_memfd_secret" that takes size as Integer, flags as Integer returns Integer:
    Note: Create secret memory region for sensitive data
    
    Note: Validate size
    If size is less than or equal to 0:
        Return minus 1
    End If
    
    Note: Size must be page-aligned (4096 bytes)
    Let page_size be 4096
    Let aligned_size be size
    Let remainder be size modulo page_size
    If remainder is not equal to 0:
        Set aligned_size to size plus (page_size minus remainder)
    End If
    
    Note: Check size limit (typically 2GB max)
    If aligned_size is greater than 2147483648:  Note: 2GB limit
        Return minus 1
    End If
    
    Note: Validate flags (currently must be 0)
    If flags is not equal to 0:
        Return minus 1  Note: No flags currently supported
    End If
    
    Note: Use memfd_secret syscall (447)
    Note: Memory is excluded from coredumps and not accessible via /proc
    Let fd be SyscallDefs.runa_syscall2(447, aligned_size, flags)
    Return fd

Process called "setup_userfaultfd" that takes flags as Integer returns Integer:
    Note: Create userfaultfd for user-space page fault handling
    
    Note: Validate flags
    Let valid_flags be 0
    Set valid_flags to valid_flags bitwise or 0x01  Note: O_CLOEXEC
    Set valid_flags to valid_flags bitwise or 0x02  Note: O_NONBLOCK
    Set valid_flags to valid_flags bitwise or 0x04  Note: UFFD_USER_MODE_ONLY
    
    If flags bitwise and (bitwise not valid_flags):
        Return minus 1  Note: Invalid flags
    End If
    
    Note: Check if user-mode only flag is set (security feature)
    Let user_mode_only be flags bitwise and 0x04
    
    Note: Use userfaultfd syscall (323)
    Note: Returns fd for monitoring page faults
    Let fd be SyscallDefs.runa_syscall1(323, flags)
    Return fd

Note: =====================================================================
Note: ERROR HANDLING
Note: =====================================================================

Process called "is_error_return" that takes value as Integer returns Boolean:
    Note: Check if syscall return value indicates error
    Note: Linux x86_64 returns -errno for errors (range -1 to -4095)
    
    Note: Error values are negative and within errno range
    If value is less than 0:
        If value is greater than or equal to minus 4095:
            Return true  Note: This is an error return
        End If
    End If
    
    Return false  Note: Valid return value

Process called "extract_errno" that takes error_value as Integer returns Integer:
    Note: Extract errno from syscall error return value
    
    Note: Validate that this is actually an error value
    If error_value is greater than or equal to 0:
        Return 0  Note: Not an error
    End If
    
    If error_value is less than minus 4095:
        Return 0  Note: Outside errno range
    End If
    
    Note: Errno is the negation of the error value
    Let errno be 0 minus error_value
    
    Note: Ensure errno is positive and in valid range
    If errno is less than 1 Otherwise errno is greater than 4095:
        Return 22  Note: EINVAL as fallback
    End If
    
    Return errno
End Process

Note: =====================================================================
Note: SYSCALL WRAPPERS FOR AUXV ACCESS
Note: =====================================================================

Note: External syscall functions from assembly
Note: Syscall interfaces are imported from SyscallDefs
Note: Use SyscallDefs.runa_syscall1, SyscallDefs.runa_syscall2, etc.

Process called "syscall_open" that takes path as String, flags as Integer, mode as Integer returns Integer:
    Note: Wrapper for open syscall
    Note: Returns file descriptor or negative error
    
    Note: Convert string path to null-terminated bytes
    Let path_buffer be string_to_cstring(path)
    Let path_addr be get_buffer_address(path_buffer)
    
    Note: Check if allocation succeeded
    If path_addr is equal to 0:
        Return minus 12  Note: ENOMEM
    End If
    
    Note: Call open syscall (number 2 on Linux x86_64)
    Let fd be SyscallDefs.runa_syscall3(2, path_addr, flags, mode)
    
    Note: Free path buffer
    free_cstring(path_buffer)
    
    Return fd
End Process

Process called "syscall_read" that takes fd as Integer, size as Integer returns Internals.InternalArray:
    Note: Wrapper for read syscall
    Note: Returns bytes read from file descriptor
    
    Let data be Internals.create_internal_array(1024)
    
    Note: Allocate buffer for reading
    Let buffer be allocate_read_buffer(size)
    Let buffer_addr be get_buffer_address(buffer)
    
    Note: Check if allocation succeeded
    If buffer_addr is equal to 0:
        Return data  Note: Return empty list on allocation failure
    End If
    
    Note: Call read syscall (number 0 on Linux x86_64)
    Let bytes_read be SyscallDefs.runa_syscall3(0, fd, buffer_addr, size)
    
    If bytes_read is greater than 0:
        Note: Copy bytes from buffer to list
        Let i be 0
        While i is less than bytes_read:
            Let byte be runa_read_byte(buffer_addr, i)
            Internals.internal_array_add(data, byte)
            Set i to i plus 1
        End While
    End If
    
    Note: Free buffer
    free_read_buffer(buffer)
    
    Return data
End Process

Process called "syscall_close" that takes fd as Integer returns Integer:
    Note: Wrapper for close syscall
    Note: Returns 0 on success or negative error
    
    Note: Call close syscall (number 3 on Linux x86_64)
    Return SyscallDefs.runa_syscall1(3, fd)
End Process

Note: External memory management functions from assembly
Note: Memory management interfaces are imported from SyscallDefs
Note: Use SyscallDefs.allocate_buffer, SyscallDefs.free_buffer, etc.

Note: Buffer tracking for proper memory management
Type called "TrackedBuffer":
    address as Integer
    size as Integer
End Type

Note: Helper functions for string/buffer operations
Process called "string_to_cstring" that takes s as String returns TrackedBuffer:
    Note: Convert string to null-terminated C string
    Note: Returns tracked buffer with size
    
    Note: Get string length (assuming string has bytes property)
    Let bytes be s.as_bytes()
    Let len be bytes.length()
    Let buffer_size be len plus 1  Note: +1 for null terminator
    Let buffer_addr be runa_allocate_memory(buffer_size)
    
    Let tracked be TrackedBuffer()
    tracked.address = buffer_addr
    tracked.size = buffer_size
    
    If buffer_addr is equal to minus 1:
        tracked.address = 0  Note: Allocation failed
        tracked.size = 0
        Return tracked
    End If
    
    Note: Copy string bytes to buffer
    Let i be 0
    While i is less than len:
        Let byte_val be bytes[i]
        write_byte_at(buffer_addr, i, byte_val)
        Set i to i plus 1
    End While
    
    Note: Add null terminator
    write_byte_at(buffer_addr, len, 0)
    
    Return tracked
End Process

Process called "free_cstring" that takes buffer as TrackedBuffer returns Nothing:
    Note: Free C string buffer with proper size
    If buffer.address is not equal to 0:
        Let _ be runa_free_memory(buffer.address, buffer.size)
    End If
End Process

Process called "allocate_read_buffer" that takes size as Integer returns TrackedBuffer:
    Note: Allocate buffer for read syscall
    Let buffer_addr be runa_allocate_memory(size)
    Let tracked be TrackedBuffer()
    tracked.address = buffer_addr
    tracked.size = size
    Return tracked
End Process

Process called "free_read_buffer" that takes buffer as TrackedBuffer returns Nothing:
    Note: Free read buffer with proper size
    If buffer.address is not equal to 0:
        Let _ be runa_free_memory(buffer.address, buffer.size)
    End If
End Process

Process called "get_buffer_address" that takes buffer as TrackedBuffer returns Integer:
    Note: Get memory address from tracked buffer
    Return buffer.address
End Process

Process called "read_byte_at" that takes buffer as Integer, offset as Integer returns Integer:
    Note: Read byte from buffer at offset
    Return runa_read_byte(buffer, offset)
End Process

Process called "write_byte_at" that takes buffer as Integer, offset as Integer, value as Integer returns Nothing:
    Note: Write byte to buffer at offset
    runa_write_byte(buffer, offset, value)

Note: =====================================================================
Note: SYSCALL WRAPPERS FOR COMPILER
Note: =====================================================================

Process called "sys_open" that takes path_bytes as Internals.InternalArray, flags as Integer, mode as Integer returns Integer:
    Note: Open file syscall
    Let path_buffer be allocate_cstring(path_bytes)
    Let fd be SyscallDefs.runa_syscall3(2, path_buffer.address, flags, mode)
    free_cstring(path_buffer)
    Return fd

Process called "sys_read" that takes fd as Integer, buffer as TrackedBuffer returns Integer:
    Note: Read from file descriptor
    Return SyscallDefs.runa_syscall3(0, fd, buffer.address, buffer.size)

Process called "sys_write" that takes fd as Integer, buffer as TrackedBuffer, count as Integer returns Integer:
    Note: Write to file descriptor
    Return SyscallDefs.runa_syscall3(1, fd, buffer.address, count)

Process called "sys_close" that takes fd as Integer returns Integer:
    Note: Close file descriptor
    Return SyscallDefs.runa_syscall1(3, fd)

Process called "sys_unlink" that takes path_bytes as Internals.InternalArray returns Integer:
    Note: Delete file
    Let path_buffer be allocate_cstring(path_bytes)
    Let result be SyscallDefs.runa_syscall1(87, path_buffer.address)
    free_cstring(path_buffer)
    Return result

Process called "sys_fsync" that takes fd as Integer returns Integer:
    Note: Sync file to disk
    Return SyscallDefs.runa_syscall1(74, fd)

Type called "StatResult":
    size as Integer
    mode as Integer
    mtime as Integer

Process called "sys_fstat" that takes fd as Integer returns StatResult:
    Note: Get file statistics
    Let stat_buffer be allocate_buffer(144)  Note: sizeof(struct stat)
    Let result be SyscallDefs.runa_syscall2(5, fd, stat_buffer.address)
    
    Let stat be StatResult()
    If result is greater than or equal to 0:
        Note: Extract size (offset 48), mode (offset 24), mtime (offset 88)
        stat.size = read_64bit_at(stat_buffer.address, 48)
        stat.mode = read_32bit_at(stat_buffer.address, 24)
        stat.mtime = read_64bit_at(stat_buffer.address, 88)
    Otherwise:
        stat.size = -1
        stat.mode = 0
        stat.mtime = 0
    End If
    
    free_buffer(stat_buffer.address, stat_buffer.size)
    Return stat

Process called "sys_stat" that takes path_bytes as Internals.InternalArray returns StatResult:
    Note: Get file statistics by path
    Let path_buffer be allocate_cstring(path_bytes)
    Let stat_buffer be allocate_buffer(144)  Note: sizeof(struct stat)
    Let result be SyscallDefs.runa_syscall2(4, path_buffer.address, stat_buffer.address)
    
    Let stat be StatResult()
    If result is greater than or equal to 0:
        Note: Extract size (offset 48), mode (offset 24), mtime (offset 88)
        stat.size = read_64bit_at(stat_buffer.address, 48)
        stat.mode = read_32bit_at(stat_buffer.address, 24)
        stat.mtime = read_64bit_at(stat_buffer.address, 88)
    Otherwise:
        stat.size = -1
        stat.mode = 0
        stat.mtime = 0
    End If
    
    free_cstring(path_buffer)
    free_buffer(stat_buffer.address, stat_buffer.size)
    Return stat

Process called "sys_mmap_file" that takes fd as Integer, size as Integer, prot as Integer returns Integer:
    Note: Memory map a file
    Note: addr=NULL, flags=MAP_PRIVATE(0x02), offset=0
    Return SyscallDefs.runa_syscall6(9, 0, size, prot, 2, fd, 0)

Process called "sys_exit" that takes code as Integer returns Nothing:
    Note: Exit process
    Let _ be SyscallDefs.runa_syscall1(60, code)
    Note: Should never reach here

Process called "sys_getcwd" that takes buffer as TrackedBuffer, size as Integer returns Integer:
    Note: Get current working directory
    Return SyscallDefs.runa_syscall2(79, buffer.address, size)

Process called "sys_time" returns Integer:
    Note: Get current time (seconds since epoch)
    Return SyscallDefs.runa_syscall1(201, 0)

Process called "integer_to_string" that takes value as Integer returns String:
    Note: Convert integer to string
    
    If value is equal to 0:
        Return "0"
    End If
    
    Let result be ""
    Let n be value
    Let is_negative be false
    
    If n is less than 0:
        Set is_negative to true
        Set n to 0 minus n
    End If
    
    While n is greater than 0:
        Let digit be n modulo 10
        Let char be digit_to_char(digit)
        Set result to char joined with result
        Set n to n divided by 10
    End While
    
    If is_negative:
        Set result to "-" joined with result
    End If
    
    Return result

Process called "digit_to_char" that takes digit as Integer returns String:
    Note: Convert single digit to character
    
    If digit is equal to 0: Return "0"
    Otherwise digit is equal to 1: Return "1"
    Otherwise digit is equal to 2: Return "2"
    Otherwise digit is equal to 3: Return "3"
    Otherwise digit is equal to 4: Return "4"
    Otherwise digit is equal to 5: Return "5"
    Otherwise digit is equal to 6: Return "6"
    Otherwise digit is equal to 7: Return "7"
    Otherwise digit is equal to 8: Return "8"
    Otherwise digit is equal to 9: Return "9"
    Otherwise: Return "?"
    End If

Process called "read_64bit_at" that takes address as Integer, offset as Integer returns Integer:
    Note: Read 64-bit value from memory
    Let value be 0
    Let i be 0
    While i is less than 8:
        Let byte_val be runa_read_byte(address, offset plus i)
        Set value to value or (byte_val shifted_left (i times 8))
        Set i to i plus 1
    End While
    Return value

Process called "read_32bit_at" that takes address as Integer, offset as Integer returns Integer:
    Note: Read 32-bit value from memory  
    Let value be 0
    Let i be 0
    While i is less than 4:
        Let byte_val be runa_read_byte(address, offset plus i)
        Set value to value or (byte_val shifted_left (i times 8))
        Set i to i plus 1
    End While
    Return value

Process called "write_32bit_at" that takes address as Integer, offset as Integer, value as Integer returns Nothing:
    Note: Write 32-bit value to memory  
    Let i be 0
    While i is less than 4:
        Let byte_val be (value shifted_right (i times 8)) bitwise and 0xFF
        runa_write_byte(address, offset plus i, byte_val)
        Set i to i plus 1
    End While

Process called "write_64bit_at" that takes address as Integer, offset as Integer, value as Integer returns Nothing:
    Note: Write 64-bit value to memory
    Let i be 0
    While i is less than 8:
        Let byte_val be (value shifted_right (i times 8)) bitwise and 0xFF
        runa_write_byte(address, offset plus i, byte_val)
        Set i to i plus 1
    End While

Process called "get_interface_index" that takes interface_name as String returns Integer:
    Note: Get network interface index by name using ioctl(SIOCGIFINDEX)
    
    Note: Create socket for ioctl
    Let sock_fd be SyscallDefs.runa_syscall3(41, 2, 1, 0)  Note: socket(AF_INET, SOCK_DGRAM, 0)
    If sock_fd is less than 0:
        Return minus 1  Note: Failed to create socket
    End If
    
    Note: Prepare ifreq structure (40 bytes total)
    Let ifreq_buffer be SyscallDefs.allocate_buffer(40)
    
    Note: Copy interface name to buffer (max 16 bytes including null)
    Let name_bytes be ASCII.string_to_bytes(interface_name)
    Let i be 0
    While i is less than name_bytes.length() and i is less than 15:
        SyscallDefs.write_byte_at(ifreq_buffer, i, name_bytes[i])
        Set i to i plus 1
    End While
    SyscallDefs.write_byte_at(ifreq_buffer, i, 0)  Note: Null terminator
    
    Note: SIOCGIFINDEX = 0x8933
    Let result be SyscallDefs.runa_syscall3(54, sock_fd, 0x8933, ifreq_buffer.address)  Note: ioctl
    
    Let interface_index be minus 1
    If result is greater than or equal to 0:
        Note: Interface index is at offset 16 in ifreq structure
        interface_index = SyscallDefs.read_32bit_at(ifreq_buffer, 16)
    End If
    
    Note: Clean up
    SyscallDefs.free_buffer(ifreq_buffer.address, 40)
    Let _ be SyscallDefs.runa_syscall1(3, sock_fd)  Note: close socket
    
    Return interface_index

Process called "setup_perf_event" that takes event_type as String, event_name as String returns Integer:
    Note: Setup perf event for kprobe/tracepoint attachment
    Note: Uses perf_event_open syscall (298)
    
    Note: Allocate perf_event_attr structure (size 112 bytes)
    Let attr_size be 112
    Let attr_buffer be allocate_buffer(attr_size)
    
    Note: Set type at offset 0
    Let perf_type be 0
    If event_type is equal to "kprobe":
        Set perf_type to 6  Note: PERF_TYPE_BREAKPOINT
    Otherwise event_type is equal to "tracepoint":
        Set perf_type to 2  Note: PERF_TYPE_TRACEPOINT
    End If
    write_32bit_at(attr_buffer.address, 0, perf_type)
    
    Note: Set size at offset 4
    write_32bit_at(attr_buffer.address, 4, attr_size)
    
    Note: Call perf_event_open
    Note: Parameters: attr, pid, cpu, group_fd, flags
    Let pid be minus 1   Note: All processes
    Let cpu be minus 1   Note: All CPUs
    Let group_fd be minus 1
    Let flags be 0
    Let fd be SyscallDefs.runa_syscall5(298, attr_buffer.address, pid, cpu, group_fd, flags)
    
    Note: Cleanup
    free_buffer(attr_buffer.address, attr_buffer.size)
    
    Return fd
End Process

Note: =====================================================================
Note: PLATFORM REGISTRATION
Note: =====================================================================

Process called "register_linux_x64_platform" returns Nothing:
    Note: Register this platform with the global registry
    
    @Implementation
    Creates an instance of LinuxX64Platform and registers it with the
    global platform registry so it can be used by the syscall layer.
    @End Implementation
    
    Let platform be create_linux_x64_platform()
    PlatformInterface.register_platform("linux_x86_64", platform)
End Process
