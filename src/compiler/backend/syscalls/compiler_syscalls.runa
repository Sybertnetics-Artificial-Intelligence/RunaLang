Note:
runa/src/compiler/backend/syscalls/compiler_syscalls.runa
Minimal Syscalls for Compiler Operations

This module provides the minimal set of syscalls required for the compiler
itself to function. These are the only syscalls the compiler needs to read
source files, write output, and manage compilation resources.

Key features and capabilities:
- File I/O syscalls for reading source and writing output
- Memory management syscalls for compilation buffers
- Process control syscalls for compiler termination
- Error reporting syscalls for diagnostics
- Minimal dependency footprint
- Cross-platform abstraction layer
- Efficient syscall usage patterns
- Error handling and recovery
- Resource cleanup on exit
- Temporary file management
- Compiler cache operations
- Build system integration
:End Note

Import "compiler/frontend/diagnostics/errors" as Errors
Import "compiler/backend/syscalls/platforms/linux_x64" as Linux
Import "compiler/frontend/primitives/types/ascii_conversion" as ASCII

Note: =====================================================================
Note: COMPILER SYSCALL DATA STRUCTURES
Note: =====================================================================

Type called "FileHandle":
    fd as Integer                           Note: File descriptor
    path as String                          Note: File path for debugging
    mode as String                          Note: Open mode (read, write, etc.)
    is_temporary as Boolean                 Note: Whether this is a temp file
    should_delete_on_close as Boolean       Note: Auto-delete temporary files

Type called "MemoryMapping":
    address as Integer                      Note: Base address of mapping
    size as Integer                        Note: Size of mapped region
    protection as Integer                   Note: Memory protection flags
    is_file_backed as Boolean              Note: Whether backed by a file
    file_handle as Optional[FileHandle]    Note: Associated file if any

Type called "CompilerResource":
    resource_type as String                 Note: Type (file, memory, etc.)
    resource_id as Integer                  Note: Unique identifier
    cleanup_required as Boolean             Note: Whether cleanup needed
    cleanup_action as String               Note: How to clean up

Type called "CompilationContext":
    source_files as List[FileHandle]       Note: Open source files
    output_file as FileHandle               Note: Output file handle
    temp_files as List[FileHandle]         Note: Temporary files
    memory_mappings as List[MemoryMapping] Note: Active memory mappings
    error_count as Integer                  Note: Compilation errors encountered

Note: =====================================================================
Note: FILE I/O SYSCALLS
Note: =====================================================================

Process called "open_source_file" that takes path as String returns FileHandle:
    Note: Open a source file for reading
    
    Note: Convert path to bytes for syscall
    Let path_bytes be ASCII.string_to_bytes(path)
    
    Note: Open file with read-only flag (O_RDONLY = 0)
    Let fd be Linux.sys_open(path_bytes, 0, 0)
    
    If fd is less than 0:
        Let error_msg be "Failed to open source file: " joined with path
        Throw Errors.create_error("FileError", error_msg)
    End If
    
    Let handle be FileHandle()
    Set handle.fd to fd
    Set handle.path to path
    Set handle.mode to "read"
    Set handle.is_temporary to false
    Set handle.should_delete_on_close to false
    
    Return handle

Process called "create_output_file" that takes path as String returns FileHandle:
    Note: Create output file for compiled code
    
    Note: Convert path to bytes
    Let path_bytes be ASCII.string_to_bytes(path)
    
    Note: Open with O_CREAT | O_WRONLY | O_TRUNC (0x241 = 577)
    Note: Permissions: rwxr-xr-x (0755 = 493)
    Let fd be Linux.sys_open(path_bytes, 577, 493)
    
    If fd is less than 0:
        Let error_msg be "Failed to create output file: " joined with path
        Throw Errors.create_error("FileError", error_msg)
    End If
    
    Let handle be FileHandle()
    Set handle.fd to fd
    Set handle.path to path
    Set handle.mode to "write"
    Set handle.is_temporary to false
    Set handle.should_delete_on_close to false
    
    Return handle

Process called "read_file_content" that takes handle as FileHandle, buffer_size as Integer returns String:
    Note: Read file content into memory
    
    Note: Allocate buffer for reading
    Let buffer be Linux.allocate_buffer(buffer_size)
    
    Note: Read from file descriptor
    Let bytes_read be Linux.sys_read(handle.fd, buffer)
    
    If bytes_read is less than 0:
        Linux.free_buffer(buffer.address, buffer.size)
        Let error_msg be "Failed to read file: " joined with handle.path
        Throw Errors.create_error("FileError", error_msg)
    End If
    
    If bytes_read is equal to 0:
        Note: EOF reached
        Linux.free_buffer(buffer.address, buffer.size)
        Return ""
    End If
    
    Note: Convert bytes to string
    Let content be Linux.buffer_to_string(buffer, bytes_read)
    
    Note: Free the buffer
    Linux.free_buffer(buffer.address, buffer.size)
    
    Return content

Process called "write_compiled_output" that takes handle as FileHandle, content as String returns Integer:
    Note: Write compiled output to file
    
    Note: Convert content to bytes
    Let content_bytes be ASCII.string_to_bytes(content)
    Let content_length be content_bytes.length()
    
    Note: Allocate buffer and copy content
    Let buffer be Linux.allocate_buffer(content_length)
    Let i be 0
    While i is less than content_length:
        Linux.write_byte_to_buffer(buffer, i, content_bytes[i])
        Set i to i plus 1
    End While
    
    Note: Write to file descriptor
    Let bytes_written be Linux.sys_write(handle.fd, buffer, content_length)
    
    Note: Free the buffer
    Linux.free_buffer(buffer.address, buffer.size)
    
    If bytes_written is less than 0:
        Let error_msg be "Failed to write output file: " joined with handle.path
        Throw Errors.create_error("FileError", error_msg)
    End If
    
    If bytes_written is not equal to content_length:
        Let error_msg be "Partial write to output file: " joined with handle.path
        Throw Errors.create_error("FileError", error_msg)
    End If
    
    Note: Sync to disk (fsync syscall = 74)
    Let sync_result be Linux.sys_fsync(handle.fd)
    If sync_result is less than 0:
        Note: Log warning but don't fail
    End If
    
    Return bytes_written

Process called "close_file" that takes handle as FileHandle returns Boolean:
    Note: Close file handle and cleanup
    
    Note: Close the file descriptor
    Let close_result be Linux.sys_close(handle.fd)
    
    If close_result is less than 0:
        Note: Log error but continue cleanup
    End If
    
    Note: Delete temporary file if requested
    If handle.is_temporary and handle.should_delete_on_close:
        Let path_bytes be ASCII.string_to_bytes(handle.path)
        Let unlink_result be Linux.sys_unlink(path_bytes)
        If unlink_result is less than 0:
            Note: Log warning but don't fail
        End If
    End If
    
    Return close_result is greater than or equal to 0

Note: =====================================================================
Note: MEMORY MANAGEMENT SYSCALLS
Note: =====================================================================

Process called "allocate_compilation_memory" that takes size as Integer returns MemoryMapping:
    Note: Allocate memory for compilation buffers
    
    Note: Use mmap syscall through Linux module
    Let buffer be Linux.allocate_buffer(size)
    
    If buffer.address is equal to 0:
        Let error_msg be "Failed to allocate compilation memory"
        Throw Errors.create_error("MemoryError", error_msg)
    End If
    
    Let mapping be MemoryMapping()
    Set mapping.address to buffer.address
    Set mapping.size to size
    Set mapping.protection to 3  Note: PROT_READ | PROT_WRITE
    Set mapping.is_file_backed to false
    Set mapping.file_handle to Optional[FileHandle].None()
    
    Return mapping

Process called "map_source_file" that takes handle as FileHandle returns MemoryMapping:
    Note: Memory-map source file for efficient access
    
    Note: Get file size using fstat (syscall 5)
    Let stat_result be Linux.sys_fstat(handle.fd)
    If stat_result.size is equal to 0:
        Let error_msg be "Cannot map empty file: " joined with handle.path
        Throw Errors.create_error("FileError", error_msg)
    End If
    
    Note: Map file with read-only protection (PROT_READ = 1)
    Let address be Linux.sys_mmap_file(handle.fd, stat_result.size, 1)
    
    If address is equal to 0:
        Let error_msg be "Failed to map source file: " joined with handle.path
        Throw Errors.create_error("MemoryError", error_msg)
    End If
    
    Let mapping be MemoryMapping()
    Set mapping.address to address
    Set mapping.size to stat_result.size
    Set mapping.protection to 1  Note: PROT_READ
    Set mapping.is_file_backed to true
    Set mapping.file_handle to Optional[FileHandle].Some(handle)
    
    Return mapping

Process called "release_memory" that takes mapping as MemoryMapping returns Boolean:
    Note: Release allocated memory
    
    Note: Use munmap syscall through Linux module
    Linux.free_buffer(mapping.address, mapping.size)
    
    Note: Clear the mapping
    Set mapping.address to 0
    Set mapping.size to 0
    
    Return true

Note: =====================================================================
Note: PROCESS CONTROL SYSCALLS
Note: =====================================================================

Process called "exit_compiler" that takes exit_code as Integer returns Nothing:
    Note: Terminate compiler process
    
    Note: Flush output streams first
    flush_output_streams()
    
    Note: Call exit syscall (60 on x86_64)
    Linux.sys_exit(exit_code)
    
    Note: This point should never be reached
    Throw Errors.create_internal_error("Exit syscall failed")

Process called "get_working_directory" returns String:
    Note: Get current working directory
    
    Note: Allocate buffer for path (PATH_MAX = 4096)
    Let buffer be Linux.allocate_buffer(4096)
    
    Note: Call getcwd syscall (79 on x86_64)
    Let result be Linux.sys_getcwd(buffer, 4096)
    
    If result is equal to 0:
        Linux.free_buffer(buffer.address, buffer.size)
        Let error_msg be "Failed to get working directory"
        Throw Errors.create_error("SystemError", error_msg)
    End If
    
    Note: Find string length by looking for null terminator
    Let length be 0
    While length is less than 4096:
        Let byte_val be Linux.read_byte_from_buffer(buffer, length)
        If byte_val is equal to 0:
            Note: Found null terminator
            Set length to length plus 1  Note: Exit loop
            Set length to 4097  Note: Force exit
        End If
        If length is less than 4096:
            Set length to length plus 1
        End If
    End While
    
    Note: Convert buffer to string
    Let cwd be Linux.buffer_to_string(buffer, length)
    
    Note: Free the buffer
    Linux.free_buffer(buffer.address, buffer.size)
    
    Return cwd

Process called "get_file_metadata" that takes path as String returns Dictionary[String, Any]:
    Note: Get file size, timestamps, permissions
    
    Note: Convert path to bytes
    Let path_bytes be ASCII.string_to_bytes(path)
    
    Note: Call stat syscall (4 on x86_64)
    Let stat_result be Linux.sys_stat(path_bytes)
    
    If stat_result.size is less than 0:
        Let error_msg be "Failed to get file metadata: " joined with path
        Throw Errors.create_error("FileError", error_msg)
    End If
    
    Let metadata be Dictionary[String, Any]()
    Set metadata["size"] to stat_result.size
    Set metadata["mode"] to stat_result.mode
    Set metadata["mtime"] to stat_result.mtime
    Set metadata["exists"] to true
    
    Return metadata

Note: =====================================================================
Note: ERROR REPORTING SYSCALLS
Note: =====================================================================

Process called "write_error_output" that takes message as String returns Integer:
    Note: Write error messages to stderr
    
    Note: Convert message to bytes
    Let msg_bytes be ASCII.string_to_bytes(message)
    Let msg_length be msg_bytes.length()
    
    Note: Allocate buffer and copy message
    Let buffer be Linux.allocate_buffer(msg_length)
    Let i be 0
    While i is less than msg_length:
        Linux.write_byte_to_buffer(buffer, i, msg_bytes[i])
        Set i to i plus 1
    End While
    
    Note: Write to stderr (fd = 2)
    Let bytes_written be Linux.sys_write(2, buffer, msg_length)
    
    Note: Free the buffer
    Linux.free_buffer(buffer.address, buffer.size)
    
    If bytes_written is less than 0:
        Note: Can't report error about error writing, return failure
        Return -1
    End If
    
    Return bytes_written

Process called "flush_output_streams" returns Boolean:
    Note: Flush stdout and stderr
    
    Note: fsync on stdout (fd = 1)
    Let stdout_result be Linux.sys_fsync(1)
    
    Note: fsync on stderr (fd = 2)
    Let stderr_result be Linux.sys_fsync(2)
    
    Note: Return true if at least one succeeded
    Return (stdout_result is greater than or equal to 0) or (stderr_result is greater than or equal to 0)

Note: =====================================================================
Note: RESOURCE MANAGEMENT
Note: =====================================================================

Process called "initialize_compiler_resources" returns CompilationContext:
    Note: Initialize resource tracking
    
    Let context be CompilationContext()
    Set context.source_files to List[FileHandle]()
    Set context.temp_files to List[FileHandle]()
    Set context.memory_mappings to List[MemoryMapping]()
    Set context.error_count to 0
    
    Note: Create empty output file handle placeholder
    Let empty_handle be FileHandle()
    Set empty_handle.fd to -1
    Set empty_handle.path to ""
    Set empty_handle.mode to "none"
    Set empty_handle.is_temporary to false
    Set empty_handle.should_delete_on_close to false
    Set context.output_file to empty_handle
    
    Return context

Process called "cleanup_compiler_resources" that takes context as CompilationContext returns Boolean:
    Note: Clean up all compiler resources
    
    Let success be true
    
    Note: Close all source files
    For Each handle in context.source_files:
        If not close_file(handle):
            Set success to false
        End If
    End For
    
    Note: Close output file if open
    If context.output_file.fd is greater than or equal to 0:
        If not close_file(context.output_file):
            Set success to false
        End If
    End If
    
    Note: Close and delete temporary files
    For Each handle in context.temp_files:
        Set handle.should_delete_on_close to true
        If not close_file(handle):
            Set success to false
        End If
    End For
    
    Note: Release all memory mappings
    For Each mapping in context.memory_mappings:
        If not release_memory(mapping):
            Set success to false
        End If
    End For
    
    Return success

Process called "create_temporary_file" that takes prefix as String returns FileHandle:
    Note: Create temporary file for intermediate data
    
    Note: Generate temporary file name
    Let temp_dir be "/tmp/"
    
    Note: Get current time as part of unique name (using time syscall)
    Let timestamp be Linux.sys_time()
    
    Note: Create file path
    Let temp_path be temp_dir joined with prefix
    Set temp_path to temp_path joined with "_"
    Set temp_path to temp_path joined with Linux.integer_to_string(timestamp)
    Set temp_path to temp_path joined with ".tmp"
    
    Note: Create the file
    Let handle be create_output_file(temp_path)
    
    Note: Mark as temporary
    Set handle.is_temporary to true
    Set handle.should_delete_on_close to true
    
    Return handle