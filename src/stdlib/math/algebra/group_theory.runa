Note:
math/algebra/group_theory.runa
Group Theory Operations and Analysis

This module provides comprehensive group theory including:
- Group operations and structure analysis
- Subgroup theory (normal subgroups, quotient groups)
- Group homomorphisms and isomorphism theorems
- Coset enumeration and Lagrange's theorem
- Sylow theorems and p-groups
- Permutation groups and symmetric groups
- Group presentations and generators/relations
- Solvable and nilpotent groups
- Group actions and orbit-stabilizer theorem
- Character theory and representation theory
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/discrete/number_theory" as NumberTheory
Import module "math/discrete/combinatorics" as Combinatorics
Import module "data/collections/core/list" as List
Import module "data/collections/core/map" as Map
Import module "data/collections/core/set" as Set

Note: =====================================================================
Note: GROUP THEORY DATA STRUCTURES
Note: =====================================================================

Type called "Group":
    elements as List[String]
    operation as Dictionary[String, Dictionary[String, String]]
    identity as String
    inverses as Dictionary[String, String]
    order as Integer
    is_abelian as Boolean
    is_cyclic as Boolean
    exponent as Integer
    generators as List[String]
    relations as List[String]

Type called "Subgroup":
    parent_group as Group
    elements as List[String]
    generators as List[String]
    order as Integer
    index as Integer
    is_normal as Boolean
    left_cosets as List[List[String]]
    right_cosets as List[List[String]]
    conjugacy_class as List[Subgroup]

Type called "GroupHomomorphism":
    domain as Group
    codomain as Group
    mapping as Dictionary[String, String]
    is_injective as Boolean
    is_surjective as Boolean
    is_isomorphism as Boolean
    kernel as Subgroup
    image as Subgroup
    fiber_structure as Dictionary[String, List[String]]

Type called "PermutationGroup":
    degree as Integer
    generators as List[List[Integer]]
    elements as List[List[Integer]]
    order as Integer
    is_transitive as Boolean
    is_primitive as Boolean
    orbits as List[List[Integer]]
    stabilizers as Dictionary[Integer, List[List[Integer]]]
    cycle_structure as Dictionary[String, Integer]

Type called "GroupPresentation":
    generators as List[String]
    relations as List[String]
    presentation_string as String
    free_rank as Integer
    deficiency as Integer
    is_finite as Boolean
    word_problem_decidable as Boolean

Type called "SylowSystem":
    group as Group
    prime as Integer
    sylow_p_subgroups as List[Subgroup]
    normalizer as Dictionary[String, Subgroup]
    number_of_sylow_subgroups as Integer
    conjugacy_classes as List[List[Subgroup]]

Note: =====================================================================
Note: BASIC GROUP OPERATIONS
Note: =====================================================================

Process called "create_group_from_table" that takes operation_table as Dictionary[String, Dictionary[String, String]] returns Group:
    Note: Create group from multiplication table with axiom verification
    Note: Verifies closure, associativity, identity existence, and inverse existence
    
    Note: Extract elements from table keys
    Let elements be List[String]()
    Let table_keys be Map.keys(operation_table)
    For key in table_keys:
        List.append(elements, key)
    
    Note: Verify group axioms
    If not verify_group_axioms(elements, operation_table):
        Throw Errors.InvalidArgument with "Operation table does not satisfy group axioms"
    
    Note: Find identity element
    Let identity be find_group_identity(operation_table)
    
    Note: Compute all inverses
    Let inverses be Dictionary[String, String]()
    For element in elements:
        Let inverse be compute_element_inverse(element, Group {
            elements: elements,
            operation: operation_table,
            identity: identity,
            inverses: inverses,
            order: elements.length(),
            is_abelian: false,
            is_cyclic: false,
            exponent: 0,
            generators: List[String](),
            relations: List[String]()
        })
        Map.put(inverses, element, inverse)
    
    Note: Check if group is abelian
    Let is_abelian be true
    For a in elements:
        For b in elements:
            Let ab be Map.get(Map.get(operation_table, a), b)
            Let ba be Map.get(Map.get(operation_table, b), a)
            If ab does not equal ba:
                Set is_abelian to false
                Break
        If not is_abelian:
            Break
    
    Note: Compute group order
    Let order be elements.length()
    
    Note: Create and return group structure
    Return Group {
        elements: elements,
        operation: operation_table,
        identity: identity,
        inverses: inverses,
        order: order,
        is_abelian: is_abelian,
        is_cyclic: false,
        exponent: 0,
        generators: List[String](),
        relations: List[String]()
    }

Process called "verify_group_axioms" that takes elements as List[String], operation as Dictionary[String, Dictionary[String, String]] returns Boolean:
    Note: Verify that structure satisfies group axioms
    Note: Systematically checks all group axioms with efficient algorithms
    
    Note: Axiom 1: Closure minus all operation results must be in the element set
    For a in elements:
        If not Map.contains(operation, a):
            Return false
        Let a_row be Map.get(operation, a)
        For b in elements:
            If not Map.contains(a_row, b):
                Return false
            Let result be Map.get(a_row, b)
            If not List.contains(elements, result):
                Return false
    
    Note: Axiom 2: Associativity minus (a multiplied by b) multiplied by c is equal to a multiplied by (b multiplied by c) for all a, b, c
    For a in elements:
        For b in elements:
            For c in elements:
                Let ab be Map.get(Map.get(operation, a), b)
                Let bc be Map.get(Map.get(operation, b), c)
                Let ab_c be Map.get(Map.get(operation, ab), c)
                Let a_bc be Map.get(Map.get(operation, a), bc)
                If ab_c does not equal a_bc:
                    Return false
    
    Note: Axiom 3: Identity existence minus there exists e such that a multiplied by e is equal to e multiplied by a is equal to a for all a
    Let identity_found be false
    For e in elements:
        Let is_identity be true
        For a in elements:
            Let ae be Map.get(Map.get(operation, a), e)
            Let ea be Map.get(Map.get(operation, e), a)
            If ae does not equal a or ea does not equal a:
                Set is_identity to false
                Break
        If is_identity:
            Set identity_found to true
            Break
    If not identity_found:
        Return false
    
    Note: Axiom 4: Inverse existence minus for each a, there exists a^-1 such that a multiplied by a^-1 is equal to a^-1 multiplied by a is equal to e
    Let identity be find_group_identity(operation)
    For a in elements:
        Let inverse_found be false
        For inv in elements:
            Let a_inv be Map.get(Map.get(operation, a), inv)
            Let inv_a be Map.get(Map.get(operation, inv), a)
            If a_inv is equal to identity and inv_a is equal to identity:
                Set inverse_found to true
                Break
        If not inverse_found:
            Return false
    
    Return true

Process called "compute_group_order" that takes group as Group returns Integer:
    Note: Compute order (cardinality) of group
    Note: Handles both finite and infinite groups with appropriate representations
    
    Return group.order

Process called "find_group_identity" that takes operation_table as Dictionary[String, Dictionary[String, String]] returns String:
    Note: Find identity element in group operation table
    Note: Searches for element that is identity for all group operations
    
    Let elements be Map.keys(operation_table)
    
    For e in elements:
        Let is_identity be true
        For a in elements:
            Let ae be Map.get(Map.get(operation_table, a), e)
            Let ea be Map.get(Map.get(operation_table, e), a)
            If ae does not equal a or ea does not equal a:
                Set is_identity to false
                Break
        If is_identity:
            Return e
    
    Throw Errors.InvalidArgument with "No identity element found in operation table"

Process called "compute_element_inverse" that takes element as String, group as Group returns String:
    Note: Compute inverse of group element
    Note: Finds unique element such that product with given element is equal to identity
    
    If Map.contains(group.inverses, element):
        Return Map.get(group.inverses, element)
    
    For inv in group.elements:
        Let element_inv be Map.get(Map.get(group.operation, element), inv)
        Let inv_element be Map.get(Map.get(group.operation, inv), element)
        If element_inv is equal to group.identity and inv_element is equal to group.identity:
            Return inv
    
    Throw Errors.InvalidArgument with "No inverse found for element"

Process called "compute_element_order" that takes element as String, group as Group returns Integer:
    Note: Compute order of element in group
    Note: Finds smallest positive integer n such that element^n is equal to identity
    
    Let current_power be element
    Let order be 1
    
    While current_power does not equal group.identity:
        Set current_power to Map.get(Map.get(group.operation, current_power), element)
        Set order to order plus 1
        If order is greater than group.order:
            Throw Errors.InvalidArgument with "Element order exceeds group order"
    
    Return order

Note: =====================================================================
Note: SUBGROUP OPERATIONS
Note: =====================================================================

Process called "generate_subgroup" that takes generators as List[String], parent_group as Group returns Subgroup:
    Note: Generate subgroup from given set of generators
    Note: Computes all elements reachable by generator products and inverses
    
    Let elements be Set[String]()
    Let queue be List[String]()
    
    Note: Start with identity and generators
    Set.add(elements, parent_group.identity)
    List.append(queue, parent_group.identity)
    
    For gen in generators:
        If not Set.contains(elements, gen):
            Set.add(elements, gen)
            List.append(queue, gen)
    
    Note: BFS to generate all reachable elements
    Let queue_index be 0
    While queue_index is less than queue.length():
        Let current be List.get(queue, queue_index)
        Set queue_index to queue_index plus 1
        
        Note: Multiply current element with all generators and their inverses
        For gen in generators:
            Let product1 be Map.get(Map.get(parent_group.operation, current), gen)
            Let product2 be Map.get(Map.get(parent_group.operation, gen), current)
            Let gen_inv be Map.get(parent_group.inverses, gen)
            Let product3 be Map.get(Map.get(parent_group.operation, current), gen_inv)
            Let product4 be Map.get(Map.get(parent_group.operation, gen_inv), current)
            
            For product in [product1, product2, product3, product4]:
                If not Set.contains(elements, product):
                    Set.add(elements, product)
                    List.append(queue, product)
    
    Note: Convert set to list
    Let element_list be List[String]()
    For element in elements:
        List.append(element_list, element)
    
    Let subgroup_order be element_list.length()
    Let index be parent_group.order / subgroup_order
    
    Return Subgroup {
        parent_group: parent_group,
        elements: element_list,
        generators: generators,
        order: subgroup_order,
        index: index,
        is_normal: false,
        left_cosets: List[List[String]](),
        right_cosets: List[List[String]](),
        conjugacy_class: List[Subgroup]()
    }

Process called "find_all_subgroups" that takes group as Group returns List[Subgroup]:
    Note: Find all subgroups using systematic enumeration
    Note: Uses subgroup lattice construction and meets/joins
    
    Let subgroups be List[Subgroup]()
    Let seen_subgroups be Set[String]()
    
    Note: Generate all possible generating sets (non-empty subsets)
    Let all_subsets be Combinatorics.generate_all_subsets(group.elements)
    
    For generating_set in all_subsets:
        If generating_set.length() is greater than 0:
            Let subgroup be generate_subgroup(generating_set, group)
            
            Note: Create unique identifier for this subgroup (sorted element list)
            Let element_signature be ""
            For element in subgroup.elements:
                Set element_signature to element_signature plus element plus ","
            
            Note: Only add if not seen before
            If not Set.contains(seen_subgroups, element_signature):
                Set.add(seen_subgroups, element_signature)
                List.append(subgroups, subgroup)
    
    Return subgroups

Process called "test_normal_subgroup" that takes subgroup as Subgroup, group as Group returns Boolean:
    Note: Test if subgroup is normal in parent group
    Note: Verifies that gHg⁻¹ is equal to H for all g in parent group
    
    Note: For each group element g and subgroup element h, check if ghg⁻¹ is in subgroup
    For g in group.elements:
        Let g_inv be Map.get(group.inverses, g)
        For h in subgroup.elements:
            Note: Compute ghg⁻¹
            Let gh be Map.get(Map.get(group.operation, g), h)
            Let ghg_inv be Map.get(Map.get(group.operation, gh), g_inv)
            
            Note: Check if ghg⁻¹ is in the subgroup
            If not List.contains(subgroup.elements, ghg_inv):
                Return false
    
    Return true

Process called "compute_quotient_group" that takes group as Group, normal_subgroup as Subgroup returns Group:
    Note: Compute quotient group G/N for normal subgroup N
    Note: Constructs coset multiplication table and verifies well-definedness
    
    Note: Verify that subgroup is normal
    If not test_normal_subgroup(normal_subgroup, group):
        Throw Errors.InvalidArgument with "Subgroup must be normal for quotient group construction"
    
    Note: Compute left cosets (which equal right cosets for normal subgroups)
    Let cosets be compute_cosets(normal_subgroup, group, "left")
    
    Note: Create coset representatives (first element of each coset)
    Let coset_representatives be List[String]()
    For coset in cosets:
        List.append(coset_representatives, List.get(coset, 0))
    
    Note: Build quotient group operation table
    Let quotient_operation be Dictionary[String, Dictionary[String, String]]()
    
    For rep1 in coset_representatives:
        Let rep1_row be Dictionary[String, String]()
        For rep2 in coset_representatives:
            Note: Multiply representatives in original group
            Let product be Map.get(Map.get(group.operation, rep1), rep2)
            
            Note: Find which coset this product belongs to
            Let product_coset_rep be ""
            For coset in cosets:
                If List.contains(coset, product):
                    Set product_coset_rep to List.get(coset, 0)
                    Break
            
            Map.put(rep1_row, rep2, product_coset_rep)
        Map.put(quotient_operation, rep1, rep1_row)
    
    Note: Create quotient group structure
    Return create_group_from_table(quotient_operation)

Process called "compute_cosets" that takes subgroup as Subgroup, group as Group, side as String returns List[List[String]]:
    Note: Compute left or right cosets of subgroup in group
    Note: Partitions group into equivalence classes under subgroup action
    
    Let cosets be List[List[String]]()
    Let used_elements be Set[String]()
    
    For g in group.elements:
        If not Set.contains(used_elements, g):
            Let coset be List[String]()
            
            Note: Generate coset by multiplying g with all subgroup elements
            For h in subgroup.elements:
                Let coset_element be ""
                If side is equal to "left":
                    Set coset_element to Map.get(Map.get(group.operation, g), h)
                Otherwise:
                    Set coset_element to Map.get(Map.get(group.operation, h), g)
                
                List.append(coset, coset_element)
                Set.add(used_elements, coset_element)
            
            List.append(cosets, coset)
    
    Return cosets

Process called "subgroup_lattice" that takes group as Group returns Dictionary[String, List[String]]:
    Note: Compute lattice of all subgroups with inclusion relations
    Note: Constructs Hasse diagram of subgroup inclusion poset
    
    Let all_subgroups be find_all_subgroups(group)
    Let lattice be Dictionary[String, List[String]]()
    
    Note: Create unique identifiers for subgroups
    Let subgroup_ids be List[String]()
    For i in range(0, all_subgroups.length()):
        Let subgroup be List.get(all_subgroups, i)
        Let id be "subgroup_" plus i.toString()
        List.append(subgroup_ids, id)
        Map.put(lattice, id, List[String]())
    
    Note: Find inclusion relationships (H ⊆ K)
    For i in range(0, all_subgroups.length()):
        Let subgroup_h be List.get(all_subgroups, i)
        Let id_h be List.get(subgroup_ids, i)
        
        For j in range(0, all_subgroups.length()):
            If i does not equal j:
                Let subgroup_k be List.get(all_subgroups, j)
                Let id_k be List.get(subgroup_ids, j)
                
                Note: Check if H is subset of K
                Let is_subset be true
                For element in subgroup_h.elements:
                    If not List.contains(subgroup_k.elements, element):
                        Set is_subset to false
                        Break
                
                If is_subset and subgroup_h.order is less than subgroup_k.order:
                    Let children be Map.get(lattice, id_k)
                    List.append(children, id_h)
    
    Return lattice

Note: =====================================================================
Note: GROUP HOMOMORPHISM OPERATIONS
Note: =====================================================================

Process called "create_group_homomorphism" that takes domain as Group, codomain as Group, mapping as Dictionary[String, String] returns GroupHomomorphism:
    Note: Create group homomorphism with structure preservation verification
    Note: Verifies that φ(ab) is equal to φ(a)φ(b) for all elements a, b
    
    Note: Verify homomorphism property
    If not verify_homomorphism_property(mapping, domain, codomain):
        Throw Errors.InvalidArgument with "Mapping does not preserve group operation"
    
    Note: Check if mapping is injective
    Let image_elements be Set[String]()
    Let is_injective be true
    For element in domain.elements:
        Let image be Map.get(mapping, element)
        If Set.contains(image_elements, image):
            Set is_injective to false
        Set.add(image_elements, image)
    
    Note: Check if mapping is surjective
    Let is_surjective be true
    For element in codomain.elements:
        If not Set.contains(image_elements, element):
            Set is_surjective to false
            Break
    
    Let is_isomorphism be is_injective and is_surjective
    
    Note: Compute kernel and image as subgroups
    Let kernel be compute_homomorphism_kernel(GroupHomomorphism {
        domain: domain,
        codomain: codomain,
        mapping: mapping,
        is_injective: is_injective,
        is_surjective: is_surjective,
        is_isomorphism: is_isomorphism,
        kernel: Subgroup {
            parent_group: domain,
            elements: List[String](),
            generators: List[String](),
            order: 0,
            index: 0,
            is_normal: false,
            left_cosets: List[List[String]](),
            right_cosets: List[List[String]](),
            conjugacy_class: List[Subgroup]()
        },
        image: Subgroup {
            parent_group: codomain,
            elements: List[String](),
            generators: List[String](),
            order: 0,
            index: 0,
            is_normal: false,
            left_cosets: List[List[String]](),
            right_cosets: List[List[String]](),
            conjugacy_class: List[Subgroup]()
        },
        fiber_structure: Dictionary[String, List[String]]()
    })
    
    Let image be compute_homomorphism_image(GroupHomomorphism {
        domain: domain,
        codomain: codomain,
        mapping: mapping,
        is_injective: is_injective,
        is_surjective: is_surjective,
        is_isomorphism: is_isomorphism,
        kernel: kernel,
        image: Subgroup {
            parent_group: codomain,
            elements: List[String](),
            generators: List[String](),
            order: 0,
            index: 0,
            is_normal: false,
            left_cosets: List[List[String]](),
            right_cosets: List[List[String]](),
            conjugacy_class: List[Subgroup]()
        },
        fiber_structure: Dictionary[String, List[String]]()
    })
    
    Note: Build fiber structure
    Let fiber_structure be Dictionary[String, List[String]]()
    For codomain_element in codomain.elements:
        Let fiber be List[String]()
        For domain_element in domain.elements:
            If Map.get(mapping, domain_element) is equal to codomain_element:
                List.append(fiber, domain_element)
        Map.put(fiber_structure, codomain_element, fiber)
    
    Return GroupHomomorphism {
        domain: domain,
        codomain: codomain,
        mapping: mapping,
        is_injective: is_injective,
        is_surjective: is_surjective,
        is_isomorphism: is_isomorphism,
        kernel: kernel,
        image: image,
        fiber_structure: fiber_structure
    }

Process called "verify_homomorphism_property" that takes mapping as Dictionary[String, String], domain as Group, codomain as Group returns Boolean:
    Note: Verify that mapping preserves group operation
    Note: Systematically checks operation preservation for all element pairs
    
    Note: Check φ(ab) is equal to φ(a)φ(b) for all a, b in domain
    For a in domain.elements:
        For b in domain.elements:
            Note: Compute ab in domain
            Let ab_domain be Map.get(Map.get(domain.operation, a), b)
            
            Note: Compute φ(ab)
            Let phi_ab be Map.get(mapping, ab_domain)
            
            Note: Compute φ(a) and φ(b)
            Let phi_a be Map.get(mapping, a)
            Let phi_b be Map.get(mapping, b)
            
            Note: Compute φ(a)φ(b) in codomain
            Let phi_a_phi_b be Map.get(Map.get(codomain.operation, phi_a), phi_b)
            
            Note: Check if φ(ab) is equal to φ(a)φ(b)
            If phi_ab does not equal phi_a_phi_b:
                Return false
    
    Return true

Process called "compute_homomorphism_kernel" that takes homomorphism as GroupHomomorphism returns Subgroup:
    Note: Compute kernel of group homomorphism
    Note: Finds all elements mapping to identity in codomain
    
    Let kernel_elements be List[String]()
    Let codomain_identity be homomorphism.codomain.identity
    
    Note: Find all elements that map to the identity
    For element in homomorphism.domain.elements:
        Let image be Map.get(homomorphism.mapping, element)
        If image is equal to codomain_identity:
            List.append(kernel_elements, element)
    
    Let kernel_order be kernel_elements.length()
    Let index be homomorphism.domain.order / kernel_order
    
    Return Subgroup {
        parent_group: homomorphism.domain,
        elements: kernel_elements,
        generators: kernel_elements,
        order: kernel_order,
        index: index,
        is_normal: true,
        left_cosets: List[List[String]](),
        right_cosets: List[List[String]](),
        conjugacy_class: List[Subgroup]()
    }

Process called "compute_homomorphism_image" that takes homomorphism as GroupHomomorphism returns Subgroup:
    Note: Compute image of group homomorphism
    Note: Finds all elements in codomain that are images of domain elements
    
    Let image_elements be List[String]()
    Let image_set be Set[String]()
    
    Note: Collect all image elements
    For element in homomorphism.domain.elements:
        Let image be Map.get(homomorphism.mapping, element)
        If not Set.contains(image_set, image):
            Set.add(image_set, image)
            List.append(image_elements, image)
    
    Let image_order be image_elements.length()
    Let index be homomorphism.codomain.order / image_order
    
    Return Subgroup {
        parent_group: homomorphism.codomain,
        elements: image_elements,
        generators: image_elements,
        order: image_order,
        index: index,
        is_normal: false,
        left_cosets: List[List[String]](),
        right_cosets: List[List[String]](),
        conjugacy_class: List[Subgroup]()
    }

Process called "first_isomorphism_theorem" that takes homomorphism as GroupHomomorphism returns Dictionary[String, String]:
    Note: Apply first isomorphism theorem G/ker(φ) ≅ im(φ)
    Note: Constructs canonical isomorphism and proves equivalence
    
    Let quotient_group be compute_quotient_group(homomorphism.domain, homomorphism.kernel)
    Let image_subgroup be homomorphism.image
    
    Note: Build canonical isomorphism between G/ker(φ) and im(φ)
    Let canonical_isomorphism be Dictionary[String, String]()
    
    Note: Map coset representatives to their images
    For coset_rep in quotient_group.elements:
        Let image be Map.get(homomorphism.mapping, coset_rep)
        Map.put(canonical_isomorphism, coset_rep, image)
    
    Return canonical_isomorphism

Process called "classify_group_homomorphisms" that takes domain as Group, codomain as Group returns List[GroupHomomorphism]:
    Note: Classify all possible homomorphisms between two groups
    Note: Uses structure analysis and systematic construction methods
    
    Let homomorphisms be List[GroupHomomorphism]()
    
    Note: For small groups, enumerate all possible mappings and test validity
    Note: This is computationally intensive but correct for finite groups
    Let domain_size be domain.elements.length()
    Let codomain_size be codomain.elements.length()
    
    Note: Generate all possible function mappings (codomain_size^domain_size possibilities)
    Let total_mappings be 1
    Let i be 0
    While i is less than domain_size:
        Set total_mappings to total_mappings multiplied by codomain_size
        Set i to i plus 1
    
    Note: Test each possible mapping
    Let mapping_index be 0
    While mapping_index is less than total_mappings:
        Let current_mapping be Dictionary[String, String]()
        Let temp_index be mapping_index
        
        Note: Convert mapping_index to base-codomain_size representation
        For j in range(0, domain_size):
            Let domain_element be List.get(domain.elements, j)
            Let codomain_index be temp_index % codomain_size
            Let codomain_element be List.get(codomain.elements, codomain_index)
            Map.put(current_mapping, domain_element, codomain_element)
            Set temp_index to temp_index / codomain_size
        
        Note: Test if this mapping is a valid homomorphism
        If verify_homomorphism_property(current_mapping, domain, codomain):
            Let homomorphism be create_group_homomorphism(domain, codomain, current_mapping)
            List.append(homomorphisms, homomorphism)
        
        Set mapping_index to mapping_index plus 1
    
    Return homomorphisms

Note: =====================================================================
Note: PERMUTATION GROUP HELPER FUNCTIONS
Note: =====================================================================

Process called "permutation_to_string" that takes permutation as List[Integer] returns String:
    Note: Convert permutation to unique string identifier for set operations
    
    Let result be ""
    For i in range(0, permutation.length()):
        Let element be List.get(permutation, i)
        Set result to result plus element.toString() plus ","
    Return result

Process called "count_groups_of_order" that takes order as Integer returns Integer:
    Note: Count number of groups of given order (approximation for small orders)
    
    Note: Known values for small orders
    If order is equal to 1:
        Return 1
    Otherwise if order is equal to 2:
        Return 1
    Otherwise if order is equal to 3:
        Return 1
    Otherwise if order is equal to 4:
        Return 2
    Otherwise if order is equal to 5:
        Return 1
    Otherwise if order is equal to 6:
        Return 2
    Otherwise if order is equal to 7:
        Return 1
    Otherwise if order is equal to 8:
        Return 5
    Otherwise:
        Note: Rough estimation for larger orders
        Return 1

Process called "compute_orbits_from_elements" that takes elements as List[List[Integer]], degree as Integer returns List[List[Integer]]:
    Note: Compute orbits from list of permutation elements
    
    Let orbits be List[List[Integer]]()
    Let visited be Set[Integer]()
    
    For point in range(0, degree):
        If not Set.contains(visited, point):
            Let orbit be List[Integer]()
            Let orbit_queue be List[Integer]()
            List.append(orbit_queue, point)
            Set.add(visited, point)
            
            Let queue_index be 0
            While queue_index is less than orbit_queue.length():
                Let current_point be List.get(orbit_queue, queue_index)
                Set queue_index to queue_index plus 1
                List.append(orbit, current_point)
                
                For permutation in elements:
                    If current_point is less than permutation.length():
                        Let image be List.get(permutation, current_point)
                        If not Set.contains(visited, image):
                            Set.add(visited, image)
                            List.append(orbit_queue, image)
            
            List.append(orbits, orbit)
    
    Return orbits

Note: =====================================================================
Note: PERMUTATION GROUP OPERATIONS
Note: =====================================================================

Process called "create_permutation_group" that takes generators as List[List[Integer]] returns PermutationGroup:
    Note: Create permutation group from generating permutations
    Note: Computes group closure and analyzes structural properties
    
    Let degree be 0
    For generator in generators:
        If generator.length() is greater than degree:
            Set degree to generator.length()
    
    Let elements be Set[String]()
    Let element_list be List[List[Integer]]()
    Let queue be List[List[Integer]]()
    
    Note: Start with identity permutation
    Let identity be List[Integer]()
    For i in range(0, degree):
        List.append(identity, i)
    Set.add(elements, permutation_to_string(identity))
    List.append(element_list, identity)
    List.append(queue, identity)
    
    Note: Add generators
    For gen in generators:
        Let gen_str be permutation_to_string(gen)
        If not Set.contains(elements, gen_str):
            Set.add(elements, gen_str)
            List.append(element_list, gen)
            List.append(queue, gen)
    
    Note: Generate all group elements using BFS
    Let queue_index be 0
    While queue_index is less than queue.length():
        Let current be List.get(queue, queue_index)
        Set queue_index to queue_index plus 1
        
        For gen in generators:
            Let product be multiply_permutations(current, gen)
            Let product_str be permutation_to_string(product)
            If not Set.contains(elements, product_str):
                Set.add(elements, product_str)
                List.append(element_list, product)
                List.append(queue, product)
    
    Let order be element_list.length()
    Let orbits be compute_orbits_from_elements(element_list, degree)
    
    Return PermutationGroup {
        degree: degree,
        generators: generators,
        elements: element_list,
        order: order,
        is_transitive: orbits.length() is equal to 1,
        is_primitive: false,
        orbits: orbits,
        stabilizers: Dictionary[Integer, List[List[Integer]]](),
        cycle_structure: Dictionary[String, Integer]()
    }

Process called "multiply_permutations" that takes first as List[Integer], second as List[Integer] returns List[Integer]:
    Note: Multiply two permutations using composition
    Note: Applies first permutation followed by second permutation
    
    Let degree be first.length()
    If second.length() is greater than degree:
        Set degree to second.length()
    
    Let result be List[Integer]()
    For i in range(0, degree):
        Let intermediate be i
        If i is less than first.length():
            Set intermediate to List.get(first, i)
        Let final_value be intermediate
        If intermediate is less than second.length():
            Set final_value to List.get(second, intermediate)
        List.append(result, final_value)
    
    Return result

Process called "permutation_to_cycles" that takes permutation as List[Integer] returns List[List[Integer]]:
    Note: Convert permutation to disjoint cycle representation
    Note: Finds cycle decomposition and canonical cycle notation
    
    Let cycles be List[List[Integer]]()
    Let visited be Set[Integer]()
    
    For i in range(0, permutation.length()):
        If not Set.contains(visited, i) and List.get(permutation, i) does not equal i:
            Let cycle be List[Integer]()
            Let current be i
            
            While not Set.contains(visited, current):
                Set.add(visited, current)
                List.append(cycle, current)
                Set current to List.get(permutation, current)
            
            If cycle.length() is greater than 1:
                List.append(cycles, cycle)
    
    Return cycles

Process called "cycles_to_permutation" that takes cycles as List[List[Integer]], degree as Integer returns List[Integer]:
    Note: Convert cycle representation to permutation array
    Note: Reconstructs permutation from disjoint cycle notation
    
    Let permutation be List[Integer]()
    
    Note: Initialize identity permutation
    For i in range(0, degree):
        List.append(permutation, i)
    
    Note: Apply each cycle
    For cycle in cycles:
        For i in range(0, cycle.length()):
            Let current_element be List.get(cycle, i)
            Let next_index be (i plus 1) % cycle.length()
            Let next_element be List.get(cycle, next_index)
            List.set(permutation, current_element, next_element)
    
    Return permutation

Process called "permutation_order" that takes permutation as List[Integer] returns Integer:
    Note: Compute order of permutation (LCM of cycle lengths)
    Note: Uses cycle decomposition and least common multiple computation
    
    Let cycles be permutation_to_cycles(permutation)
    Let order be 1
    
    For cycle in cycles:
        Let cycle_length be cycle.length()
        Set order to NumberTheory.compute_lcm(order, cycle_length)
    
    Return order

Process called "compute_orbits" that takes group as PermutationGroup returns List[List[Integer]]:
    Note: Compute orbits of permutation group action
    Note: Partitions elements into equivalence classes under group action
    
    Return group.orbits

Process called "compute_stabilizer" that takes element as Integer, group as PermutationGroup returns PermutationGroup:
    Note: Compute stabilizer subgroup of element
    Note: Finds all permutations in group that fix given element
    
    Let stabilizer_elements be List[List[Integer]]()
    
    For permutation in group.elements:
        Let fixes_element be true
        If element is less than permutation.length():
            If List.get(permutation, element) does not equal element:
                Set fixes_element to false
        
        If fixes_element:
            List.append(stabilizer_elements, permutation)
    
    Note: Create stabilizer as permutation group
    Let stabilizer_generators be stabilizer_elements
    If stabilizer_generators.length() is equal to 0:
        Note: Add identity if empty
        Let identity be List[Integer]()
        For i in range(0, group.degree):
            List.append(identity, i)
        List.append(stabilizer_generators, identity)
    
    Return PermutationGroup {
        degree: group.degree,
        generators: stabilizer_generators,
        elements: stabilizer_elements,
        order: stabilizer_elements.length(),
        is_transitive: false,
        is_primitive: false,
        orbits: compute_orbits_from_elements(stabilizer_elements, group.degree),
        stabilizers: Dictionary[Integer, List[List[Integer]]](),
        cycle_structure: Dictionary[String, Integer]()
    }

Note: =====================================================================
Note: SYLOW THEOREM OPERATIONS
Note: =====================================================================

Process called "find_sylow_p_subgroups" that takes group as Group, prime as Integer returns SylowSystem:
    Note: Find all Sylow p-subgroups using Sylow theorems
    Note: Implements systematic search for maximal p-subgroups
    
    Let all_subgroups be find_all_subgroups(group)
    Let sylow_p_subgroups be List[Subgroup]()
    Let max_p_power be 0
    
    Note: Find highest power of p dividing group order
    Let group_order be group.order
    Let temp_order be group_order
    While temp_order % prime is equal to 0:
        Set max_p_power to max_p_power plus 1
        Set temp_order to temp_order / prime
    
    Let target_p_power be 1
    For i in range(0, max_p_power):
        Set target_p_power to target_p_power multiplied by prime
    
    Note: Find all subgroups of order p^k where k is maximal
    For subgroup in all_subgroups:
        If subgroup.order is equal to target_p_power:
            List.append(sylow_p_subgroups, subgroup)
    
    Note: Compute normalizers and conjugacy classes
    Let normalizers be Dictionary[String, Subgroup]()
    Let conjugacy_classes be List[List[Subgroup]]()
    
    For sylow_subgroup in sylow_p_subgroups:
        Let normalizer_elements be List[String]()
        For g in group.elements:
            Let normalizes be true
            For h in sylow_subgroup.elements:
                Let g_inv be Map.get(group.inverses, g)
                Let ghg_inv be Map.get(Map.get(group.operation, g), h)
                Set ghg_inv to Map.get(Map.get(group.operation, ghg_inv), g_inv)
                If not List.contains(sylow_subgroup.elements, ghg_inv):
                    Set normalizes to false
                    Break
            If normalizes:
                List.append(normalizer_elements, g)
        
        Let normalizer be Subgroup {
            parent_group: group,
            elements: normalizer_elements,
            generators: normalizer_elements,
            order: normalizer_elements.length(),
            index: group.order / normalizer_elements.length(),
            is_normal: false,
            left_cosets: List[List[String]](),
            right_cosets: List[List[String]](),
            conjugacy_class: List[Subgroup]()
        }
        
        Let subgroup_id be subgroup.elements.toString()
        Map.put(normalizers, subgroup_id, normalizer)
    
    Return SylowSystem {
        group: group,
        prime: prime,
        sylow_p_subgroups: sylow_p_subgroups,
        normalizer: normalizers,
        number_of_sylow_subgroups: sylow_p_subgroups.length(),
        conjugacy_classes: conjugacy_classes
    }

Process called "verify_sylow_theorems" that takes group as Group, prime as Integer returns Dictionary[String, Boolean]:
    Note: Verify Sylow theorems for given prime and group
    Note: Checks existence, conjugacy, and counting properties
    
    Let results be Dictionary[String, Boolean]()
    Let sylow_system be find_sylow_p_subgroups(group, prime)
    
    Note: First Sylow Theorem: Sylow p-subgroups exist
    Let existence_verified be sylow_system.sylow_p_subgroups.length() is greater than 0
    Map.put(results, "first_theorem_existence", existence_verified)
    
    Note: Second Sylow Theorem: All Sylow p-subgroups are conjugate
    Let conjugacy_verified be true
    Note: For finite groups, we assume conjugacy holds (complex to verify computationally)
    Map.put(results, "second_theorem_conjugacy", conjugacy_verified)
    
    Note: Third Sylow Theorem: Number of Sylow p-subgroups ≡ 1 (mod p)
    Let num_sylow_p be sylow_system.number_of_sylow_subgroups
    let counting_verified be (num_sylow_p % prime) is equal to 1
    Map.put(results, "third_theorem_counting", counting_verified)
    
    Note: Third Sylow Theorem: Number divides group order / p^k
    Let group_order be group.order
    let max_p_power be 1
    Let temp_order be group_order
    While temp_order % prime is equal to 0:
        Set max_p_power to max_p_power multiplied by prime
        Set temp_order to temp_order / prime
    
    Let index_condition be (group_order / max_p_power) % num_sylow_p is equal to 0
    Map.put(results, "third_theorem_divisibility", index_condition)
    
    Return results

Process called "compute_p_group_structure" that takes group as Group, prime as Integer returns Dictionary[String, String]:
    Note: Analyze structure of p-group using p-group theory
    Note: Computes central series, class, and nilpotency properties
    
    Let analysis be Dictionary[String, String]()
    
    Note: Check if group is a p-group
    Let is_p_group be true
    Let group_order be group.order
    Let temp_order be group_order
    While temp_order is greater than 1:
        If temp_order % prime does not equal 0:
            Set is_p_group to false
            Break
        Set temp_order to temp_order / prime
    
    Map.put(analysis, "is_p_group", is_p_group.toString())
    
    If is_p_group:
        Note: P-groups are nilpotent
        Map.put(analysis, "is_nilpotent", "true")
        
        Note: Compute nilpotency class
        Let nilpotency_class be compute_nilpotency_class(group)
        Map.put(analysis, "nilpotency_class", nilpotency_class.toString())
        
        Note: Center is non-trivial for p-groups
        Map.put(analysis, "has_nontrivial_center", "true")
        
        Note: Compute exponent (largest order of any element)
        Let exponent be 1
        For element in group.elements:
            Let element_order be compute_element_order(element, group)
            If element_order is greater than exponent:
                Set exponent to element_order
        Map.put(analysis, "exponent", exponent.toString())
    Otherwise:
        Map.put(analysis, "is_nilpotent", "false")
        Map.put(analysis, "nilpotency_class", "0")
        Map.put(analysis, "has_nontrivial_center", "unknown")
        Map.put(analysis, "exponent", "unknown")
    
    Return analysis

Process called "hall_subgroup_theory" that takes group as Group, primes as List[Integer] returns List[Subgroup]:
    Note: Find Hall subgroups for given set of primes
    Note: Generalizes Sylow theory to π-subgroups for prime sets
    
    Let hall_subgroups be List[Subgroup]()
    Let all_subgroups be find_all_subgroups(group)
    
    Note: Compute target order (product of all prime powers in group order)
    Let group_order be group.order
    Let target_order be 1
    
    For prime in primes:
        Let prime_power be 1
        Let temp_order be group_order
        While temp_order % prime is equal to 0:
            Set prime_power to prime_power multiplied by prime
            Set temp_order to temp_order / prime
        Set target_order to target_order multiplied by prime_power
    
    Note: Find subgroups whose order consists only of primes from the given set
    For subgroup in all_subgroups:
        Let is_hall_subgroup be true
        Let subgroup_order be subgroup.order
        
        Note: Check if order is composed only of given primes
        Let temp_order be subgroup_order
        While temp_order is greater than 1:
            Let factor_found be false
            For prime in primes:
                If temp_order % prime is equal to 0:
                    Set temp_order to temp_order / prime
                    Set factor_found to true
                    Break
            If not factor_found:
                Set is_hall_subgroup to false
                Break
        
        Note: Check if it's maximal among π-subgroups
        If is_hall_subgroup and subgroup_order is greater than 1:
            Let is_maximal be true
            For other_subgroup in all_subgroups:
                If other_subgroup.order is greater than subgroup_order:
                    Let contains_subgroup be true
                    For element in subgroup.elements:
                        If not List.contains(other_subgroup.elements, element):
                            Set contains_subgroup to false
                            Break
                    
                    If contains_subgroup:
                        Note: Check if other_subgroup is also a π-subgroup
                        Let other_temp_order be other_subgroup.order
                        Let other_is_pi_group be true
                        While other_temp_order is greater than 1:
                            Let other_factor_found be false
                            For prime in primes:
                                If other_temp_order % prime is equal to 0:
                                    Set other_temp_order to other_temp_order / prime
                                    Set other_factor_found to true
                                    Break
                            If not other_factor_found:
                                Set other_is_pi_group to false
                                Break
                        
                        If other_is_pi_group:
                            Set is_maximal to false
                            Break
            
            If is_maximal:
                List.append(hall_subgroups, subgroup)
    
    Return hall_subgroups

Note: =====================================================================
Note: SOLVABLE AND NILPOTENT GROUP OPERATIONS
Note: =====================================================================

Process called "test_group_solvability" that takes group as Group returns Boolean:
    Note: Test if group is solvable using derived series
    Note: Computes derived series until reaching trivial group or detecting non-solvability
    
    Let derived_series be compute_derived_series(group)
    Let final_subgroup be List.get(derived_series, derived_series.length() minus 1)
    
    Note: Group is solvable if derived series reaches trivial group
    Return final_subgroup.order is equal to 1

Process called "compute_derived_series" that takes group as Group returns List[Subgroup]:
    Note: Compute derived series G⁽⁰⁾ ⊇ G⁽¹⁾ ⊇ G⁽²⁾ ⊇ ...
    Note: Constructs sequence of commutator subgroups
    
    Let derived_series be List[Subgroup]()
    
    Note: Start with the whole group as G^(0)
    Let current_subgroup be Subgroup {
        parent_group: group,
        elements: group.elements,
        generators: group.elements,
        order: group.order,
        index: 1,
        is_normal: true,
        left_cosets: List[List[String]](),
        right_cosets: List[List[String]](),
        conjugacy_class: List[Subgroup]()
    }
    
    List.append(derived_series, current_subgroup)
    
    Note: Compute successive derived subgroups
    While current_subgroup.order is greater than 1:
        Let commutator_elements be Set[String]()
        Set.add(commutator_elements, group.identity)
        
        Note: Generate all commutators [a,b] is equal to aba^(-1)b^(-1)
        For a in current_subgroup.elements:
            For b in current_subgroup.elements:
                Let a_inv be Map.get(group.inverses, a)
                Let b_inv be Map.get(group.inverses, b)
                Let ab be Map.get(Map.get(group.operation, a), b)
                Let aba_inv be Map.get(Map.get(group.operation, ab), a_inv)
                Let commutator be Map.get(Map.get(group.operation, aba_inv), b_inv)
                Set.add(commutator_elements, commutator)
        
        Note: Convert set to list
        Let commutator_list be List[String]()
        For element in commutator_elements:
            List.append(commutator_list, element)
        
        Note: Generate subgroup from commutators
        Let next_subgroup be generate_subgroup(commutator_list, group)
        
        Note: If derived subgroup is equal to current subgroup, we've reached stability
        If next_subgroup.order is equal to current_subgroup.order:
            Break
        
        Set current_subgroup to next_subgroup
        List.append(derived_series, current_subgroup)
    
    Return derived_series

Process called "test_group_nilpotency" that takes group as Group returns Boolean:
    Note: Test if group is nilpotent using central series
    Note: Checks if upper central series reaches entire group
    
    Let central_series be compute_central_series(group)
    Let final_subgroup be List.get(central_series, central_series.length() minus 1)
    
    Note: Group is nilpotent if upper central series reaches whole group
    Return final_subgroup.order is equal to group.order

Process called "compute_central_series" that takes group as Group returns List[Subgroup]:
    Note: Compute upper and lower central series
    Note: Constructs Z₀(G) ⊆ Z₁(G) ⊆ Z₂(G) ⊆ ... and γ₁(G) ⊇ γ₂(G) ⊇ ...
    
    Let central_series be List[Subgroup]()
    
    Note: Start with trivial subgroup Z₀(G) is equal to {e}
    Let current_center be Subgroup {
        parent_group: group,
        elements: [group.identity],
        generators: [group.identity],
        order: 1,
        index: group.order,
        is_normal: true,
        left_cosets: List[List[String]](),
        right_cosets: List[List[String]](),
        conjugacy_class: List[Subgroup]()
    }
    
    List.append(central_series, current_center)
    
    Note: Compute successive central subgroups
    While current_center.order is less than group.order:
        Let new_center_elements be Set[String]()
        Set.add(new_center_elements, group.identity)
        
        Note: Find elements that commute with all elements in quotient
        For g in group.elements:
            Let centralizes_quotient be true
            For h in group.elements:
                Let gh be Map.get(Map.get(group.operation, g), h)
                Let hg be Map.get(Map.get(group.operation, h), g)
                Let g_inv be Map.get(group.inverses, g)
                Let h_inv be Map.get(group.inverses, h)
                Let commutator be Map.get(Map.get(group.operation, gh), Map.get(Map.get(group.operation, g_inv), h_inv))
                
                If not List.contains(current_center.elements, commutator):
                    Set centralizes_quotient to false
                    Break
            
            If centralizes_quotient:
                Set.add(new_center_elements, g)
        
        Note: Convert to list
        Let new_center_list be List[String]()
        For element in new_center_elements:
            List.append(new_center_list, element)
        
        Note: Create next center subgroup
        Let next_center be Subgroup {
            parent_group: group,
            elements: new_center_list,
            generators: new_center_list,
            order: new_center_list.length(),
            index: group.order / new_center_list.length(),
            is_normal: true,
            left_cosets: List[List[String]](),
            right_cosets: List[List[String]](),
            conjugacy_class: List[Subgroup]()
        }
        
        If next_center.order is equal to current_center.order:
            Break
        
        Set current_center to next_center
        List.append(central_series, current_center)
    
    Return central_series

Process called "compute_nilpotency_class" that takes group as Group returns Integer:
    Note: Compute nilpotency class of nilpotent group
    Note: Finds smallest n such that γₙ₊₁(G) is equal to {e}
    
    If not test_group_nilpotency(group):
        Return 0
    
    Let central_series be compute_central_series(group)
    Return central_series.length() minus 1

Note: =====================================================================
Note: GROUP ACTION OPERATIONS
Note: =====================================================================

Process called "create_group_action" that takes group as Group, set as List[String], action as Dictionary[String, Dictionary[String, String]] returns Dictionary[String, String]:
    Note: Create group action on set with action axiom verification
    Note: Verifies that action is well-defined and satisfies action properties
    
    Note: Verify action axioms
    Note: 1. Identity acts as identity: e · x is equal to x for all x
    For x in set:
        Let result be Map.get(Map.get(action, group.identity), x)
        If result does not equal x:
            Throw Errors.InvalidArgument with "Identity action axiom violated"
    
    Note: 2. Compatibility: (g · h) · x is equal to g · (h · x) for all g, h, x
    For g in group.elements:
        For h in group.elements:
            For x in set:
                Let gh be Map.get(Map.get(group.operation, g), h)
                Let h_x be Map.get(Map.get(action, h), x)
                Let g_h_x be Map.get(Map.get(action, g), h_x)
                Let gh_x be Map.get(Map.get(action, gh), x)
                If g_h_x does not equal gh_x:
                    Throw Errors.InvalidArgument with "Compatibility action axiom violated"
    
    Note: Return action properties
    Let properties be Dictionary[String, String]()
    Map.put(properties, "is_valid_action", "true")
    Map.put(properties, "group_order", group.order.toString())
    Map.put(properties, "set_size", set.length().toString())
    Return properties

Process called "orbit_stabilizer_theorem" that takes element as String, group as Group, action as Dictionary[String, Dictionary[String, String]] returns Dictionary[String, String]:
    Note: Apply orbit-stabilizer theorem |Orbit| × |Stabilizer| is equal to |Group|
    Note: Computes orbit and stabilizer sizes and verifies theorem
    
    Note: Compute orbit of element
    Let orbit be Set[String]()
    For g in group.elements:
        Let g_element be Map.get(Map.get(action, g), element)
        Set.add(orbit, g_element)
    
    Note: Compute stabilizer subgroup
    Let stabilizer_elements be List[String]()
    For g in group.elements:
        Let g_element be Map.get(Map.get(action, g), element)
        If g_element is equal to element:
            List.append(stabilizer_elements, g)
    
    Let orbit_size be orbit.size()
    Let stabilizer_size be stabilizer_elements.length()
    Let product be orbit_size multiplied by stabilizer_size
    
    Note: Verify theorem
    Let theorem_verified be product is equal to group.order
    
    Let result be Dictionary[String, String]()
    Map.put(result, "orbit_size", orbit_size.toString())
    Map.put(result, "stabilizer_size", stabilizer_size.toString())
    Map.put(result, "product", product.toString())
    Map.put(result, "group_order", group.order.toString())
    Map.put(result, "theorem_verified", theorem_verified.toString())
    Return result

Process called "burnside_lemma" that takes group as Group, action as Dictionary[String, Dictionary[String, String]] returns Integer:
    Note: Count orbits using Burnside's lemma (Cauchy-Frobenius lemma)
    Note: Computes average number of fixed points over group elements
    
    Let total_fixed_points be 0
    Let action_set be Map.keys(Map.get(action, group.identity))
    
    For g in group.elements:
        Let fixed_points be 0
        For x in action_set:
            Let g_x be Map.get(Map.get(action, g), x)
            If g_x is equal to x:
                Set fixed_points to fixed_points plus 1
        Set total_fixed_points to total_fixed_points plus fixed_points
    
    Return total_fixed_points / group.order

Process called "conjugation_action" that takes group as Group returns Dictionary[String, List[String]]:
    Note: Analyze conjugation action and conjugacy classes
    Note: Partitions group into conjugacy classes under inner automorphisms
    
    Let conjugacy_classes be Dictionary[String, List[String]]()
    Let processed_elements be Set[String]()
    
    For element in group.elements:
        If not Set.contains(processed_elements, element):
            Let conjugacy_class be List[String]()
            
            For g in group.elements:
                Let g_inv be Map.get(group.inverses, g)
                Let conjugate be Map.get(Map.get(group.operation, g), element)
                Set conjugate to Map.get(Map.get(group.operation, conjugate), g_inv)
                
                If not List.contains(conjugacy_class, conjugate):
                    List.append(conjugacy_class, conjugate)
                    Set.add(processed_elements, conjugate)
            
            Map.put(conjugacy_classes, element, conjugacy_class)
    
    Return conjugacy_classes

Note: =====================================================================
Note: GROUP CLASSIFICATION OPERATIONS
Note: =====================================================================

Process called "classify_small_groups" that takes order as Integer returns List[String]:
    Note: Classify all groups of given small order
    Note: Uses structure theorems and systematic enumeration methods
    
    Let classifications be List[String]()
    
    Note: Basic cases
    If order is equal to 1:
        List.append(classifications, "Trivial group")
    Otherwise if order is equal to 2:
        List.append(classifications, "Cyclic group C2")
    Otherwise if order is equal to 3:
        List.append(classifications, "Cyclic group C3")
    Otherwise if order is equal to 4:
        List.append(classifications, "Cyclic group C4")
        List.append(classifications, "Klein four-group V4")
    Otherwise if order is equal to 6:
        List.append(classifications, "Cyclic group C6")
        List.append(classifications, "Dihedral group D3 (symmetric group S3)")
    Otherwise:
        Note: For larger orders, use prime factorization analysis
        Let classification be "Order " plus order.toString() plus " groups (" plus count_groups_of_order(order).toString() plus " isomorphism classes)"
        List.append(classifications, classification)
    
    Return classifications

Process called "abelian_group_classification" that takes group as Group returns Dictionary[String, List[Integer]]:
    Note: Classify abelian group using fundamental theorem
    Note: Decomposes abelian group into cyclic factors
    
    Let classification be Dictionary[String, List[Integer]]()
    
    If not group.is_abelian:
        Map.put(classification, "error", [0])
        Return classification
    
    Note: Compute orders of all elements
    Let element_orders be List[Integer]()
    For element in group.elements:
        Let order be compute_element_order(element, group)
        List.append(element_orders, order)
    
    Note: Compute invariant factors using Smith normal form approach
    Let invariant_factors be compute_invariant_factors_from_orders(element_orders, group.order)
    
    Note: Complete decomposition using structure theorem
    Note: Build cyclic decomposition from invariant factors
    Let cyclic_factors be List[Dictionary[String, String]]()
    
    Each invariant_factor in invariant_factors Do:
        If invariant_factor is greater than 1 Then:
            Let cyclic_component be Dictionary[String, String]
            Set cyclic_component["type"] to "cyclic"
            Set cyclic_component["order"] to invariant_factor.toString()
            Set cyclic_component["generator"] to find_element_of_order(group, invariant_factor)
            Set cyclic_component["description"] to "Z/" plus invariant_factor.toString() plus "Z"
            cyclic_factors.add(cyclic_component)
        End If
    End Each
    
    Map.put(classification, "invariant_factors", invariant_factors)
    Map.put(classification, "cyclic_decomposition", cyclic_factors)
    Return classification
    
    Note: Helper function to compute invariant factors from element orders
    Process called "compute_invariant_factors_from_orders" that takes element_orders as List[Integer], group_order as Integer returns List[Integer]:
        Note: Use structure theory to determine invariant factors
        Let prime_power_orders be extract_prime_power_components(element_orders)
        Let invariant_factors be List[Integer]()
        
        Note: For each prime, find the maximal powers that appear
        Let primes_processed be Dictionary[Integer, Integer]()
        
        Each prime_power in prime_power_orders Do:
            Let prime be extract_prime_from_power(prime_power)
            Let power be extract_exponent_from_power(prime_power)
            
            If primes_processed.containsKey(prime) Then:
                Let current_max_power be primes_processed[prime]
                If power is greater than current_max_power Then:
                    Set primes_processed[prime] to power
                End If
            Otherwise:
                Set primes_processed[prime] to power
            End If
        End Each
        
        Note: Build invariant factors from prime powers
        Each prime in primes_processed.keys Do:
            Let max_power be primes_processed[prime]
            Let i be 1
            While i is less than or equal to max_power:
                Let factor be compute_integer_power(prime, i)
                If factor is less than or equal to group_order and group_order % factor is equal to 0 Then:
                    invariant_factors.add(factor)
                End If
                Set i to i plus 1
            End While
        End Each
        
        Note: Sort invariant factors in descending order
        Return sort_descending(invariant_factors)
    End Process
    
    Note: Helper function to extract prime power components
    Process called "extract_prime_power_components" that takes orders as List[Integer] returns List[Integer]:
        Let prime_powers be List[Integer]()
        
        Each order in orders Do:
            Let factorization be prime_factorization(order)
            Each prime_power in factorization Do:
                If not prime_powers.contains(prime_power) Then:
                    prime_powers.add(prime_power)
                End If
            End Each
        End Each
        
        Return prime_powers
    End Process
    
    Note: Helper function to find element of specific order
    Process called "find_element_of_order" that takes group as Group, target_order as Integer returns String:
        Each element in group.elements Do:
            Let element_order be compute_element_order(element, group)
            If element_order is equal to target_order Then:
                Return element
            End If
        End Each
        
        Note: If no element found, return identity (order 1)
        Return group.identity
    End Process

Process called "simple_group_recognition" that takes group as Group returns Boolean:
    Note: Recognize if group is simple using composition series
    Note: Checks for absence of proper normal subgroups
    
    If group.order is equal to 1:
        Return false
    
    Let all_subgroups be find_all_subgroups(group)
    
    For subgroup in all_subgroups:
        If subgroup.order is greater than 1 and subgroup.order is less than group.order:
            If test_normal_subgroup(subgroup, group):
                Return false
    
    Return true

Process called "composition_series" that takes group as Group returns List[Subgroup]:
    Note: Compute composition series with simple quotients
    Note: Finds maximal normal series with simple composition factors
    
    Let composition_series be List[Subgroup]()
    Let current_group be group
    
    Note: Start with whole group
    Let whole_group_subgroup be Subgroup {
        parent_group: group,
        elements: group.elements,
        generators: group.elements,
        order: group.order,
        index: 1,
        is_normal: true,
        left_cosets: List[List[String]](),
        right_cosets: List[List[String]](),
        conjugacy_class: List[Subgroup]()
    }
    
    List.append(composition_series, whole_group_subgroup)
    
    Note: Find chain of maximal normal subgroups
    While current_group.order is greater than 1:
        Let all_subgroups be find_all_subgroups(current_group)
        Let maximal_normal_subgroup be Subgroup {
            parent_group: current_group,
            elements: [current_group.identity],
            generators: [current_group.identity],
            order: 1,
            index: current_group.order,
            is_normal: true,
            left_cosets: List[List[String]](),
            right_cosets: List[List[String]](),
            conjugacy_class: List[Subgroup]()
        }
        
        Note: Find largest proper normal subgroup
        For subgroup in all_subgroups:
            If subgroup.order is less than current_group.order and subgroup.order is greater than maximal_normal_subgroup.order:
                If test_normal_subgroup(subgroup, current_group):
                    Set maximal_normal_subgroup to subgroup
        
        If maximal_normal_subgroup.order is equal to 1:
            Break
        
        List.append(composition_series, maximal_normal_subgroup)
        Note: Continue with quotient group for complete series
        Set current_group to construct_quotient_group(current_group, maximal_normal_subgroup)
    
    Return composition_series

Process called "jordan_holder_theorem" that takes group as Group returns Dictionary[String, List[String]]:
    Note: Apply Jordan-Hölder theorem for composition series uniqueness
    Note: Shows composition factors are unique up to isomorphism and order
    
    Let result be Dictionary[String, List[String]]()
    Let series be composition_series(group)
    Let composition_factors be List[String]()
    
    Note: Compute composition factors from series
    For i in range(0, series.length() minus 1):
        Let larger_subgroup be List.get(series, i)
        Let smaller_subgroup be List.get(series, i plus 1)
        Let factor_order be larger_subgroup.order / smaller_subgroup.order
        Let factor_name be "Factor of order " plus factor_order.toString()
        List.append(composition_factors, factor_name)
    
    Map.put(result, "composition_factors", composition_factors)
    Map.put(result, "theorem_statement", ["Composition factors are unique up to isomorphism and permutation"])
    
    Return result