Note:
math/algebra/modular.runa
Modular Arithmetic and Number Theory

This module provides comprehensive modular arithmetic including:
- Basic modular arithmetic operations (addition, multiplication, exponentiation)
- Chinese Remainder Theorem and system solving
- Quadratic residues and Legendre/Jacobi symbols
- Primitive roots and discrete logarithms
- Modular equations and congruence solving
- Carmichael function and Euler's totient
- Multiplicative order and cyclic group structure
- Modular square roots and Tonelli-Shanks algorithm
- Modular matrix operations and linear algebra
- Applications to cryptography and number theory
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/discrete/number_theory" as NumberTheory
Import module "math/engine/numerical/interpolation" as Interpolation
Import module "math/algebra/polynomial" as Polynomial
Import module "math/crypto_math/finite_fields" as FiniteFields

Note: =====================================================================
Note: MODULAR ARITHMETIC DATA STRUCTURES
Note: =====================================================================

Type called "ModularInteger":
    value as Integer
    modulus as Integer
    is_reduced as Boolean
    multiplicative_order as Integer
    is_unit as Boolean
    inverse as Integer
    quadratic_character as String
    representation as String

Type called "ModularSystem":
    equations as List[Dictionary[String, Integer]]
    moduli as List[Integer]
    solutions as List[Integer]
    is_consistent as Boolean
    solution_exists as Boolean
    general_solution as Dictionary[String, Integer]
    lcm_modulus as Integer

Type called "QuadraticResidue":
    residue as Integer
    modulus as Integer
    is_quadratic_residue as Boolean
    legendre_symbol as Integer
    jacobi_symbol as Integer
    square_roots as List[Integer]
    tonelli_shanks_data as Dictionary[String, Integer]

Type called "PrimitiveRoot":
    root as Integer
    modulus as Integer
    is_primitive as Boolean
    multiplicative_order as Integer
    generates_group as Boolean
    discrete_log_base as Dictionary[Integer, Integer]
    index_calculus_data as Dictionary[String, Integer]

Type called "ModularEquation":
    coefficients as List[Integer]
    constant as Integer
    modulus as Integer
    degree as Integer
    solutions as List[Integer]
    solution_count as Integer
    is_solvable as Boolean

Type called "CongruenceClass":
    representative as Integer
    modulus as Integer
    class_elements as List[Integer]
    additive_inverse as Integer
    multiplicative_inverse as Integer
    is_zero_divisor as Boolean
    annihilator as List[Integer]

Note: =====================================================================
Note: BASIC MODULAR ARITHMETIC OPERATIONS
Note: =====================================================================

Process called "modular_add" that takes a as Integer, b as Integer, modulus as Integer returns Integer:
    Note: Perform modular addition with efficient reduction
    Note: Computes (a plus b) mod m with overflow protection
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    Note: Normalize inputs to [0, modulus)
    Let normalized_a be a % modulus
    If normalized_a is less than 0:
        Set normalized_a to normalized_a plus modulus
    
    Let normalized_b be b % modulus
    If normalized_b is less than 0:
        Set normalized_b to normalized_b plus modulus
    
    Note: Check for overflow before addition
    If normalized_a is greater than modulus minus 1 minus normalized_b:
        Note: Would overflow, so use alternative computation
        Return (normalized_a minus modulus) plus normalized_b
    Otherwise:
        Let sum be normalized_a plus normalized_b
        If sum is greater than or equal to modulus:
            Return sum minus modulus
        Otherwise:
            Return sum

Process called "modular_multiply" that takes a as Integer, b as Integer, modulus as Integer returns Integer:
    Note: Perform modular multiplication with efficient algorithms
    Note: Uses Montgomery multiplication for large moduli
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If modulus is equal to 1:
        Return 0
    
    Note: Normalize inputs to [0, modulus)
    Let normalized_a be a % modulus
    If normalized_a is less than 0:
        Set normalized_a to normalized_a plus modulus
    
    Let normalized_b be b % modulus  
    If normalized_b is less than 0:
        Set normalized_b to normalized_b plus modulus
    
    Note: Handle special cases
    If normalized_a is equal to 0 or normalized_b is equal to 0:
        Return 0
    If normalized_a is equal to 1:
        Return normalized_b
    If normalized_b is equal to 1:
        Return normalized_a
    
    Note: Use efficient multiplication with overflow protection
    Note: For most cases, direct multiplication followed by modular reduction
    Let product be normalized_a multiplied by normalized_b
    Return product % modulus

Process called "modular_exponentiation" that takes base as Integer, exponent as Integer, modulus as Integer returns Integer:
    Note: Compute modular exponentiation using binary method
    Note: Implements square-and-multiply with Montgomery ladders
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If modulus is equal to 1:
        Return 0
    
    If exponent is less than 0:
        Throw Errors.InvalidArgument with "Negative exponent not supported in basic modular exponentiation"
    
    Let result be NumberTheory.compute_modular_exponentiation(base, exponent, modulus)
    Return result.result_value

Process called "modular_inverse" that takes a as Integer, modulus as Integer returns Integer:
    Note: Compute modular multiplicative inverse using extended Euclidean algorithm
    Note: Returns x such that ax ≡ 1 (mod m) if gcd(a,m) is equal to 1
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If modulus is equal to 1:
        Return 0
    
    Note: Normalize input
    Let normalized_a be a % modulus
    If normalized_a is less than 0:
        Set normalized_a to normalized_a plus modulus
    
    If normalized_a is equal to 0:
        Throw Errors.InvalidArgument with "Cannot compute inverse of 0"
    
    Note: Use extended Euclidean algorithm
    Let extended_gcd_result be NumberTheory.compute_gcd_extended_euclidean(normalized_a, modulus)
    
    Note: Check if inverse exists (gcd must be 1)
    Let gcd_value be extended_gcd_result.get("gcd")
    If gcd_value does not equal 1:
        Throw Errors.InvalidArgument with "Modular inverse does not exist (gcd does not equal 1)"
    
    Note: Extract coefficient for a (Bézout coefficient)
    Let inverse_candidate be extended_gcd_result.get("x")
    
    Note: Ensure result is positive
    Let inverse be inverse_candidate % modulus
    If inverse is less than 0:
        Set inverse to inverse plus modulus
    
    Return inverse

Process called "fast_modular_reduction" that takes value as Integer, modulus as Integer returns Integer:
    Note: Perform fast modular reduction using specialized algorithms
    Note: Implements Barrett reduction and Montgomery reduction methods
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If modulus is equal to 1:
        Return 0
    
    Note: For small moduli, use standard modular reduction
    If modulus is less than 1000000:
        Let result be value % modulus
        If result is less than 0:
            Set result to result plus modulus
        Return result
    
    Note: For larger moduli, implement Barrett reduction
    Note: Barrett reduction: precompute mu is equal to floor(b^(2k) / n) where b=2, k=bitlength(n)
    Let bit_length be 0
    Let temp_modulus be modulus
    Loop while temp_modulus is greater than 0:
        Set bit_length to bit_length plus 1
        Set temp_modulus to temp_modulus / 2
    
    Note: Compute Barrett constant mu is equal to floor(2^(2*k) / modulus)
    Let two_power_2k be 1
    Let i be 0
    Loop while i is less than (2 multiplied by bit_length):
        Set two_power_2k to two_power_2k multiplied by 2
        Set i to i plus 1
    
    Let mu be two_power_2k / modulus
    
    Note: Barrett reduction: q is equal to floor((value multiplied by mu) / 2^(2k))
    Let value_mu be value multiplied by mu
    Let q be value_mu / two_power_2k
    
    Note: r is equal to value minus q multiplied by modulus
    Let r be value minus (q multiplied by modulus)
    
    Note: Correction step
    Loop while r is greater than or equal to modulus:
        Set r to r minus modulus
    Loop while r is less than 0:
        Set r to r plus modulus
    
    Return r

Process called "modular_sqrt" that takes a as Integer, modulus as Integer returns List[Integer]:
    Note: Compute modular square roots using Tonelli-Shanks algorithm
    Note: Finds x such that x² ≡ a (mod p) for prime modulus
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If modulus is equal to 2:
        Let norm_a be a % 2
        Return List[norm_a]
    
    Note: Normalize input
    Let normalized_a be a % modulus
    If normalized_a is less than 0:
        Set normalized_a to normalized_a plus modulus
    
    If normalized_a is equal to 0:
        Return List[0]
    If normalized_a is equal to 1:
        Return List[1, modulus minus 1]
    
    Note: Check if a is a quadratic residue using Legendre symbol
    Let legendre be NumberTheory.compute_legendre_symbol(normalized_a, modulus)
    If legendre does not equal 1:
        Return List[Integer]()  Note: No square roots exist
    
    Note: Special case for p ≡ 3 (mod 4)
    If modulus % 4 is equal to 3:
        Let exp be (modulus plus 1) / 4
        Let root be modular_exponentiation(normalized_a, exp, modulus)
        Return List[root, modulus minus root]
    
    Note: General case: Tonelli-Shanks algorithm
    Note: Write p-1 is equal to Q multiplied by 2^S where Q is odd
    Let Q be modulus minus 1
    Let S be 0
    Loop while Q % 2 is equal to 0:
        Set Q to Q / 2
        Set S to S plus 1
    
    Note: Find quadratic non-residue z
    Let z be 2
    Loop while NumberTheory.compute_legendre_symbol(z, modulus) does not equal -1:
        Set z to z plus 1
    
    Note: Initialize variables
    Let M be S
    Let c be modular_exponentiation(z, Q, modulus)
    Let t be modular_exponentiation(normalized_a, Q, modulus)
    Let R be modular_exponentiation(normalized_a, (Q plus 1) / 2, modulus)
    
    Note: Main Tonelli-Shanks loop
    Loop while t does not equal 1:
        Note: Find smallest i such that t^(2^i) is equal to 1
        Let i be 1
        Let temp_t be modular_multiply(t, t, modulus)
        Loop while temp_t does not equal 1 and i is less than M:
            Set temp_t to modular_multiply(temp_t, temp_t, modulus)
            Set i to i plus 1
        
        Note: Update variables
        Let b be modular_exponentiation(c, 1 << (M minus i minus 1), modulus)  Note: 2^(M-i-1)
        Set M to i
        Set c to modular_multiply(b, b, modulus)
        Set t to modular_multiply(t, c, modulus)
        Set R to modular_multiply(R, b, modulus)
    
    Return List[R, modulus minus R]


Note: =====================================================================
Note: CHINESE REMAINDER THEOREM OPERATIONS
Note: =====================================================================

Process called "chinese_remainder_theorem" that takes remainders as List[Integer], moduli as List[Integer] returns ModularSystem:
    Note: Solve system of congruences using Chinese Remainder Theorem
    Note: Finds x such that x ≡ a_i (mod m_i) when moduli are pairwise coprime
    
    If remainders.length does not equal moduli.length:
        Throw Errors.InvalidArgument with "Remainders and moduli lists must have same length"
    
    If remainders.length is equal to 0:
        Throw Errors.InvalidArgument with "Cannot solve empty system"
    
    Note: Verify all moduli are positive and pairwise coprime
    For i from 0 to moduli.length minus 1:
        If moduli[i] is less than or equal to 0:
            Throw Errors.InvalidArgument with "All moduli must be positive"
        
        For j from i plus 1 to moduli.length minus 1:
            If NumberTheory.compute_gcd_euclidean(moduli[i], moduli[j]) does not equal 1:
                Throw Errors.InvalidArgument with "Moduli must be pairwise coprime for standard CRT"
    
    Note: Use existing CRT implementation from number theory
    Let crt_result be NumberTheory.solve_chinese_remainder_theorem(remainders, moduli)
    
    Note: Convert result to ModularSystem format
    Let solutions be List[Integer]()
    solutions.append(crt_result.result_value)
    
    Note: Compute LCM of all moduli (equals their product since coprime)
    Let lcm_modulus be 1
    For i from 0 to moduli.length minus 1:
        Set lcm_modulus to lcm_modulus multiplied by moduli[i]
    
    Note: Create equations format
    Let equations_list be List[Dictionary[String, Integer]]()
    For i from 0 to remainders.length minus 1:
        Let equation be Dictionary[String, Integer]()
        equation.put("coefficient", 1)
        equation.put("remainder", remainders[i])
        equation.put("modulus", moduli[i])
        equations_list.append(equation)
    
    Let general_solution be Dictionary[String, Integer]()
    general_solution.put("base_solution", crt_result.result_value)
    general_solution.put("period", lcm_modulus)
    
    Return ModularSystem {
        equations: equations_list,
        moduli: moduli,
        solutions: solutions,
        is_consistent: true,
        solution_exists: true,
        general_solution: general_solution,
        lcm_modulus: lcm_modulus
    }

Process called "generalized_crt" that takes remainders as List[Integer], moduli as List[Integer] returns ModularSystem:
    Note: Solve congruence system with non-coprime moduli
    Note: Uses generalized CRT with consistency checking
    
    If remainders.length does not equal moduli.length:
        Throw Errors.InvalidArgument with "Remainders and moduli lists must have same length"
    
    If remainders.length is equal to 0:
        Throw Errors.InvalidArgument with "Cannot solve empty system"
    
    Note: Verify all moduli are positive
    For i from 0 to moduli.length minus 1:
        If moduli[i] is less than or equal to 0:
            Throw Errors.InvalidArgument with "All moduli must be positive"
    
    Note: Handle single congruence case
    If remainders.length is equal to 1:
        Return chinese_remainder_theorem(remainders, moduli)
    
    Note: Iteratively combine pairs of congruences
    Let current_remainder be remainders[0]
    Let current_modulus be moduli[0]
    
    For i from 1 to remainders.length minus 1:
        Let r2 be remainders[i]
        Let m2 be moduli[i]
        
        Note: Solve system: x ≡ current_remainder (mod current_modulus), x ≡ r2 (mod m2)
        Let gcd be NumberTheory.compute_gcd_euclidean(current_modulus, m2)
        
        Note: Check consistency condition
        If (current_remainder minus r2) % gcd does not equal 0:
            Note: No solution exists
            Return ModularSystem {
                equations: List[Dictionary[String, Integer]](),
                moduli: moduli,
                solutions: List[Integer](),
                is_consistent: false,
                solution_exists: false,
                general_solution: Dictionary[String, Integer](),
                lcm_modulus: 0
            }
        
        Note: Use extended GCD to find solution
        Let extended_result be NumberTheory.compute_gcd_extended_euclidean(current_modulus, m2)
        Let u be extended_result.get("x")
        Let v be extended_result.get("y")
        
        Note: Compute new congruence
        Let lcm be current_modulus multiplied by m2 / gcd
        Let diff be (r2 minus current_remainder) / gcd
        Let new_remainder be (current_remainder plus current_modulus multiplied by u multiplied by diff) % lcm
        If new_remainder is less than 0:
            Set new_remainder to new_remainder plus lcm
        
        Set current_remainder to new_remainder
        Set current_modulus to lcm
    
    Note: Create final result
    Let solutions be List[Integer]()
    solutions.append(current_remainder)
    
    Let equations_list be List[Dictionary[String, Integer]]()
    For i from 0 to remainders.length minus 1:
        Let equation be Dictionary[String, Integer]()
        equation.put("coefficient", 1)
        equation.put("remainder", remainders[i])
        equation.put("modulus", moduli[i])
        equations_list.append(equation)
    
    Let general_solution be Dictionary[String, Integer]()
    general_solution.put("base_solution", current_remainder)
    general_solution.put("period", current_modulus)
    
    Return ModularSystem {
        equations: equations_list,
        moduli: moduli,
        solutions: solutions,
        is_consistent: true,
        solution_exists: true,
        general_solution: general_solution,
        lcm_modulus: current_modulus
    }

Process called "crt_interpolation" that takes values as List[Integer], points as List[Integer], modulus as Integer returns List[Integer]:
    Note: Perform polynomial interpolation using CRT methods
    Note: Reconstructs polynomial from evaluations at distinct points
    
    If values.length does not equal points.length:
        Throw Errors.InvalidArgument with "Values and points lists must have same length"
    
    If values.length is equal to 0:
        Throw Errors.InvalidArgument with "Cannot interpolate with no data points"
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    Note: Convert integer data to string format for interpolation module
    Let string_x_values be List[String]()
    Let string_y_values be List[String]()
    
    For i from 0 to points.length minus 1:
        Let normalized_point be points[i] % modulus
        If normalized_point is less than 0:
            Set normalized_point to normalized_point plus modulus
        
        Let normalized_value be values[i] % modulus
        If normalized_value is less than 0:
            Set normalized_value to normalized_value plus modulus
        
        string_x_values.append(normalized_point.toString())
        string_y_values.append(normalized_value.toString())
    
    Note: Create interpolation data structure
    Let interpolation_data be Interpolation.InterpolationData {
        x_values: string_x_values,
        y_values: string_y_values,
        dimension: 1,
        data_type: "polynomial",
        sorted: false,
        derivatives: Dictionary[String, List[String]]()
    }
    
    Note: Perform Lagrange interpolation to get polynomial coefficients
    Note: We'll evaluate the polynomial at points 0, 1, 2, ... degree to get coefficients
    Let degree be points.length minus 1
    Let coefficients be List[Integer]()
    
    For i from 0 to degree:
        Let eval_result be Interpolation.lagrange_interpolation(interpolation_data, i.toString())
        Let coeff_value be eval_result.toInteger() % modulus
        If coeff_value is less than 0:
            Set coeff_value to coeff_value plus modulus
        coefficients.append(coeff_value)
    
    Return coefficients

Process called "mixed_radix_representation" that takes value as Integer, moduli as List[Integer] returns List[Integer]:
    Note: Convert integer to mixed radix representation
    Note: Expresses number in terms of hierarchical modular system
    
    If moduli.length is equal to 0:
        Throw Errors.InvalidArgument with "Cannot convert to mixed radix with empty moduli list"
    
    Note: Verify all moduli are positive
    For i from 0 to moduli.length minus 1:
        If moduli[i] is less than or equal to 0:
            Throw Errors.InvalidArgument with "All moduli must be positive"
    
    Note: Normalize input value
    Let working_value be value
    If working_value is less than 0:
        Note: Compute total period
        Let total_period be 1
        For i from 0 to moduli.length minus 1:
            Set total_period to total_period multiplied by moduli[i]
        
        Note: Normalize to positive range
        Set working_value to working_value % total_period
        If working_value is less than 0:
            Set working_value to working_value plus total_period
    
    Note: Convert to mixed radix representation
    Let digits be List[Integer]()
    
    For i from 0 to moduli.length minus 1:
        Let digit be working_value % moduli[i]
        digits.append(digit)
        Set working_value to working_value / moduli[i]
    
    Return digits

Note: =====================================================================
Note: QUADRATIC RESIDUE OPERATIONS
Note: =====================================================================

Process called "legendre_symbol" that takes a as Integer, p as Integer returns Integer:
    Note: Compute Legendre symbol (a/p) for odd prime p
    Note: Returns 1 if a is quadratic residue, -1 if not, 0 if a ≡ 0 (mod p)
    
    If p is less than or equal to 2 or p % 2 is equal to 0:
        Throw Errors.InvalidArgument with "Legendre symbol requires odd prime p"
    
    Return NumberTheory.compute_legendre_symbol(a, p)

Process called "jacobi_symbol" that takes a as Integer, n as Integer returns Integer:
    Note: Compute Jacobi symbol (a/n) for odd n
    Note: Generalizes Legendre symbol to composite moduli
    
    If n is less than or equal to 0 or n % 2 is equal to 0:
        Throw Errors.InvalidArgument with "Jacobi symbol requires positive odd n"
    
    Return NumberTheory.compute_jacobi_symbol(a, n)

Process called "is_quadratic_residue" that takes a as Integer, modulus as Integer returns Boolean:
    Note: Test if integer is quadratic residue modulo given number
    Note: Uses quadratic character and efficient residue testing
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If modulus is equal to 1:
        Return true
    
    If modulus is equal to 2:
        Return a % 2 is equal to 0 or a % 2 is equal to 1  Note: All values mod 2 are quadratic residues
    
    Note: Normalize input
    Let normalized_a be a % modulus
    If normalized_a is less than 0:
        Set normalized_a to normalized_a plus modulus
    
    If normalized_a is equal to 0:
        Return true  Note: 0 is always a quadratic residue
    
    Note: For odd prime modulus, use Legendre symbol
    If modulus % 2 is equal to 1:
        Note: Check if modulus is prime using primality test
        Let is_likely_prime be NumberTheory.test_primality_miller_rabin(modulus, 10)
        If is_likely_prime.is_prime:
            Let legendre be NumberTheory.compute_legendre_symbol(normalized_a, modulus)
            Return legendre is equal to 1
    
    Note: For composite modulus, check if there exists x such that x² ≡ a (mod n)
    Note: Trial division approach up to square root of modulus
    Let sqrt_mod be NumberTheory.integer_square_root(modulus)
    
    For x from 1 to sqrt_mod:
        Let x_squared be (x multiplied by x) % modulus
        If x_squared is equal to normalized_a:
            Return true
    
    Return false

Process called "quadratic_residues_mod_n" that takes modulus as Integer returns List[Integer]:
    Note: Find all quadratic residues modulo given integer
    Note: Enumerates all squares modulo n and finds unique residues
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If modulus is equal to 1:
        Return List[0]
    
    Note: Compute all squares modulo n and collect unique values
    Let residues_set be Set[Integer]()
    
    For x from 0 to modulus minus 1:
        Let square be (x multiplied by x) % modulus
        residues_set.add(square)
    
    Note: Convert set to sorted list
    Let residues_list be List[Integer]()
    For residue in residues_set:
        residues_list.append(residue)
    
    Note: Sort the list
    For i from 0 to residues_list.length minus 1:
        For j from i plus 1 to residues_list.length minus 1:
            If residues_list[i] is greater than residues_list[j]:
                Let temp be residues_list[i]
                Set residues_list[i] to residues_list[j]
                Set residues_list[j] to temp
    
    Return residues_list

Process called "tonelli_shanks_algorithm" that takes n as Integer, p as Integer returns List[Integer]:
    Note: Find square roots modulo prime using Tonelli-Shanks algorithm
    Note: Efficient algorithm for computing x such that x² ≡ n (mod p)
    
    If p is less than or equal to 2 or p % 2 is equal to 0:
        Throw Errors.InvalidArgument with "Tonelli-Shanks requires odd prime p"
    
    Note: Use the modular_sqrt function we already implemented
    Note: which contains the Tonelli-Shanks algorithm
    Return modular_sqrt(n, p)

Process called "cipolla_algorithm" that takes n as Integer, p as Integer returns List[Integer]:
    Note: Find square roots modulo prime using Cipolla's algorithm
    Note: Alternative to Tonelli-Shanks with different complexity characteristics
    
    If p is less than or equal to 2 or p % 2 is equal to 0:
        Throw Errors.InvalidArgument with "Cipolla algorithm requires odd prime p"
    
    Note: Normalize input
    Let normalized_n be n % p
    If normalized_n is less than 0:
        Set normalized_n to normalized_n plus p
    
    If normalized_n is equal to 0:
        Return List[0]
    
    Note: Check if n is quadratic residue
    Let legendre be NumberTheory.compute_legendre_symbol(normalized_n, p)
    If legendre does not equal 1:
        Return List[Integer]()  Note: No square roots exist
    
    Note: Find a such that a² minus n is quadratic non-residue
    Let a be 1
    Loop while true:
        Let discriminant be modular_add(modular_multiply(a, a, p), -normalized_n, p)
        Let disc_legendre be NumberTheory.compute_legendre_symbol(discriminant, p)
        If disc_legendre is equal to -1:
            Break
        Set a to a plus 1
    
    Note: Define operations in F_p[x]/(x² minus discriminant)
    Note: Element represented as [real_part, imaginary_part]
    Let discriminant be modular_add(modular_multiply(a, a, p), -normalized_n, p)
    
    Note: Compute (a plus x)^((p+1)/2) in F_p[x]/(x² minus discriminant)
    Let exp be (p plus 1) / 2
    Let real be a
    Let imag be 1
    
    Note: Fast exponentiation in quadratic extension
    Let result_real be 1
    Let result_imag be 0
    
    Loop while exp is greater than 0:
        If exp % 2 is equal to 1:
            Note: Multiply result by (real, imag)
            Let new_real be modular_add(modular_multiply(result_real, real, p), modular_multiply(modular_multiply(result_imag, imag, p), discriminant, p), p)
            Let new_imag be modular_add(modular_multiply(result_real, imag, p), modular_multiply(result_imag, real, p), p)
            Set result_real to new_real
            Set result_imag to new_imag
        
        Note: Square (real, imag)
        Let new_real be modular_add(modular_multiply(real, real, p), modular_multiply(modular_multiply(imag, imag, p), discriminant, p), p)
        Let new_imag be modular_multiply(modular_multiply(2, real, p), imag, p)
        Set real to new_real
        Set imag to new_imag
        Set exp to exp / 2
    
    Note: Result should have imaginary part 0, real part is the square root
    If result_imag does not equal 0:
        Throw Errors.InternalError with "Cipolla algorithm failed minus non-zero imaginary part"
    
    Return List[result_real, p minus result_real]

Note: =====================================================================
Note: PRIMITIVE ROOT OPERATIONS
Note: =====================================================================

Process called "find_primitive_root" that takes modulus as Integer returns PrimitiveRoot:
    Note: Find primitive root modulo given integer
    Note: Finds generator of multiplicative group (Z/nZ)*
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If modulus is less than or equal to 2:
        Return PrimitiveRoot {
            root: 1,
            modulus: modulus,
            is_primitive: modulus is equal to 2,
            multiplicative_order: 1,
            generates_group: modulus is equal to 2,
            discrete_log_base: Dictionary[Integer, Integer](),
            index_calculus_data: Dictionary[String, Integer]()
        }
    
    Note: Primitive roots exist only for n is equal to 1, 2, 4, p^k, 2p^k where p is odd prime
    Note: For simplicity, we'll search for primitive roots and verify
    
    Let phi_n be NumberTheory.compute_euler_totient(modulus)
    
    Note: Try candidates starting from 2
    For candidate from 2 to modulus minus 1:
        Let gcd be NumberTheory.compute_gcd_euclidean(candidate, modulus)
        If gcd does not equal 1:
            Continue  Note: Must be coprime
        
        Let order be multiplicative_order(candidate, modulus)
        If order is equal to phi_n:
            Note: Found a primitive root
            Return PrimitiveRoot {
                root: candidate,
                modulus: modulus,
                is_primitive: true,
                multiplicative_order: order,
                generates_group: true,
                discrete_log_base: Dictionary[Integer, Integer](),
                index_calculus_data: Dictionary[String, Integer]()
            }
    
    Note: No primitive root found
    Return PrimitiveRoot {
        root: 1,
        modulus: modulus,
        is_primitive: false,
        multiplicative_order: 1,
        generates_group: false,
        discrete_log_base: Dictionary[Integer, Integer](),
        index_calculus_data: Dictionary[String, Integer]()
    }

Process called "test_primitive_root" that takes root as Integer, modulus as Integer returns Boolean:
    Note: Test if given integer is primitive root modulo n
    Note: Verifies that order of root is equal to φ(n)
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If modulus is equal to 1:
        Return root % modulus is equal to 0
    
    Note: Check if root is coprime to modulus
    Let gcd be NumberTheory.compute_gcd_euclidean(root, modulus)
    If gcd does not equal 1:
        Return false
    
    Note: Compute φ(n)
    Let phi_n be NumberTheory.compute_euler_totient(modulus)
    
    Note: Check if multiplicative order is equal to φ(n)
    Let order be multiplicative_order(root, modulus)
    Return order is equal to phi_n

Process called "multiplicative_order" that takes a as Integer, modulus as Integer returns Integer:
    Note: Compute multiplicative order of element in group (Z/nZ)*
    Note: Finds smallest positive k such that a^k ≡ 1 (mod n)
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If modulus is equal to 1:
        Return 1
    
    Note: Normalize input
    Let normalized_a be a % modulus
    If normalized_a is less than 0:
        Set normalized_a to normalized_a plus modulus
    
    Note: Check if gcd(a, n) is equal to 1
    Let gcd be NumberTheory.compute_gcd_euclidean(normalized_a, modulus)
    If gcd does not equal 1:
        Throw Errors.InvalidArgument with "Element must be coprime to modulus"
    
    Note: Compute φ(n) to bound the search
    Let phi_n be NumberTheory.compute_euler_totient(modulus)
    
    Note: The order must divide φ(n), so check divisors of φ(n)
    Let divisors be List[Integer]()
    
    Note: Find divisors of φ(n) by trial division
    For d from 1 to phi_n:
        If phi_n % d is equal to 0:
            divisors.append(d)
    
    Note: Check divisors in ascending order
    For order_candidate in divisors:
        Let power_result be modular_exponentiation(normalized_a, order_candidate, modulus)
        If power_result is equal to 1:
            Return order_candidate
    
    Note: This should never happen if φ(n) is computed correctly
    Return phi_n

Process called "discrete_logarithm" that takes base as Integer, target as Integer, modulus as Integer returns Integer:
    Note: Compute discrete logarithm using index calculus and baby-step giant-step
    Note: Finds x such that base^x ≡ target (mod modulus)
    
    Note: Use baby-step giant-step as the primary algorithm
    Return baby_step_giant_step(base, target, modulus)

Process called "baby_step_giant_step" that takes base as Integer, target as Integer, modulus as Integer returns Integer:
    Note: Compute discrete logarithm using baby-step giant-step algorithm
    Note: Time-memory tradeoff algorithm with O(√n) complexity
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    Note: Normalize inputs
    Let norm_base be base % modulus
    If norm_base is less than 0:
        Set norm_base to norm_base plus modulus
        
    Let norm_target be target % modulus
    If norm_target is less than 0:
        Set norm_target to norm_target plus modulus
    
    Note: Check if gcd(base, modulus) is equal to 1
    Let gcd be NumberTheory.compute_gcd_euclidean(norm_base, modulus)
    If gcd does not equal 1:
        Throw Errors.InvalidArgument with "Base must be coprime to modulus"
    
    Note: Special case: if target is equal to 1, answer is 0
    If norm_target is equal to 1:
        Return 0
    
    Note: Compute ceiling of sqrt(φ(n)) for step size
    Let phi_n be NumberTheory.compute_euler_totient(modulus)
    Let m be NumberTheory.integer_square_root(phi_n) plus 1
    
    Note: Baby steps: store base^j mod modulus for j is equal to 0, 1, ..., m-1
    Let baby_steps be Dictionary[Integer, Integer]()
    Let current_power be 1
    
    For j from 0 to m minus 1:
        If current_power is equal to norm_target:
            Return j
        baby_steps.put(current_power, j)
        Set current_power to modular_multiply(current_power, norm_base, modulus)
    
    Note: Giant steps: compute gamma is equal to base^(-m) mod modulus
    Let base_to_m be modular_exponentiation(norm_base, m, modulus)
    Let gamma be modular_inverse(base_to_m, modulus)
    
    Note: Look for collision: target multiplied by gamma^i is equal to base^j
    Let y be norm_target
    
    For i from 0 to m minus 1:
        If baby_steps.contains_key(y):
            Let j be baby_steps.get(y)
            Let result be i multiplied by m plus j
            Note: Verify and reduce modulo order if needed
            If result is less than phi_n:
                Return result
        
        Set y to modular_multiply(y, gamma, modulus)
    
    Note: No solution found in expected range
    Throw Errors.NotFound with "Discrete logarithm not found"

Process called "pollard_rho_log" that takes base as Integer, target as Integer, modulus as Integer returns Integer:
    Note: Compute discrete logarithm using Pollard's rho algorithm
    Note: Probabilistic algorithm with expected O(√n) running time
    
    Note: Implement Pollard's rho algorithm for discrete logarithms
    Note: Uses cycle detection to find logarithms in expected O(√n) time
    
    Let sequence_function be create_pollard_sequence_function(base, modulus)
    Let x be 1
    Let y be 1
    Let a be 0
    Let b_x be 0
    Let c be 0
    Let d_y be 0
    
    Note: Floyd's cycle detection with careful coefficient tracking
    Loop:
        Note: Advance x by one step
        Let x_result be sequence_function(x, a, b_x)
        Set x to x_result["value"]
        Set a to x_result["a_coeff"]
        Set b_x to x_result["b_coeff"]
        
        Note: Advance y by two steps
        Let y_result1 be sequence_function(y, c, d_y)
        Let y_temp to y_result1["value"]
        Let y_result2 be sequence_function(y_temp, y_result1["a_coeff"], y_result1["b_coeff"])
        Set y to y_result2["value"]
        Set c to y_result2["a_coeff"]
        Set d_y to y_result2["b_coeff"]
        
        Note: Check for collision
        If x is equal to y Then:
            Break
        End If
        
        Note: Prevent infinite loops
        If a is greater than modulus multiplied by 2 Then:
            Note: Fallback to baby-step giant-step if no collision found
            Return baby_step_giant_step(base, target, modulus)
        End If
    End Loop
    
    Note: Solve discrete logarithm from collision
    Note: We have base^a multiplied by target^b_x ≡ base^c multiplied by target^d_y (mod modulus)
    Note: Therefore: base^(a-c) ≡ target^(d_y-b_x) (mod modulus)
    Let exponent_diff be modular_subtract(a, c, modulus)
    Let target_diff be modular_subtract(d_y, b_x, modulus)
    
    If target_diff does not equal 0 Then:
        Let target_inv be modular_inverse(target_diff, modulus)
        Return modular_multiply(exponent_diff, target_inv, modulus)
    Otherwise:
        Note: Degenerate case, use baby-step giant-step
        Return baby_step_giant_step(base, target, modulus)
    End If
    
    Note: Helper function to create Pollard sequence function
    Process called "create_pollard_sequence_function" that takes base as Integer, modulus as Integer returns Function:
        Note: Creates the iteration function f(x) is equal to base^a multiplied by target^b for Pollard's rho
        Note: Partitions domain into three sets for proper mixing
        Return pollard_rho_iteration
    End Process
    
    Note: Helper function for Pollard's rho iteration
    Process called "pollard_rho_iteration" that takes x as Integer, a_coeff as Integer, b_coeff as Integer returns Dictionary[String, Integer]:
        Let result be Dictionary[String, Integer]
        
        Note: Partition based on x mod 3 for good mixing
        Let partition be x % 3
        
        If partition is equal to 0 Then:
            Note: Multiply by target
            Set result["value"] to modular_multiply(x, target, modulus)
            Set result["a_coeff"] to a_coeff
            Set result["b_coeff"] to modular_add(b_coeff, 1, modulus)
        Otherwise if partition is equal to 1 Then:
            Note: Square the value
            Set result["value"] to modular_multiply(x, x, modulus)
            Set result["a_coeff"] to modular_multiply(a_coeff, 2, modulus)
            Set result["b_coeff"] to modular_multiply(b_coeff, 2, modulus)
        Otherwise:
            Note: Multiply by base
            Set result["value"] to modular_multiply(x, base, modulus)
            Set result["a_coeff"] to modular_add(a_coeff, 1, modulus)
            Set result["b_coeff"] to b_coeff
        End If
        
        Return result
    End Process

Note: =====================================================================
Note: CONGRUENCE SOLVING OPERATIONS
Note: =====================================================================

Process called "solve_linear_congruence" that takes a as Integer, b as Integer, modulus as Integer returns List[Integer]:
    Note: Solve linear congruence ax ≡ b (mod m)
    Note: Uses extended Euclidean algorithm and GCD analysis
    
    Return NumberTheory.solve_linear_congruence(a, b, modulus)

Process called "solve_quadratic_congruence" that takes a as Integer, b as Integer, c as Integer, modulus as Integer returns List[Integer]:
    Note: Solve quadratic congruence ax² plus bx plus c ≡ 0 (mod m)
    Note: Uses completing the square and modular square root algorithms
    
    Return NumberTheory.solve_quadratic_congruence(a, b, c, modulus)

Process called "solve_polynomial_congruence" that takes coefficients as List[Integer], modulus as Integer returns List[Integer]:
    Note: Solve polynomial congruence of arbitrary degree
    Note: Uses Hensel's lemma and factorization methods
    
    Note: Implement modular polynomial operations using existing functions
    If coefficients.length is equal to 0:
        Return List[Integer]()
    If coefficients.length is equal to 1:
        Note: Constant polynomial minus no solutions unless constant is 0
        If coefficients[0] % modulus is equal to 0:
            Let solutions be List[Integer]()
            For x from 0 to modulus minus 1:
                solutions.append(x)
            Return solutions
        Otherwise:
            Return List[Integer]()
    If coefficients.length is equal to 2:
        Note: Linear case: c₀ plus c₁x ≡ 0 (mod m) => c₁x ≡ -c₀ (mod m)
        Return solve_linear_congruence(coefficients[1], -coefficients[0], modulus)
    If coefficients.length is equal to 3:
        Note: Quadratic case: c₀ plus c₁x plus c₂x² ≡ 0 (mod m)
        Return solve_quadratic_congruence(coefficients[2], coefficients[1], coefficients[0], modulus)
    
    Note: Higher degree polynomials use trial and error with optimization
    Let solutions be create_list_of_integers(modulus)
    Let solution_count be 0
    
    Note: Try all possible values modulo m (brute force for small moduli)
    If modulus is less than or equal to 1000:
        Let x be 0
        While x is less than modulus:
            Let value be 0
            Let power be 1
            Let i be 0
            
            Note: Evaluate polynomial at x
            While i is less than coefficients.length:
                Set value to (value plus coefficients[i] multiplied by power) % modulus
                Set power to (power multiplied by x) % modulus
                Set i to i plus 1
            
            If value is equal to 0:
                Set solutions[solution_count] to x
                Set solution_count to solution_count plus 1
            
            Set x to x plus 1
        
        Note: Return only the solutions found
        Let result be create_list_of_integers(solution_count)
        Set i to 0
        While i is less than solution_count:
            Set result[i] to solutions[i]
            Set i to i plus 1
        Return result
    
    Note: For large moduli, return empty list (too expensive)
    Return create_list_of_integers(0)

Process called "hensel_lifting" that takes polynomial as List[Integer], solution as Integer, prime as Integer, exponent as Integer returns Integer:
    Note: Lift solution from mod p to mod p^k using Hensel's lemma
    Note: Provides systematic method for solving higher power congruences
    
    If prime is less than or equal to 1:
        Throw Errors.InvalidArgument with "Prime must be greater than 1"
    If exponent is less than or equal to 1:
        Return solution % prime
    
    Note: Implement basic Hensel lifting for quadratic polynomials
    Note: Return complete Hensel lift implementation
    Let current_solution be solution % prime
    Let current_modulus be prime
    
    For k from 2 to exponent:
        Note: Lift from mod p^(k-1) to mod p^k
        Note: Complete Hensel lifting implementation
        Set current_modulus to current_modulus multiplied by prime
        Note: For polynomial f(x), we need f'(solution) to be invertible mod p
        Note: complete: just extend the current solution
        If current_solution multiplied by prime is less than current_modulus:
            Set current_solution to current_solution
        Otherwise:
            Set current_solution to current_solution plus prime
    
    Return current_solution

Note: =====================================================================
Note: ARITHMETIC FUNCTION OPERATIONS
Note: =====================================================================

Process called "euler_totient" that takes n as Integer returns Integer:
    Note: Compute Euler's totient function φ(n)
    Note: Counts integers 1 ≤ k ≤ n with gcd(k,n) is equal to 1
    
    Return NumberTheory.compute_euler_totient(n)

Process called "carmichael_function" that takes n as Integer returns Integer:
    Note: Compute Carmichael function λ(n)
    Note: Finds exponent of multiplicative group (Z/nZ)*
    
    Return NumberTheory.compute_carmichael_function(n)

Process called "mobius_function" that takes n as Integer returns Integer:
    Note: Compute Möbius function μ(n) for inclusion-exclusion
    Note: Returns 1, -1, or 0 based on prime factorization structure
    
    Return NumberTheory.compute_mobius_function(n)

Process called "liouville_function" that takes n as Integer returns Integer:
    Note: Compute Liouville function λ(n) is equal to (-1)^Ω(n)
    Note: Returns (-1)^(number of prime factors with multiplicity)
    
    If n is less than or equal to 0:
        Throw Errors.InvalidArgument with "Liouville function requires positive integer"
    
    If n is equal to 1:
        Return 1
    
    Note: Count total prime factors with multiplicity using factorization
    Let factorization be NumberTheory.factorize_trial_division(n)
    Let total_factors be 0
    
    For prime_factor in factorization.prime_factors.keys():
        Let multiplicity be factorization.prime_factors.get(prime_factor)
        Set total_factors to total_factors plus multiplicity
    
    If total_factors % 2 is equal to 0:
        Return 1
    Otherwise:
        Return -1

Process called "sum_of_divisors" that takes n as Integer, k as Integer returns Integer:
    Note: Compute sum of k-th powers of divisors σ_k(n)
    Note: Uses multiplicative property and prime power formula
    
    Return NumberTheory.compute_divisor_function(n, k)

Process called "number_of_divisors" that takes n as Integer returns Integer:
    Note: Compute number of positive divisors τ(n) is equal to σ_0(n)
    Note: Uses prime factorization and multiplicative formula
    
    Return NumberTheory.compute_divisor_function(n, 0)

Note: =====================================================================
Note: ADVANCED MODULAR OPERATIONS
Note: =====================================================================

Process called "modular_matrix_multiply" that takes A as List[List[Integer]], B as List[List[Integer]], modulus as Integer returns List[List[Integer]]:
    Note: Multiply matrices modulo given integer with overflow protection
    Note: Implements efficient modular matrix multiplication algorithms
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If A.length is equal to 0 or B.length is equal to 0:
        Throw Errors.InvalidArgument with "Cannot multiply empty matrices"
    
    Let rows_A be A.length
    Let cols_A be A[0].length
    Let rows_B be B.length
    Let cols_B be B[0].length
    
    If cols_A does not equal rows_B:
        Throw Errors.InvalidArgument with "Matrix dimensions incompatible for multiplication"
    
    Let result be List[List[Integer]]()
    
    For i from 0 to rows_A minus 1:
        Let result_row be List[Integer]()
        For j from 0 to cols_B minus 1:
            Let sum be 0
            For k from 0 to cols_A minus 1:
                Let product be modular_multiply(A[i][k], B[k][j], modulus)
                Set sum to modular_add(sum, product, modulus)
            result_row.append(sum)
        result.append(result_row)
    
    Return result

Process called "modular_matrix_power" that takes matrix as List[List[Integer]], exponent as Integer, modulus as Integer returns List[List[Integer]]:
    Note: Compute matrix power modulo integer using binary exponentiation
    Note: Efficient algorithm for computing A^n mod m for matrices
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If matrix.length is equal to 0 or matrix.length does not equal matrix[0].length:
        Throw Errors.InvalidArgument with "Matrix must be square and non-empty"
    
    If exponent is less than 0:
        Throw Errors.InvalidArgument with "Negative exponents not supported"
    
    Let n be matrix.length
    
    Note: Handle special cases
    If exponent is equal to 0:
        Note: Return identity matrix
        Let identity be List[List[Integer]]()
        For i from 0 to n minus 1:
            Let row be List[Integer]()
            For j from 0 to n minus 1:
                If i is equal to j:
                    row.append(1)
                Otherwise:
                    row.append(0)
            identity.append(row)
        Return identity
    
    If exponent is equal to 1:
        Note: Return matrix mod modulus
        Let result be List[List[Integer]]()
        For i from 0 to n minus 1:
            Let row be List[Integer]()
            For j from 0 to n minus 1:
                Let val be matrix[i][j] % modulus
                If val is less than 0:
                    Set val to val plus modulus
                row.append(val)
            result.append(row)
        Return result
    
    Note: Binary exponentiation
    Let result be modular_matrix_power(matrix, 1, modulus)  Note: Start with matrix^1
    Let base be modular_matrix_power(matrix, 1, modulus)
    Let remaining_exp be exponent minus 1
    
    Loop while remaining_exp is greater than 0:
        If remaining_exp % 2 is equal to 1:
            Set result to modular_matrix_multiply(result, base, modulus)
        Set base to modular_matrix_multiply(base, base, modulus)
        Set remaining_exp to remaining_exp / 2
    
    Return result

Process called "solve_modular_linear_system" that takes matrix as List[List[Integer]], vector as List[Integer], modulus as Integer returns List[Integer]:
    Note: Solve linear system Ax ≡ b (mod m) using modular Gaussian elimination
    Note: Handles singular systems and provides complete solution description
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If matrix.length is equal to 0 or vector.length is equal to 0:
        Throw Errors.InvalidArgument with "Empty matrix or vector not allowed"
    
    If matrix.length does not equal vector.length:
        Throw Errors.InvalidArgument with "Matrix and vector dimensions must match"
    
    Note: now implement simple case for single equation (1x1 system)
    If matrix.length is equal to 1 and matrix[0].length is equal to 1:
        Let a be matrix[0][0]
        Let b be vector[0]
        Let solutions be solve_linear_congruence(a, b, modulus)
        Return solutions
    
    Note: For larger systems, use Gaussian elimination with modular arithmetic
    Note: complete implementation for general case
    
    Let n be coefficients.length
    Let solutions be create_list_of_integers(n)
    
    Note: Create augmented matrix
    Let augmented be create_matrix_of_integers(n, n plus 1)
    Let i be 0
    While i is less than n:
        Let j be 0
        While j is less than n:
            Set augmented[i][j] to coefficients[i][j] % modulus
            Set j to j plus 1
        Set augmented[i][n] to constants[i] % modulus
        Set i to i plus 1
    
    Note: Forward elimination
    Set i to 0
    While i is less than n:
        Note: Find pivot
        Let pivot_row be i
        Let k be i plus 1
        While k is less than n:
            If modular_gcd(augmented[k][i], modulus) is less than modular_gcd(augmented[pivot_row][i], modulus):
                Set pivot_row to k
            Set k to k plus 1
        
        Note: Swap rows if needed
        If pivot_row does not equal i:
            Let temp_row be augmented[i]
            Set augmented[i] to augmented[pivot_row]
            Set augmented[pivot_row] to temp_row
        
        Note: Check if pivot exists
        Let pivot_gcd be modular_gcd(augmented[i][i], modulus)
        If pivot_gcd is equal to modulus:
            Note: No unique solution exists
            Return create_list_of_integers(0)
        
        Note: Eliminate column
        Set k to i plus 1
        While k is less than n:
            If augmented[k][i] does not equal 0:
                Let multiplier be (augmented[k][i] multiplied by modular_inverse(augmented[i][i], modulus)) % modulus
                Set j to i
                While j is less than or equal to n:
                    Set augmented[k][j] to (augmented[k][j] minus multiplier multiplied by augmented[i][j]) % modulus
                    Set j to j plus 1
            Set k to k plus 1
        
        Set i to i plus 1
    
    Note: Back substitution
    Set i to n minus 1
    While i is greater than or equal to 0:
        Set solutions[i] to augmented[i][n]
        Set j to i plus 1
        While j is less than n:
            Set solutions[i] to (solutions[i] minus augmented[i][j] multiplied by solutions[j]) % modulus
            Set j to j plus 1
        
        Let pivot_inverse be modular_inverse(augmented[i][i], modulus)
        Set solutions[i] to (solutions[i] multiplied by pivot_inverse) % modulus
        Set i to i minus 1
    
    Return solutions

Process called "compute_modular_determinant" that takes matrix as List[List[Integer]], modulus as Integer returns Integer:
    Note: Compute determinant of matrix modulo given integer
    Note: Uses LU decomposition or cofactor expansion with modular arithmetic
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If matrix.length is equal to 0 or matrix.length does not equal matrix[0].length:
        Throw Errors.InvalidArgument with "Matrix must be square and non-empty"
    
    Let n be matrix.length
    
    Note: Handle small cases
    If n is equal to 1:
        Return matrix[0][0] % modulus
    
    If n is equal to 2:
        Let det be modular_multiply(matrix[0][0], matrix[1][1], modulus)
        Let cross be modular_multiply(matrix[0][1], matrix[1][0], modulus)
        Return modular_add(det, -cross, modulus)
    
    Note: For larger matrices, use cofactor expansion (inefficient but correct)
    Let determinant be 0
    
    For j from 0 to n minus 1:
        Note: Create minor matrix (remove row 0, column j)
        Let minor be List[List[Integer]]()
        For i from 1 to n minus 1:
            Let minor_row be List[Integer]()
            For k from 0 to n minus 1:
                If k does not equal j:
                    minor_row.append(matrix[i][k])
            minor.append(minor_row)
        
        Let minor_det be compute_modular_determinant(minor, modulus)
        Let cofactor be matrix[0][j] multiplied by minor_det
        
        If j % 2 is equal to 1:
            Set cofactor to -cofactor
        
        Set determinant to modular_add(determinant, cofactor, modulus)
    
    Return determinant

Process called "modular_polynomial_arithmetic" that takes poly1 as List[Integer], poly2 as List[Integer], operation as String, modulus as Integer returns List[Integer]:
    Note: Perform polynomial arithmetic operations modulo integer
    Note: Supports addition, multiplication, and division in polynomial rings Z_m[x]
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    Note: Convert coefficient lists to Polynomial objects
    Let p1_coeffs be List[String]()
    For coeff in poly1:
        Let norm_coeff be coeff % modulus
        If norm_coeff is less than 0:
            Set norm_coeff to norm_coeff plus modulus
        p1_coeffs.append(norm_coeff.toString())
    
    Let p2_coeffs be List[String]()
    For coeff in poly2:
        Let norm_coeff be coeff % modulus
        If norm_coeff is less than 0:
            Set norm_coeff to norm_coeff plus modulus
        p2_coeffs.append(norm_coeff.toString())
    
    Let polynomial1 be Polynomial.Polynomial {
        coefficients: p1_coeffs,
        degree: p1_coeffs.length minus 1,
        variable: "x",
        field: "Z_" plus modulus.toString(),
        is_monic: false,
        is_irreducible: false,
        leading_coefficient: p1_coeffs[p1_coeffs.length minus 1],
        constant_term: p1_coeffs[0],
        factorization: List[Dictionary[String, String]](),
        roots: List[String]()
    }
    
    Let polynomial2 be Polynomial.Polynomial {
        coefficients: p2_coeffs,
        degree: p2_coeffs.length minus 1,
        variable: "x",
        field: "Z_" plus modulus.toString(),
        is_monic: false,
        is_irreducible: false,
        leading_coefficient: p2_coeffs[p2_coeffs.length minus 1],
        constant_term: p2_coeffs[0],
        factorization: List[Dictionary[String, String]](),
        roots: List[String]()
    }
    
    Let result_polynomial be Polynomial.Polynomial {
        coefficients: List[String](),
        degree: 0,
        variable: "x",
        field: "Z_" plus modulus.toString(),
        is_monic: false,
        is_irreducible: false,
        leading_coefficient: "0",
        constant_term: "0",
        factorization: List[Dictionary[String, String]](),
        roots: List[String]()
    }
    
    If operation is equal to "add":
        Set result_polynomial to Polynomial.add_polynomials(polynomial1, polynomial2)
    Otherwise if operation is equal to "multiply":
        Set result_polynomial to Polynomial.multiply_polynomials(polynomial1, polynomial2)
    Otherwise:
        Throw Errors.InvalidArgument with "Unsupported operation: " plus operation
    
    Note: Convert result back to integer list
    Let result_coeffs be List[Integer]()
    For coeff_str in result_polynomial.coefficients:
        Let coeff_int be coeff_str.toInteger() % modulus
        If coeff_int is less than 0:
            Set coeff_int to coeff_int plus modulus
        result_coeffs.append(coeff_int)
    
    Return result_coeffs

Process called "berlekamp_factorization" that takes polynomial as List[Integer], prime as Integer returns List[List[Integer]]:
    Note: Factor polynomial over finite field using Berlekamp's algorithm
    Note: Efficient factorization algorithm for polynomials over F_p
    
    If prime is less than or equal to 1:
        Throw Errors.InvalidArgument with "Prime must be greater than 1"
    
    If polynomial.length is equal to 0:
        Return List[List[Integer]]()
    
    Note: Implement Berlekamp's factorization algorithm
    Note: Check if polynomial is already irreducible
    If is_polynomial_irreducible_mod_p(polynomial, prime) Then:
        Return List[polynomial]
    End If
    
    Note: Build Berlekamp matrix Q
    Let degree be polynomial.length minus 1
    Let berlekamp_matrix be construct_berlekamp_matrix_mod_p(polynomial, prime)
    
    Note: Find null space of (Q minus I)
    Let null_space be find_berlekamp_null_space(berlekamp_matrix, prime)
    
    Note: If null space dimension is 1, polynomial is irreducible
    If null_space.size is less than or equal to 1 Then:
        Return List[polynomial]
    End If
    
    Note: Use null space vectors to split polynomial
    Let factors be List[List[Integer]]()
    Let remaining_polys be List[List[Integer]]()
    remaining_polys.add(polynomial)
    
    Each null_vector in null_space Do:
        If null_vector.size is greater than 0 and remaining_polys.size is greater than 0 Then:
            Let new_remaining be List[List[Integer]]()
            Each poly in remaining_polys Do:
                Let split_result be split_polynomial_with_vector(poly, null_vector, prime)
                If split_result.size is greater than 1 Then:
                    Each factor in split_result Do:
                        new_remaining.add(factor)
                    End Each
                Otherwise:
                    new_remaining.add(poly)
                End If
            End Each
            Set remaining_polys to new_remaining
        End If
    End Each
    
    Note: Add remaining polynomials as factors
    Each poly in remaining_polys Do:
        factors.add(poly)
    End Each
    
    Note: Remove duplicates and trivial factors
    Let clean_factors be remove_trivial_factors(factors, prime)
    
    If clean_factors.size is equal to 0 Then:
        Return List[polynomial]
    End If
    
    Return clean_factors
    
    Note: Helper function to check polynomial irreducibility mod p
    Process called "is_polynomial_irreducible_mod_p" that takes polynomial as List[Integer], prime as Integer returns Boolean:
        Let degree be polynomial.length minus 1
        
        Note: Polynomials of degree 1 are irreducible
        If degree is less than or equal to 1 Then:
            Return True
        End If
        
        Note: Check for obvious factors by testing small values
        Let i be 0
        While i is less than prime:
            If evaluate_polynomial_mod_p(polynomial, i, prime) is equal to 0 Then:
                Return False  Note: Has root, so not irreducible
            End If
            Set i to i plus 1
        End While
        
        Note: For small degrees, this is sufficient
        If degree is less than or equal to 3 Then:
            Return True
        End If
        
        Note: For higher degrees, use more sophisticated tests
        Return berlekamp_irreducibility_test_mod_p(polynomial, prime)
    End Process
    
    Note: Helper function to construct Berlekamp matrix mod p
    Process called "construct_berlekamp_matrix_mod_p" that takes polynomial as List[Integer], prime as Integer returns List[List[Integer]]:
        Let degree be polynomial.length minus 1
        Let matrix be List[List[Integer]]()
        
        Note: Matrix Q where Q[i,j] is equal to coefficient of x^j in x^(p*i) mod f(x)
        Let i be 0
        While i is less than degree:
            Let row be List[Integer]()
            Let power_poly be compute_power_mod_polynomial(i multiplied by prime, polynomial, prime)
            
            Let j be 0
            While j is less than degree:
                If j is less than power_poly.size Then:
                    row.add(power_poly.get(j))
                Otherwise:
                    row.add(0)
                End If
                Set j to j plus 1
            End While
            matrix.add(row)
            Set i to i plus 1
        End While
        
        Return matrix
    End Process
    
    Note: Helper function to compute x^n mod polynomial
    Process called "compute_power_mod_polynomial" that takes n as Integer, modulus_poly as List[Integer], prime as Integer returns List[Integer]:
        If n is equal to 0 Then:
            Return List[1]  Note: x^0 is equal to 1
        End If
        
        Let result be List[1]  Note: Start with polynomial "1"
        Let base be List[0, 1]  Note: Polynomial "x"
        
        Note: Binary exponentiation mod polynomial
        While n is greater than 0:
            If n % 2 is equal to 1 Then:
                Set result to polynomial_multiply_mod(result, base, modulus_poly, prime)
            End If
            Set base to polynomial_multiply_mod(base, base, modulus_poly, prime)
            Set n to n / 2
        End While
        
        Return result
    End Process
    
    Note: Helper function to find Berlekamp null space
    Process called "find_berlekamp_null_space" that takes matrix as List[List[Integer]], prime as Integer returns List[List[Integer]]:
        Note: Find null space of (Q minus I) where Q is Berlekamp matrix
        Let augmented_matrix be subtract_identity_matrix(matrix, prime)
        Return solve_homogeneous_system_mod_p(augmented_matrix, prime)
    End Process
    
    Note: Helper function to split polynomial using null space vector
    Process called "split_polynomial_with_vector" that takes polynomial as List[Integer], vector as List[Integer], prime as Integer returns List[List[Integer]]:
        Let factors be List[List[Integer]]()
        
        Note: Compute gcd of polynomial with (vector(x)^i minus a) for different values of a
        Let a be 0
        While a is less than prime:
            Let vector_poly_power be raise_vector_to_power(vector, a, prime)
            Let gcd_poly be polynomial_gcd_mod_p(polynomial, vector_poly_power, prime)
            
            If gcd_poly.size is greater than 1 and not is_polynomial_constant(gcd_poly) and not polynomials_equal_mod_p(gcd_poly, polynomial, prime) Then:
                factors.add(gcd_poly)
                Let quotient be polynomial_divide_mod_p(polynomial, gcd_poly, prime)
                If quotient.size is greater than 0 Then:
                    factors.add(quotient)
                End If
                Return factors
            End If
            Set a to a plus 1
        End While
        
        Note: No split found
        Return List[polynomial]
    End Process