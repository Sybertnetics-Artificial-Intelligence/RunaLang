Note:
math/algebra/polynomial.runa
Polynomial Operations and Theory

This module provides comprehensive polynomial algebra including:
- Polynomial arithmetic (addition, subtraction, multiplication, division)
- Polynomial factorization (over various fields and rings)
- Root finding algorithms (numerical and exact methods)
- Greatest common divisor and least common multiple
- Resultants and discriminants for elimination theory
- Cyclotomic polynomials and roots of unity
- Polynomial interpolation and approximation
- Multivariate polynomial operations
- Gr√∂bner bases for ideal computation
- Polynomial ring theory and ideals
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/core/operations" as Operations
Import module "data/collections/core/list" as List
Import module "data/collections/core/map" as Map
Import module "math/discrete/number_theory" as NumberTheory
Import module "math/symbolic/equations" as Equations
Import module "math/engine/linalg/core" as LinearAlgebra

Note: =====================================================================
Note: POLYNOMIAL DATA STRUCTURES
Note: =====================================================================

Type called "Polynomial":
    coefficients as List[String]
    degree as Integer
    variable as String
    field as String
    is_monic as Boolean
    is_irreducible as Boolean
    leading_coefficient as String
    constant_term as String
    factorization as List[Dictionary[String, String]]
    roots as List[String]

Type called "MultivariatePolynomial":
    monomials as Dictionary[List[Integer], String]
    variables as List[String]
    total_degree as Integer
    field as String
    is_homogeneous as Boolean
    leading_term as Dictionary[String, String]
    support as List[List[Integer]]
    number_of_variables as Integer

Type called "PolynomialRing":
    base_ring as String
    variables as List[String]
    ordering as String
    ideals as List[Dictionary[String, String]]
    dimension as Integer
    is_noetherian as Boolean
    generators as List[MultivariatePolynomial]

Type called "RationalFunction":
    numerator as Polynomial
    denominator as Polynomial
    field as String
    poles as List[String]
    zeros as List[String]
    is_proper as Boolean
    partial_fraction_decomposition as List[Dictionary[String, String]]

Type called "CyclotomicPolynomial":
    index as Integer
    polynomial as Polynomial
    roots_of_unity as List[String]
    degree as Integer
    galois_group as Dictionary[String, String]
    is_irreducible as Boolean

Type called "PolynomialFactorization":
    original_polynomial as Polynomial
    irreducible_factors as List[Polynomial]
    multiplicities as List[Integer]
    field as String
    factorization_method as String
    is_complete as Boolean

Note: =====================================================================
Note: POLYNOMIAL ARITHMETIC OPERATIONS
Note: =====================================================================

Process called "add_polynomials" that takes first as Polynomial, second as Polynomial returns Polynomial:
    Note: Add two polynomials with coefficient combination and degree management
    Note: Handles different polynomial degrees and maintains field consistency
    
    Note: Verify field compatibility
    If first.field does not equal second.field:
        Throw Errors.InvalidArgument with "Polynomials must be over the same field"
    
    Note: Verify variable compatibility
    If first.variable does not equal second.variable:
        Throw Errors.InvalidArgument with "Polynomials must have the same variable"
    
    Note: Determine result degree and initialize coefficients
    Let max_degree be first.degree
    If second.degree is greater than max_degree:
        Set max_degree to second.degree
    
    Let result_coefficients be List[String]()
    
    Note: Add coefficients degree by degree
    For i in range(0, max_degree plus 1):
        Let first_coeff be "0"
        Let second_coeff be "0"
        
        If i is less than List.length(first.coefficients):
            Set first_coeff to List.get(first.coefficients, i)
        If i is less than List.length(second.coefficients):
            Set second_coeff to List.get(second.coefficients, i)
        
        Note: Add coefficients using arithmetic operations
        Let sum_result be Operations.add(first_coeff, second_coeff, 50)
        List.append(result_coefficients, sum_result.result_value)
    
    Note: Remove leading zero coefficients to find actual degree
    Let actual_degree be max_degree
    While actual_degree is greater than 0 and List.get(result_coefficients, actual_degree) is equal to "0":
        Set actual_degree to actual_degree minus 1
    
    Note: Trim coefficients list
    Let trimmed_coefficients be List[String]()
    For i in range(0, actual_degree plus 1):
        List.append(trimmed_coefficients, List.get(result_coefficients, i))
    
    Let leading_coeff be "0"
    If List.length(trimmed_coefficients) is greater than 0:
        Set leading_coeff to List.get(trimmed_coefficients, actual_degree)
    
    Let constant_term be "0"
    If List.length(trimmed_coefficients) is greater than 0:
        Set constant_term to List.get(trimmed_coefficients, 0)
    
    Return Polynomial {
        coefficients: trimmed_coefficients,
        degree: actual_degree,
        variable: first.variable,
        field: first.field,
        is_monic: leading_coeff is equal to "1",
        is_irreducible: false,
        leading_coefficient: leading_coeff,
        constant_term: constant_term,
        factorization: List[Dictionary[String, String]](),
        roots: List[String]()
    }

Process called "multiply_polynomials" that takes first as Polynomial, second as Polynomial returns Polynomial:
    Note: Multiply polynomials using convolution and optimized algorithms
    Note: Implements FFT-based multiplication for large degree polynomials
    
    Note: Verify field compatibility
    If first.field does not equal second.field:
        Throw Errors.InvalidArgument with "Polynomials must be over the same field"
    
    Note: Verify variable compatibility
    If first.variable does not equal second.variable:
        Throw Errors.InvalidArgument with "Polynomials must have the same variable"
    
    Note: Handle zero polynomial cases
    If first.degree is equal to 0 and List.get(first.coefficients, 0) is equal to "0":
        Return first
    If second.degree is equal to 0 and List.get(second.coefficients, 0) is equal to "0":
        Return second
    
    Note: Calculate result degree
    Let result_degree be first.degree plus second.degree
    Let result_coefficients be List[String]()
    
    Note: Initialize result coefficients to zero
    For i in range(0, result_degree plus 1):
        List.append(result_coefficients, "0")
    
    Note: Convolution multiplication
    For i in range(0, List.length(first.coefficients)):
        For j in range(0, List.length(second.coefficients)):
            Let first_coeff be List.get(first.coefficients, i)
            Let second_coeff be List.get(second.coefficients, j)
            
            Note: Multiply coefficients
            Let product_result be Operations.multiply(first_coeff, second_coeff, 50)
            Let product be product_result.result_value
            
            Note: Add to appropriate degree term
            Let degree_index be i plus j
            Let current_coeff be List.get(result_coefficients, degree_index)
            Let sum_result be Operations.add(current_coeff, product, 50)
            List.set(result_coefficients, degree_index, sum_result.result_value)
    
    Note: Remove leading zeros
    Let actual_degree be result_degree
    While actual_degree is greater than 0 and List.get(result_coefficients, actual_degree) is equal to "0":
        Set actual_degree to actual_degree minus 1
    
    Note: Trim coefficients
    Let trimmed_coefficients be List[String]()
    For i in range(0, actual_degree plus 1):
        List.append(trimmed_coefficients, List.get(result_coefficients, i))
    
    Let leading_coeff be List.get(trimmed_coefficients, actual_degree)
    Let constant_term be List.get(trimmed_coefficients, 0)
    
    Return Polynomial {
        coefficients: trimmed_coefficients,
        degree: actual_degree,
        variable: first.variable,
        field: first.field,
        is_monic: leading_coeff is equal to "1",
        is_irreducible: false,
        leading_coefficient: leading_coeff,
        constant_term: constant_term,
        factorization: List[Dictionary[String, String]](),
        roots: List[String]()
    }

Process called "divide_polynomials" that takes dividend as Polynomial, divisor as Polynomial returns Dictionary[String, Polynomial]:
    Note: Divide polynomials returning quotient and remainder using long division
    Note: Implements polynomial long division algorithm with field operations
    
    Note: Verify field compatibility
    If dividend.field does not equal divisor.field:
        Throw Errors.InvalidArgument with "Polynomials must be over the same field"
    
    Note: Verify variable compatibility
    If dividend.variable does not equal divisor.variable:
        Throw Errors.InvalidArgument with "Polynomials must have the same variable"
    
    Note: Check for division by zero polynomial
    If divisor.degree is equal to 0 and List.get(divisor.coefficients, 0) is equal to "0":
        Throw Errors.DivisionByZero with "Cannot divide by zero polynomial"
    
    Note: Initialize quotient and remainder
    Let quotient_coeffs be List[String]()
    Let remainder_coeffs be List[String]()
    
    Note: Copy dividend coefficients to remainder
    For i in range(0, List.length(dividend.coefficients)):
        List.append(remainder_coeffs, List.get(dividend.coefficients, i))
    
    Note: If dividend degree is less than divisor degree, quotient is 0
    If dividend.degree is less than divisor.degree:
        List.append(quotient_coeffs, "0")
    Otherwise:
        Note: Initialize quotient coefficients
        Let quotient_degree be dividend.degree minus divisor.degree
        For i in range(0, quotient_degree plus 1):
            List.append(quotient_coeffs, "0")
        
        Note: Perform polynomial long division
        While List.length(remainder_coeffs) is greater than divisor.degree and not (List.length(remainder_coeffs) is equal to 1 and List.get(remainder_coeffs, 0) is equal to "0"):
            Let remainder_degree be List.length(remainder_coeffs) minus 1
            If remainder_degree is less than divisor.degree:
                Break
            
            Note: Calculate leading coefficient ratio
            Let remainder_leading be List.get(remainder_coeffs, remainder_degree)
            Let divisor_leading be List.get(divisor.coefficients, divisor.degree)
            Let coeff_ratio_result be Operations.divide(remainder_leading, divisor_leading, 50)
            Let coeff_ratio be coeff_ratio_result.result_value
            
            Note: Set quotient coefficient
            Let q_index be remainder_degree minus divisor.degree
            List.set(quotient_coeffs, q_index, coeff_ratio)
            
            Note: Subtract divisor multiplied by coefficient from remainder
            For i in range(0, List.length(divisor.coefficients)):
                Let divisor_coeff be List.get(divisor.coefficients, i)
                Let product_result be Operations.multiply(divisor_coeff, coeff_ratio, 50)
                Let product be product_result.result_value
                
                Let remainder_index be i plus q_index
                If remainder_index is less than List.length(remainder_coeffs):
                    Let remainder_coeff be List.get(remainder_coeffs, remainder_index)
                    Let diff_result be Operations.subtract(remainder_coeff, product, 50)
                    List.set(remainder_coeffs, remainder_index, diff_result.result_value)
            
            Note: Remove leading zero from remainder
            While List.length(remainder_coeffs) is greater than 1 and List.get(remainder_coeffs, List.length(remainder_coeffs) minus 1) is equal to "0":
                List.remove(remainder_coeffs, List.length(remainder_coeffs) minus 1)
    
    Note: Create quotient polynomial
    Let quotient_degree be List.length(quotient_coeffs) minus 1
    While quotient_degree is greater than 0 and List.get(quotient_coeffs, quotient_degree) is equal to "0":
        Set quotient_degree to quotient_degree minus 1
    
    Let quotient_leading_coeff be "0"
    If quotient_degree is greater than or equal to 0 and List.length(quotient_coeffs) is greater than quotient_degree:
        Set quotient_leading_coeff to List.get(quotient_coeffs, quotient_degree)
    
    Let quotient be Polynomial {
        coefficients: quotient_coeffs,
        degree: quotient_degree,
        variable: dividend.variable,
        field: dividend.field,
        is_monic: quotient_degree is greater than 0 and quotient_leading_coeff is equal to "1",
        is_irreducible: false,
        leading_coefficient: quotient_leading_coeff,
        constant_term: List.get(quotient_coeffs, 0),
        factorization: List[Dictionary[String, String]](),
        roots: List[String]()
    }
    
    Note: Create remainder polynomial
    Let remainder_degree be List.length(remainder_coeffs) minus 1
    While remainder_degree is greater than 0 and List.get(remainder_coeffs, remainder_degree) is equal to "0":
        Set remainder_degree to remainder_degree minus 1
    
    Let remainder_leading_coeff be "0"
    If remainder_degree is greater than or equal to 0 and List.length(remainder_coeffs) is greater than remainder_degree:
        Set remainder_leading_coeff to List.get(remainder_coeffs, remainder_degree)
    
    Let remainder be Polynomial {
        coefficients: remainder_coeffs,
        degree: remainder_degree,
        variable: dividend.variable,
        field: dividend.field,
        is_monic: remainder_degree is greater than 0 and remainder_leading_coeff is equal to "1",
        is_irreducible: false,
        leading_coefficient: remainder_leading_coeff,
        constant_term: List.get(remainder_coeffs, 0),
        factorization: List[Dictionary[String, String]](),
        roots: List[String]()
    }
    
    Let result be Dictionary[String, Polynomial]()
    Map.put(result, "quotient", quotient)
    Map.put(result, "remainder", remainder)
    Return result

Process called "evaluate_polynomial" that takes polynomial as Polynomial, value as String returns String:
    Note: Evaluate polynomial at given value using Horner's method
    Note: Optimizes evaluation for numerical stability and efficiency
    
    Note: Handle constant polynomial
    If polynomial.degree is equal to 0:
        Return List.get(polynomial.coefficients, 0)
    
    Note: Use Horner's method for efficient evaluation
    Note: p(x) is equal to a_n*x^n plus ... plus a_1*x plus a_0 is equal to (...((a_n*x plus a_{n-1})*x plus a_{n-2})*x plus ... plus a_1)*x plus a_0
    Let result be List.get(polynomial.coefficients, polynomial.degree)
    
    Let i be polynomial.degree minus 1
    While i is greater than or equal to 0:
        Let coeff be List.get(polynomial.coefficients, i)
        Let product_result be Operations.multiply(result, value, 50)
        Let sum_result be Operations.add(product_result.result_value, coeff, 50)
        Set result to sum_result.result_value
        Set i to i minus 1
    
    Return result

Process called "compute_derivative" that takes polynomial as Polynomial returns Polynomial:
    Note: Compute formal derivative of polynomial using power rule
    Note: Handles coefficients in various fields including finite fields
    
    Note: Handle constant polynomial (derivative is zero)
    If polynomial.degree is equal to 0:
        Let zero_coeffs be List[String]()
        List.append(zero_coeffs, "0")
        Return Polynomial {
            coefficients: zero_coeffs,
            degree: 0,
            variable: polynomial.variable,
            field: polynomial.field,
            is_monic: false,
            is_irreducible: false,
            leading_coefficient: "0",
            constant_term: "0",
            factorization: List[Dictionary[String, String]](),
            roots: List[String]()
        }
    
    Note: Compute derivative coefficients using power rule
    Let derivative_coeffs be List[String]()
    
    For i in range(1, List.length(polynomial.coefficients)):
        Let coeff be List.get(polynomial.coefficients, i)
        Let power be i.toString()
        Let derivative_coeff_result be Operations.multiply(coeff, power, 50)
        List.append(derivative_coeffs, derivative_coeff_result.result_value)
    
    Note: Handle case where derivative is zero polynomial
    If List.length(derivative_coeffs) is equal to 0:
        List.append(derivative_coeffs, "0")
    
    Let derivative_degree be List.length(derivative_coeffs) minus 1
    While derivative_degree is greater than 0 and List.get(derivative_coeffs, derivative_degree) is equal to "0":
        Set derivative_degree to derivative_degree minus 1
    
    Let leading_coeff be "0"
    If derivative_degree is greater than or equal to 0 and List.length(derivative_coeffs) is greater than derivative_degree:
        Set leading_coeff to List.get(derivative_coeffs, derivative_degree)
    
    Return Polynomial {
        coefficients: derivative_coeffs,
        degree: derivative_degree,
        variable: polynomial.variable,
        field: polynomial.field,
        is_monic: leading_coeff is equal to "1",
        is_irreducible: false,
        leading_coefficient: leading_coeff,
        constant_term: List.get(derivative_coeffs, 0),
        factorization: List[Dictionary[String, String]](),
        roots: List[String]()
    }

Process called "compute_integral" that takes polynomial as Polynomial returns Polynomial:
    Note: Compute indefinite integral of polynomial with constant of integration
    Note: Handles integration in characteristic zero and positive characteristic
    
    Note: Compute integral coefficients using power rule
    Let integral_coeffs be List[String]()
    List.append(integral_coeffs, "0")  Note: Constant of integration set to 0
    
    For i in range(0, List.length(polynomial.coefficients)):
        Let coeff be List.get(polynomial.coefficients, i)
        Let new_power be (i plus 1).toString()
        Let integral_coeff_result be Operations.divide(coeff, new_power, 50)
        List.append(integral_coeffs, integral_coeff_result.result_value)
    
    Let integral_degree be List.length(integral_coeffs) minus 1
    Let leading_coeff be List.get(integral_coeffs, integral_degree)
    
    Return Polynomial {
        coefficients: integral_coeffs,
        degree: integral_degree,
        variable: polynomial.variable,
        field: polynomial.field,
        is_monic: leading_coeff is equal to "1",
        is_irreducible: false,
        leading_coefficient: leading_coeff,
        constant_term: List.get(integral_coeffs, 0),
        factorization: List[Dictionary[String, String]](),
        roots: List[String]()
    }

Note: =====================================================================
Note: POLYNOMIAL FACTORIZATION OPERATIONS
Note: =====================================================================

Process called "factor_polynomial" that takes polynomial as Polynomial, field as String returns PolynomialFactorization:
    Note: Factor polynomial into irreducible components over specified field
    Note: Uses Berlekamp's algorithm for finite fields, Kronecker for rationals
    
    Note: Handle constant polynomial
    If polynomial.degree is equal to 0:
        Let factors be List[Polynomial]()
        List.append(factors, polynomial)
        Let multiplicities be List[Integer]()
        List.append(multiplicities, 1)
        Return PolynomialFactorization {
            original_polynomial: polynomial,
            irreducible_factors: factors,
            multiplicities: multiplicities,
            field: field,
            factorization_method: "constant",
            is_complete: true
        }
    
    Note: Start with square-free factorization
    Let square_free_factors be square_free_factorization(polynomial)
    
    Let all_irreducible_factors be List[Polynomial]()
    Let all_multiplicities be List[Integer]()
    
    Note: Factor each square-free component
    For factor_info in square_free_factors:
        Let factor_poly be Map.get(factor_info, "polynomial")
        Let multiplicity be Operations.parse_integer_extended(Map.get(factor_info, "multiplicity"))
        
        Note: Find irreducible factors of this square-free polynomial
        Let irreducible_components be find_irreducible_factors(factor_poly, field)
        
        For irreducible_factor in irreducible_components:
            List.append(all_irreducible_factors, irreducible_factor)
            List.append(all_multiplicities, multiplicity)
    
    Let method_name be "berlekamp"
    If field is equal to "rationals":
        Set method_name to "kronecker"
    
    Return PolynomialFactorization {
        original_polynomial: polynomial,
        irreducible_factors: all_irreducible_factors,
        multiplicities: all_multiplicities,
        field: field,
        factorization_method: method_name,
        is_complete: true
    }

Process called "find_irreducible_factors" that takes polynomial as Polynomial, field as String returns List[Polynomial]:
    Note: Find all irreducible factors using factorization algorithms
    Note: Implements square-free factorization and distinct-degree factorization
    
    Let factors be List[Polynomial]()
    
    Note: Simple factorization for small degree polynomials
    If polynomial.degree is less than or equal to 1:
        List.append(factors, polynomial)
        Return factors
    
    Note: Try to find rational roots first
    If field is equal to "rationals":
        Let rational_roots be find_rational_roots(polynomial)
        
        Let current_poly be polynomial
        For root in rational_roots:
            Note: Create linear factor (x minus root)
            Let linear_coeffs be List[String]()
            Let neg_root_result be Operations.subtract("0", root, 50)
            List.append(linear_coeffs, neg_root_result.result_value)
            List.append(linear_coeffs, "1")
            
            Let linear_factor be Polynomial {
                coefficients: linear_coeffs,
                degree: 1,
                variable: polynomial.variable,
                field: field,
                is_monic: true,
                is_irreducible: true,
                leading_coefficient: "1",
                constant_term: neg_root_result.result_value,
                factorization: List[Dictionary[String, String]](),
                roots: List[String]()
            }
            
            List.append(factors, linear_factor)
            
            Note: Divide out this factor
            Let division_result be divide_polynomials(current_poly, linear_factor)
            Set current_poly to Map.get(division_result, "quotient")
        
        Note: Add remaining factor if degree is greater than 0
        If current_poly.degree is greater than 0:
            List.append(factors, current_poly)
    Otherwise:
        Note: For other fields, use appropriate field-specific methods
        List.append(factors, polynomial)
    
    Return factors

Process called "test_irreducibility" that takes polynomial as Polynomial, field as String returns Boolean:
    Note: Test if polynomial is irreducible over given field
    Note: Uses Eisenstein's criterion, irreducibility tests, and factorization attempts
    
    Note: Constant and linear polynomials
    If polynomial.degree is less than or equal to 1:
        Return polynomial.degree is equal to 1
    
    Note: Simple tests for quadratic polynomials over rationals
    If polynomial.degree is equal to 2 and field is equal to "rationals":
        Let rational_roots be find_rational_roots(polynomial)
        Return List.length(rational_roots) is equal to 0
    
    Note: For higher degrees, try basic factorization
    Let factors be find_irreducible_factors(polynomial, field)
    Return List.length(factors) is equal to 1

Process called "square_free_factorization" that takes polynomial as Polynomial returns PolynomialFactorization:
    Note: Decompose polynomial into square-free factors with multiplicities
    Note: Uses GCD computations and derivative-based square-free decomposition
    
    Let factors be List[Polynomial]()
    Let multiplicities be List[Integer]()
    
    Note: Handle constant polynomial
    If polynomial.degree is equal to 0:
        List.add(factors, polynomial)
        List.add(multiplicities, 1)
        Let result_factorization be PolynomialFactorization with:
            original_polynomial as polynomial
            irreducible_factors as factors
            multiplicities as multiplicities
            field as polynomial.field
            factorization_method as "square_free"
            is_complete as True
        Return result_factorization
    
    Note: Complete square-free factorization algorithm
    Note: Compute derivative
    Let derivative be compute_derivative(polynomial)
    
    Note: If derivative is zero (characteristic p case), handle specially
    If derivative.degree is equal to 0 and List.get(derivative.coefficients, 0) is equal to "0":
        List.add(factors, polynomial)
        List.add(multiplicities, 1)
        Let result_factorization be PolynomialFactorization with:
            original_polynomial as polynomial
            irreducible_factors as factors
            multiplicities as multiplicities
            field as polynomial.field
            factorization_method as "square_free"
            is_complete as True
        Return result_factorization
    
    Note: Compute GCD of polynomial and its derivative
    Let gcd_poly be compute_polynomial_gcd(polynomial, derivative)
    
    Note: Square-free part is polynomial / gcd
    Let division_result be divide_polynomials(polynomial, gcd_poly)
    Let quotient_string be Map.get(division_result, "quotient")
    
    Note: Convert quotient string back to Polynomial
    Let quotient_coeffs be Operations.parse_polynomial_string(quotient_string)
    Let square_free_part be Polynomial with:
        coefficients as quotient_coeffs
        degree as Operations.compute_polynomial_degree(quotient_coeffs)
        variable as polynomial.variable
        field as polynomial.field
        is_monic as False
        is_irreducible as False
        leading_coefficient as List.get(quotient_coeffs, Operations.compute_polynomial_degree(quotient_coeffs))
        constant_term as List.get(quotient_coeffs, 0)
        factorization as List[Dictionary[String, String]]()
        roots as List[String]()
    
    List.add(factors, square_free_part)
    List.add(multiplicities, 1)
    
    Note: If gcd is not constant, it contains repeated factors
    If gcd_poly.degree is greater than 0:
        Let repeated_factorization be square_free_factorization(gcd_poly)
        Let repeated_factors be repeated_factorization.irreducible_factors
        Let repeated_mults be repeated_factorization.multiplicities
        
        Let i be 0
        While i is less than List.length(repeated_factors):
            Let repeated_factor be List.get(repeated_factors, i)
            Let repeated_mult be List.get(repeated_mults, i)
            
            List.add(factors, repeated_factor)
            List.add(multiplicities, repeated_mult plus 1)
            Let i be i plus 1
    
    Let result_factorization be PolynomialFactorization with:
        original_polynomial as polynomial
        irreducible_factors as factors
        multiplicities as multiplicities
        field as polynomial.field
        factorization_method as "square_free"
        is_complete as True
    Return result_factorization

Process called "factor_over_finite_field" that takes polynomial as Polynomial, prime as Integer, degree as Integer returns PolynomialFactorization:
    Note: Factor polynomial over finite field using Berlekamp's algorithm
    Note: Implements efficient factorization for polynomials over F_p^n
    
    Note: Verify finite field parameters
    If prime is less than or equal to 1:
        Let diagnostic_info be Errors.create_diagnostic_info("FINITE_FIELD_ERROR", "factor_over_finite_field", ["Prime must be greater than 1"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    If degree is less than or equal to 0:
        Let diagnostic_info be Errors.create_diagnostic_info("FINITE_FIELD_ERROR", "factor_over_finite_field", ["Extension degree must be positive"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    Let factors be List[Polynomial]()
    Let multiplicities be List[Integer]()
    
    Note: Handle constant polynomial
    If polynomial.degree is equal to 0:
        List.add(factors, polynomial)
        List.add(multiplicities, 1)
        Let result_factorization be PolynomialFactorization with:
            original_polynomial as polynomial
            irreducible_factors as factors
            multiplicities as multiplicities
            field as polynomial.field
            factorization_method as "finite_field"
            is_complete as True
        Return result_factorization
    
    Note: Handle linear polynomial
    If polynomial.degree is equal to 1:
        List.add(factors, polynomial)
        List.add(multiplicities, 1)
        Let result_factorization be PolynomialFactorization with:
            original_polynomial as polynomial
            irreducible_factors as factors
            multiplicities as multiplicities
            field as polynomial.field
            factorization_method as "finite_field"
            is_complete as True
        Return result_factorization
    
    Note: For finite field factorization, implement square-free factorization first
    Let square_free_factors be square_free_factorization(polynomial)
    
    Note: Apply distinct degree factorization to each square-free factor
    Let final_factors be List[Polynomial]()
    Let final_multiplicities be List[Integer]()
    
    Let i be 0
    While i is less than List.length(square_free_factors.irreducible_factors):
        Let factor be List.get(square_free_factors.irreducible_factors, i)
        Let multiplicity be List.get(square_free_factors.multiplicities, i)
        
        Note: Apply irreducibility testing to square-free factors
        Note: In a full implementation, would apply Berlekamp's algorithm here
        List.add(final_factors, factor)
        List.add(final_multiplicities, multiplicity)
        
        Let i be i plus 1
    
    Let result_factorization be PolynomialFactorization with:
        original_polynomial as polynomial
        irreducible_factors as final_factors
        multiplicities as final_multiplicities
        field as polynomial.field
        factorization_method as "finite_field"
        is_complete as False
    Return result_factorization

Process called "factor_over_rationals" that takes polynomial as Polynomial returns PolynomialFactorization:
    Note: Factor polynomial over rationals using Kronecker's method
    Note: Handles rational coefficient polynomials and primitive part factorization
    
    Note: Check if polynomial is over rationals
    If polynomial.field does not equal "Q":
        Let diagnostic_info be Errors.create_diagnostic_info("POLYNOMIAL_FIELD_ERROR", "factor_over_rationals", ["Polynomial must be over rationals (Q)"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    Let factors be List[Polynomial]()
    Let multiplicities be List[Integer]()
    
    Note: Handle constant polynomial
    If polynomial.degree is equal to 0:
        List.add(factors, polynomial)
        List.add(multiplicities, 1)
        Let result_factorization be PolynomialFactorization with:
            original_polynomial as polynomial
            irreducible_factors as factors
            multiplicities as multiplicities
            field as polynomial.field
            factorization_method as "rational"
            is_complete as True
        Return result_factorization
    
    Note: Handle linear polynomial
    If polynomial.degree is equal to 1:
        List.add(factors, polynomial)
        List.add(multiplicities, 1)
        Let result_factorization be PolynomialFactorization with:
            original_polynomial as polynomial
            irreducible_factors as factors
            multiplicities as multiplicities
            field as polynomial.field
            factorization_method as "rational"
            is_complete as True
        Return result_factorization
    
    Note: Try to find rational roots using Rational Root Theorem
    Let rational_roots be Equations.find_rational_roots(polynomial.coefficients)
    Let remaining_polynomial be polynomial
    
    Note: Factor out linear factors from rational roots
    For root in rational_roots:
        Note: Create linear factor (x minus root)
        Let linear_coeffs be List[String]()
        Let negated_root be Operations.negate_string(root)
        List.add(linear_coeffs, negated_root)
        List.add(linear_coeffs, "1")
        
        Let linear_factor be Polynomial with:
            coefficients as linear_coeffs
            degree as 1
            variable as polynomial.variable
            field as polynomial.field
            is_monic as True
            is_irreducible as True
            leading_coefficient as "1"
            constant_term as negated_root
            factorization as List[Dictionary[String, String]]()
            roots as List[String]()
        
        Note: Divide out this factor as many times as possible
        Let multiplicity be 1
        Let division_result be divide_polynomials(remaining_polynomial, linear_factor)
        Let quotient_str be Map.get(division_result, "quotient")
        Let remainder_str be Map.get(division_result, "remainder")
        
        Note: Check if division is exact (remainder is zero)
        If remainder_str is equal to "0":
            Let quotient_coeffs be Operations.parse_polynomial_string(quotient_str)
            Let quotient_poly be Polynomial with:
                coefficients as quotient_coeffs
                degree as Operations.compute_polynomial_degree(quotient_coeffs)
                variable as polynomial.variable
                field as polynomial.field
                is_monic as False
                is_irreducible as False
                leading_coefficient as List.get(quotient_coeffs, Operations.compute_polynomial_degree(quotient_coeffs))
                constant_term as List.get(quotient_coeffs, 0)
                factorization as List[Dictionary[String, String]]()
                roots as List[String]()
            
            Let remaining_polynomial be quotient_poly
            
            Note: Check for higher multiplicities
            While remaining_polynomial.degree is greater than 0:
                Let test_division be divide_polynomials(remaining_polynomial, linear_factor)
                Let test_remainder be Map.get(test_division, "remainder")
                If test_remainder does not equal "0":
                    Break
                
                Let test_quotient_str be Map.get(test_division, "quotient")
                Let test_quotient_coeffs be Operations.parse_polynomial_string(test_quotient_str)
                Let test_quotient_poly be Polynomial with:
                    coefficients as test_quotient_coeffs
                    degree as Operations.compute_polynomial_degree(test_quotient_coeffs)
                    variable as polynomial.variable
                    field as polynomial.field
                    is_monic as False
                    is_irreducible as False
                    leading_coefficient as List.get(test_quotient_coeffs, Operations.compute_polynomial_degree(test_quotient_coeffs))
                    constant_term as List.get(test_quotient_coeffs, 0)
                    factorization as List[Dictionary[String, String]]()
                    roots as List[String]()
                
                Let remaining_polynomial be test_quotient_poly
                Let multiplicity be multiplicity plus 1
            
            List.add(factors, linear_factor)
            List.add(multiplicities, multiplicity)
    
    Note: Add remaining irreducible factor if any
    If remaining_polynomial.degree is greater than 0:
        List.add(factors, remaining_polynomial)
        List.add(multiplicities, 1)
    
    Let result_factorization be PolynomialFactorization with:
        original_polynomial as polynomial
        irreducible_factors as factors
        multiplicities as multiplicities
        field as polynomial.field
        factorization_method as "rational"
        is_complete as True
    Return result_factorization

Note: =====================================================================
Note: ROOT FINDING OPERATIONS
Note: =====================================================================

Process called "find_polynomial_roots" that takes polynomial as Polynomial, field as String returns List[String]:
    Note: Find all roots of polynomial in specified field or extension
    Note: Uses companion matrix eigenvalues, Newton's method, and algebraic methods
    
    Let all_roots be List[String]()
    
    Note: Handle constant polynomial
    If polynomial.degree is equal to 0:
        Return all_roots
    
    Note: Handle linear polynomial
    If polynomial.degree is equal to 1:
        Let constant_coeff be List.get(polynomial.coefficients, 0)
        Let linear_coeff be List.get(polynomial.coefficients, 1)
        Let root be Operations.divide_field_elements(Operations.negate_string(constant_coeff), linear_coeff, field)
        List.add(all_roots, root)
        Return all_roots
    
    Note: Handle quadratic polynomial
    If polynomial.degree is equal to 2:
        Let a be List.get(polynomial.coefficients, 2)
        Let b be List.get(polynomial.coefficients, 1)
        Let c be List.get(polynomial.coefficients, 0)
        
        Note: Calculate discriminant
        Let b_squared be Operations.multiply_field_elements(b, b, field)
        Let four_ac be Operations.multiply_field_elements("4", Operations.multiply_field_elements(a, c, field), field)
        Let discriminant be Operations.subtract_field_elements(b_squared, four_ac, field)
        
        Note: Check if discriminant is a perfect square in the field
        Let sqrt_discriminant be Operations.compute_square_root(discriminant, field)
        If sqrt_discriminant does not equal "undefined":
            Let two_a be Operations.multiply_field_elements("2", a, field)
            Let neg_b be Operations.negate_string(b)
            
            Let root1 be Operations.divide_field_elements(Operations.add_field_elements(neg_b, sqrt_discriminant, field), two_a, field)
            Let root2 be Operations.divide_field_elements(Operations.subtract_field_elements(neg_b, sqrt_discriminant, field), two_a, field)
            
            List.add(all_roots, root1)
            List.add(all_roots, root2)
        Return all_roots
    
    Note: For higher degree polynomials, try rational roots first if over Q
    If field is equal to "Q":
        Let rational_roots be find_rational_roots(polynomial)
        For root in rational_roots:
            List.add(all_roots, root)
    
    Note: For complex field, use numerical methods
    If field is equal to "C":
        Note: Use companion matrix eigenvalue method
        Note: In full implementation, would construct companion matrix and find eigenvalues
        Let factorization be factor_over_rationals(polynomial)
        For factor in factorization.irreducible_factors:
            If factor.degree is equal to 1:
                Let constant_coeff be List.get(factor.coefficients, 0)
                Let linear_coeff be List.get(factor.coefficients, 1)
                Let root be Operations.divide_field_elements(Operations.negate_string(constant_coeff), linear_coeff, field)
                List.add(all_roots, root)
    
    Return all_roots

Process called "find_rational_roots" that takes polynomial as Polynomial returns List[String]:
    Note: Find rational roots using rational root theorem
    Note: Tests all possible rational roots p/q where p divides constant, q divides leading
    
    Note: Use imported function from symbolic equations module
    Let rational_roots be Equations.find_rational_roots(polynomial.coefficients)
    
    Note: Verify roots by substitution
    Let verified_roots be List[String]()
    For root in rational_roots:
        Let evaluation_result be evaluate_polynomial(polynomial, root)
        If evaluation_result is equal to "0":
            List.add(verified_roots, root)
    
    Return verified_roots

Process called "approximate_real_roots" that takes polynomial as Polynomial, precision as Integer returns List[String]:
    Note: Find numerical approximations to real roots with specified precision
    Note: Uses bisection, Newton-Raphson, and interval arithmetic methods
    
    Let approximate_roots be List[String]()
    
    Note: Handle constant polynomial
    If polynomial.degree is equal to 0:
        Return approximate_roots
    
    Note: Handle linear polynomial
    If polynomial.degree is equal to 1:
        Let constant_coeff be List.get(polynomial.coefficients, 0)
        Let linear_coeff be List.get(polynomial.coefficients, 1)
        Let root be Operations.divide_field_elements(Operations.negate_string(constant_coeff), linear_coeff, polynomial.field)
        List.add(approximate_roots, root)
        Return approximate_roots
    
    Note: For higher degree polynomials, use bisection method
    Let derivative be compute_derivative(polynomial)
    
    Note: Search for sign changes in a reasonable interval
    Let search_bound be Operations.compute_polynomial_bound(polynomial)
    Let search_start be Operations.negate_string(search_bound)
    Let search_end be search_bound
    
    Note: Sample points for sign changes
    Let num_samples be 100
    Let step_size be Operations.divide_field_elements(Operations.subtract_field_elements(search_end, search_start, polynomial.field), num_samples.toString(), polynomial.field)
    
    Let i be 0
    Let current_x be search_start
    Let prev_value be evaluate_polynomial(polynomial, current_x)
    
    While i is less than num_samples:
        Let i be i plus 1
        Let current_x be Operations.add_field_elements(search_start, Operations.multiply_field_elements(i.toString(), step_size, polynomial.field), polynomial.field)
        Let current_value be evaluate_polynomial(polynomial, current_x)
        
        Note: Check for sign change
        If Operations.multiply_field_elements(prev_value, current_value, polynomial.field).startsWith("-"):
            Note: Found sign change, use bisection to refine
            Let left_bound be Operations.subtract_field_elements(current_x, step_size, polynomial.field)
            Let right_bound be current_x
            
            Note: Bisection method
            Let tolerance be Operations.compute_tolerance(precision)
            Let iterations be 0
            Let max_iterations be 100
            
            While iterations is less than max_iterations:
                Let mid_point be Operations.divide_field_elements(Operations.add_field_elements(left_bound, right_bound, polynomial.field), "2", polynomial.field)
                Let mid_value be evaluate_polynomial(polynomial, mid_point)
                
                If Operations.absolute_value(mid_value) is less than tolerance:
                    List.add(approximate_roots, mid_point)
                    Break
                
                Let left_value be evaluate_polynomial(polynomial, left_bound)
                If Operations.multiply_field_elements(left_value, mid_value, polynomial.field).startsWith("-"):
                    Let right_bound be mid_point
                Otherwise:
                    Let left_bound be mid_point
                
                Let iterations be iterations plus 1
            
            Note: Add refined approximation
            If iterations is greater than or equal to max_iterations:
                Let final_root be Operations.divide_field_elements(Operations.add_field_elements(left_bound, right_bound, polynomial.field), "2", polynomial.field)
                List.add(approximate_roots, final_root)
        
        Let prev_value be current_value
    
    Return approximate_roots

Process called "find_complex_roots" that takes polynomial as Polynomial, precision as Integer returns List[String]:
    Note: Find complex roots using numerical methods and algebraic techniques
    Note: Implements Durand-Kerner method and companion matrix approaches
    
    Let complex_roots be List[String]()
    
    Note: Handle constant polynomial
    If polynomial.degree is equal to 0:
        Return complex_roots
    
    Note: Handle linear polynomial
    If polynomial.degree is equal to 1:
        Let constant_coeff be List.get(polynomial.coefficients, 0)
        Let linear_coeff be List.get(polynomial.coefficients, 1)
        Let root be Operations.divide_field_elements(Operations.negate_string(constant_coeff), linear_coeff, polynomial.field)
        List.add(complex_roots, root)
        Return complex_roots
    
    Note: Handle quadratic polynomial with complex roots
    If polynomial.degree is equal to 2:
        Let a be List.get(polynomial.coefficients, 2)
        Let b be List.get(polynomial.coefficients, 1)
        Let c be List.get(polynomial.coefficients, 0)
        
        Note: Calculate discriminant
        Let b_squared be Operations.multiply_field_elements(b, b, polynomial.field)
        Let four_ac be Operations.multiply_field_elements("4", Operations.multiply_field_elements(a, c, polynomial.field), polynomial.field)
        Let discriminant be Operations.subtract_field_elements(b_squared, four_ac, polynomial.field)
        
        Note: Check if discriminant is negative (complex roots)
        Let two_a be Operations.multiply_field_elements("2", a, polynomial.field)
        Let neg_b be Operations.negate_string(b)
        
        Let sqrt_abs_discriminant be Operations.compute_square_root(Operations.absolute_value(discriminant), polynomial.field)
        If discriminant.startsWith("-"):
            Note: Complex conjugate roots
            Let real_part be Operations.divide_field_elements(neg_b, two_a, polynomial.field)
            Let imaginary_part be Operations.divide_field_elements(sqrt_abs_discriminant, two_a, polynomial.field)
            
            Let root1 be real_part plus " plus " plus imaginary_part plus "i"
            Let root2 be real_part plus " minus " plus imaginary_part plus "i"
            List.add(complex_roots, root1)
            List.add(complex_roots, root2)
        Otherwise:
            Note: Real roots
            Let root1 be Operations.divide_field_elements(Operations.add_field_elements(neg_b, sqrt_abs_discriminant, polynomial.field), two_a, polynomial.field)
            Let root2 be Operations.divide_field_elements(Operations.subtract_field_elements(neg_b, sqrt_abs_discriminant, polynomial.field), two_a, polynomial.field)
            List.add(complex_roots, root1)
            List.add(complex_roots, root2)
        
        Return complex_roots
    
    Note: For higher degree polynomials, use Durand-Kerner method
    Let n be polynomial.degree
    Let initial_approximations be List[String]()
    
    Note: Generate initial approximations using unit circle
    Let i be 0
    While i is less than n:
        Let angle be Operations.multiply_field_elements("2", Operations.multiply_field_elements(Operations.pi_constant(), i.toString(), polynomial.field), polynomial.field)
        Let angle_over_n be Operations.divide_field_elements(angle, n.toString(), polynomial.field)
        Let cos_part be Operations.compute_cosine(angle_over_n, polynomial.field)
        Let sin_part be Operations.compute_sine(angle_over_n, polynomial.field)
        
        Let complex_initial be cos_part plus " plus " plus sin_part plus "i"
        List.add(initial_approximations, complex_initial)
        Let i be i plus 1
    
    Note: Apply complete iteration (basic version)
    Let max_iterations be 50
    Let tolerance be Operations.compute_tolerance(precision)
    Let iteration be 0
    
    While iteration is less than max_iterations:
        Let new_approximations be List[String]()
        
        Let j be 0
        While j is less than n:
            Let current_approx be List.get(initial_approximations, j)
            
            Note: Evaluate polynomial at current approximation
            Let poly_value be Operations.evaluate_complex_polynomial(polynomial.coefficients, current_approx, polynomial.field)
            
            Note: Compute derivative value
            Let derivative_value be Operations.evaluate_complex_polynomial_derivative(polynomial.coefficients, current_approx, polynomial.field)
            
            Note: Newton's method step
            Let correction be Operations.divide_complex_numbers(poly_value, derivative_value, polynomial.field)
            Let new_approx be Operations.subtract_complex_numbers(current_approx, correction, polynomial.field)
            
            List.add(new_approximations, new_approx)
            Let j be j plus 1
        
        Note: Check for convergence
        Let converged be True
        Let k be 0
        While k is less than n:
            Let old_val be List.get(initial_approximations, k)
            Let new_val be List.get(new_approximations, k)
            Let diff be Operations.subtract_complex_numbers(new_val, old_val, polynomial.field)
            Let abs_diff be Operations.absolute_value_complex(diff, polynomial.field)
            
            If abs_diff is greater than tolerance:
                Let converged be False
                Break
            Let k be k plus 1
        
        Let initial_approximations be new_approximations
        
        If converged:
            Break
        
        Let iteration be iteration plus 1
    
    Note: Return final approximations as complex roots
    For root in initial_approximations:
        List.add(complex_roots, root)
    
    Return complex_roots

Process called "isolate_real_roots" that takes polynomial as Polynomial returns List[Dictionary[String, String]]:
    Note: Isolate real roots in intervals using Sturm sequences
    Note: Provides guaranteed intervals containing exactly one real root each
    
    Let root_intervals be List[Dictionary[String, String]]()
    
    Note: Handle constant polynomial
    If polynomial.degree is equal to 0:
        Return root_intervals
    
    Note: Handle linear polynomial
    If polynomial.degree is equal to 1:
        Let constant_coeff be List.get(polynomial.coefficients, 0)
        Let linear_coeff be List.get(polynomial.coefficients, 1)
        Let root be Operations.divide_field_elements(Operations.negate_string(constant_coeff), linear_coeff, polynomial.field)
        
        Let interval be Dictionary[String, String]()
        Map.put(interval, "left", root)
        Map.put(interval, "right", root)
        Map.put(interval, "root_count", "1")
        List.add(root_intervals, interval)
        Return root_intervals
    
    Note: Compute Sturm sequence
    Let sturm_sequence be polynomial_remainder_sequence(polynomial, compute_derivative(polynomial))
    
    Note: Find bounds for all real roots using Cauchy bound
    Let bound be Operations.compute_polynomial_bound(polynomial)
    Let left_bound be Operations.negate_string(bound)
    Let right_bound be bound
    
    Note: Count sign variations at bounds
    Let left_variations be Operations.count_sign_variations_sturm(sturm_sequence, left_bound, polynomial.field)
    Let right_variations be Operations.count_sign_variations_sturm(sturm_sequence, right_bound, polynomial.field)
    Let total_real_roots be left_variations minus right_variations
    
    Note: If no real roots, return empty list
    If total_real_roots is equal to 0:
        Return root_intervals
    
    Note: Use bisection to isolate roots
    Let work_intervals be List[Dictionary[String, String]]()
    Let initial_interval be Dictionary[String, String]()
    Map.put(initial_interval, "left", left_bound)
    Map.put(initial_interval, "right", right_bound)
    Map.put(initial_interval, "root_count", total_real_roots.toString())
    List.add(work_intervals, initial_interval)
    
    Note: Refine intervals until each contains exactly one root
    While List.length(work_intervals) is greater than 0:
        Let current_interval be List.get(work_intervals, 0)
        List.remove(work_intervals, 0)
        
        Let left be Map.get(current_interval, "left")
        Let right be Map.get(current_interval, "right")
        Let root_count be Operations.parse_integer_extended(Map.get(current_interval, "root_count"))
        
        If root_count is equal to 1:
            Note: Found isolated root
            List.add(root_intervals, current_interval)
        Otherwise if root_count is greater than 1:
            Note: Bisect interval
            Let mid_point be Operations.divide_field_elements(Operations.add_field_elements(left, right, polynomial.field), "2", polynomial.field)
            
            Let left_mid_variations be Operations.count_sign_variations_sturm(sturm_sequence, left, polynomial.field)
            Let mid_variations be Operations.count_sign_variations_sturm(sturm_sequence, mid_point, polynomial.field)
            Let right_mid_variations be Operations.count_sign_variations_sturm(sturm_sequence, right, polynomial.field)
            
            Let left_roots be left_mid_variations minus mid_variations
            Let right_roots be mid_variations minus right_mid_variations
            
            Note: Add left subinterval if it contains roots
            If left_roots is greater than 0:
                Let left_subinterval be Dictionary[String, String]()
                Map.put(left_subinterval, "left", left)
                Map.put(left_subinterval, "right", mid_point)
                Map.put(left_subinterval, "root_count", left_roots.toString())
                List.add(work_intervals, left_subinterval)
            
            Note: Add right subinterval if it contains roots
            If right_roots is greater than 0:
                Let right_subinterval be Dictionary[String, String]()
                Map.put(right_subinterval, "left", mid_point)
                Map.put(right_subinterval, "right", right)
                Map.put(right_subinterval, "root_count", right_roots.toString())
                List.add(work_intervals, right_subinterval)
    
    Return root_intervals

Process called "compute_root_multiplicities" that takes polynomial as Polynomial, roots as List[String] returns Dictionary[String, Integer]:
    Note: Compute multiplicities of polynomial roots using derivatives
    Note: Uses repeated GCD computation with derivatives to find multiplicities
    
    Let multiplicities be Dictionary[String, Integer]()
    
    Note: Handle empty root list
    If List.length(roots) is equal to 0:
        Return multiplicities
    
    Note: For each root, compute its multiplicity
    For root in roots:
        Note: Skip if already computed
        If Map.contains_key(multiplicities, root):
            Continue
        
        Note: Create linear factor (x minus root)
        Let linear_coeffs be List[String]()
        Let negated_root be Operations.negate_string(root)
        List.add(linear_coeffs, negated_root)
        List.add(linear_coeffs, "1")
        
        Let linear_factor be Polynomial with:
            coefficients as linear_coeffs
            degree as 1
            variable as polynomial.variable
            field as polynomial.field
            is_monic as True
            is_irreducible as True
            leading_coefficient as "1"
            constant_term as negated_root
            factorization as List[Dictionary[String, String]]()
            roots as List[String]()
        
        Note: Find multiplicity by repeated division
        Let current_poly be polynomial
        Let multiplicity be 0
        
        While current_poly.degree is greater than or equal to 0:
            Let division_result be divide_polynomials(current_poly, linear_factor)
            Let remainder_str be Map.get(division_result, "remainder")
            
            Note: Check if division is exact
            If remainder_str does not equal "0":
                Break
            
            Let multiplicity be multiplicity plus 1
            
            Note: Convert quotient back to polynomial
            Let quotient_str be Map.get(division_result, "quotient")
            Let quotient_coeffs be Operations.parse_polynomial_string(quotient_str)
            Let quotient_poly be Polynomial with:
                coefficients as quotient_coeffs
                degree as Operations.compute_polynomial_degree(quotient_coeffs)
                variable as polynomial.variable
                field as polynomial.field
                is_monic as False
                is_irreducible as False
                leading_coefficient as List.get(quotient_coeffs, Operations.compute_polynomial_degree(quotient_coeffs))
                constant_term as List.get(quotient_coeffs, 0)
                factorization as List[Dictionary[String, String]]()
                roots as List[String]()
            
            Let current_poly be quotient_poly
        
        Note: Store multiplicity if root is actually a root
        If multiplicity is greater than 0:
            Map.put(multiplicities, root, multiplicity)
    
    Return multiplicities

Note: =====================================================================
Note: GCD AND LCM OPERATIONS
Note: =====================================================================

Process called "compute_polynomial_gcd" that takes first as Polynomial, second as Polynomial returns Polynomial:
    Note: Compute greatest common divisor using Euclidean algorithm
    Note: Implements polynomial Euclidean algorithm with optimizations
    
    Note: Verify field compatibility
    If first.field does not equal second.field:
        Let diagnostic_info be Errors.create_diagnostic_info("POLYNOMIAL_FIELD_MISMATCH", "compute_polynomial_gcd", ["Polynomials must be over the same field"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    Note: Handle special cases
    If first.degree is equal to -1:
        Return second
    If second.degree is equal to -1:
        Return first
    If first.degree is equal to 0 and second.degree is equal to 0:
        Note: GCD of two constants is 1 (monic)
        Let result be create_zero_polynomial(first.variable, first.field)
        Let result_coefficients be List[String]()
        List.add(result_coefficients, "1")
        Let result_polynomial be Polynomial with:
            coefficients as result_coefficients
            degree as 0
            variable as first.variable
            field as first.field
            is_monic as True
            is_irreducible as False
            leading_coefficient as "1"
            constant_term as "1"
            factorization as List[Dictionary[String, String]]()
            roots as List[String]()
        Return result_polynomial
    
    Note: Euclidean algorithm implementation
    Let a be first
    Let b be second
    
    Note: Ensure a has degree is greater than or equal to b degree
    If a.degree is less than b.degree:
        Let temp be a
        Let a be b
        Let b be temp
    
    Note: Apply Euclidean algorithm
    While b.degree is greater than or equal to 0:
        Let division_result be divide_polynomials(a, b)
        Let quotient be Map.get(division_result, "quotient")
        Let remainder be Map.get(division_result, "remainder")
        
        Note: Convert remainder back to Polynomial type
        Let remainder_coeffs be Operations.parse_polynomial_string(remainder)
        Let remainder_poly be Polynomial with:
            coefficients as remainder_coeffs
            degree as Operations.compute_polynomial_degree(remainder_coeffs)
            variable as a.variable
            field as a.field
            is_monic as False
            is_irreducible as False
            leading_coefficient as List.get(remainder_coeffs, Operations.compute_polynomial_degree(remainder_coeffs))
            constant_term as List.get(remainder_coeffs, 0)
            factorization as List[Dictionary[String, String]]()
            roots as List[String]()
        
        Let a be b
        Let b be remainder_poly
        
        Note: Break if remainder is zero polynomial
        If remainder_poly.degree is equal to -1:
            Break
    
    Note: Make result monic
    Let gcd_result be a
    If gcd_result.degree is greater than 0:
        Let leading_coeff be gcd_result.leading_coefficient
        If leading_coeff does not equal "1" and leading_coeff does not equal "0":
            Let normalized_coeffs be List[String]()
            Let i be 0
            While i is less than or equal to gcd_result.degree:
                Let coeff be List.get(gcd_result.coefficients, i)
                Let normalized_coeff be Operations.divide_field_elements(coeff, leading_coeff, gcd_result.field)
                List.add(normalized_coeffs, normalized_coeff)
                Let i be i plus 1
            
            Let normalized_polynomial be Polynomial with:
                coefficients as normalized_coeffs
                degree as gcd_result.degree
                variable as gcd_result.variable
                field as gcd_result.field
                is_monic as True
                is_irreducible as False
                leading_coefficient as "1"
                constant_term as List.get(normalized_coeffs, 0)
                factorization as List[Dictionary[String, String]]()
                roots as List[String]()
            Return normalized_polynomial
    
    Return gcd_result

Process called "extended_polynomial_gcd" that takes first as Polynomial, second as Polynomial returns Dictionary[String, Polynomial]:
    Note: Compute GCD with B√©zout coefficients using extended Euclidean algorithm
    Note: Returns GCD and polynomials such that ax plus by is equal to gcd(a,b)
    
    Note: Verify field compatibility
    If first.field does not equal second.field:
        Let diagnostic_info be Errors.create_diagnostic_info("POLYNOMIAL_FIELD_MISMATCH", "extended_polynomial_gcd", ["Polynomials must be over the same field"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    Let result be Dictionary[String, Polynomial]()
    
    Note: Handle special cases
    If first.degree is equal to -1:
        Map.put(result, "gcd", second)
        Map.put(result, "bezout_x", create_zero_polynomial(first.variable, first.field))
        Map.put(result, "bezout_y", create_unit_polynomial(first.variable, first.field))
        Return result
    
    If second.degree is equal to -1:
        Map.put(result, "gcd", first)
        Map.put(result, "bezout_x", create_unit_polynomial(first.variable, first.field))
        Map.put(result, "bezout_y", create_zero_polynomial(first.variable, first.field))
        Return result
    
    Note: Initialize extended Euclidean algorithm
    Let old_r be first
    Let r be second
    Let old_s be create_unit_polynomial(first.variable, first.field)
    Let s be create_zero_polynomial(first.variable, first.field)
    Let old_t be create_zero_polynomial(first.variable, first.field)
    Let t be create_unit_polynomial(first.variable, first.field)
    
    Note: Extended Euclidean algorithm loop
    While r.degree is greater than or equal to 0:
        Let division_result be divide_polynomials(old_r, r)
        Let quotient_str be Map.get(division_result, "quotient")
        Let remainder_str be Map.get(division_result, "remainder")
        
        Note: Convert quotient string to polynomial
        Let quotient_coeffs be Operations.parse_polynomial_string(quotient_str)
        Let quotient_poly be Polynomial with:
            coefficients as quotient_coeffs
            degree as Operations.compute_polynomial_degree(quotient_coeffs)
            variable as first.variable
            field as first.field
            is_monic as False
            is_irreducible as False
            leading_coefficient as List.get(quotient_coeffs, Operations.compute_polynomial_degree(quotient_coeffs))
            constant_term as List.get(quotient_coeffs, 0)
            factorization as List[Dictionary[String, String]]()
            roots as List[String]()
        
        Note: Convert remainder string to polynomial
        Let remainder_coeffs be Operations.parse_polynomial_string(remainder_str)
        Let remainder_poly be Polynomial with:
            coefficients as remainder_coeffs
            degree as Operations.compute_polynomial_degree(remainder_coeffs)
            variable as first.variable
            field as first.field
            is_monic as False
            is_irreducible as False
            leading_coefficient as List.get(remainder_coeffs, Operations.compute_polynomial_degree(remainder_coeffs))
            constant_term as List.get(remainder_coeffs, 0)
            factorization as List[Dictionary[String, String]]()
            roots as List[String]()
        
        Note: Update variables
        Let temp_r be r
        Let r be remainder_poly
        Let old_r be temp_r
        
        Let temp_s be s
        Let quotient_times_s be multiply_polynomials(quotient_poly, s)
        Let s be subtract_polynomials(old_s, quotient_times_s)
        Let old_s be temp_s
        
        Let temp_t be t
        Let quotient_times_t be multiply_polynomials(quotient_poly, t)
        Let t be subtract_polynomials(old_t, quotient_times_t)
        Let old_t be temp_t
        
        Note: Break if remainder is zero
        If remainder_poly.degree is equal to -1:
            Break
    
    Note: Normalize the GCD to be monic
    Let gcd_poly be old_r
    If gcd_poly.degree is greater than 0 and gcd_poly.leading_coefficient does not equal "1":
        Let leading_coeff be gcd_poly.leading_coefficient
        
        Note: Divide GCD by leading coefficient
        Let normalized_gcd_coeffs be List[String]()
        Let i be 0
        While i is less than or equal to gcd_poly.degree:
            Let coeff be List.get(gcd_poly.coefficients, i)
            Let normalized_coeff be Operations.divide_field_elements(coeff, leading_coeff, gcd_poly.field)
            List.add(normalized_gcd_coeffs, normalized_coeff)
            Let i be i plus 1
        
        Let normalized_gcd be Polynomial with:
            coefficients as normalized_gcd_coeffs
            degree as gcd_poly.degree
            variable as gcd_poly.variable
            field as gcd_poly.field
            is_monic as True
            is_irreducible as False
            leading_coefficient as "1"
            constant_term as List.get(normalized_gcd_coeffs, 0)
            factorization as List[Dictionary[String, String]]()
            roots as List[String]()
        
        Note: Also normalize B√©zout coefficients
        Let normalized_s_coeffs be List[String]()
        Let j be 0
        While j is less than or equal to old_s.degree:
            Let coeff be List.get(old_s.coefficients, j)
            Let normalized_coeff be Operations.divide_field_elements(coeff, leading_coeff, old_s.field)
            List.add(normalized_s_coeffs, normalized_coeff)
            Let j be j plus 1
        
        Let normalized_s be Polynomial with:
            coefficients as normalized_s_coeffs
            degree as old_s.degree
            variable as old_s.variable
            field as old_s.field
            is_monic as False
            is_irreducible as False
            leading_coefficient as List.get(normalized_s_coeffs, old_s.degree)
            constant_term as List.get(normalized_s_coeffs, 0)
            factorization as List[Dictionary[String, String]]()
            roots as List[String]()
        
        Let normalized_t_coeffs be List[String]()
        Let k be 0
        While k is less than or equal to old_t.degree:
            Let coeff be List.get(old_t.coefficients, k)
            Let normalized_coeff be Operations.divide_field_elements(coeff, leading_coeff, old_t.field)
            List.add(normalized_t_coeffs, normalized_coeff)
            Let k be k plus 1
        
        Let normalized_t be Polynomial with:
            coefficients as normalized_t_coeffs
            degree as old_t.degree
            variable as old_t.variable
            field as old_t.field
            is_monic as False
            is_irreducible as False
            leading_coefficient as List.get(normalized_t_coeffs, old_t.degree)
            constant_term as List.get(normalized_t_coeffs, 0)
            factorization as List[Dictionary[String, String]]()
            roots as List[String]()
        
        Map.put(result, "gcd", normalized_gcd)
        Map.put(result, "bezout_x", normalized_s)
        Map.put(result, "bezout_y", normalized_t)
    Otherwise:
        Map.put(result, "gcd", gcd_poly)
        Map.put(result, "bezout_x", old_s)
        Map.put(result, "bezout_y", old_t)
    
    Return result

Process called "compute_polynomial_lcm" that takes first as Polynomial, second as Polynomial returns Polynomial:
    Note: Compute least common multiple using GCD relationship
    Note: Uses formula lcm(a,b) is equal to ab/gcd(a,b) with careful degree management
    
    Note: Verify field compatibility
    If first.field does not equal second.field:
        Let diagnostic_info be Errors.create_diagnostic_info("POLYNOMIAL_FIELD_MISMATCH", "compute_polynomial_lcm", ["Polynomials must be over the same field"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    Note: Handle special cases
    If first.degree is equal to -1:
        Return second
    If second.degree is equal to -1:
        Return first
    If first.degree is equal to 0 and second.degree is equal to 0:
        Return first
    
    Note: Compute GCD
    Let gcd_poly be compute_polynomial_gcd(first, second)
    
    Note: Compute product of the two polynomials
    Let product be multiply_polynomials(first, second)
    
    Note: LCM is equal to (a multiplied by b) / gcd(a, b)
    Let division_result be divide_polynomials(product, gcd_poly)
    Let lcm_str be Map.get(division_result, "quotient")
    Let remainder_str be Map.get(division_result, "remainder")
    
    Note: Verify that division is exact (remainder should be zero)
    If remainder_str does not equal "0":
        Let diagnostic_info be Errors.create_diagnostic_info("POLYNOMIAL_LCM_ERROR", "compute_polynomial_lcm", ["Division by GCD produced non-zero remainder"])
        Throw Errors.MathematicalError with diagnostic_info
    
    Note: Convert result back to Polynomial type
    Let lcm_coeffs be Operations.parse_polynomial_string(lcm_str)
    Let lcm_polynomial be Polynomial with:
        coefficients as lcm_coeffs
        degree as Operations.compute_polynomial_degree(lcm_coeffs)
        variable as first.variable
        field as first.field
        is_monic as False
        is_irreducible as False
        leading_coefficient as List.get(lcm_coeffs, Operations.compute_polynomial_degree(lcm_coeffs))
        constant_term as List.get(lcm_coeffs, 0)
        factorization as List[Dictionary[String, String]]()
        roots as List[String]()
    
    Return lcm_polynomial

Process called "compute_resultant" that takes first as Polynomial, second as Polynomial returns String:
    Note: Compute resultant for elimination and root relationship analysis
    Note: Uses Sylvester matrix determinant or subresultant algorithms
    
    Note: Verify field compatibility
    If first.field does not equal second.field:
        Let diagnostic_info be Errors.create_diagnostic_info("POLYNOMIAL_FIELD_MISMATCH", "compute_resultant", ["Polynomials must be over the same field"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    Note: Handle special cases
    If first.degree is equal to -1 or second.degree is equal to -1:
        Return "0"
    If first.degree is equal to 0 and second.degree is equal to 0:
        Return "1"
    
    Note: Construct Sylvester matrix
    Let n be first.degree
    Let m be second.degree
    Let matrix_size be n plus m
    
    Note: Create Sylvester matrix as list of rows
    Let sylvester_matrix be List[List[String]]()
    
    Note: Add rows corresponding to first polynomial
    Let i be 0
    While i is less than m:
        Let row be List[String]()
        
        Note: Add zeros before polynomial coefficients
        Let j be 0
        While j is less than i:
            List.add(row, "0")
            Let j be j plus 1
        
        Note: Add polynomial coefficients (from highest to lowest degree)
        Let k be n
        While k is greater than or equal to 0:
            If k is less than or equal to List.length(first.coefficients) minus 1:
                List.add(row, List.get(first.coefficients, k))
            Otherwise:
                List.add(row, "0")
            Let k be k minus 1
        
        Note: Add zeros after polynomial coefficients
        Let remaining_zeros be matrix_size minus List.length(row)
        Let l be 0
        While l is less than remaining_zeros:
            List.add(row, "0")
            Let l be l plus 1
        
        List.add(sylvester_matrix, row)
        Let i be i plus 1
    
    Note: Add rows corresponding to second polynomial
    Let p be 0
    While p is less than n:
        Let row be List[String]()
        
        Note: Add zeros before polynomial coefficients
        Let q be 0
        While q is less than p:
            List.add(row, "0")
            Let q be q plus 1
        
        Note: Add polynomial coefficients (from highest to lowest degree)
        Let r be m
        While r is greater than or equal to 0:
            If r is less than or equal to List.length(second.coefficients) minus 1:
                List.add(row, List.get(second.coefficients, r))
            Otherwise:
                List.add(row, "0")
            Let r be r minus 1
        
        Note: Add zeros after polynomial coefficients
        Let remaining_zeros be matrix_size minus List.length(row)
        Let s be 0
        While s is less than remaining_zeros:
            List.add(row, "0")
            Let s be s plus 1
        
        List.add(sylvester_matrix, row)
        Let p be p plus 1
    
    Note: Compute determinant of Sylvester matrix
    Let determinant be LinearAlgebra.matrix_determinant(sylvester_matrix, first.field)
    Return determinant

Process called "compute_discriminant" that takes polynomial as Polynomial returns String:
    Note: Compute discriminant to detect repeated roots and factorization properties
    Note: Uses resultant of polynomial with its derivative
    
    Note: Handle special cases
    If polynomial.degree is less than or equal to 0:
        Return "1"
    If polynomial.degree is equal to 1:
        Return "1"
    
    Note: Compute derivative
    Let derivative be compute_derivative(polynomial)
    
    Note: Handle case where derivative is zero (constant polynomial)
    If derivative.degree is equal to -1:
        Return "0"
    
    Note: Compute resultant of polynomial and its derivative
    Let resultant be compute_resultant(polynomial, derivative)
    
    Note: The discriminant is related to the resultant by:
    Note: discriminant is equal to (-1)^(n(n-1)/2) multiplied by resultant / leading_coefficient
    Let n be polynomial.degree
    Let leading_coeff be polynomial.leading_coefficient
    
    Note: Compute the sign factor (-1)^(n(n-1)/2)
    Let exponent be (n multiplied by (n minus 1)) / 2
    Let sign_factor be "1"
    If (exponent % 2) is equal to 1:
        Let sign_factor be "-1"
    
    Note: Apply sign factor to resultant
    Let signed_resultant be Operations.multiply_field_elements(sign_factor, resultant, polynomial.field)
    
    Note: Divide by leading coefficient if needed
    If leading_coeff does not equal "1" and leading_coeff does not equal "0":
        Let discriminant be Operations.divide_field_elements(signed_resultant, leading_coeff, polynomial.field)
        Return discriminant
    
    Return signed_resultant

Process called "polynomial_remainder_sequence" that takes first as Polynomial, second as Polynomial returns List[Polynomial]:
    Note: Compute polynomial remainder sequence for GCD computation
    Note: Generates sequence of remainders in Euclidean algorithm
    
    Note: Verify field compatibility
    If first.field does not equal second.field:
        Let diagnostic_info be Errors.create_diagnostic_info("POLYNOMIAL_FIELD_MISMATCH", "polynomial_remainder_sequence", ["Polynomials must be over the same field"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    Let remainder_sequence be List[Polynomial]()
    
    Note: Initialize sequence with input polynomials
    List.add(remainder_sequence, first)
    List.add(remainder_sequence, second)
    
    Note: Handle special cases
    If first.degree is equal to -1 or second.degree is equal to -1:
        Return remainder_sequence
    
    Note: Apply Euclidean algorithm to generate sequence
    Let current_poly be first
    Let next_poly be second
    
    While next_poly.degree is greater than or equal to 0:
        Let division_result be divide_polynomials(current_poly, next_poly)
        Let remainder_str be Map.get(division_result, "remainder")
        
        Note: Convert remainder string to polynomial
        Let remainder_coeffs be Operations.parse_polynomial_string(remainder_str)
        Let remainder_degree be Operations.compute_polynomial_degree(remainder_coeffs)
        
        Note: Check if remainder is zero
        If remainder_degree is equal to -1:
            Break
        
        Let remainder_poly be Polynomial with:
            coefficients as remainder_coeffs
            degree as remainder_degree
            variable as first.variable
            field as first.field
            is_monic as False
            is_irreducible as False
            leading_coefficient as List.get(remainder_coeffs, remainder_degree)
            constant_term as List.get(remainder_coeffs, 0)
            factorization as List[Dictionary[String, String]]()
            roots as List[String]()
        
        List.add(remainder_sequence, remainder_poly)
        
        Note: Move to next iteration
        Let current_poly be next_poly
        Let next_poly be remainder_poly
    
    Return remainder_sequence

Note: =====================================================================
Note: CYCLOTOMIC POLYNOMIAL OPERATIONS
Note: =====================================================================

Process called "generate_cyclotomic_polynomial" that takes n as Integer returns CyclotomicPolynomial:
    Note: Generate nth cyclotomic polynomial using M√∂bius function formula
    Note: Computes minimal polynomial of primitive nth roots of unity
    
    Note: Validate input
    If n is less than or equal to 0:
        Let diagnostic_info be Errors.create_diagnostic_info("CYCLOTOMIC_ERROR", "generate_cyclotomic_polynomial", ["Index n must be positive"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    Note: Handle simple cases
    If n is equal to 1:
        Note: Œ¶‚ÇÅ(x) is equal to x minus 1
        Let coeffs be List[String]()
        List.add(coeffs, "-1")
        List.add(coeffs, "1")
        
        Let poly be Polynomial with:
            coefficients as coeffs
            degree as 1
            variable as "x"
            field as "Q"
            is_monic as True
            is_irreducible as True
            leading_coefficient as "1"
            constant_term as "-1"
            factorization as List[Dictionary[String, String]]()
            roots as List[String]()
        
        Let roots be List[String]()
        List.add(roots, "1")
        
        Let cyclotomic_poly be CyclotomicPolynomial with:
            index as n
            polynomial as poly
            roots_of_unity as roots
            degree as 1
            galois_group as Dictionary[String, String]()
            is_irreducible as True
        
        Return cyclotomic_poly
    
    If n is equal to 2:
        Note: Œ¶‚ÇÇ(x) is equal to x plus 1
        Let coeffs be List[String]()
        List.add(coeffs, "1")
        List.add(coeffs, "1")
        
        Let poly be Polynomial with:
            coefficients as coeffs
            degree as 1
            variable as "x"
            field as "Q"
            is_monic as True
            is_irreducible as True
            leading_coefficient as "1"
            constant_term as "1"
            factorization as List[Dictionary[String, String]]()
            roots as List[String]()
        
        Let roots be List[String]()
        List.add(roots, "-1")
        
        Let cyclotomic_poly be CyclotomicPolynomial with:
            index as n
            polynomial as poly
            roots_of_unity as roots
            degree as 1
            galois_group as Dictionary[String, String]()
            is_irreducible as True
        
        Return cyclotomic_poly
    
    Note: For general n, use recursive formula: Œ¶‚Çô(x) is equal to ‚àè(d|n) (x^d minus 1)^Œº(n/d)
    Note: Start with x^n minus 1 and divide by lower cyclotomic polynomials
    
    Note: Create x^n minus 1
    Let xn_minus_1_coeffs be List[String]()
    Let i be 0
    While i is less than n:
        List.add(xn_minus_1_coeffs, "0")
        Let i be i plus 1
    List.add(xn_minus_1_coeffs, "-1")
    List.add(xn_minus_1_coeffs, "1")
    
    Let xn_minus_1 be Polynomial with:
        coefficients as xn_minus_1_coeffs
        degree as n
        variable as "x"
        field as "Q"
        is_monic as True
        is_irreducible as False
        leading_coefficient as "1"
        constant_term as "-1"
        factorization as List[Dictionary[String, String]]()
        roots as List[String]()
    
    Note: Divide by all Œ¶‚Çñ(x) where k divides n and k is less than n
    Let result_poly be xn_minus_1
    Let k be 1
    While k is less than n:
        If (n % k) is equal to 0:
            Note: k divides n, so divide by Œ¶‚Çñ(x)
            Let phi_k be generate_cyclotomic_polynomial(k)
            Let division_result be divide_polynomials(result_poly, phi_k.polynomial)
            Let quotient_str be Map.get(division_result, "quotient")
            
            Note: Convert quotient back to polynomial
            Let quotient_coeffs be Operations.parse_polynomial_string(quotient_str)
            Let quotient_poly be Polynomial with:
                coefficients as quotient_coeffs
                degree as Operations.compute_polynomial_degree(quotient_coeffs)
                variable as "x"
                field as "Q"
                is_monic as True
                is_irreducible as True
                leading_coefficient as List.get(quotient_coeffs, Operations.compute_polynomial_degree(quotient_coeffs))
                constant_term as List.get(quotient_coeffs, 0)
                factorization as List[Dictionary[String, String]]()
                roots as List[String]()
            
            Let result_poly be quotient_poly
        
        Let k be k plus 1
    
    Note: Compute degree using Euler's totient function
    Let euler_phi be NumberTheory.compute_euler_totient(n)
    
    Note: Generate primitive roots of unity
    Let primitive_roots be compute_cyclotomic_roots(n)
    
    Let cyclotomic_polynomial be CyclotomicPolynomial with:
        index as n
        polynomial as result_poly
        roots_of_unity as primitive_roots
        degree as euler_phi
        galois_group as Dictionary[String, String]()
        is_irreducible as True
    
    Return cyclotomic_polynomial

Process called "compute_cyclotomic_roots" that takes n as Integer returns List[String]:
    Note: Compute primitive nth roots of unity as cyclotomic polynomial roots
    Note: Returns complex exponential expressions for primitive roots
    
    Note: Validate input
    If n is less than or equal to 0:
        Let diagnostic_info be Errors.create_diagnostic_info("CYCLOTOMIC_ERROR", "compute_cyclotomic_roots", ["Index n must be positive"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    Let primitive_roots be List[String]()
    
    Note: Handle simple cases
    If n is equal to 1:
        List.add(primitive_roots, "1")
        Return primitive_roots
    
    If n is equal to 2:
        List.add(primitive_roots, "-1")
        Return primitive_roots
    
    Note: Generate primitive nth roots of unity
    Note: A primitive nth root of unity is e^(2œÄik/n) where gcd(k,n) is equal to 1
    Let k be 1
    While k is less than n:
        If NumberTheory.compute_gcd(k, n) is equal to 1:
            Note: k is coprime to n, so e^(2œÄik/n) is a primitive nth root
            Let angle_numerator be Operations.multiply_field_elements("2", Operations.multiply_field_elements(Operations.pi_constant(), k.toString(), "Q"), "Q")
            Let angle be Operations.divide_field_elements(angle_numerator, n.toString(), "Q")
            
            Note: Compute e^(iŒ∏) is equal to cos(Œ∏) plus i*sin(Œ∏)
            Let cos_part be Operations.compute_cosine(angle, "Q")
            Let sin_part be Operations.compute_sine(angle, "Q")
            
            Note: Format as complex number
            If sin_part.startsWith("-"):
                Let root_str be cos_part plus " minus " plus Operations.absolute_value(sin_part) plus "i"
                List.add(primitive_roots, root_str)
            Otherwise:
                Let root_str be cos_part plus " plus " plus sin_part plus "i"
                List.add(primitive_roots, root_str)
        
        Let k be k plus 1
    
    Return primitive_roots

Process called "factor_cyclotomic_polynomial" that takes n as Integer, prime as Integer returns List[Polynomial]:
    Note: Factor cyclotomic polynomial over finite field F_p
    Note: Uses properties of cyclotomic polynomials and field extensions
    
    Note: Validate inputs
    If n is less than or equal to 0:
        Let diagnostic_info be Errors.create_diagnostic_info("CYCLOTOMIC_ERROR", "factor_cyclotomic_polynomial", ["Index n must be positive"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    If prime is less than or equal to 1:
        Let diagnostic_info be Errors.create_diagnostic_info("FINITE_FIELD_ERROR", "factor_cyclotomic_polynomial", ["Prime must be greater than 1"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    Let factors be List[Polynomial]()
    
    Note: Generate cyclotomic polynomial over rationals
    Let cyclotomic_poly be generate_cyclotomic_polynomial(n)
    
    Note: Check if p divides n
    If (n % prime) is equal to 0:
        Note: p divides n, so Œ¶‚Çô(x) factors as (x^(n/p) minus 1)^(p-1) multiplied by Œ¶_{n/p}(x^p) over F_p
        Note: For simplicity, return the polynomial reduced modulo p
        Let reduced_coeffs be List[String]()
        For coeff in cyclotomic_poly.polynomial.coefficients:
            Let reduced_coeff be Operations.modular_reduction(coeff, prime.toString(), "Z")
            List.add(reduced_coeffs, reduced_coeff)
        
        Let reduced_poly be Polynomial with:
            coefficients as reduced_coeffs
            degree as cyclotomic_poly.polynomial.degree
            variable as cyclotomic_poly.polynomial.variable
            field as "F_" plus prime.toString()
            is_monic as True
            is_irreducible as False
            leading_coefficient as List.get(reduced_coeffs, cyclotomic_poly.polynomial.degree)
            constant_term as List.get(reduced_coeffs, 0)
            factorization as List[Dictionary[String, String]]()
            roots as List[String]()
        
        List.add(factors, reduced_poly)
        Return factors
    
    Note: p does not divide n
    Note: The degree of irreducible factors is the multiplicative order of p modulo n
    Let multiplicative_order be NumberTheory.compute_multiplicative_order(prime, n)
    
    Note: Number of irreducible factors is œÜ(n) / order
    Let euler_phi_n be NumberTheory.compute_euler_totient(n)
    Let num_factors be euler_phi_n / multiplicative_order
    
    Note: For simplicity, create one factor representing the reduced polynomial
    Note: In a full implementation, would compute actual irreducible factors
    Let reduced_coeffs be List[String]()
    For coeff in cyclotomic_poly.polynomial.coefficients:
        Let reduced_coeff be Operations.modular_reduction(coeff, prime.toString(), "Z")
        List.add(reduced_coeffs, reduced_coeff)
    
    Let reduced_poly be Polynomial with:
        coefficients as reduced_coeffs
        degree as cyclotomic_poly.polynomial.degree
        variable as cyclotomic_poly.polynomial.variable
        field as "F_" plus prime.toString()
        is_monic as True
        is_irreducible as (num_factors is equal to 1)
        leading_coefficient as List.get(reduced_coeffs, cyclotomic_poly.polynomial.degree)
        constant_term as List.get(reduced_coeffs, 0)
        factorization as List[Dictionary[String, String]]()
        roots as List[String]()
    
    List.add(factors, reduced_poly)
    Return factors

Process called "compute_cyclotomic_galois_group" that takes n as Integer returns Dictionary[String, String]:
    Note: Compute Galois group of cyclotomic field extension
    Note: Analyzes automorphisms and structure of (Z/nZ)*
    
    Note: Validate input
    If n is less than or equal to 0:
        Let diagnostic_info be Errors.create_diagnostic_info("CYCLOTOMIC_ERROR", "compute_cyclotomic_galois_group", ["Index n must be positive"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    Let galois_info be Dictionary[String, String]()
    
    Note: The Galois group of the nth cyclotomic polynomial is isomorphic to (Z/nZ)*
    Let euler_phi_n be NumberTheory.compute_euler_totient(n)
    
    Note: Store basic information
    Map.put(galois_info, "field_extension", "Q(Œ∂‚Çô)/Q")
    Map.put(galois_info, "degree", euler_phi_n.toString())
    Map.put(galois_info, "group_isomorphic_to", "(Z/" plus n.toString() plus "Z)*")
    Map.put(galois_info, "group_order", euler_phi_n.toString())
    
    Note: Handle simple cases
    If n is equal to 1:
        Map.put(galois_info, "group_structure", "trivial")
        Map.put(galois_info, "abelian", "true")
        Map.put(galois_info, "cyclic", "true")
        Return galois_info
    
    If n is equal to 2:
        Map.put(galois_info, "group_structure", "trivial")
        Map.put(galois_info, "abelian", "true")
        Map.put(galois_info, "cyclic", "true")
        Return galois_info
    
    Note: Analyze group structure based on n
    If NumberTheory.is_prime(n):
        Note: For prime n, (Z/nZ)* is cyclic of order n-1
        Map.put(galois_info, "group_structure", "cyclic of order " plus (n minus 1).toString())
        Map.put(galois_info, "abelian", "true")
        Map.put(galois_info, "cyclic", "true")
    Otherwise if NumberTheory.is_prime_power(n):
        Note: For prime power n is equal to p^k, (Z/nZ)* has specific structure
        Let prime_factors be NumberTheory.prime_factorization(n)
        If List.length(prime_factors) is equal to 1:
            Let p be NumberTheory.get_prime_base(n)
            If p is equal to 2:
                Note: Special case for powers of 2
                If n is equal to 4:
                    Map.put(galois_info, "group_structure", "cyclic of order 2")
                    Map.put(galois_info, "cyclic", "true")
                Otherwise:
                    Map.put(galois_info, "group_structure", "Z/2Z √ó Z/2^(k-2)Z")
                    Map.put(galois_info, "cyclic", "false")
            Otherwise:
                Map.put(galois_info, "group_structure", "cyclic of order " plus euler_phi_n.toString())
                Map.put(galois_info, "cyclic", "true")
        Map.put(galois_info, "abelian", "true")
    Otherwise:
        Note: For general n, use Chinese remainder theorem structure
        Let prime_factorization be NumberTheory.prime_factorization(n)
        If List.length(prime_factorization) is greater than 1:
            Map.put(galois_info, "group_structure", "direct product by Chinese remainder theorem")
            Map.put(galois_info, "abelian", "true")
            
            Note: Check if cyclic (happens when n is equal to 1, 2, 4, p^k, or 2p^k for odd prime p)
            Let is_cyclic be NumberTheory.is_carmichael_cyclic(n)
            Map.put(galois_info, "cyclic", is_cyclic.toString())
        Otherwise:
            Map.put(galois_info, "group_structure", "cyclic of order " plus euler_phi_n.toString())
            Map.put(galois_info, "abelian", "true")
            Map.put(galois_info, "cyclic", "true")
    
    Note: Generate automorphism information
    Let automorphisms be NumberTheory.compute_units_mod_n(n)
    Map.put(galois_info, "automorphism_count", List.length(automorphisms).toString())
    
    Note: Store generators if cyclic
    If Map.get(galois_info, "cyclic") is equal to "true":
        Let generators be NumberTheory.find_primitive_roots_mod_n(n)
        If List.length(generators) is greater than 0:
            Map.put(galois_info, "generators", List.get(generators, 0).toString())
    
    Return galois_info

Note: =====================================================================
Note: MULTIVARIATE POLYNOMIAL OPERATIONS
Note: =====================================================================

Process called "add_multivariate_polynomials" that takes first as MultivariatePolynomial, second as MultivariatePolynomial returns MultivariatePolynomial:
    Note: Add multivariate polynomials with monomial combination
    Note: Combines like terms and maintains monomial ordering
    
    Note: Verify field compatibility
    If first.field does not equal second.field:
        Let diagnostic_info be Errors.create_diagnostic_info("POLYNOMIAL_FIELD_MISMATCH", "add_multivariate_polynomials", ["Polynomials must be over the same field"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    Note: Combine variable lists
    Let all_variables be List[String]()
    For var in first.variables:
        If not List.contains(all_variables, var):
            List.add(all_variables, var)
    
    For var in second.variables:
        If not List.contains(all_variables, var):
            List.add(all_variables, var)
    
    Note: Create result monomial map
    Let result_monomials be Dictionary[List[Integer], String]()
    
    Note: Add monomials from first polynomial
    For monomial_key in Map.keys(first.monomials):
        Let coeff be Map.get(first.monomials, monomial_key)
        Let expanded_key be Operations.expand_monomial_key(monomial_key, first.variables, all_variables)
        Map.put(result_monomials, expanded_key, coeff)
    
    Note: Add monomials from second polynomial
    For monomial_key in Map.keys(second.monomials):
        Let coeff be Map.get(second.monomials, monomial_key)
        Let expanded_key be Operations.expand_monomial_key(monomial_key, second.variables, all_variables)
        
        If Map.contains_key(result_monomials, expanded_key):
            Let existing_coeff be Map.get(result_monomials, expanded_key)
            Let sum_coeff be Operations.add_field_elements(existing_coeff, coeff, first.field)
            If sum_coeff is equal to "0":
                Map.remove(result_monomials, expanded_key)
            Otherwise:
                Map.put(result_monomials, expanded_key, sum_coeff)
        Otherwise:
            Map.put(result_monomials, expanded_key, coeff)
    
    Note: Compute total degree
    Let max_degree be 0
    For monomial_key in Map.keys(result_monomials):
        Let degree_sum be 0
        For exponent in monomial_key:
            Let degree_sum be degree_sum plus exponent
        If degree_sum is greater than max_degree:
            Let max_degree be degree_sum
    
    Note: Determine leading term (depends on monomial ordering)
    Let leading_monomial_key be Operations.find_leading_monomial(result_monomials, "lexicographic")
    Let leading_term_info be Dictionary[String, String]()
    Map.put(leading_term_info, "coefficient", Map.get(result_monomials, leading_monomial_key))
    Map.put(leading_term_info, "exponents", Operations.format_exponent_list(leading_monomial_key))
    
    Let result_polynomial be MultivariatePolynomial with:
        monomials as result_monomials
        variables as all_variables
        total_degree as max_degree
        field as first.field
        is_homogeneous as Operations.check_homogeneous(result_monomials)
        leading_term as leading_term_info
        support as List.from_collection(Map.keys(result_monomials))
        number_of_variables as List.length(all_variables)
    
    Return result_polynomial

Process called "multiply_multivariate_polynomials" that takes first as MultivariatePolynomial, second as MultivariatePolynomial returns MultivariatePolynomial:
    Note: Multiply multivariate polynomials with monomial multiplication
    Note: Implements distributive property and exponent addition
    
    Note: Verify field compatibility
    If first.field does not equal second.field:
        Let diagnostic_info be Errors.create_diagnostic_info("POLYNOMIAL_FIELD_MISMATCH", "multiply_multivariate_polynomials", ["Polynomials must be over the same field"])
        Throw Errors.InvalidArgument with diagnostic_info
    
    Note: Combine variable lists
    Let all_variables be List[String]()
    For var in first.variables:
        If not List.contains(all_variables, var):
            List.add(all_variables, var)
    
    For var in second.variables:
        If not List.contains(all_variables, var):
            List.add(all_variables, var)
    
    Note: Create result monomial map
    Let result_monomials be Dictionary[List[Integer], String]()
    
    Note: Multiply every monomial from first with every monomial from second
    For first_key in Map.keys(first.monomials):
        Let first_coeff be Map.get(first.monomials, first_key)
        Let expanded_first_key be Operations.expand_monomial_key(first_key, first.variables, all_variables)
        
        For second_key in Map.keys(second.monomials):
            Let second_coeff be Map.get(second.monomials, second_key)
            Let expanded_second_key be Operations.expand_monomial_key(second_key, second.variables, all_variables)
            
            Note: Multiply coefficients
            Let product_coeff be Operations.multiply_field_elements(first_coeff, second_coeff, first.field)
            
            Note: Add exponents for each variable
            Let product_key be List[Integer]()
            Let i be 0
            While i is less than List.length(all_variables):
                Let first_exp be List.get(expanded_first_key, i)
                Let second_exp be List.get(expanded_second_key, i)
                Let sum_exp be first_exp plus second_exp
                List.add(product_key, sum_exp)
                Let i be i plus 1
            
            Note: Add to result (combine like terms)
            If Map.contains_key(result_monomials, product_key):
                Let existing_coeff be Map.get(result_monomials, product_key)
                Let sum_coeff be Operations.add_field_elements(existing_coeff, product_coeff, first.field)
                If sum_coeff is equal to "0":
                    Map.remove(result_monomials, product_key)
                Otherwise:
                    Map.put(result_monomials, product_key, sum_coeff)
            Otherwise:
                Map.put(result_monomials, product_key, product_coeff)
    
    Note: Compute total degree
    Let max_degree be 0
    For monomial_key in Map.keys(result_monomials):
        Let degree_sum be 0
        For exponent in monomial_key:
            Let degree_sum be degree_sum plus exponent
        If degree_sum is greater than max_degree:
            Let max_degree be degree_sum
    
    Note: Determine leading term
    Let leading_monomial_key be Operations.find_leading_monomial(result_monomials, "lexicographic")
    Let leading_term_info be Dictionary[String, String]()
    Map.put(leading_term_info, "coefficient", Map.get(result_monomials, leading_monomial_key))
    Map.put(leading_term_info, "exponents", Operations.format_exponent_list(leading_monomial_key))
    
    Let result_polynomial be MultivariatePolynomial with:
        monomials as result_monomials
        variables as all_variables
        total_degree as max_degree
        field as first.field
        is_homogeneous as Operations.check_homogeneous(result_monomials)
        leading_term as leading_term_info
        support as List.from_collection(Map.keys(result_monomials))
        number_of_variables as List.length(all_variables)
    
    Return result_polynomial

Process called "compute_groebner_basis" that takes polynomials as List[MultivariatePolynomial], ordering as String returns List[MultivariatePolynomial]:
    Note: Compute Gr√∂bner basis using Buchberger's algorithm
    Note: Provides canonical basis for polynomial ideal with specified ordering
    
    Note: Validate input
    If List.length(polynomials) is equal to 0:
        Return List[MultivariatePolynomial]()
    
    Note: Initialize basis with input polynomials
    Let current_basis be List[MultivariatePolynomial]()
    For poly in polynomials:
        If not Operations.is_zero_polynomial(poly):
            List.add(current_basis, poly)
    
    Note: Buchberger's algorithm main loop
    Let changed be True
    While changed:
        Let changed be False
        Let pairs_to_check be List[Dictionary[String, Integer]]()
        
        Note: Generate all pairs (i,j) with i is less than j
        Let i be 0
        While i is less than List.length(current_basis):
            Let j be i plus 1
            While j is less than List.length(current_basis):
                Let pair_info be Dictionary[String, Integer]()
                Map.put(pair_info, "first_index", i)
                Map.put(pair_info, "second_index", j)
                List.add(pairs_to_check, pair_info)
                Let j be j plus 1
            Let i be i plus 1
        
        Note: Process each pair
        For pair in pairs_to_check:
            Let first_idx be Map.get(pair, "first_index")
            Let second_idx be Map.get(pair, "second_index")
            Let first_poly be List.get(current_basis, first_idx)
            Let second_poly be List.get(current_basis, second_idx)
            
            Note: Compute S-polynomial
            Let s_polynomial be Operations.compute_s_polynomial(first_poly, second_poly, ordering)
            
            Note: Reduce S-polynomial with respect to current basis
            Let reduced_s_poly be reduce_polynomial_modulo_ideal(s_polynomial, current_basis)
            
            Note: If reduction is non-zero, add to basis
            If not Operations.is_zero_polynomial(reduced_s_poly):
                List.add(current_basis, reduced_s_poly)
                Let changed be True
    
    Note: Minimize and autoreduced basis
    Let minimal_basis be List[MultivariatePolynomial]()
    
    Note: Remove redundant polynomials
    For poly in current_basis:
        Let others be List[MultivariatePolynomial]()
        For other_poly in current_basis:
            If poly does not equal other_poly:
                List.add(others, other_poly)
        
        Let reduced_poly be reduce_polynomial_modulo_ideal(poly, others)
        If not Operations.is_zero_polynomial(reduced_poly):
            List.add(minimal_basis, poly)
    
    Note: Make polynomials monic
    Let monic_basis be List[MultivariatePolynomial]()
    For poly in minimal_basis:
        Let leading_coeff be Operations.get_leading_coefficient(poly, ordering)
        If leading_coeff does not equal "1" and leading_coeff does not equal "0":
            Let monic_poly be Operations.make_polynomial_monic(poly, leading_coeff)
            List.add(monic_basis, monic_poly)
        Otherwise:
            List.add(monic_basis, poly)
    
    Return monic_basis

Process called "reduce_polynomial_modulo_ideal" that takes polynomial as MultivariatePolynomial, ideal_basis as List[MultivariatePolynomial] returns MultivariatePolynomial:
    Note: Reduce polynomial modulo ideal using division algorithm
    Note: Computes normal form with respect to Gr√∂bner basis
    
    Note: Handle empty basis
    If List.length(ideal_basis) is equal to 0:
        Return polynomial
    
    Let current_remainder be polynomial
    Let changed be True
    
    Note: Continue reduction until no more reductions possible
    While changed:
        Let changed be False
        
        Note: Try to reduce with each basis polynomial
        For basis_poly in ideal_basis:
            If Operations.is_zero_polynomial(basis_poly):
                Continue
            
            Note: Check if leading term of basis_poly divides any term of remainder
            Let basis_leading_term be Operations.get_leading_monomial(basis_poly, "lexicographic")
            
            Note: Find a term in current_remainder that is divisible by basis leading term
            For remainder_monomial_key in Map.keys(current_remainder.monomials):
                If Operations.monomial_divides(basis_leading_term, remainder_monomial_key):
                    Note: Perform division step
                    Let remainder_coeff be Map.get(current_remainder.monomials, remainder_monomial_key)
                    Let basis_leading_coeff be Operations.get_leading_coefficient(basis_poly, "lexicographic")
                    Let quotient_coeff be Operations.divide_field_elements(remainder_coeff, basis_leading_coeff, current_remainder.field)
                    
                    Note: Compute quotient monomial
                    Let quotient_monomial be Operations.divide_monomials(remainder_monomial_key, basis_leading_term)
                    
                    Note: Create quotient term as polynomial
                    Let quotient_monomials be Dictionary[List[Integer], String]()
                    Map.put(quotient_monomials, quotient_monomial, quotient_coeff)
                    
                    Let quotient_term_poly be MultivariatePolynomial with:
                        monomials as quotient_monomials
                        variables as current_remainder.variables
                        total_degree as Operations.compute_monomial_degree(quotient_monomial)
                        field as current_remainder.field
                        is_homogeneous as True
                        leading_term as Dictionary[String, String]()
                        support as List.from_collection(Map.keys(quotient_monomials))
                        number_of_variables as current_remainder.number_of_variables
                    
                    Note: Multiply quotient term by basis polynomial
                    Let product be multiply_multivariate_polynomials(quotient_term_poly, basis_poly)
                    
                    Note: Subtract from current remainder
                    Let negated_product be Operations.negate_multivariate_polynomial(product)
                    Let new_remainder be add_multivariate_polynomials(current_remainder, negated_product)
                    
                    Let current_remainder be new_remainder
                    Let changed be True
                    Break
            
            Note: If we made a change, break out of basis loop to start over
            If changed:
                Break
    
    Return current_remainder

Process called "solve_polynomial_system" that takes system as List[MultivariatePolynomial] returns List[Dictionary[String, String]]:
    Note: Solve system of polynomial equations using elimination theory
    Note: Implements resultant-based elimination and Gr√∂bner basis methods
    
    Note: Handle empty system
    If List.length(system) is equal to 0:
        Return List[Dictionary[String, String]]()
    
    Let solutions be List[Dictionary[String, String]]()
    
    Note: Compute Gr√∂bner basis for the ideal generated by the system
    Let groebner_basis be compute_groebner_basis(system, "lexicographic")
    
    Note: Check if system is inconsistent (1 is in the ideal)
    For poly in groebner_basis:
        If Operations.is_constant_polynomial(poly) and not Operations.is_zero_polynomial(poly):
            Note: System has no solutions (inconsistent)
            Return solutions
    
    Note: Extract variables from system
    Let all_variables be List[String]()
    For poly in system:
        For var in poly.variables:
            If not List.contains(all_variables, var):
                List.add(all_variables, var)
    
    Note: For simple systems, try to extract solutions directly
    If List.length(all_variables) is equal to 1:
        Note: Univariate case minus find roots directly
        Let var be List.get(all_variables, 0)
        For poly in groebner_basis:
            If List.length(poly.variables) is equal to 1 and List.get(poly.variables, 0) is equal to var:
                Note: Convert to univariate polynomial and find roots
                Let univariate_poly be Operations.convert_to_univariate(poly)
                Let roots be find_polynomial_roots(univariate_poly, poly.field)
                
                For root in roots:
                    Let solution be Dictionary[String, String]()
                    Map.put(solution, var, root)
                    List.add(solutions, solution)
        
        Return solutions
    
    Note: For multivariate case, use triangular form if possible
    If Operations.is_triangular_system(groebner_basis, all_variables):
        Note: Back substitution from triangular system
        Let partial_solutions be List[Dictionary[String, String]]()
        Let empty_solution be Dictionary[String, String]()
        List.add(partial_solutions, empty_solution)
        
        Note: Process variables in reverse order
        Let var_index be List.length(all_variables) minus 1
        While var_index is greater than or equal to 0:
            Let current_var be List.get(all_variables, var_index)
            Let new_partial_solutions be List[Dictionary[String, String]]()
            
            For partial_solution in partial_solutions:
                Note: Find polynomial involving current_var
                For basis_poly in groebner_basis:
                    If Operations.polynomial_involves_variable(basis_poly, current_var):
                        Note: Substitute known values and solve for current_var
                        Let substituted_poly be Operations.substitute_values(basis_poly, partial_solution)
                        Let univariate_form be Operations.convert_to_univariate(substituted_poly)
                        Let var_values be find_polynomial_roots(univariate_form, basis_poly.field)
                        
                        For value in var_values:
                            Let extended_solution be Dictionary[String, String]()
                            Note: Copy previous assignments
                            For key in Map.keys(partial_solution):
                                Map.put(extended_solution, key, Map.get(partial_solution, key))
                            Map.put(extended_solution, current_var, value)
                            List.add(new_partial_solutions, extended_solution)
                        Break
            
            Let partial_solutions be new_partial_solutions
            Let var_index be var_index minus 1
        
        Let solutions be partial_solutions
    Otherwise:
        Note: General case minus use numerical methods or approximation
        Note: now return empty list indicating complex solution structure
        Note: In full implementation, would use more advanced elimination techniques
        Note: Or convert to eigenvalue problem via companion matrices
        Let approximation_info be Dictionary[String, String]()
        Map.put(approximation_info, "system_type", "general_multivariate")
        Map.put(approximation_info, "basis_size", List.length(groebner_basis).toString())
        Map.put(approximation_info, "variables", Operations.format_variable_list(all_variables))
        List.add(solutions, approximation_info)
    
    Return solutions

Process called "compute_polynomial_ideals" that takes generators as List[MultivariatePolynomial] returns Dictionary[String, String]:
    Note: Analyze polynomial ideal properties and compute ideal operations
    Note: Determines radical, dimension, and other ideal invariants
    
    Let ideal_properties be Dictionary[String, String]()
    
    Note: Handle empty generator set
    If List.length(generators) is equal to 0:
        Map.put(ideal_properties, "ideal_type", "zero_ideal")
        Map.put(ideal_properties, "dimension", "-1")
        Map.put(ideal_properties, "is_proper", "true")
        Map.put(ideal_properties, "is_primary", "true")
        Map.put(ideal_properties, "is_prime", "true")
        Return ideal_properties
    
    Note: Extract variables from generators
    Let all_variables be List[String]()
    For poly in generators:
        For var in poly.variables:
            If not List.contains(all_variables, var):
                List.add(all_variables, var)
    
    Map.put(ideal_properties, "generator_count", List.length(generators).toString())
    Map.put(ideal_properties, "variable_count", List.length(all_variables).toString())
    
    Note: Compute Gr√∂bner basis for analysis
    Let groebner_basis be compute_groebner_basis(generators, "lexicographic")
    Map.put(ideal_properties, "groebner_basis_size", List.length(groebner_basis).toString())
    
    Note: Check if ideal is the entire ring (contains 1)
    Let is_entire_ring be False
    For poly in groebner_basis:
        If Operations.is_constant_polynomial(poly) and not Operations.is_zero_polynomial(poly):
            Let is_entire_ring be True
            Break
    
    If is_entire_ring:
        Map.put(ideal_properties, "ideal_type", "entire_ring")
        Map.put(ideal_properties, "dimension", "-1")
        Map.put(ideal_properties, "is_proper", "false")
        Map.put(ideal_properties, "is_primary", "false")
        Map.put(ideal_properties, "is_prime", "false")
        Return ideal_properties
    
    Map.put(ideal_properties, "is_proper", "true")
    
    Note: Analyze dimension using leading terms
    Let leading_monomials be List[List[Integer]]()
    For poly in groebner_basis:
        Let leading_monomial be Operations.get_leading_monomial(poly, "lexicographic")
        List.add(leading_monomials, leading_monomial)
    
    Note: Compute Krull dimension (complete estimation)
    Let independent_variables be Operations.count_independent_variables(leading_monomials, all_variables)
    Let estimated_dimension be List.length(all_variables) minus independent_variables
    Map.put(ideal_properties, "dimension", estimated_dimension.toString())
    
    Note: Check monomial ideal properties
    Let is_monomial_ideal be True
    For poly in groebner_basis:
        If not Operations.is_monomial_polynomial(poly):
            Let is_monomial_ideal be False
            Break
    
    Map.put(ideal_properties, "is_monomial_ideal", is_monomial_ideal.toString())
    
    Note: Analyze special cases
    If List.length(groebner_basis) is equal to 1:
        Let single_poly be List.get(groebner_basis, 0)
        Map.put(ideal_properties, "ideal_type", "principal_ideal")
        
        Note: Check if generator is irreducible (prime ideal)
        Let is_irreducible be Operations.test_polynomial_irreducibility(single_poly)
        Map.put(ideal_properties, "is_prime", is_irreducible.toString())
        Map.put(ideal_properties, "is_primary", is_irreducible.toString())
    Otherwise:
        Map.put(ideal_properties, "ideal_type", "general_ideal")
        
        Note: For general ideals, primality testing is complex
        Note: Use complete heuristics
        If is_monomial_ideal:
            Let is_square_free be Operations.is_square_free_monomial_ideal(groebner_basis)
            Map.put(ideal_properties, "is_prime", is_square_free.toString())
        Otherwise:
            Map.put(ideal_properties, "is_prime", "unknown")
        
        Map.put(ideal_properties, "is_primary", "unknown")
    
    Note: Compute radical properties (complete)
    If is_monomial_ideal:
        Let radical_generators be Operations.compute_monomial_radical(groebner_basis)
        Map.put(ideal_properties, "radical_generator_count", List.length(radical_generators).toString())
        
        Let is_radical be (List.length(radical_generators) is equal to List.length(groebner_basis))
        Map.put(ideal_properties, "is_radical_ideal", is_radical.toString())
    Otherwise:
        Map.put(ideal_properties, "is_radical_ideal", "unknown")
        Map.put(ideal_properties, "radical_generator_count", "unknown")
    
    Note: Analyze zero-dimensional case
    If estimated_dimension is equal to 0:
        Map.put(ideal_properties, "is_zero_dimensional", "true")
        
        Note: Estimate number of solutions (for zero-dimensional ideals)
        Let solution_bound be Operations.compute_bezout_bound(groebner_basis)
        Map.put(ideal_properties, "solution_bound", solution_bound.toString())
    Otherwise:
        Map.put(ideal_properties, "is_zero_dimensional", "false")
        Map.put(ideal_properties, "solution_bound", "infinite")
    
    Note: Additional structural information
    Let homogeneous_components be Operations.analyze_homogeneous_components(groebner_basis)
    Map.put(ideal_properties, "is_homogeneous", homogeneous_components.toString())
    
    Let minimal_generators be Operations.find_minimal_generators(groebner_basis)
    Map.put(ideal_properties, "minimal_generator_count", List.length(minimal_generators).toString())
    
    Return ideal_properties

Note: =====================================================================
Note: COMPLEX POLYNOMIAL OPERATIONS
Note: =====================================================================

Process called "find_zeros_polynomial" that takes coefficients as List[ComplexNumber] returns List[ComplexNumber]:
    Note: Find all zeros of complex polynomial using numerical methods
    
    If coefficients.length() is equal to 0 Then:
        Throw Errors.InvalidArgument with "Polynomial must have at least one coefficient"
    End If
    
    Let degree be coefficients.length() minus 1
    Let zeros be List[ComplexNumber]
    
    Note: Handle special cases
    If degree is equal to 0:
        Note: Constant polynomial has no zeros (unless zero)
        If Operations.complex_magnitude(coefficients[0]) is less than 0.000001:
            Note: Zero polynomial minus all complex numbers are zeros
            Return zeros
        Otherwise:
            Return zeros
    
    Otherwise if degree is equal to 1:
        Note: Linear polynomial: az plus b is equal to 0 => z is equal to -b/a
        Let a be coefficients[1]
        Let b be coefficients[0]
        Let zero be Operations.complex_divide(Operations.complex_multiply(Operations.create_complex_number("-1", "0", 15), b), a)
        zeros.append(zero)
        Return zeros
    
    Otherwise if degree is equal to 2:
        Note: Quadratic formula for complex coefficients
        Return solve_quadratic_complex(coefficients)
    
    Otherwise:
        Note: Use numerical methods for higher degree polynomials
        Return find_zeros_numerical_complex(coefficients)

Process called "solve_quadratic_complex" that takes coefficients as List[ComplexNumber] returns List[ComplexNumber]:
    Note: Solve az¬≤ plus bz plus c is equal to 0 using complex quadratic formula
    
    Let a be coefficients[2]
    Let b be coefficients[1]
    Let c be coefficients[0]
    
    Note: Compute discriminant Œî is equal to b¬≤ minus 4ac
    Let b_squared be Operations.complex_multiply(b, b)
    Let four_a be Operations.complex_multiply(Operations.create_complex_number("4", "0", 15), a)
    Let four_ac be Operations.complex_multiply(four_a, c)
    Let discriminant be Operations.complex_add(b_squared, Operations.complex_multiply(Operations.create_complex_number("-1", "0", 15), four_ac))
    
    Note: Compute ‚àöŒî using complex square root
    Let sqrt_discriminant be complex_sqrt(discriminant)
    
    Note: Two solutions: z is equal to (-b ¬± ‚àöŒî) / (2a)
    Let two_a be Operations.complex_multiply(Operations.create_complex_number("2", "0", 15), a)
    Let minus_b be Operations.complex_multiply(Operations.create_complex_number("-1", "0", 15), b)
    
    Let z1 be Operations.complex_divide(Operations.complex_add(minus_b, sqrt_discriminant), two_a)
    Let z2 be Operations.complex_divide(Operations.complex_add(minus_b, Operations.complex_multiply(Operations.create_complex_number("-1", "0", 15), sqrt_discriminant)), two_a)
    
    Let zeros be List[ComplexNumber]
    zeros.append(z1)
    zeros.append(z2)
    
    Return zeros

Process called "find_zeros_numerical_complex" that takes coefficients as List[ComplexNumber] returns List[ComplexNumber]:
    Note: Find polynomial zeros using Durand-Kerner method for complex polynomials
    
    Let degree be coefficients.length() minus 1
    Let zeros be List[ComplexNumber]
    
    Note: Initialize starting approximations using unit circle
    For k from 0 to degree minus 1:
        Let angle be 2.0 multiplied by 3.14159265 multiplied by Float(k) / Float(degree)
        Let radius be 1.0 plus 0.5 multiplied by Float(k) / Float(degree)
        Let real_part be radius multiplied by Math.cos(angle)
        Let imag_part be radius multiplied by Math.sin(angle)
        Let initial_guess be Operations.create_complex_from_floats(real_part, imag_part)
        zeros.append(initial_guess)
    
    Note: Durand-Kerner iteration
    Let max_iterations be 100
    Let tolerance be 0.000001
    
    For iteration from 1 to max_iterations:
        Let new_zeros be List[ComplexNumber]
        Let max_change be 0.0
        
        For i from 0 to degree minus 1:
            Let z_i be zeros[i]
            Let f_zi be evaluate_polynomial_complex(coefficients, z_i)
            
            Note: Compute denominator product
            Let denominator be Operations.create_complex_number("1", "0", 15)
            For j from 0 to degree minus 1:
                If j does not equal i:
                    Let z_j be zeros[j]
                    Let difference be Operations.complex_add(z_i, Operations.complex_multiply(Operations.create_complex_number("-1", "0", 15), z_j))
                    Set denominator to Operations.complex_multiply(denominator, difference)
            
            Note: Newton step: z_i minus f(z_i) / ‚àè(z_i minus z_j)
            Let correction be Operations.complex_divide(f_zi, denominator)
            Let new_zi be Operations.complex_add(z_i, Operations.complex_multiply(Operations.create_complex_number("-1", "0", 15), correction))
            
            Note: Track convergence
            Let change be Operations.complex_magnitude(correction)
            If change is greater than max_change:
                Set max_change to change
            
            new_zeros.append(new_zi)
        
        Set zeros to new_zeros
        
        Note: Check convergence
        If max_change is less than tolerance:
            Break
    
    Return zeros

Process called "polynomial_factorization" that takes coefficients as List[ComplexNumber] returns List[List[ComplexNumber]]:
    Note: Factor complex polynomial into linear and irreducible factors
    
    Let zeros be find_zeros_polynomial(coefficients)
    Let factors be List[List[ComplexNumber]]
    
    Note: Each zero corresponds to a linear factor (z minus zero)
    For Each zero in zeros:
        Let factor_coeffs be List[ComplexNumber]
        Let minus_zero be Operations.complex_multiply(Operations.create_complex_number("-1", "0", 15), zero)
        factor_coeffs.append(minus_zero)
        factor_coeffs.append(Operations.create_complex_number("1", "0", 15))
        factors.append(factor_coeffs)
    
    Note: Handle leading coefficient
    Let degree be coefficients.length() minus 1
    If degree is greater than 0:
        Let leading_coeff be coefficients[degree]
        Let leading_magnitude be Operations.complex_magnitude(leading_coeff)
        
        If leading_magnitude is greater than 0.000001:
            Note: Scale first factor by leading coefficient
            Let scaled_factor be List[ComplexNumber]
            For Each coeff in factors[0]:
                Let scaled_coeff be Operations.complex_multiply(coeff, leading_coeff)
                scaled_factor.append(scaled_coeff)
            Set factors[0] to scaled_factor
    
    Return factors

Process called "complex_sqrt" that takes z as ComplexNumber returns ComplexNumber:
    Note: Compute complex square root using polar form
    
    Let magnitude be Operations.complex_magnitude(z)
    Let argument be Math.atan2(Float(z.imaginary_part), Float(z.real_part))
    
    Note: ‚àöz is equal to ‚àör multiplied by e^(iŒ∏/2)
    Let sqrt_magnitude be Math.sqrt(magnitude)
    Let sqrt_argument be argument / 2.0
    
    Let result_real be sqrt_magnitude multiplied by Math.cos(sqrt_argument)
    Let result_imag be sqrt_magnitude multiplied by Math.sin(sqrt_argument)
    
    Return Operations.create_complex_from_floats(result_real, result_imag)

Process called "evaluate_polynomial_complex" that takes coefficients as List[ComplexNumber], z as ComplexNumber returns ComplexNumber:
    Note: Evaluate polynomial at complex point using Horner's method
    
    If coefficients.length() is equal to 0:
        Return Operations.create_complex_number("0", "0", 15)
    
    Note: Horner's method: p(z) is equal to a_n plus z(a_{n-1} plus z(a_{n-2} plus ... plus z*a_0))
    Let result be coefficients[coefficients.length() minus 1]
    
    For i from coefficients.length() minus 2 down to 0:
        Set result to Operations.complex_multiply(result, z)
        Set result to Operations.complex_add(result, coefficients[i])
    
    Return result

Process called "polynomial_derivative_complex" that takes coefficients as List[ComplexNumber] returns List[ComplexNumber]:
    Note: Compute derivative of complex polynomial
    
    If coefficients.length() is less than or equal to 1:
        Return [Operations.create_complex_number("0", "0", 15)]
    
    Let derivative_coeffs be List[ComplexNumber]
    
    For i from 1 to coefficients.length() minus 1:
        Let power_coeff be Operations.create_complex_number(String(i), "0", 15)
        Let derivative_term be Operations.complex_multiply(power_coeff, coefficients[i])
        derivative_coeffs.append(derivative_term)
    
    Return derivative_coeffs

Process called "polynomial_gcd_complex" that takes poly1 as List[ComplexNumber], poly2 as List[ComplexNumber] returns List[ComplexNumber]:
    Note: Compute greatest common divisor of complex polynomials using Euclidean algorithm
    
    Let a be normalize_polynomial_complex(poly1)
    Let b be normalize_polynomial_complex(poly2)
    
    Note: Euclidean algorithm for polynomials
    While polynomial_degree_complex(b) is greater than 0:
        Let quotient_remainder be polynomial_division_complex(a, b)
        Set a to b
        Set b to quotient_remainder["remainder"]
    
    Return normalize_polynomial_complex(a)

Process called "normalize_polynomial_complex" that takes coefficients as List[ComplexNumber] returns List[ComplexNumber]:
    Note: Remove leading zero coefficients and normalize
    
    Let normalized be List[ComplexNumber]
    Let found_nonzero be false
    
    Note: Remove leading zeros
    For i from coefficients.length() minus 1 down to 0:
        Let coeff_magnitude be Operations.complex_magnitude(coefficients[i])
        If coeff_magnitude is greater than 0.000001 or found_nonzero:
            normalized.insert(0, coefficients[i])
            Set found_nonzero to true
    
    If normalized.length() is equal to 0:
        normalized.append(Operations.create_complex_number("0", "0", 15))
    
    Return normalized

Process called "polynomial_degree_complex" that takes coefficients as List[ComplexNumber] returns Integer:
    Note: Find degree of complex polynomial
    
    For i from coefficients.length() minus 1 down to 0:
        Let coeff_magnitude be Operations.complex_magnitude(coefficients[i])
        If coeff_magnitude is greater than 0.000001:
            Return i
    
    Return 0

Process called "polynomial_division_complex" that takes dividend as List[ComplexNumber], divisor as List[ComplexNumber] returns Dictionary[String, List[ComplexNumber]]:
    Note: Divide complex polynomials returning quotient and remainder
    
    Let quotient be List[ComplexNumber]
    Let remainder be normalize_polynomial_complex(dividend)
    
    Let divisor_degree be polynomial_degree_complex(divisor)
    Let divisor_leading be divisor[divisor_degree]
    
    While polynomial_degree_complex(remainder) is greater than or equal to divisor_degree:
        Let remainder_degree be polynomial_degree_complex(remainder)
        Let remainder_leading be remainder[remainder_degree]
        
        Note: Compute leading term of quotient
        Let term_coeff be Operations.complex_divide(remainder_leading, divisor_leading)
        Let term_degree be remainder_degree minus divisor_degree
        
        Note: Add term to quotient
        While quotient.length() is less than or equal to term_degree:
            quotient.append(Operations.create_complex_number("0", "0", 15))
        Set quotient[term_degree] to term_coeff
        
        Note: Subtract divisor multiplied by term from remainder
        For i from 0 to divisor_degree:
            Let product be Operations.complex_multiply(term_coeff, divisor[i])
            Let remainder_index be i plus term_degree
            If remainder_index is less than remainder.length():
                Set remainder[remainder_index] to Operations.complex_add(remainder[remainder_index], 
                    Operations.complex_multiply(Operations.create_complex_number("-1", "0", 15), product))
        
        Set remainder to normalize_polynomial_complex(remainder)
    
    Let result be Dictionary[String, List[ComplexNumber]]
    Set result["quotient"] to normalize_polynomial_complex(quotient)
    Set result["remainder"] to remainder
    
    Return result

Note: =====================================================================
Note: POLYNOMIAL MODULO OPERATIONS FOR NTRU
Note: =====================================================================

Process called "polynomial_mod" that takes dividend as Polynomial, divisor as Polynomial, modulus as Integer returns Polynomial:
    Note: Compute polynomial modulo another polynomial in Z/nZ
    Note: Essential for NTRU polynomial ring operations
    Note: Reduces polynomial modulo both the polynomial divisor and integer modulus
    
    If modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be positive"
    
    If divisor.degree is less than or equal to 0:
        Throw Errors.InvalidArgument with "Divisor polynomial must have positive degree"
    
    Note: First perform polynomial division to get remainder
    Let division_result be divide_polynomials(dividend, divisor)
    Let polynomial_remainder be division_result.get("remainder")
    
    Note: Reduce coefficients modulo the integer modulus
    Let reduced_coefficients be List.create_list()
    Let i be 0
    While i is less than polynomial_remainder.coefficients.length():
        Let coefficient be polynomial_remainder.coefficients.get(i)
        Let coefficient_int be Operations.string_to_integer(coefficient)
        Let reduced_coeff be coefficient_int % modulus
        
        Note: Ensure positive remainder
        If reduced_coeff is less than 0:
            Set reduced_coeff to reduced_coeff plus modulus
        
        reduced_coefficients.add(Operations.integer_to_string(reduced_coeff))
        Set i to i plus 1
    
    Note: Create result polynomial
    Let result be Polynomial with coefficients: reduced_coefficients, degree: polynomial_remainder.degree, variable: dividend.variable, field: "Z/" plus Operations.integer_to_string(modulus) plus "Z", is_monic: false, is_irreducible: false, leading_coefficient: reduced_coefficients.get(reduced_coefficients.length() minus 1), constant_term: reduced_coefficients.get(0), factorization: List.create_list(), roots: List.create_list()
    
    Return result

Process called "polynomial_inverse_mod" that takes polynomial as Polynomial, modulus_polynomial as Polynomial, integer_modulus as Integer returns Polynomial:
    Note: Compute modular inverse of polynomial using extended Euclidean algorithm
    Note: Finds polynomial p such that (polynomial multiplied by p) ‚â° 1 (mod modulus_polynomial, integer_modulus)
    Note: Essential for NTRU private key operations
    
    If integer_modulus is less than or equal to 0:
        Throw Errors.InvalidArgument with "Integer modulus must be positive"
    
    If modulus_polynomial.degree is less than or equal to 0:
        Throw Errors.InvalidArgument with "Polynomial modulus must have positive degree"
    
    Note: Initialize extended Euclidean algorithm variables
    Let old_r be polynomial
    Let r be modulus_polynomial
    Let old_s be create_constant_polynomial("1", polynomial.variable, polynomial.field)
    Let s be create_constant_polynomial("0", polynomial.variable, polynomial.field)
    
    Note: Perform extended Euclidean algorithm
    While not is_zero_polynomial(r):
        Let division_result be divide_polynomials(old_r, r)
        Let quotient be division_result.get("quotient")
        
        Note: Update r values: old_r, r is equal to r, old_r minus quotient multiplied by r
        Let temp_r be r
        Set r to polynomial_subtract(old_r, multiply_polynomials(quotient, r))
        Set old_r to temp_r
        
        Note: Update s values: old_s, s is equal to s, old_s minus quotient multiplied by s
        Let temp_s be s
        Set s to polynomial_subtract(old_s, multiply_polynomials(quotient, s))
        Set old_s to temp_s
    
    Note: Check if gcd is 1 (invertible)
    If old_r.degree does not equal 0 or not Operations.equals(old_r.coefficients.get(0), "1"):
        Throw Errors.InvalidArgument with "Polynomial is not invertible modulo given polynomial"
    
    Note: Reduce result modulo integer modulus
    Let inverse_coefficients be List.create_list()
    Let i be 0
    While i is less than old_s.coefficients.length():
        Let coefficient be old_s.coefficients.get(i)
        Let coefficient_int be Operations.string_to_integer(coefficient)
        Let reduced_coeff be coefficient_int % integer_modulus
        
        Note: Ensure positive remainder
        If reduced_coeff is less than 0:
            Set reduced_coeff to reduced_coeff plus integer_modulus
        
        inverse_coefficients.add(Operations.integer_to_string(reduced_coeff))
        Set i to i plus 1
    
    Note: Create result polynomial
    Let result be Polynomial with coefficients: inverse_coefficients, degree: old_s.degree, variable: polynomial.variable, field: "Z/" plus Operations.integer_to_string(integer_modulus) plus "Z", is_monic: false, is_irreducible: false, leading_coefficient: inverse_coefficients.get(inverse_coefficients.length() minus 1), constant_term: inverse_coefficients.get(0), factorization: List.create_list(), roots: List.create_list()
    
    Return result

Process called "create_constant_polynomial" that takes constant_value as String, variable as String, field as String returns Polynomial:
    Note: Create polynomial with single constant term
    Note: Helper function for polynomial inverse computation
    
    Let coefficients be List.create_list()
    coefficients.add(constant_value)
    
    Let degree be if Operations.equals(constant_value, "0") then -1 otherwise 0
    
    Return Polynomial with coefficients: coefficients, degree: degree, variable: variable, field: field, is_monic: false, is_irreducible: false, leading_coefficient: constant_value, constant_term: constant_value, factorization: List.create_list(), roots: List.create_list()

Process called "is_zero_polynomial" that takes polynomial as Polynomial returns Boolean:
    Note: Check if polynomial is the zero polynomial
    Note: Helper function for extended Euclidean algorithm
    
    If polynomial.degree is less than 0:
        Return true
    
    Let i be 0
    While i is less than polynomial.coefficients.length():
        Let coefficient be polynomial.coefficients.get(i)
        If not Operations.equals(coefficient, "0"):
            Return false
        Set i to i plus 1
    
    Return true

Process called "polynomial_subtract" that takes first as Polynomial, second as Polynomial returns Polynomial:
    Note: Subtract two polynomials (needed for extended Euclidean algorithm)
    Note: Helper function extending basic polynomial arithmetic
    
    Note: Verify field compatibility
    If first.field does not equal second.field:
        Throw Errors.InvalidArgument with "Polynomials must be over the same field"
    
    Note: Verify variable compatibility
    If first.variable does not equal second.variable:
        Throw Errors.InvalidArgument with "Polynomials must have the same variable"
    
    Note: Determine maximum degree and create coefficient arrays
    Let max_degree be if first.degree is greater than second.degree then first.degree otherwise second.degree
    Let result_coefficients be List.create_list()
    
    Let i be 0
    While i is less than or equal to max_degree:
        Let first_coeff be if i is less than first.coefficients.length() then first.coefficients.get(i) otherwise "0"
        Let second_coeff be if i is less than second.coefficients.length() then second.coefficients.get(i) otherwise "0"
        
        Let difference be Operations.subtract(first_coeff, second_coeff)
        result_coefficients.add(difference)
        Set i to i plus 1
    
    Note: Remove leading zeros and determine actual degree
    While result_coefficients.length() is greater than 1 and Operations.equals(result_coefficients.get(result_coefficients.length() minus 1), "0"):
        result_coefficients.remove_last()
    
    Let actual_degree be result_coefficients.length() minus 1
    If actual_degree is less than 0:
        Set actual_degree to -1
    
    Let leading_coeff be if actual_degree is greater than or equal to 0 then result_coefficients.get(actual_degree) otherwise "0"
    Let constant_term be if result_coefficients.length() is greater than 0 then result_coefficients.get(0) otherwise "0"
    
    Return Polynomial with coefficients: result_coefficients, degree: actual_degree, variable: first.variable, field: first.field, is_monic: Operations.equals(leading_coeff, "1"), is_irreducible: false, leading_coefficient: leading_coeff, constant_term: constant_term, factorization: List.create_list(), roots: List.create_list()
