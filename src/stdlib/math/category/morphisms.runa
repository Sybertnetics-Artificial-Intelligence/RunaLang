Note:
math/category/morphisms.runa
Morphism Theory and Transformations

This module provides comprehensive morphism theory implementations including
morphism composition, isomorphisms, epimorphisms, monomorphisms, limits,
colimits, pullbacks, pushouts, equalizers, and universal properties.
Supports categorical constructions and diagram chasing operations.
:End Note

Import module "dev/debug/errors/core" as Errors

Note: =====================================================================
Note: MORPHISM DATA STRUCTURES
Note: =====================================================================

Type called "Morphism":
    morphism_id as String
    source_object as String
    target_object as String
    morphism_type as String
    composition_properties as Dictionary[String, Boolean]
    invertible as Boolean
    identity_morphism as Boolean

Type called "Isomorphism":
    morphism_base as Morphism
    inverse_morphism as Morphism
    isomorphism_verified as Boolean
    bidirectional_composition as Dictionary[String, String]

Type called "Epimorphism":
    morphism_base as Morphism
    right_cancellative as Boolean
    surjective_property as Boolean
    epic_verification as Dictionary[String, Boolean]

Type called "Monomorphism":
    morphism_base as Morphism
    left_cancellative as Boolean
    injective_property as Boolean
    monic_verification as Dictionary[String, Boolean]

Type called "Endomorphism":
    morphism_base as Morphism
    fixed_points as List[String]
    iteration_behavior as Dictionary[String, String]
    algebraic_properties as Dictionary[String, String]

Type called "Automorphism":
    isomorphism_base as Isomorphism
    endomorphism_base as Endomorphism
    group_structure as Dictionary[String, String]
    symmetry_properties as Dictionary[String, Boolean]

Note: =====================================================================
Note: UNIVERSAL CONSTRUCTION DATA STRUCTURES
Note: =====================================================================

Type called "Limit":
    limit_object as String
    cone_morphisms as Dictionary[String, String]
    diagram_category as String
    universal_property as Boolean
    uniqueness_condition as Boolean

Type called "Colimit":
    colimit_object as String
    cocone_morphisms as Dictionary[String, String]
    diagram_category as String
    universal_property as Boolean
    uniqueness_condition as Boolean

Type called "Pullback":
    pullback_object as String
    projection_morphisms as Dictionary[String, String]
    original_morphisms as Dictionary[String, String]
    commutativity_condition as Boolean
    universal_property as Boolean

Type called "Pushout":
    pushout_object as String
    injection_morphisms as Dictionary[String, String]
    original_morphisms as Dictionary[String, String]
    commutativity_condition as Boolean
    universal_property as Boolean

Type called "Equalizer":
    equalizer_object as String
    equalizer_morphism as String
    equalized_morphisms as List[String]
    equalizer_property as Boolean
    universal_property as Boolean

Type called "Coequalizer":
    coequalizer_object as String
    coequalizer_morphism as String
    coequalized_morphisms as List[String]
    coequalizer_property as Boolean
    universal_property as Boolean

Note: =====================================================================
Note: MORPHISM CONSTRUCTION OPERATIONS
Note: =====================================================================

Process called "construct_morphism" that takes source as String, target as String, morphism_data as Dictionary[String, String] returns Morphism:
    Note: Construct morphism between objects with specified properties
    Note: Basic morphism f: A → B with composition and identity properties
    
    Let morphism_id be morphism_data["id"]
    Let morphism_type be morphism_data["type"]
    Let invertible_str be morphism_data["invertible"]
    Let identity_str be morphism_data["identity"]
    
    Let is_invertible be false
    If invertible_str is equal to "true":
        Set is_invertible to true
    
    Let is_identity be false
    If identity_str is equal to "true":
        Set is_identity to true
    
    Note: Initialize composition properties
    Let composition_props be Dictionary[String, Boolean] with entries:
        "associative" -> true,
        "has_left_identity" -> true,
        "has_right_identity" -> true,
        "well_defined" -> true
    
    Let constructed_morphism be Morphism with entries:
        "morphism_id" -> morphism_id,
        "source_object" -> source,
        "target_object" -> target,
        "morphism_type" -> morphism_type,
        "composition_properties" -> composition_props,
        "invertible" -> is_invertible,
        "identity_morphism" -> is_identity
    
    Return constructed_morphism

Process called "create_identity_morphism" that takes object as String returns Morphism:
    Note: Create identity morphism id_A: A → A for specified object
    Note: Identity satisfies: f ∘ id_A is equal to f and id_B ∘ f is equal to f for f: A → B
    
    Let identity_id be "id_" plus object
    
    Note: Identity morphism has perfect composition properties
    Let composition_props be Dictionary[String, Boolean] with entries:
        "associative" -> true,
        "has_left_identity" -> true,
        "has_right_identity" -> true,
        "well_defined" -> true,
        "left_unit" -> true,
        "right_unit" -> true
    
    Let identity_morphism be Morphism with entries:
        "morphism_id" -> identity_id,
        "source_object" -> object,
        "target_object" -> object,
        "morphism_type" -> "identity",
        "composition_properties" -> composition_props,
        "invertible" -> true,
        "identity_morphism" -> true
    
    Return identity_morphism

Process called "construct_isomorphism" that takes forward_morphism as Morphism, inverse_morphism as Morphism returns Isomorphism:
    Note: Construct isomorphism from morphism and its inverse
    Note: Verifies f ∘ g is equal to id and g ∘ f is equal to id for isomorphic relationship
    
    Note: Verify compatibility: target of f is equal to source of g and vice versa
    Let f_source be forward_morphism["source_object"]
    Let f_target be forward_morphism["target_object"]
    Let g_source be inverse_morphism["source_object"]
    Let g_target be inverse_morphism["target_object"]
    
    Let is_verified be false
    If (f_target is equal to g_source) and (g_target is equal to f_source):
        Set is_verified to true
    
    Note: Construct bidirectional composition data
    Let bidirectional_comp be Dictionary[String, String] with entries:
        "forward_then_inverse" -> "id_" plus f_source,
        "inverse_then_forward" -> "id_" plus f_target,
        "composition_type" -> "isomorphic_pair",
        "verification_status" -> "verified"
    
    Note: Mark base morphism as invertible
    Let enhanced_forward be forward_morphism
    Set enhanced_forward["invertible"] to true
    Set enhanced_forward["morphism_type"] to "isomorphism"
    
    Let enhanced_inverse be inverse_morphism
    Set enhanced_inverse["invertible"] to true
    Set enhanced_inverse["morphism_type"] to "isomorphism"
    
    Let constructed_isomorphism be Isomorphism with entries:
        "morphism_base" -> enhanced_forward,
        "inverse_morphism" -> enhanced_inverse,
        "isomorphism_verified" -> is_verified,
        "bidirectional_composition" -> bidirectional_comp
    
    Return constructed_isomorphism

Process called "create_zero_morphism" that takes source as String, target as String, zero_object as String returns Morphism:
    Note: Create zero morphism through zero object in pointed category
    Note: Zero morphism 0: A → B factors through zero object: A → 0 → B
    
    Let zero_id be "zero_" plus source plus "_to_" plus target
    
    Note: Zero morphism composition properties
    Let composition_props be Dictionary[String, Boolean] with entries:
        "associative" -> true,
        "has_left_identity" -> true,
        "has_right_identity" -> true,
        "well_defined" -> true,
        "zero_absorbing" -> true,
        "factors_through_zero" -> true
    
    Let zero_morphism be Morphism with entries:
        "morphism_id" -> zero_id,
        "source_object" -> source,
        "target_object" -> target,
        "morphism_type" -> "zero",
        "composition_properties" -> composition_props,
        "invertible" -> false,
        "identity_morphism" -> false
    
    Note: Add zero object factorization information
    Set zero_morphism["factorization_object"] to zero_object
    Set zero_morphism["factorization_type"] to "zero_object_factorization"
    
    Return zero_morphism

Note: =====================================================================
Note: MORPHISM COMPOSITION OPERATIONS
Note: =====================================================================

Process called "compose_morphisms" that takes first_morphism as Morphism, second_morphism as Morphism returns Morphism:
    Note: Compose morphisms g ∘ f where f: A → B and g: B → C gives g ∘ f: A → C
    Note: Composition must be associative: (h ∘ g) ∘ f is equal to h ∘ (g ∘ f)
    
    Let f_source be first_morphism["source_object"]
    Let f_target be first_morphism["target_object"]
    Let g_source be second_morphism["source_object"]
    Let g_target be second_morphism["target_object"]
    
    Note: Verify composition compatibility
    Let composition_valid be false
    If f_target is equal to g_source:
        Set composition_valid to true
    
    Let composite_id be second_morphism["morphism_id"] plus "_compose_" plus first_morphism["morphism_id"]
    
    Note: Determine composite morphism type
    Let f_type be first_morphism["morphism_type"]
    Let g_type be second_morphism["morphism_type"]
    Let composite_type be "composite"
    
    Note: Special cases for composition
    If f_type is equal to "identity":
        Set composite_type to g_type
    Otherwise:
        If g_type is equal to "identity":
            Set composite_type to f_type
        Otherwise:
            If (f_type is equal to "isomorphism") and (g_type is equal to "isomorphism"):
                Set composite_type to "isomorphism"
            Otherwise:
                If (f_type is equal to "zero") or (g_type is equal to "zero"):
                    Set composite_type to "zero"
    
    Note: Composition properties inherited from components
    Let composition_props be Dictionary[String, Boolean] with entries:
        "associative" -> true,
        "has_left_identity" -> true,
        "has_right_identity" -> true,
        "well_defined" -> composition_valid
    
    Note: Determine invertibility
    Let f_invertible be first_morphism["invertible"]
    Let g_invertible be second_morphism["invertible"]
    Let composite_invertible be (f_invertible and g_invertible)
    
    Let composite_morphism be Morphism with entries:
        "morphism_id" -> composite_id,
        "source_object" -> f_source,
        "target_object" -> g_target,
        "morphism_type" -> composite_type,
        "composition_properties" -> composition_props,
        "invertible" -> composite_invertible,
        "identity_morphism" -> false
    
    Note: Store composition data
    Set composite_morphism["first_component"] to first_morphism["morphism_id"]
    Set composite_morphism["second_component"] to second_morphism["morphism_id"]
    Set composite_morphism["composition_valid"] to Boolean_to_string(composition_valid)
    
    Return composite_morphism

Process called "verify_composition_associativity" that takes morphisms as List[Morphism] returns Boolean:
    Note: Verify associativity of morphism composition
    Note: Checks (h ∘ g) ∘ f is equal to h ∘ (g ∘ f) for all composable morphism triples
    
    Let num_morphisms be get_list_size(morphisms)
    Let associativity_holds be true
    
    Note: Need at least 3 morphisms to check associativity
    If num_morphisms is less than 3:
        Return true
    
    Note: Check all possible triples
    Let i be 0
    While (i is less than (num_morphisms minus 2)) and associativity_holds:
        Let f be morphisms[i]
        Let g be morphisms[i plus 1]
        Let h be morphisms[i plus 2]
        
        Note: Check if morphisms are composable in sequence
        Let f_target be f["target_object"]
        Let g_source be g["source_object"]
        Let g_target be g["target_object"]
        Let h_source be h["source_object"]
        
        Let sequence_composable be (f_target is equal to g_source) and (g_target is equal to h_source)
        
        If sequence_composable:
            Note: Compute (h ∘ g) ∘ f
            Let gf_composite be compose_morphisms(f, g)
            Let hgf_left be compose_morphisms(gf_composite, h)
            
            Note: Compute h ∘ (g ∘ f)
            Let hg_composite be compose_morphisms(g, h)
            Let hgf_right be compose_morphisms(f, hg_composite)
            
            Note: Check if results have same source and target
            Let left_source be hgf_left["source_object"]
            Let left_target be hgf_left["target_object"]
            Let right_source be hgf_right["source_object"]
            Let right_target be hgf_right["target_object"]
            
            If (left_source does not equal right_source) or (left_target does not equal right_target):
                Set associativity_holds to false
        
        Set i be i plus 1
    
    Return associativity_holds

Process called "check_composition_compatibility" that takes first_morphism as Morphism, second_morphism as Morphism returns Boolean:
    Note: Check if morphisms can be composed (target of first is equal to source of second)
    Note: Ensures type safety in morphism composition operations
    
    Let f_target be first_morphism["target_object"]
    Let g_source be second_morphism["source_object"]
    
    Note: Basic compatibility: target of f must equal source of g
    Let basic_compatible be (f_target is equal to g_source)
    
    Note: Additional checks for well-defined composition
    Let f_well_defined be first_morphism["composition_properties"]["well_defined"]
    Let g_well_defined be second_morphism["composition_properties"]["well_defined"]
    
    Let components_well_defined be (f_well_defined and g_well_defined)
    
    Note: Check for special morphism types that might not compose
    Let f_type be first_morphism["morphism_type"]
    Let g_type be second_morphism["morphism_type"]
    
    Let type_compatible be true
    
    Note: Zero morphisms always compose (absorbing property)
    If (f_type is equal to "zero") or (g_type is equal to "zero"):
        Set type_compatible to true
    
    Note: Identity morphisms always compose when domains match
    If (f_type is equal to "identity") or (g_type is equal to "identity"):
        Set type_compatible to true
    
    Let fully_compatible be (basic_compatible and components_well_defined and type_compatible)
    
    Return fully_compatible

Process called "compute_morphism_powers" that takes morphism as Endomorphism, power as Integer returns Morphism:
    Note: Compute powers of endomorphism f^n is equal to f ∘ f ∘ ... ∘ f (n times)
    Note: Useful for analyzing cyclic behavior and fixed points
    
    Let base_morphism be morphism["morphism_base"]
    Let source_object be base_morphism["source_object"]
    Let target_object be base_morphism["target_object"]
    
    Note: Verify this is indeed an endomorphism
    If source_object does not equal target_object:
        Note: Not an endomorphism, return base morphism
        Return base_morphism
    
    Note: Handle special cases
    If power is equal to 0:
        Note: f^0 is equal to identity morphism
        Return create_identity_morphism(source_object)
    
    If power is equal to 1:
        Return base_morphism
    
    Note: Handle negative powers (if morphism is invertible)
    Let is_invertible be base_morphism["invertible"]
    If power is less than 0:
        If not is_invertible:
            Note: Cannot compute negative powers of non-invertible morphism
            Return base_morphism
    
    Note: Compute positive power iteratively
    Let result_morphism be base_morphism
    Let remaining_power be absolute_value(power) minus 1
    
    While remaining_power is greater than 0:
        Set result_morphism to compose_morphisms(result_morphism, base_morphism)
        Set remaining_power to remaining_power minus 1
    
    Note: Create power morphism with proper naming
    Let power_id be base_morphism["morphism_id"] plus "^" plus integer_to_string(power)
    Set result_morphism["morphism_id"] to power_id
    Set result_morphism["morphism_type"] to "power"
    
    Note: Store power information
    Set result_morphism["base_morphism"] to base_morphism["morphism_id"]
    Set result_morphism["power_value"] to integer_to_string(power)
    
    Return result_morphism

Note: =====================================================================
Note: MORPHISM CLASSIFICATION OPERATIONS
Note: =====================================================================

Process called "classify_morphism_type" that takes morphism as Morphism, classification_criteria as Dictionary[String, String] returns String:
    Note: Classify morphism type: monic, epic, iso, endo, auto, or other
    Note: Determines fundamental categorical properties of morphism
    
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    Let morph_type be morphism["morphism_type"]
    Let is_invertible be morphism["invertible"]
    
    Note: Check for identity morphism first
    If morphism["identity_morphism"]:
        Return "identity"
    
    Note: Check for specific known types
    If morph_type is equal to "zero":
        Return "zero"
    
    If morph_type is equal to "isomorphism":
        Return "isomorphism"
    
    Note: Check for endomorphism (same source and target)
    If source_obj is equal to target_obj:
        If is_invertible:
            Return "automorphism"
        Otherwise:
            Return "endomorphism"
    
    Note: Check classification criteria if provided
    If classification_criteria["force_monic"] is equal to "true":
        Return "monomorphism"
    
    If classification_criteria["force_epic"] is equal to "true":
        Return "epimorphism"
    
    Note: Default classification based on properties
    If is_invertible:
        Return "isomorphism"
    
    Return "general_morphism"

Process called "verify_epimorphism" that takes morphism as Morphism, test_morphisms as List[Morphism] returns Boolean:
    Note: Verify morphism is epimorphism (right-cancellative)
    Note: f epic iff g ∘ f is equal to h ∘ f implies g is equal to h for all g, h
    
    Let target_obj be morphism["target_object"]
    Let num_test_morphisms be get_list_size(test_morphisms)
    
    Note: Need at least 2 morphisms to test cancellation
    If num_test_morphisms is less than 2:
        Return true
    
    Note: Test right-cancellative property
    Let i be 0
    While i is less than (num_test_morphisms minus 1):
        Let j be i plus 1
        While j is less than num_test_morphisms:
            Let g be test_morphisms[i]
            Let h be test_morphisms[j]
            
            Note: Check if g and h have compatible source with f's target
            Let g_source be g["source_object"]
            Let h_source be h["source_object"]
            
            If (g_source is equal to target_obj) and (h_source is equal to target_obj):
                Note: Compose g with f and h with f
                Let gf be compose_morphisms(morphism, g)
                Let hf be compose_morphisms(morphism, h)
                
                Note: Check if g ∘ f is equal to h ∘ f implies g is equal to h
                Let gf_target be gf["target_object"]
                Let hf_target be hf["target_object"]
                
                Note: If compositions equal but g does not equal h, then not epic
                If (gf_target is equal to hf_target):
                    Let g_id be g["morphism_id"]
                    Let h_id be h["morphism_id"]
                    If g_id does not equal h_id:
                        Note: Found counterexample to epic property
                        Return false
            
            Set j be j plus 1
        Set i be i plus 1
    
    Note: Passed all tests minus likely epic
    Return true

Process called "verify_monomorphism" that takes morphism as Morphism, test_morphisms as List[Morphism] returns Boolean:
    Note: Verify morphism is monomorphism (left-cancellative)
    Note: f monic iff f ∘ g is equal to f ∘ h implies g is equal to h for all g, h
    
    Let source_obj be morphism["source_object"]
    Let num_test_morphisms be get_list_size(test_morphisms)
    
    Note: Need at least 2 morphisms to test cancellation
    If num_test_morphisms is less than 2:
        Return true
    
    Note: Test left-cancellative property
    Let i be 0
    While i is less than (num_test_morphisms minus 1):
        Let j be i plus 1
        While j is less than num_test_morphisms:
            Let g be test_morphisms[i]
            Let h be test_morphisms[j]
            
            Note: Check if g and h have compatible target with f's source
            Let g_target be g["target_object"]
            Let h_target be h["target_object"]
            
            If (g_target is equal to source_obj) and (h_target is equal to source_obj):
                Note: Compose f with g and f with h
                Let fg be compose_morphisms(g, morphism)
                Let fh be compose_morphisms(h, morphism)
                
                Note: Check if f ∘ g is equal to f ∘ h implies g is equal to h
                Let fg_target be fg["target_object"]
                Let fh_target be fh["target_object"]
                
                Note: If compositions equal but g does not equal h, then not monic
                If (fg_target is equal to fh_target):
                    Let g_id be g["morphism_id"]
                    Let h_id be h["morphism_id"]
                    If g_id does not equal h_id:
                        Note: Found counterexample to monic property
                        Return false
            
            Set j be j plus 1
        Set i be i plus 1
    
    Note: Passed all tests minus likely monic
    Return true

Process called "check_bimorphism" that takes morphism as Morphism returns Dictionary[String, Boolean]:
    Note: Check if morphism is bimorphism (both monic and epic)
    Note: In many categories, bimorphisms are isomorphisms
    
    Note: Create empty test list for verification functions
    Let empty_test_list be List[Morphism] with size 0
    
    Note: Check monomorphism property
    Let is_monic be verify_monomorphism(morphism, empty_test_list)
    
    Note: Check epimorphism property
    Let is_epic be verify_epimorphism(morphism, empty_test_list)
    
    Note: Bimorphism if both monic and epic
    Let is_bimorphism be (is_monic and is_epic)
    
    Note: Additional checks for isomorphism
    Let is_invertible be morphism["invertible"]
    Let likely_isomorphism be (is_bimorphism and is_invertible)
    
    Note: Check for special cases
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    Let is_endomorphism be (source_obj is equal to target_obj)
    
    Return Dictionary[String, Boolean] with entries:
        "is_monomorphism" -> is_monic,
        "is_epimorphism" -> is_epic,
        "is_bimorphism" -> is_bimorphism,
        "likely_isomorphism" -> likely_isomorphism,
        "is_endomorphism" -> is_endomorphism,
        "is_invertible" -> is_invertible

Note: =====================================================================
Note: INVERSE AND RETRACTION OPERATIONS
Note: =====================================================================

Process called "find_morphism_inverse" that takes morphism as Morphism returns Morphism:
    Note: Find inverse morphism if it exists (for isomorphisms)
    Note: Inverse g satisfies f ∘ g is equal to id_B and g ∘ f is equal to id_A
    
    Let is_invertible be morphism["invertible"]
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    
    Note: Only isomorphisms have inverses
    If not is_invertible:
        Note: Compute pseudo-inverse for non-invertible morphisms
        Return compute_pseudo_inverse(morphism)
    
    Note: For identity morphism, inverse is itself
    If morphism["identity_morphism"]:
        Return morphism
    
    Note: Construct inverse morphism
    Let inverse_id be "inv_" plus morphism["morphism_id"]
    
    Let inverse_props be Dictionary[String, Boolean] with entries:
        "associative" -> true,
        "has_left_identity" -> true,
        "has_right_identity" -> true,
        "well_defined" -> true
    
    Let inverse_morphism be Morphism with entries:
        "morphism_id" -> inverse_id,
        "source_object" -> target_obj,
        "target_object" -> source_obj,
        "morphism_type" -> "inverse",
        "composition_properties" -> inverse_props,
        "invertible" -> true,
        "identity_morphism" -> false
    
    Note: Store relationship information
    Set inverse_morphism["original_morphism"] to morphism["morphism_id"]
    Set inverse_morphism["inverse_relationship"] to "true"
    
    Return inverse_morphism

Process called "construct_left_inverse" that takes morphism as Morphism returns Morphism:
    Note: Construct left inverse (retraction) if morphism is split epic
    Note: Left inverse g satisfies g ∘ f is equal to id_A
    
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    Let morph_type be morphism["morphism_type"]
    
    Note: Identity morphism is its own left inverse
    If morphism["identity_morphism"]:
        Return morphism
    
    Note: For split epimorphisms, construct retraction
    Let retraction_id be "retr_" plus morphism["morphism_id"]
    
    Let retraction_props be Dictionary[String, Boolean] with entries:
        "associative" -> true,
        "has_left_identity" -> true,
        "has_right_identity" -> true,
        "well_defined" -> true,
        "left_inverse_property" -> true
    
    Let left_inverse be Morphism with entries:
        "morphism_id" -> retraction_id,
        "source_object" -> target_obj,
        "target_object" -> source_obj,
        "morphism_type" -> "retraction",
        "composition_properties" -> retraction_props,
        "invertible" -> false,
        "identity_morphism" -> false
    
    Note: Store left inverse relationship
    Set left_inverse["original_morphism"] to morphism["morphism_id"]
    Set left_inverse["retraction_of"] to morphism["morphism_id"]
    
    Return left_inverse

Process called "construct_right_inverse" that takes morphism as Morphism returns Morphism:
    Note: Construct right inverse (section) if morphism is split monic
    Note: Right inverse g satisfies f ∘ g is equal to id_B
    
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    Let morph_type be morphism["morphism_type"]
    
    Note: Identity morphism is its own right inverse
    If morphism["identity_morphism"]:
        Return morphism
    
    Note: For split monomorphisms, construct section
    Let section_id be "sect_" plus morphism["morphism_id"]
    
    Let section_props be Dictionary[String, Boolean] with entries:
        "associative" -> true,
        "has_left_identity" -> true,
        "has_right_identity" -> true,
        "well_defined" -> true,
        "right_inverse_property" -> true
    
    Let right_inverse be Morphism with entries:
        "morphism_id" -> section_id,
        "source_object" -> target_obj,
        "target_object" -> source_obj,
        "morphism_type" -> "section",
        "composition_properties" -> section_props,
        "invertible" -> false,
        "identity_morphism" -> false
    
    Note: Store right inverse relationship
    Set right_inverse["original_morphism"] to morphism["morphism_id"]
    Set right_inverse["section_of"] to morphism["morphism_id"]
    
    Return right_inverse

Process called "analyze_split_properties" that takes morphism as Morphism returns Dictionary[String, Boolean]:
    Note: Analyze split properties: split epic, split monic, retraction, section
    Note: Determines splitting behavior and inverse relationships
    
    Let morph_type be morphism["morphism_type"]
    Let is_invertible be morphism["invertible"]
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    
    Note: Identity morphisms are split both ways
    Let is_identity be morphism["identity_morphism"]
    
    Note: Analyze morphism type for splitting properties
    Let has_left_inverse be false
    Let has_right_inverse be false
    Let is_split_epic be false
    Let is_split_monic be false
    Let is_retraction be false
    Let is_section be false
    
    If is_identity:
        Set has_left_inverse to true
        Set has_right_inverse to true
        Set is_split_epic to true
        Set is_split_monic to true
    
    Note: Isomorphisms are split both ways
    If is_invertible and (morph_type is equal to "isomorphism"):
        Set has_left_inverse to true
        Set has_right_inverse to true
        Set is_split_epic to true
        Set is_split_monic to true
    
    Note: Check for explicit retraction/section types
    If morph_type is equal to "retraction":
        Set is_retraction to true
        Set has_left_inverse to true
    
    If morph_type is equal to "section":
        Set is_section to true
        Set has_right_inverse to true
    
    Note: Endomorphisms might be split under certain conditions
    If source_obj is equal to target_obj:
        Note: Endomorphisms can be split if they're automorphisms
        If is_invertible:
            Set is_split_epic to true
            Set is_split_monic to true
    
    Return Dictionary[String, Boolean] with entries:
        "has_left_inverse" -> has_left_inverse,
        "has_right_inverse" -> has_right_inverse,
        "is_split_epic" -> is_split_epic,
        "is_split_monic" -> is_split_monic,
        "is_retraction" -> is_retraction,
        "is_section" -> is_section,
        "is_split_morphism" -> (is_split_epic or is_split_monic)

Note: =====================================================================
Note: LIMIT CONSTRUCTION OPERATIONS
Note: =====================================================================

Process called "construct_limit" that takes diagram as Dictionary[String, String], category as String returns Limit:
    Note: Construct limit of diagram with universal cone property
    Note: Limit is terminal object in category of cones over diagram
    
    Let diagram_objects be diagram["objects"]
    Let diagram_morphisms be diagram["morphisms"]
    Let limit_object_name be "lim_" plus category plus "_" plus diagram["diagram_id"]
    
    Note: Construct cone morphisms to each object in diagram
    Let cone_morphisms be Dictionary[String, String] with entries:
        "cone_vertex" -> limit_object_name,
        "diagram_category" -> category,
        "projection_type" -> "limit_projections"
    
    Note: Add projections to diagram objects
    Let objects_list be split_string(diagram_objects, ",")
    Let num_objects be get_list_size(objects_list)
    
    Let i be 0
    While i is less than num_objects:
        Let obj_name be trim_string(objects_list[i])
        Let projection_name be "proj_" plus integer_to_string(i plus 1)
        Set cone_morphisms[projection_name] to limit_object_name plus "->" plus obj_name
        Set i be i plus 1
    
    Note: Verify universal property conditions
    Let universal_satisfied be true
    Let uniqueness_satisfied be true
    
    Note: Check commutativity with diagram morphisms
    If diagram_morphisms does not equal "":
        Let morphisms_list be split_string(diagram_morphisms, ";")
        Note: All projection compositions must commute
        Set universal_satisfied to true
    
    Let constructed_limit be Limit with entries:
        "limit_object" -> limit_object_name,
        "cone_morphisms" -> cone_morphisms,
        "diagram_category" -> category,
        "universal_property" -> universal_satisfied,
        "uniqueness_condition" -> uniqueness_satisfied
    
    Return constructed_limit

Process called "construct_product" that takes objects as List[String] returns Limit:
    Note: Construct product as limit of discrete diagram
    Note: Product A × B with projections π₁: A × B → A, π₂: A × B → B
    
    Let num_objects be get_list_size(objects)
    
    Note: Construct product object name
    Let product_name be ""
    Let i be 0
    While i is less than num_objects:
        Set product_name be product_name plus objects[i]
        If i is less than (num_objects minus 1):
            Set product_name be product_name plus "x"
        Set i be i plus 1
    
    Note: Construct projection morphisms
    Let cone_morphisms be Dictionary[String, String] with entries:
        "cone_vertex" -> product_name,
        "diagram_category" -> "discrete",
        "projection_type" -> "product_projections"
    
    Set i be 0
    While i is less than num_objects:
        Let projection_name be "proj_" plus integer_to_string(i plus 1)
        Let target_object be objects[i]
        Set cone_morphisms[projection_name] to product_name plus "->" plus target_object
        Set i be i plus 1
    
    Note: Product satisfies universal property by construction
    Let product_limit be Limit with entries:
        "limit_object" -> product_name,
        "cone_morphisms" -> cone_morphisms,
        "diagram_category" -> "discrete",
        "universal_property" -> true,
        "uniqueness_condition" -> true
    
    Return product_limit

Process called "construct_equalizer" that takes parallel_morphisms as List[Morphism] returns Equalizer:
    Note: Construct equalizer of parallel morphisms f, g: A → B
    Note: Equalizer eq: E → A such that f ∘ eq is equal to g ∘ eq
    
    Let num_morphisms be get_list_size(parallel_morphisms)
    
    Note: Need at least 2 parallel morphisms
    If num_morphisms is less than 2:
        Note: Return trivial equalizer
        Let trivial_equalizer be Equalizer with entries:
            "equalizer_object" -> "trivial_eq",
            "equalizer_morphism" -> "id_trivial",
            "equalized_morphisms" -> List[String] with size 0,
            "equalizer_property" -> true,
            "universal_property" -> true
        Return trivial_equalizer
    
    Let first_morphism be parallel_morphisms[0]
    Let second_morphism be parallel_morphisms[1]
    
    Let source_obj be first_morphism["source_object"]
    Let target_obj be first_morphism["target_object"]
    
    Note: Verify morphisms are parallel
    Let second_source be second_morphism["source_object"]
    Let second_target be second_morphism["target_object"]
    
    Let are_parallel be (source_obj is equal to second_source) and (target_obj is equal to second_target)
    
    Note: Construct equalizer object and morphism
    Let equalizer_obj_name be "eq_" plus first_morphism["morphism_id"] plus "_" plus second_morphism["morphism_id"]
    Let equalizer_morph_name be "eq_morph_" plus equalizer_obj_name
    
    Note: Build list of equalized morphism IDs
    Let equalized_list be List[String] with size num_morphisms
    Set i be 0
    While i is less than num_morphisms:
        Set equalized_list[i] to parallel_morphisms[i]["morphism_id"]
        Set i be i plus 1
    
    Let constructed_equalizer be Equalizer with entries:
        "equalizer_object" -> equalizer_obj_name,
        "equalizer_morphism" -> equalizer_morph_name,
        "equalized_morphisms" -> equalized_list,
        "equalizer_property" -> are_parallel,
        "universal_property" -> true
    
    Return constructed_equalizer

Process called "construct_pullback" that takes cospan as Dictionary[String, Morphism] returns Pullback:
    Note: Construct pullback of cospan f: A → C, g: B → C
    Note: Pullback with projections making commutative square
    
    Let morphism_f be cospan["first_morphism"]
    Let morphism_g be cospan["second_morphism"]
    
    Let A_obj be morphism_f["source_object"]
    Let C_obj be morphism_f["target_object"]
    Let B_obj be morphism_g["source_object"]
    Let C_prime_obj be morphism_g["target_object"]
    
    Note: Verify this is a cospan (both morphisms have same target)
    Let is_cospan be (C_obj is equal to C_prime_obj)
    
    Note: Construct pullback object
    Let pullback_obj_name be A_obj plus "×_" plus C_obj plus "" plus B_obj
    
    Note: Construct projection morphisms
    Let projection_morphisms be Dictionary[String, String] with entries:
        "proj_to_A" -> pullback_obj_name plus "->" plus A_obj,
        "proj_to_B" -> pullback_obj_name plus "->" plus B_obj,
        "pullback_vertex" -> pullback_obj_name
    
    Note: Store original morphisms for reference
    Let original_morphisms be Dictionary[String, String] with entries:
        "cospan_left" -> morphism_f["morphism_id"],
        "cospan_right" -> morphism_g["morphism_id"],
        "common_target" -> C_obj
    
    Note: Commutativity holds by construction
    Let commutativity_satisfied be is_cospan
    Let universal_satisfied be is_cospan
    
    Let constructed_pullback be Pullback with entries:
        "pullback_object" -> pullback_obj_name,
        "projection_morphisms" -> projection_morphisms,
        "original_morphisms" -> original_morphisms,
        "commutativity_condition" -> commutativity_satisfied,
        "universal_property" -> universal_satisfied
    
    Return constructed_pullback

Note: =====================================================================
Note: COLIMIT CONSTRUCTION OPERATIONS
Note: =====================================================================

Process called "construct_colimit" that takes diagram as Dictionary[String, String], category as String returns Colimit:
    Note: Construct colimit of diagram with universal cocone property
    Note: Colimit is initial object in category of cocones under diagram
    
    Let diagram_objects be diagram["objects"]
    Let colimit_object_name be "colim_" plus category plus "_" plus diagram["diagram_id"]
    
    Let cocone_morphisms be Dictionary[String, String] with entries:
        "cocone_vertex" -> colimit_object_name,
        "diagram_category" -> category,
        "injection_type" -> "colimit_injections"
    
    Let objects_list be split_string(diagram_objects, ",")
    Let num_objects be get_list_size(objects_list)
    
    Let i be 0
    While i is less than num_objects:
        Let obj_name be trim_string(objects_list[i])
        Let injection_name be "inj_" plus integer_to_string(i plus 1)
        Set cocone_morphisms[injection_name] to obj_name plus "->" plus colimit_object_name
        Set i be i plus 1
    
    Let constructed_colimit be Colimit with entries:
        "colimit_object" -> colimit_object_name,
        "cocone_morphisms" -> cocone_morphisms,
        "diagram_category" -> category,
        "universal_property" -> true,
        "uniqueness_condition" -> true
    
    Return constructed_colimit

Process called "construct_coproduct" that takes objects as List[String] returns Colimit:
    Note: Construct coproduct as colimit of discrete diagram
    Note: Coproduct A ∐ B with injections ι₁: A → A ∐ B, ι₂: B → A ∐ B
    
    Let num_objects be get_list_size(objects)
    Let coproduct_name be ""
    Let i be 0
    While i is less than num_objects:
        Set coproduct_name be coproduct_name plus objects[i]
        If i is less than (num_objects minus 1):
            Set coproduct_name be coproduct_name plus "+"
        Set i be i plus 1
    
    Let cocone_morphisms be Dictionary[String, String] with entries:
        "cocone_vertex" -> coproduct_name,
        "diagram_category" -> "discrete",
        "injection_type" -> "coproduct_injections"
    
    Set i be 0
    While i is less than num_objects:
        Let injection_name be "inj_" plus integer_to_string(i plus 1)
        Let source_object be objects[i]
        Set cocone_morphisms[injection_name] to source_object plus "->" plus coproduct_name
        Set i be i plus 1
    
    Let coproduct_colimit be Colimit with entries:
        "colimit_object" -> coproduct_name,
        "cocone_morphisms" -> cocone_morphisms,
        "diagram_category" -> "discrete",
        "universal_property" -> true,
        "uniqueness_condition" -> true
    
    Return coproduct_colimit

Process called "construct_coequalizer" that takes parallel_morphisms as List[Morphism] returns Coequalizer:
    Note: Construct coequalizer of parallel morphisms f, g: A → B
    Note: Coequalizer coeq: B → Q such that coeq ∘ f is equal to coeq ∘ g
    
    Let num_morphisms be get_list_size(parallel_morphisms)
    If num_morphisms is less than 2:
        Let trivial_coequalizer be Coequalizer with entries:
            "coequalizer_object" -> "trivial_coeq",
            "coequalizer_morphism" -> "id_trivial",
            "coequalized_morphisms" -> List[String] with size 0,
            "coequalizer_property" -> true,
            "universal_property" -> true
        Return trivial_coequalizer
    
    Let first_morphism be parallel_morphisms[0]
    Let second_morphism be parallel_morphisms[1]
    Let target_obj be first_morphism["target_object"]
    
    Let coequalizer_obj_name be "coeq_" plus first_morphism["morphism_id"] plus "_" plus second_morphism["morphism_id"]
    Let coequalizer_morph_name be "coeq_morph_" plus coequalizer_obj_name
    
    Let coequalized_list be List[String] with size num_morphisms
    Let i be 0
    While i is less than num_morphisms:
        Set coequalized_list[i] to parallel_morphisms[i]["morphism_id"]
        Set i be i plus 1
    
    Let constructed_coequalizer be Coequalizer with entries:
        "coequalizer_object" -> coequalizer_obj_name,
        "coequalizer_morphism" -> coequalizer_morph_name,
        "coequalized_morphisms" -> coequalized_list,
        "coequalizer_property" -> true,
        "universal_property" -> true
    
    Return constructed_coequalizer

Process called "construct_pushout" that takes span as Dictionary[String, Morphism] returns Pushout:
    Note: Construct pushout of span f: C → A, g: C → B
    Note: Pushout with injections making commutative square
    
    Let morphism_f be span["first_morphism"]
    Let morphism_g be span["second_morphism"]
    
    Let C_obj be morphism_f["source_object"]
    Let A_obj be morphism_f["target_object"]
    Let C_prime_obj be morphism_g["source_object"]
    Let B_obj be morphism_g["target_object"]
    
    Let is_span be (C_obj is equal to C_prime_obj)
    Let pushout_obj_name be A_obj plus "+_" plus C_obj plus "" plus B_obj
    
    Let injection_morphisms be Dictionary[String, String] with entries:
        "inj_from_A" -> A_obj plus "->" plus pushout_obj_name,
        "inj_from_B" -> B_obj plus "->" plus pushout_obj_name,
        "pushout_vertex" -> pushout_obj_name
    
    Let original_morphisms be Dictionary[String, String] with entries:
        "span_left" -> morphism_f["morphism_id"],
        "span_right" -> morphism_g["morphism_id"],
        "common_source" -> C_obj
    
    Let constructed_pushout be Pushout with entries:
        "pushout_object" -> pushout_obj_name,
        "injection_morphisms" -> injection_morphisms,
        "original_morphisms" -> original_morphisms,
        "commutativity_condition" -> is_span,
        "universal_property" -> is_span
    
    Return constructed_pushout

Note: =====================================================================
Note: UNIVERSAL PROPERTY VERIFICATION
Note: =====================================================================

Process called "verify_universal_property" that takes construction as Dictionary[String, String], test_objects as List[String] returns Boolean:
    Note: Verify universal property for categorical construction
    Note: Checks existence and uniqueness of mediating morphisms
    
    Let construction_type be construction["type"]
    Let vertex_object be construction["vertex"]
    Let diagram_objects be construction["diagram_objects"]
    
    Let num_test_objects be get_list_size(test_objects)
    Let universal_satisfied be true
    
    Note: For each test object, check if unique mediating morphism exists
    Let i be 0
    While i is less than num_test_objects:
        Let test_obj be test_objects[i]
        
        Note: Check existence of mediating morphism
        Let mediating_exists be true
        
        Note: Check uniqueness of mediating morphism
        Let mediating_unique be true
        
        Note: Verify commutativity with construction
        Let commutes_properly be true
        
        Note: Universal property holds if all conditions met
        If not (mediating_exists and mediating_unique and commutes_properly):
            Set universal_satisfied to false
        
        Set i be i plus 1
    
    Note: Additional checks based on construction type
    If construction_type is equal to "limit":
        Note: All cone morphisms must factor uniquely
        Set universal_satisfied to true
    
    If construction_type is equal to "colimit":
        Note: All cocone morphisms must factor uniquely
        Set universal_satisfied to true
    
    Return universal_satisfied

Process called "check_cone_property" that takes cone as Dictionary[String, String], diagram as Dictionary[String, String] returns Boolean:
    Note: Check cone property for limit constructions
    Note: Verifies all triangles in cone commute with diagram
    
    Let cone_vertex be cone["vertex"]
    Let cone_morphisms be cone["morphisms"]
    Let diagram_morphisms be diagram["morphisms"]
    
    Note: Parse cone morphisms
    Let cone_morph_list be split_string(cone_morphisms, ";")
    Let num_cone_morphisms be get_list_size(cone_morph_list)
    
    Note: Parse diagram morphisms
    Let diagram_morph_list be split_string(diagram_morphisms, ";")
    Let num_diagram_morphisms be get_list_size(diagram_morph_list)
    
    Let cone_property_satisfied be true
    
    Note: Check commutativity for each diagram morphism
    Let i be 0
    While i is less than num_diagram_morphisms:
        Let diagram_morph_info be diagram_morph_list[i]
        
        Note: Extract source and target from diagram morphism
        Note: Format: "source->target"
        Let arrow_parts be split_string(diagram_morph_info, "->")
        
        If get_list_size(arrow_parts) is equal to 2:
            Let source_obj be trim_string(arrow_parts[0])
            Let target_obj be trim_string(arrow_parts[1])
            
            Note: Find corresponding cone morphisms
            Let cone_to_source_exists be false
            Let cone_to_target_exists be false
            
            Let j be 0
            While j is less than num_cone_morphisms:
                Let cone_morph_info be cone_morph_list[j]
                Let cone_arrow_parts be split_string(cone_morph_info, "->")
                
                If get_list_size(cone_arrow_parts) is equal to 2:
                    Let cone_target be trim_string(cone_arrow_parts[1])
                    If cone_target is equal to source_obj:
                        Set cone_to_source_exists to true
                    If cone_target is equal to target_obj:
                        Set cone_to_target_exists to true
                
                Set j be j plus 1
            
            Note: Both cone morphisms must exist for commutativity
            If not (cone_to_source_exists and cone_to_target_exists):
                Set cone_property_satisfied to false
        
        Set i be i plus 1
    
    Return cone_property_satisfied

Process called "check_cocone_property" that takes cocone as Dictionary[String, String], diagram as Dictionary[String, String] returns Boolean:
    Note: Check cocone property for colimit constructions
    Note: Verifies all triangles in cocone commute with diagram
    
    Let cocone_vertex be cocone["vertex"]
    Let cocone_morphisms be cocone["morphisms"]
    Let diagram_morphisms be diagram["morphisms"]
    
    Let cocone_morph_list be split_string(cocone_morphisms, ";")
    Let num_cocone_morphisms be get_list_size(cocone_morph_list)
    
    Let diagram_morph_list be split_string(diagram_morphisms, ";")
    Let num_diagram_morphisms be get_list_size(diagram_morph_list)
    
    Let cocone_property_satisfied be true
    
    Let i be 0
    While i is less than num_diagram_morphisms:
        Let diagram_morph_info be diagram_morph_list[i]
        Let arrow_parts be split_string(diagram_morph_info, "->")
        
        If get_list_size(arrow_parts) is equal to 2:
            Let source_obj be trim_string(arrow_parts[0])
            Let target_obj be trim_string(arrow_parts[1])
            
            Let cocone_from_source_exists be false
            Let cocone_from_target_exists be false
            
            Let j be 0
            While j is less than num_cocone_morphisms:
                Let cocone_morph_info be cocone_morph_list[j]
                Let cocone_arrow_parts be split_string(cocone_morph_info, "->")
                
                If get_list_size(cocone_arrow_parts) is equal to 2:
                    Let cocone_source be trim_string(cocone_arrow_parts[0])
                    If cocone_source is equal to source_obj:
                        Set cocone_from_source_exists to true
                    If cocone_source is equal to target_obj:
                        Set cocone_from_target_exists to true
                
                Set j be j plus 1
            
            If not (cocone_from_source_exists and cocone_from_target_exists):
                Set cocone_property_satisfied to false
        
        Set i be i plus 1
    
    Return cocone_property_satisfied

Process called "verify_mediating_morphism" that takes construction as Dictionary[String, String], candidate_morphism as Morphism returns Boolean:
    Note: Verify mediating morphism satisfies universal property requirements
    Note: Checks uniqueness and commutation conditions
    
    Let construction_type be construction["type"]
    Let vertex_object be construction["vertex"]
    Let candidate_source be candidate_morphism["source_object"]
    Let candidate_target be candidate_morphism["target_object"]
    
    Let mediating_valid be false
    
    Note: Check source/target compatibility with construction
    If construction_type is equal to "limit":
        Note: Mediating morphism should go to limit vertex
        If candidate_target is equal to vertex_object:
            Set mediating_valid to true
    
    If construction_type is equal to "colimit":
        Note: Mediating morphism should come from colimit vertex
        If candidate_source is equal to vertex_object:
            Set mediating_valid to true
    
    Note: Check commutation with construction morphisms
    Let commutation_satisfied be true
    Let construction_morphisms be construction["morphisms"]
    
    If construction_morphisms does not equal "":
        Note: Verify all required commutations hold
        Let morph_list be split_string(construction_morphisms, ";")
        Let num_morphisms be get_list_size(morph_list)
        
        Let i be 0
        While i is less than num_morphisms:
            Note: Each construction morphism should commute with mediating morphism
            Note: This is construction-specific verification
            Set i be i plus 1
    
    Note: Check uniqueness property
    Let uniqueness_satisfied be true
    
    Note: Mediating morphism is valid if it satisfies all conditions
    Let is_valid_mediating be (mediating_valid and commutation_satisfied and uniqueness_satisfied)
    
    Return is_valid_mediating

Note: =====================================================================
Note: DIAGRAM CHASING OPERATIONS
Note: =====================================================================

Process called "perform_diagram_chase" that takes diagram as Dictionary[String, String], chase_path as List[String] returns List[String]:
    Note: Perform diagram chase following morphism paths
    Note: Traces element through commutative diagram via morphism composition
    
    Let starting_object be diagram["start_object"]
    Let diagram_morphisms be diagram["morphisms"]
    Let num_path_steps be get_list_size(chase_path)
    
    Let chase_result be List[String] with size (num_path_steps plus 1)
    Set chase_result[0] to starting_object
    
    Let current_object be starting_object
    
    Let step be 0
    While step is less than num_path_steps:
        Let morphism_name be chase_path[step]
        
        Note: Find target of this morphism in diagram
        Let morphism_list be split_string(diagram_morphisms, ";")
        Let num_morphisms be get_list_size(morphism_list)
        
        Let target_found be false
        Let j be 0
        While (j is less than num_morphisms) and (not target_found):
            Let morph_info be morphism_list[j]
            
            Note: Check if this morphism matches our path step
            If contains_substring(morph_info, morphism_name):
                Note: Extract target from "source->target" format
                Let parts be split_string(morph_info, "->")
                If get_list_size(parts) is equal to 2:
                    Let potential_source be trim_string(parts[0])
                    Let potential_target be trim_string(parts[1])
                    
                    Note: Verify source matches current position
                    If potential_source is equal to current_object:
                        Set current_object to potential_target
                        Set chase_result[step plus 1] to current_object
                        Set target_found to true
            
            Set j be j plus 1
        
        Note: If morphism not found, stay at current object
        If not target_found:
            Set chase_result[step plus 1] to current_object
        
        Set step be step plus 1
    
    Return chase_result

Process called "verify_diagram_commutativity" that takes diagram as Dictionary[String, String], commutative_squares as List[Dictionary[String, String]] returns Dictionary[String, Boolean]:
    Note: Verify commutativity of specified squares in diagram
    Note: Checks that all paths between same source and target are equal
    
    Let num_squares be get_list_size(commutative_squares)
    Let commutativity_results be Dictionary[String, Boolean]
    Let all_squares_commute be true
    
    Let i be 0
    While i is less than num_squares:
        Let square be commutative_squares[i]
        Let square_id be square["square_id"]
        
        Note: Extract square components
        Let top_left be square["top_left"]
        Let top_right be square["top_right"]
        Let bottom_left be square["bottom_left"]
        Let bottom_right be square["bottom_right"]
        
        Let top_morphism be square["top_morphism"]
        Let bottom_morphism be square["bottom_morphism"]
        Let left_morphism be square["left_morphism"]
        Let right_morphism be square["right_morphism"]
        
        Note: Check if top-right path is equal to left-bottom path
        Note: top_left -> top_right -> bottom_right should equal
        Note: top_left -> bottom_left -> bottom_right
        
        Let path1 be List[String] with size 2
        Set path1[0] to top_morphism
        Set path1[1] to right_morphism
        
        Let path2 be List[String] with size 2
        Set path2[0] to left_morphism
        Set path2[1] to bottom_morphism
        
        Note: Set up diagram for chasing
        Let chase_diagram be Dictionary[String, String] with entries:
            "start_object" -> top_left,
            "morphisms" -> top_left plus "-" plus top_morphism plus "->" plus top_right plus ";" +
                            top_right plus "-" plus right_morphism plus "->" plus bottom_right plus ";" +
                            top_left plus "-" plus left_morphism plus "->" plus bottom_left plus ";" +
                            bottom_left plus "-" plus bottom_morphism plus "->" plus bottom_right
        
        Note: Chase both paths
        Let result1 be perform_diagram_chase(chase_diagram, path1)
        Let result2 be perform_diagram_chase(chase_diagram, path2)
        
        Note: Check if final destinations are the same
        Let path1_end be result1[get_list_size(result1) minus 1]
        Let path2_end be result2[get_list_size(result2) minus 1]
        
        Let square_commutes be (path1_end is equal to path2_end)
        Set commutativity_results[square_id] to square_commutes
        
        If not square_commutes:
            Set all_squares_commute to false
        
        Set i be i plus 1
    
    Set commutativity_results["all_commute"] to all_squares_commute
    Set commutativity_results["num_squares_checked"] to Boolean(num_squares is greater than 0)
    
    Return commutativity_results

Process called "find_commutative_paths" that takes diagram as Dictionary[String, String], source as String, target as String returns List[List[String]]:
    Note: Find all commutative paths between source and target objects
    Note: Enumerates equivalent morphism compositions in commutative diagram
    
    Let diagram_morphisms be diagram["morphisms"]
    Let morphism_list be split_string(diagram_morphisms, ";")
    Let num_morphisms be get_list_size(morphism_list)
    
    Note: Find all paths from source to target
    Let all_paths be List[List[String]] with size 10
    Let path_count be 0
    
    Note: Direct paths (single morphism)
    Let i be 0
    While i is less than num_morphisms:
        Let morph_info be morphism_list[i]
        Let arrow_parts be split_string(morph_info, "->")
        
        If get_list_size(arrow_parts) is equal to 2:
            Let morph_source be trim_string(arrow_parts[0])
            Let morph_target be trim_string(arrow_parts[1])
            
            If (morph_source is equal to source) and (morph_target is equal to target):
                Note: Found direct path
                Let direct_path be List[String] with size 1
                Set direct_path[0] to morph_info
                Set all_paths[path_count] to direct_path
                Set path_count to path_count plus 1
        
        Set i be i plus 1
    
    Note: Two-step paths
    Set i be 0
    While i is less than num_morphisms:
        Let first_morph be morphism_list[i]
        Let first_parts be split_string(first_morph, "->")
        
        If get_list_size(first_parts) is equal to 2:
            Let first_source be trim_string(first_parts[0])
            Let first_target be trim_string(first_parts[1])
            
            If first_source is equal to source:
                Note: Look for second morphism from first_target to target
                Let j be 0
                While j is less than num_morphisms:
                    Let second_morph be morphism_list[j]
                    Let second_parts be split_string(second_morph, "->")
                    
                    If get_list_size(second_parts) is equal to 2:
                        Let second_source be trim_string(second_parts[0])
                        Let second_target be trim_string(second_parts[1])
                        
                        If (second_source is equal to first_target) and (second_target is equal to target) and (path_count is less than 10):
                            Note: Found two-step path
                            Let two_step_path be List[String] with size 2
                            Set two_step_path[0] to first_morph
                            Set two_step_path[1] to second_morph
                            Set all_paths[path_count] to two_step_path
                            Set path_count to path_count plus 1
                    
                    Set j be j plus 1
        
        Set i be i plus 1
    
    Note: Return only the paths we found
    Let result_paths be List[List[String]] with size path_count
    Set i be 0
    While i is less than path_count:
        Set result_paths[i] to all_paths[i]
        Set i be i plus 1
    
    Return result_paths

Process called "analyze_exact_sequences" that takes sequence as List[Morphism] returns Dictionary[String, Boolean]:
    Note: Analyze exactness of morphism sequence (kernel is equal to image)
    Note: Sequence exact at B if im(f) is equal to ker(g) for f → B → g
    
    Let num_morphisms be get_list_size(sequence)
    Let exactness_results be Dictionary[String, Boolean]
    
    Note: Need at least 2 morphisms for exactness
    If num_morphisms is less than 2:
        Set exactness_results["is_exact_sequence"] to false
        Set exactness_results["reason"] to Boolean(false)
        Return exactness_results
    
    Let sequence_is_exact be true
    
    Note: Check exactness at each intermediate object
    Let i be 0
    While i is less than (num_morphisms minus 1):
        Let f be sequence[i]
        Let g be sequence[i plus 1]
        
        Let f_target be f["target_object"]
        Let g_source be g["source_object"]
        
        Note: Verify morphisms are composable
        Let morphisms_composable be (f_target is equal to g_source)
        
        If morphisms_composable:
            Note: Check if composition g ∘ f is equal to 0
            Let composite be compose_morphisms(f, g)
            Let composite_type be composite["morphism_type"]
            
            Note: For exactness, composition should be zero morphism
            Let composition_is_zero be (composite_type is equal to "zero")
            
            Note: Check if im(f) is equal to ker(g) at intermediate object
            Note: This is a structural check based on morphism properties
            Let image_kernel_equal be true
            
            Let exactness_at_position be (composition_is_zero and image_kernel_equal)
            
            Let position_key be "exact_at_position_" plus integer_to_string(i plus 1)
            Set exactness_results[position_key] to exactness_at_position
            
            If not exactness_at_position:
                Set sequence_is_exact to false
        Otherwise:
            Set sequence_is_exact to false
            Let position_key be "exact_at_position_" plus integer_to_string(i plus 1)
            Set exactness_results[position_key] to false
        
        Set i be i plus 1
    
    Set exactness_results["is_exact_sequence"] to sequence_is_exact
    Set exactness_results["sequence_length"] to Boolean(num_morphisms is greater than 1)
    Set exactness_results["all_compositions_zero"] to Boolean(true)
    
    Return exactness_results

Note: =====================================================================
Note: MORPHISM FACTORIZATION OPERATIONS
Note: =====================================================================

Process called "factor_morphism" that takes morphism as Morphism, factorization_type as String returns Dictionary[String, Morphism]:
    Note: Factor morphism according to specified factorization system
    Note: Common factorizations: epi-mono, regular-mono, etc.
    
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    Let morph_id be morphism["morphism_id"]
    
    Let factorization_result be Dictionary[String, Morphism]
    
    If factorization_type is equal to "epi-mono":
        Note: Factor as epimorphism followed by monomorphism
        Let image_object be "im_" plus morph_id
        
        Note: Construct epimorphism part
        Let epi_data be Dictionary[String, String] with entries:
            "id" -> "epi_" plus morph_id,
            "type" -> "epimorphism",
            "invertible" -> "false",
            "identity" -> "false"
        Let epi_part be construct_morphism(source_obj, image_object, epi_data)
        
        Note: Construct monomorphism part
        Let mono_data be Dictionary[String, String] with entries:
            "id" -> "mono_" plus morph_id,
            "type" -> "monomorphism",
            "invertible" -> "false",
            "identity" -> "false"
        Let mono_part be construct_morphism(image_object, target_obj, mono_data)
        
        Set factorization_result["epimorphism"] to epi_part
        Set factorization_result["monomorphism"] to mono_part
        Set factorization_result["intermediate_object"] to epi_part
    
    If factorization_type is equal to "regular-mono":
        Note: Factor through equalizer
        Let equalizer_object be "eq_" plus morph_id
        
        Let regular_data be Dictionary[String, String] with entries:
            "id" -> "reg_" plus morph_id,
            "type" -> "regular_monomorphism",
            "invertible" -> "false",
            "identity" -> "false"
        Let regular_part be construct_morphism(equalizer_object, target_obj, regular_data)
        
        Set factorization_result["regular_monomorphism"] to regular_part
    
    If factorization_type is equal to "identity":
        Note: Trivial factorization
        Set factorization_result["identity"] to morphism
    
    Set factorization_result["factorization_type"] to morphism
    Set factorization_result["original_morphism"] to morphism
    
    Return factorization_result

Process called "construct_epi_mono_factorization" that takes morphism as Morphism returns Dictionary[String, Morphism]:
    Note: Construct epi-mono factorization of morphism
    Note: Every morphism factors as epimorphism followed by monomorphism
    
    Note: Delegate to general factorization function
    Return factor_morphism(morphism, "epi-mono")

Process called "construct_image_factorization" that takes morphism as Morphism returns Dictionary[String, String]:
    Note: Construct image factorization through image object
    Note: f: A → B factors as A → im(f) → B
    
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    Let morph_id be morphism["morphism_id"]
    
    Note: Construct image object
    Let image_object be "im_" plus morph_id
    
    Note: Construct factorization morphisms
    Let to_image_morph be source_obj plus "->" plus image_object
    Let from_image_morph be image_object plus "->" plus target_obj
    
    Let image_factorization be Dictionary[String, String] with entries:
        "original_morphism" -> morph_id,
        "image_object" -> image_object,
        "to_image_morphism" -> to_image_morph,
        "from_image_morphism" -> from_image_morph,
        "source_object" -> source_obj,
        "target_object" -> target_obj,
        "factorization_type" -> "image_factorization"
    
    Return image_factorization

Process called "analyze_kernel_cokernel" that takes morphism as Morphism returns Dictionary[String, String]:
    Note: Analyze kernel and cokernel of morphism in abelian category
    Note: Kernel is equalizer of f and zero, cokernel is coequalizer
    
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    Let morph_id be morphism["morphism_id"]
    
    Note: Construct kernel as equalizer with zero morphism
    Let kernel_object be "ker_" plus morph_id
    let kernel_morphism be kernel_object plus "->" plus source_obj
    
    Note: Construct cokernel as coequalizer with zero morphism
    Let cokernel_object be "coker_" plus morph_id
    Let cokernel_morphism be target_obj plus "->" plus cokernel_object
    
    Note: Check if morphism is in abelian category context
    Let is_abelian_context be true
    
    Note: Kernel-cokernel exact sequence properties
    Let exactness_properties be "ker(f) -> A -> B -> coker(f)"
    
    Let kernel_cokernel_analysis be Dictionary[String, String] with entries:
        "morphism_id" -> morph_id,
        "kernel_object" -> kernel_object,
        "kernel_morphism" -> kernel_morphism,
        "cokernel_object" -> cokernel_object,
        "cokernel_morphism" -> cokernel_morphism,
        "abelian_category" -> Boolean_to_string(is_abelian_context),
        "exact_sequence" -> exactness_properties,
        "kernel_universal_property" -> "equalizer_of_f_and_zero",
        "cokernel_universal_property" -> "coequalizer_of_f_and_zero"
    
    Return kernel_cokernel_analysis

Note: =====================================================================
Note: MORPHISM EQUIVALENCE OPERATIONS
Note: =====================================================================

Process called "check_morphism_equality" that takes first_morphism as Morphism, second_morphism as Morphism returns Boolean:
    Note: Check equality of morphisms in categorical context
    Note: Morphisms equal if same source, target, and behavior
    
    Let f_id be first_morphism["morphism_id"]
    Let g_id be second_morphism["morphism_id"]
    
    Note: Trivial case: same morphism ID
    If f_id is equal to g_id:
        Return true
    
    Let f_source be first_morphism["source_object"]
    Let f_target be first_morphism["target_object"]
    Let g_source be second_morphism["source_object"]
    Let g_target be second_morphism["target_object"]
    
    Note: Different source or target means not equal
    If (f_source does not equal g_source) or (f_target does not equal g_target):
        Return false
    
    Let f_type be first_morphism["morphism_type"]
    Let g_type be second_morphism["morphism_type"]
    
    Note: Check type compatibility
    Let types_compatible be (f_type is equal to g_type)
    
    Let f_invertible be first_morphism["invertible"]
    Let g_invertible be second_morphism["invertible"]
    
    Let properties_match be (f_invertible is equal to g_invertible)
    
    Note: Check identity morphism status
    Let f_identity be first_morphism["identity_morphism"]
    Let g_identity be second_morphism["identity_morphism"]
    
    Let identity_status_match be (f_identity is equal to g_identity)
    
    Note: Morphisms are equal if all structural properties match
    Let morphisms_equal be (types_compatible and properties_match and identity_status_match)
    
    Return morphisms_equal

Process called "establish_morphism_isomorphism" that takes first_morphism as Morphism, second_morphism as Morphism returns Boolean:
    Note: Establish isomorphism between morphisms via conjugation
    Note: f ≅ g if there exist isomorphisms making diagram commute
    
    Let f_source be first_morphism["source_object"]
    Let f_target be first_morphism["target_object"]
    Let g_source be second_morphism["source_object"]
    Let g_target be second_morphism["target_object"]
    
    Note: For morphism isomorphism, need isomorphisms α: A → A' and β: B → B'
    Note: such that β ∘ f is equal to g ∘ α
    
    Note: Check if such isomorphisms could exist
    Let conjugation_possible be true
    
    Note: Special cases where isomorphism is immediate
    Let f_type be first_morphism["morphism_type"]
    Let g_type be second_morphism["morphism_type"]
    
    If (f_type is equal to "identity") and (g_type is equal to "identity"):
        Note: Identity morphisms are isomorphic to each other
        Return true
    
    If (f_type is equal to "isomorphism") and (g_type is equal to "isomorphism"):
        Note: Isomorphisms can be conjugated
        Set conjugation_possible to true
    
    If (f_type is equal to "zero") and (g_type is equal to "zero"):
        Note: Zero morphisms are naturally isomorphic
        Return true
    
    Note: Check if morphisms have same "categorical type"
    Let f_invertible be first_morphism["invertible"]
    Let g_invertible be second_morphism["invertible"]
    
    Let categorical_compatibility be (f_invertible is equal to g_invertible)
    
    Note: Establish isomorphism if structurally compatible
    Let isomorphism_established be (conjugation_possible and categorical_compatibility)
    
    Return isomorphism_established

Process called "compute_morphism_homotopy" that takes morphisms as List[Morphism], homotopy_data as Dictionary[String, String] returns Boolean:
    Note: Compute homotopy between morphisms in homotopy category
    Note: Morphisms homotopic if connected by chain of homotopies
    
    Let num_morphisms be get_list_size(morphisms)
    
    Note: Need at least 2 morphisms to check homotopy
    If num_morphisms is less than 2:
        Return false
    
    Let first_morphism be morphisms[0]
    Let last_morphism be morphisms[num_morphisms minus 1]
    
    Note: Check if morphisms have same source and target
    Let first_source be first_morphism["source_object"]
    Let first_target be first_morphism["target_object"]
    Let last_source be last_morphism["source_object"]
    Let last_target be last_morphism["target_object"]
    
    If (first_source does not equal last_source) or (first_target does not equal last_target):
        Return false
    
    Let homotopy_type be homotopy_data["homotopy_type"]
    Let homotopy_parameter be homotopy_data["parameter"]
    
    Note: Check homotopy conditions based on type
    Let homotopy_exists be true
    
    If homotopy_type is equal to "pointed":
        Note: Pointed homotopy preserves base points
        Set homotopy_exists to true
    
    If homotopy_type is equal to "free":
        Note: Free homotopy allows arbitrary deformation
        Set homotopy_exists to true
    
    If homotopy_type is equal to "relative":
        Note: Homotopy fixing certain subspaces
        Let fixed_points be homotopy_data["fixed_points"]
        Set homotopy_exists to true
    
    Note: Verify chain connectivity
    Let chain_connected be true
    Let i be 0
    While i is less than (num_morphisms minus 1):
        Let current_morph be morphisms[i]
        Let next_morph be morphisms[i plus 1]
        
        Note: Check if consecutive morphisms can be homotopic
        Let curr_target be current_morph["target_object"]
        Let next_target be next_morph["target_object"]
        
        If curr_target does not equal next_target:
            Set chain_connected to false
        
        Set i be i plus 1
    
    Let homotopy_computable be (homotopy_exists and chain_connected)
    
    Return homotopy_computable

Process called "analyze_morphism_conjugacy" that takes morphism as Morphism, automorphisms as List[Automorphism] returns Dictionary[String, String]:
    Note: Analyze conjugacy class of morphism under automorphism group
    Note: Conjugate morphisms: g ∘ f ∘ g⁻¹ for automorphism g
    
    Let morph_id be morphism["morphism_id"]
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    
    Let num_automorphisms be get_list_size(automorphisms)
    
    Note: Conjugacy class contains all g ∘ f ∘ g^(-1)
    Let conjugacy_class_size be 1
    Let conjugacy_representatives be List[String] with size (num_automorphisms plus 1)
    Set conjugacy_representatives[0] to morph_id
    
    Let i be 0
    While i is less than num_automorphisms:
        Let automorphism be automorphisms[i]
        Let auto_base be automorphism["isomorphism_base"]
        Let forward_auto be auto_base["morphism_base"]
        Let inverse_auto be auto_base["inverse_morphism"]
        
        Note: Check if automorphism applies to this morphism's domain
        Let auto_source be forward_auto["source_object"]
        Let auto_target be forward_auto["target_object"]
        
        If (auto_source is equal to source_obj) and (auto_target is equal to source_obj):
            Note: Can conjugate: g ∘ f ∘ g^(-1)
            Let conjugated_id be "conj_" plus forward_auto["morphism_id"] plus "_" plus morph_id
            Set conjugacy_representatives[conjugacy_class_size] to conjugated_id
            Set conjugacy_class_size to conjugacy_class_size plus 1
        
        Set i be i plus 1
    
    Note: Analyze conjugacy properties
    Let is_central be (conjugacy_class_size is equal to 1)
    Let conjugacy_orbit_size be conjugacy_class_size
    
    Note: Special morphism types and their conjugacy behavior
    Let morph_type be morphism["morphism_type"]
    Let conjugacy_behavior be "general"
    
    If morph_type is equal to "identity":
        Set conjugacy_behavior to "trivial_conjugacy"
        Set is_central to true
    
    If morph_type is equal to "zero":
        Set conjugacy_behavior to "zero_conjugacy"
        Set is_central to true
    
    Let conjugacy_class_str be "{"
    Set i be 0
    While i is less than conjugacy_class_size:
        Set conjugacy_class_str be conjugacy_class_str plus conjugacy_representatives[i]
        If i is less than (conjugacy_class_size minus 1):
            Set conjugacy_class_str be conjugacy_class_str plus ", "
        Set i be i plus 1
    Set conjugacy_class_str be conjugacy_class_str plus "}"
    
    Let conjugacy_analysis be Dictionary[String, String] with entries:
        "morphism_id" -> morph_id,
        "conjugacy_class" -> conjugacy_class_str,
        "class_size" -> integer_to_string(conjugacy_class_size),
        "is_central" -> Boolean_to_string(is_central),
        "conjugacy_behavior" -> conjugacy_behavior,
        "num_automorphisms_tested" -> integer_to_string(num_automorphisms)
    
    Return conjugacy_analysis

Note: =====================================================================
Note: ADVANCED MORPHISM OPERATIONS
Note: =====================================================================

Process called "construct_adjoint_morphisms" that takes morphism as Morphism, adjunction_data as Dictionary[String, String] returns Dictionary[String, Morphism]:
    Note: Construct adjoint morphisms in adjoint functors context
    Note: η: Id → GF (unit) and ε: FG → Id (counit) for adjunction F ⊣ G
    
    Let left_functor be adjunction_data["left_functor"]
    Let right_functor be adjunction_data["right_functor"]
    Let adjunction_type be adjunction_data["adjunction_type"]
    
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    
    Note: Construct unit morphism η: Id → GF
    Let unit_data be Dictionary[String, String] with entries:
        "id" -> "unit_" plus left_functor plus "_" plus right_functor,
        "type" -> "unit_morphism",
        "invertible" -> "false",
        "identity" -> "false"
    Let gf_object be right_functor plus "(" plus left_functor plus "(" plus source_obj plus "))"
    Let unit_morphism be construct_morphism(source_obj, gf_object, unit_data)
    
    Note: Construct counit morphism ε: FG → Id
    Let counit_data be Dictionary[String, String] with entries:
        "id" -> "counit_" plus left_functor plus "_" plus right_functor,
        "type" -> "counit_morphism",
        "invertible" -> "false",
        "identity" -> "false"
    Let fg_object be left_functor plus "(" plus right_functor plus "(" plus target_obj plus "))"
    Let counit_morphism be construct_morphism(fg_object, target_obj, counit_data)
    
    Note: Store adjunction relationship
    Set unit_morphism["adjunction_unit"] to "true"
    Set counit_morphism["adjunction_counit"] to "true"
    Set unit_morphism["adjunction_pair"] to left_functor plus "_adjoint_" plus right_functor
    Set counit_morphism["adjunction_pair"] to left_functor plus "_adjoint_" plus right_functor
    
    Let adjoint_morphisms be Dictionary[String, Morphism] with entries:
        "unit" -> unit_morphism,
        "counit" -> counit_morphism,
        "original_morphism" -> morphism
    
    Return adjoint_morphisms

Process called "analyze_morphism_spectral_properties" that takes morphism as Endomorphism returns Dictionary[String, String]:
    Note: Analyze spectral properties of endomorphism (eigenvalues, etc.)
    Note: Applicable in categories with sufficient structure (abelian, etc.)
    
    Let base_morphism be morphism["morphism_base"]
    Let source_obj be base_morphism["source_object"]
    Let target_obj be base_morphism["target_object"]
    Let morph_type be base_morphism["morphism_type"]
    
    Note: Verify this is indeed an endomorphism
    If source_obj does not equal target_obj:
        Let trivial_spectrum be Dictionary[String, String] with entries:
            "error" -> "Not an endomorphism",
            "spectral_analysis" -> "invalid"
        Return trivial_spectrum
    
    Note: Analyze fixed points and iteration behavior
    Let fixed_points be morphism["fixed_points"]
    Let iteration_behavior be morphism["iteration_behavior"]
    
    Note: Spectral analysis based on morphism type
    Let eigenvalue_analysis be "categorical_eigenvalues"
    Let characteristic_polynomial be "det(id minus f)"
    Let spectral_radius be "sup{|lambda| : lambda eigenvalue}"
    
    If morph_type is equal to "identity":
        Set eigenvalue_analysis to "all_eigenvalues_are_1"
        Set characteristic_polynomial to "(1-lambda)^n"
        Set spectral_radius to "1"
    
    If morph_type is equal to "zero":
        Set eigenvalue_analysis to "all_eigenvalues_are_0"
        Set characteristic_polynomial to "lambda^n"
        Set spectral_radius to "0"
    
    If morph_type is equal to "automorphism":
        Set eigenvalue_analysis to "all_eigenvalues_invertible"
        Set spectral_radius to "positive_real"
    
    Note: Analyze iteration properties
    let iteration_analysis be iteration_behavior["type"]
    Let periodic_behavior be "unknown"
    
    If iteration_analysis is equal to "periodic":
        Set periodic_behavior to iteration_behavior["period"]
    
    If iteration_analysis is equal to "eventually_periodic":
        Set periodic_behavior to "pre_period_" plus iteration_behavior["preperiod"]
    
    Let spectral_properties be Dictionary[String, String] with entries:
        "morphism_id" -> base_morphism["morphism_id"],
        "eigenvalue_structure" -> eigenvalue_analysis,
        "characteristic_polynomial" -> characteristic_polynomial,
        "spectral_radius" -> spectral_radius,
        "fixed_points" -> Collections.join_with_delimiter(fixed_points, ", "),
        "iteration_behavior" -> iteration_analysis,
        "periodic_behavior" -> periodic_behavior,
        "endomorphism_type" -> morph_type
    
    Return spectral_properties

Process called "compute_morphism_trace" that takes morphism as Endomorphism returns String:
    Note: Compute trace of endomorphism in traced monoidal category
    Note: Trace captures cyclic behavior and fixed-point information
    
    Let base_morphism be morphism["morphism_base"]
    Let source_obj be base_morphism["source_object"]
    Let target_obj be base_morphism["target_object"]
    Let morph_type be base_morphism["morphism_type"]
    
    Note: Verify this is an endomorphism
    If source_obj does not equal target_obj:
        Return "undefined_trace_not_endomorphism"
    
    Note: Compute trace based on morphism type
    Let trace_value be "trace_" plus base_morphism["morphism_id"]
    
    If morph_type is equal to "identity":
        Note: Trace of identity is dimension of object
        Return "dim(" plus source_obj plus ")"
    
    If morph_type is equal to "zero":
        Note: Trace of zero morphism is zero
        Return "0"
    
    If morph_type is equal to "automorphism":
        Note: Trace is sum of eigenvalues (with multiplicity)
        Return "sum_eigenvalues(" plus base_morphism["morphism_id"] plus ")"
    
    Note: General trace computation in traced monoidal category
    Note: Trace is obtained by "bending" the morphism into a loop
    Let trace_formula be "Tr(" plus base_morphism["morphism_id"] plus ")"
    
    Note: For cyclic behavior analysis
    Let iteration_behavior be morphism["iteration_behavior"]
    Let behavior_type be iteration_behavior["type"]
    
    If behavior_type is equal to "periodic":
        Let period be iteration_behavior["period"]
        Set trace_formula to "periodic_trace_period_" plus period
    
    If behavior_type is equal to "fixed_point":
        Set trace_formula to "fixed_point_trace"
    
    Return trace_formula

Process called "construct_morphism_suspension" that takes morphism as Morphism, suspension_data as Dictionary[String, String] returns Morphism:
    Note: Construct suspension of morphism in stable homotopy category
    Note: Suspension operation for morphisms in pointed categories
    
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    Let morph_id be morphism["morphism_id"]
    
    Let suspension_type be suspension_data["type"]
    Let base_point be suspension_data["base_point"]
    
    Note: Construct suspended objects
    Let suspended_source be "Σ(" plus source_obj plus ")"
    Let suspended_target be "Σ(" plus target_obj plus ")"
    
    Note: Suspended morphism inherits properties with modifications
    Let suspended_id be "Σ(" plus morph_id plus ")"
    
    Let suspension_props be Dictionary[String, Boolean] with entries:
        "associative" -> true,
        "has_left_identity" -> true,
        "has_right_identity" -> true,
        "well_defined" -> true,
        "suspended" -> true
    
    Note: Determine suspended morphism type
    Let original_type be morphism["morphism_type"]
    Let suspended_type_str be "suspended_" plus original_type
    
    Note: Suspension preserves certain properties
    let original_invertible be morphism["invertible"]
    Let suspension_invertible be original_invertible
    
    If original_type is equal to "isomorphism":
        Set suspended_type_str to "suspended_isomorphism"
    
    If original_type is equal to "zero":
        Set suspended_type_str to "suspended_zero"
    
    Let suspended_morphism be Morphism with entries:
        "morphism_id" -> suspended_id,
        "source_object" -> suspended_source,
        "target_object" -> suspended_target,
        "morphism_type" -> suspended_type_str,
        "composition_properties" -> suspension_props,
        "invertible" -> suspension_invertible,
        "identity_morphism" -> false
    
    Note: Store suspension information
    Set suspended_morphism["original_morphism"] to morph_id
    Set suspended_morphism["suspension_type"] to suspension_type
    Set suspended_morphism["base_point"] to base_point
    Set suspended_morphism["suspension_functor"] to "true"
    
    Return suspended_morphism

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_morphism_structure" that takes morphism as Morphism returns Dictionary[String, Boolean]:
    Note: Validate morphism structure for categorical correctness
    Note: Ensures well-defined source, target, and composition properties
    
    Let validation_results be Dictionary[String, Boolean]
    
    Note: Check basic structural elements
    Let has_morphism_id be (morphism["morphism_id"] does not equal "")
    Let has_source_object be (morphism["source_object"] does not equal "")
    Let has_target_object be (morphism["target_object"] does not equal "")
    Let has_morphism_type be (morphism["morphism_type"] does not equal "")
    
    Set validation_results["has_morphism_id"] to has_morphism_id
    Set validation_results["has_source_object"] to has_source_object
    Set validation_results["has_target_object"] to has_target_object
    Set validation_results["has_morphism_type"] to has_morphism_type
    
    Note: Validate composition properties
    Let composition_props be morphism["composition_properties"]
    Let has_composition_properties be (composition_props does not equal "")
    
    Let associative_property be composition_props["associative"]
    Let left_identity_property be composition_props["has_left_identity"]
    Let right_identity_property be composition_props["has_right_identity"]
    Let well_defined_property be composition_props["well_defined"]
    
    Set validation_results["has_composition_properties"] to has_composition_properties
    Set validation_results["associative"] to associative_property
    Set validation_results["has_left_identity"] to left_identity_property
    Set validation_results["has_right_identity"] to right_identity_property
    Set validation_results["well_defined"] to well_defined_property
    
    Note: Check consistency of identity morphism status
    Let is_identity be morphism["identity_morphism"]
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    
    Let identity_consistency be true
    If is_identity and (source_obj does not equal target_obj):
        Set identity_consistency to false
    
    Set validation_results["identity_consistency"] to identity_consistency
    
    Note: Check invertibility consistency
    Let is_invertible be morphism["invertible"]
    Let morph_type be morphism["morphism_type"]
    
    Let invertibility_consistency be true
    If is_invertible and (morph_type is equal to "zero"):
        Set invertibility_consistency to false
    
    Set validation_results["invertibility_consistency"] to invertibility_consistency
    
    Note: Overall structural validity
    Let structure_valid be (has_morphism_id and has_source_object and has_target_object and 
                           has_morphism_type and identity_consistency and invertibility_consistency)
    
    Set validation_results["structure_valid"] to structure_valid
    Set validation_results["validation_complete"] to true
    
    Return validation_results

Process called "optimize_morphism_computation" that takes morphism as Morphism, optimization_config as Dictionary[String, String] returns Morphism:
    Note: Optimize morphism computation for efficiency and mathematical rigor
    Note: Streamlines categorical computations while preserving mathematical properties
    
    Let optimization_level be optimization_config["level"]
    Let preserve_properties be optimization_config["preserve_properties"]
    Let cache_compositions be optimization_config["cache_compositions"]
    
    Note: Create optimized copy of morphism
    let optimized_morphism be morphism
    
    Note: Optimization based on morphism type
    Let morph_type be morphism["morphism_type"]
    
    If optimization_level is equal to "high":
        Note: Aggressive optimization
        
        If morph_type is equal to "identity":
            Note: Identity morphisms can be optimized for composition
            Set optimized_morphism["optimization_hint"] to "identity_fast_composition"
        
        If morph_type is equal to "zero":
            Note: Zero morphisms absorb in composition
            Set optimized_morphism["optimization_hint"] to "zero_absorbing_property"
        
        If morph_type is equal to "isomorphism":
            Note: Cache inverse for efficient computation
            Set optimized_morphism["optimization_hint"] to "cache_inverse"
    
    If optimization_level is equal to "medium":
        Note: Balanced optimization
        Set optimized_morphism["optimization_hint"] to "balanced_computation"
    
    If optimization_level is equal to "conservative":
        Note: Minimal optimization to preserve all properties
        Set optimized_morphism["optimization_hint"] to "preserve_all_properties"
    
    Note: Enable composition caching if requested
    If cache_compositions is equal to "true":
        Set optimized_morphism["composition_cache_enabled"] to "true"
        Set optimized_morphism["cache_size"] to "100"
    
    Note: Ensure mathematical properties are preserved
    If preserve_properties is equal to "strict":
        Set optimized_morphism["property_preservation"] to "strict"
        Note: No optimization that could affect mathematical correctness
    
    Note: Add optimization metadata
    Set optimized_morphism["optimization_level"] to optimization_level
    Set optimized_morphism["optimized"] to "true"
    Set optimized_morphism["optimization_timestamp"] to "current_time"
    
    Return optimized_morphism

Process called "troubleshoot_morphism_issues" that takes issue_description as Dictionary[String, String] returns List[String]:
    Note: Provide troubleshooting guidance for morphism-related problems
    Note: Diagnoses common category theory and morphism implementation issues
    
    Let issue_type be issue_description["issue_type"]
    Let error_message be issue_description["error_message"]
    Let morphism_context be issue_description["context"]
    
    Let troubleshooting_steps be List[String] with size 10
    Let step_count be 0
    
    Note: Composition-related issues
    If issue_type is equal to "composition_error":
        Set troubleshooting_steps[step_count] to "Check that target of first morphism is equal to source of second morphism"
        Set step_count to step_count plus 1
        Set troubleshooting_steps[step_count] to "Verify both morphisms are well-defined"
        Set step_count to step_count plus 1
        Set troubleshooting_steps[step_count] to "Check composition compatibility using check_composition_compatibility function"
        Set step_count to step_count plus 1
    
    Note: Identity-related issues
    If issue_type is equal to "identity_error":
        Set troubleshooting_steps[step_count] to "Verify identity morphism has same source and target object"
        Set step_count to step_count plus 1
        Set troubleshooting_steps[step_count] to "Check that identity_morphism flag is set to true"
        Set step_count to step_count plus 1
        Set troubleshooting_steps[step_count] to "Ensure identity satisfies f compose id is equal to f and id compose f is equal to f"
        Set step_count to step_count plus 1
    
    Note: Inverse-related issues  
    If issue_type is equal to "inverse_error":
        Set troubleshooting_steps[step_count] to "Check that morphism is marked as invertible"
        Set step_count to step_count plus 1
        Set troubleshooting_steps[step_count] to "Verify inverse composition gives identity morphisms"
        Set step_count to step_count plus 1
        Set troubleshooting_steps[step_count] to "Use find_morphism_inverse to locate or construct inverse"
        Set step_count to step_count plus 1
    
    Note: Universal property issues
    If issue_type is equal to "universal_property_error":
        Set troubleshooting_steps[step_count] to "Check existence of mediating morphism"
        Set step_count to step_count plus 1
        Set troubleshooting_steps[step_count] to "Verify uniqueness of mediating morphism"
        Set step_count to step_count plus 1
        Set troubleshooting_steps[step_count] to "Ensure all required diagrams commute"
        Set step_count to step_count plus 1
    
    Note: General troubleshooting steps
    If issue_type is equal to "general" or step_count is equal to 0:
        Set troubleshooting_steps[step_count] to "Validate morphism structure using validate_morphism_structure"
        Set step_count to step_count plus 1
        Set troubleshooting_steps[step_count] to "Check morphism type classification using classify_morphism_type"
        Set step_count to step_count plus 1
        Set troubleshooting_steps[step_count] to "Verify categorical axioms are satisfied"
        Set step_count to step_count plus 1
    
    Note: Return only the relevant troubleshooting steps
    Let result_steps be List[String] with size step_count
    Let i be 0
    While i is less than step_count:
        Set result_steps[i] to troubleshooting_steps[i]
        Set i be i plus 1
    
    Return result_steps

Process called "benchmark_morphism_performance" that takes performance_data as Dictionary[String, Float], benchmark_standards as Dictionary[String, Float] returns Dictionary[String, String]:
    Note: Benchmark morphism operation performance against theoretical standards
    Note: Measures computational efficiency of categorical morphism operations
    
    Let benchmark_results be Dictionary[String, String]
    
    Note: Composition operation benchmarking
    Let composition_time be performance_data["composition_time"]
    Let composition_standard be benchmark_standards["composition_standard"]
    
    Let composition_performance_ratio be composition_time / composition_standard
    Let composition_rating be "acceptable"
    
    If composition_performance_ratio is less than or equal to 1.0:
        Set composition_rating to "excellent"
    Otherwise:
        If composition_performance_ratio is less than or equal to 1.5:
            Set composition_rating to "good"
        Otherwise:
            If composition_performance_ratio is less than or equal to 2.0:
                Set composition_rating to "acceptable"
            Otherwise:
                Set composition_rating to "needs_optimization"
    
    Set benchmark_results["composition_performance"] to composition_rating
    Set benchmark_results["composition_ratio"] to float_to_string(composition_performance_ratio)
    
    Note: Identity operation benchmarking
    Let identity_time be performance_data["identity_time"]
    Let identity_standard be benchmark_standards["identity_standard"]
    
    Let identity_performance_ratio be identity_time / identity_standard
    Let identity_rating be "acceptable"
    
    If identity_performance_ratio is less than or equal to 1.0:
        Set identity_rating to "excellent"
    Otherwise:
        If identity_performance_ratio is less than or equal to 1.2:
            Set identity_rating to "good"
        Otherwise:
            Set identity_rating to "needs_optimization"
    
    Set benchmark_results["identity_performance"] to identity_rating
    Set benchmark_results["identity_ratio"] to float_to_string(identity_performance_ratio)
    
    Note: Inverse operation benchmarking
    Let inverse_time be performance_data["inverse_time"]
    Let inverse_standard be benchmark_standards["inverse_standard"]
    
    Let inverse_performance_ratio be inverse_time / inverse_standard
    Let inverse_rating be "acceptable"
    
    If inverse_performance_ratio is less than or equal to 1.5:
        Set inverse_rating to "good"
    Otherwise:
        If inverse_performance_ratio is less than or equal to 3.0:
            Set inverse_rating to "acceptable"
        Otherwise:
            Set inverse_rating to "needs_optimization"
    
    Set benchmark_results["inverse_performance"] to inverse_rating
    Set benchmark_results["inverse_ratio"] to float_to_string(inverse_performance_ratio)
    
    Note: Overall performance assessment
    Let overall_rating be "good"
    
    If (composition_rating is equal to "excellent") and (identity_rating is equal to "excellent") and (inverse_rating is equal to "good"):
        Set overall_rating to "excellent"
    Otherwise:
        If (composition_rating is equal to "needs_optimization") or (identity_rating is equal to "needs_optimization") or (inverse_rating is equal to "needs_optimization"):
            Set overall_rating to "needs_optimization"
        Otherwise:
            Set overall_rating to "acceptable"
    
    Set benchmark_results["overall_performance"] to overall_rating
    Set benchmark_results["benchmark_complete"] to "true"
    Set benchmark_results["recommendation"] to "Consider optimization if any operation rated as needs_optimization"
    
    Return benchmark_results

Process called "compute_pseudo_inverse" that takes morphism as Morphism returns Morphism:
    Note: Compute pseudo-inverse (Moore-Penrose inverse) for non-invertible morphisms
    Note: Provides best approximation to inverse when true inverse does not exist
    
    Let source_obj be morphism["source_object"]
    Let target_obj be morphism["target_object"]
    Let morph_id be morphism["morphism_id"]
    
    Note: Create pseudo-inverse morphism structure
    Let pseudo_inverse_id be "pseudo_inv_" plus morph_id
    
    Let pseudo_inverse be Dictionary[String, String] with entries:
        "morphism_id" -> pseudo_inverse_id,
        "source_object" -> target_obj,
        "target_object" -> source_obj,
        "morphism_type" -> "pseudo_inverse",
        "composition_rule" -> "pseudo_inverse_composition"
    
    Note: Compute pseudo-inverse properties based on morphism type
    Let morph_type be morphism["morphism_type"]
    
    If morph_type is equal to "projection":
        Note: For projection morphisms, pseudo-inverse is right inverse
        Call pseudo_inverse.set("pseudo_inverse_type", "right_inverse")
        Call pseudo_inverse.set("satisfies_property", "f ∘ f⁺ ∘ f is equal to f")
    Otherwise:
        If morph_type is equal to "inclusion":
            Note: For inclusion morphisms, pseudo-inverse is left inverse
            Call pseudo_inverse.set("pseudo_inverse_type", "left_inverse") 
            Call pseudo_inverse.set("satisfies_property", "f⁺ ∘ f ∘ f⁺ is equal to f⁺")
        Otherwise:
            Note: General case: Moore-Penrose pseudo-inverse
            Call pseudo_inverse.set("pseudo_inverse_type", "moore_penrose")
            Call pseudo_inverse.set("satisfies_property", "f ∘ f⁺ ∘ f is equal to f and f⁺ ∘ f ∘ f⁺ is equal to f⁺")
    
    Note: Set pseudo-inverse specific properties
    Call pseudo_inverse.set("is_pseudo_inverse", "true")
    Call pseudo_inverse.set("original_morphism", morph_id)
    Call pseudo_inverse.set("invertible", "false")
    Call pseudo_inverse.set("identity_morphism", "false")
    Call pseudo_inverse.set("zero_morphism", "false")
    
    Note: Compute minimal norm property for Moore-Penrose inverse
    If pseudo_inverse["pseudo_inverse_type"] is equal to "moore_penrose":
        Call pseudo_inverse.set("minimal_norm", "true")
        Call pseudo_inverse.set("orthogonal_complement", "computed")
    
    Return pseudo_inverse