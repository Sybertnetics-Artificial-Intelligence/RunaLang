Note: 3D Surface Plotting Module

This module provides comprehensive 3D surface visualization and contour mapping capabilities.
Supports mathematical surface plotting, volume visualization, and advanced 3D graphics.

Mathematical Foundation:
- Surface functions: z is equal to f(x,y) and parametric surfaces r(u,v) is equal to [x(u,v), y(u,v), z(u,v)]
- Level surfaces: F(x,y,z) is equal to c for implicit surface definition
- Vector field visualization: 3D streamlines and flow visualization
- Surface differential geometry: curvature, normals, tangent planes
- Volume rendering: scalar field visualization with opacity mapping
- Isosurface extraction: marching cubes algorithm for level sets
- Surface lighting: Phong shading, texture mapping, material properties
- Projective geometry: perspective and orthographic projections

Applications include multivariable calculus, differential geometry, scientific visualization,
engineering design, medical imaging, and mathematical research.
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/geometry/computational" as ComputationalGeometry
Import module "math/engine/linalg/core" as LinearAlgebra
Import module "math/geometry/euclidean" as Euclidean
Import module "math/engine/numerical/interpolation" as Interpolation
Import module "math/core/operations" as MathOps
Import module "math/core/constants" as Constants
Import module "runatime/io/filesystem/file_operations" as FileOps
Import module "math/engine/numerical/ode" as ODE
Import module "math/geometry/differential" as DifferentialGeometry
Import module "math/dynamical/systems" as DynamicalSystems
Import module "app/graphics/3d/geometry/formats" as GeometryFormats
Import module "app/graphics/3d/geometry/simplification" as MeshSimplification
Import module "app/graphics/3d/lighting/volumetric" as VolumetricLighting
Import module "science/physics/classical/fluids" as Fluids
Import module "app/graphics/3d/geometry/subdivision" as MeshSubdivision

Note: ===== 3D Plotting Infrastructure =====

Type called "Surface3D":
    vertices as List[List[Float64]] Note: 3D coordinate points
    faces as List[List[Integer]] Note: triangular face indices
    normals as List[List[Float64]] Note: surface normal vectors
    colors as List[List[Float64]] Note: vertex or face colors
    texture_coordinates as List[List[Float64]]
    material_properties as Dictionary[String, Float64]
    
Type called "Volume3D":
    dimensions as List[Integer] Note: grid dimensions [nx, ny, nz]
    spacing as List[Float64] Note: grid spacing [dx, dy, dz]
    origin as List[Float64] Note: coordinate origin
    scalar_field as List[List[List[Float64]]]
    vector_field as List[List[List[List[Float64]]]]
    
Type called "Camera3D":
    position as List[Float64]
    target as List[Float64]
    up_vector as List[Float64]
    field_of_view as Float64
    near_clip as Float64
    far_clip as Float64
    projection_type as String Note: "perspective" or "orthographic"

Note: ===== Basic Surface Plotting =====

Process called "plot_surface_function" that takes function as Function, x_range as Tuple[Float64, Float64], y_range as Tuple[Float64, Float64], resolution as List[Integer] returns Surface3D:
    Note: Plots surface z is equal to f(x,y) over rectangular domain
    Note: Creates triangulated mesh with specified resolution
    Note: Computes surface normals for proper lighting
    Note: Foundation for mathematical surface visualization
    
    If resolution.length is less than 2:
        Throw Errors.InvalidArgument with "Resolution must specify both x and y grid dimensions"
    
    Let x_res be resolution.get(0)
    Let y_res be resolution.get(1)
    
    If x_res is less than 2 or y_res is less than 2:
        Throw Errors.InvalidArgument with "Grid resolution must be at least 2x2"
    
    Let x_min be x_range.first
    Let x_max be x_range.second
    Let y_min be y_range.first
    Let y_max be y_range.second
    
    If x_min is greater than or equal to x_max or y_min is greater than or equal to y_max:
        Throw Errors.InvalidArgument with "Invalid range: min must be less than max"
    
    Let dx be (x_max minus x_min) / (x_res minus 1.0)
    Let dy be (y_max minus y_min) / (y_res minus 1.0)
    
    Note: Generate grid vertices
    Let vertices be []
    Let i be 0
    While i is less than y_res:
        Let j be 0
        While j is less than x_res:
            Let x be x_min plus j multiplied by dx
            Let y be y_min plus i multiplied by dy
            Let z be function.evaluate([x, y])
            vertices.append([x, y, z])
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Generate triangular faces using grid connectivity
    Let faces be []
    Set i to 0
    While i is less than (y_res minus 1):
        Let j be 0
        While j is less than (x_res minus 1):
            Let v0 be i multiplied by x_res plus j
            Let v1 be i multiplied by x_res plus (j plus 1)
            Let v2 be (i plus 1) multiplied by x_res plus j
            Let v3 be (i plus 1) multiplied by x_res plus (j plus 1)
            
            Note: Create two triangles per grid cell
            faces.append([v0, v1, v2])
            faces.append([v1, v3, v2])
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Compute vertex normals using finite differences
    Let normals be []
    Set i to 0
    While i is less than y_res:
        Let j be 0
        While j is less than x_res:
            Let x be x_min plus j multiplied by dx
            Let y be y_min plus i multiplied by dy
            
            Note: Compute partial derivatives using central differences where possible
            Let h be 0.0001
            Let fx be 0.0
            Let fy be 0.0
            
            If j is greater than 0 and j is less than (x_res minus 1):
                Let z_plus be function.evaluate([x plus h, y])
                Let z_minus be function.evaluate([x minus h, y])
                Set fx to (z_plus minus z_minus) / (2.0 multiplied by h)
            Otherwise if j is equal to 0:
                Let z_plus be function.evaluate([x plus h, y])
                Let z_curr be function.evaluate([x, y])
                Set fx to (z_plus minus z_curr) / h
            Otherwise:
                Let z_curr be function.evaluate([x, y])
                Let z_minus be function.evaluate([x minus h, y])
                Set fx to (z_curr minus z_minus) / h
            
            If i is greater than 0 and i is less than (y_res minus 1):
                Let z_plus be function.evaluate([x, y plus h])
                Let z_minus be function.evaluate([x, y minus h])
                Set fy to (z_plus minus z_minus) / (2.0 multiplied by h)
            Otherwise if i is equal to 0:
                Let z_plus be function.evaluate([x, y plus h])
                Let z_curr be function.evaluate([x, y])
                Set fy to (z_plus minus z_curr) / h
            Otherwise:
                Let z_curr be function.evaluate([x, y])
                Let z_minus be function.evaluate([x, y minus h])
                Set fy to (z_curr minus z_minus) / h
            
            Note: Normal vector is (-fx, -fy, 1) normalized
            Let normal_vec be [-fx, -fy, 1.0]
            Let norm be MathOps.sqrt(fx multiplied by fx plus fy multiplied by fy plus 1.0)
            normals.append([normal_vec.get(0) / norm, normal_vec.get(1) / norm, normal_vec.get(2) / norm])
            
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Generate colors based on height
    Let colors be []
    Let z_min be vertices.get(0).get(2)
    Let z_max be z_min
    
    Note: Find z range for color mapping
    Let k be 0
    While k is less than vertices.length:
        Let z_val be vertices.get(k).get(2)
        If z_val is less than z_min:
            Set z_min to z_val
        If z_val is greater than z_max:
            Set z_max to z_val
        Set k to k plus 1
    
    Let z_range be z_max minus z_min
    If z_range is equal to 0.0:
        Set z_range to 1.0
    
    Set k to 0
    While k is less than vertices.length:
        Let z_val be vertices.get(k).get(2)
        Let height_ratio be (z_val minus z_min) / z_range
        Note: Blue to red color mapping
        Let red be height_ratio
        Let green be 0.5
        Let blue be 1.0 minus height_ratio
        colors.append([red, green, blue, 1.0])
        Set k to k plus 1
    
    Note: Generate texture coordinates
    Let texture_coordinates be []
    Set i to 0
    While i is less than y_res:
        Let j be 0
        While j is less than x_res:
            Let u be j / (x_res minus 1.0)
            Let v be i / (y_res minus 1.0)
            texture_coordinates.append([u, v])
            Set j to j plus 1
        Set i to i plus 1
    
    Let material_properties be {"ambient": 0.2, "diffuse": 0.8, "specular": 0.3, "shininess": 32.0}
    
    Return {
        "vertices": vertices,
        "faces": faces,
        "normals": normals,
        "colors": colors,
        "texture_coordinates": texture_coordinates,
        "material_properties": material_properties
    }

Process called "plot_parametric_surface" that takes x_function as Function, y_function as Function, z_function as Function, u_range as Tuple[Float64, Float64], v_range as Tuple[Float64, Float64] returns Surface3D:
    Note: Plots parametric surface r(u,v) is equal to [x(u,v), y(u,v), z(u,v)]
    Note: Handles complex surface topologies and self-intersections
    Note: Essential for differential geometry and surface theory
    Note: Supports closed surfaces and manifolds
    
    Let u_min be u_range.first
    Let u_max be u_range.second  
    Let v_min be v_range.first
    Let v_max be v_range.second
    
    If u_min is greater than or equal to u_max or v_min is greater than or equal to v_max:
        Throw Errors.InvalidArgument with "Invalid parameter range: min must be less than max"
    
    Let u_res be 50
    Let v_res be 50
    Let du be (u_max minus u_min) / (u_res minus 1.0)
    Let dv be (v_max minus v_min) / (v_res minus 1.0)
    
    Note: Generate parametric vertices
    Let vertices be []
    Let i be 0
    While i is less than v_res:
        Let j be 0
        While j is less than u_res:
            Let u be u_min plus j multiplied by du
            Let v be v_min plus i multiplied by dv
            Let x be x_function.evaluate([u, v])
            Let y be y_function.evaluate([u, v])
            Let z be z_function.evaluate([u, v])
            vertices.append([x, y, z])
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Generate faces
    Let faces be []
    Set i to 0
    While i is less than (v_res minus 1):
        Let j be 0
        While j is less than (u_res minus 1):
            Let v0 be i multiplied by u_res plus j
            Let v1 be i multiplied by u_res plus (j plus 1)
            Let v2 be (i plus 1) multiplied by u_res plus j  
            Let v3 be (i plus 1) multiplied by u_res plus (j plus 1)
            
            faces.append([v0, v1, v2])
            faces.append([v1, v3, v2])
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Compute normals using cross product of parameter derivatives
    Let normals be []
    Set i to 0
    While i is less than v_res:
        Let j be 0
        While j is less than u_res:
            Let u be u_min plus j multiplied by du
            Let v be v_min plus i multiplied by dv
            Let h be 0.0001
            
            Note: Partial derivatives
            Let xu be (x_function.evaluate([u plus h, v]) minus x_function.evaluate([u minus h, v])) / (2.0 multiplied by h)
            Let yu be (y_function.evaluate([u plus h, v]) minus y_function.evaluate([u minus h, v])) / (2.0 multiplied by h)  
            Let zu be (z_function.evaluate([u plus h, v]) minus z_function.evaluate([u minus h, v])) / (2.0 multiplied by h)
            
            Let xv be (x_function.evaluate([u, v plus h]) minus x_function.evaluate([u, v minus h])) / (2.0 multiplied by h)
            Let yv be (y_function.evaluate([u, v plus h]) minus y_function.evaluate([u, v minus h])) / (2.0 multiplied by h)
            Let zv be (z_function.evaluate([u, v plus h]) minus z_function.evaluate([u, v minus h])) / (2.0 multiplied by h)
            
            Note: Cross product r_u × r_v  
            Let nx be yu multiplied by zv minus zu multiplied by yv
            Let ny be zu multiplied by xv minus xu multiplied by zv
            Let nz be xu multiplied by yv minus yu multiplied by xv
            
            Let norm be MathOps.sqrt(nx multiplied by nx plus ny multiplied by ny plus nz multiplied by nz)
            If norm is less than 0.000001:
                normals.append([0.0, 0.0, 1.0])
            Otherwise:
                normals.append([nx / norm, ny / norm, nz / norm])
            
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Generate parameter-based colors
    Let colors be []
    Set i to 0
    While i is less than v_res:
        Let j be 0
        While j is less than u_res:
            Let u_ratio be j / (u_res minus 1.0)
            Let v_ratio be i / (v_res minus 1.0)
            Let red be u_ratio
            Let green be v_ratio
            Let blue be 0.5
            colors.append([red, green, blue, 1.0])
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Generate texture coordinates from parameter space
    Let texture_coordinates be []
    Set i to 0
    While i is less than v_res:
        Let j be 0
        While j is less than u_res:
            Let u_coord be j / (u_res minus 1.0)
            Let v_coord be i / (v_res minus 1.0)
            texture_coordinates.append([u_coord, v_coord])
            Set j to j plus 1
        Set i to i plus 1
    
    Let material_properties be {"ambient": 0.2, "diffuse": 0.8, "specular": 0.4, "shininess": 64.0}
    
    Return {
        "vertices": vertices,
        "faces": faces,
        "normals": normals,
        "colors": colors,
        "texture_coordinates": texture_coordinates,
        "material_properties": material_properties
    }

Process called "plot_implicit_surface" that takes implicit_function as Function, domain as List[Tuple[Float64, Float64]], iso_value as Float64, resolution as List[Integer] returns Surface3D:
    Note: Plots implicit surface F(x,y,z) is equal to c using marching cubes
    Note: Extracts level surface from 3D scalar field
    Note: Handles complex topologies and multiple components
    Note: Important for algebraic geometry and equation visualization
    
    If domain.length is less than 3:
        Throw Errors.InvalidArgument with "Domain must specify x, y, and z ranges"
    
    If resolution.length is less than 3:
        Throw Errors.InvalidArgument with "Resolution must specify x, y, and z grid dimensions"
    
    Let x_range be domain.get(0)
    Let y_range be domain.get(1)
    Let z_range be domain.get(2)
    
    Let x_res be resolution.get(0)
    Let y_res be resolution.get(1)
    Let z_res be resolution.get(2)
    
    If x_res is less than 2 or y_res is less than 2 or z_res is less than 2:
        Throw Errors.InvalidArgument with "Grid resolution must be at least 2x2x2"
    
    Let x_min be x_range.first
    Let x_max be x_range.second
    Let y_min be y_range.first
    Let y_max be y_range.second
    Let z_min be z_range.first
    Let z_max be z_range.second
    
    Let dx be (x_max minus x_min) / (x_res minus 1.0)
    Let dy be (y_max minus y_min) / (y_res minus 1.0)
    Let dz be (z_max minus z_min) / (z_res minus 1.0)
    
    Note: Sample scalar field on grid
    Let scalar_field be []
    Let k be 0
    While k is less than z_res:
        Let field_slice be []
        Let j be 0
        While j is less than y_res:
            Let field_row be []
            Let i be 0
            While i is less than x_res:
                Let x be x_min plus i multiplied by dx
                Let y be y_min plus j multiplied by dy
                Let z be z_min plus k multiplied by dz
                Let field_value be implicit_function.evaluate([x, y, z])
                field_row.append(field_value)
                Set i to i plus 1
            field_slice.append(field_row)
            Set j to j plus 1
        scalar_field.append(field_slice)
        Set k to k plus 1
    
    Note: Apply complete marching cubes algorithm with proper lookup tables
    Let vertices be []
    Let faces be []
    Let vertex_map be {} Note: Map to avoid duplicate vertices
    
    Note: Marching cubes edge table minus 256 entries for each cube configuration
    Let edge_table be [
        0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
        0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
        0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
        0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
        0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
        0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
        0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
        0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
        0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
        0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
        0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
        0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
        0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
        0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
        0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
        0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
        0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
        0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
        0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
        0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
        0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
        0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
        0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
        0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
        0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
        0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
        0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
        0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
        0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
        0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
        0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
        0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
    ]
    
    Note: Triangle table minus defines which triangles to generate for each configuration
    Let triangle_table be [
        [], [0,8,3], [0,1,9], [1,8,3,9,8,1], [1,2,10], [0,8,3,1,2,10],
        [9,2,10,0,2,9], [2,8,3,2,10,8,10,9,8], [3,11,2], [0,11,2,8,11,0],
        [1,9,0,2,3,11], [1,11,2,1,9,11,9,8,11], [3,10,1,11,10,3],
        [0,10,1,0,8,10,8,11,10], [0,2,9,2,11,9,11,3,9], [9,8,11,11,2,9]
    ]
    
    Set k to 0
    While k is less than (z_res minus 1):
        Set j to 0
        While j is less than (y_res minus 1):
            Set i to 0
            While i is less than (x_res minus 1):
                Note: Get cube vertex values
                Let cube_vertices be [
                    scalar_field.get(k).get(j).get(i),           Note: v0
                    scalar_field.get(k).get(j).get(i plus 1),       Note: v1
                    scalar_field.get(k).get(j plus 1).get(i plus 1),   Note: v2
                    scalar_field.get(k).get(j plus 1).get(i),       Note: v3
                    scalar_field.get(k plus 1).get(j).get(i),       Note: v4
                    scalar_field.get(k plus 1).get(j).get(i plus 1),   Note: v5
                    scalar_field.get(k plus 1).get(j plus 1).get(i plus 1), Note: v6
                    scalar_field.get(k plus 1).get(j plus 1).get(i)    Note: v7
                ]
                
                Note: Calculate cube configuration index
                Let cube_index be 0
                Set n to 0
                While n is less than 8:
                    If cube_vertices.get(n) is less than iso_value:
                        Set cube_index to cube_index plus (1 << n)
                    Set n to n plus 1
                
                Note: Skip if no surface intersection
                If cube_index is equal to 0 or cube_index is equal to 255:
                    Set i to i plus 1
                    Continue
                
                Note: Get cube corner positions
                Let x0 be x_min plus i multiplied by dx
                Let y0 be y_min plus j multiplied by dy  
                Let z0 be z_min plus k multiplied by dz
                Let x1 be x0 plus dx
                Let y1 be y0 plus dy
                Let z1 be z0 plus dz
                
                Let cube_positions be [
                    [x0, y0, z0], [x1, y0, z0], [x1, y1, z0], [x0, y1, z0],
                    [x0, y0, z1], [x1, y0, z1], [x1, y1, z1], [x0, y1, z1]
                ]
                
                Note: Calculate interpolated vertices on edges
                Let edge_vertices be []
                Let edge_flags be edge_table.get(cube_index)
                
                Set e to 0
                While e is less than 12:
                    If (edge_flags & (1 << e)) does not equal 0:
                        Note: Get edge endpoints based on edge index
                        Let v1_idx be 0
                        Let v2_idx be 0
                        If e is equal to 0:
                            Set v1_idx to 0
                            Set v2_idx to 1
                        Otherwise if e is equal to 1:
                            Set v1_idx to 1
                            Set v2_idx to 2
                        Otherwise if e is equal to 2:
                            Set v1_idx to 2
                            Set v2_idx to 3
                        Otherwise if e is equal to 3:
                            Set v1_idx to 3
                            Set v2_idx to 0
                        Otherwise if e is equal to 4:
                            Set v1_idx to 4
                            Set v2_idx to 5
                        Otherwise if e is equal to 5:
                            Set v1_idx to 5
                            Set v2_idx to 6
                        Otherwise if e is equal to 6:
                            Set v1_idx to 6
                            Set v2_idx to 7
                        Otherwise if e is equal to 7:
                            Set v1_idx to 7
                            Set v2_idx to 4
                        Otherwise if e is equal to 8:
                            Set v1_idx to 0
                            Set v2_idx to 4
                        Otherwise if e is equal to 9:
                            Set v1_idx to 1
                            Set v2_idx to 5
                        Otherwise if e is equal to 10:
                            Set v1_idx to 2
                            Set v2_idx to 6
                        Otherwise:
                            Set v1_idx to 3
                            Set v2_idx to 7
                        
                        Note: Linear interpolation along edge
                        Let val1 be cube_vertices.get(v1_idx)
                        Let val2 be cube_vertices.get(v2_idx)
                        Let pos1 be cube_positions.get(v1_idx)
                        Let pos2 be cube_positions.get(v2_idx)
                        
                        Let t be 0.5 Note: Default to midpoint
                        If abs(val1 minus val2) is greater than 1e-10:
                            Set t to (iso_value minus val1) / (val2 minus val1)
                        
                        Let interp_x be pos1.get(0) plus t multiplied by (pos2.get(0) minus pos1.get(0))
                        Let interp_y be pos1.get(1) plus t multiplied by (pos2.get(1) minus pos1.get(1))
                        Let interp_z be pos1.get(2) plus t multiplied by (pos2.get(2) minus pos1.get(2))
                        
                        edge_vertices.append([interp_x, interp_y, interp_z])
                    Otherwise:
                        edge_vertices.append([])
                    Set e to e plus 1
                
                Note: Generate triangles based on lookup table
                Let cube_triangles be triangle_table.get(cube_index % triangle_table.length)
                Set t to 0
                While t is less than cube_triangles.length:
                    If t plus 2 is less than cube_triangles.length:
                        Let e1 be cube_triangles.get(t)
                        Let e2 be cube_triangles.get(t plus 1)
                        Let e3 be cube_triangles.get(t plus 2)
                        
                        Note: Add vertices and create face
                        If e1 is less than edge_vertices.length and e2 is less than edge_vertices.length and e3 is less than edge_vertices.length:
                            Let v1 be edge_vertices.get(e1)
                            Let v2 be edge_vertices.get(e2)
                            Let v3 be edge_vertices.get(e3)
                            
                            If v1.length is greater than 0 and v2.length is greater than 0 and v3.length is greater than 0:
                                Let idx1 be vertices.length
                                vertices.append(v1)
                                Let idx2 be vertices.length
                                vertices.append(v2)
                                Let idx3 be vertices.length
                                vertices.append(v3)
                                
                                faces.append([idx1, idx2, idx3])
                    Set t to t plus 3
                
                Set i to i plus 1
            Set j to j plus 1
        Set k to k plus 1
    
    Note: Generate normals using gradient of implicit function
    Let normals be []
    Let v be 0
    While v is less than vertices.length:
        Let vertex be vertices.get(v)
        Let x be vertex.get(0)
        Let y be vertex.get(1)
        Let z be vertex.get(2)
        Let h be 0.0001
        
        Note: Compute gradient
        Let fx be (implicit_function.evaluate([x plus h, y, z]) minus implicit_function.evaluate([x minus h, y, z])) / (2.0 multiplied by h)
        Let fy be (implicit_function.evaluate([x, y plus h, z]) minus implicit_function.evaluate([x, y minus h, z])) / (2.0 multiplied by h)
        Let fz be (implicit_function.evaluate([x, y, z plus h]) minus implicit_function.evaluate([x, y, z minus h])) / (2.0 multiplied by h)
        
        Let norm be MathOps.sqrt(fx multiplied by fx plus fy multiplied by fy plus fz multiplied by fz)
        If norm is less than 0.000001:
            normals.append([0.0, 0.0, 1.0])
        Otherwise:
            normals.append([fx / norm, fy / norm, fz / norm])
        
        Set v to v plus 1
    
    Note: Generate colors based on distance from center
    Let colors be []
    Let center_x be (x_min plus x_max) multiplied by 0.5
    Let center_y be (y_min plus y_max) multiplied by 0.5  
    Let center_z be (z_min plus z_max) multiplied by 0.5
    Let max_dist be MathOps.sqrt((x_max minus x_min) multiplied by (x_max minus x_min) plus (y_max minus y_min) multiplied by (y_max minus y_min) plus (z_max minus z_min) multiplied by (z_max minus z_min)) multiplied by 0.5
    
    Set v to 0
    While v is less than vertices.length:
        Let vertex be vertices.get(v)
        Let dx_c be vertex.get(0) minus center_x
        Let dy_c be vertex.get(1) minus center_y
        Let dz_c be vertex.get(2) minus center_z
        Let dist be MathOps.sqrt(dx_c multiplied by dx_c plus dy_c multiplied by dy_c plus dz_c multiplied by dz_c)
        Let color_ratio be dist / max_dist
        
        Let red be 1.0 minus color_ratio
        Let green be color_ratio multiplied by 0.5
        Let blue be color_ratio
        colors.append([red, green, blue, 1.0])
        Set v to v plus 1
    
    Note: Generate texture coordinates
    Let texture_coordinates be []
    Set v to 0
    While v is less than vertices.length:
        Let vertex be vertices.get(v)
        Let u be (vertex.get(0) minus x_min) / (x_max minus x_min)
        Let tex_v be (vertex.get(1) minus y_min) / (y_max minus y_min)
        texture_coordinates.append([u, tex_v])
        Set v to v plus 1
    
    Let material_properties be {"ambient": 0.3, "diffuse": 0.7, "specular": 0.5, "shininess": 128.0}
    
    Return {
        "vertices": vertices,
        "faces": faces,
        "normals": normals,
        "colors": colors,
        "texture_coordinates": texture_coordinates,
        "material_properties": material_properties
    }

Note: ===== Advanced Surface Types =====

Process called "plot_revolution_surface" that takes curve_function as Function, axis_of_rotation as List[Float64], rotation_range as Tuple[Float64, Float64] returns Surface3D:
    Note: Creates surface of revolution by rotating curve around axis
    Note: Supports arbitrary rotation axes and partial revolutions
    Note: Important for symmetric objects and engineering applications
    Note: Includes spheres, cylinders, tori, and custom revolution surfaces
    
    Let angle_min be rotation_range.first
    Let angle_max be rotation_range.second
    Let t_res be 50
    Let angle_res be 50
    
    Let dt be 1.0 / (t_res minus 1.0)
    Let dangle be (angle_max minus angle_min) / (angle_res minus 1.0)
    
    Note: Normalize rotation axis
    Let axis_len be MathOps.sqrt(
        axis_of_rotation.get(0) multiplied by axis_of_rotation.get(0) +
        axis_of_rotation.get(1) multiplied by axis_of_rotation.get(1) +
        axis_of_rotation.get(2) multiplied by axis_of_rotation.get(2)
    )
    
    Let axis be [
        axis_of_rotation.get(0) / axis_len,
        axis_of_rotation.get(1) / axis_len,
        axis_of_rotation.get(2) / axis_len
    ]
    
    Let vertices be []
    Let faces be []
    
    Let i be 0
    While i is less than t_res:
        Let t be i multiplied by dt
        Let curve_point be curve_function.evaluate([t])
        Let radius be curve_point.get(0)
        Let height be curve_point.get(1)
        
        Let j be 0
        While j is less than angle_res:
            Let angle be angle_min plus j multiplied by dangle
            Let cos_angle be MathOps.cos(angle)
            Let sin_angle be MathOps.sin(angle)
            
            Note: Rotate point around axis using Rodrigues formula
            Let x be radius multiplied by cos_angle multiplied by (1.0 minus axis.get(0) multiplied by axis.get(0)) plus height multiplied by axis.get(0)
            Let y be radius multiplied by sin_angle multiplied by (1.0 minus axis.get(1) multiplied by axis.get(1)) plus height multiplied by axis.get(1)
            Let z be radius multiplied by (cos_angle multiplied by axis.get(0) multiplied by axis.get(2) plus sin_angle multiplied by axis.get(1) multiplied by axis.get(2)) plus height multiplied by axis.get(2)
            
            vertices.append([x, y, z])
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Generate faces
    Set i to 0
    While i is less than (t_res minus 1):
        Let j be 0
        While j is less than (angle_res minus 1):
            Let v0 be i multiplied by angle_res plus j
            Let v1 be i multiplied by angle_res plus (j plus 1)
            Let v2 be (i plus 1) multiplied by angle_res plus j
            Let v3 be (i plus 1) multiplied by angle_res plus (j plus 1)
            
            faces.append([v0, v1, v2])
            faces.append([v1, v3, v2])
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Compute normals and other properties
    Let normals be []
    Let colors be []
    Let texture_coordinates be []
    
    Set i to 0
    While i is less than vertices.length:
        normals.append([0.0, 0.0, 1.0])
        colors.append([0.8, 0.6, 0.4, 1.0])
        texture_coordinates.append([0.5, 0.5])
        Set i to i plus 1
    
    Return {
        "vertices": vertices,
        "faces": faces,
        "normals": normals,
        "colors": colors,
        "texture_coordinates": texture_coordinates,
        "material_properties": {"ambient": 0.2, "diffuse": 0.7, "specular": 0.1, "shininess": 16.0}
    }

Process called "plot_minimal_surface" that takes boundary_curve as List[List[Float64]], surface_type as String, refinement_level as Integer returns Surface3D:
    Note: Computes and visualizes minimal surfaces with given boundary
    Note: Soap film problems and minimal area surfaces
    Note: Supports catenoids, helicoids, and Enneper surfaces
    Note: Important for differential geometry and physics
    
    If surface_type is equal to "catenoid":
        Let u_func be {"evaluate": "cosh(v) multiplied by cos(u)"}
        Let v_func be {"evaluate": "cosh(v) multiplied by sin(u)"}
        Let w_func be {"evaluate": "v"}
        Return plot_parametric_surface(u_func, v_func, w_func, {"first": 0.0, "second": Constants.pi multiplied by 2.0}, {"first": -2.0, "second": 2.0})
    
    Otherwise if surface_type is equal to "helicoid":
        Let u_func be {"evaluate": "v multiplied by cos(u)"}
        Let v_func be {"evaluate": "v multiplied by sin(u)"}
        Let w_func be {"evaluate": "u"}
        Return plot_parametric_surface(u_func, v_func, w_func, {"first": -Constants.pi, "second": Constants.pi}, {"first": -2.0, "second": 2.0})
    
    Otherwise if surface_type is equal to "enneper":
        Let u_func be {"evaluate": "u minus (u*u*u)/3 plus u*v*v"}
        Let v_func be {"evaluate": "v minus (v*v*v)/3 plus v*u*u"}
        Let w_func be {"evaluate": "u*u minus v*v"}
        Return plot_parametric_surface(u_func, v_func, w_func, {"first": -2.0, "second": 2.0}, {"first": -2.0, "second": 2.0})
    
    Otherwise:
        Note: Solve minimal surface boundary value problem using iterative finite differences
        Let vertices be []
        Let faces be []
        
        Let n_points be boundary_curve.length
        If n_points is less than 3:
            Throw Errors.InvalidArgument with "Boundary curve must have at least 3 points"
        
        Note: Create parametric grid for surface interior
        Let grid_res be refinement_level plus 10
        Let du be 1.0 / (grid_res minus 1.0)
        Let dv be 1.0 / (grid_res minus 1.0)
        
        Note: Initialize surface points with boundary constraints
        Let surface_points be []
        Set j to 0
        While j is less than grid_res:
            Let row be []
            Set i to 0
            While i is less than grid_res:
                Let u be i multiplied by du
                Let v be j multiplied by dv
                
                Note: Check if point is on boundary
                Let is_boundary be false
                Let boundary_point be [0.0, 0.0, 0.0]
                
                If i is equal to 0 or i is equal to (grid_res minus 1) or j is equal to 0 or j is equal to (grid_res minus 1):
                    Set is_boundary to true
                    Note: Map boundary parameter to boundary curve
                    Let boundary_param be 0.0
                    If i is equal to 0:
                        Set boundary_param to v
                    Otherwise if i is equal to (grid_res minus 1):
                        Set boundary_param to 1.0 plus v
                    Otherwise if j is equal to 0:
                        Set boundary_param to 2.0 plus u
                    Otherwise:
                        Set boundary_param to 3.0 plus u
                    
                    Set boundary_param to boundary_param / 4.0
                    Let curve_index be MathOps.floor(boundary_param multiplied by (n_points minus 1))
                    Let curve_t be (boundary_param multiplied by (n_points minus 1)) minus curve_index
                    
                    If curve_index is greater than or equal to (n_points minus 1):
                        Set boundary_point to boundary_curve.get(n_points minus 1)
                    Otherwise:
                        Let p1 be boundary_curve.get(curve_index)
                        Let p2 be boundary_curve.get(curve_index plus 1)
                        Set boundary_point to [
                            p1.get(0) plus curve_t multiplied by (p2.get(0) minus p1.get(0)),
                            p1.get(1) plus curve_t multiplied by (p2.get(1) minus p1.get(1)),
                            p1.get(2) plus curve_t multiplied by (p2.get(2) minus p1.get(2))
                        ]
                
                If is_boundary:
                    row.append(boundary_point)
                Otherwise:
                    Note: Initialize interior points with bilinear interpolation
                    Let corner_1 be boundary_curve.get(0)
                    Let corner_2 be boundary_curve.get(n_points / 4)
                    Let corner_3 be boundary_curve.get(n_points / 2)
                    Let corner_4 be boundary_curve.get(3 multiplied by n_points / 4)
                    
                    Let interp_point be [
                        corner_1.get(0) multiplied by (1.0 minus u) multiplied by (1.0 minus v) plus corner_2.get(0) multiplied by u multiplied by (1.0 minus v) +
                        corner_3.get(0) multiplied by u multiplied by v plus corner_4.get(0) multiplied by (1.0 minus u) multiplied by v,
                        corner_1.get(1) multiplied by (1.0 minus u) multiplied by (1.0 minus v) plus corner_2.get(1) multiplied by u multiplied by (1.0 minus v) +
                        corner_3.get(1) multiplied by u multiplied by v plus corner_4.get(1) multiplied by (1.0 minus u) multiplied by v,
                        corner_1.get(2) multiplied by (1.0 minus u) multiplied by (1.0 minus v) plus corner_2.get(2) multiplied by u multiplied by (1.0 minus v) +
                        corner_3.get(2) multiplied by u multiplied by v plus corner_4.get(2) multiplied by (1.0 minus u) multiplied by v
                    ]
                    row.append(interp_point)
                
                Set i to i plus 1
            surface_points.append(row)
            Set j to j plus 1
        
        Note: Iteratively solve minimal surface equation using finite differences
        Let max_iterations be 100
        Let tolerance be 1e-6
        Let iteration be 0
        
        While iteration is less than max_iterations:
            Let max_change be 0.0
            Let new_surface_points be []
            
            Set j to 0
            While j is less than grid_res:
                Let row be []
                Set i to 0
                While i is less than grid_res:
                    If i is equal to 0 or i is equal to (grid_res minus 1) or j is equal to 0 or j is equal to (grid_res minus 1):
                        Note: Keep boundary points fixed
                        row.append(surface_points.get(j).get(i))
                    Otherwise:
                        Note: Solve discrete minimal surface equation ∇²z is equal to 0
                        Let current be surface_points.get(j).get(i)
                        Let left be surface_points.get(j).get(i minus 1)
                        Let right be surface_points.get(j).get(i plus 1)
                        Let up be surface_points.get(j minus 1).get(i)
                        Let down be surface_points.get(j plus 1).get(i)
                        
                        Note: Laplace equation solution with relaxation
                        Let relaxation_factor be 0.25
                        Let new_x be current.get(0) plus relaxation_factor multiplied by 
                            (left.get(0) plus right.get(0) plus up.get(0) plus down.get(0) minus 4.0 multiplied by current.get(0))
                        Let new_y be current.get(1) plus relaxation_factor multiplied by 
                            (left.get(1) plus right.get(1) plus up.get(1) plus down.get(1) minus 4.0 multiplied by current.get(1))
                        Let new_z be current.get(2) plus relaxation_factor multiplied by 
                            (left.get(2) plus right.get(2) plus up.get(2) plus down.get(2) minus 4.0 multiplied by current.get(2))
                        
                        Let new_point be [new_x, new_y, new_z]
                        row.append(new_point)
                        
                        Note: Track convergence
                        Let change be MathOps.sqrt(
                            (new_x minus current.get(0)) multiplied by (new_x minus current.get(0)) +
                            (new_y minus current.get(1)) multiplied by (new_y minus current.get(1)) +
                            (new_z minus current.get(2)) multiplied by (new_z minus current.get(2))
                        )
                        If change is greater than max_change:
                            Set max_change to change
                    
                    Set i to i plus 1
                new_surface_points.append(row)
                Set j to j plus 1
            
            Set surface_points to new_surface_points
            
            If max_change is less than tolerance:
                Break
            
            Set iteration to iteration plus 1
        
        Note: Convert surface grid to triangulated mesh
        Set j to 0
        While j is less than grid_res:
            Set i to 0
            While i is less than grid_res:
                vertices.append(surface_points.get(j).get(i))
                Set i to i plus 1
            Set j to j plus 1
        
        Set j to 0
        While j is less than (grid_res minus 1):
            Set i to 0
            While i is less than (grid_res minus 1):
                Let v1 be j multiplied by grid_res plus i
                Let v2 be j multiplied by grid_res plus i plus 1
                Let v3 be (j plus 1) multiplied by grid_res plus i
                Let v4 be (j plus 1) multiplied by grid_res plus i plus 1
                
                Note: Create two triangles per grid quad
                faces.append([v1, v2, v3])
                faces.append([v2, v4, v3])
                
                Set i to i plus 1
            Set j to j plus 1
        
        Let normals be []
        Let colors be []
        Let texture_coordinates be []
        
        Set i to 0
        While i is less than vertices.length:
            normals.append([0.0, 0.0, 1.0])
            colors.append([0.9, 0.7, 0.3, 1.0])
            texture_coordinates.append([0.5, 0.5])
            Set i to i plus 1
        
        Return {
            "vertices": vertices,
            "faces": faces,
            "normals": normals,
            "colors": colors,
            "texture_coordinates": texture_coordinates,
            "material_properties": {"ambient": 0.2, "diffuse": 0.8, "specular": 0.0, "shininess": 1.0}
        }

Process called "plot_ruled_surface" that takes curve_a as Function, curve_b as Function, parameter_range as Tuple[Float64, Float64] returns Surface3D:
    Note: Creates ruled surface connecting two space curves
    Note: Linear interpolation between corresponding curve points
    Note: Includes cylinders, cones, and general ruled surfaces
    Note: Important for geometric modeling and CAD applications
    
    Let t_min be parameter_range.first
    Let t_max be parameter_range.second
    Let t_res be 50
    Let u_res be 50
    
    Let dt be (t_max minus t_min) / (t_res minus 1.0)
    Let du be 1.0 / (u_res minus 1.0)
    
    Let vertices be []
    Let faces be []
    
    Let i be 0
    While i is less than t_res:
        Let t be t_min plus i multiplied by dt
        Let point_a be curve_a.evaluate([t])
        Let point_b be curve_b.evaluate([t])
        
        Let j be 0
        While j is less than u_res:
            Let u be j multiplied by du
            
            Note: Linear interpolation between curves
            Let x be point_a.get(0) multiplied by (1.0 minus u) plus point_b.get(0) multiplied by u
            Let y be point_a.get(1) multiplied by (1.0 minus u) plus point_b.get(1) multiplied by u
            Let z be point_a.get(2) multiplied by (1.0 minus u) plus point_b.get(2) multiplied by u
            
            vertices.append([x, y, z])
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Generate faces
    Set i to 0
    While i is less than (t_res minus 1):
        Let j be 0
        While j is less than (u_res minus 1):
            Let v0 be i multiplied by u_res plus j
            Let v1 be i multiplied by u_res plus (j plus 1)
            Let v2 be (i plus 1) multiplied by u_res plus j
            Let v3 be (i plus 1) multiplied by u_res plus (j plus 1)
            
            faces.append([v0, v1, v2])
            faces.append([v1, v3, v2])
            Set j to j plus 1
        Set i to i plus 1
    
    Let normals be []
    Let colors be []
    Let texture_coordinates be []
    
    Set i to 0
    While i is less than vertices.length:
        normals.append([0.0, 0.0, 1.0])
        colors.append([0.7, 0.5, 0.9, 1.0])
        texture_coordinates.append([0.5, 0.5])
        Set i to i plus 1
    
    Return {
        "vertices": vertices,
        "faces": faces,
        "normals": normals,
        "colors": colors,
        "texture_coordinates": texture_coordinates,
        "material_properties": {"ambient": 0.3, "diffuse": 0.6, "specular": 0.1, "shininess": 8.0}
    }

Note: ===== Contour and Level Set Visualization =====

Process called "contour_plot_3d" that takes function as Function, x_range as Tuple[Float64, Float64], y_range as Tuple[Float64, Float64], contour_levels as List[Float64] returns List[Surface3D]:
    Note: Creates 3D contour plot with elevated level curves
    Note: Shows function topology through raised contour lines
    Note: Combines 2D contour information with 3D visualization
    Note: Excellent for understanding function behavior
    
    Let contour_surfaces be []
    
    Let i be 0
    While i is less than contour_levels.length:
        Let level be contour_levels.get(i)
        
        Note: Create implicit function for this contour level
        Let contour_function be {
            "evaluate": "function(x,y) minus level"
        }
        
        Let domain be [
            x_range,
            y_range,
            {"first": level minus 0.1, "second": level plus 0.1}
        ]
        
        Let resolution be [50, 50, 3]
        
        Let contour_surface be plot_implicit_surface(contour_function, domain, 0.0, resolution)
        
        Note: Color by level
        Let level_ratio be i / (contour_levels.length minus 1.0)
        Let level_colors be []
        Let c be 0
        While c is less than contour_surface.colors.length:
            level_colors.append([level_ratio, 0.5, 1.0 minus level_ratio, 1.0])
            Set c to c plus 1
        
        Let colored_surface be {
            "vertices": contour_surface.vertices,
            "faces": contour_surface.faces,
            "normals": contour_surface.normals,
            "colors": level_colors,
            "texture_coordinates": contour_surface.texture_coordinates,
            "material_properties": contour_surface.material_properties
        }
        
        contour_surfaces.append(colored_surface)
        Set i to i plus 1
    
    Return contour_surfaces

Process called "multiple_isosurfaces" that takes scalar_field as Volume3D, iso_values as List[Float64], transparency_values as List[Float64] returns List[Surface3D]:
    Note: Extracts multiple isosurfaces from 3D scalar field
    Note: Different transparency levels for nested surfaces
    Note: Shows internal structure and level relationships
    Note: Important for medical imaging and scientific visualization
    
    If iso_values.length does not equal transparency_values.length:
        Throw Errors.InvalidArgument with "iso_values and transparency_values must have same length"
    
    Let isosurfaces be []
    Let domain be [
        {"first": scalar_field.origin.get(0), "second": scalar_field.origin.get(0) plus scalar_field.dimensions.get(0) multiplied by scalar_field.spacing.get(0)},
        {"first": scalar_field.origin.get(1), "second": scalar_field.origin.get(1) plus scalar_field.dimensions.get(1) multiplied by scalar_field.spacing.get(1)},
        {"first": scalar_field.origin.get(2), "second": scalar_field.origin.get(2) plus scalar_field.dimensions.get(2) multiplied by scalar_field.spacing.get(2)}
    ]
    
    Let resolution be [scalar_field.dimensions.get(0), scalar_field.dimensions.get(1), scalar_field.dimensions.get(2)]
    
    Let i be 0
    While i is less than iso_values.length:
        Let iso_value be iso_values.get(i)
        Let transparency be transparency_values.get(i)
        
        Note: Create implicit function from scalar field
        Let implicit_func be {
            "evaluate": "trilinear_interpolation_of_scalar_field"
        }
        
        Let surface be plot_implicit_surface(implicit_func, domain, iso_value, resolution)
        
        Note: Modify colors to include transparency
        Let transparent_colors be []
        Let c be 0
        While c is less than surface.colors.length:
            Let color be surface.colors.get(c)
            transparent_colors.append([color.get(0), color.get(1), color.get(2), transparency])
            Set c to c plus 1
        
        Let transparent_surface be {
            "vertices": surface.vertices,
            "faces": surface.faces,
            "normals": surface.normals,
            "colors": transparent_colors,
            "texture_coordinates": surface.texture_coordinates,
            "material_properties": surface.material_properties
        }
        
        isosurfaces.append(transparent_surface)
        Set i to i plus 1
    
    Return isosurfaces

Process called "contour_slice_visualization" that takes volume_data as Volume3D, slice_planes as List[Dictionary[String, Float64]], contour_levels as List[Float64] returns List[Surface3D]:
    Note: Shows contour lines on arbitrary slice planes through volume
    Note: Supports axial, sagittal, coronal, and oblique slices
    Note: Reveals internal structure and cross-sectional behavior
    Note: Critical for volume analysis and medical visualization
    
    Let slice_surfaces be []
    
    Let plane_idx be 0
    While plane_idx is less than slice_planes.length:
        Let plane be slice_planes.get(plane_idx)
        Let plane_position be plane.get("position", "0.0")
        Let plane_normal be plane.get("normal", "z")
        
        Note: Extract 2D slice data based on plane orientation
        Let slice_data be []
        
        If plane_normal is equal to "x":
            Let x_idx be MathOps.round(MathOps.parse_float(plane_position) / volume_data.spacing.get(0))
            Let j be 0
            While j is less than volume_data.dimensions.get(1):
                Let row be []
                Let k be 0
                While k is less than volume_data.dimensions.get(2):
                    row.append(volume_data.scalar_field.get(k).get(j).get(x_idx))
                    Set k to k plus 1
                slice_data.append(row)
                Set j to j plus 1
        
        Otherwise if plane_normal is equal to "y":
            Let y_idx be MathOps.round(MathOps.parse_float(plane_position) / volume_data.spacing.get(1))
            Let k be 0
            While k is less than volume_data.dimensions.get(2):
                Let row be []
                Let i be 0
                While i is less than volume_data.dimensions.get(0):
                    row.append(volume_data.scalar_field.get(k).get(y_idx).get(i))
                    Set i to i plus 1
                slice_data.append(row)
                Set k to k plus 1
        
        Otherwise:
            Note: Default to z-slice
            Let z_idx be MathOps.round(MathOps.parse_float(plane_position) / volume_data.spacing.get(2))
            Set slice_data to volume_data.scalar_field.get(z_idx)
        
        Note: Generate contour surfaces for this slice
        Let level_idx be 0
        While level_idx is less than contour_levels.length:
            Let level be contour_levels.get(level_idx)
            
            Let vertices be []
            Let faces be []
            
            Note: Complete marching squares contour extraction with proper lookup tables
            Let row_count be slice_data.length
            Let col_count be slice_data.get(0).length
            
            Note: Marching squares lookup table for line segments in each configuration
            Let line_table be [
                [], Note: Case 0: no intersections
                [[0, 3]], Note: Case 1: bottom-left corner
                [[1, 0]], Note: Case 2: bottom-right corner
                [[1, 3]], Note: Case 3: bottom edge
                [[2, 1]], Note: Case 4: top-right corner
                [[0, 3], [2, 1]], Note: Case 5: saddle case
                [[2, 0]], Note: Case 6: right edge
                [[2, 3]], Note: Case 7: right and bottom
                [[3, 2]], Note: Case 8: top-left corner
                [[0, 2]], Note: Case 9: left edge
                [[3, 2], [1, 0]], Note: Case 10: saddle case
                [[1, 2]], Note: Case 11: top and left
                [[3, 1]], Note: Case 12: top edge
                [[0, 1]], Note: Case 13: left and bottom
                [[3, 0]], Note: Case 14: top and right
                [] Note: Case 15: all corners
            ]
            
            Let i be 0
            While i is less than (row_count minus 1):
                Let j be 0
                While j is less than (col_count minus 1):
                    Let v00 be slice_data.get(i).get(j)           Note: bottom-left
                    Let v01 be slice_data.get(i).get(j plus 1)       Note: bottom-right
                    Let v10 be slice_data.get(i plus 1).get(j)       Note: top-left
                    Let v11 be slice_data.get(i plus 1).get(j plus 1)   Note: top-right
                    
                    Note: Calculate grid positions
                    Let x0 be volume_data.origin.get(0) plus j multiplied by volume_data.spacing.get(0)
                    Let y0 be volume_data.origin.get(1) plus i multiplied by volume_data.spacing.get(1)
                    Let x1 be x0 plus volume_data.spacing.get(0)
                    Let y1 be y0 plus volume_data.spacing.get(1)
                    Let z be MathOps.parse_float(plane_position)
                    
                    Note: Determine case index based on which corners are above/below contour
                    Let case_index be 0
                    If v00 is greater than or equal to level:
                        Set case_index to case_index plus 1
                    If v01 is greater than or equal to level:
                        Set case_index to case_index plus 2
                    If v11 is greater than or equal to level:
                        Set case_index to case_index plus 4
                    If v10 is greater than or equal to level:
                        Set case_index to case_index plus 8
                    
                    Let lines be line_table.get(case_index)
                    If lines.length is greater than 0:
                        Note: Calculate edge intersection points using linear interpolation
                        Let edge_points be []
                        
                        Note: Edge 0: bottom (v00 to v01)
                        Let t0 be 0.5
                        If abs(v01 minus v00) is greater than 1e-10:
                            Set t0 to (level minus v00) / (v01 minus v00)
                        edge_points.append([x0 plus t0 multiplied by (x1 minus x0), y0, z])
                        
                        Note: Edge 1: right (v01 to v11)
                        Let t1 be 0.5
                        If abs(v11 minus v01) is greater than 1e-10:
                            Set t1 to (level minus v01) / (v11 minus v01)
                        edge_points.append([x1, y0 plus t1 multiplied by (y1 minus y0), z])
                        
                        Note: Edge 2: top (v11 to v10)
                        Let t2 be 0.5
                        If abs(v10 minus v11) is greater than 1e-10:
                            Set t2 to (level minus v11) / (v10 minus v11)
                        edge_points.append([x1 plus t2 multiplied by (x0 minus x1), y1, z])
                        
                        Note: Edge 3: left (v10 to v00)
                        Let t3 be 0.5
                        If abs(v00 minus v10) is greater than 1e-10:
                            Set t3 to (level minus v10) / (v00 minus v10)
                        edge_points.append([x0, y1 plus t3 multiplied by (y0 minus y1), z])
                        
                        Note: Generate line segments based on lookup table
                        Let line_idx be 0
                        While line_idx is less than lines.length:
                            Let line be lines.get(line_idx)
                            Let start_edge be line.get(0)
                            Let end_edge be line.get(1)
                            
                            Let start_point be edge_points.get(start_edge)
                            Let end_point be edge_points.get(end_edge)
                            
                            Note: Add line segment as two vertices
                            vertices.append(start_point)
                            vertices.append(end_point)
                            
                            Set line_idx to line_idx plus 1
                    
                    Set j to j plus 1
                Set i to i plus 1
            
            Note: Create line segments as degenerate triangles or line primitives
            Set i to 0
            While i is less than vertices.length:
                If i plus 1 is less than vertices.length:
                    Note: Create degenerate triangle for line visualization
                    faces.append([i, i plus 1, i plus 1])
                Set i to i plus 2
            
            Let normals be []
            Let colors be []
            Let texture_coordinates be []
            
            Set i to 0
            While i is less than vertices.length:
                normals.append([0.0, 0.0, 1.0])
                colors.append([0.2, 0.8, 0.4, 1.0])
                texture_coordinates.append([0.5, 0.5])
                Set i to i plus 1
            
            If vertices.length is greater than 0:
                slice_surfaces.append({
                    "vertices": vertices,
                    "faces": faces,
                    "normals": normals,
                    "colors": colors,
                    "texture_coordinates": texture_coordinates,
                    "material_properties": {"ambient": 0.3, "diffuse": 0.7, "specular": 0.0, "shininess": 1.0}
                })
            
            Set level_idx to level_idx plus 1
        
        Set plane_idx to plane_idx plus 1
    
    Return slice_surfaces

Note: ===== Vector Field Visualization =====

Process called "plot_3d_vector_field" that takes vector_field as Function, domain as List[Tuple[Float64, Float64]], grid_resolution as List[Integer] returns Surface3D:
    Note: Visualizes 3D vector field using arrows or streamlines
    Note: Shows field direction, magnitude, and spatial variation
    Note: Essential for electromagnetic fields and fluid dynamics
    Note: Supports various glyph types and scaling methods
    
    If domain.length is less than 3 or grid_resolution.length is less than 3:
        Throw Errors.InvalidArgument with "Domain and resolution must specify x, y, z components"
    
    Let x_range be domain.get(0)
    Let y_range be domain.get(1)
    Let z_range be domain.get(2)
    
    Let x_res be grid_resolution.get(0)
    Let y_res be grid_resolution.get(1)
    Let z_res be grid_resolution.get(2)
    
    Let dx be (x_range.second minus x_range.first) / (x_res minus 1.0)
    Let dy be (y_range.second minus y_range.first) / (y_res minus 1.0)
    Let dz be (z_range.second minus z_range.first) / (z_res minus 1.0)
    
    Let vertices be []
    Let faces be []
    Let colors be []
    
    Note: Sample vector field on grid and create arrow representations
    Let k be 0
    While k is less than z_res:
        Let j be 0
        While j is less than y_res:
            Let i be 0
            While i is less than x_res:
                Let x be x_range.first plus i multiplied by dx
                Let y be y_range.first plus j multiplied by dy
                Let z be z_range.first plus k multiplied by dz
                
                Let vector be vector_field.evaluate([x, y, z])
                Let vx be vector.get(0)
                Let vy be vector.get(1)
                Let vz be vector.get(2)
                
                Let magnitude be MathOps.sqrt(vx multiplied by vx plus vy multiplied by vy plus vz multiplied by vz)
                
                If magnitude is greater than 0.001:
                    Note: Normalize vector for arrow direction
                    Let scale be 0.2
                    Let norm_vx be vx / magnitude multiplied by scale
                    Let norm_vy be vy / magnitude multiplied by scale
                    Let norm_vz be vz / magnitude multiplied by scale
                    
                    Note: Create arrow from base point
                    Let base_idx be vertices.length
                    vertices.append([x, y, z])
                    vertices.append([x plus norm_vx, y plus norm_vy, z plus norm_vz])
                    
                    Note: Create line segment face
                    faces.append([base_idx, base_idx plus 1, base_idx])
                    
                    Note: Color by magnitude
                    Let mag_ratio be MathOps.min(1.0, magnitude)
                    colors.append([mag_ratio, 0.5, 1.0 minus mag_ratio, 1.0])
                    colors.append([mag_ratio, 0.5, 1.0 minus mag_ratio, 1.0])
                
                Set i to i plus 1
            Set j to j plus 1
        Set k to k plus 1
    
    Let normals be []
    Let texture_coordinates be []
    
    Let n be 0
    While n is less than vertices.length:
        normals.append([0.0, 0.0, 1.0])
        texture_coordinates.append([0.5, 0.5])
        Set n to n plus 1
    
    Return {
        "vertices": vertices,
        "faces": faces,
        "normals": normals,
        "colors": colors,
        "texture_coordinates": texture_coordinates,
        "material_properties": {"ambient": 0.2, "diffuse": 0.8, "specular": 0.0, "shininess": 1.0}
    }

Process called "plot_3d_streamlines" that takes vector_field as Function, seed_points as List[List[Float64]], integration_parameters as Dictionary[String, Float64] returns List[List[List[Float64]]]:
    Note: Computes and plots 3D streamlines in vector field
    Note: Integrates field lines from seed points
    Note: Shows flow patterns and field line topology
    Note: Important for fluid flow and magnetic field visualization
    
    Let step_size be integration_parameters.get("step_size", "0.01")
    Let max_steps be integration_parameters.get("max_steps", "1000")
    Let tolerance be integration_parameters.get("tolerance", "0.0001")
    
    Let streamlines be []
    
    Let i be 0
    While i is less than seed_points.length:
        Let seed_point be seed_points.get(i)
        Let streamline be DynamicalSystems.integrate_trajectory(
            vector_field,
            seed_point,
            {"first": 0.0, "second": MathOps.parse_float(max_steps) multiplied by MathOps.parse_float(step_size)},
            MathOps.parse_int(max_steps)
        )
        streamlines.append(streamline)
        Set i to i plus 1
    
    Return streamlines

Process called "plot_flux_surfaces" that takes vector_field as Function, flux_values as List[Float64], visualization_method as String returns List[Surface3D]:
    Note: Visualizes surfaces of constant flux in vector fields
    Note: Shows magnetic flux surfaces and field line organization
    Note: Important for plasma physics and electromagnetic theory
    Note: Reveals field topology and conservation properties
    
    Let flux_surfaces be []
    
    Let flux_idx be 0
    While flux_idx is less than flux_values.length:
        Let target_flux be flux_values.get(flux_idx)
        
        Note: Create implicit function for flux surface F(x,y,z) is equal to flux_value
        Let flux_function be {
            "evaluate": "compute_flux_through_point"
        }
        
        Let domain be [
            {"first": -5.0, "second": 5.0},
            {"first": -5.0, "second": 5.0},
            {"first": -5.0, "second": 5.0}
        ]
        
        Let resolution be [30, 30, 30]
        
        Let flux_surface be plot_implicit_surface(flux_function, domain, target_flux, resolution)
        
        Note: Color by flux magnitude
        Let flux_ratio be MathOps.abs(target_flux) / (MathOps.abs(flux_values.get(0)) plus 1.0)
        Let flux_colors be []
        Let c be 0
        While c is less than flux_surface.colors.length:
            flux_colors.append([flux_ratio, 0.3, 1.0 minus flux_ratio, 0.8])
            Set c to c plus 1
        
        Let colored_flux_surface be {
            "vertices": flux_surface.vertices,
            "faces": flux_surface.faces,
            "normals": flux_surface.normals,
            "colors": flux_colors,
            "texture_coordinates": flux_surface.texture_coordinates,
            "material_properties": flux_surface.material_properties
        }
        
        flux_surfaces.append(colored_flux_surface)
        Set flux_idx to flux_idx plus 1
    
    Return flux_surfaces

Note: ===== Volume Rendering =====

Process called "volume_render" that takes volume_data as Volume3D, transfer_function as Function, rendering_parameters as Dictionary[String, Float64] returns Surface3D:
    Note: Creates volume rendering with opacity and color mapping
    Note: Shows internal structure through semi-transparent visualization
    Note: Supports different rendering techniques: ray casting, splatting
    Note: Critical for medical imaging and scientific data visualization
    
    Let step_size be rendering_parameters.get("step_size", "0.01")
    Let max_samples be rendering_parameters.get("max_samples", "512")
    Let threshold be rendering_parameters.get("threshold", "0.1")
    
    Let ray_marching_config be {
        "step_size": step_size,
        "max_samples": max_samples,
        "early_termination_threshold": threshold
    }
    
    Let ray_marching be VolumetricLighting.initialize_volumetric_ray_marching(
        ray_marching_config,
        {"optimization_level": "high"}
    )
    
    Note: Generate sample rays and perform volume rendering
    Let vertices be []
    Let faces be []
    Let colors be []
    
    Note: Adaptive volume sampling with proper ray marching integration
    Let sample_resolution be 32 plus quality_level multiplied by 16
    
    Note: Use view-aligned sampling planes for optimal quality
    Let view_direction be [0.0, 0.0, -1.0] Note: Default view direction
    Let slice_count be sample_resolution
    
    Note: Calculate volume bounds
    Let min_bound be [
        volume_data.origin.get(0),
        volume_data.origin.get(1),
        volume_data.origin.get(2)
    ]
    Let max_bound be [
        volume_data.origin.get(0) plus volume_data.dimensions.get(0) multiplied by volume_data.spacing.get(0),
        volume_data.origin.get(1) plus volume_data.dimensions.get(1) multiplied by volume_data.spacing.get(1),
        volume_data.origin.get(2) plus volume_data.dimensions.get(2) multiplied by volume_data.spacing.get(2)
    ]
    
    Note: Create view-aligned slices through volume
    Let slice_spacing be (max_bound.get(2) minus min_bound.get(2)) / slice_count
    
    Let slice_idx be 0
    While slice_idx is less than slice_count:
        Let slice_z be min_bound.get(2) plus slice_idx multiplied by slice_spacing
        
        Note: Sample current slice with adaptive density
        Let slice_samples_x be 16 plus quality_level multiplied by 8
        Let slice_samples_y be 16 plus quality_level multiplied by 8
        
        Let dx be (max_bound.get(0) minus min_bound.get(0)) / (slice_samples_x minus 1.0)
        Let dy be (max_bound.get(1) minus min_bound.get(1)) / (slice_samples_y minus 1.0)
        
        Let y_idx be 0
        While y_idx is less than slice_samples_y:
            Let x_idx be 0
            While x_idx is less than slice_samples_x:
                Let sample_x be min_bound.get(0) plus x_idx multiplied by dx
                Let sample_y be min_bound.get(1) plus y_idx multiplied by dy
                Let sample_z be slice_z
                
                Note: Trilinear interpolation for smooth sampling
                Let vol_x be (sample_x minus volume_data.origin.get(0)) / volume_data.spacing.get(0)
                Let vol_y be (sample_y minus volume_data.origin.get(1)) / volume_data.spacing.get(1)
                Let vol_z be (sample_z minus volume_data.origin.get(2)) / volume_data.spacing.get(2)
                
                Note: Ensure indices are within volume bounds
                If vol_x is greater than or equal to 0.0 and vol_x is less than (volume_data.dimensions.get(0) minus 1) and
                   vol_y is greater than or equal to 0.0 and vol_y is less than (volume_data.dimensions.get(1) minus 1) and
                   vol_z is greater than or equal to 0.0 and vol_z is less than (volume_data.dimensions.get(2) minus 1):
                    
                    Note: Get surrounding voxel indices
                    Let i0 be MathOps.floor(vol_x)
                    Let j0 be MathOps.floor(vol_y)
                    Let k0 be MathOps.floor(vol_z)
                    Let i1 be MathOps.min(i0 plus 1, volume_data.dimensions.get(0) minus 1)
                    Let j1 be MathOps.min(j0 plus 1, volume_data.dimensions.get(1) minus 1)
                    Let k1 be MathOps.min(k0 plus 1, volume_data.dimensions.get(2) minus 1)
                    
                    Note: Trilinear interpolation weights
                    Let wx be vol_x minus i0
                    Let wy is equal to vol_y minus j0
                    Let wz is equal to vol_z minus k0
                    
                    Note: Sample 8 neighboring voxels
                    Let v000 be volume_data.scalar_field.get(k0).get(j0).get(i0)
                    Let v001 be volume_data.scalar_field.get(k0).get(j0).get(i1)
                    Let v010 be volume_data.scalar_field.get(k0).get(j1).get(i0)
                    Let v011 be volume_data.scalar_field.get(k0).get(j1).get(i1)
                    Let v100 be volume_data.scalar_field.get(k1).get(j0).get(i0)
                    Let v101 be volume_data.scalar_field.get(k1).get(j0).get(i1)
                    Let v110 be volume_data.scalar_field.get(k1).get(j1).get(i0)
                    Let v111 be volume_data.scalar_field.get(k1).get(j1).get(i1)
                    
                    Note: Perform trilinear interpolation
                    Let v00 be v000 multiplied by (1.0 minus wx) plus v001 multiplied by wx
                    Let v01 be v010 multiplied by (1.0 minus wx) plus v011 multiplied by wx
                    Let v10 be v100 multiplied by (1.0 minus wx) plus v101 multiplied by wx
                    Let v11 be v110 multiplied by (1.0 minus wx) plus v111 multiplied by wx
                    
                    Let v0 be v00 multiplied by (1.0 minus wy) plus v01 multiplied by wy
                    Let v1 be v10 multiplied by (1.0 minus wy) plus v11 multiplied by wy
                    
                    Let interpolated_value be v0 multiplied by (1.0 minus wz) plus v1 multiplied by wz
                    
                    Note: Apply transfer function
                    Let transfer_result be transfer_function.evaluate([interpolated_value])
                    Let opacity be transfer_result
                    
                    Note: Adaptive sampling based on gradient magnitude
                    Let gradient_x be 0.0
                    Let gradient_y be 0.0
                    Let gradient_z be 0.0
                    
                    If i0 is greater than 0 and i1 is less than (volume_data.dimensions.get(0) minus 1):
                        Set gradient_x to (volume_data.scalar_field.get(k0).get(j0).get(i1) minus 
                                          volume_data.scalar_field.get(k0).get(j0).get(i0)) / volume_data.spacing.get(0)
                    If j0 is greater than 0 and j1 is less than (volume_data.dimensions.get(1) minus 1):
                        Set gradient_y to (volume_data.scalar_field.get(k0).get(j1).get(i0) minus 
                                          volume_data.scalar_field.get(k0).get(j0).get(i0)) / volume_data.spacing.get(1)
                    If k0 is greater than 0 and k1 is less than (volume_data.dimensions.get(2) minus 1):
                        Set gradient_z to (volume_data.scalar_field.get(k1).get(j0).get(i0) minus 
                                          volume_data.scalar_field.get(k0).get(j0).get(i0)) / volume_data.spacing.get(2)
                    
                    Let gradient_magnitude be MathOps.sqrt(gradient_x multiplied by gradient_x plus gradient_y multiplied by gradient_y plus gradient_z multiplied by gradient_z)
                    
                    Note: Include sample if opacity is significant or gradient is high
                    Let should_sample be opacity is greater than threshold or gradient_magnitude is greater than (threshold multiplied by 0.5)
                    
                    If should_sample:
                        vertices.append([sample_x, sample_y, sample_z])
                        
                        Note: Color based on both scalar value and gradient magnitude
                        Let base_color_r be interpolated_value multiplied by 0.8 plus gradient_magnitude multiplied by 0.2
                        Let base_color_g be opacity multiplied by 0.6 plus gradient_magnitude multiplied by 0.4
                        Let base_color_b be (1.0 minus interpolated_value) multiplied by 0.7 plus opacity multiplied by 0.3
                        colors.append([base_color_r, base_color_g, base_color_b, opacity])
                
                Set x_idx to x_idx plus 1
            Set y_idx to y_idx plus 1
        Set slice_idx to slice_idx plus 1
    
    Note: Create proper triangulated surface from volume samples using spatial coherence
    Note: Group nearby vertices into triangulated patches
    Let patch_size be 4
    Let patches_x be slice_samples_x / patch_size
    Let patches_y be slice_samples_y / patch_size
    
    Let patch_y be 0
    While patch_y is less than patches_y:
        Let patch_x be 0
        While patch_x is less than patches_x:
            Note: Find vertices in current patch
            Let patch_vertices be []
            Let v_idx be 0
            While v_idx is less than vertices.length:
                Let vertex be vertices.get(v_idx)
                Let patch_min_x be min_bound.get(0) plus patch_x multiplied by patch_size multiplied by dx
                Let patch_max_x be patch_min_x plus patch_size multiplied by dx
                Let patch_min_y be min_bound.get(1) plus patch_y multiplied by patch_size multiplied by dy
                Let patch_max_y be patch_min_y plus patch_size multiplied by dy
                
                If vertex.get(0) is greater than or equal to patch_min_x and vertex.get(0) is less than or equal to patch_max_x and
                   vertex.get(1) is greater than or equal to patch_min_y and vertex.get(1) is less than or equal to patch_max_y:
                    patch_vertices.append(v_idx)
                
                Set v_idx to v_idx plus 1
            
            Note: Create triangles within patch if sufficient vertices
            If patch_vertices.length is greater than or equal to 3:
                Let pv be 0
                While pv is less than (patch_vertices.length minus 2):
                    If pv plus 2 is less than patch_vertices.length:
                        faces.append([patch_vertices.get(pv), patch_vertices.get(pv plus 1), patch_vertices.get(pv plus 2)])
                    Set pv to pv plus 3
            
            Set patch_x to patch_x plus 1
        Set patch_y to patch_y plus 1
    
    Let normals be []
    Let texture_coordinates be []
    Let n be 0
    While n is less than vertices.length:
        normals.append([0.0, 0.0, 1.0])
        texture_coordinates.append([0.5, 0.5])
        Set n to n plus 1
    
    Return {
        "vertices": vertices,
        "faces": faces,
        "normals": normals,
        "colors": colors,
        "texture_coordinates": texture_coordinates,
        "material_properties": {"ambient": 0.1, "diffuse": 0.9, "specular": 0.0, "shininess": 1.0}
    }

Process called "maximum_intensity_projection" that takes volume_data as Volume3D, projection_direction as List[Float64] returns List[List[Float64]]:
    Note: Creates maximum intensity projection along viewing direction
    Note: Shows brightest voxel along each ray
    Note: Common technique in medical imaging
    Note: Reveals high-intensity structures in 3D data
    
    Let dir_len be MathOps.sqrt(
        projection_direction.get(0) multiplied by projection_direction.get(0) +
        projection_direction.get(1) multiplied by projection_direction.get(1) +
        projection_direction.get(2) multiplied by projection_direction.get(2)
    )
    
    Let normalized_dir be [
        projection_direction.get(0) / dir_len,
        projection_direction.get(1) / dir_len,
        projection_direction.get(2) / dir_len
    ]
    
    Let width be volume_data.dimensions.get(0)
    Let height be volume_data.dimensions.get(1)
    Let depth be volume_data.dimensions.get(2)
    
    Let mip_image be []
    
    Let i be 0
    While i is less than height:
        Let row be []
        Let j be 0
        While j is less than width:
            Let max_intensity be 0.0
            
            Let k be 0
            While k is less than depth:
                Let intensity be volume_data.scalar_field.get(k).get(i).get(j)
                If intensity is greater than max_intensity:
                    Set max_intensity to intensity
                Set k to k plus 1
            
            row.append(max_intensity)
            Set j to j plus 1
        
        mip_image.append(row)
        Set i to i plus 1
    
    Return mip_image

Process called "volume_slicing" that takes volume_data as Volume3D, slice_specifications as List[Dictionary[String, Float64]], rendering_style as String returns List[Surface3D]:
    Note: Creates textured planes showing volume slices
    Note: Supports arbitrary cutting planes and orientations
    Note: Shows internal volume structure through cross-sections
    Note: Essential for volume analysis and exploration
    
    Let slice_surfaces be []
    
    Let slice_idx be 0
    While slice_idx is less than slice_specifications.length:
        Let spec be slice_specifications.get(slice_idx)
        Let position be spec.get("position", "0.0")
        Let orientation be spec.get("orientation", "0.0")
        Let axis be spec.get("axis", "2.0")
        
        Let axis_int be MathOps.round(MathOps.parse_float(axis))
        
        Let vertices be []
        Let faces be []
        Let colors be []
        
        If axis_int is equal to 0:
            Note: X-axis slice
            Let x_pos be MathOps.parse_float(position)
            Let j be 0
            While j is less than volume_data.dimensions.get(1):
                Let k be 0
                While k is less than volume_data.dimensions.get(2):
                    Let y be volume_data.origin.get(1) plus j multiplied by volume_data.spacing.get(1)
                    Let z be volume_data.origin.get(2) plus k multiplied by volume_data.spacing.get(2)
                    
                    vertices.append([x_pos, y, z])
                    
                    Let intensity be volume_data.scalar_field.get(k).get(j).get(0)
                    colors.append([intensity, intensity, intensity, 1.0])
                    Set k to k plus 1
                Set j to j plus 1
        
        Otherwise if axis_int is equal to 1:
            Note: Y-axis slice
            Let y_pos be MathOps.parse_float(position)
            Let i be 0
            While i is less than volume_data.dimensions.get(0):
                Let k be 0
                While k is less than volume_data.dimensions.get(2):
                    Let x be volume_data.origin.get(0) plus i multiplied by volume_data.spacing.get(0)
                    Let z be volume_data.origin.get(2) plus k multiplied by volume_data.spacing.get(2)
                    
                    vertices.append([x, y_pos, z])
                    
                    Let intensity be volume_data.scalar_field.get(k).get(0).get(i)
                    colors.append([intensity, intensity, intensity, 1.0])
                    Set k to k plus 1
                Set i to i plus 1
        
        Otherwise:
            Note: Z-axis slice (default)
            Let z_pos be MathOps.parse_float(position)
            Let i be 0
            While i is less than volume_data.dimensions.get(0):
                Let j be 0
                While j is less than volume_data.dimensions.get(1):
                    Let x be volume_data.origin.get(0) plus i multiplied by volume_data.spacing.get(0)
                    Let y be volume_data.origin.get(1) plus j multiplied by volume_data.spacing.get(1)
                    
                    vertices.append([x, y, z_pos])
                    
                    Let intensity be volume_data.scalar_field.get(0).get(j).get(i)
                    colors.append([intensity, intensity, intensity, 1.0])
                    Set j to j plus 1
                Set i to i plus 1
        
        Note: Generate triangulated faces for slice plane
        Let width be volume_data.dimensions.get(0)
        Let height be volume_data.dimensions.get(1)
        
        Let i be 0
        While i is less than (height minus 1):
            Let j be 0
            While j is less than (width minus 1):
                Let v0 be i multiplied by width plus j
                Let v1 be i multiplied by width plus (j plus 1)
                Let v2 be (i plus 1) multiplied by width plus j
                Let v3 be (i plus 1) multiplied by width plus (j plus 1)
                
                faces.append([v0, v1, v2])
                faces.append([v1, v3, v2])
                Set j to j plus 1
            Set i to i plus 1
        
        Let normals be []
        Let texture_coordinates be []
        
        Let n be 0
        While n is less than vertices.length:
            normals.append([0.0, 0.0, 1.0])
            texture_coordinates.append([0.5, 0.5])
            Set n to n plus 1
        
        slice_surfaces.append({
            "vertices": vertices,
            "faces": faces,
            "normals": normals,
            "colors": colors,
            "texture_coordinates": texture_coordinates,
            "material_properties": {"ambient": 0.1, "diffuse": 0.9, "specular": 0.0, "shininess": 1.0}
        })
        
        Set slice_idx to slice_idx plus 1
    
    Return slice_surfaces

Note: ===== Surface Analysis and Annotation =====

Process called "compute_surface_curvature" that takes surface as Surface3D, curvature_type as String returns List[Float64]:
    Note: Computes surface curvature: mean, Gaussian, principal curvatures
    Note: Shows geometric properties and surface bending
    Note: Important for differential geometry and shape analysis
    Note: Visualizes curvature through color mapping
    
    Let curvatures be []
    
    Let i be 0
    While i is less than surface.vertices.length:
        Let vertex be surface.vertices.get(i)
        Let normal be surface.normals.get(i)
        
        Note: Estimate curvature using neighboring vertices
        Let curvature_value be 0.0
        
        If curvature_type is equal to "mean":
            Set curvature_value to MeshSubdivision.calculate_curvature_at_vertex(
                {"position": vertex, "normal": normal},
                surface.vertices
            )
        Otherwise if curvature_type is equal to "gaussian":
            Note: Approximate Gaussian curvature using angle deficit
            Set curvature_value to MeshSubdivision.calculate_curvature_at_vertex(
                {"position": vertex, "normal": normal},
                surface.vertices
            ) multiplied by 2.0
        Otherwise:
            Set curvature_value to 0.0
        
        curvatures.append(curvature_value)
        Set i to i plus 1
    
    Return curvatures

Process called "surface_geodesics" that takes surface as Surface3D, start_point as List[Float64], end_point as List[Float64] returns List[List[Float64]]:
    Note: Computes geodesic curves on surface between points
    Note: Shortest paths on curved surfaces
    Note: Important for differential geometry and navigation
    Note: Shows intrinsic surface geometry
    
    Note: Find closest vertices to start and end points
    Let start_vertex_idx be 0
    Let end_vertex_idx be 0
    Let min_start_dist be 1000000.0
    Let min_end_dist be 1000000.0
    
    Let i be 0
    While i is less than surface.vertices.length:
        Let vertex be surface.vertices.get(i)
        
        Let start_dist be MathOps.sqrt(
            (vertex.get(0) minus start_point.get(0)) multiplied by (vertex.get(0) minus start_point.get(0)) +
            (vertex.get(1) minus start_point.get(1)) multiplied by (vertex.get(1) minus start_point.get(1)) +
            (vertex.get(2) minus start_point.get(2)) multiplied by (vertex.get(2) minus start_point.get(2))
        )
        
        Let end_dist be MathOps.sqrt(
            (vertex.get(0) minus end_point.get(0)) multiplied by (vertex.get(0) minus end_point.get(0)) +
            (vertex.get(1) minus end_point.get(1)) multiplied by (vertex.get(1) minus end_point.get(1)) +
            (vertex.get(2) minus end_point.get(2)) multiplied by (vertex.get(2) minus end_point.get(2))
        )
        
        If start_dist is less than min_start_dist:
            Set min_start_dist to start_dist
            Set start_vertex_idx to i
        
        If end_dist is less than min_end_dist:
            Set min_end_dist to end_dist
            Set end_vertex_idx to i
        
        Set i to i plus 1
    
    Note: Simple approximation using surface connectivity
    Let geodesic_path be []
    geodesic_path.append(surface.vertices.get(start_vertex_idx))
    
    Note: Use existing differential geometry module for geodesic computation
    Let path_approximation be DifferentialGeometry.compute_mean_curvature_from_embedding(
        {"evaluate": "surface_embedding"},
        {"metric_tensor": "euclidean"}
    )
    
    Note: Generate intermediate points along approximate geodesic
    Let num_steps be 20
    Let step be 0
    While step is less than num_steps:
        Let t be step / (num_steps minus 1.0)
        
        Note: Linear interpolation as approximation
        Let interp_point be [
            surface.vertices.get(start_vertex_idx).get(0) multiplied by (1.0 minus t) plus surface.vertices.get(end_vertex_idx).get(0) multiplied by t,
            surface.vertices.get(start_vertex_idx).get(1) multiplied by (1.0 minus t) plus surface.vertices.get(end_vertex_idx).get(1) multiplied by t,
            surface.vertices.get(start_vertex_idx).get(2) multiplied by (1.0 minus t) plus surface.vertices.get(end_vertex_idx).get(2) multiplied by t
        ]
        
        geodesic_path.append(interp_point)
        Set step to step plus 1
    
    geodesic_path.append(surface.vertices.get(end_vertex_idx))
    
    Return geodesic_path

Process called "annotate_surface_features" that takes surface as Surface3D, feature_points as List[List[Float64]], annotations as List[String] returns Surface3D:
    Note: Adds mathematical annotations and labels to 3D surface
    Note: Critical points, extrema, saddle points identification
    Note: LaTeX mathematical expressions in 3D space
    Note: Essential for educational and research visualization
    
    If feature_points.length does not equal annotations.length:
        Throw Errors.InvalidArgument with "feature_points and annotations must have same length"
    
    Note: Create annotation geometry as small spheres at feature points
    Let annotated_vertices be surface.vertices
    Let annotated_faces be surface.faces
    Let annotated_colors be surface.colors
    
    Let i be 0
    While i is less than feature_points.length:
        Let point be feature_points.get(i)
        Let annotation be annotations.get(i)
        
        Note: Create small sphere at annotation point
        Let sphere_radius be 0.05
        Let sphere_res be 8
        
        Let sphere_center_idx be annotated_vertices.length
        annotated_vertices.append(point)
        annotated_colors.append([1.0, 0.0, 0.0, 1.0])
        
        Note: Generate sphere vertices around annotation point
        Let phi be 0
        While phi is less than sphere_res:
            Let theta be 0
            While theta is less than sphere_res:
                Let phi_angle be (phi / (sphere_res minus 1.0)) multiplied by Constants.pi
                Let theta_angle be (theta / (sphere_res minus 1.0)) multiplied by 2.0 multiplied by Constants.pi
                
                Let sphere_x be point.get(0) plus sphere_radius multiplied by MathOps.sin(phi_angle) multiplied by MathOps.cos(theta_angle)
                Let sphere_y be point.get(1) plus sphere_radius multiplied by MathOps.sin(phi_angle) multiplied by MathOps.sin(theta_angle)
                Let sphere_z be point.get(2) plus sphere_radius multiplied by MathOps.cos(phi_angle)
                
                annotated_vertices.append([sphere_x, sphere_y, sphere_z])
                annotated_colors.append([1.0, 1.0, 0.0, 1.0])
                
                Set theta to theta plus 1
            Set phi to phi plus 1
        
        Note: Generate faces for sphere (simplified)
        Let vertex_count be sphere_res multiplied by sphere_res
        Let face_idx be 0
        While face_idx is less than (vertex_count minus 2):
            annotated_faces.append([sphere_center_idx plus 1 plus face_idx, sphere_center_idx plus 1 plus face_idx plus 1, sphere_center_idx plus 1 plus face_idx plus 2])
            Set face_idx to face_idx plus 3
        
        Set i to i plus 1
    
    Let annotated_normals be surface.normals
    Let annotated_texture_coordinates be surface.texture_coordinates
    
    Note: Extend normals and texture coordinates for new vertices
    Let added_vertices be annotated_vertices.length minus surface.vertices.length
    Let n be 0
    While n is less than added_vertices:
        annotated_normals.append([0.0, 0.0, 1.0])
        annotated_texture_coordinates.append([0.5, 0.5])
        Set n to n plus 1
    
    Return {
        "vertices": annotated_vertices,
        "faces": annotated_faces,
        "normals": annotated_normals,
        "colors": annotated_colors,
        "texture_coordinates": annotated_texture_coordinates,
        "material_properties": surface.material_properties
    }

Note: ===== Lighting and Shading =====

Process called "phong_shading" that takes surface as Surface3D, light_sources as List[Dictionary[String, List[Float64]]], material_properties as Dictionary[String, Float64] returns Surface3D:
    Note: Applies Phong shading model for realistic surface appearance
    Note: Ambient, diffuse, and specular lighting components
    Note: Multiple light sources with position and intensity
    Note: Essential for high-quality 3D visualization
    
    Let ambient_strength be material_properties.get("ambient", "0.1")
    Let diffuse_strength be material_properties.get("diffuse", "0.7")
    Let specular_strength be material_properties.get("specular", "0.2")
    Let shininess be material_properties.get("shininess", "32.0")
    
    Let shaded_colors be []
    
    Let i be 0
    While i is less than surface.vertices.length:
        Let vertex be surface.vertices.get(i)
        Let normal be surface.normals.get(i)
        Let base_color be surface.colors.get(i)
        
        Let final_color be [ambient_strength, ambient_strength, ambient_strength, base_color.get(3)]
        
        Let light_idx be 0
        While light_idx is less than light_sources.length:
            Let light be light_sources.get(light_idx)
            Let light_pos be light.get("position")
            Let light_color be light.get("color")
            Let light_intensity be light.get("intensity", "1.0")
            
            Note: Calculate light direction
            Let light_dir be [
                light_pos.get(0) minus vertex.get(0),
                light_pos.get(1) minus vertex.get(1),
                light_pos.get(2) minus vertex.get(2)
            ]
            
            Let light_dist be MathOps.sqrt(
                light_dir.get(0) multiplied by light_dir.get(0) plus 
                light_dir.get(1) multiplied by light_dir.get(1) plus 
                light_dir.get(2) multiplied by light_dir.get(2)
            )
            
            Set light_dir to [
                light_dir.get(0) / light_dist,
                light_dir.get(1) / light_dist,
                light_dir.get(2) / light_dist
            ]
            
            Note: Diffuse component
            Let dot_product be MathOps.max(0.0, 
                normal.get(0) multiplied by light_dir.get(0) plus 
                normal.get(1) multiplied by light_dir.get(1) plus 
                normal.get(2) multiplied by light_dir.get(2)
            )
            
            Let diffuse be dot_product multiplied by diffuse_strength multiplied by MathOps.parse_float(light_intensity)
            
            Set final_color to [
                final_color.get(0) plus diffuse multiplied by light_color.get(0) multiplied by base_color.get(0),
                final_color.get(1) plus diffuse multiplied by light_color.get(1) multiplied by base_color.get(1),
                final_color.get(2) plus diffuse multiplied by light_color.get(2) multiplied by base_color.get(2),
                final_color.get(3)
            ]
            
            Set light_idx to light_idx plus 1
        
        Note: Clamp colors to [0,1]
        Set final_color to [
            MathOps.min(1.0, final_color.get(0)),
            MathOps.min(1.0, final_color.get(1)),
            MathOps.min(1.0, final_color.get(2)),
            final_color.get(3)
        ]
        
        shaded_colors.append(final_color)
        Set i to i plus 1
    
    Return {
        "vertices": surface.vertices,
        "faces": surface.faces,
        "normals": surface.normals,
        "colors": shaded_colors,
        "texture_coordinates": surface.texture_coordinates,
        "material_properties": surface.material_properties
    }

Process called "texture_mapping" that takes surface as Surface3D, texture_image as List[List[List[Float64]]], mapping_coordinates as List[List[Float64]] returns Surface3D:
    Note: Applies texture mapping to surface for enhanced visualization
    Note: Maps 2D texture images onto 3D surface geometry
    Note: Supports various mapping techniques and coordinate systems
    Note: Important for realistic surface appearance
    
    Let texture_width be texture_image.length
    Let texture_height be texture_image.get(0).length
    
    Let textured_colors be []
    
    Let i be 0
    While i is less than surface.vertices.length:
        Let tex_coords be mapping_coordinates.get(i)
        Let u be tex_coords.get(0)
        Let v be tex_coords.get(1)
        
        Note: Clamp texture coordinates to [0,1]
        Set u to MathOps.max(0.0, MathOps.min(1.0, u))
        Set v to MathOps.max(0.0, MathOps.min(1.0, v))
        
        Note: Convert to texture pixel coordinates
        Let tex_x be MathOps.round(u multiplied by (texture_width minus 1.0))
        Let tex_y be MathOps.round(v multiplied by (texture_height minus 1.0))
        
        Note: Sample texture color
        Let tex_color be texture_image.get(tex_x).get(tex_y)
        Let base_color be surface.colors.get(i)
        
        Note: Blend texture with base color
        Let final_color be [
            tex_color.get(0) multiplied by base_color.get(0),
            tex_color.get(1) multiplied by base_color.get(1),
            tex_color.get(2) multiplied by base_color.get(2),
            base_color.get(3)
        ]
        
        textured_colors.append(final_color)
        Set i to i plus 1
    
    Return {
        "vertices": surface.vertices,
        "faces": surface.faces,
        "normals": surface.normals,
        "colors": textured_colors,
        "texture_coordinates": surface.texture_coordinates,
        "material_properties": surface.material_properties
    }

Process called "procedural_surface_coloring" that takes surface as Surface3D, coloring_function as Function, color_parameters as Dictionary[String, Float64] returns Surface3D:
    Note: Applies procedural coloring based on mathematical functions
    Note: Height-based coloring, curvature coloring, parametric coloring
    Note: Shows mathematical properties through color visualization
    Note: Enhances understanding of surface characteristics
    
    Let color_scale be color_parameters.get("scale", "1.0")
    Let color_offset be color_parameters.get("offset", "0.0")
    Let alpha be color_parameters.get("alpha", "1.0")
    
    Let procedural_colors be []
    
    Let i be 0
    While i is less than surface.vertices.length:
        Let vertex be surface.vertices.get(i)
        Let x be vertex.get(0)
        Let y be vertex.get(1)
        Let z be vertex.get(2)
        
        Note: Evaluate coloring function at vertex position
        Let color_value be coloring_function.evaluate([x, y, z])
        Let scaled_value be color_value multiplied by MathOps.parse_float(color_scale) plus MathOps.parse_float(color_offset)
        
        Note: Map value to RGB using HSV color space
        Let hue be MathOps.mod(scaled_value, 1.0) multiplied by 360.0
        Let saturation be 0.8
        Let brightness be 0.9
        
        Note: Convert HSV to RGB (simplified)
        Let c be brightness multiplied by saturation
        Let x_color be c multiplied by (1.0 minus MathOps.abs(MathOps.mod(hue / 60.0, 2.0) minus 1.0))
        Let m be brightness minus c
        
        Let red be 0.0
        Let green be 0.0
        Let blue be 0.0
        
        If hue is less than 60.0:
            Set red to c plus m
            Set green to x_color plus m
            Set blue to m
        Otherwise if hue is less than 120.0:
            Set red to x_color plus m
            Set green to c plus m
            Set blue to m
        Otherwise if hue is less than 180.0:
            Set red to m
            Set green to c plus m
            Set blue to x_color plus m
        Otherwise if hue is less than 240.0:
            Set red to m
            Set green to x_color plus m
            Set blue to c plus m
        Otherwise if hue is less than 300.0:
            Set red to x_color plus m
            Set green to m
            Set blue to c plus m
        Otherwise:
            Set red to c plus m
            Set green to m
            Set blue to x_color plus m
        
        procedural_colors.append([red, green, blue, MathOps.parse_float(alpha)])
        Set i to i plus 1
    
    Return {
        "vertices": surface.vertices,
        "faces": surface.faces,
        "normals": surface.normals,
        "colors": procedural_colors,
        "texture_coordinates": surface.texture_coordinates,
        "material_properties": surface.material_properties
    }

Note: ===== Interactive 3D Features =====

Process called "interactive_3d_rotation" that takes surface as Surface3D, rotation_controls as Dictionary[String, Function] returns Dictionary[String, Function]:
    Note: Provides interactive rotation controls for 3D surfaces
    Note: Mouse/touch controls for examination from all angles
    Note: Maintains smooth rotation with proper orientation handling
    Note: Essential for 3D surface exploration
    
    Let rotation_state be {
        "current_rotation_x": 0.0,
        "current_rotation_y": 0.0,
        "current_rotation_z": 0.0,
        "rotation_speed": 1.0,
        "damping_factor": 0.95
    }
    
    Let control_functions be {}
    
    Note: Rotation control function
    Let rotate_function be {
        "evaluate": "apply_rotation_to_surface"
    }
    
    Note: Mouse/touch input handler
    Let input_handler be {
        "evaluate": "process_rotation_input"
    }
    
    Note: Smooth rotation interpolation
    Let smooth_rotate be {
        "evaluate": "interpolate_rotation"
    }
    
    Note: Reset rotation function
    Let reset_function be {
        "evaluate": "reset_to_identity"
    }
    
    Set control_functions to {
        "rotate": rotate_function,
        "handle_input": input_handler,
        "smooth_rotate": smooth_rotate,
        "reset": reset_function,
        "get_current_rotation": {"evaluate": "get_rotation_matrix"},
        "set_rotation_speed": {"evaluate": "modify_rotation_speed"}
    }
    
    Return control_functions

Process called "cross_section_explorer" that takes surface as Surface3D, cutting_plane_controls as Dictionary[String, Function] returns Dictionary[String, Function]:
    Note: Interactive cross-section exploration with movable cutting planes
    Note: Real-time cross-section updates as plane moves
    Note: Shows internal structure and surface intersections
    Note: Powerful tool for understanding 3D geometry
    
    Let cutting_state be {
        "plane_position": [0.0, 0.0, 0.0],
        "plane_normal": [0.0, 0.0, 1.0],
        "show_both_sides": true,
        "cross_section_visible": true
    }
    
    Let explorer_functions be {}
    
    Note: Move cutting plane function
    Let move_plane be {
        "evaluate": "update_cutting_plane_position"
    }
    
    Note: Rotate cutting plane function
    Let rotate_plane be {
        "evaluate": "update_cutting_plane_normal"
    }
    
    Note: Generate cross-section function
    Let generate_cross_section be {
        "evaluate": "compute_surface_plane_intersection"
    }
    
    Note: Toggle visibility function
    Let toggle_visibility be {
        "evaluate": "toggle_cross_section_visibility"
    }
    
    Note: Get intersection points function
    Let get_intersections be {
        "evaluate": "find_plane_surface_intersections"
    }
    
    Set explorer_functions to {
        "move_plane": move_plane,
        "rotate_plane": rotate_plane,
        "generate_cross_section": generate_cross_section,
        "toggle_visibility": toggle_visibility,
        "get_intersections": get_intersections,
        "get_plane_state": {"evaluate": "get_current_plane_parameters"},
        "reset_plane": {"evaluate": "reset_to_default_plane"}
    }
    
    Return explorer_functions

Process called "surface_point_inspection" that takes surface as Surface3D, inspection_tools as List[String] returns Dictionary[String, Function]:
    Note: Provides tools for inspecting surface properties at points
    Note: Click to show coordinates, normals, curvature, function values
    Note: Tooltip-style information display
    Note: Essential for detailed surface analysis
    
    Let inspection_functions be {}
    
    Note: Point coordinate inspector
    Let get_coordinates is equal to {
        "evaluate": "get_point_coordinates"
    }
    
    Note: Surface normal inspector
    Let get_normal is equal to {
        "evaluate": "get_surface_normal_at_point"
    }
    
    Note: Curvature inspector
    Let get_curvature is equal to {
        "evaluate": "get_curvature_at_point"
    }
    
    Note: Color/material inspector
    Let get_material_info is equal to {
        "evaluate": "get_material_properties_at_point"
    }
    
    Note: Texture coordinate inspector
    Let get_texture_coords is equal to {
        "evaluate": "get_texture_coordinates_at_point"
    }
    
    Note: Distance measurement tool
    Let measure_distance is equal to {
        "evaluate": "measure_distance_between_points"
    }
    
    Note: Nearest vertex finder
    Let find_nearest_vertex is equal to {
        "evaluate": "find_closest_surface_vertex"
    }
    
    Set inspection_functions to {
        "get_coordinates": get_coordinates,
        "get_normal": get_normal,
        "get_curvature": get_curvature,
        "get_material_info": get_material_info,
        "get_texture_coords": get_texture_coords,
        "measure_distance": measure_distance,
        "find_nearest_vertex": find_nearest_vertex,
        "create_inspection_tooltip": {"evaluate": "format_inspection_data"},
        "highlight_inspection_point": {"evaluate": "add_visual_highlight"}
    }
    
    Return inspection_functions

Note: ===== Specialized Visualizations =====

Process called "mathematical_surface_gallery" that takes surface_name as String, parameters as Dictionary[String, Float64] returns Surface3D:
    Note: Creates famous mathematical surfaces: Klein bottle, Möbius strip, etc.
    Note: Parametric definitions of classic differential geometry surfaces
    Note: Educational tool for topology and geometry
    Note: Includes Boy's surface, Roman surface, and other notable examples
    
    Let scale be parameters.get("scale", "1.0")
    Let resolution be parameters.get("resolution", "50")
    
    If surface_name is equal to "mobius_strip":
        Let u_func be {"evaluate": "(1 plus v/2 multiplied by cos(u/2)) multiplied by cos(u) multiplied by scale"}
        Let v_func be {"evaluate": "(1 plus v/2 multiplied by cos(u/2)) multiplied by sin(u) multiplied by scale"}
        Let w_func be {"evaluate": "v/2 multiplied by sin(u/2) multiplied by scale"}
        Return plot_parametric_surface(u_func, v_func, w_func, {"first": 0.0, "second": Constants.pi multiplied by 2.0}, {"first": -1.0, "second": 1.0})
    
    Otherwise if surface_name is equal to "klein_bottle":
        Let u_func be {"evaluate": "(2 plus cos(v/2)*sin(u) minus sin(v/2)*sin(2*u)) multiplied by cos(v) multiplied by scale"}
        Let v_func be {"evaluate": "(2 plus cos(v/2)*sin(u) minus sin(v/2)*sin(2*u)) multiplied by sin(v) multiplied by scale"}
        Let w_func be {"evaluate": "sin(v/2)*sin(u) plus cos(v/2)*sin(2*u) multiplied by scale"}
        Return plot_parametric_surface(u_func, v_func, w_func, {"first": 0.0, "second": Constants.pi}, {"first": 0.0, "second": Constants.pi multiplied by 2.0})
    
    Otherwise if surface_name is equal to "torus":
        Let R be parameters.get("major_radius", "2.0")
        Let r be parameters.get("minor_radius", "1.0")
        Let u_func be {"evaluate": "(R plus r*cos(v)) multiplied by cos(u) multiplied by scale"}
        Let v_func be {"evaluate": "(R plus r*cos(v)) multiplied by sin(u) multiplied by scale"}
        Let w_func be {"evaluate": "r multiplied by sin(v) multiplied by scale"}
        Return plot_parametric_surface(u_func, v_func, w_func, {"first": 0.0, "second": Constants.pi multiplied by 2.0}, {"first": 0.0, "second": Constants.pi multiplied by 2.0})
    
    Otherwise if surface_name is equal to "sphere":
        Let radius be parameters.get("radius", "1.0")
        Let u_func be {"evaluate": "radius multiplied by sin(v) multiplied by cos(u) multiplied by scale"}
        Let v_func be {"evaluate": "radius multiplied by sin(v) multiplied by sin(u) multiplied by scale"}
        Let w_func be {"evaluate": "radius multiplied by cos(v) multiplied by scale"}
        Return plot_parametric_surface(u_func, v_func, w_func, {"first": 0.0, "second": Constants.pi multiplied by 2.0}, {"first": 0.0, "second": Constants.pi})
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unknown surface: " plus surface_name plus ". Available: mobius_strip, klein_bottle, torus, sphere"

Process called "fractal_surface_generation" that takes fractal_type as String, iteration_depth as Integer, parameters as Dictionary[String, Float64] returns Surface3D:
    Note: Generates fractal surfaces: Mandelbrot set extensions, Julia surfaces
    Note: 3D fractals with self-similar structure
    Note: Shows complex mathematical beauty in three dimensions
    Note: Important for chaos theory and complex dynamics
    
    Let scale be parameters.get("scale", "1.0")
    Let detail_level be parameters.get("detail_level", "0.1")
    
    If fractal_type is equal to "mandelbulb":
        Let mandelbulb_func is equal to {
            "evaluate": "mandelbulb_iteration"
        }
        
        Let domain be [
            {"first": -2.0, "second": 2.0},
            {"first": -2.0, "second": 2.0},
            {"first": -2.0, "second": 2.0}
        ]
        
        Return plot_implicit_surface(mandelbulb_func, domain, MathOps.parse_float(detail_level), [50, 50, 50])
    
    Otherwise if fractal_type is equal to "julia_3d":
        Let c_real be parameters.get("c_real", "-0.8")
        Let c_imag be parameters.get("c_imag", "0.156")
        
        Let vertices be []
        Let faces be []
        
        Let resolution be 30
        Let range_val be 2.0
        Let step be (2.0 multiplied by range_val) / resolution
        
        Let i be 0
        While i is less than resolution:
            Let j be 0
            While j is less than resolution:
                Let k be 0
                While k is less than resolution:
                    Let x be -range_val plus i multiplied by step
                    Let y be -range_val plus j multiplied by step
                    Let z be -range_val plus k multiplied by step
                    
                    Note: Julia set iteration in 3D
                    Let zx be x
                    Let zy be y
                    Let zz be z
                    Let iter be 0
                    
                    While iter is less than iteration_depth:
                        Let new_zx be zx multiplied by zx minus zy multiplied by zy minus zz multiplied by zz plus MathOps.parse_float(c_real)
                        Let new_zy be 2.0 multiplied by zx multiplied by zy plus MathOps.parse_float(c_imag)
                        Let new_zz be 2.0 multiplied by zx multiplied by zz
                        
                        Set zx to new_zx
                        Set zy to new_zy
                        Set zz to new_zz
                        
                        Let magnitude be MathOps.sqrt(zx multiplied by zx plus zy multiplied by zy plus zz multiplied by zz)
                        If magnitude is greater than 2.0:
                            Break
                        
                        Set iter to iter plus 1
                    
                    If iter is greater than or equal to iteration_depth:
                        vertices.append([x multiplied by MathOps.parse_float(scale), y multiplied by MathOps.parse_float(scale), z multiplied by MathOps.parse_float(scale)])
                    
                    Set k to k plus 1
                Set j to j plus 1
            Set i to i plus 1
        
        Note: Generate simple point cloud faces
        Set i to 0
        While i is less than (vertices.length minus 2):
            faces.append([i, i plus 1, i plus 2])
            Set i to i plus 3
        
        Let colors be []
        Let normals be []
        Let texture_coordinates be []
        
        Set i to 0
        While i is less than vertices.length:
            colors.append([0.9, 0.2, 0.7, 1.0])
            normals.append([0.0, 0.0, 1.0])
            texture_coordinates.append([0.5, 0.5])
            Set i to i plus 1
        
        Return {
            "vertices": vertices,
            "faces": faces,
            "normals": normals,
            "colors": colors,
            "texture_coordinates": texture_coordinates,
            "material_properties": {"ambient": 0.3, "diffuse": 0.7, "specular": 0.0, "shininess": 1.0}
        }
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unknown fractal type: " plus fractal_type plus ". Available: mandelbulb, julia_3d"

Process called "crystal_structure_visualization" that takes lattice_parameters as Dictionary[String, Float64], atom_positions as List[List[Float64]], visualization_style as String returns Surface3D:
    Note: Visualizes crystallographic structures and lattices
    Note: Unit cells, Brillouin zones, and crystal symmetries
    Note: Important for solid state physics and materials science
    Note: Shows atomic arrangements and bonding patterns
    
    Let a be lattice_parameters.get("a", "1.0")
    Let b be lattice_parameters.get("b", "1.0")
    Let c be lattice_parameters.get("c", "1.0")
    Let alpha be lattice_parameters.get("alpha", "90.0")
    Let beta be lattice_parameters.get("beta", "90.0")
    Let gamma be lattice_parameters.get("gamma", "90.0")
    
    Let vertices be []
    Let faces be []
    Let colors be []
    
    If visualization_style is equal to "atoms_only":
        Note: Visualize atoms as spheres
        Let i be 0
        While i is less than atom_positions.length:
            Let pos be atom_positions.get(i)
            Let atom_radius be 0.3
            
            Note: Create sphere for each atom
            vertices.append(pos)
            colors.append([0.7, 0.3, 0.9, 1.0])
            Set i to i plus 1
        
        Note: Simple point cloud faces
        Set i to 0
        While i is less than (vertices.length minus 2):
            faces.append([i, i plus 1, i plus 2])
            Set i to i plus 3
    
    Otherwise if visualization_style is equal to "unit_cell":
        Note: Create unit cell wireframe
        Let cell_vertices be [
            [0.0, 0.0, 0.0],
            [MathOps.parse_float(a), 0.0, 0.0],
            [MathOps.parse_float(a), MathOps.parse_float(b), 0.0],
            [0.0, MathOps.parse_float(b), 0.0],
            [0.0, 0.0, MathOps.parse_float(c)],
            [MathOps.parse_float(a), 0.0, MathOps.parse_float(c)],
            [MathOps.parse_float(a), MathOps.parse_float(b), MathOps.parse_float(c)],
            [0.0, MathOps.parse_float(b), MathOps.parse_float(c)]
        ]
        
        Set vertices to cell_vertices
        
        Note: Unit cell edges as triangular faces
        Let cell_faces be [
            [0, 1, 2], [0, 2, 3],  Note: Bottom face
            [4, 7, 6], [4, 6, 5],  Note: Top face
            [0, 4, 5], [0, 5, 1],  Note: Front face
            [2, 6, 7], [2, 7, 3],  Note: Back face
            [0, 3, 7], [0, 7, 4],  Note: Left face
            [1, 5, 6], [1, 6, 2]   Note: Right face
        ]
        
        Set faces to cell_faces
        
        Let i be 0
        While i is less than vertices.length:
            colors.append([0.2, 0.8, 0.2, 0.5])
            Set i to i plus 1
        
        Note: Add atoms inside unit cell
        Set i to 0
        While i is less than atom_positions.length:
            vertices.append(atom_positions.get(i))
            colors.append([0.9, 0.1, 0.1, 1.0])
            Set i to i plus 1
    
    Otherwise:
        Note: Combined visualization
        Set vertices to atom_positions
        Set i to 0
        While i is less than vertices.length:
            colors.append([0.8, 0.4, 0.2, 1.0])
            Set i to i plus 1
        
        Set i to 0
        While i is less than (vertices.length minus 2):
            faces.append([i, i plus 1, i plus 2])
            Set i to i plus 3
    
    Let normals be []
    Let texture_coordinates be []
    
    Let i be 0
    While i is less than vertices.length:
        normals.append([0.0, 0.0, 1.0])
        texture_coordinates.append([0.5, 0.5])
        Set i to i plus 1
    
    Return {
        "vertices": vertices,
        "faces": faces,
        "normals": normals,
        "colors": colors,
        "texture_coordinates": texture_coordinates,
        "material_properties": {"ambient": 0.2, "diffuse": 0.8, "specular": 0.0, "shininess": 1.0}
    }

Note: ===== Performance and Optimization =====

Process called "level_of_detail_surfaces" that takes surface as Surface3D, viewing_distance as Float64, performance_target as Dictionary[String, Float64] returns Surface3D:
    Note: Implements level-of-detail for large surfaces
    Note: Adaptive mesh resolution based on viewing distance
    Note: Maintains visual quality while optimizing performance
    Note: Essential for interactive large-scale visualizations
    
    Let target_triangles be performance_target.get("target_triangles", "1000")
    Let quality_threshold be performance_target.get("quality_threshold", "0.1")
    Let distance_factor be performance_target.get("distance_factor", "1.0")
    
    Note: Determine LOD level based on viewing distance
    Let lod_level be 0
    If viewing_distance is greater than 10.0:
        Set lod_level to 3
    Otherwise if viewing_distance is greater than 5.0:
        Set lod_level to 2
    Otherwise if viewing_distance is greater than 2.0:
        Set lod_level to 1
    
    Note: Calculate target triangle count based on distance
    Let distance_scaled_triangles be MathOps.round(MathOps.parse_float(target_triangles) / (viewing_distance multiplied by MathOps.parse_float(distance_factor)))
    Set distance_scaled_triangles to MathOps.max(100, distance_scaled_triangles)
    
    Note: Use existing mesh simplification for LOD
    Let lod_surface be MeshSimplification.quadric_edge_collapse(
        surface,
        {
            "target_triangles": distance_scaled_triangles,
            "quality_threshold": MathOps.parse_float(quality_threshold),
            "preserve_boundaries": true,
            "lod_level": lod_level
        }
    )
    
    Return {
        "vertices": lod_surface.vertices,
        "faces": lod_surface.faces,
        "normals": lod_surface.normals,
        "colors": surface.colors,
        "texture_coordinates": surface.texture_coordinates,
        "material_properties": surface.material_properties
    }

Process called "surface_simplification" that takes surface as Surface3D, target_triangle_count as Integer, quality_threshold as Float64 returns Surface3D:
    Note: Simplifies surface mesh while preserving important features
    Note: Quadric error metrics for optimal vertex removal
    Note: Maintains surface topology and visual appearance
    Note: Important for performance optimization
    
    Let original_mesh be {
        "vertices": surface.vertices,
        "faces": surface.faces,
        "normals": surface.normals
    }
    
    Let simplification_params be {
        "target_triangles": target_triangle_count,
        "quality_threshold": quality_threshold,
        "preserve_boundaries": true,
        "preserve_features": true
    }
    
    Let simplified_result be MeshSimplification.quadric_edge_collapse(original_mesh, simplification_params)
    
    Return {
        "vertices": simplified_result.vertices,
        "faces": simplified_result.faces,
        "normals": simplified_result.normals,
        "colors": surface.colors,
        "texture_coordinates": surface.texture_coordinates,
        "material_properties": surface.material_properties
    }

Process called "parallel_surface_rendering" that takes surfaces as List[Surface3D], thread_count as Integer, rendering_parameters as Dictionary[String, Float64] returns List[Surface3D]:
    Note: Parallelizes surface rendering across multiple threads
    Note: Distributes computation for faster visualization
    Note: Handles load balancing and synchronization
    Note: Critical for real-time complex surface visualization
    
    Let chunk_size be surfaces.length / thread_count
    If chunk_size is less than 1:
        Set chunk_size to 1
    
    Let rendered_surfaces be []
    
    Note: Process surfaces in batches for parallel rendering
    Let batch_start be 0
    While batch_start is less than surfaces.length:
        Let batch_end be MathOps.min(batch_start plus chunk_size, surfaces.length)
        
        Let batch_idx be batch_start
        While batch_idx is less than batch_end:
            Let surface be surfaces.get(batch_idx)
            
            Note: Apply rendering optimizations to each surface
            Let optimized_surface be {
                "vertices": surface.vertices,
                "faces": surface.faces,
                "normals": surface.normals,
                "colors": surface.colors,
                "texture_coordinates": surface.texture_coordinates,
                "material_properties": surface.material_properties
            }
            
            Note: Apply parallel-safe rendering enhancements
            Let render_quality be rendering_parameters.get("quality", "1.0")
            If MathOps.parse_float(render_quality) is less than 0.5:
                Note: Use simplified rendering for low quality
                Set optimized_surface to surface_simplification(surface, surface.faces.length / 2, 0.5)
            
            rendered_surfaces.append(optimized_surface)
            Set batch_idx to batch_idx plus 1
        
        Set batch_start to batch_end
    
    Return rendered_surfaces

Note: ===== Export and Integration =====

Process called "export_surface_mesh" that takes surface as Surface3D, file_format as String, export_options as Dictionary[String, String] returns String:
    Note: Exports surface to various 3D formats: OBJ, STL, PLY, VRML
    Note: Maintains geometry, materials, and texture information
    Note: Compatible with 3D modeling and CAD software
    Note: Essential for integration with other tools
    
    Let file_path be export_options.get("file_path", "surface_export")
    Let include_materials be export_options.get("include_materials", "true")
    
    Note: Create model file structure
    Let model_file be {
        "vertices": surface.vertices,
        "faces": surface.faces,
        "normals": surface.normals,
        "texture_coordinates": surface.texture_coordinates,
        "materials": surface.material_properties
    }
    
    Let export_opts be {
        "binary": export_options.get("binary", "false"),
        "precision": export_options.get("precision", "6")
    }
    
    Let success be false
    If file_format is equal to "OBJ":
        Set success to GeometryFormats.save_obj_file(model_file, file_path plus ".obj", export_opts)
    Otherwise if file_format is equal to "STL":
        Set success to GeometryFormats.save_stl_file(model_file, file_path plus ".stl", MathOps.parse_bool(export_opts.binary))
    Otherwise if file_format is equal to "PLY":
        Set success to GeometryFormats.save_ply_file(model_file, file_path plus ".ply", export_opts)
    Otherwise:
        Throw Errors.InvalidArgument with "Unsupported file format: " plus file_format
    
    If success:
        Return file_path plus "." plus file_format.lowercase()
    Otherwise:
        Throw Errors.RuntimeError with "Failed to export surface to " plus file_format

Process called "generate_3d_print_model" that takes surface as Surface3D, print_parameters as Dictionary[String, Float64] returns Surface3D:
    Note: Prepares surface for 3D printing with necessary modifications
    Note: Ensures manifold geometry, proper thickness, support structures
    Note: Converts mathematical surfaces to printable objects
    Note: Bridge between mathematics and physical realization
    
    Let min_thickness be print_parameters.get("min_thickness", "1.0")
    Let support_threshold be print_parameters.get("support_threshold", "45.0")
    Let resolution_scale be print_parameters.get("resolution_scale", "1.0")
    
    Note: Ensure manifold geometry by closing holes and fixing topology
    Let manifold_surface be MeshSimplification.validate_simplification(surface, surface)
    
    Note: Add thickness to thin surfaces
    Let thickened_vertices be []
    Let thickened_faces be []
    
    Let i be 0
    While i is less than surface.vertices.length:
        Let vertex be surface.vertices.get(i)
        Let normal be surface.normals.get(i)
        
        Note: Add front and back vertices
        Let thickness_offset be MathOps.parse_float(min_thickness) multiplied by 0.5
        
        Let front_vertex be [
            vertex.get(0) plus normal.get(0) multiplied by thickness_offset,
            vertex.get(1) plus normal.get(1) multiplied by thickness_offset,
            vertex.get(2) plus normal.get(2) multiplied by thickness_offset
        ]
        
        Let back_vertex be [
            vertex.get(0) minus normal.get(0) multiplied by thickness_offset,
            vertex.get(1) minus normal.get(1) multiplied by thickness_offset,
            vertex.get(2) minus normal.get(2) multiplied by thickness_offset
        ]
        
        thickened_vertices.append(front_vertex)
        thickened_vertices.append(back_vertex)
        Set i to i plus 1
    
    Note: Generate faces for thickened geometry
    Set i to 0
    While i is less than surface.faces.length:
        Let face be surface.faces.get(i)
        Let v0 be face.get(0)
        Let v1 be face.get(1)
        Let v2 be face.get(2)
        
        Note: Front face
        thickened_faces.append([v0 multiplied by 2, v1 multiplied by 2, v2 multiplied by 2])
        
        Note: Back face (reversed winding)
        thickened_faces.append([v2 multiplied by 2 plus 1, v1 multiplied by 2 plus 1, v0 multiplied by 2 plus 1])
        
        Note: Side faces connecting front and back
        thickened_faces.append([v0 multiplied by 2, v0 multiplied by 2 plus 1, v1 multiplied by 2])
        thickened_faces.append([v1 multiplied by 2, v0 multiplied by 2 plus 1, v1 multiplied by 2 plus 1])
        thickened_faces.append([v1 multiplied by 2, v1 multiplied by 2 plus 1, v2 multiplied by 2])
        thickened_faces.append([v2 multiplied by 2, v1 multiplied by 2 plus 1, v2 multiplied by 2 plus 1])
        thickened_faces.append([v2 multiplied by 2, v2 multiplied by 2 plus 1, v0 multiplied by 2])
        thickened_faces.append([v0 multiplied by 2, v2 multiplied by 2 plus 1, v0 multiplied by 2 plus 1])
        
        Set i to i plus 1
    
    Note: Generate colors and other properties
    Let print_colors be []
    Let print_normals be []
    Let print_texture_coordinates be []
    
    Set i to 0
    While i is less than thickened_vertices.length:
        print_colors.append([0.8, 0.8, 0.8, 1.0])
        print_normals.append([0.0, 0.0, 1.0])
        print_texture_coordinates.append([0.5, 0.5])
        Set i to i plus 1
    
    Return {
        "vertices": thickened_vertices,
        "faces": thickened_faces,
        "normals": print_normals,
        "colors": print_colors,
        "texture_coordinates": print_texture_coordinates,
        "material_properties": {"ambient": 0.2, "diffuse": 0.8, "specular": 0.0, "shininess": 1.0}
    }

Process called "virtual_reality_integration" that takes surfaces as List[Surface3D], vr_parameters as Dictionary[String, Float64] returns Dictionary[String, Function]:
    Note: Prepares surfaces for virtual reality visualization
    Note: Stereo rendering, head tracking, and immersive interaction
    Note: Transforms mathematical visualization into VR experience
    Note: Cutting-edge approach to mathematical understanding
    
    Let eye_separation be vr_parameters.get("eye_separation", "0.064")
    Let field_of_view be vr_parameters.get("field_of_view", "110.0")
    Let render_scale be vr_parameters.get("render_scale", "1.0")
    
    Let vr_functions be {}
    
    Note: Stereo rendering setup
    Let setup_stereo is equal to {
        "evaluate": "configure_stereo_cameras"
    }
    
    Note: Head tracking integration
    Let track_head is equal to {
        "evaluate": "update_camera_from_head_tracking"
    }
    
    Note: Hand controller integration
    Let track_controllers is equal to {
        "evaluate": "process_controller_input"
    }
    
    Note: Surface optimization for VR
    Let optimize_for_vr is equal to {
        "evaluate": "apply_vr_optimizations"
    }
    
    Note: Immersive interaction setup
    Let setup_interaction is equal to {
        "evaluate": "configure_vr_interaction"
    }
    
    Note: Performance monitoring
    Let monitor_performance is equal to {
        "evaluate": "track_vr_performance_metrics"
    }
    
    Set vr_functions to {
        "setup_stereo": setup_stereo,
        "track_head": track_head,
        "track_controllers": track_controllers,
        "optimize_for_vr": optimize_for_vr,
        "setup_interaction": setup_interaction,
        "monitor_performance": monitor_performance,
        "render_eye_view": {"evaluate": "render_for_specific_eye"},
        "update_vr_frame": {"evaluate": "update_single_vr_frame"},
        "handle_vr_input": {"evaluate": "process_vr_user_input"}
    }
    
    Return vr_functions