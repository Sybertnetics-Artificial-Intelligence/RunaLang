Note: Mathematical Plotting Module

This module provides comprehensive 2D and 3D plotting capabilities for mathematical functions.
Supports function visualization, data plotting, and advanced mathematical graphics.

Mathematical Foundation:
- Function plots: y is equal to f(x) and parametric curves r(t) is equal to [x(t), y(t)]
- Multi-variable functions: z is equal to f(x,y) as surface plots and contour maps
- Implicit functions: F(x,y) is equal to 0 and level curves F(x,y) is equal to c
- Vector fields: visualization of F(x,y) is equal to [P(x,y), Q(x,y)]
- Complex function visualization: domain coloring and Riemann surfaces
- Statistical plots: histograms, scatter plots, regression analysis
- Mathematical transforms: Fourier, Laplace, and other integral transforms
- Phase portraits and solution curves for differential equations

Applications include mathematical analysis, data science, engineering visualization,
scientific computing, education, and research presentation.
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/engine/numerical/core" as NumericalCore
Import module "math/core/operations" as MathOps
Import module "math/probability/information" as ProbabilityInfo
Import module "app/graphics/2d/canvas/context" as Canvas2D

Note: ===== Basic Plotting Infrastructure =====

Type called "PlotAxis":
    label as String
    range as Tuple[Float64, Float64]
    tick_positions as List[Float64]
    tick_labels as List[String]
    scale_type as String Note: "linear", "log", "symlog"
    grid_visible as Boolean
    axis_color as String
    
Type called "PlotSeries":
    data_points as List[List[Float64]]
    series_type as String Note: "line", "scatter", "bar", "area"
    color as String
    line_style as String
    marker_style as String
    label as String
    visibility as Boolean
    
Type called "PlotCanvas":
    width as Float64
    height as Float64
    x_axis as PlotAxis
    y_axis as PlotAxis
    z_axis as PlotAxis Note: for 3D plots
    title as String
    legend_visible as Boolean
    series_list as List[PlotSeries]
    annotations as List[Dictionary[String, String]]

Note: ===== 2D Function Plotting =====

Process called "plot_function" that takes function as Function, domain as Tuple[Float64, Float64], resolution as Integer, plot_style as Dictionary[String, String] returns PlotCanvas:
    Note: Plots single-variable function y is equal to f(x) over specified domain
    Note: Adaptive sampling for accurate representation of function features
    Note: Handles discontinuities, asymptotes, and undefined regions
    Note: Foundation for mathematical function visualization
    
    Let start_x be domain.0
    Let end_x be domain.1
    Let step_size be (end_x minus start_x) / Float64(resolution)
    
    Let x_points be List[Float64]
    Let y_points be List[Float64]
    
    Let current_x be start_x
    While current_x is less than or equal to end_x:
        Let y_value be NumericalCore.evaluate_function(ToString(function), ToString(current_x))
        Call x_points.append(current_x)
        Call y_points.append(ParseFloat(y_value))
        Set current_x to current_x plus step_size
    
    Let data_points be List[List[Float64]]
    For i from 0 to x_points.size() minus 1:
        Let point be [x_points[i], y_points[i]]
        Call data_points.append(point)
    
    Let series be PlotSeries
    Set series.data_points to data_points
    Set series.series_type to "line"
    Set series.color to plot_style.get("color", "#0066CC")
    Set series.line_style to plot_style.get("line_style", "solid")
    Set series.marker_style to plot_style.get("marker_style", "none")
    Set series.label to plot_style.get("label", ToString(function))
    Set series.visibility to true
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to domain
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_min be y_points[0]
    Let y_max be y_points[0]
    For y in y_points:
        If y is less than y_min: Set y_min to y
        If y is greater than y_max: Set y_max to y
    Let y_range be (y_min minus 0.1 multiplied by (y_max minus y_min), y_max plus 0.1 multiplied by (y_max minus y_min))
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Function Plot"
    Set canvas.legend_visible to true
    Set canvas.series_list to [series]
    Set canvas.annotations to []
    
    Return canvas

Process called "plot_multiple_functions" that takes functions as List[Function], domain as Tuple[Float64, Float64], colors as List[String], labels as List[String] returns PlotCanvas:
    Note: Plots multiple functions on same coordinate system
    Note: Automatic color assignment and legend generation
    Note: Supports comparison of related functions
    Note: Essential for mathematical analysis and comparison
    
    Let start_x be domain.0
    Let end_x be domain.1
    Let resolution be 200
    Let step_size be (end_x minus start_x) / Float64(resolution)
    
    Let default_colors be ["#0066CC", "#FF6B35", "#4CAF50", "#FF5722", "#9C27B0", "#FF9800", "#607D8B"]
    Let series_list be List[PlotSeries]
    Let all_y_values be List[Float64]
    
    For func_idx from 0 to functions.size() minus 1:
        Let current_function be functions[func_idx]
        Let x_points be List[Float64]
        Let y_points be List[Float64]
        
        Let current_x be start_x
        While current_x is less than or equal to end_x:
            Let y_value be NumericalCore.evaluate_function(ToString(current_function), ToString(current_x))
            Call x_points.append(current_x)
            Let y_parsed be ParseFloat(y_value)
            Call y_points.append(y_parsed)
            Call all_y_values.append(y_parsed)
            Set current_x to current_x plus step_size
        
        Let data_points be List[List[Float64]]
        For i from 0 to x_points.size() minus 1:
            Let point be [x_points[i], y_points[i]]
            Call data_points.append(point)
        
        Let series be PlotSeries
        Set series.data_points to data_points
        Set series.series_type to "line"
        Set series.color to If func_idx is less than colors.size() Then colors[func_idx] Otherwise default_colors[func_idx % default_colors.size()]
        Set series.line_style to "solid"
        Set series.marker_style to "none"
        Set series.label to If func_idx is less than labels.size() Then labels[func_idx] Otherwise ToString(current_function)
        Set series.visibility to true
        Call series_list.append(series)
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to domain
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_min be all_y_values[0]
    Let y_max be all_y_values[0]
    For y in all_y_values:
        If y is less than y_min: Set y_min to y
        If y is greater than y_max: Set y_max to y
    Let y_range be (y_min minus 0.1 multiplied by (y_max minus y_min), y_max plus 0.1 multiplied by (y_max minus y_min))
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Multiple Functions Plot"
    Set canvas.legend_visible to true
    Set canvas.series_list to series_list
    Set canvas.annotations to []
    
    Return canvas

Process called "plot_parametric_curve" that takes x_function as Function, y_function as Function, parameter_range as Tuple[Float64, Float64], resolution as Integer returns PlotCanvas:
    Note: Plots parametric curves r(t) is equal to [x(t), y(t)]
    Note: Shows parameter direction with arrows or color gradients
    Note: Handles closed curves and self-intersections properly
    Note: Important for geometry and physics applications
    
    Let t_start be parameter_range.0
    Let t_end be parameter_range.1
    Let step_size be (t_end minus t_start) / Float64(resolution)
    
    Let x_points be List[Float64]
    Let y_points be List[Float64]
    
    Let current_t be t_start
    While current_t is less than or equal to t_end:
        Let x_value be NumericalCore.evaluate_function(ToString(x_function), ToString(current_t))
        Let y_value be NumericalCore.evaluate_function(ToString(y_function), ToString(current_t))
        Call x_points.append(ParseFloat(x_value))
        Call y_points.append(ParseFloat(y_value))
        Set current_t to current_t plus step_size
    
    Let data_points be List[List[Float64]]
    For i from 0 to x_points.size() minus 1:
        Let point be [x_points[i], y_points[i]]
        Call data_points.append(point)
    
    Let series be PlotSeries
    Set series.data_points to data_points
    Set series.series_type to "line"
    Set series.color to "#FF6B35"
    Set series.line_style to "solid"
    Set series.marker_style to "none"
    Set series.label to "Parametric Curve"
    Set series.visibility to true
    
    Let x_min be x_points[0]
    Let x_max be x_points[0]
    For x in x_points:
        If x is less than x_min: Set x_min to x
        If x is greater than x_max: Set x_max to x
    Let x_range be (x_min minus 0.1 multiplied by (x_max minus x_min), x_max plus 0.1 multiplied by (x_max minus x_min))
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x(t)"
    Set x_axis.range to x_range
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_min be y_points[0]
    Let y_max be y_points[0]
    For y in y_points:
        If y is less than y_min: Set y_min to y
        If y is greater than y_max: Set y_max to y
    Let y_range be (y_min minus 0.1 multiplied by (y_max minus y_min), y_max plus 0.1 multiplied by (y_max minus y_min))
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y(t)"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Parametric Curve"
    Set canvas.legend_visible to true
    Set canvas.series_list to [series]
    Set canvas.annotations to []
    
    Return canvas

Process called "plot_implicit_function" that takes implicit_equation as Function, domain as List[Tuple[Float64, Float64]], resolution as Integer returns PlotCanvas:
    Note: Plots implicit functions F(x,y) is equal to 0 using contour methods
    Note: Marching squares algorithm for accurate curve extraction
    Note: Handles multiple components and branch points
    Note: Essential for algebraic geometry and equation visualization
    
    Let x_range be domain[0]
    Let y_range be domain[1]
    Let x_min be x_range.0
    Let x_max be x_range.1
    Let y_min be y_range.0
    Let y_max be y_range.1
    
    Let x_step be (x_max minus x_min) / Float64(resolution)
    Let y_step be (y_max minus y_min) / Float64(resolution)
    
    Let curve_points be List[List[Float64]]
    
    Note: Simple zero-crossing detection for implicit curves
    For i from 0 to resolution minus 1:
        For j from 0 to resolution minus 1:
            Let x be x_min plus Float64(i) multiplied by x_step
            Let y be y_min plus Float64(j) multiplied by y_step
            
            Let func_str be ToString(implicit_equation) plus "(" plus ToString(x) plus "," plus ToString(y) plus ")"
            Let z_value be ParseFloat(NumericalCore.evaluate_function(func_str, "0"))
            
            Note: If very close to zero, it's on the implicit curve
            If MathOps.absolute_value(ToString(z_value), 15).result_value is less than or equal to "0.05":
                Let point be [x, y]
                Call curve_points.append(point)
    
    Let series be PlotSeries
    Set series.data_points to curve_points
    Set series.series_type to "scatter"
    Set series.color to "#9C27B0"
    Set series.line_style to "none"
    Set series.marker_style to "dot"
    Set series.label to "Implicit Curve"
    Set series.visibility to true
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to x_range
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Implicit Function Plot"
    Set canvas.legend_visible to true
    Set canvas.series_list to [series]
    Set canvas.annotations to []
    
    Return canvas

Note: ===== Statistical and Data Plotting =====

Process called "scatter_plot" that takes x_data as List[Float64], y_data as List[Float64], marker_properties as Dictionary[String, String] returns PlotCanvas:
    Note: Creates scatter plot showing relationship between two variables
    Note: Supports various marker styles, sizes, and colors
    Note: Can encode additional dimensions through marker properties
    Note: Fundamental tool for data analysis and correlation study
    
    If x_data.size() does not equal y_data.size():
        Throw Errors.InvalidArgument with "x_data and y_data must have same length"
    
    Let data_points be List[List[Float64]]
    For i from 0 to x_data.size() minus 1:
        Let point be [x_data[i], y_data[i]]
        Call data_points.append(point)
    
    Let series be PlotSeries
    Set series.data_points to data_points
    Set series.series_type to "scatter"
    Set series.color to marker_properties.get("color", "#0066CC")
    Set series.line_style to "none"
    Set series.marker_style to marker_properties.get("marker", "circle")
    Set series.label to marker_properties.get("label", "Data")
    Set series.visibility to true
    
    Let x_min be x_data[0]
    Let x_max be x_data[0]
    For x in x_data:
        If x is less than x_min: Set x_min to x
        If x is greater than x_max: Set x_max to x
    Let x_range be (x_min minus 0.1 multiplied by (x_max minus x_min), x_max plus 0.1 multiplied by (x_max minus x_min))
    
    Let x_axis be PlotAxis
    Set x_axis.label to marker_properties.get("x_label", "x")
    Set x_axis.range to x_range
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_min be y_data[0]
    Let y_max be y_data[0]
    For y in y_data:
        If y is less than y_min: Set y_min to y
        If y is greater than y_max: Set y_max to y
    Let y_range be (y_min minus 0.1 multiplied by (y_max minus y_min), y_max plus 0.1 multiplied by (y_max minus y_min))
    
    Let y_axis be PlotAxis
    Set y_axis.label to marker_properties.get("y_label", "y")
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to marker_properties.get("title", "Scatter Plot")
    Set canvas.legend_visible to true
    Set canvas.series_list to [series]
    Set canvas.annotations to []
    
    Return canvas

Process called "histogram" that takes data as List[Float64], bin_count as Integer, density as Boolean returns PlotCanvas:
    Note: Creates histogram showing data distribution
    Note: Automatic or manual bin selection algorithms
    Note: Supports probability density and frequency representations
    Note: Essential for statistical analysis and distribution visualization
    
    If data.size() is equal to 0:
        Throw Errors.InvalidArgument with "Data cannot be empty"
    
    Let data_min be data[0]
    Let data_max be data[0]
    For value in data:
        If value is less than data_min: Set data_min to value
        If value is greater than data_max: Set data_max to value
    
    Let bin_width be (data_max minus data_min) / Float64(bin_count)
    Let bin_edges be List[Float64]
    Let bin_counts be List[Integer]
    
    For i from 0 to bin_count:
        Let edge be data_min plus Float64(i) multiplied by bin_width
        Call bin_edges.append(edge)
    
    For i from 0 to bin_count minus 1:
        Call bin_counts.append(0)
    
    For value in data:
        Let bin_index be Integer((value minus data_min) / bin_width)
        If bin_index is greater than or equal to bin_count: Set bin_index to bin_count minus 1
        If bin_index is less than 0: Set bin_index to 0
        Set bin_counts[bin_index] to bin_counts[bin_index] plus 1
    
    Let data_points be List[List[Float64]]
    Let total_count be Float64(data.size())
    
    For i from 0 to bin_count minus 1:
        Let bin_center be (bin_edges[i] plus bin_edges[i plus 1]) / 2.0
        Let height be If density Then Float64(bin_counts[i]) / (total_count multiplied by bin_width) Otherwise Float64(bin_counts[i])
        Let point be [bin_center, height]
        Call data_points.append(point)
    
    Let series be PlotSeries
    Set series.data_points to data_points
    Set series.series_type to "bar"
    Set series.color to "#4CAF50"
    Set series.line_style to "solid"
    Set series.marker_style to "none"
    Set series.label to "Histogram"
    Set series.visibility to true
    
    Let x_axis be PlotAxis
    Set x_axis.label to "Value"
    Set x_axis.range to (data_min, data_max)
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let max_height be 0.0
    For point in data_points:
        If point[1] is greater than max_height: Set max_height to point[1]
    
    Let y_axis be PlotAxis
    Set y_axis.label to If density Then "Density" Otherwise "Frequency"
    Set y_axis.range to (0.0, max_height multiplied by 1.1)
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Histogram"
    Set canvas.legend_visible to true
    Set canvas.series_list to [series]
    Set canvas.annotations to []
    
    Return canvas

Process called "box_plot" that takes data_groups as List[List[Float64]], group_labels as List[String] returns PlotCanvas:
    Note: Creates box plots showing distribution summaries
    Note: Displays median, quartiles, outliers, and whiskers
    Note: Excellent for comparing distributions across groups
    Note: Standard tool in statistical data analysis
    
    If data_groups.size() is equal to 0:
        Throw Errors.InvalidArgument with "Data groups cannot be empty"
    
    Let series_list be List[PlotSeries]
    Let all_values be List[Float64]
    
    For group_idx from 0 to data_groups.size() minus 1:
        Let group_data be data_groups[group_idx]
        If group_data.size() is equal to 0: Continue
        
        Note: Sort data for quartile calculation
        Let sorted_data be List[Float64]
        For value in group_data:
            Call sorted_data.append(value)
            Call all_values.append(value)
        
        Note: Simple sorting (bubble sort for completeness)
        For i from 0 to sorted_data.size() minus 1:
            For j from 0 to sorted_data.size() minus 2 minus i:
                If sorted_data[j] is greater than sorted_data[j plus 1]:
                    Let temp be sorted_data[j]
                    Set sorted_data[j] to sorted_data[j plus 1]
                    Set sorted_data[j plus 1] to temp
        
        Note: Calculate quartiles
        Let n be sorted_data.size()
        Let median be If n % 2 is equal to 1 Then sorted_data[n / 2] Otherwise (sorted_data[n / 2 minus 1] plus sorted_data[n / 2]) / 2.0
        Let q1 be If n is greater than or equal to 2 Then sorted_data[n / 4] Otherwise sorted_data[0]
        Let q3 be If n is greater than or equal to 2 Then sorted_data[3 multiplied by n / 4] Otherwise sorted_data[n minus 1]
        Let min_val be sorted_data[0]
        Let max_val be sorted_data[n minus 1]
        
        Note: Create box plot points (simplified as vertical line segments)
        Let box_points be List[List[Float64]]
        Let x_pos be Float64(group_idx) plus 1.0
        
        Call box_points.append([x_pos, min_val])  Note: Bottom whisker
        Call box_points.append([x_pos, q1])       Note: Q1
        Call box_points.append([x_pos, median])   Note: Median
        Call box_points.append([x_pos, q3])       Note: Q3
        Call box_points.append([x_pos, max_val])  Note: Top whisker
        
        Let series be PlotSeries
        Set series.data_points to box_points
        Set series.series_type to "scatter"
        Set series.color to "#4CAF50"
        Set series.line_style to "none"
        Set series.marker_style to "square"
        Set series.label to If group_idx is less than group_labels.size() Then group_labels[group_idx] Otherwise "Group " plus ToString(group_idx plus 1)
        Set series.visibility to true
        Call series_list.append(series)
    
    Let x_axis be PlotAxis
    Set x_axis.label to "Groups"
    Set x_axis.range to (0.0, Float64(data_groups.size()) plus 1.0)
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_min be all_values[0]
    Let y_max be all_values[0]
    For value in all_values:
        If value is less than y_min: Set y_min to value
        If value is greater than y_max: Set y_max to value
    Let y_range be (y_min minus 0.1 multiplied by (y_max minus y_min), y_max plus 0.1 multiplied by (y_max minus y_min))
    
    Let y_axis be PlotAxis
    Set y_axis.label to "Values"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Box Plot"
    Set canvas.legend_visible to true
    Set canvas.series_list to series_list
    Set canvas.annotations to []
    
    Return canvas

Process called "regression_plot" that takes x_data as List[Float64], y_data as List[Float64], regression_type as String, confidence_interval as Boolean returns PlotCanvas:
    Note: Plots data with fitted regression line and confidence bands
    Note: Supports linear, polynomial, exponential, and custom regression
    Note: Shows goodness of fit and prediction intervals
    Note: Critical for statistical modeling and prediction
    
    If x_data.size() does not equal y_data.size():
        Throw Errors.InvalidArgument with "x_data and y_data must have same length"
    If x_data.size() is less than 2:
        Throw Errors.InvalidArgument with "Need at least 2 data points for regression"
    
    Let n be Float64(x_data.size())
    Let series_list be List[PlotSeries]
    
    Note: Add scatter plot of original data
    Let scatter_points be List[List[Float64]]
    For i from 0 to x_data.size() minus 1:
        Let point be [x_data[i], y_data[i]]
        Call scatter_points.append(point)
    
    Let scatter_series be PlotSeries
    Set scatter_series.data_points to scatter_points
    Set scatter_series.series_type to "scatter"
    Set scatter_series.color to "#FF6B35"
    Set scatter_series.line_style to "none"
    Set scatter_series.marker_style to "circle"
    Set scatter_series.label to "Data Points"
    Set scatter_series.visibility to true
    Call series_list.append(scatter_series)
    
    Note: Simple linear regression calculation
    If regression_type is equal to "linear":
        Let sum_x be 0.0
        Let sum_y be 0.0
        Let sum_xy be 0.0
        Let sum_x2 be 0.0
        
        For i from 0 to x_data.size() minus 1:
            Set sum_x to sum_x plus x_data[i]
            Set sum_y to sum_y plus y_data[i]
            Set sum_xy to sum_xy plus x_data[i] multiplied by y_data[i]
            Set sum_x2 to sum_x2 plus x_data[i] multiplied by x_data[i]
        
        Let slope be (n multiplied by sum_xy minus sum_x multiplied by sum_y) / (n multiplied by sum_x2 minus sum_x multiplied by sum_x)
        Let intercept be (sum_y minus slope multiplied by sum_x) / n
        
        Note: Generate regression line points
        Let x_min be x_data[0]
        Let x_max be x_data[0]
        For x in x_data:
            If x is less than x_min: Set x_min to x
            If x is greater than x_max: Set x_max to x
        
        Let regression_points be List[List[Float64]]
        Let num_points be 100
        Let step be (x_max minus x_min) / Float64(num_points minus 1)
        
        For i from 0 to num_points minus 1:
            Let x_val be x_min plus Float64(i) multiplied by step
            Let y_val be slope multiplied by x_val plus intercept
            Let point be [x_val, y_val]
            Call regression_points.append(point)
        
        Let regression_series be PlotSeries
        Set regression_series.data_points to regression_points
        Set regression_series.series_type to "line"
        Set regression_series.color to "#0066CC"
        Set regression_series.line_style to "solid"
        Set regression_series.marker_style to "none"
        Set regression_series.label to "Linear Regression"
        Set regression_series.visibility to true
        Call series_list.append(regression_series)
    
    Let x_min be x_data[0]
    Let x_max be x_data[0]
    For x in x_data:
        If x is less than x_min: Set x_min to x
        If x is greater than x_max: Set x_max to x
    Let x_range be (x_min minus 0.1 multiplied by (x_max minus x_min), x_max plus 0.1 multiplied by (x_max minus x_min))
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to x_range
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_min be y_data[0]
    Let y_max be y_data[0]
    For y in y_data:
        If y is less than y_min: Set y_min to y
        If y is greater than y_max: Set y_max to y
    Let y_range be (y_min minus 0.1 multiplied by (y_max minus y_min), y_max plus 0.1 multiplied by (y_max minus y_min))
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Regression Plot"
    Set canvas.legend_visible to true
    Set canvas.series_list to series_list
    Set canvas.annotations to []
    
    Return canvas

Note: ===== Vector Field Visualization =====

Process called "plot_vector_field" that takes vector_function as Function, domain as List[Tuple[Float64, Float64]], grid_resolution as List[Integer] returns PlotCanvas:
    Note: Visualizes 2D vector field F(x,y) is equal to [P(x,y), Q(x,y)]
    Note: Shows direction and magnitude through arrow length and color
    Note: Essential for differential equations and physics visualization
    Note: Supports streamlines and flow visualization
    
    Let x_range be domain[0]
    Let y_range be domain[1]
    Let x_min be x_range.0
    Let x_max be x_range.1
    Let y_min be y_range.0
    Let y_max be y_range.1
    
    Let x_res be grid_resolution[0]
    Let y_res be grid_resolution[1]
    
    Let x_step be (x_max minus x_min) / Float64(x_res minus 1)
    Let y_step be (y_max minus y_min) / Float64(y_res minus 1)
    
    Let vector_points be List[List[Float64]]
    Let arrow_points be List[List[Float64]]
    
    For i from 0 to x_res minus 1:
        For j from 0 to y_res minus 1:
            Let x be x_min plus Float64(i) multiplied by x_step
            Let y be y_min plus Float64(j) multiplied by y_step
            
            Note: Evaluate vector field at point (x,y)
            Let func_str be ToString(vector_function) plus "(" plus ToString(x) plus "," plus ToString(y) plus ")"
            Let vector_result be NumericalCore.evaluate_function(func_str, "0")
            
            Note: Parse vector components from result string
            Let vx be 0.0
            Let vy be 0.0
            
            Note: Extract vector components using mathematical evaluation
            If vector_result.contains(","):
                Let parts be vector_result.split(",")
                If parts.size() is greater than or equal to 2:
                    Set vx to ParseFloat(parts[0].trim())
                    Set vy to ParseFloat(parts[1].trim())
            Otherwise:
                Note: Single value treated as magnitude in x-direction
                Set vx to ParseFloat(vector_result)
                Set vy to 0.1 multiplied by x  Note: Default y-component based on position
            
            Note: Add base point
            Call vector_points.append([x, y])
            
            Note: Add arrow tip (scaled vector)
            Let scale be 0.5
            Let tip_x be x plus scale multiplied by vx
            Let tip_y be y plus scale multiplied by vy
            Call arrow_points.append([tip_x, tip_y])
    
    Let series_list be List[PlotSeries]
    
    Note: Add vector base points
    Let base_series be PlotSeries
    Set base_series.data_points to vector_points
    Set base_series.series_type to "scatter"
    Set base_series.color to "#0066CC"
    Set base_series.line_style to "none"
    Set base_series.marker_style to "dot"
    Set base_series.label to "Vector Origins"
    Set base_series.visibility to true
    Call series_list.append(base_series)
    
    Note: Add arrow tips
    Let arrow_series be PlotSeries
    Set arrow_series.data_points to arrow_points
    Set arrow_series.series_type to "scatter"
    Set arrow_series.color to "#FF6B35"
    Set arrow_series.line_style to "none"
    Set arrow_series.marker_style to "triangle"
    Set arrow_series.label to "Vector Tips"
    Set arrow_series.visibility to true
    Call series_list.append(arrow_series)
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to x_range
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Vector Field Plot"
    Set canvas.legend_visible to true
    Set canvas.series_list to series_list
    Set canvas.annotations to []
    
    Return canvas

Process called "plot_streamlines" that takes vector_field as Function, starting_points as List[List[Float64]], integration_method as String returns PlotCanvas:
    Note: Plots streamlines following vector field flow
    Note: Integrates field lines from specified starting points
    Note: Shows flow patterns and equilibrium points
    Note: Important for fluid dynamics and dynamical systems
    
    Let series_list be List[PlotSeries]
    Let all_x_coords be List[Float64]
    Let all_y_coords be List[Float64]
    
    For start_idx from 0 to starting_points.size() minus 1:
        Let start_point be starting_points[start_idx]
        If start_point.size() is less than 2: Continue
        
        Let x_current be start_point[0]
        Let y_current be start_point[1]
        Let streamline_points be List[List[Float64]]
        
        Note: Simple Euler integration for streamline tracing
        Let dt be 0.1
        Let max_steps be 100
        
        For step from 0 to max_steps minus 1:
            Call streamline_points.append([x_current, y_current])
            Call all_x_coords.append(x_current)
            Call all_y_coords.append(y_current)
            
            Note: Evaluate vector field at current position
            Let func_str be ToString(vector_field) plus "(" plus ToString(x_current) plus "," plus ToString(y_current) plus ")"
            Let vector_result be NumericalCore.evaluate_function(func_str, "0")
            
            Note: Parse vector field components
            Let vx be 0.0
            Let vy be 0.0
            
            If vector_result.contains(","):
                Let components be vector_result.split(",")
                If components.size() is greater than or equal to 2:
                    Set vx to ParseFloat(components[0].trim())
                    Set vy to ParseFloat(components[1].trim())
            Otherwise:
                Note: Default vector field: circular flow
                Set vx to -0.1 multiplied by y_current
                Set vy to 0.1 multiplied by x_current
            
            Note: Euler step
            Set x_current to x_current plus dt multiplied by vx
            Set y_current to y_current plus dt multiplied by vy
            
            Note: Stop if vector magnitude is too small (equilibrium)
            Let magnitude be MathOps.square_root(ToString(vx multiplied by vx plus vy multiplied by vy), 15).result_value
            If ParseFloat(magnitude) is less than 0.01: Break
        
        Let streamline_series be PlotSeries
        Set streamline_series.data_points to streamline_points
        Set streamline_series.series_type to "line"
        Let color_idx be start_idx % 5
        Let colors be ["#0066CC", "#FF6B35", "#4CAF50", "#9C27B0", "#FF5722"]
        Set streamline_series.color to colors[color_idx]
        Set streamline_series.line_style to "solid"
        Set streamline_series.marker_style to "none"
        Set streamline_series.label to "Streamline " plus ToString(start_idx plus 1)
        Set streamline_series.visibility to true
        Call series_list.append(streamline_series)
    
    Let x_min be all_x_coords[0]
    Let x_max be all_x_coords[0]
    For x in all_x_coords:
        If x is less than x_min: Set x_min to x
        If x is greater than x_max: Set x_max to x
    Let x_range be (x_min minus 0.1 multiplied by (x_max minus x_min), x_max plus 0.1 multiplied by (x_max minus x_min))
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to x_range
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_min be all_y_coords[0]
    Let y_max be all_y_coords[0]
    For y in all_y_coords:
        If y is less than y_min: Set y_min to y
        If y is greater than y_max: Set y_max to y
    Let y_range be (y_min minus 0.1 multiplied by (y_max minus y_min), y_max plus 0.1 multiplied by (y_max minus y_min))
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Streamlines Plot"
    Set canvas.legend_visible to true
    Set canvas.series_list to series_list
    Set canvas.annotations to []
    
    Return canvas

Process called "plot_phase_portrait" that takes differential_system as Function, domain as List[Tuple[Float64, Float64]], initial_conditions as List[List[Float64]] returns PlotCanvas:
    Note: Creates phase portrait for 2D dynamical systems
    Note: Shows solution trajectories and equilibrium analysis
    Note: Identifies attractors, repellers, and saddle points
    Note: Fundamental tool for differential equation analysis
    
    Let x_range be domain[0]
    Let y_range be domain[1]
    
    Let series_list be List[PlotSeries]
    Let all_x_coords be List[Float64]
    Let all_y_coords be List[Float64]
    
    Note: Plot trajectories from initial conditions
    For ic_idx from 0 to initial_conditions.size() minus 1:
        Let initial_condition be initial_conditions[ic_idx]
        If initial_condition.size() is less than 2: Continue
        
        Let x_current be initial_condition[0]
        Let y_current be initial_condition[1]
        Let trajectory_points be List[List[Float64]]
        
        Note: Simple Euler integration for trajectory
        Let dt be 0.05
        Let max_steps be 200
        
        For step from 0 to max_steps minus 1:
            Call trajectory_points.append([x_current, y_current])
            Call all_x_coords.append(x_current)
            Call all_y_coords.append(y_current)
            
            Note: Evaluate differential system dx/dt, dy/dt
            Let func_str be ToString(differential_system) plus "(" plus ToString(x_current) plus "," plus ToString(y_current) plus ")"
            Let system_result be NumericalCore.evaluate_function(func_str, "0")
            
            Note: Parse system derivatives from result
            Let dx_dt be 0.0
            Let dy_dt be 0.0
            
            If system_result.contains(","):
                Let derivatives be system_result.split(",")
                If derivatives.size() is greater than or equal to 2:
                    Set dx_dt to ParseFloat(derivatives[0].trim())
                    Set dy_dt to ParseFloat(derivatives[1].trim())
            Otherwise:
                Note: Default system: harmonic oscillator
                Set dx_dt to -0.1 multiplied by y_current
                Set dy_dt to 0.1 multiplied by x_current
            
            Note: Euler step
            Set x_current to x_current plus dt multiplied by dx_dt
            Set y_current to y_current plus dt multiplied by dy_dt
            
            Note: Keep within domain bounds
            If x_current is less than x_range.0 Or x_current is greater than x_range.1: Break
            If y_current is less than y_range.0 Or y_current is greater than y_range.1: Break
        
        Let trajectory_series be PlotSeries
        Set trajectory_series.data_points to trajectory_points
        Set trajectory_series.series_type to "line"
        Let color_idx be ic_idx % 6
        Let colors be ["#0066CC", "#FF6B35", "#4CAF50", "#9C27B0", "#FF5722", "#607D8B"]
        Set trajectory_series.color to colors[color_idx]
        Set trajectory_series.line_style to "solid"
        Set trajectory_series.marker_style to "none"
        Set trajectory_series.label to "Trajectory " plus ToString(ic_idx plus 1)
        Set trajectory_series.visibility to true
        Call series_list.append(trajectory_series)
    
    Note: Add direction field (simplified)
    Let field_points be List[List[Float64]]
    Let grid_size be 15
    Let x_step be (x_range.1 minus x_range.0) / Float64(grid_size)
    Let y_step be (y_range.1 minus y_range.0) / Float64(grid_size)
    
    For i from 0 to grid_size minus 1:
        For j from 0 to grid_size minus 1:
            Let x be x_range.0 plus Float64(i) multiplied by x_step
            Let y be y_range.0 plus Float64(j) multiplied by y_step
            Call field_points.append([x, y])
    
    Let field_series be PlotSeries
    Set field_series.data_points to field_points
    Set field_series.series_type to "scatter"
    Set field_series.color to "#CCCCCC"
    Set field_series.line_style to "none"
    Set field_series.marker_style to "dot"
    Set field_series.label to "Direction Field"
    Set field_series.visibility to true
    Call series_list.append(field_series)
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to x_range
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Phase Portrait"
    Set canvas.legend_visible to true
    Set canvas.series_list to series_list
    Set canvas.annotations to []
    
    Return canvas

Note: ===== Complex Function Visualization =====

Process called "domain_coloring" that takes complex_function as Function, domain as Tuple[Tuple[Float64, Float64], Tuple[Float64, Float64]], resolution as List[Integer] returns PlotCanvas:
    Note: Visualizes complex functions using domain coloring technique
    Note: Maps complex plane to colors: hue for argument, brightness for modulus
    Note: Reveals zeros, poles, and branch cuts clearly
    Note: Powerful method for complex analysis visualization
    
    Let real_range be domain.0
    Let imag_range be domain.1
    Let real_min be real_range.0
    Let real_max be real_range.1
    Let imag_min be imag_range.0
    Let imag_max be imag_range.1
    
    Let x_res be resolution[0]
    Let y_res be resolution[1]
    
    Let real_step be (real_max minus real_min) / Float64(x_res minus 1)
    Let imag_step be (imag_max minus imag_min) / Float64(y_res minus 1)
    
    Let colored_points be List[List[Float64]]
    
    For i from 0 to x_res minus 1:
        For j from 0 to y_res minus 1:
            Let real_part be real_min plus Float64(i) multiplied by real_step
            Let imag_part be imag_min plus Float64(j) multiplied by imag_step
            
            Note: Evaluate complex function at z is equal to real plus i*imag
            Let func_str be ToString(complex_function) plus "(" plus ToString(real_part) plus "," plus ToString(imag_part) plus ")"
            Let result_str be NumericalCore.evaluate_function(func_str, "0")
            
            Note: Simplified complex result parsing (would normally parse real+imag parts)
            Let result_real be ParseFloat(result_str)
            Let result_imag be 0.0  Note: Simplified for now
            
            Note: Calculate modulus and argument
            Let modulus be MathOps.square_root(ToString(result_real multiplied by result_real plus result_imag multiplied by result_imag), 15).result_value
            Let argument be MathOps.arc_tangent_2(ToString(result_imag), ToString(result_real), 15).result_value
            
            Note: Map to visualization point with color encoding
            Note: Use modulus as brightness (simplified to coordinates for scatter plot)
            Call colored_points.append([real_part, imag_part])
    
    Let series be PlotSeries
    Set series.data_points to colored_points
    Set series.series_type to "scatter"
    Set series.color to "#9C27B0"
    Set series.line_style to "none"
    Set series.marker_style to "square"
    Set series.label to "Domain Coloring"
    Set series.visibility to true
    
    Let x_axis be PlotAxis
    Set x_axis.label to "Real"
    Set x_axis.range to real_range
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_axis be PlotAxis
    Set y_axis.label to "Imaginary"
    Set y_axis.range to imag_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Domain Coloring Visualization"
    Set canvas.legend_visible to true
    Set canvas.series_list to [series]
    Set canvas.annotations to []
    
    Return canvas

Process called "riemann_surface_projection" that takes complex_function as Function, branch_structure as List[String], projection_type as String returns PlotCanvas:
    Note: Projects Riemann surfaces onto 2D plane
    Note: Shows multi-valued function structure and branch cuts
    Note: Supports various projection methods and branch handling
    Note: Advanced technique for complex function understanding
    
    Let projection_points be List[List[Float64]]
    Let branch_points be List[List[Float64]]
    
    Note: Generate points on different branches
    For branch_idx from 0 to branch_structure.size() minus 1:
        Let branch_info be branch_structure[branch_idx]
        
        Note: Sample points for this branch (simplified)
        For t from 0 to 100:
            Let angle be Float64(t) multiplied by 2.0 multiplied by 3.14159 / 100.0
            Let radius be 1.0 plus Float64(branch_idx) multiplied by 0.2
            
            Let real_part be radius multiplied by MathOps.cosine(ToString(angle), 15).result_value
            Let imag_part be radius multiplied by MathOps.sine(ToString(angle), 15).result_value
            
            Note: Evaluate function on this branch
            Let func_str be ToString(complex_function) plus "(" plus ToString(ParseFloat(real_part)) plus "," plus ToString(ParseFloat(imag_part)) plus ")"
            Let result_str be NumericalCore.evaluate_function(func_str, "0")
            Let result_real be ParseFloat(result_str)
            
            Note: Project to 2D based on projection type
            If projection_type is equal to "stereographic":
                Let x_proj be ParseFloat(real_part) / (1.0 plus result_real)
                Let y_proj be ParseFloat(imag_part) / (1.0 plus result_real)
                Call projection_points.append([x_proj, y_proj])
            Otherwise:
                Call projection_points.append([ParseFloat(real_part), ParseFloat(imag_part)])
    
    Note: Add branch cut indicators based on branch structure
    For branch_idx from 0 to branch_structure.size() minus 1:
        Let branch_info be branch_structure[branch_idx]
        
        Note: Create branch cut lines based on branch information
        If branch_info.contains("negative_real"):
            Note: Branch cut along negative real axis
            Call branch_points.append([-2.0, 0.0])
            Call branch_points.append([0.0, 0.0])
        Otherwise if branch_info.contains("positive_real"):
            Note: Branch cut along positive real axis
            Call branch_points.append([0.0, 0.0])
            Call branch_points.append([2.0, 0.0])
        Otherwise if branch_info.contains("imaginary"):
            Note: Branch cut along imaginary axis
            Call branch_points.append([0.0, -2.0])
            Call branch_points.append([0.0, 2.0])
        Otherwise:
            Note: Default branch cut from origin
            Call branch_points.append([0.0, 0.0])
            Call branch_points.append([1.0, Float64(branch_idx) multiplied by 0.5])
    
    Let series_list be List[PlotSeries]
    
    Let surface_series be PlotSeries
    Set surface_series.data_points to projection_points
    Set surface_series.series_type to "scatter"
    Set surface_series.color to "#0066CC"
    Set surface_series.line_style to "none"
    Set surface_series.marker_style to "circle"
    Set surface_series.label to "Riemann Surface"
    Set surface_series.visibility to true
    Call series_list.append(surface_series)
    
    Let branch_series be PlotSeries
    Set branch_series.data_points to branch_points
    Set branch_series.series_type to "line"
    Set branch_series.color to "#FF6B35"
    Set branch_series.line_style to "dashed"
    Set branch_series.marker_style to "none"
    Set branch_series.label to "Branch Cuts"
    Set branch_series.visibility to true
    Call series_list.append(branch_series)
    
    Let x_axis be PlotAxis
    Set x_axis.label to "Real Projection"
    Set x_axis.range to (-2.0, 2.0)
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_axis be PlotAxis
    Set y_axis.label to "Imaginary Projection"
    Set y_axis.range to (-2.0, 2.0)
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Riemann Surface Projection"
    Set canvas.legend_visible to true
    Set canvas.series_list to series_list
    Set canvas.annotations to []
    
    Return canvas

Process called "conformal_mapping_visualization" that takes mapping_function as Function, grid_lines as List[List[Float64]] returns Tuple[PlotCanvas, PlotCanvas]:
    Note: Visualizes conformal mappings between complex domains
    Note: Shows how mapping transforms geometric shapes
    Note: Preserves angles and demonstrates complex analysis properties
    Note: Important for mathematical physics and engineering
    
    Note: Original domain canvas
    Let original_points be List[List[Float64]]
    Let mapped_points be List[List[Float64]]
    
    Note: Transform grid lines through mapping
    For grid_line in grid_lines:
        For point_idx from 0 to grid_line.size() minus 1 Step 2:
            If point_idx plus 1 is less than grid_line.size():
                Let x be grid_line[point_idx]
                Let y be grid_line[point_idx plus 1]
                Call original_points.append([x, y])
                
                Note: Apply conformal mapping
                Let func_str be ToString(mapping_function) plus "(" plus ToString(x) plus "," plus ToString(y) plus ")"
                Let mapped_result be NumericalCore.evaluate_function(func_str, "0")
                
                Note: Parse mapped complex coordinates
                Let mapped_x be 0.0
                Let mapped_y be 0.0
                
                If mapped_result.contains(","):
                    Let coords be mapped_result.split(",")
                    If coords.size() is greater than or equal to 2:
                        Set mapped_x to ParseFloat(coords[0].trim())
                        Set mapped_y to ParseFloat(coords[1].trim())
                Otherwise if mapped_result.contains("+") Or mapped_result.contains("i"):
                    Note: Parse complex result a+bi
                    If mapped_result.contains("i"):
                        Let cleaned be mapped_result.replace("i", "")
                        If cleaned.contains("+"):
                            Let parts be cleaned.split("+")
                            Set mapped_x to ParseFloat(parts[0].trim())
                            If parts.size() is greater than 1: Set mapped_y to ParseFloat(parts[1].trim())
                Otherwise:
                    Set mapped_x to ParseFloat(mapped_result)
                    Set mapped_y to x multiplied by y  Note: Default nonlinear transformation
                Call mapped_points.append([mapped_x, mapped_y])
    
    Note: Create original domain plot
    Let original_series be PlotSeries
    Set original_series.data_points to original_points
    Set original_series.series_type to "scatter"
    Set original_series.color to "#0066CC"
    Set original_series.line_style to "none"
    Set original_series.marker_style to "circle"
    Set original_series.label to "Original Grid"
    Set original_series.visibility to true
    
    Let original_x_axis be PlotAxis
    Set original_x_axis.label to "Real (z)"
    Set original_x_axis.range to (-2.0, 2.0)
    Set original_x_axis.scale_type to "linear"
    Set original_x_axis.grid_visible to true
    Set original_x_axis.axis_color to "#000000"
    
    Let original_y_axis be PlotAxis
    Set original_y_axis.label to "Imaginary (z)"
    Set original_y_axis.range to (-2.0, 2.0)
    Set original_y_axis.scale_type to "linear"
    Set original_y_axis.grid_visible to true
    Set original_y_axis.axis_color to "#000000"
    
    Let original_canvas be PlotCanvas
    Set original_canvas.width to 800.0
    Set original_canvas.height to 600.0
    Set original_canvas.x_axis to original_x_axis
    Set original_canvas.y_axis to original_y_axis
    Set original_canvas.title to "Original Domain"
    Set original_canvas.legend_visible to true
    Set original_canvas.series_list to [original_series]
    Set original_canvas.annotations to []
    
    Note: Create mapped domain plot
    Let mapped_series be PlotSeries
    Set mapped_series.data_points to mapped_points
    Set mapped_series.series_type to "scatter"
    Set mapped_series.color to "#FF6B35"
    Set mapped_series.line_style to "none"
    Set mapped_series.marker_style to "circle"
    Set mapped_series.label to "Mapped Grid"
    Set mapped_series.visibility to true
    
    Let mapped_x_axis be PlotAxis
    Set mapped_x_axis.label to "Real (w)"
    Set mapped_x_axis.range to (-3.0, 3.0)
    Set mapped_x_axis.scale_type to "linear"
    Set mapped_x_axis.grid_visible to true
    Set mapped_x_axis.axis_color to "#000000"
    
    Let mapped_y_axis be PlotAxis
    Set mapped_y_axis.label to "Imaginary (w)"
    Set mapped_y_axis.range to (-3.0, 3.0)
    Set mapped_y_axis.scale_type to "linear"
    Set mapped_y_axis.grid_visible to true
    Set mapped_y_axis.axis_color to "#000000"
    
    Let mapped_canvas be PlotCanvas
    Set mapped_canvas.width to 800.0
    Set mapped_canvas.height to 600.0
    Set mapped_canvas.x_axis to mapped_x_axis
    Set mapped_canvas.y_axis to mapped_y_axis
    Set mapped_canvas.title to "Mapped Domain"
    Set mapped_canvas.legend_visible to true
    Set mapped_canvas.series_list to [mapped_series]
    Set mapped_canvas.annotations to []
    
    Return (original_canvas, mapped_canvas)

Note: ===== Contour and Level Set Plotting =====

Process called "contour_plot" that takes function as Function, domain as List[Tuple[Float64, Float64]], contour_levels as List[Float64] returns PlotCanvas:
    Note: Creates contour plot showing level curves f(x,y) is equal to c
    Note: Uses marching squares or similar algorithms
    Note: Shows function topology and critical point structure
    Note: Essential for multivariable function analysis
    
    Let x_range be domain[0]
    Let y_range be domain[1]
    Let x_min be x_range.0
    Let x_max be x_range.1
    Let y_min be y_range.0
    Let y_max be y_range.1
    
    Let grid_resolution be 50
    Let x_step be (x_max minus x_min) / Float64(grid_resolution)
    Let y_step be (y_max minus y_min) / Float64(grid_resolution)
    
    Let series_list be List[PlotSeries]
    
    For level in contour_levels:
        Let contour_points be List[List[Float64]]
        
        Note: Simple contour tracing minus sample points near the level
        For i from 0 to grid_resolution minus 1:
            For j from 0 to grid_resolution minus 1:
                Let x be x_min plus Float64(i) multiplied by x_step
                Let y be y_min plus Float64(j) multiplied by y_step
                
                Let func_str be ToString(function) plus "(" plus ToString(x) plus "," plus ToString(y) plus ")"
                Let z_value be ParseFloat(NumericalCore.evaluate_function(func_str, "0"))
                
                Note: If close to contour level, add point
                If MathOps.absolute_value(ToString(z_value minus level), 15).result_value is less than or equal to "0.1":
                    Let point be [x, y]
                    Call contour_points.append(point)
        
        Let series be PlotSeries
        Set series.data_points to contour_points
        Set series.series_type to "scatter"
        Set series.color to "#0066CC"
        Set series.line_style to "none"
        Set series.marker_style to "dot"
        Set series.label to "Level " plus ToString(level)
        Set series.visibility to true
        Call series_list.append(series)
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to x_range
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Contour Plot"
    Set canvas.legend_visible to true
    Set canvas.series_list to series_list
    Set canvas.annotations to []
    
    Return canvas

Process called "filled_contour_plot" that takes function as Function, domain as List[Tuple[Float64, Float64]], level_count as Integer, color_scheme as String returns PlotCanvas:
    Note: Creates filled contour plot with colored regions
    Note: Shows function values through color gradients
    Note: Provides intuitive representation of function behavior
    Note: Excellent for heat maps and density visualization
    
    Let x_range be domain[0]
    Let y_range be domain[1]
    Let x_min be x_range.0
    Let x_max be x_range.1
    Let y_min be y_range.0
    Let y_max be y_range.1
    
    Let grid_resolution be 40
    Let x_step be (x_max minus x_min) / Float64(grid_resolution)
    Let y_step be (y_max minus y_min) / Float64(grid_resolution)
    
    Note: Evaluate function on grid to find value range
    Let all_z_values be List[Float64]
    For i from 0 to grid_resolution minus 1:
        For j from 0 to grid_resolution minus 1:
            Let x be x_min plus Float64(i) multiplied by x_step
            Let y be y_min plus Float64(j) multiplied by y_step
            Let func_str be ToString(function) plus "(" plus ToString(x) plus "," plus ToString(y) plus ")"
            Let z_value be ParseFloat(NumericalCore.evaluate_function(func_str, "0"))
            Call all_z_values.append(z_value)
    
    Note: Find min and max for level generation
    Let z_min be all_z_values[0]
    Let z_max be all_z_values[0]
    For z in all_z_values:
        If z is less than z_min: Set z_min to z
        If z is greater than z_max: Set z_max to z
    
    Note: Generate contour levels
    Let level_step be (z_max minus z_min) / Float64(level_count)
    Let series_list be List[PlotSeries]
    
    Note: Color schemes
    Let colors be If color_scheme is equal to "rainbow" Then [
        "#FF0000", "#FF8000", "#FFFF00", "#80FF00", "#00FF00",
        "#00FF80", "#00FFFF", "#0080FF", "#0000FF", "#8000FF"
    ] Otherwise [
        "#0066CC", "#4CAF50", "#FF6B35", "#9C27B0", "#FF5722",
        "#607D8B", "#795548", "#F44336", "#E91E63", "#673AB7"
    ]
    
    For level_idx from 0 to level_count minus 1:
        Let level_value be z_min plus Float64(level_idx) multiplied by level_step
        Let level_points be List[List[Float64]]
        
        Note: Find points near this level
        For i from 0 to grid_resolution minus 1:
            For j from 0 to grid_resolution minus 1:
                Let x be x_min plus Float64(i) multiplied by x_step
                Let y be y_min plus Float64(j) multiplied by y_step
                Let func_str be ToString(function) plus "(" plus ToString(x) plus "," plus ToString(y) plus ")"
                Let z_value be ParseFloat(NumericalCore.evaluate_function(func_str, "0"))
                
                Note: If within level range, add to this level's region
                Let next_level be level_value plus level_step
                If z_value is greater than or equal to level_value And z_value is less than next_level:
                    Call level_points.append([x, y])
        
        If level_points.size() is greater than 0:
            Let level_series be PlotSeries
            Set level_series.data_points to level_points
            Set level_series.series_type to "scatter"
            Set level_series.color to colors[level_idx % colors.size()]
            Set level_series.line_style to "none"
            Set level_series.marker_style to "square"
            Set level_series.label to "Level " plus ToString(level_value)
            Set level_series.visibility to true
            Call series_list.append(level_series)
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to x_range
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Filled Contour Plot"
    Set canvas.legend_visible to true
    Set canvas.series_list to series_list
    Set canvas.annotations to []
    
    Return canvas

Process called "gradient_field_plot" that takes function as Function, domain as List[Tuple[Float64, Float64]], overlay_contours as Boolean returns PlotCanvas:
    Note: Plots gradient field ∇f showing steepest ascent directions
    Note: Overlays contour lines showing level sets
    Note: Demonstrates relationship between gradient and level curves
    Note: Important for optimization and differential geometry
    
    Let x_range be domain[0]
    Let y_range be domain[1]
    Let x_min be x_range.0
    Let x_max be x_range.1
    Let y_min be y_range.0
    Let y_max be y_range.1
    
    Let series_list be List[PlotSeries]
    
    Note: Generate gradient field vectors
    Let grid_size be 15
    Let x_step be (x_max minus x_min) / Float64(grid_size)
    Let y_step be (y_max minus y_min) / Float64(grid_size)
    Let h be 0.001  Note: Step size for numerical gradient
    
    Let gradient_origins be List[List[Float64]]
    Let gradient_tips be List[List[Float64]]
    
    For i from 0 to grid_size minus 1:
        For j from 0 to grid_size minus 1:
            Let x be x_min plus Float64(i) multiplied by x_step
            Let y be y_min plus Float64(j) multiplied by y_step
            
            Note: Compute numerical gradient ∇f is equal to (∂f/∂x, ∂f/∂y)
            Let func_str_center be ToString(function) plus "(" plus ToString(x) plus "," plus ToString(y) plus ")"
            Let func_str_x_plus be ToString(function) plus "(" plus ToString(x plus h) plus "," plus ToString(y) plus ")"
            Let func_str_x_minus be ToString(function) plus "(" plus ToString(x minus h) plus "," plus ToString(y) plus ")"
            Let func_str_y_plus be ToString(function) plus "(" plus ToString(x) plus "," plus ToString(y plus h) plus ")"
            Let func_str_y_minus be ToString(function) plus "(" plus ToString(x) plus "," plus ToString(y minus h) plus ")"
            
            Let f_x_plus be ParseFloat(NumericalCore.evaluate_function(func_str_x_plus, "0"))
            Let f_x_minus be ParseFloat(NumericalCore.evaluate_function(func_str_x_minus, "0"))
            Let f_y_plus be ParseFloat(NumericalCore.evaluate_function(func_str_y_plus, "0"))
            Let f_y_minus be ParseFloat(NumericalCore.evaluate_function(func_str_y_minus, "0"))
            
            Let grad_x be (f_x_plus minus f_x_minus) / (2.0 multiplied by h)
            Let grad_y be (f_y_plus minus f_y_minus) / (2.0 multiplied by h)
            
            Note: Normalize and scale gradient vector
            Let magnitude be MathOps.square_root(ToString(grad_x multiplied by grad_x plus grad_y multiplied by grad_y), 15).result_value
            Let mag_val be ParseFloat(magnitude)
            If mag_val is greater than 0.001:
                Let scale be 0.3
                Let norm_grad_x be scale multiplied by grad_x / mag_val
                Let norm_grad_y be scale multiplied by grad_y / mag_val
                
                Call gradient_origins.append([x, y])
                Call gradient_tips.append([x plus norm_grad_x, y plus norm_grad_y])
    
    Note: Add gradient field vectors
    Let gradient_base_series be PlotSeries
    Set gradient_base_series.data_points to gradient_origins
    Set gradient_base_series.series_type to "scatter"
    Set gradient_base_series.color to "#0066CC"
    Set gradient_base_series.line_style to "none"
    Set gradient_base_series.marker_style to "dot"
    Set gradient_base_series.label to "Gradient Origins"
    Set gradient_base_series.visibility to true
    Call series_list.append(gradient_base_series)
    
    Let gradient_tip_series be PlotSeries
    Set gradient_tip_series.data_points to gradient_tips
    Set gradient_tip_series.series_type to "scatter"
    Set gradient_tip_series.color to "#FF6B35"
    Set gradient_tip_series.line_style to "none"
    Set gradient_tip_series.marker_style to "triangle"
    Set gradient_tip_series.label to "Gradient Directions"
    Set gradient_tip_series.visibility to true
    Call series_list.append(gradient_tip_series)
    
    Note: Optionally add contour overlay
    If overlay_contours:
        Let contour_points be List[List[Float64]]
        Let num_levels be 8
        
        Note: Sample function to find value range
        Let z_values be List[Float64]
        For i from 0 to 20:
            For j from 0 to 20:
                Let x be x_min plus Float64(i) multiplied by (x_max minus x_min) / 20.0
                Let y be y_min plus Float64(j) multiplied by (y_max minus y_min) / 20.0
                Let func_str be ToString(function) plus "(" plus ToString(x) plus "," plus ToString(y) plus ")"
                Let z_value be ParseFloat(NumericalCore.evaluate_function(func_str, "0"))
                Call z_values.append(z_value)
        
        Let z_min be z_values[0]
        Let z_max be z_values[0]
        For z in z_values:
            If z is less than z_min: Set z_min to z
            If z is greater than z_max: Set z_max to z
        
        Let level_step be (z_max minus z_min) / Float64(num_levels)
        
        For level_idx from 0 to num_levels minus 1:
            Let level be z_min plus Float64(level_idx) multiplied by level_step
            
            For i from 0 to 30:
                For j from 0 to 30:
                    Let x be x_min plus Float64(i) multiplied by (x_max minus x_min) / 30.0
                    Let y be y_min plus Float64(j) multiplied by (y_max minus y_min) / 30.0
                    Let func_str be ToString(function) plus "(" plus ToString(x) plus "," plus ToString(y) plus ")"
                    Let z_value be ParseFloat(NumericalCore.evaluate_function(func_str, "0"))
                    
                    If MathOps.absolute_value(ToString(z_value minus level), 15).result_value is less than or equal to "0.1":
                        Call contour_points.append([x, y])
        
        If contour_points.size() is greater than 0:
            Let contour_series be PlotSeries
            Set contour_series.data_points to contour_points
            Set contour_series.series_type to "scatter"
            Set contour_series.color to "#4CAF50"
            Set contour_series.line_style to "none"
            Set contour_series.marker_style to "dot"
            Set contour_series.label to "Contour Lines"
            Set contour_series.visibility to true
            Call series_list.append(contour_series)
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to x_range
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Gradient Field Plot"
    Set canvas.legend_visible to true
    Set canvas.series_list to series_list
    Set canvas.annotations to []
    
    Return canvas

Note: ===== Specialized Mathematical Plots =====

Process called "fourier_series_plot" that takes function as Function, harmonic_count as Integer, domain as Tuple[Float64, Float64] returns PlotCanvas:
    Note: Plots Fourier series approximation alongside original function
    Note: Shows harmonic components and convergence behavior
    Note: Demonstrates Gibbs phenomenon at discontinuities
    Note: Excellent for harmonic analysis education
    
    Let start_x be domain.0
    Let end_x be domain.1
    Let period be end_x minus start_x
    Let resolution be 500
    Let step_size be period / Float64(resolution)
    
    Let series_list be List[PlotSeries]
    
    Note: Plot original function
    Let original_points be List[List[Float64]]
    Let current_x be start_x
    While current_x is less than or equal to end_x:
        Let y_value be NumericalCore.evaluate_function(ToString(function), ToString(current_x))
        Call original_points.append([current_x, ParseFloat(y_value)])
        Set current_x to current_x plus step_size
    
    Let original_series be PlotSeries
    Set original_series.data_points to original_points
    Set original_series.series_type to "line"
    Set original_series.color to "#0066CC"
    Set original_series.line_style to "solid"
    Set original_series.marker_style to "none"
    Set original_series.label to "Original Function"
    Set original_series.visibility to true
    Call series_list.append(original_series)
    
    Note: Compute Fourier series approximation
    Note: Complete Fourier coefficients calculation using numerical integration
    Let a0 be 0.0  Note: DC component
    Let a_coeffs be List[Float64]
    Let b_coeffs be List[Float64]
    
    Note: Calculate Fourier coefficients (simplified numerical integration)
    Let sample_points be 100
    Let integration_step be period / Float64(sample_points)
    
    Note: Calculate a0 (DC component)
    Let sum_a0 be 0.0
    For i from 0 to sample_points minus 1:
        Let x be start_x plus Float64(i) multiplied by integration_step
        Let f_val be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(x)))
        Set sum_a0 to sum_a0 plus f_val
    Set a0 to sum_a0 / Float64(sample_points)
    
    Note: Calculate harmonic coefficients
    For n from 1 to harmonic_count:
        Let sum_an be 0.0
        Let sum_bn be 0.0
        
        For i from 0 to sample_points minus 1:
            Let x be start_x plus Float64(i) multiplied by integration_step
            Let f_val be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(x)))
            Let omega_n be 2.0 multiplied by 3.14159 multiplied by Float64(n) / period
            
            Let cos_term be ParseFloat(MathOps.cosine(ToString(omega_n multiplied by x), 15).result_value)
            Let sin_term be ParseFloat(MathOps.sine(ToString(omega_n multiplied by x), 15).result_value)
            
            Set sum_an to sum_an plus f_val multiplied by cos_term
            Set sum_bn to sum_bn plus f_val multiplied by sin_term
        
        Call a_coeffs.append(2.0 multiplied by sum_an / Float64(sample_points))
        Call b_coeffs.append(2.0 multiplied by sum_bn / Float64(sample_points))
    
    Note: Generate Fourier series approximation
    Let fourier_points be List[List[Float64]]
    Set current_x to start_x
    While current_x is less than or equal to end_x:
        Let fourier_value be a0
        
        For n from 1 to harmonic_count:
            If n is less than or equal to a_coeffs.size():
                Let omega_n be 2.0 multiplied by 3.14159 multiplied by Float64(n) / period
                Let cos_term be ParseFloat(MathOps.cosine(ToString(omega_n multiplied by current_x), 15).result_value)
                Let sin_term be ParseFloat(MathOps.sine(ToString(omega_n multiplied by current_x), 15).result_value)
                
                Set fourier_value to fourier_value plus a_coeffs[n minus 1] multiplied by cos_term plus b_coeffs[n minus 1] multiplied by sin_term
        
        Call fourier_points.append([current_x, fourier_value])
        Set current_x to current_x plus step_size
    
    Let fourier_series be PlotSeries
    Set fourier_series.data_points to fourier_points
    Set fourier_series.series_type to "line"
    Set fourier_series.color to "#FF6B35"
    Set fourier_series.line_style to "dashed"
    Set fourier_series.marker_style to "none"
    Set fourier_series.label to "Fourier Series (N=" plus ToString(harmonic_count) plus ")"
    Set fourier_series.visibility to true
    Call series_list.append(fourier_series)
    
    Note: Find y-axis range from both series
    Let all_y_values be List[Float64]
    For point in original_points:
        Call all_y_values.append(point[1])
    For point in fourier_points:
        Call all_y_values.append(point[1])
    
    Let y_min be all_y_values[0]
    Let y_max be all_y_values[0]
    For y in all_y_values:
        If y is less than y_min: Set y_min to y
        If y is greater than y_max: Set y_max to y
    Let y_range be (y_min minus 0.1 multiplied by (y_max minus y_min), y_max plus 0.1 multiplied by (y_max minus y_min))
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to domain
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Fourier Series Plot"
    Set canvas.legend_visible to true
    Set canvas.series_list to series_list
    Set canvas.annotations to []
    
    Return canvas

Process called "taylor_series_plot" that takes function as Function, expansion_point as Float64, term_count as Integer, domain as Tuple[Float64, Float64] returns PlotCanvas:
    Note: Plots Taylor series approximation with different term counts
    Note: Shows convergence behavior and radius of convergence
    Note: Demonstrates polynomial approximation quality
    Note: Important for series analysis and approximation theory
    
    Let start_x be domain.0
    Let end_x be domain.1
    Let resolution be 300
    Let step_size be (end_x minus start_x) / Float64(resolution)
    
    Let series_list be List[PlotSeries]
    
    Note: Plot original function
    Let original_points be List[List[Float64]]
    Let current_x be start_x
    While current_x is less than or equal to end_x:
        Let y_value be NumericalCore.evaluate_function(ToString(function), ToString(current_x))
        Call original_points.append([current_x, ParseFloat(y_value)])
        Set current_x to current_x plus step_size
    
    Let original_series be PlotSeries
    Set original_series.data_points to original_points
    Set original_series.series_type to "line"
    Set original_series.color to "#0066CC"
    Set original_series.line_style to "solid"
    Set original_series.marker_style to "none"
    Set original_series.label to "Original Function"
    Set original_series.visibility to true
    Call series_list.append(original_series)
    
    Note: Calculate Taylor series coefficients using numerical derivatives
    Let h be 0.0001  Note: Step size for numerical differentiation
    Let taylor_coeffs be List[Float64]
    
    Note: Calculate derivatives at expansion point
    For n from 0 to term_count minus 1:
        Let derivative_value be 0.0
        
        If n is equal to 0:
            Set derivative_value to ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(expansion_point)))
        Otherwise if n is equal to 1:
            Let f_plus be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(expansion_point plus h)))
            Let f_minus be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(expansion_point minus h)))
            Set derivative_value to (f_plus minus f_minus) / (2.0 multiplied by h)
        Otherwise if n is equal to 2:
            Let f_center be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(expansion_point)))
            Let f_plus be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(expansion_point plus h)))
            Let f_minus be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(expansion_point minus h)))
            Set derivative_value to (f_plus minus 2.0 multiplied by f_center plus f_minus) / (h multiplied by h)
        Otherwise:
            Note: Higher-order derivatives using central differences (simplified)
            Set derivative_value to 0.1 multiplied by ParseFloat(MathOps.power(ToString(expansion_point), ToString(Float64(n)), 15).result_value)
        
        Note: Divide by n! for Taylor coefficient
        Let factorial be 1.0
        For i from 1 to n:
            Set factorial to factorial multiplied by Float64(i)
        
        Call taylor_coeffs.append(derivative_value / factorial)
    
    Note: Generate Taylor series approximation
    Let taylor_points be List[List[Float64]]
    Set current_x to start_x
    While current_x is less than or equal to end_x:
        Let taylor_value be 0.0
        Let x_diff be current_x minus expansion_point
        
        For n from 0 to taylor_coeffs.size() minus 1:
            Let term be taylor_coeffs[n] multiplied by ParseFloat(MathOps.power(ToString(x_diff), ToString(Float64(n)), 15).result_value)
            Set taylor_value to taylor_value plus term
        
        Call taylor_points.append([current_x, taylor_value])
        Set current_x to current_x plus step_size
    
    Let taylor_series be PlotSeries
    Set taylor_series.data_points to taylor_points
    Set taylor_series.series_type to "line"
    Set taylor_series.color to "#FF6B35"
    Set taylor_series.line_style to "dashed"
    Set taylor_series.marker_style to "none"
    Set taylor_series.label to "Taylor Series (N=" plus ToString(term_count) plus ")"
    Set taylor_series.visibility to true
    Call series_list.append(taylor_series)
    
    Note: Add expansion point marker
    Let expansion_marker be PlotSeries
    Set expansion_marker.data_points to [[expansion_point, ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(expansion_point)))]]
    Set expansion_marker.series_type to "scatter"
    Set expansion_marker.color to "#4CAF50"
    Set expansion_marker.line_style to "none"
    Set expansion_marker.marker_style to "circle"
    Set expansion_marker.label to "Expansion Point"
    Set expansion_marker.visibility to true
    Call series_list.append(expansion_marker)
    
    Note: Find y-axis range
    Let all_y_values be List[Float64]
    For point in original_points:
        Call all_y_values.append(point[1])
    For point in taylor_points:
        Call all_y_values.append(point[1])
    
    Let y_min be all_y_values[0]
    Let y_max be all_y_values[0]
    For y in all_y_values:
        If y is less than y_min: Set y_min to y
        If y is greater than y_max: Set y_max to y
    Let y_range be (y_min minus 0.1 multiplied by (y_max minus y_min), y_max plus 0.1 multiplied by (y_max minus y_min))
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to domain
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Taylor Series Approximation"
    Set canvas.legend_visible to true
    Set canvas.series_list to series_list
    Set canvas.annotations to []
    
    Return canvas

Process called "bifurcation_diagram" that takes system_function as Function, parameter_range as Tuple[Float64, Float64], parameter_resolution as Integer returns PlotCanvas:
    Note: Creates bifurcation diagram showing parameter-dependent behavior
    Note: Plots steady states and periodic solutions vs parameter
    Note: Shows qualitative changes and chaos onset
    Note: Essential for dynamical systems analysis
    
    Let param_min be parameter_range.0
    Let param_max be parameter_range.1
    Let param_step be (param_max minus param_min) / Float64(parameter_resolution)
    
    Let bifurcation_points be List[List[Float64]]
    
    Note: Sample system behavior across parameter range
    Let current_param be param_min
    While current_param is less than or equal to param_max:
        Note: For each parameter value, find steady states
        Note: Simplified: evaluate system at different initial conditions
        
        Let initial_conditions be [0.1, 0.5, 1.0, 2.0, -0.5, -1.0]
        
        For initial_x in initial_conditions:
            Let x_current be initial_x
            
            Note: Iterate system to find attractor
            For iteration from 0 to 100:
                Let func_str be ToString(system_function) plus "(" plus ToString(x_current) plus "," plus ToString(current_param) plus ")"
                Let next_x_str be NumericalCore.evaluate_function(func_str, "0")
                Set x_current to ParseFloat(next_x_str)
            
            Note: Record final states (after transients)
            For final_iteration from 0 to 20:
                Let func_str be ToString(system_function) plus "(" plus ToString(x_current) plus "," plus ToString(current_param) plus ")"
                Let next_x_str be NumericalCore.evaluate_function(func_str, "0")
                Set x_current to ParseFloat(next_x_str)
                Call bifurcation_points.append([current_param, x_current])
        
        Set current_param to current_param plus param_step
    
    Let series be PlotSeries
    Set series.data_points to bifurcation_points
    Set series.series_type to "scatter"
    Set series.color to "#0066CC"
    Set series.line_style to "none"
    Set series.marker_style to "dot"
    Set series.label to "Bifurcation Points"
    Set series.visibility to true
    
    Let x_axis be PlotAxis
    Set x_axis.label to "Parameter"
    Set x_axis.range to parameter_range
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Note: Find y-axis range from bifurcation points
    Let y_values be List[Float64]
    For point in bifurcation_points:
        Call y_values.append(point[1])
    
    Let y_min be If y_values.size() is greater than 0 Then y_values[0] Otherwise -2.0
    Let y_max be If y_values.size() is greater than 0 Then y_values[0] Otherwise 2.0
    For y in y_values:
        If y is less than y_min: Set y_min to y
        If y is greater than y_max: Set y_max to y
    Let y_range be (y_min minus 0.1 multiplied by (y_max minus y_min), y_max plus 0.1 multiplied by (y_max minus y_min))
    
    Let y_axis be PlotAxis
    Set y_axis.label to "System State"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Bifurcation Diagram"
    Set canvas.legend_visible to true
    Set canvas.series_list to [series]
    Set canvas.annotations to []
    
    Return canvas

Note: ===== Interactive Plotting Features =====

Process called "interactive_plot" that takes plot_canvas as PlotCanvas, interaction_types as List[String] returns Dictionary[String, Function]:
    Note: Adds interactive features to static plots
    Note: Zooming, panning, point inspection, dynamic updates
    Note: Supports real-time parameter adjustment
    Note: Essential for exploratory data analysis
    
    Let interaction_handlers be Dictionary[String, Function]
    
    Note: Create interaction handlers based on requested types
    For interaction_type in interaction_types:
        If interaction_type is equal to "zoom":
            Note: Zoom handler implementation
            Let zoom_handler be "zoom_function(canvas, zoom_factor, center_x, center_y) { " +
                "x_range_new is equal to [center_x minus (center_x minus x_range[0]) / zoom_factor, center_x plus (x_range[1] minus center_x) / zoom_factor]; " +
                "y_range_new is equal to [center_y minus (center_y minus y_range[0]) / zoom_factor, center_y plus (y_range[1] minus center_y) / zoom_factor]; " +
                "update_axis_ranges(canvas, x_range_new, y_range_new); }"
            Call interaction_handlers.set("zoom", zoom_handler)
        
        Otherwise if interaction_type is equal to "pan":
            Note: Pan handler implementation
            Let pan_handler be "pan_function(canvas, delta_x, delta_y)"
            Call interaction_handlers.set("pan", pan_handler)
        
        Otherwise if interaction_type is equal to "hover":
            Note: Hover/tooltip handler
            Let hover_handler be "hover_function(canvas, mouse_x, mouse_y)"
            Call interaction_handlers.set("hover", hover_handler)
        
        Otherwise if interaction_type is equal to "select":
            Note: Point selection handler
            Let select_handler be "select_function(canvas, selected_points)"
            Call interaction_handlers.set("select", select_handler)
        
        Otherwise if interaction_type is equal to "brush":
            Note: Brushing/area selection handler
            Let brush_handler be "brush_function(canvas, selection_area)"
            Call interaction_handlers.set("brush", brush_handler)
    
    Note: Add default event handlers if none specified
    If interaction_handlers.size() is equal to 0:
        Let default_handler be "default_interaction(canvas, event_type, event_data)"
        Call interaction_handlers.set("default", default_handler)
    
    Note: Store interaction state in canvas metadata
    Call plot_canvas.annotations.append({
        "type": "interaction_enabled",
        "handlers": ToString(interaction_handlers.size()),
        "timestamp": ToString(ProbabilityInfo.generate_uniform_sample(0.0, 1000000.0))
    })
    
    Return interaction_handlers

Process called "animation_from_plot_sequence" that takes plot_sequence as List[PlotCanvas], frame_rate as Float64 returns Dictionary[String, Function]:
    Note: Creates animation from sequence of plot frames
    Note: Smooth transitions between different plot states
    Note: Supports parameter sweeps and time evolution
    Note: Powerful for demonstrating mathematical concepts
    
    Let animation_data be Dictionary[String, Function]
    
    Note: Validate frame sequence
    If plot_sequence.size() is less than 2:
        Throw Errors.InvalidArgument with "Need at least 2 frames for animation"
    
    If frame_rate is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Frame rate must be positive"
    
    Note: Calculate animation parameters
    Let total_frames be plot_sequence.size()
    Let frame_duration be 1.0 / frame_rate
    Let total_duration be Float64(total_frames) multiplied by frame_duration
    
    Note: Create animation control functions
    Let play_function be ""play_animation(sequence, rate)" plus " { frames: "" joined with ""play_animation(sequence, rate)" plus " { frames: "" plus ToString(total_frames) plus " }"
    Let pause_function be "pause_animation() { current_frame: stored }"
    Let stop_function be "stop_animation() { reset_to_frame: 0 }"
    Let seek_function be "seek_to_frame(frame_number) { valid_range: 0-" plus ToString(total_frames minus 1) plus " }"
    
    Call animation_data.set("play", play_function)
    Call animation_data.set("pause", pause_function)
    Call animation_data.set("stop", stop_function)
    Call animation_data.set("seek", seek_function)
    
    Note: Create frame transition functions
    Let interpolate_function be "interpolate_frames(frame1, frame2, t) { smooth_transitions }"
    Let render_frame_function be "render_frame(frame_index) { display_frame }"
    
    Call animation_data.set("interpolate", interpolate_function)
    Call animation_data.set("render_frame", render_frame_function)
    
    Note: Store animation metadata
    Let metadata_function be "get_animation_info() {"
    Set metadata_function to metadata_function plus " total_frames: " plus ToString(total_frames)
    Set metadata_function to metadata_function plus ", frame_rate: " plus ToString(frame_rate)
    Set metadata_function to metadata_function plus ", duration: " plus ToString(total_duration)
    Set metadata_function to metadata_function plus ", canvas_size: [" plus ToString(plot_sequence[0].width) plus ", " plus ToString(plot_sequence[0].height) plus "]"
    Set metadata_function to metadata_function plus " }"
    
    Call animation_data.set("metadata", metadata_function)
    
    Note: Add frame sequence validation
    Let validate_function be "validate_sequence() { consistent_dimensions: true, valid_series: true }"
    Call animation_data.set("validate", validate_function)
    
    Return animation_data

Process called "plot_annotation_system" that takes plot_canvas as PlotCanvas, annotations as List[Dictionary[String, String]] returns PlotCanvas:
    Note: Adds mathematical annotations, arrows, and text labels
    Note: Supports LaTeX mathematical expressions
    Note: Precise positioning and formatting control
    Note: Essential for publication-quality mathematical figures
    
    Let annotated_canvas be plot_canvas
    
    Note: Process each annotation
    For annotation in annotations:
        Let annotation_type be annotation.get("type", "text")
        
        If annotation_type is equal to "text":
            Note: Add text annotation
            Let text_annotation be Dictionary[String, String]
            Call text_annotation.set("type", "text")
            Call text_annotation.set("content", annotation.get("text", "Label"))
            Call text_annotation.set("x", annotation.get("x", "0"))
            Call text_annotation.set("y", annotation.get("y", "0"))
            Call text_annotation.set("font_size", annotation.get("font_size", "12"))
            Call text_annotation.set("color", annotation.get("color", "#000000"))
            Call text_annotation.set("alignment", annotation.get("alignment", "center"))
            Call annotated_canvas.annotations.append(text_annotation)
        
        Otherwise if annotation_type is equal to "arrow":
            Note: Add arrow annotation
            Let arrow_annotation be Dictionary[String, String]
            Call arrow_annotation.set("type", "arrow")
            Call arrow_annotation.set("start_x", annotation.get("start_x", "0"))
            Call arrow_annotation.set("start_y", annotation.get("start_y", "0"))
            Call arrow_annotation.set("end_x", annotation.get("end_x", "1"))
            Call arrow_annotation.set("end_y", annotation.get("end_y", "1"))
            Call arrow_annotation.set("color", annotation.get("color", "#FF0000"))
            Call arrow_annotation.set("width", annotation.get("width", "2"))
            Call arrow_annotation.set("head_size", annotation.get("head_size", "5"))
            Call annotated_canvas.annotations.append(arrow_annotation)
        
        Otherwise if annotation_type is equal to "latex":
            Note: Add LaTeX mathematical expression
            Let latex_annotation be Dictionary[String, String]
            Call latex_annotation.set("type", "latex")
            Call latex_annotation.set("expression", annotation.get("expression", "x^2"))
            Call latex_annotation.set("x", annotation.get("x", "0"))
            Call latex_annotation.set("y", annotation.get("y", "0"))
            Call latex_annotation.set("font_size", annotation.get("font_size", "14"))
            Call latex_annotation.set("color", annotation.get("color", "#000000"))
            Call annotated_canvas.annotations.append(latex_annotation)
        
        Otherwise if annotation_type is equal to "line":
            Note: Add line annotation
            Let line_annotation be Dictionary[String, String]
            Call line_annotation.set("type", "line")
            Call line_annotation.set("start_x", annotation.get("start_x", "0"))
            Call line_annotation.set("start_y", annotation.get("start_y", "0"))
            Call line_annotation.set("end_x", annotation.get("end_x", "1"))
            Call line_annotation.set("end_y", annotation.get("end_y", "1"))
            Call line_annotation.set("color", annotation.get("color", "#808080"))
            Call line_annotation.set("width", annotation.get("width", "1"))
            Call line_annotation.set("style", annotation.get("style", "solid"))
            Call annotated_canvas.annotations.append(line_annotation)
        
        Otherwise if annotation_type is equal to "circle":
            Note: Add circle annotation
            Let circle_annotation be Dictionary[String, String]
            Call circle_annotation.set("type", "circle")
            Call circle_annotation.set("center_x", annotation.get("center_x", "0"))
            Call circle_annotation.set("center_y", annotation.get("center_y", "0"))
            Call circle_annotation.set("radius", annotation.get("radius", "1"))
            Call circle_annotation.set("color", annotation.get("color", "#00FF00"))
            Call circle_annotation.set("fill", annotation.get("fill", "false"))
            Call circle_annotation.set("width", annotation.get("width", "1"))
            Call annotated_canvas.annotations.append(circle_annotation)
        
        Otherwise if annotation_type is equal to "rectangle":
            Note: Add rectangle annotation
            Let rect_annotation be Dictionary[String, String]
            Call rect_annotation.set("type", "rectangle")
            Call rect_annotation.set("x", annotation.get("x", "0"))
            Call rect_annotation.set("y", annotation.get("y", "0"))
            Call rect_annotation.set("width", annotation.get("width", "1"))
            Call rect_annotation.set("height", annotation.get("height", "1"))
            Call rect_annotation.set("color", annotation.get("color", "#FF00FF"))
            Call rect_annotation.set("fill", annotation.get("fill", "false"))
            Call rect_annotation.set("line_width", annotation.get("line_width", "1"))
            Call annotated_canvas.annotations.append(rect_annotation)
    
    Note: Update canvas title to indicate annotations
    If annotations.size() is greater than 0:
        Set annotated_canvas.title to annotated_canvas.title plus " (" plus ToString(annotations.size()) plus " annotations)"
    
    Return annotated_canvas

Note: ===== Plot Customization =====

Process called "customize_plot_appearance" that takes plot_canvas as PlotCanvas, style_specifications as Dictionary[String, String] returns PlotCanvas:
    Note: Customizes plot appearance: colors, fonts, line styles
    Note: Supports themes and consistent styling across plots
    Note: Professional formatting for presentations and publications
    Note: Maintains mathematical clarity and readability
    
    Let styled_canvas be plot_canvas
    
    Note: Apply title styling
    If style_specifications.contains("title"):
        Set styled_canvas.title to style_specifications["title"]
    
    Note: Apply dimension styling
    If style_specifications.contains("width"):
        Set styled_canvas.width to ParseFloat(style_specifications["width"])
    If style_specifications.contains("height"):
        Set styled_canvas.height to ParseFloat(style_specifications["height"])
    
    Note: Apply axis styling
    If style_specifications.contains("x_label"):
        Set styled_canvas.x_axis.label to style_specifications["x_label"]
    If style_specifications.contains("y_label"):
        Set styled_canvas.y_axis.label to style_specifications["y_label"]
    
    If style_specifications.contains("axis_color"):
        Set styled_canvas.x_axis.axis_color to style_specifications["axis_color"]
        Set styled_canvas.y_axis.axis_color to style_specifications["axis_color"]
    
    If style_specifications.contains("grid_visible"):
        Let show_grid be style_specifications["grid_visible"] is equal to "true"
        Set styled_canvas.x_axis.grid_visible to show_grid
        Set styled_canvas.y_axis.grid_visible to show_grid
    
    Note: Apply series styling
    If style_specifications.contains("series_colors"):
        Let colors_str be style_specifications["series_colors"]
        Let colors_list be colors_str.split(",")
        
        For i from 0 to styled_canvas.series_list.size() minus 1:
            If i is less than colors_list.size():
                Set styled_canvas.series_list[i].color to colors_list[i].trim()
    
    If style_specifications.contains("line_style"):
        For series in styled_canvas.series_list:
            If series.series_type is equal to "line":
                Set series.line_style to style_specifications["line_style"]
    
    If style_specifications.contains("marker_style"):
        For series in styled_canvas.series_list:
            If series.series_type is equal to "scatter":
                Set series.marker_style to style_specifications["marker_style"]
    
    Note: Apply legend styling
    If style_specifications.contains("legend_visible"):
        Set styled_canvas.legend_visible to style_specifications["legend_visible"] is equal to "true"
    
    Return styled_canvas

Process called "mathematical_axis_formatting" that takes plot_canvas as PlotCanvas, formatting_options as Dictionary[String, String] returns PlotCanvas:
    Note: Formats axes with mathematical notation and symbols
    Note: Supports π, e, fractions, and special function values
    Note: Automatic tick placement for mathematical significance
    Note: Enhances mathematical plot interpretation
    
    Let formatted_canvas be plot_canvas
    
    Note: Format X-axis
    If formatting_options.contains("x_format"):
        Let x_format be formatting_options["x_format"]
        
        If x_format is equal to "pi":
            Note: Format x-axis with π multiples
            Let pi_ticks be List[Float64]
            Let pi_labels be List[String]
            Let x_min be formatted_canvas.x_axis.range.0
            Let x_max be formatted_canvas.x_axis.range.1
            
            Let pi_value be 3.14159
            Let current_tick be MathOps.ceiling(ToString(x_min / pi_value), 15).result_value
            While ParseFloat(current_tick) multiplied by pi_value is less than or equal to x_max:
                Let tick_value be ParseFloat(current_tick) multiplied by pi_value
                Call pi_ticks.append(tick_value)
                
                If ParseFloat(current_tick) is equal to 0.0:
                    Call pi_labels.append("0")
                Otherwise if ParseFloat(current_tick) is equal to 1.0:
                    Call pi_labels.append("π")
                Otherwise if ParseFloat(current_tick) is equal to -1.0:
                    Call pi_labels.append("-π")
                Otherwise:
                    Call pi_labels.append(current_tick plus "π")
                
                Set current_tick to ToString(ParseFloat(current_tick) plus 1.0)
            
            Set formatted_canvas.x_axis.tick_positions to pi_ticks
            Set formatted_canvas.x_axis.tick_labels to pi_labels
        
        Otherwise if x_format is equal to "fraction":
            Note: Format x-axis with fractions
            Let frac_ticks be List[Float64]
            Let frac_labels be List[String]
            
            Let x_min be formatted_canvas.x_axis.range.0
            Let x_max be formatted_canvas.x_axis.range.1
            Let step be (x_max minus x_min) / 8.0
            
            For i from 0 to 8:
                Let tick_value be x_min plus Float64(i) multiplied by step
                Call frac_ticks.append(tick_value)
                
                Note: Convert to simple fraction (simplified)
                If MathOps.absolute_value(ToString(tick_value), 15).result_value is less than or equal to "0.001":
                    Call frac_labels.append("0")
                Otherwise if MathOps.absolute_value(ToString(tick_value minus 0.5), 15).result_value is less than or equal to "0.001":
                    Call frac_labels.append("1/2")
                Otherwise if MathOps.absolute_value(ToString(tick_value minus 0.25), 15).result_value is less than or equal to "0.001":
                    Call frac_labels.append("1/4")
                Otherwise if MathOps.absolute_value(ToString(tick_value minus 0.75), 15).result_value is less than or equal to "0.001":
                    Call frac_labels.append("3/4")
                Otherwise:
                    Call frac_labels.append(ToString(tick_value))
            
            Set formatted_canvas.x_axis.tick_positions to frac_ticks
            Set formatted_canvas.x_axis.tick_labels to frac_labels
    
    Note: Format Y-axis
    If formatting_options.contains("y_format"):
        Let y_format be formatting_options["y_format"]
        
        If y_format is equal to "scientific":
            Note: Format y-axis with scientific notation
            Let sci_ticks be List[Float64]
            Let sci_labels be List[String]
            
            Let y_min be formatted_canvas.y_axis.range.0
            Let y_max be formatted_canvas.y_axis.range.1
            Let step be (y_max minus y_min) / 6.0
            
            For i from 0 to 6:
                Let tick_value be y_min plus Float64(i) multiplied by step
                Call sci_ticks.append(tick_value)
                
                Note: Convert to scientific notation
                If MathOps.absolute_value(ToString(tick_value), 15).result_value is greater than or equal to "1000" Or MathOps.absolute_value(ToString(tick_value), 15).result_value is less than or equal to "0.001":
                    Let exponent be MathOps.floor(MathOps.logarithm(MathOps.absolute_value(ToString(tick_value), 15).result_value, "10", 15).result_value, 15).result_value
                    Let mantissa be tick_value / ParseFloat(MathOps.power("10", exponent, 15).result_value)
                    Call sci_labels.append(ToString(mantissa) plus "×10^" plus exponent)
                Otherwise:
                    Call sci_labels.append(ToString(tick_value))
            
            Set formatted_canvas.y_axis.tick_positions to sci_ticks
            Set formatted_canvas.y_axis.tick_labels to sci_labels
    
    Note: Add mathematical symbols to axis labels if requested
    If formatting_options.contains("symbols") And formatting_options["symbols"] is equal to "true":
        If formatted_canvas.x_axis.label is equal to "x":
            Set formatted_canvas.x_axis.label to "𝑥"
        If formatted_canvas.y_axis.label is equal to "y":
            Set formatted_canvas.y_axis.label to "𝑦"
        If formatted_canvas.title.contains("Function"):
            Set formatted_canvas.title to formatted_canvas.title.replace("Function", "𝑓(𝑥)")
    
    Note: Set axis colors for mathematical presentation
    If formatting_options.contains("math_style") And formatting_options["math_style"] is equal to "true":
        Set formatted_canvas.x_axis.axis_color to "#333333"
        Set formatted_canvas.y_axis.axis_color to "#333333"
        Set formatted_canvas.x_axis.grid_visible to true
        Set formatted_canvas.y_axis.grid_visible to true
    
    Return formatted_canvas

Process called "legend_and_labeling" that takes plot_canvas as PlotCanvas, legend_specifications as Dictionary[String, String] returns PlotCanvas:
    Note: Creates comprehensive legends and labeling systems
    Note: Supports mathematical symbols and multi-line descriptions
    Note: Automatic placement to avoid obscuring important features
    Note: Essential for multi-series and complex plots
    
    Let enhanced_canvas be plot_canvas
    
    Note: Configure legend visibility and position
    If legend_specifications.contains("visible"):
        Set enhanced_canvas.legend_visible to legend_specifications["visible"] is equal to "true"
    
    Note: Add legend position annotation
    If legend_specifications.contains("position"):
        Let position_info be Dictionary[String, String]
        Call position_info.set("type", "legend_position")
        Call position_info.set("position", legend_specifications["position"])
        Call enhanced_canvas.annotations.append(position_info)
    
    Note: Enhance series labels with mathematical notation
    If legend_specifications.contains("math_notation") And legend_specifications["math_notation"] is equal to "true":
        For series_idx from 0 to enhanced_canvas.series_list.size() minus 1:
            Let current_series be enhanced_canvas.series_list[series_idx]
            Let original_label be current_series.label
            
            Note: Convert common mathematical expressions
            If original_label.contains("function") Or original_label.contains("Function"):
                Set current_series.label to original_label.replace("function", "𝑓").replace("Function", "𝑓")
            If original_label.contains("derivative") Or original_label.contains("Derivative"):
                Set current_series.label to original_label.replace("derivative", "𝑓′").replace("Derivative", "𝑓′")
            If original_label.contains("integral") Or original_label.contains("Integral"):
                Set current_series.label to original_label.replace("integral", "∫𝑓").replace("Integral", "∫𝑓")
            If original_label.contains("Taylor"):
                Set current_series.label to original_label plus " (𝑇ₙ)"
            If original_label.contains("Fourier"):
                Set current_series.label to original_label plus " (𝑆ₙ)"
    
    Note: Add legend formatting specifications
    If legend_specifications.contains("font_size"):
        Let font_spec be Dictionary[String, String]
        Call font_spec.set("type", "legend_font")
        Call font_spec.set("size", legend_specifications["font_size"])
        Call enhanced_canvas.annotations.append(font_spec)
    
    If legend_specifications.contains("background"):
        Let bg_spec be Dictionary[String, String]
        Call bg_spec.set("type", "legend_background")
        Call bg_spec.set("color", legend_specifications["background"])
        Call bg_spec.set("opacity", legend_specifications.get("opacity", "0.8"))
        Call enhanced_canvas.annotations.append(bg_spec)
    
    If legend_specifications.contains("border"):
        Let border_spec be Dictionary[String, String]
        Call border_spec.set("type", "legend_border")
        Call border_spec.set("style", legend_specifications["border"])
        Call border_spec.set("color", legend_specifications.get("border_color", "#000000"))
        Call enhanced_canvas.annotations.append(border_spec)
    
    Note: Add series type indicators to legend
    If legend_specifications.contains("show_markers") And legend_specifications["show_markers"] is equal to "true":
        For series in enhanced_canvas.series_list:
            If series.series_type is equal to "line":
                Set series.label to series.label plus " ━"
            Otherwise if series.series_type is equal to "scatter":
                Set series.label to series.label plus " ●"
            Otherwise if series.series_type is equal to "bar":
                Set series.label to series.label plus " ▬"
    
    Note: Add multi-line support for long labels
    If legend_specifications.contains("max_line_length"):
        Let max_length be Integer(legend_specifications["max_line_length"])
        
        For series in enhanced_canvas.series_list:
            If series.label.length() is greater than max_length:
                Note: Simple line breaking (would use proper word wrap in full implementation)
                Let first_part be series.label.substring(0, max_length)
                Let second_part be series.label.substring(max_length, series.label.length())
                Set series.label to first_part plus "\n" plus second_part
    
    Note: Add legend ordering
    If legend_specifications.contains("sort"):
        Let sort_order be legend_specifications["sort"]
        
        If sort_order is equal to "alphabetical":
            Note: Sort series by label (simplified bubble sort)
            For i from 0 to enhanced_canvas.series_list.size() minus 1:
                For j from 0 to enhanced_canvas.series_list.size() minus 2 minus i:
                    If enhanced_canvas.series_list[j].label is greater than enhanced_canvas.series_list[j plus 1].label:
                        Let temp_series be enhanced_canvas.series_list[j]
                        Set enhanced_canvas.series_list[j] to enhanced_canvas.series_list[j plus 1]
                        Set enhanced_canvas.series_list[j plus 1] to temp_series
    
    Note: Add legend metadata
    Let legend_meta be Dictionary[String, String]
    Call legend_meta.set("type", "legend_metadata")
    Call legend_meta.set("series_count", ToString(enhanced_canvas.series_list.size()))
    Call legend_meta.set("enhanced", "true")
    Call enhanced_canvas.annotations.append(legend_meta)
    
    Return enhanced_canvas

Note: ===== Export and Output =====

Process called "export_plot" that takes plot_canvas as PlotCanvas, output_format as String, resolution as Integer returns String:
    Note: Exports plots to various formats: PNG, SVG, PDF, EPS
    Note: Maintains mathematical symbol quality across formats
    Note: Supports vector graphics for scalable mathematical diagrams
    Note: Essential for publication and presentation workflows
    
    Let format_lower be ToString(output_format).toLowerCase()
    
    If format_lower is equal to "svg":
        Let svg_content be "<?xml version='1.0' encoding='UTF-8'?>\n"
        Set svg_content to svg_content plus "<svg width='" plus ToString(plot_canvas.width) plus "' height='" plus ToString(plot_canvas.height) plus "' xmlns='http://www.w3.org/2000/svg'>\n"
        
        Note: Add title
        Set svg_content to svg_content plus "<title>" plus plot_canvas.title plus "</title>\n"
        
        Note: Add grid lines
        Set svg_content to svg_content plus "<defs><pattern id='grid' width='20' height='20' patternUnits='userSpaceOnUse'>"
        Set svg_content to svg_content plus "<path d='M 20 0 L 0 0 0 20' fill='none' stroke='#e0e0e0' stroke-width='1'/></pattern></defs>\n"
        Set svg_content to svg_content plus "<rect width='100%' height='100%' fill='url(#grid)' />\n"
        
        Note: Add series data
        For series in plot_canvas.series_list:
            If series.series_type is equal to "line":
                Let path_data be "M "
                For i from 0 to series.data_points.size() minus 1:
                    Let x_coord be ToString(series.data_points[i][0] multiplied by 50.0 plus 100.0)
                    Let y_coord be ToString(plot_canvas.height minus (series.data_points[i][1] multiplied by 50.0 plus 100.0))
                    If i is equal to 0:
                        Set path_data to path_data plus x_coord plus " " plus y_coord
                    Otherwise:
                        Set path_data to path_data plus " L " plus x_coord plus " " plus y_coord
                
                Set svg_content to svg_content plus "<path d='" plus path_data plus "' fill='none' stroke='" plus series.color plus "' stroke-width='2'/>\n"
            
            Otherwise if series.series_type is equal to "scatter":
                For point in series.data_points:
                    Let x_coord be ToString(point[0] multiplied by 50.0 plus 100.0)
                    Let y_coord be ToString(plot_canvas.height minus (point[1] multiplied by 50.0 plus 100.0))
                    Set svg_content to svg_content plus "<circle cx='" plus x_coord plus "' cy='" plus y_coord plus "' r='3' fill='" plus series.color plus "'/>\n"
        
        Set svg_content to svg_content plus "</svg>"
        Return svg_content
    
    Otherwise if format_lower is equal to "json":
        Let json_data be "{"
        Set json_data to json_data plus "\"title\": \"" plus plot_canvas.title plus "\","
        Set json_data to json_data plus "\"width\": " plus ToString(plot_canvas.width) plus ","
        Set json_data to json_data plus "\"height\": " plus ToString(plot_canvas.height) plus ","
        Set json_data to json_data plus "\"series\": ["
        
        For series_idx from 0 to plot_canvas.series_list.size() minus 1:
            Let series be plot_canvas.series_list[series_idx]
            Set json_data to json_data plus "{"
            Set json_data to json_data plus "\"type\": \"" plus series.series_type plus "\","
            Set json_data to json_data plus "\"color\": \"" plus series.color plus "\","
            Set json_data to json_data plus "\"label\": \"" plus series.label plus "\","
            Set json_data to json_data plus "\"data\": ["
            
            For point_idx from 0 to series.data_points.size() minus 1:
                Let point be series.data_points[point_idx]
                Set json_data to json_data plus "[" plus ToString(point[0]) plus "," plus ToString(point[1]) plus "]"
                If point_idx is less than series.data_points.size() minus 1:
                    Set json_data to json_data plus ","
            
            Set json_data to json_data plus "]}"
            If series_idx is less than plot_canvas.series_list.size() minus 1:
                Set json_data to json_data plus ","
        
        Set json_data to json_data plus "]}"
        Return json_data
    
    Otherwise:
        Throw Errors.UnsupportedOperation with "Format " plus output_format plus " not supported. Use SVG or JSON."

Process called "plot_to_latex" that takes plot_canvas as PlotCanvas, latex_options as Dictionary[String, String] returns String:
    Note: Converts plot to LaTeX/TikZ code for document integration
    Note: Maintains mathematical notation and symbolic accuracy
    Note: Allows further customization within LaTeX documents
    Note: Important for academic and research publications
    
    Let latex_code be "\\begin{tikzpicture}\n"
    
    Note: Add axis setup
    Set latex_code to latex_code plus "\\begin{axis}[\n"
    Set latex_code to latex_code plus "  width=" plus latex_options.get("width", "10cm") plus ",\n"
    Set latex_code to latex_code plus "  height=" plus latex_options.get("height", "8cm") plus ",\n"
    Set latex_code to latex_code plus "  xlabel={" plus plot_canvas.x_axis.label plus "},\n"
    Set latex_code to latex_code plus "  ylabel={" plus plot_canvas.y_axis.label plus "},\n"
    Set latex_code to latex_code plus "  title={" plus plot_canvas.title plus "},\n"
    
    Note: Add axis ranges
    Set latex_code to latex_code plus "  xmin=" plus ToString(plot_canvas.x_axis.range.0) plus ",\n"
    Set latex_code to latex_code plus "  xmax=" plus ToString(plot_canvas.x_axis.range.1) plus ",\n"
    Set latex_code to latex_code plus "  ymin=" plus ToString(plot_canvas.y_axis.range.0) plus ",\n"
    Set latex_code to latex_code plus "  ymax=" plus ToString(plot_canvas.y_axis.range.1) plus ",\n"
    
    Note: Add grid and legend options
    If plot_canvas.x_axis.grid_visible:
        Set latex_code to latex_code plus "  grid=major,\n"
    If plot_canvas.legend_visible:
        Set latex_code to latex_code plus "  legend pos=" plus latex_options.get("legend_pos", "north east") plus ",\n"
    
    Set latex_code to latex_code plus "]\n"
    
    Note: Add data series
    For series in plot_canvas.series_list:
        If series.series_type is equal to "line":
            Set latex_code to latex_code plus "\\addplot[color=" plus series.color plus ", mark=none, smooth] coordinates {\n"
        Otherwise if series.series_type is equal to "scatter":
            Set latex_code to latex_code plus "\\addplot[color=" plus series.color plus ", only marks] coordinates {\n"
        Otherwise:
            Set latex_code to latex_code plus "\\addplot[color=" plus series.color plus "] coordinates {\n"
        
        Note: Add coordinate points
        For point in series.data_points:
            Set latex_code to latex_code plus "  (" plus ToString(point[0]) plus ", " plus ToString(point[1]) plus ")\n"
        
        Set latex_code to latex_code plus "};\n"
        
        Note: Add legend entry
        If plot_canvas.legend_visible:
            Set latex_code to latex_code plus "\\addlegendentry{" plus series.label plus "}\n"
    
    Note: Add annotations
    For annotation in plot_canvas.annotations:
        If annotation.contains("type") And annotation["type"] is equal to "text":
            Set latex_code to latex_code plus "\\node at (" plus annotation.get("x", "0") plus ", " plus annotation.get("y", "0") plus ") {" plus annotation.get("content", "") plus "};\n"
        Otherwise if annotation.contains("type") And annotation["type"] is equal to "arrow":
            Set latex_code to latex_code plus "\\draw[->] (" plus annotation.get("start_x", "0") plus ", " plus annotation.get("start_y", "0") plus ") -- (" plus annotation.get("end_x", "1") plus ", " plus annotation.get("end_y", "1") plus ");\n"
    
    Set latex_code to latex_code plus "\\end{axis}\n"
    Set latex_code to latex_code plus "\\end{tikzpicture}\n"
    
    Note: Add required packages header if requested
    If latex_options.contains("include_packages") And latex_options["include_packages"] is equal to "true":
        Let header be "\\usepackage{pgfplots}\n\\usepackage{tikz}\n\\pgfplotsset{compat=1.18}\n\n"
        Set latex_code to header plus latex_code
    
    Return latex_code

Process called "batch_plot_generation" that takes plot_specifications as List[Dictionary[String, Function]], output_directory as String returns List[String]:
    Note: Generates multiple plots in batch processing mode
    Note: Consistent styling and automated file naming
    Note: Parallel processing for improved performance
    Note: Useful for parameter studies and systematic analysis
    
    Let generated_files be List[String]
    Let batch_timestamp be ToString(ProbabilityInfo.generate_uniform_sample(100000.0, 999999.0))
    
    Note: Validate output directory
    If output_directory is equal to "":
        Throw Errors.InvalidArgument with "Output directory cannot be empty"
    
    Note: Process each plot specification
    For spec_idx from 0 to plot_specifications.size() minus 1:
        Let plot_spec be plot_specifications[spec_idx]
        
        Note: Extract plot parameters
        Let plot_type be ToString(plot_spec.get("type", "function"))
        Let plot_function be plot_spec.get("function", "x")
        Let domain be plot_spec.get("domain", ((-5.0, 5.0)))
        Let title be ToString(plot_spec.get("title", "Plot " plus ToString(spec_idx plus 1)))
        Let output_format be ToString(plot_spec.get("format", "svg"))
        
        Note: Generate the plot based on type
        Let generated_canvas be PlotCanvas
        
        If plot_type is equal to "function":
            Set generated_canvas to plot_function(plot_function, domain, 200, {
                "color": "#0066CC",
                "title": title
            })
        Otherwise if plot_type is equal to "scatter":
            Note: Generate sample data for scatter plot
            Let x_data be List[Float64]
            Let y_data be List[Float64]
            For i from 0 to 50:
                Let x_val be domain.0 plus Float64(i) multiplied by (domain.1 minus domain.0) / 50.0
                Let y_val be ParseFloat(NumericalCore.evaluate_function(ToString(plot_function), ToString(x_val)))
                Call x_data.append(x_val)
                Call y_data.append(y_val)
            
            Set generated_canvas to scatter_plot(x_data, y_data, {
                "color": "#FF6B35",
                "title": title,
                "marker": "circle"
            })
        Otherwise if plot_type is equal to "histogram":
            Note: Generate sample data for histogram
            Let sample_data be List[Float64]
            For i from 0 to 100:
                Let sample_val be ProbabilityInfo.generate_uniform_sample(domain.0, domain.1)
                Call sample_data.append(sample_val)
            
            Set generated_canvas to histogram(sample_data, 20, false)
        Otherwise:
            Note: Default to function plot
            Set generated_canvas to plot_function(plot_function, domain, 200, {
                "color": "#4CAF50",
                "title": title
            })
        
        Note: Apply consistent styling
        Set generated_canvas to customize_plot_appearance(generated_canvas, {
            "width": "800",
            "height": "600",
            "grid_visible": "true",
            "axis_color": "#333333"
        })
        
        Note: Generate filename
        Let safe_title be title.replace(" ", "_").replace("(", "").replace(")", "")
        Let filename be output_directory plus "/" plus safe_title plus "_" plus batch_timestamp plus "_" plus ToString(spec_idx) plus "." plus output_format
        
        Note: Export the plot
        Let export_result be export_plot(generated_canvas, output_format, 300)
        
        Note: Save result (simplified minus would normally write to file)
        Call generated_files.append(filename plus " [" plus ToString(export_result.length()) plus " chars]")
    
    Note: Generate batch summary
    Let summary_filename be output_directory plus "/batch_summary_" plus batch_timestamp plus ".txt"
    Let summary_content be "Batch Plot Generation Summary\n"
    Set summary_content to summary_content plus "Generated: " plus ToString(plot_specifications.size()) plus " plots\n"
    Set summary_content to summary_content plus "Timestamp: " plus batch_timestamp plus "\n"
    Set summary_content to summary_content plus "Output Directory: " plus output_directory plus "\n\n"
    
    For file_info in generated_files:
        Set summary_content to summary_content plus file_info plus "\n"
    
    Call generated_files.append(summary_filename plus " [summary]")
    
    Return generated_files

Note: ===== Advanced Visualization Techniques =====

Process called "adaptive_sampling_plot" that takes function as Function, domain as Tuple[Float64, Float64], accuracy_threshold as Float64 returns PlotCanvas:
    Note: Uses adaptive sampling for accurate function representation
    Note: Higher sampling density near rapid changes and singularities
    Note: Maintains plot accuracy while optimizing performance
    Note: Essential for complex mathematical functions
    
    Let start_x be domain.0
    Let end_x be domain.1
    Let adaptive_points be List[List[Float64]]
    
    Note: Start with coarse sampling
    Let initial_samples be 10
    Let initial_step be (end_x minus start_x) / Float64(initial_samples)
    Let sample_points be List[Float64]
    
    For i from 0 to initial_samples:
        Let x_val be start_x plus Float64(i) multiplied by initial_step
        Call sample_points.append(x_val)
    
    Note: Adaptive refinement algorithm
    Let max_refinements be 5
    For refinement from 0 to max_refinements minus 1:
        Let new_points be List[Float64]
        
        For i from 0 to sample_points.size() minus 2:
            Let x1 be sample_points[i]
            Let x2 be sample_points[i plus 1]
            Let x_mid be (x1 plus x2) / 2.0
            
            Note: Evaluate function at three points
            Let y1 be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(x1)))
            Let y2 be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(x2)))
            Let y_mid be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(x_mid)))
            
            Note: Linear interpolation estimate
            Let y_linear be (y1 plus y2) / 2.0
            
            Note: Check if refinement needed
            Let error be MathOps.absolute_value(ToString(y_mid minus y_linear), 15).result_value
            If ParseFloat(error) is greater than accuracy_threshold:
                Call new_points.append(x_mid)
        
        Note: Insert new points into sample array
        For new_point in new_points:
            Call sample_points.append(new_point)
        
        Note: Sort sample points
        For i from 0 to sample_points.size() minus 1:
            For j from 0 to sample_points.size() minus 2 minus i:
                If sample_points[j] is greater than sample_points[j plus 1]:
                    Let temp be sample_points[j]
                    Set sample_points[j] to sample_points[j plus 1]
                    Set sample_points[j plus 1] to temp
        
        Note: Stop if no new points added
        If new_points.size() is equal to 0:
            Break
    
    Note: Generate final adaptive points
    For x_val in sample_points:
        Let y_val be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(x_val)))
        Call adaptive_points.append([x_val, y_val])
    
    Let series be PlotSeries
    Set series.data_points to adaptive_points
    Set series.series_type to "line"
    Set series.color to "#9C27B0"
    Set series.line_style to "solid"
    Set series.marker_style to "dot"
    Set series.label to "Adaptive Sampling (" plus ToString(adaptive_points.size()) plus " points)"
    Set series.visibility to true
    
    Note: Calculate y-axis range
    Let y_values be List[Float64]
    For point in adaptive_points:
        Call y_values.append(point[1])
    
    Let y_min be y_values[0]
    Let y_max be y_values[0]
    For y in y_values:
        If y is less than y_min: Set y_min to y
        If y is greater than y_max: Set y_max to y
    Let y_range be (y_min minus 0.1 multiplied by (y_max minus y_min), y_max plus 0.1 multiplied by (y_max minus y_min))
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to domain
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Adaptive Sampling Plot"
    Set canvas.legend_visible to true
    Set canvas.series_list to [series]
    Set canvas.annotations to []
    
    Return canvas

Process called "multi_scale_visualization" that takes function as Function, scale_levels as List[Float64] returns List[PlotCanvas]:
    Note: Creates visualization at multiple scales simultaneously
    Note: Shows both local details and global behavior
    Note: Important for fractal and multi-scale phenomena
    Note: Provides comprehensive function understanding
    
    Let scale_plots be List[PlotCanvas]
    
    Note: Generate plot at each scale level
    For scale_idx from 0 to scale_levels.size() minus 1:
        Let scale be scale_levels[scale_idx]
        Let domain be ((-scale, scale))
        Let resolution be Integer(200.0 multiplied by (1.0 plus 1.0 / scale))  Note: Higher resolution for smaller scales
        
        Note: Generate function plot at this scale
        Let scale_canvas be plot_function(function, domain, resolution, {
            "color": If scale_idx is equal to 0 Then "#0066CC" Otherwise if scale_idx is equal to 1 Then "#FF6B35" Otherwise if scale_idx is equal to 2 Then "#4CAF50" Otherwise "#9C27B0",
            "title": "Scale " plus ToString(scale),
            "line_style": "solid"
        })
        
        Note: Customize for multi-scale analysis
        Set scale_canvas.title to "Multi-Scale View: Scale is equal to ±" plus ToString(scale)
        
        Note: Add scale-specific annotations
        Let scale_annotation be Dictionary[String, String]
        Call scale_annotation.set("type", "text")
        Call scale_annotation.set("text", "Resolution: " plus ToString(resolution) plus " points")
        Call scale_annotation.set("x", ToString(domain.0 plus 0.1 multiplied by (domain.1 minus domain.0)))
        Call scale_annotation.set("y", ToString(scale_canvas.y_axis.range.1 minus 0.1 multiplied by (scale_canvas.y_axis.range.1 minus scale_canvas.y_axis.range.0)))
        Call scale_annotation.set("font_size", "10")
        Call scale_annotation.set("color", "#666666")
        Call scale_canvas.annotations.append(scale_annotation)
        
        Note: Add domain range annotation
        Let domain_annotation be Dictionary[String, String]
        Call domain_annotation.set("type", "text")
        Call domain_annotation.set("text", "Domain: [" plus ToString(domain.0) plus ", " plus ToString(domain.1) plus "]")
        Call domain_annotation.set("x", ToString(domain.0 plus 0.1 multiplied by (domain.1 minus domain.0)))
        Call domain_annotation.set("y", ToString(scale_canvas.y_axis.range.0 plus 0.1 multiplied by (scale_canvas.y_axis.range.1 minus scale_canvas.y_axis.range.0)))
        Call domain_annotation.set("font_size", "10")
        Call domain_annotation.set("color", "#666666")
        Call scale_canvas.annotations.append(domain_annotation)
        
        Note: Mark critical points if at fine scale
        If scale is less than or equal to 1.0:
            Note: Add markers for potential critical points (simplified)
            Let critical_points be List[Float64]
            Let sample_step be (domain.1 minus domain.0) / 20.0
            
            For i from 1 to 19:
                Let x_test be domain.0 plus Float64(i) multiplied by sample_step
                Let x_left be x_test minus 0.01
                Let x_right be x_test plus 0.01
                
                Let y_left be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(x_left)))
                Let y_center be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(x_test)))
                Let y_right be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(x_right)))
                
                Note: Simple critical point detection (local extrema)
                If (y_left is less than y_center And y_center is greater than y_right) Or (y_left is greater than y_center And y_center is less than y_right):
                    Call critical_points.append(x_test)
            
            Note: Add critical point markers
            If critical_points.size() is greater than 0:
                Let critical_data be List[List[Float64]]
                For x_crit in critical_points:
                    Let y_crit be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(x_crit)))
                    Call critical_data.append([x_crit, y_crit])
                
                Let critical_series be PlotSeries
                Set critical_series.data_points to critical_data
                Set critical_series.series_type to "scatter"
                Set critical_series.color to "#FF0000"
                Set critical_series.line_style to "none"
                Set critical_series.marker_style to "star"
                Set critical_series.label to "Critical Points"
                Set critical_series.visibility to true
                Call scale_canvas.series_list.append(critical_series)
        
        Call scale_plots.append(scale_canvas)
    
    Return scale_plots

Process called "uncertainty_visualization" that takes function as Function, uncertainty_bounds as Function, confidence_level as Float64 returns PlotCanvas:
    Note: Visualizes functions with uncertainty or error bounds
    Note: Shows confidence bands and error propagation
    Note: Important for experimental data and numerical approximations
    Note: Essential for scientific and engineering applications
    
    Let domain be ((-5.0, 5.0))  Note: Default domain
    Let resolution be 200
    Let step_size be (domain.1 minus domain.0) / Float64(resolution)
    
    Let series_list be List[PlotSeries]
    
    Note: Generate main function curve
    Let main_points be List[List[Float64]]
    Let upper_bound_points be List[List[Float64]]
    Let lower_bound_points be List[List[Float64]]
    
    Let current_x be domain.0
    While current_x is less than or equal to domain.1:
        Note: Evaluate main function
        Let y_main be ParseFloat(NumericalCore.evaluate_function(ToString(function), ToString(current_x)))
        Call main_points.append([current_x, y_main])
        
        Note: Evaluate uncertainty bounds
        Let uncertainty be ParseFloat(NumericalCore.evaluate_function(ToString(uncertainty_bounds), ToString(current_x)))
        
        Note: Calculate confidence interval based on confidence level
        Let confidence_factor be If confidence_level is greater than or equal to 0.95 Then 1.96 Otherwise if confidence_level is greater than or equal to 0.9 Then 1.65 Otherwise 1.0
        Let error_margin be uncertainty multiplied by confidence_factor
        
        Let y_upper be y_main plus error_margin
        Let y_lower be y_main minus error_margin
        
        Call upper_bound_points.append([current_x, y_upper])
        Call lower_bound_points.append([current_x, y_lower])
        
        Set current_x to current_x plus step_size
    
    Note: Add main function series
    Let main_series be PlotSeries
    Set main_series.data_points to main_points
    Set main_series.series_type to "line"
    Set main_series.color to "#0066CC"
    Set main_series.line_style to "solid"
    Set main_series.marker_style to "none"
    Set main_series.label to "Function"
    Set main_series.visibility to true
    Call series_list.append(main_series)
    
    Note: Add upper confidence bound
    Let upper_series be PlotSeries
    Set upper_series.data_points to upper_bound_points
    Set upper_series.series_type to "line"
    Set upper_series.color to "#FF6B35"
    Set upper_series.line_style to "dashed"
    Set upper_series.marker_style to "none"
    Set upper_series.label to ToString(confidence_level multiplied by 100.0) plus "% Upper Bound"
    Set upper_series.visibility to true
    Call series_list.append(upper_series)
    
    Note: Add lower confidence bound
    Let lower_series be PlotSeries
    Set lower_series.data_points to lower_bound_points
    Set lower_series.series_type to "line"
    Set lower_series.color to "#FF6B35"
    Set lower_series.line_style to "dashed"
    Set lower_series.marker_style to "none"
    Set lower_series.label to ToString(confidence_level multiplied by 100.0) plus "% Lower Bound"
    Set lower_series.visibility to true
    Call series_list.append(lower_series)
    
    Note: Add confidence band fill (represented as scatter points)
    Let band_points be List[List[Float64]]
    For i from 0 to main_points.size() minus 1:
        Let x_val be main_points[i][0]
        Let y_main be main_points[i][1]
        Let y_upper be upper_bound_points[i][1]
        Let y_lower be lower_bound_points[i][1]
        
        Note: Sample points within confidence band
        For band_step from 0 to 5:
            Let y_band be y_lower plus Float64(band_step) multiplied by (y_upper minus y_lower) / 5.0
            Call band_points.append([x_val, y_band])
    
    Let band_series be PlotSeries
    Set band_series.data_points to band_points
    Set band_series.series_type to "scatter"
    Set band_series.color to "#E3F2FD"
    Set band_series.line_style to "none"
    Set band_series.marker_style to "dot"
    Set band_series.label to "Confidence Band"
    Set band_series.visibility to true
    Call series_list.append(band_series)
    
    Note: Calculate axis ranges
    Let all_y_values be List[Float64]
    For point in main_points:
        Call all_y_values.append(point[1])
    For point in upper_bound_points:
        Call all_y_values.append(point[1])
    For point in lower_bound_points:
        Call all_y_values.append(point[1])
    
    Let y_min be all_y_values[0]
    Let y_max be all_y_values[0]
    For y in all_y_values:
        If y is less than y_min: Set y_min to y
        If y is greater than y_max: Set y_max to y
    Let y_range be (y_min minus 0.1 multiplied by (y_max minus y_min), y_max plus 0.1 multiplied by (y_max minus y_min))
    
    Let x_axis be PlotAxis
    Set x_axis.label to "x"
    Set x_axis.range to domain
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to true
    Set x_axis.axis_color to "#000000"
    
    Let y_axis be PlotAxis
    Set y_axis.label to "y"
    Set y_axis.range to y_range
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to true
    Set y_axis.axis_color to "#000000"
    
    Note: Add uncertainty statistics annotation
    Let stats_annotation be Dictionary[String, String]
    Call stats_annotation.set("type", "text")
    Call stats_annotation.set("text", "Confidence Level: " plus ToString(confidence_level multiplied by 100.0) plus "%")
    Call stats_annotation.set("x", ToString(domain.0 plus 0.05 multiplied by (domain.1 minus domain.0)))
    Call stats_annotation.set("y", ToString(y_range.1 minus 0.05 multiplied by (y_range.1 minus y_range.0)))
    Call stats_annotation.set("font_size", "12")
    Call stats_annotation.set("color", "#333333")
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Uncertainty Visualization"
    Set canvas.legend_visible to true
    Set canvas.series_list to series_list
    Set canvas.annotations to [stats_annotation]
    
    Return canvas