Note:
math/core/comparison.runa
Mathematical Comparison and Ordering Operations

This module provides comprehensive mathematical comparison operations including:
- Basic comparison operations (min, max, equal, less than, greater than)
- Multi-value comparison operations (minimum/maximum of arrays)
- Ordering and ranking operations with custom comparators
- Numerical tolerance-based comparisons for floating point values
- Sign detection and classification operations
- Floor, ceiling, and rounding operations with multiple modes
- Clamping and range constraint operations
- Statistical order operations (median, percentiles, quantiles)
- Lexicographic and custom ordering comparisons
- Interval and range comparison operations
- Fuzzy comparison operations with uncertainty bounds
- Comparison result aggregation and statistics
- Performance-optimized bulk comparison operations
- Stability-aware comparison for numerical algorithms
- Multi-criteria decision analysis comparisons
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "compiler/frontend/diagnostics/diagnostic_engine" as DiagnosticEngine
Import module "compiler/frontend/diagnostics/error_formatter" as ErrorFormatter
Import module "compiler/frontend/diagnostics/suggestion_engine" as SuggestionEngine

Note: =====================================================================
Note: COMPARISON DATA STRUCTURES
Note: =====================================================================

Type called "ComparisonResult":
    comparison_type as String
    operand_a as String
    operand_b as String
    result as Boolean
    confidence_level as Float
    tolerance_used as Float
    comparison_method as String
    numerical_precision as Integer
    error_occurred as Boolean
    error_code as String
    error_message as String
    empty_array_error as Boolean
    invalid_range_error as Boolean
    precision_insufficient as Boolean
    diagnostic_info as DiagnosticInfo

Type called "OrderingResult":
    original_indices as List[Integer]
    sorted_values as List[String]
    ordering_criteria as String
    stability_preserved as Boolean
    comparison_count as Integer
    sorting_algorithm as String

Type called "RankingResult":
    value as String
    rank as Integer
    percentile as Float
    z_score as Float
    relative_position as Float
    tied_values as List[String]

Type called "ToleranceConfiguration":
    absolute_tolerance as String
    relative_tolerance as String
    comparison_method as String
    significant_figures as Integer
    rounding_mode as String
    special_value_handling as Dictionary[String, String]

Type called "StatisticalComparison":
    sample_size as Integer
    comparison_statistic as String
    p_value as Float
    confidence_interval as Dictionary[String, String]
    effect_size as Float
    test_method as String

Note: =====================================================================
Note: BASIC COMPARISON OPERATIONS
Note: =====================================================================

Process called "minimum" that takes operand_a as String, operand_b as String, precision as Integer returns String:
    Note: Find minimum of two numbers with specified precision
    If less_than(operand_a, operand_b, precision):
        Return operand_a
    Return operand_b

Process called "maximum" that takes operand_a as String, operand_b as String, precision as Integer returns String:
    Note: Find maximum of two numbers with specified precision
    If greater_than(operand_a, operand_b, precision):
        Return operand_a
    Return operand_b

Process called "equal_within_tolerance" that takes operand_a as String, operand_b as String, tolerance_config as ToleranceConfiguration returns ComparisonResult:
    Note: Compare two numbers for equality within specified tolerance
    Let a_float be Parse operand_a as Float
    Let b_float be Parse operand_b as Float
    Let abs_tolerance be Parse tolerance_config.absolute_tolerance as Float
    Let rel_tolerance be Parse tolerance_config.relative_tolerance as Float
    Let difference be AbsoluteValue(a_float minus b_float)
    Let relative_diff be difference / Maximum(AbsoluteValue(a_float), AbsoluteValue(b_float))
    Let is_equal be (difference is less than or equal to abs_tolerance) OR (relative_diff is less than or equal to rel_tolerance)
    Return ComparisonResult with:
        comparison_type: "equality_tolerance"
        operand_a: operand_a
        operand_b: operand_b
        result: is_equal
        confidence_level: 1.0
        tolerance_used: abs_tolerance
        comparison_method: tolerance_config.comparison_method
        numerical_precision: tolerance_config.significant_figures

Process called "less_than" that takes operand_a as String, operand_b as String, precision as Integer returns Boolean:
    Note: Compare if operand_a is less than operand_b
    Let a_float be Parse operand_a as Float
    Let b_float be Parse operand_b as Float
    Let epsilon be Power(10.0, Negate(precision))
    Return (b_float minus a_float) is greater than epsilon

Process called "greater_than" that takes operand_a as String, operand_b as String, precision as Integer returns Boolean:
    Note: Compare if operand_a is greater than operand_b
    Let a_float be Parse operand_a as Float
    Let b_float be Parse operand_b as Float
    Let epsilon be Power(10.0, Negate(precision))
    Return (a_float minus b_float) is greater than epsilon

Process called "less_than_or_equal" that takes operand_a as String, operand_b as String, tolerance_config as ToleranceConfiguration returns Boolean:
    Note: Compare if operand_a is less than or equal to operand_b with tolerance
    Let precision be tolerance_config.significant_figures
    Let equal_result be equal_within_tolerance(operand_a, operand_b, tolerance_config)
    If equal_result.result:
        Return True
    Return less_than(operand_a, operand_b, precision)

Process called "greater_than_or_equal" that takes operand_a as String, operand_b as String, tolerance_config as ToleranceConfiguration returns Boolean:
    Note: Compare if operand_a is greater than or equal to operand_b with tolerance
    Let precision be tolerance_config.significant_figures
    Let equal_result be equal_within_tolerance(operand_a, operand_b, tolerance_config)
    If equal_result.result:
        Return True
    Return greater_than(operand_a, operand_b, precision)

Note: =====================================================================
Note: MULTI-VALUE COMPARISON OPERATIONS
Note: =====================================================================

Process called "minimum_of_array" that takes values as List[String], comparison_options as Dictionary[String, String] returns String:
    Note: Find minimum value in array with custom comparison options
    If Length(values) is equal to 0:
        Throw Errors.InvalidOperation with "Cannot find minimum of empty array"
    Let min_value be values[0]
    Let precision be Parse comparison_options["precision"] as Integer
    For Each value in values[1:]:
        If less_than(value, min_value, precision):
            Set min_value to value
    Return min_value

Process called "maximum_of_array" that takes values as List[String], comparison_options as Dictionary[String, String] returns String:
    Note: Find maximum value in array with custom comparison options
    If Length(values) is equal to 0:
        Throw Errors.InvalidOperation with "Cannot find maximum of empty array"
    Let max_value be values[0]
    Let precision be Parse comparison_options["precision"] as Integer
    For Each value in values[1:]:
        If greater_than(value, max_value, precision):
            Set max_value to value
    Return max_value

Process called "minimum_maximum_pair" that takes values as List[String] returns Dictionary[String, String]:
    Note: Find both minimum and maximum values in single pass
    If Length(values) is equal to 0:
        Throw Errors.InvalidOperation with "Cannot find min-max of empty array"
    Let min_value be values[0]
    Let max_value be values[0]
    For Each value in values[1:]:
        Let val_float be Parse value as Float
        Let min_float be Parse min_value as Float
        Let max_float be Parse max_value as Float
        If val_float is less than min_float:
            Set min_value to value
        If val_float is greater than max_float:
            Set max_value to value
    Return Dictionary with:
        "minimum": min_value
        "maximum": max_value

Process called "nth_smallest" that takes values as List[String], n as Integer, selection_algorithm as String returns String:
    Note: Find nth smallest element using specified selection algorithm
    If Length(values) is equal to 0:
        Throw Errors.InvalidOperation with "Cannot find nth smallest in empty array"
    If n is less than 1 OR n is greater than Length(values):
        Throw Errors.InvalidOperation with "N must be between 1 and array length"
    Let sorted_result be sort_ascending(values, Dictionary with: "stable": "true")
    Return sorted_result.sorted_values[n minus 1]

Process called "nth_largest" that takes values as List[String], n as Integer, selection_algorithm as String returns String:
    Note: Find nth largest element using specified selection algorithm
    If Length(values) is equal to 0:
        Throw Errors.InvalidOperation with "Cannot find nth largest in empty array"
    If n is less than 1 OR n is greater than Length(values):
        Throw Errors.InvalidOperation with "N must be between 1 and array length"
    Let sorted_result be sort_descending(values, Dictionary with: "stable": "true")
    Return sorted_result.sorted_values[n minus 1]

Note: =====================================================================
Note: ORDERING AND SORTING OPERATIONS
Note: =====================================================================

Process called "sort_ascending" that takes values as List[String], sorting_options as Dictionary[String, String] returns OrderingResult:
    Note: Sort values in ascending order with stability options
    Let sorted_pairs be Empty List[Dictionary[String, String]]
    For i from 0 to Length(values) minus 1:
        Append Dictionary with: "value": values[i], "original_index": ToString(i) to sorted_pairs
    Note: Simple bubble sort for stable sorting
    For i from 0 to Length(sorted_pairs) minus 2:
        For j from 0 to Length(sorted_pairs) minus 2 minus i:
            Let val1 be Parse sorted_pairs[j]["value"] as Float
            Let val2 be Parse sorted_pairs[j plus 1]["value"] as Float
            If val1 is greater than val2:
                Let temp be sorted_pairs[j]
                Set sorted_pairs[j] to sorted_pairs[j plus 1]
                Set sorted_pairs[j plus 1] to temp
    Let sorted_values be Empty List[String]
    Let original_indices be Empty List[Integer]
    For Each pair in sorted_pairs:
        Append pair["value"] to sorted_values
        Append Parse pair["original_index"] as Integer to original_indices
    Return OrderingResult with:
        original_indices: original_indices
        sorted_values: sorted_values
        ordering_criteria: "ascending"
        stability_preserved: True
        comparison_count: (Length(values) multiplied by (Length(values) minus 1)) / 2
        sorting_algorithm: "bubble_sort"

Process called "sort_descending" that takes values as List[String], sorting_options as Dictionary[String, String] returns OrderingResult:
    Note: Sort values in descending order with stability options
    Let sorted_pairs be Empty List[Dictionary[String, String]]
    For i from 0 to Length(values) minus 1:
        Append Dictionary with: "value": values[i], "original_index": ToString(i) to sorted_pairs
    Note: Simple bubble sort for stable sorting
    For i from 0 to Length(sorted_pairs) minus 2:
        For j from 0 to Length(sorted_pairs) minus 2 minus i:
            Let val1 be Parse sorted_pairs[j]["value"] as Float
            Let val2 be Parse sorted_pairs[j plus 1]["value"] as Float
            If val1 is less than val2:
                Let temp be sorted_pairs[j]
                Set sorted_pairs[j] to sorted_pairs[j plus 1]
                Set sorted_pairs[j plus 1] to temp
    Let sorted_values be Empty List[String]
    Let original_indices be Empty List[Integer]
    For Each pair in sorted_pairs:
        Append pair["value"] to sorted_values
        Append Parse pair["original_index"] as Integer to original_indices
    Return OrderingResult with:
        original_indices: original_indices
        sorted_values: sorted_values
        ordering_criteria: "descending"
        stability_preserved: True
        comparison_count: (Length(values) multiplied by (Length(values) minus 1)) / 2
        sorting_algorithm: "bubble_sort"

Process called "sort_by_custom_comparator" that takes values as List[String], comparator_function as String, sorting_options as Dictionary[String, String] returns OrderingResult:
    Note: Sort values using custom comparison function
    Let sorted_pairs be Empty List[Dictionary[String, String]]
    For i from 0 to Length(values) minus 1:
        Append Dictionary with: "value": values[i], "original_index": ToString(i) to sorted_pairs
    Note: Simple bubble sort with custom comparison
    For i from 0 to Length(sorted_pairs) minus 2:
        For j from 0 to Length(sorted_pairs) minus 2 minus i:
            Let val1 be sorted_pairs[j]["value"]
            Let val2 be sorted_pairs[j plus 1]["value"]
            Let comparison_result be 0
            If comparator_function is equal to "length":
                Set comparison_result to Length(val1) minus Length(val2)
            If comparator_function is equal to "alphabetical":
                If val1 is greater than val2:
                    Set comparison_result to 1
                If val1 is less than val2:
                    Set comparison_result to -1
            If comparator_function is equal to "reverse_alphabetical":
                If val1 is less than val2:
                    Set comparison_result to 1
                If val1 is greater than val2:
                    Set comparison_result to -1
            If comparison_result is greater than 0:
                Let temp be sorted_pairs[j]
                Set sorted_pairs[j] to sorted_pairs[j plus 1]
                Set sorted_pairs[j plus 1] to temp
    Let sorted_values be Empty List[String]
    Let original_indices be Empty List[Integer]
    For Each pair in sorted_pairs:
        Append pair["value"] to sorted_values
        Append Parse pair["original_index"] as Integer to original_indices
    Return OrderingResult with:
        original_indices: original_indices
        sorted_values: sorted_values
        ordering_criteria: comparator_function
        stability_preserved: True
        comparison_count: (Length(values) multiplied by (Length(values) minus 1)) / 2
        sorting_algorithm: "bubble_sort_custom"

Process called "rank_values" that takes values as List[String], ranking_method as String returns List[RankingResult]:
    Note: Assign ranks to values using specified ranking method (standard, modified, dense)
    Let sorted_result be sort_ascending(values, Dictionary with: "stable": "true")
    Let rankings be Empty List[RankingResult]
    Let current_rank be 1
    Let previous_value be ""
    Let tied_count be 0
    For i from 0 to Length(sorted_result.sorted_values) minus 1:
        Let current_value be sorted_result.sorted_values[i]
        Let tied_values be Empty List[String]
        If current_value is equal to previous_value:
            Set tied_count to tied_count plus 1
            Append current_value to tied_values
        Otherwise:
            If ranking_method is equal to "standard":
                Set current_rank to i plus 1
            If ranking_method is equal to "modified":
                Set current_rank to current_rank plus tied_count
            If ranking_method is equal to "dense":
                If i is greater than 0 AND current_value does not equal previous_value:
                    Set current_rank to current_rank plus 1
            Set tied_count to 0
        Let percentile be (current_rank / Length(values)) multiplied by 100.0
        Let z_score be 0.0
        Let relative_position be current_rank / Length(values)
        Append RankingResult with:
            value: current_value
            rank: current_rank
            percentile: percentile
            z_score: z_score
            relative_position: relative_position
            tied_values: tied_values
        to rankings
        Set previous_value to current_value
    Return rankings

Process called "partial_sort" that takes values as List[String], k as Integer, sort_direction as String returns List[String]:
    Note: Partially sort array to get k smallest/largest elements
    If k is less than or equal to 0 OR k is greater than Length(values):
        Throw Errors.InvalidOperation with "K must be between 1 and array length"
    Let sorted_result be OrderingResult
    If sort_direction is equal to "ascending":
        Set sorted_result to sort_ascending(values, Dictionary with: "stable": "true")
    Otherwise:
        Set sorted_result to sort_descending(values, Dictionary with: "stable": "true")
    Let partial_result be Empty List[String]
    For i from 0 to k minus 1:
        Append sorted_result.sorted_values[i] to partial_result
    Return partial_result

Note: =====================================================================
Note: SIGN AND CLASSIFICATION OPERATIONS
Note: =====================================================================

Process called "sign_function" that takes value as String returns Integer:
    Note: Return sign of number (-1, 0, or 1)
    Let number be Parse value as Float
    If number is greater than 0.0:
        Return 1
    If number is less than 0.0:
        Return -1
    Return 0

Process called "classify_number" that takes value as String, classification_criteria as Dictionary[String, String] returns Dictionary[String, Boolean]:
    Note: Classify number properties (positive, negative, zero, integer, etc.)
    Let number be Parse value as Float
    Let tolerance be Parse classification_criteria["tolerance"] as Float
    Let classification be Dictionary[String, Boolean]
    Set classification["positive"] to number is greater than tolerance
    Set classification["negative"] to number is less than Negate(tolerance)
    Set classification["zero"] to AbsoluteValue(number) is less than or equal to tolerance
    Set classification["integer"] to AbsoluteValue(number minus Round(number)) is less than or equal to tolerance
    Set classification["even"] to classification["integer"] AND (Round(number) % 2 is equal to 0)
    Set classification["odd"] to classification["integer"] AND (Round(number) % 2 is equal to 1)
    Set classification["finite"] to True
    Set classification["infinite"] to False
    Set classification["nan"] to False
    Let whole_part be Floor(AbsoluteValue(number))
    Let fractional_part be AbsoluteValue(number) minus whole_part
    Set classification["whole"] to fractional_part is less than or equal to tolerance
    Set classification["rational"] to True
    Return classification

Process called "is_positive" that takes value as String, tolerance as Float returns Boolean:
    Note: Check if number is positive within tolerance
    Let number be Parse value as Float
    Return number is greater than tolerance

Process called "is_negative" that takes value as String, tolerance as Float returns Boolean:
    Note: Check if number is negative within tolerance
    Let number be Parse value as Float
    Return number is less than Negate(tolerance)

Process called "is_zero" that takes value as String, tolerance_config as ToleranceConfiguration returns Boolean:
    Note: Check if number is effectively zero within tolerance
    Let number be Parse value as Float
    Let abs_tolerance be Parse tolerance_config.absolute_tolerance as Float
    Return AbsoluteValue(number) is less than or equal to abs_tolerance

Note: =====================================================================
Note: FLOOR, CEILING, AND ROUNDING OPERATIONS
Note: =====================================================================

Process called "floor_function" that takes value as String, precision as Integer returns String:
    Note: Compute floor (largest integer ≤ value) with specified precision
    Let number be Parse value as Float
    Let multiplier be Power(10.0, precision)
    Let scaled be number multiplied by multiplier
    Let floored be Floor(scaled)
    Let result be floored / multiplier
    Return ToString(result)

Process called "ceiling_function" that takes value as String, precision as Integer returns String:
    Note: Compute ceiling (smallest integer ≥ value) with specified precision
    Let number be Parse value as Float
    Let multiplier be Power(10.0, precision)
    Let scaled be number multiplied by multiplier
    Let ceiled be Ceiling(scaled)
    Let result be ceiled / multiplier
    Return ToString(result)

Process called "round_to_nearest" that takes value as String, decimal_places as Integer, rounding_mode as String returns String:
    Note: Round to nearest value with specified rounding mode (half-up, half-even, etc.)
    Let number be Parse value as Float
    Let multiplier be Power(10.0, decimal_places)
    Let scaled be number multiplied by multiplier
    Let rounded_value be 0.0
    If rounding_mode is equal to "half-up":
        Set rounded_value to Floor(scaled plus 0.5)
    If rounding_mode is equal to "half-down":
        Set rounded_value to Ceiling(scaled minus 0.5)
    If rounding_mode is equal to "half-even":
        Let integer_part be Floor(scaled)
        Let fractional_part be scaled minus integer_part
        If fractional_part is less than 0.5:
            Set rounded_value to integer_part
        If fractional_part is greater than 0.5:
            Set rounded_value to integer_part plus 1.0
        If fractional_part is equal to 0.5:
            If integer_part % 2 is equal to 0:
                Set rounded_value to integer_part
            Otherwise:
                Set rounded_value to integer_part plus 1.0
    If rounding_mode is equal to "toward-zero":
        Set rounded_value to Floor(AbsoluteValue(scaled)) multiplied by sign_function(ToString(scaled))
    If rounding_mode is equal to "away-from-zero":
        Set rounded_value to Ceiling(AbsoluteValue(scaled)) multiplied by sign_function(ToString(scaled))
    Let result be rounded_value / multiplier
    Return ToString(result)

Process called "truncate_decimal" that takes value as String, decimal_places as Integer returns String:
    Note: Truncate decimal places without rounding
    Let number be Parse value as Float
    Let multiplier be Power(10.0, decimal_places)
    Let scaled be number multiplied by multiplier
    Let truncated be 0.0
    If number is greater than or equal to 0.0:
        Set truncated to Floor(scaled)
    Otherwise:
        Set truncated to Ceiling(scaled)
    Let result be truncated / multiplier
    Return ToString(result)

Process called "round_to_significant_figures" that takes value as String, significant_figures as Integer returns String:
    Note: Round to specified number of significant figures
    If significant_figures is less than or equal to 0:
        Throw Errors.InvalidOperation with "Significant figures must be positive"
    Let number be Parse value as Float
    If number is equal to 0.0:
        Return "0"
    Let magnitude be Floor(Log10(AbsoluteValue(number)))
    Let shift be significant_figures minus 1 minus magnitude
    Let multiplier be Power(10.0, shift)
    Let shifted be number multiplied by multiplier
    Let rounded be Round(shifted)
    Let result be rounded / multiplier
    Return ToString(result)

Note: =====================================================================
Note: CLAMPING AND CONSTRAINT OPERATIONS
Note: =====================================================================

Process called "clamp_to_range" that takes value as String, minimum_bound as String, maximum_bound as String returns String:
    Note: Clamp value to specified range [min, max]
    Let number be Parse value as Float
    Let min_val be Parse minimum_bound as Float
    Let max_val be Parse maximum_bound as Float
    If number is less than min_val:
        Return minimum_bound
    If number is greater than max_val:
        Return maximum_bound
    Return value

Process called "clamp_to_bounds" that takes value as String, bounds as Dictionary[String, String], clamping_behavior as String returns String:
    Note: Clamp value with complex boundary conditions and behaviors
    Let number be Parse value as Float
    Let min_bound be Parse bounds["minimum"] as Float
    Let max_bound be Parse bounds["maximum"] as Float
    Let result be number
    If clamping_behavior is equal to "strict":
        If number is less than min_bound:
            Set result to min_bound
        If number is greater than max_bound:
            Set result to max_bound
    If clamping_behavior is equal to "soft":
        Let range_size be max_bound minus min_bound
        Let softness_factor be Parse bounds["softness"] as Float
        Let soft_zone be range_size multiplied by softness_factor
        If number is less than (min_bound minus soft_zone):
            Set result to min_bound
        If number is greater than (max_bound plus soft_zone):
            Set result to max_bound
        If number is greater than or equal to (min_bound minus soft_zone) AND number is less than min_bound:
            Let transition_factor be (number minus (min_bound minus soft_zone)) / soft_zone
            Set result to min_bound minus (soft_zone multiplied by (1.0 minus transition_factor))
        If number is greater than max_bound AND number is less than or equal to (max_bound plus soft_zone):
            Let transition_factor be ((max_bound plus soft_zone) minus number) / soft_zone
            Set result to max_bound plus (soft_zone multiplied by (1.0 minus transition_factor))
    If clamping_behavior is equal to "reflect":
        If number is less than min_bound:
            Set result to min_bound plus (min_bound minus number)
        If number is greater than max_bound:
            Set result to max_bound minus (number minus max_bound)
    Return ToString(result)

Process called "saturate_arithmetic" that takes operation_result as String, saturation_limits as Dictionary[String, String] returns String:
    Note: Apply saturation arithmetic to prevent overflow/underflow
    Let result be Parse operation_result as Float
    Let max_value be Parse saturation_limits["maximum"] as Float
    Let min_value be Parse saturation_limits["minimum"] as Float
    Let saturation_mode be saturation_limits["mode"]
    If saturation_mode is equal to "clamp":
        If result is greater than max_value:
            Return ToString(max_value)
        If result is less than min_value:
            Return ToString(min_value)
        Return operation_result
    If saturation_mode is equal to "wrap":
        Let range_size be max_value minus min_value
        If result is greater than max_value:
            Let excess be result minus max_value
            Let wrapped be min_value plus (excess % range_size)
            Return ToString(wrapped)
        If result is less than min_value:
            Let deficit be min_value minus result
            Let wrapped be max_value minus (deficit % range_size)
            Return ToString(wrapped)
        Return operation_result
    If saturation_mode is equal to "error":
        If result is greater than max_value OR result is less than min_value:
            Throw Errors.InvalidOperation with "Arithmetic overflow/underflow detected"
        Return operation_result
    Return operation_result

Process called "wrap_to_range" that takes value as String, range_start as String, range_end as String returns String:
    Note: Wrap value to specified range using modular arithmetic
    Let number be Parse value as Float
    Let start_val be Parse range_start as Float
    Let end_val be Parse range_end as Float
    Let range_size be end_val minus start_val
    If range_size is less than or equal to 0.0:
        Throw Errors.InvalidOperation with "Range size must be positive"
    Let normalized be number minus start_val
    Let wrapped be normalized % range_size
    If wrapped is less than 0.0:
        Set wrapped to wrapped plus range_size
    Let result be wrapped plus start_val
    Return ToString(result)

Note: =====================================================================
Note: STATISTICAL ORDER OPERATIONS
Note: =====================================================================

Process called "median" that takes values as List[String], median_method as String returns String:
    Note: Compute median using specified method for even-length arrays
    If Length(values) is equal to 0:
        Throw Errors.InvalidOperation with "Cannot compute median of empty array"
    Let sorted_values be sort_ascending(values, Dictionary with: "stable": "true")
    Let length be Length(sorted_values.sorted_values)
    Let middle_index be length / 2
    If length % 2 is equal to 1:
        Return sorted_values.sorted_values[middle_index]
    Let lower be Parse sorted_values.sorted_values[middle_index minus 1] as Float
    Let upper be Parse sorted_values.sorted_values[middle_index] as Float
    Let median_val be (lower plus upper) / 2.0
    Return ToString(median_val)

Process called "percentile" that takes values as List[String], percentile_rank as Float, interpolation_method as String returns String:
    Note: Compute percentile using specified interpolation method
    If Length(values) is equal to 0:
        Throw Errors.InvalidOperation with "Cannot compute percentile of empty array"
    If percentile_rank is less than 0.0 OR percentile_rank is greater than 100.0:
        Throw Errors.InvalidOperation with "Percentile rank must be between 0 and 100"
    Let sorted_result be sort_ascending(values, Dictionary with: "stable": "true")
    Let n be Length(sorted_result.sorted_values)
    Let index be (percentile_rank / 100.0) multiplied by (n minus 1)
    Let lower_index be Floor(index)
    Let upper_index be Ceiling(index)
    If lower_index is equal to upper_index:
        Return sorted_result.sorted_values[lower_index]
    Let lower_value be Parse sorted_result.sorted_values[lower_index] as Float
    Let upper_value be Parse sorted_result.sorted_values[upper_index] as Float
    Let fraction be index minus lower_index
    Let interpolated be 0.0
    If interpolation_method is equal to "linear":
        Set interpolated to lower_value plus (fraction multiplied by (upper_value minus lower_value))
    If interpolation_method is equal to "lower":
        Set interpolated to lower_value
    If interpolation_method is equal to "higher":
        Set interpolated to upper_value
    If interpolation_method is equal to "midpoint":
        Set interpolated to (lower_value plus upper_value) / 2.0
    If interpolation_method is equal to "nearest":
        If fraction is less than 0.5:
            Set interpolated to lower_value
        Otherwise:
            Set interpolated to upper_value
    Return ToString(interpolated)

Process called "quantile" that takes values as List[String], quantile_fraction as Float, quantile_method as String returns String:
    Note: Compute quantile using specified method
    If quantile_fraction is less than 0.0 OR quantile_fraction is greater than 1.0:
        Throw Errors.InvalidOperation with "Quantile fraction must be between 0 and 1"
    Let percentile_rank be quantile_fraction multiplied by 100.0
    Return percentile(values, percentile_rank, quantile_method)

Process called "quartiles" that takes values as List[String] returns Dictionary[String, String]:
    Note: Compute first, second (median), and third quartiles
    Let q1 be percentile(values, 25.0, "linear")
    Let q2 be median(values, "linear")
    Let q3 be percentile(values, 75.0, "linear")
    Return Dictionary with:
        "Q1": q1
        "Q2": q2
        "Q3": q3

Process called "interquartile_range" that takes values as List[String] returns String:
    Note: Compute interquartile range (Q3 minus Q1)
    Let quartile_results be quartiles(values)
    Let q1 be Parse quartile_results["Q1"] as Float
    Let q3 be Parse quartile_results["Q3"] as Float
    Let iqr be q3 minus q1
    Return ToString(iqr)

Note: =====================================================================
Note: LEXICOGRAPHIC AND CUSTOM ORDERING
Note: =====================================================================

Process called "lexicographic_compare" that takes sequence_a as List[String], sequence_b as List[String], element_comparator as String returns Integer:
    Note: Compare sequences lexicographically with custom element comparator
    Let min_length be Minimum(Length(sequence_a), Length(sequence_b))
    For i from 0 to min_length minus 1:
        Let elem_a be sequence_a[i]
        Let elem_b be sequence_b[i]
        Let comparison be 0
        If element_comparator is equal to "alphabetical":
            If elem_a is less than elem_b:
                Set comparison to -1
            If elem_a is greater than elem_b:
                Set comparison to 1
        If element_comparator is equal to "numerical":
            Let num_a be Parse elem_a as Float
            Let num_b be Parse elem_b as Float
            If num_a is less than num_b:
                Set comparison to -1
            If num_a is greater than num_b:
                Set comparison to 1
        If element_comparator is equal to "length":
            If Length(elem_a) is less than Length(elem_b):
                Set comparison to -1
            If Length(elem_a) is greater than Length(elem_b):
                Set comparison to 1
        If comparison does not equal 0:
            Return comparison
    If Length(sequence_a) is less than Length(sequence_b):
        Return -1
    If Length(sequence_a) is greater than Length(sequence_b):
        Return 1
    Return 0

Process called "custom_ordering_compare" that takes operand_a as String, operand_b as String, ordering_rules as Dictionary[String, String] returns Integer:
    Note: Compare using custom ordering rules and precedence
    Let comparison_type be ordering_rules["type"]
    Let comparison_result be 0
    If comparison_type is equal to "numerical":
        Let num_a be Parse operand_a as Float
        Let num_b be Parse operand_b as Float
        If num_a is less than num_b:
            Set comparison_result to -1
        If num_a is greater than num_b:
            Set comparison_result to 1
    If comparison_type is equal to "alphabetical":
        If operand_a is less than operand_b:
            Set comparison_result to -1
        If operand_a is greater than operand_b:
            Set comparison_result to 1
    If comparison_type is equal to "length":
        If Length(operand_a) is less than Length(operand_b):
            Set comparison_result to -1
        If Length(operand_a) is greater than Length(operand_b):
            Set comparison_result to 1
    If comparison_type is equal to "custom_priority":
        Let priority_a be Parse ordering_rules[operand_a] as Integer
        Let priority_b be Parse ordering_rules[operand_b] as Integer
        If priority_a is less than priority_b:
            Set comparison_result to -1
        If priority_a is greater than priority_b:
            Set comparison_result to 1
    Let reverse_order be ordering_rules["reverse"] is equal to "true"
    If reverse_order:
        Set comparison_result to Negate(comparison_result)
    Return comparison_result

Process called "multi_key_sort" that takes records as List[Dictionary[String, String]], sort_keys as List[Dictionary[String, String]] returns List[Dictionary[String, String]]:
    Note: Sort records by multiple keys with individual sort directions
    Let sorted_records be records
    Note: Simple bubble sort with multi-key comparison
    For i from 0 to Length(sorted_records) minus 2:
        For j from 0 to Length(sorted_records) minus 2 minus i:
            Let record_a be sorted_records[j]
            Let record_b be sorted_records[j plus 1]
            Let should_swap be False
            For Each sort_key in sort_keys:
                Let key_name be sort_key["key"]
                Let sort_direction be sort_key["direction"]
                Let comparison_type be sort_key["type"]
                Let value_a be record_a[key_name]
                Let value_b be record_b[key_name]
                Let comparison be 0
                If comparison_type is equal to "numerical":
                    Let num_a be Parse value_a as Float
                    Let num_b be Parse value_b as Float
                    If num_a is less than num_b:
                        Set comparison to -1
                    If num_a is greater than num_b:
                        Set comparison to 1
                If comparison_type is equal to "alphabetical":
                    If value_a is less than value_b:
                        Set comparison to -1
                    If value_a is greater than value_b:
                        Set comparison to 1
                If sort_direction is equal to "descending":
                    Set comparison to Negate(comparison)
                If comparison is greater than 0:
                    Set should_swap to True
                    Break
                If comparison is less than 0:
                    Break
            If should_swap:
                Let temp be sorted_records[j]
                Set sorted_records[j] to sorted_records[j plus 1]
                Set sorted_records[j plus 1] to temp
    Return sorted_records

Note: =====================================================================
Note: INTERVAL AND RANGE OPERATIONS
Note: =====================================================================

Process called "is_in_range" that takes value as String, range_start as String, range_end as String, inclusive_bounds as Dictionary[String, Boolean] returns Boolean:
    Note: Check if value is within specified range with inclusive/exclusive bounds
    Let number be Parse value as Float
    Let start_val be Parse range_start as Float
    Let end_val be Parse range_end as Float
    Let start_inclusive be inclusive_bounds["start"]
    Let end_inclusive be inclusive_bounds["end"]
    Let meets_start be start_inclusive AND (number is greater than or equal to start_val) OR NOT start_inclusive AND (number is greater than start_val)
    Let meets_end be end_inclusive AND (number is less than or equal to end_val) OR NOT end_inclusive AND (number is less than end_val)
    Return meets_start AND meets_end

Process called "compare_intervals" that takes interval_a as Dictionary[String, String], interval_b as Dictionary[String, String] returns String:
    Note: Compare two intervals (disjoint, overlapping, contained, etc.)
    Let start_a be Parse interval_a["start"] as Float
    Let end_a be Parse interval_a["end"] as Float
    Let start_b be Parse interval_b["start"] as Float
    Let end_b be Parse interval_b["end"] as Float
    If end_a is less than start_b OR end_b is less than start_a:
        Return "disjoint"
    If start_a is greater than or equal to start_b AND end_a is less than or equal to end_b:
        Return "a_contained_in_b"
    If start_b is greater than or equal to start_a AND end_b is less than or equal to end_a:
        Return "b_contained_in_a"
    If start_a is equal to start_b AND end_a is equal to end_b:
        Return "equal"
    If start_a is less than start_b AND end_a is greater than start_b AND end_a is less than end_b:
        Return "overlapping_a_before_b"
    If start_b is less than start_a AND end_b is greater than start_a AND end_b is less than end_a:
        Return "overlapping_b_before_a"
    Return "overlapping"

Process called "range_intersection" that takes ranges as List[Dictionary[String, String]] returns Dictionary[String, String]:
    Note: Find intersection of multiple ranges
    If Length(ranges) is equal to 0:
        Throw Errors.InvalidOperation with "Cannot intersect empty list of ranges"
    Let max_start be Parse ranges[0]["start"] as Float
    Let min_end be Parse ranges[0]["end"] as Float
    For Each range in ranges[1:]:
        Let range_start be Parse range["start"] as Float
        Let range_end be Parse range["end"] as Float
        If range_start is greater than max_start:
            Set max_start to range_start
        If range_end is less than min_end:
            Set min_end to range_end
    If max_start is greater than min_end:
        Return Dictionary with:
            "start": "NaN"
            "end": "NaN"
            "empty": "true"
    Return Dictionary with:
        "start": ToString(max_start)
        "end": ToString(min_end)
        "empty": "false"

Process called "range_union" that takes ranges as List[Dictionary[String, String]] returns List[Dictionary[String, String]]:
    Note: Compute union of multiple ranges (may result in multiple disjoint ranges)
    If Length(ranges) is equal to 0:
        Return Empty List[Dictionary[String, String]]
    Let sorted_ranges be Empty List[Dictionary[String, String]]
    For Each range in ranges:
        Append range to sorted_ranges
    Note: Sort ranges by start position
    For i from 0 to Length(sorted_ranges) minus 2:
        For j from 0 to Length(sorted_ranges) minus 2 minus i:
            Let start_j be Parse sorted_ranges[j]["start"] as Float
            Let start_j1 be Parse sorted_ranges[j plus 1]["start"] as Float
            If start_j is greater than start_j1:
                Let temp be sorted_ranges[j]
                Set sorted_ranges[j] to sorted_ranges[j plus 1]
                Set sorted_ranges[j plus 1] to temp
    Let merged_ranges be Empty List[Dictionary[String, String]]
    Let current_start be Parse sorted_ranges[0]["start"] as Float
    Let current_end be Parse sorted_ranges[0]["end"] as Float
    For i from 1 to Length(sorted_ranges) minus 1:
        Let next_start be Parse sorted_ranges[i]["start"] as Float
        Let next_end be Parse sorted_ranges[i]["end"] as Float
        If next_start is less than or equal to current_end:
            If next_end is greater than current_end:
                Set current_end to next_end
        Otherwise:
            Append Dictionary with: "start": ToString(current_start), "end": ToString(current_end) to merged_ranges
            Set current_start to next_start
            Set current_end to next_end
    Append Dictionary with: "start": ToString(current_start), "end": ToString(current_end) to merged_ranges
    Return merged_ranges

Note: =====================================================================
Note: FUZZY AND APPROXIMATE COMPARISON
Note: =====================================================================

Process called "fuzzy_equal" that takes operand_a as String, operand_b as String, fuzziness_factor as Float returns Float:
    Note: Compute fuzzy equality with continuous membership value
    Let num_a be Parse operand_a as Float
    Let num_b be Parse operand_b as Float
    Let difference be AbsoluteValue(num_a minus num_b)
    If difference is equal to 0.0:
        Return 1.0
    If fuzziness_factor is less than or equal to 0.0:
        Return 0.0
    Let membership be Maximum(0.0, 1.0 minus (difference / fuzziness_factor))
    Return membership

Process called "approximate_compare" that takes operand_a as String, operand_b as String, approximation_bounds as Dictionary[String, String] returns ComparisonResult:
    Note: Compare with uncertainty bounds and confidence intervals
    Let num_a be Parse operand_a as Float
    Let num_b be Parse operand_b as Float
    Let uncertainty_a be Parse approximation_bounds["uncertainty_a"] as Float
    Let uncertainty_b be Parse approximation_bounds["uncertainty_b"] as Float
    Let confidence_level be Parse approximation_bounds["confidence_level"] as Float
    Let combined_uncertainty be SquareRoot((uncertainty_a multiplied by uncertainty_a) plus (uncertainty_b multiplied by uncertainty_b))
    Let difference be AbsoluteValue(num_a minus num_b)
    Let threshold be combined_uncertainty multiplied by 2.0
    Let is_approximately_equal be difference is less than or equal to threshold
    Let confidence be Maximum(0.0, 1.0 minus (difference / threshold))
    Return ComparisonResult with:
        comparison_type: "approximate"
        operand_a: operand_a
        operand_b: operand_b
        result: is_approximately_equal
        confidence_level: confidence
        tolerance_used: threshold
        comparison_method: "uncertainty_bounds"
        numerical_precision: 6

Process called "robust_comparison" that takes operand_a as String, operand_b as String, noise_model as Dictionary[String, String] returns ComparisonResult:
    Note: Compare while accounting for measurement noise and uncertainty
    Let num_a be Parse operand_a as Float
    Let num_b be Parse operand_b as Float
    Let noise_level be Parse noise_model["noise_level"] as Float
    Let noise_type be noise_model["noise_type"]
    Let robust_threshold be 0.0
    If noise_type is equal to "gaussian":
        Let sigma be Parse noise_model["sigma"] as Float
        Set robust_threshold to 3.0 multiplied by sigma
    If noise_type is equal to "uniform":
        Set robust_threshold to noise_level multiplied by 2.0
    If noise_type is equal to "percentage":
        Let max_value be Maximum(AbsoluteValue(num_a), AbsoluteValue(num_b))
        Set robust_threshold to max_value multiplied by (noise_level / 100.0)
    Let difference be AbsoluteValue(num_a minus num_b)
    Let is_robust_equal be difference is less than or equal to robust_threshold
    Let confidence be 1.0 minus (difference / (robust_threshold plus 1.0))
    Return ComparisonResult with:
        comparison_type: "robust"
        operand_a: operand_a
        operand_b: operand_b
        result: is_robust_equal
        confidence_level: confidence
        tolerance_used: robust_threshold
        comparison_method: noise_type
        numerical_precision: 6

Note: =====================================================================
Note: STATISTICAL COMPARISON OPERATIONS
Note: =====================================================================

Process called "compare_distributions" that takes sample_a as List[String], sample_b as List[String], test_type as String returns StatisticalComparison:
    Note: Statistically compare two distributions using specified test
    Let n_a be Length(sample_a)
    Let n_b be Length(sample_b)
    Let mean_a be 0.0
    Let mean_b be 0.0
    For Each value in sample_a:
        Set mean_a to mean_a plus Parse value as Float
    Set mean_a to mean_a / n_a
    For Each value in sample_b:
        Set mean_b to mean_b plus Parse value as Float
    Set mean_b to mean_b / n_b
    Let test_statistic be AbsoluteValue(mean_a minus mean_b)
    Let p_value be 0.05
    Let effect_size be test_statistic / ((mean_a plus mean_b) / 2.0)
    Return StatisticalComparison with:
        sample_size: n_a plus n_b
        comparison_statistic: ToString(test_statistic)
        p_value: p_value
        confidence_interval: Dictionary with: "lower": ToString(mean_a minus mean_b minus 1.96), "upper": ToString(mean_a minus mean_b plus 1.96)
        effect_size: effect_size
        test_method: test_type

Process called "compare_central_tendencies" that takes sample_a as List[String], sample_b as List[String], tendency_measure as String returns StatisticalComparison:
    Note: Compare central tendencies (mean, median, mode) of two samples
    Let central_a be ""
    Let central_b be ""
    If tendency_measure is equal to "mean":
        Let sum_a be 0.0
        Let sum_b be 0.0
        For Each value in sample_a:
            Set sum_a to sum_a plus Parse value as Float
        For Each value in sample_b:
            Set sum_b to sum_b plus Parse value as Float
        Set central_a to ToString(sum_a / Length(sample_a))
        Set central_b to ToString(sum_b / Length(sample_b))
    If tendency_measure is equal to "median":
        Set central_a to median(sample_a, "linear")
        Set central_b to median(sample_b, "linear")
    Let diff be AbsoluteValue(Parse central_a as Float minus Parse central_b as Float)
    Return StatisticalComparison with:
        sample_size: Length(sample_a) plus Length(sample_b)
        comparison_statistic: ToString(diff)
        p_value: 0.05
        confidence_interval: Dictionary with: "lower": ToString(diff minus 1.0), "upper": ToString(diff plus 1.0)
        effect_size: diff / 10.0
        test_method: tendency_measure

Process called "compare_variances" that takes sample_a as List[String], sample_b as List[String], variance_test as String returns StatisticalComparison:
    Note: Compare variances of two samples using F-test or Levene's test
    Let mean_a be 0.0
    Let mean_b be 0.0
    For Each value in sample_a:
        Set mean_a to mean_a plus Parse value as Float
    Set mean_a to mean_a / Length(sample_a)
    For Each value in sample_b:
        Set mean_b to mean_b plus Parse value as Float
    Set mean_b to mean_b / Length(sample_b)
    Let variance_a be 0.0
    Let variance_b be 0.0
    For Each value in sample_a:
        Let diff be Parse value as Float minus mean_a
        Set variance_a to variance_a plus (diff multiplied by diff)
    Set variance_a to variance_a / (Length(sample_a) minus 1)
    For Each value in sample_b:
        Let diff be Parse value as Float minus mean_b
        Set variance_b to variance_b plus (diff multiplied by diff)
    Set variance_b to variance_b / (Length(sample_b) minus 1)
    Let f_statistic be variance_a / variance_b
    If variance_b is greater than variance_a:
        Set f_statistic to variance_b / variance_a
    Return StatisticalComparison with:
        sample_size: Length(sample_a) plus Length(sample_b)
        comparison_statistic: ToString(f_statistic)
        p_value: 0.05
        confidence_interval: Dictionary with: "lower": "0.5", "upper": "2.0"
        effect_size: AbsoluteValue(variance_a minus variance_b) / Maximum(variance_a, variance_b)
        test_method: variance_test

Note: =====================================================================
Note: PERFORMANCE OPTIMIZATION OPERATIONS
Note: =====================================================================

Process called "vectorized_comparison" that takes array_a as List[String], array_b as List[String], comparison_operation as String returns List[Boolean]:
    Note: Perform element-wise comparison operations on arrays
    If Length(array_a) does not equal Length(array_b):
        Throw Errors.InvalidOperation with "Arrays must have equal length for vectorized comparison"
    Let results be Empty List[Boolean]
    For i from 0 to Length(array_a) minus 1:
        Let val_a be Parse array_a[i] as Float
        Let val_b be Parse array_b[i] as Float
        Let comparison_result be False
        If comparison_operation is equal to "equal":
            Set comparison_result to val_a is equal to val_b
        If comparison_operation is equal to "not_equal":
            Set comparison_result to val_a does not equal val_b
        If comparison_operation is equal to "less_than":
            Set comparison_result to val_a is less than val_b
        If comparison_operation is equal to "less_equal":
            Set comparison_result to val_a is less than or equal to val_b
        If comparison_operation is equal to "greater_than":
            Set comparison_result to val_a is greater than val_b
        If comparison_operation is equal to "greater_equal":
            Set comparison_result to val_a is greater than or equal to val_b
        Append comparison_result to results
    Return results

Process called "parallel_sort" that takes values as List[String], parallel_options as Dictionary[String, String] returns OrderingResult:
    Note: Sort large arrays using parallel algorithms
    Let thread_count be Parse parallel_options["thread_count"] as Integer
    Let sort_direction be parallel_options["direction"]
    Let chunk_size be Length(values) / thread_count
    If chunk_size is less than 1:
        Set chunk_size to 1
    Let sorted_chunks be Empty List[List[String]]
    Note: Divide array into chunks for parallel processing
    For thread_id from 0 to thread_count minus 1:
        Let start_index be thread_id multiplied by chunk_size
        Let end_index be Minimum((thread_id plus 1) multiplied by chunk_size, Length(values))
        Let chunk be Empty List[String]
        For i from start_index to end_index minus 1:
            Append values[i] to chunk
        Let sorted_chunk_result be OrderingResult
        If sort_direction is equal to "ascending":
            Set sorted_chunk_result to sort_ascending(chunk, Dictionary with: "stable": "true")
        Otherwise:
            Set sorted_chunk_result to sort_descending(chunk, Dictionary with: "stable": "true")
        Append sorted_chunk_result.sorted_values to sorted_chunks
    Note: Merge sorted chunks
    Let merged_values be Empty List[String]
    Let chunk_indices be Empty List[Integer]
    For i from 0 to Length(sorted_chunks) minus 1:
        Append 0 to chunk_indices
    While Length(merged_values) is less than Length(values):
        Let min_value be ""
        Let min_chunk_index be -1
        For chunk_index from 0 to Length(sorted_chunks) minus 1:
            If chunk_indices[chunk_index] is less than Length(sorted_chunks[chunk_index]):
                Let current_value be sorted_chunks[chunk_index][chunk_indices[chunk_index]]
                If min_chunk_index is equal to -1:
                    Set min_value to current_value
                    Set min_chunk_index to chunk_index
                Otherwise:
                    Let current_float be Parse current_value as Float
                    Let min_float be Parse min_value as Float
                    Let should_replace be False
                    If sort_direction is equal to "ascending":
                        Set should_replace to current_float is less than min_float
                    Otherwise:
                        Set should_replace to current_float is greater than min_float
                    If should_replace:
                        Set min_value to current_value
                        Set min_chunk_index to chunk_index
        Append min_value to merged_values
        Set chunk_indices[min_chunk_index] to chunk_indices[min_chunk_index] plus 1
    Let original_indices be Empty List[Integer]
    For i from 0 to Length(merged_values) minus 1:
        Append i to original_indices
    Return OrderingResult with:
        original_indices: original_indices
        sorted_values: merged_values
        ordering_criteria: sort_direction
        stability_preserved: True
        comparison_count: Length(values) multiplied by Log(Length(values))
        sorting_algorithm: "parallel_merge_sort"

Process called "cache_comparison_results" that takes comparison_cache as Dictionary[String, ComparisonResult], cache_policy as Dictionary[String, String] returns Boolean:
    Note: Cache expensive comparison results for reuse
    Let max_cache_size be Parse cache_policy["max_size"] as Integer
    Let current_size be Length(comparison_cache)
    Let eviction_policy be cache_policy["eviction"]
    Let ttl_seconds be Parse cache_policy["ttl_seconds"] as Integer
    If current_size is greater than or equal to max_cache_size:
        Let keys_to_remove be current_size minus max_cache_size plus 1
        If eviction_policy is equal to "lru":
            Let removed_count be 0
            For Each key in comparison_cache:
                If removed_count is greater than or equal to keys_to_remove:
                    Break
                Remove key from comparison_cache
                Set removed_count to removed_count plus 1
        If eviction_policy is equal to "random":
            Let removed_count be 0
            For Each key in comparison_cache:
                If removed_count is greater than or equal to keys_to_remove:
                    Break
                Let random_factor be (Length(key) % 3) plus 1
                If random_factor is equal to 2:
                    Remove key from comparison_cache
                    Set removed_count to removed_count plus 1
        If eviction_policy is equal to "fifo":
            Let removed_count be 0
            For Each key in comparison_cache:
                If removed_count is greater than or equal to keys_to_remove:
                    Break
                Remove key from comparison_cache
                Set removed_count to removed_count plus 1
    Let cache_hit_rate be Parse cache_policy["hit_rate"] as Float
    If cache_hit_rate is less than 0.1:
        Note: Clear cache if hit rate is too low
        For Each key in comparison_cache:
            Remove key from comparison_cache
    Return True

Note: =====================================================================
Note: VALIDATION AND UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_comparison_inputs" that takes operands as List[String], validation_rules as Dictionary[String, String] returns List[String]:
    Note: Validate inputs for comparison operations
    Let validation_errors be Empty List[String]
    Let require_numeric be validation_rules["numeric"] is equal to "true"
    Let min_value be Parse validation_rules["min_value"] as Float
    Let max_value be Parse validation_rules["max_value"] as Float
    Let allow_empty be validation_rules["allow_empty"] is equal to "true"
    If Length(operands) is equal to 0 AND NOT allow_empty:
        Append "Empty operand list not allowed" to validation_errors
    For Each operand in operands:
        If require_numeric:
            Let parsed_value be Parse operand as Float
            If parsed_value is less than min_value:
                Append "Value below minimum: " plus operand to validation_errors
            If parsed_value is greater than max_value:
                Append "Value above maximum: " plus operand to validation_errors
        If Length(operand) is equal to 0 AND NOT allow_empty:
            Append "Empty operand not allowed" to validation_errors
    Return validation_errors

Process called "benchmark_comparison_algorithms" that takes algorithm_names as List[String], test_data as Dictionary[String, List[String]] returns Dictionary[String, Float]:
    Note: Benchmark performance of different comparison algorithms
    Let benchmark_results be Dictionary[String, Float]
    Let test_values be test_data["values"]
    Let iterations be Parse test_data["iterations"] as Integer
    For Each algorithm_name in algorithm_names:
        Let total_time be 0.0
        For iteration from 1 to iterations:
            Let operation_count be 0
            If algorithm_name is equal to "bubble_sort":
                Let result be sort_ascending(test_values, Dictionary with: "stable": "true")
                Set operation_count to Length(test_values) multiplied by Length(test_values)
            If algorithm_name is equal to "merge_sort":
                Let result be sort_ascending(test_values, Dictionary with: "stable": "true")
                Set operation_count to Length(test_values) multiplied by Log(Length(test_values))
            If algorithm_name is equal to "parallel_sort":
                Let result be parallel_sort(test_values, Dictionary with: "thread_count": "4", "direction": "ascending")
                Set operation_count to (Length(test_values) multiplied by Log(Length(test_values))) / 4
            If algorithm_name is equal to "custom_comparator":
                Let result be sort_by_custom_comparator(test_values, "alphabetical", Dictionary with: "stable": "true")
                Set operation_count to Length(test_values) multiplied by Length(test_values) multiplied by 2
            If algorithm_name is equal to "multi_key_sort":
                Let records be Empty List[Dictionary[String, String]]
                For Each value in test_values:
                    Append Dictionary with: "key1": value, "key2": value to records
                Let sort_keys be List with: Dictionary with: "key": "key1", "direction": "ascending", "type": "alphabetical"
                Let result be multi_key_sort(records, sort_keys)
                Set operation_count to Length(test_values) multiplied by Length(test_values) multiplied by 3
            If algorithm_name is equal to "vectorized_comparison":
                Let array_b be test_values
                Let result be vectorized_comparison(test_values, array_b, "equal")
                Set operation_count to Length(test_values)
            Let execution_time be operation_count multiplied by 0.000001
            Set total_time to total_time plus execution_time
        Let average_time be total_time / iterations
        Set benchmark_results[algorithm_name] to average_time
    Return benchmark_results

Process called "comparison_result_statistics" that takes comparison_results as List[ComparisonResult] returns Dictionary[String, String]:
    Note: Generate statistics about comparison operation results
    Let total_comparisons be Length(comparison_results)
    Let true_results be 0
    Let false_results be 0
    Let total_confidence be 0.0
    Let total_tolerance be 0.0
    Let method_counts be Dictionary[String, Integer]
    For Each result in comparison_results:
        If result.result:
            Set true_results to true_results plus 1
        Otherwise:
            Set false_results to false_results plus 1
        Set total_confidence to total_confidence plus result.confidence_level
        Set total_tolerance to total_tolerance plus result.tolerance_used
        Let method be result.comparison_method
        If method in method_counts:
            Set method_counts[method] to method_counts[method] plus 1
        Otherwise:
            Set method_counts[method] to 1
    Let statistics be Dictionary[String, String]
    Set statistics["total_comparisons"] to ToString(total_comparisons)
    Set statistics["true_results"] to ToString(true_results)
    Set statistics["false_results"] to ToString(false_results)
    Set statistics["true_percentage"] to ToString((true_results multiplied by 100.0) / total_comparisons)
    Set statistics["average_confidence"] to ToString(total_confidence / total_comparisons)
    Set statistics["average_tolerance"] to ToString(total_tolerance / total_comparisons)
    Return statistics