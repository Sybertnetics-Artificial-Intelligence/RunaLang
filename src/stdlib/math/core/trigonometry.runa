Note:
math/core/trigonometry.runa
Trigonometric and Hyperbolic Functions

This module provides comprehensive trigonometric functionality including:
- Basic trigonometric functions (sin, cos, tan, cot, sec, csc)
- Inverse trigonometric functions (asin, acos, atan, atan2)
- Hyperbolic functions (sinh, cosh, tanh, coth, sech, csch)
- Inverse hyperbolic functions (asinh, acosh, atanh)
- Angle unit conversions (radians, degrees, gradians)
- Trigonometric identities and relationships
- High-precision trigonometric calculations
- Special angle calculations (π/6, π/4, π/3, etc.)
- Periodic function properties and normalization
- Complex trigonometric functions
- Spherical and elliptic trigonometry
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/precision/bigdecimal" as BigDecimal
Import module "math/core/constants" as Constants
Import module "math/core/operations" as Operations
Import module "math/core/conversion" as Conversion
Import module "compiler/frontend/diagnostics/diagnostic_engine" as DiagnosticEngine
Import module "compiler/frontend/diagnostics/error_formatter" as ErrorFormatter
Import module "compiler/frontend/diagnostics/suggestion_engine" as SuggestionEngine

Note: =====================================================================
Note: TRIGONOMETRIC DATA STRUCTURES
Note: =====================================================================

Type called "TrigonometricResult":
    function_value as String
    function_name as String
    input_angle as String
    angle_unit as String
    precision_used as Integer
    quadrant as Integer
    principal_value as Boolean
    computation_method as String
    error_occurred as Boolean
    error_code as String
    error_message as String
    domain_error as Boolean
    range_error as Boolean
    asymptote_error as Boolean
    precision_insufficient as Boolean
    series_convergence_failed as Boolean
    diagnostic_info as DiagnosticInfo

Type called "AngleUnit":
    unit_name as String
    radians_conversion_factor as String
    symbol as String
    full_rotation_value as String
    common_angles as Dictionary[String, String]

Type called "TrigonometricIdentity":
    identity_name as String
    identity_expression as String
    variables as List[String]
    constraints as List[String]
    proof_reference as String

Type called "SphericalTriangle":
    side_a as String
    side_b as String
    side_c as String
    angle_A as String
    angle_B as String
    angle_C as String
    sphere_radius as String

Note: =====================================================================
Note: ERROR HANDLING AND DIAGNOSTICS
Note: =====================================================================

Process called "create_trigonometric_result" that takes function_name as String returns TrigonometricResult:
    Note: Initialize a new TrigonometricResult with default error handling
    Let result be TrigonometricResult
    Set result.function_name to function_name
    Set result.error_occurred to false
    Set result.error_code to ""
    Set result.error_message to ""
    Set result.domain_error to false
    Set result.range_error to false
    Set result.asymptote_error to false
    Set result.precision_insufficient to false
    Set result.series_convergence_failed to false
    Return result

Process called "handle_trigonometric_error" that takes result as TrigonometricResult, error_code as String, context as String, operands as List[String] returns TrigonometricResult:
    Note: Handle trigonometric errors with diagnostic integration
    Set result.error_occurred to true
    Set result.error_code to error_code
    
    Let diagnostic_info be Errors.create_diagnostic_info(error_code, context, operands)
    Set result.diagnostic_info to diagnostic_info
    
    Let source_location be DiagnosticEngine.get_current_source_location()
    Set result.error_message to ErrorFormatter.format_math_error(diagnostic_info, source_location)
    
    If error_code is equal to "TRIG_DOMAIN_ERROR":
        Set result.domain_error to true
        Call Errors.emit_warning(diagnostic_info)
    Otherwise if error_code is equal to "TRIG_RANGE_ERROR":
        Set result.range_error to true
        Call Errors.emit_warning(diagnostic_info)
    Otherwise if error_code is equal to "TRIG_ASYMPTOTE_ERROR":
        Set result.asymptote_error to true
        Call Errors.emit_warning(diagnostic_info)
    Otherwise if error_code is equal to "TRIG_PRECISION_INSUFFICIENT":
        Set result.precision_insufficient to true
        Call Errors.emit_warning(diagnostic_info)
    Otherwise if error_code is equal to "TRIG_SERIES_CONVERGENCE":
        Set result.series_convergence_failed to true
        Call Errors.emit_warning(diagnostic_info)
    
    Return result

Note: =====================================================================
Note: BASIC TRIGONOMETRIC FUNCTIONS
Note: =====================================================================

Process called "sine" that takes angle as String, angle_unit as String, precision as Integer returns TrigonometricResult:
    Note: Compute sine of angle with specified precision
    Let result be create_trigonometric_result("sine")
    Set result.input_angle to angle
    Set result.angle_unit to angle_unit
    Set result.precision_used to precision
    Set result.computation_method to "taylor_series"
    Set result.principal_value to true
    
    Note: Validate precision parameter
    If precision is less than or equal to 0:
        Return handle_trigonometric_error(result, "TRIG_PRECISION_INSUFFICIENT", "sine computation", [angle, String(precision)])
    
    Note: Validate angle unit
    If not (angle_unit is equal to "radians" or angle_unit is equal to "degrees" or angle_unit is equal to "gradians" or angle_unit is equal to "turns"):
        Return handle_trigonometric_error(result, "TRIG_ANGLE_UNIT_ERROR", "sine computation", [angle, angle_unit])
    
    Let angle_radians be ""
    If angle_unit is equal to "radians":
        Set angle_radians to angle
    Otherwise if angle_unit is equal to "degrees":
        Set angle_radians to Conversion.degrees_to_radians(angle, precision)
    Otherwise if angle_unit is equal to "gradians":
        Set angle_radians to Conversion.gradians_to_radians(angle, precision)
    Otherwise:
        Return handle_trigonometric_error(result, "TRIG_ANGLE_UNIT_ERROR", "angle conversion", [angle, angle_unit])
    Let normalized_angle be normalize_angle(angle_radians)
    Set result.quadrant to determine_quadrant(normalized_angle)
    
    Let sine_value be compute_sine_taylor_series(normalized_angle, precision)
    Set result.function_value to sine_value
    
    Return result

Process called "cosine" that takes angle as String, angle_unit as String, precision as Integer returns TrigonometricResult:
    Note: Compute cosine of angle with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "cosine"
    Set result.input_angle to angle
    Set result.angle_unit to angle_unit
    Set result.precision_used to precision
    Set result.computation_method to "taylor_series"
    Set result.principal_value to true
    
    Let angle_radians be ""
    If angle_unit is equal to "radians":
        Set angle_radians to angle
    Otherwise if angle_unit is equal to "degrees":
        Set angle_radians to Conversion.degrees_to_radians(angle, precision)
    Otherwise if angle_unit is equal to "gradians":
        Set angle_radians to Conversion.gradians_to_radians(angle, precision)
    Otherwise:
        Return handle_trigonometric_error(result, "TRIG_ANGLE_UNIT_ERROR", "angle conversion", [angle, angle_unit])
    Let normalized_angle be normalize_angle(angle_radians)
    Set result.quadrant to determine_quadrant(normalized_angle)
    
    Let cosine_value be compute_cosine_taylor_series(normalized_angle, precision)
    Set result.function_value to cosine_value
    
    Return result

Process called "tangent" that takes angle as String, angle_unit as String, precision as Integer returns TrigonometricResult:
    Note: Compute tangent of angle with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "tangent"
    Set result.input_angle to angle
    Set result.angle_unit to angle_unit
    Set result.precision_used to precision
    Set result.computation_method to "sine_cosine_division"
    Set result.principal_value to true
    
    Let angle_radians be ""
    If angle_unit is equal to "radians":
        Set angle_radians to angle
    Otherwise if angle_unit is equal to "degrees":
        Set angle_radians to Conversion.degrees_to_radians(angle, precision)
    Otherwise if angle_unit is equal to "gradians":
        Set angle_radians to Conversion.gradians_to_radians(angle, precision)
    Otherwise:
        Return handle_trigonometric_error(result, "TRIG_ANGLE_UNIT_ERROR", "angle conversion", [angle, angle_unit])
    Let normalized_angle be normalize_angle(angle_radians)
    Set result.quadrant to determine_quadrant(normalized_angle)
    
    Let sine_value be compute_sine_taylor_series(normalized_angle, precision plus 5)
    Let cosine_value be compute_cosine_taylor_series(normalized_angle, precision plus 5)
    
    If BigDecimal.compare_high_precision(cosine_value, "0") is equal to 0:
        Throw Errors.InvalidOperation with "Tangent undefined at odd multiples of π/2"
    
    Let tangent_value be BigDecimal.divide_high_precision(sine_value, cosine_value, precision)
    Set result.function_value to tangent_value
    
    Return result

Process called "cotangent" that takes angle as String, angle_unit as String, precision as Integer returns TrigonometricResult:
    Note: Compute cotangent of angle with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "cotangent"
    Set result.input_angle to angle
    Set result.angle_unit to angle_unit
    Set result.precision_used to precision
    Set result.computation_method to "cosine_sine_division"
    Set result.principal_value to true
    
    Let angle_radians be ""
    If angle_unit is equal to "radians":
        Set angle_radians to angle
    Otherwise if angle_unit is equal to "degrees":
        Set angle_radians to Conversion.degrees_to_radians(angle, precision)
    Otherwise if angle_unit is equal to "gradians":
        Set angle_radians to Conversion.gradians_to_radians(angle, precision)
    Otherwise:
        Return handle_trigonometric_error(result, "TRIG_ANGLE_UNIT_ERROR", "angle conversion", [angle, angle_unit])
    Let normalized_angle be normalize_angle(angle_radians)
    Set result.quadrant to determine_quadrant(normalized_angle)
    
    Let sine_value be compute_sine_taylor_series(normalized_angle, precision plus 5)
    Let cosine_value be compute_cosine_taylor_series(normalized_angle, precision plus 5)
    
    If BigDecimal.compare_high_precision(sine_value, "0") is equal to 0:
        Throw Errors.InvalidOperation with "Cotangent undefined at multiples of π"
    
    Let cotangent_value be BigDecimal.divide_high_precision(cosine_value, sine_value, precision)
    Set result.function_value to cotangent_value
    
    Return result

Process called "secant" that takes angle as String, angle_unit as String, precision as Integer returns TrigonometricResult:
    Note: Compute secant of angle with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "secant"
    Set result.input_angle to angle
    Set result.angle_unit to angle_unit
    Set result.precision_used to precision
    Set result.computation_method to "cosine_reciprocal"
    Set result.principal_value to true
    
    Let angle_radians be ""
    If angle_unit is equal to "radians":
        Set angle_radians to angle
    Otherwise if angle_unit is equal to "degrees":
        Set angle_radians to Conversion.degrees_to_radians(angle, precision)
    Otherwise if angle_unit is equal to "gradians":
        Set angle_radians to Conversion.gradians_to_radians(angle, precision)
    Otherwise:
        Return handle_trigonometric_error(result, "TRIG_ANGLE_UNIT_ERROR", "angle conversion", [angle, angle_unit])
    Let normalized_angle be normalize_angle(angle_radians)
    Set result.quadrant to determine_quadrant(normalized_angle)
    
    Let cosine_value be compute_cosine_taylor_series(normalized_angle, precision plus 5)
    
    If BigDecimal.compare_high_precision(cosine_value, "0") is equal to 0:
        Throw Errors.InvalidOperation with "Secant undefined at odd multiples of π/2"
    
    Let secant_value be BigDecimal.divide_high_precision("1", cosine_value, precision)
    Set result.function_value to secant_value
    
    Return result

Process called "cosecant" that takes angle as String, angle_unit as String, precision as Integer returns TrigonometricResult:
    Note: Compute cosecant of angle with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "cosecant"
    Set result.input_angle to angle
    Set result.angle_unit to angle_unit
    Set result.precision_used to precision
    Set result.computation_method to "sine_reciprocal"
    Set result.principal_value to true
    
    Let angle_radians be ""
    If angle_unit is equal to "radians":
        Set angle_radians to angle
    Otherwise if angle_unit is equal to "degrees":
        Set angle_radians to Conversion.degrees_to_radians(angle, precision)
    Otherwise if angle_unit is equal to "gradians":
        Set angle_radians to Conversion.gradians_to_radians(angle, precision)
    Otherwise:
        Return handle_trigonometric_error(result, "TRIG_ANGLE_UNIT_ERROR", "angle conversion", [angle, angle_unit])
    Let normalized_angle be normalize_angle(angle_radians)
    Set result.quadrant to determine_quadrant(normalized_angle)
    
    Let sine_value be compute_sine_taylor_series(normalized_angle, precision plus 5)
    
    If BigDecimal.compare_high_precision(sine_value, "0") is equal to 0:
        Throw Errors.InvalidOperation with "Cosecant undefined at multiples of π"
    
    Let cosecant_value be BigDecimal.divide_high_precision("1", sine_value, precision)
    Set result.function_value to cosecant_value
    
    Return result

Note: =====================================================================
Note: TRIGONOMETRIC HELPER FUNCTIONS
Note: =====================================================================

Process called "determine_quadrant" that takes angle_radians as String returns Integer:
    Note: Determine which quadrant an angle in radians falls into
    Let pi_value be Constants.get_pi_constant_high_precision(50)
    Let two_pi be BigDecimal.multiply_high_precision("2", pi_value, 50)
    Let pi_half be BigDecimal.divide_high_precision(pi_value, "2", 50)
    Let three_pi_half be BigDecimal.multiply_high_precision("3", pi_half, 50)
    
    Note: Normalize angle to [0, 2π)
    Let normalized be angle_radians
    While BigDecimal.compare(normalized, "0") is less than 0:
        Set normalized to BigDecimal.add_high_precision(normalized, two_pi, 50)
    
    While BigDecimal.compare(normalized, two_pi) is greater than or equal to 0:
        Set normalized to BigDecimal.subtract_high_precision(normalized, two_pi, 50)
    
    Note: Determine quadrant
    If BigDecimal.compare(normalized, pi_half) is less than 0:
        Return 1
    Otherwise if BigDecimal.compare(normalized, pi_value) is less than 0:
        Return 2
    Otherwise if BigDecimal.compare(normalized, three_pi_half) is less than 0:
        Return 3
    Otherwise:
        Return 4

Note: =====================================================================
Note: INVERSE TRIGONOMETRIC FUNCTIONS
Note: =====================================================================

Process called "arcsine" that takes value as String, precision as Integer, output_unit as String returns TrigonometricResult:
    Note: Compute arcsine (inverse sine) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "arcsine"
    Set result.input_angle to value
    Set result.angle_unit to "radians"
    Set result.precision_used to precision
    Set result.computation_method to "taylor_series"
    Set result.principal_value to true
    
    If BigDecimal.compare_high_precision(value, "-1") is less than 0 or BigDecimal.compare_high_precision(value, "1") is greater than 0:
        Return handle_trigonometric_error(result, "TRIG_DOMAIN_ERROR", "arcsine domain validation", [value, "[-1, 1]"])
    
    Let arcsine_radians be compute_arcsine_series(value, precision)
    
    If output_unit is equal to "degrees":
        Let arcsine_degrees be Conversion.radians_to_degrees(arcsine_radians, precision)
        Set result.function_value to arcsine_degrees
        Set result.angle_unit to "degrees"
    Otherwise:
        Set result.function_value to arcsine_radians
    
    Return result

Process called "arccosine" that takes value as String, precision as Integer, output_unit as String returns TrigonometricResult:
    Note: Compute arccosine (inverse cosine) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "arccosine"
    Set result.input_angle to value
    Set result.angle_unit to "radians"
    Set result.precision_used to precision
    Set result.computation_method to "arcsine_identity"
    Set result.principal_value to true
    
    If BigDecimal.compare_high_precision(value, "-1") is less than 0 or BigDecimal.compare_high_precision(value, "1") is greater than 0:
        Throw Errors.InvalidOperation with "Arccosine domain error: input must be in [-1, 1]"
    
    Let pi_half be Constants.get_pi_constant_high_precision(precision plus 5)
    Set pi_half to BigDecimal.divide_high_precision(pi_half, "2", precision plus 5)
    
    Let arcsine_value be compute_arcsine_series(value, precision plus 5)
    Let arccosine_radians be BigDecimal.subtract_high_precision(pi_half, arcsine_value, precision)
    
    If output_unit is equal to "degrees":
        Let arccosine_degrees be Conversion.radians_to_degrees(arccosine_radians, precision)
        Set result.function_value to arccosine_degrees
        Set result.angle_unit to "degrees"
    Otherwise:
        Set result.function_value to arccosine_radians
    
    Return result

Process called "arctangent" that takes value as String, precision as Integer, output_unit as String returns TrigonometricResult:
    Note: Compute arctangent (inverse tangent) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "arctangent"
    Set result.input_angle to value
    Set result.angle_unit to "radians"
    Set result.precision_used to precision
    Set result.computation_method to "taylor_series"
    Set result.principal_value to true
    
    Let arctangent_radians be compute_arctangent_series(value, precision)
    
    If output_unit is equal to "degrees":
        Let arctangent_degrees be Conversion.radians_to_degrees(arctangent_radians, precision)
        Set result.function_value to arctangent_degrees
        Set result.angle_unit to "degrees"
    Otherwise:
        Set result.function_value to arctangent_radians
    
    Return result

Process called "arctangent2" that takes y as String, x as String, precision as Integer, output_unit as String returns TrigonometricResult:
    Note: Compute two-argument arctangent (atan2) for proper quadrant
    Let result be TrigonometricResult
    Set result.function_name to "arctangent2"
    Set result.input_angle to y joined with "," joined with x
    Set result.angle_unit to "radians"
    Set result.precision_used to precision
    Set result.computation_method to "quadrant_aware_atan"
    Set result.principal_value to true
    
    If BigDecimal.compare_high_precision(x, "0") is equal to 0 and BigDecimal.compare_high_precision(y, "0") is equal to 0:
        Throw Errors.InvalidOperation with "atan2(0,0) is undefined"
    
    Let atan2_radians be compute_atan2(y, x, precision)
    
    If output_unit is equal to "degrees":
        Let atan2_degrees be Conversion.radians_to_degrees(atan2_radians, precision)
        Set result.function_value to atan2_degrees
        Set result.angle_unit to "degrees"
    Otherwise:
        Set result.function_value to atan2_radians
    
    Return result

Process called "arccotangent" that takes value as String, precision as Integer, output_unit as String returns TrigonometricResult:
    Note: Compute arccotangent (inverse cotangent) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "arccotangent"
    Set result.input_angle to value
    Set result.angle_unit to "radians"
    Set result.precision_used to precision
    Set result.computation_method to "arctangent_identity"
    Set result.principal_value to true
    
    Let pi_half be Constants.get_pi_constant_high_precision(precision plus 5)
    Set pi_half to BigDecimal.divide_high_precision(pi_half, "2", precision plus 5)
    
    Let arctangent_value be compute_arctangent_series(value, precision plus 5)
    Let arccotangent_radians be BigDecimal.subtract_high_precision(pi_half, arctangent_value, precision)
    
    If output_unit is equal to "degrees":
        Let arccotangent_degrees be Conversion.radians_to_degrees(arccotangent_radians, precision)
        Set result.function_value to arccotangent_degrees
        Set result.angle_unit to "degrees"
    Otherwise:
        Set result.function_value to arccotangent_radians
    
    Return result

Note: =====================================================================
Note: HYPERBOLIC FUNCTIONS
Note: =====================================================================

Process called "hyperbolic_sine" that takes value as String, precision as Integer returns TrigonometricResult:
    Note: Compute hyperbolic sine (sinh) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "hyperbolic_sine"
    Set result.input_angle to value
    Set result.angle_unit to "none"
    Set result.precision_used to precision
    Set result.computation_method to "exponential_definition"
    Set result.principal_value to true
    Set result.quadrant to 0
    
    Let exp_pos be Operations.exponential(value, precision plus 5)
    Let exp_neg be Operations.exponential(BigDecimal.subtract_high_precision("0", value, precision plus 5), precision plus 5)
    
    Let numerator be BigDecimal.subtract_high_precision(exp_pos.result_value, exp_neg.result_value, precision plus 3)
    Let sinh_value be BigDecimal.divide_high_precision(numerator, "2", precision)
    
    Set result.function_value to sinh_value
    Return result

Process called "hyperbolic_cosine" that takes value as String, precision as Integer returns TrigonometricResult:
    Note: Compute hyperbolic cosine (cosh) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "hyperbolic_cosine"
    Set result.input_angle to value
    Set result.angle_unit to "none"
    Set result.precision_used to precision
    Set result.computation_method to "exponential_definition"
    Set result.principal_value to true
    Set result.quadrant to 0
    
    Let exp_pos be Operations.exponential(value, precision plus 5)
    Let exp_neg be Operations.exponential(BigDecimal.subtract_high_precision("0", value, precision plus 5), precision plus 5)
    
    Let numerator be BigDecimal.add_high_precision(exp_pos.result_value, exp_neg.result_value, precision plus 3)
    Let cosh_value be BigDecimal.divide_high_precision(numerator, "2", precision)
    
    Set result.function_value to cosh_value
    Return result

Process called "hyperbolic_tangent" that takes value as String, precision as Integer returns TrigonometricResult:
    Note: Compute hyperbolic tangent (tanh) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "hyperbolic_tangent"
    Set result.input_angle to value
    Set result.angle_unit to "none"
    Set result.precision_used to precision
    Set result.computation_method to "sinh_cosh_division"
    Set result.principal_value to true
    Set result.quadrant to 0
    
    Let sinh_result be hyperbolic_sine(value, precision plus 5)
    Let cosh_result be hyperbolic_cosine(value, precision plus 5)
    
    Let tanh_value be BigDecimal.divide_high_precision(sinh_result.function_value, cosh_result.function_value, precision)
    
    Set result.function_value to tanh_value
    Return result

Process called "hyperbolic_cotangent" that takes value as String, precision as Integer returns TrigonometricResult:
    Note: Compute hyperbolic cotangent (coth) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "hyperbolic_cotangent"
    Set result.input_angle to value
    Set result.angle_unit to "none"
    Set result.precision_used to precision
    Set result.computation_method to "cosh_sinh_division"
    Set result.principal_value to true
    Set result.quadrant to 0
    
    If BigDecimal.compare_high_precision(value, "0") is equal to 0:
        Throw Errors.InvalidOperation with "Hyperbolic cotangent undefined at zero"
    
    Let sinh_result be hyperbolic_sine(value, precision plus 5)
    Let cosh_result be hyperbolic_cosine(value, precision plus 5)
    
    Let coth_value be BigDecimal.divide_high_precision(cosh_result.function_value, sinh_result.function_value, precision)
    
    Set result.function_value to coth_value
    Return result

Process called "hyperbolic_secant" that takes value as String, precision as Integer returns TrigonometricResult:
    Note: Compute hyperbolic secant (sech) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "hyperbolic_secant"
    Set result.input_angle to value
    Set result.angle_unit to "none"
    Set result.precision_used to precision
    Set result.computation_method to "cosh_reciprocal"
    Set result.principal_value to true
    Set result.quadrant to 0
    
    Let cosh_result be hyperbolic_cosine(value, precision plus 5)
    Let sech_value be BigDecimal.divide_high_precision("1", cosh_result.function_value, precision)
    
    Set result.function_value to sech_value
    Return result

Process called "hyperbolic_cosecant" that takes value as String, precision as Integer returns TrigonometricResult:
    Note: Compute hyperbolic cosecant (csch) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "hyperbolic_cosecant"
    Set result.input_angle to value
    Set result.angle_unit to "none"
    Set result.precision_used to precision
    Set result.computation_method to "sinh_reciprocal"
    Set result.principal_value to true
    Set result.quadrant to 0
    
    If BigDecimal.compare_high_precision(value, "0") is equal to 0:
        Throw Errors.InvalidOperation with "Hyperbolic cosecant undefined at zero"
    
    Let sinh_result be hyperbolic_sine(value, precision plus 5)
    Let csch_value be BigDecimal.divide_high_precision("1", sinh_result.function_value, precision)
    
    Set result.function_value to csch_value
    Return result

Note: =====================================================================
Note: INVERSE HYPERBOLIC FUNCTIONS
Note: =====================================================================

Process called "inverse_hyperbolic_sine" that takes value as String, precision as Integer returns TrigonometricResult:
    Note: Compute inverse hyperbolic sine (asinh) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "inverse_hyperbolic_sine"
    Set result.input_angle to value
    Set result.angle_unit to "none"
    Set result.precision_used to precision
    Set result.computation_method to "logarithmic_formula"
    Set result.principal_value to true
    Set result.quadrant to 0
    
    Let value_squared be BigDecimal.multiply_high_precision(value, value, precision plus 5)
    Let value_squared_plus_one be BigDecimal.add_high_precision(value_squared, "1", precision plus 5)
    Let sqrt_result be Operations.square_root(value_squared_plus_one, precision plus 5)
    Let sum be BigDecimal.add_high_precision(value, sqrt_result.result_value, precision plus 5)
    Let ln_result be Operations.natural_logarithm(sum, precision)
    
    Set result.function_value to ln_result.result_value
    Return result

Process called "inverse_hyperbolic_cosine" that takes value as String, precision as Integer returns TrigonometricResult:
    Note: Compute inverse hyperbolic cosine (acosh) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "inverse_hyperbolic_cosine"
    Set result.input_angle to value
    Set result.angle_unit to "none"
    Set result.precision_used to precision
    Set result.computation_method to "logarithmic_formula"
    Set result.principal_value to true
    Set result.quadrant to 0
    
    If BigDecimal.compare_high_precision(value, "1") is less than 0:
        Throw Errors.InvalidOperation with "Inverse hyperbolic cosine domain error: input must be is greater than or equal to 1"
    
    Let value_squared be BigDecimal.multiply_high_precision(value, value, precision plus 5)
    Let value_squared_minus_one be BigDecimal.subtract_high_precision(value_squared, "1", precision plus 5)
    Let sqrt_result be Operations.square_root(value_squared_minus_one, precision plus 5)
    Let sum be BigDecimal.add_high_precision(value, sqrt_result.result_value, precision plus 5)
    Let ln_result be Operations.natural_logarithm(sum, precision)
    
    Set result.function_value to ln_result.result_value
    Return result

Process called "inverse_hyperbolic_tangent" that takes value as String, precision as Integer returns TrigonometricResult:
    Note: Compute inverse hyperbolic tangent (atanh) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "inverse_hyperbolic_tangent"
    Set result.input_angle to value
    Set result.angle_unit to "none"
    Set result.precision_used to precision
    Set result.computation_method to "logarithmic_formula"
    Set result.principal_value to true
    Set result.quadrant to 0
    
    If BigDecimal.compare_high_precision(Operations.absolute_value(value).result_value, "1") is greater than or equal to 0:
        Throw Errors.InvalidOperation with "Inverse hyperbolic tangent domain error: |input| must be is less than 1"
    
    Let one_plus_value be BigDecimal.add_high_precision("1", value, precision plus 5)
    Let one_minus_value be BigDecimal.subtract_high_precision("1", value, precision plus 5)
    Let quotient be BigDecimal.divide_high_precision(one_plus_value, one_minus_value, precision plus 5)
    Let ln_result be Operations.natural_logarithm(quotient, precision plus 5)
    Let atanh_value be BigDecimal.divide_high_precision(ln_result.result_value, "2", precision)
    
    Set result.function_value to atanh_value
    Return result

Process called "inverse_hyperbolic_cotangent" that takes value as String, precision as Integer returns TrigonometricResult:
    Note: Compute inverse hyperbolic cotangent (acoth) with specified precision
    Let result be TrigonometricResult
    Set result.function_name to "inverse_hyperbolic_cotangent"
    Set result.input_angle to value
    Set result.angle_unit to "none"
    Set result.precision_used to precision
    Set result.computation_method to "logarithmic_formula"
    Set result.principal_value to true
    Set result.quadrant to 0
    
    If BigDecimal.compare_high_precision(Operations.absolute_value(value).result_value, "1") is less than or equal to 0:
        Throw Errors.InvalidOperation with "Inverse hyperbolic cotangent domain error: |input| must be is greater than 1"
    
    Let value_plus_one be BigDecimal.add_high_precision(value, "1", precision plus 5)
    Let value_minus_one be BigDecimal.subtract_high_precision(value, "1", precision plus 5)
    Let quotient be BigDecimal.divide_high_precision(value_plus_one, value_minus_one, precision plus 5)
    Let ln_result be Operations.natural_logarithm(quotient, precision plus 5)
    Let acoth_value be BigDecimal.divide_high_precision(ln_result.result_value, "2", precision)
    
    Set result.function_value to acoth_value
    Return result

Note: =====================================================================
Note: ANGLE UNIT CONVERSION OPERATIONS
Note: =====================================================================


Process called "convert_angle_units" that takes angle as String, from_unit as String, to_unit as String, precision as Integer returns String:
    Note: Convert angle between any supported units
    If from_unit is equal to to_unit:
        Return angle
    
    Let angle_in_radians be angle
    
    If from_unit is equal to "degrees":
        Set angle_in_radians to Conversion.degrees_to_radians(angle, precision plus 5)
    Otherwise if from_unit is equal to "gradians":
        Set angle_in_radians to Conversion.gradians_to_radians(angle, precision plus 5)
    Otherwise if from_unit is equal to "turns":
        Let two_pi be Constants.get_pi_constant_high_precision(precision plus 5)
        Set two_pi to BigDecimal.multiply_high_precision(two_pi, "2", precision plus 5)
        Set angle_in_radians to BigDecimal.multiply_high_precision(angle, two_pi, precision plus 5)
    Otherwise if from_unit not is equal to "radians":
        Throw Errors.InvalidOperation with "Unsupported source angle unit: " joined with from_unit
    
    If to_unit is equal to "radians":
        Return BigDecimal.round_to_precision(angle_in_radians, precision)
    Otherwise if to_unit is equal to "degrees":
        Return Conversion.radians_to_degrees(angle_in_radians, precision)
    Otherwise if to_unit is equal to "gradians":
        Let pi_value be Constants.get_pi_constant_high_precision(precision plus 5)
        Let conversion_factor be BigDecimal.divide_high_precision("200", pi_value, precision plus 5)
        Return BigDecimal.multiply_high_precision(angle_in_radians, conversion_factor, precision)
    Otherwise if to_unit is equal to "turns":
        Let two_pi be Constants.get_pi_constant_high_precision(precision plus 5)
        Set two_pi to BigDecimal.multiply_high_precision(two_pi, "2", precision plus 5)
        Return BigDecimal.divide_high_precision(angle_in_radians, two_pi, precision)
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported target angle unit: " joined with to_unit

Process called "normalize_angle" that takes angle as String, unit as String, range_type as String returns String:
    Note: Normalize angle to standard range (0-2π, -π to π, etc.)
    Let angle_radians be angle
    
    If unit not is equal to "radians":
        Set angle_radians to convert_angle_units(angle, unit, "radians", 50)
    
    Let two_pi be Constants.get_pi_constant_high_precision(50)
    Set two_pi to BigDecimal.multiply_high_precision(two_pi, "2", 50)
    
    If range_type is equal to "0_to_2pi":
        While BigDecimal.compare_high_precision(angle_radians, "0") is less than 0:
            Set angle_radians to BigDecimal.add_high_precision(angle_radians, two_pi, 50)
        While BigDecimal.compare_high_precision(angle_radians, two_pi) is greater than or equal to 0:
            Set angle_radians to BigDecimal.subtract_high_precision(angle_radians, two_pi, 50)
    
    Otherwise if range_type is equal to "neg_pi_to_pi":
        Let pi_value be Constants.get_pi_constant_high_precision(50)
        While BigDecimal.compare_high_precision(angle_radians, pi_value) is greater than 0:
            Set angle_radians to BigDecimal.subtract_high_precision(angle_radians, two_pi, 50)
        While BigDecimal.compare_high_precision(angle_radians, BigDecimal.subtract_high_precision("0", pi_value, 50)) is less than or equal to 0:
            Set angle_radians to BigDecimal.add_high_precision(angle_radians, two_pi, 50)
    
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported angle range type: " joined with range_type
    
    If unit not is equal to "radians":
        Return convert_angle_units(angle_radians, "radians", unit, 50)
    Otherwise:
        Return angle_radians

Note: =====================================================================
Note: SPECIAL ANGLE OPERATIONS
Note: =====================================================================

Process called "compute_special_angle" that takes angle_fraction as String, function_name as String returns String:
    Note: Compute exact trigonometric values for special angles (π/6, π/4, π/3, etc.)
    If angle_fraction is equal to "0" and function_name is equal to "sine":
        Return "0"
    Otherwise if angle_fraction is equal to "0" and function_name is equal to "cosine":
        Return "1"
    Otherwise if angle_fraction is equal to "0" and function_name is equal to "tangent":
        Return "0"
    
    Otherwise if angle_fraction is equal to "pi/6":
        If function_name is equal to "sine":
            Return "0.5"
        Otherwise if function_name is equal to "cosine":
            Return Operations.square_root("3", 20).result_value joined with "/2"
        Otherwise if function_name is equal to "tangent":
            Return Operations.square_root("3", 20).result_value joined with "/3"
    
    Otherwise if angle_fraction is equal to "pi/4":
        If function_name is equal to "sine" or function_name is equal to "cosine":
            Return Operations.square_root("2", 20).result_value joined with "/2"
        Otherwise if function_name is equal to "tangent":
            Return "1"
    
    Otherwise if angle_fraction is equal to "pi/3":
        If function_name is equal to "sine":
            Return Operations.square_root("3", 20).result_value joined with "/2"
        Otherwise if function_name is equal to "cosine":
            Return "0.5"
        Otherwise if function_name is equal to "tangent":
            Return Operations.square_root("3", 20).result_value
    
    Otherwise if angle_fraction is equal to "pi/2":
        If function_name is equal to "sine":
            Return "1"
        Otherwise if function_name is equal to "cosine":
            Return "0"
        Otherwise if function_name is equal to "tangent":
            Throw Errors.InvalidOperation with "Tangent undefined at π/2"
    
    Otherwise:
        Throw Errors.InvalidOperation with "Unknown special angle: " joined with angle_fraction

Process called "identify_common_angle" that takes angle as String returns String:
    Note: Helper for angle identification minus determines if angle corresponds to a common special angle
    Let pi_value be Constants.get_pi_constant_high_precision(50)
    Let tolerance be "0.0000000001"
    
    Note: Check for multiples and fractions of π
    If Operations.absolute_value(angle).result_value is less than or equal to tolerance:
        Return "0"
    
    Let pi_ratios be [
        ["pi/6", BigDecimal.divide_high_precision(pi_value, "6", 50)],
        ["pi/4", BigDecimal.divide_high_precision(pi_value, "4", 50)],
        ["pi/3", BigDecimal.divide_high_precision(pi_value, "3", 50)],
        ["pi/2", BigDecimal.divide_high_precision(pi_value, "2", 50)],
        ["2pi/3", BigDecimal.multiply_high_precision(BigDecimal.divide_high_precision(pi_value, "3", 50), "2", 50)],
        ["3pi/4", BigDecimal.multiply_high_precision(BigDecimal.divide_high_precision(pi_value, "4", 50), "3", 50)],
        ["5pi/6", BigDecimal.multiply_high_precision(BigDecimal.divide_high_precision(pi_value, "6", 50), "5", 50)],
        ["pi", pi_value],
        ["2pi", BigDecimal.multiply_high_precision(pi_value, "2", 50)]
    ]
    
    For each ratio_pair in pi_ratios:
        Let ratio_name be ratio_pair[0]
        Let ratio_value be ratio_pair[1]
        Let difference be Operations.absolute_value(BigDecimal.subtract_high_precision(angle, ratio_value, 50)).result_value
        
        If Parse difference as Float is less than or equal to Parse tolerance as Float:
            Return ratio_name
    
    Return "unknown"


Process called "get_exact_trigonometric_value" that takes angle as String, function as String returns Dictionary[String, String]:
    Note: Get exact trigonometric value (as fraction or surd) for known angles
    Let result be Dictionary[String, String]
    Set result["exact_value"] to ""
    Set result["symbolic_form"] to ""
    Set result["decimal_approximation"] to ""
    Set result["is_exact"] to "false"
    
    Let angle_id be identify_common_angle(angle)
    
    If angle_id not is equal to "unknown":
        Let exact_value be compute_special_angle(angle_id, function)
        Set result["exact_value"] to exact_value
        Set result["is_exact"] to "true"
        
        If angle_id is equal to "pi/6" and function is equal to "sine":
            Set result["symbolic_form"] to "1/2"
        Otherwise if angle_id is equal to "pi/6" and function is equal to "cosine":
            Set result["symbolic_form"] to "√3/2"
        Otherwise if angle_id is equal to "pi/4" and (function is equal to "sine" or function is equal to "cosine"):
            Set result["symbolic_form"] to "√2/2"
        Otherwise if angle_id is equal to "pi/3" and function is equal to "sine":
            Set result["symbolic_form"] to "√3/2"
        Otherwise if angle_id is equal to "pi/3" and function is equal to "cosine":
            Set result["symbolic_form"] to "1/2"
        Otherwise:
            Set result["symbolic_form"] to exact_value
        
        Set result["decimal_approximation"] to Conversion.convert_exact_to_decimal(exact_value, 15)
    
    Return result

Process called "identify_special_angle" that takes angle as String, unit as String, tolerance as Float returns Dictionary[String, String]:
    Note: Identify if angle is close to a special angle with known exact value
    Let result be Dictionary[String, String]
    Set result["is_special"] to "false"
    Set result["special_angle"] to ""
    Set result["exact_fraction"] to ""
    Set result["confidence"] to "0"
    
    Let angle_radians be angle
    If unit not is equal to "radians":
        Set angle_radians to convert_angle_units(angle, unit, "radians", 50)
    
    Let pi_value be Constants.get_pi_constant_high_precision(50)
    Let special_angles be [
        ["0", "0"],
        ["pi/6", BigDecimal.divide_high_precision(pi_value, "6", 50)],
        ["pi/4", BigDecimal.divide_high_precision(pi_value, "4", 50)],
        ["pi/3", BigDecimal.divide_high_precision(pi_value, "3", 50)],
        ["pi/2", BigDecimal.divide_high_precision(pi_value, "2", 50)],
        ["2pi/3", BigDecimal.multiply_high_precision(BigDecimal.divide_high_precision(pi_value, "3", 50), "2", 50)],
        ["3pi/4", BigDecimal.multiply_high_precision(BigDecimal.divide_high_precision(pi_value, "4", 50), "3", 50)],
        ["5pi/6", BigDecimal.multiply_high_precision(BigDecimal.divide_high_precision(pi_value, "6", 50), "5", 50)],
        ["pi", pi_value],
        ["2pi", BigDecimal.multiply_high_precision(pi_value, "2", 50)]
    ]
    
    For each special_angle_pair in special_angles:
        Let special_name be special_angle_pair[0]
        Let special_value be special_angle_pair[1]
        Let difference be Operations.absolute_value(BigDecimal.subtract_high_precision(angle_radians, special_value, 50)).result_value
        
        If Parse difference as Float is less than or equal to tolerance:
            Set result["is_special"] to "true"
            Set result["special_angle"] to special_name
            Set result["exact_fraction"] to special_name
            Set result["confidence"] to String(1.0 minus (Parse difference as Float / tolerance))
            Break
    
    Return result

Note: =====================================================================
Note: TRIGONOMETRIC IDENTITY OPERATIONS
Note: =====================================================================

Process called "apply_pythagorean_identity" that takes known_function as String, known_value as String, target_function as String returns String:
    Note: Apply Pythagorean identity to find related trigonometric value
    Let known_value_squared be BigDecimal.multiply_high_precision(known_value, known_value, 50)
    
    If known_function is equal to "sine" and target_function is equal to "cosine":
        Note: sin²(x) plus cos²(x) is equal to 1, so cos²(x) is equal to 1 minus sin²(x)
        Let one be "1"
        Let cos_squared be BigDecimal.subtract_high_precision(one, known_value_squared, 50)
        Return Operations.square_root(cos_squared, 50).result_value
    
    Otherwise if known_function is equal to "cosine" and target_function is equal to "sine":
        Note: sin²(x) plus cos²(x) is equal to 1, so sin²(x) is equal to 1 minus cos²(x)
        Let one be "1"
        Let sin_squared be BigDecimal.subtract_high_precision(one, known_value_squared, 50)
        Return Operations.square_root(sin_squared, 50).result_value
    
    Otherwise if known_function is equal to "tangent" and target_function is equal to "secant":
        Note: 1 plus tan²(x) is equal to sec²(x)
        Let one be "1"
        Let sec_squared be BigDecimal.add_high_precision(one, known_value_squared, 50)
        Return Operations.square_root(sec_squared, 50).result_value
    
    Otherwise if known_function is equal to "secant" and target_function is equal to "tangent":
        Note: sec²(x) minus 1 is equal to tan²(x)
        Let one be "1"
        Let tan_squared be BigDecimal.subtract_high_precision(known_value_squared, one, 50)
        Return Operations.square_root(tan_squared, 50).result_value
    
    Otherwise if known_function is equal to "cotangent" and target_function is equal to "cosecant":
        Note: 1 plus cot²(x) is equal to csc²(x)
        Let one be "1"
        Let csc_squared be BigDecimal.add_high_precision(one, known_value_squared, 50)
        Return Operations.square_root(csc_squared, 50).result_value
    
    Otherwise if known_function is equal to "cosecant" and target_function is equal to "cotangent":
        Note: csc²(x) minus 1 is equal to cot²(x)
        Let one be "1"
        Let cot_squared be BigDecimal.subtract_high_precision(known_value_squared, one, 50)
        Return Operations.square_root(cot_squared, 50).result_value
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unsupported Pythagorean identity combination: " joined with known_function joined with " to " joined with target_function

Process called "apply_angle_sum_formula" that takes angle1 as String, angle2 as String, function as String, operation as String returns String:
    Note: Apply angle sum/difference formulas (sin(A±B), cos(A±B), tan(A±B))
    Let sin_a be sine(angle1, 50)
    Let cos_a be cosine(angle1, 50)
    Let sin_b be sine(angle2, 50)
    Let cos_b be cosine(angle2, 50)
    
    If function is equal to "sine":
        If operation is equal to "add":
            Note: sin(A plus B) is equal to sin(A)cos(B) plus cos(A)sin(B)
            Let term1 be BigDecimal.multiply_high_precision(sin_a, cos_b, 50)
            Let term2 be BigDecimal.multiply_high_precision(cos_a, sin_b, 50)
            Return BigDecimal.add_high_precision(term1, term2, 50)
        Otherwise if operation is equal to "subtract":
            Note: sin(A minus B) is equal to sin(A)cos(B) minus cos(A)sin(B)
            Let term1 be BigDecimal.multiply_high_precision(sin_a, cos_b, 50)
            Let term2 be BigDecimal.multiply_high_precision(cos_a, sin_b, 50)
            Return BigDecimal.subtract_high_precision(term1, term2, 50)
    
    Otherwise if function is equal to "cosine":
        If operation is equal to "add":
            Note: cos(A plus B) is equal to cos(A)cos(B) minus sin(A)sin(B)
            Let term1 be BigDecimal.multiply_high_precision(cos_a, cos_b, 50)
            Let term2 be BigDecimal.multiply_high_precision(sin_a, sin_b, 50)
            Return BigDecimal.subtract_high_precision(term1, term2, 50)
        Otherwise if operation is equal to "subtract":
            Note: cos(A minus B) is equal to cos(A)cos(B) plus sin(A)sin(B)
            Let term1 be BigDecimal.multiply_high_precision(cos_a, cos_b, 50)
            Let term2 be BigDecimal.multiply_high_precision(sin_a, sin_b, 50)
            Return BigDecimal.add_high_precision(term1, term2, 50)
    
    Otherwise if function is equal to "tangent":
        Let tan_a be tangent(angle1, 50)
        Let tan_b be tangent(angle2, 50)
        Let one be "1"
        
        If operation is equal to "add":
            Note: tan(A plus B) is equal to (tan(A) plus tan(B)) / (1 minus tan(A)tan(B))
            Let numerator be BigDecimal.add_high_precision(tan_a, tan_b, 50)
            Let tan_product be BigDecimal.multiply_high_precision(tan_a, tan_b, 50)
            Let denominator be BigDecimal.subtract_high_precision(one, tan_product, 50)
            Return BigDecimal.divide_high_precision(numerator, denominator, 50)
        Otherwise if operation is equal to "subtract":
            Note: tan(A minus B) is equal to (tan(A) minus tan(B)) / (1 plus tan(A)tan(B))
            Let numerator be BigDecimal.subtract_high_precision(tan_a, tan_b, 50)
            Let tan_product be BigDecimal.multiply_high_precision(tan_a, tan_b, 50)
            Let denominator be BigDecimal.add_high_precision(one, tan_product, 50)
            Return BigDecimal.divide_high_precision(numerator, denominator, 50)
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unsupported function for angle sum formula: " joined with function

Process called "apply_double_angle_formula" that takes angle as String, function as String returns String:
    Note: Apply double angle formulas (sin(2θ), cos(2θ), tan(2θ))
    If function is equal to "sine":
        Note: sin(2θ) is equal to 2sin(θ)cos(θ)
        Let sin_theta be sine(angle, 50)
        Let cos_theta be cosine(angle, 50)
        Let two be "2"
        Let product be BigDecimal.multiply_high_precision(sin_theta, cos_theta, 50)
        Return BigDecimal.multiply_high_precision(two, product, 50)
    
    Otherwise if function is equal to "cosine":
        Note: cos(2θ) is equal to cos²(θ) minus sin²(θ)
        Let sin_theta be sine(angle, 50)
        Let cos_theta be cosine(angle, 50)
        Let sin_squared be BigDecimal.multiply_high_precision(sin_theta, sin_theta, 50)
        Let cos_squared be BigDecimal.multiply_high_precision(cos_theta, cos_theta, 50)
        Return BigDecimal.subtract_high_precision(cos_squared, sin_squared, 50)
    
    Otherwise if function is equal to "tangent":
        Note: tan(2θ) is equal to 2tan(θ) / (1 minus tan²(θ))
        Let tan_theta be tangent(angle, 50)
        Let two be "2"
        Let one be "1"
        Let tan_squared be BigDecimal.multiply_high_precision(tan_theta, tan_theta, 50)
        Let numerator be BigDecimal.multiply_high_precision(two, tan_theta, 50)
        Let denominator be BigDecimal.subtract_high_precision(one, tan_squared, 50)
        Return BigDecimal.divide_high_precision(numerator, denominator, 50)
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unsupported function for double angle formula: " joined with function

Process called "apply_half_angle_formula" that takes angle as String, function as String returns String:
    Note: Apply half angle formulas (sin(θ/2), cos(θ/2), tan(θ/2))
    Let cos_theta be cosine(angle, 50)
    Let one be "1"
    Let two be "2"
    
    If function is equal to "sine":
        Note: sin(θ/2) is equal to ±√((1 minus cos(θ))/2)
        Let numerator be BigDecimal.subtract_high_precision(one, cos_theta, 50)
        Let fraction be BigDecimal.divide_high_precision(numerator, two, 50)
        Return Operations.square_root(fraction, 50).result_value
    
    Otherwise if function is equal to "cosine":
        Note: cos(θ/2) is equal to ±√((1 plus cos(θ))/2)
        Let numerator be BigDecimal.add_high_precision(one, cos_theta, 50)
        Let fraction be BigDecimal.divide_high_precision(numerator, two, 50)
        Return Operations.square_root(fraction, 50).result_value
    
    Otherwise if function is equal to "tangent":
        Note: tan(θ/2) is equal to ±√((1 minus cos(θ))/(1 plus cos(θ)))
        Let numerator be BigDecimal.subtract_high_precision(one, cos_theta, 50)
        Let denominator be BigDecimal.add_high_precision(one, cos_theta, 50)
        Let fraction be BigDecimal.divide_high_precision(numerator, denominator, 50)
        Return Operations.square_root(fraction, 50).result_value
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unsupported function for half angle formula: " joined with function

Process called "evaluate_trigonometric_expression" that takes expression as String, angle as String, precision as Integer returns String:
    Note: Evaluate trigonometric expression by parsing and computing
    Note: Simple parser for basic trigonometric expressions
    If expression is equal to "sin(x)":
        Return sine(angle, precision)
    Otherwise if expression is equal to "cos(x)":
        Return cosine(angle, precision)
    Otherwise if expression is equal to "tan(x)":
        Return tangent(angle, precision)
    Otherwise if String.contains(expression, "sin(x)") and String.contains(expression, "cos(x)"):
        Note: Handle expressions like sin²(x) plus cos²(x)
        If String.contains(expression, "sin²(x) plus cos²(x)") or String.contains(expression, "sin^2(x) plus cos^2(x)"):
            Return "1"
        Otherwise if String.contains(expression, "sin²(x)") or String.contains(expression, "sin^2(x)"):
            Let sin_val be sine(angle, precision)
            Return BigDecimal.multiply_high_precision(sin_val, sin_val, precision)
        Otherwise if String.contains(expression, "cos²(x)") or String.contains(expression, "cos^2(x)"):
            Let cos_val be cosine(angle, precision)
            Return BigDecimal.multiply_high_precision(cos_val, cos_val, precision)
    Otherwise if String.contains(expression, "1 plus tan²(x)") or String.contains(expression, "1 plus tan^2(x)"):
        Note: Handle secant identity: 1 plus tan²(x) is equal to sec²(x)
        Let tan_val be tangent(angle, precision)
        Let tan_squared be BigDecimal.multiply_high_precision(tan_val, tan_val, precision)
        Return BigDecimal.add_high_precision("1", tan_squared, precision)
    Otherwise if String.contains(expression, "sec²(x)") or String.contains(expression, "sec^2(x)"):
        Let sec_val be secant(angle, "radians", precision).function_value
        Return BigDecimal.multiply_high_precision(sec_val, sec_val, precision)
    Otherwise:
        Note: Fallback minus try to evaluate as sine
        Return sine(angle, precision)

Process called "verify_trigonometric_identity" that takes identity as TrigonometricIdentity, test_values as List[String] returns Boolean:
    Note: Verify trigonometric identity for given test values
    For each test_angle in test_values:
        Let left_result be evaluate_trigonometric_expression(identity.left_side, test_angle, 50)
        Let right_result be evaluate_trigonometric_expression(identity.right_side, test_angle, 50)
        Let difference be Operations.absolute_value(BigDecimal.subtract_high_precision(left_result, right_result, 50)).result_value
        Let tolerance be "0.0000000001"
        
        If Parse difference as Float is greater than Parse tolerance as Float:
            Return false
    
    Return true

Note: =====================================================================
Note: COMPLEX TRIGONOMETRIC OPERATIONS
Note: =====================================================================

Process called "complex_sine" that takes complex_angle as Dictionary[String, String], precision as Integer returns Dictionary[String, String]:
    Note: Compute sine of complex number using sin(a plus bi) is equal to sin(a)cosh(b) plus i*cos(a)sinh(b)
    Let real_part be complex_angle["real"]
    Let imaginary_part be complex_angle["imaginary"]
    
    Let sin_real be sine(real_part, precision)
    Let cos_real be cosine(real_part, precision)
    Let cosh_imag be hyperbolic_cosine(imaginary_part, precision)
    Let sinh_imag be hyperbolic_sine(imaginary_part, precision)
    
    Let result_real be BigDecimal.multiply_high_precision(sin_real, cosh_imag, precision)
    Let result_imaginary be BigDecimal.multiply_high_precision(cos_real, sinh_imag, precision)
    
    Let result be Dictionary[String, String]
    Set result["real"] to result_real
    Set result["imaginary"] to result_imaginary
    Return result

Process called "complex_cosine" that takes complex_angle as Dictionary[String, String], precision as Integer returns Dictionary[String, String]:
    Note: Compute cosine of complex number using cos(a plus bi) is equal to cos(a)cosh(b) minus i*sin(a)sinh(b)
    Let real_part be complex_angle["real"]
    Let imaginary_part be complex_angle["imaginary"]
    
    Let sin_real be sine(real_part, precision)
    Let cos_real be cosine(real_part, precision)
    Let cosh_imag be hyperbolic_cosine(imaginary_part, precision)
    Let sinh_imag be hyperbolic_sine(imaginary_part, precision)
    
    Let result_real be BigDecimal.multiply_high_precision(cos_real, cosh_imag, precision)
    Let result_imaginary_term be BigDecimal.multiply_high_precision(sin_real, sinh_imag, precision)
    Let result_imaginary be BigDecimal.negate(result_imaginary_term)
    
    Let result be Dictionary[String, String]
    Set result["real"] to result_real
    Set result["imaginary"] to result_imaginary
    Return result

Process called "complex_exponential" that takes complex_exponent as Dictionary[String, String], precision as Integer returns Dictionary[String, String]:
    Note: Compute e^(complex number) using e^(a plus bi) is equal to e^a multiplied by (cos(b) plus i*sin(b))
    Let real_part be complex_exponent["real"]
    Let imaginary_part be complex_exponent["imaginary"]
    
    Let exp_real be Operations.natural_exponential(real_part, precision).result_value
    Let cos_imag be cosine(imaginary_part, precision)
    Let sin_imag be sine(imaginary_part, precision)
    
    Let result_real be BigDecimal.multiply_high_precision(exp_real, cos_imag, precision)
    Let result_imaginary be BigDecimal.multiply_high_precision(exp_real, sin_imag, precision)
    
    Let result be Dictionary[String, String]
    Set result["real"] to result_real
    Set result["imaginary"] to result_imaginary
    Return result

Process called "euler_formula" that takes angle as String, precision as Integer returns Dictionary[String, String]:
    Note: Apply Euler's formula: e^(iθ) is equal to cos(θ) plus i*sin(θ)
    Let cos_theta be cosine(angle, precision)
    Let sin_theta be sine(angle, precision)
    
    Let result be Dictionary[String, String]
    Set result["real"] to cos_theta
    Set result["imaginary"] to sin_theta
    Return result

Note: =====================================================================
Note: SPHERICAL TRIGONOMETRY OPERATIONS
Note: =====================================================================

Process called "solve_spherical_triangle" that takes triangle as SphericalTriangle, known_elements as List[String] returns SphericalTriangle:
    Note: Solve spherical triangle using spherical law of sines/cosines
    Let result be triangle
    Let known_count be List.length(known_elements)
    
    If known_count is less than 3:
        Throw Errors.InvalidArgument with "At least 3 elements must be known to solve spherical triangle"
    
    Note: Apply spherical law of cosines for sides: cos(c) is equal to cos(a)cos(b) plus sin(a)sin(b)cos(C)
    Note: Apply spherical law of cosines for angles: cos(C) is equal to -cos(A)cos(B) plus sin(A)sin(B)cos(c)
    Note: Apply spherical law of sines: sin(A)/sin(a) is equal to sin(B)/sin(b) is equal to sin(C)/sin(c)
    
    If List.contains(known_elements, "side_a") and List.contains(known_elements, "side_b") and List.contains(known_elements, "angle_C"):
        Note: Solve for side c using spherical law of cosines
        Let cos_a be cosine(result.side_a, 50)
        Let cos_b be cosine(result.side_b, 50)
        Let sin_a be sine(result.side_a, 50)
        Let sin_b be sine(result.side_b, 50)
        Let cos_C be cosine(result.angle_C, 50)
        
        Let term1 be BigDecimal.multiply_high_precision(cos_a, cos_b, 50)
        Let term2 be BigDecimal.multiply_high_precision(BigDecimal.multiply_high_precision(sin_a, sin_b, 50), cos_C, 50)
        Let cos_c be BigDecimal.add_high_precision(term1, term2, 50)
        Set result.side_c to arccosine(cos_c, 50)
    
    Return result

Process called "spherical_law_of_cosines" that takes triangle as SphericalTriangle, solve_for as String returns String:
    Note: Apply spherical law of cosines
    If solve_for is equal to "side_c":
        Note: cos(c) is equal to cos(a)cos(b) plus sin(a)sin(b)cos(C)
        Let cos_a be cosine(triangle.side_a, 50)
        Let cos_b be cosine(triangle.side_b, 50)
        Let sin_a be sine(triangle.side_a, 50)
        Let sin_b be sine(triangle.side_b, 50)
        Let cos_C be cosine(triangle.angle_C, 50)
        
        Let term1 be BigDecimal.multiply_high_precision(cos_a, cos_b, 50)
        Let term2 be BigDecimal.multiply_high_precision(BigDecimal.multiply_high_precision(sin_a, sin_b, 50), cos_C, 50)
        Let cos_c be BigDecimal.add_high_precision(term1, term2, 50)
        Return arccosine(cos_c, 50)
    
    Otherwise if solve_for is equal to "angle_C":
        Note: cos(C) is equal to (cos(c) minus cos(a)cos(b)) / (sin(a)sin(b))
        Let cos_a be cosine(triangle.side_a, 50)
        Let cos_b be cosine(triangle.side_b, 50)
        Let cos_c be cosine(triangle.side_c, 50)
        Let sin_a be sine(triangle.side_a, 50)
        Let sin_b be sine(triangle.side_b, 50)
        
        Let numerator be BigDecimal.subtract_high_precision(cos_c, BigDecimal.multiply_high_precision(cos_a, cos_b, 50), 50)
        Let denominator be BigDecimal.multiply_high_precision(sin_a, sin_b, 50)
        Let cos_C be BigDecimal.divide_high_precision(numerator, denominator, 50)
        Return arccosine(cos_C, 50)
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unsupported solve_for parameter in spherical law of cosines: " joined with solve_for

Process called "spherical_law_of_sines" that takes triangle as SphericalTriangle, solve_for as String returns String:
    Note: Apply spherical law of sines: sin(A)/sin(a) is equal to sin(B)/sin(b) is equal to sin(C)/sin(c)
    If solve_for is equal to "angle_A":
        Note: sin(A) is equal to sin(a) multiplied by sin(B) / sin(b)
        Let sin_a be sine(triangle.side_a, 50)
        Let sin_B be sine(triangle.angle_B, 50)
        Let sin_b be sine(triangle.side_b, 50)
        
        Let numerator be BigDecimal.multiply_high_precision(sin_a, sin_B, 50)
        Let sin_A be BigDecimal.divide_high_precision(numerator, sin_b, 50)
        Return arcsine(sin_A, 50)
    
    Otherwise if solve_for is equal to "side_a":
        Note: sin(a) is equal to sin(A) multiplied by sin(b) / sin(B)
        Let sin_A be sine(triangle.angle_A, 50)
        Let sin_b be sine(triangle.side_b, 50)
        Let sin_B be sine(triangle.angle_B, 50)
        
        Let numerator be BigDecimal.multiply_high_precision(sin_A, sin_b, 50)
        Let sin_a be BigDecimal.divide_high_precision(numerator, sin_B, 50)
        Return arcsine(sin_a, 50)
    
    Otherwise if solve_for is equal to "angle_C":
        Note: sin(C) is equal to sin(c) multiplied by sin(A) / sin(a)
        Let sin_c be sine(triangle.side_c, 50)
        Let sin_A be sine(triangle.angle_A, 50)
        Let sin_a be sine(triangle.side_a, 50)
        
        Let numerator be BigDecimal.multiply_high_precision(sin_c, sin_A, 50)
        Let sin_C be BigDecimal.divide_high_precision(numerator, sin_a, 50)
        Return arcsine(sin_C, 50)
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unsupported solve_for parameter in spherical law of sines: " joined with solve_for

Note: =====================================================================
Note: SERIES AND APPROXIMATION OPERATIONS
Note: =====================================================================

Process called "taylor_series_sine" that takes angle as String, terms as Integer, precision as Integer returns String:
    Note: Compute sine using Taylor series: sin(x) is equal to x minus x³/3! plus x⁵/5! minus x⁷/7! plus ...
    Let result be "0"
    Let x_power be angle
    Let sign be "1"
    
    For i from 0 to terms minus 1:
        Let factorial_value be Operations.factorial(String(2 multiplied by i plus 1), precision).result_value
        Let term be BigDecimal.divide_high_precision(x_power, factorial_value, precision)
        Let signed_term be BigDecimal.multiply_high_precision(term, sign, precision)
        Set result to BigDecimal.add_high_precision(result, signed_term, precision)
        
        Note: Update for next iteration
        Set x_power to BigDecimal.multiply_high_precision(BigDecimal.multiply_high_precision(x_power, angle, precision), angle, precision)
        Set sign to BigDecimal.negate(sign)
    
    Return result

Process called "taylor_series_cosine" that takes angle as String, terms as Integer, precision as Integer returns String:
    Note: Compute cosine using Taylor series: cos(x) is equal to 1 minus x²/2! plus x⁴/4! minus x⁶/6! plus ...
    Let result be "1"
    Let x_power be BigDecimal.multiply_high_precision(angle, angle, precision)
    Let sign be "-1"
    
    For i from 1 to terms minus 1:
        Let factorial_value be Operations.factorial(String(2 multiplied by i), precision).result_value
        Let term be BigDecimal.divide_high_precision(x_power, factorial_value, precision)
        Let signed_term be BigDecimal.multiply_high_precision(term, sign, precision)
        Set result to BigDecimal.add_high_precision(result, signed_term, precision)
        
        Note: Update for next iteration
        Set x_power to BigDecimal.multiply_high_precision(BigDecimal.multiply_high_precision(x_power, angle, precision), angle, precision)
        Set sign to BigDecimal.negate(sign)
    
    Return result

Process called "chebyshev_approximation" that takes function_name as String, interval as Dictionary[String, String], degree as Integer returns Dictionary[String, String]:
    Note: Generate Chebyshev polynomial approximation for trigonometric function
    Let a be interval["start"]
    Let b be interval["end"]
    Let n be degree plus 1
    Let coefficients be List[String]
    
    Note: Generate Chebyshev nodes
    Let nodes be List[String]
    For k from 0 to n minus 1:
        Let pi_value be Constants.get_pi_constant_high_precision(50)
        Let angle be BigDecimal.divide_high_precision(BigDecimal.multiply_high_precision(pi_value, String(2 multiplied by k plus 1), 50), String(2 multiplied by n), 50)
        Let cos_val be cosine(angle, 50)
        Let node be BigDecimal.multiply_high_precision("0.5", BigDecimal.add_high_precision(BigDecimal.subtract_high_precision(b, a, 50), BigDecimal.multiply_high_precision(BigDecimal.subtract_high_precision(b, a, 50), cos_val, 50), 50), 50)
        Set node to BigDecimal.add_high_precision(node, a, 50)
        Call List.append(nodes, node)
    
    Note: Evaluate function at nodes
    Let function_values be List[String]
    For each node in nodes:
        If function_name is equal to "sine":
            Call List.append(function_values, sine(node, 50))
        Otherwise if function_name is equal to "cosine":
            Call List.append(function_values, cosine(node, 50))
        Otherwise if function_name is equal to "tangent":
            Call List.append(function_values, tangent(node, 50))
    
    Note: Compute Chebyshev coefficients using discrete cosine transform
    For j from 0 to degree:
        Let c_j be "0"
        For k from 0 to n minus 1:
            Let pi_value be Constants.get_pi_constant_high_precision(50)
            Let angle be BigDecimal.divide_high_precision(BigDecimal.multiply_high_precision(pi_value, String(j multiplied by k), 50), String(n), 50)
            Let cos_term be cosine(angle, 50)
            Let weighted_value be BigDecimal.multiply_high_precision(function_values[k], cos_term, 50)
            Set c_j to BigDecimal.add_high_precision(c_j, weighted_value, 50)
        
        Let normalization be String(2.0 / Float(n))
        If j is equal to 0:
            Set normalization to String(1.0 / Float(n))
        Set c_j to BigDecimal.multiply_high_precision(c_j, normalization, 50)
        Call List.append(coefficients, c_j)
    
    Let result be Dictionary[String, String]
    Set result["function"] to function_name
    Set result["degree"] to String(degree)
    Set result["interval_start"] to a
    Set result["interval_end"] to b
    Set result["coefficients"] to String.join(coefficients, ",")
    Return result

Process called "cordic_algorithm" that takes angle as String, function as String, iterations as Integer returns String:
    Note: Compute trigonometric function using CORDIC (COordinate Rotation DIgital Computer) algorithm
    Let x be "0.60725293500888"
    Let y be "0"
    Let z be angle
    
    Note: CORDIC arctangent table (precomputed for efficiency)
    Let arctan_table be [
        "0.78539816339744830961566084581988",
        "0.46364760900080611621425623146121",
        "0.24497866312686415417208248121128",
        "0.12435499454676143503135484916387",
        "0.06241880999595734847775546985414",
        "0.03123983343026827663645825806102",
        "0.01562372862047683080280152125657",
        "0.00781234106010111137890013617194",
        "0.00390623013196697182762866531142",
        "0.00195312251647881868512148262508"
    ]
    
    For i from 0 to iterations minus 1:
        If i is less than List.length(arctan_table):
            Let d be "1"
            If BigDecimal.compare(z, "0") is less than 0:
                Set d to "-1"
            
            Let power_of_2 be Operations.power("2", String(-i), 50).result_value
            Let x_new be BigDecimal.subtract_high_precision(x, BigDecimal.multiply_high_precision(BigDecimal.multiply_high_precision(d, y, 50), power_of_2, 50), 50)
            Let y_new be BigDecimal.add_high_precision(y, BigDecimal.multiply_high_precision(BigDecimal.multiply_high_precision(d, x, 50), power_of_2, 50), 50)
            Let z_new be BigDecimal.subtract_high_precision(z, BigDecimal.multiply_high_precision(d, arctan_table[i], 50), 50)
            
            Set x to x_new
            Set y to y_new
            Set z to z_new
    
    If function is equal to "sine":
        Return y
    Otherwise if function is equal to "cosine":
        Return x
    Otherwise if function is equal to "tangent":
        Return BigDecimal.divide_high_precision(y, x, 50)
    Otherwise:
        Throw Errors.InvalidArgument with "Unsupported function for CORDIC algorithm: " joined with function

Note: =====================================================================
Note: PERIODIC PROPERTIES OPERATIONS
Note: =====================================================================

Process called "find_period" that takes function_name as String returns String:
    Note: Find period of trigonometric function
    Let pi_value be Constants.get_pi_constant_high_precision(50)
    Let two_pi be BigDecimal.multiply_high_precision("2", pi_value, 50)
    
    If function_name is equal to "sine" or function_name is equal to "cosine" or function_name is equal to "cosecant" or function_name is equal to "secant":
        Return two_pi
    Otherwise if function_name is equal to "tangent" or function_name is equal to "cotangent":
        Return pi_value
    Otherwise if function_name is equal to "hyperbolic_sine" or function_name is equal to "hyperbolic_cosine" or function_name is equal to "hyperbolic_tangent":
        Throw Errors.InvalidArgument with "Hyperbolic functions are not periodic"
    Otherwise:
        Throw Errors.InvalidArgument with "Unknown function for period calculation: " joined with function_name

Process called "find_amplitude" that takes function_expression as String returns String:
    Note: Find amplitude of trigonometric function from expression like "A*sin(Bx plus C) plus D"
    Note: Parse amplitude coefficient A from the expression
    Let amplitude be "1"
    
    Note: Simple pattern matching for coefficient before trigonometric function
    If String.contains(function_expression, "*sin(") or String.contains(function_expression, "*cos("):
        Let parts be String.split(function_expression, "*")
        If List.length(parts) is greater than or equal to 2:
            Set amplitude to Operations.absolute_value(parts[0]).result_value
    Otherwise if String.starts_with(function_expression, "-sin(") or String.starts_with(function_expression, "-cos("):
        Set amplitude to "1"
    Otherwise if String.starts_with(function_expression, "sin(") or String.starts_with(function_expression, "cos("):
        Set amplitude to "1"
    Otherwise:
        Note: Try to extract numeric coefficient
        Let coefficient_match be ""
        For i from 0 to String.length(function_expression) minus 1:
            Let char be String.charAt(function_expression, i)
            If char is equal to "s" and String.substring(function_expression, i, i plus 4) is equal to "sin(":
                Set coefficient_match to String.substring(function_expression, 0, i)
                Break
            Otherwise if char is equal to "c" and String.substring(function_expression, i, i plus 4) is equal to "cos(":
                Set coefficient_match to String.substring(function_expression, 0, i)
                Break
        
        If coefficient_match not is equal to "":
            Set amplitude to Operations.absolute_value(coefficient_match).result_value
    
    Return amplitude

Process called "find_phase_shift" that takes function_expression as String returns String:
    Note: Find phase shift of trigonometric function from expression like "sin(Bx plus C)"
    Let phase_shift be "0"
    
    Note: Extract the argument inside the trigonometric function
    Let start_paren be -1
    Let end_paren be -1
    
    For i from 0 to String.length(function_expression) minus 1:
        Let char be String.charAt(function_expression, i)
        If char is equal to "(":
            Set start_paren to i
        Otherwise if char is equal to ")" and start_paren is greater than or equal to 0:
            Set end_paren to i
            Break
    
    If start_paren is greater than or equal to 0 and end_paren is greater than start_paren:
        Let argument be String.substring(function_expression, start_paren plus 1, end_paren)
        
        Note: Parse argument for phase shift (C in Bx plus C or Bx minus C)
        If String.contains(argument, "+"):
            Let parts be String.split(argument, "+")
            If List.length(parts) is greater than or equal to 2:
                Set phase_shift to parts[1]
        Otherwise if String.contains(argument, "-"):
            Let parts be String.split(argument, "-")
            If List.length(parts) is greater than or equal to 2:
                Set phase_shift to "-" joined with parts[1]
    
    Return phase_shift

Process called "analyze_harmonic_function" that takes function_expression as String returns Dictionary[String, String]:
    Note: Analyze harmonic function properties (amplitude, period, phase)
    Let result be Dictionary[String, String]
    
    Note: Find amplitude
    Let amplitude be find_amplitude(function_expression)
    Set result["amplitude"] to amplitude
    
    Note: Find phase shift
    Let phase_shift be find_phase_shift(function_expression)
    Set result["phase_shift"] to phase_shift
    
    Note: Determine function type and calculate period
    Let function_type be "sine"
    If String.contains(function_expression, "cos("):
        Set function_type to "cosine"
    Otherwise if String.contains(function_expression, "tan("):
        Set function_type to "tangent"
    
    Let base_period be find_period(function_type)
    
    Note: Find frequency multiplier (B in sin(Bx plus C))
    Let frequency_multiplier be "1"
    Let start_paren be -1
    For i from 0 to String.length(function_expression) minus 1:
        Let char be String.charAt(function_expression, i)
        If char is equal to "(":
            Set start_paren to i
            Break
    
    If start_paren is greater than or equal to 0:
        Let argument be String.substring(function_expression, start_paren plus 1, String.length(function_expression) minus 1)
        Note: Extract coefficient of x
        If String.contains(argument, "x"):
            Let x_index be String.indexOf(argument, "x")
            If x_index is greater than 0:
                Let coefficient_part be String.substring(argument, 0, x_index)
                If coefficient_part not is equal to "":
                    Set frequency_multiplier to coefficient_part
    
    Note: Calculate actual period: period is equal to base_period / |B|
    Let actual_period be BigDecimal.divide_high_precision(base_period, Operations.absolute_value(frequency_multiplier).result_value, 50)
    Set result["period"] to actual_period
    Set result["frequency_multiplier"] to frequency_multiplier
    Set result["function_type"] to function_type
    
    Note: Calculate vertical shift (D in A*sin(Bx plus C) plus D)
    Let vertical_shift be "0"
    If String.contains(function_expression, ") +"):
        Let plus_index be String.indexOf(function_expression, ") +")
        If plus_index is greater than or equal to 0:
            Set vertical_shift to String.substring(function_expression, plus_index plus 3, String.length(function_expression))
    Otherwise if String.contains(function_expression, ") -"):
        Let minus_index be String.indexOf(function_expression, ") -")
        If minus_index is greater than or equal to 0:
            Set vertical_shift to "-" joined with String.substring(function_expression, minus_index plus 3, String.length(function_expression))
    
    Set result["vertical_shift"] to vertical_shift
    
    Return result

Note: =====================================================================
Note: VALIDATION OPERATIONS
Note: =====================================================================

Process called "validate_trigonometric_domain" that takes function_name as String, input_value as String returns Boolean:
    Note: Validate input value is in domain of trigonometric function
    If function_name is equal to "sine" or function_name is equal to "cosine" or function_name is equal to "tangent":
        Note: All real numbers are valid for basic trig functions
        Return true
    
    Otherwise if function_name is equal to "secant":
        Note: Domain excludes odd multiples of π/2 where cos(x) is equal to 0
        Let pi_value be Constants.get_pi_constant_high_precision(50)
        Let pi_half be BigDecimal.divide_high_precision(pi_value, "2", 50)
        Let normalized be BigDecimal.remainder(input_value, pi_value)
        Let tolerance be "0.0000000001"
        
        If Operations.absolute_value(BigDecimal.subtract_high_precision(normalized, pi_half, 50)).result_value is less than or equal to tolerance:
            Return false
        If Operations.absolute_value(BigDecimal.add_high_precision(normalized, pi_half, 50)).result_value is less than or equal to tolerance:
            Return false
        Return true
    
    Otherwise if function_name is equal to "cosecant":
        Note: Domain excludes multiples of π where sin(x) is equal to 0
        Let pi_value be Constants.get_pi_constant_high_precision(50)
        Let normalized be BigDecimal.remainder(input_value, pi_value)
        Let tolerance be "0.0000000001"
        
        If Operations.absolute_value(normalized).result_value is less than or equal to tolerance:
            Return false
        Return true
    
    Otherwise if function_name is equal to "cotangent":
        Note: Domain excludes multiples of π where sin(x) is equal to 0
        Let pi_value be Constants.get_pi_constant_high_precision(50)
        Let normalized be BigDecimal.remainder(input_value, pi_value)
        Let tolerance be "0.0000000001"
        
        If Operations.absolute_value(normalized).result_value is less than or equal to tolerance:
            Return false
        Return true
    
    Otherwise if function_name is equal to "arcsine" or function_name is equal to "arccosine":
        Note: Domain is [-1, 1]
        Let abs_value be Operations.absolute_value(input_value).result_value
        Return BigDecimal.compare(abs_value, "1") is less than or equal to 0
    
    Otherwise if function_name is equal to "arctangent":
        Note: All real numbers are valid
        Return true
    
    Otherwise if function_name is equal to "arcsecant" or function_name is equal to "arccosecant":
        Note: Domain is (-∞, -1] ∪ [1, ∞)
        Let abs_value be Operations.absolute_value(input_value).result_value
        Return BigDecimal.compare(abs_value, "1") is greater than or equal to 0
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unknown function for domain validation: " joined with function_name

Process called "check_trigonometric_range" that takes function_name as String, output_value as String returns Boolean:
    Note: Check if output value is in range of trigonometric function
    If function_name is equal to "sine" or function_name is equal to "cosine":
        Note: Range is [-1, 1]
        Let abs_value be Operations.absolute_value(output_value).result_value
        Return BigDecimal.compare(abs_value, "1") is less than or equal to 0
    
    Otherwise if function_name is equal to "tangent" or function_name is equal to "cotangent":
        Note: Range is all real numbers (-∞, ∞)
        Return true
    
    Otherwise if function_name is equal to "secant" or function_name is equal to "cosecant":
        Note: Range is (-∞, -1] ∪ [1, ∞)
        Let abs_value be Operations.absolute_value(output_value).result_value
        Return BigDecimal.compare(abs_value, "1") is greater than or equal to 0
    
    Otherwise if function_name is equal to "arcsine":
        Note: Range is [-π/2, π/2]
        Let pi_value be Constants.get_pi_constant_high_precision(50)
        Let pi_half be BigDecimal.divide_high_precision(pi_value, "2", 50)
        Let abs_value be Operations.absolute_value(output_value).result_value
        Return BigDecimal.compare(abs_value, pi_half) is less than or equal to 0
    
    Otherwise if function_name is equal to "arccosine":
        Note: Range is [0, π]
        Let pi_value be Constants.get_pi_constant_high_precision(50)
        Return BigDecimal.compare(output_value, "0") is greater than or equal to 0 and BigDecimal.compare(output_value, pi_value) is less than or equal to 0
    
    Otherwise if function_name is equal to "arctangent":
        Note: Range is (-π/2, π/2)
        Let pi_value be Constants.get_pi_constant_high_precision(50)
        Let pi_half be BigDecimal.divide_high_precision(pi_value, "2", 50)
        Let abs_value be Operations.absolute_value(output_value).result_value
        Return BigDecimal.compare(abs_value, pi_half) is less than 0
    
    Otherwise if function_name is equal to "arcsecant" or function_name is equal to "arccosecant":
        Note: Range is [0, π] excluding π/2
        Let pi_value be Constants.get_pi_constant_high_precision(50)
        Let pi_half be BigDecimal.divide_high_precision(pi_value, "2", 50)
        Let tolerance be "0.0000000001"
        
        If Operations.absolute_value(BigDecimal.subtract_high_precision(output_value, pi_half, 50)).result_value is less than or equal to tolerance:
            Return false
        
        Return BigDecimal.compare(output_value, "0") is greater than or equal to 0 and BigDecimal.compare(output_value, pi_value) is less than or equal to 0
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unknown function for range checking: " joined with function_name

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "list_supported_angle_units" that returns List[AngleUnit]:
    Note: List all supported angle units with conversion factors
    Let angle_units be List[AngleUnit]
    
    Let radians_unit be AngleUnit
    Set radians_unit.name to "radians"
    Set radians_unit.symbol to "rad"
    Set radians_unit.to_radians_factor to "1.0"
    Set radians_unit.description to "Base unit for angle measurement in mathematics"
    Call List.append(angle_units, radians_unit)
    
    Let degrees_unit be AngleUnit
    Set degrees_unit.name to "degrees"
    Set degrees_unit.symbol to "deg"
    Set degrees_unit.to_radians_factor to BigDecimal.divide_high_precision(Constants.get_pi_constant_high_precision(50), "180", 50)
    Set degrees_unit.description to "Common angle unit where full circle is equal to 360 degrees"
    Call List.append(angle_units, degrees_unit)
    
    Let gradians_unit be AngleUnit
    Set gradians_unit.name to "gradians"
    Set gradians_unit.symbol to "grad"
    Set gradians_unit.to_radians_factor to BigDecimal.divide_high_precision(Constants.get_pi_constant_high_precision(50), "200", 50)
    Set gradians_unit.description to "Alternative angle unit where full circle is equal to 400 gradians"
    Call List.append(angle_units, gradians_unit)
    
    Let turns_unit be AngleUnit
    Set turns_unit.name to "turns"
    Set turns_unit.symbol to "tr"
    Set turns_unit.to_radians_factor to BigDecimal.multiply_high_precision("2", Constants.get_pi_constant_high_precision(50), 50)
    Set turns_unit.description to "Full rotation unit where 1 turn is equal to 360 degrees"
    Call List.append(angle_units, turns_unit)
    
    Return angle_units

Process called "get_trigonometric_function_info" that takes function_name as String returns Dictionary[String, String]:
    Note: Get information about trigonometric function (domain, range, period)
    Let info be Dictionary[String, String]
    Set info["name"] to function_name
    
    If function_name is equal to "sine":
        Set info["domain"] to "All real numbers (-∞, ∞)"
        Set info["range"] to "[-1, 1]"
        Set info["period"] to find_period("sine")
        Set info["even_odd"] to "Odd function: sin(-x) is equal to -sin(x)"
        Set info["zeros"] to "nπ where n is any integer"
        Set info["maximum"] to "1 at π/2 plus 2nπ"
        Set info["minimum"] to "-1 at 3π/2 plus 2nπ"
    
    Otherwise if function_name is equal to "cosine":
        Set info["domain"] to "All real numbers (-∞, ∞)"
        Set info["range"] to "[-1, 1]"
        Set info["period"] to find_period("cosine")
        Set info["even_odd"] to "Even function: cos(-x) is equal to cos(x)"
        Set info["zeros"] to "π/2 plus nπ where n is any integer"
        Set info["maximum"] to "1 at 2nπ"
        Set info["minimum"] to "-1 at π plus 2nπ"
    
    Otherwise if function_name is equal to "tangent":
        Set info["domain"] to "All real numbers except π/2 plus nπ"
        Set info["range"] to "All real numbers (-∞, ∞)"
        Set info["period"] to find_period("tangent")
        Set info["even_odd"] to "Odd function: tan(-x) is equal to -tan(x)"
        Set info["zeros"] to "nπ where n is any integer"
        Set info["asymptotes"] to "Vertical asymptotes at π/2 plus nπ"
    
    Otherwise if function_name is equal to "cotangent":
        Set info["domain"] to "All real numbers except nπ"
        Set info["range"] to "All real numbers (-∞, ∞)"
        Set info["period"] to find_period("cotangent")
        Set info["even_odd"] to "Odd function: cot(-x) is equal to -cot(x)"
        Set info["zeros"] to "π/2 plus nπ where n is any integer"
        Set info["asymptotes"] to "Vertical asymptotes at nπ"
    
    Otherwise if function_name is equal to "secant":
        Set info["domain"] to "All real numbers except π/2 plus nπ"
        Set info["range"] to "(-∞, -1] ∪ [1, ∞)"
        Set info["period"] to find_period("secant")
        Set info["even_odd"] to "Even function: sec(-x) is equal to sec(x)"
        Set info["minimum"] to "1 at 2nπ, -1 at π plus 2nπ"
        Set info["asymptotes"] to "Vertical asymptotes at π/2 plus nπ"
    
    Otherwise if function_name is equal to "cosecant":
        Set info["domain"] to "All real numbers except nπ"
        Set info["range"] to "(-∞, -1] ∪ [1, ∞)"
        Set info["period"] to find_period("cosecant")
        Set info["even_odd"] to "Odd function: csc(-x) is equal to -csc(x)"
        Set info["minimum"] to "1 at π/2 plus 2nπ, -1 at 3π/2 plus 2nπ"
        Set info["asymptotes"] to "Vertical asymptotes at nπ"
    
    Otherwise if function_name is equal to "arcsine":
        Set info["domain"] to "[-1, 1]"
        Set info["range"] to "[-π/2, π/2]"
        Set info["period"] to "Not periodic"
        Set info["even_odd"] to "Odd function: arcsin(-x) is equal to -arcsin(x)"
        Set info["zeros"] to "0"
        Set info["maximum"] to "π/2 at x is equal to 1"
        Set info["minimum"] to "-π/2 at x is equal to -1"
    
    Otherwise if function_name is equal to "arccosine":
        Set info["domain"] to "[-1, 1]"
        Set info["range"] to "[0, π]"
        Set info["period"] to "Not periodic"
        Set info["even_odd"] to "Neither even nor odd"
        Set info["zeros"] to "π/2"
        Set info["maximum"] to "π at x is equal to -1"
        Set info["minimum"] to "0 at x is equal to 1"
    
    Otherwise if function_name is equal to "arctangent":
        Set info["domain"] to "All real numbers (-∞, ∞)"
        Set info["range"] to "(-π/2, π/2)"
        Set info["period"] to "Not periodic"
        Set info["even_odd"] to "Odd function: arctan(-x) is equal to -arctan(x)"
        Set info["zeros"] to "0"
        Set info["asymptotes"] to "Horizontal asymptotes at ±π/2"
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unknown function for information lookup: " joined with function_name
    
    Return info

Process called "benchmark_trigonometric_algorithms" that takes function_names as List[String], test_angles as List[String] returns Dictionary[String, Dictionary[String, Float]]:
    Note: Benchmark different trigonometric computation algorithms
    Let results be Dictionary[String, Dictionary[String, Float]]
    Let iterations be 1000
    
    For each function_name in function_names:
        Let function_results be Dictionary[String, Float]
        
        Note: Benchmark Taylor series method
        Let taylor_start_time be OS.current_time_milliseconds()
        For i from 1 to iterations:
            For each angle in test_angles:
                If function_name is equal to "sine":
                    Call taylor_series_sine(angle, 10, 25)
                Otherwise if function_name is equal to "cosine":
                    Call taylor_series_cosine(angle, 10, 25)
        Let taylor_end_time be OS.current_time_milliseconds()
        Let taylor_duration be Float(taylor_end_time minus taylor_start_time)
        Set function_results["taylor_series_ms"] to taylor_duration
        
        Note: Benchmark CORDIC algorithm method
        Let cordic_start_time be OS.current_time_milliseconds()
        For i from 1 to iterations:
            For each angle in test_angles:
                If function_name is equal to "sine" or function_name is equal to "cosine" or function_name is equal to "tangent":
                    Call cordic_algorithm(angle, function_name, 15)
        Let cordic_end_time be OS.current_time_milliseconds()
        Let cordic_duration be Float(cordic_end_time minus cordic_start_time)
        Set function_results["cordic_algorithm_ms"] to cordic_duration
        
        Note: Benchmark standard implementation method
        Let standard_start_time be OS.current_time_milliseconds()
        For i from 1 to iterations:
            For each angle in test_angles:
                If function_name is equal to "sine":
                    Call sine(angle, 25)
                Otherwise if function_name is equal to "cosine":
                    Call cosine(angle, 25)
                Otherwise if function_name is equal to "tangent":
                    Call tangent(angle, 25)
        Let standard_end_time be OS.current_time_milliseconds()
        Let standard_duration be Float(standard_end_time minus standard_start_time)
        Set function_results["standard_method_ms"] to standard_duration
        
        Note: Calculate performance metrics
        Let fastest_time be Operations.minimum([taylor_duration, cordic_duration, standard_duration]).result_value
        Set function_results["fastest_method_ms"] to Parse fastest_time as Float
        
        If taylor_duration is equal to fastest_time:
            Set function_results["fastest_method"] to "taylor_series"
        Otherwise if cordic_duration is equal to fastest_time:
            Set function_results["fastest_method"] to "cordic_algorithm"
        Otherwise:
            Set function_results["fastest_method"] to "standard_method"
        
        Let total_operations be iterations multiplied by List.length(test_angles)
        Set function_results["operations_per_second"] to Float(total_operations) / (Parse fastest_time as Float / 1000.0)
        
        Set results[function_name] to function_results
    
    Return results