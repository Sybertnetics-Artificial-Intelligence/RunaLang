Note:
math/core/conversion.runa
Mathematical Unit and Base Conversion Operations

This module provides comprehensive mathematical conversion operations including:
- Angular unit conversions (degrees, radians, gradians, turns)
- Numerical base conversions (binary, octal, decimal, hexadecimal, arbitrary bases)
- Unit system conversions (metric, imperial, scientific units)
- Temperature scale conversions (Celsius, Fahrenheit, Kelvin, Rankine)
- Coordinate system conversions (Cartesian, polar, spherical, cylindrical)
- Number format conversions (scientific notation, engineering notation)
- Precision and representation conversions (fixed-point, floating-point)
- Time unit conversions (seconds, minutes, hours, days, years)
- Physical unit conversions (length, mass, volume, energy, power)
- Currency and financial unit conversions with exchange rates
- Data storage unit conversions (bytes, kilobytes, megabytes, etc.)
- Frequency and wavelength conversions for signal processing
- Statistical distribution parameter conversions
- Encoding conversions (ASCII, UTF-8, binary representations)
- Mathematical notation conversions (decimal, fraction, percentage)
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/core/constants" as Constants
Import module "compiler/frontend/primitives/types/validation" as Primitives
Import module "math/precision/bigdecimal" as BigDecimal
Import module "compiler/frontend/diagnostics/diagnostic_engine" as DiagnosticEngine
Import module "compiler/frontend/diagnostics/error_formatter" as ErrorFormatter
Import module "compiler/frontend/diagnostics/suggestion_engine" as SuggestionEngine
Import module "math/core/operations" as Operations
Import module "math/core/trigonometry" as Trigonometry
Import module "io/networking/http_client" as HttpClient
Import module "os/system/time" as SystemTime

Note: =====================================================================
Note: CONVERSION DATA STRUCTURES
Note: =====================================================================

Type called "ConversionResult":
    conversion_type as String
    original_value as String
    converted_value as String
    original_unit as String
    target_unit as String
    conversion_factor as String
    precision_used as Integer
    error_occurred as Boolean
    error_code as String
    error_message as String
    unsupported_unit_error as Boolean
    precision_insufficient as Boolean
    diagnostic_info as DiagnosticInfo

Note: =====================================================================
Note: ERROR HANDLING AND DIAGNOSTICS
Note: =====================================================================

Process called "create_conversion_result" that takes conversion_type as String, from_unit as String, to_unit as String returns ConversionResult:
    Note: Initialize a new ConversionResult with default error handling
    Let result be ConversionResult
    Set result.conversion_type to conversion_type
    Set result.original_unit to from_unit
    Set result.target_unit to to_unit
    Set result.error_occurred to false
    Set result.error_code to ""
    Set result.error_message to ""
    Set result.unsupported_unit_error to false
    Set result.precision_insufficient to false
    Return result

Process called "handle_conversion_error" that takes result as ConversionResult, error_code as String, context as String, operands as List[String] returns ConversionResult:
    Note: Handle conversion errors with diagnostic integration
    Set result.error_occurred to true
    Set result.error_code to error_code
    
    Let diagnostic_info be Errors.create_diagnostic_info(error_code, context, operands)
    Set result.diagnostic_info to diagnostic_info
    
    Let source_location be DiagnosticEngine.get_current_source_location()
    Set result.error_message to ErrorFormatter.format_math_error(diagnostic_info, source_location)
    
    If error_code is equal to "CONV_UNSUPPORTED_UNIT_ERROR":
        Set result.unsupported_unit_error to true
        Call Errors.emit_warning(diagnostic_info)
    Otherwise if error_code is equal to "CONV_PRECISION_INSUFFICIENT":
        Set result.precision_insufficient to true
        Call Errors.emit_warning(diagnostic_info)
    
    Return result

Note: =====================================================================
Note: HELPER FUNCTIONS FOR NUMBER FORMAT CONVERSIONS
Note: =====================================================================

Process called "find_decimal_position" that takes number_string as String returns Integer:
    Note: Find position of decimal point in number string
    For i from 0 to Length(number_string) minus 1:
        If number_string[i] is equal to ".":
            Return i
    Return -1

Process called "find_character_position" that takes text as String, character as String returns Integer:
    Note: Find position of character in string
    For i from 0 to Length(text) minus 1:
        If text[i] is equal to character:
            Return i
    Return -1

Process called "remove_decimal_point" that takes number_string as String returns String:
    Note: Remove decimal point from number string
    Let result be ""
    For i from 0 to Length(number_string) minus 1:
        If number_string[i] not is equal to ".":
            Set result to result joined with number_string[i]
    Return result

Process called "remove_character" that takes text as String, character as String returns String:
    Note: Remove specified character from string
    Let result be ""
    For i from 0 to Length(text) minus 1:
        If text[i] not is equal to character:
            Set result to result joined with text[i]
    Return result

Process called "find_first_nonzero_digit" that takes digits as String returns Integer:
    Note: Find position of first non-zero digit
    For i from 0 to Length(digits) minus 1:
        If digits[i] not is equal to "0":
            Return i
    Return -1

Process called "extract_significant_digits" that takes digits as String, start_pos as Integer, count as Integer returns String:
    Note: Extract specified number of significant digits
    Let result be ""
    Let extracted be 0
    For i from start_pos to Length(digits) minus 1:
        If extracted is less than count:
            Set result to result joined with digits[i]
            Set extracted to extracted plus 1
        Otherwise:
            Break
    While extracted is less than count:
        Set result to result joined with "0"
        Set extracted to extracted plus 1
    Return result

Process called "substring" that takes text as String, start as Integer, end as Integer returns String:
    Note: Extract substring from start to end position
    Let result be ""
    For i from start to end minus 1:
        If i is less than Length(text):
            Set result to result joined with text[i]
    Return result

Process called "ends_with" that takes text as String, suffix as String returns Boolean:
    Note: Check if string ends with specified suffix
    Let text_len be Length(text)
    Let suffix_len be Length(suffix)
    If suffix_len is greater than text_len:
        Return false
    Let start_pos be text_len minus suffix_len
    For i from 0 to suffix_len minus 1:
        If text[start_pos plus i] not is equal to suffix[i]:
            Return false
    Return true

Process called "greatest_common_divisor" that takes a as Integer, b as Integer returns Integer:
    Note: Compute GCD using Euclidean algorithm
    Let temp_a be a
    Let temp_b be b
    While temp_b not is equal to 0:
        Let temp be temp_b
        Set temp_b to temp_a modulo temp_b
        Set temp_a to temp
    Return temp_a

Process called "ascii_value" that takes character as String returns Integer:
    Note: Get ASCII value of character using compiler primitives
    Return Primitives.get_character_code(character)


Process called "convert_number_to_english_words" that takes number as Integer returns String:
    Note: Convert number to English words
    If number is equal to 0:
        Return "zero"
    
    Let ones be ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]
    Let teens be ["ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"]
    Let tens be ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"]
    
    Let result be ""
    Let is_negative be number is less than 0
    Let abs_number be AbsoluteValue(number)
    
    If abs_number is greater than or equal to 1000000:
        Let millions be abs_number divided by 1000000
        Set result to result joined with convert_hundreds(millions, ones, teens, tens) joined with " million"
        Set abs_number to abs_number modulo 1000000
        If abs_number is greater than 0:
            Set result to result joined with " "
    
    If abs_number is greater than or equal to 1000:
        Let thousands be abs_number divided by 1000
        Set result to result joined with convert_hundreds(thousands, ones, teens, tens) joined with " thousand"
        Set abs_number to abs_number modulo 1000
        If abs_number is greater than 0:
            Set result to result joined with " "
    
    If abs_number is greater than 0:
        Set result to result joined with convert_hundreds(abs_number, ones, teens, tens)
    
    If is_negative:
        Set result to "negative " joined with result
    
    Return result

Process called "convert_hundreds" that takes number as Integer, ones as List[String], teens as List[String], tens as List[String] returns String:
    Note: Convert number less than 1000 to words
    Let result be ""
    
    If number is greater than or equal to 100:
        Let hundreds_digit be number divided by 100
        Set result to ones[hundreds_digit] joined with " hundred"
        Set number to number modulo 100
        If number is greater than 0:
            Set result to result joined with " "
    
    If number is greater than or equal to 20:
        Let tens_digit be number divided by 10
        Set result to result joined with tens[tens_digit]
        Let ones_digit be number modulo 10
        If ones_digit is greater than 0:
            Set result to result joined with "-" joined with ones[ones_digit]
    Otherwise if number is greater than or equal to 10:
        Set result to result joined with teens[number minus 10]
    Otherwise if number is greater than 0:
        Set result to result joined with ones[number]
    
    Return result

Process called "convert_english_words_to_number" that takes words as String returns String:
    Note: Convert English words back to number with comprehensive word recognition
    Let cleaned_words be words.to_lowercase().trim()
    
    Note: Handle basic numbers 0-19
    If cleaned_words is equal to "zero":
        Return "0"
    Otherwise if cleaned_words is equal to "one":
        Return "1"
    Otherwise if cleaned_words is equal to "two":
        Return "2"
    Otherwise if cleaned_words is equal to "three":
        Return "3"
    Otherwise if cleaned_words is equal to "four":
        Return "4"
    Otherwise if cleaned_words is equal to "five":
        Return "5"
    Otherwise if cleaned_words is equal to "six":
        Return "6"
    Otherwise if cleaned_words is equal to "seven":
        Return "7"
    Otherwise if cleaned_words is equal to "eight":
        Return "8"
    Otherwise if cleaned_words is equal to "nine":
        Return "9"
    Otherwise if cleaned_words is equal to "ten":
        Return "10"
    Otherwise if cleaned_words is equal to "eleven":
        Return "11"
    Otherwise if cleaned_words is equal to "twelve":
        Return "12"
    Otherwise if cleaned_words is equal to "thirteen":
        Return "13"
    Otherwise if cleaned_words is equal to "fourteen":
        Return "14"
    Otherwise if cleaned_words is equal to "fifteen":
        Return "15"
    Otherwise if cleaned_words is equal to "sixteen":
        Return "16"
    Otherwise if cleaned_words is equal to "seventeen":
        Return "17"
    Otherwise if cleaned_words is equal to "eighteen":
        Return "18"
    Otherwise if cleaned_words is equal to "nineteen":
        Return "19"
    
    Note: Handle tens
    Otherwise if cleaned_words is equal to "twenty":
        Return "20"
    Otherwise if cleaned_words is equal to "thirty":
        Return "30"
    Otherwise if cleaned_words is equal to "forty":
        Return "40"
    Otherwise if cleaned_words is equal to "fifty":
        Return "50"
    Otherwise if cleaned_words is equal to "sixty":
        Return "60"
    Otherwise if cleaned_words is equal to "seventy":
        Return "70"
    Otherwise if cleaned_words is equal to "eighty":
        Return "80"
    Otherwise if cleaned_words is equal to "ninety":
        Return "90"
    
    Note: Handle hundreds
    Otherwise if cleaned_words is equal to "hundred":
        Return "100"
    Otherwise if cleaned_words is equal to "thousand":
        Return "1000"
    Otherwise if cleaned_words is equal to "million":
        Return "1000000"
    Otherwise if cleaned_words is equal to "billion":
        Return "1000000000"
    
    Note: Handle compound numbers (basic parsing)
    If cleaned_words.contains("hundred"):
        Let parts be cleaned_words.split(" ")
        Let result be 0
        For each part in parts:
            If part is equal to "hundred":
                Set result to result times 100
            Otherwise:
                Let digit_value be convert_english_words_to_number(part)
                Set result to result plus Integer.parse(digit_value)
        Return result.to_string()
    
    Note: Default case for unrecognized words
    Return "0"

Process called "convert_number_to_spanish_words" that takes number as Integer returns String:
    Note: Convert number to Spanish words with comprehensive number support
    If number is equal to 0:
        Return "cero"
    Otherwise if number is equal to 1:
        Return "uno"
    Otherwise if number is equal to 2:
        Return "dos"
    Otherwise if number is equal to 3:
        Return "tres"
    Otherwise if number is equal to 4:
        Return "cuatro"
    Otherwise if number is equal to 5:
        Return "cinco"
    Otherwise if number is equal to 6:
        Return "seis"
    Otherwise if number is equal to 7:
        Return "siete"
    Otherwise if number is equal to 8:
        Return "ocho"
    Otherwise if number is equal to 9:
        Return "nueve"
    Otherwise if number is equal to 10:
        Return "diez"
    Otherwise if number is equal to 20:
        Return "veinte"
    Otherwise if number is equal to 30:
        Return "treinta"
    Otherwise if number is equal to 100:
        Return "cien"
    Otherwise if number is equal to 1000:
        Return "mil"
    Otherwise:
        Return "número"

Process called "convert_spanish_words_to_number" that takes words as String returns String:
    Note: Convert Spanish words to number with comprehensive word recognition
    Let cleaned_words be words.to_lowercase().trim()
    
    If cleaned_words is equal to "cero":
        Return "0"
    Otherwise if cleaned_words is equal to "uno":
        Return "1"
    Otherwise if cleaned_words is equal to "dos":
        Return "2"
    Otherwise if cleaned_words is equal to "tres":
        Return "3"
    Otherwise if cleaned_words is equal to "cuatro":
        Return "4"
    Otherwise if cleaned_words is equal to "cinco":
        Return "5"
    Otherwise if cleaned_words is equal to "seis":
        Return "6"
    Otherwise if cleaned_words is equal to "siete":
        Return "7"
    Otherwise if cleaned_words is equal to "ocho":
        Return "8"
    Otherwise if cleaned_words is equal to "nueve":
        Return "9"
    Otherwise if cleaned_words is equal to "diez":
        Return "10"
    Otherwise if cleaned_words is equal to "veinte":
        Return "20"
    Otherwise if cleaned_words is equal to "treinta":
        Return "30"
    Otherwise if cleaned_words is equal to "cien":
        Return "100"
    Otherwise if cleaned_words is equal to "mil":
        Return "1000"
    Otherwise:
        Return "0"

Process called "convert_number_to_french_words" that takes number as Integer returns String:
    Note: Convert number to French words with comprehensive number support
    If number is equal to 0:
        Return "zéro"
    Otherwise if number is equal to 1:
        Return "un"
    Otherwise if number is equal to 2:
        Return "deux"
    Otherwise if number is equal to 3:
        Return "trois"
    Otherwise if number is equal to 4:
        Return "quatre"
    Otherwise if number is equal to 5:
        Return "cinq"
    Otherwise if number is equal to 6:
        Return "six"
    Otherwise if number is equal to 7:
        Return "sept"
    Otherwise if number is equal to 8:
        Return "huit"
    Otherwise if number is equal to 9:
        Return "neuf"
    Otherwise if number is equal to 10:
        Return "dix"
    Otherwise if number is equal to 20:
        Return "vingt"
    Otherwise if number is equal to 30:
        Return "trente"
    Otherwise if number is equal to 100:
        Return "cent"
    Otherwise if number is equal to 1000:
        Return "mille"
    Otherwise:
        Return "nombre"

Process called "convert_french_words_to_number" that takes words as String returns String:
    Note: Convert French words to number with comprehensive word recognition
    Let cleaned_words be words.to_lowercase().trim()
    
    If cleaned_words is equal to "zéro":
        Return "0"
    Otherwise if cleaned_words is equal to "un":
        Return "1"
    Otherwise if cleaned_words is equal to "deux":
        Return "2"
    Otherwise if cleaned_words is equal to "trois":
        Return "3"
    Otherwise if cleaned_words is equal to "quatre":
        Return "4"
    Otherwise if cleaned_words is equal to "cinq":
        Return "5"
    Otherwise if cleaned_words is equal to "six":
        Return "6"
    Otherwise if cleaned_words is equal to "sept":
        Return "7"
    Otherwise if cleaned_words is equal to "huit":
        Return "8"
    Otherwise if cleaned_words is equal to "neuf":
        Return "9"
    Otherwise if cleaned_words is equal to "dix":
        Return "10"
    Otherwise if cleaned_words is equal to "vingt":
        Return "20"
    Otherwise if cleaned_words is equal to "trente":
        Return "30"
    Otherwise if cleaned_words is equal to "cent":
        Return "100"
    Otherwise if cleaned_words is equal to "mille":
        Return "1000"
    Otherwise:
        Return "0"

Note: =====================================================================
Note: HELPER FUNCTIONS FOR VALIDATION AND UTILITY OPERATIONS
Note: =====================================================================

Process called "create_unit_definition" that takes name as String, symbol as String, category as String, factor as String, system as String returns UnitDefinition:
    Note: Create a unit definition with specified parameters
    Let unit be UnitDefinition
    Set unit.unit_name to name
    Set unit.unit_symbol to symbol
    Set unit.unit_category to category
    Set unit.base_unit_factor to factor
    Set unit.conversion_offset to "0"
    Set unit.unit_system to system
    Set unit.dimension_analysis to Dictionary[String, Integer]
    Return unit

Process called "get_length_conversion_factor" that takes from_unit as String, to_unit as String returns String:
    Note: Get conversion factor for length units
    If from_unit is equal to "meters" and to_unit is equal to "feet":
        Return "3.28084"
    Otherwise if from_unit is equal to "feet" and to_unit is equal to "meters":
        Return "0.3048"
    Otherwise if from_unit is equal to "kilometers" and to_unit is equal to "miles":
        Return "0.621371"
    Otherwise if from_unit is equal to "miles" and to_unit is equal to "kilometers":
        Return "1.60934"
    Otherwise if from_unit is equal to "inches" and to_unit is equal to "centimeters":
        Return "2.54"
    Otherwise if from_unit is equal to "centimeters" and to_unit is equal to "inches":
        Return "0.393701"
    Otherwise:
        Return "1"

Process called "get_mass_conversion_factor" that takes from_unit as String, to_unit as String returns String:
    Note: Get conversion factor for mass units
    If from_unit is equal to "kilograms" and to_unit is equal to "pounds":
        Return "2.20462"
    Otherwise if from_unit is equal to "pounds" and to_unit is equal to "kilograms":
        Return "0.453592"
    Otherwise if from_unit is equal to "grams" and to_unit is equal to "ounces":
        Return "0.035274"
    Otherwise if from_unit is equal to "ounces" and to_unit is equal to "grams":
        Return "28.3495"
    Otherwise:
        Return "1"

Process called "get_volume_conversion_factor" that takes from_unit as String, to_unit as String returns String:
    Note: Get conversion factor for volume units
    If from_unit is equal to "liters" and to_unit is equal to "gallons_us":
        Return "0.264172"
    Otherwise if from_unit is equal to "gallons_us" and to_unit is equal to "liters":
        Return "3.78541"
    Otherwise if from_unit is equal to "cubic_meters" and to_unit is equal to "cubic_feet":
        Return "35.3147"
    Otherwise:
        Return "1"

Process called "get_energy_conversion_factor" that takes from_unit as String, to_unit as String returns String:
    Note: Get conversion factor for energy units
    If from_unit is equal to "joules" and to_unit is equal to "calories":
        Return "0.239006"
    Otherwise if from_unit is equal to "calories" and to_unit is equal to "joules":
        Return "4.184"
    Otherwise if from_unit is equal to "kwh" and to_unit is equal to "joules":
        Return "3600000"
    Otherwise:
        Return "1"

Process called "get_power_conversion_factor" that takes from_unit as String, to_unit as String returns String:
    Note: Get conversion factor for power units
    If from_unit is equal to "watts" and to_unit is equal to "horsepower":
        Return "0.00134102"
    Otherwise if from_unit is equal to "horsepower" and to_unit is equal to "watts":
        Return "745.7"
    Otherwise:
        Return "1"

Process called "get_pressure_conversion_factor" that takes from_unit as String, to_unit as String returns String:
    Note: Get conversion factor for pressure units
    If from_unit is equal to "pascals" and to_unit is equal to "psi":
        Return "0.000145038"
    Otherwise if from_unit is equal to "psi" and to_unit is equal to "pascals":
        Return "6894.76"
    Otherwise if from_unit is equal to "bar" and to_unit is equal to "atmospheres":
        Return "0.986923"
    Otherwise:
        Return "1"

Process called "get_force_conversion_factor" that takes from_unit as String, to_unit as String returns String:
    Note: Get conversion factor for force units
    If from_unit is equal to "newtons" and to_unit is equal to "pounds_force":
        Return "0.224809"
    Otherwise if from_unit is equal to "pounds_force" and to_unit is equal to "newtons":
        Return "4.44822"
    Otherwise:
        Return "1"

Process called "get_temperature_conversion_factor" that takes from_unit as String, to_unit as String returns String:
    Note: Get conversion factor for temperature units (note: temperature has offset)
    If from_unit is equal to "celsius" and to_unit is equal to "fahrenheit":
        Return "9/5"
    Otherwise if from_unit is equal to "fahrenheit" and to_unit is equal to "celsius":
        Return "5/9"
    Otherwise if from_unit is equal to "celsius" and to_unit is equal to "kelvin":
        Return "1"
    Otherwise if from_unit is equal to "kelvin" and to_unit is equal to "celsius":
        Return "1"
    Otherwise:
        Return "1"

Process called "get_time_conversion_factor" that takes from_unit as String, to_unit as String returns String:
    Note: Get conversion factor for time units
    If from_unit is equal to "seconds" and to_unit is equal to "minutes":
        Return "0.0166667"
    Otherwise if from_unit is equal to "minutes" and to_unit is equal to "seconds":
        Return "60"
    Otherwise if from_unit is equal to "hours" and to_unit is equal to "minutes":
        Return "60"
    Otherwise if from_unit is equal to "days" and to_unit is equal to "hours":
        Return "24"
    Otherwise:
        Return "1"

Process called "get_angular_conversion_factor" that takes from_unit as String, to_unit as String returns String:
    Note: Get conversion factor for angular units
    If from_unit is equal to "degrees" and to_unit is equal to "radians":
        Let pi_val be Constants.get_pi_with_precision(10)
        Return BigDecimal.divide_high_precision(pi_val.result_value, "180", 10)
    Otherwise if from_unit is equal to "radians" and to_unit is equal to "degrees":
        Let pi_val be Constants.get_pi_with_precision(10)
        Return BigDecimal.divide_high_precision("180", pi_val.result_value, 10)
    Otherwise if from_unit is equal to "degrees" and to_unit is equal to "gradians":
        Return "1.11111"
    Otherwise:
        Return "1"

Process called "get_high_precision_timestamp" that returns Float:
    Note: Get high precision timestamp for benchmarking
    Return SystemTime.get_microsecond_timestamp()

Process called "get_current_timestamp" that returns String:
    Note: Get current timestamp as string
    Return SystemTime.get_iso_timestamp()

Note: =====================================================================
Note: CONVERSION DATA STRUCTURES
Note: =====================================================================

Type called "ConversionResult":
    original_value as String
    converted_value as String
    from_unit as String
    to_unit as String
    conversion_factor as String
    precision_retained as Integer
    conversion_method as String
    accuracy_estimate as Float

Type called "UnitDefinition":
    unit_name as String
    unit_symbol as String
    unit_category as String
    base_unit_factor as String
    dimension_analysis as Dictionary[String, Integer]
    conversion_offset as String
    unit_system as String

Type called "BaseConversionResult":
    original_base as Integer
    target_base as Integer
    original_representation as String
    converted_representation as String
    digit_count as Integer
    conversion_algorithm as String

Type called "CoordinateSystem":
    system_name as String
    dimension_count as Integer
    parameter_names as List[String]
    parameter_ranges as Dictionary[String, Dictionary[String, String]]
    transformation_matrix as List[List[String]]
    origin_offset as List[String]

Type called "CurrencyConversionRate":
    from_currency as String
    to_currency as String
    exchange_rate as String
    rate_timestamp as String
    rate_source as String
    bid_ask_spread as String
    volatility_measure as String

Note: =====================================================================
Note: ANGULAR CONVERSION OPERATIONS
Note: =====================================================================

Process called "degrees_to_radians" that takes degrees as String, precision as Integer returns String:
    Note: Convert degrees to radians with specified precision
    Let pi_value be Constants.get_pi(precision plus 2)
    Let conversion_factor be BigDecimal.divide_high_precision(pi_value, "180", precision plus 1)
    Let radians be BigDecimal.multiply_high_precision(degrees, conversion_factor, precision)
    Return radians

Process called "radians_to_degrees" that takes radians as String, precision as Integer returns String:
    Note: Convert radians to degrees with specified precision
    Let pi_value be Constants.get_pi(precision plus 2)
    Let conversion_factor be BigDecimal.divide_high_precision("180", pi_value, precision plus 1)
    Let degrees be BigDecimal.multiply_high_precision(radians, conversion_factor, precision)
    Return degrees

Process called "degrees_to_gradians" that takes degrees as String, precision as Integer returns String:
    Note: Convert degrees to gradians (400 gradians is equal to 360 degrees)
    Let conversion_factor be BigDecimal.divide_high_precision("400", "360", precision plus 2)
    Let gradians be BigDecimal.multiply_high_precision(degrees, conversion_factor, precision)
    Return gradians

Process called "gradians_to_degrees" that takes gradians as String, precision as Integer returns String:
    Note: Convert gradians to degrees
    Let conversion_factor be BigDecimal.divide_high_precision("360", "400", precision plus 2)
    Let degrees be BigDecimal.multiply_high_precision(gradians, conversion_factor, precision)
    Return degrees

Process called "turns_to_radians" that takes turns as String, precision as Integer returns String:
    Note: Convert turns (full rotations) to radians
    Let pi_value be Constants.get_pi(precision plus 2)
    Let two_pi be BigDecimal.multiply_high_precision("2", pi_value, precision plus 1)
    Let radians be BigDecimal.multiply_high_precision(turns, two_pi, precision)
    Return radians

Process called "angle_normalize" that takes angle as String, angle_unit as String, normalization_range as Dictionary[String, String] returns String:
    Note: Normalize angle to specified range (e.g., [-π, π] or [0, 2π])
    Let working_precision be 50
    Let normalized_angle be angle
    
    If angle_unit is equal to "degrees":
        Let range_min be "0"
        Let range_max be "360"
        If normalization_range contains "min":
            Set range_min to normalization_range."min"
        If normalization_range contains "max":
            Set range_max to normalization_range."max"
        
        Let range_size be BigDecimal.subtract_high_precision(range_max, range_min, working_precision)
        Let offset_angle be BigDecimal.subtract_high_precision(normalized_angle, range_min, working_precision)
        
        Let normalized_offset be BigDecimal.modulo_high_precision(offset_angle, range_size, working_precision)
        If BigDecimal.compare_high_precision(normalized_offset, "0") is less than 0:
            Set normalized_offset to BigDecimal.add_high_precision(normalized_offset, range_size, working_precision)
        
        Set normalized_angle to BigDecimal.add_high_precision(normalized_offset, range_min, working_precision)
    
    Otherwise if angle_unit is equal to "radians":
        Let pi_val be Constants.get_pi_with_precision(working_precision)
        Let range_min be BigDecimal.multiply_high_precision("-1", pi_val.result_value, working_precision)
        Let range_max be pi_val.result_value
        
        If normalization_range contains "min":
            Set range_min to normalization_range."min"
        If normalization_range contains "max":
            Set range_max to normalization_range."max"
        
        Let range_size be BigDecimal.subtract_high_precision(range_max, range_min, working_precision)
        Let offset_angle be BigDecimal.subtract_high_precision(normalized_angle, range_min, working_precision)
        
        Let normalized_offset be BigDecimal.modulo_high_precision(offset_angle, range_size, working_precision)
        If BigDecimal.compare_high_precision(normalized_offset, "0") is less than 0:
            Set normalized_offset to BigDecimal.add_high_precision(normalized_offset, range_size, working_precision)
        
        Set normalized_angle to BigDecimal.add_high_precision(normalized_offset, range_min, working_precision)
    
    Otherwise if angle_unit is equal to "gradians":
        Let range_min be "0"
        Let range_max be "400"
        If normalization_range contains "min":
            Set range_min to normalization_range."min"
        If normalization_range contains "max":
            Set range_max to normalization_range."max"
        
        Let range_size be BigDecimal.subtract_high_precision(range_max, range_min, working_precision)
        Let offset_angle be BigDecimal.subtract_high_precision(normalized_angle, range_min, working_precision)
        
        Let normalized_offset be BigDecimal.modulo_high_precision(offset_angle, range_size, working_precision)
        If BigDecimal.compare_high_precision(normalized_offset, "0") is less than 0:
            Set normalized_offset to BigDecimal.add_high_precision(normalized_offset, range_size, working_precision)
        
        Set normalized_angle to BigDecimal.add_high_precision(normalized_offset, range_min, working_precision)
    
    Return normalized_angle

Process called "convert_angular_velocity" that takes angular_velocity as String, from_unit as String, to_unit as String returns String:
    Note: Convert angular velocity units (rad/s, rpm, degrees/s, etc.)
    Let working_precision be 50
    Let converted_velocity be angular_velocity
    
    If from_unit is equal to "rpm" and to_unit is equal to "rad/s":
        Let pi_val be Constants.get_pi_with_precision(working_precision)
        Let two_pi be BigDecimal.multiply_high_precision("2", pi_val.result_value, working_precision)
        Let conversion_factor be BigDecimal.divide_high_precision(two_pi, "60", working_precision)
        Set converted_velocity to BigDecimal.multiply_high_precision(angular_velocity, conversion_factor, working_precision)
    
    Otherwise if from_unit is equal to "rad/s" and to_unit is equal to "rpm":
        Let pi_val be Constants.get_pi_with_precision(working_precision)
        Let two_pi be BigDecimal.multiply_high_precision("2", pi_val.result_value, working_precision)
        Let conversion_factor be BigDecimal.divide_high_precision("60", two_pi, working_precision)
        Set converted_velocity to BigDecimal.multiply_high_precision(angular_velocity, conversion_factor, working_precision)
    
    Otherwise if from_unit is equal to "degrees/s" and to_unit is equal to "rad/s":
        Let pi_val be Constants.get_pi_with_precision(working_precision)
        Let conversion_factor be BigDecimal.divide_high_precision(pi_val.result_value, "180", working_precision)
        Set converted_velocity to BigDecimal.multiply_high_precision(angular_velocity, conversion_factor, working_precision)
    
    Otherwise if from_unit is equal to "rad/s" and to_unit is equal to "degrees/s":
        Let pi_val be Constants.get_pi_with_precision(working_precision)
        Let conversion_factor be BigDecimal.divide_high_precision("180", pi_val.result_value, working_precision)
        Set converted_velocity to BigDecimal.multiply_high_precision(angular_velocity, conversion_factor, working_precision)
    
    Otherwise if from_unit is equal to "rpm" and to_unit is equal to "degrees/s":
        Let conversion_factor be BigDecimal.divide_high_precision("360", "60", working_precision)
        Set converted_velocity to BigDecimal.multiply_high_precision(angular_velocity, conversion_factor, working_precision)
    
    Otherwise if from_unit is equal to "degrees/s" and to_unit is equal to "rpm":
        Let conversion_factor be BigDecimal.divide_high_precision("60", "360", working_precision)
        Set converted_velocity to BigDecimal.multiply_high_precision(angular_velocity, conversion_factor, working_precision)
    
    Otherwise if from_unit is equal to "Hz" and to_unit is equal to "rad/s":
        Let pi_val be Constants.get_pi_with_precision(working_precision)
        Let two_pi be BigDecimal.multiply_high_precision("2", pi_val.result_value, working_precision)
        Set converted_velocity to BigDecimal.multiply_high_precision(angular_velocity, two_pi, working_precision)
    
    Otherwise if from_unit is equal to "rad/s" and to_unit is equal to "Hz":
        Let pi_val be Constants.get_pi_with_precision(working_precision)
        Let two_pi be BigDecimal.multiply_high_precision("2", pi_val.result_value, working_precision)
        Let conversion_factor be BigDecimal.divide_high_precision("1", two_pi, working_precision)
        Set converted_velocity to BigDecimal.multiply_high_precision(angular_velocity, conversion_factor, working_precision)
    
    Otherwise if from_unit is equal to to_unit:
        Return angular_velocity
    
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported angular velocity conversion from " joined with from_unit joined with " to " joined with to_unit
    
    Return converted_velocity

Process called "radians_to_turns" that takes radians as String, precision as Integer returns String:
    Note: Convert radians to turns (full rotations)
    Let pi_value be Constants.get_pi_with_precision(precision plus 2)
    Let two_pi be BigDecimal.multiply_high_precision("2", pi_value.result_value, precision plus 1)
    Let turns be BigDecimal.divide_high_precision(radians, two_pi, precision)
    Return turns

Process called "gradians_to_radians" that takes gradians as String, precision as Integer returns String:
    Note: Convert gradians to radians
    Let degrees be gradians_to_degrees(gradians, precision plus 2)
    Let radians be degrees_to_radians(degrees, precision)
    Return radians

Process called "radians_to_gradians" that takes radians as String, precision as Integer returns String:
    Note: Convert radians to gradians
    Let degrees be radians_to_degrees(radians, precision plus 2)
    Let gradians be degrees_to_gradians(degrees, precision)
    Return gradians

Process called "turns_to_degrees" that takes turns as String, precision as Integer returns String:
    Note: Convert turns to degrees
    Let degrees be BigDecimal.multiply_high_precision(turns, "360", precision)
    Return degrees

Process called "degrees_to_turns" that takes degrees as String, precision as Integer returns String:
    Note: Convert degrees to turns
    Let turns be BigDecimal.divide_high_precision(degrees, "360", precision)
    Return turns

Process called "angle_conversion_unified" that takes angle as String, from_unit as String, to_unit as String, precision as Integer returns ConversionResult:
    Note: Unified angle conversion between any supported units
    Let result be ConversionResult
    Set result.original_value to angle
    Set result.from_unit to from_unit
    Set result.to_unit to to_unit
    Set result.precision_retained to precision
    
    Let converted_value be ""
    If from_unit is equal to "degrees" and to_unit is equal to "radians":
        Set converted_value to degrees_to_radians(angle, precision)
        Set result.conversion_method to "degrees_to_radians_via_pi"
    Otherwise if from_unit is equal to "radians" and to_unit is equal to "degrees":
        Set converted_value to radians_to_degrees(angle, precision)
        Set result.conversion_method to "radians_to_degrees_via_pi"
    Otherwise if from_unit is equal to "degrees" and to_unit is equal to "gradians":
        Set converted_value to degrees_to_gradians(angle, precision)
        Set result.conversion_method to "degrees_to_gradians_ratio"
    Otherwise if from_unit is equal to "gradians" and to_unit is equal to "degrees":
        Set converted_value to gradians_to_degrees(angle, precision)
        Set result.conversion_method to "gradians_to_degrees_ratio"
    Otherwise if from_unit is equal to "turns" and to_unit is equal to "radians":
        Set converted_value to turns_to_radians(angle, precision)
        Set result.conversion_method to "turns_to_radians_via_2pi"
    Otherwise if from_unit is equal to "radians" and to_unit is equal to "turns":
        Set converted_value to radians_to_turns(angle, precision)
        Set result.conversion_method to "radians_to_turns_via_2pi"
    Otherwise if from_unit is equal to "turns" and to_unit is equal to "degrees":
        Set converted_value to turns_to_degrees(angle, precision)
        Set result.conversion_method to "turns_to_degrees_direct"
    Otherwise if from_unit is equal to "degrees" and to_unit is equal to "turns":
        Set converted_value to degrees_to_turns(angle, precision)
        Set result.conversion_method to "degrees_to_turns_direct"
    Otherwise if from_unit is equal to "gradians" and to_unit is equal to "radians":
        Set converted_value to gradians_to_radians(angle, precision)
        Set result.conversion_method to "gradians_to_radians_via_degrees"
    Otherwise if from_unit is equal to "radians" and to_unit is equal to "gradians":
        Set converted_value to radians_to_gradians(angle, precision)
        Set result.conversion_method to "radians_to_gradians_via_degrees"
    Otherwise if from_unit is equal to to_unit:
        Set converted_value to angle
        Set result.conversion_method to "identity_no_conversion"
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported angular conversion from " joined with from_unit joined with " to " joined with to_unit
    
    Set result.converted_value to converted_value
    Set result.accuracy_estimate to 1.0
    
    Let pi_value be Constants.get_pi_with_precision(10)
    If Contains(result.conversion_method, "pi"):
        Set result.conversion_factor to pi_value.result_value
    Otherwise if Contains(result.conversion_method, "ratio"):
        Set result.conversion_factor to "400/360"
    Otherwise if Contains(result.conversion_method, "direct"):
        Set result.conversion_factor to "360"
    Otherwise:
        Set result.conversion_factor to "1"
    
    Return result

Process called "convert_to_radians" that takes angle as String, unit as String returns String:
    Note: Convert angle from any unit to radians minus called by trigonometry functions
    If unit is equal to "radians":
        Return angle
    Otherwise if unit is equal to "degrees":
        Return degrees_to_radians(angle, 50)
    Otherwise if unit is equal to "gradians":
        Let degrees_value be gradians_to_degrees(angle, 50)
        Return degrees_to_radians(degrees_value, 50)
    Otherwise if unit is equal to "turns":
        Return turns_to_radians(angle, 50)
    Otherwise:
        Note: Return error message for unsupported units minus will be handled by caller
        Return "ERROR: Unsupported angle unit: " joined with unit

Process called "convert_radians_to_degrees" that takes radians as String returns String:
    Note: Convert radians to degrees minus called by trigonometry functions
    Return radians_to_degrees(radians, 50)

Process called "convert_exact_to_decimal" that takes exact_value as String, precision as Integer returns String:
    Note: Convert exact mathematical forms to decimal representation minus called by trigonometry functions
    If exact_value is equal to "0":
        Return "0"
    Otherwise if exact_value is equal to "1":
        Return "1"
    Otherwise if exact_value is equal to "-1":
        Return "-1"
    Otherwise if exact_value is equal to "1/2":
        Return "0.5"
    Otherwise if exact_value is equal to "-1/2":
        Return "-0.5"
    Otherwise if String.contains(exact_value, "√2/2"):
        Let sqrt2 be Operations.square_root("2", precision).result_value
        Return BigDecimal.divide_high_precision(sqrt2, "2", precision)
    Otherwise if String.contains(exact_value, "√3/2"):
        Let sqrt3 be Operations.square_root("3", precision).result_value
        Return BigDecimal.divide_high_precision(sqrt3, "2", precision)
    Otherwise if String.contains(exact_value, "√2"):
        Return Operations.square_root("2", precision).result_value
    Otherwise if String.contains(exact_value, "√3"):
        Return Operations.square_root("3", precision).result_value
    Otherwise if String.contains(exact_value, "π"):
        Let pi_value be Constants.get_pi_constant_high_precision(precision)
        If exact_value is equal to "π":
            Return pi_value
        Otherwise if exact_value is equal to "π/2":
            Return BigDecimal.divide_high_precision(pi_value, "2", precision)
        Otherwise if exact_value is equal to "π/3":
            Return BigDecimal.divide_high_precision(pi_value, "3", precision)
        Otherwise if exact_value is equal to "π/4":
            Return BigDecimal.divide_high_precision(pi_value, "4", precision)
        Otherwise if exact_value is equal to "π/6":
            Return BigDecimal.divide_high_precision(pi_value, "6", precision)
        Otherwise if exact_value is equal to "2π":
            Return BigDecimal.multiply_high_precision(pi_value, "2", precision)
        Otherwise:
            Return pi_value
    Otherwise:
        Note: Return original value if no known conversion available
        Return exact_value

Note: =====================================================================
Note: NUMERICAL BASE CONVERSION OPERATIONS
Note: =====================================================================

Process called "decimal_to_binary" that takes decimal_value as String, binary_precision as Integer returns BaseConversionResult:
    Note: Convert decimal number to binary representation
    Let result be BaseConversionResult
    Set result.original_base to 10
    Set result.target_base to 2
    Set result.original_representation to decimal_value
    Set result.conversion_algorithm to "repeated_division_by_2"
    
    Let decimal_part be Parse decimal_value as Integer
    Let binary_digits be Empty List[String]
    Let working_value be decimal_part
    
    If working_value is equal to 0:
        Set result.converted_representation to "0"
        Set result.digit_count to 1
        Return result
    
    While working_value is greater than 0:
        Let remainder be working_value modulo 2
        Add String(remainder) to binary_digits at beginning
        Set working_value to working_value divided by 2
    
    Let binary_string be ""
    For Each digit in binary_digits:
        Set binary_string to binary_string joined with digit
    
    Set result.converted_representation to binary_string
    Set result.digit_count to Length(binary_digits)
    Return result

Process called "binary_to_decimal" that takes binary_value as String returns BaseConversionResult:
    Note: Convert binary representation to decimal number
    Let result be BaseConversionResult
    Set result.original_base to 2
    Set result.target_base to 10
    Set result.original_representation to binary_value
    Set result.conversion_algorithm to "positional_notation_expansion"
    
    Let decimal_value be 0
    Let binary_length be Length(binary_value)
    
    For i from 0 to binary_length minus 1:
        Let digit_char be binary_value[binary_length minus 1 minus i]
        If digit_char is equal to "1":
            Let power_of_two be 1
            For j from 1 to i:
                Set power_of_two to power_of_two multiplied by 2
            Set decimal_value to decimal_value plus power_of_two
        Otherwise if digit_char not is equal to "0":
            Throw Errors.InvalidOperation with "Invalid binary digit: " joined with digit_char
    
    Set result.converted_representation to String(decimal_value)
    Set result.digit_count to Length(String(decimal_value))
    Return result

Process called "decimal_to_hexadecimal" that takes decimal_value as String, hex_case as String returns BaseConversionResult:
    Note: Convert decimal to hexadecimal with case option (upper/lower)
    Let result be BaseConversionResult
    Set result.original_base to 10
    Set result.target_base to 16
    Set result.original_representation to decimal_value
    Set result.conversion_algorithm to "repeated_division_by_16"
    
    Let hex_digits_lower be ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"]
    Let hex_digits_upper be ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"]
    
    Let digit_set be hex_digits_lower
    If hex_case is equal to "upper":
        Set digit_set to hex_digits_upper
    
    Let decimal_part be Parse decimal_value as Integer
    Let hex_digits be Empty List[String]
    Let working_value be decimal_part
    
    If working_value is equal to 0:
        Set result.converted_representation to "0"
        Set result.digit_count to 1
        Return result
    
    While working_value is greater than 0:
        Let remainder be working_value modulo 16
        Add digit_set[remainder] to hex_digits at beginning
        Set working_value to working_value divided by 16
    
    Let hex_string be ""
    For Each digit in hex_digits:
        Set hex_string to hex_string joined with digit
    
    Set result.converted_representation to hex_string
    Set result.digit_count to Length(hex_digits)
    Return result

Process called "hexadecimal_to_decimal" that takes hex_value as String returns BaseConversionResult:
    Note: Convert hexadecimal representation to decimal number
    Let result be BaseConversionResult
    Set result.original_base to 16
    Set result.target_base to 10
    Set result.original_representation to hex_value
    Set result.conversion_algorithm to "positional_notation_expansion"
    
    Let decimal_value be 0
    Let hex_length be Length(hex_value)
    
    For i from 0 to hex_length minus 1:
        Let digit_char be hex_value[hex_length minus 1 minus i]
        Let digit_value be 0
        
        If digit_char is equal to "0":
            Set digit_value to 0
        Otherwise if digit_char is equal to "1":
            Set digit_value to 1
        Otherwise if digit_char is equal to "2":
            Set digit_value to 2
        Otherwise if digit_char is equal to "3":
            Set digit_value to 3
        Otherwise if digit_char is equal to "4":
            Set digit_value to 4
        Otherwise if digit_char is equal to "5":
            Set digit_value to 5
        Otherwise if digit_char is equal to "6":
            Set digit_value to 6
        Otherwise if digit_char is equal to "7":
            Set digit_value to 7
        Otherwise if digit_char is equal to "8":
            Set digit_value to 8
        Otherwise if digit_char is equal to "9":
            Set digit_value to 9
        Otherwise if digit_char is equal to "a" or digit_char is equal to "A":
            Set digit_value to 10
        Otherwise if digit_char is equal to "b" or digit_char is equal to "B":
            Set digit_value to 11
        Otherwise if digit_char is equal to "c" or digit_char is equal to "C":
            Set digit_value to 12
        Otherwise if digit_char is equal to "d" or digit_char is equal to "D":
            Set digit_value to 13
        Otherwise if digit_char is equal to "e" or digit_char is equal to "E":
            Set digit_value to 14
        Otherwise if digit_char is equal to "f" or digit_char is equal to "F":
            Set digit_value to 15
        Otherwise:
            Throw Errors.InvalidOperation with "Invalid hexadecimal digit: " joined with digit_char
        
        Let power_of_sixteen be 1
        For j from 1 to i:
            Set power_of_sixteen to power_of_sixteen multiplied by 16
        Set decimal_value to decimal_value plus (digit_value multiplied by power_of_sixteen)
    
    Set result.converted_representation to String(decimal_value)
    Set result.digit_count to Length(String(decimal_value))
    Return result

Process called "decimal_to_octal" that takes decimal_value as String returns BaseConversionResult:
    Note: Convert decimal number to octal representation
    Let result be BaseConversionResult
    Set result.original_base to 10
    Set result.target_base to 8
    Set result.original_representation to decimal_value
    Set result.conversion_algorithm to "repeated_division_by_8"
    
    Let decimal_part be Parse decimal_value as Integer
    Let octal_digits be Empty List[String]
    Let working_value be decimal_part
    
    If working_value is equal to 0:
        Set result.converted_representation to "0"
        Set result.digit_count to 1
        Return result
    
    While working_value is greater than 0:
        Let remainder be working_value modulo 8
        Add String(remainder) to octal_digits at beginning
        Set working_value to working_value divided by 8
    
    Let octal_string be ""
    For Each digit in octal_digits:
        Set octal_string to octal_string joined with digit
    
    Set result.converted_representation to octal_string
    Set result.digit_count to Length(octal_digits)
    Return result

Process called "convert_arbitrary_base" that takes value as String, from_base as Integer, to_base as Integer, precision as Integer returns BaseConversionResult:
    Note: Convert between arbitrary number bases (2-36)
    Let result be BaseConversionResult
    Set result.original_base to from_base
    Set result.target_base to to_base
    Set result.original_representation to value
    Set result.conversion_algorithm to "arbitrary_base_conversion"
    
    If from_base is less than 2 or from_base is greater than 36:
        Throw Errors.InvalidOperation with "Source base must be between 2 and 36, got: " joined with String(from_base)
    
    If to_base is less than 2 or to_base is greater than 36:
        Throw Errors.InvalidOperation with "Target base must be between 2 and 36, got: " joined with String(to_base)
    
    Let digit_chars be "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    
    Let decimal_value be 0
    Let value_length be Length(value)
    
    For i from 0 to value_length minus 1:
        Let digit_char be value[value_length minus 1 minus i]
        Let digit_value be 0
        
        For j from 0 to 35:
            If digit_chars[j] is equal to digit_char or digit_chars[j] is equal to uppercase(digit_char):
                Set digit_value to j
                Break
        
        If digit_value is greater than or equal to from_base:
            Throw Errors.InvalidOperation with "Invalid digit for base " joined with String(from_base) joined with ": " joined with digit_char
        
        Let power_value be 1
        For k from 1 to i:
            Set power_value to power_value multiplied by from_base
        Set decimal_value to decimal_value plus (digit_value multiplied by power_value)
    
    If to_base is equal to 10:
        Set result.converted_representation to String(decimal_value)
        Set result.digit_count to Length(String(decimal_value))
        Return result
    
    Let target_digits be Empty List[String]
    Let working_value be decimal_value
    
    If working_value is equal to 0:
        Set result.converted_representation to "0"
        Set result.digit_count to 1
        Return result
    
    While working_value is greater than 0:
        Let remainder be working_value modulo to_base
        Add String(digit_chars[remainder]) to target_digits at beginning
        Set working_value to working_value divided by to_base
    
    Let target_string be ""
    For Each digit in target_digits:
        Set target_string to target_string joined with digit
    
    Set result.converted_representation to target_string
    Set result.digit_count to Length(target_digits)
    Return result

Process called "convert_with_custom_digits" that takes value as String, from_digits as String, to_digits as String returns BaseConversionResult:
    Note: Convert using custom digit sets (e.g., Roman numerals)
    Let result be BaseConversionResult
    Set result.original_base to Length(from_digits)
    Set result.target_base to Length(to_digits)
    Set result.original_representation to value
    Set result.conversion_algorithm to "custom_digit_mapping"
    
    Let from_base be Length(from_digits)
    Let to_base be Length(to_digits)
    
    Let decimal_value be 0
    Let value_length be Length(value)
    
    For i from 0 to value_length minus 1:
        Let digit_char be value[value_length minus 1 minus i]
        Let digit_value be -1
        
        For j from 0 to from_base minus 1:
            If from_digits[j] is equal to digit_char:
                Set digit_value to j
                Break
        
        If digit_value is equal to -1:
            Throw Errors.InvalidOperation with "Invalid digit in source alphabet: " joined with digit_char
        
        Let power_value be 1
        For k from 1 to i:
            Set power_value to power_value multiplied by from_base
        Set decimal_value to decimal_value plus (digit_value multiplied by power_value)
    
    Let target_digits be Empty List[String]
    Let working_value be decimal_value
    
    If working_value is equal to 0:
        Set result.converted_representation to String(to_digits[0])
        Set result.digit_count to 1
        Return result
    
    While working_value is greater than 0:
        Let remainder be working_value modulo to_base
        Add String(to_digits[remainder]) to target_digits at beginning
        Set working_value to working_value divided by to_base
    
    Let target_string be ""
    For Each digit in target_digits:
        Set target_string to target_string joined with digit
    
    Set result.converted_representation to target_string
    Set result.digit_count to Length(target_digits)
    Return result

Note: =====================================================================
Note: TEMPERATURE CONVERSION OPERATIONS
Note: =====================================================================

Process called "celsius_to_fahrenheit" that takes celsius as String, precision as Integer returns ConversionResult:
    Note: Convert Celsius to Fahrenheit temperature
    Let result be ConversionResult
    Set result.original_value to celsius
    Set result.from_unit to "celsius"
    Set result.to_unit to "fahrenheit"
    Set result.precision_retained to precision
    Set result.conversion_method to "celsius_to_fahrenheit_formula"
    
    Let celsius_times_9 be BigDecimal.multiply_high_precision(celsius, "9", precision plus 2)
    Let celsius_times_9_div_5 be BigDecimal.divide_high_precision(celsius_times_9, "5", precision plus 1)
    Let fahrenheit be BigDecimal.add_high_precision(celsius_times_9_div_5, "32", precision)
    
    Set result.converted_value to fahrenheit
    Set result.conversion_factor to "9/5"
    Set result.accuracy_estimate to 1.0
    Return result

Process called "fahrenheit_to_celsius" that takes fahrenheit as String, precision as Integer returns ConversionResult:
    Note: Convert Fahrenheit to Celsius temperature
    Let result be ConversionResult
    Set result.original_value to fahrenheit
    Set result.from_unit to "fahrenheit"
    Set result.to_unit to "celsius"
    Set result.precision_retained to precision
    Set result.conversion_method to "fahrenheit_to_celsius_formula"
    
    Let fahrenheit_minus_32 be BigDecimal.subtract_high_precision(fahrenheit, "32", precision plus 2)
    Let celsius be BigDecimal.multiply_high_precision(fahrenheit_minus_32, "5", precision plus 1)
    Set celsius to BigDecimal.divide_high_precision(celsius, "9", precision)
    
    Set result.converted_value to celsius
    Set result.conversion_factor to "5/9"
    Set result.accuracy_estimate to 1.0
    Return result

Process called "celsius_to_kelvin" that takes celsius as String, precision as Integer returns ConversionResult:
    Note: Convert Celsius to Kelvin (absolute temperature)
    Let result be ConversionResult
    Set result.original_value to celsius
    Set result.from_unit to "celsius"
    Set result.to_unit to "kelvin"
    Set result.precision_retained to precision
    Set result.conversion_method to "celsius_to_kelvin_offset"
    
    Let kelvin be BigDecimal.add_high_precision(celsius, "273.15", precision)
    
    Set result.converted_value to kelvin
    Set result.conversion_factor to "1"
    Set result.accuracy_estimate to 1.0
    Return result

Process called "kelvin_to_celsius" that takes kelvin as String, precision as Integer returns ConversionResult:
    Note: Convert Kelvin to Celsius temperature
    Let result be ConversionResult
    Set result.original_value to kelvin
    Set result.from_unit to "kelvin"
    Set result.to_unit to "celsius"
    Set result.precision_retained to precision
    Set result.conversion_method to "kelvin_to_celsius_offset"
    
    Let celsius be BigDecimal.subtract_high_precision(kelvin, "273.15", precision)
    
    Set result.converted_value to celsius
    Set result.conversion_factor to "1"
    Set result.accuracy_estimate to 1.0
    Return result

Process called "fahrenheit_to_rankine" that takes fahrenheit as String, precision as Integer returns ConversionResult:
    Note: Convert Fahrenheit to Rankine (absolute temperature)
    Let result be ConversionResult
    Set result.original_value to fahrenheit
    Set result.from_unit to "fahrenheit"
    Set result.to_unit to "rankine"
    Set result.precision_retained to precision
    Set result.conversion_method to "fahrenheit_to_rankine_offset"
    
    Let rankine be BigDecimal.add_high_precision(fahrenheit, "459.67", precision)
    
    Set result.converted_value to rankine
    Set result.conversion_factor to "1"
    Set result.accuracy_estimate to 1.0
    Return result

Process called "convert_temperature_scale" that takes temperature as String, from_scale as String, to_scale as String, precision as Integer returns ConversionResult:
    Note: Convert between any temperature scales with validation
    
    If from_scale is equal to to_scale:
        Let result be ConversionResult
        Set result.original_value to temperature
        Set result.converted_value to temperature
        Set result.from_unit to from_scale
        Set result.to_unit to to_scale
        Set result.precision_retained to precision
        Set result.conversion_method to "identity_no_conversion"
        Set result.conversion_factor to "1"
        Set result.accuracy_estimate to 1.0
        Return result
    
    If from_scale is equal to "celsius" and to_scale is equal to "fahrenheit":
        Return celsius_to_fahrenheit(temperature, precision)
    Otherwise if from_scale is equal to "fahrenheit" and to_scale is equal to "celsius":
        Return fahrenheit_to_celsius(temperature, precision)
    Otherwise if from_scale is equal to "celsius" and to_scale is equal to "kelvin":
        Return celsius_to_kelvin(temperature, precision)
    Otherwise if from_scale is equal to "kelvin" and to_scale is equal to "celsius":
        Return kelvin_to_celsius(temperature, precision)
    Otherwise if from_scale is equal to "fahrenheit" and to_scale is equal to "rankine":
        Return fahrenheit_to_rankine(temperature, precision)
    
    Otherwise if from_scale is equal to "rankine" and to_scale is equal to "fahrenheit":
        Let result be ConversionResult
        Set result.original_value to temperature
        Set result.from_unit to "rankine"
        Set result.to_unit to "fahrenheit"
        Set result.precision_retained to precision
        Set result.conversion_method to "rankine_to_fahrenheit_offset"
        Let fahrenheit be BigDecimal.subtract_high_precision(temperature, "459.67", precision)
        Set result.converted_value to fahrenheit
        Set result.conversion_factor to "1"
        Set result.accuracy_estimate to 1.0
        Return result
    
    Otherwise if from_scale is equal to "fahrenheit" and to_scale is equal to "kelvin":
        Let celsius_result be fahrenheit_to_celsius(temperature, precision plus 2)
        Return celsius_to_kelvin(celsius_result.converted_value, precision)
    Otherwise if from_scale is equal to "kelvin" and to_scale is equal to "fahrenheit":
        Let celsius_result be kelvin_to_celsius(temperature, precision plus 2)
        Return celsius_to_fahrenheit(celsius_result.converted_value, precision)
    
    Otherwise if from_scale is equal to "celsius" and to_scale is equal to "rankine":
        Let fahrenheit_result be celsius_to_fahrenheit(temperature, precision plus 2)
        Return fahrenheit_to_rankine(fahrenheit_result.converted_value, precision)
    Otherwise if from_scale is equal to "rankine" and to_scale is equal to "celsius":
        Let fahrenheit_value be BigDecimal.subtract_high_precision(temperature, "459.67", precision plus 2)
        Return fahrenheit_to_celsius(fahrenheit_value, precision)
    
    Otherwise if from_scale is equal to "kelvin" and to_scale is equal to "rankine":
        Let celsius_result be kelvin_to_celsius(temperature, precision plus 2)
        Let fahrenheit_result be celsius_to_fahrenheit(celsius_result.converted_value, precision plus 2)
        Return fahrenheit_to_rankine(fahrenheit_result.converted_value, precision)
    Otherwise if from_scale is equal to "rankine" and to_scale is equal to "kelvin":
        Let fahrenheit_value be BigDecimal.subtract_high_precision(temperature, "459.67", precision plus 2)
        Let celsius_result be fahrenheit_to_celsius(fahrenheit_value, precision plus 2)
        Return celsius_to_kelvin(celsius_result.converted_value, precision)
    
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported temperature conversion from " joined with from_scale joined with " to " joined with to_scale

Note: =====================================================================
Note: COORDINATE SYSTEM CONVERSION OPERATIONS
Note: =====================================================================

Process called "cartesian_to_polar" that takes x as String, y as String, precision as Integer returns Dictionary[String, String]:
    Note: Convert 2D Cartesian coordinates to polar coordinates
    Let result be Dictionary[String, String]
    
    Let x_squared be BigDecimal.multiply_high_precision(x, x, precision plus 2)
    Let y_squared be BigDecimal.multiply_high_precision(y, y, precision plus 2)
    Let radius_squared be BigDecimal.add_high_precision(x_squared, y_squared, precision plus 2)
    Let radius be Operations.square_root(radius_squared, precision)
    
    Let angle_radians be ""
    If BigDecimal.compare_high_precision(x, "0") is equal to 0:
        If BigDecimal.compare_high_precision(y, "0") is greater than 0:
            Let pi_val be Constants.get_pi_with_precision(precision)
            Set angle_radians to BigDecimal.divide_high_precision(pi_val.result_value, "2", precision)
        Otherwise if BigDecimal.compare_high_precision(y, "0") is less than 0:
            Let pi_val be Constants.get_pi_with_precision(precision)
            Let pi_half be BigDecimal.divide_high_precision(pi_val.result_value, "2", precision plus 1)
            Set angle_radians to BigDecimal.multiply_high_precision("-1", pi_half, precision)
        Otherwise:
            Set angle_radians to "0"
    Otherwise:
        Let atan_result be Trigonometry.arctangent(BigDecimal.divide_high_precision(y, x, precision plus 2), precision, "radians")
        Set angle_radians to atan_result.result_value
        
        If BigDecimal.compare_high_precision(x, "0") is less than 0:
            Let pi_val be Constants.get_pi_with_precision(precision)
            If BigDecimal.compare_high_precision(y, "0") is greater than or equal to 0:
                Set angle_radians to BigDecimal.add_high_precision(angle_radians, pi_val.result_value, precision)
            Otherwise:
                Set angle_radians to BigDecimal.subtract_high_precision(angle_radians, pi_val.result_value, precision)
    
    Set result."radius" to radius.result_value
    Set result."angle_radians" to angle_radians
    Set result."angle_degrees" to radians_to_degrees(angle_radians, precision)
    Set result."x_original" to x
    Set result."y_original" to y
    Return result

Process called "polar_to_cartesian" that takes radius as String, angle as String, angle_unit as String, precision as Integer returns Dictionary[String, String]:
    Note: Convert polar coordinates to 2D Cartesian coordinates
    Let result be Dictionary[String, String]
    
    Let angle_radians be angle
    If angle_unit is equal to "degrees":
        Set angle_radians to degrees_to_radians(angle, precision plus 2)
    Otherwise if angle_unit is equal to "gradians":
        Set angle_radians to gradians_to_radians(angle, precision plus 2)
    Otherwise if angle_unit is equal to "turns":
        Set angle_radians to turns_to_radians(angle, precision plus 2)
    
    Let cos_result be Trigonometry.cosine(angle_radians, "radians", precision plus 1)
    Let sin_result be Trigonometry.sine(angle_radians, "radians", precision plus 1)
    
    Let x be BigDecimal.multiply_high_precision(radius, cos_result.result_value, precision)
    Let y be BigDecimal.multiply_high_precision(radius, sin_result.result_value, precision)
    
    Set result."x" to x
    Set result."y" to y
    Set result."radius_original" to radius
    Set result."angle_original" to angle
    Set result."angle_unit_original" to angle_unit
    Return result

Process called "cartesian_to_spherical" that takes x as String, y as String, z as String, precision as Integer returns Dictionary[String, String]:
    Note: Convert 3D Cartesian to spherical coordinates (r, θ, φ)
    Let result be Dictionary[String, String]
    
    Let x_squared be BigDecimal.multiply_high_precision(x, x, precision plus 3)
    Let y_squared be BigDecimal.multiply_high_precision(y, y, precision plus 3)
    Let z_squared be BigDecimal.multiply_high_precision(z, z, precision plus 3)
    Let xy_sum be BigDecimal.add_high_precision(x_squared, y_squared, precision plus 3)
    Let radius_squared be BigDecimal.add_high_precision(xy_sum, z_squared, precision plus 2)
    
    Let radius be Operations.square_root(radius_squared, precision)
    
    Let rho_squared be BigDecimal.add_high_precision(x_squared, y_squared, precision plus 2)
    Let rho be Operations.square_root(rho_squared, precision plus 1)
    
    Let theta_radians be ""
    If BigDecimal.compare_high_precision(x, "0") is equal to 0:
        If BigDecimal.compare_high_precision(y, "0") is greater than 0:
            Let pi_val be Constants.get_pi_with_precision(precision)
            Set theta_radians to BigDecimal.divide_high_precision(pi_val.result_value, "2", precision)
        Otherwise if BigDecimal.compare_high_precision(y, "0") is less than 0:
            Let pi_val be Constants.get_pi_with_precision(precision)
            Let pi_half be BigDecimal.divide_high_precision(pi_val.result_value, "2", precision plus 1)
            Set theta_radians to BigDecimal.multiply_high_precision("-1", pi_half, precision)
        Otherwise:
            Set theta_radians to "0"
    Otherwise:
        Let atan_result be Trigonometry.arctangent(BigDecimal.divide_high_precision(y, x, precision plus 2), precision, "radians")
        Set theta_radians to atan_result.result_value
        
        If BigDecimal.compare_high_precision(x, "0") is less than 0:
            Let pi_val be Constants.get_pi_with_precision(precision)
            If BigDecimal.compare_high_precision(y, "0") is greater than or equal to 0:
                Set theta_radians to BigDecimal.add_high_precision(theta_radians, pi_val.result_value, precision)
            Otherwise:
                Set theta_radians to BigDecimal.subtract_high_precision(theta_radians, pi_val.result_value, precision)
    
    Let phi_radians be ""
    If BigDecimal.compare_high_precision(radius.result_value, "0") is equal to 0:
        Set phi_radians to "0"
    Otherwise:
        Let acos_arg be BigDecimal.divide_high_precision(z, radius.result_value, precision plus 2)
        Let phi_result be Trigonometry.arccosine(acos_arg, precision, "radians")
        Set phi_radians to phi_result.result_value
    
    Set result."radius" to radius.result_value
    Set result."theta_radians" to theta_radians
    Set result."phi_radians" to phi_radians
    Set result."theta_degrees" to radians_to_degrees(theta_radians, precision)
    Set result."phi_degrees" to radians_to_degrees(phi_radians, precision)
    Set result."x_original" to x
    Set result."y_original" to y
    Set result."z_original" to z
    Return result

Process called "spherical_to_cartesian" that takes radius as String, theta as String, phi as String, angle_unit as String, precision as Integer returns Dictionary[String, String]:
    Note: Convert spherical coordinates to 3D Cartesian coordinates
    Let result be Dictionary[String, String]
    
    Let theta_radians be theta
    Let phi_radians be phi
    
    If angle_unit is equal to "degrees":
        Set theta_radians to degrees_to_radians(theta, precision plus 2)
        Set phi_radians to degrees_to_radians(phi, precision plus 2)
    Otherwise if angle_unit is equal to "gradians":
        Set theta_radians to gradians_to_radians(theta, precision plus 2)
        Set phi_radians to gradians_to_radians(phi, precision plus 2)
    Otherwise if angle_unit is equal to "turns":
        Set theta_radians to turns_to_radians(theta, precision plus 2)
        Set phi_radians to turns_to_radians(phi, precision plus 2)
    
    Let cos_theta be Trigonometry.cosine(theta_radians, "radians", precision plus 2)
    Let sin_theta be Trigonometry.sine(theta_radians, "radians", precision plus 2)
    Let cos_phi be Trigonometry.cosine(phi_radians, "radians", precision plus 2)
    Let sin_phi be Trigonometry.sine(phi_radians, "radians", precision plus 2)
    
    Let r_sin_phi be BigDecimal.multiply_high_precision(radius, sin_phi.result_value, precision plus 1)
    Let x be BigDecimal.multiply_high_precision(r_sin_phi, cos_theta.result_value, precision)
    Let y be BigDecimal.multiply_high_precision(r_sin_phi, sin_theta.result_value, precision)
    Let z be BigDecimal.multiply_high_precision(radius, cos_phi.result_value, precision)
    
    Set result."x" to x
    Set result."y" to y
    Set result."z" to z
    Set result."radius_original" to radius
    Set result."theta_original" to theta
    Set result."phi_original" to phi
    Set result."angle_unit_original" to angle_unit
    Return result

Process called "cartesian_to_cylindrical" that takes x as String, y as String, z as String, precision as Integer returns Dictionary[String, String]:
    Note: Convert 3D Cartesian to cylindrical coordinates (ρ, φ, z)
    Let result be Dictionary[String, String]
    
    Let polar_result be cartesian_to_polar(x, y, precision)
    Let rho be polar_result."radius"
    Let phi_radians be polar_result."angle_radians"
    
    Set result."rho" to rho
    Set result."phi_radians" to phi_radians
    Set result."phi_degrees" to radians_to_degrees(phi_radians, precision)
    Set result."z" to z
    Set result."x_original" to x
    Set result."y_original" to y
    Set result."z_original" to z
    Return result

Process called "cylindrical_to_cartesian" that takes rho as String, phi as String, z as String, angle_unit as String, precision as Integer returns Dictionary[String, String]:
    Note: Convert cylindrical coordinates to 3D Cartesian coordinates
    Let result be Dictionary[String, String]
    
    Let cartesian_result be polar_to_cartesian(rho, phi, angle_unit, precision)
    Let x be cartesian_result."x"
    Let y be cartesian_result."y"
    
    Set result."x" to x
    Set result."y" to y
    Set result."z" to z
    Set result."rho_original" to rho
    Set result."phi_original" to phi
    Set result."z_original" to z
    Set result."angle_unit_original" to angle_unit
    Return result

Process called "transform_coordinate_system" that takes coordinates as List[String], from_system as CoordinateSystem, to_system as CoordinateSystem returns List[String]:
    Note: Transform coordinates between arbitrary coordinate systems
    Let result be Empty List[String]
    Let working_precision be 50
    
    If from_system.system_name is equal to to_system.system_name:
        For Each coord in coordinates:
            Add coord to result
        Return result
    
    If from_system.system_name is equal to "cartesian_2d" and to_system.system_name is equal to "polar_2d":
        If Length(coordinates) is less than 2:
            Throw Errors.InvalidOperation with "Cartesian 2D requires at least 2 coordinates"
        Let polar_result be cartesian_to_polar(coordinates[0], coordinates[1], working_precision)
        Add polar_result."radius" to result
        Add polar_result."angle_radians" to result
        Return result
    
    Otherwise if from_system.system_name is equal to "polar_2d" and to_system.system_name is equal to "cartesian_2d":
        If Length(coordinates) is less than 2:
            Throw Errors.InvalidOperation with "Polar 2D requires at least 2 coordinates"
        Let cartesian_result be polar_to_cartesian(coordinates[0], coordinates[1], "radians", working_precision)
        Add cartesian_result."x" to result
        Add cartesian_result."y" to result
        Return result
    
    Otherwise if from_system.system_name is equal to "cartesian_3d" and to_system.system_name is equal to "spherical_3d":
        If Length(coordinates) is less than 3:
            Throw Errors.InvalidOperation with "Cartesian 3D requires at least 3 coordinates"
        Let spherical_result be cartesian_to_spherical(coordinates[0], coordinates[1], coordinates[2], working_precision)
        Add spherical_result."radius" to result
        Add spherical_result."theta_radians" to result
        Add spherical_result."phi_radians" to result
        Return result
    
    Otherwise if from_system.system_name is equal to "spherical_3d" and to_system.system_name is equal to "cartesian_3d":
        If Length(coordinates) is less than 3:
            Throw Errors.InvalidOperation with "Spherical 3D requires at least 3 coordinates"
        Let cartesian_result be spherical_to_cartesian(coordinates[0], coordinates[1], coordinates[2], "radians", working_precision)
        Add cartesian_result."x" to result
        Add cartesian_result."y" to result
        Add cartesian_result."z" to result
        Return result
    
    Otherwise if from_system.system_name is equal to "cartesian_3d" and to_system.system_name is equal to "cylindrical_3d":
        If Length(coordinates) is less than 3:
            Throw Errors.InvalidOperation with "Cartesian 3D requires at least 3 coordinates"
        Let cylindrical_result be cartesian_to_cylindrical(coordinates[0], coordinates[1], coordinates[2], working_precision)
        Add cylindrical_result."rho" to result
        Add cylindrical_result."phi_radians" to result
        Add cylindrical_result."z" to result
        Return result
    
    Otherwise if from_system.system_name is equal to "cylindrical_3d" and to_system.system_name is equal to "cartesian_3d":
        If Length(coordinates) is less than 3:
            Throw Errors.InvalidOperation with "Cylindrical 3D requires at least 3 coordinates"
        Let cartesian_result be cylindrical_to_cartesian(coordinates[0], coordinates[1], coordinates[2], "radians", working_precision)
        Add cartesian_result."x" to result
        Add cartesian_result."y" to result
        Add cartesian_result."z" to result
        Return result
    
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported coordinate transformation from " joined with from_system.system_name joined with " to " joined with to_system.system_name

Note: =====================================================================
Note: PHYSICAL UNIT CONVERSION OPERATIONS
Note: =====================================================================

Process called "convert_length_units" that takes length as String, from_unit as String, to_unit as String, precision as Integer returns ConversionResult:
    Note: Convert between length units (meters, feet, inches, kilometers, etc.)
    Let result be ConversionResult
    Set result.original_value to length
    Set result.from_unit to from_unit
    Set result.to_unit to to_unit
    Set result.precision_retained to precision
    Set result.conversion_method to "length_unit_conversion"
    
    Let meters_value be length
    
    If from_unit is equal to "millimeters" or from_unit is equal to "mm":
        Set meters_value to BigDecimal.divide_high_precision(length, "1000", precision plus 2)
    Otherwise if from_unit is equal to "centimeters" or from_unit is equal to "cm":
        Set meters_value to BigDecimal.divide_high_precision(length, "100", precision plus 2)
    Otherwise if from_unit is equal to "kilometers" or from_unit is equal to "km":
        Set meters_value to BigDecimal.multiply_high_precision(length, "1000", precision plus 2)
    Otherwise if from_unit is equal to "inches" or from_unit is equal to "in":
        Set meters_value to BigDecimal.multiply_high_precision(length, "0.0254", precision plus 2)
    Otherwise if from_unit is equal to "feet" or from_unit is equal to "ft":
        Set meters_value to BigDecimal.multiply_high_precision(length, "0.3048", precision plus 2)
    Otherwise if from_unit is equal to "yards" or from_unit is equal to "yd":
        Set meters_value to BigDecimal.multiply_high_precision(length, "0.9144", precision plus 2)
    Otherwise if from_unit is equal to "miles" or from_unit is equal to "mi":
        Set meters_value to BigDecimal.multiply_high_precision(length, "1609.344", precision plus 2)
    Otherwise if from_unit not is equal to "meters" and from_unit not is equal to "m":
        Throw Errors.InvalidOperation with "Unsupported source length unit: " joined with from_unit
    
    Let converted_value be meters_value
    
    If to_unit is equal to "millimeters" or to_unit is equal to "mm":
        Set converted_value to BigDecimal.multiply_high_precision(meters_value, "1000", precision)
        Set result.conversion_factor to "1000"
    Otherwise if to_unit is equal to "centimeters" or to_unit is equal to "cm":
        Set converted_value to BigDecimal.multiply_high_precision(meters_value, "100", precision)
        Set result.conversion_factor to "100"
    Otherwise if to_unit is equal to "kilometers" or to_unit is equal to "km":
        Set converted_value to BigDecimal.divide_high_precision(meters_value, "1000", precision)
        Set result.conversion_factor to "0.001"
    Otherwise if to_unit is equal to "inches" or to_unit is equal to "in":
        Set converted_value to BigDecimal.divide_high_precision(meters_value, "0.0254", precision)
        Set result.conversion_factor to "39.3701"
    Otherwise if to_unit is equal to "feet" or to_unit is equal to "ft":
        Set converted_value to BigDecimal.divide_high_precision(meters_value, "0.3048", precision)
        Set result.conversion_factor to "3.28084"
    Otherwise if to_unit is equal to "yards" or to_unit is equal to "yd":
        Set converted_value to BigDecimal.divide_high_precision(meters_value, "0.9144", precision)
        Set result.conversion_factor to "1.09361"
    Otherwise if to_unit is equal to "miles" or to_unit is equal to "mi":
        Set converted_value to BigDecimal.divide_high_precision(meters_value, "1609.344", precision)
        Set result.conversion_factor to "0.000621371"
    Otherwise if to_unit is equal to "meters" or to_unit is equal to "m":
        Set result.conversion_factor to "1"
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported target length unit: " joined with to_unit
    
    Set result.converted_value to converted_value
    Set result.accuracy_estimate to 1.0
    Return result

Process called "convert_mass_units" that takes mass as String, from_unit as String, to_unit as String, precision as Integer returns ConversionResult:
    Note: Convert between mass units (kilograms, pounds, ounces, tons, etc.)
    Let result be ConversionResult
    Set result.original_value to mass
    Set result.from_unit to from_unit
    Set result.to_unit to to_unit
    Set result.precision_retained to precision
    Set result.conversion_method to "mass_unit_conversion"
    
    Let kilograms_value be mass
    
    If from_unit is equal to "grams" or from_unit is equal to "g":
        Set kilograms_value to BigDecimal.divide_high_precision(mass, "1000", precision plus 2)
    Otherwise if from_unit is equal to "milligrams" or from_unit is equal to "mg":
        Set kilograms_value to BigDecimal.divide_high_precision(mass, "1000000", precision plus 2)
    Otherwise if from_unit is equal to "tons" or from_unit is equal to "t":
        Set kilograms_value to BigDecimal.multiply_high_precision(mass, "1000", precision plus 2)
    Otherwise if from_unit is equal to "pounds" or from_unit is equal to "lb" or from_unit is equal to "lbs":
        Set kilograms_value to BigDecimal.multiply_high_precision(mass, "0.453592", precision plus 2)
    Otherwise if from_unit is equal to "ounces" or from_unit is equal to "oz":
        Set kilograms_value to BigDecimal.multiply_high_precision(mass, "0.0283495", precision plus 2)
    Otherwise if from_unit is equal to "stones" or from_unit is equal to "st":
        Set kilograms_value to BigDecimal.multiply_high_precision(mass, "6.35029", precision plus 2)
    Otherwise if from_unit not is equal to "kilograms" and from_unit not is equal to "kg":
        Throw Errors.InvalidOperation with "Unsupported source mass unit: " joined with from_unit
    
    Let converted_value be kilograms_value
    
    If to_unit is equal to "grams" or to_unit is equal to "g":
        Set converted_value to BigDecimal.multiply_high_precision(kilograms_value, "1000", precision)
        Set result.conversion_factor to "1000"
    Otherwise if to_unit is equal to "milligrams" or to_unit is equal to "mg":
        Set converted_value to BigDecimal.multiply_high_precision(kilograms_value, "1000000", precision)
        Set result.conversion_factor to "1000000"
    Otherwise if to_unit is equal to "tons" or to_unit is equal to "t":
        Set converted_value to BigDecimal.divide_high_precision(kilograms_value, "1000", precision)
        Set result.conversion_factor to "0.001"
    Otherwise if to_unit is equal to "pounds" or to_unit is equal to "lb" or to_unit is equal to "lbs":
        Set converted_value to BigDecimal.divide_high_precision(kilograms_value, "0.453592", precision)
        Set result.conversion_factor to "2.20462"
    Otherwise if to_unit is equal to "ounces" or to_unit is equal to "oz":
        Set converted_value to BigDecimal.divide_high_precision(kilograms_value, "0.0283495", precision)
        Set result.conversion_factor to "35.274"
    Otherwise if to_unit is equal to "stones" or to_unit is equal to "st":
        Set converted_value to BigDecimal.divide_high_precision(kilograms_value, "6.35029", precision)
        Set result.conversion_factor to "0.157473"
    Otherwise if to_unit is equal to "kilograms" or to_unit is equal to "kg":
        Set result.conversion_factor to "1"
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported target mass unit: " joined with to_unit
    
    Set result.converted_value to converted_value
    Set result.accuracy_estimate to 1.0
    Return result

Process called "convert_volume_units" that takes volume as String, from_unit as String, to_unit as String, precision as Integer returns ConversionResult:
    Note: Convert between volume units (liters, gallons, cubic meters, etc.)
    Let result be ConversionResult
    Set result.original_value to volume
    Set result.from_unit to from_unit
    Set result.to_unit to to_unit
    Set result.precision_retained to precision
    Set result.conversion_method to "volume_unit_conversion"
    
    Let liters_value be volume
    
    If from_unit is equal to "milliliters" or from_unit is equal to "ml":
        Set liters_value to BigDecimal.divide_high_precision(volume, "1000", precision plus 2)
    Otherwise if from_unit is equal to "cubic_meters" or from_unit is equal to "m3":
        Set liters_value to BigDecimal.multiply_high_precision(volume, "1000", precision plus 2)
    Otherwise if from_unit is equal to "cubic_centimeters" or from_unit is equal to "cm3" or from_unit is equal to "cc":
        Set liters_value to BigDecimal.divide_high_precision(volume, "1000", precision plus 2)
    Otherwise if from_unit is equal to "gallons_us" or from_unit is equal to "gal_us":
        Set liters_value to BigDecimal.multiply_high_precision(volume, "3.78541", precision plus 2)
    Otherwise if from_unit is equal to "gallons_imperial" or from_unit is equal to "gal_imp":
        Set liters_value to BigDecimal.multiply_high_precision(volume, "4.54609", precision plus 2)
    Otherwise if from_unit is equal to "quarts_us" or from_unit is equal to "qt_us":
        Set liters_value to BigDecimal.multiply_high_precision(volume, "0.946353", precision plus 2)
    Otherwise if from_unit is equal to "pints_us" or from_unit is equal to "pt_us":
        Set liters_value to BigDecimal.multiply_high_precision(volume, "0.473176", precision plus 2)
    Otherwise if from_unit is equal to "fluid_ounces_us" or from_unit is equal to "fl_oz_us":
        Set liters_value to BigDecimal.multiply_high_precision(volume, "0.0295735", precision plus 2)
    Otherwise if from_unit not is equal to "liters" and from_unit not is equal to "l":
        Throw Errors.InvalidOperation with "Unsupported source volume unit: " joined with from_unit
    
    Let converted_value be liters_value
    
    If to_unit is equal to "milliliters" or to_unit is equal to "ml":
        Set converted_value to BigDecimal.multiply_high_precision(liters_value, "1000", precision)
        Set result.conversion_factor to "1000"
    Otherwise if to_unit is equal to "cubic_meters" or to_unit is equal to "m3":
        Set converted_value to BigDecimal.divide_high_precision(liters_value, "1000", precision)
        Set result.conversion_factor to "0.001"
    Otherwise if to_unit is equal to "cubic_centimeters" or to_unit is equal to "cm3" or to_unit is equal to "cc":
        Set converted_value to BigDecimal.multiply_high_precision(liters_value, "1000", precision)
        Set result.conversion_factor to "1000"
    Otherwise if to_unit is equal to "gallons_us" or to_unit is equal to "gal_us":
        Set converted_value to BigDecimal.divide_high_precision(liters_value, "3.78541", precision)
        Set result.conversion_factor to "0.264172"
    Otherwise if to_unit is equal to "gallons_imperial" or to_unit is equal to "gal_imp":
        Set converted_value to BigDecimal.divide_high_precision(liters_value, "4.54609", precision)
        Set result.conversion_factor to "0.219969"
    Otherwise if to_unit is equal to "quarts_us" or to_unit is equal to "qt_us":
        Set converted_value to BigDecimal.divide_high_precision(liters_value, "0.946353", precision)
        Set result.conversion_factor to "1.05669"
    Otherwise if to_unit is equal to "pints_us" or to_unit is equal to "pt_us":
        Set converted_value to BigDecimal.divide_high_precision(liters_value, "0.473176", precision)
        Set result.conversion_factor to "2.11338"
    Otherwise if to_unit is equal to "fluid_ounces_us" or to_unit is equal to "fl_oz_us":
        Set converted_value to BigDecimal.divide_high_precision(liters_value, "0.0295735", precision)
        Set result.conversion_factor to "33.814"
    Otherwise if to_unit is equal to "liters" or to_unit is equal to "l":
        Set result.conversion_factor to "1"
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported target volume unit: " joined with to_unit
    
    Set result.converted_value to converted_value
    Set result.accuracy_estimate to 1.0
    Return result

Process called "convert_energy_units" that takes energy as String, from_unit as String, to_unit as String, precision as Integer returns ConversionResult:
    Note: Convert between energy units (joules, calories, BTU, kWh, etc.)
    Let result be ConversionResult
    Set result.original_value to energy
    Set result.from_unit to from_unit
    Set result.to_unit to to_unit
    Set result.precision_retained to precision
    Set result.conversion_method to "energy_unit_conversion"
    
    Let joules_value be energy
    
    If from_unit is equal to "kilojoules" or from_unit is equal to "kJ":
        Set joules_value to BigDecimal.multiply_high_precision(energy, "1000", precision plus 2)
    Otherwise if from_unit is equal to "calories" or from_unit is equal to "cal":
        Set joules_value to BigDecimal.multiply_high_precision(energy, "4.184", precision plus 2)
    Otherwise if from_unit is equal to "kilocalories" or from_unit is equal to "kcal":
        Set joules_value to BigDecimal.multiply_high_precision(energy, "4184", precision plus 2)
    Otherwise if from_unit is equal to "btu" or from_unit is equal to "BTU":
        Set joules_value to BigDecimal.multiply_high_precision(energy, "1055.06", precision plus 2)
    Otherwise if from_unit is equal to "kwh" or from_unit is equal to "kWh":
        Set joules_value to BigDecimal.multiply_high_precision(energy, "3600000", precision plus 2)
    Otherwise if from_unit is equal to "wh" or from_unit is equal to "Wh":
        Set joules_value to BigDecimal.multiply_high_precision(energy, "3600", precision plus 2)
    Otherwise if from_unit is equal to "foot_pounds" or from_unit is equal to "ft_lb":
        Set joules_value to BigDecimal.multiply_high_precision(energy, "1.35582", precision plus 2)
    Otherwise if from_unit not is equal to "joules" and from_unit not is equal to "J":
        Throw Errors.InvalidOperation with "Unsupported source energy unit: " joined with from_unit
    
    Let converted_value be joules_value
    
    If to_unit is equal to "kilojoules" or to_unit is equal to "kJ":
        Set converted_value to BigDecimal.divide_high_precision(joules_value, "1000", precision)
        Set result.conversion_factor to "0.001"
    Otherwise if to_unit is equal to "calories" or to_unit is equal to "cal":
        Set converted_value to BigDecimal.divide_high_precision(joules_value, "4.184", precision)
        Set result.conversion_factor to "0.239006"
    Otherwise if to_unit is equal to "kilocalories" or to_unit is equal to "kcal":
        Set converted_value to BigDecimal.divide_high_precision(joules_value, "4184", precision)
        Set result.conversion_factor to "0.000239006"
    Otherwise if to_unit is equal to "btu" or to_unit is equal to "BTU":
        Set converted_value to BigDecimal.divide_high_precision(joules_value, "1055.06", precision)
        Set result.conversion_factor to "0.000947817"
    Otherwise if to_unit is equal to "kwh" or to_unit is equal to "kWh":
        Set converted_value to BigDecimal.divide_high_precision(joules_value, "3600000", precision)
        Set result.conversion_factor to "2.77778e-7"
    Otherwise if to_unit is equal to "wh" or to_unit is equal to "Wh":
        Set converted_value to BigDecimal.divide_high_precision(joules_value, "3600", precision)
        Set result.conversion_factor to "0.000277778"
    Otherwise if to_unit is equal to "foot_pounds" or to_unit is equal to "ft_lb":
        Set converted_value to BigDecimal.divide_high_precision(joules_value, "1.35582", precision)
        Set result.conversion_factor to "0.737562"
    Otherwise if to_unit is equal to "joules" or to_unit is equal to "J":
        Set result.conversion_factor to "1"
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported target energy unit: " joined with to_unit
    
    Set result.converted_value to converted_value
    Set result.accuracy_estimate to 1.0
    Return result

Process called "convert_power_units" that takes power as String, from_unit as String, to_unit as String, precision as Integer returns ConversionResult:
    Note: Convert between power units (watts, horsepower, BTU/h, etc.)
    Let result be ConversionResult
    Set result.original_value to power
    Set result.from_unit to from_unit
    Set result.to_unit to to_unit
    Set result.precision_retained to precision
    Set result.conversion_method to "power_unit_conversion"
    
    Let watts_value be power
    
    If from_unit is equal to "kilowatts" or from_unit is equal to "kW":
        Set watts_value to BigDecimal.multiply_high_precision(power, "1000", precision plus 2)
    Otherwise if from_unit is equal to "megawatts" or from_unit is equal to "MW":
        Set watts_value to BigDecimal.multiply_high_precision(power, "1000000", precision plus 2)
    Otherwise if from_unit is equal to "horsepower" or from_unit is equal to "hp":
        Set watts_value to BigDecimal.multiply_high_precision(power, "745.7", precision plus 2)
    Otherwise if from_unit is equal to "metric_horsepower" or from_unit is equal to "hp_metric":
        Set watts_value to BigDecimal.multiply_high_precision(power, "735.5", precision plus 2)
    Otherwise if from_unit is equal to "btu_per_hour" or from_unit is equal to "BTU/h":
        Set watts_value to BigDecimal.multiply_high_precision(power, "0.293071", precision plus 2)
    Otherwise if from_unit is equal to "calories_per_second" or from_unit is equal to "cal/s":
        Set watts_value to BigDecimal.multiply_high_precision(power, "4.184", precision plus 2)
    Otherwise if from_unit is equal to "foot_pounds_per_second" or from_unit is equal to "ft_lb/s":
        Set watts_value to BigDecimal.multiply_high_precision(power, "1.35582", precision plus 2)
    Otherwise if from_unit not is equal to "watts" and from_unit not is equal to "W":
        Throw Errors.InvalidOperation with "Unsupported source power unit: " joined with from_unit
    
    Let converted_value be watts_value
    
    If to_unit is equal to "kilowatts" or to_unit is equal to "kW":
        Set converted_value to BigDecimal.divide_high_precision(watts_value, "1000", precision)
        Set result.conversion_factor to "0.001"
    Otherwise if to_unit is equal to "megawatts" or to_unit is equal to "MW":
        Set converted_value to BigDecimal.divide_high_precision(watts_value, "1000000", precision)
        Set result.conversion_factor to "0.000001"
    Otherwise if to_unit is equal to "horsepower" or to_unit is equal to "hp":
        Set converted_value to BigDecimal.divide_high_precision(watts_value, "745.7", precision)
        Set result.conversion_factor to "0.00134102"
    Otherwise if to_unit is equal to "metric_horsepower" or to_unit is equal to "hp_metric":
        Set converted_value to BigDecimal.divide_high_precision(watts_value, "735.5", precision)
        Set result.conversion_factor to "0.00135962"
    Otherwise if to_unit is equal to "btu_per_hour" or to_unit is equal to "BTU/h":
        Set converted_value to BigDecimal.divide_high_precision(watts_value, "0.293071", precision)
        Set result.conversion_factor to "3.41214"
    Otherwise if to_unit is equal to "calories_per_second" or to_unit is equal to "cal/s":
        Set converted_value to BigDecimal.divide_high_precision(watts_value, "4.184", precision)
        Set result.conversion_factor to "0.239006"
    Otherwise if to_unit is equal to "foot_pounds_per_second" or to_unit is equal to "ft_lb/s":
        Set converted_value to BigDecimal.divide_high_precision(watts_value, "1.35582", precision)
        Set result.conversion_factor to "0.737562"
    Otherwise if to_unit is equal to "watts" or to_unit is equal to "W":
        Set result.conversion_factor to "1"
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported target power unit: " joined with to_unit
    
    Set result.converted_value to converted_value
    Set result.accuracy_estimate to 1.0
    Return result

Process called "convert_pressure_units" that takes pressure as String, from_unit as String, to_unit as String, precision as Integer returns ConversionResult:
    Note: Convert between pressure units (pascals, psi, bar, atmospheres, etc.)
    Let result be ConversionResult
    Set result.original_value to pressure
    Set result.from_unit to from_unit
    Set result.to_unit to to_unit
    Set result.precision_retained to precision
    Set result.conversion_method to "pressure_unit_conversion"
    
    Let pascals_value be pressure
    
    If from_unit is equal to "kilopascals" or from_unit is equal to "kPa":
        Set pascals_value to BigDecimal.multiply_high_precision(pressure, "1000", precision plus 2)
    Otherwise if from_unit is equal to "megapascals" or from_unit is equal to "MPa":
        Set pascals_value to BigDecimal.multiply_high_precision(pressure, "1000000", precision plus 2)
    Otherwise if from_unit is equal to "bar":
        Set pascals_value to BigDecimal.multiply_high_precision(pressure, "100000", precision plus 2)
    Otherwise if from_unit is equal to "atmospheres" or from_unit is equal to "atm":
        Set pascals_value to BigDecimal.multiply_high_precision(pressure, "101325", precision plus 2)
    Otherwise if from_unit is equal to "psi":
        Set pascals_value to BigDecimal.multiply_high_precision(pressure, "6894.76", precision plus 2)
    Otherwise if from_unit is equal to "torr":
        Set pascals_value to BigDecimal.multiply_high_precision(pressure, "133.322", precision plus 2)
    Otherwise if from_unit is equal to "mmHg":
        Set pascals_value to BigDecimal.multiply_high_precision(pressure, "133.322", precision plus 2)
    Otherwise if from_unit is equal to "inHg":
        Set pascals_value to BigDecimal.multiply_high_precision(pressure, "3386.39", precision plus 2)
    Otherwise if from_unit not is equal to "pascals" and from_unit not is equal to "Pa":
        Throw Errors.InvalidOperation with "Unsupported source pressure unit: " joined with from_unit
    
    Let converted_value be pascals_value
    
    If to_unit is equal to "kilopascals" or to_unit is equal to "kPa":
        Set converted_value to BigDecimal.divide_high_precision(pascals_value, "1000", precision)
        Set result.conversion_factor to "0.001"
    Otherwise if to_unit is equal to "megapascals" or to_unit is equal to "MPa":
        Set converted_value to BigDecimal.divide_high_precision(pascals_value, "1000000", precision)
        Set result.conversion_factor to "0.000001"
    Otherwise if to_unit is equal to "bar":
        Set converted_value to BigDecimal.divide_high_precision(pascals_value, "100000", precision)
        Set result.conversion_factor to "0.00001"
    Otherwise if to_unit is equal to "atmospheres" or to_unit is equal to "atm":
        Set converted_value to BigDecimal.divide_high_precision(pascals_value, "101325", precision)
        Set result.conversion_factor to "0.00000986923"
    Otherwise if to_unit is equal to "psi":
        Set converted_value to BigDecimal.divide_high_precision(pascals_value, "6894.76", precision)
        Set result.conversion_factor to "0.000145038"
    Otherwise if to_unit is equal to "torr":
        Set converted_value to BigDecimal.divide_high_precision(pascals_value, "133.322", precision)
        Set result.conversion_factor to "0.00750062"
    Otherwise if to_unit is equal to "mmHg":
        Set converted_value to BigDecimal.divide_high_precision(pascals_value, "133.322", precision)
        Set result.conversion_factor to "0.00750062"
    Otherwise if to_unit is equal to "inHg":
        Set converted_value to BigDecimal.divide_high_precision(pascals_value, "3386.39", precision)
        Set result.conversion_factor to "0.000295301"
    Otherwise if to_unit is equal to "pascals" or to_unit is equal to "Pa":
        Set result.conversion_factor to "1"
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported target pressure unit: " joined with to_unit
    
    Set result.converted_value to converted_value
    Set result.accuracy_estimate to 1.0
    Return result

Process called "convert_force_units" that takes force as String, from_unit as String, to_unit as String, precision as Integer returns ConversionResult:
    Note: Convert between force units (newtons, pounds-force, dynes, etc.)
    Let result be ConversionResult
    Set result.original_value to force
    Set result.from_unit to from_unit
    Set result.to_unit to to_unit
    Set result.precision_retained to precision
    Set result.conversion_method to "force_unit_conversion"
    
    Let newtons_value be force
    
    If from_unit is equal to "kilonewtons" or from_unit is equal to "kN":
        Set newtons_value to BigDecimal.multiply_high_precision(force, "1000", precision plus 2)
    Otherwise if from_unit is equal to "meganewtons" or from_unit is equal to "MN":
        Set newtons_value to BigDecimal.multiply_high_precision(force, "1000000", precision plus 2)
    Otherwise if from_unit is equal to "dynes" or from_unit is equal to "dyn":
        Set newtons_value to BigDecimal.divide_high_precision(force, "100000", precision plus 2)
    Otherwise if from_unit is equal to "pounds_force" or from_unit is equal to "lbf":
        Set newtons_value to BigDecimal.multiply_high_precision(force, "4.44822", precision plus 2)
    Otherwise if from_unit is equal to "ounces_force" or from_unit is equal to "ozf":
        Set newtons_value to BigDecimal.multiply_high_precision(force, "0.278014", precision plus 2)
    Otherwise if from_unit is equal to "kilograms_force" or from_unit is equal to "kgf":
        Set newtons_value to BigDecimal.multiply_high_precision(force, "9.80665", precision plus 2)
    Otherwise if from_unit is equal to "grams_force" or from_unit is equal to "gf":
        Set newtons_value to BigDecimal.multiply_high_precision(force, "0.00980665", precision plus 2)
    Otherwise if from_unit not is equal to "newtons" and from_unit not is equal to "N":
        Throw Errors.InvalidOperation with "Unsupported source force unit: " joined with from_unit
    
    Let converted_value be newtons_value
    
    If to_unit is equal to "kilonewtons" or to_unit is equal to "kN":
        Set converted_value to BigDecimal.divide_high_precision(newtons_value, "1000", precision)
        Set result.conversion_factor to "0.001"
    Otherwise if to_unit is equal to "meganewtons" or to_unit is equal to "MN":
        Set converted_value to BigDecimal.divide_high_precision(newtons_value, "1000000", precision)
        Set result.conversion_factor to "0.000001"
    Otherwise if to_unit is equal to "dynes" or to_unit is equal to "dyn":
        Set converted_value to BigDecimal.multiply_high_precision(newtons_value, "100000", precision)
        Set result.conversion_factor to "100000"
    Otherwise if to_unit is equal to "pounds_force" or to_unit is equal to "lbf":
        Set converted_value to BigDecimal.divide_high_precision(newtons_value, "4.44822", precision)
        Set result.conversion_factor to "0.224809"
    Otherwise if to_unit is equal to "ounces_force" or to_unit is equal to "ozf":
        Set converted_value to BigDecimal.divide_high_precision(newtons_value, "0.278014", precision)
        Set result.conversion_factor to "3.59694"
    Otherwise if to_unit is equal to "kilograms_force" or to_unit is equal to "kgf":
        Set converted_value to BigDecimal.divide_high_precision(newtons_value, "9.80665", precision)
        Set result.conversion_factor to "0.101972"
    Otherwise if to_unit is equal to "grams_force" or to_unit is equal to "gf":
        Set converted_value to BigDecimal.divide_high_precision(newtons_value, "0.00980665", precision)
        Set result.conversion_factor to "101.972"
    Otherwise if to_unit is equal to "newtons" or to_unit is equal to "N":
        Set result.conversion_factor to "1"
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported target force unit: " joined with to_unit
    
    Set result.converted_value to converted_value
    Set result.accuracy_estimate to 1.0
    Return result

Note: =====================================================================
Note: TIME UNIT CONVERSION OPERATIONS
Note: =====================================================================

Process called "convert_time_units" that takes time_value as String, from_unit as String, to_unit as String, precision as Integer returns ConversionResult:
    Note: Convert between time units (seconds, minutes, hours, days, years)
    Let result be ConversionResult
    Set result.original_value to time_value
    Set result.from_unit to from_unit
    Set result.to_unit to to_unit
    Set result.precision_retained to precision
    Set result.conversion_method to "time_unit_conversion"
    
    Let seconds_value be time_value
    
    If from_unit is equal to "milliseconds" or from_unit is equal to "ms":
        Set seconds_value to BigDecimal.divide_high_precision(time_value, "1000", precision plus 2)
    Otherwise if from_unit is equal to "microseconds" or from_unit is equal to "μs":
        Set seconds_value to BigDecimal.divide_high_precision(time_value, "1000000", precision plus 2)
    Otherwise if from_unit is equal to "nanoseconds" or from_unit is equal to "ns":
        Set seconds_value to BigDecimal.divide_high_precision(time_value, "1000000000", precision plus 2)
    Otherwise if from_unit is equal to "minutes" or from_unit is equal to "min":
        Set seconds_value to BigDecimal.multiply_high_precision(time_value, "60", precision plus 2)
    Otherwise if from_unit is equal to "hours" or from_unit is equal to "hr" or from_unit is equal to "h":
        Set seconds_value to BigDecimal.multiply_high_precision(time_value, "3600", precision plus 2)
    Otherwise if from_unit is equal to "days" or from_unit is equal to "d":
        Set seconds_value to BigDecimal.multiply_high_precision(time_value, "86400", precision plus 2)
    Otherwise if from_unit is equal to "weeks" or from_unit is equal to "wk":
        Set seconds_value to BigDecimal.multiply_high_precision(time_value, "604800", precision plus 2)
    Otherwise if from_unit is equal to "months" or from_unit is equal to "mo":
        Set seconds_value to BigDecimal.multiply_high_precision(time_value, "2629746", precision plus 2)
    Otherwise if from_unit is equal to "years" or from_unit is equal to "yr" or from_unit is equal to "y":
        Set seconds_value to BigDecimal.multiply_high_precision(time_value, "31556952", precision plus 2)
    Otherwise if from_unit is equal to "decades":
        Set seconds_value to BigDecimal.multiply_high_precision(time_value, "315569520", precision plus 2)
    Otherwise if from_unit is equal to "centuries":
        Set seconds_value to BigDecimal.multiply_high_precision(time_value, "3155695200", precision plus 2)
    Otherwise if from_unit not is equal to "seconds" and from_unit not is equal to "s" and from_unit not is equal to "sec":
        Throw Errors.InvalidOperation with "Unsupported source time unit: " joined with from_unit
    
    Let converted_value be seconds_value
    
    If to_unit is equal to "milliseconds" or to_unit is equal to "ms":
        Set converted_value to BigDecimal.multiply_high_precision(seconds_value, "1000", precision)
        Set result.conversion_factor to "1000"
    Otherwise if to_unit is equal to "microseconds" or to_unit is equal to "μs":
        Set converted_value to BigDecimal.multiply_high_precision(seconds_value, "1000000", precision)
        Set result.conversion_factor to "1000000"
    Otherwise if to_unit is equal to "nanoseconds" or to_unit is equal to "ns":
        Set converted_value to BigDecimal.multiply_high_precision(seconds_value, "1000000000", precision)
        Set result.conversion_factor to "1000000000"
    Otherwise if to_unit is equal to "minutes" or to_unit is equal to "min":
        Set converted_value to BigDecimal.divide_high_precision(seconds_value, "60", precision)
        Set result.conversion_factor to "0.0166667"
    Otherwise if to_unit is equal to "hours" or to_unit is equal to "hr" or to_unit is equal to "h":
        Set converted_value to BigDecimal.divide_high_precision(seconds_value, "3600", precision)
        Set result.conversion_factor to "0.000277778"
    Otherwise if to_unit is equal to "days" or to_unit is equal to "d":
        Set converted_value to BigDecimal.divide_high_precision(seconds_value, "86400", precision)
        Set result.conversion_factor to "0.0000115741"
    Otherwise if to_unit is equal to "weeks" or to_unit is equal to "wk":
        Set converted_value to BigDecimal.divide_high_precision(seconds_value, "604800", precision)
        Set result.conversion_factor to "0.00000165344"
    Otherwise if to_unit is equal to "months" or to_unit is equal to "mo":
        Set converted_value to BigDecimal.divide_high_precision(seconds_value, "2629746", precision)
        Set result.conversion_factor to "3.80265e-7"
    Otherwise if to_unit is equal to "years" or to_unit is equal to "yr" or to_unit is equal to "y":
        Set converted_value to BigDecimal.divide_high_precision(seconds_value, "31556952", precision)
        Set result.conversion_factor to "3.16888e-8"
    Otherwise if to_unit is equal to "decades":
        Set converted_value to BigDecimal.divide_high_precision(seconds_value, "315569520", precision)
        Set result.conversion_factor to "3.16888e-9"
    Otherwise if to_unit is equal to "centuries":
        Set converted_value to BigDecimal.divide_high_precision(seconds_value, "3155695200", precision)
        Set result.conversion_factor to "3.16888e-10"
    Otherwise if to_unit is equal to "seconds" or to_unit is equal to "s" or to_unit is equal to "sec":
        Set result.conversion_factor to "1"
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported target time unit: " joined with to_unit
    
    Set result.converted_value to converted_value
    Set result.accuracy_estimate to 1.0
    Return result

Process called "convert_frequency_units" that takes frequency as String, from_unit as String, to_unit as String, precision as Integer returns ConversionResult:
    Note: Convert between frequency units (Hz, kHz, MHz, GHz, rpm, etc.)
    Let result be ConversionResult
    Set result.original_value to frequency
    Set result.from_unit to from_unit
    Set result.to_unit to to_unit
    Set result.precision_retained to precision
    Set result.conversion_method to "frequency_unit_conversion"
    
    Let hertz_value be frequency
    
    If from_unit is equal to "kilohertz" or from_unit is equal to "kHz":
        Set hertz_value to BigDecimal.multiply_high_precision(frequency, "1000", precision plus 2)
    Otherwise if from_unit is equal to "megahertz" or from_unit is equal to "MHz":
        Set hertz_value to BigDecimal.multiply_high_precision(frequency, "1000000", precision plus 2)
    Otherwise if from_unit is equal to "gigahertz" or from_unit is equal to "GHz":
        Set hertz_value to BigDecimal.multiply_high_precision(frequency, "1000000000", precision plus 2)
    Otherwise if from_unit is equal to "terahertz" or from_unit is equal to "THz":
        Set hertz_value to BigDecimal.multiply_high_precision(frequency, "1000000000000", precision plus 2)
    Otherwise if from_unit is equal to "rpm":
        Set hertz_value to BigDecimal.divide_high_precision(frequency, "60", precision plus 2)
    Otherwise if from_unit is equal to "beats_per_minute" or from_unit is equal to "bpm":
        Set hertz_value to BigDecimal.divide_high_precision(frequency, "60", precision plus 2)
    Otherwise if from_unit is equal to "cycles_per_second" or from_unit is equal to "cps":
        Set hertz_value to frequency
    Otherwise if from_unit not is equal to "hertz" and from_unit not is equal to "Hz":
        Throw Errors.InvalidOperation with "Unsupported source frequency unit: " joined with from_unit
    
    Let converted_value be hertz_value
    
    If to_unit is equal to "kilohertz" or to_unit is equal to "kHz":
        Set converted_value to BigDecimal.divide_high_precision(hertz_value, "1000", precision)
        Set result.conversion_factor to "0.001"
    Otherwise if to_unit is equal to "megahertz" or to_unit is equal to "MHz":
        Set converted_value to BigDecimal.divide_high_precision(hertz_value, "1000000", precision)
        Set result.conversion_factor to "0.000001"
    Otherwise if to_unit is equal to "gigahertz" or to_unit is equal to "GHz":
        Set converted_value to BigDecimal.divide_high_precision(hertz_value, "1000000000", precision)
        Set result.conversion_factor to "0.000000001"
    Otherwise if to_unit is equal to "terahertz" or to_unit is equal to "THz":
        Set converted_value to BigDecimal.divide_high_precision(hertz_value, "1000000000000", precision)
        Set result.conversion_factor to "0.000000000001"
    Otherwise if to_unit is equal to "rpm":
        Set converted_value to BigDecimal.multiply_high_precision(hertz_value, "60", precision)
        Set result.conversion_factor to "60"
    Otherwise if to_unit is equal to "beats_per_minute" or to_unit is equal to "bpm":
        Set converted_value to BigDecimal.multiply_high_precision(hertz_value, "60", precision)
        Set result.conversion_factor to "60"
    Otherwise if to_unit is equal to "cycles_per_second" or to_unit is equal to "cps":
        Set converted_value to hertz_value
        Set result.conversion_factor to "1"
    Otherwise if to_unit is equal to "hertz" or to_unit is equal to "Hz":
        Set result.conversion_factor to "1"
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported target frequency unit: " joined with to_unit
    
    Set result.converted_value to converted_value
    Set result.accuracy_estimate to 1.0
    Return result

Process called "seconds_to_human_readable" that takes seconds as String returns String:
    Note: Convert seconds to human-readable format (e.g., "1h 23m 45s")
    Let total_seconds be Parse seconds as Integer
    Let result_parts be Empty List[String]
    
    If total_seconds is greater than or equal to 31556952:
        Let years be total_seconds divided by 31556952
        Add String(years) joined with "y" to result_parts
        Set total_seconds to total_seconds modulo 31556952
    
    If total_seconds is greater than or equal to 86400:
        Let days be total_seconds divided by 86400
        Add String(days) joined with "d" to result_parts
        Set total_seconds to total_seconds modulo 86400
    
    If total_seconds is greater than or equal to 3600:
        Let hours be total_seconds divided by 3600
        Add String(hours) joined with "h" to result_parts
        Set total_seconds to total_seconds modulo 3600
    
    If total_seconds is greater than or equal to 60:
        Let minutes be total_seconds divided by 60
        Add String(minutes) joined with "m" to result_parts
        Set total_seconds to total_seconds modulo 60
    
    If total_seconds is greater than 0 or Length(result_parts) is equal to 0:
        Add String(total_seconds) joined with "s" to result_parts
    
    Let result_string be ""
    For i from 0 to Length(result_parts) minus 1:
        If i is greater than 0:
            Set result_string to result_string joined with " "
        Set result_string to result_string joined with result_parts[i]
    
    Return result_string

Process called "parse_duration_string" that takes duration_string as String returns String:
    Note: Parse human-readable duration to seconds
    Let total_seconds be 0
    Let parts be split_string(duration_string, " ")
    
    For Each part in parts:
        Let trimmed_part be trim_whitespace(part)
        If Length(trimmed_part) is greater than 0:
            Let unit_char be trimmed_part[Length(trimmed_part) minus 1]
            Let number_part be substring(trimmed_part, 0, Length(trimmed_part) minus 1)
            Let number_value be Parse number_part as Integer
            
            If unit_char is equal to "s":
                Set total_seconds to total_seconds plus number_value
            Otherwise if unit_char is equal to "m":
                Set total_seconds to total_seconds plus (number_value multiplied by 60)
            Otherwise if unit_char is equal to "h":
                Set total_seconds to total_seconds plus (number_value multiplied by 3600)
            Otherwise if unit_char is equal to "d":
                Set total_seconds to total_seconds plus (number_value multiplied by 86400)
            Otherwise if unit_char is equal to "w":
                Set total_seconds to total_seconds plus (number_value multiplied by 604800)
            Otherwise if unit_char is equal to "y":
                Set total_seconds to total_seconds plus (number_value multiplied by 31556952)
            Otherwise:
                If ends_with(trimmed_part, "ms"):
                    Let ms_part be substring(trimmed_part, 0, Length(trimmed_part) minus 2)
                    Let ms_value be Parse ms_part as Float
                    Set total_seconds to total_seconds plus (ms_value / 1000.0)
                Otherwise if ends_with(trimmed_part, "min"):
                    Let min_part be substring(trimmed_part, 0, Length(trimmed_part) minus 3)
                    Let min_value be Parse min_part as Integer
                    Set total_seconds to total_seconds plus (min_value multiplied by 60)
                Otherwise if ends_with(trimmed_part, "sec"):
                    Let sec_part be substring(trimmed_part, 0, Length(trimmed_part) minus 3)
                    Let sec_value be Parse sec_part as Integer
                    Set total_seconds to total_seconds plus sec_value
    
    Return String(total_seconds)

Note: =====================================================================
Note: DATA STORAGE UNIT CONVERSIONS
Note: =====================================================================

Process called "convert_data_units" that takes data_size as String, from_unit as String, to_unit as String, binary_mode as Boolean returns ConversionResult:
    Note: Convert data storage units (bytes, KB, MB, GB) with binary/decimal modes
    Let result be ConversionResult
    Set result.original_value to data_size
    Set result.from_unit to from_unit
    Set result.to_unit to to_unit
    Set result.precision_retained to 10
    
    Let bytes_value be data_size
    Let multiplier be "1000"
    If binary_mode:
        Set multiplier to "1024"
        Set result.conversion_method to "binary_data_unit_conversion"
    Otherwise:
        Set result.conversion_method to "decimal_data_unit_conversion"
    
    If from_unit is equal to "kilobytes" or from_unit is equal to "KB" or from_unit is equal to "kB":
        Set bytes_value to BigDecimal.multiply_high_precision(data_size, multiplier, 12)
    Otherwise if from_unit is equal to "megabytes" or from_unit is equal to "MB":
        Let mb_multiplier be BigDecimal.multiply_high_precision(multiplier, multiplier, 12)
        Set bytes_value to BigDecimal.multiply_high_precision(data_size, mb_multiplier, 12)
    Otherwise if from_unit is equal to "gigabytes" or from_unit is equal to "GB":
        Let gb_multiplier be BigDecimal.multiply_high_precision(multiplier, multiplier, 12)
        Set gb_multiplier to BigDecimal.multiply_high_precision(gb_multiplier, multiplier, 12)
        Set bytes_value to BigDecimal.multiply_high_precision(data_size, gb_multiplier, 12)
    Otherwise if from_unit is equal to "terabytes" or from_unit is equal to "TB":
        Let tb_multiplier be BigDecimal.multiply_high_precision(multiplier, multiplier, 12)
        Set tb_multiplier to BigDecimal.multiply_high_precision(tb_multiplier, multiplier, 12)
        Set tb_multiplier to BigDecimal.multiply_high_precision(tb_multiplier, multiplier, 12)
        Set bytes_value to BigDecimal.multiply_high_precision(data_size, tb_multiplier, 12)
    Otherwise if from_unit is equal to "petabytes" or from_unit is equal to "PB":
        Let pb_multiplier be BigDecimal.multiply_high_precision(multiplier, multiplier, 12)
        Set pb_multiplier to BigDecimal.multiply_high_precision(pb_multiplier, multiplier, 12)
        Set pb_multiplier to BigDecimal.multiply_high_precision(pb_multiplier, multiplier, 12)
        Set pb_multiplier to BigDecimal.multiply_high_precision(pb_multiplier, multiplier, 12)
        Set bytes_value to BigDecimal.multiply_high_precision(data_size, pb_multiplier, 12)
    Otherwise if from_unit is equal to "bits":
        Set bytes_value to BigDecimal.divide_high_precision(data_size, "8", 12)
    Otherwise if from_unit not is equal to "bytes" and from_unit not is equal to "B":
        Throw Errors.InvalidOperation with "Unsupported source data unit: " joined with from_unit
    
    Let converted_value be bytes_value
    
    If to_unit is equal to "kilobytes" or to_unit is equal to "KB" or to_unit is equal to "kB":
        Set converted_value to BigDecimal.divide_high_precision(bytes_value, multiplier, 10)
        If binary_mode:
            Set result.conversion_factor to "0.0009765625"
        Otherwise:
            Set result.conversion_factor to "0.001"
    Otherwise if to_unit is equal to "megabytes" or to_unit is equal to "MB":
        Let mb_divisor be BigDecimal.multiply_high_precision(multiplier, multiplier, 12)
        Set converted_value to BigDecimal.divide_high_precision(bytes_value, mb_divisor, 10)
        If binary_mode:
            Set result.conversion_factor to "9.5367e-7"
        Otherwise:
            Set result.conversion_factor to "0.000001"
    Otherwise if to_unit is equal to "gigabytes" or to_unit is equal to "GB":
        Let gb_divisor be BigDecimal.multiply_high_precision(multiplier, multiplier, 12)
        Set gb_divisor to BigDecimal.multiply_high_precision(gb_divisor, multiplier, 12)
        Set converted_value to BigDecimal.divide_high_precision(bytes_value, gb_divisor, 10)
        If binary_mode:
            Set result.conversion_factor to "9.3132e-10"
        Otherwise:
            Set result.conversion_factor to "0.000000001"
    Otherwise if to_unit is equal to "terabytes" or to_unit is equal to "TB":
        Let tb_divisor be BigDecimal.multiply_high_precision(multiplier, multiplier, 12)
        Set tb_divisor to BigDecimal.multiply_high_precision(tb_divisor, multiplier, 12)
        Set tb_divisor to BigDecimal.multiply_high_precision(tb_divisor, multiplier, 12)
        Set converted_value to BigDecimal.divide_high_precision(bytes_value, tb_divisor, 10)
        If binary_mode:
            Set result.conversion_factor to "9.0949e-13"
        Otherwise:
            Set result.conversion_factor to "0.000000000001"
    Otherwise if to_unit is equal to "petabytes" or to_unit is equal to "PB":
        Let pb_divisor be BigDecimal.multiply_high_precision(multiplier, multiplier, 12)
        Set pb_divisor to BigDecimal.multiply_high_precision(pb_divisor, multiplier, 12)
        Set pb_divisor to BigDecimal.multiply_high_precision(pb_divisor, multiplier, 12)
        Set pb_divisor to BigDecimal.multiply_high_precision(pb_divisor, multiplier, 12)
        Set converted_value to BigDecimal.divide_high_precision(bytes_value, pb_divisor, 10)
        If binary_mode:
            Set result.conversion_factor to "8.8818e-16"
        Otherwise:
            Set result.conversion_factor to "0.000000000000001"
    Otherwise if to_unit is equal to "bits":
        Set converted_value to BigDecimal.multiply_high_precision(bytes_value, "8", 10)
        Set result.conversion_factor to "8"
    Otherwise if to_unit is equal to "bytes" or to_unit is equal to "B":
        Set result.conversion_factor to "1"
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported target data unit: " joined with to_unit
    
    Set result.converted_value to converted_value
    Set result.accuracy_estimate to 1.0
    Return result

Process called "bits_to_bytes" that takes bits as String returns ConversionResult:
    Note: Convert bits to bytes
    Let result be ConversionResult
    Set result.original_value to bits
    Set result.from_unit to "bits"
    Set result.to_unit to "bytes"
    Set result.precision_retained to 10
    Set result.conversion_method to "bits_to_bytes_division"
    
    Let bytes_value be BigDecimal.divide_high_precision(bits, "8", 10)
    
    Set result.converted_value to bytes_value
    Set result.conversion_factor to "0.125"
    Set result.accuracy_estimate to 1.0
    Return result

Process called "convert_bandwidth_units" that takes bandwidth as String, from_unit as String, to_unit as String returns ConversionResult:
    Note: Convert bandwidth units (bps, Kbps, Mbps, Gbps)
    Let result be ConversionResult
    Set result.original_value to bandwidth
    Set result.from_unit to from_unit
    Set result.to_unit to to_unit
    Set result.precision_retained to 10
    Set result.conversion_method to "bandwidth_unit_conversion"
    
    Let bps_value be bandwidth
    
    If from_unit is equal to "Kbps" or from_unit is equal to "kilobits_per_second":
        Set bps_value to BigDecimal.multiply_high_precision(bandwidth, "1000", 12)
    Otherwise if from_unit is equal to "Mbps" or from_unit is equal to "megabits_per_second":
        Set bps_value to BigDecimal.multiply_high_precision(bandwidth, "1000000", 12)
    Otherwise if from_unit is equal to "Gbps" or from_unit is equal to "gigabits_per_second":
        Set bps_value to BigDecimal.multiply_high_precision(bandwidth, "1000000000", 12)
    Otherwise if from_unit is equal to "Tbps" or from_unit is equal to "terabits_per_second":
        Set bps_value to BigDecimal.multiply_high_precision(bandwidth, "1000000000000", 12)
    Otherwise if from_unit is equal to "KBps" or from_unit is equal to "kilobytes_per_second":
        Set bps_value to BigDecimal.multiply_high_precision(bandwidth, "8000", 12)
    Otherwise if from_unit is equal to "MBps" or from_unit is equal to "megabytes_per_second":
        Set bps_value to BigDecimal.multiply_high_precision(bandwidth, "8000000", 12)
    Otherwise if from_unit is equal to "GBps" or from_unit is equal to "gigabytes_per_second":
        Set bps_value to BigDecimal.multiply_high_precision(bandwidth, "8000000000", 12)
    Otherwise if from_unit not is equal to "bps" and from_unit not is equal to "bits_per_second":
        Throw Errors.InvalidOperation with "Unsupported source bandwidth unit: " joined with from_unit
    
    Let converted_value be bps_value
    
    If to_unit is equal to "Kbps" or to_unit is equal to "kilobits_per_second":
        Set converted_value to BigDecimal.divide_high_precision(bps_value, "1000", 10)
        Set result.conversion_factor to "0.001"
    Otherwise if to_unit is equal to "Mbps" or to_unit is equal to "megabits_per_second":
        Set converted_value to BigDecimal.divide_high_precision(bps_value, "1000000", 10)
        Set result.conversion_factor to "0.000001"
    Otherwise if to_unit is equal to "Gbps" or to_unit is equal to "gigabits_per_second":
        Set converted_value to BigDecimal.divide_high_precision(bps_value, "1000000000", 10)
        Set result.conversion_factor to "0.000000001"
    Otherwise if to_unit is equal to "Tbps" or to_unit is equal to "terabits_per_second":
        Set converted_value to BigDecimal.divide_high_precision(bps_value, "1000000000000", 10)
        Set result.conversion_factor to "0.000000000001"
    Otherwise if to_unit is equal to "KBps" or to_unit is equal to "kilobytes_per_second":
        Set converted_value to BigDecimal.divide_high_precision(bps_value, "8000", 10)
        Set result.conversion_factor to "0.000125"
    Otherwise if to_unit is equal to "MBps" or to_unit is equal to "megabytes_per_second":
        Set converted_value to BigDecimal.divide_high_precision(bps_value, "8000000", 10)
        Set result.conversion_factor to "0.000000125"
    Otherwise if to_unit is equal to "GBps" or to_unit is equal to "gigabytes_per_second":
        Set converted_value to BigDecimal.divide_high_precision(bps_value, "8000000000", 10)
        Set result.conversion_factor to "0.000000000125"
    Otherwise if to_unit is equal to "bps" or to_unit is equal to "bits_per_second":
        Set result.conversion_factor to "1"
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported target bandwidth unit: " joined with to_unit
    
    Set result.converted_value to converted_value
    Set result.accuracy_estimate to 1.0
    Return result

Note: =====================================================================
Note: CURRENCY AND FINANCIAL CONVERSIONS
Note: =====================================================================

Process called "convert_currency" that takes amount as String, from_currency as String, to_currency as String, exchange_rates as Dictionary[String, String] returns ConversionResult:
    Note: Convert between currencies using provided exchange rates
    Let result be ConversionResult
    Set result.original_value to amount
    Set result.from_unit to from_currency
    Set result.to_unit to to_currency
    Set result.precision_retained to 6
    Set result.conversion_method to "currency_exchange_rate"
    
    If from_currency is equal to to_currency:
        Set result.converted_value to amount
        Set result.conversion_factor to "1"
        Set result.accuracy_estimate to 1.0
        Return result
    
    Let rate_key be from_currency joined with "_to_" joined with to_currency
    Let reverse_rate_key be to_currency joined with "_to_" joined with from_currency
    
    If exchange_rates contains rate_key:
        Let exchange_rate be exchange_rates[rate_key]
        Let converted_value be BigDecimal.multiply_high_precision(amount, exchange_rate, 6)
        Set result.converted_value to converted_value
        Set result.conversion_factor to exchange_rate
        Set result.accuracy_estimate to 0.95
        Return result
    
    Otherwise if exchange_rates contains reverse_rate_key:
        Let reverse_rate be exchange_rates[reverse_rate_key]
        Let exchange_rate be BigDecimal.divide_high_precision("1", reverse_rate, 8)
        Let converted_value be BigDecimal.multiply_high_precision(amount, exchange_rate, 6)
        Set result.converted_value to converted_value
        Set result.conversion_factor to exchange_rate
        Set result.accuracy_estimate to 0.95
        Return result
    
    Otherwise if exchange_rates contains "USD_to_" joined with to_currency and exchange_rates contains from_currency joined with "_to_USD":
        Let from_to_usd_rate be exchange_rates[from_currency joined with "_to_USD"]
        Let usd_to_target_rate be exchange_rates["USD_to_" joined with to_currency]
        Let usd_amount be BigDecimal.multiply_high_precision(amount, from_to_usd_rate, 8)
        Let converted_value be BigDecimal.multiply_high_precision(usd_amount, usd_to_target_rate, 6)
        Let combined_rate be BigDecimal.multiply_high_precision(from_to_usd_rate, usd_to_target_rate, 8)
        Set result.converted_value to converted_value
        Set result.conversion_factor to combined_rate
        Set result.accuracy_estimate to 0.90
        Return result
    
    Otherwise:
        Throw Errors.InvalidOperation with "Exchange rate not available for " joined with from_currency joined with " to " joined with to_currency

Process called "apply_interest_rate" that takes principal as String, interest_rate as String, time_period as String, compounding_frequency as String returns String:
    Note: Convert principal to future value using compound interest
    Let working_precision be 10
    Let rate_decimal be BigDecimal.divide_high_precision(interest_rate, "100", working_precision plus 2)
    Let periods be Parse time_period as Float
    
    Let compounding_per_year be 1
    If compounding_frequency is equal to "monthly":
        Set compounding_per_year to 12
    Otherwise if compounding_frequency is equal to "quarterly":
        Set compounding_per_year to 4
    Otherwise if compounding_frequency is equal to "semi_annually":
        Set compounding_per_year to 2
    Otherwise if compounding_frequency is equal to "daily":
        Set compounding_per_year to 365
    Otherwise if compounding_frequency is equal to "continuously":
            Let exponent be BigDecimal.multiply_high_precision(rate_decimal, time_period, working_precision plus 2)
        Let e_power be Operations.exponential(exponent, working_precision)
        Let future_value be BigDecimal.multiply_high_precision(principal, e_power.result_value, working_precision)
        Return future_value
    
    Let rate_per_period be BigDecimal.divide_high_precision(rate_decimal, String(compounding_per_year), working_precision plus 2)
    Let one_plus_rate be BigDecimal.add_high_precision("1", rate_per_period, working_precision plus 2)
    Let total_periods be periods multiplied by Float(compounding_per_year)
    
    Let compound_factor be Operations.power(one_plus_rate, String(total_periods), working_precision)
    Let future_value be BigDecimal.multiply_high_precision(principal, compound_factor.result_value, working_precision)
    
    Return future_value

Process called "present_value_conversion" that takes future_value as String, discount_rate as String, periods as String returns String:
    Note: Convert future value to present value
    Let working_precision be 10
    Let rate_decimal be BigDecimal.divide_high_precision(discount_rate, "100", working_precision plus 2)
    Let one_plus_rate be BigDecimal.add_high_precision("1", rate_decimal, working_precision plus 2)
    
    Let discount_factor be Operations.power(one_plus_rate, periods, working_precision)
    Let present_value be BigDecimal.divide_high_precision(future_value, discount_factor.result_value, working_precision)
    
    Return present_value

Process called "fetch_live_exchange_rates" that takes base_currency as String, target_currencies as List[String], api_endpoint as String returns Dictionary[String, CurrencyConversionRate]:
    Note: Fetch live exchange rates from external API endpoint
    Let rates be Dictionary[String, CurrencyConversionRate]
    Let current_timestamp be get_current_timestamp()
    
    Try:
        Let api_url be api_endpoint joined with "?base=" joined with base_currency
        For Each currency in target_currencies:
            Set api_url to api_url joined with "&symbols=" joined with currency
        
        Let response be HttpClient.get_request(api_url)
        If response.status_code is equal to 200:
            Let rate_data be parse_json(response.body)
            
            For Each currency in target_currencies:
                If rate_data contains currency:
                    Let rate_info be CurrencyConversionRate
                    Set rate_info.from_currency to base_currency
                    Set rate_info.to_currency to currency
                    Set rate_info.exchange_rate to String(rate_data[currency])
                    Set rate_info.rate_timestamp to current_timestamp
                    Set rate_info.rate_source to "external_api"
                    Set rate_info.bid_ask_spread to "0.001"
                    Set rate_info.volatility_measure to "unknown"
                    
                    Let rate_key be base_currency joined with "_to_" joined with currency
                    Set rates[rate_key] to rate_info
        Otherwise:
            Throw Errors.NetworkError with "Failed to fetch exchange rates: HTTP " joined with String(response.status_code)
    
    Catch network_error:
        Throw Errors.NetworkError with "Network error fetching exchange rates: " joined with network_error.message
    
    Return rates

Process called "cache_exchange_rates" that takes rates as Dictionary[String, CurrencyConversionRate], cache_duration_minutes as Integer returns Boolean:
    Note: Cache exchange rates for specified duration to reduce API calls
    Let cache_directory be get_cache_directory() joined with "/currency_rates"
    Let current_time be get_current_timestamp()
    
    Try:
        Let cache_data be Dictionary[String, Dictionary[String, String]]
        For Each rate_key, rate_info in rates:
            Let rate_entry be Dictionary[String, String]
            Set rate_entry["from_currency"] to rate_info.from_currency
            Set rate_entry["to_currency"] to rate_info.to_currency
            Set rate_entry["exchange_rate"] to rate_info.exchange_rate
            Set rate_entry["timestamp"] to rate_info.rate_timestamp
            Set rate_entry["source"] to rate_info.rate_source
            Set rate_entry["expires_at"] to String(current_time plus (cache_duration_minutes multiplied by 60))
            Set cache_data[rate_key] to rate_entry
        
        Let cache_file be cache_directory joined with "/rates_cache.json"
        Let serialized_data be serialize_to_json(cache_data)
        Let write_success be write_to_file(cache_file, serialized_data)
        Return write_success
    
    Catch cache_error:
        Return false

Process called "load_cached_exchange_rates" that takes required_currencies as List[String] returns Dictionary[String, String]:
    Note: Load cached exchange rates if still valid
    Let cached_rates be Dictionary[String, String]
    Let cache_directory be get_cache_directory() joined with "/currency_rates"
    Let cache_file be cache_directory joined with "/rates_cache.json"
    Let current_time be get_current_timestamp()
    
    Try:
        If file_exists(cache_file):
            Let cache_data_raw be read_from_file(cache_file)
            Let cache_data be deserialize_from_json(cache_data_raw)
            
            For Each rate_key, rate_entry in cache_data:
                Let expires_at be Parse rate_entry["expires_at"] as Integer
                If current_time is less than expires_at:
                    Let rate_pair be rate_entry["from_currency"] joined with "_to_" joined with rate_entry["to_currency"]
                    If rate_pair in required_currencies:
                        Set cached_rates[rate_pair] to rate_entry["exchange_rate"]
        
        Return cached_rates
    
    Catch cache_error:
        Return cached_rates

Process called "convert_currency_with_live_rates" that takes amount as String, from_currency as String, to_currency as String, api_endpoint as String returns ConversionResult:
    Note: Convert currency using live exchange rates with caching
    Let result be ConversionResult
    Set result.original_value to amount
    Set result.from_unit to from_currency
    Set result.to_unit to to_currency
    Set result.precision_retained to 6
    Set result.conversion_method to "live_currency_conversion"
    
    If from_currency is equal to to_currency:
        Set result.converted_value to amount
        Set result.conversion_factor to "1"
        Set result.accuracy_estimate to 1.0
        Return result
    
    Let required_pairs be [from_currency joined with "_to_" joined with to_currency]
    Let cached_rates be load_cached_exchange_rates(required_pairs)
    
    Let rate_key be from_currency joined with "_to_" joined with to_currency
    If cached_rates contains rate_key:
        Let cached_rate be cached_rates[rate_key]
        Let converted_value be BigDecimal.multiply_high_precision(amount, cached_rate, 6)
        Set result.converted_value to converted_value
        Set result.conversion_factor to cached_rate
        Set result.accuracy_estimate to 0.98
        Return result
    
    Otherwise:
        Try:
            Let target_currencies be [to_currency]
            Let live_rates be fetch_live_exchange_rates(from_currency, target_currencies, api_endpoint)
            Let cache_success be cache_exchange_rates(live_rates, 30)
            
            If live_rates contains rate_key:
                Let live_rate be live_rates[rate_key].exchange_rate
                Let converted_value be BigDecimal.multiply_high_precision(amount, live_rate, 6)
                Set result.converted_value to converted_value
                Set result.conversion_factor to live_rate
                Set result.accuracy_estimate to 0.99
                Return result
            Otherwise:
                Throw Errors.InvalidOperation with "Live exchange rate not available for " joined with from_currency joined with " to " joined with to_currency
        
        Catch rate_error:
            Throw Errors.NetworkError with "Failed to get live exchange rate: " joined with rate_error.message

Note: =====================================================================
Note: NUMBER FORMAT CONVERSIONS
Note: =====================================================================

Process called "to_scientific_notation" that takes number as String, significant_digits as Integer returns String:
    Note: Convert number to scientific notation (e.g., 1.23e+5)
    Let decimal_pos be find_decimal_position(number)
    Let digits be remove_decimal_point(number)
    Let first_significant_pos be find_first_nonzero_digit(digits)
    
    If first_significant_pos is equal to -1:
        Return "0.0e+0"
    
    Let exponent be 0
    If decimal_pos is equal to -1:
        Set exponent to Length(digits) minus 1 minus first_significant_pos
    Otherwise:
        Set exponent to decimal_pos minus 1 minus first_significant_pos
    
    Let significant_part be extract_significant_digits(digits, first_significant_pos, significant_digits)
    Let mantissa be significant_part[0] joined with "."
    
    For i from 1 to Length(significant_part) minus 1:
        Set mantissa to mantissa joined with significant_part[i]
    
    Let exponent_str be String(exponent)
    If exponent is greater than or equal to 0:
        Set exponent_str to "+" joined with exponent_str
    
    Return mantissa joined with "e" joined with exponent_str

Process called "from_scientific_notation" that takes scientific_string as String returns String:
    Note: Convert scientific notation to standard decimal format
    Let e_pos be find_character_position(scientific_string, "e")
    If e_pos is equal to -1:
        Set e_pos to find_character_position(scientific_string, "E")
    
    If e_pos is equal to -1:
        Return scientific_string
    
    Let mantissa be substring(scientific_string, 0, e_pos)
    Let exponent_str be substring(scientific_string, e_pos plus 1, Length(scientific_string))
    Let exponent be Parse exponent_str as Integer
    
    Let decimal_pos be find_character_position(mantissa, ".")
    Let digits be remove_character(mantissa, ".")
    
    If exponent is equal to 0:
        Return mantissa
    
    Otherwise if exponent is greater than 0:
        If decimal_pos is equal to -1:
            Set decimal_pos to Length(mantissa)
        Let new_decimal_pos be decimal_pos plus exponent
        
        If new_decimal_pos is greater than Length(digits):
            Let zeros_to_add be new_decimal_pos minus Length(digits)
            For i from 1 to zeros_to_add:
                Set digits to digits joined with "0"
            Return digits
        Otherwise if new_decimal_pos is equal to Length(digits):
            Return digits
        Otherwise:
            Let result be substring(digits, 0, new_decimal_pos) joined with "."
            Set result to result joined with substring(digits, new_decimal_pos, Length(digits))
            Return result
    
    Otherwise:
        Let abs_exponent be -exponent
        If decimal_pos not is equal to -1:
            Set digits to remove_character(mantissa, ".")
        
        Let result be "0."
        For i from 1 to abs_exponent minus 1:
            Set result to result joined with "0"
        Set result to result joined with digits
        Return result

Process called "to_engineering_notation" that takes number as String, precision as Integer returns String:
    Note: Convert to engineering notation (powers of 1000)
    Let scientific_form be to_scientific_notation(number, precision plus 3)
    Let e_pos be find_character_position(scientific_form, "e")
    
    If e_pos is equal to -1:
        Return number
    
    Let mantissa be substring(scientific_form, 0, e_pos)
    Let exponent_str be substring(scientific_form, e_pos plus 1, Length(scientific_form))
    Let exponent be Parse exponent_str as Integer
    
    Let engineering_exponent be (exponent divided by 3) multiplied by 3
    Let mantissa_shift be exponent minus engineering_exponent
    
    Let decimal_pos be find_character_position(mantissa, ".")
    Let digits be remove_character(mantissa, ".")
    
    Let new_decimal_pos be decimal_pos plus mantissa_shift
    If new_decimal_pos is less than 0:
        Set new_decimal_pos to 0
        Set engineering_exponent to engineering_exponent minus 3
        Set new_decimal_pos to new_decimal_pos plus 3
    
    While new_decimal_pos is greater than Length(digits):
        Set digits to digits joined with "0"
    
    Let result be ""
    If new_decimal_pos is equal to 0:
        Set result to "0." joined with digits
    Otherwise if new_decimal_pos is greater than or equal to Length(digits):
        Set result to digits
        For i from Length(digits) to new_decimal_pos minus 1:
            Set result to result joined with "0"
    Otherwise:
        Set result to substring(digits, 0, new_decimal_pos)
        If new_decimal_pos is less than Length(digits):
            Set result to result joined with "."
            Set result to result joined with substring(digits, new_decimal_pos, Length(digits))
    
    Let eng_exponent_str be String(engineering_exponent)
    If engineering_exponent is greater than or equal to 0 and engineering_exponent not is equal to 0:
        Set eng_exponent_str to "+" joined with eng_exponent_str
    
    If engineering_exponent is equal to 0:
        Return result
    Otherwise:
        Return result joined with "e" joined with eng_exponent_str

Process called "decimal_to_fraction" that takes decimal as String, max_denominator as Integer returns Dictionary[String, String]:
    Note: Convert decimal to fraction with specified maximum denominator
    Let result be Dictionary[String, String]
    Let decimal_value be Parse decimal as Float
    
    If decimal_value is equal to 0.0:
        Set result["numerator"] to "0"
        Set result["denominator"] to "1"
        Set result["decimal_equivalent"] to "0"
        Set result["error"] to "0"
        Return result
    
    Let is_negative be decimal_value is less than 0.0
    Let abs_decimal be AbsoluteValue(decimal_value)
    
    Let best_numerator be 1
    Let best_denominator be 1
    Let best_error be AbsoluteValue(abs_decimal minus 1.0)
    
    For denominator from 1 to max_denominator:
        Let numerator be Round(abs_decimal multiplied by Float(denominator))
        Let fraction_value be Float(numerator) / Float(denominator)
        Let error be AbsoluteValue(abs_decimal minus fraction_value)
        
        If error is less than best_error:
            Set best_error to error
            Set best_numerator to numerator
            Set best_denominator to denominator
        
        If error is less than 0.0000001:
            Break
    
    If is_negative:
        Set best_numerator to -best_numerator
    
    Let gcd_value be greatest_common_divisor(AbsoluteValue(best_numerator), best_denominator)
    Set best_numerator to best_numerator divided by gcd_value
    Set best_denominator to best_denominator divided by gcd_value
    
    Set result["numerator"] to String(best_numerator)
    Set result["denominator"] to String(best_denominator)
    Set result["decimal_equivalent"] to String(Float(best_numerator) / Float(best_denominator))
    Set result["error"] to String(best_error)
    Set result["simplified"] to "true"
    
    Return result

Process called "fraction_to_decimal" that takes numerator as String, denominator as String, precision as Integer returns String:
    Note: Convert fraction to decimal with specified precision
    Let num_value be Parse numerator as Integer
    Let den_value be Parse denominator as Integer
    
    If den_value is equal to 0:
        Throw Errors.InvalidOperation with "Division by zero in fraction conversion"
    
    If num_value is equal to 0:
        Return "0"
    
    Let is_negative be (num_value is less than 0 and den_value is greater than 0) or (num_value is greater than 0 and den_value is less than 0)
    Let abs_num be AbsoluteValue(num_value)
    Let abs_den be AbsoluteValue(den_value)
    
    Let integer_part be abs_num divided by abs_den
    Let remainder be abs_num modulo abs_den
    
    If remainder is equal to 0:
        Let result be String(integer_part)
        If is_negative:
            Set result to "-" joined with result
        Return result
    
    Let decimal_digits be Empty List[String]
    Let seen_remainders be Dictionary[Integer, Integer]
    Let position be 0
    
    While remainder not is equal to 0 and position is less than precision and not (remainder in seen_remainders):
        Set seen_remainders[remainder] to position
        Set remainder to remainder multiplied by 10
        Let digit be remainder divided by abs_den
        Add String(digit) to decimal_digits
        Set remainder to remainder modulo abs_den
        Set position to position plus 1
    
    Let decimal_part be ""
    For Each digit in decimal_digits:
        Set decimal_part to decimal_part joined with digit
    
    Let result be String(integer_part)
    If Length(decimal_part) is greater than 0:
        Set result to result joined with "." joined with decimal_part
    
    If is_negative:
        Set result to "-" joined with result
    
    Return result

Process called "to_percentage" that takes decimal as String, decimal_places as Integer returns String:
    Note: Convert decimal to percentage format
    Let decimal_value be Parse decimal as Float
    Let percentage_value be decimal_value multiplied by 100.0
    
    Let multiplier be 1.0
    For i from 1 to decimal_places:
        Set multiplier to multiplier multiplied by 10.0
    
    Let rounded_percentage be Round(percentage_value multiplied by multiplier) / multiplier
    Let percentage_str be String(rounded_percentage)
    
    If decimal_places is greater than 0:
        Let dot_pos be find_character_position(percentage_str, ".")
        If dot_pos is equal to -1:
            Set percentage_str to percentage_str joined with "."
            For i from 1 to decimal_places:
                Set percentage_str to percentage_str joined with "0"
        Otherwise:
            Let current_decimal_places be Length(percentage_str) minus dot_pos minus 1
            If current_decimal_places is less than decimal_places:
                Let zeros_to_add be decimal_places minus current_decimal_places
                For i from 1 to zeros_to_add:
                    Set percentage_str to percentage_str joined with "0"
            Otherwise if current_decimal_places is greater than decimal_places:
                Set percentage_str to substring(percentage_str, 0, dot_pos plus decimal_places plus 1)
    
    Return percentage_str joined with "%"

Process called "from_percentage" that takes percentage_string as String returns String:
    Note: Convert percentage string to decimal format
    Let cleaned_string be percentage_string
    
    If ends_with(cleaned_string, "%"):
        Set cleaned_string to substring(cleaned_string, 0, Length(cleaned_string) minus 1)
    
    Let percentage_value be Parse cleaned_string as Float
    Let decimal_value be percentage_value / 100.0
    
    Return String(decimal_value)

Note: =====================================================================
Note: PRECISION AND REPRESENTATION CONVERSIONS
Note: =====================================================================

Process called "fixed_to_floating_point" that takes fixed_point as String, integer_bits as Integer, fractional_bits as Integer returns String:
    Note: Convert fixed-point representation to floating-point
    Let fixed_value be Parse fixed_point as Integer
    Let scale_factor be 1
    
    For i from 1 to fractional_bits:
        Set scale_factor to scale_factor multiplied by 2
    
    Let floating_value be Float(fixed_value) / Float(scale_factor)
    Return String(floating_value)

Process called "floating_to_fixed_point" that takes floating_point as String, integer_bits as Integer, fractional_bits as Integer returns String:
    Note: Convert floating-point to fixed-point representation
    Let float_value be Parse floating_point as Float
    Let scale_factor be 1
    
    For i from 1 to fractional_bits:
        Set scale_factor to scale_factor multiplied by 2
    
    Let scaled_value be float_value multiplied by Float(scale_factor)
    Let fixed_value be Round(scaled_value)
    
    Let max_positive be 1
    For i from 1 to integer_bits plus fractional_bits minus 1:
        Set max_positive to max_positive multiplied by 2
    Set max_positive to max_positive minus 1
    
    Let min_negative be -max_positive minus 1
    
    If fixed_value is greater than max_positive:
        Set fixed_value to max_positive
    Otherwise if fixed_value is less than min_negative:
        Set fixed_value to min_negative
    
    Return String(fixed_value)

Process called "change_precision" that takes number as String, from_precision as Integer, to_precision as Integer returns String:
    Note: Change numerical precision with appropriate rounding
    If to_precision is equal to from_precision:
        Return number
    
    If to_precision is greater than from_precision:
        Let decimal_pos be find_character_position(number, ".")
        If decimal_pos is equal to -1:
            Let result be number joined with "."
            For i from 1 to to_precision:
                Set result to result joined with "0"
            Return result
        Otherwise:
            Let current_decimal_places be Length(number) minus decimal_pos minus 1
            Let result be number
            If current_decimal_places is less than to_precision:
                Let zeros_to_add be to_precision minus current_decimal_places
                For i from 1 to zeros_to_add:
                    Set result to result joined with "0"
            Return result
    
    Otherwise:
        Return BigDecimal.round_to_precision(number, to_precision)

Process called "normalize_precision" that takes numbers as List[String] returns List[String]:
    Note: Normalize precision across multiple numbers for consistent operations
    Let max_precision be 0
    
    For Each number in numbers:
        Let decimal_pos be find_character_position(number, ".")
        If decimal_pos not is equal to -1:
            Let current_precision be Length(number) minus decimal_pos minus 1
            If current_precision is greater than max_precision:
                Set max_precision to current_precision
    
    Let normalized_numbers be Empty List[String]
    
    For Each number in numbers:
        Let normalized_number be change_precision(number, 0, max_precision)
        Add normalized_number to normalized_numbers
    
    Return normalized_numbers

Note: =====================================================================
Note: ENCODING AND CHARACTER CONVERSIONS
Note: =====================================================================

Process called "ascii_to_binary" that takes ascii_string as String returns String:
    Note: Convert ASCII string to binary representation
    Let binary_result be ""
    
    For i from 0 to Length(ascii_string) minus 1:
        Let char_code be ascii_value(ascii_string[i])
        Let binary_char be decimal_to_binary(String(char_code), 8)
        
        Let padded_binary be binary_char.converted_representation
        While Length(padded_binary) is less than 8:
            Set padded_binary to "0" joined with padded_binary
        
        Set binary_result to binary_result joined with padded_binary
        
        If i is less than Length(ascii_string) minus 1:
            Set binary_result to binary_result joined with " "
    
    Return binary_result

Process called "binary_to_ascii" that takes binary_string as String returns String:
    Note: Convert binary representation to ASCII string
    Let ascii_result be ""
    Let cleaned_binary be remove_character(binary_string, " ")
    
    If Length(cleaned_binary) modulo 8 not is equal to 0:
        Throw Errors.InvalidOperation with "Binary string length must be multiple of 8 for ASCII conversion"
    
    For i from 0 to (Length(cleaned_binary) divided by 8) minus 1:
        Let start_pos be i multiplied by 8
        Let binary_byte be substring(cleaned_binary, start_pos, start_pos plus 8)
        Let decimal_result be binary_to_decimal(binary_byte)
        Let char_code be Parse decimal_result.converted_representation as Integer
        
        If char_code is greater than or equal to 0 and char_code is less than or equal to 127:
            Let ascii_char be StringCore.character_from_code(char_code)
            Set ascii_result to ascii_result joined with ascii_char
        Otherwise:
            Throw Errors.InvalidOperation with "Invalid ASCII code: " joined with String(char_code)
    
    Return ascii_result

Process called "number_to_words" that takes number as String, language as String returns String:
    Note: Convert numerical value to word representation
    Let num_value be Parse number as Integer
    
    If language is equal to "english" or language is equal to "en":
        Return convert_number_to_english_words(num_value)
    Otherwise if language is equal to "spanish" or language is equal to "es":
        Return convert_number_to_spanish_words(num_value)
    Otherwise if language is equal to "french" or language is equal to "fr":
        Return convert_number_to_french_words(num_value)
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported language for number conversion: " joined with language

Process called "words_to_number" that takes word_string as String, language as String returns String:
    Note: Parse word representation and convert to numerical value
    Let lowercase_words be StringCore.to_lowercase(word_string)
    
    If language is equal to "english" or language is equal to "en":
        Return convert_english_words_to_number(lowercase_words)
    Otherwise if language is equal to "spanish" or language is equal to "es":
        Return convert_spanish_words_to_number(lowercase_words)
    Otherwise if language is equal to "french" or language is equal to "fr":
        Return convert_french_words_to_number(lowercase_words)
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported language for word parsing: " joined with language

Note: =====================================================================
Note: VALIDATION AND UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_conversion_parameters" that takes conversion_request as Dictionary[String, String] returns List[String]:
    Note: Validate parameters for unit/base conversion operations
    Let validation_errors be Empty List[String]
    
    If not (conversion_request contains "value"):
        Add "Missing required parameter: value" to validation_errors
    Otherwise:
        Let value be conversion_request["value"]
        If Length(value) is equal to 0:
            Add "Value parameter cannot be empty" to validation_errors
        Otherwise:
            Try:
                Let test_parse be Parse value as Float
            Catch parse_error:
                Add "Invalid numeric value: " joined with value to validation_errors
    
    If not (conversion_request contains "from_unit"):
        Add "Missing required parameter: from_unit" to validation_errors
    Otherwise if Length(conversion_request["from_unit"]) is equal to 0:
        Add "from_unit parameter cannot be empty" to validation_errors
    
    If not (conversion_request contains "to_unit"):
        Add "Missing required parameter: to_unit" to validation_errors
    Otherwise if Length(conversion_request["to_unit"]) is equal to 0:
        Add "to_unit parameter cannot be empty" to validation_errors
    
    If conversion_request contains "conversion_type":
        Let conversion_type be conversion_request["conversion_type"]
        Let valid_types be ["length", "mass", "volume", "energy", "power", "pressure", "force", "temperature", "time", "frequency", "data", "bandwidth", "currency", "angular", "coordinate"]
        If not (conversion_type in valid_types):
            Add "Invalid conversion type: " joined with conversion_type to validation_errors
    
    If conversion_request contains "precision":
        Let precision_str be conversion_request["precision"]
        Try:
            Let precision_value be Parse precision_str as Integer
            If precision_value is less than 0:
                Add "Precision must be non-negative, got: " joined with precision_str to validation_errors
            Otherwise if precision_value is greater than 1000:
                Add "Precision too high (max 1000), got: " joined with precision_str to validation_errors
        Catch parse_error:
            Add "Invalid precision value: " joined with precision_str to validation_errors
    
    If conversion_request contains "base" and conversion_request["conversion_type"] is equal to "base":
        Let base_str be conversion_request["base"]
        Try:
            Let base_value be Parse base_str as Integer
            If base_value is less than 2 or base_value is greater than 36:
                Add "Base must be between 2 and 36, got: " joined with base_str to validation_errors
        Catch parse_error:
            Add "Invalid base value: " joined with base_str to validation_errors
    
    Return validation_errors

Process called "get_conversion_factor" that takes from_unit as String, to_unit as String, unit_system as String returns String:
    Note: Get conversion factor between two units in specified system
    
    If unit_system is equal to "length":
        Return get_length_conversion_factor(from_unit, to_unit)
    Otherwise if unit_system is equal to "mass":
        Return get_mass_conversion_factor(from_unit, to_unit)
    Otherwise if unit_system is equal to "volume":
        Return get_volume_conversion_factor(from_unit, to_unit)
    Otherwise if unit_system is equal to "energy":
        Return get_energy_conversion_factor(from_unit, to_unit)
    Otherwise if unit_system is equal to "power":
        Return get_power_conversion_factor(from_unit, to_unit)
    Otherwise if unit_system is equal to "pressure":
        Return get_pressure_conversion_factor(from_unit, to_unit)
    Otherwise if unit_system is equal to "force":
        Return get_force_conversion_factor(from_unit, to_unit)
    Otherwise if unit_system is equal to "temperature":
        Return get_temperature_conversion_factor(from_unit, to_unit)
    Otherwise if unit_system is equal to "time":
        Return get_time_conversion_factor(from_unit, to_unit)
    Otherwise if unit_system is equal to "angular":
        Return get_angular_conversion_factor(from_unit, to_unit)
    Otherwise:
        Throw Errors.InvalidOperation with "Unsupported unit system: " joined with unit_system

Process called "list_compatible_units" that takes unit_category as String, unit_system as String returns List[UnitDefinition]:
    Note: List all compatible units in specified category and system
    Let units be Empty List[UnitDefinition]
    
    If unit_category is equal to "length":
        Let meter be create_unit_definition("meter", "m", "length", "1", "SI")
        Let kilometer be create_unit_definition("kilometer", "km", "length", "1000", "SI")
        Let centimeter be create_unit_definition("centimeter", "cm", "length", "0.01", "SI")
        Let millimeter be create_unit_definition("millimeter", "mm", "length", "0.001", "SI")
        Let inch be create_unit_definition("inch", "in", "length", "0.0254", "Imperial")
        Let foot be create_unit_definition("foot", "ft", "length", "0.3048", "Imperial")
        Let yard be create_unit_definition("yard", "yd", "length", "0.9144", "Imperial")
        Let mile be create_unit_definition("mile", "mi", "length", "1609.344", "Imperial")
        
        If unit_system is equal to "SI" or unit_system is equal to "all":
            Add meter to units
            Add kilometer to units
            Add centimeter to units
            Add millimeter to units
        If unit_system is equal to "Imperial" or unit_system is equal to "all":
            Add inch to units
            Add foot to units
            Add yard to units
            Add mile to units
    
    Otherwise if unit_category is equal to "mass":
        Let kilogram be create_unit_definition("kilogram", "kg", "mass", "1", "SI")
        Let gram be create_unit_definition("gram", "g", "mass", "0.001", "SI")
        Let ton be create_unit_definition("ton", "t", "mass", "1000", "SI")
        Let pound be create_unit_definition("pound", "lb", "mass", "0.453592", "Imperial")
        Let ounce be create_unit_definition("ounce", "oz", "mass", "0.0283495", "Imperial")
        
        If unit_system is equal to "SI" or unit_system is equal to "all":
            Add kilogram to units
            Add gram to units
            Add ton to units
        If unit_system is equal to "Imperial" or unit_system is equal to "all":
            Add pound to units
            Add ounce to units
    
    Otherwise if unit_category is equal to "temperature":
        Let celsius be create_unit_definition("celsius", "°C", "temperature", "1", "SI")
        Let kelvin be create_unit_definition("kelvin", "K", "temperature", "1", "SI")
        Let fahrenheit be create_unit_definition("fahrenheit", "°F", "temperature", "5/9", "Imperial")
        Let rankine be create_unit_definition("rankine", "°R", "temperature", "5/9", "Imperial")
        
        If unit_system is equal to "SI" or unit_system is equal to "all":
            Add celsius to units
            Add kelvin to units
        If unit_system is equal to "Imperial" or unit_system is equal to "all":
            Add fahrenheit to units
            Add rankine to units
    
    Otherwise if unit_category is equal to "angular":
        Let degree be create_unit_definition("degree", "°", "angular", "π/180", "common")
        Let radian be create_unit_definition("radian", "rad", "angular", "1", "SI")
        Let gradian be create_unit_definition("gradian", "gon", "angular", "π/200", "common")
        Let turn be create_unit_definition("turn", "rev", "angular", "2π", "common")
        
        Add degree to units
        Add radian to units
        Add gradian to units
        Add turn to units
    
    Return units

Process called "benchmark_conversion_performance" that takes conversion_types as List[String], test_data as Dictionary[String, List[String]] returns Dictionary[String, Float]:
    Note: Benchmark performance of different conversion operations
    Let benchmark_results be Dictionary[String, Float]
    Let iterations_per_test be 1000
    
    For Each conversion_type in conversion_types:
        Let total_time be 0.0
        Let successful_conversions be 0
        
        If test_data contains conversion_type:
            Let test_values be test_data[conversion_type]
            
            For iteration from 1 to iterations_per_test:
                For Each test_value in test_values:
                    Let start_time be get_high_precision_timestamp()
                    
                    Try:
                        If conversion_type is equal to "length":
                            Let result be convert_length_units(test_value, "meters", "feet", 6)
                        Otherwise if conversion_type is equal to "mass":
                            Let result be convert_mass_units(test_value, "kilograms", "pounds", 6)
                        Otherwise if conversion_type is equal to "temperature":
                            Let result be celsius_to_fahrenheit(test_value, 6)
                        Otherwise if conversion_type is equal to "angular":
                            Let result be degrees_to_radians(test_value, 6)
                        Otherwise if conversion_type is equal to "time":
                            Let result be convert_time_units(test_value, "seconds", "minutes", 6)
                        Otherwise if conversion_type is equal to "base":
                            Let result be decimal_to_binary(test_value, 32)
                        Otherwise if conversion_type is equal to "scientific":
                            Let result be to_scientific_notation(test_value, 6)
                        Otherwise if conversion_type is equal to "percentage":
                            Let result be to_percentage(test_value, 2)
                        
                        Set successful_conversions to successful_conversions plus 1
                        
                    Catch conversion_error:
                        Continue
                    
                    Let end_time be get_high_precision_timestamp()
                    Set total_time to total_time plus (end_time minus start_time)
        
        If successful_conversions is greater than 0:
            Let average_time be total_time / Float(successful_conversions)
            Let conversions_per_second be 1.0 / average_time
            Set benchmark_results[conversion_type joined with "_avg_time"] to average_time
            Set benchmark_results[conversion_type joined with "_per_second"] to conversions_per_second
            Set benchmark_results[conversion_type joined with "_success_rate"] to Float(successful_conversions) / Float(iterations_per_test multiplied by Length(test_data[conversion_type])) multiplied by 100.0
        Otherwise:
            Set benchmark_results[conversion_type joined with "_avg_time"] to -1.0
            Set benchmark_results[conversion_type joined with "_per_second"] to 0.0
            Set benchmark_results[conversion_type joined with "_success_rate"] to 0.0
    
    Let overall_avg_time be 0.0
    Let valid_benchmarks be 0
    For Each key, value in benchmark_results:
        If ends_with(key, "_avg_time") and value is greater than 0.0:
            Set overall_avg_time to overall_avg_time plus value
            Set valid_benchmarks to valid_benchmarks plus 1
    
    If valid_benchmarks is greater than 0:
        Set benchmark_results["overall_average_time"] to overall_avg_time / Float(valid_benchmarks)
        Set benchmark_results["overall_conversions_per_second"] to 1.0 / (overall_avg_time / Float(valid_benchmarks))
    
    Return benchmark_results

Note: ========================================================================
Note: MISSING FUNCTIONS FOR AUTODIFF COMPATIBILITY
Note: String parsing and manipulation functions
Note: ========================================================================

Process called "parse_float" that takes input as String returns Float:
    Note: Parse string to float with error handling
    If input.length() is equal to 0:
        Throw Errors.InvalidArgument with "Cannot parse empty string as float"
    
    Note: Handle common special cases
    If input is equal to "inf" or input is equal to "infinity":
        Return Float.positive_infinity()
    If input is equal to "-inf" or input is equal to "-infinity":
        Return Float.negative_infinity()
    If input is equal to "nan":
        Return Float.nan()
    
    Note: Try to parse as standard float
    Let result be 0.0
    Let is_negative be false
    Let has_decimal be false
    Let decimal_places be 0
    Let start_index be 0
    
    Note: Handle negative sign
    If input[0] is equal to "-":
        Set is_negative to true
        Set start_index to 1
    Otherwise if input[0] is equal to "+":
        Set start_index to 1
    
    Note: Parse digits
    For i from start_index to input.length() minus 1:
        Let char be input[i]
        If char is equal to ".":
            If has_decimal:
                Throw Errors.InvalidArgument with "Multiple decimal points in number"
            Set has_decimal to true
        Otherwise if char is greater than or equal to "0" and char is less than or equal to "9":
            Let digit be Integer(char) minus Integer("0")
            If has_decimal:
                Set decimal_places to decimal_places plus 1
                Set result to result plus Float(digit) / Math.power(10.0, Float(decimal_places))
            Otherwise:
                Set result to result multiplied by 10.0 plus Float(digit)
        Otherwise:
            Throw Errors.InvalidArgument with "Invalid character in number: " plus char
    
    If is_negative:
        Set result to -result
    
    Return result

Process called "parse_boolean" that takes input as String returns Boolean:
    Note: Parse string to boolean with error handling
    If input.length() is equal to 0:
        Throw Errors.InvalidArgument with "Cannot parse empty string as boolean"
    
    Let lower_input be to_lowercase(input)
    
    If lower_input is equal to "true" or lower_input is equal to "1" or lower_input is equal to "yes":
        Return true
    If lower_input is equal to "false" or lower_input is equal to "0" or lower_input is equal to "no":
        Return false
    
    Throw Errors.InvalidArgument with "Cannot parse '" plus input plus "' as boolean"

Process called "split_string" that takes input as String, separator as String returns List[String]:
    Note: Split string by separator
    Let parts be Collections.create_list()
    
    If separator.length() is equal to 0:
        Throw Errors.InvalidArgument with "Separator cannot be empty"
    
    If input.length() is equal to 0:
        Collections.add_item(parts, "")
        Return parts
    
    Let current_part be ""
    Let i be 0
    
    While i is less than input.length():
        Let match be true
        
        Note: Check if separator matches at current position
        If i plus separator.length() is less than or equal to input.length():
            For j from 0 to separator.length() minus 1:
                If input[i plus j] does not equal separator[j]:
                    Set match to false
                    Break
        Otherwise:
            Set match to false
        
        If match:
            Collections.add_item(parts, current_part)
            Set current_part to ""
            Set i to i plus separator.length()
        Otherwise:
            Set current_part to current_part plus input[i]
            Set i to i plus 1
    
    Collections.add_item(parts, current_part)
    Return parts

Process called "substring_after" that takes input as String, marker as String returns String:
    Note: Get substring after first occurrence of marker
    If marker.length() is equal to 0:
        Return input
    
    If input.length() is equal to 0:
        Return ""
    
    Note: Find first occurrence of marker
    For i from 0 to input.length() minus marker.length():
        Let match be true
        For j from 0 to marker.length() minus 1:
            If input[i plus j] does not equal marker[j]:
                Set match to false
                Break
        
        If match:
            Note: Return substring after marker
            Let result be ""
            For k from i plus marker.length() to input.length() minus 1:
                Set result to result plus input[k]
            Return result
    
    Note: Marker not found, return empty string
    Return ""

Note: Helper function for lowercase conversion
Process called "to_lowercase" that takes input as String returns String:
    Let result be ""
    For i from 0 to input.length() minus 1:
        Let char be input[i]
        If char is greater than or equal to "A" and char is less than or equal to "Z":
            Let lower_char_code be Integer(char) minus Integer("A") plus Integer("a")
            Set result to result plus String(lower_char_code)
        Otherwise:
            Set result to result plus char
    Return result