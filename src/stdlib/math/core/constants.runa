Note:
math/core/constants.runa
Mathematical Constants and Fundamental Values

This module provides comprehensive mathematical constants including:
- Universal constants (PI, E, PHI, EULER_GAMMA)
- Arithmetic constants (ZERO, ONE, INFINITY, NaN handling)
- Physical constants (c, h, G, elementary charge)
- Computational constants (machine epsilon, overflow limits)
- Number theory constants (APERY, CATALAN, GLAISHER)
- Arbitrary precision constant generation
- Constant validation and precision management
- Unit circle and geometric constants
- Logarithmic and exponential constants
- Statistical and probabilistic constants
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "compiler/frontend/diagnostics/diagnostic_engine" as DiagnosticEngine
Import module "compiler/frontend/diagnostics/error_formatter" as ErrorFormatter
Import module "compiler/frontend/diagnostics/suggestion_engine" as SuggestionEngine

Note: =====================================================================
Note: MATHEMATICAL CONSTANT DATA STRUCTURES
Note: =====================================================================

Type called "MathematicalConstant":
    name as String
    symbol as String
    value as String
    precision as Integer
    decimal_places as Integer
    is_rational as Boolean
    is_algebraic as Boolean
    mathematical_definition as String
    historical_context as String
    computation_method as String
    error_occurred as Boolean
    error_code as String
    error_message as String
    precision_insufficient as Boolean
    computation_failed as Boolean
    diagnostic_info as DiagnosticInfo

Type called "ConstantPrecision":
    requested_digits as Integer
    computed_digits as Integer
    computation_time as Float
    method_used as String
    error_estimate as Float
    convergence_rate as String

Type called "PhysicalConstant":
    constant_name as String
    symbol as String
    value as String
    units as String
    uncertainty as String
    codata_year as String
    measurement_method as String

Type called "ComputationalLimit":
    limit_type as String
    value as String
    platform_dependent as Boolean
    affects_calculations as List[String]
    workaround_methods as List[String]

Note: =====================================================================
Note: ERROR HANDLING AND DIAGNOSTICS
Note: =====================================================================

Process called "create_constant_result" that takes name as String returns MathematicalConstant:
    Note: Initialize a new MathematicalConstant with default error handling
    Let result be MathematicalConstant
    Set result.name to name
    Set result.error_occurred to false
    Set result.error_code to ""
    Set result.error_message to ""
    Set result.precision_insufficient to false
    Set result.computation_failed to false
    Return result

Process called "handle_constant_error" that takes result as MathematicalConstant, error_code as String, context as String, operands as List[String] returns MathematicalConstant:
    Note: Handle constant computation errors with diagnostic integration
    Set result.error_occurred to true
    Set result.error_code to error_code
    
    Let diagnostic_info be Errors.create_diagnostic_info(error_code, context, operands)
    Set result.diagnostic_info to diagnostic_info
    
    Let source_location be DiagnosticEngine.get_current_source_location()
    Set result.error_message to ErrorFormatter.format_math_error(diagnostic_info, source_location)
    
    If error_code is equal to "CONST_PRECISION_INSUFFICIENT":
        Set result.precision_insufficient to true
        Call Errors.emit_warning(diagnostic_info)
    Otherwise if error_code is equal to "CONST_COMPUTATION_FAILED":
        Set result.computation_failed to true
        Call Errors.emit_warning(diagnostic_info)
    
    Return result

Note: =====================================================================
Note: UNIVERSAL MATHEMATICAL CONSTANTS
Note: =====================================================================

Process called "get_pi" that takes precision as Integer returns String:
    Note: Get π (pi) to specified precision using optimal algorithm
    If precision is less than or equal to 0:
        Let error_result be create_constant_result("pi")
        Let final_error be handle_constant_error(error_result, "CONST_PRECISION_INSUFFICIENT", "pi precision validation", [String(precision)])
        Return final_error.error_message
    If precision is less than or equal to 15:
        Return "3.141592653589793"
    Let pi_value be "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679"
    If precision is less than or equal to Length(pi_value) minus 2:
        Return Substring(pi_value, 0, precision plus 2)
Import module "math/engine/numerical/core" as NumericalCore
    Let result be NumericalCore.compute_pi_machin_formula(precision)
    Return result

Process called "get_e" that takes precision as Integer returns String:
    Note: Get e (Euler's number) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "2.718281828459045"
    Let e_value be "2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274"
    If precision is less than or equal to Length(e_value) minus 2:
        Return Substring(e_value, 0, precision plus 2)
Import module "math/symbolic/series" as Series
    Let result be Series.compute_e_taylor_series(precision)
    Return result

Process called "get_golden_ratio" that takes precision as Integer returns String:
    Note: Get φ (golden ratio) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "1.618033988749894"
    Let phi_value be "1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374"
    If precision is less than or equal to Length(phi_value) minus 2:
        Return Substring(phi_value, 0, precision plus 2)
Import module "math/engine/numerical/core" as NumericalCore
Import module "math/precision/bigdecimal" as BigDecimal
    Let sqrt5 be NumericalCore.get_sqrt_n(5, precision plus 10)
    Let one_plus_sqrt5 be BigDecimal.add_high_precision("1", sqrt5, precision plus 5)
    Let result be BigDecimal.divide_high_precision(one_plus_sqrt5, "2", precision)
    Return result

Process called "get_euler_gamma" that takes precision as Integer returns String:
    Note: Get γ (Euler-Mascheroni constant) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "0.577215664901532"
    Let gamma_value be "0.5772156649015328606065120900824024310421593359399235988057672348848677267776646709369470632917467495"
    If precision is less than or equal to Length(gamma_value) minus 2:
        Return Substring(gamma_value, 0, precision plus 2)
Import module "math/symbolic/series" as Series
    Let result be Series.compute_euler_gamma_series(precision)
    Return result

Process called "get_sqrt_2" that takes precision as Integer returns String:
    Note: Get √2 (square root of 2) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "1.414213562373095"
    Let sqrt2_value be "1.4142135623730950488016887242096980785696718753769480731766797379907324784621070388503875343276415727"
    If precision is less than or equal to Length(sqrt2_value) minus 2:
        Return Substring(sqrt2_value, 0, precision plus 2)
Import module "math/engine/numerical/rootfinding" as RootFinding
    Let result be RootFinding.compute_sqrt_newton_method("2", precision)
    Return result

Note: =====================================================================
Note: NUMBER THEORY CONSTANTS
Note: =====================================================================

Process called "get_apery_constant" that takes precision as Integer returns String:
    Note: Get ζ(3) (Apéry's constant) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "1.202056903159594"
    Let apery_value be "1.2020569031595942853997381615114499907649862923404988817922715553418382057863130901864558736093352581"
    If precision is less than or equal to Length(apery_value) minus 2:
        Return Substring(apery_value, 0, precision plus 2)
Import module "math/special/zeta" as ZetaFunctions
    Let result be ZetaFunctions.riemann_zeta("3", precision)
    Return result

Process called "get_catalan_constant" that takes precision as Integer returns String:
    Note: Get G (Catalan's constant) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "0.915965594177219"
    Let catalan_value be "0.9159655941772190150546035149323841107741493742816721342664981196217630197762547694793565129261151062"
    If precision is less than or equal to Length(catalan_value) minus 2:
        Return Substring(catalan_value, 0, precision plus 2)
Import module "math/symbolic/series" as Series
    Let result be Series.compute_catalan_constant_series(precision)
    Return result

Process called "get_glaisher_kinkelin" that takes precision as Integer returns String:
    Note: Get A (Glaisher-Kinkelin constant) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "1.282427129100623"
    Let glaisher_value be "1.2824271291006226368753425688697917277676889273250011920637400217404063088588264611297364477904946016"
    If precision is less than or equal to Length(glaisher_value) minus 2:
        Return Substring(glaisher_value, 0, precision plus 2)
Import module "math/special/gamma" as GammaFunctions
    Let result be GammaFunctions.compute_glaisher_kinkelin_constant(precision)
    Return result

Process called "get_khinchin_constant" that takes precision as Integer returns String:
    Note: Get K₀ (Khinchin's constant) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "2.685452001065306"
    Let khinchin_value be "2.6854520010653064453097148354817956938203822939944629530511523455572188595371520028011411749318476979"
    If precision is less than or equal to Length(khinchin_value) minus 2:
        Return Substring(khinchin_value, 0, precision plus 2)
Import module "math/discrete/number_theory" as NumberTheory
    Let result be NumberTheory.compute_khinchin_constant(precision)
    Return result

Note: =====================================================================
Note: PHYSICAL CONSTANTS
Note: =====================================================================

Process called "get_speed_of_light" that takes unit_system as String returns PhysicalConstant:
    Note: Get speed of light in vacuum (c) in specified units
    Let value be ""
    Let units be ""
    If unit_system is equal to "SI":
        Set value to "299792458"
        Set units to "m/s"
    If unit_system is equal to "CGS":
        Set value to "2.99792458e10"
        Set units to "cm/s"
    If unit_system is equal to "natural":
        Set value to "1"
        Set units to "c"
    If unit_system is equal to "imperial":
        Set value to "670616629"
        Set units to "mph"
    Return PhysicalConstant with:
        constant_name: "Speed of light in vacuum"
        symbol: "c"
        value: value
        units: units
        uncertainty: "0"
        codata_year: "2018"
        measurement_method: "defined"

Process called "get_planck_constant" that takes unit_system as String returns PhysicalConstant:
    Note: Get Planck constant (h) in specified units
    Let value be ""
    Let units be ""
    If unit_system is equal to "SI":
        Set value to "6.62607015e-34"
        Set units to "J⋅s"
    If unit_system is equal to "CGS":
        Set value to "6.62607015e-27"
        Set units to "erg⋅s"
    If unit_system is equal to "eV":
        Set value to "4.135667696e-15"
        Set units to "eV⋅s"
    If unit_system is equal to "natural":
        Set value to "1"
        Set units to "ℏ"
    Return PhysicalConstant with:
        constant_name: "Planck constant"
        symbol: "h"
        value: value
        units: units
        uncertainty: "0"
        codata_year: "2018"
        measurement_method: "defined"

Process called "get_gravitational_constant" that takes unit_system as String returns PhysicalConstant:
    Note: Get gravitational constant (G) in specified units
    Let value be ""
    Let units be ""
    Let uncertainty be ""
    If unit_system is equal to "SI":
        Set value to "6.67430e-11"
        Set units to "m³⋅kg⁻¹⋅s⁻²"
        Set uncertainty to "1.5e-15"
    If unit_system is equal to "CGS":
        Set value to "6.67430e-8"
        Set units to "cm³⋅g⁻¹⋅s⁻²"
        Set uncertainty to "1.5e-12"
    If unit_system is equal to "astronomical":
        Set value to "1.48818e-34"
        Set units to "AU³⋅M☉⁻¹⋅s⁻²"
        Set uncertainty to "3.3e-39"
    Return PhysicalConstant with:
        constant_name: "Gravitational constant"
        symbol: "G"
        value: value
        units: units
        uncertainty: uncertainty
        codata_year: "2018"
        measurement_method: "experimental"

Process called "get_elementary_charge" that takes unit_system as String returns PhysicalConstant:
    Note: Get elementary charge (e) in specified units
    Let value be ""
    Let units be ""
    If unit_system is equal to "SI":
        Set value to "1.602176634e-19"
        Set units to "C"
    If unit_system is equal to "CGS":
        Set value to "4.8032e-10"
        Set units to "esu"
    If unit_system is equal to "natural":
        Set value to "1"
        Set units to "e"
    If unit_system is equal to "atomic":
        Set value to "1"
        Set units to "au"
    Return PhysicalConstant with:
        constant_name: "Elementary charge"
        symbol: "e"
        value: value
        units: units
        uncertainty: "0"
        codata_year: "2018"
        measurement_method: "defined"

Note: =====================================================================
Note: COMPUTATIONAL CONSTANTS
Note: =====================================================================

Process called "get_machine_epsilon" that takes number_type as String returns ComputationalLimit:
    Note: Get machine epsilon for specified floating-point type
    Let epsilon_value be ""
    Let platform_dependent be True
    Let affects be List[String]
    If number_type is equal to "float32":
        Set epsilon_value to "1.1920929e-07"
        Append "floating_point_arithmetic" to affects
        Append "numerical_precision" to affects
    If number_type is equal to "float64":
        Set epsilon_value to "2.220446049250313e-16"
        Append "double_precision_arithmetic" to affects
        Append "scientific_calculations" to affects
    If number_type is equal to "decimal128":
        Set epsilon_value to "1e-33"
        Set platform_dependent to False
        Append "financial_calculations" to affects
    Let workarounds be List with: "use_arbitrary_precision", "interval_arithmetic", "error_analysis"
    Return ComputationalLimit with:
        limit_type: "machine_epsilon"
        value: epsilon_value
        platform_dependent: platform_dependent
        affects_calculations: affects
        workaround_methods: workarounds

Process called "get_max_safe_integer" that takes integer_type as String returns ComputationalLimit:
    Note: Get maximum safe integer for specified type
    Let max_value be ""
    Let affects be List[String]
    If integer_type is equal to "int32":
        Set max_value to "2147483647"
        Append "32bit_arithmetic" to affects
    If integer_type is equal to "int64":
        Set max_value to "9223372036854775807"
        Append "64bit_arithmetic" to affects
    If integer_type is equal to "uint64":
        Set max_value to "18446744073709551615"
        Append "unsigned_arithmetic" to affects
    If integer_type is equal to "javascript_safe":
        Set max_value to "9007199254740991"
        Append "floating_point_integers" to affects
        Append "web_compatibility" to affects
    Let workarounds be List with: "use_biginteger", "chunked_arithmetic", "modular_arithmetic"
    Return ComputationalLimit with:
        limit_type: "max_safe_integer"
        value: max_value
        platform_dependent: True
        affects_calculations: affects
        workaround_methods: workarounds

Process called "get_overflow_threshold" that takes number_type as String returns ComputationalLimit:
    Note: Get overflow threshold for specified numeric type
    Let threshold_value be ""
    Let affects be List[String]
    If number_type is equal to "float32":
        Set threshold_value to "3.4028235e+38"
        Append "single_precision_overflow" to affects
    If number_type is equal to "float64":
        Set threshold_value to "1.7976931348623157e+308"
        Append "double_precision_overflow" to affects
    If number_type is equal to "decimal128":
        Set threshold_value to "9.999999999999999999999999999999999e+6144"
        Append "decimal_overflow" to affects
    Let workarounds be List with: "range_checking", "saturation_arithmetic", "arbitrary_precision"
    Return ComputationalLimit with:
        limit_type: "overflow_threshold"
        value: threshold_value
        platform_dependent: True
        affects_calculations: affects
        workaround_methods: workarounds

Process called "get_underflow_threshold" that takes number_type as String returns ComputationalLimit:
    Note: Get underflow threshold for specified numeric type
    Let threshold_value be ""
    Let affects be List[String]
    If number_type is equal to "float32":
        Set threshold_value to "1.175494e-38"
        Append "single_precision_underflow" to affects
        Append "denormalized_numbers" to affects
    If number_type is equal to "float64":
        Set threshold_value to "2.2250738585072014e-308"
        Append "double_precision_underflow" to affects
        Append "subnormal_numbers" to affects
    If number_type is equal to "decimal128":
        Set threshold_value to "1e-6143"
        Append "decimal_underflow" to affects
    Let workarounds be List with: "range_checking", "gradual_underflow", "scaled_arithmetic"
    Return ComputationalLimit with:
        limit_type: "underflow_threshold"
        value: threshold_value
        platform_dependent: True
        affects_calculations: affects
        workaround_methods: workarounds

Note: =====================================================================
Note: GEOMETRIC CONSTANTS
Note: =====================================================================

Process called "get_unit_circle_circumference" that takes precision as Integer returns String:
    Note: Get circumference of unit circle (2π) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    Let pi_value be get_pi(precision plus 1)
Import module "math/precision/bigdecimal" as BigDecimal
    Let result be BigDecimal.multiply_high_precision("2", pi_value, precision)
    Return result

Process called "get_unit_sphere_surface_area" that takes precision as Integer returns String:
    Note: Get surface area of unit sphere (4π) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    Let pi_value be get_pi(precision plus 1)
Import module "math/precision/bigdecimal" as BigDecimal
    Let result be BigDecimal.multiply_high_precision("4", pi_value, precision)
    Return result

Process called "get_unit_sphere_volume" that takes precision as Integer returns String:
    Note: Get volume of unit sphere (4π/3) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    Let pi_value be get_pi(precision plus 2)
Import module "math/precision/bigdecimal" as BigDecimal
    Let four_pi be BigDecimal.multiply_high_precision("4", pi_value, precision plus 1)
    Let result be BigDecimal.divide_high_precision(four_pi, "3", precision)
    Return result

Note: =====================================================================
Note: LOGARITHMIC AND EXPONENTIAL CONSTANTS
Note: =====================================================================

Process called "get_natural_log_2" that takes precision as Integer returns String:
    Note: Get ln(2) (natural logarithm of 2) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "0.693147180559945"
    Let ln2_value be "0.6931471805599453094172321214581765680755001343602552541206800094933936219696947156058633269964186875"
    If precision is less than or equal to Length(ln2_value) minus 2:
        Return Substring(ln2_value, 0, precision plus 2)
Import module "math/engine/numerical/core" as NumericalCore
    Let result be NumericalCore.natural_log_high_precision("2", precision)
    Return result

Process called "get_natural_log_10" that takes precision as Integer returns String:
    Note: Get ln(10) (natural logarithm of 10) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "2.302585092994046"
    Let ln10_value be "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983"
    If precision is less than or equal to Length(ln10_value) minus 2:
        Return Substring(ln10_value, 0, precision plus 2)
Import module "math/engine/numerical/core" as NumericalCore
    Let result be NumericalCore.natural_log_high_precision("10", precision)
    Return result

Process called "get_log10_e" that takes precision as Integer returns String:
    Note: Get log₁₀(e) (common logarithm of e) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "0.434294481903252"
    Let log10e_value be "0.4342944819032518276511289189166050822943970058036665661144537831658646492088707747292249493384317483"
    If precision is less than or equal to Length(log10e_value) minus 2:
        Return Substring(log10e_value, 0, precision plus 2)
Import module "math/precision/bigdecimal" as BigDecimal
    Let ln10 be get_natural_log_10(precision plus 5)
    Let result be BigDecimal.divide_high_precision("1", ln10, precision)
    Return result

Process called "get_log2_e" that takes precision as Integer returns String:
    Note: Get log₂(e) (binary logarithm of e) to specified precision
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "1.442695040888963"
    Let log2e_value be "1.4426950408889634073599246810018921374266459541529859341354494069311092191811850798855266228935063444"
    If precision is less than or equal to Length(log2e_value) minus 2:
        Return Substring(log2e_value, 0, precision plus 2)
Import module "math/precision/bigdecimal" as BigDecimal
    Let ln2 be get_natural_log_2(precision plus 5)
    Let result be BigDecimal.divide_high_precision("1", ln2, precision)
    Return result

Note: =====================================================================
Note: STATISTICAL CONSTANTS
Note: =====================================================================

Process called "get_normal_distribution_normalization" that takes precision as Integer returns String:
    Note: Get 1/√(2π) for normal distribution normalization
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "0.398942280401433"
    Let pi_value be get_pi(precision plus 5)
Import module "math/precision/bigdecimal" as BigDecimal
Import module "math/engine/numerical/core" as NumericalCore
    Let two_pi be BigDecimal.multiply_high_precision("2", pi_value, precision plus 4)
    Let sqrt_two_pi be NumericalCore.get_sqrt_n(Parse two_pi as Integer, precision plus 3)
    Let result be BigDecimal.divide_high_precision("1", sqrt_two_pi, precision)
    Return result

Process called "get_stirling_approximation_constant" that takes precision as Integer returns String:
    Note: Get √(2π) for Stirling's approximation
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If precision is less than or equal to 15:
        Return "2.506628274631000"
    Let pi_value be get_pi(precision plus 3)
Import module "math/precision/bigdecimal" as BigDecimal
Import module "math/engine/numerical/core" as NumericalCore
    Let two_pi be BigDecimal.multiply_high_precision("2", pi_value, precision plus 2)
    Let result be NumericalCore.get_sqrt_n(Parse two_pi as Integer, precision)
    Return result

Process called "get_chi_squared_normalization" that takes degrees_of_freedom as Integer, precision as Integer returns String:
    Note: Get normalization constant for chi-squared distribution
    If precision is less than or equal to 0:
        Throw Errors.InvalidOperation with "Precision must be positive"
    If degrees_of_freedom is less than or equal to 0:
        Throw Errors.InvalidOperation with "Degrees of freedom must be positive"
Import module "math/special/gamma" as GammaFunctions
Import module "math/precision/bigdecimal" as BigDecimal
    Let dof_half be BigDecimal.divide_high_precision(ToString(degrees_of_freedom), "2", precision plus 5)
    Let gamma_value be GammaFunctions.gamma_function(dof_half, precision plus 3)
    Let ln2 be get_natural_log_2(precision plus 3)
    Let power_term be BigDecimal.multiply_high_precision(dof_half, ln2, precision plus 2)
    Let two_power be exponential_high_precision(power_term, precision plus 2)
    Let result be BigDecimal.divide_high_precision("1", BigDecimal.multiply_high_precision(gamma_value, two_power, precision plus 1), precision)
    Return result

Note: =====================================================================
Note: CONSTANT COMPUTATION OPERATIONS
Note: =====================================================================

Process called "compute_constant_arbitrary_precision" that takes constant_name as String, precision as Integer, algorithm as String returns Dictionary[String, String]:
    Note: Compute mathematical constant to arbitrary precision
    Let computation_start_time be current_timestamp()
    Let result_value be ""
    Let method_used be ""
    Let error_estimate be 0.0
    If constant_name is equal to "pi":
        If algorithm is equal to "machin":
Import module "math/engine/numerical/core" as NumericalCore
            Set result_value to NumericalCore.compute_pi_machin_formula(precision)
            Set method_used to "Machin formula"
        If algorithm is equal to "chudnovsky":
Import module "math/symbolic/series" as Series
            Set result_value to Series.compute_pi_chudnovsky_series(precision)
            Set method_used to "Chudnovsky algorithm"
        Set error_estimate to Power(10.0, Negate(precision))
    If constant_name is equal to "e":
Import module "math/symbolic/series" as Series
        Set result_value to Series.compute_e_taylor_series(precision)
        Set method_used to "Taylor series"
        Set error_estimate to Power(10.0, Negate(precision minus 1))
    If constant_name is equal to "golden_ratio":
        Set result_value to get_golden_ratio(precision)
        Set method_used to "Algebraic formula"
        Set error_estimate to Power(10.0, Negate(precision))
    Let computation_end_time be current_timestamp()
    Return Dictionary with:
        "value": result_value
        "method": method_used
        "precision": ToString(precision)
        "error_estimate": ToString(error_estimate)
        "computation_time": ToString(computation_end_time minus computation_start_time)
        "algorithm": algorithm

Process called "validate_constant_precision" that takes computed_value as String, known_reference as String, tolerance as Float returns Boolean:
    Note: Validate computed constant against known reference
Import module "math/precision/bigdecimal" as BigDecimal
    Let difference be BigDecimal.subtract_high_precision(computed_value, known_reference, 50)
    Let abs_difference be AbsoluteValue(Parse difference as Float)
    If abs_difference is less than or equal to tolerance:
        Return True
    Return False

Process called "optimize_constant_algorithm" that takes constant_type as String, precision_requirement as Integer returns String:
    Note: Select optimal algorithm for constant computation
    If constant_type is equal to "pi":
        If precision_requirement is less than or equal to 100:
            Return "machin"
        If precision_requirement is less than or equal to 10000:
            Return "chudnovsky"
        Return "ramanujan"
    If constant_type is equal to "e":
        If precision_requirement is less than or equal to 1000:
            Return "taylor_series"
        Return "continued_fraction"
    If constant_type is equal to "golden_ratio":
        Return "algebraic_formula"
    If constant_type is equal to "euler_gamma":
        If precision_requirement is less than or equal to 500:
            Return "harmonic_series"
        Return "brent_mcmillan"
    Return "default"

Process called "estimate_computation_time" that takes constant_name as String, precision as Integer, algorithm as String returns Float:
    Note: Estimate time required for constant computation
    Let base_time be 0.001
    Let complexity_factor be 1.0
    If constant_name is equal to "pi":
        If algorithm is equal to "machin":
            Set complexity_factor to precision multiplied by Log(precision) multiplied by 0.0001
        If algorithm is equal to "chudnovsky":
            Set complexity_factor to precision multiplied by 0.0001
        If algorithm is equal to "ramanujan":
            Set complexity_factor to precision multiplied by 0.00005
    If constant_name is equal to "e":
        If algorithm is equal to "taylor_series":
            Set complexity_factor to precision multiplied by 0.0002
        If algorithm is equal to "continued_fraction":
            Set complexity_factor to precision multiplied by 0.0001
    If constant_name is equal to "golden_ratio":
        Set complexity_factor to 0.001
    Let estimated_time be base_time multiplied by complexity_factor
    Return estimated_time

Note: =====================================================================
Note: CONSTANT SERIES OPERATIONS
Note: =====================================================================

Process called "compute_pi_series" that takes series_type as String, precision as Integer returns Dictionary[String, String]:
    Note: Compute π using various series (Leibniz, Machin, Chudnovsky)
    Let computation_start be current_timestamp()
    Let result_value be ""
    Let convergence_rate be ""
    Let terms_used be 0
    If series_type is equal to "leibniz":
Import module "math/symbolic/series" as Series
        Set result_value to Series.compute_pi_leibniz_series(precision)
        Set convergence_rate to "O(1/n)"
        Set terms_used to precision multiplied by 10
    If series_type is equal to "machin":
Import module "math/engine/numerical/core" as NumericalCore
        Set result_value to NumericalCore.compute_pi_machin_formula(precision)
        Set convergence_rate to "O(1/5^n)"
        Set terms_used to precision / 2
    If series_type is equal to "chudnovsky":
Import module "math/symbolic/series" as Series
        Set result_value to Series.compute_pi_chudnovsky_series(precision)
        Set convergence_rate to "O(1/426880^n)"
        Set terms_used to precision / 14
    If series_type is equal to "ramanujan":
Import module "math/symbolic/series" as Series
        Set result_value to Series.compute_pi_ramanujan_series(precision)
        Set convergence_rate to "O(1/99^n)"
        Set terms_used to precision / 8
    Let computation_end be current_timestamp()
    Return Dictionary with:
        "value": result_value
        "series_type": series_type
        "convergence_rate": convergence_rate
        "terms_used": ToString(terms_used)
        "computation_time": ToString(computation_end minus computation_start)
        "precision_achieved": ToString(precision)

Process called "compute_e_series" that takes series_type as String, precision as Integer returns Dictionary[String, String]:
    Note: Compute e using various series expansions
    Let computation_start be current_timestamp()
    Let result_value be ""
    Let convergence_rate be ""
    Let terms_used be 0
    If series_type is equal to "taylor":
Import module "math/symbolic/series" as Series
        Set result_value to Series.compute_e_taylor_series(precision)
        Set convergence_rate to "O(1/n!)"
        Set terms_used to precision plus 10
    If series_type is equal to "continued_fraction":
Import module "math/symbolic/series" as Series
        Set result_value to Series.compute_e_continued_fraction(precision)
        Set convergence_rate to "Exponential"
        Set terms_used to precision / 2
    If series_type is equal to "limit":
Import module "math/symbolic/series" as Series
        Set result_value to Series.compute_e_limit_definition(precision)
        Set convergence_rate to "O(1/n^n)"
        Set terms_used to Power(10, precision / 10)
    Let computation_end be current_timestamp()
    Return Dictionary with:
        "value": result_value
        "series_type": series_type
        "convergence_rate": convergence_rate
        "terms_used": ToString(terms_used)
        "computation_time": ToString(computation_end minus computation_start)
        "precision_achieved": ToString(precision)

Process called "compute_zeta_function" that takes s as String, precision as Integer returns String:
    Note: Compute Riemann zeta function ζ(s) for specific values
Import module "math/special/zeta" as ZetaFunctions
    If s is equal to "2":
        Let pi_value be get_pi(precision plus 3)
Import module "math/precision/bigdecimal" as BigDecimal
        Let pi_squared be BigDecimal.multiply_high_precision(pi_value, pi_value, precision plus 2)
        Let result be BigDecimal.divide_high_precision(pi_squared, "6", precision)
        Return result
    If s is equal to "3":
        Return get_apery_constant(precision)
    If s is equal to "4":
        Let pi_value be get_pi(precision plus 5)
Import module "math/precision/bigdecimal" as BigDecimal
        Let pi_fourth be BigDecimal.multiply_high_precision(pi_value, pi_value, precision plus 4)
        Set pi_fourth to BigDecimal.multiply_high_precision(pi_fourth, pi_fourth, precision plus 3)
        Let result be BigDecimal.divide_high_precision(pi_fourth, "90", precision)
        Return result
    Let result be ZetaFunctions.riemann_zeta(s, precision)
    Return result

Note: =====================================================================
Note: CONSTANT RELATIONSHIP OPERATIONS
Note: =====================================================================

Process called "verify_constant_relationships" that takes constant_set as List[String], precision as Integer returns List[Dictionary[String, String]]:
    Note: Verify mathematical relationships between constants
    Let verification_results be Empty List[Dictionary[String, String]]
    For Each constant in constant_set:
        If constant is equal to "euler_identity":
            Let e_val be get_e(precision plus 5)
            Let pi_val be get_pi(precision plus 5)
Import module "math/engine/numerical/core" as NumericalCore
Import module "math/precision/bigdecimal" as BigDecimal
            Let i_pi be BigDecimal.multiply_high_precision(pi_val, "i", precision plus 3)
            Let exp_i_pi be NumericalCore.exponential_high_precision(i_pi, precision plus 2)
            Let result be BigDecimal.add_high_precision(exp_i_pi, "1", precision)
            Let is_zero be AbsoluteValue(Parse result as Float) is less than Power(10.0, Negate(precision minus 2))
            Append Dictionary with: "relationship": "e^(iπ) plus 1 is equal to 0", "verified": ToString(is_zero), "error": result to verification_results
        If constant is equal to "golden_ratio_properties":
            Let phi be get_golden_ratio(precision plus 3)
            Let phi_squared be BigDecimal.multiply_high_precision(phi, phi, precision plus 2)
            Let phi_plus_one be BigDecimal.add_high_precision(phi, "1", precision plus 1)
            Let diff be BigDecimal.subtract_high_precision(phi_squared, phi_plus_one, precision)
            Let is_valid be AbsoluteValue(Parse diff as Float) is less than Power(10.0, Negate(precision minus 2))
            Append Dictionary with: "relationship": "φ² is equal to φ plus 1", "verified": ToString(is_valid), "error": diff to verification_results
        If constant is equal to "zeta_2_identity":
            Let pi_val be get_pi(precision plus 3)
            Let pi_squared be BigDecimal.multiply_high_precision(pi_val, pi_val, precision plus 2)
            Let zeta_2_theoretical be BigDecimal.divide_high_precision(pi_squared, "6", precision plus 1)
            Let zeta_2_computed be compute_zeta_function("2", precision)
            Let diff be BigDecimal.subtract_high_precision(zeta_2_theoretical, zeta_2_computed, precision)
            Let is_valid be AbsoluteValue(Parse diff as Float) is less than Power(10.0, Negate(precision minus 2))
            Append Dictionary with: "relationship": "ζ(2) is equal to π²/6", "verified": ToString(is_valid), "error": diff to verification_results
    Return verification_results

Process called "derive_constant_from_others" that takes target_constant as String, base_constants as List[String], precision as Integer returns String:
    Note: Derive one constant from others using known relationships
Import module "math/precision/bigdecimal" as BigDecimal
    If target_constant is equal to "pi" AND "zeta_2" in base_constants:
        Let zeta_2 be compute_zeta_function("2", precision plus 3)
        Let six_zeta_2 be BigDecimal.multiply_high_precision("6", zeta_2, precision plus 2)
Import module "math/engine/numerical/core" as NumericalCore
        Let result be NumericalCore.get_sqrt_n(Parse six_zeta_2 as Integer, precision)
        Return result
    If target_constant is equal to "golden_ratio" AND "sqrt_5" in base_constants:
        Let sqrt_5 be get_sqrt_n(5, precision plus 2)
        Let one_plus_sqrt5 be BigDecimal.add_high_precision("1", sqrt_5, precision plus 1)
        Let result be BigDecimal.divide_high_precision(one_plus_sqrt5, "2", precision)
        Return result
    If target_constant is equal to "log10_e" AND "ln_10" in base_constants:
        Let ln_10 be get_natural_log_10(precision plus 2)
        Let result be BigDecimal.divide_high_precision("1", ln_10, precision)
        Return result
    If target_constant is equal to "log2_e" AND "ln_2" in base_constants:
        Let ln_2 be get_natural_log_2(precision plus 2)
        Let result be BigDecimal.divide_high_precision("1", ln_2, precision)
        Return result
    If target_constant is equal to "stirling_constant" AND "pi" in base_constants:
        Let pi_val be get_pi(precision plus 2)
        Let two_pi be BigDecimal.multiply_high_precision("2", pi_val, precision plus 1)
Import module "math/engine/numerical/core" as NumericalCore
        Let result be NumericalCore.get_sqrt_n(Parse two_pi as Integer, precision)
        Return result
    Throw Errors.InvalidOperation with "Cannot derive " joined with target_constant joined with " from given constants"

Process called "find_rational_approximations" that takes constant_value as String, max_denominator as Integer returns List[Dictionary[String, String]]:
    Note: Find rational approximations to irrational constants
    Let approximations be Empty List[Dictionary[String, String]]
    Let target_value be Parse constant_value as Float
    Let best_error be 1.0
    For denominator from 1 to max_denominator:
        Let numerator be Round(target_value multiplied by denominator)
        Let approximation be numerator / denominator
        Let error be AbsoluteValue(target_value minus approximation)
        If error is less than best_error:
            Set best_error to error
            Append Dictionary with:
                "numerator": ToString(numerator)
                "denominator": ToString(denominator)
                "decimal_value": ToString(approximation)
                "error": ToString(error)
                "relative_error": ToString(error / target_value)
            to approximations
        If error is less than Power(10.0, -12):
            Break
    Return approximations

Note: =====================================================================
Note: CONSTANT STORAGE OPERATIONS
Note: =====================================================================

Process called "cache_computed_constant" that takes constant_info as MathematicalConstant, storage_options as Dictionary[String, String] returns Boolean:
    Note: Cache computed constant for future use
    Let cache_key be constant_info.name joined with "_" joined with ToString(constant_info.precision)
    Let cache_directory be storage_options["cache_directory"]
    Let compression_enabled be storage_options["compression"] is equal to "true"
    Let cache_entry be Dictionary with:
        "name": constant_info.name
        "value": constant_info.value
        "precision": ToString(constant_info.precision)
        "computation_method": constant_info.computation_method
        "timestamp": ToString(current_timestamp())
        "mathematical_definition": constant_info.mathematical_definition
        "is_verified": "true"
    Let cache_file_path be cache_directory joined with "/" joined with cache_key joined with ".cache"
    Let serialized_data be serialize_to_json(cache_entry)
    If compression_enabled:
        Set serialized_data to compress_data(serialized_data, "gzip")
    Let write_success be write_to_file(cache_file_path, serialized_data)
    If write_success:
        Let index_file be cache_directory joined with "/cache_index.json"
        Let index_entry be Dictionary with: cache_key: cache_file_path
        Let append_success be append_to_json_file(index_file, index_entry)
        Return append_success
    Return False

Process called "load_cached_constant" that takes constant_name as String, precision as Integer returns MathematicalConstant:
    Note: Load previously cached constant
    Let cache_key be constant_name joined with "_" joined with ToString(precision)
    Let cache_directory be get_cache_directory()
    Let index_file be cache_directory joined with "/cache_index.json"
    Let cache_index be load_json_file(index_file)
    If cache_key in cache_index:
        Let cache_file_path be cache_index[cache_key]
        Let cached_data be read_from_file(cache_file_path)
        Let is_compressed be ends_with(cache_file_path, ".gz")
        If is_compressed:
            Set cached_data to decompress_data(cached_data, "gzip")
        Let cache_entry be deserialize_from_json(cached_data)
        Let age_hours be (current_timestamp() minus Parse cache_entry["timestamp"] as Float) / 3600.0
        If age_hours is less than 168.0:
            Return MathematicalConstant with:
                name: cache_entry["name"]
                symbol: extract_symbol(cache_entry["name"])
                value: cache_entry["value"]
                precision: Parse cache_entry["precision"] as Integer
                decimal_places: Length(cache_entry["value"]) minus 2
                is_rational: False
                is_algebraic: determine_algebraic_nature(cache_entry["name"])
                mathematical_definition: cache_entry["mathematical_definition"]
                historical_context: get_historical_context(cache_entry["name"])
                computation_method: cache_entry["computation_method"]
        otherwise:
            Let delete_success be delete_file(cache_file_path)
    Throw Errors.NotFound with "Cached constant not found: " joined with cache_key

Process called "manage_constant_precision_levels" that takes precision_requirements as Dictionary[String, Integer] returns Dictionary[String, String]:
    Note: Manage different precision levels for constants
    Let precision_status be Dictionary[String, String]
    Let available_constants be List with: "pi", "e", "golden_ratio", "euler_gamma", "sqrt_2", "ln_2", "ln_10"
    For Each constant_name in precision_requirements:
        Let required_precision be precision_requirements[constant_name]
        If constant_name in available_constants:
            Let optimal_algorithm be optimize_constant_algorithm(constant_name, required_precision)
            Let estimated_time be estimate_computation_time(constant_name, required_precision, optimal_algorithm)
            Let cache_key be constant_name joined with "_" joined with ToString(required_precision)
            Let is_cached be check_cache_exists(cache_key)
            If is_cached:
                Set precision_status[constant_name] to "cached_available"
            otherwise:
                If estimated_time is less than 1.0:
                    Set precision_status[constant_name] to "compute_immediately"
                If estimated_time is less than 60.0:
                    Set precision_status[constant_name] to "compute_on_demand"
                otherwise:
                    Set precision_status[constant_name] to "schedule_background_computation"
        otherwise:
            Set precision_status[constant_name] to "unsupported_constant"
    Return precision_status

Note: =====================================================================
Note: CONSTANT VALIDATION OPERATIONS
Note: =====================================================================

Process called "validate_constant_definition" that takes constant_definition as MathematicalConstant returns List[String]:
    Note: Validate mathematical constant definition for correctness
    Let validation_errors be Empty List[String]
    If Length(constant_definition.name) is equal to 0:
        Append "Constant name cannot be empty" to validation_errors
    If Length(constant_definition.value) is equal to 0:
        Append "Constant value cannot be empty" to validation_errors
    If constant_definition.precision is less than or equal to 0:
        Append "Precision must be positive" to validation_errors
    If constant_definition.decimal_places is less than 0:
        Append "Decimal places cannot be negative" to validation_errors
    Let parsed_value be Parse constant_definition.value as Float
    If IsNaN(parsed_value):
        Append "Constant value is not a valid number" to validation_errors
    If IsInfinite(parsed_value):
        Append "Constant value cannot be infinite" to validation_errors
    Let expected_decimal_places be Length(constant_definition.value) minus 2
    If constant_definition.decimal_places does not equal expected_decimal_places:
        Append "Decimal places count does not match value length" to validation_errors
    If constant_definition.name is equal to "pi":
        If parsed_value is less than 3.1 OR parsed_value is greater than 3.2:
            Append "Pi value is outside expected range [3.1, 3.2]" to validation_errors
    If constant_definition.name is equal to "e":
        If parsed_value is less than 2.7 OR parsed_value is greater than 2.8:
            Append "E value is outside expected range [2.7, 2.8]" to validation_errors
    If constant_definition.name is equal to "golden_ratio":
        If parsed_value is less than 1.6 OR parsed_value is greater than 1.7:
            Append "Golden ratio value is outside expected range [1.6, 1.7]" to validation_errors
    If Length(constant_definition.computation_method) is equal to 0:
        Append "Computation method must be specified" to validation_errors
    Return validation_errors

Process called "check_constant_convergence" that takes computation_sequence as List[String], convergence_criteria as Dictionary[String, Float] returns Boolean:
    Note: Check convergence of constant computation sequence
    Let sequence_length be Length(computation_sequence)
    If sequence_length is less than 3:
        Return False
    Let tolerance be convergence_criteria["tolerance"]
    Let min_stable_iterations be Parse convergence_criteria["min_stable_iterations"] as Integer
    Let recent_values be computation_sequence[sequence_length minus min_stable_iterations:]
    Let target_value be Parse recent_values[Length(recent_values) minus 1] as Float
    Let is_converged be True
    For Each value in recent_values:
        Let current_value be Parse value as Float
        Let difference be AbsoluteValue(current_value minus target_value)
        If difference is greater than tolerance:
            Set is_converged to False
            Break
    If is_converged:
        Let convergence_rate be 0.0
        If sequence_length is greater than or equal to 4:
            Let prev_diff be AbsoluteValue(Parse computation_sequence[sequence_length minus 2] as Float minus Parse computation_sequence[sequence_length minus 3] as Float)
            Let curr_diff be AbsoluteValue(Parse computation_sequence[sequence_length minus 1] as Float minus Parse computation_sequence[sequence_length minus 2] as Float)
            If prev_diff is greater than 0.0:
                Set convergence_rate to curr_diff / prev_diff
        Return convergence_rate is less than 1.0
    Return False

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "list_available_constants" that takes category as String returns List[MathematicalConstant]:
    Note: List all available mathematical constants by category
    Let constants be Empty List[MathematicalConstant]
    
    If category is equal to "universal" or category is equal to "all":
        Let pi_constant be MathematicalConstant with:
            name: "Pi"
            symbol: "π"
            value: "3.1415926535897932384626433832795"
            precision: 50
            decimal_places: 50
            is_rational: false
            is_algebraic: false
            mathematical_definition: "π is equal to C/d where C is circumference, d is diameter"
            historical_context: "Known to ancient civilizations, rigorously defined in 18th century"
            computation_method: "Machin formula, Chudnovsky algorithm"
        Append pi_constant to constants
        
        Let e_constant be MathematicalConstant with:
            name: "Euler's number"
            symbol: "e"
            value: "2.7182818284590452353602874713527"
            precision: 50
            decimal_places: 50
            is_rational: false
            is_algebraic: false
            mathematical_definition: "e is equal to lim(n→∞) (1 plus 1/n)^n is equal to Σ(n=0→∞) 1/n!"
            historical_context: "Discovered by Euler in 18th century"
            computation_method: "Taylor series, continued fractions"
        Append e_constant to constants
        
        Let phi_constant be MathematicalConstant with:
            name: "Golden ratio"
            symbol: "φ"
            value: "1.6180339887498948482045868343656"
            precision: 50
            decimal_places: 50
            is_rational: false
            is_algebraic: true
            mathematical_definition: "φ is equal to (1 plus √5)/2"
            historical_context: "Known to ancient Greeks, studied in Renaissance"
            computation_method: "Algebraic formula, continued fractions"
        Append phi_constant to constants
    
    If category is equal to "physical" or category is equal to "all":
        Let c_constant be MathematicalConstant with:
            name: "Speed of light"
            symbol: "c"
            value: "299792458"
            precision: 9
            decimal_places: 0
            is_rational: true
            is_algebraic: true
            mathematical_definition: "c is equal to 299,792,458 m/s (exact by definition)"
            historical_context: "Measured by various methods, defined exactly in 1983"
            computation_method: "Defined constant"
        Append c_constant to constants
    
    If category is equal to "computational" or category is equal to "all":
        Let epsilon_constant be MathematicalConstant with:
            name: "Machine epsilon"
            symbol: "ε"
            value: "2.220446049250313080847263336181640625e-16"
            precision: 17
            decimal_places: 50
            is_rational: true
            is_algebraic: true
            mathematical_definition: "Smallest representable positive floating point number"
            historical_context: "IEEE 754 double precision standard"
            computation_method: "Hardware/software dependent"
        Append epsilon_constant to constants
    
    Return constants

Process called "get_constant_information" that takes constant_name as String returns MathematicalConstant:
    Note: Get detailed information about a mathematical constant
    
    If constant_name is equal to "pi":
        Let pi_info be MathematicalConstant with:
            name: "Pi"
            symbol: "π"
            value: "3.1415926535897932384626433832795028841971693993751"
            precision: 50
            decimal_places: 50
            is_rational: false
            is_algebraic: false
            mathematical_definition: "π is equal to C/d where C is circumference, d is diameter of a circle"
            historical_context: "Used by Babylonians ~1900 BCE, symbol π introduced by William Jones 1706"
            computation_method: "Machin formula, Chudnovsky algorithm, Bailey-Borwein-Plouffe"
        Return pi_info
    
    otherwise If constant_name is equal to "e":
        Let e_info be MathematicalConstant with:
            name: "Euler's number"
            symbol: "e"
            value: "2.7182818284590452353602874713526624977572470937000"
            precision: 50
            decimal_places: 50
            is_rational: false
            is_algebraic: false
            mathematical_definition: "e is equal to lim(n→∞) (1 plus 1/n)^n is equal to Σ(n=0→∞) 1/n!"
            historical_context: "First studied by Jacob Bernoulli 1683, named after Euler"
            computation_method: "Taylor series expansion, continued fractions"
        Return e_info
    
    otherwise If constant_name is equal to "golden_ratio":
        Let phi_info be MathematicalConstant with:
            name: "Golden ratio"
            symbol: "φ"
            value: "1.6180339887498948482045868343656381177203091798058"
            precision: 50
            decimal_places: 50
            is_rational: false
            is_algebraic: true
            mathematical_definition: "φ is equal to (1 plus √5)/2, satisfies φ² is equal to φ plus 1"
            historical_context: "Known to Euclid ~300 BCE, Renaissance artists called it 'divine proportion'"
            computation_method: "Algebraic formula, continued fraction [1;1,1,1,...]"
        Return phi_info
    
    otherwise If constant_name is equal to "euler_gamma":
        Let gamma_info be MathematicalConstant with:
            name: "Euler-Mascheroni constant"
            symbol: "γ"
            value: "0.5772156649015328606065120900824024310421593359399"
            precision: 50
            decimal_places: 50
            is_rational: false
            is_algebraic: false
            mathematical_definition: "γ is equal to lim(n→∞) (Σ(k=1→n) 1/k minus ln(n))"
            historical_context: "Studied by Euler 1734, unknown if rational or transcendental"
            computation_method: "Harmonic series minus natural logarithm limit"
        Return gamma_info
    
    otherwise If constant_name is equal to "speed_of_light":
        Let c_info be MathematicalConstant with:
            name: "Speed of light in vacuum"
            symbol: "c"
            value: "299792458"
            precision: 9
            decimal_places: 0
            is_rational: true
            is_algebraic: true
            mathematical_definition: "c is equal to 299,792,458 m/s (exact by SI definition)"
            historical_context: "First measured by Rømer 1676, defined exactly 1983"
            computation_method: "Defined constant (no computation needed)"
        Return c_info
    
    otherwise:
        Let unknown_info be MathematicalConstant with:
            name: "Unknown constant"
            symbol: "?"
            value: "0"
            precision: 0
            decimal_places: 0
            is_rational: false
            is_algebraic: false
            mathematical_definition: "Constant not found in registry"
            historical_context: "N/A"
            computation_method: "N/A"
        Return unknown_info

Process called "compare_constant_precisions" that takes constant_values as List[String], reference_precision as Integer returns Dictionary[String, Float]:
    Note: Compare precision of different constant computations
    Let precision_results be Dictionary[String, Float]
    
    Let reference_pi be "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679"
    Let reference_e be "2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274"
    Let reference_phi be "1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374"
    
    For Each value_str in constant_values:
        Let trimmed_value be trim_to_precision(value_str, reference_precision)
        Let constant_type be identify_constant_type(trimmed_value)
        
        If constant_type is equal to "pi":
            Let reference_trimmed be trim_to_precision(reference_pi, reference_precision)
            Let accuracy_score be calculate_decimal_accuracy(trimmed_value, reference_trimmed)
            Set precision_results."pi_accuracy" to accuracy_score
            
        otherwise If constant_type is equal to "e":
            Let reference_trimmed be trim_to_precision(reference_e, reference_precision)
            Let accuracy_score be calculate_decimal_accuracy(trimmed_value, reference_trimmed)
            Set precision_results."e_accuracy" to accuracy_score
            
        otherwise If constant_type is equal to "golden_ratio":
            Let reference_trimmed be trim_to_precision(reference_phi, reference_precision)
            Let accuracy_score be calculate_decimal_accuracy(trimmed_value, reference_trimmed)
            Set precision_results."phi_accuracy" to accuracy_score
            
        otherwise:
            Set precision_results.("unknown_" joined with String(Length(constant_values))) to 0.0
    
    Let overall_precision be 0.0
    Let valid_comparisons be 0
    For Each key, accuracy in precision_results:
        If accuracy is greater than 0.0:
            Set overall_precision to overall_precision plus accuracy
            Set valid_comparisons to valid_comparisons plus 1
    
    If valid_comparisons is greater than 0:
        Set precision_results."overall_precision" to overall_precision / Float(valid_comparisons)
    otherwise:
        Set precision_results."overall_precision" to 0.0
    
    Set precision_results."reference_precision" to Float(reference_precision)
    Set precision_results."values_compared" to Float(Length(constant_values))
    
    Return precision_results

Process called "benchmark_constant_computation" that takes computation_methods as List[String], precision_levels as List[Integer] returns Dictionary[String, Dictionary[String, Float]]:
    Note: Benchmark different constant computation methods
    Let benchmark_results be Dictionary[String, Dictionary[String, Float]]
    
    For Each method in computation_methods:
        Let method_results be Dictionary[String, Float]
        
        For Each precision in precision_levels:
            Let start_time be get_high_precision_timestamp()
            Let start_memory be get_current_memory_usage()
            Let computation_successful be true
            
            Try:
                If method is equal to "pi_machin":
                    Let pi_result be compute_pi_machin_formula(precision)
                    
                otherwise If method is equal to "pi_chudnovsky":
                    Let pi_result be compute_pi_chudnovsky_algorithm(precision)
                    
                otherwise If method is equal to "pi_bbp":
                    Let pi_result be compute_pi_bbp_formula(precision)
                    
                otherwise If method is equal to "e_taylor":
                    Let e_result be compute_e_taylor_series(precision)
                    
                otherwise If method is equal to "e_continued_fraction":
                    Let e_result be compute_e_continued_fractions(precision)
                    
                otherwise If method is equal to "golden_ratio_algebraic":
                    Let phi_result be compute_golden_ratio_algebraic(precision)
                    
                otherwise:
                    Set computation_successful to false
                    
            Catch error:
                Set computation_successful to false
            
            Let end_time be get_high_precision_timestamp()
            Let end_memory be get_current_memory_usage()
            
            If computation_successful:
                Let computation_time be end_time minus start_time
                Let memory_used be end_memory minus start_memory
                
                Set method_results.("precision_" joined with String(precision) joined with "_time") to computation_time
                Set method_results.("precision_" joined with String(precision) joined with "_memory") to Float(memory_used)
                
                Let efficiency_score be Float(precision) / (computation_time multiplied by 1000.0)
                Set method_results.("precision_" joined with String(precision) joined with "_efficiency") to efficiency_score
                
            otherwise:
                Set method_results.("precision_" joined with String(precision) joined with "_time") to -1.0
                Set method_results.("precision_" joined with String(precision) joined with "_memory") to -1.0
                Set method_results.("precision_" joined with String(precision) joined with "_efficiency") to 0.0
        
        Let total_successful_computations be 0.0
        Let total_computation_time be 0.0
        Let total_efficiency be 0.0
        
        For Each key, value in method_results:
            If Contains(key, "_time") and value is greater than 0.0:
                Set total_successful_computations to total_successful_computations plus 1.0
                Set total_computation_time to total_computation_time plus value
            If Contains(key, "_efficiency") and value is greater than 0.0:
                Set total_efficiency to total_efficiency plus value
        
        If total_successful_computations is greater than 0.0:
            Set method_results."average_computation_time" to total_computation_time / total_successful_computations
            Set method_results."average_efficiency_score" to total_efficiency / total_successful_computations
            Set method_results."success_rate" to (total_successful_computations / Float(Length(precision_levels))) multiplied by 100.0
        otherwise:
            Set method_results."average_computation_time" to -1.0
            Set method_results."average_efficiency_score" to 0.0
            Set method_results."success_rate" to 0.0
        
        Set method_results."total_precisions_tested" to Float(Length(precision_levels))
        Set method_results."benchmark_timestamp" to get_current_timestamp()
        
        Set benchmark_results.method to method_results
    
    Let best_method be ""
    Let best_efficiency be 0.0
    For Each method_name, results in benchmark_results:
        If Contains(results, "average_efficiency_score"):
            Let method_efficiency be results."average_efficiency_score"
            If method_efficiency is greater than best_efficiency:
                Set best_efficiency to method_efficiency
                Set best_method to method_name
    
    Let summary_results be Dictionary[String, Float]
    Set summary_results."best_overall_method" to 0.0
    Set summary_results."best_efficiency_score" to best_efficiency
    Set summary_results."total_methods_tested" to Float(Length(computation_methods))
    Set summary_results."total_precision_levels" to Float(Length(precision_levels))
    Set benchmark_results."benchmark_summary" to summary_results
    
    Return benchmark_results