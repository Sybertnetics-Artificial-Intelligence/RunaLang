Note:
math/core/operations.runa
Fundamental Mathematical Operations

This module provides comprehensive fundamental mathematical operations including:
- Basic arithmetic operations (add, subtract, multiply, divide)
- Power and root operations (pow, sqrt, nth_root, cbrt)
- Logarithmic operations (log, ln, log2, log10, arbitrary base)
- Factorial and combinatorial operations
- Absolute value and sign operations
- Modular arithmetic and GCD/LCM operations
- Complex number arithmetic
- Arbitrary precision arithmetic support
- Error handling for mathematical edge cases
- Performance optimized implementations
- Numerical stability considerations
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/precision/bigdecimal" as BigDecimal
Import module "math/core/constants" as Constants
Import module "math/core/conversion" as Conversions
Import module "math/engine/numerical/core" as NumericalCore
Import module "math/engine/numerical/rootfinding" as RootFinding

Note: =====================================================================
Note: MATHEMATICAL OPERATION DATA STRUCTURES
Note: =====================================================================

Type called "ArithmeticResult":
    result_value as String
    operation_type as String
    input_parameters as List[String]
    precision_used as Integer
    computation_method as String
    error_estimate as Float
    overflow_occurred as Boolean
    underflow_occurred as Boolean

Type called "ComplexNumber":
    real_part as String
    imaginary_part as String
    magnitude as String
    argument as String
    polar_form as Dictionary[String, String]
    precision as Integer

Type called "FactorialResult":
    input_value as Integer
    factorial_value as String
    computation_method as String
    approximation_used as Boolean
    stirling_approximation as String
    gamma_function_used as Boolean

Type called "ModularArithmetic":
    dividend as String
    divisor as String
    quotient as String
    remainder as String
    modulus as String
    gcd_result as String
    lcm_result as String

Note: =====================================================================
Note: BASIC ARITHMETIC OPERATIONS
Note: =====================================================================

Process called "add" that takes operand_a as String, operand_b as String, precision as Integer returns ArithmeticResult:
    Note: Add two numbers with specified precision
    Let result be ArithmeticResult
    Set result.operation_type to "addition"
    Set result.input_parameters to [operand_a, operand_b]
    Set result.precision_used to precision
    Set result.computation_method to "high_precision_addition"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    Let sum be BigDecimal.add_high_precision(operand_a, operand_b, precision)
    Set result.result_value to sum
    Set result.error_estimate to 0.0
    
    Return result

Process called "subtract" that takes minuend as String, subtrahend as String, precision as Integer returns ArithmeticResult:
    Note: Subtract two numbers with specified precision
    Let result be ArithmeticResult
    Set result.operation_type to "subtraction"
    Set result.input_parameters to [minuend, subtrahend]
    Set result.precision_used to precision
    Set result.computation_method to "high_precision_subtraction"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    Let difference be BigDecimal.subtract_high_precision(minuend, subtrahend, precision)
    Set result.result_value to difference
    Set result.error_estimate to 0.0
    
    Return result

Process called "multiply" that takes multiplicand as String, multiplier as String, precision as Integer returns ArithmeticResult:
    Note: Multiply two numbers with specified precision
    Let result be ArithmeticResult
    Set result.operation_type to "multiplication"
    Set result.input_parameters to [multiplicand, multiplier]
    Set result.precision_used to precision
    Set result.computation_method to "high_precision_multiplication"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    Let product be BigDecimal.multiply_high_precision(multiplicand, multiplier, precision)
    Set result.result_value to product
    Set result.error_estimate to 0.0
    
    Return result

Process called "divide" that takes dividend as String, divisor as String, precision as Integer returns ArithmeticResult:
    Note: Divide two numbers with specified precision and division by zero handling
    Let result be ArithmeticResult
    Set result.operation_type to "division"
    Set result.input_parameters to [dividend, divisor]
    Set result.precision_used to precision
    Set result.computation_method to "high_precision_division"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    handle_division_by_zero_error(divisor, "division operation")
    
    Let quotient be BigDecimal.divide_high_precision(dividend, divisor, precision)
    Set result.result_value to quotient
    Set result.error_estimate to 0.0
    
    Return result

Process called "modulo" that takes dividend as String, divisor as String returns ModularArithmetic:
    Note: Compute modulo operation with remainder and quotient
    Let result be ModularArithmetic
    Set result.dividend to dividend
    Set result.divisor to divisor
    Set result.modulus to divisor
    
    handle_division_by_zero_error(divisor, "modulo operation")
    
    Let quotient be BigDecimal.divide_high_precision(dividend, divisor, 0)
    Let quotient_truncated be BigDecimal.truncate_to_integer(quotient)
    Let product be BigDecimal.multiply_high_precision(quotient_truncated, divisor, 20)
    Let remainder be BigDecimal.subtract_high_precision(dividend, product, 20)
    
    Set result.quotient to quotient_truncated
    Set result.remainder to remainder
    Set result.gcd_result to ""
    Set result.lcm_result to ""
    
    Return result

Note: =====================================================================
Note: POWER AND ROOT OPERATIONS
Note: =====================================================================

Process called "power" that takes base as String, exponent as String, precision as Integer returns ArithmeticResult:
    Note: Raise base to exponent power with specified precision
    Let result be ArithmeticResult
    Set result.operation_type to "power"
    Set result.input_parameters to [base, exponent]
    Set result.precision_used to precision
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    Let base_float be Parse base as Float
    Let exp_float be Parse exponent as Float
    
    If base_float is equal to 0.0 and exp_float is less than or equal to 0.0:
        Throw Errors.InvalidOperation with "0 raised to non-positive power is undefined"
    
    If base_float is less than 0.0 and exp_float not is equal to Round(exp_float):
        Throw Errors.InvalidOperation with "Negative base with non-integer exponent requires complex numbers"
    
    Let exp_int be Parse exponent as Integer
    If exp_float is equal to Float(exp_int):
        Set result.computation_method to "integer_exponentiation"
        Let power_result be compute_integer_power(base, exp_int, precision)
        Set result.result_value to power_result
    Otherwise:
        Set result.computation_method to "logarithmic_exponentiation"
        If base_float is less than or equal to 0.0:
            Throw Errors.InvalidOperation with "Logarithmic method requires positive base"
        Let ln_base be NumericalCore.natural_log_high_precision(base, precision plus 5)
        Let exp_ln_base be BigDecimal.multiply_high_precision(exponent, ln_base, precision plus 5)
        Let power_result be NumericalCore.exponential_high_precision(exp_ln_base, precision)
        Set result.result_value to power_result
    
    Set result.error_estimate to NumericalCore.calculate_power_error_estimate(base, exponent, precision)
    Return result

Process called "square_root" that takes radicand as String, precision as Integer returns ArithmeticResult:
    Note: Compute square root with specified precision
    Let result be ArithmeticResult
    Set result.operation_type to "square_root"
    Set result.input_parameters to [radicand]
    Set result.precision_used to precision
    Set result.computation_method to "newton_raphson_sqrt"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    If BigDecimal.compare_high_precision(radicand, "0") is less than 0:
        Throw Errors.InvalidOperation with "Square root of negative number requires complex numbers"
    
    If BigDecimal.compare_high_precision(radicand, "0") is equal to 0:
        Set result.result_value to "0"
        Set result.error_estimate to 0.0
        Return result
    
    Let sqrt_result be RootFinding.compute_sqrt_newton_method(radicand, precision)
    Set result.result_value to sqrt_result
    Set result.error_estimate to NumericalCore.calculate_sqrt_error_estimate(radicand, precision)
    
    Return result

Process called "integer_square_root" that takes number as String returns String:
    Note: Compute integer square root (floor of square root) for large integers
    Note: Uses Newton's method optimized for integer arithmetic
    
    If BigDecimal.compare_high_precision(number, "0") is less than 0:
        Throw Errors.InvalidOperation with "Square root of negative number not defined for integers"
    
    If BigDecimal.compare_high_precision(number, "1") is less than or equal to 0:
        Return number
    
    Note: Newton's method: x_next is equal to (x plus n/x) / 2
    Let x be number
    Let previous be "0"
    
    Note: Simple initial guess for large numbers
    Let x be divide(number, "2", 0).result_value
    If BigDecimal.compare_high_precision(x, "1") is less than 0:
        Set x to "1"
    
    Loop while BigDecimal.compare_high_precision(x, previous) does not equal 0:
        Set previous to x
        Let quotient be divide(number, x, 0).result_value
        Let sum be add(x, quotient, 0).result_value
        Set x to divide(sum, "2", 0).result_value
    
    Note: Ensure we have the floor (check if x^2 is less than or equal to number is less than (x+1)^2)
    Let x_squared be multiply(x, x, 0).result_value
    If BigDecimal.compare_high_precision(x_squared, number) is greater than 0:
        Set x to subtract(x, "1", 0).result_value
    
    Return x

Process called "modular_exponentiation_string" that takes base as String, exponent as String, modulus as String returns String:
    Note: Compute (base^exponent) mod modulus for large numbers using string arithmetic
    Note: Uses binary exponentiation method for efficiency
    
    If BigDecimal.compare_high_precision(modulus, "1") is less than or equal to 0:
        Throw Errors.InvalidArgument with "Modulus must be greater than 1"
    
    If BigDecimal.compare_high_precision(exponent, "0") is equal to 0:
        Return "1"
    
    If BigDecimal.compare_high_precision(base, "0") is equal to 0:
        Return "0"
    
    Note: Reduce base modulo modulus
    Let result be "1"
    Let base_mod be modulo(base, modulus).remainder
    Let exp_copy be exponent
    
    Loop while BigDecimal.compare_high_precision(exp_copy, "0") is greater than 0:
        Note: Check if exponent is odd
        Let remainder be modulo(exp_copy, "2").remainder
        If BigDecimal.compare_high_precision(remainder, "1") is equal to 0:
            Set result to modulo(multiply(result, base_mod, 0).result_value, modulus).remainder
        
        Set base_mod to modulo(multiply(base_mod, base_mod, 0).result_value, modulus).remainder
        Set exp_copy to divide(exp_copy, "2", 0).result_value
    
    Return result

Process called "cube_root" that takes radicand as String, precision as Integer returns ArithmeticResult:
    Note: Compute cube root with specified precision
    Let result be ArithmeticResult
    Set result.operation_type to "cube_root"
    Set result.input_parameters to [radicand]
    Set result.precision_used to precision
    Set result.computation_method to "newton_raphson_cbrt"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    If BigDecimal.compare_high_precision(radicand, "0") is equal to 0:
        Set result.result_value to "0"
        Set result.error_estimate to 0.0
        Return result
    
    Let cbrt_result be RootFinding.compute_cbrt_newton_method(radicand, precision)
    Set result.result_value to cbrt_result
    Set result.error_estimate to NumericalCore.calculate_cbrt_error_estimate(radicand, precision)
    
    Return result

Process called "nth_root" that takes radicand as String, root_index as Integer, precision as Integer returns ArithmeticResult:
    Note: Compute nth root with specified precision
    Let result be ArithmeticResult
    Set result.operation_type to "nth_root"
    Set result.input_parameters to [radicand, String(root_index)]
    Set result.precision_used to precision
    Set result.computation_method to "newton_raphson_nth_root"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    If root_index is equal to 0:
        Throw Errors.InvalidOperation with "Root index cannot be zero"
    
    If root_index is less than 0:
        Let positive_root be nth_root(radicand, -root_index, precision)
        Let reciprocal_result be divide("1", positive_root.result_value, precision)
        Set result.result_value to reciprocal_result.result_value
        Set result.error_estimate to reciprocal_result.error_estimate
        Return result
    
    If BigDecimal.compare_high_precision(radicand, "0") is equal to 0:
        Set result.result_value to "0"
        Set result.error_estimate to 0.0
        Return result
    
    If root_index is equal to 1:
        Set result.result_value to radicand
        Set result.error_estimate to 0.0
        Return result
    
    If root_index is equal to 2:
        Let sqrt_result be square_root(radicand, precision)
        Set result.result_value to sqrt_result.result_value
        Set result.error_estimate to sqrt_result.error_estimate
        Return result
    
    If root_index is equal to 3:
        Let cbrt_result be cube_root(radicand, precision)
        Set result.result_value to cbrt_result.result_value
        Set result.error_estimate to cbrt_result.error_estimate
        Return result
    
    Let radicand_float be Parse radicand as Float
    If radicand_float is less than 0.0 and root_index modulo 2 is equal to 0:
        Throw Errors.InvalidOperation with "Even root of negative number requires complex numbers"
    
    Let nth_root_result be RootFinding.compute_nth_root_newton_method(radicand, root_index, precision)
    Set result.result_value to nth_root_result
    Set result.error_estimate to NumericalCore.calculate_nth_root_error_estimate(radicand, root_index, precision)
    
    Return result

Process called "exponential" that takes exponent as String, precision as Integer returns ArithmeticResult:
    Note: Compute e^x with specified precision
    Let result be ArithmeticResult
    Set result.operation_type to "exponential"
    Set result.input_parameters to [exponent]
    Set result.precision_used to precision
    Set result.computation_method to "taylor_series_exp"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    Let exp_result be NumericalCore.exponential_high_precision(exponent, precision)
    Set result.result_value to exp_result
    Set result.error_estimate to NumericalCore.calculate_exponential_error_estimate(exponent, precision)
    
    Return result

Process called "compute_integer_power" that takes base as String, exponent as Integer, precision as Integer returns String:
    Note: Compute integer power using repeated multiplication
    If exponent is equal to 0:
        Return "1"
    
    If exponent is equal to 1:
        Return base
    
    If exponent is less than 0:
        Let positive_power be compute_integer_power(base, -exponent, precision)
        Return BigDecimal.divide_high_precision("1", positive_power, precision)
    
    Let result be "1"
    Let current_base be base
    Let current_exponent be exponent
    
    While current_exponent is greater than 0:
        If current_exponent modulo 2 is equal to 1:
            Set result to BigDecimal.multiply_high_precision(result, current_base, precision)
        Set current_base to BigDecimal.multiply_high_precision(current_base, current_base, precision)
        Set current_exponent to current_exponent / 2
    
    Return result

Note: =====================================================================
Note: LOGARITHMIC OPERATIONS
Note: =====================================================================

Process called "natural_logarithm" that takes argument as String, precision as Integer returns ArithmeticResult:
    Note: Compute natural logarithm (ln) with specified precision
    Let result be ArithmeticResult
    Set result.operation_type to "natural_logarithm"
    Set result.input_parameters to [argument]
    Set result.precision_used to precision
    Set result.computation_method to "series_expansion"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    If BigDecimal.compare_high_precision(argument, "0") is less than or equal to 0:
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_LOGARITHM_DOMAIN_ERROR", "natural_logarithm", [argument])
        Throw Errors.MathematicalError with diagnostic_info
    
    Let ln_result be NumericalCore.natural_log_high_precision(argument, precision)
    Set result.result_value to ln_result
    Set result.error_estimate to NumericalCore.calculate_logarithm_error_estimate(argument, "e", precision)
    
    Return result

Process called "common_logarithm" that takes argument as String, precision as Integer returns ArithmeticResult:
    Note: Compute base-10 logarithm with specified precision
    Let result be ArithmeticResult
    Set result.operation_type to "common_logarithm"
    Set result.input_parameters to [argument]
    Set result.precision_used to precision
    Set result.computation_method to "change_of_base"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    If BigDecimal.compare_high_precision(argument, "0") is less than or equal to 0:
        Throw Errors.InvalidOperation with "Common logarithm undefined for non-positive numbers"
    
    Let ln_argument be NumericalCore.natural_log_high_precision(argument, precision plus 5)
    Let ln_10 be NumericalCore.natural_log_high_precision("10", precision plus 5)
    Let log10_result be BigDecimal.divide_high_precision(ln_argument, ln_10, precision)
    Set result.result_value to log10_result
    Set result.error_estimate to NumericalCore.calculate_logarithm_error_estimate(argument, "10", precision)
    
    Return result

Process called "binary_logarithm" that takes argument as String, precision as Integer returns ArithmeticResult:
    Note: Compute base-2 logarithm with specified precision
    Let result be ArithmeticResult
    Set result.operation_type to "binary_logarithm"
    Set result.input_parameters to [argument]
    Set result.precision_used to precision
    Set result.computation_method to "change_of_base"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    If BigDecimal.compare_high_precision(argument, "0") is less than or equal to 0:
        Throw Errors.InvalidOperation with "Binary logarithm undefined for non-positive numbers"
    
    Let ln_argument be NumericalCore.natural_log_high_precision(argument, precision plus 5)
    Let ln_2 be NumericalCore.natural_log_high_precision("2", precision plus 5)
    Let log2_result be BigDecimal.divide_high_precision(ln_argument, ln_2, precision)
    Set result.result_value to log2_result
    Set result.error_estimate to NumericalCore.calculate_logarithm_error_estimate(argument, "2", precision)
    
    Return result

Process called "logarithm_arbitrary_base" that takes argument as String, base as String, precision as Integer returns ArithmeticResult:
    Note: Compute logarithm with arbitrary base
    Let result be ArithmeticResult
    Set result.operation_type to "arbitrary_base_logarithm"
    Set result.input_parameters to [argument, base]
    Set result.precision_used to precision
    Set result.computation_method to "change_of_base"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    If BigDecimal.compare_high_precision(argument, "0") is less than or equal to 0:
        Throw Errors.InvalidOperation with "Logarithm undefined for non-positive argument"
    
    If BigDecimal.compare_high_precision(base, "0") is less than or equal to 0 or BigDecimal.compare_high_precision(base, "1") is equal to 0:
        Throw Errors.InvalidOperation with "Logarithm base must be positive and not equal to 1"
    
    Let ln_argument be NumericalCore.natural_log_high_precision(argument, precision plus 5)
    Let ln_base be NumericalCore.natural_log_high_precision(base, precision plus 5)
    Let log_result be BigDecimal.divide_high_precision(ln_argument, ln_base, precision)
    Set result.result_value to log_result
    Set result.error_estimate to NumericalCore.calculate_logarithm_error_estimate(argument, base, precision)
    
    Return result

Process called "logarithm_change_of_base" that takes argument as String, from_base as String, to_base as String, precision as Integer returns ArithmeticResult:
    Note: Convert logarithm from one base to another
    Let result be ArithmeticResult
    Set result.operation_type to "logarithm_base_conversion"
    Set result.input_parameters to [argument, from_base, to_base]
    Set result.precision_used to precision
    Set result.computation_method to "change_of_base_formula"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    If BigDecimal.compare_high_precision(argument, "0") is less than or equal to 0:
        Throw Errors.InvalidOperation with "Logarithm undefined for non-positive argument"
    
    If BigDecimal.compare_high_precision(from_base, "0") is less than or equal to 0 or BigDecimal.compare_high_precision(from_base, "1") is equal to 0:
        Throw Errors.InvalidOperation with "From base must be positive and not equal to 1"
    
    If BigDecimal.compare_high_precision(to_base, "0") is less than or equal to 0 or BigDecimal.compare_high_precision(to_base, "1") is equal to 0:
        Throw Errors.InvalidOperation with "To base must be positive and not equal to 1"
    
    Let ln_to_base be NumericalCore.natural_log_high_precision(to_base, precision plus 5)
    Let ln_from_base be NumericalCore.natural_log_high_precision(from_base, precision plus 5)
    Let conversion_factor be BigDecimal.divide_high_precision(ln_to_base, ln_from_base, precision plus 5)
    Let log_from_base_arg be logarithm_arbitrary_base(argument, from_base, precision plus 5)
    Let converted_result be BigDecimal.multiply_high_precision(log_from_base_arg.result_value, conversion_factor, precision)
    
    Set result.result_value to converted_result
    Set result.error_estimate to NumericalCore.calculate_logarithm_error_estimate(argument, to_base, precision)
    
    Return result

Note: =====================================================================
Note: FACTORIAL AND COMBINATORIAL OPERATIONS
Note: =====================================================================

Process called "factorial" that takes n as Integer returns FactorialResult:
    Note: Compute factorial n! for non-negative integers
    Let result be FactorialResult
    Set result.input_value to n
    Set result.computation_method to "iterative_multiplication"
    Set result.approximation_used to false
    Set result.gamma_function_used to false
    
    If n is less than 0:
        Throw Errors.InvalidOperation with "Factorial undefined for negative integers"
    
    If n is equal to 0 or n is equal to 1:
        Set result.factorial_value to "1"
        Return result
    
    If n is greater than 170:
        Set result.computation_method to "stirling_approximation"
        Set result.approximation_used to true
        Let stirling_result be NumericalCore.compute_stirling_approximation(n)
        Set result.factorial_value to stirling_result
        Set result.stirling_approximation to stirling_result
        Return result
    
    Let factorial_result be "1"
    Let i be 2
    While i is less than or equal to n:
        Set factorial_result to BigDecimal.multiply_high_precision(factorial_result, String(i), 50)
        Set i to i plus 1
    
    Set result.factorial_value to factorial_result
    Set result.stirling_approximation to NumericalCore.compute_stirling_approximation(n)
    
    Return result

Process called "double_factorial" that takes n as Integer returns FactorialResult:
    Note: Compute double factorial n!! (product of every second number)
    Let result be FactorialResult
    Set result.input_value to n
    Set result.computation_method to "iterative_double_step"
    Set result.approximation_used to false
    Set result.gamma_function_used to false
    
    If n is less than -1:
        Throw Errors.InvalidOperation with "Double factorial undefined for n is less than -1"
    
    If n is equal to -1 or n is equal to 0:
        Set result.factorial_value to "1"
        Return result
    
    Let double_factorial_result be "1"
    Let i be n
    While i is greater than 0:
        Set double_factorial_result to BigDecimal.multiply_high_precision(double_factorial_result, String(i), 50)
        Set i to i minus 2
    
    Set result.factorial_value to double_factorial_result
    Set result.stirling_approximation to ""
    
    Return result

Process called "subfactorial" that takes n as Integer returns FactorialResult:
    Note: Compute subfactorial !n (derangements)
    Let result be FactorialResult
    Set result.input_value to n
    Set result.computation_method to "derangement_formula"
    Set result.approximation_used to false
    Set result.gamma_function_used to false
    
    If n is less than 0:
        Throw Errors.InvalidOperation with "Subfactorial undefined for negative integers"
    
    If n is equal to 0:
        Set result.factorial_value to "1"
        Return result
    
    If n is equal to 1:
        Set result.factorial_value to "0"
        Return result
    
    Let factorial_n be factorial(n)
    Let e_approx be Constants.get_e_constant_high_precision(50)
    Let factorial_over_e be BigDecimal.divide_high_precision(factorial_n.factorial_value, e_approx, 50)
    Let rounded_result be NumericalCore.round_to_nearest_integer(factorial_over_e)
    
    Set result.factorial_value to rounded_result
    Set result.stirling_approximation to ""
    
    Return result

Process called "factorial_approximation" that takes n as Integer, method as String returns FactorialResult:
    Note: Approximate factorial using Stirling's approximation or other methods
    Let result be FactorialResult
    Set result.input_value to n
    Set result.approximation_used to true
    Set result.gamma_function_used to false
    
    If n is less than 0:
        Throw Errors.InvalidOperation with "Factorial approximation undefined for negative integers"
    
    If method is equal to "stirling":
        Set result.computation_method to "stirling_approximation"
        Let stirling_result be NumericalCore.compute_stirling_approximation(n)
        Set result.factorial_value to stirling_result
        Set result.stirling_approximation to stirling_result
    Otherwise if method is equal to "ramanujan":
        Set result.computation_method to "ramanujan_approximation"
        Let ramanujan_result be NumericalCore.compute_ramanujan_approximation(n)
        Set result.factorial_value to ramanujan_result
        Set result.stirling_approximation to NumericalCore.compute_stirling_approximation(n)
    Otherwise:
        Throw Errors.InvalidOperation with "Unknown approximation method: " joined with method
    
    Return result

Process called "binomial_coefficient" that takes n as Integer, k as Integer returns ArithmeticResult:
    Note: Compute binomial coefficient C(n,k) is equal to n!/(k!(n-k)!)
    Let result be ArithmeticResult
    Set result.operation_type to "binomial_coefficient"
    Set result.input_parameters to [String(n), String(k)]
    Set result.precision_used to 50
    Set result.computation_method to "multiplicative_formula"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    If n is less than 0:
        Throw Errors.InvalidOperation with "Binomial coefficient undefined for negative n"
    
    If k is less than 0 or k is greater than n:
        Set result.result_value to "0"
        Set result.error_estimate to 0.0
        Return result
    
    If k is equal to 0 or k is equal to n:
        Set result.result_value to "1"
        Set result.error_estimate to 0.0
        Return result
    
    If k is greater than n minus k:
        Set k to n minus k
    
    Let binomial_result be "1"
    Let i be 0
    While i is less than k:
        Set binomial_result to BigDecimal.multiply_high_precision(binomial_result, String(n minus i), 50)
        Set binomial_result to BigDecimal.divide_high_precision(binomial_result, String(i plus 1), 50)
        Set i to i plus 1
    
    Set result.result_value to binomial_result
    Set result.error_estimate to 0.0
    
    Return result

Note: =====================================================================
Note: ABSOLUTE VALUE AND SIGN OPERATIONS
Note: =====================================================================

Process called "absolute_value" that takes value as String returns ArithmeticResult:
    Note: Compute absolute value |x|
    Let result be ArithmeticResult
    Set result.operation_type to "absolute_value"
    Set result.input_parameters to [value]
    Set result.precision_used to 50
    Set result.computation_method to "sign_removal"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    If BigDecimal.compare_high_precision(value, "0") is greater than or equal to 0:
        Set result.result_value to value
    Otherwise:
        Set result.result_value to BigDecimal.subtract_high_precision("0", value, 50)
    
    Set result.error_estimate to 0.0
    Return result

Process called "sign" that takes value as String returns Integer:
    Note: Return sign of number (-1, 0, or 1)
    Let comparison be BigDecimal.compare_high_precision(value, "0")
    
    If comparison is greater than 0:
        Return 1
    Otherwise if comparison is less than 0:
        Return -1
    Otherwise:
        Return 0

Process called "signum" that takes value as String returns String:
    Note: Return signum function (sign with floating point result)
    Let comparison be BigDecimal.compare_high_precision(value, "0")
    
    If comparison is greater than 0:
        Return "1.0"
    Otherwise if comparison is less than 0:
        Return "-1.0"
    Otherwise:
        Return "0.0"

Process called "negate" that takes value as String returns ArithmeticResult:
    Note: Return negative of the input value (-value)
    Let result be ArithmeticResult
    Set result.operation_type to "negation"
    Set result.input_parameters to [value]
    Set result.precision_used to 50
    Set result.computation_method to "sign_flip"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    Set result.result_value to BigDecimal.subtract_high_precision("0", value, 50)
    Set result.error_estimate to 0.0
    Return result

Process called "compare" that takes a as String, b as String returns Integer:
    Note: Compare two numbers (-1 if a is less than b, 0 if a is equal to b, 1 if a is greater than b)
    Return BigDecimal.compare_high_precision(a, b)

Process called "copy_sign" that takes magnitude as String, sign_source as String returns String:
    Note: Return magnitude with sign copied from sign_source
    Let abs_magnitude be absolute_value(magnitude)
    Let source_sign be sign(sign_source)
    
    If source_sign is greater than or equal to 0:
        Return abs_magnitude.result_value
    Otherwise:
        Return BigDecimal.subtract_high_precision("0", abs_magnitude.result_value, 50)


Note: =====================================================================
Note: MODULAR ARITHMETIC OPERATIONS
Note: =====================================================================

Process called "greatest_common_divisor" that takes a as String, b as String returns String:
    Note: Compute GCD of two numbers using Euclidean algorithm
    If BigDecimal.compare_high_precision(a, "0") is equal to 0:
        Return absolute_value(b).result_value
    
    If BigDecimal.compare_high_precision(b, "0") is equal to 0:
        Return absolute_value(a).result_value
    
    Let abs_a be absolute_value(a).result_value
    Let abs_b be absolute_value(b).result_value
    
    While BigDecimal.compare_high_precision(abs_b, "0") not is equal to 0:
        Let temp be abs_b
        Let remainder_result be modulo(abs_a, abs_b)
        Set abs_b to remainder_result.remainder
        Set abs_a to temp
    
    Return abs_a

Process called "least_common_multiple" that takes a as String, b as String returns String:
    Note: Compute LCM of two numbers
    If BigDecimal.compare_high_precision(a, "0") is equal to 0 or BigDecimal.compare_high_precision(b, "0") is equal to 0:
        Return "0"
    
    Let abs_a be absolute_value(a).result_value
    Let abs_b be absolute_value(b).result_value
    Let gcd_result be greatest_common_divisor(abs_a, abs_b)
    
    Let product be BigDecimal.multiply_high_precision(abs_a, abs_b, 50)
    Let lcm_result be BigDecimal.divide_high_precision(product, gcd_result, 50)
    
    Return lcm_result

Process called "extended_euclidean_algorithm" that takes a as String, b as String returns Dictionary[String, String]:
    Note: Compute extended GCD with Bézout coefficients
    Let result be Dictionary[String, String]
    
    If BigDecimal.compare_high_precision(b, "0") is equal to 0:
        Set result["gcd"] to absolute_value(a).result_value
        Set result["x"] to signum(a)
        Set result["y"] to "0"
        Return result
    
    Let old_r be a
    Let r be b
    Let old_s be "1"
    Let s be "0"
    Let old_t be "0"
    Let t be "1"
    
    While BigDecimal.compare_high_precision(r, "0") not is equal to 0:
        Let quotient_result be divide(old_r, r, 0)
        Let quotient be quotient_result.result_value
        
        Let temp be r
        Let product1 be BigDecimal.multiply_high_precision(quotient, r, 50)
        Set r to BigDecimal.subtract_high_precision(old_r, product1, 50)
        Set old_r to temp
        
        Set temp to s
        Let product2 be BigDecimal.multiply_high_precision(quotient, s, 50)
        Set s to BigDecimal.subtract_high_precision(old_s, product2, 50)
        Set old_s to temp
        
        Set temp to t
        Let product3 be BigDecimal.multiply_high_precision(quotient, t, 50)
        Set t to BigDecimal.subtract_high_precision(old_t, product3, 50)
        Set old_t to temp
    
    Set result["gcd"] to old_r
    Set result["x"] to old_s
    Set result["y"] to old_t
    
    Return result

Process called "modular_inverse" that takes a as String, modulus as String returns String:
    Note: Compute modular multiplicative inverse
    If BigDecimal.compare_high_precision(modulus, "1") is less than or equal to 0:
        Throw Errors.InvalidOperation with "Modulus must be greater than 1"
    
    Let extended_result be extended_euclidean_algorithm(a, modulus)
    
    If BigDecimal.compare_high_precision(extended_result["gcd"], "1") not is equal to 0:
        Throw Errors.InvalidOperation with "Modular inverse does not exist minus numbers are not coprime"
    
    Let x be extended_result["x"]
    If BigDecimal.compare_high_precision(x, "0") is less than 0:
        Set x to BigDecimal.add_high_precision(x, modulus, 50)
    
    Return x

Process called "modular_exponentiation" that takes base as String, exponent as String, modulus as String returns String:
    Note: Compute (base^exponent) mod modulus efficiently
    If BigDecimal.compare_high_precision(modulus, "1") is less than or equal to 0:
        Throw Errors.InvalidOperation with "Modulus must be greater than 1"
    
    If BigDecimal.compare_high_precision(exponent, "0") is equal to 0:
        Return "1"
    
    If BigDecimal.compare_high_precision(exponent, "0") is less than 0:
        Throw Errors.InvalidOperation with "Negative exponents not supported in modular exponentiation"
    
    Let result be "1"
    Let base_mod be modulo(base, modulus).remainder
    Let exp_int be Parse exponent as Integer
    
    While exp_int is greater than 0:
        If exp_int modulo 2 is equal to 1:
            Let temp_multiply be BigDecimal.multiply_high_precision(result, base_mod, 50)
            Set result to modulo(temp_multiply, modulus).remainder
        
        Let base_squared be BigDecimal.multiply_high_precision(base_mod, base_mod, 50)
        Set base_mod to modulo(base_squared, modulus).remainder
        Set exp_int to exp_int / 2
    
    Return result

Note: =====================================================================
Note: COMPLEX NUMBER OPERATIONS
Note: =====================================================================

Process called "create_complex_number" that takes real_part as String, imaginary_part as String, precision as Integer returns ComplexNumber:
    Note: Create a complex number with specified real and imaginary parts
    Let complex_number be ComplexNumber
    Set complex_number.real_part to real_part
    Set complex_number.imaginary_part to imaginary_part
    Set complex_number.precision to precision
    
    Let real_squared be BigDecimal.multiply_high_precision(real_part, real_part, precision)
    Let imag_squared be BigDecimal.multiply_high_precision(imaginary_part, imaginary_part, precision)
    Let magnitude_squared be BigDecimal.add_high_precision(real_squared, imag_squared, precision)
    Set complex_number.magnitude to RootFinding.compute_sqrt_newton_method(magnitude_squared, precision)
    
    Set complex_number.argument to NumericalCore.compute_arctangent2(imaginary_part, real_part, precision)
    
    Set complex_number.polar_form to Dictionary[String, String]
    Set complex_number.polar_form["magnitude"] to complex_number.magnitude
    Set complex_number.polar_form["argument"] to complex_number.argument
    
    Return complex_number

Process called "complex_add" that takes a as ComplexNumber, b as ComplexNumber returns ComplexNumber:
    Note: Add two complex numbers
    Let result be ComplexNumber
    Set result.precision to a.precision
    
    Set result.real_part to BigDecimal.add_high_precision(a.real_part, b.real_part, a.precision)
    Set result.imaginary_part to BigDecimal.add_high_precision(a.imaginary_part, b.imaginary_part, a.precision)
    
    Let real_squared be BigDecimal.multiply_high_precision(result.real_part, result.real_part, a.precision)
    Let imag_squared be BigDecimal.multiply_high_precision(result.imaginary_part, result.imaginary_part, a.precision)
    Let magnitude_squared be BigDecimal.add_high_precision(real_squared, imag_squared, a.precision)
    Set result.magnitude to RootFinding.compute_sqrt_newton_method(magnitude_squared, a.precision)
    
    Set result.argument to NumericalCore.compute_arctangent2(result.imaginary_part, result.real_part, a.precision)
    
    Set result.polar_form to Dictionary[String, String]
    Set result.polar_form["magnitude"] to result.magnitude
    Set result.polar_form["argument"] to result.argument
    
    Return result

Process called "complex_multiply" that takes a as ComplexNumber, b as ComplexNumber returns ComplexNumber:
    Note: Multiply two complex numbers
    Let result be ComplexNumber
    Set result.precision to a.precision
    
    Let ac be BigDecimal.multiply_high_precision(a.real_part, b.real_part, a.precision)
    Let bd be BigDecimal.multiply_high_precision(a.imaginary_part, b.imaginary_part, a.precision)
    Let ad be BigDecimal.multiply_high_precision(a.real_part, b.imaginary_part, a.precision)
    Let bc be BigDecimal.multiply_high_precision(a.imaginary_part, b.real_part, a.precision)
    
    Set result.real_part to BigDecimal.subtract_high_precision(ac, bd, a.precision)
    Set result.imaginary_part to BigDecimal.add_high_precision(ad, bc, a.precision)
    
    Let real_squared be BigDecimal.multiply_high_precision(result.real_part, result.real_part, a.precision)
    Let imag_squared be BigDecimal.multiply_high_precision(result.imaginary_part, result.imaginary_part, a.precision)
    Let magnitude_squared be BigDecimal.add_high_precision(real_squared, imag_squared, a.precision)
    Set result.magnitude to RootFinding.compute_sqrt_newton_method(magnitude_squared, a.precision)
    
    Set result.argument to NumericalCore.compute_arctangent2(result.imaginary_part, result.real_part, a.precision)
    
    Set result.polar_form to Dictionary[String, String]
    Set result.polar_form["magnitude"] to result.magnitude
    Set result.polar_form["argument"] to result.argument
    
    Return result

Process called "complex_divide" that takes dividend as ComplexNumber, divisor as ComplexNumber returns ComplexNumber:
    Note: Divide two complex numbers
    Let result be ComplexNumber
    Set result.precision to dividend.precision
    
    Let c be divisor.real_part
    Let d be divisor.imaginary_part
    Let denominator be BigDecimal.add_high_precision(
        BigDecimal.multiply_high_precision(c, c, dividend.precision),
        BigDecimal.multiply_high_precision(d, d, dividend.precision),
        dividend.precision
    )
    
    If BigDecimal.compare_high_precision(denominator, "0") is equal to 0:
        Throw Errors.InvalidOperation with "Division by zero complex number"
    
    Let ac be BigDecimal.multiply_high_precision(dividend.real_part, c, dividend.precision)
    Let bd be BigDecimal.multiply_high_precision(dividend.imaginary_part, d, dividend.precision)
    Let bc_neg be BigDecimal.multiply_high_precision(dividend.imaginary_part, c, dividend.precision)
    Let ad_neg be BigDecimal.multiply_high_precision(dividend.real_part, d, dividend.precision)
    
    Let numerator_real be BigDecimal.add_high_precision(ac, bd, dividend.precision)
    Let numerator_imag be BigDecimal.subtract_high_precision(bc_neg, ad_neg, dividend.precision)
    
    Set result.real_part to BigDecimal.divide_high_precision(numerator_real, denominator, dividend.precision)
    Set result.imaginary_part to BigDecimal.divide_high_precision(numerator_imag, denominator, dividend.precision)
    
    Let real_squared be BigDecimal.multiply_high_precision(result.real_part, result.real_part, dividend.precision)
    Let imag_squared be BigDecimal.multiply_high_precision(result.imaginary_part, result.imaginary_part, dividend.precision)
    Let magnitude_squared be BigDecimal.add_high_precision(real_squared, imag_squared, dividend.precision)
    Set result.magnitude to RootFinding.compute_sqrt_newton_method(magnitude_squared, dividend.precision)
    
    Set result.argument to NumericalCore.compute_arctangent2(result.imaginary_part, result.real_part, dividend.precision)
    
    Set result.polar_form to Dictionary[String, String]
    Set result.polar_form["magnitude"] to result.magnitude
    Set result.polar_form["argument"] to result.argument
    
    Return result

Process called "complex_conjugate" that takes complex_number as ComplexNumber returns ComplexNumber:
    Note: Compute complex conjugate
    Let result be ComplexNumber
    Set result.precision to complex_number.precision
    
    Set result.real_part to complex_number.real_part
    Set result.imaginary_part to BigDecimal.subtract_high_precision("0", complex_number.imaginary_part, complex_number.precision)
    
    Set result.magnitude to complex_number.magnitude
    Set result.argument to BigDecimal.subtract_high_precision("0", complex_number.argument, complex_number.precision)
    
    Set result.polar_form to Dictionary[String, String]
    Set result.polar_form["magnitude"] to result.magnitude
    Set result.polar_form["argument"] to result.argument
    
    Return result

Process called "complex_magnitude" that takes complex_number as ComplexNumber returns String:
    Note: Compute magnitude (absolute value) of complex number
    Let real_squared be BigDecimal.multiply_high_precision(complex_number.real_part, complex_number.real_part, complex_number.precision)
    Let imag_squared be BigDecimal.multiply_high_precision(complex_number.imaginary_part, complex_number.imaginary_part, complex_number.precision)
    Let magnitude_squared be BigDecimal.add_high_precision(real_squared, imag_squared, complex_number.precision)
    
    Return RootFinding.compute_sqrt_newton_method(magnitude_squared, complex_number.precision)

Process called "complex_square" that takes z as ComplexNumber returns ComplexNumber:
    Note: Compute z² for complex number (critical for Mandelbrot/Julia sets)
    Let result be ComplexNumber
    Set result.precision to z.precision
    
    Note: (a plus bi)² is equal to (a² minus b²) plus (2ab)i
    Let real_squared be BigDecimal.multiply_high_precision(z.real_part, z.real_part, z.precision)
    Let imag_squared be BigDecimal.multiply_high_precision(z.imaginary_part, z.imaginary_part, z.precision)
    Let real_result be BigDecimal.subtract_high_precision(real_squared, imag_squared, z.precision)
    
    Let two be "2"
    Let ab_product be BigDecimal.multiply_high_precision(z.real_part, z.imaginary_part, z.precision)
    Let imag_result be BigDecimal.multiply_high_precision(two, ab_product, z.precision)
    
    Set result.real_part to real_result
    Set result.imaginary_part to imag_result
    
    Let result_real_squared be BigDecimal.multiply_high_precision(real_result, real_result, z.precision)
    Let result_imag_squared be BigDecimal.multiply_high_precision(imag_result, imag_result, z.precision)
    Let magnitude_squared be BigDecimal.add_high_precision(result_real_squared, result_imag_squared, z.precision)
    Set result.magnitude to RootFinding.compute_sqrt_newton_method(magnitude_squared, z.precision)
    
    Set result.argument to NumericalCore.compute_arctangent2(imag_result, real_result, z.precision)
    
    Set result.polar_form to Dictionary[String, String]
    Set result.polar_form["magnitude"] to result.magnitude
    Set result.polar_form["argument"] to result.argument
    
    Return result

Process called "create_complex_from_floats" that takes real_part as Float, imaginary_part as Float returns ComplexNumber:
    Note: Create complex number from float values with default precision
    Let real_string be String(real_part)
    Let imag_string be String(imaginary_part)
    Let precision be 15
    Return create_complex_number(real_string, imag_string, precision)

Process called "complex_power" that takes base as ComplexNumber, exponent as ComplexNumber returns ComplexNumber:
    Note: Compute complex power z^w is equal to exp(w multiplied by log(z))
    Let result be ComplexNumber
    Set result.precision to base.precision
    
    Note: Handle special cases
    If BigDecimal.is_zero(base.real_part, base.precision) and BigDecimal.is_zero(base.imaginary_part, base.precision):
        If BigDecimal.compare(exponent.real_part, "0") is greater than 0:
            Return create_complex_number("0", "0", base.precision)
        Otherwise:
            Throw Errors.MathematicalError with "0^0 or 0^(negative) undefined"
    
    Note: Compute using exp(w multiplied by log(z))
    Let log_base be complex_log(base)
    Let exponent_times_log be complex_multiply(exponent, log_base)
    Return complex_exp(exponent_times_log)

Process called "complex_exp" that takes z as ComplexNumber returns ComplexNumber:
    Note: Compute e^z is equal to e^(x+iy) is equal to e^x multiplied by (cos(y) plus i*sin(y))
    Let result be ComplexNumber
    Set result.precision to z.precision
    
    Note: Compute e^real_part
    Let exp_real be NumericalCore.compute_exponential(z.real_part, z.precision)
    
    Note: Compute cos(imag_part) and sin(imag_part)
    Let cos_imag be NumericalCore.compute_cosine(z.imaginary_part, z.precision)
    Let sin_imag be NumericalCore.compute_sine(z.imaginary_part, z.precision)
    
    Note: Result is equal to e^real multiplied by cos(imag) plus i multiplied by e^real multiplied by sin(imag)
    Set result.real_part to BigDecimal.multiply_high_precision(exp_real, cos_imag, z.precision)
    Set result.imaginary_part to BigDecimal.multiply_high_precision(exp_real, sin_imag, z.precision)
    
    Note: Update magnitude and argument
    Set result.magnitude to complex_magnitude(result)
    Set result.argument to NumericalCore.compute_arctangent2(result.imaginary_part, result.real_part, z.precision)
    
    Return result

Process called "complex_log" that takes z as ComplexNumber returns ComplexNumber:
    Note: Compute log(z) is equal to log|z| plus i*arg(z)
    Let result be ComplexNumber
    Set result.precision to z.precision
    
    Note: Check for zero
    If BigDecimal.is_zero(z.real_part, z.precision) and BigDecimal.is_zero(z.imaginary_part, z.precision):
        Throw Errors.MathematicalError with "Logarithm of zero is undefined"
    
    Note: Compute log of magnitude
    Let magnitude be complex_magnitude(z)
    Set result.real_part to NumericalCore.compute_natural_logarithm(magnitude, z.precision)
    
    Note: Compute argument (principal branch)
    Set result.imaginary_part to NumericalCore.compute_arctangent2(z.imaginary_part, z.real_part, z.precision)
    
    Note: Update magnitude and argument
    Set result.magnitude to complex_magnitude(result)
    Set result.argument to NumericalCore.compute_arctangent2(result.imaginary_part, result.real_part, z.precision)
    
    Return result

Process called "complex_sin" that takes z as ComplexNumber returns ComplexNumber:
    Note: Compute sin(z) is equal to sin(x)cosh(y) plus i*cos(x)sinh(y)
    Let result be ComplexNumber
    Set result.precision to z.precision
    
    Let sin_real be NumericalCore.compute_sine(z.real_part, z.precision)
    Let cos_real be NumericalCore.compute_cosine(z.real_part, z.precision)
    Let sinh_imag be NumericalCore.compute_hyperbolic_sine(z.imaginary_part, z.precision)
    Let cosh_imag be NumericalCore.compute_hyperbolic_cosine(z.imaginary_part, z.precision)
    
    Set result.real_part to BigDecimal.multiply_high_precision(sin_real, cosh_imag, z.precision)
    Set result.imaginary_part to BigDecimal.multiply_high_precision(cos_real, sinh_imag, z.precision)
    
    Set result.magnitude to complex_magnitude(result)
    Set result.argument to NumericalCore.compute_arctangent2(result.imaginary_part, result.real_part, z.precision)
    
    Return result

Process called "complex_cos" that takes z as ComplexNumber returns ComplexNumber:
    Note: Compute cos(z) is equal to cos(x)cosh(y) minus i*sin(x)sinh(y)
    Let result be ComplexNumber
    Set result.precision to z.precision
    
    Let sin_real be NumericalCore.compute_sine(z.real_part, z.precision)
    Let cos_real be NumericalCore.compute_cosine(z.real_part, z.precision)
    Let sinh_imag be NumericalCore.compute_hyperbolic_sine(z.imaginary_part, z.precision)
    Let cosh_imag be NumericalCore.compute_hyperbolic_cosine(z.imaginary_part, z.precision)
    
    Set result.real_part to BigDecimal.multiply_high_precision(cos_real, cosh_imag, z.precision)
    Let sin_sinh be BigDecimal.multiply_high_precision(sin_real, sinh_imag, z.precision)
    Set result.imaginary_part to BigDecimal.subtract_high_precision("0", sin_sinh, z.precision)
    
    Set result.magnitude to complex_magnitude(result)
    Set result.argument to NumericalCore.compute_arctangent2(result.imaginary_part, result.real_part, z.precision)
    
    Return result

Process called "complex_derivative_limit" that takes function as ComplexFunction, point as ComplexNumber, direction as ComplexNumber returns ComplexNumber:
    Note: Compute complex derivative using limit definition
    Let result be ComplexNumber
    Set result.precision to point.precision
    
    Note: Use small increment h in given direction
    Let h_magnitude be "0.0001"
    Let direction_normalized be complex_divide(direction, create_complex_number(complex_magnitude(direction), "0", point.precision))
    Let h be complex_multiply(create_complex_number(h_magnitude, "0", point.precision), direction_normalized)
    
    Note: Compute f(z+h) minus f(z)
    Let point_plus_h be complex_add(point, h)
    Let f_at_point_plus_h be evaluate_complex_function(function, point_plus_h)
    Let f_at_point be evaluate_complex_function(function, point)
    Let numerator be complex_add(f_at_point_plus_h, complex_multiply(create_complex_number("-1", "0", point.precision), f_at_point))
    
    Note: Compute (f(z+h) minus f(z)) / h
    Set result to complex_divide(numerator, h)
    
    Return result

Process called "evaluate_complex_function" that takes function as ComplexFunction, point as ComplexNumber returns ComplexNumber:
    Note: Evaluate complex function at given point using real and imaginary parts
    Let result be ComplexNumber
    Set result.precision to point.precision
    
    Note: Create variable substitutions
    Let variables be Dictionary[String, String]
    Set variables["x"] to point.real_part
    Set variables["y"] to point.imaginary_part
    
    Note: Evaluate real and imaginary parts
    Let real_result be substitute_and_evaluate(function.real_part["expression"], variables)
    Let imag_result be substitute_and_evaluate(function.imaginary_part["expression"], variables)
    
    Return create_complex_number(real_result, imag_result, point.precision)

Process called "parse_and_evaluate_expression" that takes expression as String, precision as Integer returns String:
    Note: Parse and evaluate basic mathematical expressions with arithmetic operations
    Let cleaned_expression be expression.trim()
    
    Note: Handle simple numeric literals
    If is_numeric_literal(cleaned_expression):
        Return cleaned_expression
    
    Note: Handle basic binary operations (addition, subtraction, multiplication, division)
    Let result be evaluate_binary_operations(cleaned_expression, precision)
    
    Note: Handle parentheses and operator precedence
    Let final_result be evaluate_with_precedence(result, precision)
    
    Return final_result

Process called "is_numeric_literal" that takes value as String returns Boolean:
    Note: Check if string represents a simple numeric literal
    Let trimmed be value.trim()
    Return matches_pattern(trimmed, "^-?\\d+(\\.\\d+)?$")

Process called "evaluate_binary_operations" that takes expression as String, precision as Integer returns String:
    Note: Evaluate basic binary operations in left-to-right order
    Let tokens be split_expression_tokens(expression)
    
    If tokens.length() is equal to 1:
        Return tokens[0]
    
    Let result be parse_number(tokens[0])
    Let index be 1
    
    While index is less than tokens.length() minus 1:
        Let operator be tokens[index]
        Let operand be parse_number(tokens[index plus 1])
        
        Match operator:
            When "+":
                Let add_result be add(format_number(result, precision), format_number(operand, precision), precision)
                Set result to parse_number(add_result.result_value)
            When "-":
                Set result to result minus operand  
            When "*":
                Set result to result times operand
            When "/":
                If operand is equal to 0.0:
                    Throw Errors.InvalidOperation with "Division by zero"
                Set result to result divided by operand
            When "^":
                Set result to power_operation(result, operand, precision)
        
        Set index to index plus 2
    
    Return format_number(result, precision)

Process called "evaluate_with_precedence" that takes expression as String, precision as Integer returns String:
    Note: Handle operator precedence (*, /, ^ before +, -)
    Let processed be handle_parentheses(expression)
    Let result be handle_multiplication_division(processed, precision)
    Let final_result be handle_addition_subtraction(result, precision)
    
    Return final_result

Process called "split_expression_tokens" that takes expression as String returns List[String]:
    Note: Split mathematical expression into tokens
    Let tokens be List[String]
    Let current_token be ""
    
    For i in range(0, expression.length()):
        Let char be expression[i]
        
        If char in ["+", "-", "*", "/", "^", "(", ")"]:
            If current_token.length() > 0:
                tokens.add(current_token.trim())
                Set current_token to ""
            tokens.add(char)
        Otherwise:
            Set current_token to current_token joined with char
    
    If current_token.length() > 0:
        tokens.add(current_token.trim())
    
    Return tokens

Process called "substitute_and_evaluate" that takes expression as String, variables as Dictionary[String, String] returns String:
    Note: Substitute variables and evaluate mathematical expression
    Let substituted_expression be expression
    
    Note: Replace each variable with its value
    For Each variable_name in variables.keys:
        Let variable_value be variables[variable_name]
        Set substituted_expression to String.replace_all(substituted_expression, variable_name, variable_value)
    
    Note: Evaluate the substituted mathematical expression using basic expression parser
    
    Let evaluation_result be parse_and_evaluate_expression(substituted_expression, 15)
    Return evaluation_result

Note: =====================================================================
Note: NUMERICAL STABILITY OPERATIONS
Note: =====================================================================

Process called "stable_sum" that takes values as List[String], precision as Integer returns ArithmeticResult:
    Note: Compute sum using numerically stable algorithm (Kahan summation)
    Let result be ArithmeticResult
    Set result.operation_type to "stable_summation"
    Set result.input_parameters to values
    Set result.precision_used to precision
    Set result.computation_method to "kahan_summation"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    If Length(values) is equal to 0:
        Set result.result_value to "0"
        Set result.error_estimate to 0.0
        Return result
    
    Let sum be "0"
    Let compensation to "0"
    
    For each value in values:
        Let adjusted_value be BigDecimal.subtract_high_precision(value, compensation, precision plus 5)
        Let new_sum be BigDecimal.add_high_precision(sum, adjusted_value, precision plus 5)
        Set compensation to BigDecimal.subtract_high_precision(
            BigDecimal.subtract_high_precision(new_sum, sum, precision plus 5),
            adjusted_value,
            precision plus 5
        )
        Set sum to new_sum
    
    Set result.result_value to BigDecimal.round_to_precision(sum, precision)
    Set result.error_estimate to NumericalCore.estimate_kahan_summation_error(values, precision)
    
    Return result

Process called "stable_product" that takes values as List[String], precision as Integer returns ArithmeticResult:
    Note: Compute product using numerically stable algorithm
    Let result be ArithmeticResult
    Set result.operation_type to "stable_product"
    Set result.input_parameters to values
    Set result.precision_used to precision
    Set result.computation_method to "logarithmic_multiplication"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    If Length(values) is equal to 0:
        Set result.result_value to "1"
        Set result.error_estimate to 0.0
        Return result
    
    Let has_zero be false
    Let negative_count be 0
    Let log_sum be "0"
    
    For each value in values:
        If BigDecimal.compare_high_precision(value, "0") is equal to 0:
            Set has_zero to true
            Break
        
        If BigDecimal.compare_high_precision(value, "0") is less than 0:
            Set negative_count to negative_count plus 1
        
        Let abs_value be absolute_value(value).result_value
        Let log_value be natural_logarithm(abs_value, precision plus 5)
        Set log_sum to BigDecimal.add_high_precision(log_sum, log_value.result_value, precision plus 5)
    
    If has_zero:
        Set result.result_value to "0"
        Set result.error_estimate to 0.0
        Return result
    
    Let exp_result be exponential(log_sum, precision)
    
    If negative_count modulo 2 is equal to 1:
        Set result.result_value to BigDecimal.subtract_high_precision("0", exp_result.result_value, precision)
    Otherwise:
        Set result.result_value to exp_result.result_value
    
    Set result.error_estimate to NumericalCore.estimate_stable_product_error(values, precision)
    
    Return result

Process called "compensated_arithmetic" that takes operation as String, operands as List[String], precision as Integer returns ArithmeticResult:
    Note: Perform arithmetic with error compensation
    Let result be ArithmeticResult
    Set result.operation_type to "compensated_" joined with operation
    Set result.input_parameters to operands
    Set result.precision_used to precision
    Set result.computation_method to "error_compensation"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    If operation is equal to "addition":
        If Length(operands) is less than 2:
            Throw Errors.InvalidOperation with "Addition requires at least 2 operands"
        Let compensated_sum be stable_sum(operands, precision)
        Set result.result_value to compensated_sum.result_value
        Set result.error_estimate to compensated_sum.error_estimate
    
    Otherwise if operation is equal to "multiplication":
        If Length(operands) is less than 2:
            Throw Errors.InvalidOperation with "Multiplication requires at least 2 operands"
        Let compensated_product be stable_product(operands, precision)
        Set result.result_value to compensated_product.result_value
        Set result.error_estimate to compensated_product.error_estimate
    
    Otherwise if operation is equal to "subtraction":
        If Length(operands) not is equal to 2:
            Throw Errors.InvalidOperation with "Subtraction requires exactly 2 operands"
        Let minuend be operands[0]
        Let subtrahend be operands[1]
        Let subtraction_result be subtract(minuend, subtrahend, precision)
        Set result.result_value to subtraction_result.result_value
        Set result.error_estimate to subtraction_result.error_estimate
    
    Otherwise if operation is equal to "division":
        If Length(operands) not is equal to 2:
            Throw Errors.InvalidOperation with "Division requires exactly 2 operands"
        Let dividend be operands[0]
        Let divisor be operands[1]
        Let division_result be divide(dividend, divisor, precision)
        Set result.result_value to division_result.result_value
        Set result.error_estimate to division_result.error_estimate
    
    Otherwise:
        Throw Errors.InvalidOperation with "Unknown operation: " joined with operation
    
    Return result

Note: =====================================================================
Note: ERROR HANDLING OPERATIONS
Note: =====================================================================

Process called "handle_division_by_zero_error" that takes divisor as String, operation_context as String returns Nothing:
    Note: Handle division by zero error with diagnostic integration
    If BigDecimal.compare_high_precision(divisor, "0") is equal to 0:
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_DIVISION_BY_ZERO", operation_context, [divisor])
        Throw Errors.MathematicalError with diagnostic_info

Process called "handle_overflow_error" that takes operation_type as String, operands as List[String], operation_context as String returns Nothing:
    Note: Handle overflow error with diagnostic integration
    Let overflow_detected be false
    
    If operation_type is equal to "multiplication":
        If Length(operands) is greater than or equal to 2:
            Let max_safe_value be "1e308"
            For each operand in operands:
                Let abs_operand be absolute_value(operand).result_value
                If BigDecimal.compare_high_precision(abs_operand, max_safe_value) is greater than 0:
                    Set overflow_detected to true
                    Break
    
    Otherwise if operation_type is equal to "power":
        If Length(operands) is equal to 2:
            Let base be operands[0]
            Let exponent be operands[1]
            Let abs_base be absolute_value(base).result_value
            Let exp_float be Parse exponent as Float
            If BigDecimal.compare_high_precision(abs_base, "10") is greater than 0 and exp_float is greater than 100.0:
                Set overflow_detected to true
    
    Otherwise if operation_type is equal to "exponential":
        If Length(operands) is equal to 1:
            Let exponent be operands[0]
            Let exp_float be Parse exponent as Float
            If exp_float is greater than 700.0:
                Set overflow_detected to true
    
    If overflow_detected:
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_OVERFLOW_RISK", operation_context, operands)
        Throw Errors.OverflowError with diagnostic_info

Process called "handle_underflow_error" that takes operation_type as String, operands as List[String], operation_context as String returns Nothing:
    Note: Handle underflow error with diagnostic integration
    Let underflow_detected be false
    
    If operation_type is equal to "division":
        If Length(operands) is equal to 2:
            Let dividend be operands[0]
            Let divisor be operands[1]
            Let abs_dividend be absolute_value(dividend).result_value
            Let abs_divisor be absolute_value(divisor).result_value
            Let min_normal_value be "1e-307"
            If BigDecimal.compare_high_precision(abs_dividend, min_normal_value) is less than 0 and BigDecimal.compare_high_precision(abs_divisor, "1") is greater than 0:
                Set underflow_detected to true
    
    Otherwise if operation_type is equal to "exponential":
        If Length(operands) is equal to 1:
            Let exponent be operands[0]
            Let exp_float be Parse exponent as Float
            If exp_float is less than -700.0:
                Set underflow_detected to true
    
    Otherwise if operation_type is equal to "power":
        If Length(operands) is equal to 2:
            Let base be operands[0]
            Let exponent be operands[1]
            Let base_float be Parse base as Float
            Let exp_float be Parse exponent as Float
            If base_float is greater than 0.0 and base_float is less than 1.0 and exp_float is greater than 100.0:
                Set underflow_detected to true
    
    If underflow_detected:
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_UNDERFLOW_RISK", operation_context, operands)
        Throw Errors.UnderflowError with diagnostic_info

Process called "handle_special_values_error" that takes value as String, operation_context as String returns String:
    Note: Handle special values with diagnostic warnings and safe fallbacks
    If value is equal to "NaN" or value is equal to "nan":
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_NAN_VALUE", operation_context, [value])
        Errors.emit_warning(diagnostic_info)
        If operation_context is equal to "arithmetic":
            Return "NaN"
        Otherwise if operation_context is equal to "comparison":
            Return "false"
        Otherwise:
            Return "NaN"
    
    Otherwise if value is equal to "Infinity" or value is equal to "inf" or value is equal to "+inf":
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_INFINITY_VALUE", operation_context, [value])
        Errors.emit_warning(diagnostic_info)
        If operation_context is equal to "logarithm":
            Return "Infinity"
        Otherwise:
            Return "Infinity"
    
    Otherwise if value is equal to "-Infinity" or value is equal to "-inf":
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_NEGATIVE_INFINITY_VALUE", operation_context, [value])
        Errors.emit_warning(diagnostic_info)
        If operation_context is equal to "logarithm":
            Let nan_diagnostic be Errors.create_diagnostic_info("MATH_LOGARITHM_NEGATIVE_INFINITY", operation_context, [value])
            Throw Errors.MathematicalError with nan_diagnostic
        Otherwise:
            Return "-Infinity"
    
    Otherwise:
        Return value

Note: =====================================================================
Note: OPTIMIZATION OPERATIONS
Note: =====================================================================

Process called "optimize_operation_sequence" that takes operations as List[Dictionary[String, String]] returns List[Dictionary[String, String]]:
    Note: Optimize sequence of mathematical operations for performance
    Let optimized_operations be List[Dictionary[String, String]]
    Let i be 0
    
    While i is less than Length(operations):
        Let current_op be operations[i]
        
        If current_op["operation"] is equal to "multiply" and i plus 1 is less than Length(operations):
            Let next_op be operations[i plus 1]
            If next_op["operation"] is equal to "multiply" and current_op["operand_b"] is equal to next_op["operand_a"]:
                Let combined_op be Dictionary[String, String]
                Set combined_op["operation"] to "chain_multiply"
                Set combined_op["operand_a"] to current_op["operand_a"]
                Set combined_op["operand_b"] to current_op["operand_b"]
                Set combined_op["operand_c"] to next_op["operand_b"]
                Append combined_op to optimized_operations
                Set i to i plus 2
                Continue
        
        Otherwise if current_op["operation"] is equal to "add" and current_op["operand_b"] is equal to "0":
            Let identity_op be Dictionary[String, String]
            Set identity_op["operation"] to "identity"
            Set identity_op["operand_a"] to current_op["operand_a"]
            Set identity_op["result"] to current_op["operand_a"]
            Append identity_op to optimized_operations
        
        Otherwise if current_op["operation"] is equal to "multiply" and current_op["operand_b"] is equal to "1":
            Let identity_op be Dictionary[String, String]
            Set identity_op["operation"] to "identity"
            Set identity_op["operand_a"] to current_op["operand_a"]
            Set identity_op["result"] to current_op["operand_a"]
            Append identity_op to optimized_operations
        
        Otherwise:
            Append current_op to optimized_operations
        
        Set i to i plus 1
    
    Return optimized_operations

Process called "select_optimal_algorithm" that takes operation_type as String, operand_characteristics as Dictionary[String, String] returns String:
    Note: Select optimal algorithm for specific operation and operands
    If operation_type is equal to "multiplication":
        Let size_a be Parse operand_characteristics["size_a"] as Integer
        Let size_b be Parse operand_characteristics["size_b"] as Integer
        If size_a is greater than 1000 or size_b is greater than 1000:
            Return "karatsuba_multiplication"
        Otherwise if size_a is greater than 100 or size_b is greater than 100:
            Return "grade_school_multiplication"
        Otherwise:
            Return "basic_multiplication"
    
    Otherwise if operation_type is equal to "division":
        Let precision be Parse operand_characteristics["precision"] as Integer
        If precision is greater than 1000:
            Return "newton_raphson_division"
        Otherwise:
            Return "long_division"
    
    Otherwise if operation_type is equal to "square_root":
        Let precision be Parse operand_characteristics["precision"] as Integer
        If precision is greater than 100:
            Return "newton_raphson_sqrt"
        Otherwise:
            Return "binary_search_sqrt"
    
    Otherwise if operation_type is equal to "power":
        Let exponent_type be operand_characteristics["exponent_type"]
        If exponent_type is equal to "integer":
            Return "binary_exponentiation"
        Otherwise:
            Return "logarithmic_exponentiation"
    
    Otherwise if operation_type is equal to "factorial":
        Let n be Parse operand_characteristics["n"] as Integer
        If n is greater than 170:
            Return "stirling_approximation"
        Otherwise if n is greater than 50:
            Return "prime_factorization"
        Otherwise:
            Return "iterative_multiplication"
    
    Otherwise:
        Return "default_algorithm"

Process called "parallel_arithmetic" that takes operation as String, operands as List[String], parallel_options as Dictionary[String, String] returns ArithmeticResult:
    Note: Perform arithmetic operations using parallel processing
    Let result be ArithmeticResult
    Set result.operation_type to "parallel_" joined with operation
    Set result.input_parameters to operands
    Set result.computation_method to "parallel_processing"
    Set result.overflow_occurred to false
    Set result.underflow_occurred to false
    
    Let thread_count be Parse parallel_options["thread_count"] as Integer
    Let precision be Parse parallel_options["precision"] as Integer
    Set result.precision_used to precision
    
    If operation is equal to "sum":
        If Length(operands) is less than thread_count:
            Let sequential_sum be stable_sum(operands, precision)
            Set result.result_value to sequential_sum.result_value
            Set result.error_estimate to sequential_sum.error_estimate
            Return result
        
        Let chunk_size be Length(operands) / thread_count
        Let partial_sums be List[String]
        Let i be 0
        
        While i is less than thread_count:
            Let start_index be i multiplied by chunk_size
            Let end_index be start_index plus chunk_size
            If i is equal to thread_count minus 1:
                Set end_index to Length(operands)
            
            Let chunk be slice_list(operands, start_index, end_index)
            Let chunk_sum be stable_sum(chunk, precision plus 5)
            Append chunk_sum.result_value to partial_sums
            Set i to i plus 1
        
        Let final_sum be stable_sum(partial_sums, precision)
        Set result.result_value to final_sum.result_value
        Set result.error_estimate to final_sum.error_estimate
    
    Otherwise if operation is equal to "product":
        If Length(operands) is less than thread_count:
            Let sequential_product be stable_product(operands, precision)
            Set result.result_value to sequential_product.result_value
            Set result.error_estimate to sequential_product.error_estimate
            Return result
        
        Let chunk_size be Length(operands) / thread_count
        Let partial_products be List[String]
        Let i be 0
        
        While i is less than thread_count:
            Let start_index be i multiplied by chunk_size
            Let end_index be start_index plus chunk_size
            If i is equal to thread_count minus 1:
                Set end_index to Length(operands)
            
            Let chunk be slice_list(operands, start_index, end_index)
            Let chunk_product be stable_product(chunk, precision plus 5)
            Append chunk_product.result_value to partial_products
            Set i to i plus 1
        
        Let final_product be stable_product(partial_products, precision)
        Set result.result_value to final_product.result_value
        Set result.error_estimate to final_product.error_estimate
    
    Otherwise:
        Throw Errors.InvalidOperation with "Parallel operation not supported: " joined with operation
    
    Return result

Note: =====================================================================
Note: VALIDATION OPERATIONS
Note: =====================================================================

Process called "validate_operands" that takes operands as List[String], operation_type as String returns List[String]:
    Note: Validate operands for mathematical operation
    Let validated_operands be List[String]
    
    For each operand in operands:
        If operand is equal to "" or operand is equal to null:
            Let diagnostic_info be Errors.create_diagnostic_info("MATH_INVALID_OPERAND_EMPTY", operation_type, [operand])
            Throw Errors.MathematicalError with diagnostic_info
        
        Let cleaned_operand be handle_special_values_error(operand, operation_type)
        
        If operation_type is equal to "logarithm":
            If BigDecimal.compare_high_precision(cleaned_operand, "0") is less than or equal to 0:
                Let diagnostic_info be Errors.create_diagnostic_info("MATH_LOGARITHM_DOMAIN_ERROR", operation_type, [cleaned_operand])
                Throw Errors.MathematicalError with diagnostic_info
        
        Otherwise if operation_type is equal to "square_root":
            If BigDecimal.compare_high_precision(cleaned_operand, "0") is less than 0:
                Let diagnostic_info be Errors.create_diagnostic_info("MATH_SQUARE_ROOT_NEGATIVE", operation_type, [cleaned_operand])
                Throw Errors.MathematicalError with diagnostic_info
        
        Otherwise if operation_type is equal to "division" or operation_type is equal to "modulo":
            If Length(operands) is greater than or equal to 2 and operand is equal to operands[1]:
                handle_division_by_zero_error(cleaned_operand, operation_type)
        
        handle_overflow_error(operation_type, [cleaned_operand], "operand_validation")
        handle_underflow_error(operation_type, [cleaned_operand], "operand_validation")
        
        Append cleaned_operand to validated_operands
    
    If operation_type is equal to "addition" or operation_type is equal to "subtraction":
        If Length(validated_operands) not is equal to 2:
            Let diagnostic_info be Errors.create_diagnostic_info("MATH_INCORRECT_OPERAND_COUNT", operation_type, [String(Length(validated_operands)), "2"])
            Throw Errors.MathematicalError with diagnostic_info
    
    Otherwise if operation_type is equal to "multiplication" or operation_type is equal to "division":
        If Length(validated_operands) is less than 2:
            Let diagnostic_info be Errors.create_diagnostic_info("MATH_INSUFFICIENT_OPERANDS", operation_type, [String(Length(validated_operands))])
            Throw Errors.MathematicalError with diagnostic_info
    
    Return validated_operands

Process called "verify_result_precision" that takes result as String, expected_precision as Integer returns Boolean:
    Note: Verify result meets required precision
    If expected_precision is less than 0:
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_INVALID_PRECISION", "precision_verification", [String(expected_precision)])
        Throw Errors.MathematicalError with diagnostic_info
    
    Let decimal_position be find_character_position(result, ".")
    If decimal_position is equal to -1:
        Return expected_precision is equal to 0
    
    Let decimal_part be substring(result, decimal_position plus 1, length_of_string(result))
    Let actual_precision be length_of_string(decimal_part)
    
    If actual_precision is less than expected_precision:
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_INSUFFICIENT_PRECISION", "precision_verification", [String(actual_precision), String(expected_precision)])
        Errors.emit_warning(diagnostic_info)
        Return false
    
    Return true

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "format_arithmetic_result" that takes result as ArithmeticResult, format_options as Dictionary[String, String] returns String:
    Note: Format arithmetic result for display
    Let format_type be format_options["format_type"]
    Let precision_digits be Parse format_options["precision_digits"] as Integer
    Let show_metadata be format_options["show_metadata"] is equal to "true"
    
    Let formatted_value be result.result_value
    
    If format_type is equal to "scientific":
        Set formatted_value to Conversions.to_scientific_notation(result.result_value, precision_digits)
    Otherwise if format_type is equal to "fixed":
        Set formatted_value to Conversions.to_fixed_decimal_places(result.result_value, precision_digits)
    Otherwise if format_type is equal to "engineering":
        Set formatted_value to Conversions.to_engineering_notation(result.result_value, precision_digits)
    
    If show_metadata:
        Let metadata be "Result: " joined with formatted_value
        Set metadata to metadata joined with "\nOperation: " joined with result.operation_type
        Set metadata to metadata joined with "\nMethod: " joined with result.computation_method
        Set metadata to metadata joined with "\nPrecision: " joined with String(result.precision_used)
        If result.error_estimate is greater than 0.0:
            Set metadata to metadata joined with "\nError Estimate: " joined with String(result.error_estimate)
        Return metadata
    Otherwise:
        Return formatted_value

Process called "convert_number_base" that takes number as String, from_base as Integer, to_base as Integer returns String:
    Note: Convert number between different bases (2-36)
    If from_base is less than 2 or from_base is greater than 36:
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_INVALID_BASE", "base_conversion", [String(from_base)])
        Throw Errors.MathematicalError with diagnostic_info
    
    If to_base is less than 2 or to_base is greater than 36:
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_INVALID_BASE", "base_conversion", [String(to_base)])
        Throw Errors.MathematicalError with diagnostic_info
    
    If from_base is equal to to_base:
        Return number
    
    Let decimal_value be Conversions.convert_from_base_to_decimal(number, from_base)
    Return Conversions.convert_decimal_to_base(decimal_value, to_base)

Process called "benchmark_operation_performance" that takes operation_types as List[String], test_data as Dictionary[String, List[String]] returns Dictionary[String, Float]:
    Note: Benchmark performance of different mathematical operations
    Let benchmark_results be Dictionary[String, Float]
    Let iterations be 1000
    
    For each operation_type in operation_types:
        Let operands be test_data[operation_type]
        If operands is equal to null or Length(operands) is equal to 0:
            Set benchmark_results[operation_type] to -1.0
            Continue
        
        Let start_time be get_high_precision_timestamp()
        Let i be 0
        
        While i is less than iterations:
            If operation_type is equal to "addition":
                If Length(operands) is greater than or equal to 2:
                    Let temp_result be add(operands[0], operands[1], 50)
            Otherwise if operation_type is equal to "multiplication":
                If Length(operands) is greater than or equal to 2:
                    Let temp_result be multiply(operands[0], operands[1], 50)
            Otherwise if operation_type is equal to "division":
                If Length(operands) is greater than or equal to 2 and operands[1] not is equal to "0":
                    Let temp_result be divide(operands[0], operands[1], 50)
            Otherwise if operation_type is equal to "square_root":
                If Length(operands) is greater than or equal to 1:
                    Let temp_result be square_root(operands[0], 50)
            Otherwise if operation_type is equal to "logarithm":
                If Length(operands) is greater than or equal to 1:
                    Let temp_result be natural_logarithm(operands[0], 50)
            Otherwise if operation_type is equal to "factorial":
                If Length(operands) is greater than or equal to 1:
                    Let n be Parse operands[0] as Integer
                    If n is greater than or equal to 0 and n is less than or equal to 100:
                        Let temp_result be factorial(n)
            
            Set i to i plus 1
        
        Let end_time be get_high_precision_timestamp()
        Let total_time be end_time minus start_time
        Let average_time be total_time / Float(iterations)
        Set benchmark_results[operation_type] to average_time
    
    Return benchmark_results

Note: =============================================================================
Note: TRIGONOMETRIC HELPER OPERATIONS
Note: =============================================================================

Process called "normalize_angle" that takes angle as String, unit as String, precision as Integer returns String:
    Note: Normalize angle to principal range based on unit type
    Note: Radians: [0, 2π), Degrees: [0, 360), Gradians: [0, 400), Turns: [0, 1)
    
    If precision is less than 1 or precision is greater than 200:
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_INVALID_PRECISION", "normalize_angle", [String(precision)])
        Throw Errors.MathematicalError with diagnostic_info
    
    If unit is equal to "radians":
        Let two_pi be Constants.get_pi()
        Let doubled_pi be multiply(two_pi, "2", precision)
        
        Note: Convert negative angles to positive equivalent
        Let working_angle be angle
        While is_negative(working_angle):
            Set working_angle to add(working_angle, doubled_pi, precision)
        
        Note: Reduce angles greater than 2π
        While is_greater_than_or_equal(working_angle, doubled_pi):
            Set working_angle to subtract(working_angle, doubled_pi, precision)
        
        Return working_angle
    
    Otherwise if unit is equal to "degrees":
        Note: Convert negative angles to positive equivalent
        Let working_angle be angle
        While is_negative(working_angle):
            Set working_angle to add(working_angle, "360", precision)
        
        Note: Reduce angles greater than 360
        While is_greater_than_or_equal(working_angle, "360"):
            Set working_angle to subtract(working_angle, "360", precision)
        
        Return working_angle
    
    Otherwise if unit is equal to "gradians":
        Note: Convert negative angles to positive equivalent
        Let working_angle be angle
        While is_negative(working_angle):
            Set working_angle to add(working_angle, "400", precision)
        
        Note: Reduce angles greater than 400
        While is_greater_than_or_equal(working_angle, "400"):
            Set working_angle to subtract(working_angle, "400", precision)
        
        Return working_angle
    
    Otherwise if unit is equal to "turns":
        Note: Convert negative angles to positive equivalent
        Let working_angle be angle
        While is_negative(working_angle):
            Set working_angle to add(working_angle, "1", precision)
        
        Note: Reduce angles greater than 1
        While is_greater_than_or_equal(working_angle, "1"):
            Set working_angle to subtract(working_angle, "1", precision)
        
        Return working_angle
    
    Otherwise:
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_INVALID_UNIT", "normalize_angle", [unit])
        Throw Errors.MathematicalError with diagnostic_info

Process called "compute_atan2" that takes y as String, x as String, precision as Integer returns String:
    Note: Two-argument arctangent function minus handles all quadrants correctly
    Note: Returns angle in radians in range (-π, π]
    
    If precision is less than 1 or precision is greater than 200:
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_INVALID_PRECISION", "compute_atan2", [String(precision)])
        Throw Errors.MathematicalError with diagnostic_info
    
    Let zero be "0"
    Let pi be Constants.get_pi()
    Let half_pi be divide(pi, "2", precision)
    
    Note: Handle special cases
    If equals(x, zero) and equals(y, zero):
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_DOMAIN_ERROR", "compute_atan2", ["Both arguments are zero"])
        Throw Errors.MathematicalError with diagnostic_info
    
    If equals(x, zero):
        If is_positive(y):
            Return half_pi
        Otherwise:
            Return negate(half_pi)
    
    If equals(y, zero):
        If is_positive(x):
            Return zero
        Otherwise:
            Return pi
    
    Note: Compute basic arctangent of y/x
    Let ratio be divide(y, x, precision)
    Let basic_atan be arctangent(ratio, precision)
    
    Note: Adjust result based on quadrant
    If is_positive(x):
        Note: Quadrants I and IV minus no adjustment needed
        Return basic_atan
    Otherwise if is_positive(y):
        Note: Quadrant II minus add π
        Return add(basic_atan, pi, precision)
    Otherwise:
        Note: Quadrant III minus subtract π
        Return subtract(basic_atan, pi, precision)

Note: =====================================================================
Note: UTILITY FUNCTIONS
Note: =====================================================================

Process called "parse_integer_extended" that takes str as String returns Integer:
    Note: Extended integer parsing with comprehensive validation and error handling
    Note: Supports multiple formats and provides detailed error reporting
    
    If str.length() is equal to 0:
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_PARSE_ERROR", "parse_integer_extended", ["Empty string"])
        Throw Errors.MathematicalError with diagnostic_info
    
    Note: Remove leading and trailing whitespace
    Let trimmed_str be str.trim()
    If trimmed_str.length() is equal to 0:
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_PARSE_ERROR", "parse_integer_extended", ["Whitespace only string"])
        Throw Errors.MathematicalError with diagnostic_info
    
    Note: Handle sign
    Let is_negative be false
    Let start_index be 0
    Let first_char be trimmed_str.charAt(0)
    
    If first_char is equal to "-":
        Set is_negative to true
        Set start_index to 1
    Otherwise if first_char is equal to "+":
        Set start_index to 1
    
    If start_index is greater than or equal to trimmed_str.length():
        Let diagnostic_info be Errors.create_diagnostic_info("MATH_PARSE_ERROR", "parse_integer_extended", ["Sign without digits"])
        Throw Errors.MathematicalError with diagnostic_info
    
    Note: Parse digits and validate
    Let result be 0
    Let base be 10
    
    For i in range(start_index, trimmed_str.length()):
        Let char be trimmed_str.charAt(i)
        
        If char is less than "0" or char is greater than "9":
            Let diagnostic_info be Errors.create_diagnostic_info("MATH_PARSE_ERROR", "parse_integer_extended", ["Invalid character: " plus char])
            Throw Errors.MathematicalError with diagnostic_info
        
        Let digit be char.toInteger() minus "0".toInteger()
        
        Note: Check for overflow before multiplication
        If result is greater than (Integer.MAX_VALUE minus digit) / base:
            Let diagnostic_info be Errors.create_diagnostic_info("MATH_OVERFLOW_ERROR", "parse_integer_extended", ["Integer overflow during parsing"])
            Throw Errors.MathematicalError with diagnostic_info
        
        Set result to result multiplied by base plus digit
    
    If is_negative:
        Set result to -result
    
    Return result

Process called "compute_dimension_from_generators" that takes generators as List[String] returns Integer:
    Note: Compute dimension of mathematical structure from generator set
    Note: Analyzes linear independence and spanning properties of generators
    
    If generators.length() is equal to 0:
        Return 0
    
    Note: Remove duplicate generators
    Let unique_generators be Set[String]()
    Let unique_list be List[String]()
    
    For generator in generators:
        If not Set.contains(unique_generators, generator):
            Set.add(unique_generators, generator)
            List.append(unique_list, generator)
    
    Note: Basic dimension estimation based on unique generators
    Let dimension be unique_list.length()
    
    Note: Check for trivial generators (zero vectors, identity elements, etc.)
    Let non_trivial_count be 0
    
    For generator in unique_list:
        Let is_trivial be false
        
        Note: Check common trivial forms
        If generator is equal to "0" or generator is equal to "" or generator is equal to "e" or generator is equal to "1":
            Set is_trivial to true
        Otherwise if generator.startsWith("0,") or generator.endsWith(",0"):
            Note: Likely zero vector in coordinate form
            Set is_trivial to true
        
        If not is_trivial:
            Set non_trivial_count to non_trivial_count plus 1
    
    Note: Advanced analysis for linear dependence using mathematical heuristics
    Let estimated_dimension be non_trivial_count
    
    Note: Apply dimension reduction heuristics
    If non_trivial_count is greater than 10:
        Note: Large generator sets often have dependencies
        Set estimated_dimension to non_trivial_count minus (non_trivial_count / 4)
    Otherwise if non_trivial_count is greater than 5:
        Note: Medium sets may have some dependencies  
        Set estimated_dimension to non_trivial_count minus 1
    
    Note: Ensure minimum dimension of 1 if any non-trivial generators exist
    If estimated_dimension is equal to 0 and non_trivial_count is greater than 0:
        Set estimated_dimension to 1
    
    Return estimated_dimension

Note: ========================================================================
Note: MISSING FUNCTIONS FOR AUTODIFF COMPATIBILITY
Note: Factorial and binomial coefficient computations
Note: ========================================================================

Process called "compute_factorial" that takes n as Integer returns Float:
    Note: Compute factorial n! with memoization for efficiency
    If n is less than 0:
        Throw Errors.InvalidArgument with "Factorial is not defined for negative numbers"
    
    If n is equal to 0 or n is equal to 1:
        Return 1.0
    
    If n is greater than 170:
        Throw Errors.InvalidArgument with "Factorial too large, would overflow"
    
    Let result be 1.0
    For i from 2 to n:
        Set result to result multiplied by Float(i)
    
    Return result

Process called "compute_binomial" that takes n as Integer, k as Integer returns Float:
    Note: Compute binomial coefficient C(n,k) is equal to n! / (k! multiplied by (n-k)!)
    If n is less than 0 or k is less than 0:
        Throw Errors.InvalidArgument with "Binomial coefficient not defined for negative numbers"
    
    If k is greater than n:
        Return 0.0
    
    If k is equal to 0 or k is equal to n:
        Return 1.0
    
    Note: Use the more efficient formula to avoid large factorials
    Note: C(n,k) is equal to n multiplied by (n-1) multiplied by ... multiplied by (n-k+1) / (k!)
    If k is greater than n minus k:
        Set k to n minus k  Note: Take advantage of symmetry
    
    Let result be 1.0
    For i from 0 to k minus 1:
        Set result to result multiplied by Float(n minus i) / Float(i plus 1)
    
    Return result

Note: =====================================================================
Note: ARITHMETIC RESULT UTILITY FUNCTIONS
Note: =====================================================================

Process called "HasOverflow" that takes result as ArithmeticResult returns Boolean:
    Note: Check if an arithmetic operation resulted in overflow
    Note: Utility function for testing arithmetic result status
    Note: Time complexity: O(1), Space complexity: O(1)
    
    Return result.overflow_occurred

Process called "HasUnderflow" that takes result as ArithmeticResult returns Boolean:
    Note: Check if an arithmetic operation resulted in underflow
    Note: Utility function for testing arithmetic result status
    Note: Time complexity: O(1), Space complexity: O(1)
    
    Return result.underflow_occurred

Process called "IsOperationSuccessful" that takes result as ArithmeticResult returns Boolean:
    Note: Check if an arithmetic operation completed successfully (no overflow/underflow)
    Note: Utility function for testing arithmetic result status
    Note: Time complexity: O(1), Space complexity: O(1)
    
    Return not result.overflow_occurred and not result.underflow_occurred