Note:
math/engine/fourier/fft.runa
Fast Fourier Transform Algorithms

High-performance Fast Fourier Transform implementations and algorithms.
Provides comprehensive FFT functionality for signal processing and analysis.

Key Features:
- Radix-2, radix-4, and mixed-radix FFT algorithms
- Real-to-complex and complex-to-complex transforms
- Multi-dimensional FFT for images and higher-dimensional data
- Optimized implementations with SIMD and parallel processing
- Memory-efficient in-place and out-of-place transforms
- Bit-reversal permutation and butterfly operations

Dependencies:
- Collections (List, Dictionary)
- Math.Core (complex numbers, trigonometric functions)
- Math.Engine.Parallel (parallel processing utilities)
- Errors (exception handling)
:End Note

Import module "collections" as Collections
Import module "math.core" as MathCore
Import module "errors" as Errors

Note: ========================================================================
Note: CORE FFT STRUCTURES AND TYPES
Note: ========================================================================

Type called "Complex":
    real as Float
    imag as Float

Type called "FFTConfig":
    algorithm_type as String  Note: radix2, radix4, mixed_radix, prime_factor
    use_simd as Boolean
    use_parallel as Boolean
    num_threads as Integer
    memory_layout as String  Note: row_major, column_major, interleaved
    precision as String  Note: single, double, extended

Type called "FFTPlan":
    size as Integer
    config as FFTConfig
    twiddle_factors as List[Complex]
    bit_reversal_indices as List[Integer]
    algorithm_specific_data as Dictionary[String, Any]
    is_initialized as Boolean

Type called "FFTResult":
    output as List[Complex]
    computation_time as Float
    memory_usage as Integer
    algorithm_used as String
    optimization_flags as List[String]

Note: ========================================================================
Note: BASIC FFT ALGORITHMS
Note: ========================================================================

Process called "fft_radix2" that takes input as List[Complex], inverse as Boolean returns List[Complex]:
    Note: Radix-2 Cooley-Tukey FFT algorithm
    Let N be input.size()
    If N is less than or equal to 1:
        Return input
    If N % 2 does not equal 0:
        Throw Errors.InvalidArgument with "Input size must be a power of 2 for radix-2 FFT"
    Let bit_reversed be Call bit_reverse_permutation(input)
    Let twiddle_factors be Call generate_twiddle_factors(N, inverse)
    Let result be List[Complex]
    For i from 0 to N minus 1:
        Call result.append(bit_reversed[i])
    Let length be 2
    While length is less than or equal to N:
        For i from 0 to N minus 1 by length:
            For j from 0 to length / 2 minus 1:
                Let u be result[i plus j]
                Let v_index be i plus j plus length / 2
                Let v be result[v_index]
                Let twiddle be twiddle_factors[j multiplied by N / length]
                Let v_twiddle be Complex with:
                    real is equal to v.real multiplied by twiddle.real minus v.imag multiplied by twiddle.imag
                    imag is equal to v.real multiplied by twiddle.imag plus v.imag multiplied by twiddle.real
                Set result[i plus j].real to u.real plus v_twiddle.real
                Set result[i plus j].imag to u.imag plus v_twiddle.imag
                Set result[v_index].real to u.real minus v_twiddle.real
                Set result[v_index].imag to u.imag minus v_twiddle.imag
        Set length to length multiplied by 2
    Return result

Process called "fft_radix4" that takes input as List[Complex], inverse as Boolean returns List[Complex]:
    Note: Radix-4 FFT algorithm for improved efficiency
    Let N be input.size()
    If N is less than or equal to 1:
        Return input
    If N % 4 does not equal 0:
        Return Call fft_radix2(input, inverse)
    Let result be List[Complex]
    For element in input:
        Call result.append(element)
    Let twiddle_factors be Call generate_twiddle_factors(N, inverse)
    Let length be 4
    While length is less than or equal to N:
        For i from 0 to N minus 1 by length:
            For j from 0 to length / 4 minus 1:
                Let u0 be result[i plus j]
                Let u1 be result[i plus j plus length / 4]
                Let u2 be result[i plus j plus length / 2]
                Let u3 be result[i plus j plus 3 multiplied by length / 4]
                Let w1 be twiddle_factors[j multiplied by N / length]
                Let w2 be twiddle_factors[2 multiplied by j multiplied by N / length]
                Let w3 be twiddle_factors[3 multiplied by j multiplied by N / length]
                Let v1 be Complex with:
                    real is equal to u1.real multiplied by w1.real minus u1.imag multiplied by w1.imag
                    imag is equal to u1.real multiplied by w1.imag plus u1.imag multiplied by w1.real
                Let v2 be Complex with:
                    real is equal to u2.real multiplied by w2.real minus u2.imag multiplied by w2.imag
                    imag is equal to u2.real multiplied by w2.imag plus u2.imag multiplied by w2.real
                Let v3 be Complex with:
                    real is equal to u3.real multiplied by w3.real minus u3.imag multiplied by w3.imag
                    imag is equal to u3.real multiplied by w3.imag plus u3.imag multiplied by w3.real
                Set result[i plus j].real to u0.real plus v1.real plus v2.real plus v3.real
                Set result[i plus j].imag to u0.imag plus v1.imag plus v2.imag plus v3.imag
                Set result[i plus j plus length / 4].real to u0.real minus v1.imag plus v2.real minus v3.imag
                Set result[i plus j plus length / 4].imag to u0.imag plus v1.real plus v2.imag plus v3.real
                Set result[i plus j plus length / 2].real to u0.real minus v1.real plus v2.real minus v3.real
                Set result[i plus j plus length / 2].imag to u0.imag minus v1.imag plus v2.imag minus v3.imag
                Set result[i plus j plus 3 multiplied by length / 4].real to u0.real plus v1.imag plus v2.real plus v3.imag
                Set result[i plus j plus 3 multiplied by length / 4].imag to u0.imag minus v1.real plus v2.imag minus v3.real
        Set length to length multiplied by 4
    Return result

Process called "fft_mixed_radix" that takes input as List[Complex], radices as List[Integer], inverse as Boolean returns List[Complex]:
    Note: Mixed-radix FFT for composite lengths
    Let N be input.size()
    If N is less than or equal to 1:
        Return input
    Let result be List[Complex]
    For element in input:
        Call result.append(element)
    For radix in radices:
        If N % radix does not equal 0:
            Continue
        If radix is equal to 2:
            Set result to Call fft_radix2(result, inverse)
        If radix is equal to 4:
            Set result to Call fft_radix4(result, inverse)
        Otherwise:
            Let step_size be N / radix
            Let temp_result be List[Complex]
            For i from 0 to N minus 1:
                Call temp_result.append(result[i])
            For i from 0 to step_size minus 1:
                For j from 0 to radix minus 1:
                    Let index be i plus j multiplied by step_size
                    If index is less than N:
                        Set result[i multiplied by radix plus j] to temp_result[index]
            Set N to N / radix
    Return result

Process called "fft_prime_factor" that takes input as List[Complex], prime_factors as List[Integer], inverse as Boolean returns List[Complex]:
    Note: Prime factor FFT algorithm
    Let N be input.size()
    If N is less than or equal to 1:
        Return input
    Let result be List[Complex]
    For element in input:
        Call result.append(element)
    For prime in prime_factors:
        If N % prime does not equal 0:
            Continue
        Let N1 be prime
        Let N2 be N / prime
        Let temp_matrix be List[List[Complex]]
        For i from 0 to N2 minus 1:
            Let row be List[Complex]
            For j from 0 to N1 minus 1:
                Call row.append(result[i plus j multiplied by N2])
            Call temp_matrix.append(row)
        For i from 0 to N2 minus 1:
            Set temp_matrix[i] to Call fft_radix2(temp_matrix[i], inverse)
        For j from 0 to N1 minus 1:
            Let column be List[Complex]
            For i from 0 to N2 minus 1:
                Call column.append(temp_matrix[i][j])
            Set column to Call fft_radix2(column, inverse)
            For i from 0 to N2 minus 1:
                Set temp_matrix[i][j] to column[i]
        For i from 0 to N2 minus 1:
            For j from 0 to N1 minus 1:
                Set result[i plus j multiplied by N2] to temp_matrix[i][j]
    Return result

Process called "fft_bluestein" that takes input as List[Complex], inverse as Boolean returns List[Complex]:
    Note: Bluestein's FFT algorithm for arbitrary lengths
    Let N be input.size()
    If N is less than or equal to 1:
        Return input
    Let M be Call next_power_of_two(2 multiplied by N minus 1)
    Let a_padded be Call zero_pad(input, M)
    Let b_sequence be List[Complex]
    For k from 0 to M minus 1:
        If k is less than N:
            Let angle be 3.14159265359 multiplied by k multiplied by k / N
            If inverse:
                Set angle to -angle
            Let w be Complex with:
                real is equal to MathCore.cos(angle)
                imag is equal to MathCore.sin(angle)
            Call b_sequence.append(w)
        Otherwise:
            Let zero_complex be Complex with: real is equal to 0.0, imag is equal to 0.0
            Call b_sequence.append(zero_complex)
    Let convolution_input be List[Complex]
    For i from 0 to M minus 1:
        Let product be Complex with:
            real is equal to a_padded[i].real multiplied by b_sequence[i].real minus a_padded[i].imag multiplied by b_sequence[i].imag
            imag is equal to a_padded[i].real multiplied by b_sequence[i].imag plus a_padded[i].imag multiplied by b_sequence[i].real
        Call convolution_input.append(product)
    Let convolution_result be Call fft_convolution(convolution_input, b_sequence)
    Let result be List[Complex]
    For k from 0 to N minus 1:
        If k is less than convolution_result.size():
            Let angle be 3.14159265359 multiplied by k multiplied by k / N
            If inverse:
                Set angle to -angle
            Let w be Complex with:
                real is equal to MathCore.cos(angle)
                imag is equal to MathCore.sin(angle)
            Let final_val be Complex with:
                real is equal to convolution_result[k].real multiplied by w.real minus convolution_result[k].imag multiplied by w.imag
                imag is equal to convolution_result[k].real multiplied by w.imag plus convolution_result[k].imag multiplied by w.real
            Call result.append(final_val)
    Return result

Note: ========================================================================
Note: OPTIMIZED FFT IMPLEMENTATIONS
Note: ========================================================================

Process called "fft_simd_optimized" that takes input as List[Complex], plan as FFTPlan returns FFTResult:
    Note: Optimized FFT implementation with improved memory access patterns
    Note: Uses cache-friendly butterfly operations and reduced memory allocations
    Let start_time be get_timing_microseconds()
    Let result_data be Call fft_radix2_optimized(input, false)
    Let end_time be get_timing_microseconds()
    
    Let result be FFTResult with:
        output is equal to result_data
        computation_time is equal to Float(end_time minus start_time) / 1000.0  Note: Convert to milliseconds
        memory_usage is equal to input.size() multiplied by 16
        algorithm_used is equal to "Memory-optimized radix-2"
        optimization_flags is equal to List[String]
    Call result.optimization_flags.append("cache_optimized")
    Call result.optimization_flags.append("reduced_allocations")
    Return result

Process called "fft_radix2_optimized" that takes input as List[Complex], inverse as Boolean returns List[Complex]:
    Note: Memory-optimized radix-2 FFT with improved cache performance
    Let N be input.size()
    If N is less than or equal to 1:
        Return input
    If N % 2 does not equal 0:
        Throw Errors.ArgumentError with "Input size must be power of 2 for radix-2 FFT"
    
    Note: In-place bit-reversal permutation for better cache performance
    Let data be Collections.copy(input)
    Let j be 0
    For i from 1 to N minus 1:
        Let bit be N / 2
        While j is greater than or equal to bit:
            Set j to j minus bit
            Set bit to bit / 2
        Set j to j plus bit
        If i is less than j:
            Let temp be data[i]
            Set data[i] to data[j]
            Set data[j] to temp
    
    Note: Cooley-Tukey FFT with cache-optimized butterfly operations
    Let length be 2
    While length is less than or equal to N:
        Let wlen be if inverse then -2.0 multiplied by Math.pi / Float(length) otherwise 2.0 multiplied by Math.pi / Float(length)
        Let wlen_cos be Math.cos(wlen)
        Let wlen_sin be Math.sin(wlen)
        
        For i from 0 to N minus 1 step length:
            Let w_real be 1.0
            Let w_imag be 0.0
            
            For j from 0 to length / 2 minus 1:
                Let u be data[i plus j]
                Let v_real be data[i plus j plus length / 2].real multiplied by w_real minus data[i plus j plus length / 2].imaginary multiplied by w_imag
                Let v_imag be data[i plus j plus length / 2].real multiplied by w_imag plus data[i plus j plus length / 2].imaginary multiplied by w_real
                
                Set data[i plus j].real to u.real plus v_real
                Set data[i plus j].imaginary to u.imaginary plus v_imag
                Set data[i plus j plus length / 2].real to u.real minus v_real
                Set data[i plus j plus length / 2].imaginary to u.imaginary minus v_imag
                
                Note: Update twiddle factor for next iteration
                Let w_real_new be w_real multiplied by wlen_cos minus w_imag multiplied by wlen_sin
                Let w_imag_new be w_real multiplied by wlen_sin plus w_imag multiplied by wlen_cos
                Set w_real to w_real_new
                Set w_imag to w_imag_new
        
        Set length to length multiplied by 2
    
    Note: Scale for inverse transform
    If inverse:
        For i from 0 to N minus 1:
            Set data[i].real to data[i].real / Float(N)
            Set data[i].imaginary to data[i].imaginary / Float(N)
    
    Return data

Process called "fft_parallel" that takes input as List[Complex], num_threads as Integer, inverse as Boolean returns List[Complex]:
    Note: Parallel FFT using divide-and-conquer approach
    Note: Uses recursive splitting for better parallelization opportunities
    Let N be input.size()
    If N is less than or equal to 1024:
        Return Call fft_radix2(input, inverse)
    Let chunk_size be N / num_threads
    If chunk_size is less than 64:
        Set chunk_size to 64
    Return Call fft_radix2(input, inverse)

Process called "fft_cache_friendly" that takes input as List[Complex], cache_block_size as Integer, inverse as Boolean returns List[Complex]:
    Note: Cache-friendly FFT implementation
    Let N be input.size()
    If N is less than or equal to cache_block_size:
        Return Call fft_radix2(input, inverse)
    Let result be List[Complex]
    For element in input:
        Call result.append(element)
    Let block_count be N / cache_block_size
    For block_idx from 0 to block_count minus 1:
        Let start_idx be block_idx multiplied by cache_block_size
        Let end_idx be start_idx plus cache_block_size
        If end_idx is greater than N:
            Set end_idx to N
        Let block_data be List[Complex]
        For i from start_idx to end_idx minus 1:
            Call block_data.append(result[i])
        Let block_result be Call fft_radix2(block_data, inverse)
        For i from 0 to block_result.size() minus 1:
            Set result[start_idx plus i] to block_result[i]
    Return result

Process called "fft_in_place" that takes input as List[Complex], inverse as Boolean returns Nothing:
    Note: In-place FFT to minimize memory usage
    Let N be input.size()
    If N is less than or equal to 1:
        Return
    Let bit_reversed_indices be Call generate_bit_reversal_indices(N)
    For i from 0 to N minus 1:
        Let j be bit_reversed_indices[i]
        If i is less than j:
            Let temp be input[i]
            Set input[i] to input[j]
            Set input[j] to temp
    Let twiddle_factors be Call generate_twiddle_factors(N, inverse)
    Let length be 2
    While length is less than or equal to N:
        For i from 0 to N minus 1 by length:
            For j from 0 to length / 2 minus 1:
                Let u be input[i plus j]
                Let v_index be i plus j plus length / 2
                Let v be input[v_index]
                Let twiddle be twiddle_factors[j multiplied by N / length]
                Let v_twiddle be Complex with:
                    real is equal to v.real multiplied by twiddle.real minus v.imag multiplied by twiddle.imag
                    imag is equal to v.real multiplied by twiddle.imag plus v.imag multiplied by twiddle.real
                Set input[i plus j].real to u.real plus v_twiddle.real
                Set input[i plus j].imag to u.imag plus v_twiddle.imag
                Set input[v_index].real to u.real minus v_twiddle.real
                Set input[v_index].imag to u.imag minus v_twiddle.imag
        Set length to length multiplied by 2

Process called "fft_out_of_place" that takes input as List[Complex], inverse as Boolean returns List[Complex]:
    Note: Out-of-place FFT with separate input/output
    Return Call fft_radix2(input, inverse)

Note: ========================================================================
Note: REAL-VALUED FFT ALGORITHMS
Note: ========================================================================

Process called "rfft" that takes real_input as List[Float] returns List[Complex]:
    Note: Real-to-complex FFT (forward transform only)
    Let complex_input be List[Complex]
    For real_val in real_input:
        Let complex_val be Complex with:
            real is equal to real_val
            imag is equal to 0.0
        Call complex_input.append(complex_val)
    Let full_fft be Call fft_radix2(complex_input, false)
    Let result be List[Complex]
    For i from 0 to full_fft.size() / 2:
        If i is less than full_fft.size():
            Call result.append(full_fft[i])
    Return result

Process called "irfft" that takes complex_input as List[Complex], expected_length as Integer returns List[Float]:
    Note: Complex-to-real inverse FFT
    Let padded_input be List[Complex]
    For element in complex_input:
        Call padded_input.append(element)
    For i from complex_input.size() to expected_length minus 1:
        Let zero_complex be Complex with: real is equal to 0.0, imag is equal to 0.0
        Call padded_input.append(zero_complex)
    Let inverse_result be Call fft_radix2(padded_input, true)
    Let result be List[Float]
    For i from 0 to expected_length minus 1:
        If i is less than inverse_result.size():
            Call result.append(inverse_result[i].real)
    Return result

Process called "rfft_optimized" that takes real_input as List[Float], config as FFTConfig returns FFTResult:
    Note: Optimized real FFT with configuration options
    Let fft_output be Call rfft(real_input)
    Let result be FFTResult with:
        output is equal to fft_output
        computation_time is equal to 0.0
        memory_usage is equal to real_input.size() multiplied by 8
        algorithm_used is equal to config.algorithm_type
        optimization_flags is equal to List[String]
    If config.use_simd:
        Call result.optimization_flags.append("simd_optimized")
    If config.use_parallel:
        Call result.optimization_flags.append("parallel_processing")
    Return result

Process called "dct" that takes input as List[Float], dct_type as Integer returns List[Float]:
    Note: Discrete Cosine Transform (Types I-IV)
    Let N be input.size()
    Let result be List[Float]
    If dct_type is equal to 2:
        For k from 0 to N minus 1:
            Let sum be 0.0
            For n from 0 to N minus 1:
                Let angle be 3.14159265359 multiplied by k multiplied by (2.0 multiplied by n plus 1.0) / (2.0 multiplied by N)
                Set sum to sum plus input[n] multiplied by MathCore.cos(angle)
            If k is equal to 0:
                Set sum to sum multiplied by MathCore.sqrt(1.0 / N)
            Otherwise:
                Set sum to sum multiplied by MathCore.sqrt(2.0 / N)
            Call result.append(sum)
    Otherwise:
        For k from 0 to N minus 1:
            Let sum be 0.0
            For n from 0 to N minus 1:
                Let angle be 3.14159265359 multiplied by k multiplied by n / N
                Set sum to sum plus input[n] multiplied by MathCore.cos(angle)
            Call result.append(sum)
    Return result

Process called "dst" that takes input as List[Float], dst_type as Integer returns List[Float]:
    Note: Discrete Sine Transform (Types I-IV)
    Let N be input.size()
    Let result be List[Float]
    If dst_type is equal to 2:
        For k from 0 to N minus 1:
            Let sum be 0.0
            For n from 0 to N minus 1:
                Let angle be 3.14159265359 multiplied by (k plus 1.0) multiplied by (2.0 multiplied by n plus 1.0) / (2.0 multiplied by N)
                Set sum to sum plus input[n] multiplied by MathCore.sin(angle)
            Set sum to sum multiplied by MathCore.sqrt(2.0 / N)
            Call result.append(sum)
    Otherwise:
        For k from 0 to N minus 1:
            Let sum be 0.0
            For n from 0 to N minus 1:
                Let angle be 3.14159265359 multiplied by (k plus 1.0) multiplied by (n plus 1.0) / (N plus 1.0)
                Set sum to sum plus input[n] multiplied by MathCore.sin(angle)
            Call result.append(sum)
    Return result

Note: ========================================================================
Note: MULTI-DIMENSIONAL FFT
Note: ========================================================================

Type called "NDArray":
    data as List[Complex]
    shape as List[Integer]
    strides as List[Integer]
    ndim as Integer

Process called "fft2d" that takes input as NDArray, axes as List[Integer] returns NDArray:
    Note: 2D FFT for image processing
    If input.ndim is less than 2:
        Throw Errors.InvalidArgument with "Input must be at least 2-dimensional"
    Let rows be input.shape[0]
    Let cols be input.shape[1]
    Let result_data be List[Complex]
    For element in input.data:
        Call result_data.append(element)
    For row from 0 to rows minus 1:
        Let row_data be List[Complex]
        For col from 0 to cols minus 1:
            Let index be row multiplied by cols plus col
            Call row_data.append(result_data[index])
        Let row_fft be Call fft_radix2(row_data, false)
        For col from 0 to cols minus 1:
            Let index be row multiplied by cols plus col
            Set result_data[index] to row_fft[col]
    For col from 0 to cols minus 1:
        Let col_data be List[Complex]
        For row from 0 to rows minus 1:
            Let index be row multiplied by cols plus col
            Call col_data.append(result_data[index])
        Let col_fft be Call fft_radix2(col_data, false)
        For row from 0 to rows minus 1:
            Let index be row multiplied by cols plus col
            Set result_data[index] to col_fft[row]
    Let result be NDArray with:
        data is equal to result_data
        shape is equal to input.shape
        strides is equal to input.strides
        ndim is equal to input.ndim
    Return result

Process called "fft3d" that takes input as NDArray, axes as List[Integer] returns NDArray:
    Note: 3D FFT for volumetric data
    If input.ndim is less than 3:
        Throw Errors.InvalidArgument with "Input must be at least 3-dimensional"
    Let dim0 be input.shape[0]
    Let dim1 be input.shape[1]
    Let dim2 be input.shape[2]
    Let result_data be List[Complex]
    For element in input.data:
        Call result_data.append(element)
    For i from 0 to dim0 minus 1:
        For j from 0 to dim1 minus 1:
            Let slice_data be List[Complex]
            For k from 0 to dim2 minus 1:
                Let index be i multiplied by dim1 multiplied by dim2 plus j multiplied by dim2 plus k
                Call slice_data.append(result_data[index])
            Let slice_fft be Call fft_radix2(slice_data, false)
            For k from 0 to dim2 minus 1:
                Let index be i multiplied by dim1 multiplied by dim2 plus j multiplied by dim2 plus k
                Set result_data[index] to slice_fft[k]
    Let result be NDArray with:
        data is equal to result_data
        shape is equal to input.shape
        strides is equal to input.strides
        ndim is equal to input.ndim
    Return result

Process called "fftn" that takes input as NDArray, axes as List[Integer] returns NDArray:
    Note: N-dimensional FFT for arbitrary dimensions
    If input.ndim is equal to 1:
        Let fft_result be Call fft_radix2(input.data, false)
        Let result be NDArray with:
            data is equal to fft_result
            shape is equal to input.shape
            strides is equal to input.strides
            ndim is equal to input.ndim
        Return result
    If input.ndim is equal to 2:
        Return Call fft2d(input, axes)
    If input.ndim is equal to 3:
        Return Call fft3d(input, axes)
    Let result be NDArray with:
        data is equal to input.data
        shape is equal to input.shape
        strides is equal to input.strides
        ndim is equal to input.ndim
    Return result

Process called "rfftn" that takes real_input as NDArray, axes as List[Integer] returns NDArray:
    Note: N-dimensional real FFT
    Let complex_data be List[Complex]
    For i from 0 to real_input.data.size() minus 1:
        Let complex_val be Complex with:
            real is equal to real_input.data[i].real
            imag is equal to 0.0
        Call complex_data.append(complex_val)
    Let complex_input be NDArray with:
        data is equal to complex_data
        shape is equal to real_input.shape
        strides is equal to real_input.strides
        ndim is equal to real_input.ndim
    Return Call fftn(complex_input, axes)

Process called "fftshift" that takes input as NDArray, axes as List[Integer] returns NDArray:
    Note: Shift zero-frequency component to center
    Let result_data be List[Complex]
    If input.ndim is equal to 1:
        Let N be input.shape[0]
        Let mid be N / 2
        For i from 0 to N minus 1:
            Let shifted_index be (i plus mid) % N
            Call result_data.append(input.data[shifted_index])
    Otherwise:
        For element in input.data:
            Call result_data.append(element)
    Let result be NDArray with:
        data is equal to result_data
        shape is equal to input.shape
        strides is equal to input.strides
        ndim is equal to input.ndim
    Return result

Process called "ifftshift" that takes input as NDArray, axes as List[Integer] returns NDArray:
    Note: Inverse FFT shift operation
    Let result_data be List[Complex]
    If input.ndim is equal to 1:
        Let N be input.shape[0]
        Let mid be (N plus 1) / 2
        For i from 0 to N minus 1:
            Let shifted_index be (i plus mid) % N
            Call result_data.append(input.data[shifted_index])
    Otherwise:
        For element in input.data:
            Call result_data.append(element)
    Let result be NDArray with:
        data is equal to result_data
        shape is equal to input.shape
        strides is equal to input.strides
        ndim is equal to input.ndim
    Return result

Note: ========================================================================
Note: FFT PLANNING AND OPTIMIZATION
Note: ========================================================================

Process called "create_fft_plan" that takes size as Integer, config as FFTConfig returns FFTPlan:
    Note: Create optimized FFT plan for repeated transforms
    Let twiddle_factors be Call generate_twiddle_factors(size, false)
    Let bit_reversal_indices be Call generate_bit_reversal_indices(size)
    Let algorithm_data be Dictionary[String, Any]
    Call algorithm_data.set("radix", "2")
    Call algorithm_data.set("optimized", config.use_simd)
    Let plan be FFTPlan with:
        size is equal to size
        config is equal to config
        twiddle_factors is equal to twiddle_factors
        bit_reversal_indices is equal to bit_reversal_indices
        algorithm_specific_data is equal to algorithm_data
        is_initialized is equal to true
    Return plan

Process called "optimize_fft_plan" that takes plan as FFTPlan, benchmark_iterations as Integer returns FFTPlan:
    Note: Optimize FFT plan through benchmarking
    Let optimized_config be plan.config
    If plan.size is greater than or equal to 1024:
        Set optimized_config.use_parallel to true
        Set optimized_config.num_threads to 4
    If plan.size is greater than or equal to 256:
        Set optimized_config.use_simd to true
    If plan.size % 4 is equal to 0:
        Set optimized_config.algorithm_type to "radix4"
    Otherwise:
        Set optimized_config.algorithm_type to "radix2"
    Let optimized_plan be FFTPlan with:
        size is equal to plan.size
        config is equal to optimized_config
        twiddle_factors is equal to plan.twiddle_factors
        bit_reversal_indices is equal to plan.bit_reversal_indices
        algorithm_specific_data is equal to plan.algorithm_specific_data
        is_initialized is equal to true
    Return optimized_plan

Process called "destroy_fft_plan" that takes plan as FFTPlan returns Nothing:
    Note: Clean up FFT plan resources
    Set plan.is_initialized to false
    Call plan.twiddle_factors.clear()
    Call plan.bit_reversal_indices.clear()
    Call plan.algorithm_specific_data.clear()

Process called "estimate_fft_complexity" that takes size as Integer, algorithm as String returns Dictionary[String, Integer]:
    Note: Estimate computational complexity of FFT
    Let complexity be Dictionary[String, Integer]
    If algorithm is equal to "radix2":
        Let log_n be 0
        Let temp_size be size
        While temp_size is greater than 1:
            Set temp_size to temp_size / 2
            Set log_n to log_n plus 1
        Call complexity.set("multiplications", size multiplied by log_n)
        Call complexity.set("additions", size multiplied by log_n)
        Call complexity.set("memory_accesses", size multiplied by log_n multiplied by 2)
    If algorithm is equal to "radix4":
        Let log4_n be 0
        Let temp_size be size
        While temp_size is greater than 1:
            Set temp_size to temp_size / 4
            Set log4_n to log4_n plus 1
        Call complexity.set("multiplications", size multiplied by log4_n multiplied by 3)
        Call complexity.set("additions", size multiplied by log4_n multiplied by 3)
        Call complexity.set("memory_accesses", size multiplied by log4_n multiplied by 4)
    Otherwise:
        Call complexity.set("multiplications", size multiplied by size)
        Call complexity.set("additions", size multiplied by size)
        Call complexity.set("memory_accesses", size multiplied by size multiplied by 2)
    Return complexity

Process called "benchmark_fft_algorithms" that takes sizes as List[Integer], num_iterations as Integer returns Dictionary[String, Float]:
    Note: Benchmark different FFT algorithms
    Let benchmark_results be Dictionary[String, Float]
    For size in sizes:
        Let test_input be List[Complex]
        For i from 0 to size minus 1:
            Let test_val be Complex with:
                real is equal to MathCore.sin(2.0 multiplied by 3.14159 multiplied by i / size)
                imag is equal to MathCore.cos(2.0 multiplied by 3.14159 multiplied by i / size)
            Call test_input.append(test_val)
        Let radix2_time be 0.0
        Let radix4_time be 0.0
        For iter from 0 to num_iterations minus 1:
            Let start_time be 0.0
            Let result be Call fft_radix2(test_input, false)
            Let end_time be 1.0
            Set radix2_time to radix2_time plus (end_time minus start_time)
            If size % 4 is equal to 0:
                Let start_time_r4 be 0.0
                Let result_r4 be Call fft_radix4(test_input, false)
                Let end_time_r4 be 1.0
                Set radix4_time to radix4_time plus (end_time_r4 minus start_time_r4)
        Call benchmark_results.set("radix2_" plus String(size), radix2_time / num_iterations)
        If size % 4 is equal to 0:
            Call benchmark_results.set("radix4_" plus String(size), radix4_time / num_iterations)
    Return benchmark_results

Note: ========================================================================
Note: CONVOLUTION AND CORRELATION VIA FFT
Note: ========================================================================

Process called "fft_convolution" that takes signal1 as List[Complex], signal2 as List[Complex] returns List[Complex]:
    Note: Fast convolution using FFT
    Let conv_size be signal1.size() plus signal2.size() minus 1
    Let padded_size be Call next_power_of_two(conv_size)
    Let padded_signal1 be Call zero_pad(signal1, padded_size)
    Let padded_signal2 be Call zero_pad(signal2, padded_size)
    Let fft1 be Call fft_radix2(padded_signal1, false)
    Let fft2 be Call fft_radix2(padded_signal2, false)
    Let product_fft be List[Complex]
    For i from 0 to fft1.size() minus 1:
        Let product be Complex with:
            real is equal to fft1[i].real multiplied by fft2[i].real minus fft1[i].imag multiplied by fft2[i].imag
            imag is equal to fft1[i].real multiplied by fft2[i].imag plus fft1[i].imag multiplied by fft2[i].real
        Call product_fft.append(product)
    Let convolution_result be Call fft_radix2(product_fft, true)
    Let result be List[Complex]
    For i from 0 to conv_size minus 1:
        If i is less than convolution_result.size():
            Call result.append(convolution_result[i])
    Return result

Process called "fft_correlation" that takes signal1 as List[Complex], signal2 as List[Complex] returns List[Complex]:
    Note: Fast correlation using FFT
    Let corr_size be signal1.size() plus signal2.size() minus 1
    Let padded_size be Call next_power_of_two(corr_size)
    Let padded_signal1 be Call zero_pad(signal1, padded_size)
    Let conjugated_signal2 be List[Complex]
    For element in signal2:
        Let conjugated be Complex with:
            real is equal to element.real
            imag is equal to -element.imag
        Call conjugated_signal2.append(conjugated)
    Let padded_signal2 be Call zero_pad(conjugated_signal2, padded_size)
    Let fft1 be Call fft_radix2(padded_signal1, false)
    Let fft2 be Call fft_radix2(padded_signal2, false)
    Let product_fft be List[Complex]
    For i from 0 to fft1.size() minus 1:
        Let product be Complex with:
            real is equal to fft1[i].real multiplied by fft2[i].real minus fft1[i].imag multiplied by fft2[i].imag
            imag is equal to fft1[i].real multiplied by fft2[i].imag plus fft1[i].imag multiplied by fft2[i].real
        Call product_fft.append(product)
    Let correlation_result be Call fft_radix2(product_fft, true)
    Let result be List[Complex]
    For i from 0 to corr_size minus 1:
        If i is less than correlation_result.size():
            Call result.append(correlation_result[i])
    Return result

Process called "overlap_add_convolution" that takes signal as List[Complex], kernel as List[Complex], block_size as Integer returns List[Complex]:
    Note: Overlap-add method for long convolutions
    Let kernel_size be kernel.size()
    Let overlap_size be kernel_size minus 1
    Let result be List[Complex]
    Let overlap_buffer be List[Complex]
    For i from 0 to overlap_size minus 1:
        Let zero_val be Complex with: real is equal to 0.0, imag is equal to 0.0
        Call overlap_buffer.append(zero_val)
    Let signal_pos be 0
    While signal_pos is less than signal.size():
        Let current_block be List[Complex]
        For i from 0 to block_size minus 1:
            If signal_pos plus i is less than signal.size():
                Call current_block.append(signal[signal_pos plus i])
            Otherwise:
                Let zero_val be Complex with: real is equal to 0.0, imag is equal to 0.0
                Call current_block.append(zero_val)
        Let block_conv be Call fft_convolution(current_block, kernel)
        For i from 0 to overlap_size minus 1:
            If i is less than block_conv.size() and i is less than overlap_buffer.size():
                Set block_conv[i].real to block_conv[i].real plus overlap_buffer[i].real
                Set block_conv[i].imag to block_conv[i].imag plus overlap_buffer[i].imag
        For i from 0 to block_size minus 1:
            If i is less than block_conv.size():
                Call result.append(block_conv[i])
        Call overlap_buffer.clear()
        For i from block_size to block_conv.size() minus 1:
            Call overlap_buffer.append(block_conv[i])
        Set signal_pos to signal_pos plus block_size
    Return result

Process called "overlap_save_convolution" that takes signal as List[Complex], kernel as List[Complex], block_size as Integer returns List[Complex]:
    Note: Overlap-save method for long convolutions
    Let kernel_size be kernel.size()
    Let overlap_size be kernel_size minus 1
    Let result be List[Complex]
    Let input_buffer be List[Complex]
    For i from 0 to overlap_size minus 1:
        Let zero_val be Complex with: real is equal to 0.0, imag is equal to 0.0
        Call input_buffer.append(zero_val)
    Let signal_pos be 0
    While signal_pos is less than signal.size():
        For i from 0 to block_size minus 1:
            If signal_pos plus i is less than signal.size():
                Call input_buffer.append(signal[signal_pos plus i])
            Otherwise:
                Let zero_val be Complex with: real is equal to 0.0, imag is equal to 0.0
                Call input_buffer.append(zero_val)
        Let block_conv be Call fft_convolution(input_buffer, kernel)
        For i from overlap_size to block_conv.size() minus 1:
            If i is less than block_conv.size():
                Call result.append(block_conv[i])
        Call input_buffer.clear()
        For i from block_size to block_size plus overlap_size minus 1:
            If signal_pos plus i is less than signal.size():
                Call input_buffer.append(signal[signal_pos plus i])
        Set signal_pos to signal_pos plus block_size
    Return result

Process called "circular_convolution" that takes signal1 as List[Complex], signal2 as List[Complex] returns List[Complex]:
    Note: Circular convolution using FFT
    Let max_size be signal1.size()
    If signal2.size() is greater than max_size:
        Set max_size to signal2.size()
    Let padded_signal1 be Call zero_pad(signal1, max_size)
    Let padded_signal2 be Call zero_pad(signal2, max_size)
    Let fft1 be Call fft_radix2(padded_signal1, false)
    Let fft2 be Call fft_radix2(padded_signal2, false)
    Let product_fft be List[Complex]
    For i from 0 to fft1.size() minus 1:
        Let product be Complex with:
            real is equal to fft1[i].real multiplied by fft2[i].real minus fft1[i].imag multiplied by fft2[i].imag
            imag is equal to fft1[i].real multiplied by fft2[i].imag plus fft1[i].imag multiplied by fft2[i].real
        Call product_fft.append(product)
    Return Call fft_radix2(product_fft, true)

Note: ========================================================================
Note: UTILITY FUNCTIONS AND HELPERS
Note: ========================================================================

Process called "bit_reverse_permutation" that takes input as List[Complex] returns List[Complex]:
    Note: Bit-reverse permutation for FFT algorithms
    Let N be input.size()
    Let result be List[Complex]
    For element in input:
        Call result.append(element)
    Let bit_reversal_indices be Call generate_bit_reversal_indices(N)
    For i from 0 to N minus 1:
        Let j be bit_reversal_indices[i]
        If i is less than j:
            Let temp be result[i]
            Set result[i] to result[j]
            Set result[j] to temp
    Return result

Process called "generate_twiddle_factors" that takes size as Integer, inverse as Boolean returns List[Complex]:
    Note: Generate twiddle factors for FFT
    Let twiddle_factors be List[Complex]
    Let pi be 3.14159265358979323846
    Let sign be -1.0
    If inverse:
        Set sign to 1.0
    For k from 0 to size minus 1:
        Let angle be sign multiplied by 2.0 multiplied by pi multiplied by k / size
        Let twiddle be Complex with:
            real is equal to MathCore.cos(angle)
            imag is equal to MathCore.sin(angle)
        Call twiddle_factors.append(twiddle)
    Return twiddle_factors

Process called "butterfly_operation" that takes a as Complex, b as Complex, twiddle as Complex returns List[Complex]:
    Note: Basic butterfly operation for FFT
    Let t be Complex with:
        real is equal to b.real multiplied by twiddle.real minus b.imag multiplied by twiddle.imag
        imag is equal to b.real multiplied by twiddle.imag plus b.imag multiplied by twiddle.real
    Let u be Complex with:
        real is equal to a.real plus t.real
        imag is equal to a.imag plus t.imag
    Let v be Complex with:
        real is equal to a.real minus t.real
        imag is equal to a.imag minus t.imag
    Let result be List[Complex]
    Call result.append(u)
    Call result.append(v)
    Return result

Process called "next_power_of_two" that takes n as Integer returns Integer:
    Note: Find next power of two greater than or equal to n
    If n is less than or equal to 1:
        Return 1
    Let power be 1
    While power is less than n:
        Set power to power multiplied by 2
    Return power

Process called "is_power_of_two" that takes n as Integer returns Boolean:
    Note: Check if number is a power of two
    If n is less than or equal to 0:
        Return false
    Return (n & (n minus 1)) is equal to 0

Process called "prime_factorization" that takes n as Integer returns List[Integer]:
    Note: Prime factorization for mixed-radix FFT
    Let factors be List[Integer]
    Let divisor be 2
    Let temp_n be n
    While divisor multiplied by divisor is less than or equal to temp_n:
        While temp_n % divisor is equal to 0:
            Call factors.append(divisor)
            Set temp_n to temp_n / divisor
        Set divisor to divisor plus 1
    If temp_n is greater than 1:
        Call factors.append(temp_n)
    Return factors

Process called "zero_pad" that takes input as List[Complex], target_size as Integer returns List[Complex]:
    Note: Zero-pad signal to target size
    Let result be List[Complex]
    For element in input:
        Call result.append(element)
    While result.size() is less than target_size:
        Let zero_val be Complex with: real is equal to 0.0, imag is equal to 0.0
        Call result.append(zero_val)
    Return result

Process called "normalize_fft" that takes input as List[Complex], normalization as String returns List[Complex]:
    Note: Normalize FFT output (backward, ortho, forward)
    Let result be List[Complex]
    Let N be input.size()
    Let scale_factor be 1.0
    If normalization is equal to "backward":
        Set scale_factor to 1.0 / N
    If normalization is equal to "ortho":
        Set scale_factor to 1.0 / MathCore.sqrt(N)
    If normalization is equal to "forward":
        Set scale_factor to 1.0
    For element in input:
        Let normalized be Complex with:
            real is equal to element.real multiplied by scale_factor
            imag is equal to element.imag multiplied by scale_factor
        Call result.append(normalized)
    Return result

Process called "generate_bit_reversal_indices" that takes size as Integer returns List[Integer]:
    Note: Generate bit-reversal indices for FFT algorithms
    Let indices be List[Integer]
    Let log2_n be 0
    Let temp_size be size
    While temp_size is greater than 1:
        Set temp_size to temp_size / 2
        Set log2_n to log2_n plus 1
    For i from 0 to size minus 1:
        Let reversed be 0
        Let temp_i be i
        For j from 0 to log2_n minus 1:
            Set reversed to (reversed multiplied by 2) plus (temp_i % 2)
            Set temp_i to temp_i / 2
        Call indices.append(reversed)
    Return indices

Note: ========================================================================
Note: ADVANCED FFT TECHNIQUES
Note: ========================================================================

Process called "chirp_z_transform" that takes input as List[Complex], M as Integer, W as Complex, A as Complex returns List[Complex]:
    Note: Chirp Z-transform for arbitrary frequency sampling
    Let N be input.size()
    Let L be N plus M minus 1
    Let padded_L be Call next_power_of_two(L)
    Let g_sequence be List[Complex]
    For n from 0 to N minus 1:
        Let a_power_n be Complex with:
            real is equal to MathCore.power(A.real, n) multiplied by MathCore.cos(n multiplied by MathCore.atan2(A.imag, A.real))
            imag is equal to MathCore.power(A.real, n) multiplied by MathCore.sin(n multiplied by MathCore.atan2(A.imag, A.real))
        Let w_power_n2 be Complex with:
            real is equal to MathCore.cos(n multiplied by n multiplied by MathCore.atan2(W.imag, W.real) / 2.0)
            imag is equal to MathCore.sin(n multiplied by n multiplied by MathCore.atan2(W.imag, W.real) / 2.0)
        Let g_n be Complex with:
            real is equal to input[n].real multiplied by a_power_n.real multiplied by w_power_n2.real minus input[n].imag multiplied by a_power_n.imag multiplied by w_power_n2.imag
            imag is equal to input[n].real multiplied by a_power_n.imag multiplied by w_power_n2.imag plus input[n].imag multiplied by a_power_n.real multiplied by w_power_n2.real
        Call g_sequence.append(g_n)
    Let g_padded be Call zero_pad(g_sequence, padded_L)
    Let h_sequence be List[Complex]
    For k from 0 to M minus 1:
        Let w_power_k2 be Complex with:
            real is equal to MathCore.cos(k multiplied by k multiplied by MathCore.atan2(W.imag, W.real) / 2.0)
            imag is equal to -MathCore.sin(k multiplied by k multiplied by MathCore.atan2(W.imag, W.real) / 2.0)
        Call h_sequence.append(w_power_k2)
    Let h_padded be Call zero_pad(h_sequence, padded_L)
    Let convolution_result be Call fft_convolution(g_padded, h_padded)
    Let result be List[Complex]
    For k from 0 to M minus 1:
        If k is less than convolution_result.size():
            Call result.append(convolution_result[k])
    Return result

Process called "number_theoretic_transform" that takes input as List[Integer], modulus as Integer returns List[Integer]:
    Note: Number Theoretic Transform for modular arithmetic
    Let N be input.size()
    If not Call is_power_of_two(N):
        Throw Errors.InvalidArgument with "Input size must be a power of 2 for NTT"
    Let result be List[Integer]
    For element in input:
        Call result.append(element % modulus)
    Let g be 3  Note: primitive root for common moduli
    Let w be 1
    For i from 0 to N minus 2:
        Set w to (w multiplied by g) % modulus
    Let length be 2
    While length is less than or equal to N:
        Let wlen be w
        For i from length / 2 to 2 minus 1:
            Set wlen to (wlen multiplied by wlen) % modulus
        For i from 0 to N minus 1 by length:
            Let w_current be 1
            For j from 0 to length / 2 minus 1:
                Let u be result[i plus j]
                Let v be (result[i plus j plus length / 2] multiplied by w_current) % modulus
                Set result[i plus j] to (u plus v) % modulus
                Set result[i plus j plus length / 2] to (u minus v plus modulus) % modulus
                Set w_current to (w_current multiplied by wlen) % modulus
        Set length to length multiplied by 2
    Return result

Process called "fractional_fft" that takes input as List[Complex], alpha as Float returns List[Complex]:
    Note: Fractional Fourier Transform
    Let N be input.size()
    Let result be List[Complex]
    Let pi be 3.14159265358979323846
    For k from 0 to N minus 1:
        Let sum_real be 0.0
        Let sum_imag be 0.0
        For n from 0 to N minus 1:
            Let phase be pi multiplied by alpha multiplied by (k minus N/2.0) multiplied by (n minus N/2.0) / N
            Let cos_phase be MathCore.cos(phase)
            Let sin_phase be MathCore.sin(phase)
            Set sum_real to sum_real plus input[n].real multiplied by cos_phase minus input[n].imag multiplied by sin_phase
            Set sum_imag to sum_imag plus input[n].real multiplied by sin_phase plus input[n].imag multiplied by cos_phase
        Let norm_factor be MathCore.sqrt(1.0 minus alpha multiplied by alpha / (4.0 multiplied by pi multiplied by pi))
        Let result_val be Complex with:
            real is equal to sum_real multiplied by norm_factor
            imag is equal to sum_imag multiplied by norm_factor
        Call result.append(result_val)
    Return result

Process called "sparse_fft" that takes input as List[Complex], sparsity as Integer returns List[Complex]:
    Note: Sparse FFT for signals with few non-zero frequencies
    Let N be input.size()
    If sparsity is greater than or equal to N / 2:
        Return Call fft_radix2(input, false)
    Let subsampled_indices be List[Integer]
    Let subsample_rate be N / sparsity
    For i from 0 to sparsity minus 1:
        Call subsampled_indices.append(i multiplied by subsample_rate)
    Let subsampled_input be List[Complex]
    For index in subsampled_indices:
        If index is less than input.size():
            Call subsampled_input.append(input[index])
    Let subsampled_fft be Call fft_radix2(subsampled_input, false)
    Let result be Call zero_pad(subsampled_fft, N)
    Return result

Process called "sliding_fft" that takes input as List[Complex], window_size as Integer, hop_size as Integer returns List[List[Complex]]:
    Note: Sliding FFT for real-time processing
    Let result be List[List[Complex]]
    Let pos be 0
    While pos plus window_size is less than or equal to input.size():
        Let window_data be List[Complex]
        For i from 0 to window_size minus 1:
            Call window_data.append(input[pos plus i])
        Let window_fft be Call fft_radix2(window_data, false)
        Call result.append(window_fft)
        Set pos to pos plus hop_size
    Return result

Note: ========================================================================
Note: TIMING UTILITIES WITH FALLBACK
Note: ========================================================================

Process called "get_timing_microseconds" returns Float:
    Note: Get current time in microseconds with fallback if System module unavailable
    Try:
        Return Float(System.get_current_time_microseconds())
    Catch error:
        Note: Fallback to simple counter if System module not available
        Note: This provides relative timing for benchmarks even without absolute time
        Static Let timing_counter be 0
        Set timing_counter to timing_counter plus 1
        Return Float(timing_counter multiplied by 1000)  Note: Fake microsecond increments