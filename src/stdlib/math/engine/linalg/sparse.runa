Note:
math/engine/linalg/sparse.runa
Sparse Matrix Operations and Specialized Algorithms

This module provides comprehensive sparse matrix operations including:
- Sparse matrix storage formats (CSR, CSC, COO, Block Sparse)
- Memory-efficient sparse matrix operations
- Specialized algorithms for sparse linear systems
- Sparse matrix factorizations and decompositions
- Graph-based sparse matrix analysis
- Parallel sparse matrix computations
- Sparse matrix pattern analysis and optimization
- Block sparse matrix operations
- Sparse eigenvalue and singular value computations
- Iterative methods optimized for sparse matrices
- Fill-reducing ordering algorithms
- Sparse direct solvers with symbolic preprocessing
- Memory bandwidth optimization for sparse operations
- Sparse matrix-vector and matrix-matrix products
- Sparse matrix visualization and analysis tools
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/core/operations" as MathOps

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "sort_triplets_by_row" that takes values as List[String], row_indices as List[Integer], col_indices as List[Integer] returns Dictionary[String, List[String]]:
    Note: Sort triplet arrays by row index, then by column index
    Note: Uses efficient quicksort algorithm with O(n log n) average complexity
    Note: Computational complexity: O(n log n) average case, O(nÂ²) worst case
    
    Let n be values.length
    Let sorted_values be List[String]()
    Let sorted_row_indices be List[Integer]()
    Let sorted_col_indices be List[Integer]()
    
    Note: Copy arrays
    Let k be 0
    While k is less than n:
        Call sorted_values.add(values.get(k))
        Call sorted_row_indices.add(row_indices.get(k))
        Call sorted_col_indices.add(col_indices.get(k))
        Set k to k plus 1
    
    Note: Use merge sort for stable O(n log n) sorting by (row, column) pairs
    Call triplet_merge_sort(sorted_values, sorted_row_indices, sorted_col_indices, 0, n minus 1)
    
    Let result be Dictionary[String, List[String]]()
    Call result.set("values", sorted_values)
    Call result.set("row_indices", sorted_row_indices)
    Call result.set("col_indices", sorted_col_indices)
    Return result

Process called "triplet_merge_sort" that takes values as List[String], row_indices as List[Integer], col_indices as List[Integer], left as Integer, right as Integer returns Nothing:
    Note: Merge sort implementation for triplet arrays
    If left is less than right:
        Let mid be (left plus right) / 2
        Call triplet_merge_sort(values, row_indices, col_indices, left, mid)
        Call triplet_merge_sort(values, row_indices, col_indices, mid plus 1, right)
        Call triplet_merge(values, row_indices, col_indices, left, mid, right)

Process called "triplet_merge" that takes values as List[String], row_indices as List[Integer], col_indices as List[Integer], left as Integer, mid as Integer, right as Integer returns Nothing:
    Note: Merge helper for triplet arrays minus merges sorted subarrays
    Let n1 be mid minus left plus 1
    Let n2 be right minus mid
    
    Note: Create temporary arrays for left subarray
    Let left_values be List[String]()
    Let left_rows be List[Integer]()  
    Let left_cols be List[Integer]()
    
    Note: Create temporary arrays for right subarray
    Let right_values be List[String]()
    Let right_rows be List[Integer]()
    Let right_cols be List[Integer]()
    
    Note: Copy data to temporary arrays
    Let i be 0
    While i is less than n1:
        Call left_values.add(values.get(left plus i))
        Call left_rows.add(row_indices.get(left plus i))
        Call left_cols.add(col_indices.get(left plus i))
        Set i to i plus 1
    
    Let j be 0
    While j is less than n2:
        Call right_values.add(values.get(mid plus 1 plus j))
        Call right_rows.add(row_indices.get(mid plus 1 plus j))
        Call right_cols.add(col_indices.get(mid plus 1 plus j))
        Set j to j plus 1
    
    Note: Merge the temporary arrays back
    Set i to 0
    Set j to 0
    Let k be left
    
    While i is less than n1 and j is less than n2:
        Let left_row be left_rows.get(i)
        Let right_row be right_rows.get(j)
        Let left_col be left_cols.get(i)
        Let right_col be right_cols.get(j)
        
        Let should_take_left be false
        If left_row is less than right_row:
            Set should_take_left to true
        Otherwise if left_row is equal to right_row and left_col is less than or equal to right_col:
            Set should_take_left to true
        
        If should_take_left:
            Set values[k] to left_values.get(i)
            Set row_indices[k] to left_rows.get(i)  
            Set col_indices[k] to left_cols.get(i)
            Set i to i plus 1
        Otherwise:
            Set values[k] to right_values.get(j)
            Set row_indices[k] to right_rows.get(j)
            Set col_indices[k] to right_cols.get(j)
            Set j to j plus 1
        Set k to k plus 1
    
    Note: Copy remaining elements of left array
    While i is less than n1:
        Set values[k] to left_values.get(i)
        Set row_indices[k] to left_rows.get(i)
        Set col_indices[k] to left_cols.get(i)
        Set i to i plus 1
        Set k to k plus 1
    
    Note: Copy remaining elements of right array  
    While j is less than n2:
        Set values[k] to right_values.get(j)
        Set row_indices[k] to right_rows.get(j)
        Set col_indices[k] to right_cols.get(j)
        Set j to j plus 1
        Set k to k plus 1

Note: =====================================================================
Note: SPARSE MATRIX DATA STRUCTURES
Note: =====================================================================

Type called "SparseMatrix":
    format as String
    rows as Integer
    columns as Integer
    non_zeros as Integer
    sparsity_ratio as Float
    data as List[String]
    indices as List[Integer]
    pointers as List[Integer]
    diagonal_storage as List[String]
    block_structure as Dictionary[String, List[Integer]]

Type called "CSRMatrix":
    values as List[String]
    column_indices as List[Integer]
    row_pointers as List[Integer]
    rows as Integer
    columns as Integer
    non_zeros as Integer
    is_symmetric as Boolean
    is_sorted as Boolean

Type called "CSCMatrix":
    values as List[String]
    row_indices as List[Integer]
    column_pointers as List[Integer]
    rows as Integer
    columns as Integer
    non_zeros as Integer
    is_symmetric as Boolean
    is_sorted as Boolean

Type called "COOMatrix":
    values as List[String]
    row_indices as List[Integer]
    column_indices as List[Integer]
    rows as Integer
    columns as Integer
    non_zeros as Integer
    is_sorted as Boolean
    has_duplicates as Boolean

Type called "BlockSparseMatrix":
    blocks as Dictionary[String, SparseMatrix]
    block_rows as Integer
    block_columns as Integer
    block_row_sizes as List[Integer]
    block_column_sizes as List[Integer]
    sparsity_pattern as List[List[Boolean]]

Type called "SparsePattern":
    pattern_type as String
    bandwidth as Integer
    profile as Integer
    fill_reducing_order as List[Integer]
    structural_rank as Integer
    connected_components as List[List[Integer]]
    elimination_tree as Dictionary[String, List[Integer]]

Type called "SparseSolver":
    solver_type as String
    factorization as String
    ordering_method as String
    pivot_tolerance as Float
    memory_usage as Integer
    factorization_time as Float
    solve_time as Float
    symbolic_analysis as Dictionary[String, String]

Note: =====================================================================
Note: SPARSE MATRIX CREATION AND CONVERSION OPERATIONS
Note: =====================================================================

Process called "create_sparse_matrix" that takes format as String, rows as Integer, columns as Integer, entries as List[Dictionary[String, String]] returns SparseMatrix:
    Note: Create sparse matrix from triplet format entries
    Note: Supports CSR, CSC, and COO formats with automatic format selection
    Note: Computational complexity: O(nnz multiplied by log(nnz)) for sorting
    
    If rows is less than or equal to 0 or columns is less than or equal to 0:
        Throw Errors.InvalidArgument with "Matrix dimensions must be positive"
    
    If entries.length is equal to 0:
        Note: Create empty sparse matrix
        Let empty_data be List[String]()
        Let empty_indices be List[Integer]()
        Let empty_pointers be List[Integer]()
        Return SparseMatrix with format: format, rows: rows, columns: columns, non_zeros: 0, sparsity_ratio: 1.0, data: empty_data, indices: empty_indices, pointers: empty_pointers, diagonal_storage: List[String](), block_structure: Dictionary[String, List[Integer]]()
    
    Let non_zeros be entries.length
    Let sparsity_ratio be 1.0 minus (non_zeros.to_float() / (rows multiplied by columns).to_float())
    
    Note: Extract values, row indices, and column indices from entries
    Let values be List[String]()
    Let row_indices be List[Integer]()
    Let col_indices be List[Integer]()
    
    Let k be 0
    While k is less than entries.length:
        Let entry be entries.get(k)
        Call values.add(entry.get("value"))
        Call row_indices.add(entry.get("row").to_integer())
        Call col_indices.add(entry.get("column").to_integer())
        Set k to k plus 1
    
    Note: Validate indices are within bounds
    Set k to 0
    While k is less than entries.length:
        If row_indices.get(k) is less than 0 or row_indices.get(k) is greater than or equal to rows:
            Throw Errors.InvalidArgument with "Row index out of bounds"
        If col_indices.get(k) is less than 0 or col_indices.get(k) is greater than or equal to columns:
            Throw Errors.InvalidArgument with "Column index out of bounds"
        Set k to k plus 1
    
    If format is equal to "CSR" or format is equal to "csr":
        Note: Create CSR format sparse matrix
        Note: Sort entries by row, then by column
        Let sorted_entries be sort_triplets_by_row(values, row_indices, col_indices)
        
        Let csr_values be sorted_entries.get("values")
        Let csr_row_indices be sorted_entries.get("row_indices")
        Let csr_col_indices be sorted_entries.get("col_indices")
        
        Note: Build row pointers array
        Let row_pointers be List[Integer]()
        Set k to 0
        While k is less than or equal to rows:
            Call row_pointers.add(0)
            Set k to k plus 1
        
        Set k to 0
        While k is less than non_zeros:
            Let row be csr_row_indices.get(k)
            Set row_pointers[row plus 1] to row_pointers.get(row plus 1) plus 1
            Set k to k plus 1
        
        Note: Convert counts to pointers (cumulative sum)
        Set k to 1
        While k is less than or equal to rows:
            Set row_pointers[k] to row_pointers.get(k) plus row_pointers.get(k minus 1)
            Set k to k plus 1
        
        Return SparseMatrix with format: "CSR", rows: rows, columns: columns, non_zeros: non_zeros, sparsity_ratio: sparsity_ratio, data: csr_values, indices: csr_col_indices, pointers: row_pointers, diagonal_storage: List[String](), block_structure: Dictionary[String, List[Integer]]()
    
    Otherwise if format is equal to "COO" or format is equal to "coo":
        Note: Create COO format sparse matrix (coordinate format)
        Return SparseMatrix with format: "COO", rows: rows, columns: columns, non_zeros: non_zeros, sparsity_ratio: sparsity_ratio, data: values, indices: col_indices, pointers: row_indices, diagonal_storage: List[String](), block_structure: Dictionary[String, List[Integer]]()
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unsupported sparse matrix format. Supported: CSR, COO"

Process called "convert_sparse_format" that takes matrix as SparseMatrix, target_format as String returns SparseMatrix:
    Note: Convert between sparse matrix storage formats
    Note: Supports conversion between CSR, CSC, and COO formats
    Note: Computational complexity: O(nnz) for most conversions
    
    If matrix.format is equal to target_format:
        Note: No conversion needed, return copy
        Return matrix
    
    If matrix.format is equal to "COO" and (target_format is equal to "CSR" or target_format is equal to "csr"):
        Note: Convert COO to CSR
        Let values be matrix.data
        Let row_indices be matrix.pointers
        Let col_indices be matrix.indices
        
        Note: Sort by row indices
        Let sorted_triplets be sort_triplets_by_row(values, row_indices, col_indices)
        
        Note: Build CSR row pointers
        Let row_pointers be List[Integer]()
        Let k be 0
        While k is less than or equal to matrix.rows:
            Call row_pointers.add(0)
            Set k to k plus 1
        
        Set k to 0
        While k is less than matrix.non_zeros:
            Let row be sorted_triplets.get("row_indices").get(k)
            Set row_pointers[row plus 1] to row_pointers.get(row plus 1) plus 1
            Set k to k plus 1
        
        Note: Convert to cumulative sum
        Set k to 1
        While k is less than or equal to matrix.rows:
            Set row_pointers[k] to row_pointers.get(k) plus row_pointers.get(k minus 1)
            Set k to k plus 1
        
        Return SparseMatrix with format: "CSR", rows: matrix.rows, columns: matrix.columns, non_zeros: matrix.non_zeros, sparsity_ratio: matrix.sparsity_ratio, data: sorted_triplets.get("values"), indices: sorted_triplets.get("col_indices"), pointers: row_pointers, diagonal_storage: matrix.diagonal_storage, block_structure: matrix.block_structure
    
    Otherwise if matrix.format is equal to "CSR" and (target_format is equal to "COO" or target_format is equal to "coo"):
        Note: Convert CSR to COO
        Let values be matrix.data
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Let row_indices be List[Integer]()
        Let i be 0
        While i is less than matrix.rows:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Let j be row_start
            While j is less than row_end:
                Call row_indices.add(i)
                Set j to j plus 1
            Set i to i plus 1
        
        Return SparseMatrix with format: "COO", rows: matrix.rows, columns: matrix.columns, non_zeros: matrix.non_zeros, sparsity_ratio: matrix.sparsity_ratio, data: values, indices: col_indices, pointers: row_indices, diagonal_storage: matrix.diagonal_storage, block_structure: matrix.block_structure
    
    Otherwise:
        Throw Errors.InvalidArgument with "Conversion from " plus matrix.format plus " to " plus target_format plus " not yet supported"

Process called "dense_to_sparse" that takes dense_matrix as Dictionary[String, String], threshold as Float returns SparseMatrix:
    Note: Convert dense matrix to sparse format with sparsity threshold
    Note: Elements with absolute value below threshold are treated as zero
    Note: Computational complexity: O(rows multiplied by columns)
    
    Let rows be dense_matrix.get("rows").to_integer()
    Let columns be dense_matrix.get("columns").to_integer()
    
    If rows is less than or equal to 0 or columns is less than or equal to 0:
        Throw Errors.InvalidArgument with "Matrix dimensions must be positive"
    
    Let entries be List[Dictionary[String, String]]()
    
    Note: Scan dense matrix for non-zero elements
    Let i be 0
    While i is less than rows:
        Let j be 0
        While j is less than columns:
            Let element_key be "element_" plus i.to_string() plus "_" plus j.to_string()
            If dense_matrix.contains(element_key):
                Let element_value be dense_matrix.get(element_key)
                Let abs_result be MathOps.absolute_value(element_value)
                If not abs_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute absolute value"
                
                If abs_result.result_value.to_float() is greater than threshold:
                    Let entry be Dictionary[String, String]()
                    Call entry.set("row", i.to_string())
                    Call entry.set("column", j.to_string())
                    Call entry.set("value", element_value)
                    Call entries.add(entry)
            Set j to j plus 1
        Set i to i plus 1
    
    Let sparse_matrix be create_sparse_matrix("CSR", rows, columns, entries)
    Return sparse_matrix

Process called "sparse_to_dense" that takes sparse_matrix as SparseMatrix returns Dictionary[String, String]:
    Note: Convert sparse matrix to dense format
    Note: Creates full dense representation of sparse matrix
    Note: Computational complexity: O(rows multiplied by columns plus nnz)
    
    Let dense_matrix be Dictionary[String, String]()
    Call dense_matrix.set("rows", sparse_matrix.rows.to_string())
    Call dense_matrix.set("columns", sparse_matrix.columns.to_string())
    
    Note: Initialize all elements to zero
    Let i be 0
    While i is less than sparse_matrix.rows:
        Let j be 0
        While j is less than sparse_matrix.columns:
            Let element_key be "element_" plus i.to_string() plus "_" plus j.to_string()
            Call dense_matrix.set(element_key, "0")
            Set j to j plus 1
        Set i to i plus 1
    
    If sparse_matrix.format is equal to "CSR":
        Note: Process CSR format
        Let values be sparse_matrix.data
        Let col_indices be sparse_matrix.indices
        Let row_pointers be sparse_matrix.pointers
        
        Set i to 0
        While i is less than sparse_matrix.rows:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Let k be row_start
            While k is less than row_end:
                Let j be col_indices.get(k)
                Let value be values.get(k)
                Let element_key be "element_" plus i.to_string() plus "_" plus j.to_string()
                Call dense_matrix.set(element_key, value)
                Set k to k plus 1
            Set i to i plus 1
    
    Otherwise if sparse_matrix.format is equal to "COO":
        Note: Process COO format
        Let values be sparse_matrix.data
        Let row_indices be sparse_matrix.pointers
        Let col_indices be sparse_matrix.indices
        
        Let k be 0
        While k is less than sparse_matrix.non_zeros:
            Let i be row_indices.get(k)
            Let j be col_indices.get(k)
            Let value be values.get(k)
            Let element_key be "element_" plus i.to_string() plus "_" plus j.to_string()
            Call dense_matrix.set(element_key, value)
            Set k to k plus 1
    
    Return dense_matrix

Note: =====================================================================
Note: SPARSE MATRIX BASIC OPERATIONS
Note: =====================================================================

Process called "sparse_matrix_multiply" that takes matrix_a as SparseMatrix, matrix_b as SparseMatrix, algorithm as String returns SparseMatrix:
    Note: Multiply two sparse matrices using specified algorithm
    Note: Implements basic sparse matrix multiplication (A multiplied by B)
    Note: Computational complexity: O(nnz_A multiplied by avg_nnz_per_col_B)
    
    If matrix_a.columns does not equal matrix_b.rows:
        Throw Errors.InvalidArgument with "Matrix A columns must equal Matrix B rows"
    
    Note: Convert both matrices to CSR format for efficient row-wise access
    Let csr_a be convert_sparse_format(matrix_a, "CSR")
    Let csr_b be convert_sparse_format(matrix_b, "CSR")
    
    Note: Transpose B to get CSC-like access pattern (CSR of B^T)
    Let csr_bt be sparse_matrix_transpose(csr_b)
    
    Let result_entries be List[Dictionary[String, String]]()
    
    Note: Multiply using outer product approach
    Let i be 0
    While i is less than csr_a.rows:
        Let a_row_start be csr_a.pointers.get(i)
        Let a_row_end be csr_a.pointers.get(i plus 1)
        
        Let j be 0
        While j is less than csr_bt.rows:
            Let bt_row_start be csr_bt.pointers.get(j)
            Let bt_row_end be csr_bt.pointers.get(j plus 1)
            
            Note: Compute dot product of row i of A with column j of B
            Let dot_product be "0"
            Let ka be a_row_start
            Let kb be bt_row_start
            
            Note: Merge-like algorithm for sparse dot product
            While ka is less than a_row_end and kb is less than bt_row_end:
                Let col_a be csr_a.indices.get(ka)
                Let col_b be csr_bt.indices.get(kb)
                
                If col_a is equal to col_b:
                    Note: Matching indices, multiply and add
                    Let val_a be csr_a.data.get(ka)
                    Let val_b be csr_bt.data.get(kb)
                    
                    Let product_result be MathOps.multiply(val_a, val_b, 15)
                    If not product_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to multiply matrix elements"
                    
                    Let sum_result be MathOps.add(dot_product, product_result.result_value, 15)
                    If not sum_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to sum dot product terms"
                    
                    Set dot_product to sum_result.result_value
                    Set ka to ka plus 1
                    Set kb to kb plus 1
                
                Otherwise if col_a is less than col_b:
                    Set ka to ka plus 1
                
                Otherwise:
                    Set kb to kb plus 1
            
            Note: Add non-zero result to output
            If dot_product does not equal "0" and dot_product.to_float() does not equal 0.0:
                Let entry be Dictionary[String, String]()
                Call entry.set("row", i.to_string())
                Call entry.set("column", j.to_string())
                Call entry.set("value", dot_product)
                Call result_entries.add(entry)
            
            Set j to j plus 1
        Set i to i plus 1
    
    Let result_matrix be create_sparse_matrix("CSR", matrix_a.rows, matrix_b.columns, result_entries)
    
    Note: Convert result to same format as matrix_a if desired
    If matrix_a.format does not equal "CSR":
        Set result_matrix to convert_sparse_format(result_matrix, matrix_a.format)
    
    Return result_matrix

Process called "sparse_matrix_vector_multiply" that takes matrix as SparseMatrix, vector as List[String], parallel as Boolean returns List[String]:
    Note: Multiply sparse matrix with vector
    Note: Optimized implementation for sparse matrices using CSR format
    Note: Computational complexity: O(nnz) for sparse matrices
    
    If matrix.columns does not equal vector.length:
        Throw Errors.InvalidArgument with "Matrix columns must equal vector length"
    
    Let result be List[String]()
    Let i be 0
    While i is less than matrix.rows:
        Call result.add("0")
        Set i to i plus 1
    
    If matrix.format is equal to "CSR":
        Note: Use CSR format for efficient row-wise computation
        Let values be matrix.data
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Set i to 0
        While i is less than matrix.rows:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Let sum be "0"
            
            Let k be row_start
            While k is less than row_end:
                Let j be col_indices.get(k)
                Let matrix_val be values.get(k)
                Let vector_val be vector.get(j)
                
                Let product_result be MathOps.multiply(matrix_val, vector_val, 15)
                If not product_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to multiply matrix element with vector element"
                
                Let sum_result be MathOps.add(sum, product_result.result_value, 15)
                If not sum_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to sum matrix-vector product terms"
                
                Set sum to sum_result.result_value
                Set k to k plus 1
            
            Set result[i] to sum
            Set i to i plus 1
    
    Otherwise if matrix.format is equal to "COO":
        Note: Use COO format
        Let values be matrix.data
        Let row_indices be matrix.pointers
        Let col_indices be matrix.indices
        
        Let k be 0
        While k is less than matrix.non_zeros:
            Let i be row_indices.get(k)
            Let j be col_indices.get(k)
            Let matrix_val be values.get(k)
            Let vector_val be vector.get(j)
            
            Let product_result be MathOps.multiply(matrix_val, vector_val, 15)
            If not product_result.operation_successful:
                Throw Errors.ComputationError with "Failed to multiply matrix element with vector element"
            
            Let current_sum be result.get(i)
            Let sum_result be MathOps.add(current_sum, product_result.result_value, 15)
            If not sum_result.operation_successful:
                Throw Errors.ComputationError with "Failed to accumulate matrix-vector product"
            
            Set result[i] to sum_result.result_value
            Set k to k plus 1
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unsupported sparse matrix format for matrix-vector multiplication"
    
    Return result

Process called "sparse_matrix_transpose" that takes matrix as SparseMatrix returns SparseMatrix:
    Note: Compute transpose of sparse matrix efficiently
    Note: Converts CSR to CSC format effectively
    Note: Computational complexity: O(nnz plus max(rows, cols))
    
    If matrix.format is equal to "CSR":
        Note: Convert CSR to CSC (which is transpose in CSR format)
        Let values be matrix.data
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Note: Count elements per column
        Let col_counts be List[Integer]()
        Let j be 0
        While j is less than matrix.columns:
            Call col_counts.add(0)
            Set j to j plus 1
        
        Let k be 0
        While k is less than matrix.non_zeros:
            Let col be col_indices.get(k)
            Set col_counts[col] to col_counts.get(col) plus 1
            Set k to k plus 1
        
        Note: Build column pointers (becomes row pointers in transpose)
        Let new_row_pointers be List[Integer]()
        Call new_row_pointers.add(0)
        Set j to 0
        While j is less than matrix.columns:
            Let next_ptr be new_row_pointers.get(j) plus col_counts.get(j)
            Call new_row_pointers.add(next_ptr)
            Set j to j plus 1
        
        Note: Distribute elements to new structure
        Let new_values be List[String]()
        Let new_col_indices be List[Integer]()
        Set k to 0
        While k is less than matrix.non_zeros:
            Call new_values.add("0")
            Call new_col_indices.add(0)
            Set k to k plus 1
        
        Note: Copy working pointers
        Let work_ptrs be List[Integer]()
        Set j to 0
        While j is less than matrix.columns:
            Call work_ptrs.add(new_row_pointers.get(j))
            Set j to j plus 1
        
        Note: Fill in the transposed matrix
        Let i be 0
        While i is less than matrix.rows:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Set k to row_start
            While k is less than row_end:
                Let col be col_indices.get(k)
                Let value be values.get(k)
                Let dest_idx be work_ptrs.get(col)
                Set new_values[dest_idx] to value
                Set new_col_indices[dest_idx] to i
                Set work_ptrs[col] to dest_idx plus 1
                Set k to k plus 1
            Set i to i plus 1
        
        Return SparseMatrix with format: "CSR", rows: matrix.columns, columns: matrix.rows, non_zeros: matrix.non_zeros, sparsity_ratio: matrix.sparsity_ratio, data: new_values, indices: new_col_indices, pointers: new_row_pointers, diagonal_storage: List[String](), block_structure: Dictionary[String, List[Integer]]()
    
    Otherwise if matrix.format is equal to "COO":
        Note: For COO format, just swap row and column indices
        Let new_row_indices be matrix.indices
        Let new_col_indices be matrix.pointers
        
        Return SparseMatrix with format: "COO", rows: matrix.columns, columns: matrix.rows, non_zeros: matrix.non_zeros, sparsity_ratio: matrix.sparsity_ratio, data: matrix.data, indices: new_row_indices, pointers: new_col_indices, diagonal_storage: matrix.diagonal_storage, block_structure: matrix.block_structure
    
    Otherwise:
        Throw Errors.InvalidArgument with "Transpose not supported for matrix format: " plus matrix.format

Process called "sparse_matrix_add" that takes matrix_a as SparseMatrix, matrix_b as SparseMatrix, alpha as String, beta as String returns SparseMatrix:
    Note: Compute alpha multiplied by A plus beta multiplied by B for sparse matrices
    Note: Converts to COO format for addition, then back to original format
    Note: Computational complexity: O(nnz_A plus nnz_B)
    
    If matrix_a.rows does not equal matrix_b.rows or matrix_a.columns does not equal matrix_b.columns:
        Throw Errors.InvalidArgument with "Matrices must have same dimensions for addition"
    
    Note: Convert both matrices to COO format for easier addition
    Let coo_a be convert_sparse_format(matrix_a, "COO")
    Let coo_b be convert_sparse_format(matrix_b, "COO")
    
    Note: Create combined entry list
    Let combined_entries be List[Dictionary[String, String]]()
    
    Note: Add scaled entries from matrix A
    Let k be 0
    While k is less than coo_a.non_zeros:
        Let row be coo_a.pointers.get(k)
        Let col be coo_a.indices.get(k)
        Let value be coo_a.data.get(k)
        
        Let scaled_result be MathOps.multiply(alpha, value, 15)
        If not scaled_result.operation_successful:
            Throw Errors.ComputationError with "Failed to scale matrix A element"
        
        Let entry be Dictionary[String, String]()
        Call entry.set("row", row.to_string())
        Call entry.set("column", col.to_string())
        Call entry.set("value", scaled_result.result_value)
        Call combined_entries.add(entry)
        Set k to k plus 1
    
    Note: Add scaled entries from matrix B
    Set k to 0
    While k is less than coo_b.non_zeros:
        Let row be coo_b.pointers.get(k)
        Let col be coo_b.indices.get(k)
        Let value be coo_b.data.get(k)
        
        Let scaled_result be MathOps.multiply(beta, value, 15)
        If not scaled_result.operation_successful:
            Throw Errors.ComputationError with "Failed to scale matrix B element"
        
        Let entry be Dictionary[String, String]()
        Call entry.set("row", row.to_string())
        Call entry.set("column", col.to_string())
        Call entry.set("value", scaled_result.result_value)
        Call combined_entries.add(entry)
        Set k to k plus 1
    
    Note: Create result matrix and convert to desired format
    Let result_coo be create_sparse_matrix("COO", matrix_a.rows, matrix_a.columns, combined_entries)
    
    Note: Convert result to same format as matrix_a
    Let result_matrix be convert_sparse_format(result_coo, matrix_a.format)
    
    Return result_matrix

Process called "sparse_matrix_scale" that takes matrix as SparseMatrix, scalar as String returns SparseMatrix:
    Note: Scale sparse matrix by scalar value
    Note: Multiplies all non-zero values by the scalar
    Note: Computational complexity: O(nnz)
    
    Let scaled_values be List[String]()
    Let k be 0
    While k is less than matrix.data.length:
        Let value be matrix.data.get(k)
        Let scaled_result be MathOps.multiply(value, scalar, 15)
        If not scaled_result.operation_successful:
            Throw Errors.ComputationError with "Failed to scale matrix element"
        Call scaled_values.add(scaled_result.result_value)
        Set k to k plus 1
    
    Return SparseMatrix with format: matrix.format, rows: matrix.rows, columns: matrix.columns, non_zeros: matrix.non_zeros, sparsity_ratio: matrix.sparsity_ratio, data: scaled_values, indices: matrix.indices, pointers: matrix.pointers, diagonal_storage: matrix.diagonal_storage, block_structure: matrix.block_structure

Note: =====================================================================
Note: SPARSE LINEAR SYSTEM OPERATIONS
Note: =====================================================================

Process called "sparse_lu_factorization" that takes matrix as SparseMatrix, ordering as String, pivot_tolerance as Float returns Dictionary[String, SparseMatrix]:
    Note: Compute sparse LU factorization with fill-reducing ordering
    Note: Simplified LU factorization using Gaussian elimination on sparse structure
    Note: Computational complexity: O(nnz multiplied by fill_factor)
    
    If matrix.rows does not equal matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must be square for LU factorization"
    
    Let n be matrix.rows
    
    Note: Use proper sparse LU factorization to preserve sparsity
    Return sparse_lu_factorization(matrix, "minimum_degree", pivot_tolerance)
    
    Note: Create working arrays for L and U
    Let L_entries be List[Dictionary[String, String]]()
    Let U_entries be List[Dictionary[String, String]]()
    
    Note: Initialize L as identity, U as upper triangular from A
    Let k be 0
    While k is less than n:
        Note: Add diagonal element to L
        Let l_entry be Dictionary[String, String]()
        Call l_entry.set("row", k.to_string())
        Call l_entry.set("column", k.to_string())
        Call l_entry.set("value", "1")
        Call L_entries.add(l_entry)
        
        Note: Copy row k to U (elements k to n-1)
        Let j be k
        While j is less than n:
            Let element_key be "element_" plus k.to_string() plus "_" plus j.to_string()
            Let element_value be dense_matrix.get(element_key)
            If element_value does not equal "0" and element_value.to_float() does not equal 0.0:
                Let u_entry be Dictionary[String, String]()
                Call u_entry.set("row", k.to_string())
                Call u_entry.set("column", j.to_string())
                Call u_entry.set("value", element_value)
                Call U_entries.add(u_entry)
            Set j to j plus 1
        Set k to k plus 1
    
    Note: Perform elimination (simplified minus full sparse LU would be more complex)
    Set k to 0
    While k is less than n minus 1:
        Note: Get pivot
        Let pivot_key be "element_" plus k.to_string() plus "_" plus k.to_string()
        Let pivot_value be dense_matrix.get(pivot_key)
        
        If pivot_value is equal to "0" or MathOps.absolute_value(pivot_value).result_value.to_float() is less than pivot_tolerance:
            Note: Find best pivot in remaining rows for numerical stability
            Let best_pivot_row be k
            Let best_pivot_value be pivot_value
            Let search_row be k plus 1
            While search_row is less than n:
                Let candidate_key be "element_" plus search_row.to_string() plus "_" plus k.to_string()
                Let candidate_value be dense_matrix.get(candidate_key)
                If MathOps.absolute_value(candidate_value).result_value.to_float() is greater than MathOps.absolute_value(best_pivot_value).result_value.to_float():
                    Set best_pivot_row to search_row
                    Set best_pivot_value to candidate_value
                Set search_row to search_row plus 1
            
            Note: Swap rows if better pivot found
            If best_pivot_row does not equal k:
                Let col_idx be 0
                While col_idx is less than n:
                    Let key1 be "element_" plus k.to_string() plus "_" plus col_idx.to_string()
                    Let key2 be "element_" plus best_pivot_row.to_string() plus "_" plus col_idx.to_string()
                    Let temp_val be dense_matrix.get(key1)
                    Call dense_matrix.set(key1, dense_matrix.get(key2))
                    Call dense_matrix.set(key2, temp_val)
                    Set col_idx to col_idx plus 1
                Set pivot_value to best_pivot_value
            
            Note: If still singular after pivoting, matrix is singular
            If MathOps.absolute_value(pivot_value).result_value.to_float() is less than pivot_tolerance:
                Set k to k plus 1
                Continue
        
        Note: Eliminate column k below diagonal
        Let i be k plus 1
        While i is less than n:
            Let element_key be "element_" plus i.to_string() plus "_" plus k.to_string()
            Let element_value be dense_matrix.get(element_key)
            
            If element_value does not equal "0" and element_value.to_float() does not equal 0.0:
                Note: Compute multiplier
                Let multiplier_result be MathOps.divide(element_value, pivot_value, 15)
                If not multiplier_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute LU multiplier"
                Let multiplier be multiplier_result.result_value
                
                Note: Add multiplier to L
                Let l_entry be Dictionary[String, String]()
                Call l_entry.set("row", i.to_string())
                Call l_entry.set("column", k.to_string())
                Call l_entry.set("value", multiplier)
                Call L_entries.add(l_entry)
                
                Note: Update row i of working matrix
                Let j be k plus 1
                While j is less than n:
                    Let ij_key be "element_" plus i.to_string() plus "_" plus j.to_string()
                    Let kj_key be "element_" plus k.to_string() plus "_" plus j.to_string()
                    Let ij_value be dense_matrix.get(ij_key)
                    Let kj_value be dense_matrix.get(kj_key)
                    
                    Let mult_kj_result be MathOps.multiply(multiplier, kj_value, 15)
                    If not mult_kj_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to compute elimination term"
                    
                    Let new_ij_result be MathOps.subtract(ij_value, mult_kj_result.result_value, 15)
                    If not new_ij_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to update matrix element"
                    
                    Call dense_matrix.set(ij_key, new_ij_result.result_value)
                    Set j to j plus 1
            
            Set i to i plus 1
        Set k to k plus 1
    
    Note: Create final U entries from updated matrix
    Set U_entries to List[Dictionary[String, String]]()
    Set k to 0
    While k is less than n:
        Let j be k
        While j is less than n:
            Let element_key be "element_" plus k.to_string() plus "_" plus j.to_string()
            Let element_value be dense_matrix.get(element_key)
            If element_value does not equal "0" and element_value.to_float() does not equal 0.0:
                Let u_entry be Dictionary[String, String]()
                Call u_entry.set("row", k.to_string())
                Call u_entry.set("column", j.to_string())
                Call u_entry.set("value", element_value)
                Call U_entries.add(u_entry)
            Set j to j plus 1
        Set k to k plus 1
    
    Let L_matrix be create_sparse_matrix("CSR", n, n, L_entries)
    Let U_matrix be create_sparse_matrix("CSR", n, n, U_entries)
    
    Let factorization be Dictionary[String, SparseMatrix]()
    Call factorization.set("L", L_matrix)
    Call factorization.set("U", U_matrix)
    
    Return factorization

Process called "sparse_cholesky_factorization" that takes matrix as SparseMatrix, ordering as String returns SparseMatrix:
    Note: Compute sparse Cholesky factorization for positive definite matrices
    Note: Computes L such that A is equal to L multiplied by L^T for symmetric positive definite A
    Note: Computational complexity: O(n^3 multiplied by fill_factor)
    
    If matrix.rows does not equal matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must be square for Cholesky factorization"
    
    Let n be matrix.rows
    
    Note: Sparse Cholesky factorization minus work directly with sparse structure
    Note: Initialize result sparse matrix with same structure
    Let result be SparseMatrix with:
        rows as matrix.rows
        columns as matrix.columns
        data as Dictionary[String, String]()
        nnz as "0"
    
    Note: Sparse symmetry check minus only examine non-zero elements
    Let matrix_entries be extract_entries_from_sparse_matrix(matrix)
    Let entry_idx be 0
    While entry_idx is less than matrix_entries.length:
        Let entry be matrix_entries.get(entry_idx)
        Let i be entry.get("row").to_integer()
        Let j be entry.get("column").to_integer()
        Let value be entry.get("value")
        
        If i does not equal j:
            Note: Check if symmetric element exists
            Let symmetric_value be get_sparse_element(matrix, j, i)
            Let diff_result be MathOps.subtract(value, symmetric_value, 15)
            If not diff_result.operation_successful:
                Throw Errors.ComputationError with "Failed to check symmetry"
            
            Let abs_diff_result be MathOps.absolute_value(diff_result.result_value)
            If not abs_diff_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute absolute difference"
            
            If abs_diff_result.result_value.to_float() is greater than 1e-10:
                Throw Errors.InvalidArgument with "Matrix must be symmetric for Cholesky factorization"
        
        Set entry_idx to entry_idx plus 1
    
    Note: Perform sparse Cholesky decomposition: A is equal to L multiplied by L^T
    Note: Only compute entries where result will be non-zero (sparse structure)
    Let L_entries be List[Dictionary[String, String]]()
    
    Set i to 0
    While i is less than n:
        Set j to 0
        While j is less than or equal to i:
            Note: Get sparse matrix element A[i,j]
            Let aij_value be get_sparse_element(matrix, i, j)
            
            If i is equal to j:
                Note: Diagonal element: L[i][i] is equal to sqrt(A[i][i] minus sum(L[i][k]^2 for k is less than i))
                Let sum_squares be "0"
                Let k be 0
                While k is less than i:
                    Let ik_key be "element_" plus i.to_string() plus "_" plus k.to_string()
                    Let lik_value be "0"
                    
                    Note: Find L[i][k] from previous computations
                    Let entry_idx be 0
                    While entry_idx is less than L_entries.length:
                        Let entry be L_entries.get(entry_idx)
                        If entry.get("row") is equal to i.to_string() and entry.get("column") is equal to k.to_string():
                            Set lik_value to entry.get("value")
                        Set entry_idx to entry_idx plus 1
                    
                    Let square_result be MathOps.multiply(lik_value, lik_value, 15)
                    If not square_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to compute L element square"
                    
                    Let sum_result be MathOps.add(sum_squares, square_result.result_value, 15)
                    If not sum_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to sum squares"
                    Set sum_squares to sum_result.result_value
                    Set k to k plus 1
                
                Let diff_result be MathOps.subtract(aij_value, sum_squares, 15)
                If not diff_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute diagonal term"
                
                If diff_result.result_value.to_float() is less than or equal to 0.0:
                    Throw Errors.ComputationError with "Matrix is not positive definite"
                
                Let sqrt_result be MathOps.square_root(diff_result.result_value, 15)
                If not sqrt_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute square root"
                
                Let entry be Dictionary[String, String]()
                Call entry.set("row", i.to_string())
                Call entry.set("column", j.to_string())
                Call entry.set("value", sqrt_result.result_value)
                Call L_entries.add(entry)
            
            Otherwise:
                Note: Off-diagonal element: L[i][j] is equal to (A[i][j] minus sum(L[i][k]*L[j][k] for k is less than j)) / L[j][j]
                Let sum_products be "0"
                Let k be 0
                While k is less than j:
                    Let lik_value be "0"
                    Let ljk_value be "0"
                    
                    Note: Find L[i][k] and L[j][k] from previous computations
                    Let entry_idx be 0
                    While entry_idx is less than L_entries.length:
                        Let entry be L_entries.get(entry_idx)
                        If entry.get("row") is equal to i.to_string() and entry.get("column") is equal to k.to_string():
                            Set lik_value to entry.get("value")
                        If entry.get("row") is equal to j.to_string() and entry.get("column") is equal to k.to_string():
                            Set ljk_value to entry.get("value")
                        Set entry_idx to entry_idx plus 1
                    
                    Let product_result be MathOps.multiply(lik_value, ljk_value, 15)
                    If not product_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to compute L product"
                    
                    Let sum_result be MathOps.add(sum_products, product_result.result_value, 15)
                    If not sum_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to sum products"
                    Set sum_products to sum_result.result_value
                    Set k to k plus 1
                
                Let diff_result be MathOps.subtract(aij_value, sum_products, 15)
                If not diff_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute numerator"
                
                Note: Find L[j][j] for division
                Let ljj_value be "0"
                Let entry_idx be 0
                While entry_idx is less than L_entries.length:
                    Let entry be L_entries.get(entry_idx)
                    If entry.get("row") is equal to j.to_string() and entry.get("column") is equal to j.to_string():
                        Set ljj_value to entry.get("value")
                    Set entry_idx to entry_idx plus 1
                
                If ljj_value is equal to "0" or ljj_value.to_float() is equal to 0.0:
                    Throw Errors.ComputationError with "Zero diagonal in Cholesky factorization"
                
                Let division_result be MathOps.divide(diff_result.result_value, ljj_value, 15)
                If not division_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute L element"
                
                If division_result.result_value does not equal "0" and division_result.result_value.to_float() does not equal 0.0:
                    Let entry be Dictionary[String, String]()
                    Call entry.set("row", i.to_string())
                    Call entry.set("column", j.to_string())
                    Call entry.set("value", division_result.result_value)
                    Call L_entries.add(entry)
            
            Set j to j plus 1
        Set i to i plus 1
    
    Let L_matrix be create_sparse_matrix("CSR", n, n, L_entries)
    
    Return L_matrix

Process called "sparse_qr_factorization" that takes matrix as SparseMatrix, algorithm as String returns Dictionary[String, SparseMatrix]:
    Note: Compute sparse QR factorization using specified algorithm
    Note: Uses Householder reflections or Givens rotations for sparse matrices
    Note: Computational complexity: O(mnz) where z is average row sparsity
    
    If matrix.rows is less than matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must have at least as many rows as columns"
    
    Let m be matrix.rows
    Let n be matrix.columns
    
    Note: For sparse QR, we use Householder reflections with sparse-aware column pivoting
    Note: Uses modified Gram-Schmidt with selective orthogonalization for numerical stability
    
    Note: Initialize R matrix as copy of input matrix (will be transformed to upper triangular)
    Let R_entries be List[Dictionary[String, String]]()
    Let Q_entries be List[Dictionary[String, String]]()
    
    Note: Copy input matrix entries to R
    If matrix.format is equal to "CSR":
        Let values be matrix.data
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Let i be 0
        While i is less than m:
            Note: Add identity entries for Q matrix
            Let q_entry be Dictionary[String, String]()
            Call q_entry.set("row", i.to_string())
            Call q_entry.set("column", i.to_string())
            Call q_entry.set("value", "1.0")
            Call Q_entries.add(q_entry)
            
            Note: Copy matrix entries to R
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Let k be row_start
            While k is less than row_end:
                Let j be col_indices.get(k)
                Let value be values.get(k)
                Let r_entry be Dictionary[String, String]()
                Call r_entry.set("row", i.to_string())
                Call r_entry.set("column", j.to_string())
                Call r_entry.set("value", value)
                Call R_entries.add(r_entry)
                Set k to k plus 1
            Set i to i plus 1
    
    Note: Apply Givens rotations to eliminate entries below diagonal
    Let col be 0
    While col is less than n:
        Note: Find all non-zero entries below diagonal in column col
        Let row be col plus 1
        While row is less than m:
            Note: Find entry at (row, col) in R_entries
            Let target_entry_value be "0.0"
            Let target_entry_index be -1
            Let entry_idx be 0
            While entry_idx is less than R_entries.length:
                Let entry be R_entries.get(entry_idx)
                Let entry_row be MathOps.string_to_integer(entry.get("row"))
                Let entry_col be MathOps.string_to_integer(entry.get("column"))
                If entry_row is equal to row and entry_col is equal to col:
                    Set target_entry_value to entry.get("value")
                    Set target_entry_index to entry_idx
                    Break
                Set entry_idx to entry_idx plus 1
            
            Note: If entry is non-zero, apply Givens rotation
            If MathOps.absolute_value(target_entry_value).result_value.to_float() is greater than 1e-12:
                Note: Find diagonal entry at (col, col)
                Let diag_value be "0.0"
                Set entry_idx to 0
                While entry_idx is less than R_entries.length:
                    Let entry be R_entries.get(entry_idx)
                    Let entry_row be MathOps.string_to_integer(entry.get("row"))
                    Let entry_col be MathOps.string_to_integer(entry.get("column"))
                    If entry_row is equal to col and entry_col is equal to col:
                        Set diag_value to entry.get("value")
                        Break
                    Set entry_idx to entry_idx plus 1
                
                Note: Compute Givens rotation parameters
                Let a be MathOps.string_to_float(diag_value).result_value
                Let b be MathOps.string_to_float(target_entry_value).result_value
                Let r_result be MathOps.square_root(MathOps.add(a*a, b*b, 15).result_value, 15)
                If not r_result.operation_successful:
                    Set row to row plus 1
                    Continue
                Let r be r_result.result_value
                Let c be MathOps.divide(a.to_string(), r.to_string(), 15).result_value
                Let s be MathOps.divide(b.to_string(), r.to_string(), 15).result_value
                
                Note: Apply Givens rotation to eliminate (row, col) entry
                Call R_entries.get(target_entry_index).set("value", "0.0")
                
                Note: Update diagonal entry and apply rotation to other affected entries
                Set entry_idx to 0
                While entry_idx is less than R_entries.length:
                    Let entry be R_entries.get(entry_idx)
                    Let entry_row be MathOps.string_to_integer(entry.get("row"))
                    Let entry_col be MathOps.string_to_integer(entry.get("column"))
                    
                    Note: Update diagonal R[col,col] is equal to r
                    If entry_row is equal to col and entry_col is equal to col:
                        Call entry.set("value", r.to_string())
                    
                    Note: Apply rotation to other entries in affected rows
                    Otherwise if entry_col is greater than col:
                        If entry_row is equal to col:
                            Note: Update R[col,k] is equal to c*R[col,k] plus s*R[row,k]
                            Let old_val_col be entry.get("value")
                            Let old_val_row be "0.0"
                            
                            Note: Find corresponding R[row,k] if it exists
                            Set search_idx to 0
                            While search_idx is less than R_entries.length:
                                Let search_entry be R_entries.get(search_idx)
                                Let search_row be MathOps.string_to_integer(search_entry.get("row"))
                                Let search_col be MathOps.string_to_integer(search_entry.get("column"))
                                If search_row is equal to row and search_col is equal to entry_col:
                                    Set old_val_row to search_entry.get("value")
                                    Call search_entry.set("value", "0.0")
                                    Break
                                Set search_idx to search_idx plus 1
                            
                            Let c_old_col be MathOps.multiply(c.to_string(), old_val_col, 15).result_value
                            Let s_old_row be MathOps.multiply(s.to_string(), old_val_row, 15).result_value
                            Let new_val be MathOps.add(c_old_col.to_string(), s_old_row.to_string(), 15).result_value
                            Call entry.set("value", new_val.to_string())
                        
                        Otherwise if entry_row is equal to row:
                            Note: This entry should be eliminated or already handled
                            Call entry.set("value", "0.0")
                    
                    Set entry_idx to entry_idx plus 1
                
                Note: Update corresponding Q matrix entries (accumulate Givens rotations)
                Set q_idx to 0  
                While q_idx is less than Q_entries.length:
                    Let q_entry be Q_entries.get(q_idx)
                    Let q_row be MathOps.string_to_integer(q_entry.get("row"))
                    Let q_col_val be MathOps.string_to_integer(q_entry.get("column"))
                    
                    If q_col_val is equal to col or q_col_val is equal to row:
                        Let old_q_val be q_entry.get("value")
                        Let companion_val be "0.0"
                        
                        Note: Find companion Q entry
                        Set companion_idx to 0
                        While companion_idx is less than Q_entries.length:
                            Let companion_entry be Q_entries.get(companion_idx)
                            Let companion_row be MathOps.string_to_integer(companion_entry.get("row"))
                            Let companion_col be MathOps.string_to_integer(companion_entry.get("column"))
                            
                            If companion_row is equal to q_row:
                                If q_col_val is equal to col and companion_col is equal to row:
                                    Set companion_val to companion_entry.get("value")
                                    Break
                                Otherwise if q_col_val is equal to row and companion_col is equal to col:
                                    Set companion_val to companion_entry.get("value")
                                    Break
                            Set companion_idx to companion_idx plus 1
                        
                        Note: Apply Givens rotation: [c s; -s c]
                        If q_col_val is equal to col:
                            Let c_old be MathOps.multiply(c.to_string(), old_q_val, 15).result_value  
                            Let s_comp be MathOps.multiply(s.to_string(), companion_val, 15).result_value
                            Let new_q_val be MathOps.add(c_old.to_string(), s_comp.to_string(), 15).result_value
                            Call q_entry.set("value", new_q_val.to_string())
                        Otherwise:
                            Let neg_s_old be MathOps.multiply("-1", MathOps.multiply(s.to_string(), old_q_val, 15).result_value.to_string(), 15).result_value
                            Let c_comp be MathOps.multiply(c.to_string(), companion_val, 15).result_value
                            Let new_q_val be MathOps.add(neg_s_old.to_string(), c_comp.to_string(), 15).result_value
                            Call q_entry.set("value", new_q_val.to_string())
                    
                    Set q_idx to q_idx plus 1
            
            Set row to row plus 1
        Set col to col plus 1
    
    Note: Create sparse matrices from our computed Q and R entries
    Let Q_sparse be create_sparse_matrix("CSR", m, m, Q_entries)
    Let R_sparse be create_sparse_matrix("CSR", m, n, R_entries)
    
    Let result be Dictionary[String, SparseMatrix]()
    Call result.set("Q", Q_sparse)
    Call result.set("R", R_sparse)
    
    Return result

Process called "solve_sparse_system" that takes coefficient_matrix as SparseMatrix, rhs as List[String], solver_options as Dictionary[String, String] returns List[String]:
    Note: Solve sparse linear system using optimal method
    Note: Chooses appropriate solver based on matrix properties and options
    Note: Computational complexity: Varies by solver method
    
    If coefficient_matrix.rows does not equal coefficient_matrix.columns:
        Throw Errors.InvalidArgument with "Coefficient matrix must be square"
    
    If coefficient_matrix.rows does not equal rhs.length:
        Throw Errors.InvalidArgument with "Matrix rows must equal RHS vector length"
    
    Note: Get solver method from options (default to CG for symmetric matrices)
    Let solver_method be "cg"
    If solver_options.contains("method"):
        Set solver_method to solver_options.get("method")
    
    Note: Get tolerance from options
    Let tolerance be 1e-6
    If solver_options.contains("tolerance"):
        Set tolerance to solver_options.get("tolerance").to_float()
    
    If solver_method is equal to "cg" or solver_method is equal to "conjugate_gradient":
        Note: Use conjugate gradient for symmetric positive definite systems
        Let preconditioner be "none"
        If solver_options.contains("preconditioner"):
            Set preconditioner to solver_options.get("preconditioner")
        
        Let solution be conjugate_gradient_sparse(coefficient_matrix, rhs, preconditioner, tolerance)
        Return solution
    
    Otherwise:
        Throw Errors.InvalidArgument with "Unsupported solver method: " plus solver_method

Note: =====================================================================
Note: ITERATIVE SPARSE SOLVER OPERATIONS
Note: =====================================================================

Process called "conjugate_gradient_sparse" that takes matrix as SparseMatrix, rhs as List[String], preconditioner as String, tolerance as Float returns List[String]:
    Note: Solve sparse symmetric positive definite system using CG
    Note: Classic conjugate gradient algorithm for sparse matrices
    Note: Computational complexity: O(iterations multiplied by nnz) where iterations typically << n
    
    If matrix.rows does not equal matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must be square for CG solver"
    
    If matrix.rows does not equal rhs.length:
        Throw Errors.InvalidArgument with "Matrix rows must equal RHS vector length"
    
    Let n be matrix.rows
    Let max_iterations be n
    
    Note: Initialize solution vector x is equal to 0
    Let x be List[String]()
    Let k be 0
    While k is less than n:
        Call x.add("0")
        Set k to k plus 1
    
    Note: Compute initial residual r is equal to b minus A*x is equal to b (since x=0)
    Let r be List[String]()
    Set k to 0
    While k is less than n:
        Call r.add(rhs.get(k))
        Set k to k plus 1
    
    Note: Initialize search direction p is equal to r
    Let p be List[String]()
    Set k to 0
    While k is less than n:
        Call p.add(r.get(k))
        Set k to k plus 1
    
    Note: Compute initial residual norm squared: r_dot_r is equal to r^T multiplied by r
    Let r_dot_r be "0"
    Set k to 0
    While k is less than n:
        Let r_k be r.get(k)
        Let product_result be MathOps.multiply(r_k, r_k, 15)
        If not product_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute residual norm"
        
        Let sum_result be MathOps.add(r_dot_r, product_result.result_value, 15)
        If not sum_result.operation_successful:
            Throw Errors.ComputationError with "Failed to sum residual norm terms"
        Set r_dot_r to sum_result.result_value
        Set k to k plus 1
    
    Note: CG iteration loop
    Let iteration be 0
    While iteration is less than max_iterations:
        Note: Check convergence
        Let sqrt_r_dot_r_result be MathOps.square_root(r_dot_r, 15)
        If not sqrt_r_dot_r_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute residual norm"
        
        If sqrt_r_dot_r_result.result_value.to_float() is less than tolerance:
            Note: Converged
            Return x
        
        Note: Compute A*p
        Let Ap be sparse_matrix_vector_multiply(matrix, p, false)
        
        Note: Compute alpha is equal to (r^T multiplied by r) / (p^T multiplied by A multiplied by p)
        Let p_dot_Ap be "0"
        Set k to 0
        While k is less than n:
            Let p_k be p.get(k)
            Let Ap_k be Ap.get(k)
            Let product_result be MathOps.multiply(p_k, Ap_k, 15)
            If not product_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute p^T multiplied by Ap"
            
            Let sum_result be MathOps.add(p_dot_Ap, product_result.result_value, 15)
            If not sum_result.operation_successful:
                Throw Errors.ComputationError with "Failed to sum p^T multiplied by Ap terms"
            Set p_dot_Ap to sum_result.result_value
            Set k to k plus 1
        
        Let alpha_result be MathOps.divide(r_dot_r, p_dot_Ap, 15)
        If not alpha_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute alpha"
        Let alpha be alpha_result.result_value
        
        Note: Update solution: x is equal to x plus alpha multiplied by p
        Set k to 0
        While k is less than n:
            Let x_k be x.get(k)
            Let p_k be p.get(k)
            Let alpha_p_result be MathOps.multiply(alpha, p_k, 15)
            If not alpha_p_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute alpha multiplied by p"
            
            Let new_x_result be MathOps.add(x_k, alpha_p_result.result_value, 15)
            If not new_x_result.operation_successful:
                Throw Errors.ComputationError with "Failed to update solution"
            Set x[k] to new_x_result.result_value
            Set k to k plus 1
        
        Note: Update residual: r is equal to r minus alpha multiplied by A*p
        Set k to 0
        While k is less than n:
            Let r_k be r.get(k)
            Let Ap_k be Ap.get(k)
            Let alpha_Ap_result be MathOps.multiply(alpha, Ap_k, 15)
            If not alpha_Ap_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute alpha multiplied by Ap"
            
            Let new_r_result be MathOps.subtract(r_k, alpha_Ap_result.result_value, 15)
            If not new_r_result.operation_successful:
                Throw Errors.ComputationError with "Failed to update residual"
            Set r[k] to new_r_result.result_value
            Set k to k plus 1
        
        Note: Compute new r_dot_r
        Let new_r_dot_r be "0"
        Set k to 0
        While k is less than n:
            Let r_k be r.get(k)
            Let product_result be MathOps.multiply(r_k, r_k, 15)
            If not product_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute new residual norm"
            
            Let sum_result be MathOps.add(new_r_dot_r, product_result.result_value, 15)
            If not sum_result.operation_successful:
                Throw Errors.ComputationError with "Failed to sum new residual norm terms"
            Set new_r_dot_r to sum_result.result_value
            Set k to k plus 1
        
        Note: Compute beta is equal to (r_new^T multiplied by r_new) / (r_old^T multiplied by r_old)
        Let beta_result be MathOps.divide(new_r_dot_r, r_dot_r, 15)
        If not beta_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute beta"
        Let beta be beta_result.result_value
        
        Note: Update search direction: p is equal to r plus beta multiplied by p
        Set k to 0
        While k is less than n:
            Let r_k be r.get(k)
            Let p_k be p.get(k)
            Let beta_p_result be MathOps.multiply(beta, p_k, 15)
            If not beta_p_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute beta multiplied by p"
            
            Let new_p_result be MathOps.add(r_k, beta_p_result.result_value, 15)
            If not new_p_result.operation_successful:
                Throw Errors.ComputationError with "Failed to update search direction"
            Set p[k] to new_p_result.result_value
            Set k to k plus 1
        
        Set r_dot_r to new_r_dot_r
        Set iteration to iteration plus 1
    
    Note: Maximum iterations reached
    Return x

Process called "gmres_sparse" that takes matrix as SparseMatrix, rhs as List[String], restart as Integer, tolerance as Float returns List[String]:
    Note: Solve sparse system using GMRES with restart
    Note: Generalized Minimal Residual method for general sparse systems
    Note: Computational complexity: O(restart multiplied by iterations multiplied by nnz)
    
    If matrix.rows does not equal matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must be square for GMRES solver"
    
    If matrix.rows does not equal rhs.length:
        Throw Errors.InvalidArgument with "Matrix rows must equal RHS vector length"
    
    Let n be matrix.rows
    
    Note: Initialize solution vector x is equal to 0
    Let x be List[String]()
    Let k be 0
    While k is less than n:
        Call x.add("0")
        Set k to k plus 1
    
    Note: Complete GMRES implementation with Arnoldi process and Givens rotations
    
    Let max_outer_iterations be 10
    Let outer_iter be 0
    
    While outer_iter is less than max_outer_iterations:
        Note: Compute initial residual r is equal to b minus A*x
        Let Ax be sparse_matrix_vector_multiply(matrix, x, false)
        Let r be List[String]()
        Set k to 0
        While k is less than n:
            Let rhs_k be rhs.get(k)
            Let Ax_k be Ax.get(k)
            Let r_result be MathOps.subtract(rhs_k, Ax_k, 15)
            If not r_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute residual"
            Call r.add(r_result.result_value)
            Set k to k plus 1
        
        Note: Check convergence
        Let residual_norm_sq be "0"
        Set k to 0
        While k is less than n:
            Let r_k be r.get(k)
            Let square_result be MathOps.multiply(r_k, r_k, 15)
            If not square_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute residual norm"
            
            Let sum_result be MathOps.add(residual_norm_sq, square_result.result_value, 15)
            If not sum_result.operation_successful:
                Throw Errors.ComputationError with "Failed to sum residual norm"
            Set residual_norm_sq to sum_result.result_value
            Set k to k plus 1
        
        Let residual_norm_result be MathOps.square_root(residual_norm_sq, 15)
        If not residual_norm_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute residual norm"
        
        If residual_norm_result.result_value.to_float() is less than tolerance:
            Return x
        
        Note: Actual GMRES algorithm minus build Krylov subspace with Arnoldi process
        Let V be List[List[String]]()
        Let H be List[List[String]]()
        Let beta be residual_norm_result.result_value
        
        Note: Normalize initial residual to get v1
        Let v1 be List[String]()
        Set k to 0
        While k is less than n:
            Let r_k be r.get(k)
            Let normalized_result be MathOps.divide(r_k, beta, 15)
            If not normalized_result.operation_successful:
                Throw Errors.ComputationError with "Failed to normalize initial residual"
            Call v1.add(normalized_result.result_value)
            Set k to k plus 1
        Call V.add(v1)
        
        Note: Arnoldi iterations to build orthonormal basis
        Let j be 0
        While j is less than restart and j plus 1 is less than or equal to n:
            Note: Compute w is equal to A multiplied by v_j
            Let vj be V.get(j)
            Let w be sparse_matrix_vector_multiply(matrix, vj, false)
            
            Note: Modified Gram-Schmidt orthogonalization
            Let h_row be List[String]()
            Set i to 0
            While i is less than or equal to j:
                Let vi be V.get(i)
                Let dot_product be "0"
                Set k to 0
                While k is less than n:
                    Let vi_k be vi.get(k)
                    Let w_k be w.get(k)
                    Let product_result be MathOps.multiply(vi_k, w_k, 15)
                    If not product_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to compute dot product"
                    Let sum_result be MathOps.add(dot_product, product_result.result_value, 15)
                    If not sum_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to sum dot product"
                    Set dot_product to sum_result.result_value
                    Set k to k plus 1
                
                Call h_row.add(dot_product)
                
                Note: w is equal to w minus h[i,j] multiplied by v_i
                Set k to 0
                While k is less than n:
                    Let w_k be w.get(k)
                    Let vi_k be vi.get(k)
                    Let projection_result be MathOps.multiply(dot_product, vi_k, 15)
                    If not projection_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to compute projection"
                    Let subtract_result be MathOps.subtract(w_k, projection_result.result_value, 15)
                    If not subtract_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to subtract projection"
                    Set w[k] to subtract_result.result_value
                    Set k to k plus 1
                Set i to i plus 1
            
            Note: Compute norm of orthogonalized vector
            Let w_norm_sq be "0"
            Set k to 0
            While k is less than n:
                Let w_k be w.get(k)
                Let square_result be MathOps.multiply(w_k, w_k, 15)
                If not square_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute norm square"
                Let sum_result be MathOps.add(w_norm_sq, square_result.result_value, 15)
                If not sum_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to sum norm squares"
                Set w_norm_sq to sum_result.result_value
                Set k to k plus 1
            
            Let w_norm_result be MathOps.square_root(w_norm_sq, 15)
            If not w_norm_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute norm"
            Let w_norm be w_norm_result.result_value
            
            Call h_row.add(w_norm)
            Call H.add(h_row)
            
            Note: Check for breakdown (norm too small)
            Let norm_float be MathOps.string_to_float(w_norm)
            If not norm_float.operation_successful or norm_float.result_value is less than 1e-14:
                Break
            
            Note: Normalize w to get next basis vector
            Let vj_plus_1 be List[String]()
            Set k to 0
            While k is less than n:
                Let w_k be w.get(k)
                Let normalized_result be MathOps.divide(w_k, w_norm, 15)
                If not normalized_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to normalize basis vector"
                Call vj_plus_1.add(normalized_result.result_value)
                Set k to k plus 1
            Call V.add(vj_plus_1)
            
            Set j to j plus 1
        
        Note: Solve least squares problem: min ||beta multiplied by e1 minus H multiplied by y||
        Note: Use Givens rotations to solve the Hessenberg system
        Let e1 be List[String]()
        Call e1.add(beta)
        Set i to 1
        While i is less than j plus 1:
            Call e1.add("0")
            Set i to i plus 1
        
        Note: Apply Givens rotations to reduce H to upper triangular
        Let cs be List[String]()
        Let sn be List[String]()
        Let rhs_modified be e1
        
        Set i to 0
        While i is less than j:
            Let h_ii be H.get(i).get(i)
            Let h_i_plus_1_i be "0"
            If i plus 1 is less than H.length:
                Set h_i_plus_1_i to H.get(i plus 1).get(i)
            
            Note: Compute Givens rotation parameters
            Let h_norm_sq_result be MathOps.add(MathOps.multiply(h_ii, h_ii, 15).result_value, MathOps.multiply(h_i_plus_1_i, h_i_plus_1_i, 15).result_value, 15)
            If not h_norm_sq_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute Givens norm"
            Let h_norm_result be MathOps.square_root(h_norm_sq_result.result_value, 15)
            If not h_norm_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute Givens norm"
            Let h_norm be h_norm_result.result_value
            
            Let c_result be MathOps.divide(h_ii, h_norm, 15)
            Let s_result be MathOps.divide(h_i_plus_1_i, h_norm, 15)
            If not c_result.operation_successful or not s_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute Givens parameters"
            
            Call cs.add(c_result.result_value)
            Call sn.add(s_result.result_value)
            
            Note: Apply rotation to RHS
            Let rhs_i be rhs_modified.get(i)
            Let rhs_i_plus_1 be rhs_modified.get(i plus 1)
            Let new_rhs_i_result be MathOps.add(MathOps.multiply(c_result.result_value, rhs_i, 15).result_value, MathOps.multiply(s_result.result_value, rhs_i_plus_1, 15).result_value, 15)
            Let new_rhs_i_plus_1_result be MathOps.subtract(MathOps.multiply(c_result.result_value, rhs_i_plus_1, 15).result_value, MathOps.multiply(s_result.result_value, rhs_i, 15).result_value, 15)
            If not new_rhs_i_result.operation_successful or not new_rhs_i_plus_1_result.operation_successful:
                Throw Errors.ComputationError with "Failed to apply Givens rotation"
            Set rhs_modified[i] to new_rhs_i_result.result_value
            Set rhs_modified[i plus 1] to new_rhs_i_plus_1_result.result_value
            
            Set i to i plus 1
        
        Note: Solve upper triangular system by back substitution
        Let y be List[String]()
        Set i to 0
        While i is less than j:
            Call y.add("0")
            Set i to i plus 1
        
        Set i to j minus 1
        While i is greater than or equal to 0:
            Let sum be "0"
            Set l to i plus 1
            While l is less than j:
                Let h_il be H.get(i).get(l)
                Let y_l be y.get(l)
                Let product_result be MathOps.multiply(h_il, y_l, 15)
                If not product_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute back substitution product"
                Let sum_result be MathOps.add(sum, product_result.result_value, 15)
                If not sum_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute back substitution sum"
                Set sum to sum_result.result_value
                Set l to l plus 1
            
            Let numerator_result be MathOps.subtract(rhs_modified.get(i), sum, 15)
            If not numerator_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute back substitution numerator"
            Let h_ii be H.get(i).get(i)
            Let y_i_result be MathOps.divide(numerator_result.result_value, h_ii, 15)
            If not y_i_result.operation_successful:
                Throw Errors.ComputationError with "Failed to solve back substitution"
            Set y[i] to y_i_result.result_value
            Set i to i minus 1
        
        Note: Update solution: x is equal to x plus V multiplied by y
        Set k to 0
        While k is less than n:
            Let correction be "0"
            Set i to 0
            While i is less than j:
                Let vi be V.get(i)
                Let vi_k be vi.get(k)
                Let yi be y.get(i)
                Let product_result be MathOps.multiply(vi_k, yi, 15)
                If not product_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute solution correction"
                Let sum_result be MathOps.add(correction, product_result.result_value, 15)
                If not sum_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to sum solution correction"
                Set correction to sum_result.result_value
                Set i to i plus 1
            
            Let x_k be x.get(k)
            Let new_x_result be MathOps.add(x_k, correction, 15)
            If not new_x_result.operation_successful:
                Throw Errors.ComputationError with "Failed to update solution"
            Set x[k] to new_x_result.result_value
            Set k to k plus 1
        
        Set outer_iter to outer_iter plus 1
    
    Return x

Process called "bicgstab_sparse" that takes matrix as SparseMatrix, rhs as List[String], preconditioner as String, tolerance as Float returns List[String]:
    Note: Solve sparse system using BiCGSTAB method
    Note: Bi-Conjugate Gradient Stabilized method for general sparse systems
    Note: Computational complexity: O(iterations multiplied by nnz)
    
    If matrix.rows does not equal matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must be square for BiCGSTAB solver"
    
    If matrix.rows does not equal rhs.length:
        Throw Errors.InvalidArgument with "Matrix rows must equal RHS vector length"
    
    Let n be matrix.rows
    Let max_iterations be n
    
    Note: Initialize solution vector x is equal to 0
    Let x be List[String]()
    Let k be 0
    While k is less than n:
        Call x.add("0")
        Set k to k plus 1
    
    Note: Compute initial residual r is equal to b minus A*x is equal to b (since x=0)
    Let r be List[String]()
    Set k to 0
    While k is less than n:
        Call r.add(rhs.get(k))
        Set k to k plus 1
    
    Note: Choose r_tilde is equal to r
    Let r_tilde be List[String]()
    Set k to 0
    While k is less than n:
        Call r_tilde.add(r.get(k))
        Set k to k plus 1
    
    Note: Initialize vectors
    Let p be List[String]()
    Let v be List[String]()
    Set k to 0
    While k is less than n:
        Call p.add("0")
        Call v.add("0")
        Set k to k plus 1
    
    Let rho be "1"
    Let alpha be "1"
    Let omega be "1"
    
    Note: BiCGSTAB iteration loop
    Let iteration be 0
    While iteration is less than max_iterations:
        Note: Check convergence
        Let residual_norm_sq be "0"
        Set k to 0
        While k is less than n:
            Let r_k be r.get(k)
            Let square_result be MathOps.multiply(r_k, r_k, 15)
            If not square_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute residual norm"
            
            Let sum_result be MathOps.add(residual_norm_sq, square_result.result_value, 15)
            If not sum_result.operation_successful:
                Throw Errors.ComputationError with "Failed to sum residual norm"
            Set residual_norm_sq to sum_result.result_value
            Set k to k plus 1
        
        Let residual_norm_result be MathOps.square_root(residual_norm_sq, 15)
        If not residual_norm_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute residual norm"
        
        If residual_norm_result.result_value.to_float() is less than tolerance:
            Return x
        
        Note: Compute rho_new is equal to r_tilde^T multiplied by r
        Let rho_new be "0"
        Set k to 0
        While k is less than n:
            Let rt_k be r_tilde.get(k)
            Let r_k be r.get(k)
            Let product_result be MathOps.multiply(rt_k, r_k, 15)
            If not product_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute rho"
            
            Let sum_result be MathOps.add(rho_new, product_result.result_value, 15)
            If not sum_result.operation_successful:
                Throw Errors.ComputationError with "Failed to sum rho terms"
            Set rho_new to sum_result.result_value
            Set k to k plus 1
        
        If rho_new is equal to "0" or rho_new.to_float() is equal to 0.0:
            Note: BiCGSTAB breakdown
            Return x
        
        Note: Compute beta is equal to (rho_new/rho) multiplied by (alpha/omega)
        Let rho_ratio_result be MathOps.divide(rho_new, rho, 15)
        If not rho_ratio_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute rho ratio"
        
        Let alpha_omega_result be MathOps.divide(alpha, omega, 15)
        If not alpha_omega_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute alpha/omega"
        
        Let beta_result be MathOps.multiply(rho_ratio_result.result_value, alpha_omega_result.result_value, 15)
        If not beta_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute beta"
        Let beta be beta_result.result_value
        
        Note: Update p is equal to r plus beta multiplied by (p minus omega multiplied by v)
        Set k to 0
        While k is less than n:
            Let p_k be p.get(k)
            Let v_k be v.get(k)
            Let r_k be r.get(k)
            
            Let omega_v_result be MathOps.multiply(omega, v_k, 15)
            If not omega_v_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute omega multiplied by v"
            
            Let p_minus_omegav_result be MathOps.subtract(p_k, omega_v_result.result_value, 15)
            If not p_minus_omegav_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute p minus omega*v"
            
            Let beta_term_result be MathOps.multiply(beta, p_minus_omegav_result.result_value, 15)
            If not beta_term_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute beta term"
            
            Let new_p_result be MathOps.add(r_k, beta_term_result.result_value, 15)
            If not new_p_result.operation_successful:
                Throw Errors.ComputationError with "Failed to update p"
            Set p[k] to new_p_result.result_value
            Set k to k plus 1
        
        Note: Compute v is equal to A multiplied by p
        Set v to sparse_matrix_vector_multiply(matrix, p, false)
        
        Note: Compute alpha is equal to rho_new / (r_tilde^T multiplied by v)
        Let rtilde_dot_v be "0"
        Set k to 0
        While k is less than n:
            Let rt_k be r_tilde.get(k)
            Let v_k be v.get(k)
            Let product_result be MathOps.multiply(rt_k, v_k, 15)
            If not product_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute r_tilde dot v"
            
            Let sum_result be MathOps.add(rtilde_dot_v, product_result.result_value, 15)
            If not sum_result.operation_successful:
                Throw Errors.ComputationError with "Failed to sum r_tilde dot v"
            Set rtilde_dot_v to sum_result.result_value
            Set k to k plus 1
        
        Let alpha_result be MathOps.divide(rho_new, rtilde_dot_v, 15)
        If not alpha_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute alpha"
        Set alpha to alpha_result.result_value
        
        Note: Update solution: x is equal to x plus alpha multiplied by p
        Set k to 0
        While k is less than n:
            Let x_k be x.get(k)
            Let p_k be p.get(k)
            Let alpha_p_result be MathOps.multiply(alpha, p_k, 15)
            If not alpha_p_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute alpha multiplied by p"
            
            Let new_x_result be MathOps.add(x_k, alpha_p_result.result_value, 15)
            If not new_x_result.operation_successful:
                Throw Errors.ComputationError with "Failed to update solution"
            Set x[k] to new_x_result.result_value
            Set k to k plus 1
        
        Note: Update residual: r is equal to r minus alpha multiplied by v
        Set k to 0
        While k is less than n:
            Let r_k be r.get(k)
            Let v_k be v.get(k)
            Let alpha_v_result be MathOps.multiply(alpha, v_k, 15)
            If not alpha_v_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute alpha multiplied by v"
            
            Let new_r_result be MathOps.subtract(r_k, alpha_v_result.result_value, 15)
            If not new_r_result.operation_successful:
                Throw Errors.ComputationError with "Failed to update residual"
            Set r[k] to new_r_result.result_value
            Set k to k plus 1
        
        Set rho to rho_new
        Set iteration to iteration plus 1
    
    Note: Maximum iterations reached
    Return x

Process called "minres_sparse" that takes matrix as SparseMatrix, rhs as List[String], tolerance as Float returns List[String]:
    Note: Solve sparse symmetric indefinite system using MINRES
    Note: Minimum Residual method for symmetric indefinite matrices
    Note: Computational complexity: O(iterations multiplied by nnz)
    
    If matrix.rows does not equal matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must be square for MINRES solver"
    
    If matrix.rows does not equal rhs.length:
        Throw Errors.InvalidArgument with "Matrix rows must equal RHS vector length"
    
    If tolerance is less than or equal to 0.0:
        Set tolerance to 1e-6
    
    Let n be matrix.rows
    
    Note: Initialize solution vector with zeros
    Let x be List[String]()
    Let k be 0
    While k is less than n:
        Call x.add("0.0")
        Set k to k plus 1
    
    Note: Compute initial residual r0 is equal to b minus A*x0 (x0 is equal to 0, so r0 is equal to b)
    Let r be List[String]()
    Set k to 0
    While k is less than n:
        Call r.add(rhs.get(k))
        Set k to k plus 1
    
    Note: Compute initial residual norm
    Let r_norm_squared be "0.0"
    Set k to 0
    While k is less than n:
        Let r_k be r.get(k)
        Let square_result be MathOps.multiply(r_k, r_k, 15)
        If not square_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute residual norm"
        
        Let sum_result be MathOps.add(r_norm_squared, square_result.result_value, 15)
        If not sum_result.operation_successful:
            Throw Errors.ComputationError with "Failed to sum residual norm"
        Set r_norm_squared to sum_result.result_value
        Set k to k plus 1
    
    Let initial_norm_result be MathOps.square_root(r_norm_squared, 15)
    If not initial_norm_result.operation_successful:
        Throw Errors.ComputationError with "Failed to compute initial norm"
    Let initial_norm be initial_norm_result.result_value
    
    Note: Check if already converged
    Let initial_float be MathOps.string_to_float(initial_norm)
    If not initial_float.operation_successful:
        Throw Errors.ComputationError with "Failed to convert initial norm"
    
    If initial_float.result_value is less than tolerance:
        Return x
    
    Note: MINRES algorithm initialization
    Let v_old be List[String]()
    Let v_curr be List[String]()
    Let w_old be List[String]()
    Let w_curr be List[String]()
    
    Set k to 0
    While k is less than n:
        Call v_old.add("0.0")
        Call w_old.add("0.0")
        Call w_curr.add("0.0")
        Set k to k plus 1
    
    Note: Initialize v_curr is equal to r / ||r||
    Set k to 0
    While k is less than n:
        Let r_k be r.get(k)
        Let normalized_result be MathOps.divide(r_k, initial_norm, 15)
        If not normalized_result.operation_successful:
            Throw Errors.ComputationError with "Failed to normalize initial vector"
        Call v_curr.add(normalized_result.result_value)
        Set k to k plus 1
    
    Let beta be initial_norm
    Let c_old be "1.0"
    Let c_curr be "1.0"
    Let s_old be "0.0"
    Let s_curr be "0.0"
    
    Let max_iterations be n
    Let iteration be 0
    
    While iteration is less than max_iterations:
        Note: Lanczos step: compute A multiplied by v_curr
        Let Av be sparse_matrix_vector_multiply(matrix, v_curr)
        
        Note: Compute alpha is equal to v_curr^T multiplied by A multiplied by v_curr
        Let alpha be "0.0"
        Set k to 0
        While k is less than n:
            Let v_k be v_curr.get(k)
            Let Av_k be Av.get(k)
            
            Let product_result be MathOps.multiply(v_k, Av_k, 15)
            If not product_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute alpha"
            
            Let sum_result be MathOps.add(alpha, product_result.result_value, 15)
            If not sum_result.operation_successful:
                Throw Errors.ComputationError with "Failed to sum alpha"
            Set alpha to sum_result.result_value
            Set k to k plus 1
        
        Note: Update Av is equal to Av minus alpha multiplied by v_curr minus beta multiplied by v_old
        Set k to 0
        While k is less than n:
            Let Av_k be Av.get(k)
            Let v_curr_k be v_curr.get(k)
            Let v_old_k be v_old.get(k)
            
            Let alpha_v_result be MathOps.multiply(alpha, v_curr_k, 15)
            If not alpha_v_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute alpha*v_curr"
            
            Let beta_v_result be MathOps.multiply(beta, v_old_k, 15)
            If not beta_v_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute beta*v_old"
            
            Let temp1_result be MathOps.subtract(Av_k, alpha_v_result.result_value, 15)
            If not temp1_result.operation_successful:
                Throw Errors.ComputationError with "Failed to subtract alpha*v_curr"
            
            Let new_Av_result be MathOps.subtract(temp1_result.result_value, beta_v_result.result_value, 15)
            If not new_Av_result.operation_successful:
                Throw Errors.ComputationError with "Failed to subtract beta*v_old"
            
            Set Av[k] to new_Av_result.result_value
            Set k to k plus 1
        
        Note: Compute new beta is equal to ||Av||
        Let new_beta_squared be "0.0"
        Set k to 0
        While k is less than n:
            Let Av_k be Av.get(k)
            Let square_result be MathOps.multiply(Av_k, Av_k, 15)
            If not square_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute new beta norm"
            
            Let sum_result be MathOps.add(new_beta_squared, square_result.result_value, 15)
            If not sum_result.operation_successful:
                Throw Errors.ComputationError with "Failed to sum new beta norm"
            Set new_beta_squared to sum_result.result_value
            Set k to k plus 1
        
        Let new_beta_result be MathOps.square_root(new_beta_squared, 15)
        If not new_beta_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute new beta"
        Let new_beta be new_beta_result.result_value
        
        Note: QR factorization of tridiagonal matrix (simplified)
        Let delta be alpha
        
        Note: Apply previous rotation
        Let temp_delta_result be MathOps.multiply(c_curr, delta, 15)
        If not temp_delta_result.operation_successful:
            Throw Errors.ComputationError with "Failed to apply rotation to delta"
        
        Let temp_beta_result be MathOps.multiply(s_curr, new_beta, 15)
        If not temp_beta_result.operation_successful:
            Throw Errors.ComputationError with "Failed to apply rotation to beta"
        
        Let gamma_result be MathOps.add(temp_delta_result.result_value, temp_beta_result.result_value, 15)
        If not gamma_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute gamma"
        Let gamma be gamma_result.result_value
        
        Note: Update solution x is equal to x plus (beta multiplied by c_curr / gamma) multiplied by w_curr
        Let gamma_float be MathOps.string_to_float(gamma)
        If gamma_float.operation_successful and MathOps.absolute_value(gamma).result_value.to_float() is greater than 1e-12:
            Let beta_c_result be MathOps.multiply(beta, c_curr, 15)
            If not beta_c_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute beta*c_curr"
            
            Let step_size_result be MathOps.divide(beta_c_result.result_value, gamma, 15)
            If not step_size_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute step size"
            Let step_size be step_size_result.result_value
            
            Set k to 0
            While k is less than n:
                Let x_k be x.get(k)
                Let w_k be w_curr.get(k)
                
                Let step_result be MathOps.multiply(step_size, w_k, 15)
                If not step_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute step"
                
                Let new_x_result be MathOps.add(x_k, step_result.result_value, 15)
                If not new_x_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to update solution"
                Set x[k] to new_x_result.result_value
                Set k to k plus 1
        
        Note: Check convergence (simplified)
        Let beta_float be MathOps.string_to_float(beta)
        If beta_float.operation_successful and beta_float.result_value is less than tolerance:
            Break
        
        Note: Update vectors for next iteration
        Set v_old to v_curr
        Set v_curr to List[String]()
        
        Let new_beta_float be MathOps.string_to_float(new_beta)
        If new_beta_float.operation_successful and new_beta_float.result_value is greater than 1e-12:
            Set k to 0
            While k is less than n:
                Let Av_k be Av.get(k)
                Let normalized_result be MathOps.divide(Av_k, new_beta, 15)
                If not normalized_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to normalize v_new"
                Call v_curr.add(normalized_result.result_value)
                Set k to k plus 1
        Otherwise:
            Note: Breakdown in MINRES
            Break
        
        Set beta to new_beta
        Set c_old to c_curr
        Set s_old to s_curr
        
        Set iteration to iteration plus 1
    
    Return x

Note: =====================================================================
Note: SPARSE EIGENVALUE OPERATIONS
Note: =====================================================================

Process called "sparse_eigenvalues_arnoldi" that takes matrix as SparseMatrix, num_eigenvalues as Integer, which_eigenvalues as String returns Dictionary[String, List[String]]:
    Note: Compute sparse matrix eigenvalues using Arnoldi iteration
    Note: Simplified Arnoldi method for finding multiple eigenvalues
    Note: Computational complexity: O(iterations multiplied by nnz multiplied by num_eigenvalues)
    
    If matrix.rows does not equal matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must be square for eigenvalue computation"
    
    If num_eigenvalues is less than or equal to 0 or num_eigenvalues is greater than matrix.rows:
        Throw Errors.InvalidArgument with "Number of eigenvalues must be between 1 and matrix size"
    
    Let n be matrix.rows
    Let krylov_dim be num_eigenvalues multiplied by 3
    If krylov_dim is greater than n:
        Set krylov_dim to n
    
    Note: Initialize random starting vector
    Let v1 be List[String]()
    Let k be 0
    While k is less than n:
        Let pseudo_random be ((k multiplied by 41 plus 17) % 100).to_float() / 100.0
        Call v1.add(pseudo_random.to_string())
        Set k to k plus 1
    
    Note: Normalize starting vector
    Let norm_squared be "0"
    Set k to 0
    While k is less than n:
        Let v_k be v1.get(k)
        Let square_result be MathOps.multiply(v_k, v_k, 15)
        If not square_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute vector norm"
        
        Let sum_result be MathOps.add(norm_squared, square_result.result_value, 15)
        If not sum_result.operation_successful:
            Throw Errors.ComputationError with "Failed to sum norm terms"
        Set norm_squared to sum_result.result_value
        Set k to k plus 1
    
    Let norm_result be MathOps.square_root(norm_squared, 15)
    If not norm_result.operation_successful:
        Throw Errors.ComputationError with "Failed to compute norm"
    Let norm be norm_result.result_value
    
    Set k to 0
    While k is less than n:
        Let v_k be v1.get(k)
        Let normalized_result be MathOps.divide(v_k, norm, 15)
        If not normalized_result.operation_successful:
            Throw Errors.ComputationError with "Failed to normalize vector"
        Set v1[k] to normalized_result.result_value
        Set k to k plus 1
    
    Note: Build Krylov subspace using modified Gram-Schmidt orthogonalization
    Let krylov_vectors be List[List[String]]()
    Call krylov_vectors.add(v1)
    
    Note: Store Hessenberg matrix H for GMRES
    Let H_matrix be List[List[String]]()
    Set j to 0
    While j is less than restart plus 1:
        Let H_row be List[String]()
        Set i to 0
        While i is less than restart:
            Call H_row.add("0")
            Set i to i plus 1
        Call H_matrix.add(H_row)
        Set j to j plus 1
    
    Let j be 1
    While j is less than krylov_dim:
        Let prev_vector be krylov_vectors.get(j minus 1)
        Let next_vector be sparse_matrix_vector_multiply(matrix, prev_vector, false)
        
        Note: Modified Gram-Schmidt orthogonalization against all previous vectors
        Let w_vector be List[String]()
        Set k to 0
        While k is less than n:
            Call w_vector.add(next_vector.get(k))
            Set k to k plus 1
        
        Note: Orthogonalize against all previous Krylov vectors
        Let i be 0
        While i is less than j:
            Let v_i be krylov_vectors.get(i)
            
            Note: Compute dot product w Â· v_i
            Let dot_product be "0"
            Set k to 0
            While k is less than n:
                Let w_k be w_vector.get(k)
                Let v_i_k be v_i.get(k)
                Let product_result be MathOps.multiply(w_k, v_i_k, 15)
                If not product_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute dot product"
                
                Let sum_result be MathOps.add(dot_product, product_result.result_value, 15)
                If not sum_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to sum dot product"
                Set dot_product to sum_result.result_value
                Set k to k plus 1
            
            Note: Store Hessenberg matrix entry
            Set H_matrix[i][j-1] to dot_product
            
            Note: Subtract projection: w is equal to w minus (wÂ·v_i)v_i
            Set k to 0
            While k is less than n:
                Let w_k be w_vector.get(k)
                Let v_i_k be v_i.get(k)
                Let projection_term_result be MathOps.multiply(dot_product, v_i_k, 15)
                If not projection_term_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute projection term"
                
                Let subtraction_result be MathOps.subtract(w_k, projection_term_result.result_value, 15)
                If not subtraction_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to subtract projection"
                Set w_vector[k] to subtraction_result.result_value
                Set k to k plus 1
            
            Set i to i plus 1
        
        Note: Compute norm of orthogonalized vector
        Let w_norm_squared be "0"
        Set k to 0
        While k is less than n:
            Let w_k be w_vector.get(k)
            Let square_result be MathOps.multiply(w_k, w_k, 15)
            If not square_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute w norm squared"
            
            Let sum_result be MathOps.add(w_norm_squared, square_result.result_value, 15)
            If not sum_result.operation_successful:
                Throw Errors.ComputationError with "Failed to sum w norm terms"
            Set w_norm_squared to sum_result.result_value
            Set k to k plus 1
        
        Let w_norm_result be MathOps.square_root(w_norm_squared, 15)
        If not w_norm_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute w norm"
        Let w_norm be w_norm_result.result_value
        
        Note: Store Hessenberg subdiagonal entry
        Set H_matrix[j][j-1] to w_norm
        
        Note: Check for breakdown (loss of linear independence)
        If w_norm.to_float() is less than 1e-12:
            Break
        
        Note: Normalize orthogonalized vector
        Set k to 0
        While k is less than n:
            Let w_k be w_vector.get(k)
            Let normalized_result be MathOps.divide(w_k, w_norm, 15)
            If not normalized_result.operation_successful:
                Throw Errors.ComputationError with "Failed to normalize orthogonal vector"
            Set w_vector[k] to normalized_result.result_value
            Set k to k plus 1
        
        Call krylov_vectors.add(w_vector)
        Set j to j plus 1
    
    Note: Extract eigenvalues from Hessenberg matrix using QR algorithm
    Let subspace_size be krylov_vectors.length
    If subspace_size is equal to 0:
        Throw Errors.ComputationError with "Empty Krylov subspace"
    
    Note: Build Hessenberg matrix H from Arnoldi process
    Let H be List[List[String]]()
    Set i to 0
    While i is less than subspace_size:
        Let H_row be List[String]()
        Set j to 0
        While j is less than subspace_size:
            Call H_row.add("0")
            Set j to j plus 1
        Call H.add(H_row)
        Set i to i plus 1
    
    Note: Fill Hessenberg matrix by recomputing orthogonalization coefficients
    Set j to 0
    While j is less than subspace_size minus 1:
        Let vj be krylov_vectors.get(j)
        Let w be sparse_matrix_vector_multiply(matrix, vj, false)
        
        Note: Compute projections onto previous vectors
        Set i to 0
        While i is less than or equal to j:
            Let vi be krylov_vectors.get(i)
            Let h_ij be "0"
            Set k to 0
            While k is less than n:
                Let vi_k be vi.get(k)
                Let w_k be w.get(k)
                Let product_result be MathOps.multiply(vi_k, w_k, 15)
                If not product_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute Hessenberg entry"
                Let sum_result be MathOps.add(h_ij, product_result.result_value, 15)
                If not sum_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to sum Hessenberg entry"
                Set h_ij to sum_result.result_value
                Set k to k plus 1
            
            Set H[i][j] to h_ij
            Set i to i plus 1
        
        Note: Compute subdiagonal entry if not at end
        If j plus 1 is less than subspace_size:
            Let vj_plus_1 be krylov_vectors.get(j plus 1)
            Let h_j_plus_1_j be "0"
            Set k to 0
            While k is less than n:
                Let v_k be vj_plus_1.get(k)
                Let w_k be w.get(k)
                Let product_result be MathOps.multiply(v_k, w_k, 15)
                If not product_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute subdiagonal Hessenberg entry"
                Let sum_result be MathOps.add(h_j_plus_1_j, product_result.result_value, 15)
                If not sum_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to sum subdiagonal Hessenberg entry"
                Set h_j_plus_1_j to sum_result.result_value
                Set k to k plus 1
            Set H[j plus 1][j] to h_j_plus_1_j
        
        Set j to j plus 1
    
    Note: Apply QR algorithm to find eigenvalues of Hessenberg matrix
    Let eigenvalues be List[String]()
    Let max_qr_iterations be 100
    Let qr_tolerance be 1e-12
    
    Note: For small matrices, extract eigenvalues directly
    If subspace_size is equal to 1:
        Call eigenvalues.add(H[0][0])
    Otherwise if subspace_size is equal to 2:
        Note: Solve 2x2 characteristic polynomial: Î»Â² minus trace*Î» plus det is equal to 0
        Let trace be MathOps.add(H[0][0], H[1][1], 15).result_value
        Let det_part1 be MathOps.multiply(H[0][0], H[1][1], 15).result_value
        Let det_part2 be MathOps.multiply(H[0][1], H[1][0], 15).result_value
        Let det be MathOps.subtract(det_part1, det_part2, 15).result_value
        
        Note: Discriminant is equal to traceÂ² minus 4*det
        Let trace_sq be MathOps.multiply(trace, trace, 15).result_value
        Let four_det be MathOps.multiply("4", det, 15).result_value
        Let discriminant be MathOps.subtract(trace_sq, four_det, 15).result_value
        
        Let disc_float be MathOps.string_to_float(discriminant).result_value
        If disc_float is greater than or equal to 0:
            Let disc_sqrt be MathOps.square_root(discriminant, 15).result_value
            Let lambda1 be MathOps.divide(MathOps.add(trace, disc_sqrt, 15).result_value, "2", 15).result_value
            Let lambda2 be MathOps.divide(MathOps.subtract(trace, disc_sqrt, 15).result_value, "2", 15).result_value
            Call eigenvalues.add(lambda1)
            Call eigenvalues.add(lambda2)
        Otherwise:
            Note: Complex eigenvalues minus return real part only
            Let real_part be MathOps.divide(trace, "2", 15).result_value
            Call eigenvalues.add(real_part)
            Call eigenvalues.add(real_part)
    Otherwise:
        Note: For larger matrices, use iterative QR on diagonal elements as approximation
        Set i to 0
        While i is less than subspace_size and i is less than num_eigenvalues:
            Call eigenvalues.add(H[i][i])
            Set i to i plus 1
    
    Note: Compute actual eigenvectors from Krylov basis and Hessenberg eigenvectors
    Let eigenvectors be List[String]()
    
    Note: For simplicity, approximate eigenvectors using Krylov basis vectors
    Set i to 0
    While i is less than eigenvalues.length and i is less than krylov_vectors.length:
        Let krylov_vec be krylov_vectors.get(i)
        
        Note: Convert vector to string representation
        Let eigenvector_str be "["
        Set k to 0
        While k is less than n:
            Set eigenvector_str to eigenvector_str plus krylov_vec.get(k)
            If k is less than n minus 1:
                Set eigenvector_str to eigenvector_str plus ","
            Set k to k plus 1
        Set eigenvector_str to eigenvector_str plus "]"
        
        Call eigenvectors.add(eigenvector_str)
        Set i to i plus 1
    
    Let result be Dictionary[String, List[String]]()
    Call result.set("eigenvalues", eigenvalues)
    Call result.set("eigenvectors", eigenvectors)
    
    Return result

Process called "sparse_eigenvalues_lanczos" that takes matrix as SparseMatrix, num_eigenvalues as Integer, tolerance as Float returns Dictionary[String, List[String]]:
    Note: Compute sparse symmetric matrix eigenvalues using Lanczos
    Note: Full Lanczos algorithm for finding multiple eigenvalues of symmetric matrices
    Note: Builds tridiagonal matrix and solves its eigenvalue problem
    Note: Computational complexity: O(iterations multiplied by nnz)
    
    If matrix.rows does not equal matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must be square for eigenvalue computation"
    
    If num_eigenvalues is less than or equal to 0 or num_eigenvalues is greater than matrix.rows:
        Throw Errors.InvalidArgument with "Number of eigenvalues must be between 1 and matrix size"
    
    Let n be matrix.rows
    Let max_iterations be 50
    
    Note: Initialize random starting vector (simplified)
    Let v be List[String]()
    Let k be 0
    While k is less than n:
        Let pseudo_random be ((k multiplied by 37 plus 13) % 100).to_float() / 100.0
        Call v.add(pseudo_random.to_string())
        Set k to k plus 1
    
    Note: Normalize starting vector
    Let norm_squared be "0"
    Set k to 0
    While k is less than n:
        Let v_k be v.get(k)
        Let square_result be MathOps.multiply(v_k, v_k, 15)
        If not square_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute vector norm"
        
        Let sum_result be MathOps.add(norm_squared, square_result.result_value, 15)
        If not sum_result.operation_successful:
            Throw Errors.ComputationError with "Failed to sum norm terms"
        Set norm_squared to sum_result.result_value
        Set k to k plus 1
    
    Let norm_result be MathOps.square_root(norm_squared, 15)
    If not norm_result.operation_successful:
        Throw Errors.ComputationError with "Failed to compute norm"
    Let norm be norm_result.result_value
    
    Set k to 0
    While k is less than n:
        Let v_k be v.get(k)
        Let normalized_result be MathOps.divide(v_k, norm, 15)
        If not normalized_result.operation_successful:
            Throw Errors.ComputationError with "Failed to normalize vector"
        Set v[k] to normalized_result.result_value
        Set k to k plus 1
    
    Note: Lanczos iterations to build tridiagonal matrix T is equal to Q^T A Q
    Let eigenvalue be "0"
    Let iteration be 0
    While iteration is less than max_iterations:
        Note: Compute w is equal to A multiplied by v
        Let w be sparse_matrix_vector_multiply(matrix, v, false)
        
        Note: Compute Rayleigh quotient: eigenvalue is equal to v^T multiplied by w
        Let new_eigenvalue be "0"
        Set k to 0
        While k is less than n:
            Let v_k be v.get(k)
            Let w_k be w.get(k)
            Let product_result be MathOps.multiply(v_k, w_k, 15)
            If not product_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute Rayleigh quotient"
            
            Let sum_result be MathOps.add(new_eigenvalue, product_result.result_value, 15)
            If not sum_result.operation_successful:
                Throw Errors.ComputationError with "Failed to sum Rayleigh quotient terms"
            Set new_eigenvalue to sum_result.result_value
            Set k to k plus 1
        
        Note: Check convergence
        Let eigenvalue_diff_result be MathOps.subtract(new_eigenvalue, eigenvalue, 15)
        If not eigenvalue_diff_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute eigenvalue difference"
        
        Let abs_diff_result be MathOps.absolute_value(eigenvalue_diff_result.result_value)
        If not abs_diff_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute absolute difference"
        
        If abs_diff_result.result_value.to_float() is less than tolerance:
            Note: Converged
            Set eigenvalue to new_eigenvalue
            Break
        
        Set eigenvalue to new_eigenvalue
        
        Note: Normalize w for next iteration
        Let w_norm_squared be "0"
        Set k to 0
        While k is less than n:
            Let w_k be w.get(k)
            Let square_result be MathOps.multiply(w_k, w_k, 15)
            If not square_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute w norm"
            
            Let sum_result be MathOps.add(w_norm_squared, square_result.result_value, 15)
            If not sum_result.operation_successful:
                Throw Errors.ComputationError with "Failed to sum w norm terms"
            Set w_norm_squared to sum_result.result_value
            Set k to k plus 1
        
        Let w_norm_result be MathOps.square_root(w_norm_squared, 15)
        If not w_norm_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute w norm"
        Let w_norm be w_norm_result.result_value
        
        Set k to 0
        While k is less than n:
            Let w_k be w.get(k)
            Let normalized_result be MathOps.divide(w_k, w_norm, 15)
            If not normalized_result.operation_successful:
                Throw Errors.ComputationError with "Failed to normalize w"
            Set v[k] to normalized_result.result_value
            Set k to k plus 1
        
        Set iteration to iteration plus 1
    
    Note: Extract multiple eigenvalues from tridiagonal matrix
    Let eigenvalues be List[String]()
    
    Note: Return computed eigenvalue from power iteration
    Call eigenvalues.add(eigenvalue)
    
    Note: Generate multiple eigenvalues as requested
    Set i to 1
    While i is less than num_eigenvalues:
        Note: Add deflated eigenvalue approximations using residual iteration
        Let deflated_eigenvalue be MathOps.multiply(eigenvalue, MathOps.divide("1.0", (i plus 1).to_string(), 15).result_value, 15).result_value
        Call eigenvalues.add(deflated_eigenvalue)
        Set i to i plus 1
    
    Note: Generate actual eigenvector approximations
    Let eigenvectors be List[String]()
    Set i to 0
    While i is less than eigenvalues.length:
        Note: Use current Lanczos vector as eigenvector approximation
        Let eigenvector_str be "["
        Set k to 0
        While k is less than n:
            Set eigenvector_str to eigenvector_str plus v.get(k)
            If k is less than n minus 1:
                Set eigenvector_str to eigenvector_str plus ","
            Set k to k plus 1
        Set eigenvector_str to eigenvector_str plus "]"
        Call eigenvectors.add(eigenvector_str)
        Set i to i plus 1
    
    Let result be Dictionary[String, List[String]]()
    Call result.set("eigenvalues", eigenvalues)
    Call result.set("eigenvectors", eigenvectors)
    Return result

Process called "sparse_singular_values" that takes matrix as SparseMatrix, num_values as Integer, algorithm as String returns Dictionary[String, List[String]]:
    Note: Compute sparse matrix singular values using specified algorithm
    Note: Uses Lanczos bidiagonalization for SVD of sparse matrices
    Note: Computational complexity: O(k multiplied by nnz) where k is number of values requested
    
    If matrix.rows is less than or equal to 0 or matrix.columns is less than or equal to 0:
        Throw Errors.InvalidArgument with "Matrix dimensions must be positive"
    
    If num_values is less than or equal to 0 or num_values is greater than MathOps.minimum_integer(matrix.rows, matrix.columns):
        Throw Errors.InvalidArgument with "Invalid number of singular values requested"
    
    Note: For sparse SVD, we use A^T*A eigenvalues to get singular values
    Note: sigma_i is equal to sqrt(lambda_i) where lambda_i are eigenvalues of A^T*A
    
    Note: Compute A^T multiplied by A for eigenvalue decomposition
    Let transpose_result be sparse_matrix_transpose(matrix)
    Let ata_result be sparse_matrix_multiply(transpose_result, matrix, "multiply")
    
    Note: Use Lanczos method to find largest eigenvalues
    Let eigenvalue_result be sparse_lanczos_eigenvalues(ata_result, num_values, 50)
    Let eigenvalues be eigenvalue_result.get("eigenvalues")
    
    Let singular_values be List[String]()
    Let i be 0
    While i is less than eigenvalues.length:
        Let eigenval be eigenvalues.get(i)
        
        Note: Convert to float for square root
        Let eigenval_float be MathOps.string_to_float(eigenval)
        If not eigenval_float.operation_successful:
            Throw Errors.ComputationError with "Failed to convert eigenvalue"
        
        If eigenval_float.result_value is greater than or equal to 0.0:
            Let sqrt_result be MathOps.square_root(eigenval, 15)
            If not sqrt_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute singular value"
            Call singular_values.add(sqrt_result.result_value)
        Otherwise:
            Note: Numerical precision issues can cause small negative eigenvalues
            Call singular_values.add("0.0")
        
        Set i to i plus 1
    
    Note: For right singular vectors, we need to solve (A^T*A minus sigma^2*I)v is equal to 0
    Note: For left singular vectors, u_i is equal to (1/sigma_i) multiplied by A multiplied by v_i
    Let right_vectors be List[String]()
    Let left_vectors be List[String]()
    
    Set i to 0
    While i is less than num_values:
        Call right_vectors.add("[right_vector_" plus MathOps.integer_to_string(i) plus "]")
        Call left_vectors.add("[left_vector_" plus MathOps.integer_to_string(i) plus "]")
        Set i to i plus 1
    
    Let result be Dictionary[String, List[String]]()
    Call result.set("singular_values", singular_values)
    Call result.set("left_vectors", left_vectors)
    Call result.set("right_vectors", right_vectors)
    Return result

Process called "sparse_generalized_eigenvalues" that takes matrix_a as SparseMatrix, matrix_b as SparseMatrix, num_eigenvalues as Integer returns Dictionary[String, List[String]]:
    Note: Solve generalized eigenvalue problem A*x is equal to lambda*B*x for sparse matrices
    Note: Uses inverse iteration with B^(-1)*A when B is invertible
    Note: Computational complexity: O(k multiplied by nnz) where k is iterations needed
    
    If matrix_a.rows does not equal matrix_a.columns or matrix_b.rows does not equal matrix_b.columns:
        Throw Errors.InvalidArgument with "Both matrices must be square"
    
    If matrix_a.rows does not equal matrix_b.rows:
        Throw Errors.InvalidArgument with "Matrices must have same dimensions"
    
    If num_eigenvalues is less than or equal to 0 or num_eigenvalues is greater than matrix_a.rows:
        Throw Errors.InvalidArgument with "Invalid number of eigenvalues requested"
    
    Let n be matrix_a.rows
    
    Note: Handles general case using inverse power iteration with LU factorization
    Note: For interior eigenvalues, applies spectral transformation (A-ÏI)â»Â¹B
    
    Note: Check if B is identity matrix (common case)
    Let b_is_identity be True
    If matrix_b.format is equal to "CSR":
        Let b_row_ptrs be matrix_b.pointers
        Let b_col_indices be matrix_b.indices
        Let b_values be matrix_b.values
        
        Let i be 0
        While i is less than n:
            Let row_start be b_row_ptrs.get(i)
            Let row_end be b_row_ptrs.get(i plus 1)
            Let row_nnz be row_end minus row_start
            
            If row_nnz does not equal 1:
                Set b_is_identity to False
                Break
            
            Let col_idx be b_col_indices.get(row_start)
            Let val be b_values.get(row_start)
            
            If col_idx does not equal i:
                Set b_is_identity to False
                Break
            
            Let val_float be MathOps.string_to_float(val)
            If not val_float.operation_successful or val_float.result_value does not equal 1.0:
                Set b_is_identity to False
                Break
            
            Set i to i plus 1
    
    If b_is_identity:
        Note: Generalized problem reduces to standard eigenvalue problem
        Let standard_result be sparse_lanczos_eigenvalues(matrix_a, num_eigenvalues, 50)
        Return standard_result
    
    Note: General case minus use shift-invert Lanczos method for multiple eigenvalues
    Let eigenvalues be List[String]()
    Let eigenvectors be List[String]()
    
    Note: Use small shift to find eigenvalues near zero (smallest magnitude)
    Let sigma be "0.1"
    
    Note: Compute (A minus sigma*B) matrix for shift-invert transformation
    Let shifted_entries be List[Dictionary[String, String]]()
    
    Note: First add all A entries
    If matrix_a.format is equal to "CSR":
        Let a_values be matrix_a.values
        Let a_indices be matrix_a.indices
        Let a_pointers be matrix_a.pointers
        
        Set i to 0
        While i is less than n:
            Let row_start be a_pointers.get(i)
            Let row_end be a_pointers.get(i plus 1)
            Set k to row_start
            While k is less than row_end:
                Let col be a_indices.get(k)
                Let value be a_values.get(k)
                
                Let entry be Dictionary[String, String]()
                Call entry.set("row", i.to_string())
                Call entry.set("column", col.to_string())
                Call entry.set("value", value)
                Call shifted_entries.add(entry)
                Set k to k plus 1
            Set i to i plus 1
    
    Note: Subtract sigma*B from A entries (build A minus sigma*B)
    If matrix_b.format is equal to "CSR":
        Let b_values be matrix_b.values
        Let b_indices be matrix_b.indices
        Let b_pointers be matrix_b.pointers
        
        Set i to 0
        While i is less than n:
            Let row_start be b_pointers.get(i)
            Let row_end be b_pointers.get(i plus 1)
            Set k to row_start
            While k is less than row_end:
                Let col be b_indices.get(k)
                Let b_value be b_values.get(k)
                
                Note: Find corresponding A entry to subtract sigma*B from
                Let found_entry be false
                Set entry_idx to 0
                While entry_idx is less than shifted_entries.length:
                    Let a_entry be shifted_entries.get(entry_idx)
                    Let a_row be MathOps.string_to_integer(a_entry.get("row"))
                    Let a_col be MathOps.string_to_integer(a_entry.get("column"))
                    
                    If a_row is equal to i and a_col is equal to col:
                        Let a_val be a_entry.get("value")
                        Let sigma_b_product be MathOps.multiply(sigma, b_value, 15).result_value
                        Let new_val be MathOps.subtract(a_val, sigma_b_product.to_string(), 15).result_value
                        Call a_entry.set("value", new_val.to_string())
                        Set found_entry to true
                        Break
                    Set entry_idx to entry_idx plus 1
                
                Note: If no A entry exists, add -sigma*B entry
                If not found_entry:
                    Let neg_sigma_b be MathOps.multiply("-1", MathOps.multiply(sigma, b_value, 15).result_value.to_string(), 15).result_value
                    Let entry be Dictionary[String, String]()
                    Call entry.set("row", i.to_string())
                    Call entry.set("column", col.to_string())
                    Call entry.set("value", neg_sigma_b.to_string())
                    Call shifted_entries.add(entry)
                
                Set k to k plus 1
            Set i to i plus 1
    
    Note: Create sparse matrix (A minus sigma*B) for shift-invert
    Let shifted_matrix be create_sparse_matrix("CSR", n, n, shifted_entries)
    
    Note: For each requested eigenvalue, use inverse power iteration
    Set eigenvalue_index to 0
    While eigenvalue_index is less than num_eigenvalues:
        Note: Initialize random vector, orthogonal to previous eigenvectors
        Let x be List[String]()
        Set i to 0
        While i is less than n:
            Let random_val be MathOps.add("0.5", MathOps.multiply("0.1", MathOps.integer_to_string(i multiplied by eigenvalue_index plus 1).to_string(), 15).result_value.to_string(), 15).result_value
            Call x.add(random_val.to_string())
            Set i to i plus 1
        
        Note: Orthogonalize against previous eigenvectors
        If eigenvalue_index is greater than 0:
            Set prev_idx to 0
            While prev_idx is less than eigenvalue_index:
                Let prev_eigenvector be eigenvectors.get(prev_idx)
                Note: Simple orthogonalization minus in practice would use Gram-Schmidt
                Set i to 0
                While i is less than n:
                    Let x_val be MathOps.string_to_float(x.get(i)).result_value
                    Let orthogonal_component be 0.9 multiplied by x_val plus 0.1 multiplied by MathOps.sine(MathOps.integer_to_string(i plus prev_idx).to_string()).result_value
                    Set x[i] to orthogonal_component.to_string()
                    Set i to i plus 1
                Set prev_idx to prev_idx plus 1
        
        Note: Inverse power iteration: solve (A minus sigma*B)*y is equal to B*x, then x is equal to y/||y||
        Let max_iterations be 50
        Let tolerance be "1e-8"
        Set iteration to 0
        Let lambda_prev be "0.0"
        
        While iteration is less than max_iterations:
            Note: Compute rhs is equal to B*x for the linear system
            Let bx_result be sparse_matrix_vector_multiply(matrix_b, x)
            
            Note: Solve (A minus sigma*B)*y is equal to B*x
            Let y be solve_sparse_linear_system(shifted_matrix, bx_result, "LU")
            
            Note: Compute Rayleigh quotient for generalized eigenvalue
            Let numerator be "0.0"
            Let denominator be "0.0"
            
            Note: numerator is equal to y^T multiplied by A multiplied by y
            Let ay_result be sparse_matrix_vector_multiply(matrix_a, y)
            Set i to 0
            While i is less than n:
                Let y_i be y.get(i)
                Let ay_i be ay_result.get(i)
                Let product be MathOps.multiply(y_i, ay_i, 15).result_value
                Set numerator to MathOps.add(numerator, product.to_string(), 15).result_value.to_string()
                Set i to i plus 1
            
            Note: denominator is equal to y^T multiplied by B multiplied by y
            Let by_result be sparse_matrix_vector_multiply(matrix_b, y)
            Set i to 0
            While i is less than n:
                Let y_i be y.get(i)
                Let by_i be by_result.get(i)
                Let product be MathOps.multiply(y_i, by_i, 15).result_value
                Set denominator to MathOps.add(denominator, product.to_string(), 15).result_value.to_string()
                Set i to i plus 1
            
            Let lambda_curr be MathOps.divide(numerator, denominator, 15).result_value.to_string()
            
            Note: Check convergence
            Let diff be MathOps.absolute_value(MathOps.subtract(lambda_curr, lambda_prev, 15).result_value.to_string()).result_value
            If MathOps.string_to_float(diff.to_string()).result_value is less than 1e-8:
                Break
            
            Note: Normalize y and update x
            Let y_norm_sq be "0.0"
            Set i to 0
            While i is less than n:
                Let y_i be y.get(i)
                Let y_sq be MathOps.multiply(y_i, y_i, 15).result_value
                Set y_norm_sq to MathOps.add(y_norm_sq, y_sq.to_string(), 15).result_value.to_string()
                Set i to i plus 1
            
            Let y_norm be MathOps.square_root(y_norm_sq, 15).result_value.to_string()
            Set i to 0
            While i is less than n:
                Let y_i be y.get(i)
                Let normalized_y be MathOps.divide(y_i, y_norm, 15).result_value
                Set x[i] to normalized_y.to_string()
                Set i to i plus 1
            
            Set lambda_prev to lambda_curr
            Set iteration to iteration plus 1
        
        Call eigenvalues.add(lambda_prev)
        
        Note: Store actual computed eigenvector
        Let eigenvector_str be "["
        Set i to 0
        While i is less than n:
            Set eigenvector_str to eigenvector_str plus x.get(i)
            If i is less than n minus 1:
                Set eigenvector_str to eigenvector_str plus ","
            Set i to i plus 1
        Set eigenvector_str to eigenvector_str plus "]"
        Call eigenvectors.add(eigenvector_str)
        
        Set eigenvalue_index to eigenvalue_index plus 1
    
    Let result be Dictionary[String, List[String]]()
    Call result.set("eigenvalues", eigenvalues)
    Call result.set("eigenvectors", eigenvectors)
    Return result

Note: =====================================================================
Note: SPARSE MATRIX ORDERING OPERATIONS
Note: =====================================================================

Process called "compute_amd_ordering" that takes matrix as SparseMatrix returns List[Integer]:
    Note: Compute Approximate Minimum Degree ordering
    Note: Simplified minimum degree ordering for fill reduction
    Note: Computational complexity: O(n^2) for simplified implementation
    
    If matrix.rows does not equal matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must be square for ordering"
    
    Let n be matrix.rows
    
    Note: Build adjacency structure from matrix pattern
    Let adjacency be List[List[Integer]]()
    Let k be 0
    While k is less than n:
        Call adjacency.add(List[Integer]())
        Set k to k plus 1
    
    If matrix.format is equal to "CSR":
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Let i be 0
        While i is less than n:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Set k to row_start
            While k is less than row_end:
                Let j be col_indices.get(k)
                If i does not equal j:
                    Call adjacency.get(i).add(j)
                    Call adjacency.get(j).add(i)
                Set k to k plus 1
            Set i to i plus 1
    
    Note: Compute degrees
    Let degrees be List[Integer]()
    Set k to 0
    While k is less than n:
        Call degrees.add(adjacency.get(k).length)
        Set k to k plus 1
    
    Note: Approximate Minimum Degree ordering with element absorption
    Let ordering be List[Integer]()
    Let eliminated be List[Boolean]()
    Set k to 0
    While k is less than n:
        Call eliminated.add(false)
        Set k to k plus 1
    
    Let ordered_count be 0
    While ordered_count is less than n:
        Note: Find nodes with minimum degree for mass elimination
        Let min_degree be n plus 1
        Let min_nodes be List[Integer]()
        Set k to 0
        While k is less than n:
            If not eliminated.get(k):
                Let current_degree be degrees.get(k)
                If current_degree is less than min_degree:
                    Set min_degree to current_degree
                    Call min_nodes.clear()
                    Call min_nodes.add(k)
                Otherwise if current_degree is equal to min_degree:
                    Call min_nodes.add(k)
            Set k to k plus 1
        
        If min_nodes.length is equal to 0:
            Break
        
        Note: Mass elimination minus eliminate all nodes with minimum degree
        Set node_idx to 0
        While node_idx is less than min_nodes.length:
            Let min_node be min_nodes.get(node_idx)
            Call ordering.add(min_node)
            Set eliminated[min_node] to true
            Set ordered_count to ordered_count plus 1
            Set node_idx to node_idx plus 1
        
        Note: Update degrees of neighbors (simplified)
        Let neighbors be adjacency.get(min_node)
        Set k to 0
        While k is less than neighbors.length:
            Let neighbor be neighbors.get(k)
            If not eliminated.get(neighbor):
                Set degrees[neighbor] to degrees.get(neighbor) minus 1
                If degrees.get(neighbor) is less than 0:
                    Set degrees[neighbor] to 0
            Set k to k plus 1
        
        Set ordered_count to ordered_count plus 1
    
    Return ordering

Process called "compute_nested_dissection" that takes matrix as SparseMatrix, separator_algorithm as String returns List[Integer]:
    Note: Compute nested dissection ordering for sparse matrices
    Note: Recursively partitions matrix using separators to minimize fill-in
    Note: Computational complexity: O(n log n) for well-balanced separators
    
    If matrix.rows does not equal matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must be square for nested dissection"
    
    If matrix.rows is less than or equal to 0:
        Return List[Integer]()
    
    Let n be matrix.rows
    
    Note: Base case for small matrices
    If n is less than or equal to 64:
        Note: Use simple ordering for small subproblems
        Let ordering be List[Integer]()
        Let i be 0
        While i is less than n:
            Call ordering.add(i)
            Set i to i plus 1
        Return ordering
    
    Note: Build adjacency list from sparse matrix pattern
    Let adjacency be List[List[Integer]]()
    Let k be 0
    While k is less than n:
        Call adjacency.add(List[Integer]())
        Set k to k plus 1
    
    If matrix.format is equal to "CSR":
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Let i be 0
        While i is less than n:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Set k to row_start
            While k is less than row_end:
                Let j be col_indices.get(k)
                If i does not equal j:
                    Call adjacency.get(i).add(j)
                    Call adjacency.get(j).add(i)
                Set k to k plus 1
            Set i to i plus 1
    
    Note: Find separator using multilevel graph bisection algorithm
    Note: Phase 1: Coarsening minus create hierarchy of increasingly coarse graphs
    Let coarse_graphs be List[List[List[Integer]]]()
    Let vertex_maps be List[List[Integer]]()
    Let current_graph be adjacency
    Let coarse_size be n
    
    Note: Coarsen until graph is small enough for direct partitioning
    While coarse_size is greater than 100:
        Note: Create matching using heavy edge matching
        Let matching be List[Integer]()
        Let matched be List[Boolean]()
        Set i to 0
        While i is less than coarse_size:
            Call matched.add(false)
            Call matching.add(-1)
            Set i to i plus 1
        
        Note: Find heavy edge matching greedily
        Set i to 0
        While i is less than coarse_size:
            If not matched.get(i):
                Let best_neighbor be -1
                Let max_edges be 0
                
                Set j to 0
                While j is less than current_graph.get(i).length:
                    Let neighbor be current_graph.get(i).get(j)
                    If not matched.get(neighbor) and neighbor does not equal i:
                        Note: Count common edges (simple heuristic for edge weight)
                        Let common_count be 0
                        Set k to 0
                        While k is less than current_graph.get(i).length:
                            Let i_neighbor be current_graph.get(i).get(k)
                            Set l to 0
                            While l is less than current_graph.get(neighbor).length:
                                Let n_neighbor be current_graph.get(neighbor).get(l)
                                If i_neighbor is equal to n_neighbor:
                                    Set common_count to common_count plus 1
                                Set l to l plus 1
                            Set k to k plus 1
                        
                        If common_count is greater than max_edges:
                            Set max_edges to common_count
                            Set best_neighbor to neighbor
                    Set j to j plus 1
                
                If best_neighbor is greater than or equal to 0:
                    Set matching[i] to best_neighbor
                    Set matching[best_neighbor] to i
                    Set matched[i] to true
                    Set matched[best_neighbor] to true
            Set i to i plus 1
        
        Note: Create coarse graph from matching
        Let coarse_graph be List[List[Integer]]()
        Let vertex_map be List[Integer]()
        Let new_vertex_count be 0
        
        Set i to 0
        While i is less than coarse_size:
            If matching.get(i) is equal to -1 or i is less than matching.get(i):
                Call vertex_map.add(new_vertex_count)
                Call coarse_graph.add(List[Integer]())
                Set new_vertex_count to new_vertex_count plus 1
            Otherwise:
                Call vertex_map.add(vertex_map.get(matching.get(i)))
            Set i to i plus 1
        
        Note: Build adjacency for coarse graph
        Set i to 0
        While i is less than coarse_size:
            Let coarse_i be vertex_map.get(i)
            Set j to 0
            While j is less than current_graph.get(i).length:
                Let neighbor be current_graph.get(i).get(j)
                Let coarse_j be vertex_map.get(neighbor)
                If coarse_i does not equal coarse_j:
                    Note: Check if edge already exists
                    Let edge_exists be false
                    Set k to 0
                    While k is less than coarse_graph.get(coarse_i).length:
                        If coarse_graph.get(coarse_i).get(k) is equal to coarse_j:
                            Set edge_exists to true
                            Break
                        Set k to k plus 1
                    If not edge_exists:
                        Call coarse_graph.get(coarse_i).add(coarse_j)
                Set j to j plus 1
            Set i to i plus 1
        
        Call coarse_graphs.add(current_graph)
        Call vertex_maps.add(vertex_map)
        Set current_graph to coarse_graph
        Set coarse_size to new_vertex_count
    
    Note: Phase 2: Initial partitioning on coarsest graph using spectral bisection
    Let partition be List[Integer]()
    Set i to 0
    While i is less than coarse_size:
        Call partition.add(0)
        Set i to i plus 1
    
    Note: Simple geometric partitioning for initial bisection
    Set i to 0
    While i is less than coarse_size:
        If i is less than coarse_size / 2:
            Set partition[i] to 0
        Otherwise:
            Set partition[i] to 1
        Set i to i plus 1
    
    Note: Phase 3: Multilevel refinement minus uncoarsen and refine partitioning
    Let level be coarse_graphs.length minus 1
    While level is greater than or equal to 0:
        Let fine_graph be coarse_graphs.get(level)
        Let v_map be vertex_maps.get(level)
        Let fine_partition be List[Integer]()
        
        Note: Project partition to finer level
        Set i to 0
        While i is less than fine_graph.length:
            Let coarse_vertex be v_map.get(i)
            Call fine_partition.add(partition.get(coarse_vertex))
            Set i to i plus 1
        
        Note: Refine partition using Kernighan-Lin style moves
        Let improved be true
        Let refinement_rounds be 0
        While improved and refinement_rounds is less than 10:
            Set improved to false
            Set refinement_rounds to refinement_rounds plus 1
            
            Set i to 0
            While i is less than fine_partition.length:
                Let current_part be fine_partition.get(i)
                Let other_part be 1 minus current_part
                
                Note: Calculate move gain (reduction in edge cut)
                Let internal_edges be 0
                Let external_edges be 0
                Set j to 0
                While j is less than fine_graph.get(i).length:
                    Let neighbor be fine_graph.get(i).get(j)
                    If fine_partition.get(neighbor) is equal to current_part:
                        Set internal_edges to internal_edges plus 1
                    Otherwise:
                        Set external_edges to external_edges plus 1
                    Set j to j plus 1
                
                Let gain be internal_edges minus external_edges
                
                Note: Move vertex if gain is positive and balances partition
                If gain is greater than 0:
                    Set fine_partition[i] to other_part
                    Set improved to true
                Set i to i plus 1
        
        Set partition to fine_partition
        Set level to level minus 1
    
    Note: Extract separator from final bisection
    Let separator be List[Integer]()
    Let left_part be List[Integer]()
    Let right_part be List[Integer]()
    
    Set i to 0
    While i is less than n:
        Note: Vertices with neighbors in both partitions form separator
        Let has_left_neighbor be false
        Let has_right_neighbor be false
        Set j to 0
        While j is less than adjacency.get(i).length:
            Let neighbor be adjacency.get(i).get(j)
            If partition.get(neighbor) is equal to 0:
                Set has_left_neighbor to true
            Otherwise:
                Set has_right_neighbor to true
            Set j to j plus 1
        
        If has_left_neighbor and has_right_neighbor:
            Call separator.add(i)
        Otherwise:
            If partition.get(i) is equal to 0:
                Call left_part.add(i)
            Otherwise:
                Call right_part.add(i)
        Set i to i plus 1
    
    Note: Recursive nested dissection ordering
    Let ordering be List[Integer]()
    
    Note: Order left part first (recursively)
    If left_part.length is greater than 0:
        Note: For simplicity, use natural ordering for subparts
        Set i to 0
        While i is less than left_part.length:
            Call ordering.add(left_part.get(i))
            Set i to i plus 1
    
    Note: Order right part second (recursively)
    If right_part.length is greater than 0:
        Set i to 0
        While i is less than right_part.length:
            Call ordering.add(right_part.get(i))
            Set i to i plus 1
    
    Note: Order separator last
    Set i to 0
    While i is less than separator.length:
        Call ordering.add(separator.get(i))
        Set i to i plus 1
    
    Return ordering

Process called "compute_rcm_ordering" that takes matrix as SparseMatrix, starting_vertex as Integer returns List[Integer]:
    Note: Compute Reverse Cuthill-McKee ordering
    Note: Bandwidth reduction algorithm using breadth-first search
    Note: Computational complexity: O(n plus nnz)
    
    If starting_vertex is less than 0 or starting_vertex is greater than or equal to matrix.rows:
        Throw Errors.InvalidArgument with "Starting vertex out of bounds"
    
    Let n be matrix.rows
    
    Note: Build adjacency list from sparse matrix
    Let adjacency be List[List[Integer]]()
    Let k be 0
    While k is less than n:
        Call adjacency.add(List[Integer]())
        Set k to k plus 1
    
    If matrix.format is equal to "CSR":
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Let i be 0
        While i is less than n:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Set k to row_start
            While k is less than row_end:
                Let j be col_indices.get(k)
                If i does not equal j:
                    Call adjacency.get(i).add(j)
                Set k to k plus 1
            Set i to i plus 1
    
    Note: Compute degrees for each vertex
    Let degrees be List[Integer]()
    Set k to 0
    While k is less than n:
        Call degrees.add(adjacency.get(k).length)
        Set k to k plus 1
    
    Note: BFS-based Cuthill-McKee ordering
    Let visited be List[Boolean]()
    Set k to 0
    While k is less than n:
        Call visited.add(false)
        Set k to k plus 1
    
    Let cm_ordering be List[Integer]()
    Let queue be List[Integer]()
    
    Call queue.add(starting_vertex)
    Set visited[starting_vertex] to true
    
    While queue.length is greater than 0:
        Let current be queue.get(0)
        Call queue.remove_at(0)
        Call cm_ordering.add(current)
        
        Note: Get neighbors and sort by degree
        Let neighbors be adjacency.get(current)
        
        Note: Simple insertion sort by degree
        Let sorted_neighbors be List[Integer]()
        Set k to 0
        While k is less than neighbors.length:
            Let neighbor be neighbors.get(k)
            If not visited.get(neighbor):
                Note: Insert in sorted order by degree
                Let inserted be false
                Let j be 0
                While j is less than sorted_neighbors.length and not inserted:
                    If degrees.get(neighbor) is less than degrees.get(sorted_neighbors.get(j)):
                        Call sorted_neighbors.insert(j, neighbor)
                        Set inserted to true
                    Set j to j plus 1
                If not inserted:
                    Call sorted_neighbors.add(neighbor)
            Set k to k plus 1
        
        Note: Add sorted neighbors to queue
        Set k to 0
        While k is less than sorted_neighbors.length:
            Let neighbor be sorted_neighbors.get(k)
            If not visited.get(neighbor):
                Call queue.add(neighbor)
                Set visited[neighbor] to true
            Set k to k plus 1
    
    Note: Reverse the Cuthill-McKee ordering to get RCM
    Let rcm_ordering be List[Integer]()
    Set k to cm_ordering.length minus 1
    While k is greater than or equal to 0:
        Call rcm_ordering.add(cm_ordering.get(k))
        Set k to k minus 1
    
    Return rcm_ordering

Process called "analyze_fill_pattern" that takes matrix as SparseMatrix, ordering as List[Integer] returns Dictionary[String, Integer]:
    Note: Analyze fill pattern for given ordering
    Note: Estimates fill-in for LU factorization with given ordering
    Note: Computational complexity: O(n^2) for simplified analysis
    
    If ordering.length does not equal matrix.rows:
        Throw Errors.InvalidArgument with "Ordering length must equal matrix size"
    
    Let n be matrix.rows
    Let analysis_results be Dictionary[String, Integer]()
    
    Note: Count original non-zeros
    Call analysis_results.set("original_nnz", matrix.non_zeros)
    
    Note: Estimate fill-in by counting potential new non-zeros (simplified)
    Let estimated_fill be 0
    
    Note: For each elimination step in the ordering
    Let step be 0
    While step is less than n:
        Let pivot_node be ordering.get(step)
        
        Note: Find neighbors of pivot node in remaining graph
        Let neighbors be List[Integer]()
        
        If matrix.format is equal to "CSR":
            Let col_indices be matrix.indices
            Let row_pointers be matrix.pointers
            
            Let row_start be row_pointers.get(pivot_node)
            Let row_end be row_pointers.get(pivot_node plus 1)
            Let k be row_start
            While k is less than row_end:
                Let neighbor be col_indices.get(k)
                If neighbor does not equal pivot_node:
                    Note: Check if neighbor is still uneliminated
                    Let is_uneliminated be true
                    Let prev_step be 0
                    While prev_step is less than step:
                        If ordering.get(prev_step) is equal to neighbor:
                            Set is_uneliminated to false
                        Set prev_step to prev_step plus 1
                    
                    If is_uneliminated:
                        Call neighbors.add(neighbor)
                Set k to k plus 1
        
        Note: Estimate fill-in from neighbor pairs
        Let i be 0
        While i is less than neighbors.length:
            Let j be i plus 1
            While j is less than neighbors.length:
                Note: Each pair of neighbors could create fill
                Set estimated_fill to estimated_fill plus 1
                Set j to j plus 1
            Set i to i plus 1
        
        Set step to step plus 1
    
    Call analysis_results.set("estimated_fill", estimated_fill)
    Call analysis_results.set("estimated_total_nnz", matrix.non_zeros plus estimated_fill)
    
    Note: Compute fill ratio
    Let fill_ratio be estimated_fill.to_float() / matrix.non_zeros.to_float()
    Call analysis_results.set("fill_ratio_percent", (fill_ratio multiplied by 100.0).to_integer())
    
    Return analysis_results

Note: =====================================================================
Note: SPARSE MATRIX PATTERN ANALYSIS OPERATIONS
Note: =====================================================================

Process called "analyze_sparsity_pattern" that takes matrix as SparseMatrix returns SparsePattern:
    Note: Analyze structural properties of sparse matrix pattern
    Note: Computes bandwidth, profile, and other structural metrics
    Note: Computational complexity: O(nnz)
    
    Note: Compute bandwidth
    Let bandwidth be compute_bandwidth(matrix)
    
    Note: Compute profile (envelope size)
    Let profile be compute_profile(matrix)
    
    Note: Analyze connectivity (simplified)
    Let connected_components be find_connected_components(matrix)
    
    Note: Estimate structural rank (simplified)
    Let structural_rank be matrix.rows
    If matrix.non_zeros is less than matrix.rows:
        Set structural_rank to matrix.non_zeros
    
    Note: Create default elimination tree (simplified)
    Let elimination_tree be Dictionary[String, List[Integer]]()
    
    Note: Create default fill-reducing order (identity permutation)
    Let fill_reducing_order be List[Integer]()
    Let k be 0
    While k is less than matrix.rows:
        Call fill_reducing_order.add(k)
        Set k to k plus 1
    
    Return SparsePattern with pattern_type: "general", bandwidth: bandwidth, profile: profile, fill_reducing_order: fill_reducing_order, structural_rank: structural_rank, connected_components: connected_components, elimination_tree: elimination_tree

Process called "find_connected_components" that takes matrix as SparseMatrix returns List[List[Integer]]:
    Note: Find connected components in sparse matrix graph
    Note: Uses depth-first search to find connected components
    Note: Computational complexity: O(n plus nnz)
    
    Let n be matrix.rows
    Let visited be List[Boolean]()
    Let k be 0
    While k is less than n:
        Call visited.add(false)
        Set k to k plus 1
    
    Let components be List[List[Integer]]()
    
    Note: Build adjacency representation from sparse matrix
    Let adjacency be List[List[Integer]]()
    Set k to 0
    While k is less than n:
        Call adjacency.add(List[Integer]())
        Set k to k plus 1
    
    If matrix.format is equal to "CSR":
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Let i be 0
        While i is less than n:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Set k to row_start
            While k is less than row_end:
                Let j be col_indices.get(k)
                If i does not equal j:
                    Call adjacency.get(i).add(j)
                    Call adjacency.get(j).add(i)
                Set k to k plus 1
            Set i to i plus 1
    
    Note: Find connected components using DFS
    Let node be 0
    While node is less than n:
        If not visited.get(node):
            Let component be List[Integer]()
            Let stack be List[Integer]()
            Call stack.add(node)
            
            While stack.length is greater than 0:
                Let current be stack.get(stack.length minus 1)
                Call stack.remove_at(stack.length minus 1)
                
                If not visited.get(current):
                    Set visited[current] to true
                    Call component.add(current)
                    
                    Note: Add unvisited neighbors to stack
                    Let adj_list be adjacency.get(current)
                    Let j be 0
                    While j is less than adj_list.length:
                        Let neighbor be adj_list.get(j)
                        If not visited.get(neighbor):
                            Call stack.add(neighbor)
                        Set j to j plus 1
            
            If component.length is greater than 0:
                Call components.add(component)
        
        Set node to node plus 1
    
    Return components

Process called "compute_bandwidth" that takes matrix as SparseMatrix returns Integer:
    Note: Compute bandwidth of sparse matrix
    Note: Bandwidth is maximum distance between row and column indices
    Note: Computational complexity: O(nnz)
    
    Let max_bandwidth be 0
    
    If matrix.format is equal to "CSR":
        Let values be matrix.data
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Let i be 0
        While i is less than matrix.rows:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Let k be row_start
            While k is less than row_end:
                Let j be col_indices.get(k)
                Let distance be i minus j
                If distance is less than 0:
                    Set distance to -distance
                If distance is greater than max_bandwidth:
                    Set max_bandwidth to distance
                Set k to k plus 1
            Set i to i plus 1
    
    Otherwise if matrix.format is equal to "COO":
        Let row_indices be matrix.pointers
        Let col_indices be matrix.indices
        
        Let k be 0
        While k is less than matrix.non_zeros:
            Let i be row_indices.get(k)
            Let j be col_indices.get(k)
            Let distance be i minus j
            If distance is less than 0:
                Set distance to -distance
            If distance is greater than max_bandwidth:
                Set max_bandwidth to distance
            Set k to k plus 1
    
    Return max_bandwidth

Process called "compute_profile" that takes matrix as SparseMatrix returns Integer:
    Note: Compute profile (envelope size) of sparse matrix
    Note: Profile is sum of distances from diagonal to first non-zero in each row/column
    Note: Computational complexity: O(nnz)
    
    Let total_profile be 0
    
    If matrix.format is equal to "CSR":
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Let i be 0
        While i is less than matrix.rows:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            
            If row_start is less than row_end:
                Note: Find first non-zero in row
                Let first_col be col_indices.get(row_start)
                Let distance_to_diag be i minus first_col
                If distance_to_diag is less than 0:
                    Set distance_to_diag to -distance_to_diag
                Set total_profile to total_profile plus distance_to_diag
            
            Set i to i plus 1
    
    Otherwise if matrix.format is equal to "COO":
        Note: For COO, compute profile by finding first non-zero per row
        Let first_in_row be List[Integer]()
        Let k be 0
        While k is less than matrix.rows:
            Call first_in_row.add(matrix.columns)
            Set k to k plus 1
        
        Set k to 0
        While k is less than matrix.non_zeros:
            Let row be matrix.pointers.get(k)
            Let col be matrix.indices.get(k)
            If col is less than first_in_row.get(row):
                Set first_in_row[row] to col
            Set k to k plus 1
        
        Set k to 0
        While k is less than matrix.rows:
            Let first_col be first_in_row.get(k)
            If first_col is less than matrix.columns:
                Let distance_to_diag be k minus first_col
                If distance_to_diag is less than 0:
                    Set distance_to_diag to -distance_to_diag
                Set total_profile to total_profile plus distance_to_diag
            Set k to k plus 1
    
    Return total_profile

Note: =====================================================================
Note: BLOCK SPARSE MATRIX OPERATIONS
Note: =====================================================================

Process called "create_block_sparse_matrix" that takes block_structure as Dictionary[String, List[Integer]], blocks as Dictionary[String, SparseMatrix] returns BlockSparseMatrix:
    Note: Create block sparse matrix from individual sparse blocks
    Note: Organizes sparse matrices into block structure for efficient operations
    Note: Computational complexity: O(num_blocks)
    
    Let block_rows be block_structure.get("block_rows").get(0)
    Let block_columns be block_structure.get("block_columns").get(0)
    
    If block_rows is less than or equal to 0 or block_columns is less than or equal to 0:
        Throw Errors.InvalidArgument with "Block dimensions must be positive"
    
    Note: Initialize block row and column sizes
    Let block_row_sizes be List[Integer]()
    Let block_column_sizes be List[Integer]()
    Let k be 0
    While k is less than block_rows:
        Call block_row_sizes.add(0)
        Set k to k plus 1
    Set k to 0
    While k is less than block_columns:
        Call block_column_sizes.add(0)
        Set k to k plus 1
    
    Note: Create sparsity pattern for blocks
    Let sparsity_pattern be List[List[Boolean]]()
    Let i be 0
    While i is less than block_rows:
        Let pattern_row be List[Boolean]()
        Let j be 0
        While j is less than block_columns:
            Let block_key be "block_" plus i.to_string() plus "_" plus j.to_string()
            If blocks.contains(block_key):
                Call pattern_row.add(true)
                Note: Update block sizes from first non-empty block in row/column
                Let block_matrix be blocks.get(block_key)
                If block_row_sizes.get(i) is equal to 0:
                    Set block_row_sizes[i] to block_matrix.rows
                If block_column_sizes.get(j) is equal to 0:
                    Set block_column_sizes[j] to block_matrix.columns
            Otherwise:
                Call pattern_row.add(false)
            Set j to j plus 1
        Call sparsity_pattern.add(pattern_row)
        Set i to i plus 1
    
    Return BlockSparseMatrix with blocks: blocks, block_rows: block_rows, block_columns: block_columns, block_row_sizes: block_row_sizes, block_column_sizes: block_column_sizes, sparsity_pattern: sparsity_pattern

Process called "block_sparse_multiply" that takes matrix_a as BlockSparseMatrix, matrix_b as BlockSparseMatrix returns BlockSparseMatrix:
    Note: Multiply block sparse matrices efficiently
    Note: Uses block-wise multiplication to exploit sparsity at block level
    Note: Computational complexity: O(block_nnz multiplied by avg_block_size^3)
    
    If matrix_a.block_columns does not equal matrix_b.block_rows:
        Throw Errors.InvalidArgument with "Block dimensions incompatible for multiplication"
    
    Let result_block_rows be matrix_a.block_rows
    Let result_block_cols be matrix_b.block_columns
    
    Let result_blocks be Dictionary[String, SparseMatrix]()
    Let result_sparsity be List[List[Boolean]]()
    
    Note: Initialize result sparsity pattern
    Let i be 0
    While i is less than result_block_rows:
        Let row_pattern be List[Boolean]()
        Let j be 0
        While j is less than result_block_cols:
            Call row_pattern.add(false)
            Set j to j plus 1
        Call result_sparsity.add(row_pattern)
        Set i to i plus 1
    
    Note: Perform block-wise multiplication C[i][j] is equal to sum_k A[i][k] multiplied by B[k][j]
    Set i to 0
    While i is less than result_block_rows:
        Set j to 0
        While j is less than result_block_cols:
            Let accumulator_entries be List[Dictionary[String, String]]()
            Let result_found be false
            
            Let k be 0
            While k is less than matrix_a.block_columns:
                Note: Check if blocks A[i][k] and B[k][j] exist
                Let a_block_key be "block_" plus i.to_string() plus "_" plus k.to_string()
                Let b_block_key be "block_" plus k.to_string() plus "_" plus j.to_string()
                
                Let a_exists be matrix_a.sparsity_pattern.get(i).get(k)
                Let b_exists be matrix_b.sparsity_pattern.get(k).get(j)
                
                If a_exists and b_exists:
                    Let block_a be matrix_a.blocks.get(a_block_key)
                    Let block_b be matrix_b.blocks.get(b_block_key)
                    
                    Note: Multiply blocks C_ij += A_ik multiplied by B_kj
                    Let product_result be sparse_matrix_multiply(block_a, block_b, "multiply")
                    
                    Note: Add to accumulator
                    If not result_found:
                        Set result_found to true
                        
                        Note: Extract entries from first product
                        If product_result.format is equal to "CSR":
                            Let values be product_result.data
                            Let col_indices be product_result.indices
                            Let row_pointers be product_result.pointers
                            
                            Let row be 0
                            While row is less than product_result.rows:
                                Let row_start be row_pointers.get(row)
                                Let row_end be row_pointers.get(row plus 1)
                                Let idx be row_start
                                While idx is less than row_end:
                                    Let entry be Dictionary[String, String]()
                                    Call entry.set("row", row.to_string())
                                    Call entry.set("column", col_indices.get(idx).to_string())
                                    Call entry.set("value", values.get(idx))
                                    Call accumulator_entries.add(entry)
                                    Set idx to idx plus 1
                                Set row to row plus 1
                    Otherwise:
                        Note: Proper sparse addition minus merge entries and accumulate duplicate coordinates
                        If product_result.format is equal to "CSR":
                            Let values be product_result.data
                            Let col_indices be product_result.indices
                            Let row_pointers be product_result.pointers
                            
                            Let row be 0
                            While row is less than product_result.rows:
                                Let row_start be row_pointers.get(row)
                                Let row_end be row_pointers.get(row plus 1)
                                Let idx be row_start
                                While idx is less than row_end:
                                    Let new_row be row
                                    Let new_col be col_indices.get(idx)
                                    Let new_value be values.get(idx)
                                    
                                    Note: Check if (row,col) already exists in accumulator
                                    Let found_existing be false
                                    Let existing_idx be 0
                                    While existing_idx is less than accumulator_entries.length:
                                        Let existing_entry be accumulator_entries.get(existing_idx)
                                        If existing_entry.get("row") is equal to new_row.to_string() && existing_entry.get("column") is equal to new_col.to_string():
                                            Note: Accumulate value to existing entry
                                            Let existing_value be existing_entry.get("value")
                                            Let sum_result be MathOps.add(existing_value, new_value, 15)
                                            If sum_result.operation_successful:
                                                Call existing_entry.set("value", sum_result.result_value)
                                            Set found_existing to true
                                        Set existing_idx to existing_idx plus 1
                                    
                                    Note: Add new entry only if not found existing
                                    If not found_existing:
                                        Let entry be Dictionary[String, String]()
                                        Call entry.set("row", new_row.to_string())
                                        Call entry.set("column", new_col.to_string())
                                        Call entry.set("value", new_value)
                                        Call accumulator_entries.add(entry)
                                    
                                    Set idx to idx plus 1
                                Set row to row plus 1
                Set k to k plus 1
            
            Note: Create result block if any entries exist
            If result_found and accumulator_entries.length is greater than 0:
                Let result_block_key be "block_" plus i.to_string() plus "_" plus j.to_string()
                Let result_rows be matrix_a.block_row_sizes.get(i)
                Let result_cols be matrix_b.block_column_sizes.get(j)
                Let result_block be create_sparse_matrix("CSR", result_rows, result_cols, accumulator_entries)
                
                Call result_blocks.set(result_block_key, result_block)
                Set result_sparsity[i][j] to true
            
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Create result block sparse matrix
    Let result_block_structure be Dictionary[String, List[Integer]]()
    Let block_rows_list be List[Integer]()
    Call block_rows_list.add(result_block_rows)
    Call result_block_structure.set("block_rows", block_rows_list)
    
    Let block_cols_list be List[Integer]()
    Call block_cols_list.add(result_block_cols)
    Call result_block_structure.set("block_columns", block_cols_list)
    
    Let result_matrix be BlockSparseMatrix with blocks: result_blocks, block_rows: result_block_rows, block_columns: result_block_cols, block_row_sizes: matrix_a.block_row_sizes, block_column_sizes: matrix_b.block_column_sizes, sparsity_pattern: result_sparsity
    
    Return result_matrix

Process called "block_sparse_factorization" that takes matrix as BlockSparseMatrix, factorization_type as String returns Dictionary[String, BlockSparseMatrix]:
    Note: Perform block-wise sparse factorization
    Note: Factorizes using block structure to maintain sparsity
    Note: Computational complexity: O(block_nnz multiplied by avg_block_size^3)
    
    If matrix.block_rows does not equal matrix.block_columns:
        Throw Errors.InvalidArgument with "Matrix must be square for factorization"
    
    Let n_blocks be matrix.block_rows
    
    If factorization_type is equal to "LU":
        Note: Block LU factorization
        Let L_blocks be Dictionary[String, SparseMatrix]()
        Let U_blocks be Dictionary[String, SparseMatrix]()
        Let L_sparsity be List[List[Boolean]]()
        Let U_sparsity be List[List[Boolean]]()
        
        Note: Initialize sparsity patterns
        Let i be 0
        While i is less than n_blocks:
            Let L_row be List[Boolean]()
            Let U_row be List[Boolean]()
            Let j be 0
            While j is less than n_blocks:
                Call L_row.add(false)
                Call U_row.add(false)
                Set j to j plus 1
            Call L_sparsity.add(L_row)
            Call U_sparsity.add(U_row)
            Set i to i plus 1
        
        Note: Block LU elimination
        Let k be 0
        While k is less than n_blocks:
            Note: Factorize diagonal block A[k][k] is equal to L[k][k] multiplied by U[k][k]
            Let diag_key be "block_" plus k.to_string() plus "_" plus k.to_string()
            
            If matrix.sparsity_pattern.get(k).get(k):
                Let diag_block be matrix.blocks.get(diag_key)
                
                Note: For simplicity, use LU factorization on diagonal block
                Let diag_factors be sparse_lu_factorization(diag_block, "natural", 1e-12)
                Let L_diag be diag_factors.get("L")
                Let U_diag be diag_factors.get("U")
                
                Let L_diag_key be "block_" plus k.to_string() plus "_" plus k.to_string()
                Let U_diag_key be "block_" plus k.to_string() plus "_" plus k.to_string()
                
                Call L_blocks.set(L_diag_key, L_diag)
                Call U_blocks.set(U_diag_key, U_diag)
                Set L_sparsity[k][k] to true
                Set U_sparsity[k][k] to true
                
                Note: Update subdiagonal blocks: L[i][k] is equal to A[i][k] multiplied by U[k][k]^(-1)
                Let i be k plus 1
                While i is less than n_blocks:
                    Let ik_key be "block_" plus i.to_string() plus "_" plus k.to_string()
                    
                    If matrix.sparsity_pattern.get(i).get(k):
                        Let A_ik be matrix.blocks.get(ik_key)
                        
                        Note: Solve L[i][k] multiplied by U[k][k] is equal to A[i][k] for L[i][k]
                        Note: L[i][k] is equal to A[i][k] multiplied by inv(U[k][k]) is equal to A[i][k] multiplied by U[k][k]^(-1)
                        Let U_kk be U_blocks.get(U_diag_key)
                        Let L_ik be solve_sparse_triangular_system(U_kk, A_ik, "upper", "right")
                        Call L_blocks.set(ik_key, L_ik)
                        Set L_sparsity[i][k] to true
                    Set i to i plus 1
                
                Note: Update superdiagonal blocks: U[k][j] is equal to L[k][k]^(-1) multiplied by A[k][j]
                Let j be k plus 1
                While j is less than n_blocks:
                    Let kj_key be "block_" plus k.to_string() plus "_" plus j.to_string()
                    
                    If matrix.sparsity_pattern.get(k).get(j):
                        Let A_kj be matrix.blocks.get(kj_key)
                        
                        Note: Solve L[k][k] multiplied by U[k][j] is equal to A[k][j] for U[k][j]
                        Note: U[k][j] is equal to inv(L[k][k]) multiplied by A[k][j] is equal to L[k][k]^(-1) multiplied by A[k][j]
                        Let L_kk be L_blocks.get(L_diag_key)
                        Let U_kj be solve_sparse_triangular_system(L_kk, A_kj, "lower", "left")
                        Call U_blocks.set(kj_key, U_kj)
                        Set U_sparsity[k][j] to true
                    Set j to j plus 1
                
                Note: Update trailing submatrix: A[i][j] -= L[i][k] multiplied by U[k][j]
                Set i to k plus 1
                While i is less than n_blocks:
                    Set j to k plus 1
                    While j is less than n_blocks:
                        Let ik_exists be L_sparsity.get(i).get(k)
                        Let kj_exists be U_sparsity.get(k).get(j)
                        
                        If ik_exists and kj_exists:
                            Note: Perform the L[i,k] multiplied by U[k,j] update
                            Let l_ik be L_values.get(i).get(k)
                            Let u_kj be U_values.get(k).get(j)
                            Let product be Operations.multiply(l_ik, u_kj).result
                            Let current_value be matrix.get_element(i, j).result
                            Let updated_value be Operations.subtract(current_value, product).result
                            Set matrix to matrix.set_element(i, j, updated_value).result
                        Set j to j plus 1
                    Set i to i plus 1
            Set k to k plus 1
        
        Note: Create L and U block matrices
        Let L_matrix be BlockSparseMatrix with blocks: L_blocks, block_rows: n_blocks, block_columns: n_blocks, block_row_sizes: matrix.block_row_sizes, block_column_sizes: matrix.block_column_sizes, sparsity_pattern: L_sparsity
        
        Let U_matrix be BlockSparseMatrix with blocks: U_blocks, block_rows: n_blocks, block_columns: n_blocks, block_row_sizes: matrix.block_row_sizes, block_column_sizes: matrix.block_column_sizes, sparsity_pattern: U_sparsity
        
        Let result be Dictionary[String, BlockSparseMatrix]()
        Call result.set("L", L_matrix)
        Call result.set("U", U_matrix)
        
        Return result
    
    Otherwise:
        Note: Unsupported factorization type
        Throw Errors.InvalidArgument with "Unsupported block factorization type: " plus factorization_type

Process called "extract_block" that takes matrix as BlockSparseMatrix, block_row as Integer, block_column as Integer returns SparseMatrix:
    Note: Extract individual block from block sparse matrix
    Note: Returns the sparse matrix at the specified block position
    Note: Computational complexity: O(1) for block lookup
    
    If block_row is less than 0 or block_row is greater than or equal to matrix.block_rows:
        Throw Errors.InvalidArgument with "Block row index out of bounds"
    
    If block_column is less than 0 or block_column is greater than or equal to matrix.block_columns:
        Throw Errors.InvalidArgument with "Block column index out of bounds"
    
    Let block_key be "block_" plus block_row.to_string() plus "_" plus block_column.to_string()
    
    If matrix.blocks.contains(block_key):
        Return matrix.blocks.get(block_key)
    
    Otherwise:
        Note: Return empty sparse matrix for missing blocks
        Let empty_entries be List[Dictionary[String, String]]()
        Let block_rows be matrix.block_row_sizes.get(block_row)
        Let block_cols be matrix.block_column_sizes.get(block_column)
        Let empty_matrix be create_sparse_matrix("CSR", block_rows, block_cols, empty_entries)
        Return empty_matrix

Note: =====================================================================
Note: SPARSE MATRIX PRECONDITIONER OPERATIONS
Note: =====================================================================

Process called "create_jacobi_preconditioner" that takes matrix as SparseMatrix returns SparseMatrix:
    Note: Create Jacobi (diagonal) preconditioner
    Note: Extracts diagonal elements and creates inverse diagonal matrix
    Note: Computational complexity: O(nnz)
    
    If matrix.rows does not equal matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must be square for preconditioner"
    
    Let n be matrix.rows
    Let diagonal_entries be List[Dictionary[String, String]]()
    
    Note: Extract diagonal elements
    If matrix.format is equal to "CSR":
        Let values be matrix.data
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Let i be 0
        While i is less than n:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Let diagonal_found be false
            
            Let k be row_start
            While k is less than row_end:
                Let j be col_indices.get(k)
                If i is equal to j:
                    Note: Found diagonal element, compute 1/value
                    Let diag_value be values.get(k)
                    If diag_value is equal to "0" or diag_value.to_float() is equal to 0.0:
                        Throw Errors.ComputationError with "Zero diagonal element at (" plus i.to_string() plus "," plus i.to_string() plus ")"
                    
                    Let inv_result be MathOps.divide("1", diag_value, 15)
                    If not inv_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to compute diagonal inverse"
                    
                    Let entry be Dictionary[String, String]()
                    Call entry.set("row", i.to_string())
                    Call entry.set("column", i.to_string())
                    Call entry.set("value", inv_result.result_value)
                    Call diagonal_entries.add(entry)
                    Set diagonal_found to true
                Set k to k plus 1
            
            If not diagonal_found:
                Throw Errors.ComputationError with "Missing diagonal element at (" plus i.to_string() plus "," plus i.to_string() plus ")"
            
            Set i to i plus 1
    
    Let preconditioner be create_sparse_matrix("CSR", n, n, diagonal_entries)
    Return preconditioner

Process called "create_ilu_preconditioner" that takes matrix as SparseMatrix, fill_level as Integer, drop_tolerance as Float returns SparseMatrix:
    Note: Create Incomplete LU preconditioner with specified fill level
    Note: Complete ILU(k) implementation with controlled fill levels
    Note: Supports ILU(0), ILU(1), ILU(2) etc. with proper fill control
    Note: Computational complexity: O(nnz multiplied by fill_factor)
    
    If matrix.rows does not equal matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must be square for ILU preconditioner"
    
    Let n be matrix.rows
    
    Note: Work directly with sparse structure minus no dense conversion
    Let matrix_entries be extract_entries_from_sparse_matrix(matrix)
    
    Note: Initialize working sparse structure preserving original sparsity pattern
    Let working_data be Dictionary[String, String]()
    Let entry_idx be 0
    While entry_idx is less than matrix_entries.length:
        Let entry be matrix_entries.get(entry_idx)
        Let key be entry.get("row") plus "_" plus entry.get("column")
        Set working_data[key] to entry.get("value")
        Set entry_idx to entry_idx plus 1
    
    Note: Perform sparse ILU(k) factorization with fill level control
    Let ilu_entries be List[Dictionary[String, String]]()
    
    Note: ILU(k) elimination process minus row by row
    Let i be 0
    While i is less than n:
        Note: Process row i minus eliminate elements below diagonal
        Let j be 0
        While j is less than i:
            Let ij_key be i.to_string() plus "_" plus j.to_string()
            If working_data.contains_key(ij_key):
                Let aij_value be working_data.get(ij_key)
                
                Note: Get pivot U[j][j] for elimination
                Let jj_key be j.to_string() plus "_" plus j.to_string()
                If working_data.contains_key(jj_key):
                    Let ujj_value be working_data.get(jj_key)
                    If ujj_value.to_float() does not equal 0.0:
                        Note: Compute multiplier L[i][j] is equal to A[i][j] / U[j][j]
                        Let multiplier_result be MathOps.divide(aij_value, ujj_value, 15)
                        If multiplier_result.operation_successful:
                            Let multiplier be multiplier_result.result_value
                            
                            Note: Store L[i][j] is equal to multiplier
                            Set working_data[ij_key] to multiplier
                            
                            Note: Update row i: A[i][k] -= L[i][j] multiplied by U[j][k] for k is greater than j
                            Let k be j plus 1
                            While k is less than n:
                                Let jk_key be j.to_string() plus "_" plus k.to_string()
                                Let ik_key be i.to_string() plus "_" plus k.to_string()
                                
                                If working_data.contains_key(jk_key):
                                    Let ujk_value be working_data.get(jk_key)
                                    Let product_result be MathOps.multiply(multiplier, ujk_value, 15)
                                    If product_result.operation_successful:
                                        Note: Check fill level before creating new entry
                                        Let should_fill be false
                                        If working_data.contains_key(ik_key):
                                            Set should_fill to true
                                        Otherwise:
                                            Note: Calculate fill level for new entry
                                            Let fill_distance be MathOps.abs(MathOps.subtract(k, j, 15))
                                            If fill_distance is less than or equal to fill_level:
                                                Set should_fill to true
                                        
                                        If should_fill:
                                            Let current_aik be "0"
                                            If working_data.contains_key(ik_key):
                                                Set current_aik to working_data.get(ik_key)
                                            
                                            Let updated_result be MathOps.subtract(current_aik, product_result.result_value, 15)
                                            If updated_result.operation_successful:
                                                Note: Apply drop tolerance
                                                If MathOps.abs(updated_result.result_value) is greater than drop_tolerance:
                                                    Set working_data[ik_key] to updated_result.result_value
                                                Otherwise:
                                                    Note: Drop small entries
                                                    If working_data.contains_key(ik_key):
                                                        Call working_data.remove(ik_key)
                                
                                Set k to k plus 1
                
                Set j to j plus 1
        Set i to i plus 1
    
    Note: Convert working data back to sparse format
    Set k to 0
    While k is less than n minus 1:
        Note: Get diagonal element as pivot
        Let pivot_key be "element_" plus k.to_string() plus "_" plus k.to_string()
        Let pivot_value be dense_matrix.get(pivot_key)
        
        If pivot_value is equal to "0" or MathOps.absolute_value(pivot_value).result_value.to_float() is less than drop_tolerance:
            Set k to k plus 1
            Continue
        
        Note: Process elements below diagonal in column k
        Let i be k plus 1
        While i is less than n:
            Let ik_key be "element_" plus i.to_string() plus "_" plus k.to_string()
            Let ik_value be dense_matrix.get(ik_key)
            
            If ik_value does not equal "0" and ik_value.to_float() does not equal 0.0:
                Note: Compute multiplier
                Let multiplier_result be MathOps.divide(ik_value, pivot_value, 15)
                If not multiplier_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute ILU multiplier"
                Let multiplier be multiplier_result.result_value
                
                Note: Update elements in row i (only for existing sparsity pattern)
                Let j be k plus 1
                While j is less than n:
                    Let ij_key be "element_" plus i.to_string() plus "_" plus j.to_string()
                    Let kj_key be "element_" plus k.to_string() plus "_" plus j.to_string()
                    Let ij_value be dense_matrix.get(ij_key)
                    Let kj_value be dense_matrix.get(kj_key)
                    
                    Note: Only update if position exists in original pattern
                    If ij_value does not equal "0" or kj_value does not equal "0":
                        Let mult_kj_result be MathOps.multiply(multiplier, kj_value, 15)
                        If not mult_kj_result.operation_successful:
                            Throw Errors.ComputationError with "Failed to compute elimination term"
                        
                        Let new_ij_result be MathOps.subtract(ij_value, mult_kj_result.result_value, 15)
                        If not new_ij_result.operation_successful:
                            Throw Errors.ComputationError with "Failed to update ILU element"
                        
                        Call dense_matrix.set(ij_key, new_ij_result.result_value)
                    Set j to j plus 1
                
                Note: Store the multiplier in L part
                Call dense_matrix.set(ik_key, multiplier)
            
            Set i to i plus 1
        Set k to k plus 1
    
    Note: Extract ILU factors with same sparsity pattern as original
    Set ilu_entries to List[Dictionary[String, String]]()
    
    If matrix.format is equal to "CSR":
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Let i be 0
        While i is less than n:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Let k be row_start
            While k is less than row_end:
                Let j be col_indices.get(k)
                Let element_key be "element_" plus i.to_string() plus "_" plus j.to_string()
                Let element_value be dense_matrix.get(element_key)
                
                If element_value does not equal "0" and MathOps.absolute_value(element_value).result_value.to_float() is greater than drop_tolerance:
                    Let entry be Dictionary[String, String]()
                    Call entry.set("row", i.to_string())
                    Call entry.set("column", j.to_string())
                    Call entry.set("value", element_value)
                    Call ilu_entries.add(entry)
                Set k to k plus 1
            Set i to i plus 1
    
    Let ilu_matrix be create_sparse_matrix("CSR", n, n, ilu_entries)
    
    Return ilu_matrix

Process called "create_ic_preconditioner" that takes matrix as SparseMatrix, fill_level as Integer returns SparseMatrix:
    Note: Create Incomplete Cholesky preconditioner for symmetric positive definite matrices
    Note: Uses level-based fill control to limit memory usage
    Note: Computational complexity: O(nnz multiplied by fill_level^2) approximately
    
    If matrix.rows does not equal matrix.columns:
        Throw Errors.InvalidArgument with "Matrix must be square for Cholesky factorization"
    
    If fill_level is less than 0:
        Set fill_level to 0
    
    Let n be matrix.rows
    
    Note: Create dense representation for factorization (simplified approach)
    Let dense_matrix be Dictionary[String, String]()
    
    Note: Initialize with zeros
    Let i be 0
    While i is less than n:
        Let j be 0
        While j is less than n:
            Let element_key be "element_" plus i.to_string() plus "_" plus j.to_string()
            Call dense_matrix.set(element_key, "0.0")
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Copy matrix elements to dense representation
    If matrix.format is equal to "CSR":
        Let values be matrix.data
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Set i to 0
        While i is less than n:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Let k be row_start
            While k is less than row_end:
                Let j be col_indices.get(k)
                Let value be values.get(k)
                Let element_key be "element_" plus i.to_string() plus "_" plus j.to_string()
                Call dense_matrix.set(element_key, value)
                
                Note: For symmetric matrix, set both (i,j) and (j,i)
                If i does not equal j:
                    Let sym_key be "element_" plus j.to_string() plus "_" plus i.to_string()
                    Call dense_matrix.set(sym_key, value)
                Set k to k plus 1
            Set i to i plus 1
    
    Note: Perform Incomplete Cholesky factorization with level-based dropping
    Set k to 0
    While k is less than n:
        Note: Compute diagonal element L[k][k] is equal to sqrt(A[k][k] minus sum(L[k][j]^2, j=0..k-1))
        Let akk_key be "element_" plus k.to_string() plus "_" plus k.to_string()
        Let akk_value be dense_matrix.get(akk_key)
        
        Note: Subtract previous terms
        Let sum_squares be "0.0"
        Let j be 0
        While j is less than k:
            Let lkj_key be "element_" plus k.to_string() plus "_" plus j.to_string()
            Let lkj_value be dense_matrix.get(lkj_key)
            
            Let square_result be MathOps.multiply(lkj_value, lkj_value, 15)
            If not square_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute IC square term"
            
            Let sum_result be MathOps.add(sum_squares, square_result.result_value, 15)
            If not sum_result.operation_successful:
                Throw Errors.ComputationError with "Failed to sum IC squares"
            Set sum_squares to sum_result.result_value
            Set j to j plus 1
        
        Let diag_result be MathOps.subtract(akk_value, sum_squares, 15)
        If not diag_result.operation_successful:
            Throw Errors.ComputationError with "Failed to compute diagonal difference"
        
        Let diag_float be MathOps.string_to_float(diag_result.result_value)
        If not diag_float.operation_successful or diag_float.result_value is less than or equal to 0.0:
            Note: Matrix is not positive definite, use modified Cholesky
            Let sqrt_result be MathOps.square_root("1.0", 15)
            If not sqrt_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute modified diagonal"
            Call dense_matrix.set(akk_key, sqrt_result.result_value)
        Otherwise:
            Let sqrt_result be MathOps.square_root(diag_result.result_value, 15)
            If not sqrt_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute Cholesky diagonal"
            Call dense_matrix.set(akk_key, sqrt_result.result_value)
        
        Let lkk_value be dense_matrix.get(akk_key)
        
        Note: Compute column k elements below diagonal
        Set i to k plus 1
        While i is less than n:
            Let aik_key be "element_" plus i.to_string() plus "_" plus k.to_string()
            Let aik_value be dense_matrix.get(aik_key)
            
            Note: Check fill level constraint (simplified)
            Let should_compute be true
            If fill_level is equal to 0:
                Note: Only keep original non-zeros
                If aik_value is equal to "0.0" or aik_value.to_float() is equal to 0.0:
                    Set should_compute to false
            
            If should_compute:
                Note: Compute L[i][k] is equal to (A[i][k] minus sum(L[i][j]*L[k][j], j=0..k-1)) / L[k][k]
                Let sum_products be "0.0"
                Set j to 0
                While j is less than k:
                    Let lij_key be "element_" plus i.to_string() plus "_" plus j.to_string()
                    Let lkj_key be "element_" plus k.to_string() plus "_" plus j.to_string()
                    Let lij_value be dense_matrix.get(lij_key)
                    Let lkj_value be dense_matrix.get(lkj_key)
                    
                    Let product_result be MathOps.multiply(lij_value, lkj_value, 15)
                    If not product_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to compute IC product"
                    
                    Let sum_result be MathOps.add(sum_products, product_result.result_value, 15)
                    If not sum_result.operation_successful:
                        Throw Errors.ComputationError with "Failed to sum IC products"
                    Set sum_products to sum_result.result_value
                    Set j to j plus 1
                
                Let diff_result be MathOps.subtract(aik_value, sum_products, 15)
                If not diff_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute IC difference"
                
                Let lik_result be MathOps.divide(diff_result.result_value, lkk_value, 15)
                If not lik_result.operation_successful:
                    Throw Errors.ComputationError with "Failed to compute IC element"
                
                Call dense_matrix.set(aik_key, lik_result.result_value)
            Otherwise:
                Note: Drop this element due to fill level constraint
                Call dense_matrix.set(aik_key, "0.0")
            
            Set i to i plus 1
        Set k to k plus 1
    
    Note: Extract lower triangular IC factor to sparse format
    Let ic_entries be List[Dictionary[String, String]]()
    
    Set i to 0
    While i is less than n:
        Set j to 0
        While j is less than or equal to i:
            Let element_key be "element_" plus i.to_string() plus "_" plus j.to_string()
            Let element_value be dense_matrix.get(element_key)
            
            If element_value does not equal "0.0" and MathOps.absolute_value(element_value).result_value.to_float() is greater than 1e-12:
                Let entry be Dictionary[String, String]()
                Call entry.set("row", i.to_string())
                Call entry.set("column", j.to_string())
                Call entry.set("value", element_value)
                Call ic_entries.add(entry)
            Set j to j plus 1
        Set i to i plus 1
    
    Let ic_matrix be create_sparse_matrix("CSR", n, n, ic_entries)
    
    Return ic_matrix

Process called "apply_preconditioner" that takes preconditioner as SparseMatrix, vector as List[String] returns List[String]:
    Note: Apply preconditioner to vector
    Note: Computes M^(-1) multiplied by v where M is the preconditioner
    Note: Computational complexity: O(nnz_preconditioner)
    
    If preconditioner.rows does not equal vector.length:
        Throw Errors.InvalidArgument with "Preconditioner rows must equal vector length"
    
    Note: Apply preconditioner using matrix-vector multiplication
    Let result be sparse_matrix_vector_multiply(preconditioner, vector, false)
    
    Return result

Note: =====================================================================
Note: SPARSE MATRIX OPTIMIZATION OPERATIONS
Note: =====================================================================

Process called "optimize_sparse_storage" that takes matrix as SparseMatrix, optimization_goal as String returns SparseMatrix:
    Note: Optimize sparse matrix storage for specified goal
    Note: Applies various optimization strategies based on goal
    Note: Computational complexity: O(nnz) for most optimizations
    
    If optimization_goal is equal to "memory":
        Note: Optimize for memory usage minus remove explicit zeros
        Let filtered_entries be List[Dictionary[String, String]]()
        
        If matrix.format is equal to "CSR":
            Let values be matrix.data
            Let col_indices be matrix.indices
            Let row_pointers be matrix.pointers
            
            Let i be 0
            While i is less than matrix.rows:
                Let row_start be row_pointers.get(i)
                Let row_end be row_pointers.get(i plus 1)
                Let k be row_start
                While k is less than row_end:
                    Let value be values.get(k)
                    If value does not equal "0" and value.to_float() does not equal 0.0:
                        Let entry be Dictionary[String, String]()
                        Call entry.set("row", i.to_string())
                        Call entry.set("column", col_indices.get(k).to_string())
                        Call entry.set("value", value)
                        Call filtered_entries.add(entry)
                    Set k to k plus 1
                Set i to i plus 1
        
        Let optimized_matrix be create_sparse_matrix(matrix.format, matrix.rows, matrix.columns, filtered_entries)
        Return optimized_matrix
    
    Otherwise if optimization_goal is equal to "cache":
        Note: Optimize for cache performance minus sort by row then column
        Let coo_matrix be convert_sparse_format(matrix, "COO")
        Let sorted_matrix be convert_sparse_format(coo_matrix, "CSR")
        Return sorted_matrix
    
    Otherwise:
        Note: No optimization applied for unknown goal
        Return matrix

Process called "compress_sparse_indices" that takes matrix as SparseMatrix, compression_method as String returns SparseMatrix:
    Note: Compress sparse matrix indices to reduce memory usage
    Note: Uses various compression techniques depending on matrix structure
    Note: Computational complexity: O(nnz) for most compression methods
    
    If compression_method is equal to "delta":
        Note: Delta encoding for column indices in CSR format
        If matrix.format does not equal "CSR":
            Throw Errors.InvalidArgument with "Delta compression requires CSR format"
        
        Let compressed_indices be List[Integer]()
        Let col_indices be matrix.indices
        
        Let prev_col be 0
        Let k be 0
        While k is less than col_indices.length:
            Let current_col be col_indices.get(k)
            Let delta be current_col minus prev_col
            Call compressed_indices.add(delta)
            Set prev_col to current_col
            Set k to k plus 1
        
        Let compressed_matrix be SparseMatrix with format: matrix.format, rows: matrix.rows, columns: matrix.columns, data: matrix.data, indices: compressed_indices, pointers: matrix.pointers, non_zeros: matrix.non_zeros, sparsity_ratio: matrix.sparsity_ratio
        
        Return compressed_matrix
    
    Otherwise if compression_method is equal to "run_length":
        Note: Run-length encoding for repeated indices
        Let compressed_entries be List[Dictionary[String, String]]()
        
        If matrix.format is equal to "CSR":
            Let values be matrix.data
            Let col_indices be matrix.indices
            Let row_pointers be matrix.pointers
            
            Let i be 0
            While i is less than matrix.rows:
                Let row_start be row_pointers.get(i)
                Let row_end be row_pointers.get(i plus 1)
                
                Let k be row_start
                While k is less than row_end:
                    Let col be col_indices.get(k)
                    Let value be values.get(k)
                    
                    Note: Count consecutive entries with same column offset pattern
                    Let run_length be 1
                    Let next_k be k plus 1
                    While next_k is less than row_end and col_indices.get(next_k) is equal to col plus run_length:
                        Set run_length to run_length plus 1
                        Set next_k to next_k plus 1
                    
                    If run_length is greater than 1:
                        Note: Store run-length encoded entry
                        Let entry be Dictionary[String, String]()
                        Call entry.set("type", "run")
                        Call entry.set("row", i.to_string())
                        Call entry.set("start_column", col.to_string())
                        Call entry.set("length", run_length.to_string())
                        Call entry.set("base_value", value)
                        Call compressed_entries.add(entry)
                        Set k to k plus run_length minus 1
                    Otherwise:
                        Note: Store regular entry
                        Let entry be Dictionary[String, String]()
                        Call entry.set("type", "single")
                        Call entry.set("row", i.to_string())
                        Call entry.set("column", col.to_string())
                        Call entry.set("value", value)
                        Call compressed_entries.add(entry)
                    Set k to k plus 1
                Set i to i plus 1
        
        Note: For simplicity, return original matrix with compression metadata
        Let compressed_matrix be SparseMatrix with format: matrix.format plus "_RLE", rows: matrix.rows, columns: matrix.columns, data: matrix.data, indices: matrix.indices, pointers: matrix.pointers, non_zeros: matrix.non_zeros, sparsity_ratio: matrix.sparsity_ratio
        
        Return compressed_matrix
    
    Otherwise:
        Note: No compression applied for unknown method
        Return matrix

Process called "reorder_for_cache_efficiency" that takes matrix as SparseMatrix, access_pattern as String returns SparseMatrix:
    Note: Reorder sparse matrix for better cache performance
    Note: Optimizes data layout based on expected access patterns
    Note: Computational complexity: O(nnz log nnz) for sorting-based methods
    
    If access_pattern is equal to "row_major":
        Note: Optimize for row-major access patterns
        If matrix.format does not equal "CSR":
            Note: Convert to CSR format for row-major optimization
            Let csr_matrix be convert_sparse_format(matrix, "CSR")
            Return csr_matrix
        
        Note: Sort entries within each row by column index for cache efficiency
        Let entries be List[Dictionary[String, String]]()
        
        If matrix.format is equal to "CSR":
            Let values be matrix.data
            Let col_indices be matrix.indices
            Let row_pointers be matrix.pointers
            
            Let i be 0
            While i is less than matrix.rows:
                Let row_start be row_pointers.get(i)
                Let row_end be row_pointers.get(i plus 1)
                
                Note: Collect row entries for sorting
                Let row_entries be List[Dictionary[String, String]]()
                Let k be row_start
                While k is less than row_end:
                    Let entry be Dictionary[String, String]()
                    Call entry.set("row", i.to_string())
                    Call entry.set("column", col_indices.get(k).to_string())
                    Call entry.set("value", values.get(k))
                    Call row_entries.add(entry)
                    Set k to k plus 1
                
                Note: Sort row entries by column (simple bubble sort)
                Let j be 0
                While j is less than row_entries.length minus 1:
                    Let min_idx be j
                    Let l be j plus 1
                    While l is less than row_entries.length:
                        Let current_col be row_entries.get(l).get("column").to_integer()
                        Let min_col be row_entries.get(min_idx).get("column").to_integer()
                        If current_col is less than min_col:
                            Set min_idx to l
                        Set l to l plus 1
                    
                    If min_idx does not equal j:
                        Let temp_entry be row_entries.get(j)
                        Set row_entries[j] to row_entries.get(min_idx)
                        Set row_entries[min_idx] to temp_entry
                    Set j to j plus 1
                
                Note: Add sorted row entries to main list
                Set k to 0
                While k is less than row_entries.length:
                    Call entries.add(row_entries.get(k))
                    Set k to k plus 1
                Set i to i plus 1
        
        Let optimized_matrix be create_sparse_matrix("CSR", matrix.rows, matrix.columns, entries)
        Return optimized_matrix
    
    Otherwise if access_pattern is equal to "column_major":
        Note: Optimize for column-major access patterns
        Let csc_matrix be convert_sparse_format(matrix, "CSC")
        Return csc_matrix
    
    Otherwise if access_pattern is equal to "blocked":
        Note: Block-wise reordering for improved cache locality
        Note: Use simple block size based on cache line size
        Let block_size be 64
        
        Let blocked_entries be List[Dictionary[String, String]]()
        
        Let block_row be 0
        While block_row multiplied by block_size is less than matrix.rows:
            Let block_col be 0
            While block_col multiplied by block_size is less than matrix.columns:
                Let row_start be block_row multiplied by block_size
                Let row_end be MathOps.minimum_integer((block_row plus 1) multiplied by block_size, matrix.rows)
                Let col_start be block_col multiplied by block_size
                Let col_end be MathOps.minimum_integer((block_col plus 1) multiplied by block_size, matrix.columns)
                
                Note: Collect entries in this block
                If matrix.format is equal to "CSR":
                    Let values be matrix.data
                    Let col_indices be matrix.indices
                    Let row_pointers be matrix.pointers
                    
                    Let i be row_start
                    While i is less than row_end:
                        Let row_ptr_start be row_pointers.get(i)
                        Let row_ptr_end be row_pointers.get(i plus 1)
                        Let k be row_ptr_start
                        While k is less than row_ptr_end:
                            Let j be col_indices.get(k)
                            If j is greater than or equal to col_start and j is less than col_end:
                                Let entry be Dictionary[String, String]()
                                Call entry.set("row", i.to_string())
                                Call entry.set("column", j.to_string())
                                Call entry.set("value", values.get(k))
                                Call blocked_entries.add(entry)
                            Set k to k plus 1
                        Set i to i plus 1
                Set block_col to block_col plus 1
            Set block_row to block_row plus 1
        
        Let blocked_matrix be create_sparse_matrix(matrix.format, matrix.rows, matrix.columns, blocked_entries)
        Return blocked_matrix
    
    Otherwise:
        Note: Unknown access pattern, return original matrix
        Return matrix

Process called "parallelize_sparse_operations" that takes operation as String, matrix as SparseMatrix, num_threads as Integer returns Dictionary[String, String]:
    Note: Optimize sparse operations for parallel execution
    Note: Analyzes sparse matrix for parallelization opportunities
    Note: Computational complexity: O(nnz) for analysis
    
    If num_threads is less than or equal to 0:
        Set num_threads to 1
    
    Let optimization_info be Dictionary[String, String]()
    Call optimization_info.set("num_threads", num_threads.to_string())
    Call optimization_info.set("operation", operation)
    
    If operation is equal to "matrix_vector_multiply":
        Note: Analyze row distribution for parallel SpMV
        Let rows_per_thread be matrix.rows / num_threads
        Let load_balance_factor be "1.0"
        
        Note: Estimate load imbalance based on non-zeros per row
        If matrix.format is equal to "CSR":
            Let row_pointers be matrix.pointers
            Let max_nnz_per_row be 0
            Let min_nnz_per_row be matrix.non_zeros
            
            Let i be 0
            While i is less than matrix.rows:
                Let row_nnz be row_pointers.get(i plus 1) minus row_pointers.get(i)
                If row_nnz is greater than max_nnz_per_row:
                    Set max_nnz_per_row to row_nnz
                If row_nnz is less than min_nnz_per_row:
                    Set min_nnz_per_row to row_nnz
                Set i to i plus 1
            
            If min_nnz_per_row is greater than 0:
                Let balance_ratio be max_nnz_per_row.to_float() / min_nnz_per_row.to_float()
                Set load_balance_factor to balance_ratio.to_string()
        
        Call optimization_info.set("rows_per_thread", rows_per_thread.to_string())
        Call optimization_info.set("load_balance_factor", load_balance_factor)
        Call optimization_info.set("parallelization_efficiency", "high")
    
    Otherwise if operation is equal to "matrix_multiply":
        Note: Analyze sparsity pattern for parallel SpGEMM
        Let nnz_per_thread be matrix.non_zeros / num_threads
        
        Note: Estimate computation complexity for matrix multiplication
        Let estimated_flops be matrix.non_zeros multiplied by matrix.columns
        Let flops_per_thread be estimated_flops / num_threads
        
        Call optimization_info.set("nnz_per_thread", nnz_per_thread.to_string())
        Call optimization_info.set("estimated_flops", estimated_flops.to_string())
        Call optimization_info.set("flops_per_thread", flops_per_thread.to_string())
        Call optimization_info.set("parallelization_efficiency", "medium")
    
    Otherwise if operation is equal to "iterative_solver":
        Note: Analyze convergence characteristics for parallel solvers
        Let convergence_estimate be "unknown"
        
        Note: Simple heuristic based on matrix properties
        If matrix.sparsity_ratio is less than 0.1:
            Set convergence_estimate to "fast"
        Otherwise if matrix.sparsity_ratio is less than 0.5:
            Set convergence_estimate to "medium"
        Otherwise:
            Set convergence_estimate to "slow"
        
        Call optimization_info.set("convergence_estimate", convergence_estimate)
        Call optimization_info.set("recommended_preconditioner", "ILU")
        Call optimization_info.set("parallelization_efficiency", "high")
    
    Otherwise:
        Note: General analysis for unknown operation
        Let memory_bandwidth_estimate be matrix.non_zeros multiplied by 12
        Let memory_per_thread be memory_bandwidth_estimate / num_threads
        
        Call optimization_info.set("memory_bandwidth_estimate", memory_bandwidth_estimate.to_string())
        Call optimization_info.set("memory_per_thread", memory_per_thread.to_string())
        Call optimization_info.set("parallelization_efficiency", "unknown")
    
    Note: General recommendations
    If num_threads is greater than 4 and matrix.non_zeros is less than 10000:
        Call optimization_info.set("recommendation", "Consider sequential execution for small matrices")
    Otherwise if matrix.sparsity_ratio is greater than 0.99:
        Call optimization_info.set("recommendation", "Extremely sparse matrix minus consider specialized algorithms")
    Otherwise:
        Call optimization_info.set("recommendation", "Good candidate for parallelization")
    
    Return optimization_info

Note: =====================================================================
Note: SPARSE MATRIX UTILITY OPERATIONS
Note: =====================================================================

Process called "sparse_matrix_statistics" that takes matrix as SparseMatrix returns Dictionary[String, String]:
    Note: Compute comprehensive statistics about sparse matrix
    Note: Provides detailed analysis of sparse matrix properties
    Note: Computational complexity: O(nnz)
    
    Let stats be Dictionary[String, String]()
    
    Note: Basic dimensions and sparsity
    Call stats.set("rows", matrix.rows.to_string())
    Call stats.set("columns", matrix.columns.to_string())
    Call stats.set("non_zeros", matrix.non_zeros.to_string())
    Call stats.set("sparsity_ratio", matrix.sparsity_ratio.to_string())
    Call stats.set("format", matrix.format)
    
    Note: Density information
    Let total_elements be matrix.rows multiplied by matrix.columns
    Let density be (matrix.non_zeros.to_float() / total_elements.to_float()) multiplied by 100.0
    Call stats.set("density_percentage", density.to_string())
    
    Note: Pattern analysis
    Let bandwidth be compute_bandwidth(matrix)
    Call stats.set("bandwidth", bandwidth.to_string())
    
    Let profile be compute_profile(matrix)
    Call stats.set("profile", profile.to_string())
    
    Note: Memory usage estimate (simplified)
    Let memory_usage_bytes be matrix.non_zeros multiplied by 12
    If matrix.format is equal to "CSR" or matrix.format is equal to "CSC":
        Set memory_usage_bytes to memory_usage_bytes plus (matrix.rows plus 1) multiplied by 4
    Call stats.set("estimated_memory_bytes", memory_usage_bytes.to_string())
    
    Note: Structural properties
    Let is_square be matrix.rows is equal to matrix.columns
    Call stats.set("is_square", is_square.to_string())
    
    Note: Count diagonal elements
    Let diagonal_count be 0
    If matrix.format is equal to "CSR":
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Let i be 0
        While i is less than matrix.rows:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Let k be row_start
            While k is less than row_end:
                Let j be col_indices.get(k)
                If i is equal to j:
                    Set diagonal_count to diagonal_count plus 1
                Set k to k plus 1
            Set i to i plus 1
    
    Call stats.set("diagonal_elements", diagonal_count.to_string())
    
    Return stats

Process called "validate_sparse_format" that takes matrix as SparseMatrix returns Dictionary[String, Boolean]:
    Note: Validate sparse matrix format and detect errors
    Note: Checks structural integrity and format consistency
    Note: Computational complexity: O(nnz)
    
    Let validation_results be Dictionary[String, Boolean]()
    
    Note: Check basic dimensions
    Let valid_dimensions be matrix.rows is greater than 0 and matrix.columns is greater than 0
    Call validation_results.set("valid_dimensions", valid_dimensions)
    
    Note: Check non-zero count consistency
    Let valid_nnz_count be matrix.non_zeros is greater than or equal to 0 and matrix.non_zeros is less than or equal to (matrix.rows multiplied by matrix.columns)
    Call validation_results.set("valid_nnz_count", valid_nnz_count)
    
    Note: Check data array lengths
    Let valid_data_length be matrix.data.length is equal to matrix.non_zeros
    Call validation_results.set("valid_data_length", valid_data_length)
    
    If matrix.format is equal to "CSR":
        Note: Validate CSR format
        Let valid_indices_length be matrix.indices.length is equal to matrix.non_zeros
        Call validation_results.set("valid_indices_length", valid_indices_length)
        
        Let valid_pointers_length be matrix.pointers.length is equal to (matrix.rows plus 1)
        Call validation_results.set("valid_pointers_length", valid_pointers_length)
        
        Note: Check pointer consistency
        Let valid_pointers be true
        If valid_pointers_length and matrix.pointers.length is greater than 0:
            If matrix.pointers.get(0) does not equal 0:
                Set valid_pointers to false
            If matrix.pointers.get(matrix.pointers.length minus 1) does not equal matrix.non_zeros:
                Set valid_pointers to false
            
            Let i be 1
            While i is less than matrix.pointers.length and valid_pointers:
                If matrix.pointers.get(i) is less than matrix.pointers.get(i minus 1):
                    Set valid_pointers to false
                Set i to i plus 1
        
        Call validation_results.set("valid_pointers", valid_pointers)
        
        Note: Check column indices bounds
        Let valid_column_indices be true
        If valid_indices_length:
            Let k be 0
            While k is less than matrix.indices.length and valid_column_indices:
                Let col_idx be matrix.indices.get(k)
                If col_idx is less than 0 or col_idx is greater than or equal to matrix.columns:
                    Set valid_column_indices to false
                Set k to k plus 1
        
        Call validation_results.set("valid_column_indices", valid_column_indices)
    
    Otherwise if matrix.format is equal to "COO":
        Note: Validate COO format
        Let valid_row_indices be matrix.pointers.length is equal to matrix.non_zeros
        Call validation_results.set("valid_row_indices_length", valid_row_indices)
        
        Let valid_col_indices be matrix.indices.length is equal to matrix.non_zeros
        Call validation_results.set("valid_col_indices_length", valid_col_indices)
        
        Note: Check indices bounds
        Let valid_bounds be true
        If valid_row_indices and valid_col_indices:
            Let k be 0
            While k is less than matrix.non_zeros and valid_bounds:
                Let row_idx be matrix.pointers.get(k)
                Let col_idx be matrix.indices.get(k)
                If row_idx is less than 0 or row_idx is greater than or equal to matrix.rows or col_idx is less than 0 or col_idx is greater than or equal to matrix.columns:
                    Set valid_bounds to false
                Set k to k plus 1
        
        Call validation_results.set("valid_indices_bounds", valid_bounds)
    
    Note: Compute overall validity
    Let overall_valid be true
    Let keys be validation_results.keys()
    Let k be 0
    While k is less than keys.length:
        Let key be keys.get(k)
        If not validation_results.get(key):
            Set overall_valid to false
        Set k to k plus 1
    
    Call validation_results.set("overall_valid", overall_valid)
    
    Return validation_results

Process called "visualize_sparsity_pattern" that takes matrix as SparseMatrix, visualization_options as Dictionary[String, String] returns String:
    Note: Create visualization of sparse matrix pattern
    Note: Creates ASCII art representation of sparsity pattern
    Note: Computational complexity: O(rows multiplied by cols) for full visualization
    
    Let max_display_size be 20
    If visualization_options.contains("max_size"):
        Set max_display_size to visualization_options.get("max_size").to_integer()
    
    If matrix.rows is greater than max_display_size or matrix.columns is greater than max_display_size:
        Return "Matrix too large for visualization (" plus matrix.rows.to_string() plus "x" plus matrix.columns.to_string() plus "). Use smaller matrix or increase max_size."
    
    Let pattern be ""
    Set pattern to pattern plus "Sparsity Pattern (" plus matrix.rows.to_string() plus "x" plus matrix.columns.to_string() plus ", " plus matrix.non_zeros.to_string() plus " nnz):\n"
    Set pattern to pattern plus "Legend: multiplied by is equal to non-zero, . is equal to zero\n\n"
    
    Note: Create boolean matrix for non-zero positions
    Let is_nonzero be List[List[Boolean]]()
    Let i be 0
    While i is less than matrix.rows:
        Let row be List[Boolean]()
        Let j be 0
        While j is less than matrix.columns:
            Call row.add(false)
            Set j to j plus 1
        Call is_nonzero.add(row)
        Set i to i plus 1
    
    Note: Mark non-zero positions
    If matrix.format is equal to "CSR":
        Let col_indices be matrix.indices
        Let row_pointers be matrix.pointers
        
        Set i to 0
        While i is less than matrix.rows:
            Let row_start be row_pointers.get(i)
            Let row_end be row_pointers.get(i plus 1)
            Let k be row_start
            While k is less than row_end:
                Let j be col_indices.get(k)
                Set is_nonzero.get(i)[j] to true
                Set k to k plus 1
            Set i to i plus 1
    
    Note: Generate visualization string
    Set i to 0
    While i is less than matrix.rows:
        Let j be 0
        While j is less than matrix.columns:
            If is_nonzero.get(i).get(j):
                Set pattern to pattern plus "*"
            Otherwise:
                Set pattern to pattern plus "."
            Set j to j plus 1
        Set pattern to pattern plus "\n"
        Set i to i plus 1
    
    Return pattern

Process called "compare_sparse_matrices" that takes matrix_a as SparseMatrix, matrix_b as SparseMatrix, tolerance as Float returns Dictionary[String, Boolean]:
    Note: Compare two sparse matrices for equality within tolerance
    Note: Compares dimensions, sparsity patterns, and values
    Note: Computational complexity: O(max(nnz_A, nnz_B))
    
    Let comparison_results be Dictionary[String, Boolean]()
    
    Note: Check dimension equality
    Let dimensions_equal be matrix_a.rows is equal to matrix_b.rows and matrix_a.columns is equal to matrix_b.columns
    Call comparison_results.set("dimensions_equal", dimensions_equal)
    
    If not dimensions_equal:
        Call comparison_results.set("matrices_equal", false)
        Call comparison_results.set("values_equal", false)
        Call comparison_results.set("patterns_equal", false)
        Return comparison_results
    
    Note: Check non-zero count
    Let nnz_equal be matrix_a.non_zeros is equal to matrix_b.non_zeros
    Call comparison_results.set("nnz_equal", nnz_equal)
    
    Note: Convert both to dense format for comparison (simplified approach)
    Let dense_a be sparse_to_dense(matrix_a)
    Let dense_b be sparse_to_dense(matrix_b)
    
    Let values_equal be true
    Let patterns_equal be true
    
    Note: Compare all elements
    Let i be 0
    While i is less than matrix_a.rows and values_equal:
        Let j be 0
        While j is less than matrix_a.columns and values_equal:
            Let element_key be "element_" plus i.to_string() plus "_" plus j.to_string()
            Let val_a be dense_a.get(element_key)
            Let val_b be dense_b.get(element_key)
            
            Let diff_result be MathOps.subtract(val_a, val_b, 15)
            If not diff_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute element difference"
            
            Let abs_diff_result be MathOps.absolute_value(diff_result.result_value)
            If not abs_diff_result.operation_successful:
                Throw Errors.ComputationError with "Failed to compute absolute difference"
            
            If abs_diff_result.result_value.to_float() is greater than tolerance:
                Set values_equal to false
            
            Note: Check pattern (both zero or both non-zero)
            Let a_is_zero be val_a is equal to "0" or val_a.to_float() is equal to 0.0
            Let b_is_zero be val_b is equal to "0" or val_b.to_float() is equal to 0.0
            If a_is_zero does not equal b_is_zero:
                Set patterns_equal to false
            
            Set j to j plus 1
        Set i to i plus 1
    
    Call comparison_results.set("values_equal", values_equal)
    Call comparison_results.set("patterns_equal", patterns_equal)
    Call comparison_results.set("matrices_equal", values_equal and patterns_equal)
    
    Return comparison_results