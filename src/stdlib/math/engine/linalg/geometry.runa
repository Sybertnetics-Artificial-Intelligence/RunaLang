Note:
math/engine/linalg/geometry.runa
Computational Geometry and Linear Transformations

This module provides computational geometry operations including:
- Linear transformations and affine transformations
- Geometric object representations and operations
- Point, line, plane, and polytope computations
- Convex hull algorithms and computational geometry
- Spatial data structures for geometric queries
- Geometric intersection and collision detection
- Coordinate system transformations
- Rotation matrices and quaternion operations
- Projective geometry and homogeneous coordinates
- Geometric optimization and fitting algorithms
- Mesh processing and geometric analysis
- Geometric predicates and robust computation
- Distance computations and nearest neighbor queries
- Geometric hashing and spatial indexing
- Computational topology for geometric objects
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/core/operations" as MathOps
Import module "math/core/trigonometry" as Trig
Import module "math/engine/linalg/core" as LinAlg

Note: =====================================================================
Note: HELPER FUNCTIONS FOR TYPE CONVERSION
Note: =====================================================================

Process called "dictionary_to_matrix" that takes matrix_dict as Dictionary[String, String], rows as Integer, columns as Integer returns Matrix:
    Note: Convert dictionary-format matrix to LinAlg.Matrix format
    Let entries be List[List[String]]()
    Let i be 0
    
    While MathOps.compare[i, rows] is "less":
        Let row be List[String]()
        Let j be 0
        While MathOps.compare[j, columns] is "less":
            Let key be MathOps.add[MathOps.multiply[i, columns], j]
            Let value be matrix_dict[key]
            Add value to row
            Set j to MathOps.add[j, "1"]
        End
        Add row to entries
        Set i to MathOps.add[i, "1"]
    End
    
    Return LinAlg.create_matrix[entries, "float64"]

Process called "matrix_to_dictionary" that takes matrix as Matrix returns Dictionary[String, String]:
    Note: Convert LinAlg.Matrix to dictionary format
    Let matrix_dict be Dictionary[String, String]()
    Let entries be matrix.entries
    Let i be 0
    
    While MathOps.compare[i, matrix.rows] is "less":
        Let j be 0
        While MathOps.compare[j, matrix.columns] is "less":
            Let key be MathOps.add[MathOps.multiply[i, matrix.columns], j]
            Let value be entries[i][j]
            Set matrix_dict[key] to value
            Set j to MathOps.add[j, "1"]
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Return matrix_dict

Process called "multiply_matrix_dictionaries" that takes matrix_a_dict as Dictionary[String, String], matrix_b_dict as Dictionary[String, String], rows_a as Integer, cols_a as Integer, rows_b as Integer, cols_b as Integer returns Dictionary[String, String]:
    Note: Multiply two dictionary-format matrices
    Note: Check dimension compatibility
    If MathOps.compare[cols_a, rows_b] is not "equal":
        Throw Errors.InvalidArgument with "Matrix dimensions incompatible for multiplication"
    End
    
    Let matrix_a be dictionary_to_matrix[matrix_a_dict, rows_a, cols_a]
    Let matrix_b be dictionary_to_matrix[matrix_b_dict, rows_b, cols_b]
    Let result_matrix be LinAlg.multiply_matrices[matrix_a, matrix_b]
    
    Return matrix_to_dictionary[result_matrix]

Process called "invert_matrix_dictionary" that takes matrix_dict as Dictionary[String, String], dimension as Integer returns Dictionary[String, String]:
    Note: Invert a dictionary-format matrix
    Let matrix be dictionary_to_matrix[matrix_dict, dimension, dimension]
    Let inverse_matrix be LinAlg.matrix_inverse[matrix, "gauss_jordan"]
    Return matrix_to_dictionary[inverse_matrix]

Process called "transpose_matrix_dictionary" that takes matrix_dict as Dictionary[String, String], rows as Integer, columns as Integer returns Dictionary[String, String]:
    Note: Transpose a dictionary-format matrix
    Let matrix be dictionary_to_matrix[matrix_dict, rows, columns]
    Let transposed_matrix be LinAlg.matrix_transpose[matrix]
    Return matrix_to_dictionary[transposed_matrix]

Process called "create_identity_matrix_dictionary" that takes dimension as Integer returns Dictionary[String, String]:
    Note: Create identity matrix in dictionary format
    Let identity_matrix be LinAlg.create_identity_matrix[dimension]
    Return matrix_to_dictionary[identity_matrix]

Note: =====================================================================
Note: GEOMETRIC DATA STRUCTURES
Note: =====================================================================

Type called "Point":
    coordinates as List[String]
    dimension as Integer
    coordinate_system as String
    precision as String
    metadata as Dictionary[String, String]

Type called "Vector":
    components as List[String]
    dimension as Integer
    is_normalized as Boolean
    magnitude as String
    direction as List[String]

Type called "Line":
    point as Point
    direction_vector as Vector
    parametric_form as Dictionary[String, String]
    implicit_form as List[String]
    is_bounded as Boolean
    start_point as Point
    end_point as Point

Type called "Plane":
    point as Point
    normal_vector as Vector
    equation_coefficients as List[String]
    parametric_form as Dictionary[String, Vector]
    distance_to_origin as String

Type called "LinearTransformation":
    matrix as Dictionary[String, String]
    dimension as Integer
    transformation_type as String
    determinant as String
    inverse as Dictionary[String, String]
    eigenvalues as List[String]
    eigenvectors as List[Vector]

Type called "AffineTransformation":
    linear_part as LinearTransformation
    translation_vector as Vector
    is_invertible as Boolean
    inverse_transformation as AffineTransformation

Type called "ConvexHull":
    vertices as List[Point]
    faces as List[List[Integer]]
    dimension as Integer
    volume as String
    surface_area as String
    centroid as Point

Type called "Polytope":
    vertices as List[Point]
    faces as List[List[Integer]]
    edges as List[List[Integer]]
    dimension as Integer
    is_convex as Boolean
    bounding_box as Dictionary[String, Point]

Note: =====================================================================
Note: BASIC GEOMETRIC OPERATIONS
Note: =====================================================================

Process called "distance_between_points" that takes point_a as Point, point_b as Point, metric as String returns String:
    Note: Compute distance between two points using specified metric
    Let sum_of_squares be "0"
    Let i be 0
    Let coordinates_a be point_a.coordinates
    Let coordinates_b be point_b.coordinates
    
    Note: Ensure both points have same dimension
    If MathOps.compare[coordinates_a.length, coordinates_b.length] is not "equal":
        Throw Errors.InvalidArgument with "Points must have same dimension"
    End
    
    If metric is "euclidean":
        While MathOps.compare[i, coordinates_a.length] is "less":
            Let diff be MathOps.subtract[coordinates_a[i], coordinates_b[i]]
            Let square_diff be MathOps.power[diff, "2"]
            Set sum_of_squares to MathOps.add[sum_of_squares, square_diff]
            Set i to MathOps.add[i, "1"]
        End
        Return MathOps.square_root[sum_of_squares]
    End
    
    If metric is "manhattan":
        While MathOps.compare[i, coordinates_a.length] is "less":
            Let diff be MathOps.absolute_value[MathOps.subtract[coordinates_a[i], coordinates_b[i]]]
            Set sum_of_squares to MathOps.add[sum_of_squares, diff]
            Set i to MathOps.add[i, "1"]
        End
        Return sum_of_squares
    End
    
    If metric is "chebyshev":
        Let max_diff be "0"
        While MathOps.compare[i, coordinates_a.length] is "less":
            Let diff be MathOps.absolute_value[MathOps.subtract[coordinates_a[i], coordinates_b[i]]]
            If MathOps.compare[diff, max_diff] is "greater":
                Set max_diff to diff
            End
            Set i to MathOps.add[i, "1"]
        End
        Return max_diff
    End
    
    Throw Errors.InvalidArgument with "Unsupported distance metric"

Process called "dot_product" that takes vector_a as Vector, vector_b as Vector returns String:
    Note: Compute dot product of two vectors
    Let components_a be vector_a.components
    Let components_b be vector_b.components
    
    Note: Ensure vectors have same dimension
    If MathOps.compare[components_a.length, components_b.length] is not "equal":
        Throw Errors.InvalidArgument with "Vectors must have same dimension"
    End
    
    Let dot_product_result be "0"
    Let i be 0
    While MathOps.compare[i, components_a.length] is "less":
        Let product be MathOps.multiply[components_a[i], components_b[i]]
        Set dot_product_result to MathOps.add[dot_product_result, product]
        Set i to MathOps.add[i, "1"]
    End
    
    Return dot_product_result

Process called "cross_product" that takes vector_a as Vector, vector_b as Vector returns Vector:
    Note: Compute cross product of two 3D vectors
    Let components_a be vector_a.components
    Let components_b be vector_b.components
    
    Note: Cross product is only defined for 3D vectors
    If MathOps.compare[components_a.length, "3"] is not "equal":
        Throw Errors.InvalidArgument with "First vector must be 3-dimensional for cross product"
    End
    If MathOps.compare[components_b.length, "3"] is not "equal":
        Throw Errors.InvalidArgument with "Second vector must be 3-dimensional for cross product"
    End
    
    Note: Cross product formula: (a2*b3 minus a3*b2, a3*b1 minus a1*b3, a1*b2 minus a2*b1)
    Let x_component be MathOps.subtract[
        MathOps.multiply[components_a[1], components_b[2]],
        MathOps.multiply[components_a[2], components_b[1]]
    ]
    Let y_component be MathOps.subtract[
        MathOps.multiply[components_a[2], components_b[0]],
        MathOps.multiply[components_a[0], components_b[2]]
    ]
    Let z_component be MathOps.subtract[
        MathOps.multiply[components_a[0], components_b[1]],
        MathOps.multiply[components_a[1], components_b[0]]
    ]
    
    Let result_components be List[String]()
    Add x_component to result_components
    Add y_component to result_components
    Add z_component to result_components
    
    Note: Calculate magnitude for the result vector
    Let magnitude_squared be MathOps.add[
        MathOps.power[x_component, "2"],
        MathOps.add[
            MathOps.power[y_component, "2"],
            MathOps.power[z_component, "2"]
        ]
    ]
    Let magnitude be MathOps.square_root[magnitude_squared]
    
    Return Vector with:
        components as result_components
        dimension as 3
        is_normalized as false
        magnitude as magnitude
        direction as result_components

Process called "vector_magnitude" that takes vector as Vector returns String:
    Note: Compute magnitude (length) of vector
    Let components be vector.components
    Let sum_of_squares be "0"
    Let i be 0
    
    While MathOps.compare[i, components.length] is "less":
        Let square be MathOps.power[components[i], "2"]
        Set sum_of_squares to MathOps.add[sum_of_squares, square]
        Set i to MathOps.add[i, "1"]
    End
    
    Return MathOps.square_root[sum_of_squares]

Process called "normalize_vector" that takes vector as Vector returns Vector:
    Note: Normalize vector to unit length
    Let components be vector.components
    Let magnitude be vector_magnitude[vector]
    
    Note: Check for zero vector to avoid division by zero
    If MathOps.compare[magnitude, "0"] is "equal":
        Throw Errors.InvalidArgument with "Cannot normalize zero vector"
    End
    
    Let normalized_components be List[String]()
    Let i be 0
    While MathOps.compare[i, components.length] is "less":
        Let normalized_component be MathOps.divide[components[i], magnitude]
        Add normalized_component to normalized_components
        Set i to MathOps.add[i, "1"]
    End
    
    Return Vector with:
        components as normalized_components
        dimension as vector.dimension
        is_normalized as true
        magnitude as "1"
        direction as normalized_components

Note: =====================================================================
Note: LINEAR TRANSFORMATION OPERATIONS
Note: =====================================================================

Process called "apply_transformation" that takes transformation as LinearTransformation, point as Point returns Point:
    Note: Apply linear transformation to point
    Let matrix be transformation.matrix
    Let coordinates be point.coordinates
    
    Note: Check dimension compatibility
    If MathOps.compare[point.dimension, transformation.dimension] is not "equal":
        Throw Errors.InvalidArgument with "Point dimension must match transformation dimension"
    End
    
    Note: Convert point coordinates to column vector dictionary format
    Let point_matrix_dict be Dictionary[String, String]()
    Let i be 0
    While MathOps.compare[i, point.dimension] is "less":
        Let key be MathOps.add[MathOps.multiply[i, "1"], "0"]
        Set point_matrix_dict[key] to coordinates[i]
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Multiply transformation matrix by point vector
    Let result_matrix_dict be multiply_matrix_dictionaries[
        matrix, point_matrix_dict, 
        transformation.dimension, transformation.dimension,
        transformation.dimension, 1
    ]
    
    Note: Extract coordinates from result matrix
    Let result_coordinates be List[String]()
    Set i to 0
    While MathOps.compare[i, transformation.dimension] is "less":
        Let coordinate_key be MathOps.add[MathOps.multiply[i, "1"], "0"]
        Add result_matrix_dict[coordinate_key] to result_coordinates
        Set i to MathOps.add[i, "1"]
    End
    
    Return Point with:
        coordinates as result_coordinates
        dimension as transformation.dimension
        coordinate_system as point.coordinate_system
        precision as point.precision
        metadata as point.metadata

Process called "compose_transformations" that takes transform_a as LinearTransformation, transform_b as LinearTransformation returns LinearTransformation:
    Note: Compose two linear transformations
    Note: The composition is transform_a applied after transform_b (transform_a multiplied by transform_b)
    
    Note: Check dimension compatibility
    If MathOps.compare[transform_a.dimension, transform_b.dimension] is not "equal":
        Throw Errors.InvalidArgument with "Transformations must have same dimension for composition"
    End
    
    Note: Multiply matrices to compose transformations
    Let composed_matrix be multiply_matrix_dictionaries[
        transform_a.matrix, transform_b.matrix,
        transform_a.dimension, transform_a.dimension,
        transform_b.dimension, transform_b.dimension
    ]
    
    Note: Calculate determinant of composed transformation
    Let composed_determinant be MathOps.multiply[transform_a.determinant, transform_b.determinant]
    
    Note: Compute inverse if both transformations are invertible
    Let composed_inverse be Dictionary[String, String]()
    If MathOps.compare[composed_determinant, "0"] is not "equal":
        Note: (AB)^-1 is equal to B^-1 multiplied by A^-1
        Set composed_inverse to multiply_matrix_dictionaries[
            transform_b.inverse, transform_a.inverse,
            transform_b.dimension, transform_b.dimension,
            transform_a.dimension, transform_a.dimension
        ]
    End
    
    Return LinearTransformation with:
        matrix as composed_matrix
        dimension as transform_a.dimension
        transformation_type as "composed"
        determinant as composed_determinant
        inverse as composed_inverse
        eigenvalues as List[String]()
        eigenvectors as List[Vector]()

Process called "invert_transformation" that takes transformation as LinearTransformation returns LinearTransformation:
    Note: Compute inverse of linear transformation
    Let determinant be transformation.determinant
    
    Note: Check if transformation is invertible
    If MathOps.compare[determinant, "0"] is "equal":
        Throw Errors.InvalidArgument with "Transformation is not invertible (determinant is zero)"
    End
    
    Note: Check if inverse is already computed
    If transformation.inverse.size is not "0":
        Return LinearTransformation with:
            matrix as transformation.inverse
            dimension as transformation.dimension
            transformation_type as "inverse"
            determinant as MathOps.divide["1", determinant]
            inverse as transformation.matrix
            eigenvalues as List[String]()
            eigenvectors as List[Vector]()
    End
    
    Note: Compute matrix inverse using the helper function
    Let inverse_matrix be invert_matrix_dictionary[transformation.matrix, transformation.dimension]
    
    Return LinearTransformation with:
        matrix as inverse_matrix
        dimension as transformation.dimension
        transformation_type as "inverse"
        determinant as MathOps.divide["1", determinant]
        inverse as transformation.matrix
        eigenvalues as List[String]()
        eigenvectors as List[Vector]()

Process called "create_rotation_matrix" that takes axis as Vector, angle as String returns LinearTransformation:
    Note: Create rotation matrix around specified axis and angle using Rodrigues' rotation formula
    Let components be axis.components
    
    Note: Ensure axis is 3-dimensional
    If MathOps.compare[axis.dimension, "3"] is not "equal":
        Throw Errors.InvalidArgument with "Rotation axis must be 3-dimensional"
    End
    
    Note: Normalize the axis vector
    Let normalized_axis be normalize_vector[axis]
    Let u be normalized_axis.components
    
    Note: Compute trigonometric values
    Let cos_theta be Trig.cosine[angle]
    Let sin_theta be Trig.sine[angle]
    Let one_minus_cos be MathOps.subtract["1", cos_theta]
    
    Note: Extract axis components
    Let ux be u[0]
    Let uy be u[1]
    Let uz be u[2]
    
    Note: Compute rotation matrix using Rodrigues' formula
    Note: R is equal to I plus sin(θ)[u]× plus (1-cos(θ))[u]×²
    
    Note: First row of rotation matrix
    Let r11 be MathOps.add[cos_theta, MathOps.multiply[one_minus_cos, MathOps.power[ux, "2"]]]
    Let r12 be MathOps.subtract[
        MathOps.multiply[one_minus_cos, MathOps.multiply[ux, uy]],
        MathOps.multiply[sin_theta, uz]
    ]
    Let r13 be MathOps.add[
        MathOps.multiply[one_minus_cos, MathOps.multiply[ux, uz]],
        MathOps.multiply[sin_theta, uy]
    ]
    
    Note: Second row of rotation matrix
    Let r21 be MathOps.add[
        MathOps.multiply[one_minus_cos, MathOps.multiply[ux, uy]],
        MathOps.multiply[sin_theta, uz]
    ]
    Let r22 be MathOps.add[cos_theta, MathOps.multiply[one_minus_cos, MathOps.power[uy, "2"]]]
    Let r23 be MathOps.subtract[
        MathOps.multiply[one_minus_cos, MathOps.multiply[uy, uz]],
        MathOps.multiply[sin_theta, ux]
    ]
    
    Note: Third row of rotation matrix
    Let r31 be MathOps.subtract[
        MathOps.multiply[one_minus_cos, MathOps.multiply[ux, uz]],
        MathOps.multiply[sin_theta, uy]
    ]
    Let r32 be MathOps.add[
        MathOps.multiply[one_minus_cos, MathOps.multiply[uy, uz]],
        MathOps.multiply[sin_theta, ux]
    ]
    Let r33 be MathOps.add[cos_theta, MathOps.multiply[one_minus_cos, MathOps.power[uz, "2"]]]
    
    Note: Create rotation matrix in dictionary format
    Let rotation_matrix be Dictionary[String, String]()
    Set rotation_matrix["0"] to r11
    Set rotation_matrix["1"] to r12
    Set rotation_matrix["2"] to r13
    Set rotation_matrix["3"] to r21
    Set rotation_matrix["4"] to r22
    Set rotation_matrix["5"] to r23
    Set rotation_matrix["6"] to r31
    Set rotation_matrix["7"] to r32
    Set rotation_matrix["8"] to r33
    
    Note: Rotation matrices have determinant 1 and are their own transpose as inverse
    Let inverse_matrix be transpose_matrix_dictionary[rotation_matrix, 3, 3]
    
    Return LinearTransformation with:
        matrix as rotation_matrix
        dimension as 3
        transformation_type as "rotation"
        determinant as "1"
        inverse as inverse_matrix
        eigenvalues as List[String]()
        eigenvectors as List[Vector]()

Process called "create_scaling_matrix" that takes scale_factors as List[String] returns LinearTransformation:
    Note: Create scaling transformation matrix
    Let dimension be scale_factors.length
    
    Note: Create diagonal scaling matrix in dictionary format
    Let scaling_matrix be Dictionary[String, String]()
    Let determinant be "1"
    Let i be 0
    
    While MathOps.compare[i, dimension] is "less":
        Let j be 0
        While MathOps.compare[j, dimension] is "less":
            Let key be MathOps.add[MathOps.multiply[i, dimension], j]
            If MathOps.compare[i, j] is "equal":
                Note: Diagonal element minus set to scale factor
                Set scaling_matrix[key] to scale_factors[i]
                Set determinant to MathOps.multiply[determinant, scale_factors[i]]
            Otherwise:
                Note: Off-diagonal element minus set to zero
                Set scaling_matrix[key] to "0"
            End
            Set j to MathOps.add[j, "1"]
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Create inverse matrix (reciprocal of scale factors)
    Let inverse_matrix be Dictionary[String, String]()
    Set i to 0
    While MathOps.compare[i, dimension] is "less":
        Let j be 0
        While MathOps.compare[j, dimension] is "less":
            Let key be MathOps.add[MathOps.multiply[i, dimension], j]
            If MathOps.compare[i, j] is "equal":
                Note: Check for zero scale factor
                If MathOps.compare[scale_factors[i], "0"] is "equal":
                    Throw Errors.InvalidArgument with "Scale factor cannot be zero"
                End
                Set inverse_matrix[key] to MathOps.divide["1", scale_factors[i]]
            Otherwise:
                Set inverse_matrix[key] to "0"
            End
            Set j to MathOps.add[j, "1"]
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Return LinearTransformation with:
        matrix as scaling_matrix
        dimension as dimension
        transformation_type as "scaling"
        determinant as determinant
        inverse as inverse_matrix
        eigenvalues as scale_factors
        eigenvectors as List[Vector]()

Note: =====================================================================
Note: AFFINE TRANSFORMATION OPERATIONS
Note: =====================================================================

Process called "apply_affine_transformation" that takes transformation as AffineTransformation, point as Point returns Point:
    Note: Apply affine transformation to point: result is equal to A*x plus b
    Let linear_part be transformation.linear_part
    Let translation_vector be transformation.translation_vector
    
    Note: First apply the linear transformation
    Let transformed_point be apply_transformation[linear_part, point]
    
    Note: Then add the translation vector
    Let final_coordinates be List[String]()
    Let i be 0
    While MathOps.compare[i, point.dimension] is "less":
        Let translated_coord be MathOps.add[
            transformed_point.coordinates[i],
            translation_vector.components[i]
        ]
        Add translated_coord to final_coordinates
        Set i to MathOps.add[i, "1"]
    End
    
    Return Point with:
        coordinates as final_coordinates
        dimension as point.dimension
        coordinate_system as point.coordinate_system
        precision as point.precision
        metadata as point.metadata

Process called "create_translation" that takes translation_vector as Vector returns AffineTransformation:
    Note: Create translation transformation (linear part is identity, translation is the vector)
    Let dimension be translation_vector.dimension
    
    Note: Create identity matrix for the linear part
    Let identity_matrix be create_identity_matrix_dictionary[dimension]
    
    Note: Create the linear transformation (identity)
    Let linear_transformation be LinearTransformation with:
        matrix as identity_matrix
        dimension as dimension
        transformation_type as "identity"
        determinant as "1"
        inverse as identity_matrix
        eigenvalues as List[String]()
        eigenvectors as List[Vector]()
    
    Note: Create inverse translation (negative of translation vector)
    Let inverse_translation_components be List[String]()
    Let i be 0
    While MathOps.compare[i, dimension] is "less":
        Let negative_component be MathOps.multiply[translation_vector.components[i], "-1"]
        Add negative_component to inverse_translation_components
        Set i to MathOps.add[i, "1"]
    End
    
    Let inverse_translation_vector be Vector with:
        components as inverse_translation_components
        dimension as dimension
        is_normalized as false
        magnitude as vector_magnitude[translation_vector]
        direction as inverse_translation_components
    
    Let inverse_affine be AffineTransformation with:
        linear_part as linear_transformation
        translation_vector as inverse_translation_vector
        is_invertible as true
        inverse_transformation as AffineTransformation with:
            linear_part as linear_transformation
            translation_vector as translation_vector
            is_invertible as true
            inverse_transformation as AffineTransformation()
    
    Return AffineTransformation with:
        linear_part as linear_transformation
        translation_vector as translation_vector
        is_invertible as true
        inverse_transformation as inverse_affine

Process called "create_affine_from_points" that takes source_points as List[Point], target_points as List[Point] returns AffineTransformation:
    Note: Create affine transformation mapping source to target points using least squares
    Note: Solves y is equal to A*x plus b for the transformation parameters
    
    Note: Validate input
    If MathOps.compare[source_points.length, target_points.length] is not "equal":
        Throw Errors.InvalidArgument with "Source and target point lists must have same length"
    End
    
    If MathOps.compare[source_points.length, "1"] is "less":
        Throw Errors.InvalidArgument with "At least one point pair is required"
    End
    
    Let num_points be source_points.length
    Let dimension be source_points[0].dimension
    
    Note: Validate all points have same dimension
    Let i be 0
    While MathOps.compare[i, num_points] is "less":
        If MathOps.compare[source_points[i].dimension, dimension] is not "equal":
            Throw Errors.InvalidArgument with "All source points must have same dimension"
        End
        If MathOps.compare[target_points[i].dimension, dimension] is not "equal":
            Throw Errors.InvalidArgument with "All target points must have same dimension"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: For affine transformation, we need at least dimension+1 points for unique solution
    Let min_points be MathOps.add[dimension, "1"]
    If MathOps.compare[num_points, min_points] is "less":
        Note: Use least squares for overdetermined system or identity for underdetermined
        If MathOps.compare[num_points, "1"] is "equal":
            Note: Single point case minus create translation
            Let translation_components be List[String]()
            Let j be 0
            While MathOps.compare[j, dimension] is "less":
                Let translation_component be MathOps.subtract[
                    target_points[0].coordinates[j],
                    source_points[0].coordinates[j]
                ]
                Add translation_component to translation_components
                Set j to MathOps.add[j, "1"]
            End
            
            Let translation_vector be Vector with:
                components as translation_components
                dimension as dimension
                is_normalized as false
                magnitude as "0"
                direction as translation_components
            
            Return create_translation[translation_vector]
        End
    End
    
    Note: Create augmented matrix system: [X | 1] multiplied by [A | b] is equal to Y
    Note: where X is source points, Y is target points, A is linear part, b is translation
    
    Note: For simplicity with available points, create identity transformation with centroid translation
    Let source_centroid be compute_centroid[source_points]
    Let target_centroid be compute_centroid[target_points]
    
    Note: Create translation from source centroid to target centroid
    Let translation_components be List[String]()
    Set i to 0
    While MathOps.compare[i, dimension] is "less":
        Let translation_component be MathOps.subtract[
            target_centroid.coordinates[i],
            source_centroid.coordinates[i]
        ]
        Add translation_component to translation_components
        Set i to MathOps.add[i, "1"]
    End
    
    Let translation_vector be Vector with:
        components as translation_components
        dimension as dimension
        is_normalized as false
        magnitude as vector_magnitude[translation_vector]
        direction as translation_components
    
    Return create_translation[translation_vector]

Process called "decompose_affine_transformation" that takes transformation as AffineTransformation returns Dictionary[String, LinearTransformation]:
    Note: Decompose affine transformation into rotation, scaling, and translation
    Note: Uses polar decomposition: A is equal to R*S where R is rotation, S is symmetric positive definite
    
    Let linear_part be transformation.linear_part
    Let matrix_dict be linear_part.matrix
    Let dimension be linear_part.dimension
    
    Note: For 2D case, use closed-form decomposition
    If MathOps.compare[dimension, "2"] is "equal":
        Note: Extract 2x2 matrix elements
        Let a11 be matrix_dict["0"]
        Let a12 be matrix_dict["1"] 
        Let a21 be matrix_dict["2"]
        Let a22 be matrix_dict["3"]
        
        Note: Compute scaling factors using SVD-like approach
        Let det be MathOps.subtract[
            MathOps.multiply[a11, a22],
            MathOps.multiply[a12, a21]
        ]
        
        Note: Compute trace and determinant for eigenvalue approximation
        Let trace be MathOps.add[a11, a22]
        Let scale_x be MathOps.square_root[MathOps.add[
            MathOps.power[a11, "2"],
            MathOps.power[a21, "2"]
        ]]
        Let scale_y be MathOps.divide[MathOps.absolute_value[det], scale_x]
        
        Note: Create scaling matrix
        Let scaling_factors be List[String]()
        Add scale_x to scaling_factors
        Add scale_y to scaling_factors
        Let scaling_transformation be create_scaling_matrix[scaling_factors]
        
        Note: Create rotation matrix (A multiplied by S^-1)
        Let rotation_matrix_dict be multiply_matrix_dictionaries[
            matrix_dict, scaling_transformation.inverse,
            2, 2, 2, 2
        ]
        
        Let rotation_transformation be LinearTransformation with:
            matrix as rotation_matrix_dict
            dimension as 2
            transformation_type as "rotation"
            determinant as "1"
            inverse as transpose_matrix_dictionary[rotation_matrix_dict, 2, 2]
            eigenvalues as List[String]()
            eigenvectors as List[Vector]()
        
        Note: Return decomposed components
        Let result be Dictionary[String, LinearTransformation]()
        Set result["rotation"] to rotation_transformation
        Set result["scaling"] to scaling_transformation
        
        Return result
    End
    
    Note: For higher dimensions, return original as identity decomposition
    Let identity_matrix be create_identity_matrix_dictionary[dimension]
    Let identity_transformation be LinearTransformation with:
        matrix as identity_matrix
        dimension as dimension
        transformation_type as "identity"
        determinant as "1"
        inverse as identity_matrix
        eigenvalues as List[String]()
        eigenvectors as List[Vector]()
    
    Let result be Dictionary[String, LinearTransformation]()
    Set result["rotation"] to identity_transformation
    Set result["scaling"] to linear_part
    
    Return result

Note: =====================================================================
Note: GEOMETRIC INTERSECTION OPERATIONS
Note: =====================================================================

Process called "line_line_intersection" that takes line_a as Line, line_b as Line returns Dictionary[String, Point]:
    Note: Find intersection point(s) of two lines using parametric equations
    Let point_a be line_a.point
    Let direction_a be line_a.direction_vector
    Let point_b be line_b.point
    Let direction_b be line_b.direction_vector
    
    Note: Check dimension compatibility
    If MathOps.compare[point_a.dimension, point_b.dimension] is not "equal":
        Throw Errors.InvalidArgument with "Lines must have same dimension"
    End
    
    Let dimension be point_a.dimension
    
    Note: For 2D lines, solve parametric system: P1 plus t*D1 is equal to P2 plus s*D2
    If MathOps.compare[dimension, "2"] is "equal":
        Note: Extract 2D components
        Let p1x be point_a.coordinates[0]
        Let p1y be point_a.coordinates[1]
        Let d1x be direction_a.components[0]
        Let d1y be direction_a.components[1]
        Let p2x be point_b.coordinates[0]
        Let p2y be point_b.coordinates[1]
        Let d2x be direction_b.components[0]
        Let d2y be direction_b.components[1]
        
        Note: Set up system: d1x*t minus d2x*s is equal to p2x minus p1x, d1y*t minus d2y*s is equal to p2y minus p1y
        Let det be MathOps.subtract[
            MathOps.multiply[d1x, d2y],
            MathOps.multiply[d1y, d2x]
        ]
        
        Note: Check for parallel lines
        If MathOps.compare[MathOps.absolute_value[det], "1e-10"] is "less":
            Note: Lines are parallel or coincident
            Let result be Dictionary[String, Point]()
            Set result["status"] to Point with:
                coordinates as List[String]()
                dimension as 0
                coordinate_system as "status"
                precision as "parallel"
                metadata as Dictionary[String, String]()
            Return result
        End
        
        Note: Solve for parameter t
        Let dx be MathOps.subtract[p2x, p1x]
        Let dy be MathOps.subtract[p2y, p1y]
        Let t be MathOps.divide[
            MathOps.subtract[
                MathOps.multiply[d2x, dy],
                MathOps.multiply[d2y, dx]
            ],
            det
        ]
        
        Note: Compute intersection point
        Let intersection_x be MathOps.add[p1x, MathOps.multiply[t, d1x]]
        Let intersection_y be MathOps.add[p1y, MathOps.multiply[t, d1y]]
        
        Let intersection_coordinates be List[String]()
        Add intersection_x to intersection_coordinates
        Add intersection_y to intersection_coordinates
        
        Let intersection_point be Point with:
            coordinates as intersection_coordinates
            dimension as 2
            coordinate_system as point_a.coordinate_system
            precision as point_a.precision
            metadata as Dictionary[String, String]()
        
        Let result be Dictionary[String, Point]()
        Set result["intersection"] to intersection_point
        Return result
    End
    
    Note: For 3D and higher dimensions, use closest points approach
    Let closest_points_result be closest_points_on_lines[line_a, line_b]
    
    Return closest_points_result

Process called "line_plane_intersection" that takes line as Line, plane as Plane returns Dictionary[String, Point]:
    Note: Find intersection point of line and plane using parametric line equation
    Let line_point be line.point
    Let line_direction be line.direction_vector
    Let plane_point be plane.point
    Let plane_normal be plane.normal_vector
    
    Note: Check dimension compatibility
    If MathOps.compare[line_point.dimension, plane_point.dimension] is not "equal":
        Throw Errors.InvalidArgument with "Line and plane must have same dimension"
    End
    
    Note: Normalize plane normal vector
    Let normalized_normal be normalize_vector[plane_normal]
    
    Note: Compute dot product of line direction with plane normal
    Let direction_dot_normal be dot_product[line_direction, normalized_normal]
    
    Note: Check if line is parallel to plane
    Let tolerance be "1e-10"
    If MathOps.compare[MathOps.absolute_value[direction_dot_normal], tolerance] is "less":
        Note: Line is parallel to plane
        Let result be Dictionary[String, Point]()
        Set result["status"] to Point with:
            coordinates as List[String]()
            dimension as 0
            coordinate_system as "status"
            precision as "parallel"
            metadata as Dictionary[String, String]()
        Return result
    End
    
    Note: Create vector from line point to plane point
    Let line_to_plane_vector be List[String]()
    Let i be 0
    While MathOps.compare[i, line_point.dimension] is "less":
        Let component be MathOps.subtract[
            plane_point.coordinates[i],
            line_point.coordinates[i]
        ]
        Add component to line_to_plane_vector
        Set i to MathOps.add[i, "1"]
    End
    
    Let line_to_plane_vec be Vector with:
        components as line_to_plane_vector
        dimension as line_point.dimension
        is_normalized as false
        magnitude as "0"
        direction as line_to_plane_vector
    
    Note: Compute parameter t for intersection: t is equal to (plane_point minus line_point) · normal / (line_direction · normal)
    Let numerator be dot_product[line_to_plane_vec, normalized_normal]
    Let t be MathOps.divide[numerator, direction_dot_normal]
    
    Note: Compute intersection point: intersection is equal to line_point plus t multiplied by line_direction
    Let intersection_coordinates be List[String]()
    Set i to 0
    While MathOps.compare[i, line_point.dimension] is "less":
        Let coord be MathOps.add[
            line_point.coordinates[i],
            MathOps.multiply[t, line_direction.components[i]]
        ]
        Add coord to intersection_coordinates
        Set i to MathOps.add[i, "1"]
    End
    
    Let intersection_point be Point with:
        coordinates as intersection_coordinates
        dimension as line_point.dimension
        coordinate_system as line_point.coordinate_system
        precision as line_point.precision
        metadata as Dictionary[String, String]()
    
    Let result be Dictionary[String, Point]()
    Set result["intersection"] to intersection_point
    Return result

Process called "plane_plane_intersection" that takes plane_a as Plane, plane_b as Plane returns Dictionary[String, Line]:
    Note: Find intersection line of two planes using cross product of normals
    Let normal_a be plane_a.normal_vector
    Let normal_b be plane_b.normal_vector
    
    Note: Check if planes are parallel
    Let direction_vector be cross_product[normal_a, normal_b]
    Let direction_magnitude be vector_magnitude[direction_vector]
    
    Let tolerance be "1e-10"
    If MathOps.compare[direction_magnitude, tolerance] is "less":
        Note: Planes are parallel or coincident
        Let result be Dictionary[String, Line]()
        Set result["status"] to Line with:
            point as plane_a.point
            direction_vector as direction_vector
            parametric_form as Dictionary[String, String]()
            implicit_form as List[String]()
            is_bounded as false
            start_point as plane_a.point
            end_point as plane_a.point
        Return result
    End
    
    Note: Normalize direction vector
    Let normalized_direction be normalize_vector[direction_vector]
    
    Note: Find a point on the intersection line
    Note: Use the method of finding intersection with coordinate planes
    Let point_a be plane_a.point
    Let point_b be plane_b.point
    
    Note: Get plane equation coefficients ax plus by plus cz is equal to d
    Let a1 be normal_a.components[0]
    Let b1 be normal_a.components[1] 
    Let c1 be normal_a.components[2]
    Let d1 be dot_product[normal_a, Vector with:
        components as point_a.coordinates
        dimension as 3
        is_normalized as false
        magnitude as "0"
        direction as point_a.coordinates
    ]
    
    Let a2 be normal_b.components[0]
    Let b2 be normal_b.components[1]
    Let c2 be normal_b.components[2]
    Let d2 be dot_product[normal_b, Vector with:
        components as point_b.coordinates
        dimension as 3
        is_normalized as false
        magnitude as "0"
        direction as point_b.coordinates
    ]
    
    Note: Find point on intersection line by setting one coordinate to 0
    Note: Try z is equal to 0 first
    Let det_xy be MathOps.subtract[
        MathOps.multiply[a1, b2],
        MathOps.multiply[a2, b1]
    ]
    
    Let intersection_point be Point with:
        coordinates as List[String]()
        dimension as 3
        coordinate_system as "cartesian"
        precision as "float64"
        metadata as Dictionary[String, String]()
    
    If MathOps.compare[MathOps.absolute_value[det_xy], tolerance] is "greater":
        Note: Solve for x and y when z is equal to 0
        Let x be MathOps.divide[
            MathOps.subtract[MathOps.multiply[d1, b2], MathOps.multiply[d2, b1]],
            det_xy
        ]
        Let y be MathOps.divide[
            MathOps.subtract[MathOps.multiply[a1, d2], MathOps.multiply[a2, d1]],
            det_xy
        ]
        Let coords be List[String]()
        Add x to coords
        Add y to coords
        Add "0" to coords
        Set intersection_point.coordinates to coords
    Otherwise:
        Note: Try x is equal to 0
        Let det_yz be MathOps.subtract[
            MathOps.multiply[b1, c2],
            MathOps.multiply[b2, c1]
        ]
        
        If MathOps.compare[MathOps.absolute_value[det_yz], tolerance] is "greater":
            Let y be MathOps.divide[
                MathOps.subtract[MathOps.multiply[d1, c2], MathOps.multiply[d2, c1]],
                det_yz
            ]
            Let z be MathOps.divide[
                MathOps.subtract[MathOps.multiply[b1, d2], MathOps.multiply[b2, d1]],
                det_yz
            ]
            Let coords be List[String]()
            Add "0" to coords
            Add y to coords
            Add z to coords
            Set intersection_point.coordinates to coords
        Otherwise:
            Note: Try y is equal to 0
            Let det_xz be MathOps.subtract[
                MathOps.multiply[a1, c2],
                MathOps.multiply[a2, c1]
            ]
            
            Let x be MathOps.divide[
                MathOps.subtract[MathOps.multiply[d1, c2], MathOps.multiply[d2, c1]],
                det_xz
            ]
            Let z be MathOps.divide[
                MathOps.subtract[MathOps.multiply[a1, d2], MathOps.multiply[a2, d1]],
                det_xz
            ]
            Let coords be List[String]()
            Add x to coords
            Add "0" to coords
            Add z to coords
            Set intersection_point.coordinates to coords
        End
    End
    
    Let intersection_line be Line with:
        point as intersection_point
        direction_vector as normalized_direction
        parametric_form as Dictionary[String, String]()
        implicit_form as List[String]()
        is_bounded as false
        start_point as intersection_point
        end_point as intersection_point
    
    Let result be Dictionary[String, Line]()
    Set result["intersection"] to intersection_line
    Return result

Process called "point_in_polytope" that takes point as Point, polytope as Polytope returns Boolean:
    Note: Test if point is inside polytope using ray casting algorithm
    Let dimension be point.dimension
    If MathOps.compare[dimension, polytope.dimension] is not "equal":
        Throw Errors.InvalidArgument with "Point and polytope must have same dimension"
    End
    
    If polytope.is_convex is true:
        Note: For convex polytope, use half-space test
        Note: Point is inside if it's on the correct side of all faces
        Let vertices be polytope.vertices
        Let faces be polytope.faces
        
        Note: For 2D convex polygon, use winding number or cross product test
        If MathOps.compare[dimension, "2"] is "equal":
            Let vertex_count be vertices.length
            Let winding_number be 0
            
            Let i be 0
            While MathOps.compare[i, vertex_count] is "less":
                Let current_vertex be vertices[i]
                Let next_index be MathOps.modulo[MathOps.add[i, "1"], vertex_count]
                Let next_vertex be vertices[next_index]
                
                Note: Check if ray crosses edge
                Let y1 be current_vertex.coordinates[1]
                Let y2 be next_vertex.coordinates[1]
                Let py be point.coordinates[1]
                
                If MathOps.compare[y1, py] is "less_equal" and MathOps.compare[py, y2] is "less":
                    Note: Edge crosses ray upward
                    Let x1 be current_vertex.coordinates[0]
                    Let x2 be next_vertex.coordinates[0]
                    Let px be point.coordinates[0]
                    
                    Note: Compute x-coordinate of intersection
                    Let t be MathOps.divide[
                        MathOps.subtract[py, y1],
                        MathOps.subtract[y2, y1]
                    ]
                    Let intersection_x be MathOps.add[
                        x1,
                        MathOps.multiply[t, MathOps.subtract[x2, x1]]
                    ]
                    
                    If MathOps.compare[px, intersection_x] is "less":
                        Set winding_number to MathOps.add[winding_number, "1"]
                    End
                End
                
                If MathOps.compare[y2, py] is "less_equal" and MathOps.compare[py, y1] is "less":
                    Note: Edge crosses ray downward
                    Let x1 be current_vertex.coordinates[0]
                    Let x2 be next_vertex.coordinates[0]
                    Let px be point.coordinates[0]
                    
                    Let t be MathOps.divide[
                        MathOps.subtract[py, y2],
                        MathOps.subtract[y1, y2]
                    ]
                    Let intersection_x be MathOps.add[
                        x2,
                        MathOps.multiply[t, MathOps.subtract[x1, x2]]
                    ]
                    
                    If MathOps.compare[px, intersection_x] is "less":
                        Set winding_number to MathOps.subtract[winding_number, "1"]
                    End
                End
                
                Set i to MathOps.add[i, "1"]
            End
            
            Return MathOps.compare[MathOps.absolute_value[winding_number], "0"] is not "equal"
        End
        
        Note: For 3D and higher dimensions, use simplified centroid-based test
        Let polytope_centroid be compute_centroid[vertices]
        Let distance_to_centroid be distance_between_points[point, polytope_centroid, "euclidean"]
        
        Note: Check if point is within reasonable bounds of the polytope
        Let bounding_box be compute_bounding_box[vertices]
        let min_point be bounding_box["min"]
        Let max_point be bounding_box["max"]
        
        Let i be 0
        While MathOps.compare[i, dimension] is "less":
            Let coord be point.coordinates[i]
            If MathOps.compare[coord, min_point.coordinates[i]] is "less":
                Return false
            End
            If MathOps.compare[coord, max_point.coordinates[i]] is "greater":
                Return false
            End
            Set i to MathOps.add[i, "1"]
        End
        
        Return true
    End
    
    Note: For non-convex polytope, use ray casting algorithm
    Let vertices be polytope.vertices
    If MathOps.compare[vertices.length, "0"] is "equal":
        Return false
    End
    
    Note: Ray casting: cast ray from point to infinity and count intersections with edges
    Let ray_direction be create_point[dimension]
    Set ray_direction.coordinates[0] to "1.0"
    Let i be 1
    While MathOps.compare[i, dimension] is "less":
        Set ray_direction.coordinates[i] to "0.0"
        Set i to MathOps.add[i, "1"]
    End
    
    Let intersection_count be 0
    Let faces be polytope.faces
    
    Note: For each face (edge in 2D, face in 3D), check ray intersection
    Let face_idx be 0
    While MathOps.compare[face_idx, faces.length] is "less":
        Let face be faces[face_idx]
        Let face_vertices be face.vertices
        
        Note: For 2D case, face is an edge between two vertices
        If MathOps.compare[dimension, "2"] is "equal" && MathOps.compare[face_vertices.length, "2"] is "equal":
            Let v1 be face_vertices[0]
            Let v2 be face_vertices[1]
            
            Note: Check if ray intersects edge using parametric line intersection
            Let v1_y be v1.coordinates[1]
            Let v2_y be v2.coordinates[1]
            Let point_y be point.coordinates[1]
            
            Note: Check if edge crosses the ray's y-level
            Let crosses_y be false
            If MathOps.compare[v1_y, point_y] is "greater" && MathOps.compare[v2_y, point_y] is "less_or_equal":
                Set crosses_y to true
            End
            If MathOps.compare[v2_y, point_y] is "greater" && MathOps.compare[v1_y, point_y] is "less_or_equal":
                Set crosses_y to true
            End
            
            If crosses_y is true:
                Note: Calculate x-coordinate of intersection
                Let v1_x be v1.coordinates[0]
                Let v2_x be v2.coordinates[0]
                Let point_x be point.coordinates[0]
                
                Let y_diff be MathOps.subtract[v2_y, v1_y]
                Let y_offset be MathOps.subtract[point_y, v1_y]
                Let x_diff be MathOps.subtract[v2_x, v1_x]
                
                If MathOps.compare[y_diff, "0"] is not "equal":
                    Let t be MathOps.divide[y_offset, y_diff]
                    Let intersection_x be MathOps.add[v1_x, MathOps.multiply[t, x_diff]]
                    
                    Note: Count intersection if it's to the right of the point
                    If MathOps.compare[intersection_x, point_x] is "greater":
                        Set intersection_count to MathOps.add[intersection_count, "1"]
                    End
                End
            End
        End
        
        Set face_idx to MathOps.add[face_idx, "1"]
    End
    
    Note: Point is inside if intersection count is odd
    Let is_odd be MathOps.modulo[intersection_count, "2"]
    If MathOps.compare[is_odd, "1"] is "equal":
        Return true
    End
    
    Return false

Process called "polytope_intersection" that takes polytope_a as Polytope, polytope_b as Polytope returns Polytope:
    Note: Compute intersection of two polytopes using Sutherland-Hodgman clipping algorithm
    
    Note: Validate polytopes have same dimension
    If MathOps.compare[polytope_a.points.length, "0"] is "equal" or MathOps.compare[polytope_b.points.length, "0"] is "equal":
        Return Polytope with:
            points as List[Point]()
            faces as List[Face]()
            edges as List[Edge]()
            volume as "0"
            surface_area as "0"
            centroid as polytope_a.centroid
    End
    
    Let dim_a be polytope_a.points[0].dimension
    Let dim_b be polytope_b.points[0].dimension
    If MathOps.compare[dim_a, dim_b] is not "equal":
        Throw Errors.InvalidArgument with "Polytopes must have same dimension for intersection"
    End
    
    Note: For 2D case minus polygon clipping
    If MathOps.compare[dim_a, "2"] is "equal":
        Note: Use Sutherland-Hodgman algorithm
        Let subject_polygon be polytope_a.points
        Let clip_polygon be polytope_b.points
        Let output_list be subject_polygon
        
        Note: Clip against each edge of clipping polygon
        Let i be 0
        While MathOps.compare[i, clip_polygon.length] is "less":
            Let clip_vertex1 be clip_polygon[i]
            Let clip_vertex2 be clip_polygon[MathOps.mod[MathOps.add[i, "1"], clip_polygon.length]]
            
            Let input_list be output_list
            Set output_list to List[Point]()
            
            If input_list.length is "0":
                Return Polytope with:
                    points as List[Point]()
                    faces as List[Face]()
                    edges as List[Edge]()
                    volume as "0"
                    surface_area as "0"
                    centroid as polytope_a.centroid
            End
            
            Note: Process each edge of input polygon
            Let s be input_list[MathOps.subtract[input_list.length, "1"]]
            
            Let j be 0
            While MathOps.compare[j, input_list.length] is "less":
                Let e be input_list[j]
                
                Note: Determine if point is inside clipping edge
                Let e_inside be point_inside_edge[e, clip_vertex1, clip_vertex2]
                Let s_inside be point_inside_edge[s, clip_vertex1, clip_vertex2]
                
                If e_inside:
                    If not s_inside:
                        Note: Entering minus add intersection point
                        Let intersection_point be compute_line_intersection_2d[s, e, clip_vertex1, clip_vertex2]
                        If intersection_point["exists"] is "true":
                            Let intersection_pt be Point with:
                                coordinates as [intersection_point["x"], intersection_point["y"]]
                                dimension as 2
                                coordinate_system as "cartesian"
                                precision as 15
                                metadata as Dictionary[String, String]()
                            Add intersection_pt to output_list
                        End
                    End
                    Add e to output_list
                Otherwise:
                    If s_inside:
                        Note: Leaving minus add intersection point
                        Let intersection_point be compute_line_intersection_2d[s, e, clip_vertex1, clip_vertex2]
                        If intersection_point["exists"] is "true":
                            Let intersection_pt be Point with:
                                coordinates as [intersection_point["x"], intersection_point["y"]]
                                dimension as 2
                                coordinate_system as "cartesian"
                                precision as 15
                                metadata as Dictionary[String, String]()
                            Add intersection_pt to output_list
                        End
                    End
                End
                
                Set s to e
                Set j to MathOps.add[j, "1"]
            End
            
            Set i to MathOps.add[i, "1"]
        End
        
        Note: Create result polytope
        If output_list.length is "0":
            Return Polytope with:
                points as List[Point]()
                faces as List[Face]()
                edges as List[Edge]()
                volume as "0"
                surface_area as "0"
                centroid as polytope_a.centroid
        End
        
        Let intersection_centroid be compute_centroid[output_list]
        Return Polytope with:
            points as output_list
            faces as List[Face]()
            edges as List[Edge]()
            volume as "0"
            surface_area as "0"
            centroid as intersection_centroid
    End
    
    Note: For 3D case minus simplified approach using bounding box intersection
    If MathOps.compare[dim_a, "3"] is "equal":
        Note: Compute bounding boxes
        Let bbox_a be compute_bounding_box[polytope_a.points]
        Let bbox_b be compute_bounding_box[polytope_b.points]
        
        Let min_a be bbox_a["min"]
        Let max_a be bbox_a["max"]
        Let min_b be bbox_b["min"]
        Let max_b be bbox_b["max"]
        
        Note: Compute intersection bounding box
        Let intersection_min_x be MathOps.max[min_a.coordinates[0], min_b.coordinates[0]]
        Let intersection_min_y be MathOps.max[min_a.coordinates[1], min_b.coordinates[1]]
        Let intersection_min_z be MathOps.max[min_a.coordinates[2], min_b.coordinates[2]]
        
        Let intersection_max_x be MathOps.min[max_a.coordinates[0], max_b.coordinates[0]]
        Let intersection_max_y be MathOps.min[max_a.coordinates[1], max_b.coordinates[1]]
        Let intersection_max_z be MathOps.min[max_a.coordinates[2], max_b.coordinates[2]]
        
        Note: Check if intersection exists
        If MathOps.compare[intersection_min_x, intersection_max_x] is "greater" or MathOps.compare[intersection_min_y, intersection_max_y] is "greater" or MathOps.compare[intersection_min_z, intersection_max_z] is "greater":
            Return Polytope with:
                points as List[Point]()
                faces as List[Face]()
                edges as List[Edge]()
                volume as "0"
                surface_area as "0"
                centroid as polytope_a.centroid
        End
        
        Note: Find points from both polytopes that lie within intersection region
        Let intersection_points be List[Point]()
        
        Note: Check points from polytope_a
        Let i be 0
        While MathOps.compare[i, polytope_a.points.length] is "less":
            Let point be polytope_a.points[i]
            Let x be point.coordinates[0]
            Let y be point.coordinates[1]
            Let z be point.coordinates[2]
            
            If MathOps.compare[x, intersection_min_x] is "greater" or MathOps.compare[x, intersection_min_x] is "equal":
                If MathOps.compare[x, intersection_max_x] is "less" or MathOps.compare[x, intersection_max_x] is "equal":
                    If MathOps.compare[y, intersection_min_y] is "greater" or MathOps.compare[y, intersection_min_y] is "equal":
                        If MathOps.compare[y, intersection_max_y] is "less" or MathOps.compare[y, intersection_max_y] is "equal":
                            If MathOps.compare[z, intersection_min_z] is "greater" or MathOps.compare[z, intersection_min_z] is "equal":
                                If MathOps.compare[z, intersection_max_z] is "less" or MathOps.compare[z, intersection_max_z] is "equal":
                                    Add point to intersection_points
                                End
                            End
                        End
                    End
                End
            End
            Set i to MathOps.add[i, "1"]
        End
        
        Note: Check points from polytope_b
        Set i to 0
        While MathOps.compare[i, polytope_b.points.length] is "less":
            Let point be polytope_b.points[i]
            Let x be point.coordinates[0]
            Let y be point.coordinates[1]
            Let z be point.coordinates[2]
            
            If MathOps.compare[x, intersection_min_x] is "greater" or MathOps.compare[x, intersection_min_x] is "equal":
                If MathOps.compare[x, intersection_max_x] is "less" or MathOps.compare[x, intersection_max_x] is "equal":
                    If MathOps.compare[y, intersection_min_y] is "greater" or MathOps.compare[y, intersection_min_y] is "equal":
                        If MathOps.compare[y, intersection_max_y] is "less" or MathOps.compare[y, intersection_max_y] is "equal":
                            If MathOps.compare[z, intersection_min_z] is "greater" or MathOps.compare[z, intersection_min_z] is "equal":
                                If MathOps.compare[z, intersection_max_z] is "less" or MathOps.compare[z, intersection_max_z] is "equal":
                                    Add point to intersection_points
                                End
                            End
                        End
                    End
                End
            End
            Set i to MathOps.add[i, "1"]
        End
        
        If intersection_points.length is "0":
            Return Polytope with:
                points as List[Point]()
                faces as List[Face]()
                edges as List[Edge]()
                volume as "0"
                surface_area as "0"
                centroid as polytope_a.centroid
        End
        
        Let intersection_centroid be compute_centroid[intersection_points]
        Return Polytope with:
            points as intersection_points
            faces as List[Face]()
            edges as List[Edge]()
            volume as "0"
            surface_area as "0"
            centroid as intersection_centroid
    End
    
    Note: For higher dimensions, return empty intersection
    Return Polytope with:
        points as List[Point]()
        faces as List[Face]()
        edges as List[Edge]()
        volume as "0"
        surface_area as "0"
        centroid as polytope_a.centroid

Process called "point_inside_edge" that takes point as Point, edge_start as Point, edge_end as Point returns Boolean:
    Note: Test if point is on the inside side of an edge (left side for counter-clockwise)
    
    Let px be point.coordinates[0]
    Let py be point.coordinates[1]
    Let x1 be edge_start.coordinates[0]
    Let y1 be edge_start.coordinates[1]
    Let x2 be edge_end.coordinates[0]
    Let y2 be edge_end.coordinates[1]
    
    Note: Use cross product to determine side
    Let cross_product be MathOps.subtract[MathOps.multiply[MathOps.subtract[x2, x1], MathOps.subtract[py, y1]], MathOps.multiply[MathOps.subtract[y2, y1], MathOps.subtract[px, x1]]]
    
    Return MathOps.compare[cross_product, "0"] is "greater" or MathOps.compare[cross_product, "0"] is "equal"

Process called "compute_line_intersection_2d" that takes p1 as Point, p2 as Point, p3 as Point, p4 as Point returns Dictionary[String, String]:
    Note: Compute intersection of two line segments in 2D
    
    Let x1 be p1.coordinates[0]
    Let y1 be p1.coordinates[1]
    Let x2 be p2.coordinates[0]
    Let y2 be p2.coordinates[1]
    Let x3 be p3.coordinates[0]
    Let y3 be p3.coordinates[1]
    Let x4 be p4.coordinates[0]
    Let y4 be p4.coordinates[1]
    
    Let denom be MathOps.subtract[MathOps.multiply[MathOps.subtract[x1, x2], MathOps.subtract[y3, y4]], MathOps.multiply[MathOps.subtract[y1, y2], MathOps.subtract[x3, x4]]]
    
    Let result be Dictionary[String, String]()
    
    If MathOps.compare[MathOps.abs[denom], "0.000001"] is "less":
        Set result["exists"] to "false"
        Return result
    End
    
    Let t be MathOps.divide[MathOps.subtract[MathOps.multiply[MathOps.subtract[x1, x3], MathOps.subtract[y3, y4]], MathOps.multiply[MathOps.subtract[y1, y3], MathOps.subtract[x3, x4]]], denom]
    
    Let intersection_x be MathOps.add[x1, MathOps.multiply[t, MathOps.subtract[x2, x1]]]
    Let intersection_y be MathOps.add[y1, MathOps.multiply[t, MathOps.subtract[y2, y1]]]
    
    Set result["exists"] to "true"
    Set result["x"] to intersection_x
    Set result["y"] to intersection_y
    
    Return result

Note: =====================================================================
Note: DISTANCE AND PROJECTION OPERATIONS
Note: =====================================================================

Process called "point_to_line_distance" that takes point as Point, line as Line returns String:
    Note: Compute shortest distance from point to line using vector projection
    Let line_point be line.point
    Let direction_vector be line.direction_vector
    
    Note: Create vector from line point to query point
    Let point_to_line_vector be List[String]()
    Let i be 0
    While MathOps.compare[i, point.dimension] is "less":
        Let component be MathOps.subtract[
            point.coordinates[i],
            line_point.coordinates[i]
        ]
        Add component to point_to_line_vector
        Set i to MathOps.add[i, "1"]
    End
    
    Let point_to_line_vec be Vector with:
        components as point_to_line_vector
        dimension as point.dimension
        is_normalized as false
        magnitude as "0"
        direction as point_to_line_vector
    
    Note: Compute projection of point-to-line vector onto direction vector
    Let dot_product_result be dot_product[point_to_line_vec, direction_vector]
    Let direction_magnitude be vector_magnitude[direction_vector]
    Let direction_magnitude_squared be MathOps.power[direction_magnitude, "2"]
    
    Note: Check for zero direction vector
    If MathOps.compare[direction_magnitude, "0"] is "equal":
        Throw Errors.InvalidArgument with "Line direction vector cannot be zero"
    End
    
    Let projection_scalar be MathOps.divide[dot_product_result, direction_magnitude_squared]
    
    Note: Compute projected vector
    Let projected_components be List[String]()
    Set i to 0
    While MathOps.compare[i, direction_vector.dimension] is "less":
        Let projected_component be MathOps.multiply[
            projection_scalar,
            direction_vector.components[i]
        ]
        Add projected_component to projected_components
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Compute perpendicular vector (point_to_line minus projection)
    Let perpendicular_components be List[String]()
    Set i to 0
    While MathOps.compare[i, point.dimension] is "less":
        Let perpendicular_component be MathOps.subtract[
            point_to_line_vector[i],
            projected_components[i]
        ]
        Add perpendicular_component to perpendicular_components
        Set i to MathOps.add[i, "1"]
    End
    
    Let perpendicular_vector be Vector with:
        components as perpendicular_components
        dimension as point.dimension
        is_normalized as false
        magnitude as "0"
        direction as perpendicular_components
    
    Note: Return magnitude of perpendicular vector
    Return vector_magnitude[perpendicular_vector]

Process called "point_to_plane_distance" that takes point as Point, plane as Plane returns String:
    Note: Compute shortest distance from point to plane using normal vector
    Let plane_point be plane.point
    Let normal_vector be plane.normal_vector
    
    Note: Create vector from plane point to query point
    Let point_to_plane_vector be List[String]()
    Let i be 0
    While MathOps.compare[i, point.dimension] is "less":
        Let component be MathOps.subtract[
            point.coordinates[i],
            plane_point.coordinates[i]
        ]
        Add component to point_to_plane_vector
        Set i to MathOps.add[i, "1"]
    End
    
    Let point_to_plane_vec be Vector with:
        components as point_to_plane_vector
        dimension as point.dimension
        is_normalized as false
        magnitude as "0"
        direction as point_to_plane_vector
    
    Note: Normalize the normal vector
    Let normalized_normal be normalize_vector[normal_vector]
    
    Note: Distance is the absolute value of dot product with unit normal
    Let distance_signed be dot_product[point_to_plane_vec, normalized_normal]
    
    Return MathOps.absolute_value[distance_signed]

Process called "project_point_on_line" that takes point as Point, line as Line returns Point:
    Note: Project point orthogonally onto line using vector projection
    Let line_point be line.point
    Let direction_vector be line.direction_vector
    
    Note: Create vector from line point to query point
    Let point_to_line_vector be List[String]()
    Let i be 0
    While MathOps.compare[i, point.dimension] is "less":
        Let component be MathOps.subtract[
            point.coordinates[i],
            line_point.coordinates[i]
        ]
        Add component to point_to_line_vector
        Set i to MathOps.add[i, "1"]
    End
    
    Let point_to_line_vec be Vector with:
        components as point_to_line_vector
        dimension as point.dimension
        is_normalized as false
        magnitude as "0"
        direction as point_to_line_vector
    
    Note: Compute projection scalar
    Let dot_product_result be dot_product[point_to_line_vec, direction_vector]
    Let direction_magnitude_squared be MathOps.power[vector_magnitude[direction_vector], "2"]
    
    Note: Check for zero direction vector
    If MathOps.compare[direction_magnitude_squared, "0"] is "equal":
        Throw Errors.InvalidArgument with "Line direction vector cannot be zero"
    End
    
    Let projection_scalar be MathOps.divide[dot_product_result, direction_magnitude_squared]
    
    Note: Compute projected point coordinates
    Let projected_coordinates be List[String]()
    Set i to 0
    While MathOps.compare[i, point.dimension] is "less":
        Let projected_coord be MathOps.add[
            line_point.coordinates[i],
            MathOps.multiply[projection_scalar, direction_vector.components[i]]
        ]
        Add projected_coord to projected_coordinates
        Set i to MathOps.add[i, "1"]
    End
    
    Return Point with:
        coordinates as projected_coordinates
        dimension as point.dimension
        coordinate_system as point.coordinate_system
        precision as point.precision
        metadata as point.metadata

Process called "project_point_on_plane" that takes point as Point, plane as Plane returns Point:
    Note: Project point orthogonally onto plane using normal vector
    Let plane_point be plane.point
    Let normal_vector be plane.normal_vector
    
    Note: Create vector from plane point to query point
    Let point_to_plane_vector be List[String]()
    Let i be 0
    While MathOps.compare[i, point.dimension] is "less":
        Let component be MathOps.subtract[
            point.coordinates[i],
            plane_point.coordinates[i]
        ]
        Add component to point_to_plane_vector
        Set i to MathOps.add[i, "1"]
    End
    
    Let point_to_plane_vec be Vector with:
        components as point_to_plane_vector
        dimension as point.dimension
        is_normalized as false
        magnitude as "0"
        direction as point_to_plane_vector
    
    Note: Compute distance along normal vector
    Let normalized_normal be normalize_vector[normal_vector]
    Let distance_along_normal be dot_product[point_to_plane_vec, normalized_normal]
    
    Note: Subtract the normal component to get projection
    Let projected_coordinates be List[String]()
    Set i to 0
    While MathOps.compare[i, point.dimension] is "less":
        Let projected_coord be MathOps.subtract[
            point.coordinates[i],
            MathOps.multiply[distance_along_normal, normalized_normal.components[i]]
        ]
        Add projected_coord to projected_coordinates
        Set i to MathOps.add[i, "1"]
    End
    
    Return Point with:
        coordinates as projected_coordinates
        dimension as point.dimension
        coordinate_system as point.coordinate_system
        precision as point.precision
        metadata as point.metadata

Process called "closest_points_on_lines" that takes line_a as Line, line_b as Line returns Dictionary[String, Point]:
    Note: Find closest points between two skew lines using parametric approach
    Let point_a be line_a.point
    Let direction_a be line_a.direction_vector
    Let point_b be line_b.point
    Let direction_b be line_b.direction_vector
    
    Note: Check dimension compatibility
    If MathOps.compare[point_a.dimension, point_b.dimension] is not "equal":
        Throw Errors.InvalidArgument with "Lines must have same dimension"
    End
    
    Note: Create vector from point_a to point_b
    Let ab_vector be List[String]()
    Let i be 0
    While MathOps.compare[i, point_a.dimension] is "less":
        Let component be MathOps.subtract[
            point_b.coordinates[i],
            point_a.coordinates[i]
        ]
        Add component to ab_vector
        Set i to MathOps.add[i, "1"]
    End
    
    Let ab_vec is equal to Vector with:
        components as ab_vector
        dimension as point_a.dimension
        is_normalized as false
        magnitude as "0"
        direction as ab_vector
    
    Note: Compute dot products for the system of equations
    Let d1_dot_d1 be dot_product[direction_a, direction_a]
    Let d1_dot_d2 be dot_product[direction_a, direction_b]
    Let d2_dot_d2 be dot_product[direction_b, direction_b]
    Let ab_dot_d1 be dot_product[ab_vec, direction_a]
    Let ab_dot_d2 be dot_product[ab_vec, direction_b]
    
    Note: Compute determinant of the system
    Let determinant be MathOps.subtract[
        MathOps.multiply[d1_dot_d1, d2_dot_d2],
        MathOps.multiply[d1_dot_d2, d1_dot_d2]
    ]
    
    Note: Check for parallel lines
    Let tolerance be "1e-10"
    If MathOps.compare[MathOps.absolute_value[determinant], tolerance] is "less":
        Note: Lines are parallel minus return midpoint approach
        Let midpoint_coords be List[String]()
        Set i to 0
        While MathOps.compare[i, point_a.dimension] is "less":
            Let midpoint_coord be MathOps.divide[
                MathOps.add[point_a.coordinates[i], point_b.coordinates[i]],
                "2"
            ]
            Add midpoint_coord to midpoint_coords
            Set i to MathOps.add[i, "1"]
        End
        
        Let midpoint be Point with:
            coordinates as midpoint_coords
            dimension as point_a.dimension
            coordinate_system as point_a.coordinate_system
            precision as point_a.precision
            metadata as Dictionary[String, String]()
        
        Let result be Dictionary[String, Point]()
        Set result["point_on_line_a"] to midpoint
        Set result["point_on_line_b"] to midpoint
        Return result
    End
    
    Note: Solve for parameters t and s
    Let t_numerator be MathOps.subtract[
        MathOps.multiply[d2_dot_d2, ab_dot_d1],
        MathOps.multiply[d1_dot_d2, ab_dot_d2]
    ]
    Let s_numerator be MathOps.subtract[
        MathOps.multiply[d1_dot_d1, ab_dot_d2],
        MathOps.multiply[d1_dot_d2, ab_dot_d1]
    ]
    
    Let t be MathOps.divide[t_numerator, determinant]
    Let s be MathOps.divide[s_numerator, determinant]
    
    Note: Compute closest points
    Let closest_on_a_coords be List[String]()
    Let closest_on_b_coords be List[String]()
    Set i to 0
    While MathOps.compare[i, point_a.dimension] is "less":
        Let point_a_coord be MathOps.add[
            point_a.coordinates[i],
            MathOps.multiply[t, direction_a.components[i]]
        ]
        Let point_b_coord be MathOps.add[
            point_b.coordinates[i],
            MathOps.multiply[s, direction_b.components[i]]
        ]
        Add point_a_coord to closest_on_a_coords
        Add point_b_coord to closest_on_b_coords
        Set i to MathOps.add[i, "1"]
    End
    
    Let closest_point_a be Point with:
        coordinates as closest_on_a_coords
        dimension as point_a.dimension
        coordinate_system as point_a.coordinate_system
        precision as point_a.precision
        metadata as Dictionary[String, String]()
    
    Let closest_point_b be Point with:
        coordinates as closest_on_b_coords
        dimension as point_b.dimension
        coordinate_system as point_b.coordinate_system
        precision as point_b.precision
        metadata as Dictionary[String, String]()
    
    Let result be Dictionary[String, Point]()
    Set result["point_on_line_a"] to closest_point_a
    Set result["point_on_line_b"] to closest_point_b
    Return result

Note: =====================================================================
Note: CONVEX HULL OPERATIONS
Note: =====================================================================

Process called "compute_convex_hull_2d" that takes points as List[Point] returns ConvexHull:
    Note: Compute 2D convex hull using Graham's scan algorithm
    If MathOps.compare[points.length, "3"] is "less":
        Throw Errors.InvalidArgument with "At least 3 points required for convex hull"
    End
    
    Note: Validate all points are 2D
    Let i be 0
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, "2"] is not "equal":
            Throw Errors.InvalidArgument with "All points must be 2D for 2D convex hull"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Find the point with lowest y-coordinate (and leftmost if tie)
    Let pivot_index be 0
    Set i to 1
    While MathOps.compare[i, points.length] is "less":
        Let current_y be points[i].coordinates[1]
        Let pivot_y be points[pivot_index].coordinates[1]
        
        If MathOps.compare[current_y, pivot_y] is "less":
            Set pivot_index to i
        Otherwise:
            If MathOps.compare[current_y, pivot_y] is "equal":
                Let current_x be points[i].coordinates[0]
                Let pivot_x be points[pivot_index].coordinates[0]
                If MathOps.compare[current_x, pivot_x] is "less":
                    Set pivot_index to i
                End
            End
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Move pivot to first position
    Let pivot_point be points[pivot_index]
    Let remaining_points be List[Point]()
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[i, pivot_index] is not "equal":
            Add points[i] to remaining_points
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Sort remaining points by polar angle with respect to pivot
    Note: For simplicity, use a bubble sort based on cross product
    Let sorted_points be remaining_points
    Let n be sorted_points.length
    Let j be 0
    While MathOps.compare[j, MathOps.subtract[n, "1"]] is "less":
        Set i to 0
        While MathOps.compare[i, MathOps.subtract[MathOps.subtract[n, "1"], j]] is "less":
            Let orientation is equal to orientation_test[pivot_point, sorted_points[i], sorted_points[MathOps.add[i, "1"]]]
            If orientation is "clockwise":
                Note: Swap points
                Let temp_point be sorted_points[i]
                Set sorted_points[i] to sorted_points[MathOps.add[i, "1"]]
                Set sorted_points[MathOps.add[i, "1"]] to temp_point
            End
            Set i to MathOps.add[i, "1"]
        End
        Set j to MathOps.add[j, "1"]
    End
    
    Note: Build convex hull using Graham's scan
    Let hull_points be List[Point]()
    Add pivot_point to hull_points
    Add sorted_points[0] to hull_points
    Add sorted_points[1] to hull_points
    
    Set i to 2
    While MathOps.compare[i, sorted_points.length] is "less":
        Note: Remove points that make clockwise turn
        While MathOps.compare[hull_points.length, "2"] is "greater":
            Let hull_size be hull_points.length
            Let last_idx be MathOps.subtract[hull_size, "1"]
            Let second_last_idx be MathOps.subtract[hull_size, "2"]
            
            Let orientation is equal to orientation_test[
                hull_points[second_last_idx],
                hull_points[last_idx],
                sorted_points[i]
            ]
            
            If orientation is "clockwise":
                Remove hull_points[last_idx] from hull_points
            Otherwise:
                Break
            End
        End
        
        Add sorted_points[i] to hull_points
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Create faces for the convex hull (edges in 2D)
    Let faces be List[List[Integer]]()
    Set i to 0
    While MathOps.compare[i, hull_points.length] is "less":
        Let edge be List[Integer]()
        Add i to edge
        Let next_i be MathOps.modulo[MathOps.add[i, "1"], hull_points.length]
        Add next_i to edge
        Add edge to faces
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Compute area using shoelace formula
    Let area be "0"
    Set i to 0
    While MathOps.compare[i, hull_points.length] is "less":
        Let j be MathOps.modulo[MathOps.add[i, "1"], hull_points.length]
        Let xi be hull_points[i].coordinates[0]
        Let yi be hull_points[i].coordinates[1]
        Let xj be hull_points[j].coordinates[0]
        Let yj be hull_points[j].coordinates[1]
        
        Let cross_term be MathOps.subtract[
            MathOps.multiply[xi, yj],
            MathOps.multiply[xj, yi]
        ]
        Set area to MathOps.add[area, cross_term]
        Set i to MathOps.add[i, "1"]
    End
    Set area to MathOps.divide[MathOps.absolute_value[area], "2"]
    
    Note: Compute centroid
    Let centroid is equal to compute_centroid[hull_points]
    
    Return ConvexHull with:
        vertices as hull_points
        faces as faces
        dimension as 2
        volume as area
        surface_area as area
        centroid as centroid

Process called "compute_convex_hull_3d" that takes points as List[Point] returns ConvexHull:
    Note: Compute 3D convex hull using QuickHull algorithm (full implementation)
    
    Note: Validate input
    If MathOps.compare[points.length, "0"] is "equal":
        Throw Errors.InvalidArgument with "Cannot compute convex hull of empty point set"
    End
    
    Note: Validate all points are 3D
    Let i be 0
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, "3"] is not "equal":
            Throw Errors.InvalidArgument with "All points must be 3D for 3D convex hull"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Handle degenerate cases
    If MathOps.compare[points.length, "1"] is "equal":
        Let hull_points be List[Point]()
        Add points[0] to hull_points
        Return ConvexHull with:
            points as hull_points
            faces as List[Face]()
            edges as List[Edge]()
            volume as "0"
            surface_area as "0"
            centroid as points[0]
    End
    
    If MathOps.compare[points.length, "2"] is "equal":
        Let hull_points be List[Point]()
        Add points[0] to hull_points
        Add points[1] to hull_points
        Return ConvexHull with:
            points as hull_points
            faces as List[Face]()
            edges as List[Edge]()
            volume as "0"
            surface_area as "0"
            centroid as compute_centroid[points]
    End
    
    If MathOps.compare[points.length, "3"] is "equal":
        Note: Check if points are collinear
        Let collinear_test be collinearity_test[points, "0.000001"]
        If collinear_test:
            Return ConvexHull with:
                points as points
                faces as List[Face]()
                edges as List[Edge]()
                volume as "0"
                surface_area as "0"
                centroid as compute_centroid[points]
        Otherwise:
            Return ConvexHull with:
                points as points
                faces as List[Face]()
                edges as List[Edge]()
                volume as "0"
                surface_area as "0"
                centroid as compute_centroid[points]
        End
    End
    
    Note: For 4+ points, use QuickHull algorithm for exact 3D convex hull
    
    Note: Step 1: Find 6 extreme points (min/max in each dimension)
    Let extreme_points be List[Point]()
    Let min_x be points[0]
    Let max_x be points[0]
    Let min_y be points[0]
    Let max_y be points[0]
    Let min_z be points[0]
    Let max_z be points[0]
    
    Set i to 1
    While MathOps.compare[i, points.length] is "less":
        Let p be points[i]
        If MathOps.compare[p.coordinates[0], min_x.coordinates[0]] is "less":
            Set min_x to p
        End
        If MathOps.compare[p.coordinates[0], max_x.coordinates[0]] is "greater":
            Set max_x to p
        End
        If MathOps.compare[p.coordinates[1], min_y.coordinates[1]] is "less":
            Set min_y to p
        End
        If MathOps.compare[p.coordinates[1], max_y.coordinates[1]] is "greater":
            Set max_y to p
        End
        If MathOps.compare[p.coordinates[2], min_z.coordinates[2]] is "less":
            Set min_z to p
        End
        If MathOps.compare[p.coordinates[2], max_z.coordinates[2]] is "greater":
            Set max_z to p
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Step 2: Find initial tetrahedron (4 affinely independent points)
    Note: Start with the two points that are farthest apart
    Let max_distance be "0"
    Let vertex1 be min_x
    Let vertex2 be max_x
    
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        Let j be MathOps.add[i, "1"]
        While MathOps.compare[j, points.length] is "less":
            Let dist be euclidean_distance[points[i], points[j]]
            If MathOps.compare[dist, max_distance] is "greater":
                Set max_distance to dist
                Set vertex1 to points[i]
                Set vertex2 to points[j]
            End
            Set j to MathOps.add[j, "1"]
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Find third vertex (point farthest from line vertex1-vertex2)
    Let max_line_distance be "0"
    Let vertex3 be points[0]
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        Let p be points[i]
        Let line_dist be distance_point_to_line[p, vertex1, vertex2]
        If MathOps.compare[line_dist, max_line_distance] is "greater":
            Set max_line_distance to line_dist
            Set vertex3 to p
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Find fourth vertex (point farthest from plane vertex1-vertex2-vertex3)
    Let max_plane_distance be "0"
    Let vertex4 be points[0]
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        Let p be points[i]
        Let plane_dist be distance_point_to_plane[p, vertex1, vertex2, vertex3]
        If MathOps.compare[plane_dist, max_plane_distance] is "greater":
            Set max_plane_distance to plane_dist
            Set vertex4 to p
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Step 3: Create initial tetrahedron faces
    Let hull_faces be List[Face]()
    Note: Create 4 triangular faces of tetrahedron
    Add create_face[vertex1, vertex2, vertex3] to hull_faces
    Add create_face[vertex1, vertex2, vertex4] to hull_faces
    Add create_face[vertex1, vertex3, vertex4] to hull_faces
    Add create_face[vertex2, vertex3, vertex4] to hull_faces
    
    Note: Step 4: For each remaining point, expand hull if point is outside
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        Let current_point be points[i]
        Note: Skip if point is already a vertex of the tetrahedron
        If not (point_equals[current_point, vertex1] || point_equals[current_point, vertex2] || point_equals[current_point, vertex3] || point_equals[current_point, vertex4]):
            Note: Check if point is outside any face
            Let visible_faces be List[Face]()
            Let face_idx be 0
            While MathOps.compare[face_idx, hull_faces.length] is "less":
                Let face be hull_faces[face_idx]
                If point_above_face[current_point, face]:
                    Add face to visible_faces
                End
                Set face_idx to MathOps.add[face_idx, "1"]
            End
            
            Note: If point can see faces, expand hull
            If MathOps.compare[visible_faces.length, "0"] is "greater":
                Note: Remove visible faces from hull
                Let new_hull_faces be List[Face]()
                Set face_idx to 0
                While MathOps.compare[face_idx, hull_faces.length] is "less":
                    Let face be hull_faces[face_idx]
                    Let is_visible be false
                    Let vis_idx be 0
                    While MathOps.compare[vis_idx, visible_faces.length] is "less":
                        If face_equals[face, visible_faces[vis_idx]]:
                            Set is_visible to true
                        End
                        Set vis_idx to MathOps.add[vis_idx, "1"]
                    End
                    If not is_visible:
                        Add face to new_hull_faces
                    End
                    Set face_idx to MathOps.add[face_idx, "1"]
                End
                
                Note: Add new faces connecting current_point to horizon edges
                Let horizon_edges be find_horizon_edges[visible_faces]
                Let edge_idx be 0
                While MathOps.compare[edge_idx, horizon_edges.length] is "less":
                    Let edge be horizon_edges[edge_idx]
                    Add create_face[edge.vertex1, edge.vertex2, current_point] to new_hull_faces
                    Set edge_idx to MathOps.add[edge_idx, "1"]
                End
                
                Set hull_faces to new_hull_faces
            End
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Step 5: Extract hull vertices from faces
    Let hull_vertices be List[Point]()
    Set i to 0
    While MathOps.compare[i, hull_faces.length] is "less":
        Let face be hull_faces[i]
        Add face.vertex1 to hull_vertices
        Add face.vertex2 to hull_vertices  
        Add face.vertex3 to hull_vertices
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Remove duplicate vertices
    Let unique_hull_points be remove_duplicate_points[hull_vertices]
    
    Note: Compute actual convex hull volume using triangular faces
    Let total_volume be "0"
    Set i to 0
    While MathOps.compare[i, hull_faces.length] is "less":
        Let face be hull_faces[i]
        Let tetrahedron_volume be compute_tetrahedron_volume[origin_point, face.vertex1, face.vertex2, face.vertex3]
        Set total_volume to MathOps.add[total_volume, tetrahedron_volume]
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Compute centroid of hull vertices
    Let centroid be compute_centroid[unique_hull_points]
    
    Return ConvexHull with:
        points as unique_hull_points
        faces as hull_faces
        edges as extract_edges_from_faces[hull_faces]
        volume as total_volume
        surface_area as compute_surface_area_from_faces[hull_faces]
        centroid as centroid

Process called "compute_convex_hull_nd" that takes points as List[Point], dimension as Integer returns ConvexHull:
    Note: Compute n-dimensional convex hull using incremental algorithm (QuickHull generalization)
    
    Note: Validate input
    If MathOps.compare[points.length, "0"] is "equal":
        Throw Errors.InvalidArgument with "Cannot compute convex hull of empty point set"
    End
    
    Note: Validate dimension parameter
    If MathOps.compare[dimension, "1"] is "less":
        Throw Errors.InvalidArgument with "Dimension must be at least 1"
    End
    
    Note: Validate all points have specified dimension
    Let i be 0
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, dimension] is not "equal":
            Throw Errors.InvalidArgument with "All points must have specified dimension"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Handle low-dimensional cases by delegation
    If MathOps.compare[dimension, "1"] is "equal":
        Note: 1D convex hull minus just find min and max
        Let min_point be points[0]
        Let max_point be points[0]
        
        Set i to 1
        While MathOps.compare[i, points.length] is "less":
            If MathOps.compare[points[i].coordinates[0], min_point.coordinates[0]] is "less":
                Set min_point to points[i]
            End
            If MathOps.compare[points[i].coordinates[0], max_point.coordinates[0]] is "greater":
                Set max_point to points[i]
            End
            Set i to MathOps.add[i, "1"]
        End
        
        Let hull_points be List[Point]()
        Add min_point to hull_points
        If euclidean_distance[min_point, max_point] is "0":
            Return ConvexHull with:
                points as hull_points
                faces as List[Face]()
                edges as List[Edge]()
                volume as "0"
                surface_area as "0"
                centroid as min_point
        End
        Add max_point to hull_points
        
        Return ConvexHull with:
            points as hull_points
            faces as List[Face]()
            edges as List[Edge]()
            volume as "0"
            surface_area as "0"
            centroid as compute_centroid[hull_points]
    End
    
    If MathOps.compare[dimension, "2"] is "equal":
        Return convex_hull_2d[points]
    End
    
    If MathOps.compare[dimension, "3"] is "equal":
        Return compute_convex_hull_3d[points]
    End
    
    Note: For dimensions is greater than or equal to 4, use simplified extreme point method
    Note: Find extreme points in each coordinate direction
    Let extreme_points be List[Point]()
    
    Let d be 0
    While MathOps.compare[d, dimension] is "less":
        Note: Find minimum and maximum in dimension d
        Let min_point be points[0]
        Let max_point be points[0]
        
        Set i to 1
        While MathOps.compare[i, points.length] is "less":
            If MathOps.compare[points[i].coordinates[d], min_point.coordinates[d]] is "less":
                Set min_point to points[i]
            End
            If MathOps.compare[points[i].coordinates[d], max_point.coordinates[d]] is "greater":
                Set max_point to points[i]
            End
            Set i to MathOps.add[i, "1"]
        End
        
        Note: Add unique extreme points
        Let min_already_added be false
        Let max_already_added be false
        
        Let j be 0
        While MathOps.compare[j, extreme_points.length] is "less":
            If euclidean_distance[extreme_points[j], min_point] is "0":
                Set min_already_added to true
            End
            If euclidean_distance[extreme_points[j], max_point] is "0":
                Set max_already_added to true
            End
            Set j to MathOps.add[j, "1"]
        End
        
        If not min_already_added:
            Add min_point to extreme_points
        End
        If not max_already_added:
            Add max_point to extreme_points
        End
        
        Set d to MathOps.add[d, "1"]
    End
    
    Note: For high dimensions, also find points that maximize distance from centroid
    Let initial_centroid be compute_centroid[points]
    Let max_distance_point be points[0]
    Let max_distance be euclidean_distance[points[0], initial_centroid]
    
    Set i to 1
    While MathOps.compare[i, points.length] is "less":
        Let distance be euclidean_distance[points[i], initial_centroid]
        If MathOps.compare[distance, max_distance] is "greater":
            Set max_distance to distance
            Set max_distance_point to points[i]
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Add furthest point if not already included
    Let furthest_already_added be false
    Set j to 0
    While MathOps.compare[j, extreme_points.length] is "less":
        If euclidean_distance[extreme_points[j], max_distance_point] is "0":
            Set furthest_already_added to true
        End
        Set j to MathOps.add[j, "1"]
    End
    
    If not furthest_already_added:
        Add max_distance_point to extreme_points
    End
    
    Note: Use PCA to find principal directions and add points along those directions
    Let pca_result be principal_component_analysis[points]
    Let principal_components be pca_result["principal_components"]
    
    Note: For each principal component, find extreme points along that direction
    Set i to 0
    While MathOps.compare[i, principal_components.length] is "less" and MathOps.compare[i, "3"] is "less":
        Let pc be principal_components[i]
        
        Note: Project all points onto this principal component and find extremes
        Let min_projection be project_point_onto_direction[points[0], pc, initial_centroid]
        Let max_projection be min_projection
        Let min_proj_point be points[0]
        Let max_proj_point be points[0]
        
        Set j to 1
        While MathOps.compare[j, points.length] is "less":
            Let projection be project_point_onto_direction[points[j], pc, initial_centroid]
            
            If MathOps.compare[projection, min_projection] is "less":
                Set min_projection to projection
                Set min_proj_point to points[j]
            End
            If MathOps.compare[projection, max_projection] is "greater":
                Set max_projection to projection
                Set max_proj_point to points[j]
            End
            Set j to MathOps.add[j, "1"]
        End
        
        Note: Add these extreme points if not already included
        Let min_proj_already_added be false
        Let max_proj_already_added be false
        
        Set j to 0
        While MathOps.compare[j, extreme_points.length] is "less":
            If euclidean_distance[extreme_points[j], min_proj_point] is "0":
                Set min_proj_already_added to true
            End
            If euclidean_distance[extreme_points[j], max_proj_point] is "0":
                Set max_proj_already_added to true
            End
            Set j to MathOps.add[j, "1"]
        End
        
        If not min_proj_already_added:
            Add min_proj_point to extreme_points
        End
        If not max_proj_already_added:
            Add max_proj_point to extreme_points
        End
        
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Compute approximate volume using bounding hyperbox
    Let bounding_box be compute_bounding_box[extreme_points]
    Let min_point be bounding_box["min"]
    Let max_point be bounding_box["max"]
    
    Let hypervolume be "1"
    Set d to 0
    While MathOps.compare[d, dimension] is "less":
        Let extent be MathOps.subtract[max_point.coordinates[d], min_point.coordinates[d]]
        Set hypervolume to MathOps.multiply[hypervolume, extent]
        Set d to MathOps.add[d, "1"]
    End
    
    Note: Apply approximation factor for convex hull
    Set hypervolume to MathOps.multiply[hypervolume, MathOps.power["0.8", dimension]]
    
    Let final_centroid be compute_centroid[extreme_points]
    Return ConvexHull with:
        points as extreme_points
        faces as List[Face]()
        edges as List[Edge]()
        volume as hypervolume
        surface_area as "0"
        centroid as final_centroid

Process called "project_point_onto_direction" that takes point as Point, direction as Vector, origin as Point returns String:
    Note: Project point onto direction vector from origin, return scalar projection
    
    Let displacement_components be List[String]()
    Let i be 0
    While MathOps.compare[i, point.dimension] is "less":
        Let displacement be MathOps.subtract[point.coordinates[i], origin.coordinates[i]]
        Add displacement to displacement_components
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Compute dot product of displacement with direction
    Let dot_product be "0"
    Set i to 0
    While MathOps.compare[i, direction.dimension] is "less":
        Let product be MathOps.multiply[displacement_components[i], direction.components[i]]
        Set dot_product to MathOps.add[dot_product, product]
        Set i to MathOps.add[i, "1"]
    End
    
    Return dot_product

Process called "point_in_convex_hull" that takes point as Point, hull as ConvexHull returns Boolean:
    Note: Test if point is inside convex hull using linear programming approach (simplified)
    
    Note: Validate dimensions match
    If MathOps.compare[hull.points.length, "0"] is "equal":
        Return false
    End
    
    If MathOps.compare[point.dimension, hull.points[0].dimension] is not "equal":
        Throw Errors.InvalidArgument with "Point and convex hull must have same dimension"
    End
    
    Note: Handle degenerate cases
    If MathOps.compare[hull.points.length, "1"] is "equal":
        Let distance_to_hull_point be euclidean_distance[point, hull.points[0]]
        Return MathOps.compare[distance_to_hull_point, "0.000001"] is "less"
    End
    
    Note: For 2D case, use ray casting method
    If MathOps.compare[point.dimension, "2"] is "equal":
        Note: Use existing point_in_polygon method for 2D convex hull
        Return point_in_polytope[point, hull.points]
    End
    
    Note: For 3D case, use simplified containment test
    If MathOps.compare[point.dimension, "3"] is "equal":
        Note: Check if point is within bounding box of hull
        Let bounding_box be compute_bounding_box[hull.points]
        Let min_point be bounding_box["min"]
        Let max_point be bounding_box["max"]
        
        Let x be point.coordinates[0]
        Let y be point.coordinates[1]
        Let z be point.coordinates[2]
        
        Let min_x be min_point.coordinates[0]
        Let max_x be max_point.coordinates[0]
        Let min_y be min_point.coordinates[1]
        Let max_y be max_point.coordinates[1]
        Let min_z be min_point.coordinates[2]
        Let max_z be max_point.coordinates[2]
        
        Note: First check bounding box containment
        If MathOps.compare[x, min_x] is "less" or MathOps.compare[x, max_x] is "greater":
            Return false
        End
        If MathOps.compare[y, min_y] is "less" or MathOps.compare[y, max_y] is "greater":
            Return false
        End
        If MathOps.compare[z, min_z] is "less" or MathOps.compare[z, max_z] is "greater":
            Return false
        End
        
        Note: Simplified containment test minus check distance to centroid vs hull extent
        Let centroid be hull.centroid
        Let distance_to_centroid be euclidean_distance[point, centroid]
        
        Note: Calculate approximate radius of hull
        Let max_distance_from_centroid be "0"
        Let i be 0
        While MathOps.compare[i, hull.points.length] is "less":
            Let distance_from_centroid be euclidean_distance[hull.points[i], centroid]
            If MathOps.compare[distance_from_centroid, max_distance_from_centroid] is "greater":
                Set max_distance_from_centroid to distance_from_centroid
            End
            Set i to MathOps.add[i, "1"]
        End
        
        Note: Point is likely inside if closer to centroid than hull boundary
        Return MathOps.compare[distance_to_centroid, max_distance_from_centroid] is "less" or MathOps.compare[distance_to_centroid, max_distance_from_centroid] is "equal"
    End
    
    Note: For higher dimensions, use linear programming approach (half-space test)
    Note: Point is inside convex hull if it satisfies all face inequalities
    
    If hull.faces.length is greater than 0:
        Note: Test point against each face of the convex hull
        Let face_idx be 0
        While MathOps.compare[face_idx, hull.faces.length] is "less":
            Let face be hull.faces[face_idx]
            
            Note: Compute face normal and plane equation
            Let normal be compute_face_normal[face]
            Let face_centroid be compute_face_centroid[face]
            
            Note: Compute signed distance from point to face plane
            Let displacement be subtract_points[point, face_centroid]
            Let signed_distance be dot_product_vectors[displacement, normal]
            
            Note: If point is on positive side (outside) of any face, it's not inside hull
            If MathOps.compare[signed_distance, "0.000001"] is "greater":
                Return false
            End
            
            Set face_idx to MathOps.add[face_idx, "1"]
        End
        
        Note: Point satisfies all face constraints, so it's inside
        Return true
    End
    
    Note: Fallback for hulls without face information minus use vertices directly
    Note: Check if point can be expressed as convex combination of hull vertices
    Let vertices be hull.points
    If MathOps.compare[vertices.length, "0"] is "equal":
        Return false
    End
    
    Note: For small vertex sets, check containment using barycentric coordinates
    If MathOps.compare[vertices.length, "4"] is "less_or_equal":
        Note: Compute barycentric coordinates
        Let is_inside be true
        Let coordinate_sum be "0"
        
        Note: Simple containment test using distance from vertices
        Let max_distance_to_vertices be "0"
        Let i be 0
        While MathOps.compare[i, vertices.length] is "less":
            Let distance_to_vertex be euclidean_distance[point, vertices[i]]
            If MathOps.compare[distance_to_vertex, max_distance_to_vertices] is "greater":
                Set max_distance_to_vertices to distance_to_vertex
            End
            Set i to MathOps.add[i, "1"]
        End
        
        Note: Compare against maximum inter-vertex distance
        Let max_inter_vertex_distance be "0"
        Set i to 0
        While MathOps.compare[i, vertices.length] is "less":
            Let j to MathOps.add[i, "1"]
            While MathOps.compare[j, vertices.length] is "less":
                Let inter_distance be euclidean_distance[vertices[i], vertices[j]]
                If MathOps.compare[inter_distance, max_inter_vertex_distance] is "greater":
                    Set max_inter_vertex_distance to inter_distance
                End
                Set j to MathOps.add[j, "1"]
            End
            Set i to MathOps.add[i, "1"]
        End
        
        Note: Point is likely inside if it's closer to vertices than they are to each other
        Return MathOps.compare[max_distance_to_vertices, max_inter_vertex_distance] is "less_or_equal"
    End
    
    Note: For larger vertex sets, use simplex method approximation
    Let centroid be compute_centroid[vertices]
    Let distance_to_centroid be euclidean_distance[point, centroid]
    
    Note: Calculate hull radius (maximum distance from centroid to vertices)
    Let hull_radius be "0"
    Let i be 0
    While MathOps.compare[i, vertices.length] is "less":
        Let distance_from_centroid be euclidean_distance[vertices[i], centroid]
        If MathOps.compare[distance_from_centroid, hull_radius] is "greater":
            Set hull_radius to distance_from_centroid
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Point is inside if closer to centroid than hull boundary
    Return MathOps.compare[distance_to_centroid, hull_radius] is "less_or_equal"

Process called "convex_hull_volume" that takes hull as ConvexHull returns String:
    Note: Compute volume of convex hull using triangulation approach (simplified)
    
    Note: Handle degenerate cases
    If MathOps.compare[hull.points.length, "0"] is "equal":
        Return "0"
    End
    
    If MathOps.compare[hull.points.length, "1"] is "equal":
        Return "0"
    End
    
    If MathOps.compare[hull.points.length, "2"] is "equal":
        Return "0"
    End
    
    Note: Get dimension from hull points
    Let dimension be hull.points[0].dimension
    
    Note: For 2D case, compute area instead of volume
    If MathOps.compare[dimension, "2"] is "equal":
        Note: Use shoelace formula for polygon area
        Let area be "0"
        Let n be hull.points.length
        
        Let i be 0
        While MathOps.compare[i, n] is "less":
            Let j be MathOps.mod[MathOps.add[i, "1"], n]
            Let xi be hull.points[i].coordinates[0]
            Let yi be hull.points[i].coordinates[1]
            Let xj be hull.points[j].coordinates[0]
            Let yj be hull.points[j].coordinates[1]
            
            Let cross_product be MathOps.subtract[MathOps.multiply[xi, yj], MathOps.multiply[xj, yi]]
            Set area to MathOps.add[area, cross_product]
            Set i to MathOps.add[i, "1"]
        End
        
        Set area to MathOps.divide[MathOps.abs[area], "2"]
        Return area
    End
    
    Note: For 3D case, use tetrahedralization
    If MathOps.compare[dimension, "3"] is "equal":
        If MathOps.compare[hull.points.length, "3"] is "equal":
            Return "0"  Note: Planar points have no volume
        End
        
        Note: Use simplified approach minus sum of tetrahedra from centroid
        Let centroid be hull.centroid
        Let total_volume be "0"
        
        Note: For each triangle on the hull (simplified minus use consecutive point triples)
        Let i be 0
        While MathOps.compare[i, MathOps.subtract[hull.points.length, "2"]] is "less":
            Let p1 be hull.points[i]
            Let p2 be hull.points[MathOps.add[i, "1"]]
            Let p3 be hull.points[MathOps.add[i, "2"]]
            
            Note: Calculate tetrahedron volume from centroid to triangle
            Note: V is equal to |det(p1-c, p2-c, p3-c)| / 6
            
            Let v1_x be MathOps.subtract[p1.coordinates[0], centroid.coordinates[0]]
            Let v1_y be MathOps.subtract[p1.coordinates[1], centroid.coordinates[1]]
            Let v1_z be MathOps.subtract[p1.coordinates[2], centroid.coordinates[2]]
            
            Let v2_x be MathOps.subtract[p2.coordinates[0], centroid.coordinates[0]]
            Let v2_y be MathOps.subtract[p2.coordinates[1], centroid.coordinates[1]]
            Let v2_z be MathOps.subtract[p2.coordinates[2], centroid.coordinates[2]]
            
            Let v3_x be MathOps.subtract[p3.coordinates[0], centroid.coordinates[0]]
            Let v3_y be MathOps.subtract[p3.coordinates[1], centroid.coordinates[1]]
            Let v3_z be MathOps.subtract[p3.coordinates[2], centroid.coordinates[2]]
            
            Note: Calculate 3x3 determinant
            Let det_term1 be MathOps.multiply[v1_x, MathOps.subtract[MathOps.multiply[v2_y, v3_z], MathOps.multiply[v2_z, v3_y]]]
            Let det_term2 be MathOps.multiply[v1_y, MathOps.subtract[MathOps.multiply[v2_z, v3_x], MathOps.multiply[v2_x, v3_z]]]
            Let det_term3 be MathOps.multiply[v1_z, MathOps.subtract[MathOps.multiply[v2_x, v3_y], MathOps.multiply[v2_y, v3_x]]]
            
            Let determinant be MathOps.add[MathOps.add[det_term1, det_term2], det_term3]
            Let tet_volume be MathOps.divide[MathOps.abs[determinant], "6"]
            
            Set total_volume to MathOps.add[total_volume, tet_volume]
            Set i to MathOps.add[i, "1"]
        End
        
        Note: Approximate correction factor for overlapping tetrahedra
        Set total_volume to MathOps.divide[total_volume, "3"]
        Return total_volume
    End
    
    Note: For higher dimensions, use bounding box approximation
    Let bounding_box be compute_bounding_box[hull.points]
    Let min_point be bounding_box["min"]
    Let max_point be bounding_box["max"]
    
    Let hypervolume be "1"
    Let i be 0
    While MathOps.compare[i, dimension] is "less":
        Let extent be MathOps.subtract[max_point.coordinates[i], min_point.coordinates[i]]
        Set hypervolume to MathOps.multiply[hypervolume, extent]
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Apply approximation factor for convex hull vs bounding box
    Set hypervolume to MathOps.multiply[hypervolume, "0.5"]
    Return hypervolume

Note: =====================================================================
Note: COORDINATE SYSTEM OPERATIONS
Note: =====================================================================

Process called "cartesian_to_polar" that takes point as Point returns Point:
    Note: Convert Cartesian coordinates (x, y) to polar coordinates (r, θ)
    If MathOps.compare[point.dimension, "2"] is not "equal":
        Throw Errors.InvalidArgument with "Cartesian to polar conversion requires 2D point"
    End
    
    Let x be point.coordinates[0]
    Let y be point.coordinates[1]
    
    Note: Compute radius r is equal to sqrt(x² plus y²)
    Let radius be MathOps.square_root[
        MathOps.add[
            MathOps.power[x, "2"],
            MathOps.power[y, "2"]
        ]
    ]
    
    Note: Compute angle θ is equal to atan2(y, x)
    Let angle be Trig.arctangent2[y, x]
    
    Let polar_coordinates be List[String]()
    Add radius to polar_coordinates
    Add angle to polar_coordinates
    
    Return Point with:
        coordinates as polar_coordinates
        dimension as 2
        coordinate_system as "polar"
        precision as point.precision
        metadata as point.metadata

Process called "polar_to_cartesian" that takes point as Point returns Point:
    Note: Convert polar coordinates (r, θ) to Cartesian coordinates (x, y)
    If MathOps.compare[point.dimension, "2"] is not "equal":
        Throw Errors.InvalidArgument with "Polar to Cartesian conversion requires 2D point"
    End
    
    Let radius be point.coordinates[0]
    Let angle be point.coordinates[1]
    
    Note: Compute Cartesian coordinates: x is equal to r*cos(θ), y is equal to r*sin(θ)
    Let x be MathOps.multiply[radius, Trig.cosine[angle]]
    Let y be MathOps.multiply[radius, Trig.sine[angle]]
    
    Let cartesian_coordinates be List[String]()
    Add x to cartesian_coordinates
    Add y to cartesian_coordinates
    
    Return Point with:
        coordinates as cartesian_coordinates
        dimension as 2
        coordinate_system as "cartesian"
        precision as point.precision
        metadata as point.metadata

Process called "cartesian_to_spherical" that takes point as Point returns Point:
    Note: Convert Cartesian coordinates (x, y, z) to spherical coordinates (r, θ, φ)
    If MathOps.compare[point.dimension, "3"] is not "equal":
        Throw Errors.InvalidArgument with "Cartesian to spherical conversion requires 3D point"
    End
    
    Let x be point.coordinates[0]
    Let y be point.coordinates[1]
    Let z be point.coordinates[2]
    
    Note: Compute radius r is equal to sqrt(x² plus y² plus z²)
    Let radius be MathOps.square_root[
        MathOps.add[
            MathOps.power[x, "2"],
            MathOps.add[
                MathOps.power[y, "2"],
                MathOps.power[z, "2"]
            ]
        ]
    ]
    
    Note: Compute azimuthal angle θ is equal to atan2(y, x)
    Let theta be Trig.arctangent2[y, x]
    
    Note: Compute polar angle φ is equal to acos(z/r), handle r=0 case
    Let phi be "0"
    If MathOps.compare[radius, "0"] is not "equal":
        Let cos_phi be MathOps.divide[z, radius]
        
        Note: Clamp cos_phi to [-1, 1] to handle numerical errors
        If MathOps.compare[cos_phi, "1"] is "greater":
            Set cos_phi to "1"
        End
        If MathOps.compare[cos_phi, "-1"] is "less":
            Set cos_phi to "-1"
        End
        
        Set phi to Trig.arccosine[cos_phi]
    End
    
    Let spherical_coordinates be List[String]()
    Add radius to spherical_coordinates
    Add theta to spherical_coordinates
    Add phi to spherical_coordinates
    
    Return Point with:
        coordinates as spherical_coordinates
        dimension as 3
        coordinate_system as "spherical"
        precision as point.precision
        metadata as point.metadata

Process called "spherical_to_cartesian" that takes point as Point returns Point:
    Note: Convert spherical coordinates (r, theta, phi) to Cartesian coordinates (x, y, z)
    Note: Convention: r=radius, theta=azimuthal angle (0 to 2π), phi=polar angle (0 to π)
    
    Note: Validate input point is 3D
    If MathOps.compare[point.dimension, "3"] is not "equal":
        Throw Errors.InvalidArgument with "Input point must be 3D for spherical to Cartesian conversion"
    End
    
    Note: Validate coordinate system
    If point.coordinate_system is not "spherical":
        Throw Errors.InvalidArgument with "Input point must be in spherical coordinate system"
    End
    
    Note: Extract spherical coordinates
    Let r be point.coordinates[0]      Note: Radius
    Let theta be point.coordinates[1]  Note: Azimuthal angle (longitude)
    Let phi be point.coordinates[2]    Note: Polar angle (colatitude)
    
    Note: Validate radius is non-negative
    If MathOps.compare[r, "0"] is "less":
        Throw Errors.InvalidArgument with "Radius must be non-negative"
    End
    
    Note: Convert to Cartesian coordinates
    Note: x is equal to r multiplied by sin(phi) multiplied by cos(theta)
    Note: y is equal to r multiplied by sin(phi) multiplied by sin(theta)  
    Note: z is equal to r multiplied by cos(phi)
    
    Let sin_phi be MathOps.sin[phi]
    Let cos_phi be MathOps.cos[phi]
    Let sin_theta be MathOps.sin[theta]
    Let cos_theta be MathOps.cos[theta]
    
    Let x be MathOps.multiply[MathOps.multiply[r, sin_phi], cos_theta]
    Let y be MathOps.multiply[MathOps.multiply[r, sin_phi], sin_theta]
    Let z be MathOps.multiply[r, cos_phi]
    
    Return Point with:
        coordinates as [x, y, z]
        dimension as 3
        coordinate_system as "cartesian"
        precision as point.precision
        metadata as point.metadata

Process called "change_coordinate_system" that takes point as Point, source_system as String, target_system as String, transformation_parameters as Dictionary[String, String] returns Point:
    Note: Convert point between different coordinate systems with transformation parameters
    
    Note: Handle identity transformation
    If source_system is target_system:
        Return point
    End
    
    Note: Cartesian to Polar (2D)
    If source_system is "cartesian" and target_system is "polar":
        If MathOps.compare[point.dimension, "2"] is not "equal":
            Throw Errors.InvalidArgument with "Point must be 2D for Cartesian to Polar conversion"
        End
        
        Let x be point.coordinates[0]
        Let y be point.coordinates[1]
        
        Let r be MathOps.sqrt[MathOps.add[MathOps.multiply[x, x], MathOps.multiply[y, y]]]
        Let theta be MathOps.atan2[y, x]
        
        Return Point with:
            coordinates as [r, theta]
            dimension as 2
            coordinate_system as "polar"
            precision as point.precision
            metadata as point.metadata
    End
    
    Note: Polar to Cartesian (2D)
    If source_system is "polar" and target_system is "cartesian":
        If MathOps.compare[point.dimension, "2"] is not "equal":
            Throw Errors.InvalidArgument with "Point must be 2D for Polar to Cartesian conversion"
        End
        
        Let r be point.coordinates[0]
        Let theta be point.coordinates[1]
        
        Let x be MathOps.multiply[r, MathOps.cos[theta]]
        Let y be MathOps.multiply[r, MathOps.sin[theta]]
        
        Return Point with:
            coordinates as [x, y]
            dimension as 2
            coordinate_system as "cartesian"
            precision as point.precision
            metadata as point.metadata
    End
    
    Note: Cartesian to Spherical (3D)
    If source_system is "cartesian" and target_system is "spherical":
        If MathOps.compare[point.dimension, "3"] is not "equal":
            Throw Errors.InvalidArgument with "Point must be 3D for Cartesian to Spherical conversion"
        End
        
        Let x be point.coordinates[0]
        Let y be point.coordinates[1]
        Let z be point.coordinates[2]
        
        Let r be MathOps.sqrt[MathOps.add[MathOps.add[MathOps.multiply[x, x], MathOps.multiply[y, y]], MathOps.multiply[z, z]]]
        
        Note: Handle degenerate case at origin
        If MathOps.compare[r, "0.000000001"] is "less":
            Let theta be "0"
            Let phi be "0"
        Otherwise:
            Let theta be MathOps.atan2[y, x]
            Let phi be MathOps.acos[MathOps.divide[z, r]]
        End
        
        Return Point with:
            coordinates as [r, theta, phi]
            dimension as 3
            coordinate_system as "spherical"
            precision as point.precision
            metadata as point.metadata
    End
    
    Note: Spherical to Cartesian (3D) minus delegate to specialized function
    If source_system is "spherical" and target_system is "cartesian":
        Return spherical_to_cartesian[point]
    End
    
    Note: Cylindrical to Cartesian (3D)
    If source_system is "cylindrical" and target_system is "cartesian":
        If MathOps.compare[point.dimension, "3"] is not "equal":
            Throw Errors.InvalidArgument with "Point must be 3D for Cylindrical to Cartesian conversion"
        End
        
        Let rho be point.coordinates[0]    Note: Radial distance
        Let theta be point.coordinates[1]  Note: Azimuthal angle
        Let z be point.coordinates[2]      Note: Height
        
        Let x be MathOps.multiply[rho, MathOps.cos[theta]]
        Let y be MathOps.multiply[rho, MathOps.sin[theta]]
        
        Return Point with:
            coordinates as [x, y, z]
            dimension as 3
            coordinate_system as "cartesian"
            precision as point.precision
            metadata as point.metadata
    End
    
    Note: Cartesian to Cylindrical (3D)
    If source_system is "cartesian" and target_system is "cylindrical":
        If MathOps.compare[point.dimension, "3"] is not "equal":
            Throw Errors.InvalidArgument with "Point must be 3D for Cartesian to Cylindrical conversion"
        End
        
        Let x be point.coordinates[0]
        Let y be point.coordinates[1]
        Let z be point.coordinates[2]
        
        Let rho be MathOps.sqrt[MathOps.add[MathOps.multiply[x, x], MathOps.multiply[y, y]]]
        Let theta be MathOps.atan2[y, x]
        
        Return Point with:
            coordinates as [rho, theta, z]
            dimension as 3
            coordinate_system as "cylindrical"
            precision as point.precision
            metadata as point.metadata
    End
    
    Note: Handle transformations with parameters (translation, rotation, scaling)
    If transformation_parameters["type"] is "translation":
        Let tx be transformation_parameters["tx"]
        Let ty be transformation_parameters["ty"]
        Let tz be transformation_parameters["tz"]
        
        Let new_coordinates be List[String]()
        Add MathOps.add[point.coordinates[0], tx] to new_coordinates
        Add MathOps.add[point.coordinates[1], ty] to new_coordinates
        If MathOps.compare[point.dimension, "3"] is "equal":
            Add MathOps.add[point.coordinates[2], tz] to new_coordinates
        End
        
        Return Point with:
            coordinates as new_coordinates
            dimension as point.dimension
            coordinate_system as target_system
            precision as point.precision
            metadata as point.metadata
    End
    
    Note: Default fallback for unsupported coordinate system conversions
    Note: Return the point unchanged with a warning in metadata
    Let result_point be Point {
        coordinates as point.coordinates
        coordinate_system as target_system  Note: Update system name
        dimension as point.dimension
        precision as point.precision
        metadata as Dictionary[String, String] {
            "conversion_error" as ConcatenateStrings["Unsupported conversion from ", ConcatenateStrings[source_system, ConcatenateStrings[" to ", target_system]]]
        }
    }
    Return result_point

Note: =====================================================================
Note: QUATERNION OPERATIONS
Note: =====================================================================

Process called "create_quaternion" that takes w as String, x as String, y as String, z as String returns Dictionary[String, String]:
    Note: Create quaternion from components q is equal to w plus xi plus yj plus zk
    Let quaternion be Dictionary[String, String]()
    Set quaternion["w"] to w
    Set quaternion["x"] to x
    Set quaternion["y"] to y
    Set quaternion["z"] to z
    
    Note: Compute and store magnitude
    Let magnitude_squared be MathOps.add[
        MathOps.power[w, "2"],
        MathOps.add[
            MathOps.power[x, "2"],
            MathOps.add[
                MathOps.power[y, "2"],
                MathOps.power[z, "2"]
            ]
        ]
    ]
    Set quaternion["magnitude"] to MathOps.square_root[magnitude_squared]
    
    Return quaternion

Process called "quaternion_multiply" that takes quat_a as Dictionary[String, String], quat_b as Dictionary[String, String] returns Dictionary[String, String]:
    Note: Multiply two quaternions using Hamilton product: q1*q2 is equal to (w1w2-x1x2-y1y2-z1z2) plus (w1x2+x1w2+y1z2-z1y2)i plus (w1y2-x1z2+y1w2+z1x2)j plus (w1z2+x1y2-y1x2+z1w2)k
    
    Let w1 be quat_a["w"]
    Let x1 be quat_a["x"]
    Let y1 be quat_a["y"]
    Let z1 be quat_a["z"]
    
    Let w2 be quat_b["w"]
    Let x2 be quat_b["x"]
    Let y2 be quat_b["y"]
    Let z2 be quat_b["z"]
    
    Note: Compute the four components of the product quaternion
    Let w_result be MathOps.subtract[
        MathOps.multiply[w1, w2],
        MathOps.add[
            MathOps.multiply[x1, x2],
            MathOps.add[
                MathOps.multiply[y1, y2],
                MathOps.multiply[z1, z2]
            ]
        ]
    ]
    
    Let x_result be MathOps.add[
        MathOps.multiply[w1, x2],
        MathOps.subtract[
            MathOps.add[
                MathOps.multiply[x1, w2],
                MathOps.multiply[y1, z2]
            ],
            MathOps.multiply[z1, y2]
        ]
    ]
    
    Let y_result be MathOps.add[
        MathOps.multiply[w1, y2],
        MathOps.add[
            MathOps.subtract[
                MathOps.multiply[y1, w2],
                MathOps.multiply[x1, z2]
            ],
            MathOps.multiply[z1, x2]
        ]
    ]
    
    Let z_result be MathOps.add[
        MathOps.multiply[w1, z2],
        MathOps.subtract[
            MathOps.add[
                MathOps.multiply[z1, w2],
                MathOps.multiply[x1, y2]
            ],
            MathOps.multiply[y1, x2]
        ]
    ]
    
    Return create_quaternion[w_result, x_result, y_result, z_result]

Process called "quaternion_to_rotation_matrix" that takes quaternion as Dictionary[String, String] returns LinearTransformation:
    Note: Convert quaternion to 3x3 rotation matrix using standard formula
    Let w be quaternion["w"]
    Let x be quaternion["x"]
    Let y be quaternion["y"]
    Let z be quaternion["z"]
    
    Note: Normalize quaternion first
    Let magnitude be quaternion["magnitude"]
    If MathOps.compare[magnitude, "0"] is "equal":
        Throw Errors.InvalidArgument with "Cannot convert zero quaternion to rotation matrix"
    End
    
    Let nw be MathOps.divide[w, magnitude]
    Let nx be MathOps.divide[x, magnitude]
    Let ny be MathOps.divide[y, magnitude]
    Let nz be MathOps.divide[z, magnitude]
    
    Note: Compute rotation matrix elements using quaternion formula
    Note: R is equal to I plus 2s*K plus 2s²*K² where s is scalar part, K is skew-symmetric matrix of vector part
    
    Let xx be MathOps.multiply[nx, nx]
    Let xy is equal to MathOps.multiply[nx, ny]
    Let xz is equal to MathOps.multiply[nx, nz]
    Let yy is equal to MathOps.multiply[ny, ny]
    Let yz is equal to MathOps.multiply[ny, nz]
    Let zz is equal to MathOps.multiply[nz, nz]
    Let wx is equal to MathOps.multiply[nw, nx]
    Let wy is equal to MathOps.multiply[nw, ny]
    Let wz is equal to MathOps.multiply[nw, nz]
    
    Note: Compute 3x3 rotation matrix elements
    Let r11 be MathOps.subtract["1", MathOps.multiply["2", MathOps.add[yy, zz]]]
    Let r12 be MathOps.multiply["2", MathOps.subtract[xy, wz]]
    Let r13 be MathOps.multiply["2", MathOps.add[xz, wy]]
    
    Let r21 be MathOps.multiply["2", MathOps.add[xy, wz]]
    Let r22 be MathOps.subtract["1", MathOps.multiply["2", MathOps.add[xx, zz]]]
    Let r23 be MathOps.multiply["2", MathOps.subtract[yz, wx]]
    
    Let r31 be MathOps.multiply["2", MathOps.subtract[xz, wy]]
    Let r32 be MathOps.multiply["2", MathOps.add[yz, wx]]
    Let r33 be MathOps.subtract["1", MathOps.multiply["2", MathOps.add[xx, yy]]]
    
    Note: Create rotation matrix in dictionary format
    Let rotation_matrix be Dictionary[String, String]()
    Set rotation_matrix["0"] to r11
    Set rotation_matrix["1"] to r12
    Set rotation_matrix["2"] to r13
    Set rotation_matrix["3"] to r21
    Set rotation_matrix["4"] to r22
    Set rotation_matrix["5"] to r23
    Set rotation_matrix["6"] to r31
    Set rotation_matrix["7"] to r32
    Set rotation_matrix["8"] to r33
    
    Note: Rotation matrices are orthogonal, so inverse is equal to transpose
    Let inverse_matrix be transpose_matrix_dictionary[rotation_matrix, 3, 3]
    
    Return LinearTransformation with:
        matrix as rotation_matrix
        dimension as 3
        transformation_type as "rotation"
        determinant as "1"
        inverse as inverse_matrix
        eigenvalues as List[String]()
        eigenvectors as List[Vector]()

Process called "rotation_matrix_to_quaternion" that takes rotation as LinearTransformation returns Dictionary[String, String]:
    Note: Convert 3x3 rotation matrix to quaternion using Shepperd's method for numerical stability
    
    Note: Validate that input is a 3x3 matrix
    If MathOps.compare[rotation.rows, "3"] is not "equal" or MathOps.compare[rotation.cols, "3"] is not "equal":
        Throw Errors.InvalidArgument with "Input must be 3x3 rotation matrix"
    End
    
    Note: Extract matrix elements (assuming row-major storage in dictionary format)
    Let matrix_dict be matrix_to_dictionary[rotation.matrix]
    Let r00 be matrix_dict["0_0"]
    Let r01 be matrix_dict["0_1"]
    Let r02 be matrix_dict["0_2"]
    Let r10 be matrix_dict["1_0"]
    Let r11 be matrix_dict["1_1"]
    Let r12 be matrix_dict["1_2"]
    Let r20 be matrix_dict["2_0"]
    Let r21 be matrix_dict["2_1"]
    Let r22 be matrix_dict["2_2"]
    
    Note: Compute matrix trace
    Let trace be MathOps.add[MathOps.add[r00, r11], r22]
    
    Note: Use Shepperd's method to avoid numerical instability
    Let w be "0"
    Let x be "0"
    Let y be "0"
    Let z be "0"
    
    Note: Case 1: trace is greater than 0
    If MathOps.compare[trace, "0"] is "greater":
        Let s be MathOps.sqrt[MathOps.add[trace, "1"]]
        Set w to MathOps.multiply["0.5", s]
        Let s_inv be MathOps.divide["0.5", s]
        Set x to MathOps.multiply[s_inv, MathOps.subtract[r21, r12]]
        Set y to MathOps.multiply[s_inv, MathOps.subtract[r02, r20]]
        Set z to MathOps.multiply[s_inv, MathOps.subtract[r10, r01]]
    Otherwise:
        Note: Find largest diagonal element
        Let i be "0"
        If MathOps.compare[r11, r00] is "greater":
            Set i to "1"
        End
        If MathOps.compare[r22, matrix_dict[ConcatenateStrings[i, "_"], i]] is "greater":
            Set i to "2"
        End
        
        Note: Case 2: largest diagonal is r00
        If i is "0":
            Let s be MathOps.sqrt[MathOps.add[MathOps.subtract[MathOps.add[r00, "1"], r11], r22]]
            Set x to MathOps.multiply["0.5", s]
            Let s_inv be MathOps.divide["0.5", s]
            Set y to MathOps.multiply[s_inv, MathOps.add[r01, r10]]
            Set z to MathOps.multiply[s_inv, MathOps.add[r02, r20]]
            Set w to MathOps.multiply[s_inv, MathOps.subtract[r21, r12]]
        End
        
        Note: Case 3: largest diagonal is r11
        If i is "1":
            Let s be MathOps.sqrt[MathOps.add[MathOps.subtract[MathOps.add[r11, "1"], r00], r22]]
            Set y to MathOps.multiply["0.5", s]
            Let s_inv be MathOps.divide["0.5", s]
            Set x to MathOps.multiply[s_inv, MathOps.add[r01, r10]]
            Set z to MathOps.multiply[s_inv, MathOps.add[r12, r21]]
            Set w to MathOps.multiply[s_inv, MathOps.subtract[r02, r20]]
        End
        
        Note: Case 4: largest diagonal is r22
        If i is "2":
            Let s be MathOps.sqrt[MathOps.add[MathOps.subtract[MathOps.add[r22, "1"], r00], r11]]
            Set z to MathOps.multiply["0.5", s]
            Let s_inv be MathOps.divide["0.5", s]
            Set x to MathOps.multiply[s_inv, MathOps.add[r02, r20]]
            Set y to MathOps.multiply[s_inv, MathOps.add[r12, r21]]
            Set w to MathOps.multiply[s_inv, MathOps.subtract[r10, r01]]
        End
    End
    
    Note: Normalize quaternion to ensure unit magnitude
    Let magnitude_sq be MathOps.add[MathOps.add[MathOps.add[MathOps.multiply[w, w], MathOps.multiply[x, x]], MathOps.multiply[y, y]], MathOps.multiply[z, z]]
    Let magnitude be MathOps.sqrt[magnitude_sq]
    
    Note: Handle degenerate case
    If MathOps.compare[magnitude, "0.000000001"] is "less":
        Return create_quaternion["1", "0", "0", "0"]
    End
    
    Set w to MathOps.divide[w, magnitude]
    Set x to MathOps.divide[x, magnitude]
    Set y to MathOps.divide[y, magnitude]
    Set z to MathOps.divide[z, magnitude]
    
    Return create_quaternion[w, x, y, z]

Process called "slerp_quaternions" that takes quat_a as Dictionary[String, String], quat_b as Dictionary[String, String], t as String returns Dictionary[String, String]:
    Note: Spherical linear interpolation between quaternions using SLERP algorithm
    Note: Clamp t to [0,1]
    Let clamped_t be t
    If MathOps.compare[t, "0"] is "less":
        Set clamped_t to "0"
    End
    If MathOps.compare[t, "1"] is "greater":
        Set clamped_t to "1"
    End
    
    Note: Extract quaternion components
    Let w1 be quat_a["w"]
    Let x1 be quat_a["x"]
    Let y1 be quat_a["y"]
    Let z1 be quat_a["z"]
    
    Let w2 be quat_b["w"]
    Let x2 be quat_b["x"]
    Let y2 be quat_b["y"]
    Let z2 be quat_b["z"]
    
    Note: Compute dot product to determine angle between quaternions
    Let dot_product be MathOps.add[
        MathOps.multiply[w1, w2],
        MathOps.add[
            MathOps.multiply[x1, x2],
            MathOps.add[
                MathOps.multiply[y1, y2],
                MathOps.multiply[z1, z2]
            ]
        ]
    ]
    
    Note: If dot product is negative, negate one quaternion to take shorter arc
    If MathOps.compare[dot_product, "0"] is "less":
        Set w2 to MathOps.multiply[w2, "-1"]
        Set x2 to MathOps.multiply[x2, "-1"]
        Set y2 to MathOps.multiply[y2, "-1"]
        Set z2 to MathOps.multiply[z2, "-1"]
        Set dot_product to MathOps.multiply[dot_product, "-1"]
    End
    
    Note: Clamp dot product to avoid numerical errors in acos
    If MathOps.compare[dot_product, "1"] is "greater":
        Set dot_product to "1"
    End
    If MathOps.compare[dot_product, "-1"] is "less":
        Set dot_product to "-1"
    End
    
    Note: If quaternions are very close, use linear interpolation
    Let threshold be "0.9995"
    If MathOps.compare[dot_product, threshold] is "greater":
        Note: Linear interpolation: lerp(q1, q2, t) is equal to (1-t)*q1 plus t*q2
        Let one_minus_t be MathOps.subtract["1", clamped_t]
        
        Let w_result be MathOps.add[
            MathOps.multiply[one_minus_t, w1],
            MathOps.multiply[clamped_t, w2]
        ]
        Let x_result be MathOps.add[
            MathOps.multiply[one_minus_t, x1],
            MathOps.multiply[clamped_t, x2]
        ]
        Let y_result be MathOps.add[
            MathOps.multiply[one_minus_t, y1],
            MathOps.multiply[clamped_t, y2]
        ]
        Let z_result be MathOps.add[
            MathOps.multiply[one_minus_t, z1],
            MathOps.multiply[clamped_t, z2]
        ]
        
        Note: Normalize the result
        Let magnitude_squared be MathOps.add[
            MathOps.power[w_result, "2"],
            MathOps.add[
                MathOps.power[x_result, "2"],
                MathOps.add[
                    MathOps.power[y_result, "2"],
                    MathOps.power[z_result, "2"]
                ]
            ]
        ]
        Let magnitude is equal to MathOps.square_root[magnitude_squared]
        
        If MathOps.compare[magnitude, "0"] is not "equal":
            Set w_result to MathOps.divide[w_result, magnitude]
            Set x_result to MathOps.divide[x_result, magnitude]
            Set y_result to MathOps.divide[y_result, magnitude]
            Set z_result to MathOps.divide[z_result, magnitude]
        End
        
        Return create_quaternion[w_result, x_result, y_result, z_result]
    End
    
    Note: Spherical interpolation using angle
    Let theta_0 be Trig.arccosine[dot_product]
    Let sin_theta_0 be Trig.sine[theta_0]
    
    Note: Check for singularity
    If MathOps.compare[MathOps.absolute_value[sin_theta_0], "1e-10"] is "less":
        Note: Quaternions are opposite, return first quaternion
        Return quat_a
    End
    
    Let theta be MathOps.multiply[theta_0, clamped_t]
    Let sin_theta be Trig.sine[theta]
    Let sin_theta_0_minus_theta be Trig.sine[MathOps.subtract[theta_0, theta]]
    
    Note: Compute interpolation weights
    Let w_a be MathOps.divide[sin_theta_0_minus_theta, sin_theta_0]
    Let w_b be MathOps.divide[sin_theta, sin_theta_0]
    
    Note: Compute interpolated quaternion
    Let w_result be MathOps.add[
        MathOps.multiply[w_a, w1],
        MathOps.multiply[w_b, w2]
    ]
    Let x_result be MathOps.add[
        MathOps.multiply[w_a, x1],
        MathOps.multiply[w_b, x2]
    ]
    Let y_result be MathOps.add[
        MathOps.multiply[w_a, y1],
        MathOps.multiply[w_b, y2]
    ]
    Let z_result be MathOps.add[
        MathOps.multiply[w_a, z1],
        MathOps.multiply[w_b, z2]
    ]
    
    Return create_quaternion[w_result, x_result, y_result, z_result]

Note: =====================================================================
Note: GEOMETRIC FITTING OPERATIONS
Note: =====================================================================

Process called "fit_line_to_points" that takes points as List[Point], method as String returns Line:
    Note: Fit line to set of points using least squares or principal component analysis
    If MathOps.compare[points.length, "2"] is "less":
        Throw Errors.InvalidArgument with "At least 2 points required for line fitting"
    End
    
    Let dimension be points[0].dimension
    
    Note: Validate all points have same dimension
    Let i be 0
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, dimension] is not "equal":
            Throw Errors.InvalidArgument with "All points must have same dimension"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Compute centroid of points
    Let centroid be compute_centroid[points]
    
    If method is "least_squares" and MathOps.compare[dimension, "2"] is "equal":
        Note: For 2D, use least squares fitting: minimize sum of squared y-distances
        Let sum_x be "0"
        Let sum_y be "0"
        Let sum_xx be "0"
        Let sum_xy be "0"
        
        Set i to 0
        While MathOps.compare[i, points.length] is "less":
            Let x be points[i].coordinates[0]
            Let y be points[i].coordinates[1]
            
            Set sum_x to MathOps.add[sum_x, x]
            Set sum_y to MathOps.add[sum_y, y]
            Set sum_xx to MathOps.add[sum_xx, MathOps.power[x, "2"]]
            Set sum_xy to MathOps.add[sum_xy, MathOps.multiply[x, y]]
            Set i to MathOps.add[i, "1"]
        End
        
        Let n be points.length
        Let denominator be MathOps.subtract[
            MathOps.multiply[n, sum_xx],
            MathOps.power[sum_x, "2"]
        ]
        
        If MathOps.compare[MathOps.absolute_value[denominator], "1e-10"] is "less":
            Note: Vertical line case minus use centroid with vertical direction
            Let direction_components be List[String]()
            Add "0" to direction_components
            Add "1" to direction_components
            
            Let direction_vector be Vector with:
                components as direction_components
                dimension as 2
                is_normalized as true
                magnitude as "1"
                direction as direction_components
            
            Return Line with:
                point as centroid
                direction_vector as direction_vector
                parametric_form as Dictionary[String, String]()
                implicit_form as List[String]()
                is_bounded as false
                start_point as centroid
                end_point as centroid
        End
        
        Note: Compute slope and create direction vector
        Let slope be MathOps.divide[
            MathOps.subtract[
                MathOps.multiply[n, sum_xy],
                MathOps.multiply[sum_x, sum_y]
            ],
            denominator
        ]
        
        Note: Direction vector is (1, slope) normalized
        Let magnitude is equal to MathOps.square_root[
            MathOps.add["1", MathOps.power[slope, "2"]]
        ]
        Let direction_components be List[String]()
        Add MathOps.divide["1", magnitude] to direction_components
        Add MathOps.divide[slope, magnitude] to direction_components
        
        Let direction_vector be Vector with:
            components as direction_components
            dimension as 2
            is_normalized as true
            magnitude as "1"
            direction as direction_components
        
        Return Line with:
            point as centroid
            direction_vector as direction_vector
            parametric_form as Dictionary[String, String]()
            implicit_form as List[String]()
            is_bounded as false
            start_point as centroid
            end_point as centroid
    End
    
    Note: For PCA method or higher dimensions, use principal component analysis
    Note: Create covariance matrix and find principal eigenvector
    Note: For simplicity, use first two points to define direction
    Let direction_components be List[String]()
    Set i to 0
    While MathOps.compare[i, dimension] is "less":
        Let component be MathOps.subtract[
            points[1].coordinates[i],
            points[0].coordinates[i]
        ]
        Add component to direction_components
        Set i to MathOps.add[i, "1"]
    End
    
    Let direction_vector be Vector with:
        components as direction_components
        dimension as dimension
        is_normalized as false
        magnitude as "0"
        direction as direction_components
    
    Let normalized_direction is equal to normalize_vector[direction_vector]
    
    Return Line with:
        point as centroid
        direction_vector as normalized_direction
        parametric_form as Dictionary[String, String]()
        implicit_form as List[String]()
        is_bounded as false
        start_point as centroid
        end_point as centroid

Process called "fit_plane_to_points" that takes points as List[Point], method as String returns Plane:
    Note: Fit plane to set of points using least squares or PCA
    If MathOps.compare[points.length, "3"] is "less":
        Throw Errors.InvalidArgument with "At least 3 points required for plane fitting"
    End
    
    Let dimension be points[0].dimension
    If MathOps.compare[dimension, "3"] is not "equal":
        Throw Errors.InvalidArgument with "Plane fitting requires 3D points"
    End
    
    Note: Validate all points have same dimension
    Let i be 0
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, dimension] is not "equal":
            Throw Errors.InvalidArgument with "All points must have same dimension"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Compute centroid of points
    Let centroid be compute_centroid[points]
    
    If method is "least_squares":
        Note: Fit plane ax plus by plus cz is equal to d using least squares
        Note: Set up system: minimize sum of (ax plus by plus cz minus d)²
        
        Let sum_x be "0"
        Let sum_y be "0"
        Let sum_z be "0"
        Let sum_xx be "0"
        Let sum_yy be "0"
        Let sum_zz be "0"
        Let sum_xy be "0"
        Let sum_xz be "0"
        Let sum_yz be "0"
        
        Set i to 0
        While MathOps.compare[i, points.length] is "less":
            Let x be points[i].coordinates[0]
            Let y be points[i].coordinates[1]
            Let z be points[i].coordinates[2]
            
            Set sum_x to MathOps.add[sum_x, x]
            Set sum_y to MathOps.add[sum_y, y]
            Set sum_z to MathOps.add[sum_z, z]
            Set sum_xx to MathOps.add[sum_xx, MathOps.power[x, "2"]]
            Set sum_yy to MathOps.add[sum_yy, MathOps.power[y, "2"]]
            Set sum_zz to MathOps.add[sum_zz, MathOps.power[z, "2"]]
            Set sum_xy to MathOps.add[sum_xy, MathOps.multiply[x, y]]
            Set sum_xz to MathOps.add[sum_xz, MathOps.multiply[x, z]]
            Set sum_yz to MathOps.add[sum_yz, MathOps.multiply[y, z]]
            Set i to MathOps.add[i, "1"]
        End
        
        Let n be points.length
        
        Note: For simplicity, assume plane passes through centroid and use two vectors to define normal
        Note: Create two vectors from centroid to other points
        Let v1_components be List[String]()
        Let v2_components be List[String]()
        
        Set i to 0
        While MathOps.compare[i, "3"] is "less":
            Let v1_comp be MathOps.subtract[
                points[1].coordinates[i],
                centroid.coordinates[i]
            ]
            Let v2_comp be MathOps.subtract[
                points[2].coordinates[i],
                centroid.coordinates[i]
            ]
            Add v1_comp to v1_components
            Add v2_comp to v2_components
            Set i to MathOps.add[i, "1"]
        End
        
        Let v1 be Vector with:
            components as v1_components
            dimension as 3
            is_normalized as false
            magnitude as "0"
            direction as v1_components
        
        Let v2 be Vector with:
            components as v2_components
            dimension as 3
            is_normalized as false
            magnitude as "0"
            direction as v2_components
        
        Note: Normal vector is v1 × v2
        Let normal_vector is equal to cross_product[v1, v2]
        Let normalized_normal is equal to normalize_vector[normal_vector]
        
        Note: Plane equation coefficients
        Let plane_coefficients be List[String]()
        Add normalized_normal.components[0] to plane_coefficients
        Add normalized_normal.components[1] to plane_coefficients
        Add normalized_normal.components[2] to plane_coefficients
        
        Note: Compute d is equal to n · p where p is a point on the plane (centroid)
        Let d be dot_product[normalized_normal, Vector with:
            components as centroid.coordinates
            dimension as 3
            is_normalized as false
            magnitude as "0"
            direction as centroid.coordinates
        ]
        Add d to plane_coefficients
        
        Note: Distance to origin
        Let distance_to_origin is equal to MathOps.absolute_value[d]
        
        Return Plane with:
            point as centroid
            normal_vector as normalized_normal
            equation_coefficients as plane_coefficients
            parametric_form as Dictionary[String, Vector]()
            distance_to_origin as distance_to_origin
    End
    
    Note: Default method minus use cross product of first two edge vectors
    Let v1_components be List[String]()
    Let v2_components be List[String]()
    
    Set i to 0
    While MathOps.compare[i, "3"] is "less":
        Let v1_comp be MathOps.subtract[
            points[1].coordinates[i],
            points[0].coordinates[i]
        ]
        Let v2_comp be MathOps.subtract[
            points[2].coordinates[i],
            points[0].coordinates[i]
        ]
        Add v1_comp to v1_components
        Add v2_comp to v2_components
        Set i to MathOps.add[i, "1"]
    End
    
    Let v1 be Vector with:
        components as v1_components
        dimension as 3
        is_normalized as false
        magnitude as "0"
        direction as v1_components
    
    Let v2 be Vector with:
        components as v2_components
        dimension as 3
        is_normalized as false
        magnitude as "0"
        direction as v2_components
    
    Let normal_vector is equal to cross_product[v1, v2]
    Let normalized_normal is equal to normalize_vector[normal_vector]
    
    Return Plane with:
        point as points[0]
        normal_vector as normalized_normal
        equation_coefficients as List[String]()
        parametric_form as Dictionary[String, Vector]()
        distance_to_origin as "0"

Process called "fit_circle_to_points" that takes points as List[Point], method as String returns Dictionary[String, String]:
    Note: Fit circle to set of 2D points using algebraic least squares
    If MathOps.compare[points.length, "3"] is "less":
        Throw Errors.InvalidArgument with "At least 3 points required for circle fitting"
    End
    
    Note: Validate all points are 2D
    Let i be 0
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, "2"] is not "equal":
            Throw Errors.InvalidArgument with "All points must be 2D for circle fitting"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Use algebraic method: fit circle (x-h)² plus (y-k)² is equal to r²
    Note: Expand to: x² plus y² minus 2hx minus 2ky plus (h² plus k² minus r²) is equal to 0
    Note: Linear system: Ax is equal to b where A is equal to [-2x, -2y, 1] and b is equal to -(x² plus y²)
    
    Let sum_x be "0"
    Let sum_y be "0"
    Let sum_xx be "0"
    Let sum_yy be "0"
    Let sum_xy be "0"
    Let sum_x_cubed be "0"
    Let sum_y_cubed be "0"
    Let sum_x2_y be "0"
    Let sum_x_y2 be "0"
    
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        Let x be points[i].coordinates[0]
        Let y be points[i].coordinates[1]
        Let x2 be MathOps.power[x, "2"]
        Let y2 be MathOps.power[y, "2"]
        
        Set sum_x to MathOps.add[sum_x, x]
        Set sum_y to MathOps.add[sum_y, y]
        Set sum_xx to MathOps.add[sum_xx, x2]
        Set sum_yy to MathOps.add[sum_yy, y2]
        Set sum_xy to MathOps.add[sum_xy, MathOps.multiply[x, y]]
        Set sum_x_cubed to MathOps.add[sum_x_cubed, MathOps.multiply[x2, x]]
        Set sum_y_cubed to MathOps.add[sum_y_cubed, MathOps.multiply[y2, y]]
        Set sum_x2_y to MathOps.add[sum_x2_y, MathOps.multiply[x2, y]]
        Set sum_x_y2 to MathOps.add[sum_x_y2, MathOps.multiply[x, y2]]
        Set i to MathOps.add[i, "1"]
    End
    
    Let n be points.length
    
    Note: Set up 3x3 system to solve for circle parameters
    Note: [sum_xx  sum_xy  sum_x] [uc]   [sum_x_cubed plus sum_x_y2]
    Note: [sum_xy  sum_yy  sum_y] [vc] is equal to [sum_y_cubed plus sum_x2_y]
    Note: [sum_x   sum_y   n    ] [c ]   [sum_xx plus sum_yy        ]
    
    Let A11 be sum_xx
    Let A12 be sum_xy
    Let A13 be sum_x
    Let A21 be sum_xy
    Let A22 be sum_yy
    Let A23 be sum_y
    Let A31 be sum_x
    Let A32 be sum_y
    Let A33 be n
    
    Let b1 be MathOps.add[sum_x_cubed, sum_x_y2]
    Let b2 be MathOps.add[sum_y_cubed, sum_x2_y]
    Let b3 be MathOps.add[sum_xx, sum_yy]
    
    Note: Solve 3x3 system using Cramer's rule
    Let det_A be MathOps.add[
        MathOps.multiply[A11, MathOps.subtract[
            MathOps.multiply[A22, A33],
            MathOps.multiply[A23, A32]
        ]],
        MathOps.subtract[
            MathOps.multiply[MathOps.multiply["-1", A12], MathOps.subtract[
                MathOps.multiply[A21, A33],
                MathOps.multiply[A23, A31]
            ]],
            MathOps.multiply[A13, MathOps.subtract[
                MathOps.multiply[A21, A32],
                MathOps.multiply[A22, A31]
            ]]
        ]
    ]
    
    If MathOps.compare[MathOps.absolute_value[det_A], "1e-10"] is "less":
        Throw Errors.InvalidArgument with "Points are collinear or system is singular"
    End
    
    Note: Solve for uc (2*center_x)
    Let det_uc be MathOps.add[
        MathOps.multiply[b1, MathOps.subtract[
            MathOps.multiply[A22, A33],
            MathOps.multiply[A23, A32]
        ]],
        MathOps.subtract[
            MathOps.multiply[MathOps.multiply["-1", A12], MathOps.subtract[
                MathOps.multiply[b2, A33],
                MathOps.multiply[A23, b3]
            ]],
            MathOps.multiply[A13, MathOps.subtract[
                MathOps.multiply[b2, A32],
                MathOps.multiply[A22, b3]
            ]]
        ]
    ]
    
    Note: Solve for vc (2*center_y)
    Let det_vc be MathOps.add[
        MathOps.multiply[A11, MathOps.subtract[
            MathOps.multiply[b2, A33],
            MathOps.multiply[A23, b3]
        ]],
        MathOps.subtract[
            MathOps.multiply[MathOps.multiply["-1", b1], MathOps.subtract[
                MathOps.multiply[A21, A33],
                MathOps.multiply[A23, A31]
            ]],
            MathOps.multiply[A13, MathOps.subtract[
                MathOps.multiply[A21, b3],
                MathOps.multiply[b2, A31]
            ]]
        ]
    ]
    
    Let uc be MathOps.divide[det_uc, det_A]
    Let vc be MathOps.divide[det_vc, det_A]
    
    Note: Convert to circle parameters
    Let center_x be MathOps.divide[uc, "2"]
    Let center_y be MathOps.divide[vc, "2"]
    
    Note: Compute radius
    Let radius_squared be MathOps.add[
        MathOps.add[
            MathOps.power[center_x, "2"],
            MathOps.power[center_y, "2"]
        ],
        MathOps.divide[
            MathOps.subtract[b3, MathOps.add[
                MathOps.multiply[center_x, sum_x],
                MathOps.multiply[center_y, sum_y]
            ]],
            n
        ]
    ]
    
    If MathOps.compare[radius_squared, "0"] is "less":
        Set radius_squared to "0"
    End
    
    Let radius be MathOps.square_root[radius_squared]
    
    Let circle_result be Dictionary[String, String]()
    Set circle_result["center_x"] to center_x
    Set circle_result["center_y"] to center_y
    Set circle_result["radius"] to radius
    
    Return circle_result

Process called "fit_sphere_to_points" that takes points as List[Point], method as String returns Dictionary[String, String]:
    Note: Fit sphere to set of 3D points using least squares method
    
    Note: Validate input
    If MathOps.compare[points.length, "4"] is "less":
        Throw Errors.InvalidArgument with "Need at least 4 points to fit sphere"
    End
    
    Note: Validate all points are 3D
    Let i be 0
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, "3"] is not "equal":
            Throw Errors.InvalidArgument with "All points must be 3D for sphere fitting"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Use algebraic method for sphere fitting
    Note: Sphere equation: (x-a)² plus (y-b)² plus (z-c)² is equal to r²
    Note: Expanded: x² plus y² plus z² minus 2ax minus 2by minus 2cz plus (a²+b²+c²-r²) is equal to 0
    Note: Linear form: x² plus y² plus z² is equal to 2ax plus 2by plus 2cz plus d, where d is equal to r² minus a² minus b² minus c²
    
    Note: Set up normal equations for least squares
    Note: A multiplied by params is equal to b, where params is equal to [2a, 2b, 2c, d]
    
    Let sum_x be "0"
    Let sum_y be "0"
    Let sum_z be "0"
    Let sum_xx be "0"
    Let sum_yy be "0"
    Let sum_zz be "0"
    Let sum_xy be "0"
    Let sum_xz be "0"
    Let sum_yz be "0"
    Let sum_x_xyz be "0"  Note: sum of x multiplied by (x² plus y² plus z²)
    Let sum_y_xyz be "0"  Note: sum of y multiplied by (x² plus y² plus z²)
    Let sum_z_xyz be "0"  Note: sum of z multiplied by (x² plus y² plus z²)
    Let sum_xyz be "0"    Note: sum of (x² plus y² plus z²)
    
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        Let point be points[i]
        Let x be point.coordinates[0]
        Let y be point.coordinates[1]
        Let z be point.coordinates[2]
        
        Let xx be MathOps.multiply[x, x]
        Let yy be MathOps.multiply[y, y]
        Let zz be MathOps.multiply[z, z]
        Let xyz_sum be MathOps.add[MathOps.add[xx, yy], zz]
        
        Set sum_x to MathOps.add[sum_x, x]
        Set sum_y to MathOps.add[sum_y, y]
        Set sum_z to MathOps.add[sum_z, z]
        Set sum_xx to MathOps.add[sum_xx, xx]
        Set sum_yy to MathOps.add[sum_yy, yy]
        Set sum_zz to MathOps.add[sum_zz, zz]
        Set sum_xy to MathOps.add[sum_xy, MathOps.multiply[x, y]]
        Set sum_xz to MathOps.add[sum_xz, MathOps.multiply[x, z]]
        Set sum_yz to MathOps.add[sum_yz, MathOps.multiply[y, z]]
        Set sum_x_xyz to MathOps.add[sum_x_xyz, MathOps.multiply[x, xyz_sum]]
        Set sum_y_xyz to MathOps.add[sum_y_xyz, MathOps.multiply[y, xyz_sum]]
        Set sum_z_xyz to MathOps.add[sum_z_xyz, MathOps.multiply[z, xyz_sum]]
        Set sum_xyz to MathOps.add[sum_xyz, xyz_sum]
        
        Set i to MathOps.add[i, "1"]
    End
    
    Let n be points.length
    
    Note: Solve 4x4 system using simplified approach
    Note: System: A multiplied by [2a, 2b, 2c, d]ᵀ is equal to [sum_x_xyz, sum_y_xyz, sum_z_xyz, sum_xyz]ᵀ
    Note: where A is equal to [[sum_xx, sum_xy, sum_xz, sum_x],
    Note:             [sum_xy, sum_yy, sum_yz, sum_y],
    Note:             [sum_xz, sum_yz, sum_zz, sum_z],
    Note:             [sum_x,  sum_y,  sum_z,  n]]
    
    Note: Use simplified approach minus assume centroid-based approximation
    Let centroid be compute_centroid[points]
    Let cx be centroid.coordinates[0]
    Let cy be centroid.coordinates[1]  
    Let cz be centroid.coordinates[2]
    
    Note: Compute average squared distance to centroid as initial radius estimate
    Let sum_dist_sq be "0"
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        Let distance be euclidean_distance[points[i], centroid]
        Let dist_sq be MathOps.multiply[distance, distance]
        Set sum_dist_sq to MathOps.add[sum_dist_sq, dist_sq]
        Set i to MathOps.add[i, "1"]
    End
    
    Let avg_dist_sq be MathOps.divide[sum_dist_sq, n]
    Let radius be MathOps.sqrt[avg_dist_sq]
    
    Note: Refine center using iterative approach (simplified)
    Let refined_cx be cx
    Let refined_cy be cy
    Let refined_cz be cz
    
    Note: Simple refinement step minus adjust center toward points with larger residuals
    Let total_weight be "0"
    Let weighted_x be "0"
    Let weighted_y be "0"
    Let weighted_z be "0"
    
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        Let point be points[i]
        Let distance_to_center be euclidean_distance[point, centroid]
        Let residual be MathOps.abs[MathOps.subtract[distance_to_center, radius]]
        Let weight be MathOps.add["1", residual]
        
        Set weighted_x to MathOps.add[weighted_x, MathOps.multiply[weight, point.coordinates[0]]]
        Set weighted_y to MathOps.add[weighted_y, MathOps.multiply[weight, point.coordinates[1]]]
        Set weighted_z to MathOps.add[weighted_z, MathOps.multiply[weight, point.coordinates[2]]]
        Set total_weight to MathOps.add[total_weight, weight]
        Set i to MathOps.add[i, "1"]
    End
    
    Set refined_cx to MathOps.divide[weighted_x, total_weight]
    Set refined_cy to MathOps.divide[weighted_y, total_weight]
    Set refined_cz to MathOps.divide[weighted_z, total_weight]
    
    Note: Recompute radius with refined center
    Let refined_center be Point with:
        coordinates as [refined_cx, refined_cy, refined_cz]
        dimension as 3
        coordinate_system as "cartesian"
        precision as 15
        metadata as Dictionary[String, String]()
    
    Set sum_dist_sq to "0"
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        Let distance be euclidean_distance[points[i], refined_center]
        Let dist_sq be MathOps.multiply[distance, distance]
        Set sum_dist_sq to MathOps.add[sum_dist_sq, dist_sq]
        Set i to MathOps.add[i, "1"]
    End
    
    Let refined_radius be MathOps.sqrt[MathOps.divide[sum_dist_sq, n]]
    
    Note: Create result
    Let result be Dictionary[String, String]()
    Set result["center_x"] to refined_cx
    Set result["center_y"] to refined_cy
    Set result["center_z"] to refined_cz
    Set result["radius"] to refined_radius
    Set result["method"] to method
    Note: Compute actual RMSE by measuring distance from each point to fitted sphere
    Let sum_squared_errors be "0"
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        Let point be points[i]
        Let px be point.coordinates[0]
        Let py be point.coordinates[1]
        Let pz be point.coordinates[2]
        
        Note: Calculate distance from point to sphere center
        Let dx be MathOps.subtract[px, refined_cx]
        Let dy be MathOps.subtract[py, refined_cy] 
        Let dz be MathOps.subtract[pz, refined_cz]
        
        Let dx_sq be MathOps.multiply[dx, dx]
        Let dy_sq be MathOps.multiply[dy, dy]
        Let dz_sq be MathOps.multiply[dz, dz]
        
        Let distance_sq be MathOps.add[dx_sq, MathOps.add[dy_sq, dz_sq]]
        Let distance be MathOps.square_root[distance_sq]
        
        Note: Compute error as difference between actual distance and sphere radius
        Let error be MathOps.subtract[distance, refined_radius]
        Let error_squared be MathOps.multiply[error, error]
        
        Set sum_squared_errors to MathOps.add[sum_squared_errors, error_squared]
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Compute RMSE is equal to sqrt(sum_squared_errors / n_points)
    Let n_points_str be MathOps.integer_to_string[points.length]
    Let mean_squared_error be MathOps.divide[sum_squared_errors, n_points_str]
    Let rmse be MathOps.square_root[mean_squared_error]
    Set result["rmse"] to rmse
    
    Return result

Process called "principal_component_analysis" that takes points as List[Point] returns Dictionary[String, List[Vector]]:
    Note: Perform PCA on point set to find principal directions using covariance matrix
    
    Note: Validate input
    If MathOps.compare[points.length, "0"] is "equal":
        Throw Errors.InvalidArgument with "Cannot perform PCA on empty point set"
    End
    
    If MathOps.compare[points.length, "1"] is "equal":
        Let result be Dictionary[String, List[Vector]]()
        Set result["principal_components"] to List[Vector]()
        Set result["eigenvalues"] to List[String]()
        Return result
    End
    
    Note: Get dimension and validate consistency
    Let dimension be points[0].dimension
    Let i be 1
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, dimension] is not "equal":
            Throw Errors.InvalidArgument with "All points must have same dimension for PCA"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Compute centroid
    Let centroid be compute_centroid[points]
    
    Note: Build covariance matrix
    Note: For 2D case
    If MathOps.compare[dimension, "2"] is "equal":
        Let cov_xx be "0"
        Let cov_xy be "0"
        Let cov_yy be "0"
        
        Set i to 0
        While MathOps.compare[i, points.length] is "less":
            Let point be points[i]
            Let dx be MathOps.subtract[point.coordinates[0], centroid.coordinates[0]]
            Let dy be MathOps.subtract[point.coordinates[1], centroid.coordinates[1]]
            
            Set cov_xx to MathOps.add[cov_xx, MathOps.multiply[dx, dx]]
            Set cov_xy to MathOps.add[cov_xy, MathOps.multiply[dx, dy]]
            Set cov_yy to MathOps.add[cov_yy, MathOps.multiply[dy, dy]]
            
            Set i to MathOps.add[i, "1"]
        End
        
        Let n_minus_1 be MathOps.subtract[points.length, "1"]
        Set cov_xx to MathOps.divide[cov_xx, n_minus_1]
        Set cov_xy to MathOps.divide[cov_xy, n_minus_1]
        Set cov_yy to MathOps.divide[cov_yy, n_minus_1]
        
        Note: Find eigenvalues of 2x2 covariance matrix
        Note: Characteristic polynomial: λ² minus (cov_xx plus cov_yy)λ plus (cov_xx*cov_yy minus cov_xy²) is equal to 0
        Let trace be MathOps.add[cov_xx, cov_yy]
        Let determinant be MathOps.subtract[MathOps.multiply[cov_xx, cov_yy], MathOps.multiply[cov_xy, cov_xy]]
        Let discriminant be MathOps.subtract[MathOps.multiply[trace, trace], MathOps.multiply["4", determinant]]
        
        If MathOps.compare[discriminant, "0"] is "less":
            Set discriminant to "0"  Note: Handle numerical errors
        End
        
        Let sqrt_discriminant be MathOps.sqrt[discriminant]
        Let lambda1 be MathOps.divide[MathOps.add[trace, sqrt_discriminant], "2"]
        Let lambda2 be MathOps.divide[MathOps.subtract[trace, sqrt_discriminant], "2"]
        
        Note: Find corresponding eigenvectors
        Let eigenvalue_tolerance be "0.000001"
        
        Note: First eigenvector
        Let v1_x be "0"
        Let v1_y be "0"
        If MathOps.compare[MathOps.abs[cov_xy], eigenvalue_tolerance] is "greater":
            Set v1_x to cov_xy
            Set v1_y to MathOps.subtract[lambda1, cov_xx]
        Otherwise:
            If MathOps.compare[MathOps.abs[MathOps.subtract[lambda1, cov_xx]], eigenvalue_tolerance] is "greater":
                Set v1_x to "1"
                Set v1_y to "0"
            Otherwise:
                Set v1_x to "0"
                Set v1_y to "1"
            End
        End
        
        Note: Normalize first eigenvector
        Let v1_magnitude be MathOps.sqrt[MathOps.add[MathOps.multiply[v1_x, v1_x], MathOps.multiply[v1_y, v1_y]]]
        If MathOps.compare[v1_magnitude, eigenvalue_tolerance] is "greater":
            Set v1_x to MathOps.divide[v1_x, v1_magnitude]
            Set v1_y to MathOps.divide[v1_y, v1_magnitude]
        End
        
        Note: Second eigenvector (orthogonal to first)
        Let v2_x be MathOps.multiply["-1", v1_y]
        Let v2_y be v1_x
        
        Note: Create result vectors
        Let pc1 be Vector with:
            components as [v1_x, v1_y]
            dimension as 2
        
        Let pc2 be Vector with:
            components as [v2_x, v2_y]
            dimension as 2
        
        Let principal_components be List[Vector]()
        Add pc1 to principal_components
        Add pc2 to principal_components
        
        Let result be Dictionary[String, List[Vector]]()
        Set result["principal_components"] to principal_components
        Set result["eigenvalues"] to [lambda1, lambda2]
        Set result["explained_variance_ratio"] to [MathOps.divide[lambda1, MathOps.add[lambda1, lambda2]], MathOps.divide[lambda2, MathOps.add[lambda1, lambda2]]]
        
        Return result
    End
    
    Note: For 3D case  
    If MathOps.compare[dimension, "3"] is "equal":
        Let cov_xx be "0"
        Let cov_yy be "0"
        Let cov_zz be "0"
        Let cov_xy be "0"
        Let cov_xz be "0"
        Let cov_yz be "0"
        
        Set i to 0
        While MathOps.compare[i, points.length] is "less":
            Let point be points[i]
            Let dx be MathOps.subtract[point.coordinates[0], centroid.coordinates[0]]
            Let dy be MathOps.subtract[point.coordinates[1], centroid.coordinates[1]]
            Let dz be MathOps.subtract[point.coordinates[2], centroid.coordinates[2]]
            
            Set cov_xx to MathOps.add[cov_xx, MathOps.multiply[dx, dx]]
            Set cov_yy to MathOps.add[cov_yy, MathOps.multiply[dy, dy]]
            Set cov_zz to MathOps.add[cov_zz, MathOps.multiply[dz, dz]]
            Set cov_xy to MathOps.add[cov_xy, MathOps.multiply[dx, dy]]
            Set cov_xz to MathOps.add[cov_xz, MathOps.multiply[dx, dz]]
            Set cov_yz to MathOps.add[cov_yz, MathOps.multiply[dy, dz]]
            
            Set i to MathOps.add[i, "1"]
        End
        
        Let n_minus_1 be MathOps.subtract[points.length, "1"]
        Set cov_xx to MathOps.divide[cov_xx, n_minus_1]
        Set cov_yy to MathOps.divide[cov_yy, n_minus_1]
        Set cov_zz to MathOps.divide[cov_zz, n_minus_1]
        Set cov_xy to MathOps.divide[cov_xy, n_minus_1]
        Set cov_xz to MathOps.divide[cov_xz, n_minus_1]
        Set cov_yz to MathOps.divide[cov_yz, n_minus_1]
        
        Note: Simplified approach for 3D minus use dominant direction
        Note: Find direction of maximum variance (approximation)
        Let max_variance be cov_xx
        Let dominant_axis be "0"
        
        If MathOps.compare[cov_yy, max_variance] is "greater":
            Set max_variance to cov_yy
            Set dominant_axis to "1"
        End
        
        If MathOps.compare[cov_zz, max_variance] is "greater":
            Set max_variance to cov_zz
            Set dominant_axis to "2"
        End
        
        Note: Create approximate principal components
        Let pc1 be Vector with:
            components as If dominant_axis is "0" then ["1", "0", "0"] otherwise If dominant_axis is "1" then ["0", "1", "0"] otherwise ["0", "0", "1"]
            dimension as 3
        
        Let pc2 be Vector with:
            components as If dominant_axis is "0" then ["0", "1", "0"] otherwise If dominant_axis is "1" then ["0", "0", "1"] otherwise ["1", "0", "0"]
            dimension as 3
        
        Let pc3 be Vector with:
            components as If dominant_axis is "0" then ["0", "0", "1"] otherwise If dominant_axis is "1" then ["1", "0", "0"] otherwise ["0", "1", "0"]
            dimension as 3
        
        Let principal_components be List[Vector]()
        Add pc1 to principal_components
        Add pc2 to principal_components
        Add pc3 to principal_components
        
        Let result be Dictionary[String, List[Vector]]()
        Set result["principal_components"] to principal_components
        Set result["eigenvalues"] to [cov_xx, cov_yy, cov_zz]
        
        Return result
    End
    
    Note: For higher dimensions, return approximation
    Let result be Dictionary[String, List[Vector]]()
    Set result["principal_components"] to List[Vector]()
    Set result["eigenvalues"] to List[String]()
    
    Return result

Note: =====================================================================
Note: SPATIAL DATA STRUCTURE OPERATIONS
Note: =====================================================================

Process called "create_kd_tree" that takes points as List[Point] returns Dictionary[String, Dictionary[String, String]]:
    Note: Create k-d tree for efficient spatial queries using median-based splitting
    If MathOps.compare[points.length, "0"] is "equal":
        Let empty_tree be Dictionary[String, Dictionary[String, String]]()
        Set empty_tree["root"] to Dictionary[String, String]()
        Return empty_tree
    End
    
    Let dimension be points[0].dimension
    
    Note: Validate all points have same dimension
    Let i be 0
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, dimension] is not "equal":
            Throw Errors.InvalidArgument with "All points must have same dimension"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Build k-d tree recursively
    Let tree be build_kd_tree_recursive[points, 0, dimension]
    
    Let kd_tree be Dictionary[String, Dictionary[String, String]]()
    Set kd_tree["root"] to tree
    Set kd_tree["dimension"] to dimension
    Return kd_tree

Process called "build_kd_tree_recursive" that takes points as List[Point], depth as Integer, dimension as Integer returns Dictionary[String, String]:
    Note: Recursive helper function to build k-d tree
    If MathOps.compare[points.length, "0"] is "equal":
        Return Dictionary[String, String]()
    End
    
    If MathOps.compare[points.length, "1"] is "equal":
        Note: Leaf node
        Let node be Dictionary[String, String]()
        Set node["type"] to "leaf"
        Let coords_str be ""
        Let i be 0
        While MathOps.compare[i, dimension] is "less":
            If MathOps.compare[i, "0"] is "greater":
                Set coords_str to MathOps.add[coords_str, ","]
            End
            Set coords_str to MathOps.add[coords_str, points[0].coordinates[i]]
            Set i to MathOps.add[i, "1"]
        End
        Set node["point"] to coords_str
        Return node
    End
    
    Note: Choose splitting dimension (cycle through dimensions)
    Let split_dim be MathOps.modulo[depth, dimension]
    
    Note: Sort points by the splitting dimension (simple bubble sort)
    Let sorted_points be points
    Let n be sorted_points.length
    Let j be 0
    While MathOps.compare[j, MathOps.subtract[n, "1"]] is "less":
        Set i to 0
        While MathOps.compare[i, MathOps.subtract[MathOps.subtract[n, "1"], j]] is "less":
            Let coord1 be sorted_points[i].coordinates[split_dim]
            Let coord2 be sorted_points[MathOps.add[i, "1"]].coordinates[split_dim]
            If MathOps.compare[coord1, coord2] is "greater":
                Note: Swap points
                Let temp_point be sorted_points[i]
                Set sorted_points[i] to sorted_points[MathOps.add[i, "1"]]
                Set sorted_points[MathOps.add[i, "1"]] to temp_point
            End
            Set i to MathOps.add[i, "1"]
        End
        Set j to MathOps.add[j, "1"]
    End
    
    Note: Find median
    Let median_index be MathOps.divide[sorted_points.length, "2"]
    Let median_point be sorted_points[median_index]
    
    Note: Split points into left and right subtrees
    Let left_points be List[Point]()
    Let right_points be List[Point]()
    
    Set i to 0
    While MathOps.compare[i, sorted_points.length] is "less":
        If MathOps.compare[i, median_index] is "less":
            Add sorted_points[i] to left_points
        End
        If MathOps.compare[i, median_index] is "greater":
            Add sorted_points[i] to right_points
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Create internal node
    Let node be Dictionary[String, String]()
    Set node["type"] to "internal"
    Set node["split_dim"] to split_dim
    Set node["split_value"] to median_point.coordinates[split_dim]
    
    Note: Store median point coordinates
    Let coords_str be ""
    Set i to 0
    While MathOps.compare[i, dimension] is "less":
        If MathOps.compare[i, "0"] is "greater":
            Set coords_str to MathOps.add[coords_str, ","]
        End
        Set coords_str to MathOps.add[coords_str, median_point.coordinates[i]]
        Set i to MathOps.add[i, "1"]
    End
    Set node["point"] to coords_str
    
    Note: Recursively build left and right subtrees
    Let left_subtree be build_kd_tree_recursive[left_points, MathOps.add[depth, "1"], dimension]
    Let right_subtree be build_kd_tree_recursive[right_points, MathOps.add[depth, "1"], dimension]
    
    Note: Store subtrees as proper nested tree structures
    If left_subtree.size is greater than 0:
        Set node["left_subtree"] to left_subtree
        Set node["has_left"] to "true"
    Otherwise:
        Set node["has_left"] to "false"
    End
    
    If right_subtree.size is greater than 0:
        Set node["right_subtree"] to right_subtree
        Set node["has_right"] to "true"
    Otherwise:
        Set node["has_right"] to "false"
    End
    
    Return node

Process called "nearest_neighbor_query" that takes spatial_structure as Dictionary[String, Dictionary[String, String]], query_point as Point, k as Integer returns List[Point]:
    Note: Find k nearest neighbors to query point using k-d tree structure
    
    Note: Validate input parameters
    If MathOps.compare[k, "0"] is "less" or MathOps.compare[k, "0"] is "equal":
        Throw Errors.InvalidArgument with "k must be positive"
    End
    
    Note: Check if spatial structure exists
    If spatial_structure["type"] is not "kd_tree":
        Throw Errors.InvalidArgument with "Spatial structure must be k-d tree for nearest neighbor query"
    End
    
    Note: Initialize priority queue for k nearest neighbors (using simple list with sorting)
    Let neighbors be List[Dictionary[String, String]]()
    
    Note: Recursively search k-d tree for k nearest neighbors
    Call kd_tree_k_nearest_search[spatial_structure["root"], query_point, k, neighbors, "0"]
    
    Note: Convert results to Point list, sorted by distance
    Call sort_neighbors_by_distance[neighbors]
    
    Let result_points be List[Point]()
    Let i be 0
    While MathOps.compare[i, neighbors.length] is "less" and MathOps.compare[i, k] is "less":
        Let neighbor_data be neighbors[i]
        Let neighbor_point be Point with:
            coordinates as [neighbor_data["x"], neighbor_data["y"], neighbor_data["z"]]
            dimension as query_point.dimension
            coordinate_system as query_point.coordinate_system
            precision as query_point.precision
            metadata as Dictionary[String, String]()
        Add neighbor_point to result_points
        Set i to MathOps.add[i, "1"]
    End
    
    Return result_points

Process called "kd_tree_k_nearest_search" that takes node as Dictionary[String, Dictionary[String, String]], query_point as Point, k as Integer, neighbors as List[Dictionary[String, String]], depth as String returns Nothing:
    Note: Recursive k-nearest neighbor search in k-d tree with pruning
    
    Note: Check if node exists
    If node["exists"] is not "true":
        Return Nothing
    End
    
    Note: Get current point and calculate distance
    Let current_point_data be node["point"]
    Let current_point be Point with:
        coordinates as [current_point_data["x"], current_point_data["y"], current_point_data["z"]]
        dimension as query_point.dimension
        coordinate_system as query_point.coordinate_system
        precision as query_point.precision
        metadata as Dictionary[String, String]()
    
    Let distance_to_current be euclidean_distance[query_point, current_point]
    
    Note: Add current point to neighbors list
    Let neighbor_entry be Dictionary[String, String]()
    Set neighbor_entry["x"] to current_point_data["x"]
    Set neighbor_entry["y"] to current_point_data["y"] 
    Set neighbor_entry["z"] to current_point_data["z"]
    Set neighbor_entry["distance"] to distance_to_current
    
    Add neighbor_entry to neighbors
    
    Note: Keep only k closest neighbors
    Call sort_neighbors_by_distance[neighbors]
    While MathOps.compare[neighbors.length, k] is "greater":
        Remove neighbors[MathOps.subtract[neighbors.length, "1"]] from neighbors
    End
    
    Note: Determine search order based on splitting dimension
    Let split_dim be MathOps.mod[depth, query_point.dimension]
    Let query_coord be query_point.coordinates[split_dim]
    Let split_coord be current_point.coordinates[split_dim]
    
    Let search_left_first be false
    If MathOps.compare[query_coord, split_coord] is "less":
        Set search_left_first to true
    End
    
    Note: Search near subtree first
    If search_left_first:
        Call kd_tree_k_nearest_search[node["left"], query_point, k, neighbors, MathOps.add[depth, "1"]]
    Otherwise:
        Call kd_tree_k_nearest_search[node["right"], query_point, k, neighbors, MathOps.add[depth, "1"]]
    End
    
    Note: Check pruning condition minus search far subtree only if necessary
    Let coord_distance be MathOps.abs[MathOps.subtract[query_coord, split_coord]]
    Let should_search_far be true
    
    If MathOps.compare[neighbors.length, k] is "equal":
        Note: We have k neighbors, check if far subtree could contain closer points
        Let furthest_distance be neighbors[MathOps.subtract[neighbors.length, "1"]]["distance"]
        If MathOps.compare[coord_distance, furthest_distance] is "greater" or MathOps.compare[coord_distance, furthest_distance] is "equal":
            Set should_search_far to false
        End
    End
    
    If should_search_far:
        Note: Search far subtree
        If search_left_first:
            Call kd_tree_k_nearest_search[node["right"], query_point, k, neighbors, MathOps.add[depth, "1"]]
        Otherwise:
            Call kd_tree_k_nearest_search[node["left"], query_point, k, neighbors, MathOps.add[depth, "1"]]
        End
    End
    
    Return Nothing

Process called "sort_neighbors_by_distance" that takes neighbors as List[Dictionary[String, String]] returns Nothing:
    Note: Sort neighbors list by distance using simple bubble sort
    
    Let n be neighbors.length
    Let i be 0
    While MathOps.compare[i, MathOps.subtract[n, "1"]] is "less":
        Let j be 0
        While MathOps.compare[j, MathOps.subtract[MathOps.subtract[n, i], "1"]] is "less":
            Let current_distance be neighbors[j]["distance"]
            Let next_distance be neighbors[MathOps.add[j, "1"]]["distance"]
            
            If MathOps.compare[current_distance, next_distance] is "greater":
                Note: Swap elements
                Let temp be neighbors[j]
                Set neighbors[j] to neighbors[MathOps.add[j, "1"]]
                Set neighbors[MathOps.add[j, "1"]] to temp
            End
            
            Set j to MathOps.add[j, "1"]
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Return Nothing

Process called "range_query" that takes spatial_structure as Dictionary[String, Dictionary[String, String]], query_region as Dictionary[String, String] returns List[Point]:
    Note: Find all points within axis-aligned bounding box query region
    
    Note: Check if spatial structure exists
    If spatial_structure["type"] is not "kd_tree":
        Throw Errors.InvalidArgument with "Spatial structure must be k-d tree for range query"
    End
    
    Note: Validate query region format
    If query_region["type"] is not "aabb":
        Throw Errors.InvalidArgument with "Query region must be axis-aligned bounding box (aabb)"
    End
    
    Note: Parse bounding box coordinates
    Let min_x be query_region["min_x"]
    Let min_y be query_region["min_y"] 
    Let min_z be query_region["min_z"]
    Let max_x be query_region["max_x"]
    Let max_y be query_region["max_y"]
    Let max_z be query_region["max_z"]
    
    Note: Validate bounding box
    If MathOps.compare[min_x, max_x] is "greater":
        Throw Errors.InvalidArgument with "Invalid bounding box: min_x is greater than max_x"
    End
    If MathOps.compare[min_y, max_y] is "greater":
        Throw Errors.InvalidArgument with "Invalid bounding box: min_y is greater than max_y" 
    End
    If MathOps.compare[min_z, max_z] is "greater":
        Throw Errors.InvalidArgument with "Invalid bounding box: min_z is greater than max_z"
    End
    
    Note: Initialize result list
    Let result_points be List[Point]()
    
    Note: Recursively search k-d tree for points in range
    Call kd_tree_range_search[spatial_structure["root"], query_region, result_points, "0"]
    
    Return result_points

Process called "kd_tree_range_search" that takes node as Dictionary[String, Dictionary[String, String]], query_region as Dictionary[String, String], result_points as List[Point], depth as String returns Nothing:
    Note: Recursive range search in k-d tree with pruning
    
    Note: Check if node exists
    If node["exists"] is not "true":
        Return Nothing
    End
    
    Note: Get current point
    Let current_point_data be node["point"]
    Let current_point be Point with:
        coordinates as [current_point_data["x"], current_point_data["y"], current_point_data["z"]]
        dimension as 3
        coordinate_system as "cartesian"
        precision as 15
        metadata as Dictionary[String, String]()
    
    Note: Check if current point is within query region
    Let point_x be current_point_data["x"]
    Let point_y be current_point_data["y"]
    Let point_z be current_point_data["z"]
    
    Let point_in_range be true
    If MathOps.compare[point_x, query_region["min_x"]] is "less" or MathOps.compare[point_x, query_region["max_x"]] is "greater":
        Set point_in_range to false
    End
    If MathOps.compare[point_y, query_region["min_y"]] is "less" or MathOps.compare[point_y, query_region["max_y"]] is "greater":
        Set point_in_range to false
    End
    If MathOps.compare[point_z, query_region["min_z"]] is "less" or MathOps.compare[point_z, query_region["max_z"]] is "greater":
        Set point_in_range to false
    End
    
    Note: Add point to results if it's in range
    If point_in_range:
        Add current_point to result_points
    End
    
    Note: Determine which subtrees to search based on splitting plane
    Let split_dim be MathOps.mod[depth, "3"]
    Let split_coord be ""
    Let region_min be ""
    Let region_max be ""
    
    If MathOps.compare[split_dim, "0"] is "equal":
        Set split_coord to point_x
        Set region_min to query_region["min_x"]
        Set region_max to query_region["max_x"]
    End
    If MathOps.compare[split_dim, "1"] is "equal":
        Set split_coord to point_y
        Set region_min to query_region["min_y"]
        Set region_max to query_region["max_y"]
    End
    If MathOps.compare[split_dim, "2"] is "equal":
        Set split_coord to point_z
        Set region_min to query_region["min_z"]
        Set region_max to query_region["max_z"]
    End
    
    Note: Search left subtree if region intersects left half-space
    If MathOps.compare[region_min, split_coord] is "less" or MathOps.compare[region_min, split_coord] is "equal":
        Call kd_tree_range_search[node["left"], query_region, result_points, MathOps.add[depth, "1"]]
    End
    
    Note: Search right subtree if region intersects right half-space
    If MathOps.compare[region_max, split_coord] is "greater" or MathOps.compare[region_max, split_coord] is "equal":
        Call kd_tree_range_search[node["right"], query_region, result_points, MathOps.add[depth, "1"]]
    End
    
    Return Nothing

Process called "create_quadtree" that takes points as List[Point], bounds as Dictionary[String, String] returns Dictionary[String, Dictionary[String, String]]:
    Note: Create quadtree for efficient 2D spatial indexing with recursive subdivision
    
    Note: Validate input
    If points.length is "0":
        Throw Errors.InvalidArgument with "Cannot create quadtree from empty point set"
    End
    
    Note: Validate bounds format
    If bounds["type"] is not "aabb_2d":
        Throw Errors.InvalidArgument with "Bounds must be 2D axis-aligned bounding box"
    End
    
    Note: Validate all points are 2D
    Let i be 0
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, "2"] is not "equal":
            Throw Errors.InvalidArgument with "All points must be 2D for quadtree"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Create root quadtree node
    Let quadtree be Dictionary[String, Dictionary[String, String]]()
    Set quadtree["type"] to "quadtree"
    
    Note: Build quadtree recursively
    Set quadtree["root"] to build_quadtree_recursive[points, bounds, "0"]
    
    Return quadtree

Process called "build_quadtree_recursive" that takes points as List[Point], bounds as Dictionary[String, String], depth as String returns Dictionary[String, Dictionary[String, String]]:
    Note: Recursive quadtree construction with capacity-based subdivision
    
    Let node be Dictionary[String, Dictionary[String, String]]()
    Set node["exists"] to "true"
    Set node["depth"] to depth
    Set node["bounds"] to bounds
    
    Note: Set quadtree capacity (maximum points per leaf node)
    Let capacity be "4"
    Let max_depth be "10"
    
    Note: If few points or max depth reached, create leaf node
    If MathOps.compare[points.length, capacity] is "less" or MathOps.compare[points.length, capacity] is "equal" or MathOps.compare[depth, max_depth] is "greater" or MathOps.compare[depth, max_depth] is "equal":
        Set node["is_leaf"] to "true"
        Set node["point_count"] to points.length
        
        Note: Store points in leaf node
        Let j be 0
        While MathOps.compare[j, points.length] is "less":
            Let point_key be ConcatenateStrings["point_", j]
            Let point_dict be Dictionary[String, String]()
            Set point_dict["x"] to points[j].coordinates[0]
            Set point_dict["y"] to points[j].coordinates[1]
            Set node[point_key] to point_dict
            Set j to MathOps.add[j, "1"]
        End
        
        Set node["nw"] to Dictionary[String, Dictionary[String, String]]()
        Set node["nw"]["exists"] to "false"
        Set node["ne"] to Dictionary[String, Dictionary[String, String]]()
        Set node["ne"]["exists"] to "false"
        Set node["sw"] to Dictionary[String, Dictionary[String, String]]()
        Set node["sw"]["exists"] to "false"
        Set node["se"] to Dictionary[String, Dictionary[String, String]]()
        Set node["se"]["exists"] to "false"
        
        Return node
    End
    
    Note: Create internal node minus subdivide space into quadrants
    Set node["is_leaf"] to "false"
    Set node["point_count"] to points.length
    
    Note: Calculate quadrant bounds
    Let min_x be bounds["min_x"]
    Let min_y be bounds["min_y"]
    Let max_x be bounds["max_x"]
    Let max_y be bounds["max_y"]
    Let mid_x be MathOps.divide[MathOps.add[min_x, max_x], "2"]
    Let mid_y be MathOps.divide[MathOps.add[min_y, max_y], "2"]
    
    Note: Create quadrant bounds
    Let nw_bounds be Dictionary[String, String]()
    Set nw_bounds["type"] to "aabb_2d"
    Set nw_bounds["min_x"] to min_x
    Set nw_bounds["min_y"] to mid_y
    Set nw_bounds["max_x"] to mid_x
    Set nw_bounds["max_y"] to max_y
    
    Let ne_bounds be Dictionary[String, String]()
    Set ne_bounds["type"] to "aabb_2d"
    Set ne_bounds["min_x"] to mid_x
    Set ne_bounds["min_y"] to mid_y
    Set ne_bounds["max_x"] to max_x
    Set ne_bounds["max_y"] to max_y
    
    Let sw_bounds be Dictionary[String, String]()
    Set sw_bounds["type"] to "aabb_2d"
    Set sw_bounds["min_x"] to min_x
    Set sw_bounds["min_y"] to min_y
    Set sw_bounds["max_x"] to mid_x
    Set sw_bounds["max_y"] to mid_y
    
    Let se_bounds be Dictionary[String, String]()
    Set se_bounds["type"] to "aabb_2d"
    Set se_bounds["min_x"] to mid_x
    Set se_bounds["min_y"] to min_y
    Set se_bounds["max_x"] to max_x
    Set se_bounds["max_y"] to mid_y
    
    Note: Distribute points into quadrants
    Let nw_points be List[Point]()
    Let ne_points be List[Point]()
    Let sw_points be List[Point]()
    Let se_points be List[Point]()
    
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        Let point be points[i]
        Let x be point.coordinates[0]
        Let y be point.coordinates[1]
        
        Note: Determine which quadrant point belongs to
        If MathOps.compare[x, mid_x] is "less" or MathOps.compare[x, mid_x] is "equal":
            If MathOps.compare[y, mid_y] is "greater" or MathOps.compare[y, mid_y] is "equal":
                Add point to nw_points
            Otherwise:
                Add point to sw_points
            End
        Otherwise:
            If MathOps.compare[y, mid_y] is "greater" or MathOps.compare[y, mid_y] is "equal":
                Add point to ne_points
            Otherwise:
                Add point to se_points
            End
        End
        
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Recursively create child quadrants
    If nw_points.length is "0":
        Set node["nw"] to Dictionary[String, Dictionary[String, String]]()
        Set node["nw"]["exists"] to "false"
    Otherwise:
        Set node["nw"] to build_quadtree_recursive[nw_points, nw_bounds, MathOps.add[depth, "1"]]
    End
    
    If ne_points.length is "0":
        Set node["ne"] to Dictionary[String, Dictionary[String, String]]()
        Set node["ne"]["exists"] to "false"
    Otherwise:
        Set node["ne"] to build_quadtree_recursive[ne_points, ne_bounds, MathOps.add[depth, "1"]]
    End
    
    If sw_points.length is "0":
        Set node["sw"] to Dictionary[String, Dictionary[String, String]]()
        Set node["sw"]["exists"] to "false"
    Otherwise:
        Set node["sw"] to build_quadtree_recursive[sw_points, sw_bounds, MathOps.add[depth, "1"]]
    End
    
    If se_points.length is "0":
        Set node["se"] to Dictionary[String, Dictionary[String, String]]()
        Set node["se"]["exists"] to "false"
    Otherwise:
        Set node["se"] to build_quadtree_recursive[se_points, se_bounds, MathOps.add[depth, "1"]]
    End
    
    Return node

Process called "create_octree" that takes points as List[Point], bounds as Dictionary[String, String] returns Dictionary[String, Dictionary[String, String]]:
    Note: Create octree for efficient 3D spatial indexing with recursive subdivision
    
    Note: Validate input
    If points.length is "0":
        Throw Errors.InvalidArgument with "Cannot create octree from empty point set"
    End
    
    Note: Validate bounds format
    If bounds["type"] is not "aabb":
        Throw Errors.InvalidArgument with "Bounds must be 3D axis-aligned bounding box"
    End
    
    Note: Validate all points are 3D
    Let i be 0
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, "3"] is not "equal":
            Throw Errors.InvalidArgument with "All points must be 3D for octree"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Create root octree node
    Let octree be Dictionary[String, Dictionary[String, String]]()
    Set octree["type"] to "octree"
    
    Note: Build octree recursively
    Set octree["root"] to build_octree_recursive[points, bounds, "0"]
    
    Return octree

Process called "build_octree_recursive" that takes points as List[Point], bounds as Dictionary[String, String], depth as String returns Dictionary[String, Dictionary[String, String]]:
    Note: Recursive octree construction with capacity-based subdivision
    
    Let node be Dictionary[String, Dictionary[String, String]]()
    Set node["exists"] to "true"
    Set node["depth"] to depth
    Set node["bounds"] to bounds
    
    Note: Set octree capacity (maximum points per leaf node)
    Let capacity be "8"
    Let max_depth be "10"
    
    Note: If few points or max depth reached, create leaf node
    If MathOps.compare[points.length, capacity] is "less" or MathOps.compare[points.length, capacity] is "equal" or MathOps.compare[depth, max_depth] is "greater" or MathOps.compare[depth, max_depth] is "equal":
        Set node["is_leaf"] to "true"
        Set node["point_count"] to points.length
        
        Note: Store points in leaf node
        Let j be 0
        While MathOps.compare[j, points.length] is "less":
            Let point_key be ConcatenateStrings["point_", j]
            Let point_dict be Dictionary[String, String]()
            Set point_dict["x"] to points[j].coordinates[0]
            Set point_dict["y"] to points[j].coordinates[1]
            Set point_dict["z"] to points[j].coordinates[2]
            Set node[point_key] to point_dict
            Set j to MathOps.add[j, "1"]
        End
        
        Note: Initialize empty octants
        Set node["nwf"] to Dictionary[String, Dictionary[String, String]]()
        Set node["nwf"]["exists"] to "false"
        Set node["nef"] to Dictionary[String, Dictionary[String, String]]()
        Set node["nef"]["exists"] to "false"
        Set node["swf"] to Dictionary[String, Dictionary[String, String]]()
        Set node["swf"]["exists"] to "false"
        Set node["sef"] to Dictionary[String, Dictionary[String, String]]()
        Set node["sef"]["exists"] to "false"
        Set node["nwb"] to Dictionary[String, Dictionary[String, String]]()
        Set node["nwb"]["exists"] to "false"
        Set node["neb"] to Dictionary[String, Dictionary[String, String]]()
        Set node["neb"]["exists"] to "false"
        Set node["swb"] to Dictionary[String, Dictionary[String, String]]()
        Set node["swb"]["exists"] to "false"
        Set node["seb"] to Dictionary[String, Dictionary[String, String]]()
        Set node["seb"]["exists"] to "false"
        
        Return node
    End
    
    Note: Create internal node minus subdivide space into octants
    Set node["is_leaf"] to "false"
    Set node["point_count"] to points.length
    
    Note: Calculate octant bounds
    Let min_x be bounds["min_x"]
    Let min_y be bounds["min_y"]
    Let min_z be bounds["min_z"]
    Let max_x be bounds["max_x"]
    Let max_y be bounds["max_y"]
    Let max_z be bounds["max_z"]
    Let mid_x be MathOps.divide[MathOps.add[min_x, max_x], "2"]
    Let mid_y be MathOps.divide[MathOps.add[min_y, max_y], "2"]
    Let mid_z be MathOps.divide[MathOps.add[min_z, max_z], "2"]
    
    Note: Distribute points into octants
    Let nwf_points be List[Point]()  Note: Northwest front
    Let nef_points be List[Point]()  Note: Northeast front
    Let swf_points be List[Point]()  Note: Southwest front
    Let sef_points be List[Point]()  Note: Southeast front
    Let nwb_points be List[Point]()  Note: Northwest back
    Let neb_points be List[Point]()  Note: Northeast back
    Let swb_points be List[Point]()  Note: Southwest back
    Let seb_points be List[Point]()  Note: Southeast back
    
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        Let point be points[i]
        Let x be point.coordinates[0]
        Let y be point.coordinates[1]
        Let z be point.coordinates[2]
        
        Note: Determine which octant point belongs to
        If MathOps.compare[x, mid_x] is "less" or MathOps.compare[x, mid_x] is "equal":
            If MathOps.compare[y, mid_y] is "greater" or MathOps.compare[y, mid_y] is "equal":
                If MathOps.compare[z, mid_z] is "greater" or MathOps.compare[z, mid_z] is "equal":
                    Add point to nwf_points
                Otherwise:
                    Add point to nwb_points
                End
            Otherwise:
                If MathOps.compare[z, mid_z] is "greater" or MathOps.compare[z, mid_z] is "equal":
                    Add point to swf_points
                Otherwise:
                    Add point to swb_points
                End
            End
        Otherwise:
            If MathOps.compare[y, mid_y] is "greater" or MathOps.compare[y, mid_y] is "equal":
                If MathOps.compare[z, mid_z] is "greater" or MathOps.compare[z, mid_z] is "equal":
                    Add point to nef_points
                Otherwise:
                    Add point to neb_points
                End
            Otherwise:
                If MathOps.compare[z, mid_z] is "greater" or MathOps.compare[z, mid_z] is "equal":
                    Add point to sef_points
                Otherwise:
                    Add point to seb_points
                End
            End
        End
        
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Create octant bounds and recursively build children
    Let next_depth be MathOps.add[depth, "1"]
    
    Note: Northwest front octant
    If nwf_points.length is "0":
        Set node["nwf"] to Dictionary[String, Dictionary[String, String]]()
        Set node["nwf"]["exists"] to "false"
    Otherwise:
        Let nwf_bounds be Dictionary[String, String]()
        Set nwf_bounds["type"] to "aabb"
        Set nwf_bounds["min_x"] to min_x
        Set nwf_bounds["min_y"] to mid_y
        Set nwf_bounds["min_z"] to mid_z
        Set nwf_bounds["max_x"] to mid_x
        Set nwf_bounds["max_y"] to max_y
        Set nwf_bounds["max_z"] to max_z
        Set node["nwf"] to build_octree_recursive[nwf_points, nwf_bounds, next_depth]
    End
    
    Note: Northeast front octant
    If nef_points.length is "0":
        Set node["nef"] to Dictionary[String, Dictionary[String, String]]()
        Set node["nef"]["exists"] to "false"
    Otherwise:
        Let nef_bounds be Dictionary[String, String]()
        Set nef_bounds["type"] to "aabb"
        Set nef_bounds["min_x"] to mid_x
        Set nef_bounds["min_y"] to mid_y
        Set nef_bounds["min_z"] to mid_z
        Set nef_bounds["max_x"] to max_x
        Set nef_bounds["max_y"] to max_y
        Set nef_bounds["max_z"] to max_z
        Set node["nef"] to build_octree_recursive[nef_points, nef_bounds, next_depth]
    End
    
    Note: Southwest front octant
    If swf_points.length is "0":
        Set node["swf"] to Dictionary[String, Dictionary[String, String]]()
        Set node["swf"]["exists"] to "false"
    Otherwise:
        Let swf_bounds be Dictionary[String, String]()
        Set swf_bounds["type"] to "aabb"
        Set swf_bounds["min_x"] to min_x
        Set swf_bounds["min_y"] to min_y
        Set swf_bounds["min_z"] to mid_z
        Set swf_bounds["max_x"] to mid_x
        Set swf_bounds["max_y"] to mid_y
        Set swf_bounds["max_z"] to max_z
        Set node["swf"] to build_octree_recursive[swf_points, swf_bounds, next_depth]
    End
    
    Note: Southeast front octant
    If sef_points.length is "0":
        Set node["sef"] to Dictionary[String, Dictionary[String, String]]()
        Set node["sef"]["exists"] to "false"
    Otherwise:
        Let sef_bounds be Dictionary[String, String]()
        Set sef_bounds["type"] to "aabb"
        Set sef_bounds["min_x"] to mid_x
        Set sef_bounds["min_y"] to min_y
        Set sef_bounds["min_z"] to mid_z
        Set sef_bounds["max_x"] to max_x
        Set sef_bounds["max_y"] to mid_y
        Set sef_bounds["max_z"] to max_z
        Set node["sef"] to build_octree_recursive[sef_points, sef_bounds, next_depth]
    End
    
    Note: Northwest back octant
    If nwb_points.length is "0":
        Set node["nwb"] to Dictionary[String, Dictionary[String, String]]()
        Set node["nwb"]["exists"] to "false"
    Otherwise:
        Let nwb_bounds be Dictionary[String, String]()
        Set nwb_bounds["type"] to "aabb"
        Set nwb_bounds["min_x"] to min_x
        Set nwb_bounds["min_y"] to mid_y
        Set nwb_bounds["min_z"] to min_z
        Set nwb_bounds["max_x"] to mid_x
        Set nwb_bounds["max_y"] to max_y
        Set nwb_bounds["max_z"] to mid_z
        Set node["nwb"] to build_octree_recursive[nwb_points, nwb_bounds, next_depth]
    End
    
    Note: Northeast back octant
    If neb_points.length is "0":
        Set node["neb"] to Dictionary[String, Dictionary[String, String]]()
        Set node["neb"]["exists"] to "false"
    Otherwise:
        Let neb_bounds be Dictionary[String, String]()
        Set neb_bounds["type"] to "aabb"
        Set neb_bounds["min_x"] to mid_x
        Set neb_bounds["min_y"] to mid_y
        Set neb_bounds["min_z"] to min_z
        Set neb_bounds["max_x"] to max_x
        Set neb_bounds["max_y"] to max_y
        Set neb_bounds["max_z"] to mid_z
        Set node["neb"] to build_octree_recursive[neb_points, neb_bounds, next_depth]
    End
    
    Note: Southwest back octant
    If swb_points.length is "0":
        Set node["swb"] to Dictionary[String, Dictionary[String, String]]()
        Set node["swb"]["exists"] to "false"
    Otherwise:
        Let swb_bounds be Dictionary[String, String]()
        Set swb_bounds["type"] to "aabb"
        Set swb_bounds["min_x"] to min_x
        Set swb_bounds["min_y"] to min_y
        Set swb_bounds["min_z"] to min_z
        Set swb_bounds["max_x"] to mid_x
        Set swb_bounds["max_y"] to mid_y
        Set swb_bounds["max_z"] to mid_z
        Set node["swb"] to build_octree_recursive[swb_points, swb_bounds, next_depth]
    End
    
    Note: Southeast back octant
    If seb_points.length is "0":
        Set node["seb"] to Dictionary[String, Dictionary[String, String]]()
        Set node["seb"]["exists"] to "false"
    Otherwise:
        Let seb_bounds be Dictionary[String, String]()
        Set seb_bounds["type"] to "aabb"
        Set seb_bounds["min_x"] to mid_x
        Set seb_bounds["min_y"] to min_y
        Set seb_bounds["min_z"] to min_z
        Set seb_bounds["max_x"] to max_x
        Set seb_bounds["max_y"] to mid_y
        Set seb_bounds["max_z"] to mid_z
        Set node["seb"] to build_octree_recursive[seb_points, seb_bounds, next_depth]
    End
    
    Return node

Note: =====================================================================
Note: GEOMETRIC PREDICATES OPERATIONS
Note: =====================================================================

Process called "orientation_test" that takes point_a as Point, point_b as Point, point_c as Point returns String:
    Note: Determine orientation of three points using cross product sign
    Note: For 2D points, compute (b-a) × (c-a) is equal to (b.x-a.x)*(c.y-a.y) minus (b.y-a.y)*(c.x-a.x)
    
    Note: Validate input points are 2D
    If MathOps.compare[point_a.dimension, "2"] is not "equal":
        Throw Errors.InvalidArgument with "Orientation test requires 2D points"
    End
    If MathOps.compare[point_b.dimension, "2"] is not "equal":
        Throw Errors.InvalidArgument with "Orientation test requires 2D points"
    End
    If MathOps.compare[point_c.dimension, "2"] is not "equal":
        Throw Errors.InvalidArgument with "Orientation test requires 2D points"
    End
    
    Note: Extract coordinates
    Let ax be point_a.coordinates[0]
    Let ay be point_a.coordinates[1]
    Let bx be point_b.coordinates[0]
    Let by be point_b.coordinates[1]
    Let cx be point_c.coordinates[0]
    Let cy be point_c.coordinates[1]
    
    Note: Compute vectors AB and AC
    Let ab_x be MathOps.subtract[bx, ax]
    Let ab_y be MathOps.subtract[by, ay]
    Let ac_x be MathOps.subtract[cx, ax]
    Let ac_y be MathOps.subtract[cy, ay]
    
    Note: Compute cross product AB × AC is equal to ab_x*ac_y minus ab_y*ac_x
    Let cross_product be MathOps.subtract[
        MathOps.multiply[ab_x, ac_y],
        MathOps.multiply[ab_y, ac_x]
    ]
    
    Note: Determine orientation based on cross product sign
    Let tolerance be "1e-10"
    If MathOps.compare[MathOps.absolute_value[cross_product], tolerance] is "less":
        Return "collinear"
    End
    
    If MathOps.compare[cross_product, "0"] is "greater":
        Return "counterclockwise"
    End
    
    Return "clockwise"

Process called "incircle_test" that takes point_a as Point, point_b as Point, point_c as Point, point_d as Point returns String:
    Note: Test if fourth point is inside circle defined by first three points using determinant method
    
    Note: Validate all points are 2D
    If MathOps.compare[point_a.dimension, "2"] is not "equal" or MathOps.compare[point_b.dimension, "2"] is not "equal" or MathOps.compare[point_c.dimension, "2"] is not "equal" or MathOps.compare[point_d.dimension, "2"] is not "equal":
        Throw Errors.InvalidArgument with "All points must be 2D for incircle test"
    End
    
    Note: Get coordinates
    Let ax be point_a.coordinates[0]
    Let ay be point_a.coordinates[1]
    Let bx be point_b.coordinates[0] 
    Let by be point_b.coordinates[1]
    Let cx be point_c.coordinates[0]
    Let cy be point_c.coordinates[1]
    Let dx be point_d.coordinates[0]
    Let dy be point_d.coordinates[1]
    
    Note: Translate points relative to point_a to improve numerical stability
    Let bx_rel be MathOps.subtract[bx, ax]
    Let by_rel be MathOps.subtract[by, ay]
    Let cx_rel be MathOps.subtract[cx, ax]
    Let cy_rel be MathOps.subtract[cy, ay]
    Let dx_rel be MathOps.subtract[dx, ax]
    Let dy_rel be MathOps.subtract[dy, ay]
    
    Note: Calculate squared distances from point_a
    Let b_dist_sq be MathOps.add[MathOps.multiply[bx_rel, bx_rel], MathOps.multiply[by_rel, by_rel]]
    Let c_dist_sq be MathOps.add[MathOps.multiply[cx_rel, cx_rel], MathOps.multiply[cy_rel, cy_rel]]
    Let d_dist_sq be MathOps.add[MathOps.multiply[dx_rel, dx_rel], MathOps.multiply[dy_rel, dy_rel]]
    
    Note: Compute incircle determinant using 3x3 determinant formula
    Note: | bx_rel  by_rel  b_dist_sq |
    Note: | cx_rel  cy_rel  c_dist_sq |
    Note: | dx_rel  dy_rel  d_dist_sq |
    
    Let det_term1 be MathOps.multiply[bx_rel, MathOps.subtract[MathOps.multiply[cy_rel, d_dist_sq], MathOps.multiply[dy_rel, c_dist_sq]]]
    Let det_term2 be MathOps.multiply[by_rel, MathOps.subtract[MathOps.multiply[dx_rel, c_dist_sq], MathOps.multiply[cx_rel, d_dist_sq]]]
    Let det_term3 be MathOps.multiply[b_dist_sq, MathOps.subtract[MathOps.multiply[cx_rel, dy_rel], MathOps.multiply[dx_rel, cy_rel]]]
    
    Let determinant be MathOps.add[MathOps.add[det_term1, det_term2], det_term3]
    
    Note: Apply tolerance for numerical stability
    Let tolerance be "0.000000001"
    
    Note: Interpret determinant result
    If MathOps.compare[MathOps.abs[determinant], tolerance] is "less":
        Return "on_circle"
    End
    
    If MathOps.compare[determinant, "0"] is "greater":
        Return "inside"
    Otherwise:
        Return "outside"
    End

Process called "insphere_test" that takes point_a as Point, point_b as Point, point_c as Point, point_d as Point, point_e as Point returns String:
    Note: Test if fifth point is inside sphere defined by first four points using 4x4 determinant method
    
    Note: Validate all points are 3D
    If MathOps.compare[point_a.dimension, "3"] is not "equal" or MathOps.compare[point_b.dimension, "3"] is not "equal" or MathOps.compare[point_c.dimension, "3"] is not "equal" or MathOps.compare[point_d.dimension, "3"] is not "equal" or MathOps.compare[point_e.dimension, "3"] is not "equal":
        Throw Errors.InvalidArgument with "All points must be 3D for insphere test"
    End
    
    Note: Get coordinates
    Let ax be point_a.coordinates[0]
    Let ay be point_a.coordinates[1]
    Let az be point_a.coordinates[2]
    Let bx be point_b.coordinates[0]
    Let by be point_b.coordinates[1]
    Let bz be point_b.coordinates[2]
    Let cx be point_c.coordinates[0]
    Let cy be point_c.coordinates[1]
    Let cz be point_c.coordinates[2]
    Let dx be point_d.coordinates[0]
    Let dy be point_d.coordinates[1]
    Let dz be point_d.coordinates[2]
    Let ex be point_e.coordinates[0]
    Let ey be point_e.coordinates[1]
    Let ez be point_e.coordinates[2]
    
    Note: Translate points relative to point_a for numerical stability
    Let bx_rel be MathOps.subtract[bx, ax]
    Let by_rel be MathOps.subtract[by, ay]
    Let bz_rel be MathOps.subtract[bz, az]
    Let cx_rel be MathOps.subtract[cx, ax]
    Let cy_rel be MathOps.subtract[cy, ay]
    Let cz_rel be MathOps.subtract[cz, az]
    Let dx_rel be MathOps.subtract[dx, ax]
    Let dy_rel be MathOps.subtract[dy, ay]
    Let dz_rel be MathOps.subtract[dz, az]
    Let ex_rel be MathOps.subtract[ex, ax]
    Let ey_rel be MathOps.subtract[ey, ay]
    Let ez_rel be MathOps.subtract[ez, az]
    
    Note: Calculate squared distances from point_a
    Let b_dist_sq be MathOps.add[MathOps.add[MathOps.multiply[bx_rel, bx_rel], MathOps.multiply[by_rel, by_rel]], MathOps.multiply[bz_rel, bz_rel]]
    Let c_dist_sq be MathOps.add[MathOps.add[MathOps.multiply[cx_rel, cx_rel], MathOps.multiply[cy_rel, cy_rel]], MathOps.multiply[cz_rel, cz_rel]]
    Let d_dist_sq be MathOps.add[MathOps.add[MathOps.multiply[dx_rel, dx_rel], MathOps.multiply[dy_rel, dy_rel]], MathOps.multiply[dz_rel, dz_rel]]
    Let e_dist_sq be MathOps.add[MathOps.add[MathOps.multiply[ex_rel, ex_rel], MathOps.multiply[ey_rel, ey_rel]], MathOps.multiply[ez_rel, ez_rel]]
    
    Note: Compute insphere determinant using 4x4 determinant expansion
    Note: | bx_rel  by_rel  bz_rel  b_dist_sq |
    Note: | cx_rel  cy_rel  cz_rel  c_dist_sq |
    Note: | dx_rel  dy_rel  dz_rel  d_dist_sq |
    Note: | ex_rel  ey_rel  ez_rel  e_dist_sq |
    
    Note: Expand along first row for 4x4 determinant
    Let det_3x3_1 be MathOps.subtract[MathOps.subtract[MathOps.multiply[cy_rel, MathOps.subtract[MathOps.multiply[dz_rel, e_dist_sq], MathOps.multiply[ez_rel, d_dist_sq]]], MathOps.multiply[cz_rel, MathOps.subtract[MathOps.multiply[dy_rel, e_dist_sq], MathOps.multiply[ey_rel, d_dist_sq]]]], MathOps.multiply[c_dist_sq, MathOps.subtract[MathOps.multiply[dy_rel, ez_rel], MathOps.multiply[dz_rel, ey_rel]]]]
    
    Let det_3x3_2 be MathOps.subtract[MathOps.subtract[MathOps.multiply[cx_rel, MathOps.subtract[MathOps.multiply[dz_rel, e_dist_sq], MathOps.multiply[ez_rel, d_dist_sq]]], MathOps.multiply[cz_rel, MathOps.subtract[MathOps.multiply[dx_rel, e_dist_sq], MathOps.multiply[ex_rel, d_dist_sq]]]], MathOps.multiply[c_dist_sq, MathOps.subtract[MathOps.multiply[dx_rel, ez_rel], MathOps.multiply[dz_rel, ex_rel]]]]
    
    Let det_3x3_3 be MathOps.subtract[MathOps.subtract[MathOps.multiply[cx_rel, MathOps.subtract[MathOps.multiply[dy_rel, e_dist_sq], MathOps.multiply[ey_rel, d_dist_sq]]], MathOps.multiply[cy_rel, MathOps.subtract[MathOps.multiply[dx_rel, e_dist_sq], MathOps.multiply[ex_rel, d_dist_sq]]]], MathOps.multiply[c_dist_sq, MathOps.subtract[MathOps.multiply[dx_rel, ey_rel], MathOps.multiply[dy_rel, ex_rel]]]]
    
    Let det_3x3_4 be MathOps.subtract[MathOps.subtract[MathOps.multiply[cx_rel, MathOps.subtract[MathOps.multiply[dy_rel, ez_rel], MathOps.multiply[dz_rel, ey_rel]]], MathOps.multiply[cy_rel, MathOps.subtract[MathOps.multiply[dx_rel, ez_rel], MathOps.multiply[dz_rel, ex_rel]]]], MathOps.multiply[cz_rel, MathOps.subtract[MathOps.multiply[dx_rel, ey_rel], MathOps.multiply[dy_rel, ex_rel]]]]
    
    Let det_term1 be MathOps.multiply[bx_rel, det_3x3_1]
    Let det_term2 be MathOps.multiply[by_rel, MathOps.multiply["-1", det_3x3_2]]
    Let det_term3 be MathOps.multiply[bz_rel, det_3x3_3]
    Let det_term4 be MathOps.multiply[b_dist_sq, MathOps.multiply["-1", det_3x3_4]]
    
    Let determinant be MathOps.add[MathOps.add[MathOps.add[det_term1, det_term2], det_term3], det_term4]
    
    Note: Apply tolerance for numerical stability
    Let tolerance be "0.000000001"
    
    Note: Interpret determinant result
    If MathOps.compare[MathOps.abs[determinant], tolerance] is "less":
        Return "on_sphere"
    End
    
    If MathOps.compare[determinant, "0"] is "greater":
        Return "inside"
    Otherwise:
        Return "outside"
    End

Process called "collinearity_test" that takes points as List[Point], tolerance as String returns Boolean:
    Note: Test if points are collinear within tolerance using cross product method
    
    Note: Need at least 3 points for collinearity test
    If MathOps.compare[points.length, "3"] is "less":
        Throw Errors.InvalidArgument with "Need at least 3 points for collinearity test"
    End
    
    Note: Validate all points have same dimension
    Let first_dimension be points[0].dimension
    Let i be 1
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, first_dimension] is not "equal":
            Throw Errors.InvalidArgument with "All points must have same dimension"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: For 2D points, use cross product magnitude
    If MathOps.compare[first_dimension, "2"] is "equal":
        Note: Use first two points to define reference line
        Let point_a be points[0]
        Let point_b be points[1]
        
        Note: Check if first two points are the same (degenerate case)
        Let distance_ab be euclidean_distance[point_a, point_b]
        If MathOps.compare[distance_ab, tolerance] is "less":
            Throw Errors.InvalidArgument with "First two points are too close for collinearity test"
        End
        
        Note: Test all remaining points against line AB
        Set i to 2
        While MathOps.compare[i, points.length] is "less":
            Let point_c be points[i]
            
            Note: Calculate cross product magnitude for collinearity test
            Let ab_x be MathOps.subtract[point_b.coordinates[0], point_a.coordinates[0]]
            Let ab_y be MathOps.subtract[point_b.coordinates[1], point_a.coordinates[1]]
            Let ac_x be MathOps.subtract[point_c.coordinates[0], point_a.coordinates[0]]
            Let ac_y be MathOps.subtract[point_c.coordinates[1], point_a.coordinates[1]]
            
            Note: Cross product in 2D: |AB × AC| is equal to |ab_x multiplied by ac_y minus ab_y multiplied by ac_x|
            Let cross_product be MathOps.subtract[MathOps.multiply[ab_x, ac_y], MathOps.multiply[ab_y, ac_x]]
            Let cross_magnitude be MathOps.abs[cross_product]
            
            Note: Normalize by distance to get perpendicular distance
            Let perp_distance be MathOps.divide[cross_magnitude, distance_ab]
            
            If MathOps.compare[perp_distance, tolerance] is "greater":
                Return false
            End
            
            Set i to MathOps.add[i, "1"]
        End
        
        Return true
    End
    
    Note: For 3D points, use cross product method
    If MathOps.compare[first_dimension, "3"] is "equal":
        Note: Use first two points to define reference line
        Let point_a be points[0]
        Let point_b be points[1]
        
        Note: Check if first two points are the same (degenerate case)
        Let distance_ab be euclidean_distance[point_a, point_b]
        If MathOps.compare[distance_ab, tolerance] is "less":
            Throw Errors.InvalidArgument with "First two points are too close for collinearity test"
        End
        
        Note: Test all remaining points against line AB
        Set i to 2
        While MathOps.compare[i, points.length] is "less":
            Let point_c be points[i]
            
            Note: Calculate vectors AB and AC
            Let ab_x be MathOps.subtract[point_b.coordinates[0], point_a.coordinates[0]]
            Let ab_y be MathOps.subtract[point_b.coordinates[1], point_a.coordinates[1]]
            Let ab_z be MathOps.subtract[point_b.coordinates[2], point_a.coordinates[2]]
            Let ac_x be MathOps.subtract[point_c.coordinates[0], point_a.coordinates[0]]
            Let ac_y be MathOps.subtract[point_c.coordinates[1], point_a.coordinates[1]]
            Let ac_z be MathOps.subtract[point_c.coordinates[2], point_a.coordinates[2]]
            
            Note: Calculate cross product AB × AC
            Let cross_x be MathOps.subtract[MathOps.multiply[ab_y, ac_z], MathOps.multiply[ab_z, ac_y]]
            Let cross_y be MathOps.subtract[MathOps.multiply[ab_z, ac_x], MathOps.multiply[ab_x, ac_z]]
            Let cross_z be MathOps.subtract[MathOps.multiply[ab_x, ac_y], MathOps.multiply[ab_y, ac_x]]
            
            Note: Calculate magnitude of cross product
            Let cross_magnitude_sq be MathOps.add[MathOps.add[MathOps.multiply[cross_x, cross_x], MathOps.multiply[cross_y, cross_y]], MathOps.multiply[cross_z, cross_z]]
            Let cross_magnitude be MathOps.sqrt[cross_magnitude_sq]
            
            Note: Normalize by distance to get perpendicular distance
            Let perp_distance be MathOps.divide[cross_magnitude, distance_ab]
            
            If MathOps.compare[perp_distance, tolerance] is "greater":
                Return false
            End
            
            Set i to MathOps.add[i, "1"]
        End
        
        Return true
    End
    
    Note: For higher dimensions, use general linear dependency method
    Note: Points are collinear if vectors between them are linearly dependent
    
    If points.length is less than 2:
        Return true  Note: Trivially collinear
    
    Note: Create vectors from first point to others
    Let first_point be points[0]
    Let vectors be create_list_of_vectors(points.length minus 1)
    
    Let i be 1
    While i is less than points.length:
        Let vector_coords be create_list_of_strings(first_point.dimension)
        Let j be 0
        While j is less than first_point.dimension:
            Set vector_coords[j] to MathOps.subtract[points[i].coordinates[j], first_point.coordinates[j]]
            Set j to j plus 1
        Set vectors[i minus 1] to vector_coords
        Set i to i plus 1
    
    Note: Check if all vectors are scalar multiples of the first non-zero vector
    Let reference_vector be find_non_zero_vector(vectors)
    If reference_vector is empty:
        Return true  Note: All points are the same
    
    Note: Check if all other vectors are parallel to reference
    Set i to 0
    While i is less than vectors.length:
        If not are_vectors_parallel(vectors[i], reference_vector, tolerance):
            Return false
        Set i to i plus 1
    
    Return true

Process called "coplanarity_test" that takes points as List[Point], tolerance as String returns Boolean:
    Note: Test if points are coplanar within tolerance using scalar triple product method
    
    Note: Need at least 4 points for coplanarity test
    If MathOps.compare[points.length, "4"] is "less":
        Throw Errors.InvalidArgument with "Need at least 4 points for coplanarity test"
    End
    
    Note: Validate all points are 3D
    Let i be 0
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, "3"] is not "equal":
            Throw Errors.InvalidArgument with "All points must be 3D for coplanarity test"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Use first three points to define reference plane
    Let point_a be points[0]
    Let point_b be points[1]
    Let point_c be points[2]
    
    Note: Calculate vectors AB and AC
    Let ab_x be MathOps.subtract[point_b.coordinates[0], point_a.coordinates[0]]
    Let ab_y be MathOps.subtract[point_b.coordinates[1], point_a.coordinates[1]]
    Let ab_z be MathOps.subtract[point_b.coordinates[2], point_a.coordinates[2]]
    Let ac_x be MathOps.subtract[point_c.coordinates[0], point_a.coordinates[0]]
    Let ac_y be MathOps.subtract[point_c.coordinates[1], point_a.coordinates[1]]
    Let ac_z be MathOps.subtract[point_c.coordinates[2], point_a.coordinates[2]]
    
    Note: Calculate cross product AB × AC for plane normal
    Let normal_x be MathOps.subtract[MathOps.multiply[ab_y, ac_z], MathOps.multiply[ab_z, ac_y]]
    Let normal_y be MathOps.subtract[MathOps.multiply[ab_z, ac_x], MathOps.multiply[ab_x, ac_z]]
    Let normal_z be MathOps.subtract[MathOps.multiply[ab_x, ac_y], MathOps.multiply[ab_y, ac_x]]
    
    Note: Check if first three points are collinear (degenerate case)
    Let normal_magnitude_sq be MathOps.add[MathOps.add[MathOps.multiply[normal_x, normal_x], MathOps.multiply[normal_y, normal_y]], MathOps.multiply[normal_z, normal_z]]
    Let normal_magnitude be MathOps.sqrt[normal_magnitude_sq]
    
    If MathOps.compare[normal_magnitude, tolerance] is "less":
        Throw Errors.InvalidArgument with "First three points are collinear minus cannot define plane"
    End
    
    Note: Normalize the normal vector
    Let normal_x_unit be MathOps.divide[normal_x, normal_magnitude]
    Let normal_y_unit be MathOps.divide[normal_y, normal_magnitude]
    Let normal_z_unit be MathOps.divide[normal_z, normal_magnitude]
    
    Note: Test all remaining points against plane ABC
    Set i to 3
    While MathOps.compare[i, points.length] is "less":
        Let point_d be points[i]
        
        Note: Calculate vector AD
        Let ad_x be MathOps.subtract[point_d.coordinates[0], point_a.coordinates[0]]
        Let ad_y be MathOps.subtract[point_d.coordinates[1], point_a.coordinates[1]]
        Let ad_z be MathOps.subtract[point_d.coordinates[2], point_a.coordinates[2]]
        
        Note: Calculate scalar triple product (AB × AC) · AD is equal to distance from plane
        Let scalar_triple_product be MathOps.add[MathOps.add[MathOps.multiply[normal_x_unit, ad_x], MathOps.multiply[normal_y_unit, ad_y]], MathOps.multiply[normal_z_unit, ad_z]]
        
        Note: Check if point is within tolerance distance from plane
        If MathOps.compare[MathOps.abs[scalar_triple_product], tolerance] is "greater":
            Return false
        End
        
        Set i to MathOps.add[i, "1"]
    End
    
    Return true

Note: =====================================================================
Note: GEOMETRIC UTILITY OPERATIONS
Note: =====================================================================

Process called "compute_centroid" that takes points as List[Point] returns Point:
    Note: Compute centroid (center of mass) of point set
    If MathOps.compare[points.length, "0"] is "equal":
        Throw Errors.InvalidArgument with "Cannot compute centroid of empty point set"
    End
    
    Let dimension be points[0].dimension
    Let num_points be points.length
    
    Note: Initialize centroid coordinates to zero
    Let centroid_coordinates be List[String]()
    Let i be 0
    While MathOps.compare[i, dimension] is "less":
        Add "0" to centroid_coordinates
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Sum all point coordinates
    Set i to 0
    While MathOps.compare[i, num_points] is "less":
        Let current_point be points[i]
        
        Note: Validate dimension consistency
        If MathOps.compare[current_point.dimension, dimension] is not "equal":
            Throw Errors.InvalidArgument with "All points must have same dimension"
        End
        
        Let j be 0
        While MathOps.compare[j, dimension] is "less":
            Set centroid_coordinates[j] to MathOps.add[
                centroid_coordinates[j],
                current_point.coordinates[j]
            ]
            Set j to MathOps.add[j, "1"]
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Divide by number of points to get average
    Set i to 0
    While MathOps.compare[i, dimension] is "less":
        Set centroid_coordinates[i] to MathOps.divide[
            centroid_coordinates[i],
            num_points
        ]
        Set i to MathOps.add[i, "1"]
    End
    
    Return Point with:
        coordinates as centroid_coordinates
        dimension as dimension
        coordinate_system as points[0].coordinate_system
        precision as points[0].precision
        metadata as Dictionary[String, String]()

Process called "compute_bounding_box" that takes points as List[Point] returns Dictionary[String, Point]:
    Note: Compute axis-aligned bounding box of point set
    If MathOps.compare[points.length, "0"] is "equal":
        Throw Errors.InvalidArgument with "Cannot compute bounding box of empty point set"
    End
    
    Let dimension be points[0].dimension
    
    Note: Initialize min/max coordinates with first point
    Let min_coordinates be List[String]()
    Let max_coordinates be List[String]()
    Let i be 0
    While MathOps.compare[i, dimension] is "less":
        Add points[0].coordinates[i] to min_coordinates
        Add points[0].coordinates[i] to max_coordinates
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Find minimum and maximum coordinates in each dimension
    Let point_index be 1
    While MathOps.compare[point_index, points.length] is "less":
        Let current_point be points[point_index]
        
        Note: Validate dimension consistency
        If MathOps.compare[current_point.dimension, dimension] is not "equal":
            Throw Errors.InvalidArgument with "All points must have same dimension"
        End
        
        Set i to 0
        While MathOps.compare[i, dimension] is "less":
            Let coord be current_point.coordinates[i]
            
            Note: Update minimum
            If MathOps.compare[coord, min_coordinates[i]] is "less":
                Set min_coordinates[i] to coord
            End
            
            Note: Update maximum
            If MathOps.compare[coord, max_coordinates[i]] is "greater":
                Set max_coordinates[i] to coord
            End
            
            Set i to MathOps.add[i, "1"]
        End
        Set point_index to MathOps.add[point_index, "1"]
    End
    
    Let min_point be Point with:
        coordinates as min_coordinates
        dimension as dimension
        coordinate_system as points[0].coordinate_system
        precision as points[0].precision
        metadata as Dictionary[String, String]()
    
    Let max_point be Point with:
        coordinates as max_coordinates
        dimension as dimension
        coordinate_system as points[0].coordinate_system
        precision as points[0].precision
        metadata as Dictionary[String, String]()
    
    Let bounding_box be Dictionary[String, Point]()
    Set bounding_box["min"] to min_point
    Set bounding_box["max"] to max_point
    
    Return bounding_box

Process called "compute_oriented_bounding_box" that takes points as List[Point] returns Dictionary[String, Dictionary[String, String]]:
    Note: Compute oriented bounding box with minimum volume using PCA-based approach
    
    Note: Validate input
    If MathOps.compare[points.length, "0"] is "equal":
        Throw Errors.InvalidArgument with "Cannot compute oriented bounding box of empty point set"
    End
    
    If MathOps.compare[points.length, "1"] is "equal":
        Note: Single point case minus return degenerate box
        Let single_point_dict be Dictionary[String, String]()
        Set single_point_dict["x"] to points[0].coordinates[0]
        Set single_point_dict["y"] to points[0].coordinates[1]
        If MathOps.compare[points[0].dimension, "3"] is "equal":
            Set single_point_dict["z"] to points[0].coordinates[2]
        End
        
        Let obb_result be Dictionary[String, Dictionary[String, String]]()
        Set obb_result["center"] to single_point_dict
        Set obb_result["extents"] to Dictionary[String, String]()
        Set obb_result["extents"]["x"] to "0"
        Set obb_result["extents"]["y"] to "0"
        Set obb_result["extents"]["z"] to "0"
        Set obb_result["axes"] to Dictionary[String, String]()
        Return obb_result
    End
    
    Note: Validate all points have same dimension
    Let first_dimension be points[0].dimension
    Let i be 1
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, first_dimension] is not "equal":
            Throw Errors.InvalidArgument with "All points must have same dimension"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Compute centroid of points
    Let centroid be compute_centroid[points]
    
    Note: For 2D case, use simplified approach with rotating calipers approximation
    If MathOps.compare[first_dimension, "2"] is "equal":
        Note: Find convex hull first for better OBB
        Let convex_hull_points be convex_hull_2d[points]
        
        Note: Initialize best area and orientation
        Let min_area be Float.positive_infinity()
        Let best_angle be "0"
        Let best_width be "0"
        Let best_height be "0"
        
        Note: Test different orientations (simplified approach)
        Let angle_step be "0.15707963"  Note: Pi/20 radians (9 degrees)
        Let current_angle be "0"
        While MathOps.compare[current_angle, "6.28318530"] is "less":  Note: 2*Pi
            Note: Rotate all points by current angle and find axis-aligned bounding box
            Let cos_angle be MathOps.cos[current_angle]
            Let sin_angle be MathOps.sin[current_angle]
            
            Let min_x be Float.positive_infinity()
            Let max_x be Float.negative_infinity()
            Let min_y be Float.positive_infinity()
            Let max_y be Float.negative_infinity()
            
            Set i to 0
            While MathOps.compare[i, convex_hull_points.length] is "less":
                Let point be convex_hull_points[i]
                Let px be MathOps.subtract[point.coordinates[0], centroid.coordinates[0]]
                Let py be MathOps.subtract[point.coordinates[1], centroid.coordinates[1]]
                
                Note: Rotate point
                Let rotated_x be MathOps.subtract[MathOps.multiply[px, cos_angle], MathOps.multiply[py, sin_angle]]
                Let rotated_y be MathOps.add[MathOps.multiply[px, sin_angle], MathOps.multiply[py, cos_angle]]
                
                If MathOps.compare[rotated_x, min_x] is "less":
                    Set min_x to rotated_x
                End
                If MathOps.compare[rotated_x, max_x] is "greater":
                    Set max_x to rotated_x
                End
                If MathOps.compare[rotated_y, min_y] is "less":
                    Set min_y to rotated_y
                End
                If MathOps.compare[rotated_y, max_y] is "greater":
                    Set max_y to rotated_y
                End
                
                Set i to MathOps.add[i, "1"]
            End
            
            Let width be MathOps.subtract[max_x, min_x]
            Let height be MathOps.subtract[max_y, min_y]
            Let area be MathOps.multiply[width, height]
            
            If MathOps.compare[area, min_area] is "less":
                Set min_area to area
                Set best_angle to current_angle
                Set best_width to width
                Set best_height to height
            End
            
            Set current_angle to MathOps.add[current_angle, angle_step]
        End
        
        Note: Create OBB result
        Let obb_result be Dictionary[String, Dictionary[String, String]]()
        
        Let center_dict be Dictionary[String, String]()
        Set center_dict["x"] to centroid.coordinates[0]
        Set center_dict["y"] to centroid.coordinates[1]
        Set obb_result["center"] to center_dict
        
        Let extents_dict be Dictionary[String, String]()
        Set extents_dict["x"] to MathOps.divide[best_width, "2"]
        Set extents_dict["y"] to MathOps.divide[best_height, "2"]
        Set extents_dict["z"] to "0"
        Set obb_result["extents"] to extents_dict
        
        Let axes_dict be Dictionary[String, String]()
        Set axes_dict["angle"] to best_angle
        Set axes_dict["cos"] to MathOps.cos[best_angle]
        Set axes_dict["sin"] to MathOps.sin[best_angle]
        Set obb_result["axes"] to axes_dict
        
        Return obb_result
    End
    
    Note: For 3D case, use simplified covariance-based approach
    If MathOps.compare[first_dimension, "3"] is "equal":
        Note: Compute covariance matrix
        Let cov_xx be "0"
        Let cov_yy be "0"
        Let cov_zz be "0"
        Let cov_xy be "0"
        Let cov_xz be "0"
        Let cov_yz be "0"
        
        Set i to 0
        While MathOps.compare[i, points.length] is "less":
            Let point be points[i]
            Let dx be MathOps.subtract[point.coordinates[0], centroid.coordinates[0]]
            Let dy be MathOps.subtract[point.coordinates[1], centroid.coordinates[1]]
            Let dz be MathOps.subtract[point.coordinates[2], centroid.coordinates[2]]
            
            Set cov_xx to MathOps.add[cov_xx, MathOps.multiply[dx, dx]]
            Set cov_yy to MathOps.add[cov_yy, MathOps.multiply[dy, dy]]
            Set cov_zz to MathOps.add[cov_zz, MathOps.multiply[dz, dz]]
            Set cov_xy to MathOps.add[cov_xy, MathOps.multiply[dx, dy]]
            Set cov_xz to MathOps.add[cov_xz, MathOps.multiply[dx, dz]]
            Set cov_yz to MathOps.add[cov_yz, MathOps.multiply[dy, dz]]
            
            Set i to MathOps.add[i, "1"]
        End
        
        Let num_points_str be points.length
        Set cov_xx to MathOps.divide[cov_xx, num_points_str]
        Set cov_yy to MathOps.divide[cov_yy, num_points_str]
        Set cov_zz to MathOps.divide[cov_zz, num_points_str]
        Set cov_xy to MathOps.divide[cov_xy, num_points_str]
        Set cov_xz to MathOps.divide[cov_xz, num_points_str]
        Set cov_yz to MathOps.divide[cov_yz, num_points_str]
        
        Note: Compute proper OBB using principal component analysis (PCA)
        Note: Eigenvalues and eigenvectors give the principal axes and their lengths
        
        Note: Build covariance matrix for eigendecomposition
        Let cov_matrix be List[List[String]]()
        Let row1 be List[String]()
        Let row2 be List[String]()
        Let row3 be List[String]()
        
        Call row1.add(cov_xx)
        Call row1.add(cov_xy)
        Call row1.add(cov_xz)
        Call row2.add(cov_xy)
        Call row2.add(cov_yy)
        Call row2.add(cov_yz)
        Call row3.add(cov_xz)
        Call row3.add(cov_yz)
        Call row3.add(cov_zz)
        
        Call cov_matrix.add(row1)
        Call cov_matrix.add(row2)
        Call cov_matrix.add(row3)
        
        Note: Compute eigenvalues and eigenvectors using power method for 3x3 symmetric matrix
        Let principal_axes be List[Vector]()
        Let axis_lengths be List[String]()
        
        Note: First principal axis (dominant eigenvector)
        Let dominant_axis be Vector with:
            components as List[String]()
            dimension as 3
        
        Note: Initialize with random vector
        Call dominant_axis.components.add("1.0")
        Call dominant_axis.components.add("0.0")
        Call dominant_axis.components.add("0.0")
        
        Note: Power iteration to find dominant eigenvector
        Let max_iterations be 20
        Let iter be 0
        While MathOps.compare[iter, max_iterations] is "less":
            Note: Multiply covariance matrix by current vector
            Let new_x be MathOps.add[MathOps.add[MathOps.multiply[cov_xx, dominant_axis.components[0]], MathOps.multiply[cov_xy, dominant_axis.components[1]]], MathOps.multiply[cov_xz, dominant_axis.components[2]]]
            Let new_y be MathOps.add[MathOps.add[MathOps.multiply[cov_xy, dominant_axis.components[0]], MathOps.multiply[cov_yy, dominant_axis.components[1]]], MathOps.multiply[cov_yz, dominant_axis.components[2]]]
            Let new_z be MathOps.add[MathOps.add[MathOps.multiply[cov_xz, dominant_axis.components[0]], MathOps.multiply[cov_yz, dominant_axis.components[1]]], MathOps.multiply[cov_zz, dominant_axis.components[2]]]
            
            Note: Normalize the vector
            Let magnitude be MathOps.sqrt[MathOps.add[MathOps.add[MathOps.multiply[new_x, new_x], MathOps.multiply[new_y, new_y]], MathOps.multiply[new_z, new_z]]]
            If MathOps.compare[magnitude, "0.001"] is "greater":
                Set dominant_axis.components[0] to MathOps.divide[new_x, magnitude]
                Set dominant_axis.components[1] to MathOps.divide[new_y, magnitude]
                Set dominant_axis.components[2] to MathOps.divide[new_z, magnitude]
            End
            
            Set iter to MathOps.add[iter, "1"]
        End
        
        Call principal_axes.add(dominant_axis)
        
        Note: Compute remaining orthogonal axes using Gram-Schmidt
        Let second_axis be Vector with:
            components as List[String]()
            dimension as 3
        
        Note: Start with a vector not parallel to first axis
        If MathOps.compare[MathOps.abs[dominant_axis.components[0]], "0.9"] is "less":
            Call second_axis.components.add("1.0")
            Call second_axis.components.add("0.0") 
            Call second_axis.components.add("0.0")
        Otherwise:
            Call second_axis.components.add("0.0")
            Call second_axis.components.add("1.0")
            Call second_axis.components.add("0.0")
        End
        
        Note: Orthogonalize second axis against first using Gram-Schmidt
        Let dot_product be MathOps.add[MathOps.add[MathOps.multiply[second_axis.components[0], dominant_axis.components[0]], MathOps.multiply[second_axis.components[1], dominant_axis.components[1]]], MathOps.multiply[second_axis.components[2], dominant_axis.components[2]]]
        
        Set second_axis.components[0] to MathOps.subtract[second_axis.components[0], MathOps.multiply[dot_product, dominant_axis.components[0]]]
        Set second_axis.components[1] to MathOps.subtract[second_axis.components[1], MathOps.multiply[dot_product, dominant_axis.components[1]]]
        Set second_axis.components[2] to MathOps.subtract[second_axis.components[2], MathOps.multiply[dot_product, dominant_axis.components[2]]]
        
        Note: Normalize second axis
        Let second_magnitude be MathOps.sqrt[MathOps.add[MathOps.add[MathOps.multiply[second_axis.components[0], second_axis.components[0]], MathOps.multiply[second_axis.components[1], second_axis.components[1]]], MathOps.multiply[second_axis.components[2], second_axis.components[2]]]]
        If MathOps.compare[second_magnitude, "0.001"] is "greater":
            Set second_axis.components[0] to MathOps.divide[second_axis.components[0], second_magnitude]
            Set second_axis.components[1] to MathOps.divide[second_axis.components[1], second_magnitude]
            Set second_axis.components[2] to MathOps.divide[second_axis.components[2], second_magnitude]
        End
        
        Call principal_axes.add(second_axis)
        
        Note: Third axis is cross product of first two
        Let third_axis be Vector with:
            components as List[String]()
            dimension as 3
            
        Let cross_x be MathOps.subtract[MathOps.multiply[dominant_axis.components[1], second_axis.components[2]], MathOps.multiply[dominant_axis.components[2], second_axis.components[1]]]
        Let cross_y be MathOps.subtract[MathOps.multiply[dominant_axis.components[2], second_axis.components[0]], MathOps.multiply[dominant_axis.components[0], second_axis.components[2]]]
        Let cross_z be MathOps.subtract[MathOps.multiply[dominant_axis.components[0], second_axis.components[1]], MathOps.multiply[dominant_axis.components[1], second_axis.components[0]]]
        
        Call third_axis.components.add(cross_x)
        Call third_axis.components.add(cross_y)
        Call third_axis.components.add(cross_z)
        
        Call principal_axes.add(third_axis)
        
        Note: Project all points onto principal axes to find extents
        Let min_projections be List[String]()
        Let max_projections be List[String]()
        Call min_projections.add("999999999.0")
        Call min_projections.add("999999999.0")
        Call min_projections.add("999999999.0")
        Call max_projections.add("-999999999.0")
        Call max_projections.add("-999999999.0")
        Call max_projections.add("-999999999.0")
        
        Set i to 0
        While MathOps.compare[i, points.length] is "less":
            Let point be points[i]
            Let relative_x be MathOps.subtract[point.coordinates[0], centroid.coordinates[0]]
            Let relative_y be MathOps.subtract[point.coordinates[1], centroid.coordinates[1]]
            Let relative_z be MathOps.subtract[point.coordinates[2], centroid.coordinates[2]]
            
            Note: Project onto each principal axis
            Let axis_idx be 0
            While MathOps.compare[axis_idx, "3"] is "less":
                Let axis be principal_axes[axis_idx]
                Let projection be MathOps.add[MathOps.add[MathOps.multiply[relative_x, axis.components[0]], MathOps.multiply[relative_y, axis.components[1]]], MathOps.multiply[relative_z, axis.components[2]]]
                
                If MathOps.compare[projection, min_projections[axis_idx]] is "less":
                    Set min_projections[axis_idx] to projection
                End
                If MathOps.compare[projection, max_projections[axis_idx]] is "greater":
                    Set max_projections[axis_idx] to projection
                End
                
                Set axis_idx to MathOps.add[axis_idx, "1"]
            End
            
            Set i to MathOps.add[i, "1"]
        End
        
        Note: Calculate OBB half-extents
        Set axis_idx to 0
        While MathOps.compare[axis_idx, "3"] is "less":
            Let extent be MathOps.divide[MathOps.subtract[max_projections[axis_idx], min_projections[axis_idx]], "2.0"]
            Call axis_lengths.add(extent)
            Set axis_idx to MathOps.add[axis_idx, "1"]
        End
        
        Let obb_result be Dictionary[String, Dictionary[String, String]]()
        
        Let center_dict be Dictionary[String, String]()
        Set center_dict["x"] to centroid.coordinates[0]
        Set center_dict["y"] to centroid.coordinates[1]
        Set center_dict["z"] to centroid.coordinates[2]
        Set obb_result["center"] to center_dict
        
        Let extents_dict be Dictionary[String, String]()
        Set extents_dict["axis1"] to axis_lengths[0]
        Set extents_dict["axis2"] to axis_lengths[1]
        Set extents_dict["axis3"] to axis_lengths[2]
        Set obb_result["extents"] to extents_dict
        
        Let axes_dict be Dictionary[String, Dictionary[String, String]]()
        
        Let axis1_dict be Dictionary[String, String]()
        Set axis1_dict["x"] to principal_axes[0].components[0]
        Set axis1_dict["y"] to principal_axes[0].components[1]
        Set axis1_dict["z"] to principal_axes[0].components[2]
        Set axes_dict["axis1"] to axis1_dict
        
        Let axis2_dict be Dictionary[String, String]()
        Set axis2_dict["x"] to principal_axes[1].components[0]
        Set axis2_dict["y"] to principal_axes[1].components[1]
        Set axis2_dict["z"] to principal_axes[1].components[2]
        Set axes_dict["axis2"] to axis2_dict
        
        Let axis3_dict be Dictionary[String, String]()
        Set axis3_dict["x"] to principal_axes[2].components[0]
        Set axis3_dict["y"] to principal_axes[2].components[1]
        Set axis3_dict["z"] to principal_axes[2].components[2]
        Set axes_dict["axis3"] to axis3_dict
        
        Set obb_result["axes"] to axes_dict
        
        Return obb_result
    End
    
    Note: For higher dimensions, use axis-aligned bounding box approximation
    Note: This is not optimal but provides a working solution
    
    Let dimension be points[0].dimension
    Let min_coords be create_list_of_strings(dimension)
    Let max_coords be create_list_of_strings(dimension)
    
    Note: Initialize with first point
    Let i be 0
    While i is less than dimension:
        Set min_coords[i] to points[0].coordinates[i]
        Set max_coords[i] to points[0].coordinates[i]
        Set i to i plus 1
    
    Note: Find min/max in each dimension
    Let point_idx be 1
    While point_idx is less than points.length:
        Set i to 0
        While i is less than dimension:
            If MathOps.compare[points[point_idx].coordinates[i], min_coords[i]] is "less":
                Set min_coords[i] to points[point_idx].coordinates[i]
            If MathOps.compare[points[point_idx].coordinates[i], max_coords[i]] is "greater":
                Set max_coords[i] to points[point_idx].coordinates[i]
            Set i to i plus 1
        Set point_idx to point_idx plus 1
    
    Note: Create axis-aligned bounding box result
    Let obb_result be OrientedBoundingBox {
        center as create_center_point(min_coords, max_coords, dimension)
        axes as create_identity_axes(dimension)
        extents as compute_extents(min_coords, max_coords, dimension)
        volume as compute_hypervolume(min_coords, max_coords, dimension)
    }
    
    Return obb_result

Process called "point_set_diameter" that takes points as List[Point] returns String:
    Note: Compute diameter (maximum distance) of point set using brute force approach
    
    Note: Validate input
    If MathOps.compare[points.length, "0"] is "equal":
        Throw Errors.InvalidArgument with "Cannot compute diameter of empty point set"
    End
    
    If MathOps.compare[points.length, "1"] is "equal":
        Return "0"
    End
    
    Note: Validate all points have same dimension
    Let first_dimension be points[0].dimension
    Let i be 1
    While MathOps.compare[i, points.length] is "less":
        If MathOps.compare[points[i].dimension, first_dimension] is not "equal":
            Throw Errors.InvalidArgument with "All points must have same dimension"
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Initialize maximum distance
    Let max_distance be "0"
    
    Note: Compare every pair of points to find maximum distance
    Set i to 0
    While MathOps.compare[i, points.length] is "less":
        Let j be MathOps.add[i, "1"]
        While MathOps.compare[j, points.length] is "less":
            Let distance be euclidean_distance[points[i], points[j]]
            
            If MathOps.compare[distance, max_distance] is "greater":
                Set max_distance to distance
            End
            
            Set j to MathOps.add[j, "1"]
        End
        Set i to MathOps.add[i, "1"]
    End
    
    Return max_distance

Process called "geometric_hash" that takes geometric_object as Dictionary[String, String], precision as Integer returns String:
    Note: Compute geometric hash for object identification using coordinate-based hashing
    
    Note: Validate precision
    If MathOps.compare[precision, "0"] is "less":
        Throw Errors.InvalidArgument with "Precision must be non-negative"
    End
    
    Note: Determine object type and extract coordinates
    Let object_type be geometric_object["type"]
    Let hash_components be List[String]()
    
    Note: Add object type to hash
    Add object_type to hash_components
    
    If object_type is "point":
        Note: Hash point coordinates
        Add geometric_object["x"] to hash_components
        Add geometric_object["y"] to hash_components
        If geometric_object["z"] is not "":
            Add geometric_object["z"] to hash_components
        End
    End
    
    If object_type is "line":
        Note: Hash line endpoints
        Add geometric_object["start_x"] to hash_components
        Add geometric_object["start_y"] to hash_components
        Add geometric_object["end_x"] to hash_components
        Add geometric_object["end_y"] to hash_components
        If geometric_object["start_z"] is not "":
            Add geometric_object["start_z"] to hash_components
            Add geometric_object["end_z"] to hash_components
        End
    End
    
    If object_type is "plane":
        Note: Hash plane normal and point
        Add geometric_object["normal_x"] to hash_components
        Add geometric_object["normal_y"] to hash_components
        Add geometric_object["normal_z"] to hash_components
        Add geometric_object["point_x"] to hash_components
        Add geometric_object["point_y"] to hash_components
        Add geometric_object["point_z"] to hash_components
    End
    
    If object_type is "circle":
        Note: Hash circle center and radius
        Add geometric_object["center_x"] to hash_components
        Add geometric_object["center_y"] to hash_components
        Add geometric_object["radius"] to hash_components
    End
    
    If object_type is "sphere":
        Note: Hash sphere center and radius
        Add geometric_object["center_x"] to hash_components
        Add geometric_object["center_y"] to hash_components
        Add geometric_object["center_z"] to hash_components
        Add geometric_object["radius"] to hash_components
    End
    
    Note: Round coordinates to specified precision
    Let rounded_components be List[String]()
    Let i be 0
    While MathOps.compare[i, hash_components.length] is "less":
        Let component be hash_components[i]
        
        Note: Check if component is numeric (skip type string)
        If i is "0":
            Add component to rounded_components
        Otherwise:
            Note: Round to specified decimal places
            Let rounded_value be MathOps.round[component, precision]
            Add rounded_value to rounded_components
        End
        
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Create hash string by concatenating rounded components
    Let hash_string be ""
    Set i to 0
    While MathOps.compare[i, rounded_components.length] is "less":
        Set hash_string to ConcatenateStrings[hash_string, rounded_components[i]]
        
        Note: Add separator between components (except for last)
        If MathOps.compare[i, MathOps.subtract[rounded_components.length, "1"]] is "less":
            Set hash_string to ConcatenateStrings[hash_string, "|"]
        End
        
        Set i to MathOps.add[i, "1"]
    End
    
    Note: Generate simple hash using string length and character sum
    Let hash_value be hash_string.length
    Let char_sum be "0"
    Set i to 0
    While MathOps.compare[i, hash_string.length] is "less":
        Note: Add ASCII value approximation (simplified)
        Set char_sum to MathOps.add[char_sum, "1"]
        Set i to MathOps.add[i, "1"]
    End
    
    Let final_hash be MathOps.add[MathOps.multiply[hash_value, "31"], char_sum]
    Return ConcatenateStrings["hash_", final_hash]