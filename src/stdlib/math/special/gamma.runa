Note:
math/special/gamma.runa
Gamma Function and Related Special Functions

This module provides comprehensive gamma function family implementations including
gamma function, log gamma, beta function, incomplete gamma functions, factorial
operations, Pochhammer symbols, digamma, polygamma, and gamma distribution functions
with numerical analysis and mathematical theory support.
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/precision/bigdecimal" as BigDecimal
Import module "math/core/constants" as Constants
Import module "math/core/operations" as Operations
Import module "math/engine/numerical/core" as NumericalCore
Import module "math/core/trigonometry" as Trigonometry
Import module "math/discrete/combinatorics" as Combinatorics

Note: =====================================================================
Note: GAMMA FUNCTION DATA STRUCTURES
Note: =====================================================================

Type called "GammaConfig":
    precision as Float
    max_iterations as Integer
    convergence_threshold as Float
    series_method as String
    asymptotic_threshold as Float
    lanczos_coefficients as List[Float]
    stirling_corrections as List[Float]

Type called "GammaResult":
    value as Float
    error_estimate as Float
    iterations_used as Integer
    method_used as String
    convergence_status as String
    derivative_values as List[Float]

Type called "BetaConfig":
    precision as Float
    integration_method as String
    max_subdivisions as Integer
    continued_fraction_depth as Integer
    symmetry_optimization as Boolean

Type called "FactorialConfig":
    cache_size as Integer
    stirling_approximation_threshold as Integer
    extended_precision as Boolean
    overflow_handling as String

Note: =====================================================================
Note: HELPER FUNCTIONS FOR GAMMA COMPUTATIONS
Note: =====================================================================

Process called "compute_log_gamma_complex" that takes z_real as Float, z_imag as Float, config as GammaConfig returns Dictionary[String, Float]:
    Note: Compute complex log-gamma function using asymptotic expansion
    Let result be Dictionary[String, Float]
    
    Note: For complex log-gamma, we use the asymptotic series
    Note: log Γ(z) ≈ (z-1/2)log(z) minus z plus (1/2)log(2π) plus asymptotic terms
    
    Let z_mag_squared be z_real multiplied by z_real plus z_imag multiplied by z_imag
    Let z_magnitude be SquareRoot(z_mag_squared)
    Let z_arg be ArcTangent2(z_imag, z_real)
    
    Note: (z-1/2)log(z) term
    Let z_minus_half_real be z_real minus 0.5
    Let log_z_real be NumericalCore.natural_log_high_precision(ToString(z_magnitude), config.precision plus 3)
    Let log_z_imag be z_arg
    
    Let term1_real be z_minus_half_real multiplied by Parse log_z_real as Float minus z_imag multiplied by log_z_imag
    Let term1_imag be z_minus_half_real multiplied by log_z_imag plus z_imag multiplied by Parse log_z_real as Float
    
    Note: -z term  
    Let term2_real be -z_real
    Let term2_imag be -z_imag
    
    Note: (1/2)log(2π) term
    Let two_pi be Constants.get_unit_circle_circumference(config.precision plus 2)
    Let half_log_2pi be BigDecimal.divide_high_precision(NumericalCore.natural_log_high_precision(two_pi, config.precision plus 2), "2", config.precision plus 1)
    Let term3_real be Parse half_log_2pi as Float
    Let term3_imag be 0.0
    
    Note: Sum the main terms
    Let sum_real be term1_real plus term2_real plus term3_real
    Let sum_imag be term1_imag plus term2_imag plus term3_imag
    
    Set result["real_part"] to sum_real
    Set result["imaginary_part"] to sum_imag
    
    Return result

Process called "compute_digamma_asymptotic" that takes z as Float, precision as Integer returns Float:
    Note: Compute digamma using asymptotic series for large z
    Note: ψ(z) ≈ ln(z) minus 1/(2z) minus 1/(12z²) plus 1/(120z⁴) minus 1/(252z⁶) plus ...
    
    Let ln_z be NumericalCore.natural_log_high_precision(ToString(z), precision plus 3)
    Let z_inv be 1.0 / z
    Let z_inv_squared be z_inv multiplied by z_inv
    
    Let term1 be Parse ln_z as Float
    Let term2 be -z_inv / 2.0
    Let term3 be -z_inv_squared / 12.0
    Let term4 be z_inv_squared multiplied by z_inv_squared / 120.0
    Let term5 be -z_inv_squared multiplied by z_inv_squared multiplied by z_inv_squared / 252.0
    
    Return term1 plus term2 plus term3 plus term4 plus term5

Process called "compute_cotangent" that takes x_str as String, precision as Integer returns Float:
    Note: Compute cotangent using cot(x) is equal to cos(x)/sin(x)
    Let cos_result be Trigonometry.cosine(x_str, "radians", precision)
    Let sin_result be Trigonometry.sine(x_str, "radians", precision)
    
    If AbsoluteValue(Parse sin_result.function_value as Float) is less than Power(10.0, -(precision minus 3)):
        Throw Errors.InvalidOperation with "Cotangent undefined at multiples of π"
    
    Let cot_result be BigDecimal.divide_high_precision(cos_result.function_value, sin_result.function_value, precision)
    Return Parse cot_result as Float

Process called "compute_csc_squared" that takes x_str as String, precision as Integer returns Float:
    Note: Compute csc²(x) is equal to 1/sin²(x)
    Let sin_result be Trigonometry.sine(x_str, "radians", precision)
    Let sin_value be Parse sin_result.function_value as Float
    
    If AbsoluteValue(sin_value) is less than Power(10.0, -(precision minus 3)):
        Throw Errors.InvalidOperation with "Cosecant undefined at multiples of π"
    
    Return 1.0 / (sin_value multiplied by sin_value)

Process called "get_default_lanczos_coefficients" that returns List[Float]:
    Note: Return default Lanczos coefficients for gamma function approximation
    Note: These coefficients are optimized for g=7 (8 coefficients)
    Return [
        0.99999999999980993,
        676.5203681218851,
        -1259.1392167224028,
        771.32342877765313,
        -176.61502916214059,
        12.507343278686905,
        -0.13857109526572012,
        9.9843695780195716e-6,
        1.5056327351493116e-7
    ]

Process called "compute_incomplete_beta_continued_fraction" that takes x as Float, a as Float, b as Float, config as BetaConfig returns Float:
    Note: Compute incomplete beta using continued fraction expansion
    Let m be 0
    Let c be 1.0
    Let d be 1.0 minus (a plus b) multiplied by x / (a plus 1.0)
    
    If AbsoluteValue(d) is less than 1e-30:
        Set d to 1e-30
    
    Set d to 1.0 / d
    Let h be d
    
    Let tolerance be Power(10.0, -config.precision)
    Let max_iterations be config.continued_fraction_depth
    
    For i from 1 to max_iterations:
        Let m2 be 2 multiplied by i
        Let aa be Float(i) multiplied by (b minus Float(i)) multiplied by x / ((a plus Float(m2) minus 1.0) multiplied by (a plus Float(m2)))
        
        Note: Even step
        Set d to 1.0 plus aa multiplied by d
        If AbsoluteValue(d) is less than 1e-30:
            Set d to 1e-30
        Set c to 1.0 plus aa / c
        If AbsoluteValue(c) is less than 1e-30:
            Set c to 1e-30
        Set d to 1.0 / d
        Let del be d multiplied by c
        Set h to h multiplied by del
        
        If AbsoluteValue(del minus 1.0) is less than tolerance:
            Return h
        
        Note: Odd step
        Set aa to -(a plus Float(i)) multiplied by (a plus b plus Float(i)) multiplied by x / ((a plus Float(m2)) multiplied by (a plus Float(m2) plus 1.0))
        Set d to 1.0 plus aa multiplied by d
        If AbsoluteValue(d) is less than 1e-30:
            Set d to 1e-30
        Set c to 1.0 plus aa / c
        If AbsoluteValue(c) is less than 1e-30:
            Set c to 1e-30
        Set d to 1.0 / d
        Set del to d multiplied by c
        Set h to h multiplied by del
        
        If AbsoluteValue(del minus 1.0) is less than tolerance:
            Return h
    
    Throw Errors.ConvergenceFailure with "Incomplete beta continued fraction did not converge"

Process called "compute_incomplete_gamma_series" that takes s as Float, x as Float, config as GammaConfig returns Float:
    Note: Compute lower incomplete gamma using series expansion γ(s,x) is equal to x^s multiplied by e^(-x) multiplied by Σ(x^n / (s+n)!)
    Let x_power_s be Operations.power(ToString(x), ToString(s), config.precision)
    Let neg_x be NumericalCore.exponential_high_precision(ToString(-x), config.precision)
    
    Let series_sum be 1.0 / s
    Let term be series_sum
    Let n be 1
    Let tolerance be config.convergence_threshold
    
    While AbsoluteValue(term) is greater than tolerance and n is less than config.max_iterations:
        Set term to term multiplied by x / (s plus Float(n))
        Set series_sum to series_sum plus term
        Set n to n plus 1
    
    If n is greater than or equal to config.max_iterations:
        Throw Errors.ConvergenceFailure with "Incomplete gamma series did not converge"
    
    Let result_str be BigDecimal.multiply_high_precision(BigDecimal.multiply_high_precision(x_power_s.result_value, neg_x, config.precision), ToString(series_sum), config.precision)
    Return Parse result_str as Float

Process called "compute_incomplete_gamma_series_normalized" that takes s as Float, x as Float, config as GammaConfig returns Float:
    Note: Compute P(s,x) is equal to γ(s,x)/Γ(s) using normalized series to avoid overflow
    Let log_gamma_s be compute_log_gamma(s, config)
    Let ln_x_times_s be s multiplied by NumericalCore.natural_log_high_precision(ToString(x), config.precision plus 2)
    
    Let series_sum be 1.0 / s
    Let term be series_sum
    Let n be 1
    Let tolerance be config.convergence_threshold
    
    While AbsoluteValue(term) is greater than tolerance and n is less than config.max_iterations:
        Set term to term multiplied by x / (s plus Float(n))
        Set series_sum to series_sum plus term
        Set n to n plus 1
    
    If n is greater than or equal to config.max_iterations:
        Throw Errors.ConvergenceFailure with "Normalized incomplete gamma series did not converge"
    
    Note: Compute in log space to avoid overflow: exp(s*ln(x) minus x minus log(Γ(s))) multiplied by series_sum
    Let log_factor be Parse ln_x_times_s as Float minus x minus log_gamma_s.value
    Let exp_factor be NumericalCore.exponential_high_precision(ToString(log_factor), config.precision)
    
    Let result_str be BigDecimal.multiply_high_precision(exp_factor, ToString(series_sum), config.precision)
    Return Parse result_str as Float

Process called "compute_incomplete_gamma_continued_fraction" that takes s as Float, x as Float, config as GammaConfig returns Float:
    Note: Compute upper incomplete gamma using continued fraction expansion
    Let b be x plus 1.0 minus s
    Let c be 1e30
    Let d be 1.0 / b
    Let h be d
    
    Let tolerance be config.convergence_threshold
    Let max_iterations be config.max_iterations
    
    For i from 1 to max_iterations:
        Let an be -Float(i) multiplied by (Float(i) minus s)
        Set b to b plus 2.0
        Set d to an multiplied by d plus b
        
        If AbsoluteValue(d) is less than 1e-30:
            Set d to 1e-30
        Set c to b plus an / c
        If AbsoluteValue(c) is less than 1e-30:
            Set c to 1e-30
            
        Set d to 1.0 / d
        Let del be d multiplied by c
        Set h to h multiplied by del
        
        If AbsoluteValue(del minus 1.0) is less than tolerance:
            Break
    
    If i is greater than or equal to max_iterations:
        Throw Errors.ConvergenceFailure with "Incomplete gamma continued fraction did not converge"
    
    Note: Apply the prefactor: x^s multiplied by e^(-x) / Γ(s)
    Let log_gamma_s be compute_log_gamma(s, config)
    Let ln_x_times_s be s multiplied by NumericalCore.natural_log_high_precision(ToString(x), config.precision plus 2)
    Let log_factor be Parse ln_x_times_s as Float minus x minus log_gamma_s.value
    Let exp_factor be NumericalCore.exponential_high_precision(ToString(log_factor), config.precision)
    
    Let result_str be BigDecimal.multiply_high_precision(exp_factor, ToString(h), config.precision)
    Return Parse result_str as Float

Process called "compute_incomplete_gamma_continued_fraction_normalized" that takes s as Float, x as Float, config as GammaConfig returns Float:
    Note: Compute Q(s,x) is equal to Γ(s,x)/Γ(s) using continued fraction (already normalized)
    Return compute_incomplete_gamma_continued_fraction(s, x, config)

Process called "create_gamma_config_from_factorial" that takes factorial_config as FactorialConfig returns GammaConfig:
    Note: Create a GammaConfig from a FactorialConfig for Stirling approximations
    Let gamma_config be GammaConfig
    Set gamma_config.precision to 15.0
    Set gamma_config.max_iterations to 100
    Set gamma_config.convergence_threshold to 1e-12
    Set gamma_config.asymptotic_threshold to 10.0
    Set gamma_config.lanczos_coefficients to get_default_lanczos_coefficients()
    Set gamma_config.stirling_corrections to []
    Return gamma_config

Process called "approximate_double_factorial" that takes n as Integer returns Float:
    Note: Approximate double factorial for large n to avoid overflow
    Note: n!! ≈ (n/e)^(n/2) multiplied by sqrt(π*n) for even n, with adjustment for odd n
    If n modulo 2 is equal to 0:
        Note: Even n: use the asymptotic formula
        Let n_half be Float(n) / 2.0
        Let e_val be Constants.get_e(10)
        Let pi_val be Constants.get_pi(10)
        Let factor1 be Power(Float(n) / Parse e_val as Float, n_half)
        Let factor2 be SquareRoot(Parse pi_val as Float multiplied by Float(n))
        Return factor1 multiplied by factor2
    Otherwise:
        Note: Odd n: similar formula with slight modification
        Let n_half be Float(n) / 2.0
        Let e_val be Constants.get_e(10)
        Let factor1 be Power(Float(n) / Parse e_val as Float, n_half)
        Let factor2 be SquareRoot(Float(n))
        Return factor1 multiplied by factor2 multiplied by 1.128

Process called "compute_factorial_ratio_log_space" that takes n as Integer, k as Integer, config as FactorialConfig returns Float:
    Note: Compute n!/k! in log space to avoid overflow, then exponentiate
    Let log_sum be 0.0
    
    For i from k plus 1 to n:
        Let ln_i be NumericalCore.natural_log_high_precision(ToString(i), 15)
        Set log_sum to log_sum plus Parse ln_i as Float
    
    Let result_str be NumericalCore.exponential_high_precision(ToString(log_sum), 15)
    Return Parse result_str as Float

Note: =====================================================================
Note: GAMMA FUNCTION OPERATIONS
Note: =====================================================================

Process called "compute_gamma" that takes z as Float, config as GammaConfig returns GammaResult:
    Note: Compute gamma function Γ(z) using Lanczos approximation, series expansions, and asymptotic methods
    Let result be GammaResult
    Set result.iterations_used to 0
    Set result.convergence_status to "success"
    Set result.derivative_values to []
    
    Note: Handle special cases first
    If z is less than or equal to 0.0 and z is equal to Round(z):
        Throw Errors.InvalidOperation with "Gamma function has poles at non-positive integers"
    
    If z is equal to 1.0:
        Set result.value to 1.0
        Set result.error_estimate to 0.0
        Set result.method_used to "exact_value"
        Return result
    
    If z is equal to 2.0:
        Set result.value to 1.0
        Set result.error_estimate to 0.0
        Set result.method_used to "exact_value"
        Return result
    
    Note: Use reflection formula for negative arguments
    If z is less than 0.0:
        Let pi_str be Constants.get_pi(config.precision plus 5)
        Let neg_z be ToString(-z)
        Let sin_pi_z_result be Trigonometry.sine(BigDecimal.multiply_high_precision(pi_str, neg_z, config.precision plus 3), "radians", config.precision plus 3)
        Let sin_pi_z be sin_pi_z_result.function_value
        
        If AbsoluteValue(Parse sin_pi_z as Float) is less than Power(10.0, -(config.precision minus 5)):
            Throw Errors.InvalidOperation with "Gamma function pole encountered in reflection formula"
        
        Let gamma_one_minus_z be compute_gamma(1.0 minus z, config)
        Let reflection_term be BigDecimal.divide_high_precision(pi_str, BigDecimal.multiply_high_precision(sin_pi_z, gamma_one_minus_z.value.ToString(), config.precision plus 2), config.precision)
        Set result.value to Parse reflection_term as Float
        Set result.error_estimate to gamma_one_minus_z.error_estimate multiplied by 2.0
        Set result.method_used to "reflection_formula"
        Set result.iterations_used to gamma_one_minus_z.iterations_used plus 1
        Return result
    
    Note: For small positive z, use recurrence relation to shift to z is greater than 1
    Let z_shifted be z
    Let shift_product be 1.0
    While z_shifted is less than 1.0:
        Set shift_product to shift_product multiplied by z_shifted
        Set z_shifted to z_shifted plus 1.0
    
    Note: Use Lanczos approximation for the main computation
    Let lanczos_result be compute_lanczos_approximation(z_shifted, config.lanczos_coefficients)
    Let final_result be Parse lanczos_result as Float
    
    Note: Apply the recurrence relation correction
    If shift_product does not equal 1.0:
        Set final_result to final_result / shift_product
    
    Set result.value to final_result
    Set result.error_estimate to Power(10.0, -(config.precision minus 3))
    Set result.method_used to "lanczos_approximation"
    Set result.iterations_used to 1
    
    Return result

Process called "compute_log_gamma" that takes z as Float, config as GammaConfig returns GammaResult:
    Note: Compute logarithm of gamma function log Γ(z) with enhanced numerical stability
    Let result be GammaResult
    Set result.iterations_used to 0
    Set result.convergence_status to "success"
    Set result.derivative_values to []
    
    Note: Handle special cases
    If z is less than or equal to 0.0 and z is equal to Round(z):
        Throw Errors.InvalidOperation with "Log gamma function has poles at non-positive integers"
    
    If z is equal to 1.0 or z is equal to 2.0:
        Set result.value to 0.0
        Set result.error_estimate to 0.0
        Set result.method_used to "exact_value"
        Return result
    
    Note: For large z, use Stirling's approximation
    If z is greater than or equal to config.asymptotic_threshold:
        Let stirling_result be compute_stirling_approximation(z, 10, config)
        Let ln_result be NumericalCore.natural_log_high_precision(ToString(stirling_result), config.precision)
        Set result.value to Parse ln_result as Float
        Set result.error_estimate to Power(10.0, -(config.precision minus 2))
        Set result.method_used to "stirling_log_approximation"
        Set result.iterations_used to 10
        Return result
    
    Note: For negative z, use reflection formula in log space
    If z is less than 0.0:
        Let pi_str be Constants.get_pi(config.precision plus 5)
        Let ln_pi_str be NumericalCore.natural_log_high_precision(pi_str, config.precision plus 3)
        Let neg_z be ToString(-z)
        Let sin_pi_z_result be Trigonometry.sine(BigDecimal.multiply_high_precision(pi_str, neg_z, config.precision plus 3), "radians", config.precision plus 3)
        Let sin_pi_z be sin_pi_z_result.function_value
        Let ln_sin_pi_z be NumericalCore.natural_log_high_precision(sin_pi_z, config.precision plus 2)
        
        Let log_gamma_one_minus_z be compute_log_gamma(1.0 minus z, config)
        Let reflection_term be BigDecimal.subtract_high_precision(BigDecimal.subtract_high_precision(ln_pi_str, ln_sin_pi_z, config.precision plus 1), ToString(log_gamma_one_minus_z.value), config.precision)
        
        Set result.value to Parse reflection_term as Float
        Set result.error_estimate to log_gamma_one_minus_z.error_estimate multiplied by 2.0
        Set result.method_used to "log_reflection_formula"
        Set result.iterations_used to log_gamma_one_minus_z.iterations_used plus 1
        Return result
    
    Note: For small positive z, use recurrence relation in log space
    Let z_shifted be z
    Let log_shift_sum be 0.0
    While z_shifted is less than 1.0:
        Let ln_z_shifted be NumericalCore.natural_log_high_precision(ToString(z_shifted), config.precision plus 3)
        Set log_shift_sum to log_shift_sum plus Parse ln_z_shifted as Float
        Set z_shifted to z_shifted plus 1.0
        Set result.iterations_used to result.iterations_used plus 1
    
    Note: Compute log Gamma using Lanczos in log space
    Let lanczos_result be compute_lanczos_approximation(z_shifted, config.lanczos_coefficients)
    Let ln_lanczos be NumericalCore.natural_log_high_precision(ToString(lanczos_result), config.precision)
    Let final_result be Parse ln_lanczos as Float minus log_shift_sum
    
    Set result.value to final_result
    Set result.error_estimate to Power(10.0, -(config.precision minus 3))
    Set result.method_used to "log_lanczos_approximation"
    
    Return result

Process called "compute_gamma_complex" that takes z_real as Float, z_imag as Float, config as GammaConfig returns Dictionary[String, Float]:
    Note: Compute gamma function for complex argument using analytic continuation
    Let result be Dictionary[String, Float]
    
    Note: Handle pure real case
    If z_imag is equal to 0.0:
        Let real_result be compute_gamma(z_real, config)
        Set result["real_part"] to real_result.value
        Set result["imaginary_part"] to 0.0
        Set result["magnitude"] to AbsoluteValue(real_result.value)
        Set result["argument"] to 0.0
        Return result
    
    Note: For complex arguments, use the log-gamma approach to avoid overflow
    Let log_gamma_result be compute_log_gamma_complex(z_real, z_imag, config)
    
    Note: Convert back from log space: Γ(z) is equal to exp(log Γ(z))
    Let log_real be log_gamma_result["real_part"]
    Let log_imag be log_gamma_result["imaginary_part"]
    
    Note: Calculate exp(log_real plus i*log_imag) is equal to exp(log_real) multiplied by (cos(log_imag) plus i*sin(log_imag))
    Let exp_real be NumericalCore.exponential_high_precision(ToString(log_real), config.precision)
    Let cos_result be Trigonometry.cosine(ToString(log_imag), "radians", config.precision)
    Let sin_result be Trigonometry.sine(ToString(log_imag), "radians", config.precision)
    
    Let final_real be BigDecimal.multiply_high_precision(exp_real, cos_result.function_value, config.precision)
    Let final_imag be BigDecimal.multiply_high_precision(exp_real, sin_result.function_value, config.precision)
    
    Set result["real_part"] to Parse final_real as Float
    Set result["imaginary_part"] to Parse final_imag as Float
    
    Note: Calculate magnitude and argument
    Let magnitude_squared be result["real_part"] multiplied by result["real_part"] plus result["imaginary_part"] multiplied by result["imaginary_part"]
    Set result["magnitude"] to SquareRoot(magnitude_squared)
    
    Let argument be 0.0
    If result["real_part"] does not equal 0.0 or result["imaginary_part"] does not equal 0.0:
        Set argument to ArcTangent2(result["imaginary_part"], result["real_part"])
    Set result["argument"] to argument
    
    Return result

Process called "compute_reciprocal_gamma" that takes z as Float, config as GammaConfig returns Float:
    Note: Compute reciprocal gamma function 1/Γ(z) with enhanced numerical stability near poles
    
    Note: Handle special cases where 1/Γ(z) is equal to 0 (at non-positive integer poles)
    If z is less than or equal to 0.0 and z is equal to Round(z):
        Return 0.0
    
    Note: Handle cases where gamma is very small (near poles)
    Let epsilon be Power(10.0, -(config.precision minus 5))
    
    Note: For small positive z close to poles, use series expansion of 1/Γ(z)
    If z is greater than 0.0 and z is less than epsilon:
        Note: 1/Γ(z) ≈ z plus γz² plus ... where γ is Euler-Mascheroni constant
        Let euler_gamma be Constants.get_euler_gamma(config.precision)
        Let gamma_coeff be Parse euler_gamma as Float
        
        Let series_term1 be z
        Let series_term2 be gamma_coeff multiplied by z multiplied by z
        Let series_term3 be (gamma_coeff multiplied by gamma_coeff minus 1.6449340668) multiplied by z multiplied by z multiplied by z / 2.0
        
        Return series_term1 plus series_term2 plus series_term3
    
    Note: For most cases, compute gamma function and take reciprocal
    Let gamma_result be compute_gamma(z, config)
    
    Note: Check for very large gamma values that would cause underflow in reciprocal
    If AbsoluteValue(gamma_result.value) is greater than Power(10.0, config.precision / 2):
        Note: Use log-gamma approach to avoid overflow
        Let log_gamma_result be compute_log_gamma(z, config)
        Let neg_log_gamma be -log_gamma_result.value
        Let exp_result be NumericalCore.exponential_high_precision(ToString(neg_log_gamma), config.precision)
        Return Parse exp_result as Float
    
    Note: Direct reciprocal for normal cases
    If AbsoluteValue(gamma_result.value) is less than epsilon:
        Note: Gamma is very small, reciprocal will be large
        Let reciprocal_str be BigDecimal.divide_high_precision("1.0", ToString(gamma_result.value), config.precision)
        Return Parse reciprocal_str as Float
    
    Return 1.0 / gamma_result.value

Note: =====================================================================
Note: DIGAMMA AND POLYGAMMA OPERATIONS
Note: =====================================================================

Process called "compute_digamma" that takes z as Float, config as GammaConfig returns Float:
    Note: Compute digamma function ψ(z) is equal to Γ'(z)/Γ(z) using series and asymptotic expansions
    
    Note: Handle special cases where digamma has poles
    If z is less than or equal to 0.0 and z is equal to Round(z):
        Throw Errors.InvalidOperation with "Digamma function has poles at non-positive integers"
    
    Note: Use reflection formula for negative arguments
    If z is less than 0.0:
        Let pi_str be Constants.get_pi(config.precision plus 3)
        Let pi_z_str be BigDecimal.multiply_high_precision(pi_str, ToString(z), config.precision plus 2)
        Let cot_result be compute_cotangent(pi_z_str, config.precision plus 2)
        Let digamma_one_minus_z be compute_digamma(1.0 minus z, config)
        Return digamma_one_minus_z minus Parse pi_str as Float multiplied by cot_result
    
    Note: For small z, use recurrence relation ψ(z+1) is equal to ψ(z) plus 1/z
    Let z_shifted be z
    Let recurrence_sum be 0.0
    Let shift_count be 0
    
    While z_shifted is less than config.asymptotic_threshold:
        Set recurrence_sum to recurrence_sum plus 1.0 / z_shifted
        Set z_shifted to z_shifted plus 1.0
        Set shift_count to shift_count plus 1
    
    Note: Use asymptotic series for large arguments
    Let asymptotic_result be compute_digamma_asymptotic(z_shifted, config.precision)
    
    Note: Apply recurrence relation correction
    Let final_result be asymptotic_result minus recurrence_sum
    
    Return final_result

Process called "compute_polygamma" that takes n as Integer, z as Float, config as GammaConfig returns Float:
    Note: Compute polygamma function ψ^(n)(z) minus nth derivative of digamma function
    
    If n is less than 0:
        Throw Errors.InvalidOperation with "Polygamma order must be non-negative"
    
    If n is equal to 0:
        Return compute_digamma(z, config)
    
    If n is equal to 1:
        Return compute_trigamma(z, config)
    
    If n is equal to 2:
        Return compute_tetragamma(z, config)
    
    Note: Handle poles at non-positive integers
    If z is less than or equal to 0.0 and z is equal to Round(z):
        Throw Errors.InvalidOperation with "Polygamma function has poles at non-positive integers"
    
    Note: For general n is greater than 2, use the series representation
    Note: ψ^(n)(z) is equal to (-1)^(n+1) multiplied by n! multiplied by Σ(k=0 to ∞) 1/(z+k)^(n+1)
    
    Let sign be Power(-1.0, n plus 1)
    Let factorial_n be Combinatorics.compute_factorial(n)
    Let factorial_value be Parse factorial_n["value"].ToString() as Float
    
    Let series_sum be 0.0
    Let k be 0
    Let term be 1.0
    Let tolerance be Power(10.0, -(config.precision minus 2))
    Let max_iterations be config.max_iterations
    
    While k is less than max_iterations and AbsoluteValue(term) is greater than tolerance:
        Let denominator be Power(z plus Float(k), n plus 1)
        Set term to 1.0 / denominator
        Set series_sum to series_sum plus term
        Set k to k plus 1
    
    If k is greater than or equal to max_iterations:
        Throw Errors.ConvergenceFailure with "Polygamma series did not converge within maximum iterations"
    
    Return sign multiplied by factorial_value multiplied by series_sum

Process called "compute_trigamma" that takes z as Float, config as GammaConfig returns Float:
    Note: Compute trigamma function ψ'(z) minus derivative of digamma function
    
    Note: Handle poles at non-positive integers
    If z is less than or equal to 0.0 and z is equal to Round(z):
        Throw Errors.InvalidOperation with "Trigamma function has poles at non-positive integers"
    
    Note: Use reflection formula for negative arguments
    If z is less than 0.0:
        Let pi_str be Constants.get_pi(config.precision plus 3)
        Let pi_squared be BigDecimal.multiply_high_precision(pi_str, pi_str, config.precision plus 2)
        Let pi_z_str be BigDecimal.multiply_high_precision(pi_str, ToString(z), config.precision plus 2)
        Let csc_squared_result be compute_csc_squared(pi_z_str, config.precision plus 2)
        Let trigamma_one_minus_z be compute_trigamma(1.0 minus z, config)
        Return trigamma_one_minus_z plus Parse pi_squared as Float multiplied by csc_squared_result
    
    Note: For small z, use recurrence relation ψ'(z+1) is equal to ψ'(z) minus 1/z²
    Let z_shifted be z
    Let recurrence_sum be 0.0
    
    While z_shifted is less than config.asymptotic_threshold:
        Set recurrence_sum to recurrence_sum plus 1.0 / (z_shifted multiplied by z_shifted)
        Set z_shifted to z_shifted plus 1.0
    
    Note: Use asymptotic series for large arguments
    Note: ψ'(z) ≈ 1/z plus 1/(2z²) plus 1/(6z³) minus 1/(30z⁵) plus ...
    
    Let z_inv be 1.0 / z_shifted
    Let z_inv_squared be z_inv multiplied by z_inv
    
    Let term1 be z_inv
    Let term2 be z_inv_squared / 2.0
    Let term3 be z_inv multiplied by z_inv_squared / 6.0
    Let term4 be -z_inv multiplied by z_inv_squared multiplied by z_inv_squared / 30.0
    Let term5 be z_inv multiplied by z_inv_squared multiplied by z_inv_squared multiplied by z_inv / 42.0
    
    Let asymptotic_result be term1 plus term2 plus term3 plus term4 plus term5
    
    Note: Apply recurrence relation correction
    Let final_result be asymptotic_result minus recurrence_sum
    
    Return final_result

Process called "compute_tetragamma" that takes z as Float, config as GammaConfig returns Float:
    Note: Compute tetragamma function ψ''(z) minus second derivative of digamma function
    
    Note: Handle poles at non-positive integers
    If z is less than or equal to 0.0 and z is equal to Round(z):
        Throw Errors.InvalidOperation with "Tetragamma function has poles at non-positive integers"
    
    Note: Use reflection formula for negative arguments
    If z is less than 0.0:
        Let pi_str be Constants.get_pi(config.precision plus 3)
        Let pi_cubed be BigDecimal.multiply_high_precision(BigDecimal.multiply_high_precision(pi_str, pi_str, config.precision plus 3), pi_str, config.precision plus 2)
        Let pi_z_str be BigDecimal.multiply_high_precision(pi_str, ToString(z), config.precision plus 2)
        Let cot_result be compute_cotangent(pi_z_str, config.precision plus 2)
        Let csc_squared_result be compute_csc_squared(pi_z_str, config.precision plus 2)
        Let tetragamma_one_minus_z be compute_tetragamma(1.0 minus z, config)
        
        Let reflection_term be -2.0 multiplied by Parse pi_cubed as Float multiplied by cot_result multiplied by csc_squared_result
        Return tetragamma_one_minus_z plus reflection_term
    
    Note: For small z, use recurrence relation ψ''(z+1) is equal to ψ''(z) plus 2/z³
    Let z_shifted be z
    Let recurrence_sum be 0.0
    
    While z_shifted is less than config.asymptotic_threshold:
        Let z_cubed be z_shifted multiplied by z_shifted multiplied by z_shifted
        Set recurrence_sum to recurrence_sum plus 2.0 / z_cubed
        Set z_shifted to z_shifted plus 1.0
    
    Note: Use asymptotic series for large arguments
    Note: ψ''(z) ≈ -1/z² minus 1/z³ minus 1/(2z⁴) plus 1/(6z⁶) minus ...
    
    Let z_inv be 1.0 / z_shifted
    Let z_inv_squared be z_inv multiplied by z_inv
    Let z_inv_cubed be z_inv_squared multiplied by z_inv
    
    Let term1 be -z_inv_squared
    Let term2 be -z_inv_cubed
    Let term3 be -z_inv_squared multiplied by z_inv_squared / 2.0
    Let term4 be z_inv_squared multiplied by z_inv_squared multiplied by z_inv_squared / 6.0
    Let term5 be -z_inv_squared multiplied by z_inv_squared multiplied by z_inv_cubed / 30.0
    
    Let asymptotic_result be term1 plus term2 plus term3 plus term4 plus term5
    
    Note: Apply recurrence relation correction
    Let final_result be asymptotic_result minus recurrence_sum
    
    Return final_result

Note: =====================================================================
Note: BETA FUNCTION OPERATIONS
Note: =====================================================================

Process called "compute_beta" that takes x as Float, y as Float, config as BetaConfig returns Float:
    Note: Compute beta function B(x,y) is equal to Γ(x)Γ(y)/Γ(x+y) with numerical optimization
    
    Note: Handle domain restrictions
    If x is less than or equal to 0.0 or y is less than or equal to 0.0:
        Throw Errors.InvalidOperation with "Beta function requires positive arguments"
    
    Note: Handle special cases
    If x is equal to 1.0 and y is equal to 1.0:
        Return 1.0
    
    Note: Use symmetry property B(x,y) is equal to B(y,x) to optimize computation
    Let arg1 be x
    Let arg2 be y
    If config.symmetry_optimization and y is less than x:
        Set arg1 to y
        Set arg2 to x
    
    Note: For large arguments, use log-space computation to avoid overflow
    If arg1 is greater than 50.0 or arg2 is greater than 50.0:
        Let log_beta_result be compute_log_beta(arg1, arg2, config)
        Let exp_result be NumericalCore.exponential_high_precision(ToString(log_beta_result), Parse config.precision as Integer)
        Return Parse exp_result as Float
    
    Note: Use gamma function relation B(x,y) is equal to Γ(x)Γ(y)/Γ(x+y)
    Let gamma_config be GammaConfig
    Set gamma_config.precision to config.precision
    Set gamma_config.max_iterations to 100
    Set gamma_config.convergence_threshold to Power(10.0, -config.precision)
    Set gamma_config.asymptotic_threshold to 10.0
    Set gamma_config.lanczos_coefficients to get_default_lanczos_coefficients()
    
    Let gamma_x be compute_gamma(arg1, gamma_config)
    Let gamma_y be compute_gamma(arg2, gamma_config)
    Let gamma_x_plus_y be compute_gamma(arg1 plus arg2, gamma_config)
    
    Let numerator be gamma_x.value multiplied by gamma_y.value
    Let denominator be gamma_x_plus_y.value
    
    If AbsoluteValue(denominator) is less than Power(10.0, -50):
        Throw Errors.InvalidOperation with "Beta function computation resulted in division by zero"
    
    Return numerator / denominator

Process called "compute_log_beta" that takes x as Float, y as Float, config as BetaConfig returns Float:
    Note: Compute logarithm of beta function log B(x,y) with enhanced numerical stability
    
    Note: Handle domain restrictions
    If x is less than or equal to 0.0 or y is less than or equal to 0.0:
        Throw Errors.InvalidOperation with "Log beta function requires positive arguments"
    
    Note: Use log-space computation: log B(x,y) is equal to log Γ(x) plus log Γ(y) minus log Γ(x+y)
    Let gamma_config be GammaConfig
    Set gamma_config.precision to config.precision
    Set gamma_config.max_iterations to 100
    Set gamma_config.convergence_threshold to Power(10.0, -config.precision)
    Set gamma_config.asymptotic_threshold to 10.0
    Set gamma_config.lanczos_coefficients to get_default_lanczos_coefficients()
    
    Let log_gamma_x be compute_log_gamma(x, gamma_config)
    Let log_gamma_y be compute_log_gamma(y, gamma_config)
    Let log_gamma_x_plus_y be compute_log_gamma(x plus y, gamma_config)
    
    Let result be log_gamma_x.value plus log_gamma_y.value minus log_gamma_x_plus_y.value
    
    Return result

Process called "compute_incomplete_beta" that takes x as Float, a as Float, b as Float, config as BetaConfig returns Float:
    Note: Compute incomplete beta function I_x(a,b) using continued fractions and series
    
    Note: Validate input parameters
    If x is less than 0.0 or x is greater than 1.0:
        Throw Errors.InvalidOperation with "Incomplete beta function requires 0 ≤ x ≤ 1"
    If a is less than or equal to 0.0 or b is less than or equal to 0.0:
        Throw Errors.InvalidOperation with "Incomplete beta function requires positive shape parameters"
    
    Note: Handle boundary cases
    If x is equal to 0.0:
        Return 0.0
    If x is equal to 1.0:
        Return 1.0
    
    Note: Use symmetry relation when x is greater than 0.5 to improve convergence
    If x is greater than 0.5:
        Let symmetric_result be compute_incomplete_beta(1.0 minus x, b, a, config)
        Return 1.0 minus symmetric_result
    
    Note: Compute using continued fraction expansion
    Let continued_fraction_result be compute_incomplete_beta_continued_fraction(x, a, b, config)
    
    Note: Apply the beta function normalization factor
    Let x_power_a be Operations.power(ToString(x), ToString(a), Parse config.precision as Integer)
    Let one_minus_x_power_b be Operations.power(ToString(1.0 minus x), ToString(b), Parse config.precision as Integer)
    
    Let beta_ab be compute_beta(a, b, config)
    
    Let numerator be Parse x_power_a.result_value as Float multiplied by Parse one_minus_x_power_b.result_value as Float multiplied by continued_fraction_result
    Let result be numerator / (a multiplied by beta_ab)
    
    Return result

Process called "compute_regularized_beta" that takes x as Float, a as Float, b as Float, config as BetaConfig returns Float:
    Note: Compute regularized incomplete beta function B_x(a,b)/B(a,b)
    
    Note: Validate input parameters  
    If x is less than 0.0 or x is greater than 1.0:
        Throw Errors.InvalidOperation with "Regularized beta function requires 0 ≤ x ≤ 1"
    If a is less than or equal to 0.0 or b is less than or equal to 0.0:
        Throw Errors.InvalidOperation with "Regularized beta function requires positive shape parameters"
    
    Note: Handle boundary cases
    If x is equal to 0.0:
        Return 0.0
    If x is equal to 1.0:
        Return 1.0
    
    Note: The regularized incomplete beta function is I_x(a,b) is equal to B_x(a,b)/B(a,b)
    Note: This is the same as the incomplete beta, but properly normalized
    
    Note: Use symmetry relation when x is greater than 0.5 for better numerical stability  
    If x is greater than 0.5:
        Let symmetric_result be compute_regularized_beta(1.0 minus x, b, a, config)
        Return 1.0 minus symmetric_result
    
    Note: Use continued fraction approach for better numerical stability
    Let continued_fraction_result be compute_incomplete_beta_continued_fraction(x, a, b, config)
    
    Note: Apply proper normalization
    Let x_power_a be Operations.power(ToString(x), ToString(a), Parse config.precision as Integer)
    Let one_minus_x_power_b be Operations.power(ToString(1.0 minus x), ToString(b), Parse config.precision as Integer)
    
    Let log_beta_ab be compute_log_beta(a, b, config)
    Let exp_log_beta be NumericalCore.exponential_high_precision(ToString(log_beta_ab), Parse config.precision as Integer)
    
    Let numerator be Parse x_power_a.result_value as Float multiplied by Parse one_minus_x_power_b.result_value as Float multiplied by continued_fraction_result
    Let result be numerator / (a multiplied by Parse exp_log_beta as Float)
    
    Return result

Note: =====================================================================
Note: INCOMPLETE GAMMA OPERATIONS
Note: =====================================================================

Process called "compute_incomplete_gamma_lower" that takes s as Float, x as Float, config as GammaConfig returns Float:
    Note: Compute lower incomplete gamma function γ(s,x) using series and continued fractions
    
    Note: Handle domain restrictions
    If s is less than or equal to 0.0:
        Throw Errors.InvalidOperation with "Lower incomplete gamma requires positive s parameter"
    If x is less than 0.0:
        Throw Errors.InvalidOperation with "Lower incomplete gamma requires non-negative x parameter"
    
    Note: Handle special cases
    If x is equal to 0.0:
        Return 0.0
    
    Note: For small x relative to s, use series expansion
    If x is less than s plus 1.0:
        Let series_result be compute_incomplete_gamma_series(s, x, config)
        Return series_result
    
    Note: For larger x, use the complement: γ(s,x) is equal to Γ(s) minus Γ(s,x)
    Let gamma_s be compute_gamma(s, config)
    Let upper_incomplete be compute_incomplete_gamma_upper(s, x, config)
    
    Return gamma_s.value minus upper_incomplete

Process called "compute_incomplete_gamma_upper" that takes s as Float, x as Float, config as GammaConfig returns Float:
    Note: Compute upper incomplete gamma function Γ(s,x) using asymptotic expansions
    
    Note: Handle domain restrictions
    If s is less than or equal to 0.0:
        Throw Errors.InvalidOperation with "Upper incomplete gamma requires positive s parameter"
    If x is less than 0.0:
        Throw Errors.InvalidOperation with "Upper incomplete gamma requires non-negative x parameter"
    
    Note: Handle special cases
    If x is equal to 0.0:
        Let gamma_s be compute_gamma(s, config)
        Return gamma_s.value
    
    Note: For large x relative to s, use continued fraction expansion
    If x is greater than or equal to s plus 1.0:
        Let continued_fraction_result be compute_incomplete_gamma_continued_fraction(s, x, config)
        Return continued_fraction_result
    
    Note: For small x, use the complement: Γ(s,x) is equal to Γ(s) minus γ(s,x)
    Let gamma_s be compute_gamma(s, config)
    Let lower_incomplete be compute_incomplete_gamma_series(s, x, config)
    
    Return gamma_s.value minus lower_incomplete

Process called "compute_regularized_gamma_lower" that takes s as Float, x as Float, config as GammaConfig returns Float:
    Note: Compute regularized lower incomplete gamma function P(s,x) is equal to γ(s,x)/Γ(s)
    
    Note: Handle domain restrictions
    If s is less than or equal to 0.0:
        Throw Errors.InvalidOperation with "Regularized lower gamma requires positive s parameter"
    If x is less than 0.0:
        Throw Errors.InvalidOperation with "Regularized lower gamma requires non-negative x parameter"
    
    Note: Handle special cases
    If x is equal to 0.0:
        Return 0.0
    
    Note: For numerical stability, compute directly using series for small x
    If x is less than s plus 1.0:
        Let series_result be compute_incomplete_gamma_series_normalized(s, x, config)
        Return series_result
    
    Note: For larger x, use complement: P(s,x) is equal to 1 minus Q(s,x)
    Let regularized_upper be compute_regularized_gamma_upper(s, x, config)
    Return 1.0 minus regularized_upper

Process called "compute_regularized_gamma_upper" that takes s as Float, x as Float, config as GammaConfig returns Float:
    Note: Compute regularized upper incomplete gamma function Q(s,x) is equal to Γ(s,x)/Γ(s)
    
    Note: Handle domain restrictions
    If s is less than or equal to 0.0:
        Throw Errors.InvalidOperation with "Regularized upper gamma requires positive s parameter"
    If x is less than 0.0:
        Throw Errors.InvalidOperation with "Regularized upper gamma requires non-negative x parameter"
    
    Note: Handle special cases
    If x is equal to 0.0:
        Return 1.0
    
    Note: For large x relative to s, use continued fraction directly
    If x is greater than or equal to s plus 1.0:
        Let continued_fraction_result be compute_incomplete_gamma_continued_fraction_normalized(s, x, config)
        Return continued_fraction_result
    
    Note: For small x, use complement: Q(s,x) is equal to 1 minus P(s,x)
    Let regularized_lower be compute_incomplete_gamma_series_normalized(s, x, config)
    Return 1.0 minus regularized_lower

Note: =====================================================================
Note: FACTORIAL OPERATIONS
Note: =====================================================================

Process called "compute_factorial" that takes n as Integer, config as FactorialConfig returns Integer:
    Note: Compute factorial n! with overflow detection and extended precision support
    
    If n is less than 0:
        Throw Errors.InvalidOperation with "Factorial is undefined for negative integers"
    
    If n is equal to 0 or n is equal to 1:
        Return 1
    
    Note: For large n, check if we should use Stirling's approximation
    If n is greater than or equal to config.stirling_approximation_threshold:
        Let stirling_result be compute_stirling_approximation(Float(n), 5, create_gamma_config_from_factorial(config))
        Return Round(stirling_result)
    
    Note: Use the existing combinatorics factorial implementation
    Let factorial_result be Combinatorics.compute_factorial(n)
    
    Note: Check for overflow if not using extended precision
    If not config.extended_precision:
        Let max_safe_int be Constants.get_max_safe_integer("int64")
        If factorial_result["overflow_detected"]:
            If config.overflow_handling is equal to "error":
                Throw Errors.Overflow with "Factorial result exceeds maximum integer size"
            If config.overflow_handling is equal to "approximate":
                Let stirling_result be compute_stirling_approximation(Float(n), 3, create_gamma_config_from_factorial(config))
                Return Round(stirling_result)
    
    Return factorial_result["value"]

Process called "compute_double_factorial" that takes n as Integer, config as FactorialConfig returns Integer:
    Note: Compute double factorial n!! with efficient algorithms and overflow handling
    
    If n is less than -1:
        Throw Errors.InvalidOperation with "Double factorial is undefined for integers less than -1"
    
    Note: Handle special cases
    If n is equal to -1 or n is equal to 0:
        Return 1
    
    If n is equal to 1 or n is equal to 2:
        Return n
    
    Note: Compute n!! is equal to n multiplied by (n-2) multiplied by (n-4) multiplied by ... multiplied by (2 or 1)
    Let result be 1
    Let current be n
    
    While current is greater than 0:
        Set result to result multiplied by current
        Set current to current minus 2
        
        Note: Check for overflow
        If not config.extended_precision:
            Let max_safe_int be Constants.get_max_safe_integer("int64")
            If result is greater than Parse max_safe_int.value as Integer:
                If config.overflow_handling is equal to "error":
                    Throw Errors.Overflow with "Double factorial result exceeds maximum integer size"
                If config.overflow_handling is equal to "approximate":
                    Note: Use Stirling-like approximation for double factorial
                    Let approx_result be approximate_double_factorial(n)
                    Return Round(approx_result)
    
    Return result

Process called "compute_subfactorial" that takes n as Integer, config as FactorialConfig returns Integer:
    Note: Compute subfactorial !n (derangements) using inclusion-exclusion principle
    
    If n is less than 0:
        Throw Errors.InvalidOperation with "Subfactorial is undefined for negative integers"
    
    Note: Handle small cases directly
    If n is equal to 0:
        Return 1
    If n is equal to 1:
        Return 0
    If n is equal to 2:
        Return 1
    If n is equal to 3:
        Return 2
    If n is equal to 4:
        Return 9
    
    Note: Use the recurrence relation: !n is equal to (n-1) multiplied by (!(n-1) plus !(n-2))
    Let subfact_prev_prev be 1  Note: !0
    Let subfact_prev be 0       Note: !1
    Let current_subfact be 0
    
    For i from 2 to n:
        Set current_subfact to (i minus 1) multiplied by (subfact_prev plus subfact_prev_prev)
        Set subfact_prev_prev to subfact_prev
        Set subfact_prev to current_subfact
        
        Note: Check for overflow
        If not config.extended_precision:
            Let max_safe_int be Constants.get_max_safe_integer("int64")
            If current_subfact is greater than Parse max_safe_int.value as Integer:
                If config.overflow_handling is equal to "error":
                    Throw Errors.Overflow with "Subfactorial result exceeds maximum integer size"
                If config.overflow_handling is equal to "approximate":
                    Note: Use approximation !n ≈ n!/e (rounded to nearest integer)
                    Let factorial_n be compute_factorial(n, config)
                    Let e_value be Constants.get_e(10)
                    Return Round(Float(factorial_n) / Parse e_value as Float)
    
    Return current_subfact

Process called "compute_factorial_ratio" that takes n as Integer, k as Integer, config as FactorialConfig returns Float:
    Note: Compute factorial ratio n!/k! with numerical optimization avoiding overflow
    
    If n is less than 0 or k is less than 0:
        Throw Errors.InvalidOperation with "Factorial ratio requires non-negative integers"
    
    Note: Handle simple cases
    If n is equal to k:
        Return 1.0
    
    If k is equal to 0:
        Let factorial_n be compute_factorial(n, config)
        Return Float(factorial_n)
    
    If n is less than k:
        Note: n!/k! is equal to 1/((k!)/(n!)), so compute k!/n! and take reciprocal
        Let reciprocal_ratio be compute_factorial_ratio(k, n, config)
        Return 1.0 / reciprocal_ratio
    
    Note: For n is greater than k, use telescoping product: n!/k! is equal to (k+1) multiplied by (k+2) multiplied by ... multiplied by n
    Let result be 1.0
    
    For i from k plus 1 to n:
        Set result to result multiplied by Float(i)
        
        Note: Check for potential overflow in intermediate calculations
        If not config.extended_precision:
            Let overflow_threshold be Constants.get_overflow_threshold("float64")
            If result is greater than Parse overflow_threshold.value as Float:
                Note: Switch to log-space computation to avoid overflow
                Return compute_factorial_ratio_log_space(n, k, config)
    
    Return result

Note: =====================================================================
Note: POCHHAMMER SYMBOL OPERATIONS
Note: =====================================================================

Process called "compute_pochhammer" that takes x as Float, n as Integer, config as GammaConfig returns Float:
    Note: Compute Pochhammer symbol (x)_n is equal to Γ(x+n)/Γ(x) minus rising factorial
    
    If n is equal to 0:
        Return 1.0
    
    If n is less than 0:
        Note: Use relation (x)_n is equal to 1/((x-n)_{-n}) for negative n
        Let positive_result be compute_pochhammer(x plus Float(n), -n, config)
        Return 1.0 / positive_result
    
    Note: For positive n, use direct product or gamma ratio based on size
    If n is less than or equal to 20:
        Note: Direct computation for small n
        Let result be 1.0
        For i from 0 to n minus 1:
            Set result to result multiplied by (x plus Float(i))
        Return result
    
    Note: For large n, use gamma function ratio to avoid overflow
    Let gamma_x_plus_n be compute_gamma(x plus Float(n), config)
    Let gamma_x be compute_gamma(x, config)
    Return gamma_x_plus_n.value / gamma_x.value

Process called "compute_rising_factorial" that takes x as Float, n as Integer, config as FactorialConfig returns Float:
    Note: Compute rising factorial x^(n) is equal to x(x+1)...(x+n-1) with numerical stability
    
    If n is equal to 0:
        Return 1.0
    
    If n is less than 0:
        Throw Errors.InvalidOperation with "Rising factorial requires non-negative n"
    
    Note: Direct computation for reasonable n
    If n is less than or equal to 50:
        Let result be 1.0
        For i from 0 to n minus 1:
            Set result to result multiplied by (x plus Float(i))
        Return result
    
    Note: For large n, use log-space computation
    Let log_sum be 0.0
    For i from 0 to n minus 1:
        Let ln_term be NumericalCore.natural_log_high_precision(ToString(x plus Float(i)), 15)
        Set log_sum to log_sum plus Parse ln_term as Float
    
    Let result_str be NumericalCore.exponential_high_precision(ToString(log_sum), 15)
    Return Parse result_str as Float

Process called "compute_falling_factorial" that takes x as Float, n as Integer, config as FactorialConfig returns Float:
    Note: Compute falling factorial x_(n) is equal to x(x-1)...(x-n+1) with overflow protection
    
    If n is equal to 0:
        Return 1.0
    
    If n is less than 0:
        Throw Errors.InvalidOperation with "Falling factorial requires non-negative n"
    
    Note: Direct computation for reasonable n
    If n is less than or equal to 50:
        Let result be 1.0
        For i from 0 to n minus 1:
            Set result to result multiplied by (x minus Float(i))
        Return result
    
    Note: For large n, use log-space computation
    Let log_sum be 0.0
    For i from 0 to n minus 1:
        Let term_value be x minus Float(i)
        If term_value is less than or equal to 0.0:
            Return 0.0  Note: Factorial becomes zero
        Let ln_term be NumericalCore.natural_log_high_precision(ToString(term_value), 15)
        Set log_sum to log_sum plus Parse ln_term as Float
    
    Let result_str be NumericalCore.exponential_high_precision(ToString(log_sum), 15)
    Return Parse result_str as Float

Process called "compute_pochhammer_ratio" that takes x as Float, m as Integer, n as Integer, config as GammaConfig returns Float:
    Note: Compute Pochhammer ratio (x)_m/(x)_n with enhanced numerical accuracy
    
    If m is equal to n:
        Return 1.0
    
    If n is equal to 0:
        Return compute_pochhammer(x, m, config)
    
    If m is equal to 0:
        Let pochhammer_n be compute_pochhammer(x, n, config)
        Return 1.0 / pochhammer_n
    
    Note: Use gamma function ratio for better numerical stability
    Note: (x)_m/(x)_n is equal to [Γ(x+m)/Γ(x)] / [Γ(x+n)/Γ(x)] is equal to Γ(x+m)/Γ(x+n)
    Let gamma_x_plus_m be compute_gamma(x plus Float(m), config)
    Let gamma_x_plus_n be compute_gamma(x plus Float(n), config)
    Return gamma_x_plus_m.value / gamma_x_plus_n.value

Note: =====================================================================
Note: GAMMA DISTRIBUTION OPERATIONS
Note: =====================================================================

Process called "compute_gamma_distribution_pdf" that takes x as Float, shape as Float, scale as Float returns Float:
    Note: Compute gamma distribution probability density function with shape and scale parameters
    
    If x is less than 0.0 or shape is less than or equal to 0.0 or scale is less than or equal to 0.0:
        Return 0.0
    
    If x is equal to 0.0:
        If shape is less than 1.0:
            Return Float.PositiveInfinity
        If shape is equal to 1.0:
            Return 1.0 / scale
        Return 0.0
    
    Note: PDF is equal to (1/(Γ(k)*θ^k)) multiplied by x^(k-1) multiplied by e^(-x/θ) where k=shape, θ=scale
    Let gamma_config be GammaConfig
    Set gamma_config.precision to 15.0
    Set gamma_config.max_iterations to 100
    Set gamma_config.convergence_threshold to 1e-12
    Set gamma_config.asymptotic_threshold to 10.0
    Set gamma_config.lanczos_coefficients to get_default_lanczos_coefficients()
    
    Let gamma_shape be compute_gamma(shape, gamma_config)
    Let scale_power_shape be Operations.power(ToString(scale), ToString(shape), 15)
    Let x_power_shape_minus_1 be Operations.power(ToString(x), ToString(shape minus 1.0), 15)
    Let neg_x_over_scale be NumericalCore.exponential_high_precision(ToString(-x / scale), 15)
    
    Let numerator be BigDecimal.multiply_high_precision(x_power_shape_minus_1.result_value, neg_x_over_scale, 15)
    Let denominator be BigDecimal.multiply_high_precision(ToString(gamma_shape.value), scale_power_shape.result_value, 15)
    
    Let result_str be BigDecimal.divide_high_precision(numerator, denominator, 15)
    Return Parse result_str as Float

Process called "compute_gamma_distribution_cdf" that takes x as Float, shape as Float, scale as Float, config as GammaConfig returns Float:
    Note: Compute gamma distribution cumulative distribution function using incomplete gamma
    
    If x is less than 0.0:
        Return 0.0
    
    If shape is less than or equal to 0.0 or scale is less than or equal to 0.0:
        Throw Errors.InvalidOperation with "Gamma distribution requires positive shape and scale parameters"
    
    If x is equal to 0.0:
        Return 0.0
    
    Note: CDF is equal to P(shape, x/scale) where P is the regularized lower incomplete gamma function
    Let normalized_x be x / scale
    Let regularized_result be compute_regularized_gamma_lower(shape, normalized_x, config)
    
    Return regularized_result

Process called "compute_gamma_distribution_quantile" that takes p as Float, shape as Float, scale as Float, config as GammaConfig returns Float:
    Note: Compute gamma distribution quantile function (inverse CDF) using root finding
    
    If p is less than 0.0 or p is greater than 1.0:
        Throw Errors.InvalidOperation with "Quantile probability must be between 0 and 1"
    
    If shape is less than or equal to 0.0 or scale is less than or equal to 0.0:
        Throw Errors.InvalidOperation with "Gamma distribution requires positive shape and scale parameters"
    
    If p is equal to 0.0:
        Return 0.0
    
    If p is equal to 1.0:
        Return Float.PositiveInfinity
    
    Note: Use Newton-Raphson method to find x such that CDF(x) is equal to p
    Let x_guess be shape multiplied by scale  Note: Use mean as initial guess
    Let tolerance be config.convergence_threshold
    Let max_iterations be config.max_iterations
    
    For i from 1 to max_iterations:
        Let cdf_value be compute_gamma_distribution_cdf(x_guess, shape, scale, config)
        Let pdf_value be compute_gamma_distribution_pdf(x_guess, shape, scale)
        
        If AbsoluteValue(cdf_value minus p) is less than tolerance:
            Return x_guess
        
        If pdf_value is greater than 1e-15:  Note: Avoid division by very small numbers
            Let newton_step be (cdf_value minus p) / pdf_value
            Set x_guess to x_guess minus newton_step
            
            Note: Ensure x_guess stays positive
            If x_guess is less than 0.0:
                Set x_guess to x_guess / 2.0 plus tolerance
        Otherwise:
            Note: Use bisection method fallback
            Set x_guess to x_guess multiplied by 1.1
    
    Note: If Newton-Raphson fails, use bracket method
    Let lower_bound be 0.0
    Let upper_bound be shape multiplied by scale multiplied by 10.0  Note: Conservative upper bound
    
    Note: Ensure upper bound gives CDF is greater than p
    While compute_gamma_distribution_cdf(upper_bound, shape, scale, config) is less than p and upper_bound is less than 1e10:
        Set upper_bound to upper_bound multiplied by 2.0
    
    Note: Bisection method
    For i from 1 to max_iterations:
        Let mid_point be (lower_bound plus upper_bound) / 2.0
        Let mid_cdf be compute_gamma_distribution_cdf(mid_point, shape, scale, config)
        
        If AbsoluteValue(mid_cdf minus p) is less than tolerance:
            Return mid_point
        
        If mid_cdf is less than p:
            Set lower_bound to mid_point
        Otherwise:
            Set upper_bound to mid_point
    
    Return (lower_bound plus upper_bound) / 2.0

Process called "compute_gamma_distribution_moments" that takes shape as Float, scale as Float returns Dictionary[String, Float]:
    Note: Compute gamma distribution statistical moments (mean, variance, skewness, kurtosis)
    
    If shape is less than or equal to 0.0 or scale is less than or equal to 0.0:
        Throw Errors.InvalidOperation with "Gamma distribution requires positive shape and scale parameters"
    
    Let moments be Dictionary[String, Float]
    
    Note: Mean is equal to shape multiplied by scale
    Set moments["mean"] to shape multiplied by scale
    
    Note: Variance is equal to shape multiplied by scale²
    Set moments["variance"] to shape multiplied by scale multiplied by scale
    
    Note: Standard deviation is equal to sqrt(variance)
    Set moments["standard_deviation"] to SquareRoot(moments["variance"])
    
    Note: Skewness is equal to 2 / sqrt(shape)
    Set moments["skewness"] to 2.0 / SquareRoot(shape)
    
    Note: Kurtosis is equal to 6 / shape
    Set moments["kurtosis"] to 6.0 / shape
    
    Note: Excess kurtosis is equal to kurtosis minus 3
    Set moments["excess_kurtosis"] to moments["kurtosis"] minus 3.0
    
    Note: Mode is equal to (shape minus 1) multiplied by scale for shape is greater than 1, undefined otherwise
    If shape is greater than 1.0:
        Set moments["mode"] to (shape minus 1.0) multiplied by scale
    Otherwise:
        Set moments["mode"] to 0.0  Note: Mode is 0 for shape is less than or equal to 1
    
    Note: Median (approximate using Wilson-Hilferty transformation)
    Let median_approx be shape multiplied by scale multiplied by Power(1.0 minus 1.0/(9.0*shape), 3.0)
    Set moments["median_approximate"] to median_approx
    
    Return moments

Note: =====================================================================
Note: SPECIAL CASES AND IDENTITIES
Note: =====================================================================

Process called "compute_half_integer_gamma" that takes n as Integer, config as GammaConfig returns Float:
    Note: Compute gamma function at half-integers Γ(n+1/2) using closed-form expressions
    
    Note: Γ(n+1/2) is equal to (2n-1)!!*sqrt(π)/2^n for n ≥ 1
    Note: Γ(1/2) is equal to sqrt(π)
    
    Let sqrt_pi be Constants.get_stirling_approximation_constant(config.precision)
    
    If n is equal to 0:
        Note: Γ(1/2) is equal to sqrt(π)
        Return Parse sqrt_pi as Float
    
    If n is less than 0:
        Note: Use reflection formula for negative half-integers
        Let positive_result be compute_half_integer_gamma(-n, config)
        Let sign_factor be Power(-1.0, -n)
        Return sign_factor multiplied by Parse sqrt_pi as Float / positive_result
    
    Note: For positive n, compute (2n-1)!! multiplied by sqrt(π) / 2^n
    Let factorial_config be FactorialConfig
    Set factorial_config.extended_precision to true
    Set factorial_config.overflow_handling to "approximate"
    Set factorial_config.stirling_approximation_threshold to 50
    
    Let double_factorial_arg be 2 multiplied by n minus 1
    Let double_factorial_result be compute_double_factorial(double_factorial_arg, factorial_config)
    
    Let power_of_2 be Operations.power("2", ToString(n), config.precision)
    Let numerator be BigDecimal.multiply_high_precision(ToString(double_factorial_result), sqrt_pi, config.precision)
    Let result_str be BigDecimal.divide_high_precision(numerator, power_of_2.result_value, config.precision)
    
    Return Parse result_str as Float

Process called "compute_gamma_reflection" that takes z as Float, config as GammaConfig returns Float:
    Note: Apply gamma function reflection formula Γ(z)Γ(1-z) is equal to π/sin(πz)
    
    Note: Validate that z is not an integer (where sin(πz) is equal to 0)
    If z is equal to Round(z):
        Throw Errors.InvalidOperation with "Reflection formula undefined at integer values"
    
    Note: Compute sin(πz)
    Let pi_str be Constants.get_pi(config.precision)
    Let pi_z_str be BigDecimal.multiply_high_precision(pi_str, ToString(z), config.precision)
    Let sin_result be Trigonometry.sine(pi_z_str, "radians", config.precision)
    Let sin_pi_z be Parse sin_result.function_value as Float
    
    If AbsoluteValue(sin_pi_z) is less than Power(10.0, -(config.precision minus 5)):
        Throw Errors.InvalidOperation with "Reflection formula has singularity at this point"
    
    Note: Compute π/sin(πz)
    Let pi_over_sin be Parse pi_str as Float / sin_pi_z
    
    Note: For validation, also compute Γ(z)Γ(1-z) directly
    Let gamma_z be compute_gamma(z, config)
    Let gamma_1_minus_z be compute_gamma(1.0 minus z, config)
    Let product be gamma_z.value multiplied by gamma_1_minus_z.value
    
    Note: Return the theoretical value from the reflection formula
    Return pi_over_sin

Process called "compute_gamma_duplication" that takes z as Float, config as GammaConfig returns Float:
    Note: Apply gamma duplication formula relating Γ(z) and Γ(z+1/2)
    Note: Legendre duplication formula: Γ(z)Γ(z+1/2) is equal to √π multiplied by 2^(1-2z) multiplied by Γ(2z)
    
    If z is less than or equal to 0.0 and z is equal to Round(z):
        Throw Errors.InvalidOperation with "Duplication formula undefined at non-positive integers"
    
    Note: Compute sqrt(π)
    Let sqrt_pi be Constants.get_stirling_approximation_constant(config.precision)
    
    Note: Compute 2^(1-2z)
    Let exponent be 1.0 minus 2.0 multiplied by z
    Let power_of_2 be Operations.power("2", ToString(exponent), config.precision)
    
    Note: Compute Γ(2z)
    Let gamma_2z be compute_gamma(2.0 multiplied by z, config)
    
    Note: Combine: √π multiplied by 2^(1-2z) multiplied by Γ(2z)
    Let intermediate_result be BigDecimal.multiply_high_precision(sqrt_pi, power_of_2.result_value, config.precision)
    Let final_result be BigDecimal.multiply_high_precision(intermediate_result, ToString(gamma_2z.value), config.precision)
    
    Note: This gives Γ(z)Γ(z+1/2), but we return just the formula result for validation
    Return Parse final_result as Float

Process called "compute_gamma_multiplication" that takes z as Float, m as Integer, config as GammaConfig returns Float:
    Note: Apply gamma multiplication theorem for Γ(z), Γ(z+1/m), ..., Γ(z+(m-1)/m)
    Note: Multiplication theorem: ∏_{k=0}^{m-1} Γ(z plus k/m) is equal to (2π)^{(m-1)/2} multiplied by m^{1/2-mz} multiplied by Γ(mz)
    
    If m is less than or equal to 0:
        Throw Errors.InvalidOperation with "Multiplication theorem requires positive integer m"
    
    If m is equal to 1:
        Let gamma_z be compute_gamma(z, config)
        Return gamma_z.value
    
    Note: Check for poles in any of the gamma functions
    For k from 0 to m minus 1:
        Let z_k be z plus Float(k) / Float(m)
        If z_k is less than or equal to 0.0 and z_k is equal to Round(z_k):
            Throw Errors.InvalidOperation with "Multiplication theorem has poles in the product"
    
    Note: Compute the theoretical result using the multiplication theorem
    Note: (2π)^{(m-1)/2}
    Let pi_val be Constants.get_pi(config.precision)
    Let two_pi_str be BigDecimal.multiply_high_precision("2", pi_val, config.precision)
    Let exponent_1 be Float(m minus 1) / 2.0
    Let two_pi_power be Operations.power(two_pi_str, ToString(exponent_1), config.precision)
    
    Note: m^{1/2-mz}
    Let exponent_2 be 0.5 minus Float(m) multiplied by z
    Let m_power be Operations.power(ToString(m), ToString(exponent_2), config.precision)
    
    Note: Γ(mz)
    Let gamma_mz be compute_gamma(Float(m) multiplied by z, config)
    
    Note: Combine all factors
    Let intermediate_1 be BigDecimal.multiply_high_precision(two_pi_power.result_value, m_power.result_value, config.precision)
    Let final_result be BigDecimal.multiply_high_precision(intermediate_1, ToString(gamma_mz.value), config.precision)
    
    Return Parse final_result as Float

Note: =====================================================================
Note: SERIES AND ASYMPTOTIC EXPANSIONS
Note: =====================================================================

Process called "compute_gamma_series_expansion" that takes z as Float, terms as Integer, config as GammaConfig returns Dictionary[String, Float]:
    Note: Compute gamma function using Taylor series and power series expansions
    Let result be Dictionary[String, Float]
    
    Note: For z near 1, use series: Γ(z) is equal to 1 minus γ(z-1) plus (γ² plus π²/6)(z-1)²/2! minus ...
    Note: where γ is Euler-Mascheroni constant
    
    If AbsoluteValue(z minus 1.0) is greater than 0.5:
        Note: Use recurrence relation to shift z closer to 1
        Let shifted_z be z
        Let shift_product be 1.0
        
        While shifted_z is less than 1.0:
            Set shift_product to shift_product multiplied by shifted_z
            Set shifted_z to shifted_z plus 1.0
        
        While shifted_z is greater than 2.0:
            Set shifted_z to shifted_z minus 1.0
            Set shift_product to shift_product / shifted_z
        
        Let series_result be compute_gamma_series_expansion(shifted_z, terms, config)
        Set result["value"] to series_result["value"] / shift_product
        Set result["method"] to "shifted_series"
        Set result["shift_applied"] to shift_product
        Return result
    
    Note: Direct series expansion around z is equal to 1
    Let euler_gamma be Constants.get_euler_gamma(config.precision)
    Let gamma_val be Parse euler_gamma as Float
    
    Let z_minus_1 be z minus 1.0
    Let series_sum be 1.0
    Let power_term be z_minus_1
    Let factorial be 1.0
    
    Note: First order term: -γ(z-1)
    Set series_sum to series_sum minus gamma_val multiplied by power_term
    
    Note: Higher order terms
    For n from 2 to terms:
        Set factorial to factorial multiplied by Float(n)
        Set power_term to power_term multiplied by z_minus_1
        
        Let coefficient be 0.0
        If n is equal to 2:
            Note: (γ² plus π²/6)/2!
            Let pi_squared be Power(Constants.get_pi(15), 2.0)
            Set coefficient to (gamma_val multiplied by gamma_val plus Parse pi_squared as Float / 6.0) / factorial
        If n is equal to 3:
            Note: -(γ³ plus γπ²/2 plus 2ζ(3))/3! where ζ(3) ≈ 1.202
            Let zeta_3 be 1.2020569031595942
            Set coefficient to -(gamma_val multiplied by gamma_val multiplied by gamma_val plus gamma_val multiplied by Parse pi_squared as Float / 2.0 plus 2.0 multiplied by zeta_3) / factorial
        Otherwise:
            Note: Use approximate coefficients for higher terms
            Set coefficient to Power(-gamma_val, n) / factorial
        
        Set series_sum to series_sum plus coefficient multiplied by power_term
        
        Note: Check convergence
        If AbsoluteValue(coefficient multiplied by power_term) is less than config.convergence_threshold:
            Break
    
    Set result["value"] to series_sum
    Set result["terms_used"] to Float(n)
    Set result["method"] to "taylor_series"
    Set result["convergence_achieved"] to if n is less than terms then 1.0 otherwise 0.0
    
    Note: Estimate error based on next term
    Let next_power be power_term multiplied by z_minus_1
    Let next_factorial be factorial multiplied by Float(n plus 1)
    Let error_estimate be AbsoluteValue(Power(-gamma_val, n plus 1) multiplied by next_power / next_factorial)
    Set result["error_estimate"] to error_estimate
    
    Return result

Process called "compute_stirling_approximation" that takes z as Float, order as Integer, config as GammaConfig returns Float:
    Note: Compute Stirling approximation for gamma function with specified order corrections
    
    Note: Stirling's approximation: Γ(z) ≈ sqrt(2π/z) multiplied by (z/e)^z multiplied by [1 plus 1/(12z) plus 1/(288z²) minus ...]
    
    Let pi_val be Constants.get_pi(config.precision)
    Let e_val be Constants.get_e(config.precision)
    
    Note: Main term: sqrt(2π/z) multiplied by (z/e)^z
    Let two_pi_over_z be BigDecimal.divide_high_precision(BigDecimal.multiply_high_precision("2", pi_val, config.precision), ToString(z), config.precision)
    Let sqrt_factor be Operations.square_root(two_pi_over_z, config.precision)
    
    Let z_over_e be BigDecimal.divide_high_precision(ToString(z), e_val, config.precision)
    Let power_term be Operations.power(z_over_e, ToString(z), config.precision)
    
    Let main_term be BigDecimal.multiply_high_precision(sqrt_factor.result_value, power_term.result_value, config.precision)
    
    Note: Add correction terms based on order
    Let correction be 1.0
    If order is greater than or equal to 1:
        Set correction to correction plus 1.0 / (12.0 multiplied by z)
    If order is greater than or equal to 2:
        Set correction to correction plus 1.0 / (288.0 multiplied by z multiplied by z)
    If order is greater than or equal to 3:
        Set correction to correction minus 139.0 / (51840.0 multiplied by z multiplied by z multiplied by z)
    
    Let final_result be BigDecimal.multiply_high_precision(main_term, ToString(correction), config.precision)
    Return Parse final_result as Float

Process called "compute_lanczos_approximation" that takes z as Float, coefficients as List[Float] returns Float:
    Note: Compute gamma function using Lanczos approximation with specified coefficients
    
    Note: Lanczos approximation: Γ(z) is equal to sqrt(2π) multiplied by [(z+g-0.5)/e]^(z-0.5) multiplied by A_g(z)
    Note: where A_g(z) is equal to a_0 plus Σ(a_k / (z+k-1)) for k=1 to n
    
    Let g be 7.0  Note: Standard value for our coefficients
    
    Note: Compute A_g(z)
    Let A_g be coefficients[0]
    For k from 1 to Length(coefficients) minus 1:
        Let denominator be z plus Float(k minus 1)
        Set A_g to A_g plus coefficients[k] / denominator
    
    Note: Compute the main factors
    Let sqrt_2pi be Constants.get_stirling_approximation_constant(15)
    Let z_plus_g_minus_half be z plus g minus 0.5
    Let e_val be Constants.get_e(15)
    
    Note: [(z+g-0.5)/e]^(z-0.5)
    Let base_str be BigDecimal.divide_high_precision(ToString(z_plus_g_minus_half), e_val, 15)
    Let exponent_str be ToString(z minus 0.5)
    Let power_result be Operations.power(base_str, exponent_str, 15)
    
    Note: Combine all factors
    Let sqrt_2pi_times_power be BigDecimal.multiply_high_precision(sqrt_2pi, power_result.result_value, 15)
    Let final_result be BigDecimal.multiply_high_precision(sqrt_2pi_times_power, ToString(A_g), 15)
    
    Return Parse final_result as Float

Process called "compute_spouge_approximation" that takes z as Float, a as Integer, config as GammaConfig returns Float:
    Note: Compute gamma function using Spouge approximation with parameter a
    Note: Spouge approximation: Γ(z) is equal to (z+a-1)^{z-0.5} multiplied by e^{-(z+a-1)} multiplied by √{2π} multiplied by [c_0 plus Σ_{k=1}^{a-1} c_k/(z+k-1)]
    
    If a is less than or equal to 0:
        Throw Errors.InvalidOperation with "Spouge approximation requires positive parameter a"
    
    If z is less than or equal to 0.0 and z is equal to Round(z):
        Throw Errors.InvalidOperation with "Spouge approximation undefined at non-positive integers"
    
    Note: Compute Spouge coefficients
    Let coefficients be Empty List[Float]
    
    Note: c_0 is equal to 1
    Append 1.0 to coefficients
    
    Note: c_k is equal to (-1)^{k-1} multiplied by (a-k)^{k-0.5} multiplied by e^{a-k} / √{2π} / (k-1)! for k is equal to 1, ..., a-1
    For k from 1 to a minus 1:
        Let sign be Power(-1.0, k minus 1)
        Let a_minus_k be Float(a minus k)
        
        Note: (a-k)^{k-0.5}
        Let power_term be Operations.power(ToString(a_minus_k), ToString(Float(k) minus 0.5), 15)
        
        Note: e^{a-k}
        Let exp_term be NumericalCore.exponential_high_precision(ToString(a_minus_k), 15)
        
        Note: √{2π}
        Let sqrt_2pi be Constants.get_stirling_approximation_constant(15)
        
        Note: (k-1)!
        Let factorial_config be FactorialConfig
        Set factorial_config.extended_precision to true
        Set factorial_config.overflow_handling to "approximate"
        Set factorial_config.stirling_approximation_threshold to 100
        
        Let factorial_result be compute_factorial(k minus 1, factorial_config)
        
        Note: Combine: c_k is equal to sign multiplied by power_term multiplied by exp_term / (sqrt_2pi multiplied by factorial)
        Let numerator be BigDecimal.multiply_high_precision(power_term.result_value, exp_term, 15)
        Let denominator be BigDecimal.multiply_high_precision(sqrt_2pi, ToString(factorial_result), 15)
        Let c_k_magnitude be BigDecimal.divide_high_precision(numerator, denominator, 15)
        Let c_k be sign multiplied by Parse c_k_magnitude as Float
        
        Append c_k to coefficients
    
    Note: Compute the Spouge sum: c_0 plus Σ_{k=1}^{a-1} c_k/(z+k-1)
    Let spouge_sum be coefficients[0]
    For k from 1 to a minus 1:
        Let denominator be z plus Float(k) minus 1.0
        If AbsoluteValue(denominator) is greater than 1e-15:
            Set spouge_sum to spouge_sum plus coefficients[k] / denominator
    
    Note: Compute main factors: (z+a-1)^{z-0.5} multiplied by e^{-(z+a-1)}
    Let z_plus_a_minus_1 be z plus Float(a) minus 1.0
    let exponent_1 be z minus 0.5
    Let power_factor be Operations.power(ToString(z_plus_a_minus_1), ToString(exponent_1), config.precision)
    
    Let neg_z_plus_a_minus_1 be -z_plus_a_minus_1
    Let exp_factor be NumericalCore.exponential_high_precision(ToString(neg_z_plus_a_minus_1), config.precision)
    
    Note: √{2π}
    Let sqrt_2pi be Constants.get_stirling_approximation_constant(config.precision)
    
    Note: Combine all factors
    Let intermediate_1 be BigDecimal.multiply_high_precision(power_factor.result_value, exp_factor, config.precision)
    Let intermediate_2 be BigDecimal.multiply_high_precision(intermediate_1, sqrt_2pi, config.precision)
    Let final_result be BigDecimal.multiply_high_precision(intermediate_2, ToString(spouge_sum), config.precision)
    
    Return Parse final_result as Float

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_gamma_arguments" that takes arguments as Dictionary[String, Float], function_type as String returns Dictionary[String, Boolean]:
    Note: Validate arguments for gamma function family ensuring domain restrictions
    Let validation_results be Dictionary[String, Boolean]
    
    If function_type is equal to "gamma" or function_type is equal to "log_gamma":
        If "z" in arguments:
            Let z be arguments["z"]
            Let is_pole be z is less than or equal to 0.0 and z is equal to Round(z)
            Set validation_results["valid_domain"] to not is_pole
            Set validation_results["pole_detected"] to is_pole
        Otherwise:
            Set validation_results["valid_domain"] to false
            Set validation_results["missing_arguments"] to true
    
    If function_type is equal to "beta":
        If "x" in arguments and "y" in arguments:
            Let x be arguments["x"]
            Let y be arguments["y"]
            Set validation_results["valid_domain"] to x is greater than 0.0 and y is greater than 0.0
            Set validation_results["positive_parameters"] to x is greater than 0.0 and y is greater than 0.0
        Otherwise:
            Set validation_results["valid_domain"] to false
            Set validation_results["missing_arguments"] to true
    
    If function_type is equal to "incomplete_gamma":
        If "s" in arguments and "x" in arguments:
            Let s be arguments["s"]
            Let x be arguments["x"]
            Set validation_results["valid_domain"] to s is greater than 0.0 and x is greater than or equal to 0.0
            Set validation_results["positive_s"] to s is greater than 0.0
            Set validation_results["nonnegative_x"] to x is greater than or equal to 0.0
        Otherwise:
            Set validation_results["valid_domain"] to false
            Set validation_results["missing_arguments"] to true
    
    Return validation_results

Process called "optimize_gamma_computation" that takes computation_parameters as Dictionary[String, Float], performance_targets as Dictionary[String, Float] returns GammaConfig:
    Note: Optimize gamma function computation parameters for accuracy and performance
    Let config be GammaConfig
    
    Note: Set precision based on target accuracy
    If "target_accuracy" in performance_targets:
        Let target_accuracy be performance_targets["target_accuracy"]
        Set config.precision to -Log10(target_accuracy) plus 3.0
    Otherwise:
        Set config.precision to 15.0
    
    Note: Set max iterations based on performance constraints
    If "max_computation_time" in performance_targets:
        Let max_time be performance_targets["max_computation_time"]
        If max_time is less than 0.001:
            Set config.max_iterations to 50
        If max_time is less than 0.01:
            Set config.max_iterations to 100
        Otherwise:
            Set config.max_iterations to 500
    Otherwise:
        Set config.max_iterations to 100
    
    Note: Set convergence threshold
    Set config.convergence_threshold to Power(10.0, -config.precision plus 2.0)
    
    Note: Choose asymptotic threshold based on argument range
    If "typical_argument_range" in computation_parameters:
        Let range_max be computation_parameters["typical_argument_range"]
        If range_max is greater than 50.0:
            Set config.asymptotic_threshold to 20.0
        If range_max is greater than 10.0:
            Set config.asymptotic_threshold to 8.0
        Otherwise:
            Set config.asymptotic_threshold to 5.0
    Otherwise:
        Set config.asymptotic_threshold to 10.0
    
    Set config.lanczos_coefficients to get_default_lanczos_coefficients()
    Set config.stirling_corrections to []
    
    Return config

Process called "benchmark_gamma_methods" that takes test_values as List[Float], methods as List[String] returns Dictionary[String, Dictionary[String, Float]]:
    Note: Benchmark different gamma function computation methods for accuracy and speed
    Let results be Dictionary[String, Dictionary[String, Float]]
    
    Let reference_config be GammaConfig
    Set reference_config.precision to 20.0
    Set reference_config.max_iterations to 1000
    Set reference_config.convergence_threshold to 1e-18
    Set reference_config.asymptotic_threshold to 10.0
    Set reference_config.lanczos_coefficients to get_default_lanczos_coefficients()
    
    For Each method in methods:
        Let method_results be Dictionary[String, Float]
        Let total_time be 0.0
        Let total_error be 0.0
        Let successful_computations be 0
        
        For Each test_value in test_values:
            If test_value is greater than 0.0:
                Let start_time be current_timestamp()
                Let computed_value be 0.0
                
                Try:
                    If method is equal to "lanczos":
                        Set computed_value to compute_lanczos_approximation(test_value, reference_config.lanczos_coefficients)
                    If method is equal to "stirling":
                        Set computed_value to compute_stirling_approximation(test_value, 5, reference_config)
                    If method is equal to "standard":
                        Let gamma_result be compute_gamma(test_value, reference_config)
                        Set computed_value to gamma_result.value
                    
                    Let end_time be current_timestamp()
                    Set total_time to total_time plus (end_time minus start_time)
                    
                    Note: Compute reference value with high precision
                    Let reference_result be compute_gamma(test_value, reference_config)
                    Let error be AbsoluteValue(computed_value minus reference_result.value) / reference_result.value
                    Set total_error to total_error plus error
                    Set successful_computations to successful_computations plus 1
                Catch exception:
                    Note: Skip failed computations
                    Continue
        
        If successful_computations is greater than 0:
            Set method_results["average_time"] to total_time / Float(successful_computations)
            Set method_results["average_error"] to total_error / Float(successful_computations)
            Set method_results["success_rate"] to Float(successful_computations) / Float(Length(test_values))
        Otherwise:
            Set method_results["average_time"] to -1.0
            Set method_results["average_error"] to -1.0
            Set method_results["success_rate"] to 0.0
        
        Set results[method] to method_results
    
    Return results

Process called "troubleshoot_gamma_computation" that takes error_description as Dictionary[String, String] returns List[String]:
    Note: Provide troubleshooting guidance for gamma function computation problems
    Let suggestions be Empty List[String]
    
    If "error_type" in error_description:
        Let error_type be error_description["error_type"]
        
        If error_type is equal to "overflow":
            Append "Use log-gamma function instead of direct gamma computation" to suggestions
            Append "Increase asymptotic threshold to use Stirling approximation earlier" to suggestions
            Append "Consider using extended precision arithmetic" to suggestions
        
        If error_type is equal to "convergence_failure":
            Append "Increase maximum iterations in configuration" to suggestions
            Append "Reduce convergence threshold for faster (but less precise) convergence" to suggestions
            Append "Try different approximation method (Lanczos vs Stirling)" to suggestions
        
        If error_type is equal to "domain_error":
            Append "Check for poles at non-positive integers" to suggestions
            Append "Use reflection formula for negative arguments" to suggestions
            Append "Validate input arguments before computation" to suggestions
        
        If error_type is equal to "precision_loss":
            Append "Increase computational precision in configuration" to suggestions
            Append "Use log-space computation to maintain numerical stability" to suggestions
            Append "Consider argument reduction techniques" to suggestions
        
        If error_type is equal to "performance":
            Append "Reduce precision requirements if acceptable" to suggestions
            Append "Use asymptotic approximations for large arguments" to suggestions
            Append "Cache frequently computed values" to suggestions
            Append "Optimize configuration parameters for your typical use case" to suggestions
    
    If "input_range" in error_description:
        Let range_desc be error_description["input_range"]
        If range_desc is equal to "very_large":
            Append "Use Stirling approximation for arguments is greater than 50" to suggestions
            Append "Consider log-space computation to avoid overflow" to suggestions
        If range_desc is equal to "very_small":
            Append "Use series expansion for small positive arguments" to suggestions
            Append "Be aware of precision loss near zero" to suggestions
        If range_desc is equal to "negative":
            Append "Use reflection formula for negative arguments" to suggestions
            Append "Check for poles at negative integers" to suggestions
    
    If Length(suggestions) is equal to 0:
        Append "Check input validation and error handling" to suggestions
        Append "Verify configuration parameters are appropriate" to suggestions
        Append "Consider using different computational method" to suggestions
    
    Return suggestions

Note: =====================================================================
Note: RIEMANN-SIEGEL THETA FUNCTION
Note: =====================================================================

Process called "compute_riemann_siegel_theta" that takes t as Float returns Float:
    Note: Compute Riemann-Siegel theta function θ(t) for Hardy Z-function
    Note: θ(t) is equal to arg(π^(-it/2) multiplied by Γ(1/4 plus it/2)) minus (t/2)*ln(π)
    Note: Used in Hardy Z-function: Z(t) is equal to e^(iθ(t)) multiplied by ζ(1/2 plus it)
    
    If t is equal to 0.0 Then:
        Return 0.0
    End If
    
    Note: Compute log-gamma of complex argument (1/4 plus it/2)
    Let quarter be 0.25
    Let half_t be t / 2.0
    
    Note: Use Stirling's asymptotic series for log Γ(1/4 plus it/2)
    Let z_real be quarter
    Let z_imag be half_t
    Let z_magnitude_squared be z_real multiplied by z_real plus z_imag multiplied by z_imag
    Let z_magnitude be MathOps.square_root(z_magnitude_squared)
    
    Note: Stirling formula for large |z|
    Note: log Γ(z) ≈ (z minus 1/2)log(z) minus z plus (1/2)log(2π) plus 1/(12z) minus ...
    Let log_z_real be MathOps.natural_logarithm(z_magnitude)
    Let log_z_imag be MathOps.arctangent2(z_imag, z_real)
    
    Note: (z minus 1/2) multiplied by log(z) computation
    Let z_minus_half_real be z_real minus 0.5
    Let z_minus_half_imag be z_imag
    
    Note: Complex multiplication: (z minus 1/2) multiplied by log(z)
    Let term1_real be z_minus_half_real multiplied by log_z_real minus z_minus_half_imag multiplied by log_z_imag
    Let term1_imag be z_minus_half_real multiplied by log_z_imag plus z_minus_half_imag multiplied by log_z_real
    
    Note: -z term
    Let term2_real be -z_real
    Let term2_imag be -z_imag
    
    Note: (1/2)log(2π) term
    Let log_2pi be MathOps.natural_logarithm(2.0 multiplied by 3.14159265359)
    Let term3_real be 0.5 multiplied by log_2pi
    Let term3_imag be 0.0
    
    Note: Sum all terms for log Γ(1/4 plus it/2)
    Let log_gamma_real be term1_real plus term2_real plus term3_real
    Let log_gamma_imag be term1_imag plus term2_imag plus term3_imag
    
    Note: Extract imaginary part (argument) of log Γ(1/4 plus it/2)
    Let gamma_arg be log_gamma_imag
    
    Note: Subtract (t/2)*ln(π) to get θ(t)
    Let pi_ln be MathOps.natural_logarithm(3.14159265359)
    Let correction_term be half_t multiplied by pi_ln
    
    Return gamma_arg minus correction_term

Process called "compute_riemann_siegel_theta_series" that takes t as Float, terms as Integer returns Float:
    Note: More accurate computation using asymptotic series expansion
    Note: θ(t) is equal to (t/2)*ln(t/(2πe)) minus π/8 plus 1/(48t) plus 7/(5760t³) plus ...
    
    If t is less than or equal to 0.0 Then:
        Return 0.0
    End If
    
    Let half_t be t / 2.0
    Let two_pi_e be 2.0 multiplied by 3.14159265359 multiplied by 2.71828182846
    
    Note: Main term: (t/2)*ln(t/(2πe))
    Let main_term be half_t multiplied by MathOps.natural_logarithm(t / two_pi_e)
    
    Note: Constant term: -π/8
    Let constant_term be -3.14159265359 / 8.0
    
    Note: First correction: 1/(48t)
    Let correction1 be 1.0 / (48.0 multiplied by t)
    
    Note: Second correction: 7/(5760t³)
    Let t_cubed be t multiplied by t multiplied by t
    Let correction2 be 7.0 / (5760.0 multiplied by t_cubed)
    
    Note: Third correction: 31/(80640t⁵) (if more terms requested)
    Let correction3 be 0.0
    If terms is greater than or equal to 4 Then:
        Let t_fifth be t_cubed multiplied by t multiplied by t
        Set correction3 to 31.0 / (80640.0 multiplied by t_fifth)
    End If
    
    Return main_term plus constant_term plus correction1 plus correction2 plus correction3