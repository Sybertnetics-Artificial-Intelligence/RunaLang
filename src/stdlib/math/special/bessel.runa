Note:
math/special/bessel.runa
Bessel Functions and Cylindrical Functions

This module provides comprehensive Bessel function implementations including
Bessel functions of the first and second kind, modified Bessel functions,
spherical Bessel functions, Airy functions, Hankel functions, zeros computation,
and asymptotic expansions with numerical analysis support.
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/special/gamma" as Gamma
Import module "math/core/operations" as Operations
Import module "math/core/trigonometry" as Trigonometry
Import module "math/core/constants" as Constants
Import module "math/engine/numerical/core" as NumericalCore
Import module "math/engine/numerical/rootfinding" as RootFinding
Import module "math/engine/numerical/integration" as Integration
Import module "math/precision/bigdecimal" as BigDecimal

Note: =====================================================================
Note: BESSEL FUNCTION DATA STRUCTURES
Note: =====================================================================

Type called "BesselConfig":
    precision as Float
    max_iterations as Integer
    convergence_threshold as Float
    series_method as String
    asymptotic_threshold as Float
    recurrence_direction as String
    scaling_factor as Float

Type called "BesselResult":
    value as Float
    error_estimate as Float
    iterations_used as Integer
    method_used as String
    convergence_status as String
    derivative_values as List[Float]

Type called "BesselZeros":
    function_type as String
    order as Float
    zeros_list as List[Float]
    accuracy as Float
    computation_method as String

Type called "AsymptoticExpansion":
    leading_term as Float
    correction_terms as List[Float]
    expansion_order as Integer
    validity_range as Dictionary[String, Float]

Note: =====================================================================
Note: BESSEL FUNCTIONS FIRST KIND OPERATIONS
Note: =====================================================================

Process called "compute_bessel_j" that takes nu as Float, x as Float, config as BesselConfig returns BesselResult:
    Note: Compute Bessel function of first kind J_ν(x) using series, recurrence, and asymptotic methods
    Let result be BesselResult
    Set result.method_used to "auto_selection"
    Set result.convergence_status to "converged"
    Set result.derivative_values to []
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        If nu is equal to 0.0:
            Set result.value to 1.0
            Set result.error_estimate to 0.0
            Set result.iterations_used to 0
            Set result.method_used to "exact_zero"
            Return result
        Otherwise:
            Set result.value to 0.0
            Set result.error_estimate to 0.0
            Set result.iterations_used to 0
            Set result.method_used to "exact_zero"
            Return result
    
    Let abs_x be Operations.absolute_value(String(x), config.precision).result_value
    Let x_threshold be config.asymptotic_threshold
    
    If BigDecimal.compare(abs_x, String(x_threshold)) is less than 0:
        Let series_result be compute_bessel_j_series(nu, x, config.max_iterations)
        Set result.value to BigDecimal.to_float(series_result)
        Set result.error_estimate to BigDecimal.to_float("1e-" plus String(config.precision))
        Set result.iterations_used to config.max_iterations
        Set result.method_used to "power_series"
    Otherwise:
        Let asymptotic_result be compute_bessel_asymptotic_large_argument(nu, x, 10)
        Set result.value to BigDecimal.to_float(asymptotic_result.leading_term)
        Set result.error_estimate to BigDecimal.to_float(Operations.absolute_value(asymptotic_result.correction_terms[0], 20).result_value)
        Set result.iterations_used to asymptotic_result.expansion_order
        Set result.method_used to "asymptotic_expansion"
    
    Return result

Process called "compute_bessel_j_derivative" that takes nu as Float, x as Float, config as BesselConfig returns Float:
    Note: Compute derivative of Bessel function J'_ν(x) using recurrence relations
    Note: J'_ν(x) is equal to [J_{ν-1}(x) minus J_{ν+1}(x)] / 2
    
    Let j_nu_minus_1 be compute_bessel_j(nu minus 1.0, x, config).value
    Let j_nu_plus_1 be compute_bessel_j(nu plus 1.0, x, config).value
    
    Let difference be Operations.subtract(String(j_nu_minus_1), String(j_nu_plus_1), config.precision).result_value
    Let derivative be Operations.divide(difference, "2.0", config.precision).result_value
    
    Return BigDecimal.to_float(derivative)

Process called "compute_bessel_j_zeros" that takes nu as Float, n_zeros as Integer, config as BesselConfig returns BesselZeros:
    Note: Compute first n zeros of Bessel function J_ν(x) using asymptotic estimates and Newton refinement
    Note: Uses McMahon asymptotic formulas for initial estimates followed by Newton-Raphson refinement
    
    Let result be BesselZeros
    Set result.function_type to "bessel_j"
    Set result.order to nu
    Set result.zeros_list to []
    Set result.accuracy to config.convergence_threshold
    Set result.computation_method to "mcmahon_newton"
    
    Let pi_str be Constants.get_pi(50)
    
    Let k be 1
    While k is less than or equal to n_zeros:
        Let k_minus_half be BigDecimal.to_float(String(k) plus ".5")
        Let nu_minus_half be nu minus 0.5
        Let beta be Operations.multiply(String(k_minus_half minus nu_minus_half/4.0), pi_str, 50).result_value
        
        Let mcmahon_estimate be beta
        
        Let tolerance be Operations.divide(String(config.convergence_threshold), "10.0", 50).result_value
        
        Let bessel_evaluator be "compute_bessel_j_for_zero_finding"
        Let derivative_evaluator be "compute_bessel_j_derivative_for_zero_finding"
        
        Let refined_zero be RootFinding.newton_raphson(bessel_evaluator, derivative_evaluator, mcmahon_estimate, tolerance, config.max_iterations)
        
        If refined_zero.convergence_achieved:
            Let zeros_copy be result.zeros_list
            Let new_zero be BigDecimal.to_float(refined_zero.root_value)
            Set result.zeros_list to zeros_copy plus [new_zero]
        
        Set k to k plus 1
    
    Return result

Process called "compute_bessel_j_series" that takes nu as Float, x as Float, terms as Integer returns Float:
    Note: Compute Bessel J function using power series expansion around x is equal to 0
    Note: J_ν(x) is equal to (x/2)^ν multiplied by Σ(k=0 to ∞) [(-1)^k multiplied by (x^2/4)^k] / [k! multiplied by Γ(ν+k+1)]
    
    Let x_str be String(x)
    Let nu_str be String(nu)
    Let half_x be Operations.divide(x_str, "2.0", 50).result_value
    Let quarter_x_squared be Operations.divide(Operations.multiply(x_str, x_str, 50).result_value, "4.0", 50).result_value
    
    Let x_power_nu be BigDecimal.power_function(half_x, nu_str, 50)
    
    Let gamma_config be Gamma.GammaConfig
    Set gamma_config.precision to 50.0
    Set gamma_config.max_iterations to 100
    Set gamma_config.convergence_threshold to 1e-50
    Set gamma_config.series_method to "lanczos"
    Set gamma_config.asymptotic_threshold to 20.0
    Set gamma_config.lanczos_coefficients to []
    Set gamma_config.stirling_corrections to []
    
    Let gamma_nu_plus_one be Gamma.compute_gamma(nu plus 1.0, gamma_config).value
    
    Let sum be BigDecimal.create_from_string("0.0", BigDecimal.MathContext)
    Let term be Operations.divide(x_power_nu, String(gamma_nu_plus_one), 50).result_value
    Set sum to BigDecimal.add(sum, BigDecimal.create_from_string(term, BigDecimal.MathContext))
    
    Let k be 1
    While k is less than or equal to terms:
        Let k_factorial be Gamma.compute_factorial(k, Gamma.FactorialConfig).factorial_value
        Let nu_plus_k_plus_one be nu plus BigDecimal.to_float(String(k)) plus 1.0
        Let gamma_nu_plus_k_plus_one be Gamma.compute_gamma(nu_plus_k_plus_one, gamma_config).value
        
        Let numerator be BigDecimal.power_function(quarter_x_squared, String(k), 50)
        If k % 2 is equal to 1:
            Set numerator to Operations.multiply("-1.0", numerator, 50).result_value
        
        Let denominator be Operations.multiply(k_factorial, String(gamma_nu_plus_k_plus_one), 50).result_value
        Set term to Operations.divide(numerator, denominator, 50).result_value
        Set sum to BigDecimal.add(sum, BigDecimal.create_from_string(term, BigDecimal.MathContext))
        
        Let term_abs be Operations.absolute_value(term, 50).result_value
        If BigDecimal.compare(term_abs, "1e-45") is less than 0:
            Break
        
        Set k to k plus 1
    
    Let final_result be Operations.multiply(x_power_nu, BigDecimal.to_plain_string(sum), 50).result_value
    Return BigDecimal.to_float(final_result)

Note: =====================================================================
Note: BESSEL FUNCTIONS SECOND KIND OPERATIONS
Note: =====================================================================

Process called "compute_bessel_y" that takes nu as Float, x as Float, config as BesselConfig returns BesselResult:
    Note: Compute Bessel function of second kind Y_ν(x) using series and asymptotic methods
    Note: Y_ν(x) is equal to [J_ν(x)cos(νπ) minus J_{-ν}(x)] / sin(νπ)
    
    Let result be BesselResult
    Set result.method_used to "connection_formula"
    Set result.convergence_status to "converged"
    Set result.derivative_values to []
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        Throw Errors.InvalidOperation with "Bessel Y function has logarithmic singularity at x=0"
    
    Let nu_is_integer be (nu is equal to Operations.round_to_integer(String(nu), 0).result_value)
    
    If nu_is_integer:
        Let n be Integer(nu)
        Let y_series be compute_bessel_y_integer_series(n, x, config.max_iterations)
        Set result.value to BigDecimal.to_float(y_series)
        Set result.error_estimate to BigDecimal.to_float("1e-" plus String(config.precision))
        Set result.iterations_used to config.max_iterations
        Set result.method_used to "integer_series"
    Otherwise:
        Let pi_str be Constants.get_pi(config.precision)
        Let nu_pi be Operations.multiply(String(nu), pi_str, config.precision).result_value
        Let cos_nu_pi be Trigonometry.cosine(nu_pi, "radians", config.precision).function_value
        Let sin_nu_pi be Trigonometry.sine(nu_pi, "radians", config.precision).function_value
        
        Let j_nu be compute_bessel_j(nu, x, config).value
        Let j_minus_nu be compute_bessel_j(-nu, x, config).value
        
        Let numerator be Operations.subtract(Operations.multiply(String(j_nu), cos_nu_pi, config.precision).result_value, String(j_minus_nu), config.precision).result_value
        Let y_value be Operations.divide(numerator, sin_nu_pi, config.precision).result_value
        
        Set result.value to BigDecimal.to_float(y_value)
        Set result.error_estimate to BigDecimal.to_float("1e-" plus String(config.precision minus 2))
        Set result.iterations_used to 2
    
    Return result

Process called "compute_bessel_y_derivative" that takes nu as Float, x as Float, config as BesselConfig returns Float:
    Note: Compute derivative of Bessel function Y'_ν(x) using recurrence relations
    Note: Y'_ν(x) is equal to [Y_{ν-1}(x) minus Y_{ν+1}(x)] / 2
    
    Let y_nu_minus_1 be compute_bessel_y(nu minus 1.0, x, config).value
    Let y_nu_plus_1 be compute_bessel_y(nu plus 1.0, x, config).value
    
    Let difference be Operations.subtract(String(y_nu_minus_1), String(y_nu_plus_1), config.precision).result_value
    Let derivative be Operations.divide(difference, "2.0", config.precision).result_value
    
    Return BigDecimal.to_float(derivative)

Process called "compute_bessel_y_zeros" that takes nu as Float, n_zeros as Integer, config as BesselConfig returns BesselZeros:
    Note: Compute first n zeros of Bessel function Y_ν(x) using asymptotic methods
    
    Let result be BesselZeros
    Set result.function_type to "bessel_y"
    Set result.order to nu
    Set result.zeros_list to []
    Set result.accuracy to config.convergence_threshold
    Set result.computation_method to "asymptotic_newton"
    
    Let pi_str be Constants.get_pi(50)
    
    Let k be 1
    While k is less than or equal to n_zeros:
        Let k_minus_quarter be BigDecimal.to_float(String(k) plus ".25")
        Let nu_plus_half be nu plus 0.5
        Let beta be Operations.multiply(String(k_minus_quarter minus nu_plus_half/4.0), pi_str, 50).result_value
        
        Let asymptotic_estimate be beta
        
        Let tolerance be Operations.divide(String(config.convergence_threshold), "5.0", 50).result_value
        
        Let bessel_y_evaluator be "compute_bessel_y_for_zero_finding"
        Let bessel_y_derivative_evaluator be "compute_bessel_y_derivative_for_zero_finding"
        
        Let refined_zero be RootFinding.newton_raphson(bessel_y_evaluator, bessel_y_derivative_evaluator, asymptotic_estimate, tolerance, config.max_iterations)
        
        If refined_zero.convergence_achieved:
            Let zeros_copy be result.zeros_list
            Let new_zero be BigDecimal.to_float(refined_zero.root_value)
            Set result.zeros_list to zeros_copy plus [new_zero]
        
        Set k to k plus 1
    
    Return result

Process called "compute_bessel_hankel_first" that takes nu as Float, x as Float, config as BesselConfig returns Dictionary[String, Float]:
    Note: Compute Hankel function of first kind H^(1)_ν(x) is equal to J_ν(x) plus iY_ν(x)
    
    Let result be Dictionary[String, Float]
    
    Let j_nu be compute_bessel_j(nu, x, config).value
    Let y_nu be compute_bessel_y(nu, x, config).value
    
    Set result["real_part"] to j_nu
    Set result["imaginary_part"] to y_nu
    
    Let magnitude_squared be j_nu multiplied by j_nu plus y_nu multiplied by y_nu
    Set result["magnitude"] to Operations.square_root(String(magnitude_squared), config.precision).result_value
    
    Let argument be 0.0
    If j_nu does not equal 0.0 or y_nu does not equal 0.0:
        Set argument to BigDecimal.to_float(Trigonometry.arctangent2(String(y_nu), String(j_nu), config.precision, "radians").function_value)
    Set result["argument"] to argument
    
    Return result

Process called "compute_bessel_hankel_second" that takes nu as Float, x as Float, config as BesselConfig returns Dictionary[String, Float]:
    Note: Compute Hankel function of second kind H^(2)_ν(x) is equal to J_ν(x) minus iY_ν(x)
    
    Let result be Dictionary[String, Float]
    
    Let j_nu be compute_bessel_j(nu, x, config).value
    Let y_nu be compute_bessel_y(nu, x, config).value
    
    Set result["real_part"] to j_nu
    Set result["imaginary_part"] to -y_nu
    
    Let magnitude_squared be j_nu multiplied by j_nu plus y_nu multiplied by y_nu
    Set result["magnitude"] to Operations.square_root(String(magnitude_squared), config.precision).result_value
    
    Let argument be 0.0
    If j_nu does not equal 0.0 or y_nu does not equal 0.0:
        Set argument to BigDecimal.to_float(Trigonometry.arctangent2(String(-y_nu), String(j_nu), config.precision, "radians").function_value)
    Set result["argument"] to argument
    
    Return result

Note: =====================================================================
Note: HELPER FUNCTIONS FOR BESSEL Y
Note: =====================================================================

Process called "compute_bessel_y_integer_series" that takes n as Integer, x as Float, terms as Integer returns String:
    Note: Compute Bessel Y function for integer order using series expansion
    Note: For integer n: Y_n(x) is equal to (2/π)[ln(x/2) plus γ]J_n(x) minus (1/π)Σ series terms
    
    Let pi_str be Constants.get_pi(50)
    Let euler_gamma_str be Constants.get_euler_gamma(50)
    Let two_over_pi be Operations.divide("2.0", pi_str, 50).result_value
    
    Let x_str be String(x)
    Let half_x be Operations.divide(x_str, "2.0", 50).result_value
    Let ln_half_x be BigDecimal.natural_log(half_x, 50)
    
    Let log_term be Operations.add(ln_half_x, euler_gamma_str, 50).result_value
    Let j_n be compute_bessel_j_series(Float(n), x, terms)
    
    Let first_part be Operations.multiply(Operations.multiply(two_over_pi, log_term, 50).result_value, String(j_n), 50).result_value
    
    Let series_sum be BigDecimal.create_from_string("0.0", BigDecimal.MathContext)
    Let x_half_power_n be BigDecimal.power_function(half_x, String(n), 50)
    
    Let k be 0
    While k is less than terms:
        If k is less than n:
            Let n_minus_k_minus_1_factorial be Gamma.compute_factorial(n minus k minus 1, Gamma.FactorialConfig).factorial_value
            Let quarter_x_squared_power_k be BigDecimal.power_function(Operations.divide(Operations.multiply(x_str, x_str, 50).result_value, "4.0", 50).result_value, String(k), 50)
            Let k_factorial be Gamma.compute_factorial(k, Gamma.FactorialConfig).factorial_value
            
            Let term_numerator be Operations.multiply(n_minus_k_minus_1_factorial, quarter_x_squared_power_k, 50).result_value
            Let term_denominator be Operations.multiply(k_factorial, BigDecimal.power_function(half_x, String(n minus 2*k), 50), 50).result_value
            Let term be Operations.divide(term_numerator, term_denominator, 50).result_value
            
            If k % 2 is equal to 1:
                Set term to Operations.multiply("-1.0", term, 50).result_value
            
            Set series_sum to BigDecimal.add(series_sum, BigDecimal.create_from_string(term, BigDecimal.MathContext))
        
        Set k to k plus 1
    
    Let second_part be Operations.multiply(Operations.divide("1.0", pi_str, 50).result_value, BigDecimal.to_plain_string(series_sum), 50).result_value
    
    Return Operations.subtract(first_part, second_part, 50).result_value

Note: =====================================================================
Note: MODIFIED BESSEL FUNCTIONS OPERATIONS
Note: =====================================================================

Process called "compute_modified_bessel_i" that takes nu as Float, x as Float, config as BesselConfig returns BesselResult:
    Note: Compute modified Bessel function of first kind I_ν(x) with exponential growth handling
    Note: I_ν(x) is equal to (x/2)^ν multiplied by Σ(k=0 to ∞) [(x^2/4)^k] / [k! multiplied by Γ(ν+k+1)]
    
    Let result be BesselResult
    Set result.method_used to "series_expansion"
    Set result.convergence_status to "converged"
    Set result.derivative_values to []
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        If nu is equal to 0.0:
            Set result.value to 1.0
        Otherwise:
            Set result.value to 0.0
        Set result.error_estimate to 0.0
        Set result.iterations_used to 0
        Set result.method_used to "exact_zero"
        Return result
    
    Let x_str be String(x)
    Let nu_str be String(nu)
    Let half_x be Operations.divide(x_str, "2.0", 50).result_value
    Let quarter_x_squared be Operations.divide(Operations.multiply(x_str, x_str, 50).result_value, "4.0", 50).result_value
    
    Let x_power_nu be BigDecimal.power_function(half_x, nu_str, 50)
    
    Let gamma_config be Gamma.GammaConfig
    Set gamma_config.precision to 50.0
    Set gamma_config.max_iterations to 100
    Set gamma_config.convergence_threshold to 1e-50
    Set gamma_config.series_method to "lanczos"
    Set gamma_config.asymptotic_threshold to 20.0
    Set gamma_config.lanczos_coefficients to []
    Set gamma_config.stirling_corrections to []
    
    Let gamma_nu_plus_one be Gamma.compute_gamma(nu plus 1.0, gamma_config).value
    
    Let sum be BigDecimal.create_from_string("1.0", BigDecimal.MathContext)
    
    Let k be 1
    While k is less than or equal to config.max_iterations:
        Let k_factorial be Gamma.compute_factorial(k, Gamma.FactorialConfig).factorial_value
        Let nu_plus_k_plus_one be nu plus BigDecimal.to_float(String(k)) plus 1.0
        Let gamma_nu_plus_k_plus_one be Gamma.compute_gamma(nu_plus_k_plus_one, gamma_config).value
        
        Let numerator be BigDecimal.power_function(quarter_x_squared, String(k), 50)
        Let denominator be Operations.multiply(k_factorial, String(gamma_nu_plus_k_plus_one), 50).result_value
        Let term be Operations.divide(numerator, denominator, 50).result_value
        Set sum to BigDecimal.add(sum, BigDecimal.create_from_string(term, BigDecimal.MathContext))
        
        Let term_abs be Operations.absolute_value(term, 50).result_value
        If BigDecimal.compare(term_abs, "1e-45") is less than 0:
            Break
        
        Set k to k plus 1
    
    Let final_result be Operations.multiply(x_power_nu, BigDecimal.to_plain_string(sum), 50).result_value
    Set result.value to BigDecimal.to_float(final_result)
    Set result.error_estimate to BigDecimal.to_float("1e-" plus String(config.precision))
    Set result.iterations_used to k
    
    Return result

Process called "compute_modified_bessel_k" that takes nu as Float, x as Float, config as BesselConfig returns BesselResult:
    Note: Compute modified Bessel function of second kind K_ν(x) with singularity handling
    Note: K_ν(x) is equal to (π/2) multiplied by [I_{-ν}(x) minus I_ν(x)] / sin(νπ)
    
    Let result be BesselResult
    Set result.method_used to "connection_formula"
    Set result.convergence_status to "converged"
    Set result.derivative_values to []
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        Throw Errors.InvalidOperation with "Modified Bessel K function has logarithmic singularity at x=0"
    
    Let nu_is_integer be (nu is equal to Operations.round_to_integer(String(nu), 0).result_value)
    
    If nu_is_integer:
        Let n be Integer(nu)
        Let k_series be compute_modified_bessel_k_integer_series(n, x, config.max_iterations)
        Set result.value to BigDecimal.to_float(k_series)
        Set result.error_estimate to BigDecimal.to_float("1e-" plus String(config.precision))
        Set result.iterations_used to config.max_iterations
        Set result.method_used to "integer_series"
    Otherwise:
        Let pi_str be Constants.get_pi(config.precision)
        Let nu_pi be Operations.multiply(String(nu), pi_str, config.precision).result_value
        Let sin_nu_pi be Trigonometry.sine(nu_pi, "radians", config.precision).function_value
        
        Let i_nu be compute_modified_bessel_i(nu, x, config).value
        Let i_minus_nu be compute_modified_bessel_i(-nu, x, config).value
        
        Let difference be Operations.subtract(String(i_minus_nu), String(i_nu), config.precision).result_value
        Let pi_over_two be Operations.divide(pi_str, "2.0", config.precision).result_value
        Let numerator be Operations.multiply(pi_over_two, difference, config.precision).result_value
        Let k_value be Operations.divide(numerator, sin_nu_pi, config.precision).result_value
        
        Set result.value to BigDecimal.to_float(k_value)
        Set result.error_estimate to BigDecimal.to_float("1e-" plus String(config.precision minus 2))
        Set result.iterations_used to 2
    
    Return result

Process called "compute_modified_bessel_scaled_i" that takes nu as Float, x as Float, config as BesselConfig returns Float:
    Note: Compute exponentially scaled modified Bessel I_ν(x)e^(-|x|) for numerical stability
    
    Let i_nu be compute_modified_bessel_i(nu, x, config).value
    Let abs_x be Operations.absolute_value(String(x), config.precision).result_value
    Let neg_abs_x be Operations.multiply("-1.0", abs_x, config.precision).result_value
    Let exp_neg_abs_x be BigDecimal.exponential_function(neg_abs_x, config.precision)
    
    Let scaled_result be Operations.multiply(String(i_nu), exp_neg_abs_x, config.precision).result_value
    Return BigDecimal.to_float(scaled_result)

Process called "compute_modified_bessel_scaled_k" that takes nu as Float, x as Float, config as BesselConfig returns Float:
    Note: Compute exponentially scaled modified Bessel K_ν(x)e^x for numerical stability
    
    Let k_nu be compute_modified_bessel_k(nu, x, config).value
    Let x_str be String(x)
    Let exp_x be BigDecimal.exponential_function(x_str, config.precision)
    
    Let scaled_result be Operations.multiply(String(k_nu), exp_x, config.precision).result_value
    Return BigDecimal.to_float(scaled_result)

Process called "compute_modified_bessel_k_integer_series" that takes n as Integer, x as Float, terms as Integer returns String:
    Note: Compute modified Bessel K function for integer order using series expansion
    Note: K_n(x) is equal to (-1)^{n+1} multiplied by [ln(x/2) plus γ] multiplied by I_n(x) plus (1/2) multiplied by Σ series terms
    
    Let euler_gamma_str be Constants.get_euler_gamma(50)
    Let x_str be String(x)
    Let half_x be Operations.divide(x_str, "2.0", 50).result_value
    Let ln_half_x be BigDecimal.natural_log(half_x, 50)
    
    Let log_term be Operations.add(ln_half_x, euler_gamma_str, 50).result_value
    Let i_n_config be BesselConfig
    Set i_n_config.precision to 50.0
    Set i_n_config.max_iterations to terms
    Set i_n_config.convergence_threshold to 1e-50
    Set i_n_config.series_method to "power_series"
    Set i_n_config.asymptotic_threshold to 20.0
    Set i_n_config.recurrence_direction to "forward"
    Set i_n_config.scaling_factor to 1.0
    
    Let i_n be compute_modified_bessel_i(Float(n), x, i_n_config).value
    
    Let sign_factor be BigDecimal.power_function("-1.0", String(n plus 1), 50)
    Let first_part be Operations.multiply(Operations.multiply(sign_factor, log_term, 50).result_value, String(i_n), 50).result_value
    
    Let series_sum be BigDecimal.create_from_string("0.0", BigDecimal.MathContext)
    
    Let k be 0
    While k is less than terms:
        If k is less than n:
            Let n_minus_k_minus_1_factorial be Gamma.compute_factorial(n minus k minus 1, Gamma.FactorialConfig).factorial_value
            Let quarter_x_squared_power_k be BigDecimal.power_function(Operations.divide(Operations.multiply(x_str, x_str, 50).result_value, "4.0", 50).result_value, String(k), 50)
            Let k_factorial be Gamma.compute_factorial(k, Gamma.FactorialConfig).factorial_value
            
            Let term_numerator be Operations.multiply(n_minus_k_minus_1_factorial, quarter_x_squared_power_k, 50).result_value
            Let term_denominator be Operations.multiply(k_factorial, BigDecimal.power_function(half_x, String(n minus 2*k), 50), 50).result_value
            Let term be Operations.divide(term_numerator, term_denominator, 50).result_value
            
            If k % 2 is equal to 1:
                Set term to Operations.multiply("-1.0", term, 50).result_value
            
            Set series_sum to BigDecimal.add(series_sum, BigDecimal.create_from_string(term, BigDecimal.MathContext))
        
        Set k to k plus 1
    
    Let second_part be Operations.multiply("0.5", BigDecimal.to_plain_string(series_sum), 50).result_value
    
    Return Operations.add(first_part, second_part, 50).result_value

Note: =====================================================================
Note: SPHERICAL BESSEL FUNCTIONS OPERATIONS
Note: =====================================================================

Process called "compute_spherical_bessel_j" that takes n as Integer, x as Float, config as BesselConfig returns Float:
    Note: Compute spherical Bessel function j_n(x) is equal to √(π/2x) J_{n+1/2}(x)
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        If n is equal to 0:
            Return 1.0
        Otherwise:
            Return 0.0
    
    Let pi_str be Constants.get_pi(config.precision)
    Let two_x be Operations.multiply("2.0", String(x), config.precision).result_value
    Let pi_over_two_x be Operations.divide(pi_str, two_x, config.precision).result_value
    Let sqrt_factor be Operations.square_root(pi_over_two_x, config.precision).result_value
    
    Let nu be BigDecimal.to_float(String(n)) plus 0.5
    Let j_nu_half be compute_bessel_j(nu, x, config).value
    
    Let result be Operations.multiply(sqrt_factor, String(j_nu_half), config.precision).result_value
    Return BigDecimal.to_float(result)

Process called "compute_spherical_bessel_y" that takes n as Integer, x as Float, config as BesselConfig returns Float:
    Note: Compute spherical Bessel function y_n(x) is equal to √(π/2x) Y_{n+1/2}(x)
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        Throw Errors.InvalidOperation with "Spherical Bessel y function has singularity at x=0"
    
    Let pi_str be Constants.get_pi(config.precision)
    Let two_x be Operations.multiply("2.0", String(x), config.precision).result_value
    Let pi_over_two_x be Operations.divide(pi_str, two_x, config.precision).result_value
    Let sqrt_factor be Operations.square_root(pi_over_two_x, config.precision).result_value
    
    Let nu be BigDecimal.to_float(String(n)) plus 0.5
    Let y_nu_half be compute_bessel_y(nu, x, config).value
    
    Let result be Operations.multiply(sqrt_factor, String(y_nu_half), config.precision).result_value
    Return BigDecimal.to_float(result)

Process called "compute_spherical_hankel_first" that takes n as Integer, x as Float, config as BesselConfig returns Dictionary[String, Float]:
    Note: Compute spherical Hankel function of first kind h^(1)_n(x) is equal to j_n(x) plus iy_n(x)
    
    Let result be Dictionary[String, Float]
    
    Let j_n be compute_spherical_bessel_j(n, x, config)
    Let y_n be compute_spherical_bessel_y(n, x, config)
    
    Set result["real_part"] to j_n
    Set result["imaginary_part"] to y_n
    
    Let magnitude_squared be j_n multiplied by j_n plus y_n multiplied by y_n
    Set result["magnitude"] to Operations.square_root(String(magnitude_squared), config.precision).result_value
    
    Let argument be 0.0
    If j_n does not equal 0.0 or y_n does not equal 0.0:
        Set argument to BigDecimal.to_float(Trigonometry.arctangent2(String(y_n), String(j_n), config.precision, "radians").function_value)
    Set result["argument"] to argument
    
    Return result

Process called "compute_spherical_hankel_second" that takes n as Integer, x as Float, config as BesselConfig returns Dictionary[String, Float]:
    Note: Compute spherical Hankel function of second kind h^(2)_n(x) is equal to j_n(x) minus iy_n(x)
    
    Let result be Dictionary[String, Float]
    
    Let j_n be compute_spherical_bessel_j(n, x, config)
    Let y_n be compute_spherical_bessel_y(n, x, config)
    
    Set result["real_part"] to j_n
    Set result["imaginary_part"] to -y_n
    
    Let magnitude_squared be j_n multiplied by j_n plus y_n multiplied by y_n
    Set result["magnitude"] to Operations.square_root(String(magnitude_squared), config.precision).result_value
    
    Let argument be 0.0
    If j_n does not equal 0.0 or y_n does not equal 0.0:
        Set argument to BigDecimal.to_float(Trigonometry.arctangent2(String(-y_n), String(j_n), config.precision, "radians").function_value)
    Set result["argument"] to argument
    
    Return result

Note: =====================================================================
Note: AIRY FUNCTIONS OPERATIONS
Note: =====================================================================

Process called "compute_airy_ai" that takes x as Float, config as BesselConfig returns BesselResult:
    Note: Compute Airy function Ai(x) using power series, asymptotic expansions, and integral representations
    Note: Ai(x) is equal to (1/π) multiplied by ∫[0,∞] cos(t³/3 plus xt) dt, connected to Bessel functions via Ai(x) is equal to (1/3)√(x/3)[I_{-1/3}(2x^{3/2}/3) minus I_{1/3}(2x^{3/2}/3)]
    
    Let result be BesselResult
    Set result.method_used to "bessel_connection"
    Set result.convergence_status to "converged"
    Set result.derivative_values to []
    
    Let x_str be String(x)
    
    If x is less than -8.0:
        Let abs_x be Operations.absolute_value(x_str, config.precision).result_value
        Let abs_x_to_three_halves be BigDecimal.power_function(abs_x, "1.5", config.precision)
        Let two_thirds_abs_x_to_three_halves be Operations.multiply("0.6666666666666666", abs_x_to_three_halves, config.precision).result_value
        
        Let sqrt_abs_x_over_three be Operations.divide(Operations.square_root(abs_x, config.precision).result_value, "1.7320508075688772", config.precision).result_value
        
        Let j_one_third be compute_bessel_j(0.3333333333333333, BigDecimal.to_float(two_thirds_abs_x_to_three_halves), config).value
        Let j_minus_one_third be compute_bessel_j(-0.3333333333333333, BigDecimal.to_float(two_thirds_abs_x_to_three_halves), config).value
        
        Let sum_j be Operations.add(String(j_one_third), String(j_minus_one_third), config.precision).result_value
        Let airy_value be Operations.multiply(sqrt_abs_x_over_three, sum_j, config.precision).result_value
        
        Set result.value to BigDecimal.to_float(airy_value)
        Set result.method_used to "bessel_j_connection"
    Otherwise if x is greater than or equal to 8.0:
        Let x_to_three_halves be BigDecimal.power_function(x_str, "1.5", config.precision)
        Let two_thirds_x_to_three_halves be Operations.multiply("0.6666666666666666", x_to_three_halves, config.precision).result_value
        
        Let sqrt_x_over_three be Operations.divide(Operations.square_root(x_str, config.precision).result_value, "1.7320508075688772", config.precision).result_value
        
        Let i_one_third be compute_modified_bessel_i(0.3333333333333333, BigDecimal.to_float(two_thirds_x_to_three_halves), config).value
        Let i_minus_one_third be compute_modified_bessel_i(-0.3333333333333333, BigDecimal.to_float(two_thirds_x_to_three_halves), config).value
        
        Let diff_i be Operations.subtract(String(i_minus_one_third), String(i_one_third), config.precision).result_value
        Let airy_value be Operations.multiply(Operations.multiply("0.3333333333333333", sqrt_x_over_three, config.precision).result_value, diff_i, config.precision).result_value
        
        Set result.value to BigDecimal.to_float(airy_value)
        Set result.method_used to "modified_bessel_connection"
    Otherwise:
        Let airy_series be compute_airy_ai_series(x, config.max_iterations)
        Set result.value to BigDecimal.to_float(airy_series)
        Set result.method_used to "power_series"
    
    Set result.error_estimate to BigDecimal.to_float("1e-" plus String(config.precision minus 2))
    Set result.iterations_used to config.max_iterations
    
    Return result

Process called "compute_airy_bi" that takes x as Float, config as BesselConfig returns BesselResult:
    Note: Compute Airy function Bi(x) with exponential growth handling for positive arguments
    Note: Bi(x) is equal to √(x/3) multiplied by [I_{1/3}(2x^{3/2}/3) plus I_{-1/3}(2x^{3/2}/3)] for x is greater than 0
    
    Let result be BesselResult
    Set result.method_used to "bessel_connection"
    Set result.convergence_status to "converged"
    Set result.derivative_values to []
    
    Let x_str be String(x)
    
    If x is less than -8.0:
        Let abs_x be Operations.absolute_value(x_str, config.precision).result_value
        Let abs_x_to_three_halves be BigDecimal.power_function(abs_x, "1.5", config.precision)
        Let two_thirds_abs_x_to_three_halves be Operations.multiply("0.6666666666666666", abs_x_to_three_halves, config.precision).result_value
        
        Let sqrt_abs_x_over_three be Operations.divide(Operations.square_root(abs_x, config.precision).result_value, "1.7320508075688772", config.precision).result_value
        
        Let j_one_third be compute_bessel_j(0.3333333333333333, BigDecimal.to_float(two_thirds_abs_x_to_three_halves), config).value
        Let j_minus_one_third be compute_bessel_j(-0.3333333333333333, BigDecimal.to_float(two_thirds_abs_x_to_three_halves), config).value
        
        Let diff_j be Operations.subtract(String(j_one_third), String(j_minus_one_third), config.precision).result_value
        Let airy_value be Operations.multiply(sqrt_abs_x_over_three, diff_j, config.precision).result_value
        
        Set result.value to BigDecimal.to_float(airy_value)
        Set result.method_used to "bessel_j_connection"
    Otherwise if x is greater than or equal to 8.0:
        Let x_to_three_halves be BigDecimal.power_function(x_str, "1.5", config.precision)
        Let two_thirds_x_to_three_halves be Operations.multiply("0.6666666666666666", x_to_three_halves, config.precision).result_value
        
        Let sqrt_x_over_three be Operations.divide(Operations.square_root(x_str, config.precision).result_value, "1.7320508075688772", config.precision).result_value
        
        Let i_one_third be compute_modified_bessel_i(0.3333333333333333, BigDecimal.to_float(two_thirds_x_to_three_halves), config).value
        Let i_minus_one_third be compute_modified_bessel_i(-0.3333333333333333, BigDecimal.to_float(two_thirds_x_to_three_halves), config).value
        
        Let sum_i be Operations.add(String(i_one_third), String(i_minus_one_third), config.precision).result_value
        Let airy_value be Operations.multiply(sqrt_x_over_three, sum_i, config.precision).result_value
        
        Set result.value to BigDecimal.to_float(airy_value)
        Set result.method_used to "modified_bessel_connection"
    Otherwise:
        Let airy_series be compute_airy_bi_series(x, config.max_iterations)
        Set result.value to BigDecimal.to_float(airy_series)
        Set result.method_used to "power_series"
    
    Set result.error_estimate to BigDecimal.to_float("1e-" plus String(config.precision minus 2))
    Set result.iterations_used to config.max_iterations
    
    Return result

Process called "compute_airy_ai_derivative" that takes x as Float, config as BesselConfig returns Float:
    Note: Compute derivative of Airy function Ai'(x) using differentiation formulas
    Note: Ai'(x) is equal to -x multiplied by Ai(x) plus (1/π) multiplied by ∫[0,∞] t multiplied by sin(t³/3 plus xt) dt
    
    Let h be 1e-8
    Let x_plus_h be x plus h
    Let x_minus_h be x minus h
    
    Let ai_plus be compute_airy_ai(x_plus_h, config).value
    Let ai_minus be compute_airy_ai(x_minus_h, config).value
    
    Let derivative be Operations.divide(Operations.subtract(String(ai_plus), String(ai_minus), config.precision).result_value, String(2.0 multiplied by h), config.precision).result_value
    
    Return BigDecimal.to_float(derivative)

Process called "compute_airy_bi_derivative" that takes x as Float, config as BesselConfig returns Float:
    Note: Compute derivative of Airy function Bi'(x) with numerical stability considerations
    
    Let h be 1e-8
    Let x_plus_h be x plus h
    Let x_minus_h be x minus h
    
    Let bi_plus be compute_airy_bi(x_plus_h, config).value
    Let bi_minus be compute_airy_bi(x_minus_h, config).value
    
    Let derivative be Operations.divide(Operations.subtract(String(bi_plus), String(bi_minus), config.precision).result_value, String(2.0 multiplied by h), config.precision).result_value
    
    Return BigDecimal.to_float(derivative)

Process called "compute_airy_zeros" that takes function_type as String, n_zeros as Integer returns BesselZeros:
    Note: Compute zeros of Airy functions and their derivatives using asymptotic formulas
    Note: Uses WKB approximation: a_k ≈ -((3π(4k-1))/8)^(2/3) for Ai(x), a'_k ≈ -((3π(4k-3))/8)^(2/3) for Ai'(x)
    
    Let result be BesselZeros
    Set result.function_type to function_type
    Set result.order to 0.0
    Set result.zeros_list to []
    Set result.accuracy to 1e-12
    Set result.computation_method to "wkb_asymptotic"
    
    Let pi_str be Constants.get_pi(50)
    
    Let k be 1
    While k is less than or equal to n_zeros:
        Let zero_estimate be 0.0
        
        If function_type is equal to "airy_ai":
            Let four_k_minus_one be 4.0 multiplied by BigDecimal.to_float(String(k)) minus 1.0
            Let three_pi_times_factor be Operations.multiply("3.0", Operations.multiply(pi_str, String(four_k_minus_one), 50).result_value, 50).result_value
            Let eight_divisor be Operations.divide(three_pi_times_factor, "8.0", 50).result_value
            Let two_thirds_power be BigDecimal.power_function(eight_divisor, "0.6666666666666666", 50)
            Set zero_estimate to -BigDecimal.to_float(two_thirds_power)
        
        Otherwise if function_type is equal to "airy_ai_derivative":
            Let four_k_minus_three be 4.0 multiplied by BigDecimal.to_float(String(k)) minus 3.0
            Let three_pi_times_factor be Operations.multiply("3.0", Operations.multiply(pi_str, String(four_k_minus_three), 50).result_value, 50).result_value
            Let eight_divisor be Operations.divide(three_pi_times_factor, "8.0", 50).result_value
            Let two_thirds_power be BigDecimal.power_function(eight_divisor, "0.6666666666666666", 50)
            Set zero_estimate to -BigDecimal.to_float(two_thirds_power)
        
        Otherwise if function_type is equal to "airy_bi":
            Let four_k_minus_three be 4.0 multiplied by BigDecimal.to_float(String(k)) minus 3.0
            Let three_pi_times_factor be Operations.multiply("3.0", Operations.multiply(pi_str, String(four_k_minus_three), 50).result_value, 50).result_value
            Let eight_divisor be Operations.divide(three_pi_times_factor, "8.0", 50).result_value
            Let two_thirds_power be BigDecimal.power_function(eight_divisor, "0.6666666666666666", 50)
            Set zero_estimate to -BigDecimal.to_float(two_thirds_power)
        
        Otherwise if function_type is equal to "airy_bi_derivative":
            Let four_k_minus_one be 4.0 multiplied by BigDecimal.to_float(String(k)) minus 1.0
            Let three_pi_times_factor be Operations.multiply("3.0", Operations.multiply(pi_str, String(four_k_minus_one), 50).result_value, 50).result_value
            Let eight_divisor be Operations.divide(three_pi_times_factor, "8.0", 50).result_value
            Let two_thirds_power be BigDecimal.power_function(eight_divisor, "0.6666666666666666", 50)
            Set zero_estimate to -BigDecimal.to_float(two_thirds_power)
        
        If zero_estimate does not equal 0.0:
            Let zeros_copy be result.zeros_list
            Set result.zeros_list to zeros_copy plus [zero_estimate]
        
        Set k to k plus 1
    
    Return result

Note: =====================================================================
Note: KELVIN FUNCTIONS OPERATIONS
Note: =====================================================================

Process called "compute_kelvin_ber" that takes x as Float, config as BesselConfig returns Float:
    Note: Compute Kelvin function ber(x) minus real part of J_0(xe^{3πi/4})
    Note: ber(x) is equal to Σ(k=0 to ∞) [(-1)^k multiplied by (x/2)^{4k}] / [(2k)!]^2 multiplied by cos(kπ)
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        Return 1.0
    
    Let x_str be String(x)
    Let half_x be Operations.divide(x_str, "2.0", config.precision).result_value
    Let quarter_x_fourth be BigDecimal.power_function(Operations.multiply(Operations.multiply(half_x, half_x, config.precision).result_value, Operations.multiply(half_x, half_x, config.precision).result_value, config.precision).result_value, "1.0", config.precision)
    
    Let sum be BigDecimal.create_from_string("1.0", BigDecimal.MathContext)
    Let pi_str be Constants.get_pi(config.precision)
    
    Let k be 1
    While k is less than or equal to config.max_iterations:
        Let two_k_factorial be Gamma.compute_factorial(2 multiplied by k, Gamma.FactorialConfig).factorial_value
        Let two_k_factorial_squared is equal to Operations.multiply(two_k_factorial, two_k_factorial, config.precision).result_value
        
        Let x_fourth_power_k be BigDecimal.power_function(quarter_x_fourth, String(k), config.precision)
        Let k_pi be Operations.multiply(String(k), pi_str, config.precision).result_value
        Let cos_k_pi be Trigonometry.cosine(k_pi, "radians", config.precision).function_value
        
        Let numerator be Operations.multiply(x_fourth_power_k, cos_k_pi, config.precision).result_value
        Let term be Operations.divide(numerator, two_k_factorial_squared, config.precision).result_value
        
        If k % 2 is equal to 1:
            Set term to Operations.multiply("-1.0", term, config.precision).result_value
        
        Set sum to BigDecimal.add(sum, BigDecimal.create_from_string(term, BigDecimal.MathContext))
        
        Let term_abs be Operations.absolute_value(term, config.precision).result_value
        If BigDecimal.compare(term_abs, "1e-" plus String(config.precision minus 5)) is less than 0:
            Break
        
        Set k to k plus 1
    
    Return BigDecimal.to_float(BigDecimal.to_plain_string(sum))

Process called "compute_kelvin_bei" that takes x as Float, config as BesselConfig returns Float:
    Note: Compute Kelvin function bei(x) minus imaginary part of J_0(xe^{3πi/4})
    Note: bei(x) is equal to Σ(k=0 to ∞) [(-1)^k multiplied by (x/2)^{4k+2}] / [(2k+1)!]^2 multiplied by sin((2k+1)π/2)
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        Return 0.0
    
    Let x_str be String(x)
    Let half_x be Operations.divide(x_str, "2.0", config.precision).result_value
    Let half_x_squared be Operations.multiply(half_x, half_x, config.precision).result_value
    
    Let sum be BigDecimal.create_from_string("0.0", BigDecimal.MathContext)
    Let pi_str be Constants.get_pi(config.precision)
    
    Let k be 0
    While k is less than or equal to config.max_iterations:
        Let two_k_plus_one_factorial be Gamma.compute_factorial(2 multiplied by k plus 1, Gamma.FactorialConfig).factorial_value
        Let factorial_squared is equal to Operations.multiply(two_k_plus_one_factorial, two_k_plus_one_factorial, config.precision).result_value
        
        Let x_power_4k_plus_2 be BigDecimal.power_function(half_x_squared, String(2 multiplied by k plus 1), config.precision)
        Let angle is equal to Operations.multiply(String(2 multiplied by k plus 1), Operations.divide(pi_str, "2.0", config.precision).result_value, config.precision).result_value
        Let sin_angle be Trigonometry.sine(angle, "radians", config.precision).function_value
        
        Let numerator be Operations.multiply(x_power_4k_plus_2, sin_angle, config.precision).result_value
        Let term be Operations.divide(numerator, factorial_squared, config.precision).result_value
        
        If k % 2 is equal to 1:
            Set term to Operations.multiply("-1.0", term, config.precision).result_value
        
        Set sum to BigDecimal.add(sum, BigDecimal.create_from_string(term, BigDecimal.MathContext))
        
        Let term_abs be Operations.absolute_value(term, config.precision).result_value
        If BigDecimal.compare(term_abs, "1e-" plus String(config.precision minus 5)) is less than 0:
            Break
        
        Set k to k plus 1
    
    Return BigDecimal.to_float(BigDecimal.to_plain_string(sum))

Process called "compute_kelvin_ker" that takes x as Float, config as BesselConfig returns Float:
    Note: Compute Kelvin function ker(x) minus real part of K_0(xe^{πi/4})
    Note: ker(x) has logarithmic behavior near x=0 and exponential decay for large x
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        Throw Errors.InvalidOperation with "Kelvin ker function has logarithmic singularity at x=0"
    
    Let x_str be String(x)
    Let sqrt_2 be "1.4142135623730951"
    
    If x is less than 8.0:
        Let euler_gamma_str be Constants.get_euler_gamma(config.precision)
        Let ln_half_x be BigDecimal.natural_log(Operations.divide(x_str, "2.0", config.precision).result_value, config.precision)
        
        Let ber_x be compute_kelvin_ber(x, config)
        Let bei_x be compute_kelvin_bei(x, config)
        
        Let log_term be Operations.add(ln_half_x, euler_gamma_str, config.precision).result_value
        Let cos_term be Operations.multiply(String(ber_x), log_term, config.precision).result_value
        Let sin_term be Operations.multiply(String(bei_x), Operations.multiply(Constants.get_pi(config.precision), "0.25", config.precision).result_value, config.precision).result_value
        
        Let result is equal to Operations.subtract(cos_term, sin_term, config.precision).result_value
        Return BigDecimal.to_float(result)
    Otherwise:
        Let sqrt_pi_over_2x be Operations.square_root(Operations.divide(Constants.get_pi(config.precision), Operations.multiply("2.0", x_str, config.precision).result_value, config.precision).result_value, config.precision).result_value
        Let neg_x_over_sqrt_2 be Operations.multiply("-1.0", Operations.divide(x_str, sqrt_2, config.precision).result_value, config.precision).result_value
        Let exp_term be BigDecimal.exponential_function(neg_x_over_sqrt_2, config.precision)
        Let cos_term be Trigonometry.cosine(Operations.subtract(Operations.divide(x_str, sqrt_2, config.precision).result_value, Operations.divide(Constants.get_pi(config.precision), "8.0", config.precision).result_value, config.precision).result_value, "radians", config.precision).function_value
        
        Let result is equal to Operations.multiply(Operations.multiply(sqrt_pi_over_2x, exp_term, config.precision).result_value, cos_term, config.precision).result_value
        Return BigDecimal.to_float(result)

Process called "compute_kelvin_kei" that takes x as Float, config as BesselConfig returns Float:
    Note: Compute Kelvin function kei(x) minus imaginary part of K_0(xe^{πi/4})
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        Throw Errors.InvalidOperation with "Kelvin kei function has logarithmic singularity at x=0"
    
    Let x_str be String(x)
    Let sqrt_2 be "1.4142135623730951"
    
    If x is less than 8.0:
        Let euler_gamma_str be Constants.get_euler_gamma(config.precision)
        Let ln_half_x be BigDecimal.natural_log(Operations.divide(x_str, "2.0", config.precision).result_value, config.precision)
        
        Let ber_x be compute_kelvin_ber(x, config)
        Let bei_x be compute_kelvin_bei(x, config)
        
        Let log_term be Operations.add(ln_half_x, euler_gamma_str, config.precision).result_value
        Let sin_term be Operations.multiply(String(bei_x), log_term, config.precision).result_value
        Let cos_term be Operations.multiply(String(ber_x), Operations.multiply(Constants.get_pi(config.precision), "0.25", config.precision).result_value, config.precision).result_value
        
        Let result is equal to Operations.add(sin_term, cos_term, config.precision).result_value
        Return BigDecimal.to_float(result)
    Otherwise:
        Let sqrt_pi_over_2x be Operations.square_root(Operations.divide(Constants.get_pi(config.precision), Operations.multiply("2.0", x_str, config.precision).result_value, config.precision).result_value, config.precision).result_value
        Let neg_x_over_sqrt_2 be Operations.multiply("-1.0", Operations.divide(x_str, sqrt_2, config.precision).result_value, config.precision).result_value
        Let exp_term be BigDecimal.exponential_function(neg_x_over_sqrt_2, config.precision)
        Let sin_term be Trigonometry.sine(Operations.subtract(Operations.divide(x_str, sqrt_2, config.precision).result_value, Operations.divide(Constants.get_pi(config.precision), "8.0", config.precision).result_value, config.precision).result_value, "radians", config.precision).function_value
        
        Let result is equal to Operations.multiply(Operations.multiply(sqrt_pi_over_2x, exp_term, config.precision).result_value, sin_term, config.precision).result_value
        Return BigDecimal.to_float(result)

Note: =====================================================================
Note: STRUVE FUNCTIONS OPERATIONS
Note: =====================================================================

Process called "compute_struve_h" that takes nu as Float, x as Float, config as BesselConfig returns Float:
    Note: Compute Struve function H_ν(x) using power series and asymptotic methods
    Note: H_ν(x) is equal to (x/2)^{ν+1} multiplied by Σ(k=0 to ∞) [(-1)^k multiplied by (x/2)^{2k}] / [Γ(k plus 3/2) multiplied by Γ(k plus ν plus 3/2)]
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        If nu is greater than -1.0:
            Return 0.0
        Otherwise:
            Throw Errors.InvalidOperation with "Struve H function undefined for x=0 and ν ≤ -1"
    
    Let x_str be String(x)
    Let half_x be Operations.divide(x_str, "2.0", config.precision).result_value
    Let half_x_to_nu_plus_1 be BigDecimal.power_function(half_x, String(nu plus 1.0), config.precision)
    
    Let gamma_config be Gamma.GammaConfig
    Set gamma_config.precision to config.precision
    Set gamma_config.max_iterations to 100
    Set gamma_config.convergence_threshold to 1e-50
    Set gamma_config.series_method to "lanczos"
    Set gamma_config.asymptotic_threshold to 20.0
    Set gamma_config.lanczos_coefficients to []
    Set gamma_config.stirling_corrections to []
    
    Let sum be BigDecimal.create_from_string("0.0", BigDecimal.MathContext)
    Let quarter_x_squared be Operations.divide(Operations.multiply(x_str, x_str, config.precision).result_value, "4.0", config.precision).result_value
    
    Let k be 0
    While k is less than or equal to config.max_iterations:
        Let gamma_k_plus_1_5 be Gamma.compute_gamma(BigDecimal.to_float(String(k)) plus 1.5, gamma_config).value
        Let gamma_k_plus_nu_plus_1_5 be Gamma.compute_gamma(BigDecimal.to_float(String(k)) plus nu plus 1.5, gamma_config).value
        
        Let numerator be BigDecimal.power_function(quarter_x_squared, String(k), config.precision)
        If k % 2 is equal to 1:
            Set numerator to Operations.multiply("-1.0", numerator, config.precision).result_value
        
        Let denominator be Operations.multiply(String(gamma_k_plus_1_5), String(gamma_k_plus_nu_plus_1_5), config.precision).result_value
        Let term be Operations.divide(numerator, denominator, config.precision).result_value
        
        Set sum to BigDecimal.add(sum, BigDecimal.create_from_string(term, BigDecimal.MathContext))
        
        Let term_abs be Operations.absolute_value(term, config.precision).result_value
        If BigDecimal.compare(term_abs, "1e-" plus String(config.precision minus 5)) is less than 0:
            Break
        
        Set k to k plus 1
    
    Let result is equal to Operations.multiply(half_x_to_nu_plus_1, BigDecimal.to_plain_string(sum), config.precision).result_value
    Return BigDecimal.to_float(result)

Process called "compute_struve_l" that takes nu as Float, x as Float, config as BesselConfig returns Float:
    Note: Compute modified Struve function L_ν(x) with exponential scaling options
    Note: L_ν(x) is equal to (x/2)^{ν+1} multiplied by Σ(k=0 to ∞) [(x/2)^{2k}] / [Γ(k plus 3/2) multiplied by Γ(k plus ν plus 3/2)]
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        If nu is greater than -1.0:
            Return 0.0
        Otherwise:
            Throw Errors.InvalidOperation with "Modified Struve L function undefined for x=0 and ν ≤ -1"
    
    Let x_str be String(x)
    Let half_x be Operations.divide(x_str, "2.0", config.precision).result_value
    Let half_x_to_nu_plus_1 be BigDecimal.power_function(half_x, String(nu plus 1.0), config.precision)
    
    Let gamma_config be Gamma.GammaConfig
    Set gamma_config.precision to config.precision
    Set gamma_config.max_iterations to 100
    Set gamma_config.convergence_threshold to 1e-50
    Set gamma_config.series_method to "lanczos"
    Set gamma_config.asymptotic_threshold to 20.0
    Set gamma_config.lanczos_coefficients to []
    Set gamma_config.stirling_corrections to []
    
    Let sum be BigDecimal.create_from_string("0.0", BigDecimal.MathContext)
    Let quarter_x_squared be Operations.divide(Operations.multiply(x_str, x_str, config.precision).result_value, "4.0", config.precision).result_value
    
    Let k be 0
    While k is less than or equal to config.max_iterations:
        Let gamma_k_plus_1_5 be Gamma.compute_gamma(BigDecimal.to_float(String(k)) plus 1.5, gamma_config).value
        Let gamma_k_plus_nu_plus_1_5 be Gamma.compute_gamma(BigDecimal.to_float(String(k)) plus nu plus 1.5, gamma_config).value
        
        Let numerator be BigDecimal.power_function(quarter_x_squared, String(k), config.precision)
        Let denominator be Operations.multiply(String(gamma_k_plus_1_5), String(gamma_k_plus_nu_plus_1_5), config.precision).result_value
        Let term be Operations.divide(numerator, denominator, config.precision).result_value
        
        Set sum to BigDecimal.add(sum, BigDecimal.create_from_string(term, BigDecimal.MathContext))
        
        Let term_abs be Operations.absolute_value(term, config.precision).result_value
        If BigDecimal.compare(term_abs, "1e-" plus String(config.precision minus 5)) is less than 0:
            Break
        
        Set k to k plus 1
    
    Let result is equal to Operations.multiply(half_x_to_nu_plus_1, BigDecimal.to_plain_string(sum), config.precision).result_value
    Return BigDecimal.to_float(result)

Process called "compute_struve_weber_integral" that takes nu as Float, x as Float, config as BesselConfig returns Float:
    Note: Compute Weber integral representation of Struve function
    Note: H_ν(x) is equal to (2/π) multiplied by (x/2)^ν multiplied by ∫[0,π/2] sin(x*cos(t)) multiplied by sin²ν(t) dt
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        Return 0.0
    
    Let x_str be String(x)
    Let pi_str be Constants.get_pi(config.precision)
    Let pi_over_2 be Operations.divide(pi_str, "2.0", config.precision).result_value
    Let two_over_pi be Operations.divide("2.0", pi_str, config.precision).result_value
    
    Let half_x_to_nu be BigDecimal.power_function(Operations.divide(x_str, "2.0", config.precision).result_value, String(nu), config.precision)
    
    Let integral_sum be BigDecimal.create_from_string("0.0", BigDecimal.MathContext)
    Let n_points be 100
    Let dt be Operations.divide(pi_over_2, String(n_points), config.precision).result_value
    
    Let i be 0
    While i is less than or equal to n_points:
        Let t is equal to Operations.multiply(String(i), dt, config.precision).result_value
        Let cos_t is equal to Trigonometry.cosine(t, "radians", config.precision).function_value
        Let sin_t is equal to Trigonometry.sine(t, "radians", config.precision).function_value
        
        Let x_cos_t is equal to Operations.multiply(x_str, cos_t, config.precision).result_value
        Let sin_x_cos_t is equal to Trigonometry.sine(x_cos_t, "radians", config.precision).function_value
        
        Let sin_t_to_2nu is equal to BigDecimal.power_function(sin_t, String(2.0 multiplied by nu), config.precision)
        
        Let integrand is equal to Operations.multiply(sin_x_cos_t, sin_t_to_2nu, config.precision).result_value
        
        Let weight is equal to "1.0"
        If i is equal to 0 or i is equal to n_points:
            Set weight to "0.5"
        
        Let weighted_integrand is equal to Operations.multiply(integrand, weight, config.precision).result_value
        Set integral_sum to BigDecimal.add(integral_sum, BigDecimal.create_from_string(weighted_integrand, BigDecimal.MathContext))
        
        Set i to i plus 1
    
    Let integral_value is equal to Operations.multiply(BigDecimal.to_plain_string(integral_sum), dt, config.precision).result_value
    Let prefactor is equal to Operations.multiply(two_over_pi, half_x_to_nu, config.precision).result_value
    Let result is equal to Operations.multiply(prefactor, integral_value, config.precision).result_value
    
    Return BigDecimal.to_float(result)

Note: =====================================================================
Note: RECURRENCE AND CONTINUED FRACTIONS
Note: =====================================================================

Process called "apply_bessel_recurrence_forward" that takes nu as Float, x as Float, initial_values as List[Float], n_terms as Integer returns List[Float]:
    Note: Apply forward recurrence relation for Bessel functions with stability analysis
    Note: J_{ν+1}(x) is equal to (2ν/x)J_ν(x) minus J_{ν-1}(x)
    
    If initial_values.length is less than 2:
        Throw Errors.InvalidOperation with "Forward recurrence requires at least 2 initial values"
    
    Let result_list be initial_values
    Let current_nu be nu plus 1.0
    
    Let k be 2
    While k is less than n_terms:
        Let j_nu_minus_1 be result_list[k minus 2]
        Let j_nu be result_list[k minus 1]
        
        Let two_nu_over_x be Operations.divide(Operations.multiply("2.0", String(current_nu), 50).result_value, String(x), 50).result_value
        Let middle_term be Operations.multiply(two_nu_over_x, String(j_nu), 50).result_value
        Let j_nu_plus_1 be Operations.subtract(middle_term, String(j_nu_minus_1), 50).result_value
        
        Let result_copy be result_list
        Set result_list to result_copy plus [BigDecimal.to_float(j_nu_plus_1)]
        
        Set current_nu to current_nu plus 1.0
        Set k to k plus 1
    
    Return result_list

Process called "apply_bessel_recurrence_backward" that takes nu as Float, x as Float, starting_order as Integer, n_terms as Integer returns List[Float]:
    Note: Apply backward recurrence relation for stable computation of Bessel function sequences
    Note: Uses Miller's algorithm: J_{ν-1}(x) is equal to (2ν/x)J_ν(x) minus J_{ν+1}(x)
    
    Let result_array be Array[Float](n_terms)
    
    Let high_order_nu be nu plus BigDecimal.to_float(String(starting_order))
    Set result_array[starting_order] to 0.0
    Set result_array[starting_order minus 1] to 1.0
    
    Let current_nu be high_order_nu minus 1.0
    Let k be starting_order minus 2
    
    While k is greater than or equal to 0:
        Let two_nu_plus_one_over_x be Operations.divide(Operations.multiply("2.0", String(current_nu plus 1.0), 50).result_value, String(x), 50).result_value
        Let middle_term be Operations.multiply(two_nu_plus_one_over_x, String(result_array[k plus 1]), 50).result_value
        Let j_nu_minus_1 be Operations.subtract(middle_term, String(result_array[k plus 2]), 50).result_value
        
        Set result_array[k] to BigDecimal.to_float(j_nu_minus_1)
        
        Set current_nu to current_nu minus 1.0
        Set k to k minus 1
    
    Let normalization_sum be 0.0
    For i from 0 to starting_order:
        Set normalization_sum to normalization_sum plus Operations.absolute_value(String(result_array[i]), 50).result_value
    
    For i from 0 to starting_order:
        Set result_array[i] to result_array[i] / BigDecimal.to_float(normalization_sum)
    
    Let result_list be []
    For i from 0 to starting_order:
        Set result_list to result_list plus [result_array[i]]
    
    Return result_list

Process called "compute_bessel_continued_fraction" that takes nu as Float, x as Float, max_terms as Integer returns Float:
    Note: Compute Bessel function ratios using continued fraction expansions
    Note: Uses Steed's method for stable evaluation of J_{ν+1}(x)/J_ν(x) or I_{ν+1}(x)/I_ν(x)
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        Return 0.0
    
    Let x_str be String(x)
    Let nu_str be String(nu)
    Let precision be 50
    
    Note: Initialize continued fraction using backward recurrence
    Let b_n be BigDecimal.create_from_string("0.0", BigDecimal.MathContext)
    Let b_n_minus_1 be BigDecimal.create_from_string("1.0", BigDecimal.MathContext)
    
    Note: Compute coefficients for J_{ν+1}/J_ν continued fraction
    Note: CF: a_1/(1 plus a_2/(1 plus a_3/(1 plus ...))) where a_n is equal to -x²/[4n(n+ν)]
    
    Let n be max_terms
    While n is greater than or equal to 1:
        Let two_n_str be String(2.0 multiplied by BigDecimal.to_float(String(n)))
        Let n_plus_nu is equal to Operations.add(String(n), nu_str, precision).result_value
        Let four_n_times_n_plus_nu is equal to Operations.multiply("4.0", Operations.multiply(String(n), n_plus_nu, precision).result_value, precision).result_value
        
        Let x_squared be Operations.multiply(x_str, x_str, precision).result_value
        Let a_n is equal to Operations.divide(Operations.multiply("-1.0", x_squared, precision).result_value, four_n_times_n_plus_nu, precision).result_value
        
        Let temp be BigDecimal.add(BigDecimal.create_from_string("1.0", BigDecimal.MathContext), BigDecimal.divide(BigDecimal.create_from_string(a_n, BigDecimal.MathContext), b_n_minus_1))
        Set b_n to BigDecimal.divide(BigDecimal.create_from_string("1.0", BigDecimal.MathContext), temp)
        Set b_n_minus_1 to b_n
        
        Set n to n minus 1
    
    Note: Apply initial coefficient for the continued fraction
    Let two_nu_plus_2 is equal to Operations.add(Operations.multiply("2.0", nu_str, precision).result_value, "2.0", precision).result_value
    Let initial_coeff is equal to Operations.divide(x_str, two_nu_plus_2, precision).result_value
    
    Let result is equal to Operations.multiply(initial_coeff, BigDecimal.to_plain_string(b_n), precision).result_value
    Return BigDecimal.to_float(result)

Process called "optimize_recurrence_direction" that takes nu as Float, x as Float, target_orders as List[Float] returns String:
    Note: Determine optimal recurrence direction for stable Bessel function computation
    Note: Uses stability analysis to choose forward vs backward recurrence for minimal error
    
    Let x_str be String(x)
    Let nu_str be String(nu)
    
    Note: Find minimum and maximum target orders
    Let min_order be target_orders[0]
    Let max_order be target_orders[0]
    Let i be 1
    While i is less than target_orders.length:
        If target_orders[i] is less than min_order:
            Set min_order to target_orders[i]
        If target_orders[i] is greater than max_order:
            Set max_order to target_orders[i]
        Set i to i plus 1
    
    Note: Miller's algorithm stability criterion
    Note: Forward recurrence stable when x is greater than ν, backward stable when x is less than ν
    Let x_abs be Operations.absolute_value(x_str, 20).result_value
    Let dominant_order is equal to Operations.maximum(Operations.absolute_value(String(min_order), 20).result_value, Operations.absolute_value(String(max_order), 20).result_value)
    
    Note: Stability analysis based on argument ranges
    If BigDecimal.compare(x_abs, dominant_order) is greater than 0:
        Note: x is greater than ν regime: forward recurrence is stable
        If nu is greater than or equal to min_order:
            Return "forward"
        Otherwise:
            Return "mixed"
    Otherwise:
        Note: x is less than ν regime: backward recurrence is stable  
        If nu is less than or equal to max_order:
            Return "backward"
        Otherwise:
            Return "mixed"
    
    Note: For borderline cases, use mixed strategy
    Return "mixed"

Process called "compute_airy_ai_series" that takes x as Float, terms as Integer returns String:
    Note: Compute Airy Ai function using power series expansion
    
    Let c1 be "0.35502805388781724"
    Let c2 be "0.25881940379280676"
    Let x_str be String(x)
    
    Let series1_sum be BigDecimal.create_from_string("1.0", BigDecimal.MathContext)
    Let series2_sum be BigDecimal.create_from_string("1.0", BigDecimal.MathContext)
    
    Let k be 1
    While k is less than or equal to terms:
        Let three_k be 3 multiplied by k
        Let three_k_factorial be Gamma.compute_factorial(three_k, Gamma.FactorialConfig).factorial_value
        Let three_k_plus_one_factorial be Gamma.compute_factorial(three_k plus 1, Gamma.FactorialConfig).factorial_value
        
        Let x_cubed_power_k be BigDecimal.power_function(Operations.multiply(Operations.multiply(x_str, x_str, 50).result_value, x_str, 50).result_value, String(k), 50)
        
        Let term1 be Operations.divide(x_cubed_power_k, three_k_factorial, 50).result_value
        Set series1_sum to BigDecimal.add(series1_sum, BigDecimal.create_from_string(term1, BigDecimal.MathContext))
        
        Let term2 be Operations.divide(x_cubed_power_k, three_k_plus_one_factorial, 50).result_value
        Set series2_sum to BigDecimal.add(series2_sum, BigDecimal.create_from_string(term2, BigDecimal.MathContext))
        
        Set k to k plus 1
    
    Let first_part be Operations.multiply(c1, BigDecimal.to_plain_string(series1_sum), 50).result_value
    Let second_part be Operations.multiply(Operations.multiply(c2, x_str, 50).result_value, BigDecimal.to_plain_string(series2_sum), 50).result_value
    
    Return Operations.subtract(first_part, second_part, 50).result_value

Process called "compute_airy_bi_series" that takes x as Float, terms as Integer returns String:
    Note: Compute Airy Bi function using power series expansion
    
    Let c3 be "0.61492662744600073"
    Let c4 be "0.44828835735671421"
    Let x_str be String(x)
    
    Let series1_sum be BigDecimal.create_from_string("1.0", BigDecimal.MathContext)
    Let series2_sum be BigDecimal.create_from_string("1.0", BigDecimal.MathContext)
    
    Let k be 1
    While k is less than or equal to terms:
        Let three_k be 3 multiplied by k
        Let three_k_factorial be Gamma.compute_factorial(three_k, Gamma.FactorialConfig).factorial_value
        Let three_k_plus_one_factorial be Gamma.compute_factorial(three_k plus 1, Gamma.FactorialConfig).factorial_value
        
        Let x_cubed_power_k be BigDecimal.power_function(Operations.multiply(Operations.multiply(x_str, x_str, 50).result_value, x_str, 50).result_value, String(k), 50)
        
        Let term1 be Operations.divide(x_cubed_power_k, three_k_factorial, 50).result_value
        Set series1_sum to BigDecimal.add(series1_sum, BigDecimal.create_from_string(term1, BigDecimal.MathContext))
        
        Let term2 be Operations.divide(x_cubed_power_k, three_k_plus_one_factorial, 50).result_value
        Set series2_sum to BigDecimal.add(series2_sum, BigDecimal.create_from_string(term2, BigDecimal.MathContext))
        
        Set k to k plus 1
    
    Let first_part be Operations.multiply(c3, BigDecimal.to_plain_string(series1_sum), 50).result_value
    Let second_part be Operations.multiply(Operations.multiply(c4, x_str, 50).result_value, BigDecimal.to_plain_string(series2_sum), 50).result_value
    
    Return Operations.add(first_part, second_part, 50).result_value

Note: =====================================================================
Note: ASYMPTOTIC EXPANSIONS
Note: =====================================================================

Process called "compute_bessel_asymptotic_large_order" that takes nu as Float, x as Float, n_terms as Integer returns AsymptoticExpansion:
    Note: Compute asymptotic expansion for large order ν using Debye's method
    Note: For large ν: J_ν(νz) ~ (e*z/2)^ν / sqrt(2πν) multiplied by [1 minus (1-z²)/(8νz) plus ...]
    
    Let result be AsymptoticExpansion
    Set result.expansion_order to n_terms
    Set result.validity_range to {"min": nu, "max": "infinity"}
    Set result.correction_terms to []
    
    Let z be Operations.divide(String(x), String(nu), 50).result_value
    Let e_str be Constants.get_e(50)
    Let pi_str be Constants.get_pi(50)
    
    Let ez_over_2 be Operations.divide(Operations.multiply(e_str, z, 50).result_value, "2.0", 50).result_value
    Let ez_over_2_power_nu be BigDecimal.power_function(ez_over_2, String(nu), 50)
    Let sqrt_2pi_nu be Operations.square_root(Operations.multiply("2.0", Operations.multiply(pi_str, String(nu), 50).result_value, 50).result_value, 50).result_value
    
    Set result.leading_term to Operations.divide(ez_over_2_power_nu, sqrt_2pi_nu, 50).result_value
    
    Let z_squared be Operations.multiply(z, z, 50).result_value
    Let one_minus_z_squared be Operations.subtract("1.0", z_squared, 50).result_value
    Let correction1 be Operations.divide(one_minus_z_squared, Operations.multiply("8.0", Operations.multiply(String(nu), z, 50).result_value, 50).result_value, 50).result_value
    
    Set result.correction_terms to [Operations.multiply("-1.0", correction1, 50).result_value]
    
    Return result

Process called "compute_bessel_asymptotic_large_argument" that takes nu as Float, x as Float, n_terms as Integer returns AsymptoticExpansion:
    Note: Compute asymptotic expansion for large argument x using stationary phase method
    Note: J_ν(x) ~ sqrt(2/(πx)) multiplied by cos(x minus νπ/2 minus π/4) for large x
    
    Let result be AsymptoticExpansion
    Set result.expansion_order to n_terms
    Set result.validity_range to {"min": String(x), "max": "infinity"}
    Set result.correction_terms to []
    
    Let pi_str be Constants.get_pi(50)
    Let two_over_pi_x be Operations.divide("2.0", Operations.multiply(pi_str, String(x), 50).result_value, 50).result_value
    Let amplitude be Operations.square_root(two_over_pi_x, 50).result_value
    
    Let nu_pi_over_2 be Operations.divide(Operations.multiply(String(nu), pi_str, 50).result_value, "2.0", 50).result_value
    Let pi_over_4 be Operations.divide(pi_str, "4.0", 50).result_value
    Let phase is equal to Operations.subtract(Operations.subtract(String(x), nu_pi_over_2, 50).result_value, pi_over_4, 50).result_value
    
    Let cos_phase is equal to Trigonometry.cosine(phase, "radians", 50).function_value
    
    Set result.leading_term to Operations.multiply(amplitude, cos_phase, 50).result_value
    Set result.correction_terms to ["0.0"]
    
    Return result

Process called "compute_bessel_uniform_asymptotic" that takes nu as Float, x as Float, n_terms as Integer returns AsymptoticExpansion:
    Note: Compute uniform asymptotic expansion valid for all x using Airy function transitions
    Note: Uses Airy function connection in transition region around x ≈ ν
    
    Let result be AsymptoticExpansion
    Set result.expansion_order to n_terms
    Set result.validity_range to {"min": "0", "max": "infinity"}
    Set result.correction_terms to []
    
    Let nu_to_two_thirds be BigDecimal.power_function(String(nu), "0.6666666666666666", 50)
    Let xi be Operations.divide(Operations.subtract(String(x), String(nu), 50).result_value, nu_to_two_thirds, 50).result_value
    
    Let airy_config be BesselConfig
    Set airy_config.precision to 50.0
    Set airy_config.max_iterations to 100
    Set airy_config.convergence_threshold to 1e-50
    
    Let airy_ai is equal to compute_airy_ai(BigDecimal.to_float(xi), airy_config).value
    Let normalization is equal to Operations.divide("1.0", Operations.square_root(Operations.multiply(Constants.get_pi(50), nu_to_two_thirds, 50).result_value, 50).result_value, 50).result_value
    
    Set result.leading_term to Operations.multiply(normalization, String(airy_ai), 50).result_value
    Set result.correction_terms to ["0.0"]
    
    Return result

Process called "estimate_asymptotic_accuracy" that takes expansion as AsymptoticExpansion, x as Float returns Float:
    Note: Estimate accuracy of asymptotic expansion for given argument value
    
    Let leading_magnitude be Operations.absolute_value(expansion.leading_term, 50).result_value
    
    If expansion.correction_terms.length is greater than 0:
        Let first_correction_magnitude be Operations.absolute_value(expansion.correction_terms[0], 50).result_value
        Let ratio be Operations.divide(first_correction_magnitude, leading_magnitude, 50).result_value
        Return BigDecimal.to_float(ratio)
    
    Let x_magnitude be Operations.absolute_value(String(x), 50).result_value
    Let accuracy_estimate be Operations.divide("1.0", x_magnitude, 50).result_value
    
    Return BigDecimal.to_float(accuracy_estimate)

Note: =====================================================================
Note: SPECIAL VALUES AND IDENTITIES
Note: =====================================================================

Process called "compute_bessel_integer_order" that takes n as Integer, x as Float, config as BesselConfig returns Float:
    Note: Compute Bessel functions of integer order using specialized algorithms
    Note: Uses generating function e^{x(t-1/t)/2} is equal to Σ J_n(x) t^n for efficiency
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        If n is equal to 0:
            Return 1.0
        Otherwise:
            Return 0.0
    
    If n is equal to 0:
        Return compute_bessel_j(0.0, x, config).value
    
    If n is less than 0:
        Let j_minus_n be compute_bessel_j(BigDecimal.to_float(String(-n)), x, config).value
        If (-n) % 2 is equal to 1:
            Return -1.0 multiplied by j_minus_n
        Otherwise:
            Return j_minus_n
    
    Note: For positive integer orders, use optimized series
    Let x_str be String(x)
    Let half_x be Operations.divide(x_str, "2.0", config.precision).result_value
    Let half_x_to_n be BigDecimal.power_function(half_x, String(n), config.precision)
    
    Let factorial_config be Gamma.FactorialConfig
    Let n_factorial is equal to Gamma.compute_factorial(n, factorial_config).factorial_value
    
    Let sum be BigDecimal.create_from_string("0.0", BigDecimal.MathContext)
    Let x_squared_over_4 is equal to Operations.divide(Operations.multiply(x_str, x_str, config.precision).result_value, "4.0", config.precision).result_value
    
    Let k be 0
    While k is less than or equal to config.max_iterations:
        Let k_factorial is equal to Gamma.compute_factorial(k, factorial_config).factorial_value
        Let n_plus_k_factorial is equal to Gamma.compute_factorial(n plus k, factorial_config).factorial_value
        
        Let numerator be BigDecimal.power_function(Operations.multiply("-1.0", x_squared_over_4, config.precision).result_value, String(k), config.precision)
        Let denominator be Operations.multiply(k_factorial, n_plus_k_factorial, config.precision).result_value
        Let term be Operations.divide(numerator, denominator, config.precision).result_value
        
        Set sum to BigDecimal.add(sum, BigDecimal.create_from_string(term, BigDecimal.MathContext))
        
        Let term_abs be Operations.absolute_value(term, config.precision).result_value
        If BigDecimal.compare(term_abs, "1e-" plus String(config.precision minus 5)) is less than 0:
            Break
        
        Set k to k plus 1
    
    Let result is equal to Operations.multiply(half_x_to_n, BigDecimal.to_plain_string(sum), config.precision).result_value
    Return BigDecimal.to_float(result)

Process called "compute_bessel_half_integer" that takes n as Integer, x as Float, config as BesselConfig returns Float:
    Note: Compute Bessel functions of half-integer order using elementary functions
    Note: J_{n+1/2}(x) is equal to √(2/πx) multiplied by [trig functions] for efficient computation
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        If n is equal to 0:
            Return 0.0
        Otherwise:
            Return 0.0
    
    Let x_str be String(x)
    Let sqrt_2_over_pi_x is equal to Operations.square_root(Operations.divide("2.0", Operations.multiply(Constants.get_pi(config.precision), x_str, config.precision).result_value, config.precision).result_value, config.precision).result_value
    
    Note: Handle J_{1/2}(x) is equal to √(2/πx) multiplied by sin(x) as base case
    If n is equal to 0:
        Let sin_x be Trigonometry.sine(x_str, "radians", config.precision).function_value
        Let result is equal to Operations.multiply(sqrt_2_over_pi_x, sin_x, config.precision).result_value
        Return BigDecimal.to_float(result)
    
    Note: Handle J_{-1/2}(x) is equal to √(2/πx) multiplied by cos(x) as base case
    If n is equal to -1:
        Let cos_x be Trigonometry.cosine(x_str, "radians", config.precision).function_value
        Let result is equal to Operations.multiply(sqrt_2_over_pi_x, cos_x, config.precision).result_value
        Return BigDecimal.to_float(result)
    
    Note: Use recurrence relation for higher orders
    Note: J_{n+1/2} is equal to (2n+1)/x multiplied by J_{n-1/2} minus J_{n-3/2}
    Let j_minus_half is equal to Operations.multiply(sqrt_2_over_pi_x, Trigonometry.cosine(x_str, "radians", config.precision).function_value, config.precision).result_value
    Let j_plus_half is equal to Operations.multiply(sqrt_2_over_pi_x, Trigonometry.sine(x_str, "radians", config.precision).function_value, config.precision).result_value
    
    If n is equal to 1:
        Return BigDecimal.to_float(j_plus_half)
    
    Let j_prev be j_minus_half
    Let j_curr be j_plus_half
    
    Let k be 1
    While k is less than n:
        Let two_k_plus_1 is equal to String(2 multiplied by k plus 1)
        Let recurrence_coeff is equal to Operations.divide(two_k_plus_1, x_str, config.precision).result_value
        Let term1 is equal to Operations.multiply(recurrence_coeff, j_curr, config.precision).result_value
        Let j_next is equal to Operations.subtract(term1, j_prev, config.precision).result_value
        
        Set j_prev to j_curr
        Set j_curr to j_next
        Set k to k plus 1
    
    Return BigDecimal.to_float(j_curr)

Process called "apply_bessel_addition_theorem" that takes nu as Float, x as Float, y as Float returns Float:
    Note: Apply Bessel addition theorem for J_ν(x+y) in terms of products
    Note: J_ν(x+y) is equal to Σ(k=-∞ to ∞) J_{ν+k}(x) J_{-k}(y) using Neumann addition formula
    
    If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
        Let config be BesselConfig
        Set config.precision to 30.0
        Set config.max_iterations to 100
        Set config.convergence_threshold to 1e-25
        Return compute_bessel_j(nu, y, config).value
    
    If Operations.absolute_value(String(y), 20).result_value is equal to "0.0":
        Let config be BesselConfig
        Set config.precision to 30.0
        Set config.max_iterations to 100
        Set config.convergence_threshold to 1e-25
        Return compute_bessel_j(nu, x, config).value
    
    Let config be BesselConfig
    Set config.precision to 40.0
    Set config.max_iterations to 150
    Set config.convergence_threshold to 1e-35
    
    Let sum be BigDecimal.create_from_string("0.0", BigDecimal.MathContext)
    
    Note: Central term k=0
    Let j_nu_x is equal to compute_bessel_j(nu, x, config).value
    Let j_0_y is equal to compute_bessel_j(0.0, y, config).value
    Let central_term is equal to Operations.multiply(String(j_nu_x), String(j_0_y), config.precision).result_value
    Set sum to BigDecimal.add(sum, BigDecimal.create_from_string(central_term, BigDecimal.MathContext))
    
    Note: Positive and negative k terms
    Let k be 1
    While k is less than or equal to 50:
        Note: Positive k term: J_{ν+k}(x) multiplied by J_{-k}(y)
        Let j_nu_plus_k_x is equal to compute_bessel_j(nu plus BigDecimal.to_float(String(k)), x, config).value
        Let j_minus_k_y is equal to compute_bessel_j(-1.0 multiplied by BigDecimal.to_float(String(k)), y, config).value
        Let pos_term is equal to Operations.multiply(String(j_nu_plus_k_x), String(j_minus_k_y), config.precision).result_value
        
        Note: Negative k term: J_{ν-k}(x) multiplied by J_{k}(y)  
        Let j_nu_minus_k_x is equal to compute_bessel_j(nu minus BigDecimal.to_float(String(k)), x, config).value
        Let j_k_y is equal to compute_bessel_j(BigDecimal.to_float(String(k)), y, config).value
        Let neg_term is equal to Operations.multiply(String(j_nu_minus_k_x), String(j_k_y), config.precision).result_value
        
        Let k_contribution is equal to Operations.add(pos_term, neg_term, config.precision).result_value
        Set sum to BigDecimal.add(sum, BigDecimal.create_from_string(k_contribution, BigDecimal.MathContext))
        
        Note: Check convergence
        Let term_magnitude is equal to Operations.absolute_value(k_contribution, config.precision).result_value
        If BigDecimal.compare(term_magnitude, "1e-30") is less than 0:
            Break
        
        Set k to k plus 1
    
    Return BigDecimal.to_float(BigDecimal.to_plain_string(sum))

Process called "compute_bessel_integral_representations" that takes nu as Float, x as Float, integral_type as String returns Float:
    Note: Compute Bessel functions using integral representations (Schläfli, Poisson, etc.)
    Note: Uses numerical quadrature to evaluate classical integral forms
    
    Let x_str be String(x)
    Let nu_str be String(nu)
    
    If integral_type is equal to "poisson":
        Note: Poisson integral: J_ν(x) is equal to (1/π) ∫₀^π cos(x sin(t) minus νt) dt for integer ν
        If nu does not equal BigDecimal.to_float(String(Operations.round_to_integer(nu_str))):
            Throw Errors.InvalidOperation with "Poisson integral only valid for integer orders"
        
        Let integration_config be Integration.QuadratureConfig
        Set integration_config.method to "simpson"
        Set integration_config.intervals to 1000
        Set integration_config.precision to 30.0
        Set integration_config.convergence_threshold to 1e-25
        
        Note: Define integrand function for numerical integration
        Let integral_sum be BigDecimal.create_from_string("0.0", BigDecimal.MathContext)
        Let pi_str be Constants.get_pi(30.0)
        Let n_intervals be 1000
        Let h is equal to Operations.divide(pi_str, String(n_intervals), 30.0).result_value
        
        Let i be 0
        While i is less than or equal to n_intervals:
            Let t is equal to Operations.multiply(String(i), h, 30.0).result_value
            Let sin_t is equal to Trigonometry.sine(t, "radians", 30.0).function_value
            Let x_sin_t is equal to Operations.multiply(x_str, sin_t, 30.0).result_value
            Let nu_t is equal to Operations.multiply(nu_str, t, 30.0).result_value
            Let argument is equal to Operations.subtract(x_sin_t, nu_t, 30.0).result_value
            Let cos_arg is equal to Trigonometry.cosine(argument, "radians", 30.0).function_value
            
            Let weight be "1.0"
            If i is equal to 0 || i is equal to n_intervals:
                Set weight to "0.5"
            
            Let term is equal to Operations.multiply(Operations.multiply(weight, cos_arg, 30.0).result_value, h, 30.0).result_value
            Set integral_sum to BigDecimal.add(integral_sum, BigDecimal.create_from_string(term, BigDecimal.MathContext))
            
            Set i to i plus 1
        
        Let result is equal to Operations.divide(BigDecimal.to_plain_string(integral_sum), pi_str, 30.0).result_value
        Return BigDecimal.to_float(result)
    
    If integral_type is equal to "schlafli":
        Note: Schläfli integral: J_ν(x) is equal to (1/2πi) ∮ e^{x(t-1/t)/2} t^{-ν-1} dt
        Note: Simplified implementation using residue theorem approximation
        
        Let gamma_config be Gamma.GammaConfig
        Set gamma_config.precision to 30.0
        
        Let gamma_nu_plus_1 is equal to Gamma.compute_gamma(nu plus 1.0, gamma_config).value
        Let half_x_to_nu is equal to BigDecimal.power_function(Operations.divide(x_str, "2.0", 30.0).result_value, nu_str, 30.0)
        Let normalization is equal to Operations.divide(half_x_to_nu, String(gamma_nu_plus_1), 30.0).result_value
        
        Note: Use series expansion as approximation to the contour integral
        Let series_sum be BigDecimal.create_from_string("0.0", BigDecimal.MathContext)
        Let x_squared_over_4 is equal to Operations.divide(Operations.multiply(x_str, x_str, 30.0).result_value, "4.0", 30.0).result_value
        
        Let k be 0
        While k is less than or equal to 100:
            Let factorial_config be Gamma.FactorialConfig
            Let k_factorial is equal to Gamma.compute_factorial(k, factorial_config).factorial_value
            Let nu_plus_k_plus_1_gamma is equal to Gamma.compute_gamma(nu plus BigDecimal.to_float(String(k)) plus 1.0, gamma_config).value
            
            Let numerator is equal to BigDecimal.power_function(Operations.multiply("-1.0", x_squared_over_4, 30.0).result_value, String(k), 30.0)
            Let denominator is equal to Operations.multiply(k_factorial, String(nu_plus_k_plus_1_gamma), 30.0).result_value
            Let term is equal to Operations.divide(numerator, denominator, 30.0).result_value
            
            Set series_sum to BigDecimal.add(series_sum, BigDecimal.create_from_string(term, BigDecimal.MathContext))
            
            Let term_magnitude is equal to Operations.absolute_value(term, 30.0).result_value
            If BigDecimal.compare(term_magnitude, "1e-25") is less than 0:
                Break
            
            Set k to k plus 1
        
        Let result is equal to Operations.multiply(normalization, BigDecimal.to_plain_string(series_sum), 30.0).result_value
        Return BigDecimal.to_float(result)
    
    Otherwise:
        Throw Errors.InvalidOperation with "Unknown integral representation type: " plus integral_type

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_bessel_arguments" that takes arguments as Dictionary[String, Float], function_type as String returns Dictionary[String, Boolean]:
    Note: Validate arguments for Bessel functions ensuring domain restrictions and special cases
    Note: Checks for singularities, branch cuts, and invalid parameter ranges
    
    Let validation_results be Dictionary[String, Boolean]
    Set validation_results["valid"] to true
    Set validation_results["has_warnings"] to false
    Set validation_results["has_singularities"] to false
    
    Note: Extract common arguments
    Let x be arguments["x"]
    Let nu be arguments["nu"]
    
    Note: Check for NaN or infinite values
    If x does not equal x || nu does not equal nu:
        Set validation_results["valid"] to false
        Set validation_results["has_nan"] to true
        Return validation_results
    
    Note: Function-specific validation
    If function_type is equal to "bessel_j":
        Set validation_results["x_valid"] to true
        Set validation_results["nu_valid"] to true
        If Operations.absolute_value(String(x), 20).result_value is equal to "0.0" && nu is less than 0.0:
            Set validation_results["has_singularities"] to true
            Set validation_results["has_warnings"] to true
    
    If function_type is equal to "bessel_y":
        If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
            Set validation_results["valid"] to false
            Set validation_results["has_singularities"] to true
        If x is less than 0.0:
            Set validation_results["valid"] to false
            Set validation_results["negative_x"] to true
    
    If function_type is equal to "bessel_k":
        If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
            Set validation_results["valid"] to false
            Set validation_results["has_singularities"] to true
        If x is less than 0.0:
            Set validation_results["has_warnings"] to true
            Set validation_results["negative_x_complex"] to true
    
    If function_type is equal to "airy":
        Set validation_results["x_valid"] to true
        Set validation_results["nu_valid"] to true
    
    If function_type is equal to "kelvin":
        If Operations.absolute_value(String(x), 20).result_value is equal to "0.0":
            If function_type is equal to "kelvin_ker" || function_type is equal to "kelvin_kei":
                Set validation_results["valid"] to false
                Set validation_results["has_singularities"] to true
    
    Return validation_results

Process called "optimize_bessel_computation" that takes computation_parameters as Dictionary[String, Float], performance_targets as Dictionary[String, Float] returns BesselConfig:
    Note: Optimize Bessel function computation parameters for accuracy and performance
    Note: Adapts precision, iterations, and method selection based on accuracy and speed requirements
    
    Let optimized_config be BesselConfig
    
    Note: Extract performance targets
    Let target_accuracy be performance_targets["accuracy"]
    Let target_speed_ms be performance_targets["max_time_ms"]
    Let x_range_max be computation_parameters["x_max"]
    Let nu_range_max be computation_parameters["nu_max"]
    
    Note: Set precision based on accuracy target
    If target_accuracy is greater than or equal to 1e-15:
        Set optimized_config.precision to 50.0
        Set optimized_config.max_iterations to 200
    If target_accuracy is greater than or equal to 1e-10 && target_accuracy is less than 1e-15:
        Set optimized_config.precision to 35.0
        Set optimized_config.max_iterations to 150
    If target_accuracy is greater than or equal to 1e-8 && target_accuracy is less than 1e-10:
        Set optimized_config.precision to 25.0
        Set optimized_config.max_iterations to 100
    Otherwise:
        Set optimized_config.precision to 20.0
        Set optimized_config.max_iterations to 50
    
    Note: Adjust convergence threshold
    Set optimized_config.convergence_threshold to target_accuracy multiplied by 0.1
    
    Note: Speed optimizations
    If target_speed_ms is less than 10.0:
        Set optimized_config.max_iterations to optimized_config.max_iterations / 2
        Set optimized_config.precision to optimized_config.precision multiplied by 0.8
    
    If target_speed_ms is greater than 1000.0:
        Set optimized_config.max_iterations to optimized_config.max_iterations multiplied by 2
        Set optimized_config.precision to optimized_config.precision multiplied by 1.2
    
    Note: Range-based optimizations
    If x_range_max is greater than 100.0:
        Set optimized_config.asymptotic_threshold to 50.0
        Set optimized_config.series_threshold to 10.0
    If x_range_max is less than 10.0:
        Set optimized_config.asymptotic_threshold to 100.0
        Set optimized_config.series_threshold to 20.0
    Otherwise:
        Set optimized_config.asymptotic_threshold to 75.0
        Set optimized_config.series_threshold to 15.0
    
    Note: Method selection flags
    Set optimized_config.use_recurrence to true
    Set optimized_config.use_asymptotic to true
    Set optimized_config.use_continued_fractions to x_range_max is greater than 50.0
    
    Return optimized_config

Process called "benchmark_bessel_methods" that takes test_values as List[Dictionary[String, Float]], methods as List[String] returns Dictionary[String, Dictionary[String, Float]]:
    Note: Benchmark different Bessel function computation methods for accuracy and speed
    Note: Returns timing and accuracy statistics for each method across test values
    
    Let benchmark_results be Dictionary[String, Dictionary[String, Float]]
    
    Let i be 0
    While i is less than methods.length:
        Let method_name be methods[i]
        Let method_stats be Dictionary[String, Float]
        
        Set method_stats["total_time"] to 0.0
        Set method_stats["average_time"] to 0.0
        Set method_stats["max_time"] to 0.0
        Set method_stats["accuracy_score"] to 0.0
        Set method_stats["convergence_failures"] to 0.0
        Set method_stats["test_count"] to BigDecimal.to_float(String(test_values.length))
        
        Let j be 0
        While j is less than test_values.length:
            Let test_case be test_values[j]
            Let x be test_case["x"]
            Let nu be test_case["nu"]
            
            Note: Create high-precision reference config for accuracy comparison
            Let reference_config be BesselConfig
            Set reference_config.precision to 60.0
            Set reference_config.max_iterations to 500
            Set reference_config.convergence_threshold to 1e-55
            
            Note: Create test config based on method
            Let test_config be BesselConfig
            If method_name is equal to "series":
                Set test_config.precision to 30.0
                Set test_config.max_iterations to 100
                Set test_config.asymptotic_threshold to 1000.0
            If method_name is equal to "asymptotic":
                Set test_config.precision to 25.0
                Set test_config.max_iterations to 50
                Set test_config.asymptotic_threshold to 5.0
            If method_name is equal to "recurrence":
                Set test_config.precision to 35.0
                Set test_config.max_iterations to 150
                Set test_config.use_recurrence to true
            Otherwise:
                Set test_config.precision to 30.0
                Set test_config.max_iterations to 100
            
            Set test_config.convergence_threshold to 1e-25
            
            Note: Measure computation time (simplified timing)
            Let start_iterations be test_config.max_iterations
            Let reference_result is equal to compute_bessel_j(nu, x, reference_config).value
            Let test_result is equal to compute_bessel_j(nu, x, test_config).value
            
            Note: Calculate relative error
            Let error is equal to Operations.absolute_value(Operations.subtract(String(test_result), String(reference_result), 50).result_value, 50).result_value
            Let relative_error is equal to Operations.divide(error, Operations.absolute_value(String(reference_result), 50).result_value, 50).result_value
            
            Note: Accumulate statistics
            Let relative_error_float be BigDecimal.to_float(relative_error)
            Set method_stats["accuracy_score"] to method_stats["accuracy_score"] plus relative_error_float
            
            Note: Estimate timing from iteration count (proxy metric)
            Let time_estimate is equal to BigDecimal.to_float(String(test_config.max_iterations)) multiplied by 0.001
            Set method_stats["total_time"] to method_stats["total_time"] plus time_estimate
            
            If time_estimate is greater than method_stats["max_time"]:
                Set method_stats["max_time"] to time_estimate
            
            If relative_error_float is greater than 1e-10:
                Set method_stats["convergence_failures"] to method_stats["convergence_failures"] plus 1.0
            
            Set j to j plus 1
        
        Note: Finalize statistics
        Set method_stats["average_time"] to method_stats["total_time"] / BigDecimal.to_float(String(test_values.length))
        Set method_stats["accuracy_score"] to method_stats["accuracy_score"] / BigDecimal.to_float(String(test_values.length))
        Set method_stats["failure_rate"] to method_stats["convergence_failures"] / BigDecimal.to_float(String(test_values.length))
        
        Set benchmark_results[method_name] to method_stats
        Set i to i plus 1
    
    Return benchmark_results

Process called "troubleshoot_bessel_computation" that takes error_description as Dictionary[String, String] returns List[String]:
    Note: Provide troubleshooting guidance for Bessel function computation problems
    Note: Analyzes error conditions and provides specific remediation suggestions
    
    Let recommendations be List[String]
    
    Let error_type be error_description["error_type"]
    Let function_name be error_description["function"]
    Let arguments_info be error_description["arguments"]
    
    Note: Convergence issues
    If error_type is equal to "convergence_failure":
        Set recommendations to recommendations plus ["Increase max_iterations in BesselConfig (try 500-1000)"]
        Set recommendations to recommendations plus ["Increase precision in BesselConfig (try 50-60 digits)"]
        Set recommendations to recommendations plus ["Reduce convergence_threshold (try 1e-40 to 1e-50)"]
        Set recommendations to recommendations plus ["Switch to asymptotic method for large arguments (x is greater than 50)"]
        Set recommendations to recommendations plus ["Use Miller algorithm for recurrence relations"]
    
    Note: Numerical instability
    If error_type is equal to "numerical_instability":
        Set recommendations to recommendations plus ["Check argument ranges minus may be near singularities"]
        Set recommendations to recommendations plus ["Use higher precision arithmetic (BigDecimal precision is greater than 40)"]
        Set recommendations to recommendations plus ["Switch method: series for small x, asymptotic for large x"]
        Set recommendations to recommendations plus ["Enable scaled variants for exponentially growing functions"]
        Set recommendations to recommendations plus ["Validate input arguments using validate_bessel_arguments"]
    
    Note: Accuracy issues
    If error_type is equal to "accuracy_loss":
        Set recommendations to recommendations plus ["Increase precision to 2x the required output precision"]
        Set recommendations to recommendations plus ["Use continued fractions for function ratios"]
        Set recommendations to recommendations plus ["Check for catastrophic cancellation in differences"]
        Set recommendations to recommendations plus ["Use uniform asymptotic expansions for transition regions"]
        Set recommendations to recommendations plus ["Compare with reference implementations"]
    
    Note: Performance issues
    If error_type is equal to "performance_slow":
        Set recommendations to recommendations plus ["Use optimize_bessel_computation for performance tuning"]
        Set recommendations to recommendations plus ["Reduce precision if accuracy requirements allow"]
        Set recommendations to recommendations plus ["Enable asymptotic methods for appropriate ranges"]
        Set recommendations to recommendations plus ["Use integer-order specialized functions when applicable"]
        Set recommendations to recommendations plus ["Cache commonly computed values"]
    
    Note: Domain errors
    If error_type is equal to "domain_error":
        Set recommendations to recommendations plus ["Check function domain restrictions (Y, K functions)"]
        Set recommendations to recommendations plus ["Handle singularities at x=0 appropriately"]
        Set recommendations to recommendations plus ["Use complex arithmetic for negative arguments where needed"]
        Set recommendations to recommendations plus ["Validate arguments before computation"]
    
    Note: Memory issues
    If error_type is equal to "memory_usage":
        Set recommendations to recommendations plus ["Reduce precision requirements if possible"]
        Set recommendations to recommendations plus ["Use streaming computation for large arrays"]
        Set recommendations to recommendations plus ["Optimize memory allocation in series computations"]
        Set recommendations to recommendations plus ["Consider iterative rather than recursive methods"]
    
    Note: Function-specific guidance
    If function_name is equal to "bessel_y" || function_name is equal to "bessel_k":
        Set recommendations to recommendations plus ["These functions have singularities at x=0"]
        Set recommendations to recommendations plus ["Use connection formulas with J functions when appropriate"]
    
    If function_name is equal to "airy":
        Set recommendations to recommendations plus ["Airy functions use Bessel connections minus check Bessel accuracy"]
        Set recommendations to recommendations plus ["WKB approximation may need more terms for zeros"]
    
    If function_name is equal to "kelvin":
        Set recommendations to recommendations plus ["Kelvin functions combine real/imaginary parts minus check component accuracy"]
        Set recommendations to recommendations plus ["Switch algorithms at x ≈ 8 for optimal performance"]
    
    Note: Generic recommendations if no specific error type
    If recommendations.length is equal to 0:
        Set recommendations to recommendations plus ["Enable detailed error reporting in BesselConfig"]
        Set recommendations to recommendations plus ["Try different computational methods"]
        Set recommendations to recommendations plus ["Validate input parameters"]
        Set recommendations to recommendations plus ["Check for edge cases or boundary conditions"]
        Set recommendations to recommendations plus ["Consider using benchmark_bessel_methods for analysis"]
    
    Return recommendations