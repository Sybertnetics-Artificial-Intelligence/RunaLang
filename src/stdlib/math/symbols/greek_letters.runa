Note:
math/symbols/greek_letters.runa
Greek Letter Symbols and Mathematical Usage

This module provides comprehensive Greek letter symbol handling including:
- Complete Greek alphabet (uppercase and lowercase)
- Mathematical usage contexts and meanings
- Variant forms and stylistic alternatives
- Unicode normalization and encoding
- Symbol classification by usage domain
- Phonetic and transliteration information
- Historical and etymological context
- Font style variations (bold, italic, script)
- Combining forms and diacritical marks
- Modern Greek vs. ancient Greek forms
- Mathematical constants using Greek letters
- Scientific notation applications
- Engineering convention usage
- Typography and display formatting
- Cross-reference with Latin equivalents
:End Note

Import module "dev/debug/errors/core" as Errors

Note: =====================================================================
Note: GREEK LETTER DATA STRUCTURES
Note: =====================================================================

Type called "GreekLetter":
    letter_name as String
    uppercase_symbol as String
    lowercase_symbol as String
    unicode_uppercase as String
    unicode_lowercase as String
    mathematical_usage as List[String]
    pronunciation as String
    transliteration as String
    latin_equivalent as String

Type called "GreekLetterVariant":
    base_letter as String
    variant_type as String
    variant_symbol as String
    unicode_codepoint as String
    usage_context as String
    font_style as String

Type called "MathematicalConstant":
    constant_name as String
    greek_symbol as String
    mathematical_value as String
    domain as String
    definition as String
    historical_context as String

Note: =====================================================================
Note: BASIC GREEK ALPHABET OPERATIONS
Note: =====================================================================

Process called "get_complete_greek_alphabet" that returns List[GreekLetter]:
    Note: Get complete Greek alphabet with upper and lowercase forms
    Return [
        alpha_symbols(),
        beta_symbols(),
        gamma_symbols(),
        delta_symbols(),
        epsilon_symbols(),
        zeta_symbols(),
        eta_symbols(),
        theta_symbols(),
        iota_symbols(),
        kappa_symbols(),
        lambda_symbols(),
        mu_symbols(),
        nu_symbols(),
        xi_symbols(),
        omicron_symbols(),
        pi_symbols(),
        rho_symbols(),
        sigma_symbols(),
        tau_symbols(),
        upsilon_symbols(),
        phi_symbols(),
        chi_symbols(),
        psi_symbols(),
        omega_symbols()
    ]

Process called "alpha_symbols" that returns GreekLetter:
    Note: Get alpha symbols (Î‘, Î±) minus first letter of Greek alphabet
    Return {
        "letter_name": "alpha",
        "uppercase_symbol": "Î‘",
        "lowercase_symbol": "Î±",
        "unicode_uppercase": "U+0391",
        "unicode_lowercase": "U+03B1",
        "mathematical_usage": ["angle", "coefficient", "parameter", "fine_structure_constant"],
        "pronunciation": "AL-fah",
        "transliteration": "a",
        "latin_equivalent": "A"
    }

Process called "beta_symbols" that returns GreekLetter:
    Note: Get beta symbols (Î’, Î²) minus second letter of Greek alphabet
    Return {
        "letter_name": "beta",
        "uppercase_symbol": "Î’",
        "lowercase_symbol": "Î²",
        "unicode_uppercase": "U+0392",
        "unicode_lowercase": "U+03B2",
        "mathematical_usage": ["angle", "coefficient", "beta_function", "regression_coefficient"],
        "pronunciation": "BAY-tah",
        "transliteration": "b",
        "latin_equivalent": "B"
    }

Process called "gamma_symbols" that returns GreekLetter:
    Note: Get gamma symbols (Î“, Î³) minus third letter of Greek alphabet
    Return {
        "letter_name": "gamma",
        "uppercase_symbol": "Î“",
        "lowercase_symbol": "Î³",
        "unicode_uppercase": "U+0393",
        "unicode_lowercase": "U+03B3",
        "mathematical_usage": ["gamma_function", "euler_mascheroni_constant", "christoffel_symbols", "lorentz_factor"],
        "pronunciation": "GAM-ah",
        "transliteration": "g",
        "latin_equivalent": "G"
    }

Process called "delta_symbols" that returns GreekLetter:
    Note: Get delta symbols (Î”, Î´) minus fourth letter of Greek alphabet
    Return {
        "letter_name": "delta",
        "uppercase_symbol": "Î”",
        "lowercase_symbol": "Î´",
        "unicode_uppercase": "U+0394",
        "unicode_lowercase": "U+03B4",
        "mathematical_usage": ["change", "difference", "kronecker_delta", "dirac_delta", "small_increment"],
        "pronunciation": "DEL-tah",
        "transliteration": "d",
        "latin_equivalent": "D"
    }

Process called "epsilon_symbols" that returns GreekLetter:
    Note: Get epsilon symbols (Î•, Îµ, Ïµ) minus fifth letter of Greek alphabet
    Return {
        "letter_name": "epsilon",
        "uppercase_symbol": "Î•",
        "lowercase_symbol": "Îµ",
        "unicode_uppercase": "U+0395",
        "unicode_lowercase": "U+03B5",
        "mathematical_usage": ["small_quantity", "limit_definition", "permittivity", "strain"],
        "pronunciation": "EP-sih-lon",
        "transliteration": "e",
        "latin_equivalent": "E"
    }

Process called "zeta_symbols" that returns GreekLetter:
    Note: Get zeta symbols (Î–, Î¶) minus sixth letter of Greek alphabet
    Return {
        "letter_name": "zeta",
        "uppercase_symbol": "Î–",
        "lowercase_symbol": "Î¶",
        "unicode_uppercase": "U+0396",
        "unicode_lowercase": "U+03B6",
        "mathematical_usage": ["riemann_zeta_function", "damping_ratio", "impedance"],
        "pronunciation": "ZAY-tah",
        "transliteration": "z",
        "latin_equivalent": "Z"
    }

Process called "eta_symbols" that returns GreekLetter:
    Note: Get eta symbols (Î—, Î·) minus seventh letter of Greek alphabet
    Return {
        "letter_name": "eta",
        "uppercase_symbol": "Î—",
        "lowercase_symbol": "Î·",
        "unicode_uppercase": "U+0397",
        "unicode_lowercase": "U+03B7",
        "mathematical_usage": ["efficiency", "pseudorapidity", "viscosity", "refractive_index"],
        "pronunciation": "AY-tah",
        "transliteration": "e",
        "latin_equivalent": "H"
    }

Process called "theta_symbols" that returns GreekLetter:
    Note: Get theta symbols (Î˜, Î¸, Ï‘) minus eighth letter of Greek alphabet
    Return {
        "letter_name": "theta",
        "uppercase_symbol": "Î˜",
        "lowercase_symbol": "Î¸",
        "unicode_uppercase": "U+0398",
        "unicode_lowercase": "U+03B8",
        "mathematical_usage": ["angle", "parameter", "temperature", "heaviside_step_function"],
        "pronunciation": "THAY-tah",
        "transliteration": "th",
        "latin_equivalent": "TH"
    }

Process called "iota_symbols" that returns GreekLetter:
    Note: Get iota symbols (Î™, Î¹) minus ninth letter of Greek alphabet
    Return {
        "letter_name": "iota",
        "uppercase_symbol": "Î™",
        "lowercase_symbol": "Î¹",
        "unicode_uppercase": "U+0399",
        "unicode_lowercase": "U+03B9",
        "mathematical_usage": ["index", "unit_vector", "inclusion_function"],
        "pronunciation": "eye-OH-tah",
        "transliteration": "i",
        "latin_equivalent": "I"
    }

Process called "kappa_symbols" that returns GreekLetter:
    Note: Get kappa symbols (Îš, Îº, Ï°) minus tenth letter of Greek alphabet
    Return {
        "letter_name": "kappa",
        "uppercase_symbol": "Îš",
        "lowercase_symbol": "Îº",
        "unicode_uppercase": "U+039A",
        "unicode_lowercase": "U+03BA",
        "mathematical_usage": ["curvature", "thermal_conductivity", "spring_constant", "kappa_statistic"],
        "pronunciation": "KAP-ah",
        "transliteration": "k",
        "latin_equivalent": "K"
    }

Process called "lambda_symbols" that returns GreekLetter:
    Note: Get lambda symbols (Î›, Î») minus eleventh letter of Greek alphabet
    Return {
        "letter_name": "lambda",
        "uppercase_symbol": "Î›",
        "lowercase_symbol": "Î»",
        "unicode_uppercase": "U+039B",
        "unicode_lowercase": "U+03BB",
        "mathematical_usage": ["eigenvalue", "wavelength", "lambda_calculus", "poisson_parameter", "lagrange_multiplier"],
        "pronunciation": "LAM-dah",
        "transliteration": "l",
        "latin_equivalent": "L"
    }

Process called "mu_symbols" that returns GreekLetter:
    Note: Get mu symbols (Îœ, Î¼) minus twelfth letter of Greek alphabet
    Return {
        "letter_name": "mu",
        "uppercase_symbol": "Îœ",
        "lowercase_symbol": "Î¼",
        "unicode_uppercase": "U+039C",
        "unicode_lowercase": "U+03BC",
        "mathematical_usage": ["mean", "friction_coefficient", "magnetic_permeability", "micro_prefix"],
        "pronunciation": "MYOO",
        "transliteration": "m",
        "latin_equivalent": "M"
    }

Process called "nu_symbols" that returns GreekLetter:
    Note: Get nu symbols (Î, Î½) minus thirteenth letter of Greek alphabet
    Return {
        "letter_name": "nu",
        "uppercase_symbol": "Î",
        "lowercase_symbol": "Î½",
        "unicode_uppercase": "U+039D",
        "unicode_lowercase": "U+03BD",
        "mathematical_usage": ["frequency", "degrees_of_freedom", "kinematic_viscosity", "neutrino"],
        "pronunciation": "NYOO",
        "transliteration": "n",
        "latin_equivalent": "N"
    }

Process called "xi_symbols" that returns GreekLetter:
    Note: Get xi symbols (Î, Î¾) minus fourteenth letter of Greek alphabet
    Return {
        "letter_name": "xi",
        "uppercase_symbol": "Î",
        "lowercase_symbol": "Î¾",
        "unicode_uppercase": "U+039E",
        "unicode_lowercase": "U+03BE",
        "mathematical_usage": ["random_variable", "coordinate", "xi_function"],
        "pronunciation": "ZIGH",
        "transliteration": "x",
        "latin_equivalent": "X"
    }

Process called "omicron_symbols" that returns GreekLetter:
    Note: Get omicron symbols (ÎŸ, Î¿) minus fifteenth letter of Greek alphabet
    Return {
        "letter_name": "omicron",
        "uppercase_symbol": "ÎŸ",
        "lowercase_symbol": "Î¿",
        "unicode_uppercase": "U+039F",
        "unicode_lowercase": "U+03BF",
        "mathematical_usage": ["big_o_notation", "order_of_magnitude"],
        "pronunciation": "OH-mih-kron",
        "transliteration": "o",
        "latin_equivalent": "O"
    }

Process called "pi_symbols" that returns GreekLetter:
    Note: Get pi symbols (Î , Ï€, Ï–) minus sixteenth letter of Greek alphabet
    Return {
        "letter_name": "pi",
        "uppercase_symbol": "Î ",
        "lowercase_symbol": "Ï€",
        "unicode_uppercase": "U+03A0",
        "unicode_lowercase": "U+03C0",
        "mathematical_usage": ["pi_constant", "product_notation", "projection", "prime_counting_function"],
        "pronunciation": "PIE",
        "transliteration": "p",
        "latin_equivalent": "P"
    }

Process called "rho_symbols" that returns GreekLetter:
    Note: Get rho symbols (Î¡, Ï, Ï±) minus seventeenth letter of Greek alphabet
    Return {
        "letter_name": "rho",
        "uppercase_symbol": "Î¡",
        "lowercase_symbol": "Ï",
        "unicode_uppercase": "U+03A1",
        "unicode_lowercase": "U+03C1",
        "mathematical_usage": ["density", "correlation_coefficient", "resistivity", "radius"],
        "pronunciation": "ROH",
        "transliteration": "r",
        "latin_equivalent": "R"
    }

Process called "sigma_symbols" that returns GreekLetter:
    Note: Get sigma symbols (Î£, Ïƒ, Ï‚) minus eighteenth letter of Greek alphabet
    Return {
        "letter_name": "sigma",
        "uppercase_symbol": "Î£",
        "lowercase_symbol": "Ïƒ",
        "unicode_uppercase": "U+03A3",
        "unicode_lowercase": "U+03C3",
        "mathematical_usage": ["summation", "standard_deviation", "conductivity", "stress"],
        "pronunciation": "SIG-mah",
        "transliteration": "s",
        "latin_equivalent": "S"
    }

Process called "tau_symbols" that returns GreekLetter:
    Note: Get tau symbols (Î¤, Ï„) minus nineteenth letter of Greek alphabet
    Return {
        "letter_name": "tau",
        "uppercase_symbol": "Î¤",
        "lowercase_symbol": "Ï„",
        "unicode_uppercase": "U+03A4",
        "unicode_lowercase": "U+03C4",
        "mathematical_usage": ["time_constant", "torque", "tau_constant", "proper_time"],
        "pronunciation": "TAW",
        "transliteration": "t",
        "latin_equivalent": "T"
    }

Process called "upsilon_symbols" that returns GreekLetter:
    Note: Get upsilon symbols (Î¥, Ï…) minus twentieth letter of Greek alphabet
    Return {
        "letter_name": "upsilon",
        "uppercase_symbol": "Î¥",
        "lowercase_symbol": "Ï…",
        "unicode_uppercase": "U+03A5",
        "unicode_lowercase": "U+03C5",
        "mathematical_usage": ["particle_physics", "upsilon_meson"],
        "pronunciation": "OOP-sih-lon",
        "transliteration": "u",
        "latin_equivalent": "U"
    }

Process called "phi_symbols" that returns GreekLetter:
    Note: Get phi symbols (Î¦, Ï†, Ï•) minus twenty-first letter of Greek alphabet
    Return {
        "letter_name": "phi",
        "uppercase_symbol": "Î¦",
        "lowercase_symbol": "Ï†",
        "unicode_uppercase": "U+03A6",
        "unicode_lowercase": "U+03C6",
        "mathematical_usage": ["golden_ratio", "euler_totient_function", "angle", "magnetic_flux"],
        "pronunciation": "FIE",
        "transliteration": "ph",
        "latin_equivalent": "PH"
    }

Process called "chi_symbols" that returns GreekLetter:
    Note: Get chi symbols (Î§, Ï‡) minus twenty-second letter of Greek alphabet
    Return {
        "letter_name": "chi",
        "uppercase_symbol": "Î§",
        "lowercase_symbol": "Ï‡",
        "unicode_uppercase": "U+03A7",
        "unicode_lowercase": "U+03C7",
        "mathematical_usage": ["chi_squared_distribution", "euler_characteristic", "magnetic_susceptibility"],
        "pronunciation": "KIE",
        "transliteration": "ch",
        "latin_equivalent": "CH"
    }

Process called "psi_symbols" that returns GreekLetter:
    Note: Get psi symbols (Î¨, Ïˆ) minus twenty-third letter of Greek alphabet
    Return {
        "letter_name": "psi",
        "uppercase_symbol": "Î¨",
        "lowercase_symbol": "Ïˆ",
        "unicode_uppercase": "U+03A8",
        "unicode_lowercase": "U+03C8",
        "mathematical_usage": ["wave_function", "stream_function", "digamma_function", "psi_particle"],
        "pronunciation": "SIGH",
        "transliteration": "ps",
        "latin_equivalent": "PS"
    }

Process called "omega_symbols" that returns GreekLetter:
    Note: Get omega symbols (Î©, Ï‰) minus twenty-fourth letter of Greek alphabet
    Return {
        "letter_name": "omega",
        "uppercase_symbol": "Î©",
        "lowercase_symbol": "Ï‰",
        "unicode_uppercase": "U+03A9",
        "unicode_lowercase": "U+03C9",
        "mathematical_usage": ["angular_frequency", "ohm_unit", "omega_constant", "last_element"],
        "pronunciation": "oh-MAY-gah",
        "transliteration": "o",
        "latin_equivalent": "O"
    }

Note: =====================================================================
Note: VARIANT FORM OPERATIONS
Note: =====================================================================

Process called "get_epsilon_variants" that returns List[GreekLetterVariant]:
    Note: Get epsilon variants (Îµ, Ïµ) with different mathematical meanings
    Return [
        {
            "base_letter": "epsilon",
            "variant_type": "standard",
            "variant_symbol": "Îµ",
            "unicode_codepoint": "U+03B5",
            "usage_context": "set_membership_limits_analysis",
            "font_style": "normal"
        },
        {
            "base_letter": "epsilon",
            "variant_type": "lunate",
            "variant_symbol": "Ïµ",
            "unicode_codepoint": "U+03F5",
            "usage_context": "permittivity_strain_mechanics",
            "font_style": "normal"
        }
    ]

Process called "get_theta_variants" that returns List[GreekLetterVariant]:
    Note: Get theta variants (Î¸, Ï‘) with different usage contexts
    Return [
        {
            "base_letter": "theta",
            "variant_type": "standard",
            "variant_symbol": "Î¸",
            "unicode_codepoint": "U+03B8",
            "usage_context": "angles_temperature_parameters",
            "font_style": "normal"
        },
        {
            "base_letter": "theta",
            "variant_type": "script",
            "variant_symbol": "Ï‘",
            "unicode_codepoint": "U+03D1",
            "usage_context": "special_functions_jacobi_theta",
            "font_style": "script"
        }
    ]

Process called "get_kappa_variants" that returns List[GreekLetterVariant]:
    Note: Get kappa variants (Îº, Ï°) for different mathematical contexts
    Return [
        {
            "base_letter": "kappa",
            "variant_type": "standard",
            "variant_symbol": "Îº",
            "unicode_codepoint": "U+03BA",
            "usage_context": "curvature_conductivity",
            "font_style": "normal"
        },
        {
            "base_letter": "kappa",
            "variant_type": "script",
            "variant_symbol": "Ï°",
            "unicode_codepoint": "U+03F0",
            "usage_context": "statistical_mechanics",
            "font_style": "script"
        }
    ]

Process called "get_pi_variants" that returns List[GreekLetterVariant]:
    Note: Get pi variants (Ï€, Ï–) with different typographical uses
    Return [
        {
            "base_letter": "pi",
            "variant_type": "standard",
            "variant_symbol": "Ï€",
            "unicode_codepoint": "U+03C0",
            "usage_context": "pi_constant_circular_functions",
            "font_style": "normal"
        },
        {
            "base_letter": "pi",
            "variant_type": "omega_form",
            "variant_symbol": "Ï–",
            "unicode_codepoint": "U+03D6",
            "usage_context": "alternative_typographic_form",
            "font_style": "normal"
        }
    ]

Process called "get_rho_variants" that returns List[GreekLetterVariant]:
    Note: Get rho variants (Ï, Ï±) for different mathematical applications
    Return [
        {
            "base_letter": "rho",
            "variant_type": "standard",
            "variant_symbol": "Ï",
            "unicode_codepoint": "U+03C1",
            "usage_context": "density_correlation_coefficient",
            "font_style": "normal"
        },
        {
            "base_letter": "rho",
            "variant_type": "script",
            "variant_symbol": "Ï±",
            "unicode_codepoint": "U+03F1",
            "usage_context": "special_mathematical_contexts",
            "font_style": "script"
        }
    ]

Process called "get_sigma_variants" that returns List[GreekLetterVariant]:
    Note: Get sigma variants (Ïƒ, Ï‚) including final sigma form
    Return [
        {
            "base_letter": "sigma",
            "variant_type": "medial",
            "variant_symbol": "Ïƒ",
            "unicode_codepoint": "U+03C3",
            "usage_context": "standard_deviation_stress_conductivity",
            "font_style": "normal"
        },
        {
            "base_letter": "sigma",
            "variant_type": "final",
            "variant_symbol": "Ï‚",
            "unicode_codepoint": "U+03C2",
            "usage_context": "word_final_position_greek_text",
            "font_style": "normal"
        }
    ]

Process called "get_phi_variants" that returns List[GreekLetterVariant]:
    Note: Get phi variants (Ï†, Ï•) with different mathematical conventions
    Return [
        {
            "base_letter": "phi",
            "variant_type": "closed",
            "variant_symbol": "Ï†",
            "unicode_codepoint": "U+03C6",
            "usage_context": "golden_ratio_euler_totient",
            "font_style": "normal"
        },
        {
            "base_letter": "phi",
            "variant_type": "open",
            "variant_symbol": "Ï•",
            "unicode_codepoint": "U+03D5",
            "usage_context": "magnetic_flux_phase_angle",
            "font_style": "normal"
        }
    ]

Note: =====================================================================
Note: MATHEMATICAL USAGE OPERATIONS
Note: =====================================================================

Process called "get_calculus_greek_letters" that returns List[GreekLetter]:
    Note: Get Greek letters commonly used in calculus (Î´, Îµ, âˆ‚, âˆ‡, etc.)
    Return [
        delta_symbols(),
        epsilon_symbols(),
        lambda_symbols(),
        mu_symbols(),
        xi_symbols(),
        pi_symbols(),
        sigma_symbols(),
        tau_symbols(),
        omega_symbols()
    ]

Process called "get_physics_greek_letters" that returns List[GreekLetter]:
    Note: Get Greek letters commonly used in physics (Î±, Î², Î³, Î», Î¼, Î½, Ï, Ïƒ, Ï„, Ï†, Ïˆ, Ï‰)
    Return [
        alpha_symbols(),
        beta_symbols(),
        gamma_symbols(),
        delta_symbols(),
        epsilon_symbols(),
        lambda_symbols(),
        mu_symbols(),
        nu_symbols(),
        rho_symbols(),
        sigma_symbols(),
        tau_symbols(),
        phi_symbols(),
        psi_symbols(),
        omega_symbols()
    ]

Process called "get_statistics_greek_letters" that returns List[GreekLetter]:
    Note: Get Greek letters used in statistics (Î±, Î², Î¼, Ïƒ, Ï‡, Î½, etc.)
    Return [
        alpha_symbols(),
        beta_symbols(),
        gamma_symbols(),
        mu_symbols(),
        nu_symbols(),
        rho_symbols(),
        sigma_symbols(),
        chi_symbols()
    ]

Process called "get_geometry_greek_letters" that returns List[GreekLetter]:
    Note: Get Greek letters used in geometry (Î±, Î², Î³, Î¸, Ï†, etc.)
    Return [
        alpha_symbols(),
        beta_symbols(),
        gamma_symbols(),
        delta_symbols(),
        theta_symbols(),
        phi_symbols(),
        pi_symbols()
    ]

Process called "get_algebra_greek_letters" that returns List[GreekLetter]:
    Note: Get Greek letters used in algebra (Î±, Î², Î³, Î´, Î», Î¼, etc.)
    Return [
        alpha_symbols(),
        beta_symbols(),
        gamma_symbols(),
        delta_symbols(),
        lambda_symbols(),
        mu_symbols(),
        nu_symbols(),
        xi_symbols(),
        rho_symbols(),
        sigma_symbols(),
        tau_symbols()
    ]

Note: =====================================================================
Note: MATHEMATICAL CONSTANTS OPERATIONS
Note: =====================================================================

Process called "get_mathematical_constants_greek" that returns List[MathematicalConstant]:
    Note: Get mathematical constants represented by Greek letters
    Return [
        pi_constant(),
        euler_gamma_constant(),
        golden_ratio_phi(),
        euler_totient_phi(),
        lambda_constant()
    ]

Process called "pi_constant" that returns MathematicalConstant:
    Note: Get Ï€ constant (3.14159...) minus ratio of circumference to diameter
    Return {
        "constant_name": "pi",
        "greek_symbol": "Ï€",
        "mathematical_value": "3.141592653589793238462643383279502884197",
        "domain": "geometry_trigonometry",
        "definition": "ratio of circle circumference to diameter",
        "historical_context": "known to ancient civilizations, formalized by Archimedes"
    }

Process called "euler_gamma_constant" that returns MathematicalConstant:
    Note: Get Euler-Mascheroni constant Î³ (0.5772...)
    Return {
        "constant_name": "euler_mascheroni",
        "greek_symbol": "Î³",
        "mathematical_value": "0.5772156649015328606065120900824024310421",
        "domain": "number_theory_analysis",
        "definition": "limit of (harmonic series minus natural logarithm)",
        "historical_context": "discovered by Euler, studied by Mascheroni"
    }

Process called "golden_ratio_phi" that returns MathematicalConstant:
    Note: Get golden ratio Ï† (1.618...) minus (1+âˆš5)/2
    Return {
        "constant_name": "golden_ratio",
        "greek_symbol": "Ï†",
        "mathematical_value": "1.6180339887498948482045868343656381177203",
        "domain": "geometry_algebra",
        "definition": "(1 plus sqrt(5)) / 2",
        "historical_context": "known to ancient Greeks, appears in nature and art"
    }

Process called "euler_totient_phi" that returns MathematicalConstant:
    Note: Get Euler's totient function Ï†(n) minus number theory
    Return {
        "constant_name": "euler_totient",
        "greek_symbol": "Ï†",
        "mathematical_value": "function",
        "domain": "number_theory",
        "definition": "count of integers up to n that are coprime to n",
        "historical_context": "introduced by Euler for number theory applications"
    }

Process called "lambda_constant" that returns MathematicalConstant:
    Note: Get Î» constant in various mathematical contexts
    Return {
        "constant_name": "lambda_various",
        "greek_symbol": "Î»",
        "mathematical_value": "context_dependent",
        "domain": "multiple_domains",
        "definition": "eigenvalue, wavelength, decay constant, or Lagrange multiplier",
        "historical_context": "used across multiple mathematical and physical contexts"
    }

Note: =====================================================================
Note: FONT STYLE VARIATIONS
Note: =====================================================================

Process called "get_bold_greek_letters" that returns List[GreekLetterVariant]:
    Note: Get bold Greek letters (ğš¨, ğš©, ğšª, ğ›‚, ğ›ƒ, ğ›„, etc.)
    Let bold_variants be []
    
    Note: Bold uppercase Greek letters (Mathematical Bold)
    Let bold_uppercase be [
        {"letter_name": "alpha", "variant": "bold", "symbol": "ğš¨", "unicode": "U+1D6A8"},
        {"letter_name": "beta", "variant": "bold", "symbol": "ğš©", "unicode": "U+1D6A9"},
        {"letter_name": "gamma", "variant": "bold", "symbol": "ğšª", "unicode": "U+1D6AA"},
        {"letter_name": "delta", "variant": "bold", "symbol": "ğš«", "unicode": "U+1D6AB"},
        {"letter_name": "epsilon", "variant": "bold", "symbol": "ğš¬", "unicode": "U+1D6AC"},
        {"letter_name": "zeta", "variant": "bold", "symbol": "ğš­", "unicode": "U+1D6AD"},
        {"letter_name": "eta", "variant": "bold", "symbol": "ğš®", "unicode": "U+1D6AE"},
        {"letter_name": "theta", "variant": "bold", "symbol": "ğš¯", "unicode": "U+1D6AF"},
        {"letter_name": "iota", "variant": "bold", "symbol": "ğš°", "unicode": "U+1D6B0"},
        {"letter_name": "kappa", "variant": "bold", "symbol": "ğš±", "unicode": "U+1D6B1"},
        {"letter_name": "lambda", "variant": "bold", "symbol": "ğš²", "unicode": "U+1D6B2"},
        {"letter_name": "mu", "variant": "bold", "symbol": "ğš³", "unicode": "U+1D6B3"},
        {"letter_name": "nu", "variant": "bold", "symbol": "ğš´", "unicode": "U+1D6B4"},
        {"letter_name": "xi", "variant": "bold", "symbol": "ğšµ", "unicode": "U+1D6B5"},
        {"letter_name": "omicron", "variant": "bold", "symbol": "ğš¶", "unicode": "U+1D6B6"},
        {"letter_name": "pi", "variant": "bold", "symbol": "ğš·", "unicode": "U+1D6B7"},
        {"letter_name": "rho", "variant": "bold", "symbol": "ğš¸", "unicode": "U+1D6B8"},
        {"letter_name": "sigma", "variant": "bold", "symbol": "ğšº", "unicode": "U+1D6BA"},
        {"letter_name": "tau", "variant": "bold", "symbol": "ğš»", "unicode": "U+1D6BB"},
        {"letter_name": "upsilon", "variant": "bold", "symbol": "ğš¼", "unicode": "U+1D6BC"},
        {"letter_name": "phi", "variant": "bold", "symbol": "ğš½", "unicode": "U+1D6BD"},
        {"letter_name": "chi", "variant": "bold", "symbol": "ğš¾", "unicode": "U+1D6BE"},
        {"letter_name": "psi", "variant": "bold", "symbol": "ğš¿", "unicode": "U+1D6BF"},
        {"letter_name": "omega", "variant": "bold", "symbol": "ğ›€", "unicode": "U+1D6C0"}
    ]
    
    Note: Bold lowercase Greek letters (Mathematical Bold)
    Let bold_lowercase be [
        {"letter_name": "alpha", "variant": "bold", "symbol": "ğ›‚", "unicode": "U+1D6C2"},
        {"letter_name": "beta", "variant": "bold", "symbol": "ğ›ƒ", "unicode": "U+1D6C3"},
        {"letter_name": "gamma", "variant": "bold", "symbol": "ğ›„", "unicode": "U+1D6C4"},
        {"letter_name": "delta", "variant": "bold", "symbol": "ğ›…", "unicode": "U+1D6C5"},
        {"letter_name": "epsilon", "variant": "bold", "symbol": "ğ›†", "unicode": "U+1D6C6"},
        {"letter_name": "zeta", "variant": "bold", "symbol": "ğ›‡", "unicode": "U+1D6C7"},
        {"letter_name": "eta", "variant": "bold", "symbol": "ğ›ˆ", "unicode": "U+1D6C8"},
        {"letter_name": "theta", "variant": "bold", "symbol": "ğ›‰", "unicode": "U+1D6C9"},
        {"letter_name": "iota", "variant": "bold", "symbol": "ğ›Š", "unicode": "U+1D6CA"},
        {"letter_name": "kappa", "variant": "bold", "symbol": "ğ›‹", "unicode": "U+1D6CB"},
        {"letter_name": "lambda", "variant": "bold", "symbol": "ğ›Œ", "unicode": "U+1D6CC"},
        {"letter_name": "mu", "variant": "bold", "symbol": "ğ›", "unicode": "U+1D6CD"},
        {"letter_name": "nu", "variant": "bold", "symbol": "ğ›", "unicode": "U+1D6CE"},
        {"letter_name": "xi", "variant": "bold", "symbol": "ğ›", "unicode": "U+1D6CF"},
        {"letter_name": "omicron", "variant": "bold", "symbol": "ğ›", "unicode": "U+1D6D0"},
        {"letter_name": "pi", "variant": "bold", "symbol": "ğ›‘", "unicode": "U+1D6D1"},
        {"letter_name": "rho", "variant": "bold", "symbol": "ğ›’", "unicode": "U+1D6D2"},
        {"letter_name": "sigma", "variant": "bold", "symbol": "ğ›”", "unicode": "U+1D6D4"},
        {"letter_name": "tau", "variant": "bold", "symbol": "ğ›•", "unicode": "U+1D6D5"},
        {"letter_name": "upsilon", "variant": "bold", "symbol": "ğ›–", "unicode": "U+1D6D6"},
        {"letter_name": "phi", "variant": "bold", "symbol": "ğ›—", "unicode": "U+1D6D7"},
        {"letter_name": "chi", "variant": "bold", "symbol": "ğ›˜", "unicode": "U+1D6D8"},
        {"letter_name": "psi", "variant": "bold", "symbol": "ğ›™", "unicode": "U+1D6D9"},
        {"letter_name": "omega", "variant": "bold", "symbol": "ğ›š", "unicode": "U+1D6DA"}
    ]
    
    Set bold_variants to List.concat(bold_uppercase, bold_lowercase)
    Return bold_variants

Process called "get_italic_greek_letters" that returns List[GreekLetterVariant]:
    Note: Get italic Greek letters (ğ›¢, ğ›£, ğ›¤, ğ›¼, ğ›½, ğ›¾, etc.)
    Let italic_variants be []
    
    Note: Italic uppercase Greek letters (Mathematical Italic)
    Let italic_uppercase be [
        {"letter_name": "alpha", "variant": "italic", "symbol": "ğ›¢", "unicode": "U+1D6E2"},
        {"letter_name": "beta", "variant": "italic", "symbol": "ğ›£", "unicode": "U+1D6E3"},
        {"letter_name": "gamma", "variant": "italic", "symbol": "ğ›¤", "unicode": "U+1D6E4"},
        {"letter_name": "delta", "variant": "italic", "symbol": "ğ›¥", "unicode": "U+1D6E5"},
        {"letter_name": "epsilon", "variant": "italic", "symbol": "ğ›¦", "unicode": "U+1D6E6"},
        {"letter_name": "zeta", "variant": "italic", "symbol": "ğ›§", "unicode": "U+1D6E7"},
        {"letter_name": "eta", "variant": "italic", "symbol": "ğ›¨", "unicode": "U+1D6E8"},
        {"letter_name": "theta", "variant": "italic", "symbol": "ğ›©", "unicode": "U+1D6E9"},
        {"letter_name": "iota", "variant": "italic", "symbol": "ğ›ª", "unicode": "U+1D6EA"},
        {"letter_name": "kappa", "variant": "italic", "symbol": "ğ›«", "unicode": "U+1D6EB"},
        {"letter_name": "lambda", "variant": "italic", "symbol": "ğ›¬", "unicode": "U+1D6EC"},
        {"letter_name": "mu", "variant": "italic", "symbol": "ğ›­", "unicode": "U+1D6ED"},
        {"letter_name": "nu", "variant": "italic", "symbol": "ğ›®", "unicode": "U+1D6EE"},
        {"letter_name": "xi", "variant": "italic", "symbol": "ğ›¯", "unicode": "U+1D6EF"},
        {"letter_name": "omicron", "variant": "italic", "symbol": "ğ›°", "unicode": "U+1D6F0"},
        {"letter_name": "pi", "variant": "italic", "symbol": "ğ›±", "unicode": "U+1D6F1"},
        {"letter_name": "rho", "variant": "italic", "symbol": "ğ›²", "unicode": "U+1D6F2"},
        {"letter_name": "sigma", "variant": "italic", "symbol": "ğ›´", "unicode": "U+1D6F4"},
        {"letter_name": "tau", "variant": "italic", "symbol": "ğ›µ", "unicode": "U+1D6F5"},
        {"letter_name": "upsilon", "variant": "italic", "symbol": "ğ›¶", "unicode": "U+1D6F6"},
        {"letter_name": "phi", "variant": "italic", "symbol": "ğ›·", "unicode": "U+1D6F7"},
        {"letter_name": "chi", "variant": "italic", "symbol": "ğ›¸", "unicode": "U+1D6F8"},
        {"letter_name": "psi", "variant": "italic", "symbol": "ğ›¹", "unicode": "U+1D6F9"},
        {"letter_name": "omega", "variant": "italic", "symbol": "ğ›º", "unicode": "U+1D6FA"}
    ]
    
    Note: Italic lowercase Greek letters (Mathematical Italic)
    Let italic_lowercase be [
        {"letter_name": "alpha", "variant": "italic", "symbol": "ğ›¼", "unicode": "U+1D6FC"},
        {"letter_name": "beta", "variant": "italic", "symbol": "ğ›½", "unicode": "U+1D6FD"},
        {"letter_name": "gamma", "variant": "italic", "symbol": "ğ›¾", "unicode": "U+1D6FE"},
        {"letter_name": "delta", "variant": "italic", "symbol": "ğ›¿", "unicode": "U+1D6FF"},
        {"letter_name": "epsilon", "variant": "italic", "symbol": "ğœ€", "unicode": "U+1D700"},
        {"letter_name": "zeta", "variant": "italic", "symbol": "ğœ", "unicode": "U+1D701"},
        {"letter_name": "eta", "variant": "italic", "symbol": "ğœ‚", "unicode": "U+1D702"},
        {"letter_name": "theta", "variant": "italic", "symbol": "ğœƒ", "unicode": "U+1D703"},
        {"letter_name": "iota", "variant": "italic", "symbol": "ğœ„", "unicode": "U+1D704"},
        {"letter_name": "kappa", "variant": "italic", "symbol": "ğœ…", "unicode": "U+1D705"},
        {"letter_name": "lambda", "variant": "italic", "symbol": "ğœ†", "unicode": "U+1D706"},
        {"letter_name": "mu", "variant": "italic", "symbol": "ğœ‡", "unicode": "U+1D707"},
        {"letter_name": "nu", "variant": "italic", "symbol": "ğœˆ", "unicode": "U+1D708"},
        {"letter_name": "xi", "variant": "italic", "symbol": "ğœ‰", "unicode": "U+1D709"},
        {"letter_name": "omicron", "variant": "italic", "symbol": "ğœŠ", "unicode": "U+1D70A"},
        {"letter_name": "pi", "variant": "italic", "symbol": "ğœ‹", "unicode": "U+1D70B"},
        {"letter_name": "rho", "variant": "italic", "symbol": "ğœŒ", "unicode": "U+1D70C"},
        {"letter_name": "sigma", "variant": "italic", "symbol": "ğœ", "unicode": "U+1D70E"},
        {"letter_name": "tau", "variant": "italic", "symbol": "ğœ", "unicode": "U+1D70F"},
        {"letter_name": "upsilon", "variant": "italic", "symbol": "ğœ", "unicode": "U+1D710"},
        {"letter_name": "phi", "variant": "italic", "symbol": "ğœ‘", "unicode": "U+1D711"},
        {"letter_name": "chi", "variant": "italic", "symbol": "ğœ’", "unicode": "U+1D712"},
        {"letter_name": "psi", "variant": "italic", "symbol": "ğœ“", "unicode": "U+1D713"},
        {"letter_name": "omega", "variant": "italic", "symbol": "ğœ”", "unicode": "U+1D714"}
    ]
    
    Set italic_variants to List.concat(italic_uppercase, italic_lowercase)
    Return italic_variants

Process called "get_bold_italic_greek_letters" that returns List[GreekLetterVariant]:
    Note: Get bold italic Greek letters (ğœœ, ğœ, ğœ, ğœ¶, ğœ·, ğœ¸, etc.)
    Let bold_italic_variants be []
    
    Note: Bold italic uppercase Greek letters (Mathematical Bold Italic)
    Let bold_italic_uppercase be [
        {"letter_name": "alpha", "variant": "bold_italic", "symbol": "ğœœ", "unicode": "U+1D71C"},
        {"letter_name": "beta", "variant": "bold_italic", "symbol": "ğœ", "unicode": "U+1D71D"},
        {"letter_name": "gamma", "variant": "bold_italic", "symbol": "ğœ", "unicode": "U+1D71E"},
        {"letter_name": "delta", "variant": "bold_italic", "symbol": "ğœŸ", "unicode": "U+1D71F"},
        {"letter_name": "epsilon", "variant": "bold_italic", "symbol": "ğœ ", "unicode": "U+1D720"},
        {"letter_name": "zeta", "variant": "bold_italic", "symbol": "ğœ¡", "unicode": "U+1D721"},
        {"letter_name": "eta", "variant": "bold_italic", "symbol": "ğœ¢", "unicode": "U+1D722"},
        {"letter_name": "theta", "variant": "bold_italic", "symbol": "ğœ£", "unicode": "U+1D723"},
        {"letter_name": "iota", "variant": "bold_italic", "symbol": "ğœ¤", "unicode": "U+1D724"},
        {"letter_name": "kappa", "variant": "bold_italic", "symbol": "ğœ¥", "unicode": "U+1D725"},
        {"letter_name": "lambda", "variant": "bold_italic", "symbol": "ğœ¦", "unicode": "U+1D726"},
        {"letter_name": "mu", "variant": "bold_italic", "symbol": "ğœ§", "unicode": "U+1D727"},
        {"letter_name": "nu", "variant": "bold_italic", "symbol": "ğœ¨", "unicode": "U+1D728"},
        {"letter_name": "xi", "variant": "bold_italic", "symbol": "ğœ©", "unicode": "U+1D729"},
        {"letter_name": "omicron", "variant": "bold_italic", "symbol": "ğœª", "unicode": "U+1D72A"},
        {"letter_name": "pi", "variant": "bold_italic", "symbol": "ğœ«", "unicode": "U+1D72B"},
        {"letter_name": "rho", "variant": "bold_italic", "symbol": "ğœ¬", "unicode": "U+1D72C"},
        {"letter_name": "sigma", "variant": "bold_italic", "symbol": "ğœ®", "unicode": "U+1D72E"},
        {"letter_name": "tau", "variant": "bold_italic", "symbol": "ğœ¯", "unicode": "U+1D72F"},
        {"letter_name": "upsilon", "variant": "bold_italic", "symbol": "ğœ°", "unicode": "U+1D730"},
        {"letter_name": "phi", "variant": "bold_italic", "symbol": "ğœ±", "unicode": "U+1D731"},
        {"letter_name": "chi", "variant": "bold_italic", "symbol": "ğœ²", "unicode": "U+1D732"},
        {"letter_name": "psi", "variant": "bold_italic", "symbol": "ğœ³", "unicode": "U+1D733"},
        {"letter_name": "omega", "variant": "bold_italic", "symbol": "ğœ´", "unicode": "U+1D734"}
    ]
    
    Note: Bold italic lowercase Greek letters (Mathematical Bold Italic)
    Let bold_italic_lowercase be [
        {"letter_name": "alpha", "variant": "bold_italic", "symbol": "ğœ¶", "unicode": "U+1D736"},
        {"letter_name": "beta", "variant": "bold_italic", "symbol": "ğœ·", "unicode": "U+1D737"},
        {"letter_name": "gamma", "variant": "bold_italic", "symbol": "ğœ¸", "unicode": "U+1D738"},
        {"letter_name": "delta", "variant": "bold_italic", "symbol": "ğœ¹", "unicode": "U+1D739"},
        {"letter_name": "epsilon", "variant": "bold_italic", "symbol": "ğœº", "unicode": "U+1D73A"},
        {"letter_name": "zeta", "variant": "bold_italic", "symbol": "ğœ»", "unicode": "U+1D73B"},
        {"letter_name": "eta", "variant": "bold_italic", "symbol": "ğœ¼", "unicode": "U+1D73C"},
        {"letter_name": "theta", "variant": "bold_italic", "symbol": "ğœ½", "unicode": "U+1D73D"},
        {"letter_name": "iota", "variant": "bold_italic", "symbol": "ğœ¾", "unicode": "U+1D73E"},
        {"letter_name": "kappa", "variant": "bold_italic", "symbol": "ğœ¿", "unicode": "U+1D73F"},
        {"letter_name": "lambda", "variant": "bold_italic", "symbol": "ğ€", "unicode": "U+1D740"},
        {"letter_name": "mu", "variant": "bold_italic", "symbol": "ğ", "unicode": "U+1D741"},
        {"letter_name": "nu", "variant": "bold_italic", "symbol": "ğ‚", "unicode": "U+1D742"},
        {"letter_name": "xi", "variant": "bold_italic", "symbol": "ğƒ", "unicode": "U+1D743"},
        {"letter_name": "omicron", "variant": "bold_italic", "symbol": "ğ„", "unicode": "U+1D744"},
        {"letter_name": "pi", "variant": "bold_italic", "symbol": "ğ…", "unicode": "U+1D745"},
        {"letter_name": "rho", "variant": "bold_italic", "symbol": "ğ†", "unicode": "U+1D746"},
        {"letter_name": "sigma", "variant": "bold_italic", "symbol": "ğˆ", "unicode": "U+1D748"},
        {"letter_name": "tau", "variant": "bold_italic", "symbol": "ğ‰", "unicode": "U+1D749"},
        {"letter_name": "upsilon", "variant": "bold_italic", "symbol": "ğŠ", "unicode": "U+1D74A"},
        {"letter_name": "phi", "variant": "bold_italic", "symbol": "ğ‹", "unicode": "U+1D74B"},
        {"letter_name": "chi", "variant": "bold_italic", "symbol": "ğŒ", "unicode": "U+1D74C"},
        {"letter_name": "psi", "variant": "bold_italic", "symbol": "ğ", "unicode": "U+1D74D"},
        {"letter_name": "omega", "variant": "bold_italic", "symbol": "ğ", "unicode": "U+1D74E"}
    ]
    
    Set bold_italic_variants to List.concat(bold_italic_uppercase, bold_italic_lowercase)
    Return bold_italic_variants

Process called "get_script_greek_letters" that returns List[GreekLetterVariant]:
    Note: Get script-style Greek letters where available
    Let script_variants be []
    
    Note: Script uppercase Greek letters (Mathematical Script minus limited availability)
    Let script_uppercase be [
        {"letter_name": "alpha", "variant": "script", "symbol": "ğ“¶", "unicode": "U+1D4F6"},
        {"letter_name": "beta", "variant": "script", "symbol": "ğ“·", "unicode": "U+1D4F7"},
        {"letter_name": "gamma", "variant": "script", "symbol": "ğ“¸", "unicode": "U+1D4F8"},
        {"letter_name": "delta", "variant": "script", "symbol": "ğ“¹", "unicode": "U+1D4F9"},
        {"letter_name": "epsilon", "variant": "script", "symbol": "ğ“º", "unicode": "U+1D4FA"},
        {"letter_name": "zeta", "variant": "script", "symbol": "ğ“»", "unicode": "U+1D4FB"},
        {"letter_name": "eta", "variant": "script", "symbol": "ğ“¼", "unicode": "U+1D4FC"},
        {"letter_name": "theta", "variant": "script", "symbol": "ğ“½", "unicode": "U+1D4FD"},
        {"letter_name": "iota", "variant": "script", "symbol": "ğ“¾", "unicode": "U+1D4FE"},
        {"letter_name": "kappa", "variant": "script", "symbol": "ğ“¿", "unicode": "U+1D4FF"},
        {"letter_name": "lambda", "variant": "script", "symbol": "ğ”€", "unicode": "U+1D500"},
        {"letter_name": "mu", "variant": "script", "symbol": "ğ”", "unicode": "U+1D501"},
        {"letter_name": "nu", "variant": "script", "symbol": "ğ”‚", "unicode": "U+1D502"},
        {"letter_name": "xi", "variant": "script", "symbol": "ğ”ƒ", "unicode": "U+1D503"},
        {"letter_name": "omicron", "variant": "script", "symbol": "ğ”„", "unicode": "U+1D504"},
        {"letter_name": "pi", "variant": "script", "symbol": "ğ”…", "unicode": "U+1D505"},
        {"letter_name": "rho", "variant": "script", "symbol": "ğ”†", "unicode": "U+1D506"},
        {"letter_name": "sigma", "variant": "script", "symbol": "ğ”ˆ", "unicode": "U+1D508"},
        {"letter_name": "tau", "variant": "script", "symbol": "ğ”‰", "unicode": "U+1D509"},
        {"letter_name": "upsilon", "variant": "script", "symbol": "ğ”Š", "unicode": "U+1D50A"},
        {"letter_name": "phi", "variant": "script", "symbol": "ğ”‹", "unicode": "U+1D50B"},
        {"letter_name": "chi", "variant": "script", "symbol": "ğ”Œ", "unicode": "U+1D50C"},
        {"letter_name": "psi", "variant": "script", "symbol": "ğ”", "unicode": "U+1D50D"},
        {"letter_name": "omega", "variant": "script", "symbol": "ğ”", "unicode": "U+1D50E"}
    ]
    
    Note: Script lowercase Greek letters (Mathematical Script minus limited availability)
    Let script_lowercase be [
        {"letter_name": "alpha", "variant": "script", "symbol": "ğ”", "unicode": "U+1D510"},
        {"letter_name": "beta", "variant": "script", "symbol": "ğ”‘", "unicode": "U+1D511"},
        {"letter_name": "gamma", "variant": "script", "symbol": "ğ”’", "unicode": "U+1D512"},
        {"letter_name": "delta", "variant": "script", "symbol": "ğ”“", "unicode": "U+1D513"},
        {"letter_name": "epsilon", "variant": "script", "symbol": "ğ””", "unicode": "U+1D514"},
        {"letter_name": "zeta", "variant": "script", "symbol": "ğ”•", "unicode": "U+1D515"},
        {"letter_name": "eta", "variant": "script", "symbol": "ğ”–", "unicode": "U+1D516"},
        {"letter_name": "theta", "variant": "script", "symbol": "ğ”—", "unicode": "U+1D517"},
        {"letter_name": "iota", "variant": "script", "symbol": "ğ”˜", "unicode": "U+1D518"},
        {"letter_name": "kappa", "variant": "script", "symbol": "ğ”™", "unicode": "U+1D519"},
        {"letter_name": "lambda", "variant": "script", "symbol": "ğ”š", "unicode": "U+1D51A"},
        {"letter_name": "mu", "variant": "script", "symbol": "ğ”›", "unicode": "U+1D51B"},
        {"letter_name": "nu", "variant": "script", "symbol": "ğ”œ", "unicode": "U+1D51C"},
        {"letter_name": "xi", "variant": "script", "symbol": "ğ”", "unicode": "U+1D51D"},
        {"letter_name": "omicron", "variant": "script", "symbol": "ğ”", "unicode": "U+1D51E"},
        {"letter_name": "pi", "variant": "script", "symbol": "ğ”Ÿ", "unicode": "U+1D51F"},
        {"letter_name": "rho", "variant": "script", "symbol": "ğ” ", "unicode": "U+1D520"},
        {"letter_name": "sigma", "variant": "script", "symbol": "ğ”¢", "unicode": "U+1D522"},
        {"letter_name": "tau", "variant": "script", "symbol": "ğ”£", "unicode": "U+1D523"},
        {"letter_name": "upsilon", "variant": "script", "symbol": "ğ”¤", "unicode": "U+1D524"},
        {"letter_name": "phi", "variant": "script", "symbol": "ğ”¥", "unicode": "U+1D525"},
        {"letter_name": "chi", "variant": "script", "symbol": "ğ”¦", "unicode": "U+1D526"},
        {"letter_name": "psi", "variant": "script", "symbol": "ğ”§", "unicode": "U+1D527"},
        {"letter_name": "omega", "variant": "script", "symbol": "ğ”¨", "unicode": "U+1D528"}
    ]
    
    Set script_variants to List.concat(script_uppercase, script_lowercase)
    Return script_variants

Note: =====================================================================
Note: PRONUNCIATION AND TRANSLITERATION
Note: =====================================================================

Process called "get_greek_letter_pronunciation" that takes letter_name as String returns String:
    Note: Get pronunciation guide for Greek letter
    Let pronunciation_map be {
        "alpha": "AL-fah",
        "beta": "BAY-tah",
        "gamma": "GAM-ah",
        "delta": "DEL-tah",
        "epsilon": "EP-si-lon",
        "zeta": "ZAY-tah",
        "eta": "AY-tah",
        "theta": "THAY-tah",
        "iota": "eye-OH-tah",
        "kappa": "KAP-ah",
        "lambda": "LAM-dah",
        "mu": "myoo",
        "nu": "nyoo",
        "xi": "ksee",
        "omicron": "OH-mi-kron",
        "pi": "pie",
        "rho": "roh",
        "sigma": "SIG-mah",
        "tau": "tow",
        "upsilon": "OOP-si-lon",
        "phi": "fie",
        "chi": "kie",
        "psi": "sie",
        "omega": "oh-MAY-gah"
    }
    
    Let pronunciation be Dictionary.get(pronunciation_map, letter_name, "")
    If pronunciation is equal to "":
        Return "Unknown pronunciation for letter: " plus letter_name
    Otherwise:
        Return pronunciation

Process called "get_greek_letter_transliteration" that takes letter_name as String returns String:
    Note: Get Latin transliteration of Greek letter
    Let transliteration_map be {
        "alpha": "a",
        "beta": "b",
        "gamma": "g",
        "delta": "d",
        "epsilon": "e",
        "zeta": "z",
        "eta": "Ä“",
        "theta": "th",
        "iota": "i",
        "kappa": "k",
        "lambda": "l",
        "mu": "m",
        "nu": "n",
        "xi": "x",
        "omicron": "o",
        "pi": "p",
        "rho": "r",
        "sigma": "s",
        "tau": "t",
        "upsilon": "u",
        "phi": "ph",
        "chi": "ch",
        "psi": "ps",
        "omega": "Å"
    }
    
    Let transliteration be Dictionary.get(transliteration_map, letter_name, "")
    If transliteration is equal to "":
        Return "Unknown transliteration for letter: " plus letter_name
    Otherwise:
        Return transliteration

Process called "ancient_vs_modern_pronunciation" that takes letter_name as String returns Dictionary[String, String]:
    Note: Compare ancient and modern Greek pronunciation
    Let pronunciation_comparison be {
        "alpha": {"ancient": "AL-pha", "modern": "AL-fa"},
        "beta": {"ancient": "BAY-ta", "modern": "VEE-ta"},
        "gamma": {"ancient": "GAM-ma", "modern": "GHAH-ma"},
        "delta": {"ancient": "DEL-ta", "modern": "THEL-ta"},
        "epsilon": {"ancient": "EP-si-lon", "modern": "EP-si-lon"},
        "zeta": {"ancient": "DZAY-ta", "modern": "ZEE-ta"},
        "eta": {"ancient": "AY-ta", "modern": "EE-ta"},
        "theta": {"ancient": "t-HAY-ta", "modern": "THEE-ta"},
        "iota": {"ancient": "ee-OH-ta", "modern": "YO-ta"},
        "kappa": {"ancient": "KAP-pa", "modern": "KAH-pa"},
        "lambda": {"ancient": "LAM-da", "modern": "LAHM-tha"},
        "mu": {"ancient": "moo", "modern": "mee"},
        "nu": {"ancient": "noo", "modern": "nee"},
        "xi": {"ancient": "KSEE", "modern": "KSEE"},
        "omicron": {"ancient": "OH-mi-kron", "modern": "OH-mi-kron"},
        "pi": {"ancient": "PEE", "modern": "PEE"},
        "rho": {"ancient": "r-HOH", "modern": "ROH"},
        "sigma": {"ancient": "SIG-ma", "modern": "SIGH-ma"},
        "tau": {"ancient": "TOW", "modern": "TAF"},
        "upsilon": {"ancient": "OO-psi-lon", "modern": "EEP-si-lon"},
        "phi": {"ancient": "p-HEE", "modern": "FEE"},
        "chi": {"ancient": "k-HEE", "modern": "KHEE"},
        "psi": {"ancient": "p-SEE", "modern": "PSEE"},
        "omega": {"ancient": "OH-may-ga", "modern": "oh-MEH-ga"}
    }
    
    Let comparison be Dictionary.get(pronunciation_comparison, letter_name, {})
    If Dictionary.size(comparison) is equal to 0:
        Return {"error": "Unknown letter: " plus letter_name}
    Otherwise:
        Return comparison

Note: =====================================================================
Note: HISTORICAL AND ETYMOLOGICAL OPERATIONS
Note: =====================================================================

Process called "get_letter_etymology" that takes letter_name as String returns String:
    Note: Get etymological information about Greek letter
    Let etymology_map be {
        "alpha": "From Phoenician aleph, meaning 'ox'. Originally represented the glottal stop, evolved to represent the vowel sound.",
        "beta": "From Phoenician beth, meaning 'house'. Retained its consonantal value throughout Greek evolution.",
        "gamma": "From Phoenician gimel, meaning 'camel'. Originally a hard 'g' sound, evolved to various pronunciations.",
        "delta": "From Phoenician daleth, meaning 'door'. Maintained its dental consonant sound through history.",
        "epsilon": "Developed from Phoenician he. Originally a consonant, became the short 'e' vowel in Greek.",
        "zeta": "From Phoenician zayin, meaning 'weapon'. Evolved from a hard 'z' to various sibilant sounds.",
        "eta": "Originally from Phoenician heth. In early Greek dialects represented 'h', later became long 'e'.",
        "theta": "Unique Greek innovation, possibly from Phoenician teth. Represents the aspirated 't' sound.",
        "iota": "From Phoenician yodh, meaning 'hand'. Smallest letter, hence 'not one iota' meaning 'not the least bit'.",
        "kappa": "From Phoenician kaph, meaning 'palm of hand'. Maintained its velar stop pronunciation.",
        "lambda": "From Phoenician lamedh, meaning 'goad' or 'staff'. Retained its lateral consonant sound.",
        "mu": "From Phoenician mem, meaning 'water'. Maintained its bilabial nasal sound throughout history.",
        "nu": "From Phoenician nun, meaning 'fish' or 'serpent'. Retained its dental nasal pronunciation.",
        "xi": "Greek innovation, possibly from Phoenician samekh. Represents the double consonant 'ks'.",
        "omicron": "Means 'small o' in Greek, distinguishing it from omega ('big o'). Short vowel sound.",
        "pi": "From Phoenician pe, meaning 'mouth'. Maintained its bilabial stop sound in ancient Greek.",
        "rho": "From Phoenician resh, meaning 'head'. Retained its liquid consonant sound throughout history.",
        "sigma": "From Phoenician shin, meaning 'tooth'. Evolved to represent various sibilant sounds.",
        "tau": "From Phoenician taw, meaning 'mark' or 'sign'. Maintained its dental stop pronunciation.",
        "upsilon": "Originally from Phoenician waw. Developed into a distinct vowel sound separate from omicron.",
        "phi": "Greek innovation representing aspirated 'p'. Originally written as P with vertical line through it.",
        "chi": "From Phoenician qoph. Represents aspirated 'k' sound, evolved to fricative in modern Greek.",
        "psi": "Greek innovation representing 'ps' sound cluster. Late addition to the alphabet.",
        "omega": "Means 'big o' in Greek, represents long 'o' sound. Developed to distinguish from omicron."
    }
    
    Let etymology be Dictionary.get(etymology_map, letter_name, "")
    If etymology is equal to "":
        Return "No etymological information available for letter: " plus letter_name
    Otherwise:
        Return etymology

Process called "get_phoenician_origin" that takes letter_name as String returns Dictionary[String, String]:
    Note: Get Phoenician origin of Greek letter
    Let phoenician_origins be {
        "alpha": {"phoenician_letter": "aleph", "meaning": "ox", "symbol": "ğ¤€", "evolution": "glottal_stop_to_vowel"},
        "beta": {"phoenician_letter": "beth", "meaning": "house", "symbol": "ğ¤", "evolution": "consonant_preserved"},
        "gamma": {"phoenician_letter": "gimel", "meaning": "camel", "symbol": "ğ¤‚", "evolution": "hard_g_to_varied"},
        "delta": {"phoenician_letter": "daleth", "meaning": "door", "symbol": "ğ¤ƒ", "evolution": "dental_preserved"},
        "epsilon": {"phoenician_letter": "he", "meaning": "window", "symbol": "ğ¤„", "evolution": "consonant_to_vowel"},
        "zeta": {"phoenician_letter": "zayin", "meaning": "weapon", "symbol": "ğ¤…", "evolution": "sibilant_evolved"},
        "eta": {"phoenician_letter": "heth", "meaning": "fence", "symbol": "ğ¤†", "evolution": "fricative_to_vowel"},
        "theta": {"phoenician_letter": "teth", "meaning": "wheel", "symbol": "ğ¤‡", "evolution": "aspirated_innovation"},
        "iota": {"phoenician_letter": "yodh", "meaning": "hand", "symbol": "ğ¤ˆ", "evolution": "consonant_to_vowel"},
        "kappa": {"phoenician_letter": "kaph", "meaning": "palm", "symbol": "ğ¤‰", "evolution": "velar_preserved"},
        "lambda": {"phoenician_letter": "lamedh", "meaning": "goad", "symbol": "ğ¤Š", "evolution": "lateral_preserved"},
        "mu": {"phoenician_letter": "mem", "meaning": "water", "symbol": "ğ¤‹", "evolution": "nasal_preserved"},
        "nu": {"phoenician_letter": "nun", "meaning": "fish", "symbol": "ğ¤Œ", "evolution": "nasal_preserved"},
        "xi": {"phoenician_letter": "samekh", "meaning": "support", "symbol": "ğ¤", "evolution": "cluster_innovation"},
        "omicron": {"phoenician_letter": "ayin", "meaning": "eye", "symbol": "ğ¤", "evolution": "consonant_to_vowel"},
        "pi": {"phoenician_letter": "pe", "meaning": "mouth", "symbol": "ğ¤", "evolution": "bilabial_preserved"},
        "rho": {"phoenician_letter": "resh", "meaning": "head", "symbol": "ğ¤", "evolution": "liquid_preserved"},
        "sigma": {"phoenician_letter": "shin", "meaning": "tooth", "symbol": "ğ¤‘", "evolution": "sibilant_simplified"},
        "tau": {"phoenician_letter": "taw", "meaning": "mark", "symbol": "ğ¤’", "evolution": "dental_preserved"},
        "upsilon": {"phoenician_letter": "waw", "meaning": "hook", "symbol": "ğ¤“", "evolution": "consonant_to_vowel"},
        "phi": {"phoenician_letter": "none", "meaning": "greek_innovation", "symbol": "none", "evolution": "aspirated_creation"},
        "chi": {"phoenician_letter": "qoph", "meaning": "needle_eye", "symbol": "ğ¤”", "evolution": "uvular_to_fricative"},
        "psi": {"phoenician_letter": "none", "meaning": "greek_innovation", "symbol": "none", "evolution": "cluster_creation"},
        "omega": {"phoenician_letter": "none", "meaning": "greek_innovation", "symbol": "none", "evolution": "vowel_distinction"}
    }
    
    Let origin_info be Dictionary.get(phoenician_origins, letter_name, {})
    If Dictionary.size(origin_info) is equal to 0:
        Return {"error": "No Phoenician origin information for letter: " plus letter_name}
    Otherwise:
        Return origin_info

Process called "get_mathematical_history" that takes letter_name as String returns String:
    Note: Get history of letter's use in mathematics
    Let math_history_map be {
        "alpha": "Used since Euler for angles, coefficients, and the fine structure constant (Î± â‰ˆ 1/137). Common in physics for angular acceleration and thermal expansion.",
        "beta": "Introduced by Euler for angles, widely used in physics for velocity ratios (v/c), and in statistics for beta distributions and regression coefficients.",
        "gamma": "Used by Euler for the Euler-Mascheroni constant (Î³ â‰ˆ 0.5772). Common for Lorentz factor in relativity and gamma functions in analysis.",
        "delta": "Ancient symbol for change, formalized by Leibniz in calculus for infinitesimals. Modern usage includes Dirac delta function and Kronecker delta.",
        "epsilon": "Introduced by Weierstrass for arbitrarily small positive quantities in analysis. Essential in limit definitions and set theory (âˆˆ).",
        "zeta": "Famous for Riemann zeta function Î¶(s), central to number theory and the Riemann Hypothesis. Used since Riemann's 1859 paper.",
        "eta": "Used in physics for efficiency (Î·), viscosity, and pseudorapidity in particle physics. Less common in pure mathematics.",
        "theta": "Traditional symbol for angles since ancient Greek geometry. Used in spherical coordinates, trigonometry, and Jacobi theta functions.",
        "iota": "Rarely used in mathematics due to confusion with 'i'. Occasionally appears in complex analysis and set theory contexts.",
        "kappa": "Used in differential geometry for curvature, condition numbers in numerical analysis, and von KÃ¡rmÃ¡n constant in fluid dynamics.",
        "lambda": "Introduced by Church for lambda calculus (1930s). Used for eigenvalues, wavelength in physics, and Lebesgue measure theory.",
        "mu": "Used for mean in statistics, measure theory, magnetic permeability in physics, and friction coefficients in mechanics.",
        "nu": "Common for frequency in physics and engineering, degrees of freedom in statistics, and kinematic viscosity in fluid mechanics.",
        "xi": "Used in probability for random variables, particularly in statistics and stochastic processes. Less common than other Greek letters.",
        "omicron": "Rarely used in mathematics due to confusion with zero and Latin 'O'. Occasionally appears in combinatorics.",
        "pi": "Most famous mathematical constant (Ï€ â‰ˆ 3.14159), used since Archimedes. Symbol Ï€ introduced by William Jones (1706), popularized by Euler.",
        "rho": "Used for density in physics, correlation coefficients in statistics, and resistivity in electrical engineering since the 19th century.",
        "sigma": "Introduced by Euler for summation (Î£). Used for standard deviation (Ïƒ), stress in mechanics, and cross-sections in physics.",
        "tau": "Traditional symbol for time, torque, proper time in relativity. Recently proposed as 2Ï€ by Michael Hartl (2010) for 'tau manifesto'.",
        "upsilon": "Rarely used in mathematics. Occasionally appears in particle physics for upsilon mesons and some specialized mathematical contexts.",
        "phi": "Used for golden ratio (Ï† â‰ˆ 1.618) since 20th century, angles in spherical coordinates, and Euler's totient function Ï†(n).",
        "chi": "Used for chi-squared distribution (Ï‡Â²) in statistics since Karl Pearson (1900), and characteristic functions in analysis.",
        "psi": "Used for wave functions in quantum mechanics since SchrÃ¶dinger (1926), digamma function Ïˆ(x), and angles in mathematics.",
        "omega": "Used for angular frequency (Ï‰) in physics, the set of natural numbers in set theory, and resistance in electrical circuits (Î©)."
    }
    
    Let history be Dictionary.get(math_history_map, letter_name, "")
    If history is equal to "":
        Return "No mathematical history available for letter: " plus letter_name
    Otherwise:
        Return history

Note: =====================================================================
Note: SYMBOL SEARCH AND CLASSIFICATION
Note: =====================================================================

Process called "find_greek_letter_by_name" that takes letter_name as String returns GreekLetter:
    Note: Find Greek letter by name (alpha, beta, gamma, etc.)
    Let normalized_name be String.toLowerCase(letter_name)
    
    If normalized_name is equal to "alpha":
        Return alpha_symbols()
    Otherwise if normalized_name is equal to "beta":
        Return beta_symbols()
    Otherwise if normalized_name is equal to "gamma":
        Return gamma_symbols()
    Otherwise if normalized_name is equal to "delta":
        Return delta_symbols()
    Otherwise if normalized_name is equal to "epsilon":
        Return epsilon_symbols()
    Otherwise if normalized_name is equal to "zeta":
        Return zeta_symbols()
    Otherwise if normalized_name is equal to "eta":
        Return eta_symbols()
    Otherwise if normalized_name is equal to "theta":
        Return theta_symbols()
    Otherwise if normalized_name is equal to "iota":
        Return iota_symbols()
    Otherwise if normalized_name is equal to "kappa":
        Return kappa_symbols()
    Otherwise if normalized_name is equal to "lambda":
        Return lambda_symbols()
    Otherwise if normalized_name is equal to "mu":
        Return mu_symbols()
    Otherwise if normalized_name is equal to "nu":
        Return nu_symbols()
    Otherwise if normalized_name is equal to "xi":
        Return xi_symbols()
    Otherwise if normalized_name is equal to "omicron":
        Return omicron_symbols()
    Otherwise if normalized_name is equal to "pi":
        Return pi_symbols()
    Otherwise if normalized_name is equal to "rho":
        Return rho_symbols()
    Otherwise if normalized_name is equal to "sigma":
        Return sigma_symbols()
    Otherwise if normalized_name is equal to "tau":
        Return tau_symbols()
    Otherwise if normalized_name is equal to "upsilon":
        Return upsilon_symbols()
    Otherwise if normalized_name is equal to "phi":
        Return phi_symbols()
    Otherwise if normalized_name is equal to "chi":
        Return chi_symbols()
    Otherwise if normalized_name is equal to "psi":
        Return psi_symbols()
    Otherwise if normalized_name is equal to "omega":
        Return omega_symbols()
    Otherwise:
        Throw Errors.InvalidArgument with "Unknown Greek letter name: " plus letter_name

Process called "find_greek_letter_by_symbol" that takes symbol as String returns GreekLetter:
    Note: Find Greek letter information by Unicode symbol
    Let all_letters be get_complete_greek_alphabet()
    
    For each letter in all_letters:
        If letter.uppercase_symbol is equal to symbol || letter.lowercase_symbol is equal to symbol:
            Return letter
    
    Throw Errors.InvalidArgument with "Symbol not found in Greek alphabet: " plus symbol

Process called "classify_greek_letter_usage" that takes letter_name as String, context as String returns String:
    Note: Classify Greek letter usage in mathematical context
    Let letter be find_greek_letter_by_name(letter_name)
    Let usage_list be letter.mathematical_usage
    
    If context is equal to "calculus":
        If List.contains(usage_list, "small_quantity") || List.contains(usage_list, "change"):
            Return "limit_variable"
        Otherwise if List.contains(usage_list, "angle"):
            Return "parameter"
        Otherwise:
            Return "general_variable"
    
    Otherwise if context is equal to "physics":
        If List.contains(usage_list, "angle"):
            Return "angular_measurement"
        Otherwise if List.contains(usage_list, "coefficient"):
            Return "physical_constant"
        Otherwise:
            Return "physical_parameter"
    
    Otherwise if context is equal to "statistics":
        If List.contains(usage_list, "mean"):
            Return "central_tendency"
        Otherwise if List.contains(usage_list, "standard_deviation"):
            Return "dispersion_measure"
        Otherwise:
            Return "statistical_parameter"
    
    Otherwise:
        Return "general_mathematical_symbol"

Process called "get_similar_letters" that takes reference_letter as String returns List[GreekLetter]:
    Note: Get Greek letters similar to reference letter
    Let similar_letters be []
    
    If reference_letter is equal to "alpha":
        Append lambda_symbols() to similar_letters
    Otherwise if reference_letter is equal to "beta":
        Append eta_symbols() to similar_letters
    Otherwise if reference_letter is equal to "gamma":
        Append upsilon_symbols() to similar_letters
    Otherwise if reference_letter is equal to "delta":
        Append lambda_symbols() to similar_letters
    Otherwise if reference_letter is equal to "epsilon":
        Append xi_symbols() to similar_letters
    Otherwise if reference_letter is equal to "zeta":
        Append xi_symbols() to similar_letters
    Otherwise if reference_letter is equal to "theta":
        Append phi_symbols() to similar_letters
    Otherwise if reference_letter is equal to "kappa":
        Append chi_symbols() to similar_letters
    Otherwise if reference_letter is equal to "mu":
        Append nu_symbols() to similar_letters
    Otherwise if reference_letter is equal to "nu":
        Append mu_symbols() to similar_letters
    Otherwise if reference_letter is equal to "omicron":
        Append sigma_symbols() to similar_letters
    Otherwise if reference_letter is equal to "rho":
        Append pi_symbols() to similar_letters
    Otherwise if reference_letter is equal to "upsilon":
        Append psi_symbols() to similar_letters
    
    Return similar_letters

Note: =====================================================================
Note: ENCODING AND NORMALIZATION OPERATIONS
Note: =====================================================================

Process called "normalize_greek_unicode" that takes greek_text as String, normalization_form as String returns String:
    Note: Apply Unicode normalization to Greek text
    Let normalized_text be greek_text
    
    Note: Apply normalization based on form (NFC, NFD, NFKC, NFKD)
    If normalization_form is equal to "NFC":
        Note: Canonical composition minus combine base plus diacritics
        Set normalized_text to String.replace_all(normalized_text, "Î±\u0301", "Î¬")
        Set normalized_text to String.replace_all(normalized_text, "Îµ\u0301", "Î­")
        Set normalized_text to String.replace_all(normalized_text, "Î·\u0301", "Î®")
        Set normalized_text to String.replace_all(normalized_text, "Î¹\u0301", "Î¯")
        Set normalized_text to String.replace_all(normalized_text, "Î¿\u0301", "ÏŒ")
        Set normalized_text to String.replace_all(normalized_text, "Ï…\u0301", "Ï")
        Set normalized_text to String.replace_all(normalized_text, "Ï‰\u0301", "Ï")
    Otherwise if normalization_form is equal to "NFD":
        Note: Canonical decomposition minus separate base plus diacritics
        Set normalized_text to String.replace_all(normalized_text, "Î¬", "Î±\u0301")
        Set normalized_text to String.replace_all(normalized_text, "Î­", "Îµ\u0301")
        Set normalized_text to String.replace_all(normalized_text, "Î®", "Î·\u0301")
        Set normalized_text to String.replace_all(normalized_text, "Î¯", "Î¹\u0301")
        Set normalized_text to String.replace_all(normalized_text, "ÏŒ", "Î¿\u0301")
        Set normalized_text to String.replace_all(normalized_text, "Ï", "Ï…\u0301")
        Set normalized_text to String.replace_all(normalized_text, "Ï", "Ï‰\u0301")
    Otherwise if normalization_form is equal to "NFKC":
        Note: Compatibility composition
        Set normalized_text to String.replace_all(normalized_text, "Ï°", "Îº")
        Set normalized_text to String.replace_all(normalized_text, "Ï±", "Ï")
        Set normalized_text to String.replace_all(normalized_text, "Ïµ", "Îµ")
        Set normalized_text to String.replace_all(normalized_text, "Ï‘", "Î¸")
        Set normalized_text to String.replace_all(normalized_text, "Ï•", "Ï†")
        Set normalized_text to String.replace_all(normalized_text, "Ï–", "Ï€")
    Otherwise if normalization_form is equal to "NFKD":
        Note: Compatibility decomposition plus canonical decomposition
        Set normalized_text to String.replace_all(normalized_text, "Ï°", "Îº")
        Set normalized_text to String.replace_all(normalized_text, "Ï±", "Ï")
        Set normalized_text to String.replace_all(normalized_text, "Ïµ", "Îµ")
        Set normalized_text to String.replace_all(normalized_text, "Ï‘", "Î¸")
        Set normalized_text to String.replace_all(normalized_text, "Ï•", "Ï†")
        Set normalized_text to String.replace_all(normalized_text, "Ï–", "Ï€")
        Set normalized_text to String.replace_all(normalized_text, "Î¬", "Î±\u0301")
        Set normalized_text to String.replace_all(normalized_text, "Î­", "Îµ\u0301")
        Set normalized_text to String.replace_all(normalized_text, "Î®", "Î·\u0301")
        Set normalized_text to String.replace_all(normalized_text, "Î¯", "Î¹\u0301")
        Set normalized_text to String.replace_all(normalized_text, "ÏŒ", "Î¿\u0301")
        Set normalized_text to String.replace_all(normalized_text, "Ï", "Ï…\u0301")
        Set normalized_text to String.replace_all(normalized_text, "Ï", "Ï‰\u0301")
    Otherwise:
        Return "Unsupported normalization form: " plus normalization_form
    
    Return normalized_text

Process called "convert_greek_encoding" that takes greek_text as String, from_encoding as String, to_encoding as String returns String:
    Note: Convert between different Greek text encodings
    Let converted_text be greek_text
    
    Note: Handle legacy encodings to Unicode conversion
    If from_encoding is equal to "iso-8859-7" and to_encoding is equal to "utf-8":
        Note: Convert from Greek ISO to UTF-8
        Let iso_to_unicode be {
            "\xC1": "Î‘", "\xC2": "Î’", "\xC3": "Î“", "\xC4": "Î”", "\xC5": "Î•", "\xC6": "Î–",
            "\xC7": "Î—", "\xC8": "Î˜", "\xC9": "Î™", "\xCA": "Îš", "\xCB": "Î›", "\xCC": "Îœ",
            "\xCD": "Î", "\xCE": "Î", "\xCF": "ÎŸ", "\xD0": "Î ", "\xD1": "Î¡", "\xD3": "Î£",
            "\xD4": "Î¤", "\xD5": "Î¥", "\xD6": "Î¦", "\xD7": "Î§", "\xD8": "Î¨", "\xD9": "Î©",
            "\xE1": "Î±", "\xE2": "Î²", "\xE3": "Î³", "\xE4": "Î´", "\xE5": "Îµ", "\xE6": "Î¶",
            "\xE7": "Î·", "\xE8": "Î¸", "\xE9": "Î¹", "\xEA": "Îº", "\xEB": "Î»", "\xEC": "Î¼",
            "\xED": "Î½", "\xEE": "Î¾", "\xEF": "Î¿", "\xF0": "Ï€", "\xF1": "Ï", "\xF2": "Ï‚",
            "\xF3": "Ïƒ", "\xF4": "Ï„", "\xF5": "Ï…", "\xF6": "Ï†", "\xF7": "Ï‡", "\xF8": "Ïˆ", "\xF9": "Ï‰"
        }
        
        Let result be converted_text
        For each (iso_char, unicode_char) in Dictionary.items(iso_to_unicode):
            Set result to String.replace_all(result, iso_char, unicode_char)
        Set converted_text to result
        
    Otherwise if from_encoding is equal to "windows-1253" and to_encoding is equal to "utf-8":
        Note: Convert from Windows Greek to UTF-8
        Let win_to_unicode be {
            "\xC1": "Î‘", "\xC2": "Î’", "\xC3": "Î“", "\xC4": "Î”", "\xC5": "Î•", "\xC6": "Î–",
            "\xC7": "Î—", "\xC8": "Î˜", "\xC9": "Î™", "\xCA": "Îš", "\xCB": "Î›", "\xCC": "Îœ",
            "\xCD": "Î", "\xCE": "Î", "\xCF": "ÎŸ", "\xD0": "Î ", "\xD1": "Î¡", "\xD3": "Î£",
            "\xD4": "Î¤", "\xD5": "Î¥", "\xD6": "Î¦", "\xD7": "Î§", "\xD8": "Î¨", "\xD9": "Î©",
            "\xE1": "Î±", "\xE2": "Î²", "\xE3": "Î³", "\xE4": "Î´", "\xE5": "Îµ", "\xE6": "Î¶",
            "\xE7": "Î·", "\xE8": "Î¸", "\xE9": "Î¹", "\xEA": "Îº", "\xEB": "Î»", "\xEC": "Î¼",
            "\xED": "Î½", "\xEE": "Î¾", "\xEF": "Î¿", "\xF0": "Ï€", "\xF1": "Ï", "\xF2": "Ï‚",
            "\xF3": "Ïƒ", "\xF4": "Ï„", "\xF5": "Ï…", "\xF6": "Ï†", "\xF7": "Ï‡", "\xF8": "Ïˆ", "\xF9": "Ï‰"
        }
        
        Let result be converted_text
        For each (win_char, unicode_char) in Dictionary.items(win_to_unicode):
            Set result to String.replace_all(result, win_char, unicode_char)
        Set converted_text to result
        
    Otherwise if from_encoding is equal to "utf-8" and to_encoding is equal to "ascii":
        Note: Convert Greek Unicode to ASCII transliteration
        Let unicode_to_ascii be {
            "Î‘": "A", "Î’": "B", "Î“": "G", "Î”": "D", "Î•": "E", "Î–": "Z", "Î—": "H", "Î˜": "Th",
            "Î™": "I", "Îš": "K", "Î›": "L", "Îœ": "M", "Î": "N", "Î": "X", "ÎŸ": "O", "Î ": "P",
            "Î¡": "R", "Î£": "S", "Î¤": "T", "Î¥": "Y", "Î¦": "Ph", "Î§": "Ch", "Î¨": "Ps", "Î©": "O",
            "Î±": "a", "Î²": "b", "Î³": "g", "Î´": "d", "Îµ": "e", "Î¶": "z", "Î·": "e", "Î¸": "th",
            "Î¹": "i", "Îº": "k", "Î»": "l", "Î¼": "m", "Î½": "n", "Î¾": "x", "Î¿": "o", "Ï€": "p",
            "Ï": "r", "Ïƒ": "s", "Ï‚": "s", "Ï„": "t", "Ï…": "y", "Ï†": "ph", "Ï‡": "ch", "Ïˆ": "ps", "Ï‰": "o"
        }
        
        Let result be converted_text
        For each (unicode_char, ascii_char) in Dictionary.items(unicode_to_ascii):
            Set result to String.replace_all(result, unicode_char, ascii_char)
        Set converted_text to result
        
    Otherwise:
        Return "Unsupported encoding conversion: " plus from_encoding plus " to " plus to_encoding
    
    Return converted_text

Process called "detect_greek_letter_variants" that takes text as String returns List[Dictionary[String, String]]:
    Note: Detect and classify Greek letter variants in text
    Let detected_variants be []
    
    Note: Define variant detection patterns
    Let variant_patterns be [
        Note: Mathematical bold variants
        {"pattern": "ğš¨|ğš©|ğšª|ğš«|ğš¬|ğš­|ğš®|ğš¯|ğš°|ğš±|ğš²|ğš³|ğš´|ğšµ|ğš¶|ğš·|ğš¸|ğšº|ğš»|ğš¼|ğš½|ğš¾|ğš¿|ğ›€", "style": "bold", "case": "uppercase"},
        {"pattern": "ğ›‚|ğ›ƒ|ğ›„|ğ›…|ğ›†|ğ›‡|ğ›ˆ|ğ›‰|ğ›Š|ğ›‹|ğ›Œ|ğ›|ğ›|ğ›|ğ›|ğ›‘|ğ›’|ğ›”|ğ›•|ğ›–|ğ›—|ğ›˜|ğ›™|ğ›š", "style": "bold", "case": "lowercase"},
        Note: Mathematical italic variants
        {"pattern": "ğ›¢|ğ›£|ğ›¤|ğ›¥|ğ›¦|ğ›§|ğ›¨|ğ›©|ğ›ª|ğ›«|ğ›¬|ğ›­|ğ›®|ğ›¯|ğ›°|ğ›±|ğ›²|ğ›´|ğ›µ|ğ›¶|ğ›·|ğ›¸|ğ›¹|ğ›º", "style": "italic", "case": "uppercase"},
        {"pattern": "ğ›¼|ğ›½|ğ›¾|ğ›¿|ğœ€|ğœ|ğœ‚|ğœƒ|ğœ„|ğœ…|ğœ†|ğœ‡|ğœˆ|ğœ‰|ğœŠ|ğœ‹|ğœŒ|ğœ|ğœ|ğœ|ğœ‘|ğœ’|ğœ“|ğœ”", "style": "italic", "case": "lowercase"},
        Note: Mathematical bold italic variants
        {"pattern": "ğœœ|ğœ|ğœ|ğœŸ|ğœ |ğœ¡|ğœ¢|ğœ£|ğœ¤|ğœ¥|ğœ¦|ğœ§|ğœ¨|ğœ©|ğœª|ğœ«|ğœ¬|ğœ®|ğœ¯|ğœ°|ğœ±|ğœ²|ğœ³|ğœ´", "style": "bold_italic", "case": "uppercase"},
        {"pattern": "ğœ¶|ğœ·|ğœ¸|ğœ¹|ğœº|ğœ»|ğœ¼|ğœ½|ğœ¾|ğœ¿|ğ€|ğ|ğ‚|ğƒ|ğ„|ğ…|ğ†|ğˆ|ğ‰|ğŠ|ğ‹|ğŒ|ğ|ğ", "style": "bold_italic", "case": "lowercase"},
        Note: Regular Greek letters
        {"pattern": "Î‘|Î’|Î“|Î”|Î•|Î–|Î—|Î˜|Î™|Îš|Î›|Îœ|Î|Î|ÎŸ|Î |Î¡|Î£|Î¤|Î¥|Î¦|Î§|Î¨|Î©", "style": "regular", "case": "uppercase"},
        {"pattern": "Î±|Î²|Î³|Î´|Îµ|Î¶|Î·|Î¸|Î¹|Îº|Î»|Î¼|Î½|Î¾|Î¿|Ï€|Ï|Ïƒ|Ï‚|Ï„|Ï…|Ï†|Ï‡|Ïˆ|Ï‰", "style": "regular", "case": "lowercase"},
        Note: Variant forms
        {"pattern": "Ï‘|Ï•|Ï–|Ï°|Ï±|Ïµ", "style": "variant", "case": "lowercase"}
    ]
    
    Note: Search for each pattern in the text
    For each pattern_info in variant_patterns:
        Let pattern be Dictionary.get(pattern_info, "pattern", "")
        Let style be Dictionary.get(pattern_info, "style", "unknown")
        Let case_type be Dictionary.get(pattern_info, "case", "unknown")
        
        Note: Find matches using character iteration
        Let position be 0
        While position is less than String.length(text):
            Let char be String.char_at(text, position)
            If String.contains(pattern, char):
                Let detection be {
                    "symbol": char,
                    "style": style,
                    "case": case_type,
                    "position": String.from_integer(position),
                    "unicode_block": "greek_mathematical"
                }
                Set detected_variants to List.append(detected_variants, detection)
            Set position to position plus 1
    
    Return detected_variants

Note: =====================================================================
Note: RENDERING AND DISPLAY OPERATIONS
Note: =====================================================================

Process called "render_greek_letter_latex" that takes letter as GreekLetter, style as String returns String:
    Note: Render Greek letter as LaTeX command
    Let letter_name be Dictionary.get(letter, "letter_name", "")
    
    Note: Base LaTeX commands for Greek letters
    Let latex_commands be {
        "alpha": "\\alpha", "beta": "\\beta", "gamma": "\\gamma", "delta": "\\delta",
        "epsilon": "\\epsilon", "zeta": "\\zeta", "eta": "\\eta", "theta": "\\theta",
        "iota": "\\iota", "kappa": "\\kappa", "lambda": "\\lambda", "mu": "\\mu",
        "nu": "\\nu", "xi": "\\xi", "omicron": "o", "pi": "\\pi",
        "rho": "\\rho", "sigma": "\\sigma", "tau": "\\tau", "upsilon": "\\upsilon",
        "phi": "\\phi", "chi": "\\chi", "psi": "\\psi", "omega": "\\omega"
    }
    
    Note: Uppercase variants
    Let latex_uppercase be {
        "alpha": "A", "beta": "B", "gamma": "\\Gamma", "delta": "\\Delta",
        "epsilon": "E", "zeta": "Z", "eta": "H", "theta": "\\Theta",
        "iota": "I", "kappa": "K", "lambda": "\\Lambda", "mu": "M",
        "nu": "N", "xi": "\\Xi", "omicron": "O", "pi": "\\Pi",
        "rho": "P", "sigma": "\\Sigma", "tau": "T", "upsilon": "\\Upsilon",
        "phi": "\\Phi", "chi": "X", "psi": "\\Psi", "omega": "\\Omega"
    }
    
    Let base_command be Dictionary.get(latex_commands, letter_name, "")
    Let uppercase_command be Dictionary.get(latex_uppercase, letter_name, "")
    
    If base_command is equal to "" and uppercase_command is equal to "":
        Return "\\text{" plus letter_name plus "}"
    
    Note: Apply styling
    If style is equal to "bold":
        If String.contains(Dictionary.get(letter, "uppercase_symbol", ""), String.char_at(Dictionary.get(letter, "uppercase_symbol", ""), 0)):
            Return "\\boldsymbol{" plus uppercase_command plus "}"
        Otherwise:
            Return "\\boldsymbol{" plus base_command plus "}"
    Otherwise if style is equal to "italic":
        If String.contains(Dictionary.get(letter, "uppercase_symbol", ""), String.char_at(Dictionary.get(letter, "uppercase_symbol", ""), 0)):
            Return uppercase_command
        Otherwise:
            Return base_command
    Otherwise if style is equal to "bold_italic":
        If String.contains(Dictionary.get(letter, "uppercase_symbol", ""), String.char_at(Dictionary.get(letter, "uppercase_symbol", ""), 0)):
            Return "\\boldsymbol{" plus uppercase_command plus "}"
        Otherwise:
            Return "\\boldsymbol{" plus base_command plus "}"
    Otherwise:
        Note: Default to regular style
        If String.contains(Dictionary.get(letter, "uppercase_symbol", ""), String.char_at(Dictionary.get(letter, "uppercase_symbol", ""), 0)):
            Return uppercase_command
        Otherwise:
            Return base_command

Process called "render_greek_letter_mathml" that takes letter as GreekLetter, style as String returns String:
    Note: Render Greek letter as MathML markup
    Let letter_name be Dictionary.get(letter, "letter_name", "")
    Let uppercase_symbol be Dictionary.get(letter, "uppercase_symbol", "")
    Let lowercase_symbol be Dictionary.get(letter, "lowercase_symbol", "")
    
    Note: Determine which symbol to use
    Let symbol be lowercase_symbol
    Let case_attr be "normal"
    If String.length(uppercase_symbol) is greater than 0 and String.char_at(uppercase_symbol, 0) is equal to String.char_at(uppercase_symbol, 0):
        Set symbol to uppercase_symbol
        Set case_attr to "upper"
    
    Note: Build MathML based on style
    If style is equal to "bold":
        Return "<mi mathvariant=\"bold\">" plus symbol plus "</mi>"
    Otherwise if style is equal to "italic":
        Return "<mi mathvariant=\"italic\">" plus symbol plus "</mi>"
    Otherwise if style is equal to "bold_italic":
        Return "<mi mathvariant=\"bold-italic\">" plus symbol plus "</mi>"
    Otherwise if style is equal to "script":
        Return "<mi mathvariant=\"script\">" plus symbol plus "</mi>"
    Otherwise if style is equal to "double_struck":
        Return "<mi mathvariant=\"double-struck\">" plus symbol plus "</mi>"
    Otherwise if style is equal to "monospace":
        Return "<mi mathvariant=\"monospace\">" plus symbol plus "</mi>"
    Otherwise if style is equal to "sans_serif":
        Return "<mi mathvariant=\"sans-serif\">" plus symbol plus "</mi>"
    Otherwise:
        Note: Default regular style
        Return "<mi>" plus symbol plus "</mi>"

Process called "get_font_support_greek" that takes letter as GreekLetter returns List[String]:
    Note: Get fonts that support specified Greek letter
    Let letter_name be Dictionary.get(letter, "letter_name", "")
    
    Note: Fonts with comprehensive Greek support
    Let comprehensive_fonts be [
        "Times New Roman", "Arial", "Helvetica", "Georgia", "Palatino",
        "Cambria", "Computer Modern", "Latin Modern", "TeX Gyre Termes",
        "Liberation Serif", "DejaVu Serif", "GNU FreeSerif"
    ]
    
    Note: Mathematical fonts with Greek variants
    Let mathematical_fonts be [
        "Computer Modern", "Latin Modern Math", "TeX Gyre Termes Math",
        "STIX Two Math", "Asana Math", "XITS Math", "Libertinus Math",
        "Fira Math", "GFS Neohellenic Math"
    ]
    
    Note: Specialized Greek fonts
    Let greek_specialized_fonts be [
        "GFS Artemisia", "GFS Bodoni", "GFS Complutum", "GFS Didot",
        "GFS Neohellenic", "GFS Porson", "GFS Solomos", "Minion Pro",
        "Adobe Greek", "SIL Gentium", "Cardo", "Junicode"
    ]
    
    Note: Check for special variant requirements
    Let unicode_uppercase be Dictionary.get(letter, "unicode_uppercase", "")
    Let unicode_lowercase be Dictionary.get(letter, "unicode_lowercase", "")
    
    Note: Basic Greek block support (U+0370â€“U+03FF)
    Let basic_support_fonts be List.concat(comprehensive_fonts, greek_specialized_fonts)
    
    Note: Mathematical Greek block support (U+1D6A8â€“U+1D7CB)
    If String.contains(unicode_uppercase, "1D6") or String.contains(unicode_lowercase, "1D6"):
        Return mathematical_fonts
    Otherwise:
        Return basic_support_fonts

Note: =====================================================================
Note: UTILITY AND VALIDATION OPERATIONS
Note: =====================================================================

Process called "validate_greek_symbol" that takes symbol as String returns Boolean:
    Note: Validate if symbol is a valid Greek letter
    Let greek_uppercase be ["Î‘", "Î’", "Î“", "Î”", "Î•", "Î–", "Î—", "Î˜", "Î™", "Îš", "Î›", "Îœ", "Î", "Î", "ÎŸ", "Î ", "Î¡", "Î£", "Î¤", "Î¥", "Î¦", "Î§", "Î¨", "Î©"]
    Let greek_lowercase be ["Î±", "Î²", "Î³", "Î´", "Îµ", "Î¶", "Î·", "Î¸", "Î¹", "Îº", "Î»", "Î¼", "Î½", "Î¾", "Î¿", "Ï€", "Ï", "Ïƒ", "Ï„", "Ï…", "Ï†", "Ï‡", "Ïˆ", "Ï‰"]
    Let greek_variants be ["Ï‚", "Ï‘", "Ï•", "Ï–", "Ï°", "Ï±", "Ïµ"]
    
    If List.contains(greek_uppercase, symbol):
        Return true
    Otherwise if List.contains(greek_lowercase, symbol):
        Return true
    Otherwise if List.contains(greek_variants, symbol):
        Return true
    Otherwise:
        Return false

Process called "convert_case_greek" that takes symbol as String, target_case as String returns String:
    Note: Convert Greek letter between uppercase and lowercase
    Let conversion_map_upper be {
        "Î±": "Î‘", "Î²": "Î’", "Î³": "Î“", "Î´": "Î”", "Îµ": "Î•", "Î¶": "Î–", "Î·": "Î—", "Î¸": "Î˜",
        "Î¹": "Î™", "Îº": "Îš", "Î»": "Î›", "Î¼": "Îœ", "Î½": "Î", "Î¾": "Î", "Î¿": "ÎŸ", "Ï€": "Î ",
        "Ï": "Î¡", "Ïƒ": "Î£", "Ï„": "Î¤", "Ï…": "Î¥", "Ï†": "Î¦", "Ï‡": "Î§", "Ïˆ": "Î¨", "Ï‰": "Î©"
    }
    
    Let conversion_map_lower be {
        "Î‘": "Î±", "Î’": "Î²", "Î“": "Î³", "Î”": "Î´", "Î•": "Îµ", "Î–": "Î¶", "Î—": "Î·", "Î˜": "Î¸",
        "Î™": "Î¹", "Îš": "Îº", "Î›": "Î»", "Îœ": "Î¼", "Î": "Î½", "Î": "Î¾", "ÎŸ": "Î¿", "Î ": "Ï€",
        "Î¡": "Ï", "Î£": "Ïƒ", "Î¤": "Ï„", "Î¥": "Ï…", "Î¦": "Ï†", "Î§": "Ï‡", "Î¨": "Ïˆ", "Î©": "Ï‰"
    }
    
    If target_case is equal to "uppercase":
        Let uppercase_result be Dictionary.get(conversion_map_upper, symbol, symbol)
        Return uppercase_result
    Otherwise if target_case is equal to "lowercase":
        Let lowercase_result be Dictionary.get(conversion_map_lower, symbol, symbol)
        Return lowercase_result
    Otherwise:
        Return symbol

Process called "export_greek_alphabet_data" that takes export_format as String returns String:
    Note: Export Greek alphabet data in specified format
    Let alphabet_data be get_complete_greek_alphabet()
    
    If export_format is equal to "json":
        Note: Export as JSON format
        Let json_output be "[\n"
        For each (index, letter) in List.enumerate(alphabet_data):
            Let letter_json be "  {\n"
            Set letter_json to letter_json plus "    \"letter_name\": \"" plus Dictionary.get(letter, "letter_name", "") plus "\",\n"
            Set letter_json to letter_json plus "    \"uppercase_symbol\": \"" plus Dictionary.get(letter, "uppercase_symbol", "") plus "\",\n"
            Set letter_json to letter_json plus "    \"lowercase_symbol\": \"" plus Dictionary.get(letter, "lowercase_symbol", "") plus "\",\n"
            Set letter_json to letter_json plus "    \"unicode_uppercase\": \"" plus Dictionary.get(letter, "unicode_uppercase", "") plus "\",\n"
            Set letter_json to letter_json plus "    \"unicode_lowercase\": \"" plus Dictionary.get(letter, "unicode_lowercase", "") plus "\",\n"
            Set letter_json to letter_json plus "    \"pronunciation\": \"" plus Dictionary.get(letter, "pronunciation", "") plus "\",\n"
            Set letter_json to letter_json plus "    \"transliteration\": \"" plus Dictionary.get(letter, "transliteration", "") plus "\"\n"
            If index is less than List.length(alphabet_data) minus 1:
                Set letter_json to letter_json plus "  },\n"
            Otherwise:
                Set letter_json to letter_json plus "  }\n"
            Set json_output to json_output plus letter_json
        Set json_output to json_output plus "]"
        Return json_output
        
    Otherwise if export_format is equal to "csv":
        Note: Export as CSV format
        Let csv_output be "letter_name,uppercase_symbol,lowercase_symbol,unicode_uppercase,unicode_lowercase,pronunciation,transliteration\n"
        For each letter in alphabet_data:
            Let csv_row be Dictionary.get(letter, "letter_name", "") plus ","
            Set csv_row to csv_row plus Dictionary.get(letter, "uppercase_symbol", "") plus ","
            Set csv_row to csv_row plus Dictionary.get(letter, "lowercase_symbol", "") plus ","
            Set csv_row to csv_row plus Dictionary.get(letter, "unicode_uppercase", "") plus ","
            Set csv_row to csv_row plus Dictionary.get(letter, "unicode_lowercase", "") plus ","
            Set csv_row to csv_row plus Dictionary.get(letter, "pronunciation", "") plus ","
            Set csv_row to csv_row plus Dictionary.get(letter, "transliteration", "") plus "\n"
            Set csv_output to csv_output plus csv_row
        Return csv_output
        
    Otherwise if export_format is equal to "xml":
        Note: Export as XML format
        Let xml_output be "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<greek_alphabet>\n"
        For each letter in alphabet_data:
            Let xml_entry be "  <letter>\n"
            Set xml_entry to xml_entry plus "    <name>" plus Dictionary.get(letter, "letter_name", "") plus "</name>\n"
            Set xml_entry to xml_entry plus "    <uppercase>" plus Dictionary.get(letter, "uppercase_symbol", "") plus "</uppercase>\n"
            Set xml_entry to xml_entry plus "    <lowercase>" plus Dictionary.get(letter, "lowercase_symbol", "") plus "</lowercase>\n"
            Set xml_entry to xml_entry plus "    <unicode_upper>" plus Dictionary.get(letter, "unicode_uppercase", "") plus "</unicode_upper>\n"
            Set xml_entry to xml_entry plus "    <unicode_lower>" plus Dictionary.get(letter, "unicode_lowercase", "") plus "</unicode_lower>\n"
            Set xml_entry to xml_entry plus "    <pronunciation>" plus Dictionary.get(letter, "pronunciation", "") plus "</pronunciation>\n"
            Set xml_entry to xml_entry plus "    <transliteration>" plus Dictionary.get(letter, "transliteration", "") plus "</transliteration>\n"
            Set xml_entry to xml_entry plus "  </letter>\n"
            Set xml_output to xml_output plus xml_entry
        Set xml_output to xml_output plus "</greek_alphabet>\n"
        Return xml_output
        
    Otherwise if export_format is equal to "latex":
        Note: Export as LaTeX table format
        Let latex_output be "\\begin{longtable}{|l|c|c|l|l|}\n"
        Set latex_output to latex_output plus "\\hline\n"
        Set latex_output to latex_output plus "\\textbf{Name} & \\textbf{Uppercase} & \\textbf{Lowercase} & \\textbf{Pronunciation} & \\textbf{Transliteration} \\\\\n"
        Set latex_output to latex_output plus "\\hline\n"
        For each letter in alphabet_data:
            Let latex_row be Dictionary.get(letter, "letter_name", "") plus " & "
            Set latex_row to latex_row plus "$" plus Dictionary.get(letter, "uppercase_symbol", "") plus "$ & "
            Set latex_row to latex_row plus "$" plus Dictionary.get(letter, "lowercase_symbol", "") plus "$ & "
            Set latex_row to latex_row plus Dictionary.get(letter, "pronunciation", "") plus " & "
            Set latex_row to latex_row plus Dictionary.get(letter, "transliteration", "") plus " \\\\\n"
            Set latex_output to latex_output plus latex_row
        Set latex_output to latex_output plus "\\hline\n\\end{longtable}\n"
        Return latex_output
        
    Otherwise:
        Return "Unsupported export format: " plus export_format plus ". Supported: json, csv, xml, latex"

Process called "benchmark_greek_operations" that takes operation_types as List[String] returns Dictionary[String, Float]:
    Note: Benchmark performance of Greek letter operations
    Let benchmark_results be {}
    
    For each operation_type in operation_types:
        If operation_type is equal to "alphabet_retrieval":
            Note: Benchmark complete alphabet retrieval
            Let start_time be DateTime.get_current_timestamp()
            Let iterations be 1000
            For i from 0 to iterations:
                Let alphabet be get_complete_greek_alphabet()
            Let end_time be DateTime.get_current_timestamp()
            Let duration be end_time minus start_time
            Let avg_time be duration / Float.from_integer(iterations)
            Set benchmark_results to Dictionary.set(benchmark_results, "alphabet_retrieval_ms", avg_time)
            
        Otherwise if operation_type is equal to "letter_lookup":
            Note: Benchmark individual letter lookup
            Let start_time be DateTime.get_current_timestamp()
            Let iterations be 10000
            For i from 0 to iterations:
                Let letter be alpha_symbols()
                Let letter2 be pi_symbols()
                Let letter3 be omega_symbols()
            Let end_time be DateTime.get_current_timestamp()
            Let duration be end_time minus start_time
            Let avg_time be duration / Float.from_integer(iterations)
            Set benchmark_results to Dictionary.set(benchmark_results, "letter_lookup_ms", avg_time)
            
        Otherwise if operation_type is equal to "variant_generation":
            Note: Benchmark variant generation
            Let start_time be DateTime.get_current_timestamp()
            Let iterations be 1000
            For i from 0 to iterations:
                Let bold_letters be get_bold_greek_letters()
                Let italic_letters be get_italic_greek_letters()
            Let end_time be DateTime.get_current_timestamp()
            Let duration be end_time minus start_time
            Let avg_time be duration / Float.from_integer(iterations)
            Set benchmark_results to Dictionary.set(benchmark_results, "variant_generation_ms", avg_time)
            
        Otherwise if operation_type is equal to "symbol_validation":
            Note: Benchmark symbol validation
            Let test_symbols be ["Î±", "Î²", "Î³", "Î‘", "Î’", "Î“", "a", "b", "c"]
            Let start_time be DateTime.get_current_timestamp()
            Let iterations be 5000
            For i from 0 to iterations:
                For symbol in test_symbols:
                    Let is_valid be validate_greek_symbol(symbol)
            Let end_time be DateTime.get_current_timestamp()
            Let duration be end_time minus start_time
            Let avg_time be duration / Float.from_integer(iterations)
            Set benchmark_results to Dictionary.set(benchmark_results, "symbol_validation_ms", avg_time)
            
        Otherwise if operation_type is equal to "encoding_conversion":
            Note: Benchmark encoding conversion
            Let test_text be "Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰"
            Let start_time be DateTime.get_current_timestamp()
            Let iterations be 1000
            For i from 0 to iterations:
                Let converted be convert_greek_encoding(test_text, "utf-8", "ascii")
            Let end_time be DateTime.get_current_timestamp()
            Let duration be end_time minus start_time
            Let avg_time be duration / Float.from_integer(iterations)
            Set benchmark_results to Dictionary.set(benchmark_results, "encoding_conversion_ms", avg_time)
            
        Otherwise if operation_type is equal to "latex_rendering":
            Note: Benchmark LaTeX rendering
            Let test_letter be alpha_symbols()
            Let start_time be DateTime.get_current_timestamp()
            Let iterations be 2000
            For i from 0 to iterations:
                Let latex_bold be render_greek_letter_latex(test_letter, "bold")
                Let latex_italic be render_greek_letter_latex(test_letter, "italic")
            Let end_time be DateTime.get_current_timestamp()
            Let duration be end_time minus start_time
            Let avg_time be duration / Float.from_integer(iterations)
            Set benchmark_results to Dictionary.set(benchmark_results, "latex_rendering_ms", avg_time)
            
        Otherwise:
            Set benchmark_results to Dictionary.set(benchmark_results, operation_type plus "_error", -1.0)
    
    Return benchmark_results