Note:
math/symbols/greek_letters.runa
Greek Letter Symbols and Mathematical Usage

This module provides comprehensive Greek letter symbol handling including:
- Complete Greek alphabet (uppercase and lowercase)
- Mathematical usage contexts and meanings
- Variant forms and stylistic alternatives
- Unicode normalization and encoding
- Symbol classification by usage domain
- Phonetic and transliteration information
- Historical and etymological context
- Font style variations (bold, italic, script)
- Combining forms and diacritical marks
- Modern Greek vs. ancient Greek forms
- Mathematical constants using Greek letters
- Scientific notation applications
- Engineering convention usage
- Typography and display formatting
- Cross-reference with Latin equivalents
:End Note

Import module "dev/debug/errors/core" as Errors

Note: =====================================================================
Note: GREEK LETTER DATA STRUCTURES
Note: =====================================================================

Type called "GreekLetter":
    letter_name as String
    uppercase_symbol as String
    lowercase_symbol as String
    unicode_uppercase as String
    unicode_lowercase as String
    mathematical_usage as List[String]
    pronunciation as String
    transliteration as String
    latin_equivalent as String

Type called "GreekLetterVariant":
    base_letter as String
    variant_type as String
    variant_symbol as String
    unicode_codepoint as String
    usage_context as String
    font_style as String

Type called "MathematicalConstant":
    constant_name as String
    greek_symbol as String
    mathematical_value as String
    domain as String
    definition as String
    historical_context as String

Note: =====================================================================
Note: BASIC GREEK ALPHABET OPERATIONS
Note: =====================================================================

Process called "get_complete_greek_alphabet" that returns List[GreekLetter]:
    Note: Get complete Greek alphabet with upper and lowercase forms
    Return [
        alpha_symbols(),
        beta_symbols(),
        gamma_symbols(),
        delta_symbols(),
        epsilon_symbols(),
        zeta_symbols(),
        eta_symbols(),
        theta_symbols(),
        iota_symbols(),
        kappa_symbols(),
        lambda_symbols(),
        mu_symbols(),
        nu_symbols(),
        xi_symbols(),
        omicron_symbols(),
        pi_symbols(),
        rho_symbols(),
        sigma_symbols(),
        tau_symbols(),
        upsilon_symbols(),
        phi_symbols(),
        chi_symbols(),
        psi_symbols(),
        omega_symbols()
    ]

Process called "alpha_symbols" that returns GreekLetter:
    Note: Get alpha symbols (Α, α) minus first letter of Greek alphabet
    Return {
        "letter_name": "alpha",
        "uppercase_symbol": "Α",
        "lowercase_symbol": "α",
        "unicode_uppercase": "U+0391",
        "unicode_lowercase": "U+03B1",
        "mathematical_usage": ["angle", "coefficient", "parameter", "fine_structure_constant"],
        "pronunciation": "AL-fah",
        "transliteration": "a",
        "latin_equivalent": "A"
    }

Process called "beta_symbols" that returns GreekLetter:
    Note: Get beta symbols (Β, β) minus second letter of Greek alphabet
    Return {
        "letter_name": "beta",
        "uppercase_symbol": "Β",
        "lowercase_symbol": "β",
        "unicode_uppercase": "U+0392",
        "unicode_lowercase": "U+03B2",
        "mathematical_usage": ["angle", "coefficient", "beta_function", "regression_coefficient"],
        "pronunciation": "BAY-tah",
        "transliteration": "b",
        "latin_equivalent": "B"
    }

Process called "gamma_symbols" that returns GreekLetter:
    Note: Get gamma symbols (Γ, γ) minus third letter of Greek alphabet
    Return {
        "letter_name": "gamma",
        "uppercase_symbol": "Γ",
        "lowercase_symbol": "γ",
        "unicode_uppercase": "U+0393",
        "unicode_lowercase": "U+03B3",
        "mathematical_usage": ["gamma_function", "euler_mascheroni_constant", "christoffel_symbols", "lorentz_factor"],
        "pronunciation": "GAM-ah",
        "transliteration": "g",
        "latin_equivalent": "G"
    }

Process called "delta_symbols" that returns GreekLetter:
    Note: Get delta symbols (Δ, δ) minus fourth letter of Greek alphabet
    Return {
        "letter_name": "delta",
        "uppercase_symbol": "Δ",
        "lowercase_symbol": "δ",
        "unicode_uppercase": "U+0394",
        "unicode_lowercase": "U+03B4",
        "mathematical_usage": ["change", "difference", "kronecker_delta", "dirac_delta", "small_increment"],
        "pronunciation": "DEL-tah",
        "transliteration": "d",
        "latin_equivalent": "D"
    }

Process called "epsilon_symbols" that returns GreekLetter:
    Note: Get epsilon symbols (Ε, ε, ϵ) minus fifth letter of Greek alphabet
    Return {
        "letter_name": "epsilon",
        "uppercase_symbol": "Ε",
        "lowercase_symbol": "ε",
        "unicode_uppercase": "U+0395",
        "unicode_lowercase": "U+03B5",
        "mathematical_usage": ["small_quantity", "limit_definition", "permittivity", "strain"],
        "pronunciation": "EP-sih-lon",
        "transliteration": "e",
        "latin_equivalent": "E"
    }

Process called "zeta_symbols" that returns GreekLetter:
    Note: Get zeta symbols (Ζ, ζ) minus sixth letter of Greek alphabet
    Return {
        "letter_name": "zeta",
        "uppercase_symbol": "Ζ",
        "lowercase_symbol": "ζ",
        "unicode_uppercase": "U+0396",
        "unicode_lowercase": "U+03B6",
        "mathematical_usage": ["riemann_zeta_function", "damping_ratio", "impedance"],
        "pronunciation": "ZAY-tah",
        "transliteration": "z",
        "latin_equivalent": "Z"
    }

Process called "eta_symbols" that returns GreekLetter:
    Note: Get eta symbols (Η, η) minus seventh letter of Greek alphabet
    Return {
        "letter_name": "eta",
        "uppercase_symbol": "Η",
        "lowercase_symbol": "η",
        "unicode_uppercase": "U+0397",
        "unicode_lowercase": "U+03B7",
        "mathematical_usage": ["efficiency", "pseudorapidity", "viscosity", "refractive_index"],
        "pronunciation": "AY-tah",
        "transliteration": "e",
        "latin_equivalent": "H"
    }

Process called "theta_symbols" that returns GreekLetter:
    Note: Get theta symbols (Θ, θ, ϑ) minus eighth letter of Greek alphabet
    Return {
        "letter_name": "theta",
        "uppercase_symbol": "Θ",
        "lowercase_symbol": "θ",
        "unicode_uppercase": "U+0398",
        "unicode_lowercase": "U+03B8",
        "mathematical_usage": ["angle", "parameter", "temperature", "heaviside_step_function"],
        "pronunciation": "THAY-tah",
        "transliteration": "th",
        "latin_equivalent": "TH"
    }

Process called "iota_symbols" that returns GreekLetter:
    Note: Get iota symbols (Ι, ι) minus ninth letter of Greek alphabet
    Return {
        "letter_name": "iota",
        "uppercase_symbol": "Ι",
        "lowercase_symbol": "ι",
        "unicode_uppercase": "U+0399",
        "unicode_lowercase": "U+03B9",
        "mathematical_usage": ["index", "unit_vector", "inclusion_function"],
        "pronunciation": "eye-OH-tah",
        "transliteration": "i",
        "latin_equivalent": "I"
    }

Process called "kappa_symbols" that returns GreekLetter:
    Note: Get kappa symbols (Κ, κ, ϰ) minus tenth letter of Greek alphabet
    Return {
        "letter_name": "kappa",
        "uppercase_symbol": "Κ",
        "lowercase_symbol": "κ",
        "unicode_uppercase": "U+039A",
        "unicode_lowercase": "U+03BA",
        "mathematical_usage": ["curvature", "thermal_conductivity", "spring_constant", "kappa_statistic"],
        "pronunciation": "KAP-ah",
        "transliteration": "k",
        "latin_equivalent": "K"
    }

Process called "lambda_symbols" that returns GreekLetter:
    Note: Get lambda symbols (Λ, λ) minus eleventh letter of Greek alphabet
    Return {
        "letter_name": "lambda",
        "uppercase_symbol": "Λ",
        "lowercase_symbol": "λ",
        "unicode_uppercase": "U+039B",
        "unicode_lowercase": "U+03BB",
        "mathematical_usage": ["eigenvalue", "wavelength", "lambda_calculus", "poisson_parameter", "lagrange_multiplier"],
        "pronunciation": "LAM-dah",
        "transliteration": "l",
        "latin_equivalent": "L"
    }

Process called "mu_symbols" that returns GreekLetter:
    Note: Get mu symbols (Μ, μ) minus twelfth letter of Greek alphabet
    Return {
        "letter_name": "mu",
        "uppercase_symbol": "Μ",
        "lowercase_symbol": "μ",
        "unicode_uppercase": "U+039C",
        "unicode_lowercase": "U+03BC",
        "mathematical_usage": ["mean", "friction_coefficient", "magnetic_permeability", "micro_prefix"],
        "pronunciation": "MYOO",
        "transliteration": "m",
        "latin_equivalent": "M"
    }

Process called "nu_symbols" that returns GreekLetter:
    Note: Get nu symbols (Ν, ν) minus thirteenth letter of Greek alphabet
    Return {
        "letter_name": "nu",
        "uppercase_symbol": "Ν",
        "lowercase_symbol": "ν",
        "unicode_uppercase": "U+039D",
        "unicode_lowercase": "U+03BD",
        "mathematical_usage": ["frequency", "degrees_of_freedom", "kinematic_viscosity", "neutrino"],
        "pronunciation": "NYOO",
        "transliteration": "n",
        "latin_equivalent": "N"
    }

Process called "xi_symbols" that returns GreekLetter:
    Note: Get xi symbols (Ξ, ξ) minus fourteenth letter of Greek alphabet
    Return {
        "letter_name": "xi",
        "uppercase_symbol": "Ξ",
        "lowercase_symbol": "ξ",
        "unicode_uppercase": "U+039E",
        "unicode_lowercase": "U+03BE",
        "mathematical_usage": ["random_variable", "coordinate", "xi_function"],
        "pronunciation": "ZIGH",
        "transliteration": "x",
        "latin_equivalent": "X"
    }

Process called "omicron_symbols" that returns GreekLetter:
    Note: Get omicron symbols (Ο, ο) minus fifteenth letter of Greek alphabet
    Return {
        "letter_name": "omicron",
        "uppercase_symbol": "Ο",
        "lowercase_symbol": "ο",
        "unicode_uppercase": "U+039F",
        "unicode_lowercase": "U+03BF",
        "mathematical_usage": ["big_o_notation", "order_of_magnitude"],
        "pronunciation": "OH-mih-kron",
        "transliteration": "o",
        "latin_equivalent": "O"
    }

Process called "pi_symbols" that returns GreekLetter:
    Note: Get pi symbols (Π, π, ϖ) minus sixteenth letter of Greek alphabet
    Return {
        "letter_name": "pi",
        "uppercase_symbol": "Π",
        "lowercase_symbol": "π",
        "unicode_uppercase": "U+03A0",
        "unicode_lowercase": "U+03C0",
        "mathematical_usage": ["pi_constant", "product_notation", "projection", "prime_counting_function"],
        "pronunciation": "PIE",
        "transliteration": "p",
        "latin_equivalent": "P"
    }

Process called "rho_symbols" that returns GreekLetter:
    Note: Get rho symbols (Ρ, ρ, ϱ) minus seventeenth letter of Greek alphabet
    Return {
        "letter_name": "rho",
        "uppercase_symbol": "Ρ",
        "lowercase_symbol": "ρ",
        "unicode_uppercase": "U+03A1",
        "unicode_lowercase": "U+03C1",
        "mathematical_usage": ["density", "correlation_coefficient", "resistivity", "radius"],
        "pronunciation": "ROH",
        "transliteration": "r",
        "latin_equivalent": "R"
    }

Process called "sigma_symbols" that returns GreekLetter:
    Note: Get sigma symbols (Σ, σ, ς) minus eighteenth letter of Greek alphabet
    Return {
        "letter_name": "sigma",
        "uppercase_symbol": "Σ",
        "lowercase_symbol": "σ",
        "unicode_uppercase": "U+03A3",
        "unicode_lowercase": "U+03C3",
        "mathematical_usage": ["summation", "standard_deviation", "conductivity", "stress"],
        "pronunciation": "SIG-mah",
        "transliteration": "s",
        "latin_equivalent": "S"
    }

Process called "tau_symbols" that returns GreekLetter:
    Note: Get tau symbols (Τ, τ) minus nineteenth letter of Greek alphabet
    Return {
        "letter_name": "tau",
        "uppercase_symbol": "Τ",
        "lowercase_symbol": "τ",
        "unicode_uppercase": "U+03A4",
        "unicode_lowercase": "U+03C4",
        "mathematical_usage": ["time_constant", "torque", "tau_constant", "proper_time"],
        "pronunciation": "TAW",
        "transliteration": "t",
        "latin_equivalent": "T"
    }

Process called "upsilon_symbols" that returns GreekLetter:
    Note: Get upsilon symbols (Υ, υ) minus twentieth letter of Greek alphabet
    Return {
        "letter_name": "upsilon",
        "uppercase_symbol": "Υ",
        "lowercase_symbol": "υ",
        "unicode_uppercase": "U+03A5",
        "unicode_lowercase": "U+03C5",
        "mathematical_usage": ["particle_physics", "upsilon_meson"],
        "pronunciation": "OOP-sih-lon",
        "transliteration": "u",
        "latin_equivalent": "U"
    }

Process called "phi_symbols" that returns GreekLetter:
    Note: Get phi symbols (Φ, φ, ϕ) minus twenty-first letter of Greek alphabet
    Return {
        "letter_name": "phi",
        "uppercase_symbol": "Φ",
        "lowercase_symbol": "φ",
        "unicode_uppercase": "U+03A6",
        "unicode_lowercase": "U+03C6",
        "mathematical_usage": ["golden_ratio", "euler_totient_function", "angle", "magnetic_flux"],
        "pronunciation": "FIE",
        "transliteration": "ph",
        "latin_equivalent": "PH"
    }

Process called "chi_symbols" that returns GreekLetter:
    Note: Get chi symbols (Χ, χ) minus twenty-second letter of Greek alphabet
    Return {
        "letter_name": "chi",
        "uppercase_symbol": "Χ",
        "lowercase_symbol": "χ",
        "unicode_uppercase": "U+03A7",
        "unicode_lowercase": "U+03C7",
        "mathematical_usage": ["chi_squared_distribution", "euler_characteristic", "magnetic_susceptibility"],
        "pronunciation": "KIE",
        "transliteration": "ch",
        "latin_equivalent": "CH"
    }

Process called "psi_symbols" that returns GreekLetter:
    Note: Get psi symbols (Ψ, ψ) minus twenty-third letter of Greek alphabet
    Return {
        "letter_name": "psi",
        "uppercase_symbol": "Ψ",
        "lowercase_symbol": "ψ",
        "unicode_uppercase": "U+03A8",
        "unicode_lowercase": "U+03C8",
        "mathematical_usage": ["wave_function", "stream_function", "digamma_function", "psi_particle"],
        "pronunciation": "SIGH",
        "transliteration": "ps",
        "latin_equivalent": "PS"
    }

Process called "omega_symbols" that returns GreekLetter:
    Note: Get omega symbols (Ω, ω) minus twenty-fourth letter of Greek alphabet
    Return {
        "letter_name": "omega",
        "uppercase_symbol": "Ω",
        "lowercase_symbol": "ω",
        "unicode_uppercase": "U+03A9",
        "unicode_lowercase": "U+03C9",
        "mathematical_usage": ["angular_frequency", "ohm_unit", "omega_constant", "last_element"],
        "pronunciation": "oh-MAY-gah",
        "transliteration": "o",
        "latin_equivalent": "O"
    }

Note: =====================================================================
Note: VARIANT FORM OPERATIONS
Note: =====================================================================

Process called "get_epsilon_variants" that returns List[GreekLetterVariant]:
    Note: Get epsilon variants (ε, ϵ) with different mathematical meanings
    Return [
        {
            "base_letter": "epsilon",
            "variant_type": "standard",
            "variant_symbol": "ε",
            "unicode_codepoint": "U+03B5",
            "usage_context": "set_membership_limits_analysis",
            "font_style": "normal"
        },
        {
            "base_letter": "epsilon",
            "variant_type": "lunate",
            "variant_symbol": "ϵ",
            "unicode_codepoint": "U+03F5",
            "usage_context": "permittivity_strain_mechanics",
            "font_style": "normal"
        }
    ]

Process called "get_theta_variants" that returns List[GreekLetterVariant]:
    Note: Get theta variants (θ, ϑ) with different usage contexts
    Return [
        {
            "base_letter": "theta",
            "variant_type": "standard",
            "variant_symbol": "θ",
            "unicode_codepoint": "U+03B8",
            "usage_context": "angles_temperature_parameters",
            "font_style": "normal"
        },
        {
            "base_letter": "theta",
            "variant_type": "script",
            "variant_symbol": "ϑ",
            "unicode_codepoint": "U+03D1",
            "usage_context": "special_functions_jacobi_theta",
            "font_style": "script"
        }
    ]

Process called "get_kappa_variants" that returns List[GreekLetterVariant]:
    Note: Get kappa variants (κ, ϰ) for different mathematical contexts
    Return [
        {
            "base_letter": "kappa",
            "variant_type": "standard",
            "variant_symbol": "κ",
            "unicode_codepoint": "U+03BA",
            "usage_context": "curvature_conductivity",
            "font_style": "normal"
        },
        {
            "base_letter": "kappa",
            "variant_type": "script",
            "variant_symbol": "ϰ",
            "unicode_codepoint": "U+03F0",
            "usage_context": "statistical_mechanics",
            "font_style": "script"
        }
    ]

Process called "get_pi_variants" that returns List[GreekLetterVariant]:
    Note: Get pi variants (π, ϖ) with different typographical uses
    Return [
        {
            "base_letter": "pi",
            "variant_type": "standard",
            "variant_symbol": "π",
            "unicode_codepoint": "U+03C0",
            "usage_context": "pi_constant_circular_functions",
            "font_style": "normal"
        },
        {
            "base_letter": "pi",
            "variant_type": "omega_form",
            "variant_symbol": "ϖ",
            "unicode_codepoint": "U+03D6",
            "usage_context": "alternative_typographic_form",
            "font_style": "normal"
        }
    ]

Process called "get_rho_variants" that returns List[GreekLetterVariant]:
    Note: Get rho variants (ρ, ϱ) for different mathematical applications
    Return [
        {
            "base_letter": "rho",
            "variant_type": "standard",
            "variant_symbol": "ρ",
            "unicode_codepoint": "U+03C1",
            "usage_context": "density_correlation_coefficient",
            "font_style": "normal"
        },
        {
            "base_letter": "rho",
            "variant_type": "script",
            "variant_symbol": "ϱ",
            "unicode_codepoint": "U+03F1",
            "usage_context": "special_mathematical_contexts",
            "font_style": "script"
        }
    ]

Process called "get_sigma_variants" that returns List[GreekLetterVariant]:
    Note: Get sigma variants (σ, ς) including final sigma form
    Return [
        {
            "base_letter": "sigma",
            "variant_type": "medial",
            "variant_symbol": "σ",
            "unicode_codepoint": "U+03C3",
            "usage_context": "standard_deviation_stress_conductivity",
            "font_style": "normal"
        },
        {
            "base_letter": "sigma",
            "variant_type": "final",
            "variant_symbol": "ς",
            "unicode_codepoint": "U+03C2",
            "usage_context": "word_final_position_greek_text",
            "font_style": "normal"
        }
    ]

Process called "get_phi_variants" that returns List[GreekLetterVariant]:
    Note: Get phi variants (φ, ϕ) with different mathematical conventions
    Return [
        {
            "base_letter": "phi",
            "variant_type": "closed",
            "variant_symbol": "φ",
            "unicode_codepoint": "U+03C6",
            "usage_context": "golden_ratio_euler_totient",
            "font_style": "normal"
        },
        {
            "base_letter": "phi",
            "variant_type": "open",
            "variant_symbol": "ϕ",
            "unicode_codepoint": "U+03D5",
            "usage_context": "magnetic_flux_phase_angle",
            "font_style": "normal"
        }
    ]

Note: =====================================================================
Note: MATHEMATICAL USAGE OPERATIONS
Note: =====================================================================

Process called "get_calculus_greek_letters" that returns List[GreekLetter]:
    Note: Get Greek letters commonly used in calculus (δ, ε, ∂, ∇, etc.)
    Return [
        delta_symbols(),
        epsilon_symbols(),
        lambda_symbols(),
        mu_symbols(),
        xi_symbols(),
        pi_symbols(),
        sigma_symbols(),
        tau_symbols(),
        omega_symbols()
    ]

Process called "get_physics_greek_letters" that returns List[GreekLetter]:
    Note: Get Greek letters commonly used in physics (α, β, γ, λ, μ, ν, ρ, σ, τ, φ, ψ, ω)
    Return [
        alpha_symbols(),
        beta_symbols(),
        gamma_symbols(),
        delta_symbols(),
        epsilon_symbols(),
        lambda_symbols(),
        mu_symbols(),
        nu_symbols(),
        rho_symbols(),
        sigma_symbols(),
        tau_symbols(),
        phi_symbols(),
        psi_symbols(),
        omega_symbols()
    ]

Process called "get_statistics_greek_letters" that returns List[GreekLetter]:
    Note: Get Greek letters used in statistics (α, β, μ, σ, χ, ν, etc.)
    Return [
        alpha_symbols(),
        beta_symbols(),
        gamma_symbols(),
        mu_symbols(),
        nu_symbols(),
        rho_symbols(),
        sigma_symbols(),
        chi_symbols()
    ]

Process called "get_geometry_greek_letters" that returns List[GreekLetter]:
    Note: Get Greek letters used in geometry (α, β, γ, θ, φ, etc.)
    Return [
        alpha_symbols(),
        beta_symbols(),
        gamma_symbols(),
        delta_symbols(),
        theta_symbols(),
        phi_symbols(),
        pi_symbols()
    ]

Process called "get_algebra_greek_letters" that returns List[GreekLetter]:
    Note: Get Greek letters used in algebra (α, β, γ, δ, λ, μ, etc.)
    Return [
        alpha_symbols(),
        beta_symbols(),
        gamma_symbols(),
        delta_symbols(),
        lambda_symbols(),
        mu_symbols(),
        nu_symbols(),
        xi_symbols(),
        rho_symbols(),
        sigma_symbols(),
        tau_symbols()
    ]

Note: =====================================================================
Note: MATHEMATICAL CONSTANTS OPERATIONS
Note: =====================================================================

Process called "get_mathematical_constants_greek" that returns List[MathematicalConstant]:
    Note: Get mathematical constants represented by Greek letters
    Return [
        pi_constant(),
        euler_gamma_constant(),
        golden_ratio_phi(),
        euler_totient_phi(),
        lambda_constant()
    ]

Process called "pi_constant" that returns MathematicalConstant:
    Note: Get π constant (3.14159...) minus ratio of circumference to diameter
    Return {
        "constant_name": "pi",
        "greek_symbol": "π",
        "mathematical_value": "3.141592653589793238462643383279502884197",
        "domain": "geometry_trigonometry",
        "definition": "ratio of circle circumference to diameter",
        "historical_context": "known to ancient civilizations, formalized by Archimedes"
    }

Process called "euler_gamma_constant" that returns MathematicalConstant:
    Note: Get Euler-Mascheroni constant γ (0.5772...)
    Return {
        "constant_name": "euler_mascheroni",
        "greek_symbol": "γ",
        "mathematical_value": "0.5772156649015328606065120900824024310421",
        "domain": "number_theory_analysis",
        "definition": "limit of (harmonic series minus natural logarithm)",
        "historical_context": "discovered by Euler, studied by Mascheroni"
    }

Process called "golden_ratio_phi" that returns MathematicalConstant:
    Note: Get golden ratio φ (1.618...) minus (1+√5)/2
    Return {
        "constant_name": "golden_ratio",
        "greek_symbol": "φ",
        "mathematical_value": "1.6180339887498948482045868343656381177203",
        "domain": "geometry_algebra",
        "definition": "(1 plus sqrt(5)) / 2",
        "historical_context": "known to ancient Greeks, appears in nature and art"
    }

Process called "euler_totient_phi" that returns MathematicalConstant:
    Note: Get Euler's totient function φ(n) minus number theory
    Return {
        "constant_name": "euler_totient",
        "greek_symbol": "φ",
        "mathematical_value": "function",
        "domain": "number_theory",
        "definition": "count of integers up to n that are coprime to n",
        "historical_context": "introduced by Euler for number theory applications"
    }

Process called "lambda_constant" that returns MathematicalConstant:
    Note: Get λ constant in various mathematical contexts
    Return {
        "constant_name": "lambda_various",
        "greek_symbol": "λ",
        "mathematical_value": "context_dependent",
        "domain": "multiple_domains",
        "definition": "eigenvalue, wavelength, decay constant, or Lagrange multiplier",
        "historical_context": "used across multiple mathematical and physical contexts"
    }

Note: =====================================================================
Note: FONT STYLE VARIATIONS
Note: =====================================================================

Process called "get_bold_greek_letters" that returns List[GreekLetterVariant]:
    Note: Get bold Greek letters (𝚨, 𝚩, 𝚪, 𝛂, 𝛃, 𝛄, etc.)
    Let bold_variants be []
    
    Note: Bold uppercase Greek letters (Mathematical Bold)
    Let bold_uppercase be [
        {"letter_name": "alpha", "variant": "bold", "symbol": "𝚨", "unicode": "U+1D6A8"},
        {"letter_name": "beta", "variant": "bold", "symbol": "𝚩", "unicode": "U+1D6A9"},
        {"letter_name": "gamma", "variant": "bold", "symbol": "𝚪", "unicode": "U+1D6AA"},
        {"letter_name": "delta", "variant": "bold", "symbol": "𝚫", "unicode": "U+1D6AB"},
        {"letter_name": "epsilon", "variant": "bold", "symbol": "𝚬", "unicode": "U+1D6AC"},
        {"letter_name": "zeta", "variant": "bold", "symbol": "𝚭", "unicode": "U+1D6AD"},
        {"letter_name": "eta", "variant": "bold", "symbol": "𝚮", "unicode": "U+1D6AE"},
        {"letter_name": "theta", "variant": "bold", "symbol": "𝚯", "unicode": "U+1D6AF"},
        {"letter_name": "iota", "variant": "bold", "symbol": "𝚰", "unicode": "U+1D6B0"},
        {"letter_name": "kappa", "variant": "bold", "symbol": "𝚱", "unicode": "U+1D6B1"},
        {"letter_name": "lambda", "variant": "bold", "symbol": "𝚲", "unicode": "U+1D6B2"},
        {"letter_name": "mu", "variant": "bold", "symbol": "𝚳", "unicode": "U+1D6B3"},
        {"letter_name": "nu", "variant": "bold", "symbol": "𝚴", "unicode": "U+1D6B4"},
        {"letter_name": "xi", "variant": "bold", "symbol": "𝚵", "unicode": "U+1D6B5"},
        {"letter_name": "omicron", "variant": "bold", "symbol": "𝚶", "unicode": "U+1D6B6"},
        {"letter_name": "pi", "variant": "bold", "symbol": "𝚷", "unicode": "U+1D6B7"},
        {"letter_name": "rho", "variant": "bold", "symbol": "𝚸", "unicode": "U+1D6B8"},
        {"letter_name": "sigma", "variant": "bold", "symbol": "𝚺", "unicode": "U+1D6BA"},
        {"letter_name": "tau", "variant": "bold", "symbol": "𝚻", "unicode": "U+1D6BB"},
        {"letter_name": "upsilon", "variant": "bold", "symbol": "𝚼", "unicode": "U+1D6BC"},
        {"letter_name": "phi", "variant": "bold", "symbol": "𝚽", "unicode": "U+1D6BD"},
        {"letter_name": "chi", "variant": "bold", "symbol": "𝚾", "unicode": "U+1D6BE"},
        {"letter_name": "psi", "variant": "bold", "symbol": "𝚿", "unicode": "U+1D6BF"},
        {"letter_name": "omega", "variant": "bold", "symbol": "𝛀", "unicode": "U+1D6C0"}
    ]
    
    Note: Bold lowercase Greek letters (Mathematical Bold)
    Let bold_lowercase be [
        {"letter_name": "alpha", "variant": "bold", "symbol": "𝛂", "unicode": "U+1D6C2"},
        {"letter_name": "beta", "variant": "bold", "symbol": "𝛃", "unicode": "U+1D6C3"},
        {"letter_name": "gamma", "variant": "bold", "symbol": "𝛄", "unicode": "U+1D6C4"},
        {"letter_name": "delta", "variant": "bold", "symbol": "𝛅", "unicode": "U+1D6C5"},
        {"letter_name": "epsilon", "variant": "bold", "symbol": "𝛆", "unicode": "U+1D6C6"},
        {"letter_name": "zeta", "variant": "bold", "symbol": "𝛇", "unicode": "U+1D6C7"},
        {"letter_name": "eta", "variant": "bold", "symbol": "𝛈", "unicode": "U+1D6C8"},
        {"letter_name": "theta", "variant": "bold", "symbol": "𝛉", "unicode": "U+1D6C9"},
        {"letter_name": "iota", "variant": "bold", "symbol": "𝛊", "unicode": "U+1D6CA"},
        {"letter_name": "kappa", "variant": "bold", "symbol": "𝛋", "unicode": "U+1D6CB"},
        {"letter_name": "lambda", "variant": "bold", "symbol": "𝛌", "unicode": "U+1D6CC"},
        {"letter_name": "mu", "variant": "bold", "symbol": "𝛍", "unicode": "U+1D6CD"},
        {"letter_name": "nu", "variant": "bold", "symbol": "𝛎", "unicode": "U+1D6CE"},
        {"letter_name": "xi", "variant": "bold", "symbol": "𝛏", "unicode": "U+1D6CF"},
        {"letter_name": "omicron", "variant": "bold", "symbol": "𝛐", "unicode": "U+1D6D0"},
        {"letter_name": "pi", "variant": "bold", "symbol": "𝛑", "unicode": "U+1D6D1"},
        {"letter_name": "rho", "variant": "bold", "symbol": "𝛒", "unicode": "U+1D6D2"},
        {"letter_name": "sigma", "variant": "bold", "symbol": "𝛔", "unicode": "U+1D6D4"},
        {"letter_name": "tau", "variant": "bold", "symbol": "𝛕", "unicode": "U+1D6D5"},
        {"letter_name": "upsilon", "variant": "bold", "symbol": "𝛖", "unicode": "U+1D6D6"},
        {"letter_name": "phi", "variant": "bold", "symbol": "𝛗", "unicode": "U+1D6D7"},
        {"letter_name": "chi", "variant": "bold", "symbol": "𝛘", "unicode": "U+1D6D8"},
        {"letter_name": "psi", "variant": "bold", "symbol": "𝛙", "unicode": "U+1D6D9"},
        {"letter_name": "omega", "variant": "bold", "symbol": "𝛚", "unicode": "U+1D6DA"}
    ]
    
    Set bold_variants to List.concat(bold_uppercase, bold_lowercase)
    Return bold_variants

Process called "get_italic_greek_letters" that returns List[GreekLetterVariant]:
    Note: Get italic Greek letters (𝛢, 𝛣, 𝛤, 𝛼, 𝛽, 𝛾, etc.)
    Let italic_variants be []
    
    Note: Italic uppercase Greek letters (Mathematical Italic)
    Let italic_uppercase be [
        {"letter_name": "alpha", "variant": "italic", "symbol": "𝛢", "unicode": "U+1D6E2"},
        {"letter_name": "beta", "variant": "italic", "symbol": "𝛣", "unicode": "U+1D6E3"},
        {"letter_name": "gamma", "variant": "italic", "symbol": "𝛤", "unicode": "U+1D6E4"},
        {"letter_name": "delta", "variant": "italic", "symbol": "𝛥", "unicode": "U+1D6E5"},
        {"letter_name": "epsilon", "variant": "italic", "symbol": "𝛦", "unicode": "U+1D6E6"},
        {"letter_name": "zeta", "variant": "italic", "symbol": "𝛧", "unicode": "U+1D6E7"},
        {"letter_name": "eta", "variant": "italic", "symbol": "𝛨", "unicode": "U+1D6E8"},
        {"letter_name": "theta", "variant": "italic", "symbol": "𝛩", "unicode": "U+1D6E9"},
        {"letter_name": "iota", "variant": "italic", "symbol": "𝛪", "unicode": "U+1D6EA"},
        {"letter_name": "kappa", "variant": "italic", "symbol": "𝛫", "unicode": "U+1D6EB"},
        {"letter_name": "lambda", "variant": "italic", "symbol": "𝛬", "unicode": "U+1D6EC"},
        {"letter_name": "mu", "variant": "italic", "symbol": "𝛭", "unicode": "U+1D6ED"},
        {"letter_name": "nu", "variant": "italic", "symbol": "𝛮", "unicode": "U+1D6EE"},
        {"letter_name": "xi", "variant": "italic", "symbol": "𝛯", "unicode": "U+1D6EF"},
        {"letter_name": "omicron", "variant": "italic", "symbol": "𝛰", "unicode": "U+1D6F0"},
        {"letter_name": "pi", "variant": "italic", "symbol": "𝛱", "unicode": "U+1D6F1"},
        {"letter_name": "rho", "variant": "italic", "symbol": "𝛲", "unicode": "U+1D6F2"},
        {"letter_name": "sigma", "variant": "italic", "symbol": "𝛴", "unicode": "U+1D6F4"},
        {"letter_name": "tau", "variant": "italic", "symbol": "𝛵", "unicode": "U+1D6F5"},
        {"letter_name": "upsilon", "variant": "italic", "symbol": "𝛶", "unicode": "U+1D6F6"},
        {"letter_name": "phi", "variant": "italic", "symbol": "𝛷", "unicode": "U+1D6F7"},
        {"letter_name": "chi", "variant": "italic", "symbol": "𝛸", "unicode": "U+1D6F8"},
        {"letter_name": "psi", "variant": "italic", "symbol": "𝛹", "unicode": "U+1D6F9"},
        {"letter_name": "omega", "variant": "italic", "symbol": "𝛺", "unicode": "U+1D6FA"}
    ]
    
    Note: Italic lowercase Greek letters (Mathematical Italic)
    Let italic_lowercase be [
        {"letter_name": "alpha", "variant": "italic", "symbol": "𝛼", "unicode": "U+1D6FC"},
        {"letter_name": "beta", "variant": "italic", "symbol": "𝛽", "unicode": "U+1D6FD"},
        {"letter_name": "gamma", "variant": "italic", "symbol": "𝛾", "unicode": "U+1D6FE"},
        {"letter_name": "delta", "variant": "italic", "symbol": "𝛿", "unicode": "U+1D6FF"},
        {"letter_name": "epsilon", "variant": "italic", "symbol": "𝜀", "unicode": "U+1D700"},
        {"letter_name": "zeta", "variant": "italic", "symbol": "𝜁", "unicode": "U+1D701"},
        {"letter_name": "eta", "variant": "italic", "symbol": "𝜂", "unicode": "U+1D702"},
        {"letter_name": "theta", "variant": "italic", "symbol": "𝜃", "unicode": "U+1D703"},
        {"letter_name": "iota", "variant": "italic", "symbol": "𝜄", "unicode": "U+1D704"},
        {"letter_name": "kappa", "variant": "italic", "symbol": "𝜅", "unicode": "U+1D705"},
        {"letter_name": "lambda", "variant": "italic", "symbol": "𝜆", "unicode": "U+1D706"},
        {"letter_name": "mu", "variant": "italic", "symbol": "𝜇", "unicode": "U+1D707"},
        {"letter_name": "nu", "variant": "italic", "symbol": "𝜈", "unicode": "U+1D708"},
        {"letter_name": "xi", "variant": "italic", "symbol": "𝜉", "unicode": "U+1D709"},
        {"letter_name": "omicron", "variant": "italic", "symbol": "𝜊", "unicode": "U+1D70A"},
        {"letter_name": "pi", "variant": "italic", "symbol": "𝜋", "unicode": "U+1D70B"},
        {"letter_name": "rho", "variant": "italic", "symbol": "𝜌", "unicode": "U+1D70C"},
        {"letter_name": "sigma", "variant": "italic", "symbol": "𝜎", "unicode": "U+1D70E"},
        {"letter_name": "tau", "variant": "italic", "symbol": "𝜏", "unicode": "U+1D70F"},
        {"letter_name": "upsilon", "variant": "italic", "symbol": "𝜐", "unicode": "U+1D710"},
        {"letter_name": "phi", "variant": "italic", "symbol": "𝜑", "unicode": "U+1D711"},
        {"letter_name": "chi", "variant": "italic", "symbol": "𝜒", "unicode": "U+1D712"},
        {"letter_name": "psi", "variant": "italic", "symbol": "𝜓", "unicode": "U+1D713"},
        {"letter_name": "omega", "variant": "italic", "symbol": "𝜔", "unicode": "U+1D714"}
    ]
    
    Set italic_variants to List.concat(italic_uppercase, italic_lowercase)
    Return italic_variants

Process called "get_bold_italic_greek_letters" that returns List[GreekLetterVariant]:
    Note: Get bold italic Greek letters (𝜜, 𝜝, 𝜞, 𝜶, 𝜷, 𝜸, etc.)
    Let bold_italic_variants be []
    
    Note: Bold italic uppercase Greek letters (Mathematical Bold Italic)
    Let bold_italic_uppercase be [
        {"letter_name": "alpha", "variant": "bold_italic", "symbol": "𝜜", "unicode": "U+1D71C"},
        {"letter_name": "beta", "variant": "bold_italic", "symbol": "𝜝", "unicode": "U+1D71D"},
        {"letter_name": "gamma", "variant": "bold_italic", "symbol": "𝜞", "unicode": "U+1D71E"},
        {"letter_name": "delta", "variant": "bold_italic", "symbol": "𝜟", "unicode": "U+1D71F"},
        {"letter_name": "epsilon", "variant": "bold_italic", "symbol": "𝜠", "unicode": "U+1D720"},
        {"letter_name": "zeta", "variant": "bold_italic", "symbol": "𝜡", "unicode": "U+1D721"},
        {"letter_name": "eta", "variant": "bold_italic", "symbol": "𝜢", "unicode": "U+1D722"},
        {"letter_name": "theta", "variant": "bold_italic", "symbol": "𝜣", "unicode": "U+1D723"},
        {"letter_name": "iota", "variant": "bold_italic", "symbol": "𝜤", "unicode": "U+1D724"},
        {"letter_name": "kappa", "variant": "bold_italic", "symbol": "𝜥", "unicode": "U+1D725"},
        {"letter_name": "lambda", "variant": "bold_italic", "symbol": "𝜦", "unicode": "U+1D726"},
        {"letter_name": "mu", "variant": "bold_italic", "symbol": "𝜧", "unicode": "U+1D727"},
        {"letter_name": "nu", "variant": "bold_italic", "symbol": "𝜨", "unicode": "U+1D728"},
        {"letter_name": "xi", "variant": "bold_italic", "symbol": "𝜩", "unicode": "U+1D729"},
        {"letter_name": "omicron", "variant": "bold_italic", "symbol": "𝜪", "unicode": "U+1D72A"},
        {"letter_name": "pi", "variant": "bold_italic", "symbol": "𝜫", "unicode": "U+1D72B"},
        {"letter_name": "rho", "variant": "bold_italic", "symbol": "𝜬", "unicode": "U+1D72C"},
        {"letter_name": "sigma", "variant": "bold_italic", "symbol": "𝜮", "unicode": "U+1D72E"},
        {"letter_name": "tau", "variant": "bold_italic", "symbol": "𝜯", "unicode": "U+1D72F"},
        {"letter_name": "upsilon", "variant": "bold_italic", "symbol": "𝜰", "unicode": "U+1D730"},
        {"letter_name": "phi", "variant": "bold_italic", "symbol": "𝜱", "unicode": "U+1D731"},
        {"letter_name": "chi", "variant": "bold_italic", "symbol": "𝜲", "unicode": "U+1D732"},
        {"letter_name": "psi", "variant": "bold_italic", "symbol": "𝜳", "unicode": "U+1D733"},
        {"letter_name": "omega", "variant": "bold_italic", "symbol": "𝜴", "unicode": "U+1D734"}
    ]
    
    Note: Bold italic lowercase Greek letters (Mathematical Bold Italic)
    Let bold_italic_lowercase be [
        {"letter_name": "alpha", "variant": "bold_italic", "symbol": "𝜶", "unicode": "U+1D736"},
        {"letter_name": "beta", "variant": "bold_italic", "symbol": "𝜷", "unicode": "U+1D737"},
        {"letter_name": "gamma", "variant": "bold_italic", "symbol": "𝜸", "unicode": "U+1D738"},
        {"letter_name": "delta", "variant": "bold_italic", "symbol": "𝜹", "unicode": "U+1D739"},
        {"letter_name": "epsilon", "variant": "bold_italic", "symbol": "𝜺", "unicode": "U+1D73A"},
        {"letter_name": "zeta", "variant": "bold_italic", "symbol": "𝜻", "unicode": "U+1D73B"},
        {"letter_name": "eta", "variant": "bold_italic", "symbol": "𝜼", "unicode": "U+1D73C"},
        {"letter_name": "theta", "variant": "bold_italic", "symbol": "𝜽", "unicode": "U+1D73D"},
        {"letter_name": "iota", "variant": "bold_italic", "symbol": "𝜾", "unicode": "U+1D73E"},
        {"letter_name": "kappa", "variant": "bold_italic", "symbol": "𝜿", "unicode": "U+1D73F"},
        {"letter_name": "lambda", "variant": "bold_italic", "symbol": "𝝀", "unicode": "U+1D740"},
        {"letter_name": "mu", "variant": "bold_italic", "symbol": "𝝁", "unicode": "U+1D741"},
        {"letter_name": "nu", "variant": "bold_italic", "symbol": "𝝂", "unicode": "U+1D742"},
        {"letter_name": "xi", "variant": "bold_italic", "symbol": "𝝃", "unicode": "U+1D743"},
        {"letter_name": "omicron", "variant": "bold_italic", "symbol": "𝝄", "unicode": "U+1D744"},
        {"letter_name": "pi", "variant": "bold_italic", "symbol": "𝝅", "unicode": "U+1D745"},
        {"letter_name": "rho", "variant": "bold_italic", "symbol": "𝝆", "unicode": "U+1D746"},
        {"letter_name": "sigma", "variant": "bold_italic", "symbol": "𝝈", "unicode": "U+1D748"},
        {"letter_name": "tau", "variant": "bold_italic", "symbol": "𝝉", "unicode": "U+1D749"},
        {"letter_name": "upsilon", "variant": "bold_italic", "symbol": "𝝊", "unicode": "U+1D74A"},
        {"letter_name": "phi", "variant": "bold_italic", "symbol": "𝝋", "unicode": "U+1D74B"},
        {"letter_name": "chi", "variant": "bold_italic", "symbol": "𝝌", "unicode": "U+1D74C"},
        {"letter_name": "psi", "variant": "bold_italic", "symbol": "𝝍", "unicode": "U+1D74D"},
        {"letter_name": "omega", "variant": "bold_italic", "symbol": "𝝎", "unicode": "U+1D74E"}
    ]
    
    Set bold_italic_variants to List.concat(bold_italic_uppercase, bold_italic_lowercase)
    Return bold_italic_variants

Process called "get_script_greek_letters" that returns List[GreekLetterVariant]:
    Note: Get script-style Greek letters where available
    Let script_variants be []
    
    Note: Script uppercase Greek letters (Mathematical Script minus limited availability)
    Let script_uppercase be [
        {"letter_name": "alpha", "variant": "script", "symbol": "𝓶", "unicode": "U+1D4F6"},
        {"letter_name": "beta", "variant": "script", "symbol": "𝓷", "unicode": "U+1D4F7"},
        {"letter_name": "gamma", "variant": "script", "symbol": "𝓸", "unicode": "U+1D4F8"},
        {"letter_name": "delta", "variant": "script", "symbol": "𝓹", "unicode": "U+1D4F9"},
        {"letter_name": "epsilon", "variant": "script", "symbol": "𝓺", "unicode": "U+1D4FA"},
        {"letter_name": "zeta", "variant": "script", "symbol": "𝓻", "unicode": "U+1D4FB"},
        {"letter_name": "eta", "variant": "script", "symbol": "𝓼", "unicode": "U+1D4FC"},
        {"letter_name": "theta", "variant": "script", "symbol": "𝓽", "unicode": "U+1D4FD"},
        {"letter_name": "iota", "variant": "script", "symbol": "𝓾", "unicode": "U+1D4FE"},
        {"letter_name": "kappa", "variant": "script", "symbol": "𝓿", "unicode": "U+1D4FF"},
        {"letter_name": "lambda", "variant": "script", "symbol": "𝔀", "unicode": "U+1D500"},
        {"letter_name": "mu", "variant": "script", "symbol": "𝔁", "unicode": "U+1D501"},
        {"letter_name": "nu", "variant": "script", "symbol": "𝔂", "unicode": "U+1D502"},
        {"letter_name": "xi", "variant": "script", "symbol": "𝔃", "unicode": "U+1D503"},
        {"letter_name": "omicron", "variant": "script", "symbol": "𝔄", "unicode": "U+1D504"},
        {"letter_name": "pi", "variant": "script", "symbol": "𝔅", "unicode": "U+1D505"},
        {"letter_name": "rho", "variant": "script", "symbol": "𝔆", "unicode": "U+1D506"},
        {"letter_name": "sigma", "variant": "script", "symbol": "𝔈", "unicode": "U+1D508"},
        {"letter_name": "tau", "variant": "script", "symbol": "𝔉", "unicode": "U+1D509"},
        {"letter_name": "upsilon", "variant": "script", "symbol": "𝔊", "unicode": "U+1D50A"},
        {"letter_name": "phi", "variant": "script", "symbol": "𝔋", "unicode": "U+1D50B"},
        {"letter_name": "chi", "variant": "script", "symbol": "𝔌", "unicode": "U+1D50C"},
        {"letter_name": "psi", "variant": "script", "symbol": "𝔍", "unicode": "U+1D50D"},
        {"letter_name": "omega", "variant": "script", "symbol": "𝔎", "unicode": "U+1D50E"}
    ]
    
    Note: Script lowercase Greek letters (Mathematical Script minus limited availability)
    Let script_lowercase be [
        {"letter_name": "alpha", "variant": "script", "symbol": "𝔐", "unicode": "U+1D510"},
        {"letter_name": "beta", "variant": "script", "symbol": "𝔑", "unicode": "U+1D511"},
        {"letter_name": "gamma", "variant": "script", "symbol": "𝔒", "unicode": "U+1D512"},
        {"letter_name": "delta", "variant": "script", "symbol": "𝔓", "unicode": "U+1D513"},
        {"letter_name": "epsilon", "variant": "script", "symbol": "𝔔", "unicode": "U+1D514"},
        {"letter_name": "zeta", "variant": "script", "symbol": "𝔕", "unicode": "U+1D515"},
        {"letter_name": "eta", "variant": "script", "symbol": "𝔖", "unicode": "U+1D516"},
        {"letter_name": "theta", "variant": "script", "symbol": "𝔗", "unicode": "U+1D517"},
        {"letter_name": "iota", "variant": "script", "symbol": "𝔘", "unicode": "U+1D518"},
        {"letter_name": "kappa", "variant": "script", "symbol": "𝔙", "unicode": "U+1D519"},
        {"letter_name": "lambda", "variant": "script", "symbol": "𝔚", "unicode": "U+1D51A"},
        {"letter_name": "mu", "variant": "script", "symbol": "𝔛", "unicode": "U+1D51B"},
        {"letter_name": "nu", "variant": "script", "symbol": "𝔜", "unicode": "U+1D51C"},
        {"letter_name": "xi", "variant": "script", "symbol": "𝔝", "unicode": "U+1D51D"},
        {"letter_name": "omicron", "variant": "script", "symbol": "𝔞", "unicode": "U+1D51E"},
        {"letter_name": "pi", "variant": "script", "symbol": "𝔟", "unicode": "U+1D51F"},
        {"letter_name": "rho", "variant": "script", "symbol": "𝔠", "unicode": "U+1D520"},
        {"letter_name": "sigma", "variant": "script", "symbol": "𝔢", "unicode": "U+1D522"},
        {"letter_name": "tau", "variant": "script", "symbol": "𝔣", "unicode": "U+1D523"},
        {"letter_name": "upsilon", "variant": "script", "symbol": "𝔤", "unicode": "U+1D524"},
        {"letter_name": "phi", "variant": "script", "symbol": "𝔥", "unicode": "U+1D525"},
        {"letter_name": "chi", "variant": "script", "symbol": "𝔦", "unicode": "U+1D526"},
        {"letter_name": "psi", "variant": "script", "symbol": "𝔧", "unicode": "U+1D527"},
        {"letter_name": "omega", "variant": "script", "symbol": "𝔨", "unicode": "U+1D528"}
    ]
    
    Set script_variants to List.concat(script_uppercase, script_lowercase)
    Return script_variants

Note: =====================================================================
Note: PRONUNCIATION AND TRANSLITERATION
Note: =====================================================================

Process called "get_greek_letter_pronunciation" that takes letter_name as String returns String:
    Note: Get pronunciation guide for Greek letter
    Let pronunciation_map be {
        "alpha": "AL-fah",
        "beta": "BAY-tah",
        "gamma": "GAM-ah",
        "delta": "DEL-tah",
        "epsilon": "EP-si-lon",
        "zeta": "ZAY-tah",
        "eta": "AY-tah",
        "theta": "THAY-tah",
        "iota": "eye-OH-tah",
        "kappa": "KAP-ah",
        "lambda": "LAM-dah",
        "mu": "myoo",
        "nu": "nyoo",
        "xi": "ksee",
        "omicron": "OH-mi-kron",
        "pi": "pie",
        "rho": "roh",
        "sigma": "SIG-mah",
        "tau": "tow",
        "upsilon": "OOP-si-lon",
        "phi": "fie",
        "chi": "kie",
        "psi": "sie",
        "omega": "oh-MAY-gah"
    }
    
    Let pronunciation be Dictionary.get(pronunciation_map, letter_name, "")
    If pronunciation is equal to "":
        Return "Unknown pronunciation for letter: " plus letter_name
    Otherwise:
        Return pronunciation

Process called "get_greek_letter_transliteration" that takes letter_name as String returns String:
    Note: Get Latin transliteration of Greek letter
    Let transliteration_map be {
        "alpha": "a",
        "beta": "b",
        "gamma": "g",
        "delta": "d",
        "epsilon": "e",
        "zeta": "z",
        "eta": "ē",
        "theta": "th",
        "iota": "i",
        "kappa": "k",
        "lambda": "l",
        "mu": "m",
        "nu": "n",
        "xi": "x",
        "omicron": "o",
        "pi": "p",
        "rho": "r",
        "sigma": "s",
        "tau": "t",
        "upsilon": "u",
        "phi": "ph",
        "chi": "ch",
        "psi": "ps",
        "omega": "ō"
    }
    
    Let transliteration be Dictionary.get(transliteration_map, letter_name, "")
    If transliteration is equal to "":
        Return "Unknown transliteration for letter: " plus letter_name
    Otherwise:
        Return transliteration

Process called "ancient_vs_modern_pronunciation" that takes letter_name as String returns Dictionary[String, String]:
    Note: Compare ancient and modern Greek pronunciation
    Let pronunciation_comparison be {
        "alpha": {"ancient": "AL-pha", "modern": "AL-fa"},
        "beta": {"ancient": "BAY-ta", "modern": "VEE-ta"},
        "gamma": {"ancient": "GAM-ma", "modern": "GHAH-ma"},
        "delta": {"ancient": "DEL-ta", "modern": "THEL-ta"},
        "epsilon": {"ancient": "EP-si-lon", "modern": "EP-si-lon"},
        "zeta": {"ancient": "DZAY-ta", "modern": "ZEE-ta"},
        "eta": {"ancient": "AY-ta", "modern": "EE-ta"},
        "theta": {"ancient": "t-HAY-ta", "modern": "THEE-ta"},
        "iota": {"ancient": "ee-OH-ta", "modern": "YO-ta"},
        "kappa": {"ancient": "KAP-pa", "modern": "KAH-pa"},
        "lambda": {"ancient": "LAM-da", "modern": "LAHM-tha"},
        "mu": {"ancient": "moo", "modern": "mee"},
        "nu": {"ancient": "noo", "modern": "nee"},
        "xi": {"ancient": "KSEE", "modern": "KSEE"},
        "omicron": {"ancient": "OH-mi-kron", "modern": "OH-mi-kron"},
        "pi": {"ancient": "PEE", "modern": "PEE"},
        "rho": {"ancient": "r-HOH", "modern": "ROH"},
        "sigma": {"ancient": "SIG-ma", "modern": "SIGH-ma"},
        "tau": {"ancient": "TOW", "modern": "TAF"},
        "upsilon": {"ancient": "OO-psi-lon", "modern": "EEP-si-lon"},
        "phi": {"ancient": "p-HEE", "modern": "FEE"},
        "chi": {"ancient": "k-HEE", "modern": "KHEE"},
        "psi": {"ancient": "p-SEE", "modern": "PSEE"},
        "omega": {"ancient": "OH-may-ga", "modern": "oh-MEH-ga"}
    }
    
    Let comparison be Dictionary.get(pronunciation_comparison, letter_name, {})
    If Dictionary.size(comparison) is equal to 0:
        Return {"error": "Unknown letter: " plus letter_name}
    Otherwise:
        Return comparison

Note: =====================================================================
Note: HISTORICAL AND ETYMOLOGICAL OPERATIONS
Note: =====================================================================

Process called "get_letter_etymology" that takes letter_name as String returns String:
    Note: Get etymological information about Greek letter
    Let etymology_map be {
        "alpha": "From Phoenician aleph, meaning 'ox'. Originally represented the glottal stop, evolved to represent the vowel sound.",
        "beta": "From Phoenician beth, meaning 'house'. Retained its consonantal value throughout Greek evolution.",
        "gamma": "From Phoenician gimel, meaning 'camel'. Originally a hard 'g' sound, evolved to various pronunciations.",
        "delta": "From Phoenician daleth, meaning 'door'. Maintained its dental consonant sound through history.",
        "epsilon": "Developed from Phoenician he. Originally a consonant, became the short 'e' vowel in Greek.",
        "zeta": "From Phoenician zayin, meaning 'weapon'. Evolved from a hard 'z' to various sibilant sounds.",
        "eta": "Originally from Phoenician heth. In early Greek dialects represented 'h', later became long 'e'.",
        "theta": "Unique Greek innovation, possibly from Phoenician teth. Represents the aspirated 't' sound.",
        "iota": "From Phoenician yodh, meaning 'hand'. Smallest letter, hence 'not one iota' meaning 'not the least bit'.",
        "kappa": "From Phoenician kaph, meaning 'palm of hand'. Maintained its velar stop pronunciation.",
        "lambda": "From Phoenician lamedh, meaning 'goad' or 'staff'. Retained its lateral consonant sound.",
        "mu": "From Phoenician mem, meaning 'water'. Maintained its bilabial nasal sound throughout history.",
        "nu": "From Phoenician nun, meaning 'fish' or 'serpent'. Retained its dental nasal pronunciation.",
        "xi": "Greek innovation, possibly from Phoenician samekh. Represents the double consonant 'ks'.",
        "omicron": "Means 'small o' in Greek, distinguishing it from omega ('big o'). Short vowel sound.",
        "pi": "From Phoenician pe, meaning 'mouth'. Maintained its bilabial stop sound in ancient Greek.",
        "rho": "From Phoenician resh, meaning 'head'. Retained its liquid consonant sound throughout history.",
        "sigma": "From Phoenician shin, meaning 'tooth'. Evolved to represent various sibilant sounds.",
        "tau": "From Phoenician taw, meaning 'mark' or 'sign'. Maintained its dental stop pronunciation.",
        "upsilon": "Originally from Phoenician waw. Developed into a distinct vowel sound separate from omicron.",
        "phi": "Greek innovation representing aspirated 'p'. Originally written as P with vertical line through it.",
        "chi": "From Phoenician qoph. Represents aspirated 'k' sound, evolved to fricative in modern Greek.",
        "psi": "Greek innovation representing 'ps' sound cluster. Late addition to the alphabet.",
        "omega": "Means 'big o' in Greek, represents long 'o' sound. Developed to distinguish from omicron."
    }
    
    Let etymology be Dictionary.get(etymology_map, letter_name, "")
    If etymology is equal to "":
        Return "No etymological information available for letter: " plus letter_name
    Otherwise:
        Return etymology

Process called "get_phoenician_origin" that takes letter_name as String returns Dictionary[String, String]:
    Note: Get Phoenician origin of Greek letter
    Let phoenician_origins be {
        "alpha": {"phoenician_letter": "aleph", "meaning": "ox", "symbol": "𐤀", "evolution": "glottal_stop_to_vowel"},
        "beta": {"phoenician_letter": "beth", "meaning": "house", "symbol": "𐤁", "evolution": "consonant_preserved"},
        "gamma": {"phoenician_letter": "gimel", "meaning": "camel", "symbol": "𐤂", "evolution": "hard_g_to_varied"},
        "delta": {"phoenician_letter": "daleth", "meaning": "door", "symbol": "𐤃", "evolution": "dental_preserved"},
        "epsilon": {"phoenician_letter": "he", "meaning": "window", "symbol": "𐤄", "evolution": "consonant_to_vowel"},
        "zeta": {"phoenician_letter": "zayin", "meaning": "weapon", "symbol": "𐤅", "evolution": "sibilant_evolved"},
        "eta": {"phoenician_letter": "heth", "meaning": "fence", "symbol": "𐤆", "evolution": "fricative_to_vowel"},
        "theta": {"phoenician_letter": "teth", "meaning": "wheel", "symbol": "𐤇", "evolution": "aspirated_innovation"},
        "iota": {"phoenician_letter": "yodh", "meaning": "hand", "symbol": "𐤈", "evolution": "consonant_to_vowel"},
        "kappa": {"phoenician_letter": "kaph", "meaning": "palm", "symbol": "𐤉", "evolution": "velar_preserved"},
        "lambda": {"phoenician_letter": "lamedh", "meaning": "goad", "symbol": "𐤊", "evolution": "lateral_preserved"},
        "mu": {"phoenician_letter": "mem", "meaning": "water", "symbol": "𐤋", "evolution": "nasal_preserved"},
        "nu": {"phoenician_letter": "nun", "meaning": "fish", "symbol": "𐤌", "evolution": "nasal_preserved"},
        "xi": {"phoenician_letter": "samekh", "meaning": "support", "symbol": "𐤍", "evolution": "cluster_innovation"},
        "omicron": {"phoenician_letter": "ayin", "meaning": "eye", "symbol": "𐤎", "evolution": "consonant_to_vowel"},
        "pi": {"phoenician_letter": "pe", "meaning": "mouth", "symbol": "𐤏", "evolution": "bilabial_preserved"},
        "rho": {"phoenician_letter": "resh", "meaning": "head", "symbol": "𐤐", "evolution": "liquid_preserved"},
        "sigma": {"phoenician_letter": "shin", "meaning": "tooth", "symbol": "𐤑", "evolution": "sibilant_simplified"},
        "tau": {"phoenician_letter": "taw", "meaning": "mark", "symbol": "𐤒", "evolution": "dental_preserved"},
        "upsilon": {"phoenician_letter": "waw", "meaning": "hook", "symbol": "𐤓", "evolution": "consonant_to_vowel"},
        "phi": {"phoenician_letter": "none", "meaning": "greek_innovation", "symbol": "none", "evolution": "aspirated_creation"},
        "chi": {"phoenician_letter": "qoph", "meaning": "needle_eye", "symbol": "𐤔", "evolution": "uvular_to_fricative"},
        "psi": {"phoenician_letter": "none", "meaning": "greek_innovation", "symbol": "none", "evolution": "cluster_creation"},
        "omega": {"phoenician_letter": "none", "meaning": "greek_innovation", "symbol": "none", "evolution": "vowel_distinction"}
    }
    
    Let origin_info be Dictionary.get(phoenician_origins, letter_name, {})
    If Dictionary.size(origin_info) is equal to 0:
        Return {"error": "No Phoenician origin information for letter: " plus letter_name}
    Otherwise:
        Return origin_info

Process called "get_mathematical_history" that takes letter_name as String returns String:
    Note: Get history of letter's use in mathematics
    Let math_history_map be {
        "alpha": "Used since Euler for angles, coefficients, and the fine structure constant (α ≈ 1/137). Common in physics for angular acceleration and thermal expansion.",
        "beta": "Introduced by Euler for angles, widely used in physics for velocity ratios (v/c), and in statistics for beta distributions and regression coefficients.",
        "gamma": "Used by Euler for the Euler-Mascheroni constant (γ ≈ 0.5772). Common for Lorentz factor in relativity and gamma functions in analysis.",
        "delta": "Ancient symbol for change, formalized by Leibniz in calculus for infinitesimals. Modern usage includes Dirac delta function and Kronecker delta.",
        "epsilon": "Introduced by Weierstrass for arbitrarily small positive quantities in analysis. Essential in limit definitions and set theory (∈).",
        "zeta": "Famous for Riemann zeta function ζ(s), central to number theory and the Riemann Hypothesis. Used since Riemann's 1859 paper.",
        "eta": "Used in physics for efficiency (η), viscosity, and pseudorapidity in particle physics. Less common in pure mathematics.",
        "theta": "Traditional symbol for angles since ancient Greek geometry. Used in spherical coordinates, trigonometry, and Jacobi theta functions.",
        "iota": "Rarely used in mathematics due to confusion with 'i'. Occasionally appears in complex analysis and set theory contexts.",
        "kappa": "Used in differential geometry for curvature, condition numbers in numerical analysis, and von Kármán constant in fluid dynamics.",
        "lambda": "Introduced by Church for lambda calculus (1930s). Used for eigenvalues, wavelength in physics, and Lebesgue measure theory.",
        "mu": "Used for mean in statistics, measure theory, magnetic permeability in physics, and friction coefficients in mechanics.",
        "nu": "Common for frequency in physics and engineering, degrees of freedom in statistics, and kinematic viscosity in fluid mechanics.",
        "xi": "Used in probability for random variables, particularly in statistics and stochastic processes. Less common than other Greek letters.",
        "omicron": "Rarely used in mathematics due to confusion with zero and Latin 'O'. Occasionally appears in combinatorics.",
        "pi": "Most famous mathematical constant (π ≈ 3.14159), used since Archimedes. Symbol π introduced by William Jones (1706), popularized by Euler.",
        "rho": "Used for density in physics, correlation coefficients in statistics, and resistivity in electrical engineering since the 19th century.",
        "sigma": "Introduced by Euler for summation (Σ). Used for standard deviation (σ), stress in mechanics, and cross-sections in physics.",
        "tau": "Traditional symbol for time, torque, proper time in relativity. Recently proposed as 2π by Michael Hartl (2010) for 'tau manifesto'.",
        "upsilon": "Rarely used in mathematics. Occasionally appears in particle physics for upsilon mesons and some specialized mathematical contexts.",
        "phi": "Used for golden ratio (φ ≈ 1.618) since 20th century, angles in spherical coordinates, and Euler's totient function φ(n).",
        "chi": "Used for chi-squared distribution (χ²) in statistics since Karl Pearson (1900), and characteristic functions in analysis.",
        "psi": "Used for wave functions in quantum mechanics since Schrödinger (1926), digamma function ψ(x), and angles in mathematics.",
        "omega": "Used for angular frequency (ω) in physics, the set of natural numbers in set theory, and resistance in electrical circuits (Ω)."
    }
    
    Let history be Dictionary.get(math_history_map, letter_name, "")
    If history is equal to "":
        Return "No mathematical history available for letter: " plus letter_name
    Otherwise:
        Return history

Note: =====================================================================
Note: SYMBOL SEARCH AND CLASSIFICATION
Note: =====================================================================

Process called "find_greek_letter_by_name" that takes letter_name as String returns GreekLetter:
    Note: Find Greek letter by name (alpha, beta, gamma, etc.)
    Let normalized_name be String.toLowerCase(letter_name)
    
    If normalized_name is equal to "alpha":
        Return alpha_symbols()
    Otherwise if normalized_name is equal to "beta":
        Return beta_symbols()
    Otherwise if normalized_name is equal to "gamma":
        Return gamma_symbols()
    Otherwise if normalized_name is equal to "delta":
        Return delta_symbols()
    Otherwise if normalized_name is equal to "epsilon":
        Return epsilon_symbols()
    Otherwise if normalized_name is equal to "zeta":
        Return zeta_symbols()
    Otherwise if normalized_name is equal to "eta":
        Return eta_symbols()
    Otherwise if normalized_name is equal to "theta":
        Return theta_symbols()
    Otherwise if normalized_name is equal to "iota":
        Return iota_symbols()
    Otherwise if normalized_name is equal to "kappa":
        Return kappa_symbols()
    Otherwise if normalized_name is equal to "lambda":
        Return lambda_symbols()
    Otherwise if normalized_name is equal to "mu":
        Return mu_symbols()
    Otherwise if normalized_name is equal to "nu":
        Return nu_symbols()
    Otherwise if normalized_name is equal to "xi":
        Return xi_symbols()
    Otherwise if normalized_name is equal to "omicron":
        Return omicron_symbols()
    Otherwise if normalized_name is equal to "pi":
        Return pi_symbols()
    Otherwise if normalized_name is equal to "rho":
        Return rho_symbols()
    Otherwise if normalized_name is equal to "sigma":
        Return sigma_symbols()
    Otherwise if normalized_name is equal to "tau":
        Return tau_symbols()
    Otherwise if normalized_name is equal to "upsilon":
        Return upsilon_symbols()
    Otherwise if normalized_name is equal to "phi":
        Return phi_symbols()
    Otherwise if normalized_name is equal to "chi":
        Return chi_symbols()
    Otherwise if normalized_name is equal to "psi":
        Return psi_symbols()
    Otherwise if normalized_name is equal to "omega":
        Return omega_symbols()
    Otherwise:
        Throw Errors.InvalidArgument with "Unknown Greek letter name: " plus letter_name

Process called "find_greek_letter_by_symbol" that takes symbol as String returns GreekLetter:
    Note: Find Greek letter information by Unicode symbol
    Let all_letters be get_complete_greek_alphabet()
    
    For each letter in all_letters:
        If letter.uppercase_symbol is equal to symbol || letter.lowercase_symbol is equal to symbol:
            Return letter
    
    Throw Errors.InvalidArgument with "Symbol not found in Greek alphabet: " plus symbol

Process called "classify_greek_letter_usage" that takes letter_name as String, context as String returns String:
    Note: Classify Greek letter usage in mathematical context
    Let letter be find_greek_letter_by_name(letter_name)
    Let usage_list be letter.mathematical_usage
    
    If context is equal to "calculus":
        If List.contains(usage_list, "small_quantity") || List.contains(usage_list, "change"):
            Return "limit_variable"
        Otherwise if List.contains(usage_list, "angle"):
            Return "parameter"
        Otherwise:
            Return "general_variable"
    
    Otherwise if context is equal to "physics":
        If List.contains(usage_list, "angle"):
            Return "angular_measurement"
        Otherwise if List.contains(usage_list, "coefficient"):
            Return "physical_constant"
        Otherwise:
            Return "physical_parameter"
    
    Otherwise if context is equal to "statistics":
        If List.contains(usage_list, "mean"):
            Return "central_tendency"
        Otherwise if List.contains(usage_list, "standard_deviation"):
            Return "dispersion_measure"
        Otherwise:
            Return "statistical_parameter"
    
    Otherwise:
        Return "general_mathematical_symbol"

Process called "get_similar_letters" that takes reference_letter as String returns List[GreekLetter]:
    Note: Get Greek letters similar to reference letter
    Let similar_letters be []
    
    If reference_letter is equal to "alpha":
        Append lambda_symbols() to similar_letters
    Otherwise if reference_letter is equal to "beta":
        Append eta_symbols() to similar_letters
    Otherwise if reference_letter is equal to "gamma":
        Append upsilon_symbols() to similar_letters
    Otherwise if reference_letter is equal to "delta":
        Append lambda_symbols() to similar_letters
    Otherwise if reference_letter is equal to "epsilon":
        Append xi_symbols() to similar_letters
    Otherwise if reference_letter is equal to "zeta":
        Append xi_symbols() to similar_letters
    Otherwise if reference_letter is equal to "theta":
        Append phi_symbols() to similar_letters
    Otherwise if reference_letter is equal to "kappa":
        Append chi_symbols() to similar_letters
    Otherwise if reference_letter is equal to "mu":
        Append nu_symbols() to similar_letters
    Otherwise if reference_letter is equal to "nu":
        Append mu_symbols() to similar_letters
    Otherwise if reference_letter is equal to "omicron":
        Append sigma_symbols() to similar_letters
    Otherwise if reference_letter is equal to "rho":
        Append pi_symbols() to similar_letters
    Otherwise if reference_letter is equal to "upsilon":
        Append psi_symbols() to similar_letters
    
    Return similar_letters

Note: =====================================================================
Note: ENCODING AND NORMALIZATION OPERATIONS
Note: =====================================================================

Process called "normalize_greek_unicode" that takes greek_text as String, normalization_form as String returns String:
    Note: Apply Unicode normalization to Greek text
    Let normalized_text be greek_text
    
    Note: Apply normalization based on form (NFC, NFD, NFKC, NFKD)
    If normalization_form is equal to "NFC":
        Note: Canonical composition minus combine base plus diacritics
        Set normalized_text to String.replace_all(normalized_text, "α\u0301", "ά")
        Set normalized_text to String.replace_all(normalized_text, "ε\u0301", "έ")
        Set normalized_text to String.replace_all(normalized_text, "η\u0301", "ή")
        Set normalized_text to String.replace_all(normalized_text, "ι\u0301", "ί")
        Set normalized_text to String.replace_all(normalized_text, "ο\u0301", "ό")
        Set normalized_text to String.replace_all(normalized_text, "υ\u0301", "ύ")
        Set normalized_text to String.replace_all(normalized_text, "ω\u0301", "ώ")
    Otherwise if normalization_form is equal to "NFD":
        Note: Canonical decomposition minus separate base plus diacritics
        Set normalized_text to String.replace_all(normalized_text, "ά", "α\u0301")
        Set normalized_text to String.replace_all(normalized_text, "έ", "ε\u0301")
        Set normalized_text to String.replace_all(normalized_text, "ή", "η\u0301")
        Set normalized_text to String.replace_all(normalized_text, "ί", "ι\u0301")
        Set normalized_text to String.replace_all(normalized_text, "ό", "ο\u0301")
        Set normalized_text to String.replace_all(normalized_text, "ύ", "υ\u0301")
        Set normalized_text to String.replace_all(normalized_text, "ώ", "ω\u0301")
    Otherwise if normalization_form is equal to "NFKC":
        Note: Compatibility composition
        Set normalized_text to String.replace_all(normalized_text, "ϰ", "κ")
        Set normalized_text to String.replace_all(normalized_text, "ϱ", "ρ")
        Set normalized_text to String.replace_all(normalized_text, "ϵ", "ε")
        Set normalized_text to String.replace_all(normalized_text, "ϑ", "θ")
        Set normalized_text to String.replace_all(normalized_text, "ϕ", "φ")
        Set normalized_text to String.replace_all(normalized_text, "ϖ", "π")
    Otherwise if normalization_form is equal to "NFKD":
        Note: Compatibility decomposition plus canonical decomposition
        Set normalized_text to String.replace_all(normalized_text, "ϰ", "κ")
        Set normalized_text to String.replace_all(normalized_text, "ϱ", "ρ")
        Set normalized_text to String.replace_all(normalized_text, "ϵ", "ε")
        Set normalized_text to String.replace_all(normalized_text, "ϑ", "θ")
        Set normalized_text to String.replace_all(normalized_text, "ϕ", "φ")
        Set normalized_text to String.replace_all(normalized_text, "ϖ", "π")
        Set normalized_text to String.replace_all(normalized_text, "ά", "α\u0301")
        Set normalized_text to String.replace_all(normalized_text, "έ", "ε\u0301")
        Set normalized_text to String.replace_all(normalized_text, "ή", "η\u0301")
        Set normalized_text to String.replace_all(normalized_text, "ί", "ι\u0301")
        Set normalized_text to String.replace_all(normalized_text, "ό", "ο\u0301")
        Set normalized_text to String.replace_all(normalized_text, "ύ", "υ\u0301")
        Set normalized_text to String.replace_all(normalized_text, "ώ", "ω\u0301")
    Otherwise:
        Return "Unsupported normalization form: " plus normalization_form
    
    Return normalized_text

Process called "convert_greek_encoding" that takes greek_text as String, from_encoding as String, to_encoding as String returns String:
    Note: Convert between different Greek text encodings
    Let converted_text be greek_text
    
    Note: Handle legacy encodings to Unicode conversion
    If from_encoding is equal to "iso-8859-7" and to_encoding is equal to "utf-8":
        Note: Convert from Greek ISO to UTF-8
        Let iso_to_unicode be {
            "\xC1": "Α", "\xC2": "Β", "\xC3": "Γ", "\xC4": "Δ", "\xC5": "Ε", "\xC6": "Ζ",
            "\xC7": "Η", "\xC8": "Θ", "\xC9": "Ι", "\xCA": "Κ", "\xCB": "Λ", "\xCC": "Μ",
            "\xCD": "Ν", "\xCE": "Ξ", "\xCF": "Ο", "\xD0": "Π", "\xD1": "Ρ", "\xD3": "Σ",
            "\xD4": "Τ", "\xD5": "Υ", "\xD6": "Φ", "\xD7": "Χ", "\xD8": "Ψ", "\xD9": "Ω",
            "\xE1": "α", "\xE2": "β", "\xE3": "γ", "\xE4": "δ", "\xE5": "ε", "\xE6": "ζ",
            "\xE7": "η", "\xE8": "θ", "\xE9": "ι", "\xEA": "κ", "\xEB": "λ", "\xEC": "μ",
            "\xED": "ν", "\xEE": "ξ", "\xEF": "ο", "\xF0": "π", "\xF1": "ρ", "\xF2": "ς",
            "\xF3": "σ", "\xF4": "τ", "\xF5": "υ", "\xF6": "φ", "\xF7": "χ", "\xF8": "ψ", "\xF9": "ω"
        }
        
        Let result be converted_text
        For each (iso_char, unicode_char) in Dictionary.items(iso_to_unicode):
            Set result to String.replace_all(result, iso_char, unicode_char)
        Set converted_text to result
        
    Otherwise if from_encoding is equal to "windows-1253" and to_encoding is equal to "utf-8":
        Note: Convert from Windows Greek to UTF-8
        Let win_to_unicode be {
            "\xC1": "Α", "\xC2": "Β", "\xC3": "Γ", "\xC4": "Δ", "\xC5": "Ε", "\xC6": "Ζ",
            "\xC7": "Η", "\xC8": "Θ", "\xC9": "Ι", "\xCA": "Κ", "\xCB": "Λ", "\xCC": "Μ",
            "\xCD": "Ν", "\xCE": "Ξ", "\xCF": "Ο", "\xD0": "Π", "\xD1": "Ρ", "\xD3": "Σ",
            "\xD4": "Τ", "\xD5": "Υ", "\xD6": "Φ", "\xD7": "Χ", "\xD8": "Ψ", "\xD9": "Ω",
            "\xE1": "α", "\xE2": "β", "\xE3": "γ", "\xE4": "δ", "\xE5": "ε", "\xE6": "ζ",
            "\xE7": "η", "\xE8": "θ", "\xE9": "ι", "\xEA": "κ", "\xEB": "λ", "\xEC": "μ",
            "\xED": "ν", "\xEE": "ξ", "\xEF": "ο", "\xF0": "π", "\xF1": "ρ", "\xF2": "ς",
            "\xF3": "σ", "\xF4": "τ", "\xF5": "υ", "\xF6": "φ", "\xF7": "χ", "\xF8": "ψ", "\xF9": "ω"
        }
        
        Let result be converted_text
        For each (win_char, unicode_char) in Dictionary.items(win_to_unicode):
            Set result to String.replace_all(result, win_char, unicode_char)
        Set converted_text to result
        
    Otherwise if from_encoding is equal to "utf-8" and to_encoding is equal to "ascii":
        Note: Convert Greek Unicode to ASCII transliteration
        Let unicode_to_ascii be {
            "Α": "A", "Β": "B", "Γ": "G", "Δ": "D", "Ε": "E", "Ζ": "Z", "Η": "H", "Θ": "Th",
            "Ι": "I", "Κ": "K", "Λ": "L", "Μ": "M", "Ν": "N", "Ξ": "X", "Ο": "O", "Π": "P",
            "Ρ": "R", "Σ": "S", "Τ": "T", "Υ": "Y", "Φ": "Ph", "Χ": "Ch", "Ψ": "Ps", "Ω": "O",
            "α": "a", "β": "b", "γ": "g", "δ": "d", "ε": "e", "ζ": "z", "η": "e", "θ": "th",
            "ι": "i", "κ": "k", "λ": "l", "μ": "m", "ν": "n", "ξ": "x", "ο": "o", "π": "p",
            "ρ": "r", "σ": "s", "ς": "s", "τ": "t", "υ": "y", "φ": "ph", "χ": "ch", "ψ": "ps", "ω": "o"
        }
        
        Let result be converted_text
        For each (unicode_char, ascii_char) in Dictionary.items(unicode_to_ascii):
            Set result to String.replace_all(result, unicode_char, ascii_char)
        Set converted_text to result
        
    Otherwise:
        Return "Unsupported encoding conversion: " plus from_encoding plus " to " plus to_encoding
    
    Return converted_text

Process called "detect_greek_letter_variants" that takes text as String returns List[Dictionary[String, String]]:
    Note: Detect and classify Greek letter variants in text
    Let detected_variants be []
    
    Note: Define variant detection patterns
    Let variant_patterns be [
        Note: Mathematical bold variants
        {"pattern": "𝚨|𝚩|𝚪|𝚫|𝚬|𝚭|𝚮|𝚯|𝚰|𝚱|𝚲|𝚳|𝚴|𝚵|𝚶|𝚷|𝚸|𝚺|𝚻|𝚼|𝚽|𝚾|𝚿|𝛀", "style": "bold", "case": "uppercase"},
        {"pattern": "𝛂|𝛃|𝛄|𝛅|𝛆|𝛇|𝛈|𝛉|𝛊|𝛋|𝛌|𝛍|𝛎|𝛏|𝛐|𝛑|𝛒|𝛔|𝛕|𝛖|𝛗|𝛘|𝛙|𝛚", "style": "bold", "case": "lowercase"},
        Note: Mathematical italic variants
        {"pattern": "𝛢|𝛣|𝛤|𝛥|𝛦|𝛧|𝛨|𝛩|𝛪|𝛫|𝛬|𝛭|𝛮|𝛯|𝛰|𝛱|𝛲|𝛴|𝛵|𝛶|𝛷|𝛸|𝛹|𝛺", "style": "italic", "case": "uppercase"},
        {"pattern": "𝛼|𝛽|𝛾|𝛿|𝜀|𝜁|𝜂|𝜃|𝜄|𝜅|𝜆|𝜇|𝜈|𝜉|𝜊|𝜋|𝜌|𝜎|𝜏|𝜐|𝜑|𝜒|𝜓|𝜔", "style": "italic", "case": "lowercase"},
        Note: Mathematical bold italic variants
        {"pattern": "𝜜|𝜝|𝜞|𝜟|𝜠|𝜡|𝜢|𝜣|𝜤|𝜥|𝜦|𝜧|𝜨|𝜩|𝜪|𝜫|𝜬|𝜮|𝜯|𝜰|𝜱|𝜲|𝜳|𝜴", "style": "bold_italic", "case": "uppercase"},
        {"pattern": "𝜶|𝜷|𝜸|𝜹|𝜺|𝜻|𝜼|𝜽|𝜾|𝜿|𝝀|𝝁|𝝂|𝝃|𝝄|𝝅|𝝆|𝝈|𝝉|𝝊|𝝋|𝝌|𝝍|𝝎", "style": "bold_italic", "case": "lowercase"},
        Note: Regular Greek letters
        {"pattern": "Α|Β|Γ|Δ|Ε|Ζ|Η|Θ|Ι|Κ|Λ|Μ|Ν|Ξ|Ο|Π|Ρ|Σ|Τ|Υ|Φ|Χ|Ψ|Ω", "style": "regular", "case": "uppercase"},
        {"pattern": "α|β|γ|δ|ε|ζ|η|θ|ι|κ|λ|μ|ν|ξ|ο|π|ρ|σ|ς|τ|υ|φ|χ|ψ|ω", "style": "regular", "case": "lowercase"},
        Note: Variant forms
        {"pattern": "ϑ|ϕ|ϖ|ϰ|ϱ|ϵ", "style": "variant", "case": "lowercase"}
    ]
    
    Note: Search for each pattern in the text
    For each pattern_info in variant_patterns:
        Let pattern be Dictionary.get(pattern_info, "pattern", "")
        Let style be Dictionary.get(pattern_info, "style", "unknown")
        Let case_type be Dictionary.get(pattern_info, "case", "unknown")
        
        Note: Find matches using character iteration
        Let position be 0
        While position is less than String.length(text):
            Let char be String.char_at(text, position)
            If String.contains(pattern, char):
                Let detection be {
                    "symbol": char,
                    "style": style,
                    "case": case_type,
                    "position": String.from_integer(position),
                    "unicode_block": "greek_mathematical"
                }
                Set detected_variants to List.append(detected_variants, detection)
            Set position to position plus 1
    
    Return detected_variants

Note: =====================================================================
Note: RENDERING AND DISPLAY OPERATIONS
Note: =====================================================================

Process called "render_greek_letter_latex" that takes letter as GreekLetter, style as String returns String:
    Note: Render Greek letter as LaTeX command
    Let letter_name be Dictionary.get(letter, "letter_name", "")
    
    Note: Base LaTeX commands for Greek letters
    Let latex_commands be {
        "alpha": "\\alpha", "beta": "\\beta", "gamma": "\\gamma", "delta": "\\delta",
        "epsilon": "\\epsilon", "zeta": "\\zeta", "eta": "\\eta", "theta": "\\theta",
        "iota": "\\iota", "kappa": "\\kappa", "lambda": "\\lambda", "mu": "\\mu",
        "nu": "\\nu", "xi": "\\xi", "omicron": "o", "pi": "\\pi",
        "rho": "\\rho", "sigma": "\\sigma", "tau": "\\tau", "upsilon": "\\upsilon",
        "phi": "\\phi", "chi": "\\chi", "psi": "\\psi", "omega": "\\omega"
    }
    
    Note: Uppercase variants
    Let latex_uppercase be {
        "alpha": "A", "beta": "B", "gamma": "\\Gamma", "delta": "\\Delta",
        "epsilon": "E", "zeta": "Z", "eta": "H", "theta": "\\Theta",
        "iota": "I", "kappa": "K", "lambda": "\\Lambda", "mu": "M",
        "nu": "N", "xi": "\\Xi", "omicron": "O", "pi": "\\Pi",
        "rho": "P", "sigma": "\\Sigma", "tau": "T", "upsilon": "\\Upsilon",
        "phi": "\\Phi", "chi": "X", "psi": "\\Psi", "omega": "\\Omega"
    }
    
    Let base_command be Dictionary.get(latex_commands, letter_name, "")
    Let uppercase_command be Dictionary.get(latex_uppercase, letter_name, "")
    
    If base_command is equal to "" and uppercase_command is equal to "":
        Return "\\text{" plus letter_name plus "}"
    
    Note: Apply styling
    If style is equal to "bold":
        If String.contains(Dictionary.get(letter, "uppercase_symbol", ""), String.char_at(Dictionary.get(letter, "uppercase_symbol", ""), 0)):
            Return "\\boldsymbol{" plus uppercase_command plus "}"
        Otherwise:
            Return "\\boldsymbol{" plus base_command plus "}"
    Otherwise if style is equal to "italic":
        If String.contains(Dictionary.get(letter, "uppercase_symbol", ""), String.char_at(Dictionary.get(letter, "uppercase_symbol", ""), 0)):
            Return uppercase_command
        Otherwise:
            Return base_command
    Otherwise if style is equal to "bold_italic":
        If String.contains(Dictionary.get(letter, "uppercase_symbol", ""), String.char_at(Dictionary.get(letter, "uppercase_symbol", ""), 0)):
            Return "\\boldsymbol{" plus uppercase_command plus "}"
        Otherwise:
            Return "\\boldsymbol{" plus base_command plus "}"
    Otherwise:
        Note: Default to regular style
        If String.contains(Dictionary.get(letter, "uppercase_symbol", ""), String.char_at(Dictionary.get(letter, "uppercase_symbol", ""), 0)):
            Return uppercase_command
        Otherwise:
            Return base_command

Process called "render_greek_letter_mathml" that takes letter as GreekLetter, style as String returns String:
    Note: Render Greek letter as MathML markup
    Let letter_name be Dictionary.get(letter, "letter_name", "")
    Let uppercase_symbol be Dictionary.get(letter, "uppercase_symbol", "")
    Let lowercase_symbol be Dictionary.get(letter, "lowercase_symbol", "")
    
    Note: Determine which symbol to use
    Let symbol be lowercase_symbol
    Let case_attr be "normal"
    If String.length(uppercase_symbol) is greater than 0 and String.char_at(uppercase_symbol, 0) is equal to String.char_at(uppercase_symbol, 0):
        Set symbol to uppercase_symbol
        Set case_attr to "upper"
    
    Note: Build MathML based on style
    If style is equal to "bold":
        Return "<mi mathvariant=\"bold\">" plus symbol plus "</mi>"
    Otherwise if style is equal to "italic":
        Return "<mi mathvariant=\"italic\">" plus symbol plus "</mi>"
    Otherwise if style is equal to "bold_italic":
        Return "<mi mathvariant=\"bold-italic\">" plus symbol plus "</mi>"
    Otherwise if style is equal to "script":
        Return "<mi mathvariant=\"script\">" plus symbol plus "</mi>"
    Otherwise if style is equal to "double_struck":
        Return "<mi mathvariant=\"double-struck\">" plus symbol plus "</mi>"
    Otherwise if style is equal to "monospace":
        Return "<mi mathvariant=\"monospace\">" plus symbol plus "</mi>"
    Otherwise if style is equal to "sans_serif":
        Return "<mi mathvariant=\"sans-serif\">" plus symbol plus "</mi>"
    Otherwise:
        Note: Default regular style
        Return "<mi>" plus symbol plus "</mi>"

Process called "get_font_support_greek" that takes letter as GreekLetter returns List[String]:
    Note: Get fonts that support specified Greek letter
    Let letter_name be Dictionary.get(letter, "letter_name", "")
    
    Note: Fonts with comprehensive Greek support
    Let comprehensive_fonts be [
        "Times New Roman", "Arial", "Helvetica", "Georgia", "Palatino",
        "Cambria", "Computer Modern", "Latin Modern", "TeX Gyre Termes",
        "Liberation Serif", "DejaVu Serif", "GNU FreeSerif"
    ]
    
    Note: Mathematical fonts with Greek variants
    Let mathematical_fonts be [
        "Computer Modern", "Latin Modern Math", "TeX Gyre Termes Math",
        "STIX Two Math", "Asana Math", "XITS Math", "Libertinus Math",
        "Fira Math", "GFS Neohellenic Math"
    ]
    
    Note: Specialized Greek fonts
    Let greek_specialized_fonts be [
        "GFS Artemisia", "GFS Bodoni", "GFS Complutum", "GFS Didot",
        "GFS Neohellenic", "GFS Porson", "GFS Solomos", "Minion Pro",
        "Adobe Greek", "SIL Gentium", "Cardo", "Junicode"
    ]
    
    Note: Check for special variant requirements
    Let unicode_uppercase be Dictionary.get(letter, "unicode_uppercase", "")
    Let unicode_lowercase be Dictionary.get(letter, "unicode_lowercase", "")
    
    Note: Basic Greek block support (U+0370–U+03FF)
    Let basic_support_fonts be List.concat(comprehensive_fonts, greek_specialized_fonts)
    
    Note: Mathematical Greek block support (U+1D6A8–U+1D7CB)
    If String.contains(unicode_uppercase, "1D6") or String.contains(unicode_lowercase, "1D6"):
        Return mathematical_fonts
    Otherwise:
        Return basic_support_fonts

Note: =====================================================================
Note: UTILITY AND VALIDATION OPERATIONS
Note: =====================================================================

Process called "validate_greek_symbol" that takes symbol as String returns Boolean:
    Note: Validate if symbol is a valid Greek letter
    Let greek_uppercase be ["Α", "Β", "Γ", "Δ", "Ε", "Ζ", "Η", "Θ", "Ι", "Κ", "Λ", "Μ", "Ν", "Ξ", "Ο", "Π", "Ρ", "Σ", "Τ", "Υ", "Φ", "Χ", "Ψ", "Ω"]
    Let greek_lowercase be ["α", "β", "γ", "δ", "ε", "ζ", "η", "θ", "ι", "κ", "λ", "μ", "ν", "ξ", "ο", "π", "ρ", "σ", "τ", "υ", "φ", "χ", "ψ", "ω"]
    Let greek_variants be ["ς", "ϑ", "ϕ", "ϖ", "ϰ", "ϱ", "ϵ"]
    
    If List.contains(greek_uppercase, symbol):
        Return true
    Otherwise if List.contains(greek_lowercase, symbol):
        Return true
    Otherwise if List.contains(greek_variants, symbol):
        Return true
    Otherwise:
        Return false

Process called "convert_case_greek" that takes symbol as String, target_case as String returns String:
    Note: Convert Greek letter between uppercase and lowercase
    Let conversion_map_upper be {
        "α": "Α", "β": "Β", "γ": "Γ", "δ": "Δ", "ε": "Ε", "ζ": "Ζ", "η": "Η", "θ": "Θ",
        "ι": "Ι", "κ": "Κ", "λ": "Λ", "μ": "Μ", "ν": "Ν", "ξ": "Ξ", "ο": "Ο", "π": "Π",
        "ρ": "Ρ", "σ": "Σ", "τ": "Τ", "υ": "Υ", "φ": "Φ", "χ": "Χ", "ψ": "Ψ", "ω": "Ω"
    }
    
    Let conversion_map_lower be {
        "Α": "α", "Β": "β", "Γ": "γ", "Δ": "δ", "Ε": "ε", "Ζ": "ζ", "Η": "η", "Θ": "θ",
        "Ι": "ι", "Κ": "κ", "Λ": "λ", "Μ": "μ", "Ν": "ν", "Ξ": "ξ", "Ο": "ο", "Π": "π",
        "Ρ": "ρ", "Σ": "σ", "Τ": "τ", "Υ": "υ", "Φ": "φ", "Χ": "χ", "Ψ": "ψ", "Ω": "ω"
    }
    
    If target_case is equal to "uppercase":
        Let uppercase_result be Dictionary.get(conversion_map_upper, symbol, symbol)
        Return uppercase_result
    Otherwise if target_case is equal to "lowercase":
        Let lowercase_result be Dictionary.get(conversion_map_lower, symbol, symbol)
        Return lowercase_result
    Otherwise:
        Return symbol

Process called "export_greek_alphabet_data" that takes export_format as String returns String:
    Note: Export Greek alphabet data in specified format
    Let alphabet_data be get_complete_greek_alphabet()
    
    If export_format is equal to "json":
        Note: Export as JSON format
        Let json_output be "[\n"
        For each (index, letter) in List.enumerate(alphabet_data):
            Let letter_json be "  {\n"
            Set letter_json to letter_json plus "    \"letter_name\": \"" plus Dictionary.get(letter, "letter_name", "") plus "\",\n"
            Set letter_json to letter_json plus "    \"uppercase_symbol\": \"" plus Dictionary.get(letter, "uppercase_symbol", "") plus "\",\n"
            Set letter_json to letter_json plus "    \"lowercase_symbol\": \"" plus Dictionary.get(letter, "lowercase_symbol", "") plus "\",\n"
            Set letter_json to letter_json plus "    \"unicode_uppercase\": \"" plus Dictionary.get(letter, "unicode_uppercase", "") plus "\",\n"
            Set letter_json to letter_json plus "    \"unicode_lowercase\": \"" plus Dictionary.get(letter, "unicode_lowercase", "") plus "\",\n"
            Set letter_json to letter_json plus "    \"pronunciation\": \"" plus Dictionary.get(letter, "pronunciation", "") plus "\",\n"
            Set letter_json to letter_json plus "    \"transliteration\": \"" plus Dictionary.get(letter, "transliteration", "") plus "\"\n"
            If index is less than List.length(alphabet_data) minus 1:
                Set letter_json to letter_json plus "  },\n"
            Otherwise:
                Set letter_json to letter_json plus "  }\n"
            Set json_output to json_output plus letter_json
        Set json_output to json_output plus "]"
        Return json_output
        
    Otherwise if export_format is equal to "csv":
        Note: Export as CSV format
        Let csv_output be "letter_name,uppercase_symbol,lowercase_symbol,unicode_uppercase,unicode_lowercase,pronunciation,transliteration\n"
        For each letter in alphabet_data:
            Let csv_row be Dictionary.get(letter, "letter_name", "") plus ","
            Set csv_row to csv_row plus Dictionary.get(letter, "uppercase_symbol", "") plus ","
            Set csv_row to csv_row plus Dictionary.get(letter, "lowercase_symbol", "") plus ","
            Set csv_row to csv_row plus Dictionary.get(letter, "unicode_uppercase", "") plus ","
            Set csv_row to csv_row plus Dictionary.get(letter, "unicode_lowercase", "") plus ","
            Set csv_row to csv_row plus Dictionary.get(letter, "pronunciation", "") plus ","
            Set csv_row to csv_row plus Dictionary.get(letter, "transliteration", "") plus "\n"
            Set csv_output to csv_output plus csv_row
        Return csv_output
        
    Otherwise if export_format is equal to "xml":
        Note: Export as XML format
        Let xml_output be "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<greek_alphabet>\n"
        For each letter in alphabet_data:
            Let xml_entry be "  <letter>\n"
            Set xml_entry to xml_entry plus "    <name>" plus Dictionary.get(letter, "letter_name", "") plus "</name>\n"
            Set xml_entry to xml_entry plus "    <uppercase>" plus Dictionary.get(letter, "uppercase_symbol", "") plus "</uppercase>\n"
            Set xml_entry to xml_entry plus "    <lowercase>" plus Dictionary.get(letter, "lowercase_symbol", "") plus "</lowercase>\n"
            Set xml_entry to xml_entry plus "    <unicode_upper>" plus Dictionary.get(letter, "unicode_uppercase", "") plus "</unicode_upper>\n"
            Set xml_entry to xml_entry plus "    <unicode_lower>" plus Dictionary.get(letter, "unicode_lowercase", "") plus "</unicode_lower>\n"
            Set xml_entry to xml_entry plus "    <pronunciation>" plus Dictionary.get(letter, "pronunciation", "") plus "</pronunciation>\n"
            Set xml_entry to xml_entry plus "    <transliteration>" plus Dictionary.get(letter, "transliteration", "") plus "</transliteration>\n"
            Set xml_entry to xml_entry plus "  </letter>\n"
            Set xml_output to xml_output plus xml_entry
        Set xml_output to xml_output plus "</greek_alphabet>\n"
        Return xml_output
        
    Otherwise if export_format is equal to "latex":
        Note: Export as LaTeX table format
        Let latex_output be "\\begin{longtable}{|l|c|c|l|l|}\n"
        Set latex_output to latex_output plus "\\hline\n"
        Set latex_output to latex_output plus "\\textbf{Name} & \\textbf{Uppercase} & \\textbf{Lowercase} & \\textbf{Pronunciation} & \\textbf{Transliteration} \\\\\n"
        Set latex_output to latex_output plus "\\hline\n"
        For each letter in alphabet_data:
            Let latex_row be Dictionary.get(letter, "letter_name", "") plus " & "
            Set latex_row to latex_row plus "$" plus Dictionary.get(letter, "uppercase_symbol", "") plus "$ & "
            Set latex_row to latex_row plus "$" plus Dictionary.get(letter, "lowercase_symbol", "") plus "$ & "
            Set latex_row to latex_row plus Dictionary.get(letter, "pronunciation", "") plus " & "
            Set latex_row to latex_row plus Dictionary.get(letter, "transliteration", "") plus " \\\\\n"
            Set latex_output to latex_output plus latex_row
        Set latex_output to latex_output plus "\\hline\n\\end{longtable}\n"
        Return latex_output
        
    Otherwise:
        Return "Unsupported export format: " plus export_format plus ". Supported: json, csv, xml, latex"

Process called "benchmark_greek_operations" that takes operation_types as List[String] returns Dictionary[String, Float]:
    Note: Benchmark performance of Greek letter operations
    Let benchmark_results be {}
    
    For each operation_type in operation_types:
        If operation_type is equal to "alphabet_retrieval":
            Note: Benchmark complete alphabet retrieval
            Let start_time be DateTime.get_current_timestamp()
            Let iterations be 1000
            For i from 0 to iterations:
                Let alphabet be get_complete_greek_alphabet()
            Let end_time be DateTime.get_current_timestamp()
            Let duration be end_time minus start_time
            Let avg_time be duration / Float.from_integer(iterations)
            Set benchmark_results to Dictionary.set(benchmark_results, "alphabet_retrieval_ms", avg_time)
            
        Otherwise if operation_type is equal to "letter_lookup":
            Note: Benchmark individual letter lookup
            Let start_time be DateTime.get_current_timestamp()
            Let iterations be 10000
            For i from 0 to iterations:
                Let letter be alpha_symbols()
                Let letter2 be pi_symbols()
                Let letter3 be omega_symbols()
            Let end_time be DateTime.get_current_timestamp()
            Let duration be end_time minus start_time
            Let avg_time be duration / Float.from_integer(iterations)
            Set benchmark_results to Dictionary.set(benchmark_results, "letter_lookup_ms", avg_time)
            
        Otherwise if operation_type is equal to "variant_generation":
            Note: Benchmark variant generation
            Let start_time be DateTime.get_current_timestamp()
            Let iterations be 1000
            For i from 0 to iterations:
                Let bold_letters be get_bold_greek_letters()
                Let italic_letters be get_italic_greek_letters()
            Let end_time be DateTime.get_current_timestamp()
            Let duration be end_time minus start_time
            Let avg_time be duration / Float.from_integer(iterations)
            Set benchmark_results to Dictionary.set(benchmark_results, "variant_generation_ms", avg_time)
            
        Otherwise if operation_type is equal to "symbol_validation":
            Note: Benchmark symbol validation
            Let test_symbols be ["α", "β", "γ", "Α", "Β", "Γ", "a", "b", "c"]
            Let start_time be DateTime.get_current_timestamp()
            Let iterations be 5000
            For i from 0 to iterations:
                For symbol in test_symbols:
                    Let is_valid be validate_greek_symbol(symbol)
            Let end_time be DateTime.get_current_timestamp()
            Let duration be end_time minus start_time
            Let avg_time be duration / Float.from_integer(iterations)
            Set benchmark_results to Dictionary.set(benchmark_results, "symbol_validation_ms", avg_time)
            
        Otherwise if operation_type is equal to "encoding_conversion":
            Note: Benchmark encoding conversion
            Let test_text be "αβγδεζηθικλμνξοπρστυφχψω"
            Let start_time be DateTime.get_current_timestamp()
            Let iterations be 1000
            For i from 0 to iterations:
                Let converted be convert_greek_encoding(test_text, "utf-8", "ascii")
            Let end_time be DateTime.get_current_timestamp()
            Let duration be end_time minus start_time
            Let avg_time be duration / Float.from_integer(iterations)
            Set benchmark_results to Dictionary.set(benchmark_results, "encoding_conversion_ms", avg_time)
            
        Otherwise if operation_type is equal to "latex_rendering":
            Note: Benchmark LaTeX rendering
            Let test_letter be alpha_symbols()
            Let start_time be DateTime.get_current_timestamp()
            Let iterations be 2000
            For i from 0 to iterations:
                Let latex_bold be render_greek_letter_latex(test_letter, "bold")
                Let latex_italic be render_greek_letter_latex(test_letter, "italic")
            Let end_time be DateTime.get_current_timestamp()
            Let duration be end_time minus start_time
            Let avg_time be duration / Float.from_integer(iterations)
            Set benchmark_results to Dictionary.set(benchmark_results, "latex_rendering_ms", avg_time)
            
        Otherwise:
            Set benchmark_results to Dictionary.set(benchmark_results, operation_type plus "_error", -1.0)
    
    Return benchmark_results