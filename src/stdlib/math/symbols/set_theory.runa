Note:
math/symbols/set_theory.runa
Set Theory Symbols and Operations

This module provides comprehensive set theory symbol handling including:
- Set notation symbols (‚àà, ‚àâ, ‚àã, ‚àå, ‚äÇ, ‚äÉ, ‚äÜ, ‚äá, etc.)
- Set operations (‚à™, ‚à©, ‚àñ, ‚ñ≥, ‚äï, √ó, etc.)
- Cardinality and infinity symbols (‚Ñµ, ‚Ñ∂, ‚àû, etc.)
- Power set and function space notation
- Quantifier symbols (‚àÄ, ‚àÉ, ‚àÑ, ‚àÉ!, etc.)
- Set builder notation components
- Relation and function symbols
- Order theory symbols (‚äë, ‚äí, ‚äì, ‚äî, etc.)
- Category theory symbols (‚áÑ, ‚ä£, ‚ä¢, etc.)
- Topology and analysis symbols
- Boolean algebra symbols
- Lattice theory notation
- Model theory symbols
- Set-theoretic axiom representations
- Forcing and independence notation
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "sys/time/core/instant" as TimeInstant

Note: =====================================================================
Note: SET THEORY SYMBOL DATA STRUCTURES
Note: =====================================================================

Type called "SetSymbol":
    symbol_character as String
    symbol_name as String
    unicode_codepoint as String
    mathematical_meaning as String
    usage_context as String
    negation_symbol as String
    related_symbols as List[String]

Type called "SetOperation":
    operation_symbol as String
    operation_name as String
    operand_count as Integer
    operation_type as String
    properties as List[String]
    dual_operation as String

Type called "QuantifierSymbol":
    quantifier_symbol as String
    quantifier_name as String
    scope_type as String
    binding_power as Integer
    logical_meaning as String

Type called "RelationSymbol":
    relation_symbol as String
    relation_name as String
    relation_type as String
    reflexivity as String
    symmetry as String
    transitivity as String

Note: =====================================================================
Note: BASIC SET MEMBERSHIP OPERATIONS
Note: =====================================================================

Process called "get_membership_symbols" that returns List[SetSymbol]:
    Note: Get set membership symbols (‚àà, ‚àâ, ‚àã, ‚àå)
    Return [
        element_of_symbol(),
        not_element_of_symbol(),
        contains_symbol(),
        not_contains_symbol()
    ]

Process called "element_of_symbol" that returns SetSymbol:
    Note: Get element of symbol (‚àà)
    Return {
        "symbol_character": "‚àà",
        "symbol_name": "element of",
        "unicode_codepoint": "U+2208",
        "mathematical_meaning": "indicates that an element belongs to a set",
        "usage_context": "x ‚àà A means x is an element of set A",
        "negation_symbol": "‚àâ",
        "related_symbols": ["‚àâ", "‚àã", "‚àå", "‚äÇ", "‚äÜ"]
    }

Process called "not_element_of_symbol" that returns SetSymbol:
    Note: Get not element of symbol (‚àâ)
    Return {
        "symbol_character": "‚àâ",
        "symbol_name": "not element of",
        "unicode_codepoint": "U+2209",
        "mathematical_meaning": "indicates that an element does not belong to a set",
        "usage_context": "x ‚àâ A means x is not an element of set A",
        "negation_symbol": "‚àà",
        "related_symbols": ["‚àà", "‚àã", "‚àå", "‚äÑ", "‚äà"]
    }

Process called "contains_symbol" that returns SetSymbol:
    Note: Get contains symbol (‚àã)
    Return {
        "symbol_character": "‚àã",
        "symbol_name": "contains",
        "unicode_codepoint": "U+220B",
        "mathematical_meaning": "indicates that a set contains an element",
        "usage_context": "A ‚àã x means set A contains element x",
        "negation_symbol": "‚àå",
        "related_symbols": ["‚àà", "‚àâ", "‚àå", "‚äÉ", "‚äá"]
    }

Process called "not_contains_symbol" that returns SetSymbol:
    Note: Get does not contain symbol (‚àå)
    Return {
        "symbol_character": "‚àå",
        "symbol_name": "does not contain",
        "unicode_codepoint": "U+220C",
        "mathematical_meaning": "indicates that a set does not contain an element",
        "usage_context": "A ‚àå x means set A does not contain element x",
        "negation_symbol": "‚àã",
        "related_symbols": ["‚àà", "‚àâ", "‚àã", "‚äÖ", "‚äâ"]
    }

Note: =====================================================================
Note: SET INCLUSION OPERATIONS
Note: =====================================================================

Process called "get_inclusion_symbols" that returns List[SetSymbol]:
    Note: Get set inclusion symbols (‚äÇ, ‚äÉ, ‚äÜ, ‚äá, ‚ää, ‚äã)
    Return [
        subset_symbol(),
        superset_symbol(),
        subset_or_equal_symbol(),
        superset_or_equal_symbol(),
        proper_subset_symbol(),
        proper_superset_symbol()
    ]

Process called "subset_symbol" that returns SetSymbol:
    Note: Get subset symbol (‚äÇ)
    Return {
        "symbol_character": "‚äÇ",
        "symbol_name": "subset",
        "unicode_codepoint": "U+2282",
        "mathematical_meaning": "indicates proper subset relation between sets",
        "usage_context": "A ‚äÇ B means A is a proper subset of B (A is contained in B and A ‚â† B)",
        "negation_symbol": "‚äÑ",
        "related_symbols": ["‚äÜ", "‚äÉ", "‚äá", "‚ää", "‚àà"]
    }

Process called "superset_symbol" that returns SetSymbol:
    Note: Get superset symbol (‚äÉ)
    Return {
        "symbol_character": "‚äÉ",
        "symbol_name": "superset",
        "unicode_codepoint": "U+2283",
        "mathematical_meaning": "indicates proper superset relation between sets",
        "usage_context": "A ‚äÉ B means A is a proper superset of B (A contains B and A ‚â† B)",
        "negation_symbol": "‚äÖ",
        "related_symbols": ["‚äá", "‚äÇ", "‚äÜ", "‚äã", "‚àã"]
    }

Process called "subset_or_equal_symbol" that returns SetSymbol:
    Note: Get subset or equal symbol (‚äÜ)
    Return {
        "symbol_character": "‚äÜ",
        "symbol_name": "subset or equal",
        "unicode_codepoint": "U+2286",
        "mathematical_meaning": "indicates subset or equality relation between sets",
        "usage_context": "A ‚äÜ B means A is a subset of B or A is equal to B",
        "negation_symbol": "‚äà",
        "related_symbols": ["‚äÇ", "‚äá", "‚äÉ", "‚ää", "‚àà"]
    }

Process called "superset_or_equal_symbol" that returns SetSymbol:
    Note: Get superset or equal symbol (‚äá)
    Return {
        "symbol_character": "‚äá",
        "symbol_name": "superset or equal",
        "unicode_codepoint": "U+2287",
        "mathematical_meaning": "indicates superset or equality relation between sets",
        "usage_context": "A ‚äá B means A is a superset of B or A is equal to B",
        "negation_symbol": "‚äâ",
        "related_symbols": ["‚äÉ", "‚äÜ", "‚äÇ", "‚äã", "‚àã"]
    }

Process called "proper_subset_symbol" that returns SetSymbol:
    Note: Get proper subset symbol (‚ää)
    Return {
        "symbol_character": "‚ää",
        "symbol_name": "proper subset",
        "unicode_codepoint": "U+228A",
        "mathematical_meaning": "indicates strict proper subset relation",
        "usage_context": "A ‚ää B means A is a proper subset of B with emphasis on strictness",
        "negation_symbol": "‚äå",
        "related_symbols": ["‚äÇ", "‚äÜ", "‚äã", "‚äÉ", "‚àà"]
    }

Process called "proper_superset_symbol" that returns SetSymbol:
    Note: Get proper superset symbol (‚äã)
    Return {
        "symbol_character": "‚äã",
        "symbol_name": "proper superset",
        "unicode_codepoint": "U+228B",
        "mathematical_meaning": "indicates strict proper superset relation",
        "usage_context": "A ‚äã B means A is a proper superset of B with emphasis on strictness",
        "negation_symbol": "‚äç",
        "related_symbols": ["‚äÉ", "‚äá", "‚ää", "‚äÇ", "‚àã"]
    }

Note: =====================================================================
Note: SET OPERATIONS
Note: =====================================================================

Process called "get_set_operation_symbols" that returns List[SetSymbol]:
    Note: Get set operation symbols (‚à™, ‚à©, ‚àñ, ‚ñ≥, ‚äï, √ó)
    Return [
        union_symbol(),
        intersection_symbol(),
        difference_symbol(),
        symmetric_difference_symbol(),
        cartesian_product_symbol()
    ]

Process called "union_symbol" that returns SetSymbol:
    Note: Get union symbol (‚à™)
    Return {
        "symbol_character": "‚à™",
        "symbol_name": "union",
        "unicode_codepoint": "U+222A",
        "mathematical_meaning": "set operation that combines all elements from multiple sets",
        "usage_context": "A ‚à™ B contains all elements that are in A or B or both",
        "negation_symbol": "",
        "related_symbols": ["‚à©", "‚àñ", "‚ñ≥", "‚äï", "‚ãÉ"]
    }

Process called "intersection_symbol" that returns SetSymbol:
    Note: Get intersection symbol (‚à©)
    Return {
        "symbol_character": "‚à©",
        "symbol_name": "intersection",
        "unicode_codepoint": "U+2229",
        "mathematical_meaning": "set operation that finds common elements between sets",
        "usage_context": "A ‚à© B contains only elements that are in both A and B",
        "negation_symbol": "",
        "related_symbols": ["‚à™", "‚àñ", "‚ñ≥", "‚äï", "‚ãÇ"]
    }

Process called "difference_symbol" that returns SetSymbol:
    Note: Get set difference symbol (‚àñ)
    Return {
        "symbol_character": "‚àñ",
        "symbol_name": "set difference",
        "unicode_codepoint": "U+2216",
        "mathematical_meaning": "set operation that removes elements of one set from another",
        "usage_context": "A ‚àñ B contains elements in A but not in B",
        "negation_symbol": "",
        "related_symbols": ["‚à™", "‚à©", "‚ñ≥", "‚àà", "‚àâ"]
    }

Process called "symmetric_difference_symbol" that returns SetSymbol:
    Note: Get symmetric difference symbol (‚ñ≥ or ‚äï)
    Return {
        "symbol_character": "‚ñ≥",
        "symbol_name": "symmetric difference",
        "unicode_codepoint": "U+25B3",
        "mathematical_meaning": "set operation that finds elements in either set but not in both",
        "usage_context": "A ‚ñ≥ B is equal to (A ‚àñ B) ‚à™ (B ‚àñ A), elements in A or B but not both",
        "negation_symbol": "",
        "related_symbols": ["‚à™", "‚à©", "‚àñ", "‚äï", "√ó"]
    }

Process called "cartesian_product_symbol" that returns SetSymbol:
    Note: Get Cartesian product symbol (√ó)
    Return {
        "symbol_character": "√ó",
        "symbol_name": "cartesian product",
        "unicode_codepoint": "U+00D7",
        "mathematical_meaning": "set operation that creates ordered pairs from two sets",
        "usage_context": "A √ó B is equal to {(a,b) | a ‚àà A, b ‚àà B}, set of all ordered pairs",
        "negation_symbol": "",
        "related_symbols": ["‚äï", "‚à™", "‚à©", "‚àà", "‚Üí"]
    }

Note: =====================================================================
Note: QUANTIFIER OPERATIONS
Note: =====================================================================

Process called "get_quantifier_symbols" that returns List[QuantifierSymbol]:
    Note: Get quantifier symbols (‚àÄ, ‚àÉ, ‚àÑ, ‚àÉ!)
    Return [
        universal_quantifier_symbol(),
        existential_quantifier_symbol(),
        not_exists_symbol(),
        unique_existence_symbol()
    ]

Process called "universal_quantifier_symbol" that returns QuantifierSymbol:
    Note: Get universal quantifier symbol (‚àÄ)
    Return {
        "quantifier_symbol": "‚àÄ",
        "quantifier_name": "universal quantifier",
        "scope_type": "universal",
        "binding_power": 10,
        "logical_meaning": "for all elements in the domain, the predicate holds"
    }

Process called "existential_quantifier_symbol" that returns QuantifierSymbol:
    Note: Get existential quantifier symbol (‚àÉ)
    Return {
        "quantifier_symbol": "‚àÉ",
        "quantifier_name": "existential quantifier",
        "scope_type": "existential",
        "binding_power": 10,
        "logical_meaning": "there exists at least one element in the domain for which the predicate holds"
    }

Process called "not_exists_symbol" that returns QuantifierSymbol:
    Note: Get does not exist symbol (‚àÑ)
    Return {
        "quantifier_symbol": "‚àÑ",
        "quantifier_name": "does not exist",
        "scope_type": "negative_existential",
        "binding_power": 10,
        "logical_meaning": "there does not exist any element in the domain for which the predicate holds"
    }

Process called "unique_existence_symbol" that returns QuantifierSymbol:
    Note: Get unique existence symbol (‚àÉ!)
    Return {
        "quantifier_symbol": "‚àÉ!",
        "quantifier_name": "unique existence",
        "scope_type": "unique_existential",
        "binding_power": 10,
        "logical_meaning": "there exists exactly one element in the domain for which the predicate holds"
    }

Note: =====================================================================
Note: CARDINALITY AND INFINITY OPERATIONS
Note: =====================================================================

Process called "get_cardinality_symbols" that returns List[SetSymbol]:
    Note: Get cardinality symbols (|A|, #A, card(A))
    Return [
        {
            "symbol_character": "|",
            "symbol_name": "cardinality bars",
            "unicode_codepoint": "U+007C",
            "mathematical_meaning": "indicates the number of elements in a set",
            "usage_context": "|A| represents the cardinality of set A",
            "negation_symbol": "",
            "related_symbols": ["#", "card", "‚Ñµ", "‚Ñ∂"]
        },
        {
            "symbol_character": "#",
            "symbol_name": "cardinality hash",
            "unicode_codepoint": "U+0023",
            "mathematical_meaning": "alternative notation for set cardinality",
            "usage_context": "#A represents the number of elements in set A",
            "negation_symbol": "",
            "related_symbols": ["|", "card", "‚Ñµ", "‚Ñ∂"]
        }
    ]

Process called "aleph_symbols" that returns List[SetSymbol]:
    Note: Get aleph symbols for infinite cardinalities (‚Ñµ‚ÇÄ, ‚Ñµ‚ÇÅ, ‚Ñµ‚ÇÇ, ...)
    Return [
        {
            "symbol_character": "‚Ñµ‚ÇÄ",
            "symbol_name": "aleph null",
            "unicode_codepoint": "U+2135 U+2080",
            "mathematical_meaning": "cardinality of countably infinite sets",
            "usage_context": "‚Ñµ‚ÇÄ is equal to |‚Ñï| is equal to |‚Ñ§| is equal to |‚Ñö|, smallest infinite cardinal",
            "negation_symbol": "",
            "related_symbols": ["‚Ñµ‚ÇÅ", "‚Ñµ‚ÇÇ", "‚Ñ∂‚ÇÄ", "‚àû", "œâ"]
        },
        {
            "symbol_character": "‚Ñµ‚ÇÅ",
            "symbol_name": "aleph one",
            "unicode_codepoint": "U+2135 U+2081",
            "mathematical_meaning": "next cardinal after aleph null",
            "usage_context": "‚Ñµ‚ÇÅ is the smallest uncountable cardinal under CH",
            "negation_symbol": "",
            "related_symbols": ["‚Ñµ‚ÇÄ", "‚Ñµ‚ÇÇ", "‚Ñ∂‚ÇÅ", "2^{‚Ñµ‚ÇÄ}"]
        },
        {
            "symbol_character": "‚Ñµ‚ÇÇ",
            "symbol_name": "aleph two",
            "unicode_codepoint": "U+2135 U+2082",
            "mathematical_meaning": "third infinite cardinal number",
            "usage_context": "‚Ñµ‚ÇÇ follows ‚Ñµ‚ÇÅ in the cardinal hierarchy",
            "negation_symbol": "",
            "related_symbols": ["‚Ñµ‚ÇÄ", "‚Ñµ‚ÇÅ", "‚Ñ∂‚ÇÇ", "2^{‚Ñµ‚ÇÅ}"]
        }
    ]

Process called "beth_symbols" that returns List[SetSymbol]:
    Note: Get beth symbols (‚Ñ∂‚ÇÄ, ‚Ñ∂‚ÇÅ, ‚Ñ∂‚ÇÇ, ...)
    Return [
        {
            "symbol_character": "‚Ñ∂‚ÇÄ",
            "symbol_name": "beth null",
            "unicode_codepoint": "U+2136 U+2080",
            "mathematical_meaning": "cardinality of countably infinite sets, is equal to aleph null",
            "usage_context": "‚Ñ∂‚ÇÄ is equal to ‚Ñµ‚ÇÄ is equal to |‚Ñï|",
            "negation_symbol": "",
            "related_symbols": ["‚Ñ∂‚ÇÅ", "‚Ñµ‚ÇÄ", "2^{‚Ñµ‚ÇÄ}", "‚àû"]
        },
        {
            "symbol_character": "‚Ñ∂‚ÇÅ",
            "symbol_name": "beth one",
            "unicode_codepoint": "U+2136 U+2081",
            "mathematical_meaning": "cardinality of the continuum, 2^{‚Ñµ‚ÇÄ}",
            "usage_context": "‚Ñ∂‚ÇÅ is equal to 2^{‚Ñµ‚ÇÄ} is equal to |‚Ñù| is equal to |‚Ñò(‚Ñï)|",
            "negation_symbol": "",
            "related_symbols": ["‚Ñ∂‚ÇÄ", "‚Ñ∂‚ÇÇ", "‚Ñµ‚ÇÅ", "2^{‚Ñµ‚ÇÅ}"]
        }
    ]

Process called "infinity_symbols" that returns List[SetSymbol]:
    Note: Get infinity symbols (‚àû, œâ, Œ©)
    Return [
        {
            "symbol_character": "‚àû",
            "symbol_name": "infinity",
            "unicode_codepoint": "U+221E",
            "mathematical_meaning": "represents unbounded quantity or infinite cardinality",
            "usage_context": "used in limits, cardinalities, and extended real numbers",
            "negation_symbol": "",
            "related_symbols": ["‚Ñµ", "‚Ñ∂", "œâ", "œâ‚ÇÅ", "+‚àû", "-‚àû"]
        },
        {
            "symbol_character": "œâ",
            "symbol_name": "omega",
            "unicode_codepoint": "U+03C9",
            "mathematical_meaning": "first infinite ordinal number, order type of natural numbers",
            "usage_context": "œâ represents the ordinal of ‚Ñï, smallest infinite ordinal",
            "negation_symbol": "",
            "related_symbols": ["œâ‚ÇÅ", "‚Ñµ‚ÇÄ", "‚àû", "œâ^2", "œâ^œâ"]
        },
        {
            "symbol_character": "Œ©",
            "symbol_name": "big omega",
            "unicode_codepoint": "U+03A9",
            "mathematical_meaning": "class of all ordinals, not a set",
            "usage_context": "Œ© represents the class of all ordinals in set theory",
            "negation_symbol": "",
            "related_symbols": ["œâ", "œâ‚ÇÅ", "On", "V"]
        }
    ]

Note: =====================================================================
Note: FUNCTION AND RELATION OPERATIONS
Note: =====================================================================

Process called "get_function_symbols" that returns List[SetSymbol]:
    Note: Get function symbols (‚Üí, ‚Ü¶, ‚á∏, f:A‚ÜíB)
    Return [
        maps_to_symbol(),
        function_arrow_symbol(),
        partial_function_symbol(),
        bijection_symbol()
    ]

Process called "maps_to_symbol" that returns SetSymbol:
    Note: Get maps to symbol (‚Ü¶)
    Return {
        "symbol_character": "‚Ü¶",
        "symbol_name": "maps to",
        "unicode_codepoint": "U+21A6",
        "mathematical_meaning": "indicates specific element mapping in functions",
        "usage_context": "x ‚Ü¶ f(x) shows how element x maps to f(x)",
        "negation_symbol": "",
        "related_symbols": ["‚Üí", "‚á∏", "‚Üî", "‚àà", "f"]
    }

Process called "function_arrow_symbol" that returns SetSymbol:
    Note: Get function arrow symbol (‚Üí)
    Return {
        "symbol_character": "‚Üí",
        "symbol_name": "function arrow",
        "unicode_codepoint": "U+2192",
        "mathematical_meaning": "indicates function mapping between sets or domains",
        "usage_context": "f: A ‚Üí B means function f maps from domain A to codomain B",
        "negation_symbol": "",
        "related_symbols": ["‚Ü¶", "‚á∏", "‚Üî", "‚àà", "√ó"]
    }

Process called "partial_function_symbol" that returns SetSymbol:
    Note: Get partial function symbol (‚á∏)
    Return {
        "symbol_character": "‚á∏",
        "symbol_name": "partial function",
        "unicode_codepoint": "U+21F8",
        "mathematical_meaning": "indicates partial function mapping (not defined for all inputs)",
        "usage_context": "f: A ‚á∏ B means f is defined on a subset of A",
        "negation_symbol": "",
        "related_symbols": ["‚Üí", "‚Ü¶", "‚Üî", "dom", "ran"]
    }

Process called "bijection_symbol" that returns SetSymbol:
    Note: Get bijection symbol (‚Üî)
    Return {
        "symbol_character": "‚Üî",
        "symbol_name": "bijection",
        "unicode_codepoint": "U+2194",
        "mathematical_meaning": "indicates one-to-one correspondence between sets",
        "usage_context": "A ‚Üî B means there exists a bijection between A and B",
        "negation_symbol": "",
        "related_symbols": ["‚Üí", "‚Ü¶", "‚á∏", "‚âÖ", "|¬∑|"]
    }

Note: =====================================================================
Note: POWER SET AND FAMILY OPERATIONS
Note: =====================================================================

Process called "power_set_symbol" that returns SetSymbol:
    Note: Get power set symbol (‚Ñò or P)
    Return {
        "symbol_character": "‚Ñò",
        "symbol_name": "power set",
        "unicode_codepoint": "U+2118",
        "mathematical_meaning": "set of all subsets of a given set",
        "usage_context": "‚Ñò(A) is equal to {B | B ‚äÜ A}, all subsets of A",
        "negation_symbol": "",
        "related_symbols": ["‚äÜ", "‚äÇ", "‚ãÉ", "‚ãÇ", "2^A"]
    }

Process called "set_of_all_subsets_notation" that returns String:
    Note: Get notation for set of all subsets
    Return "{B | B ‚äÜ A}"

Process called "indexed_family_notation" that returns String:
    Note: Get notation for indexed families {A·µ¢}·µ¢‚ààI
    Return "{A·µ¢}·µ¢‚ààI"

Process called "big_union_symbol" that returns SetSymbol:
    Note: Get big union symbol (‚ãÉ)
    Return {
        "symbol_character": "‚ãÉ",
        "symbol_name": "big union",
        "unicode_codepoint": "U+22C3",
        "mathematical_meaning": "union of an indexed family or collection of sets",
        "usage_context": "‚ãÉ·µ¢‚ààI A·µ¢ is equal to {x | ‚àÉi ‚àà I, x ‚àà A·µ¢}",
        "negation_symbol": "",
        "related_symbols": ["‚ãÇ", "‚à™", "‚àà", "‚àÉ", "I"]
    }

Process called "big_intersection_symbol" that returns SetSymbol:
    Note: Get big intersection symbol (‚ãÇ)
    Return {
        "symbol_character": "‚ãÇ",
        "symbol_name": "big intersection",
        "unicode_codepoint": "U+22C2",
        "mathematical_meaning": "intersection of an indexed family or collection of sets",
        "usage_context": "‚ãÇ·µ¢‚ààI A·µ¢ is equal to {x | ‚àÄi ‚àà I, x ‚àà A·µ¢}",
        "negation_symbol": "",
        "related_symbols": ["‚ãÉ", "‚à©", "‚àà", "‚àÄ", "I"]
    }

Note: =====================================================================
Note: ORDER THEORY OPERATIONS
Note: =====================================================================

Process called "get_order_symbols" that returns List[SetSymbol]:
    Note: Get order relation symbols (‚â§, ‚â•, <, >, ‚äë, ‚äí, ‚™Ø, ‚™∞)
    Return [
        less_than_or_equal_symbol(),
        greater_than_or_equal_symbol(),
        precedes_symbol(),
        succeeds_symbol(),
        much_less_than_symbol(),
        much_greater_than_symbol()
    ]

Process called "partial_order_symbols" that returns List[SetSymbol]:
    Note: Get partial order symbols (‚äë, ‚äí, ‚âº, ‚âΩ)
    Return [
        square_image_of_symbol(),
        square_original_of_symbol(),
        precedes_or_equal_symbol(),
        succeeds_or_equal_symbol()
    ]

Process called "lattice_symbols" that returns List[SetSymbol]:
    Note: Get lattice operation symbols (‚äì, ‚äî, ‚àß, ‚à®)
    Return [
        meet_symbol(),
        join_symbol(),
        logical_and_symbol(),
        logical_or_symbol()
    ]

Process called "join_symbol" that returns SetSymbol:
    Note: Get join (supremum) symbol (‚äî)
    Return {
        "symbol_character": "‚äî",
        "symbol_name": "join",
        "unicode_codepoint": "U+2294",
        "mathematical_meaning": "supremum operation in lattice theory, least upper bound",
        "usage_context": "a ‚äî b represents the join (supremum) of elements a and b in a lattice",
        "negation_symbol": "",
        "related_symbols": ["‚äì", "‚à®", "‚äÜ", "‚â§", "sup"]
    }

Process called "meet_symbol" that returns SetSymbol:
    Note: Get meet (infimum) symbol (‚äì)
    Return {
        "symbol_character": "‚äì",
        "symbol_name": "meet",
        "unicode_codepoint": "U+2293",
        "mathematical_meaning": "infimum operation in lattice theory, greatest lower bound",
        "usage_context": "a ‚äì b represents the meet (infimum) of elements a and b in a lattice",
        "negation_symbol": "",
        "related_symbols": ["‚äî", "‚àß", "‚äÜ", "‚â§", "inf"]
    }

Process called "less_than_or_equal_symbol" that returns SetSymbol:
    Note: Get less than or equal symbol (‚â§)
    Return {
        "symbol_character": "‚â§",
        "symbol_name": "less than or equal",
        "unicode_codepoint": "U+2264",
        "mathematical_meaning": "partial order relation indicating one element is less than or equal to another",
        "usage_context": "a ‚â§ b means a is less than or equal to b in the given order",
        "negation_symbol": "‚â∞",
        "related_symbols": ["‚â•", "<", ">", "‚äë", "‚âº"]
    }

Process called "greater_than_or_equal_symbol" that returns SetSymbol:
    Note: Get greater than or equal symbol (‚â•)
    Return {
        "symbol_character": "‚â•",
        "symbol_name": "greater than or equal",
        "unicode_codepoint": "U+2265",
        "mathematical_meaning": "partial order relation indicating one element is greater than or equal to another",
        "usage_context": "a ‚â• b means a is greater than or equal to b in the given order",
        "negation_symbol": "‚â±",
        "related_symbols": ["‚â§", "<", ">", "‚äí", "‚âΩ"]
    }

Process called "precedes_symbol" that returns SetSymbol:
    Note: Get precedes symbol (‚â∫)
    Return {
        "symbol_character": "‚â∫",
        "symbol_name": "precedes",
        "unicode_codepoint": "U+227A",
        "mathematical_meaning": "strict order relation indicating one element precedes another",
        "usage_context": "a ‚â∫ b means a strictly precedes b in the given order",
        "negation_symbol": "‚äÄ",
        "related_symbols": ["‚âª", "‚âº", "‚âΩ", "<", "‚äè"]
    }

Process called "succeeds_symbol" that returns SetSymbol:
    Note: Get succeeds symbol (‚âª)
    Return {
        "symbol_character": "‚âª",
        "symbol_name": "succeeds",
        "unicode_codepoint": "U+227B",
        "mathematical_meaning": "strict order relation indicating one element succeeds another",
        "usage_context": "a ‚âª b means a strictly succeeds b in the given order",
        "negation_symbol": "‚äÅ",
        "related_symbols": ["‚â∫", "‚âº", "‚âΩ", ">", "‚äê"]
    }

Process called "much_less_than_symbol" that returns SetSymbol:
    Note: Get much less than symbol (‚â™)
    Return {
        "symbol_character": "‚â™",
        "symbol_name": "much less than",
        "unicode_codepoint": "U+226A",
        "mathematical_meaning": "indicates significantly less than relationship",
        "usage_context": "a ‚â™ b means a is much less than b, often used in analysis",
        "negation_symbol": "‚â´",
        "related_symbols": ["‚â´", "‚â§", "<", "‚â∫", "‚ãò"]
    }

Process called "much_greater_than_symbol" that returns SetSymbol:
    Note: Get much greater than symbol (‚â´)
    Return {
        "symbol_character": "‚â´",
        "symbol_name": "much greater than",
        "unicode_codepoint": "U+226B",
        "mathematical_meaning": "indicates significantly greater than relationship",
        "usage_context": "a ‚â´ b means a is much greater than b, often used in analysis",
        "negation_symbol": "‚â™",
        "related_symbols": ["‚â™", "‚â•", ">", "‚âª", "‚ãô"]
    }

Process called "square_image_of_symbol" that returns SetSymbol:
    Note: Get square image of symbol (‚äë)
    Return {
        "symbol_character": "‚äë",
        "symbol_name": "square image of",
        "unicode_codepoint": "U+2291",
        "mathematical_meaning": "partial order relation, often used in domain theory",
        "usage_context": "a ‚äë b means a is a square image of b, used in computer science and domain theory",
        "negation_symbol": "‚ã¢",
        "related_symbols": ["‚äí", "‚äè", "‚äê", "‚â§", "‚äÜ"]
    }

Process called "square_original_of_symbol" that returns SetSymbol:
    Note: Get square original of symbol (‚äí)
    Return {
        "symbol_character": "‚äí",
        "symbol_name": "square original of",
        "unicode_codepoint": "U+2292",
        "mathematical_meaning": "partial order relation, dual of square image of",
        "usage_context": "a ‚äí b means a is a square original of b, used in domain theory",
        "negation_symbol": "‚ã£",
        "related_symbols": ["‚äë", "‚äè", "‚äê", "‚â•", "‚äá"]
    }

Process called "precedes_or_equal_symbol" that returns SetSymbol:
    Note: Get precedes or equal symbol (‚âº)
    Return {
        "symbol_character": "‚âº",
        "symbol_name": "precedes or equal",
        "unicode_codepoint": "U+227C",
        "mathematical_meaning": "partial order relation allowing equality",
        "usage_context": "a ‚âº b means a precedes b or is equal to b in the given order",
        "negation_symbol": "‚ã†",
        "related_symbols": ["‚âΩ", "‚â∫", "‚âª", "‚â§", "‚äë"]
    }

Process called "succeeds_or_equal_symbol" that returns SetSymbol:
    Note: Get succeeds or equal symbol (‚âΩ)
    Return {
        "symbol_character": "‚âΩ",
        "symbol_name": "succeeds or equal",
        "unicode_codepoint": "U+227D",
        "mathematical_meaning": "partial order relation allowing equality",
        "usage_context": "a ‚âΩ b means a succeeds b or is equal to b in the given order",
        "negation_symbol": "‚ã°",
        "related_symbols": ["‚âº", "‚â∫", "‚âª", "‚â•", "‚äí"]
    }

Process called "logical_and_symbol" that returns SetSymbol:
    Note: Get logical and symbol (‚àß)
    Return {
        "symbol_character": "‚àß",
        "symbol_name": "logical and",
        "unicode_codepoint": "U+2227",
        "mathematical_meaning": "logical conjunction, meet operation in Boolean algebra",
        "usage_context": "P ‚àß Q means P and Q, both propositions must be true",
        "negation_symbol": "",
        "related_symbols": ["‚à®", "‚äì", "‚à©", "¬¨", "‚Üí"]
    }

Process called "logical_or_symbol" that returns SetSymbol:
    Note: Get logical or symbol (‚à®)
    Return {
        "symbol_character": "‚à®",
        "symbol_name": "logical or",
        "unicode_codepoint": "U+2228",
        "mathematical_meaning": "logical disjunction, join operation in Boolean algebra",
        "usage_context": "P ‚à® Q means P or Q, at least one proposition must be true",
        "negation_symbol": "",
        "related_symbols": ["‚àß", "‚äî", "‚à™", "¬¨", "‚Üí"]
    }

Note: =====================================================================
Note: EQUIVALENCE AND CONGRUENCE OPERATIONS
Note: =====================================================================

Process called "get_equivalence_symbols" that returns List[SetSymbol]:
    Note: Get equivalence symbols (‚â°, ‚àº, ‚âà, ‚âÖ, ‚âÉ)
    Return [
        congruence_symbol(),
        equivalence_relation_symbol(),
        approximately_equal_symbol(),
        isomorphism_symbol(),
        asymptotically_equal_symbol()
    ]

Process called "equivalence_relation_symbol" that returns SetSymbol:
    Note: Get equivalence relation symbol (‚àº)
    Return {
        "symbol_character": "‚àº",
        "symbol_name": "equivalence relation",
        "unicode_codepoint": "U+223C",
        "mathematical_meaning": "indicates equivalence relation (reflexive, symmetric, transitive)",
        "usage_context": "a ‚àº b means a is equivalent to b under some equivalence relation",
        "negation_symbol": "‚âÅ",
        "related_symbols": ["‚â°", "‚âà", "‚âÖ", "‚âÉ", "[¬∑]"]
    }

Process called "congruence_symbol" that returns SetSymbol:
    Note: Get congruence symbol (‚â°)
    Return {
        "symbol_character": "‚â°",
        "symbol_name": "congruent to",
        "unicode_codepoint": "U+2261",
        "mathematical_meaning": "indicates congruence relation, often modular arithmetic or geometric congruence",
        "usage_context": "a ‚â° b (mod n) means a and b have same remainder when divided by n",
        "negation_symbol": "‚â¢",
        "related_symbols": ["‚àº", "‚âà", "mod", "‚âÖ", "%"]
    }

Process called "isomorphism_symbol" that returns SetSymbol:
    Note: Get isomorphism symbol (‚âÖ)
    Return {
        "symbol_character": "‚âÖ",
        "symbol_name": "isomorphic to",
        "unicode_codepoint": "U+2245",
        "mathematical_meaning": "indicates isomorphism between mathematical structures",
        "usage_context": "A ‚âÖ B means structure A is isomorphic to structure B",
        "negation_symbol": "‚âÑ",
        "related_symbols": ["‚â°", "‚àº", "‚âà", "‚áî", "Hom"]
    }

Process called "approximately_equal_symbol" that returns SetSymbol:
    Note: Get approximately equal symbol (‚âà)
    Return {
        "symbol_character": "‚âà",
        "symbol_name": "approximately equal",
        "unicode_codepoint": "U+2248",
        "mathematical_meaning": "indicates approximate equality or similarity",
        "usage_context": "a ‚âà b means a is approximately equal to b within some tolerance",
        "negation_symbol": "‚ââ",
        "related_symbols": ["‚âÉ", "‚àº", "‚â°", "‚âÖ", "¬±"]
    }

Process called "asymptotically_equal_symbol" that returns SetSymbol:
    Note: Get asymptotically equal symbol (‚âÉ)
    Return {
        "symbol_character": "‚âÉ",
        "symbol_name": "asymptotically equal",
        "unicode_codepoint": "U+2243",
        "mathematical_meaning": "indicates asymptotic equality or equivalence",
        "usage_context": "f(x) ‚âÉ g(x) means f and g are asymptotically equal as x approaches some limit",
        "negation_symbol": "‚âÑ",
        "related_symbols": ["‚âà", "‚àº", "‚â°", "‚Üí", "lim"]
    }

Note: =====================================================================
Note: SPECIAL SET SYMBOLS
Note: =====================================================================

Process called "empty_set_symbol" that returns SetSymbol:
    Note: Get empty set symbol (‚àÖ or {})
    Return {
        "symbol_character": "‚àÖ",
        "symbol_name": "empty set",
        "unicode_codepoint": "U+2205",
        "mathematical_meaning": "the unique set containing no elements",
        "usage_context": "‚àÖ is equal to {} represents the empty set, subset of all sets",
        "negation_symbol": "",
        "related_symbols": ["{}", "‚äÇ", "‚äÜ", "|¬∑|", "0"]
    }

Process called "universal_set_symbol" that returns SetSymbol:
    Note: Get universal set symbol (U or ùí∞)
    Return {
        "symbol_character": "ùí∞",
        "symbol_name": "universal set",
        "unicode_codepoint": "U+1D4B0",
        "mathematical_meaning": "the set containing all objects under consideration in a given context",
        "usage_context": "ùí∞ represents the universal set, superset of all sets in the domain",
        "negation_symbol": "",
        "related_symbols": ["U", "‚äÉ", "‚äá", "‚àÖ", "V"]
    }

Process called "complement_symbol" that returns SetSymbol:
    Note: Get complement symbol (A·∂ú or AÃÖ or ‚àÅA)
    Return {
        "symbol_character": "‚àÅ",
        "symbol_name": "complement",
        "unicode_codepoint": "U+2201",
        "mathematical_meaning": "the set of all elements not in the given set",
        "usage_context": "‚àÅA or A·∂ú represents complement of set A relative to universal set",
        "negation_symbol": "",
        "related_symbols": ["A·∂ú", "AÃÖ", "‚àñ", "ùí∞", "‚àÖ"]
    }

Process called "natural_numbers_symbol" that returns SetSymbol:
    Note: Get natural numbers symbol (‚Ñï)
    Return {
        "symbol_character": "‚Ñï",
        "symbol_name": "natural numbers",
        "unicode_codepoint": "U+2115",
        "mathematical_meaning": "the set of positive integers {1, 2, 3, ...} or {0, 1, 2, 3, ...}",
        "usage_context": "n ‚àà ‚Ñï means n is a natural number, used for counting",
        "negation_symbol": "",
        "related_symbols": ["‚Ñ§", "‚Ñö", "‚Ñù", "‚ÑÇ", "‚Ñï‚ÇÄ"]
    }

Process called "integers_symbol" that returns SetSymbol:
    Note: Get integers symbol (‚Ñ§)
    Return {
        "symbol_character": "‚Ñ§",
        "symbol_name": "integers",
        "unicode_codepoint": "U+2124",
        "mathematical_meaning": "the set of all integers {..., -2, -1, 0, 1, 2, ...}",
        "usage_context": "n ‚àà ‚Ñ§ means n is an integer, includes negative numbers and zero",
        "negation_symbol": "",
        "related_symbols": ["‚Ñï", "‚Ñö", "‚Ñù", "‚ÑÇ", "‚Ñ§‚Å∫"]
    }

Process called "rationals_symbol" that returns SetSymbol:
    Note: Get rationals symbol (‚Ñö)
    Return {
        "symbol_character": "‚Ñö",
        "symbol_name": "rational numbers",
        "unicode_codepoint": "U+211A",
        "mathematical_meaning": "the set of all rational numbers {p/q | p,q ‚àà ‚Ñ§, q ‚â† 0}",
        "usage_context": "x ‚àà ‚Ñö means x is a rational number, can be expressed as fraction",
        "negation_symbol": "",
        "related_symbols": ["‚Ñï", "‚Ñ§", "‚Ñù", "‚ÑÇ", "p/q"]
    }

Process called "reals_symbol" that returns SetSymbol:
    Note: Get reals symbol (‚Ñù)
    Return {
        "symbol_character": "‚Ñù",
        "symbol_name": "real numbers",
        "unicode_codepoint": "U+211D",
        "mathematical_meaning": "the set of all real numbers, including rationals and irrationals",
        "usage_context": "x ‚àà ‚Ñù means x is a real number, can be represented on number line",
        "negation_symbol": "",
        "related_symbols": ["‚Ñï", "‚Ñ§", "‚Ñö", "‚ÑÇ", "‚Ñù‚Å∫"]
    }

Process called "complex_numbers_symbol" that returns SetSymbol:
    Note: Get complex numbers symbol (‚ÑÇ)
    Return {
        "symbol_character": "‚ÑÇ",
        "symbol_name": "complex numbers",
        "unicode_codepoint": "U+2102",
        "mathematical_meaning": "the set of all complex numbers {a plus bi | a,b ‚àà ‚Ñù, i¬≤ is equal to -1}",
        "usage_context": "z ‚àà ‚ÑÇ means z is a complex number with real and imaginary parts",
        "negation_symbol": "",
        "related_symbols": ["‚Ñï", "‚Ñ§", "‚Ñö", "‚Ñù", "i"]
    }

Note: =====================================================================
Note: CATEGORY THEORY OPERATIONS
Note: =====================================================================

Process called "get_category_symbols" that returns List[SetSymbol]:
    Note: Get category theory symbols (‚áÑ, ‚ä£, ‚ä¢, ‚àò, etc.)
    Return [
        morphism_composition_symbol(),
        natural_transformation_symbol(),
        adjunction_symbol(),
        functor_symbol(),
        isomorphism_arrows_symbol()
    ]

Process called "morphism_composition_symbol" that returns SetSymbol:
    Note: Get morphism composition symbol (‚àò)
    Return {
        "symbol_character": "‚àò",
        "symbol_name": "composition",
        "unicode_codepoint": "U+2218",
        "mathematical_meaning": "composition of morphisms or functions in category theory",
        "usage_context": "g ‚àò f represents composition of morphisms f and g, (g ‚àò f)(x) is equal to g(f(x))",
        "negation_symbol": "",
        "related_symbols": ["‚Üí", "‚áí", "id", "‚ä£", "Hom"]
    }

Process called "natural_transformation_symbol" that returns SetSymbol:
    Note: Get natural transformation symbol (‚áí)
    Return {
        "symbol_character": "‚áí",
        "symbol_name": "natural transformation",
        "unicode_codepoint": "U+21D2",
        "mathematical_meaning": "natural transformation between functors in category theory",
        "usage_context": "F ‚áí G represents a natural transformation from functor F to functor G",
        "negation_symbol": "",
        "related_symbols": ["‚àò", "‚Üí", "‚ä£", "F", "G"]
    }

Process called "adjunction_symbol" that returns SetSymbol:
    Note: Get adjunction symbol (‚ä£)
    Return {
        "symbol_character": "‚ä£",
        "symbol_name": "adjunction",
        "unicode_codepoint": "U+22A3",
        "mathematical_meaning": "adjunction between functors, left adjoint to right adjoint",
        "usage_context": "F ‚ä£ G means functor F is left adjoint to functor G",
        "negation_symbol": "",
        "related_symbols": ["‚ä¢", "‚áí", "‚àò", "‚áÑ", "Hom"]
    }

Process called "functor_symbol" that returns SetSymbol:
    Note: Get functor symbol (‚ä¢)
    Return {
        "symbol_character": "‚ä¢",
        "symbol_name": "turnstile",
        "unicode_codepoint": "U+22A2",
        "mathematical_meaning": "turnstile symbol, used in logic and category theory",
        "usage_context": "Œì ‚ä¢ œÜ means œÜ is derivable from assumptions Œì, also used for functors",
        "negation_symbol": "‚ä¨",
        "related_symbols": ["‚ä£", "‚áí", "‚àò", "‚ä®", "Hom"]
    }

Process called "isomorphism_arrows_symbol" that returns SetSymbol:
    Note: Get isomorphism arrows symbol (‚áÑ)
    Return {
        "symbol_character": "‚áÑ",
        "symbol_name": "isomorphism arrows",
        "unicode_codepoint": "U+21C4",
        "mathematical_meaning": "bidirectional arrows indicating isomorphism or equivalence",
        "usage_context": "A ‚áÑ B indicates bidirectional morphisms establishing isomorphism",
        "negation_symbol": "",
        "related_symbols": ["‚âÖ", "‚Üî", "‚áí", "‚àò", "id"]
    }

Note: =====================================================================
Note: MODEL THEORY OPERATIONS
Note: =====================================================================

Process called "get_model_theory_symbols" that returns List[SetSymbol]:
    Note: Get model theory symbols (‚ä®, ‚ä≠, ‚â°, etc.)
    Return [
        models_symbol(),
        does_not_model_symbol(),
        elementary_equivalence_symbol(),
        semantic_consequence_symbol(),
        satisfaction_symbol()
    ]

Process called "models_symbol" that returns SetSymbol:
    Note: Get models symbol (‚ä®)
    Return {
        "symbol_character": "‚ä®",
        "symbol_name": "models",
        "unicode_codepoint": "U+22A8",
        "mathematical_meaning": "semantic entailment, model relation in logic",
        "usage_context": "M ‚ä® œÜ means model M satisfies formula œÜ",
        "negation_symbol": "‚ä≠",
        "related_symbols": ["‚ä≠", "‚ä¢", "‚â°", "‚ä§", "‚ä•"]
    }

Process called "does_not_model_symbol" that returns SetSymbol:
    Note: Get does not model symbol (‚ä≠)
    Return {
        "symbol_character": "‚ä≠",
        "symbol_name": "does not model",
        "unicode_codepoint": "U+22AD",
        "mathematical_meaning": "negation of semantic entailment, model does not satisfy formula",
        "usage_context": "M ‚ä≠ œÜ means model M does not satisfy formula œÜ",
        "negation_symbol": "‚ä®",
        "related_symbols": ["‚ä®", "‚ä¨", "‚â¢", "‚ä•", "¬¨"]
    }

Process called "elementary_equivalence_symbol" that returns SetSymbol:
    Note: Get elementary equivalence symbol (‚â°)
    Return {
        "symbol_character": "‚â°",
        "symbol_name": "elementary equivalence",
        "unicode_codepoint": "U+2261",
        "mathematical_meaning": "elementary equivalence between models, same first-order theory",
        "usage_context": "M ‚â° N means models M and N are elementarily equivalent",
        "negation_symbol": "‚â¢",
        "related_symbols": ["‚ä®", "‚àº", "‚âÖ", "Th", "L"]
    }

Process called "semantic_consequence_symbol" that returns SetSymbol:
    Note: Get semantic consequence symbol (‚ä®)
    Return {
        "symbol_character": "‚ä®",
        "symbol_name": "semantic consequence",
        "unicode_codepoint": "U+22A8",
        "mathematical_meaning": "semantic consequence relation, logical entailment",
        "usage_context": "Œì ‚ä® œÜ means œÜ is a semantic consequence of premise set Œì",
        "negation_symbol": "‚ä≠",
        "related_symbols": ["‚ä¢", "‚ä≠", "‚ü∂", "‚ä§", "‚ä•"]
    }

Process called "satisfaction_symbol" that returns SetSymbol:
    Note: Get satisfaction symbol (‚ä®)
    Return {
        "symbol_character": "‚ä®",
        "symbol_name": "satisfaction",
        "unicode_codepoint": "U+22A8",
        "mathematical_meaning": "satisfaction relation between structures and formulas",
        "usage_context": "(M,v) ‚ä® œÜ means structure M with valuation v satisfies formula œÜ",
        "negation_symbol": "‚ä≠",
        "related_symbols": ["‚ä≠", "‚â°", "‚ä¢", "Th", "val"]
    }

Note: =====================================================================
Note: VALIDATION AND UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_set_notation" that takes notation as String returns List[String]:
    Note: Validate set theory notation for correctness
    Let errors be []
    Let symbols be ["‚àà", "‚àâ", "‚äÇ", "‚äÉ", "‚äÜ", "‚äá", "‚à™", "‚à©", "‚àñ", "‚ñ≥", "√ó", "‚àÖ", "‚Ñï", "‚Ñ§", "‚Ñö", "‚Ñù", "‚ÑÇ"]
    
    Note: Check for mismatched braces
    Let open_braces be 0
    Let i be 0
    While i is less than notation.length():
        If notation[i] is equal to "{":
            Let open_braces be open_braces plus 1
        Otherwise if notation[i] is equal to "}":
            Let open_braces be open_braces minus 1
            If open_braces is less than 0:
                Add "Unmatched closing brace at position " plus i.to_string() to errors
        Let i be i plus 1
    
    If open_braces is greater than 0:
        Add "Unmatched opening brace(s)" to errors
    
    Note: Check for valid set theory symbols
    Let contains_valid_symbols be False
    Let j be 0
    While j is less than symbols.length():
        If notation.contains(symbols[j]):
            Let contains_valid_symbols be True
        Let j be j plus 1
    
    If !contains_valid_symbols && notation.length() is greater than 2:
        Add "No recognized set theory symbols found" to errors
    
    Return errors

Process called "format_set_expression" that takes expression as String, format_style as String returns String:
    Note: Format set theory expression with proper symbols
    Let formatted be expression
    
    If format_style is equal to "unicode":
        Let formatted be formatted.replace("in", "‚àà")
        Let formatted be formatted.replace("notin", "‚àâ")
        Let formatted be formatted.replace("subset", "‚äÇ")
        Let formatted be formatted.replace("superset", "‚äÉ")
        Let formatted be formatted.replace("union", "‚à™")
        Let formatted be formatted.replace("intersection", "‚à©")
        Let formatted be formatted.replace("emptyset", "‚àÖ")
        Let formatted be formatted.replace("naturals", "‚Ñï")
        Let formatted be formatted.replace("integers", "‚Ñ§")
        Let formatted be formatted.replace("rationals", "‚Ñö")
        Let formatted be formatted.replace("reals", "‚Ñù")
        Let formatted be formatted.replace("complex", "‚ÑÇ")
    Otherwise if format_style is equal to "latex":
        Let formatted be formatted.replace("‚àà", "\\in")
        Let formatted be formatted.replace("‚àâ", "\\notin")
        Let formatted be formatted.replace("‚äÇ", "\\subset")
        Let formatted be formatted.replace("‚äÉ", "\\supset")
        Let formatted be formatted.replace("‚à™", "\\cup")
        Let formatted be formatted.replace("‚à©", "\\cap")
        Let formatted be formatted.replace("‚àÖ", "\\emptyset")
        Let formatted be formatted.replace("‚Ñï", "\\mathbb{N}")
        Let formatted be formatted.replace("‚Ñ§", "\\mathbb{Z}")
        Let formatted be formatted.replace("‚Ñö", "\\mathbb{Q}")
        Let formatted be formatted.replace("‚Ñù", "\\mathbb{R}")
        Let formatted be formatted.replace("‚ÑÇ", "\\mathbb{C}")
    
    Return formatted

Process called "convert_set_notation" that takes expression as String, from_style as String, to_style as String returns String:
    Note: Convert between different set notation styles
    Let result be expression
    
    Note: First normalize to unicode
    If from_style is equal to "ascii":
        Let result be result.replace("in", "‚àà")
        Let result be result.replace("subset", "‚äÇ")
        Let result be result.replace("union", "‚à™")
        Let result be result.replace("intersect", "‚à©")
    Otherwise if from_style is equal to "latex":
        Let result be result.replace("\\in", "‚àà")
        Let result be result.replace("\\subset", "‚äÇ")
        Let result be result.replace("\\cup", "‚à™")
        Let result be result.replace("\\cap", "‚à©")
        Let result be result.replace("\\emptyset", "‚àÖ")
        Let result be result.replace("\\mathbb{N}", "‚Ñï")
        Let result be result.replace("\\mathbb{Z}", "‚Ñ§")
        Let result be result.replace("\\mathbb{Q}", "‚Ñö")
        Let result be result.replace("\\mathbb{R}", "‚Ñù")
        Let result be result.replace("\\mathbb{C}", "‚ÑÇ")
    
    Note: Then convert to target style
    If to_style is equal to "ascii":
        Let result be result.replace("‚àà", " in ")
        Let result be result.replace("‚äÇ", " subset ")
        Let result be result.replace("‚à™", " union ")
        Let result be result.replace("‚à©", " intersect ")
        Let result be result.replace("‚àÖ", "{}")
    Otherwise if to_style is equal to "latex":
        Return format_set_expression(result, "latex")
    
    Return result

Process called "benchmark_symbol_operations" that takes operation_types as List[String], test_symbols as List[String] returns Dictionary[String, Float]:
    Note: Benchmark performance of set symbol operations
    Let results be {}
    Let iterations be 1000
    
    Let op_idx be 0
    While op_idx is less than operation_types.length():
        Let operation be operation_types[op_idx]
        Let start_time be TimeInstant.current_instant()
        
        Let iter be 0
        While iter is less than iterations:
            If operation is equal to "membership":
                Let _ be element_of_symbol()
            Otherwise if operation is equal to "inclusion":
                Let _ be subset_symbol()
            Otherwise if operation is equal to "operations":
                Let _ be union_symbol()
            Otherwise if operation is equal to "quantifiers":
                Let _ be universal_quantifier_symbol()
            Otherwise if operation is equal to "validation":
                Let sym_idx be 0
                While sym_idx is less than test_symbols.length():
                    Let _ be validate_set_notation(test_symbols[sym_idx])
                    Let sym_idx be sym_idx plus 1
            Let iter be iter plus 1
        
        Let end_time be TimeInstant.current_instant()
        Let duration be TimeInstant.duration_between(start_time, end_time)
        Set results[operation] to duration
        Let op_idx be op_idx plus 1
    
    Return results