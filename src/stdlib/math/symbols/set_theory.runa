Note:
math/symbols/set_theory.runa
Set Theory Symbols and Operations

This module provides comprehensive set theory symbol handling including:
- Set notation symbols (∈, ∉, ∋, ∌, ⊂, ⊃, ⊆, ⊇, etc.)
- Set operations (∪, ∩, ∖, △, ⊕, ×, etc.)
- Cardinality and infinity symbols (ℵ, ℶ, ∞, etc.)
- Power set and function space notation
- Quantifier symbols (∀, ∃, ∄, ∃!, etc.)
- Set builder notation components
- Relation and function symbols
- Order theory symbols (⊑, ⊒, ⊓, ⊔, etc.)
- Category theory symbols (⇄, ⊣, ⊢, etc.)
- Topology and analysis symbols
- Boolean algebra symbols
- Lattice theory notation
- Model theory symbols
- Set-theoretic axiom representations
- Forcing and independence notation
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "sys/time/core/instant" as TimeInstant

Note: =====================================================================
Note: SET THEORY SYMBOL DATA STRUCTURES
Note: =====================================================================

Type called "SetSymbol":
    symbol_character as String
    symbol_name as String
    unicode_codepoint as String
    mathematical_meaning as String
    usage_context as String
    negation_symbol as String
    related_symbols as List[String]

Type called "SetOperation":
    operation_symbol as String
    operation_name as String
    operand_count as Integer
    operation_type as String
    properties as List[String]
    dual_operation as String

Type called "QuantifierSymbol":
    quantifier_symbol as String
    quantifier_name as String
    scope_type as String
    binding_power as Integer
    logical_meaning as String

Type called "RelationSymbol":
    relation_symbol as String
    relation_name as String
    relation_type as String
    reflexivity as String
    symmetry as String
    transitivity as String

Note: =====================================================================
Note: BASIC SET MEMBERSHIP OPERATIONS
Note: =====================================================================

Process called "get_membership_symbols" that returns List[SetSymbol]:
    Note: Get set membership symbols (∈, ∉, ∋, ∌)
    Return [
        element_of_symbol(),
        not_element_of_symbol(),
        contains_symbol(),
        not_contains_symbol()
    ]

Process called "element_of_symbol" that returns SetSymbol:
    Note: Get element of symbol (∈)
    Return {
        "symbol_character": "∈",
        "symbol_name": "element of",
        "unicode_codepoint": "U+2208",
        "mathematical_meaning": "indicates that an element belongs to a set",
        "usage_context": "x ∈ A means x is an element of set A",
        "negation_symbol": "∉",
        "related_symbols": ["∉", "∋", "∌", "⊂", "⊆"]
    }

Process called "not_element_of_symbol" that returns SetSymbol:
    Note: Get not element of symbol (∉)
    Return {
        "symbol_character": "∉",
        "symbol_name": "not element of",
        "unicode_codepoint": "U+2209",
        "mathematical_meaning": "indicates that an element does not belong to a set",
        "usage_context": "x ∉ A means x is not an element of set A",
        "negation_symbol": "∈",
        "related_symbols": ["∈", "∋", "∌", "⊄", "⊈"]
    }

Process called "contains_symbol" that returns SetSymbol:
    Note: Get contains symbol (∋)
    Return {
        "symbol_character": "∋",
        "symbol_name": "contains",
        "unicode_codepoint": "U+220B",
        "mathematical_meaning": "indicates that a set contains an element",
        "usage_context": "A ∋ x means set A contains element x",
        "negation_symbol": "∌",
        "related_symbols": ["∈", "∉", "∌", "⊃", "⊇"]
    }

Process called "not_contains_symbol" that returns SetSymbol:
    Note: Get does not contain symbol (∌)
    Return {
        "symbol_character": "∌",
        "symbol_name": "does not contain",
        "unicode_codepoint": "U+220C",
        "mathematical_meaning": "indicates that a set does not contain an element",
        "usage_context": "A ∌ x means set A does not contain element x",
        "negation_symbol": "∋",
        "related_symbols": ["∈", "∉", "∋", "⊅", "⊉"]
    }

Note: =====================================================================
Note: SET INCLUSION OPERATIONS
Note: =====================================================================

Process called "get_inclusion_symbols" that returns List[SetSymbol]:
    Note: Get set inclusion symbols (⊂, ⊃, ⊆, ⊇, ⊊, ⊋)
    Return [
        subset_symbol(),
        superset_symbol(),
        subset_or_equal_symbol(),
        superset_or_equal_symbol(),
        proper_subset_symbol(),
        proper_superset_symbol()
    ]

Process called "subset_symbol" that returns SetSymbol:
    Note: Get subset symbol (⊂)
    Return {
        "symbol_character": "⊂",
        "symbol_name": "subset",
        "unicode_codepoint": "U+2282",
        "mathematical_meaning": "indicates proper subset relation between sets",
        "usage_context": "A ⊂ B means A is a proper subset of B (A is contained in B and A ≠ B)",
        "negation_symbol": "⊄",
        "related_symbols": ["⊆", "⊃", "⊇", "⊊", "∈"]
    }

Process called "superset_symbol" that returns SetSymbol:
    Note: Get superset symbol (⊃)
    Return {
        "symbol_character": "⊃",
        "symbol_name": "superset",
        "unicode_codepoint": "U+2283",
        "mathematical_meaning": "indicates proper superset relation between sets",
        "usage_context": "A ⊃ B means A is a proper superset of B (A contains B and A ≠ B)",
        "negation_symbol": "⊅",
        "related_symbols": ["⊇", "⊂", "⊆", "⊋", "∋"]
    }

Process called "subset_or_equal_symbol" that returns SetSymbol:
    Note: Get subset or equal symbol (⊆)
    Return {
        "symbol_character": "⊆",
        "symbol_name": "subset or equal",
        "unicode_codepoint": "U+2286",
        "mathematical_meaning": "indicates subset or equality relation between sets",
        "usage_context": "A ⊆ B means A is a subset of B or A is equal to B",
        "negation_symbol": "⊈",
        "related_symbols": ["⊂", "⊇", "⊃", "⊊", "∈"]
    }

Process called "superset_or_equal_symbol" that returns SetSymbol:
    Note: Get superset or equal symbol (⊇)
    Return {
        "symbol_character": "⊇",
        "symbol_name": "superset or equal",
        "unicode_codepoint": "U+2287",
        "mathematical_meaning": "indicates superset or equality relation between sets",
        "usage_context": "A ⊇ B means A is a superset of B or A is equal to B",
        "negation_symbol": "⊉",
        "related_symbols": ["⊃", "⊆", "⊂", "⊋", "∋"]
    }

Process called "proper_subset_symbol" that returns SetSymbol:
    Note: Get proper subset symbol (⊊)
    Return {
        "symbol_character": "⊊",
        "symbol_name": "proper subset",
        "unicode_codepoint": "U+228A",
        "mathematical_meaning": "indicates strict proper subset relation",
        "usage_context": "A ⊊ B means A is a proper subset of B with emphasis on strictness",
        "negation_symbol": "⊌",
        "related_symbols": ["⊂", "⊆", "⊋", "⊃", "∈"]
    }

Process called "proper_superset_symbol" that returns SetSymbol:
    Note: Get proper superset symbol (⊋)
    Return {
        "symbol_character": "⊋",
        "symbol_name": "proper superset",
        "unicode_codepoint": "U+228B",
        "mathematical_meaning": "indicates strict proper superset relation",
        "usage_context": "A ⊋ B means A is a proper superset of B with emphasis on strictness",
        "negation_symbol": "⊍",
        "related_symbols": ["⊃", "⊇", "⊊", "⊂", "∋"]
    }

Note: =====================================================================
Note: SET OPERATIONS
Note: =====================================================================

Process called "get_set_operation_symbols" that returns List[SetSymbol]:
    Note: Get set operation symbols (∪, ∩, ∖, △, ⊕, ×)
    Return [
        union_symbol(),
        intersection_symbol(),
        difference_symbol(),
        symmetric_difference_symbol(),
        cartesian_product_symbol()
    ]

Process called "union_symbol" that returns SetSymbol:
    Note: Get union symbol (∪)
    Return {
        "symbol_character": "∪",
        "symbol_name": "union",
        "unicode_codepoint": "U+222A",
        "mathematical_meaning": "set operation that combines all elements from multiple sets",
        "usage_context": "A ∪ B contains all elements that are in A or B or both",
        "negation_symbol": "",
        "related_symbols": ["∩", "∖", "△", "⊕", "⋃"]
    }

Process called "intersection_symbol" that returns SetSymbol:
    Note: Get intersection symbol (∩)
    Return {
        "symbol_character": "∩",
        "symbol_name": "intersection",
        "unicode_codepoint": "U+2229",
        "mathematical_meaning": "set operation that finds common elements between sets",
        "usage_context": "A ∩ B contains only elements that are in both A and B",
        "negation_symbol": "",
        "related_symbols": ["∪", "∖", "△", "⊕", "⋂"]
    }

Process called "difference_symbol" that returns SetSymbol:
    Note: Get set difference symbol (∖)
    Return {
        "symbol_character": "∖",
        "symbol_name": "set difference",
        "unicode_codepoint": "U+2216",
        "mathematical_meaning": "set operation that removes elements of one set from another",
        "usage_context": "A ∖ B contains elements in A but not in B",
        "negation_symbol": "",
        "related_symbols": ["∪", "∩", "△", "∈", "∉"]
    }

Process called "symmetric_difference_symbol" that returns SetSymbol:
    Note: Get symmetric difference symbol (△ or ⊕)
    Return {
        "symbol_character": "△",
        "symbol_name": "symmetric difference",
        "unicode_codepoint": "U+25B3",
        "mathematical_meaning": "set operation that finds elements in either set but not in both",
        "usage_context": "A △ B is equal to (A ∖ B) ∪ (B ∖ A), elements in A or B but not both",
        "negation_symbol": "",
        "related_symbols": ["∪", "∩", "∖", "⊕", "×"]
    }

Process called "cartesian_product_symbol" that returns SetSymbol:
    Note: Get Cartesian product symbol (×)
    Return {
        "symbol_character": "×",
        "symbol_name": "cartesian product",
        "unicode_codepoint": "U+00D7",
        "mathematical_meaning": "set operation that creates ordered pairs from two sets",
        "usage_context": "A × B is equal to {(a,b) | a ∈ A, b ∈ B}, set of all ordered pairs",
        "negation_symbol": "",
        "related_symbols": ["⊕", "∪", "∩", "∈", "→"]
    }

Note: =====================================================================
Note: QUANTIFIER OPERATIONS
Note: =====================================================================

Process called "get_quantifier_symbols" that returns List[QuantifierSymbol]:
    Note: Get quantifier symbols (∀, ∃, ∄, ∃!)
    Return [
        universal_quantifier_symbol(),
        existential_quantifier_symbol(),
        not_exists_symbol(),
        unique_existence_symbol()
    ]

Process called "universal_quantifier_symbol" that returns QuantifierSymbol:
    Note: Get universal quantifier symbol (∀)
    Return {
        "quantifier_symbol": "∀",
        "quantifier_name": "universal quantifier",
        "scope_type": "universal",
        "binding_power": 10,
        "logical_meaning": "for all elements in the domain, the predicate holds"
    }

Process called "existential_quantifier_symbol" that returns QuantifierSymbol:
    Note: Get existential quantifier symbol (∃)
    Return {
        "quantifier_symbol": "∃",
        "quantifier_name": "existential quantifier",
        "scope_type": "existential",
        "binding_power": 10,
        "logical_meaning": "there exists at least one element in the domain for which the predicate holds"
    }

Process called "not_exists_symbol" that returns QuantifierSymbol:
    Note: Get does not exist symbol (∄)
    Return {
        "quantifier_symbol": "∄",
        "quantifier_name": "does not exist",
        "scope_type": "negative_existential",
        "binding_power": 10,
        "logical_meaning": "there does not exist any element in the domain for which the predicate holds"
    }

Process called "unique_existence_symbol" that returns QuantifierSymbol:
    Note: Get unique existence symbol (∃!)
    Return {
        "quantifier_symbol": "∃!",
        "quantifier_name": "unique existence",
        "scope_type": "unique_existential",
        "binding_power": 10,
        "logical_meaning": "there exists exactly one element in the domain for which the predicate holds"
    }

Note: =====================================================================
Note: CARDINALITY AND INFINITY OPERATIONS
Note: =====================================================================

Process called "get_cardinality_symbols" that returns List[SetSymbol]:
    Note: Get cardinality symbols (|A|, #A, card(A))
    Return [
        {
            "symbol_character": "|",
            "symbol_name": "cardinality bars",
            "unicode_codepoint": "U+007C",
            "mathematical_meaning": "indicates the number of elements in a set",
            "usage_context": "|A| represents the cardinality of set A",
            "negation_symbol": "",
            "related_symbols": ["#", "card", "ℵ", "ℶ"]
        },
        {
            "symbol_character": "#",
            "symbol_name": "cardinality hash",
            "unicode_codepoint": "U+0023",
            "mathematical_meaning": "alternative notation for set cardinality",
            "usage_context": "#A represents the number of elements in set A",
            "negation_symbol": "",
            "related_symbols": ["|", "card", "ℵ", "ℶ"]
        }
    ]

Process called "aleph_symbols" that returns List[SetSymbol]:
    Note: Get aleph symbols for infinite cardinalities (ℵ₀, ℵ₁, ℵ₂, ...)
    Return [
        {
            "symbol_character": "ℵ₀",
            "symbol_name": "aleph null",
            "unicode_codepoint": "U+2135 U+2080",
            "mathematical_meaning": "cardinality of countably infinite sets",
            "usage_context": "ℵ₀ is equal to |ℕ| is equal to |ℤ| is equal to |ℚ|, smallest infinite cardinal",
            "negation_symbol": "",
            "related_symbols": ["ℵ₁", "ℵ₂", "ℶ₀", "∞", "ω"]
        },
        {
            "symbol_character": "ℵ₁",
            "symbol_name": "aleph one",
            "unicode_codepoint": "U+2135 U+2081",
            "mathematical_meaning": "next cardinal after aleph null",
            "usage_context": "ℵ₁ is the smallest uncountable cardinal under CH",
            "negation_symbol": "",
            "related_symbols": ["ℵ₀", "ℵ₂", "ℶ₁", "2^{ℵ₀}"]
        },
        {
            "symbol_character": "ℵ₂",
            "symbol_name": "aleph two",
            "unicode_codepoint": "U+2135 U+2082",
            "mathematical_meaning": "third infinite cardinal number",
            "usage_context": "ℵ₂ follows ℵ₁ in the cardinal hierarchy",
            "negation_symbol": "",
            "related_symbols": ["ℵ₀", "ℵ₁", "ℶ₂", "2^{ℵ₁}"]
        }
    ]

Process called "beth_symbols" that returns List[SetSymbol]:
    Note: Get beth symbols (ℶ₀, ℶ₁, ℶ₂, ...)
    Return [
        {
            "symbol_character": "ℶ₀",
            "symbol_name": "beth null",
            "unicode_codepoint": "U+2136 U+2080",
            "mathematical_meaning": "cardinality of countably infinite sets, is equal to aleph null",
            "usage_context": "ℶ₀ is equal to ℵ₀ is equal to |ℕ|",
            "negation_symbol": "",
            "related_symbols": ["ℶ₁", "ℵ₀", "2^{ℵ₀}", "∞"]
        },
        {
            "symbol_character": "ℶ₁",
            "symbol_name": "beth one",
            "unicode_codepoint": "U+2136 U+2081",
            "mathematical_meaning": "cardinality of the continuum, 2^{ℵ₀}",
            "usage_context": "ℶ₁ is equal to 2^{ℵ₀} is equal to |ℝ| is equal to |℘(ℕ)|",
            "negation_symbol": "",
            "related_symbols": ["ℶ₀", "ℶ₂", "ℵ₁", "2^{ℵ₁}"]
        }
    ]

Process called "infinity_symbols" that returns List[SetSymbol]:
    Note: Get infinity symbols (∞, ω, Ω)
    Return [
        {
            "symbol_character": "∞",
            "symbol_name": "infinity",
            "unicode_codepoint": "U+221E",
            "mathematical_meaning": "represents unbounded quantity or infinite cardinality",
            "usage_context": "used in limits, cardinalities, and extended real numbers",
            "negation_symbol": "",
            "related_symbols": ["ℵ", "ℶ", "ω", "ω₁", "+∞", "-∞"]
        },
        {
            "symbol_character": "ω",
            "symbol_name": "omega",
            "unicode_codepoint": "U+03C9",
            "mathematical_meaning": "first infinite ordinal number, order type of natural numbers",
            "usage_context": "ω represents the ordinal of ℕ, smallest infinite ordinal",
            "negation_symbol": "",
            "related_symbols": ["ω₁", "ℵ₀", "∞", "ω^2", "ω^ω"]
        },
        {
            "symbol_character": "Ω",
            "symbol_name": "big omega",
            "unicode_codepoint": "U+03A9",
            "mathematical_meaning": "class of all ordinals, not a set",
            "usage_context": "Ω represents the class of all ordinals in set theory",
            "negation_symbol": "",
            "related_symbols": ["ω", "ω₁", "On", "V"]
        }
    ]

Note: =====================================================================
Note: FUNCTION AND RELATION OPERATIONS
Note: =====================================================================

Process called "get_function_symbols" that returns List[SetSymbol]:
    Note: Get function symbols (→, ↦, ⇸, f:A→B)
    Return [
        maps_to_symbol(),
        function_arrow_symbol(),
        partial_function_symbol(),
        bijection_symbol()
    ]

Process called "maps_to_symbol" that returns SetSymbol:
    Note: Get maps to symbol (↦)
    Return {
        "symbol_character": "↦",
        "symbol_name": "maps to",
        "unicode_codepoint": "U+21A6",
        "mathematical_meaning": "indicates specific element mapping in functions",
        "usage_context": "x ↦ f(x) shows how element x maps to f(x)",
        "negation_symbol": "",
        "related_symbols": ["→", "⇸", "↔", "∈", "f"]
    }

Process called "function_arrow_symbol" that returns SetSymbol:
    Note: Get function arrow symbol (→)
    Return {
        "symbol_character": "→",
        "symbol_name": "function arrow",
        "unicode_codepoint": "U+2192",
        "mathematical_meaning": "indicates function mapping between sets or domains",
        "usage_context": "f: A → B means function f maps from domain A to codomain B",
        "negation_symbol": "",
        "related_symbols": ["↦", "⇸", "↔", "∈", "×"]
    }

Process called "partial_function_symbol" that returns SetSymbol:
    Note: Get partial function symbol (⇸)
    Return {
        "symbol_character": "⇸",
        "symbol_name": "partial function",
        "unicode_codepoint": "U+21F8",
        "mathematical_meaning": "indicates partial function mapping (not defined for all inputs)",
        "usage_context": "f: A ⇸ B means f is defined on a subset of A",
        "negation_symbol": "",
        "related_symbols": ["→", "↦", "↔", "dom", "ran"]
    }

Process called "bijection_symbol" that returns SetSymbol:
    Note: Get bijection symbol (↔)
    Return {
        "symbol_character": "↔",
        "symbol_name": "bijection",
        "unicode_codepoint": "U+2194",
        "mathematical_meaning": "indicates one-to-one correspondence between sets",
        "usage_context": "A ↔ B means there exists a bijection between A and B",
        "negation_symbol": "",
        "related_symbols": ["→", "↦", "⇸", "≅", "|·|"]
    }

Note: =====================================================================
Note: POWER SET AND FAMILY OPERATIONS
Note: =====================================================================

Process called "power_set_symbol" that returns SetSymbol:
    Note: Get power set symbol (℘ or P)
    Return {
        "symbol_character": "℘",
        "symbol_name": "power set",
        "unicode_codepoint": "U+2118",
        "mathematical_meaning": "set of all subsets of a given set",
        "usage_context": "℘(A) is equal to {B | B ⊆ A}, all subsets of A",
        "negation_symbol": "",
        "related_symbols": ["⊆", "⊂", "⋃", "⋂", "2^A"]
    }

Process called "set_of_all_subsets_notation" that returns String:
    Note: Get notation for set of all subsets
    Return "{B | B ⊆ A}"

Process called "indexed_family_notation" that returns String:
    Note: Get notation for indexed families {Aᵢ}ᵢ∈I
    Return "{Aᵢ}ᵢ∈I"

Process called "big_union_symbol" that returns SetSymbol:
    Note: Get big union symbol (⋃)
    Return {
        "symbol_character": "⋃",
        "symbol_name": "big union",
        "unicode_codepoint": "U+22C3",
        "mathematical_meaning": "union of an indexed family or collection of sets",
        "usage_context": "⋃ᵢ∈I Aᵢ is equal to {x | ∃i ∈ I, x ∈ Aᵢ}",
        "negation_symbol": "",
        "related_symbols": ["⋂", "∪", "∈", "∃", "I"]
    }

Process called "big_intersection_symbol" that returns SetSymbol:
    Note: Get big intersection symbol (⋂)
    Return {
        "symbol_character": "⋂",
        "symbol_name": "big intersection",
        "unicode_codepoint": "U+22C2",
        "mathematical_meaning": "intersection of an indexed family or collection of sets",
        "usage_context": "⋂ᵢ∈I Aᵢ is equal to {x | ∀i ∈ I, x ∈ Aᵢ}",
        "negation_symbol": "",
        "related_symbols": ["⋃", "∩", "∈", "∀", "I"]
    }

Note: =====================================================================
Note: ORDER THEORY OPERATIONS
Note: =====================================================================

Process called "get_order_symbols" that returns List[SetSymbol]:
    Note: Get order relation symbols (≤, ≥, <, >, ⊑, ⊒, ⪯, ⪰)
    Return [
        less_than_or_equal_symbol(),
        greater_than_or_equal_symbol(),
        precedes_symbol(),
        succeeds_symbol(),
        much_less_than_symbol(),
        much_greater_than_symbol()
    ]

Process called "partial_order_symbols" that returns List[SetSymbol]:
    Note: Get partial order symbols (⊑, ⊒, ≼, ≽)
    Return [
        square_image_of_symbol(),
        square_original_of_symbol(),
        precedes_or_equal_symbol(),
        succeeds_or_equal_symbol()
    ]

Process called "lattice_symbols" that returns List[SetSymbol]:
    Note: Get lattice operation symbols (⊓, ⊔, ∧, ∨)
    Return [
        meet_symbol(),
        join_symbol(),
        logical_and_symbol(),
        logical_or_symbol()
    ]

Process called "join_symbol" that returns SetSymbol:
    Note: Get join (supremum) symbol (⊔)
    Return {
        "symbol_character": "⊔",
        "symbol_name": "join",
        "unicode_codepoint": "U+2294",
        "mathematical_meaning": "supremum operation in lattice theory, least upper bound",
        "usage_context": "a ⊔ b represents the join (supremum) of elements a and b in a lattice",
        "negation_symbol": "",
        "related_symbols": ["⊓", "∨", "⊆", "≤", "sup"]
    }

Process called "meet_symbol" that returns SetSymbol:
    Note: Get meet (infimum) symbol (⊓)
    Return {
        "symbol_character": "⊓",
        "symbol_name": "meet",
        "unicode_codepoint": "U+2293",
        "mathematical_meaning": "infimum operation in lattice theory, greatest lower bound",
        "usage_context": "a ⊓ b represents the meet (infimum) of elements a and b in a lattice",
        "negation_symbol": "",
        "related_symbols": ["⊔", "∧", "⊆", "≤", "inf"]
    }

Process called "less_than_or_equal_symbol" that returns SetSymbol:
    Note: Get less than or equal symbol (≤)
    Return {
        "symbol_character": "≤",
        "symbol_name": "less than or equal",
        "unicode_codepoint": "U+2264",
        "mathematical_meaning": "partial order relation indicating one element is less than or equal to another",
        "usage_context": "a ≤ b means a is less than or equal to b in the given order",
        "negation_symbol": "≰",
        "related_symbols": ["≥", "<", ">", "⊑", "≼"]
    }

Process called "greater_than_or_equal_symbol" that returns SetSymbol:
    Note: Get greater than or equal symbol (≥)
    Return {
        "symbol_character": "≥",
        "symbol_name": "greater than or equal",
        "unicode_codepoint": "U+2265",
        "mathematical_meaning": "partial order relation indicating one element is greater than or equal to another",
        "usage_context": "a ≥ b means a is greater than or equal to b in the given order",
        "negation_symbol": "≱",
        "related_symbols": ["≤", "<", ">", "⊒", "≽"]
    }

Process called "precedes_symbol" that returns SetSymbol:
    Note: Get precedes symbol (≺)
    Return {
        "symbol_character": "≺",
        "symbol_name": "precedes",
        "unicode_codepoint": "U+227A",
        "mathematical_meaning": "strict order relation indicating one element precedes another",
        "usage_context": "a ≺ b means a strictly precedes b in the given order",
        "negation_symbol": "⊀",
        "related_symbols": ["≻", "≼", "≽", "<", "⊏"]
    }

Process called "succeeds_symbol" that returns SetSymbol:
    Note: Get succeeds symbol (≻)
    Return {
        "symbol_character": "≻",
        "symbol_name": "succeeds",
        "unicode_codepoint": "U+227B",
        "mathematical_meaning": "strict order relation indicating one element succeeds another",
        "usage_context": "a ≻ b means a strictly succeeds b in the given order",
        "negation_symbol": "⊁",
        "related_symbols": ["≺", "≼", "≽", ">", "⊐"]
    }

Process called "much_less_than_symbol" that returns SetSymbol:
    Note: Get much less than symbol (≪)
    Return {
        "symbol_character": "≪",
        "symbol_name": "much less than",
        "unicode_codepoint": "U+226A",
        "mathematical_meaning": "indicates significantly less than relationship",
        "usage_context": "a ≪ b means a is much less than b, often used in analysis",
        "negation_symbol": "≫",
        "related_symbols": ["≫", "≤", "<", "≺", "⋘"]
    }

Process called "much_greater_than_symbol" that returns SetSymbol:
    Note: Get much greater than symbol (≫)
    Return {
        "symbol_character": "≫",
        "symbol_name": "much greater than",
        "unicode_codepoint": "U+226B",
        "mathematical_meaning": "indicates significantly greater than relationship",
        "usage_context": "a ≫ b means a is much greater than b, often used in analysis",
        "negation_symbol": "≪",
        "related_symbols": ["≪", "≥", ">", "≻", "⋙"]
    }

Process called "square_image_of_symbol" that returns SetSymbol:
    Note: Get square image of symbol (⊑)
    Return {
        "symbol_character": "⊑",
        "symbol_name": "square image of",
        "unicode_codepoint": "U+2291",
        "mathematical_meaning": "partial order relation, often used in domain theory",
        "usage_context": "a ⊑ b means a is a square image of b, used in computer science and domain theory",
        "negation_symbol": "⋢",
        "related_symbols": ["⊒", "⊏", "⊐", "≤", "⊆"]
    }

Process called "square_original_of_symbol" that returns SetSymbol:
    Note: Get square original of symbol (⊒)
    Return {
        "symbol_character": "⊒",
        "symbol_name": "square original of",
        "unicode_codepoint": "U+2292",
        "mathematical_meaning": "partial order relation, dual of square image of",
        "usage_context": "a ⊒ b means a is a square original of b, used in domain theory",
        "negation_symbol": "⋣",
        "related_symbols": ["⊑", "⊏", "⊐", "≥", "⊇"]
    }

Process called "precedes_or_equal_symbol" that returns SetSymbol:
    Note: Get precedes or equal symbol (≼)
    Return {
        "symbol_character": "≼",
        "symbol_name": "precedes or equal",
        "unicode_codepoint": "U+227C",
        "mathematical_meaning": "partial order relation allowing equality",
        "usage_context": "a ≼ b means a precedes b or is equal to b in the given order",
        "negation_symbol": "⋠",
        "related_symbols": ["≽", "≺", "≻", "≤", "⊑"]
    }

Process called "succeeds_or_equal_symbol" that returns SetSymbol:
    Note: Get succeeds or equal symbol (≽)
    Return {
        "symbol_character": "≽",
        "symbol_name": "succeeds or equal",
        "unicode_codepoint": "U+227D",
        "mathematical_meaning": "partial order relation allowing equality",
        "usage_context": "a ≽ b means a succeeds b or is equal to b in the given order",
        "negation_symbol": "⋡",
        "related_symbols": ["≼", "≺", "≻", "≥", "⊒"]
    }

Process called "logical_and_symbol" that returns SetSymbol:
    Note: Get logical and symbol (∧)
    Return {
        "symbol_character": "∧",
        "symbol_name": "logical and",
        "unicode_codepoint": "U+2227",
        "mathematical_meaning": "logical conjunction, meet operation in Boolean algebra",
        "usage_context": "P ∧ Q means P and Q, both propositions must be true",
        "negation_symbol": "",
        "related_symbols": ["∨", "⊓", "∩", "¬", "→"]
    }

Process called "logical_or_symbol" that returns SetSymbol:
    Note: Get logical or symbol (∨)
    Return {
        "symbol_character": "∨",
        "symbol_name": "logical or",
        "unicode_codepoint": "U+2228",
        "mathematical_meaning": "logical disjunction, join operation in Boolean algebra",
        "usage_context": "P ∨ Q means P or Q, at least one proposition must be true",
        "negation_symbol": "",
        "related_symbols": ["∧", "⊔", "∪", "¬", "→"]
    }

Note: =====================================================================
Note: EQUIVALENCE AND CONGRUENCE OPERATIONS
Note: =====================================================================

Process called "get_equivalence_symbols" that returns List[SetSymbol]:
    Note: Get equivalence symbols (≡, ∼, ≈, ≅, ≃)
    Return [
        congruence_symbol(),
        equivalence_relation_symbol(),
        approximately_equal_symbol(),
        isomorphism_symbol(),
        asymptotically_equal_symbol()
    ]

Process called "equivalence_relation_symbol" that returns SetSymbol:
    Note: Get equivalence relation symbol (∼)
    Return {
        "symbol_character": "∼",
        "symbol_name": "equivalence relation",
        "unicode_codepoint": "U+223C",
        "mathematical_meaning": "indicates equivalence relation (reflexive, symmetric, transitive)",
        "usage_context": "a ∼ b means a is equivalent to b under some equivalence relation",
        "negation_symbol": "≁",
        "related_symbols": ["≡", "≈", "≅", "≃", "[·]"]
    }

Process called "congruence_symbol" that returns SetSymbol:
    Note: Get congruence symbol (≡)
    Return {
        "symbol_character": "≡",
        "symbol_name": "congruent to",
        "unicode_codepoint": "U+2261",
        "mathematical_meaning": "indicates congruence relation, often modular arithmetic or geometric congruence",
        "usage_context": "a ≡ b (mod n) means a and b have same remainder when divided by n",
        "negation_symbol": "≢",
        "related_symbols": ["∼", "≈", "mod", "≅", "%"]
    }

Process called "isomorphism_symbol" that returns SetSymbol:
    Note: Get isomorphism symbol (≅)
    Return {
        "symbol_character": "≅",
        "symbol_name": "isomorphic to",
        "unicode_codepoint": "U+2245",
        "mathematical_meaning": "indicates isomorphism between mathematical structures",
        "usage_context": "A ≅ B means structure A is isomorphic to structure B",
        "negation_symbol": "≄",
        "related_symbols": ["≡", "∼", "≈", "⇔", "Hom"]
    }

Process called "approximately_equal_symbol" that returns SetSymbol:
    Note: Get approximately equal symbol (≈)
    Return {
        "symbol_character": "≈",
        "symbol_name": "approximately equal",
        "unicode_codepoint": "U+2248",
        "mathematical_meaning": "indicates approximate equality or similarity",
        "usage_context": "a ≈ b means a is approximately equal to b within some tolerance",
        "negation_symbol": "≉",
        "related_symbols": ["≃", "∼", "≡", "≅", "±"]
    }

Process called "asymptotically_equal_symbol" that returns SetSymbol:
    Note: Get asymptotically equal symbol (≃)
    Return {
        "symbol_character": "≃",
        "symbol_name": "asymptotically equal",
        "unicode_codepoint": "U+2243",
        "mathematical_meaning": "indicates asymptotic equality or equivalence",
        "usage_context": "f(x) ≃ g(x) means f and g are asymptotically equal as x approaches some limit",
        "negation_symbol": "≄",
        "related_symbols": ["≈", "∼", "≡", "→", "lim"]
    }

Note: =====================================================================
Note: SPECIAL SET SYMBOLS
Note: =====================================================================

Process called "empty_set_symbol" that returns SetSymbol:
    Note: Get empty set symbol (∅ or {})
    Return {
        "symbol_character": "∅",
        "symbol_name": "empty set",
        "unicode_codepoint": "U+2205",
        "mathematical_meaning": "the unique set containing no elements",
        "usage_context": "∅ is equal to {} represents the empty set, subset of all sets",
        "negation_symbol": "",
        "related_symbols": ["{}", "⊂", "⊆", "|·|", "0"]
    }

Process called "universal_set_symbol" that returns SetSymbol:
    Note: Get universal set symbol (U or 𝒰)
    Return {
        "symbol_character": "𝒰",
        "symbol_name": "universal set",
        "unicode_codepoint": "U+1D4B0",
        "mathematical_meaning": "the set containing all objects under consideration in a given context",
        "usage_context": "𝒰 represents the universal set, superset of all sets in the domain",
        "negation_symbol": "",
        "related_symbols": ["U", "⊃", "⊇", "∅", "V"]
    }

Process called "complement_symbol" that returns SetSymbol:
    Note: Get complement symbol (Aᶜ or A̅ or ∁A)
    Return {
        "symbol_character": "∁",
        "symbol_name": "complement",
        "unicode_codepoint": "U+2201",
        "mathematical_meaning": "the set of all elements not in the given set",
        "usage_context": "∁A or Aᶜ represents complement of set A relative to universal set",
        "negation_symbol": "",
        "related_symbols": ["Aᶜ", "A̅", "∖", "𝒰", "∅"]
    }

Process called "natural_numbers_symbol" that returns SetSymbol:
    Note: Get natural numbers symbol (ℕ)
    Return {
        "symbol_character": "ℕ",
        "symbol_name": "natural numbers",
        "unicode_codepoint": "U+2115",
        "mathematical_meaning": "the set of positive integers {1, 2, 3, ...} or {0, 1, 2, 3, ...}",
        "usage_context": "n ∈ ℕ means n is a natural number, used for counting",
        "negation_symbol": "",
        "related_symbols": ["ℤ", "ℚ", "ℝ", "ℂ", "ℕ₀"]
    }

Process called "integers_symbol" that returns SetSymbol:
    Note: Get integers symbol (ℤ)
    Return {
        "symbol_character": "ℤ",
        "symbol_name": "integers",
        "unicode_codepoint": "U+2124",
        "mathematical_meaning": "the set of all integers {..., -2, -1, 0, 1, 2, ...}",
        "usage_context": "n ∈ ℤ means n is an integer, includes negative numbers and zero",
        "negation_symbol": "",
        "related_symbols": ["ℕ", "ℚ", "ℝ", "ℂ", "ℤ⁺"]
    }

Process called "rationals_symbol" that returns SetSymbol:
    Note: Get rationals symbol (ℚ)
    Return {
        "symbol_character": "ℚ",
        "symbol_name": "rational numbers",
        "unicode_codepoint": "U+211A",
        "mathematical_meaning": "the set of all rational numbers {p/q | p,q ∈ ℤ, q ≠ 0}",
        "usage_context": "x ∈ ℚ means x is a rational number, can be expressed as fraction",
        "negation_symbol": "",
        "related_symbols": ["ℕ", "ℤ", "ℝ", "ℂ", "p/q"]
    }

Process called "reals_symbol" that returns SetSymbol:
    Note: Get reals symbol (ℝ)
    Return {
        "symbol_character": "ℝ",
        "symbol_name": "real numbers",
        "unicode_codepoint": "U+211D",
        "mathematical_meaning": "the set of all real numbers, including rationals and irrationals",
        "usage_context": "x ∈ ℝ means x is a real number, can be represented on number line",
        "negation_symbol": "",
        "related_symbols": ["ℕ", "ℤ", "ℚ", "ℂ", "ℝ⁺"]
    }

Process called "complex_numbers_symbol" that returns SetSymbol:
    Note: Get complex numbers symbol (ℂ)
    Return {
        "symbol_character": "ℂ",
        "symbol_name": "complex numbers",
        "unicode_codepoint": "U+2102",
        "mathematical_meaning": "the set of all complex numbers {a plus bi | a,b ∈ ℝ, i² is equal to -1}",
        "usage_context": "z ∈ ℂ means z is a complex number with real and imaginary parts",
        "negation_symbol": "",
        "related_symbols": ["ℕ", "ℤ", "ℚ", "ℝ", "i"]
    }

Note: =====================================================================
Note: CATEGORY THEORY OPERATIONS
Note: =====================================================================

Process called "get_category_symbols" that returns List[SetSymbol]:
    Note: Get category theory symbols (⇄, ⊣, ⊢, ∘, etc.)
    Return [
        morphism_composition_symbol(),
        natural_transformation_symbol(),
        adjunction_symbol(),
        functor_symbol(),
        isomorphism_arrows_symbol()
    ]

Process called "morphism_composition_symbol" that returns SetSymbol:
    Note: Get morphism composition symbol (∘)
    Return {
        "symbol_character": "∘",
        "symbol_name": "composition",
        "unicode_codepoint": "U+2218",
        "mathematical_meaning": "composition of morphisms or functions in category theory",
        "usage_context": "g ∘ f represents composition of morphisms f and g, (g ∘ f)(x) is equal to g(f(x))",
        "negation_symbol": "",
        "related_symbols": ["→", "⇒", "id", "⊣", "Hom"]
    }

Process called "natural_transformation_symbol" that returns SetSymbol:
    Note: Get natural transformation symbol (⇒)
    Return {
        "symbol_character": "⇒",
        "symbol_name": "natural transformation",
        "unicode_codepoint": "U+21D2",
        "mathematical_meaning": "natural transformation between functors in category theory",
        "usage_context": "F ⇒ G represents a natural transformation from functor F to functor G",
        "negation_symbol": "",
        "related_symbols": ["∘", "→", "⊣", "F", "G"]
    }

Process called "adjunction_symbol" that returns SetSymbol:
    Note: Get adjunction symbol (⊣)
    Return {
        "symbol_character": "⊣",
        "symbol_name": "adjunction",
        "unicode_codepoint": "U+22A3",
        "mathematical_meaning": "adjunction between functors, left adjoint to right adjoint",
        "usage_context": "F ⊣ G means functor F is left adjoint to functor G",
        "negation_symbol": "",
        "related_symbols": ["⊢", "⇒", "∘", "⇄", "Hom"]
    }

Process called "functor_symbol" that returns SetSymbol:
    Note: Get functor symbol (⊢)
    Return {
        "symbol_character": "⊢",
        "symbol_name": "turnstile",
        "unicode_codepoint": "U+22A2",
        "mathematical_meaning": "turnstile symbol, used in logic and category theory",
        "usage_context": "Γ ⊢ φ means φ is derivable from assumptions Γ, also used for functors",
        "negation_symbol": "⊬",
        "related_symbols": ["⊣", "⇒", "∘", "⊨", "Hom"]
    }

Process called "isomorphism_arrows_symbol" that returns SetSymbol:
    Note: Get isomorphism arrows symbol (⇄)
    Return {
        "symbol_character": "⇄",
        "symbol_name": "isomorphism arrows",
        "unicode_codepoint": "U+21C4",
        "mathematical_meaning": "bidirectional arrows indicating isomorphism or equivalence",
        "usage_context": "A ⇄ B indicates bidirectional morphisms establishing isomorphism",
        "negation_symbol": "",
        "related_symbols": ["≅", "↔", "⇒", "∘", "id"]
    }

Note: =====================================================================
Note: MODEL THEORY OPERATIONS
Note: =====================================================================

Process called "get_model_theory_symbols" that returns List[SetSymbol]:
    Note: Get model theory symbols (⊨, ⊭, ≡, etc.)
    Return [
        models_symbol(),
        does_not_model_symbol(),
        elementary_equivalence_symbol(),
        semantic_consequence_symbol(),
        satisfaction_symbol()
    ]

Process called "models_symbol" that returns SetSymbol:
    Note: Get models symbol (⊨)
    Return {
        "symbol_character": "⊨",
        "symbol_name": "models",
        "unicode_codepoint": "U+22A8",
        "mathematical_meaning": "semantic entailment, model relation in logic",
        "usage_context": "M ⊨ φ means model M satisfies formula φ",
        "negation_symbol": "⊭",
        "related_symbols": ["⊭", "⊢", "≡", "⊤", "⊥"]
    }

Process called "does_not_model_symbol" that returns SetSymbol:
    Note: Get does not model symbol (⊭)
    Return {
        "symbol_character": "⊭",
        "symbol_name": "does not model",
        "unicode_codepoint": "U+22AD",
        "mathematical_meaning": "negation of semantic entailment, model does not satisfy formula",
        "usage_context": "M ⊭ φ means model M does not satisfy formula φ",
        "negation_symbol": "⊨",
        "related_symbols": ["⊨", "⊬", "≢", "⊥", "¬"]
    }

Process called "elementary_equivalence_symbol" that returns SetSymbol:
    Note: Get elementary equivalence symbol (≡)
    Return {
        "symbol_character": "≡",
        "symbol_name": "elementary equivalence",
        "unicode_codepoint": "U+2261",
        "mathematical_meaning": "elementary equivalence between models, same first-order theory",
        "usage_context": "M ≡ N means models M and N are elementarily equivalent",
        "negation_symbol": "≢",
        "related_symbols": ["⊨", "∼", "≅", "Th", "L"]
    }

Process called "semantic_consequence_symbol" that returns SetSymbol:
    Note: Get semantic consequence symbol (⊨)
    Return {
        "symbol_character": "⊨",
        "symbol_name": "semantic consequence",
        "unicode_codepoint": "U+22A8",
        "mathematical_meaning": "semantic consequence relation, logical entailment",
        "usage_context": "Γ ⊨ φ means φ is a semantic consequence of premise set Γ",
        "negation_symbol": "⊭",
        "related_symbols": ["⊢", "⊭", "⟶", "⊤", "⊥"]
    }

Process called "satisfaction_symbol" that returns SetSymbol:
    Note: Get satisfaction symbol (⊨)
    Return {
        "symbol_character": "⊨",
        "symbol_name": "satisfaction",
        "unicode_codepoint": "U+22A8",
        "mathematical_meaning": "satisfaction relation between structures and formulas",
        "usage_context": "(M,v) ⊨ φ means structure M with valuation v satisfies formula φ",
        "negation_symbol": "⊭",
        "related_symbols": ["⊭", "≡", "⊢", "Th", "val"]
    }

Note: =====================================================================
Note: VALIDATION AND UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_set_notation" that takes notation as String returns List[String]:
    Note: Validate set theory notation for correctness
    Let errors be []
    Let symbols be ["∈", "∉", "⊂", "⊃", "⊆", "⊇", "∪", "∩", "∖", "△", "×", "∅", "ℕ", "ℤ", "ℚ", "ℝ", "ℂ"]
    
    Note: Check for mismatched braces
    Let open_braces be 0
    Let i be 0
    While i is less than notation.length():
        If notation[i] is equal to "{":
            Let open_braces be open_braces plus 1
        Otherwise if notation[i] is equal to "}":
            Let open_braces be open_braces minus 1
            If open_braces is less than 0:
                Add "Unmatched closing brace at position " plus i.to_string() to errors
        Let i be i plus 1
    
    If open_braces is greater than 0:
        Add "Unmatched opening brace(s)" to errors
    
    Note: Check for valid set theory symbols
    Let contains_valid_symbols be False
    Let j be 0
    While j is less than symbols.length():
        If notation.contains(symbols[j]):
            Let contains_valid_symbols be True
        Let j be j plus 1
    
    If !contains_valid_symbols && notation.length() is greater than 2:
        Add "No recognized set theory symbols found" to errors
    
    Return errors

Process called "format_set_expression" that takes expression as String, format_style as String returns String:
    Note: Format set theory expression with proper symbols
    Let formatted be expression
    
    If format_style is equal to "unicode":
        Let formatted be formatted.replace("in", "∈")
        Let formatted be formatted.replace("notin", "∉")
        Let formatted be formatted.replace("subset", "⊂")
        Let formatted be formatted.replace("superset", "⊃")
        Let formatted be formatted.replace("union", "∪")
        Let formatted be formatted.replace("intersection", "∩")
        Let formatted be formatted.replace("emptyset", "∅")
        Let formatted be formatted.replace("naturals", "ℕ")
        Let formatted be formatted.replace("integers", "ℤ")
        Let formatted be formatted.replace("rationals", "ℚ")
        Let formatted be formatted.replace("reals", "ℝ")
        Let formatted be formatted.replace("complex", "ℂ")
    Otherwise if format_style is equal to "latex":
        Let formatted be formatted.replace("∈", "\\in")
        Let formatted be formatted.replace("∉", "\\notin")
        Let formatted be formatted.replace("⊂", "\\subset")
        Let formatted be formatted.replace("⊃", "\\supset")
        Let formatted be formatted.replace("∪", "\\cup")
        Let formatted be formatted.replace("∩", "\\cap")
        Let formatted be formatted.replace("∅", "\\emptyset")
        Let formatted be formatted.replace("ℕ", "\\mathbb{N}")
        Let formatted be formatted.replace("ℤ", "\\mathbb{Z}")
        Let formatted be formatted.replace("ℚ", "\\mathbb{Q}")
        Let formatted be formatted.replace("ℝ", "\\mathbb{R}")
        Let formatted be formatted.replace("ℂ", "\\mathbb{C}")
    
    Return formatted

Process called "convert_set_notation" that takes expression as String, from_style as String, to_style as String returns String:
    Note: Convert between different set notation styles
    Let result be expression
    
    Note: First normalize to unicode
    If from_style is equal to "ascii":
        Let result be result.replace("in", "∈")
        Let result be result.replace("subset", "⊂")
        Let result be result.replace("union", "∪")
        Let result be result.replace("intersect", "∩")
    Otherwise if from_style is equal to "latex":
        Let result be result.replace("\\in", "∈")
        Let result be result.replace("\\subset", "⊂")
        Let result be result.replace("\\cup", "∪")
        Let result be result.replace("\\cap", "∩")
        Let result be result.replace("\\emptyset", "∅")
        Let result be result.replace("\\mathbb{N}", "ℕ")
        Let result be result.replace("\\mathbb{Z}", "ℤ")
        Let result be result.replace("\\mathbb{Q}", "ℚ")
        Let result be result.replace("\\mathbb{R}", "ℝ")
        Let result be result.replace("\\mathbb{C}", "ℂ")
    
    Note: Then convert to target style
    If to_style is equal to "ascii":
        Let result be result.replace("∈", " in ")
        Let result be result.replace("⊂", " subset ")
        Let result be result.replace("∪", " union ")
        Let result be result.replace("∩", " intersect ")
        Let result be result.replace("∅", "{}")
    Otherwise if to_style is equal to "latex":
        Return format_set_expression(result, "latex")
    
    Return result

Process called "benchmark_symbol_operations" that takes operation_types as List[String], test_symbols as List[String] returns Dictionary[String, Float]:
    Note: Benchmark performance of set symbol operations
    Let results be {}
    Let iterations be 1000
    
    Let op_idx be 0
    While op_idx is less than operation_types.length():
        Let operation be operation_types[op_idx]
        Let start_time be TimeInstant.current_instant()
        
        Let iter be 0
        While iter is less than iterations:
            If operation is equal to "membership":
                Let _ be element_of_symbol()
            Otherwise if operation is equal to "inclusion":
                Let _ be subset_symbol()
            Otherwise if operation is equal to "operations":
                Let _ be union_symbol()
            Otherwise if operation is equal to "quantifiers":
                Let _ be universal_quantifier_symbol()
            Otherwise if operation is equal to "validation":
                Let sym_idx be 0
                While sym_idx is less than test_symbols.length():
                    Let _ be validate_set_notation(test_symbols[sym_idx])
                    Let sym_idx be sym_idx plus 1
            Let iter be iter plus 1
        
        Let end_time be TimeInstant.current_instant()
        Let duration be TimeInstant.duration_between(start_time, end_time)
        Set results[operation] to duration
        Let op_idx be op_idx plus 1
    
    Return results