Note:
math/symbols/calculus_symbols.runa
Calculus and Analysis Mathematical Symbols

This module provides comprehensive calculus symbol handling including:
- Differential operators (∂, d, ∇, ∆, δ)
- Integral symbols (∫, ∬, ∭, ∮, ∯, ∰)
- Limit notation (lim, →, ∞)
- Summation and product symbols (∑, ∏)
- Vector calculus operators (∇, ∆, ∂, ×, ·)
- Taylor series and expansion symbols
- Convergence and divergence notation
- Infinity symbols and their variants
- Epsilon-delta notation symbols
- Function composition operators
- Derivative notation variants
- Integration bounds and limits
- Series convergence symbols
- Asymptotic notation symbols (O, o, Θ, Ω)
- Real analysis symbols and notation
:End Note

Import module "dev/debug/errors/core" as Errors

Note: =====================================================================
Note: CALCULUS SYMBOL DATA STRUCTURES
Note: =====================================================================

Type called "CalculusSymbol":
    symbol_character as String
    symbol_name as String
    unicode_codepoint as String
    mathematical_meaning as String
    usage_context as String
    operator_type as String
    precedence as Integer

Type called "DifferentialOperator":
    operator_symbol as String
    operator_name as String
    operator_type as String
    variable_type as String
    notation_variants as List[String]
    usage_examples as List[String]

Type called "IntegralSymbol":
    integral_symbol as String
    integral_type as String
    dimension as Integer
    contour_type as String
    bounds_required as Boolean
    measure_type as String

Type called "LimitSymbol":
    limit_symbol as String
    limit_type as String
    approach_direction as String
    infinity_type as String
    notation_style as String

Note: =====================================================================
Note: DIFFERENTIAL OPERATOR OPERATIONS
Note: =====================================================================

Process called "get_differential_operators" that returns List[DifferentialOperator]:
    Note: Get differential operators (∂, d, ∇, ∆, δ)
    
    Let operators be []
    
    Note: Partial derivative operator
    Let partial_op be {
        "operator_symbol": "∂",
        "operator_name": "partial derivative",
        "operator_type": "differential",
        "variable_type": "multivariable",
        "notation_variants": ["∂", "∂f/∂x", "∂²f/∂x²", "∂ⁿf/∂xⁿ"],
        "usage_examples": ["∂f/∂x", "∂²u/∂x∂y", "∂ₓ", "∂/∂x"]
    }
    Set operators to List.append(operators, partial_op)
    
    Note: Total derivative operator
    Let total_op be {
        "operator_symbol": "d",
        "operator_name": "total derivative",
        "operator_type": "differential",
        "variable_type": "univariate",
        "notation_variants": ["d", "df/dx", "d²f/dx²", "dⁿf/dxⁿ"],
        "usage_examples": ["df/dx", "d²y/dt²", "dy", "dx"]
    }
    Set operators to List.append(operators, total_op)
    
    Note: Nabla operator (gradient, divergence, curl)
    Let nabla_op be {
        "operator_symbol": "∇",
        "operator_name": "nabla",
        "operator_type": "vector_differential",
        "variable_type": "vector",
        "notation_variants": ["∇", "∇f", "∇·", "∇×", "grad", "div", "curl"],
        "usage_examples": ["∇f", "∇·F", "∇×F", "∇²f"]
    }
    Set operators to List.append(operators, nabla_op)
    
    Note: Laplacian operator
    Let laplacian_op be {
        "operator_symbol": "∆",
        "operator_name": "Laplacian",
        "operator_type": "second_order_differential",
        "variable_type": "scalar_field",
        "notation_variants": ["∆", "∇²", "∇·∇", "Δ"],
        "usage_examples": ["∆f", "∇²u", "∂²u/∂x² plus ∂²u/∂y²"]
    }
    Set operators to List.append(operators, laplacian_op)
    
    Note: Delta variation operator
    Let delta_op be {
        "operator_symbol": "δ",
        "operator_name": "variation",
        "operator_type": "variational",
        "variable_type": "functional",
        "notation_variants": ["δ", "δF", "δS", "δI"],
        "usage_examples": ["δF/δf", "δS", "δI[f]"]
    }
    Set operators to List.append(operators, delta_op)
    
    Return operators

Process called "partial_derivative_symbol" that returns DifferentialOperator:
    Note: Get partial derivative symbol (∂)
    
    Return {
        "operator_symbol": "∂",
        "operator_name": "partial derivative",
        "operator_type": "differential",
        "variable_type": "multivariable",
        "notation_variants": ["∂", "∂f/∂x", "∂²f/∂x²", "∂ⁿf/∂xⁿ", "∂ₓ", "∂/∂x"],
        "usage_examples": ["∂f/∂x", "∂²u/∂x∂y", "∂u/∂t", "∂²f/∂x²"]
    }

Process called "total_derivative_symbol" that returns DifferentialOperator:
    Note: Get total derivative symbol (d)
    
    Return {
        "operator_symbol": "d",
        "operator_name": "total derivative",
        "operator_type": "differential",
        "variable_type": "univariate",
        "notation_variants": ["d", "df/dx", "d²f/dx²", "dⁿf/dxⁿ", "D", "d/dx"],
        "usage_examples": ["df/dx", "d²y/dt²", "dy/dx", "d³f/dx³"]
    }

Process called "nabla_operator" that returns DifferentialOperator:
    Note: Get nabla operator (∇) for gradient, divergence, curl
    
    Return {
        "operator_symbol": "∇",
        "operator_name": "nabla",
        "operator_type": "vector_differential",
        "variable_type": "vector",
        "notation_variants": ["∇", "∇f", "∇·F", "∇×F", "grad", "div", "curl", "rot"],
        "usage_examples": ["∇f", "∇·F", "∇×F", "∇²f", "grad f", "div F", "curl F"]
    }

Process called "laplacian_operator" that returns DifferentialOperator:
    Note: Get Laplacian operator (∆ or ∇²)
    
    Return {
        "operator_symbol": "∆",
        "operator_name": "Laplacian",
        "operator_type": "second_order_differential",
        "variable_type": "scalar_field",
        "notation_variants": ["∆", "∇²", "∇·∇", "Δ", "∆f", "∇²f"],
        "usage_examples": ["∆f", "∇²u", "∂²u/∂x² plus ∂²u/∂y²", "∆φ is equal to 0"]
    }

Process called "delta_operator" that returns DifferentialOperator:
    Note: Get delta operator (δ) for variations and functionals
    
    Return {
        "operator_symbol": "δ",
        "operator_name": "delta operator",
        "operator_type": "variational",
        "variable_type": "functional",
        "notation_variants": ["δ", "δF", "δF/δf", "δS", "δL"],
        "usage_examples": ["δF/δf", "δS is equal to 0", "δL/δq", "δ∫F dx"]
    }

Process called "jacobian_symbol" that returns CalculusSymbol:
    Note: Get Jacobian symbol (J or ∂(x,y)/∂(u,v))
    
    Return {
        "symbol": "J",
        "symbol_name": "Jacobian",
        "symbol_type": "matrix_operator",
        "mathematical_domain": "multivariable_calculus",
        "notation_variants": ["J", "∂(x,y)/∂(u,v)", "∂(f₁,...,fₙ)/∂(x₁,...,xₙ)", "Df", "J_f"],
        "usage_examples": ["J is equal to ∂(x,y)/∂(u,v)", "det(J)", "J_f(x)", "∇f"],
        "properties": {
            "determinant_meaning": "volume scaling factor",
            "matrix_dimensions": "n×n for n variables",
            "chain_rule": "J(g∘f) is equal to J(g)·J(f)"
        }
    }

Note: =====================================================================
Note: INTEGRAL SYMBOL OPERATIONS
Note: =====================================================================

Process called "get_integral_symbols" that returns List[IntegralSymbol]:
    Note: Get integral symbols (∫, ∬, ∭, ∮, ∯, ∰)
    Let symbols be []
    
    Note: Single integral
    Let single_integral be {
        "symbol": "∫",
        "symbol_name": "integral",
        "integral_type": "single",
        "dimension": 1,
        "notation_variants": ["∫", "∫f(x)dx", "∫[a,b]f(x)dx", "∫_{a}^{b}f(x)dx"],
        "usage_examples": ["∫x dx", "∫₀¹ x² dx", "∫f(x)dx", "∫sin(x)dx"]
    }
    Let symbols be List.append(symbols, single_integral)
    
    Note: Double integral
    Let double_integral be {
        "symbol": "∬",
        "symbol_name": "double integral",
        "integral_type": "double",
        "dimension": 2,
        "notation_variants": ["∬", "∬f(x,y)dxdy", "∬[D]f(x,y)dA", "∫∫f(x,y)dxdy"],
        "usage_examples": ["∬xy dxdy", "∬_D f(x,y)dA", "∬R f(x,y)dxdy", "∬sin(xy)dxdy"]
    }
    Let symbols be List.append(symbols, double_integral)
    
    Note: Triple integral
    Let triple_integral be {
        "symbol": "∭",
        "symbol_name": "triple integral",
        "integral_type": "triple",
        "dimension": 3,
        "notation_variants": ["∭", "∭f(x,y,z)dxdydz", "∭[V]f(x,y,z)dV", "∫∫∫f(x,y,z)dxdydz"],
        "usage_examples": ["∭xyz dxdydz", "∭_V ρ dV", "∭E f(x,y,z)dV", "∭1 dxdydz"]
    }
    Let symbols be List.append(symbols, triple_integral)
    
    Note: Contour integral
    Let contour_integral be {
        "symbol": "∮",
        "symbol_name": "contour integral",
        "integral_type": "contour",
        "dimension": 1,
        "notation_variants": ["∮", "∮_C f(z)dz", "∮[C]f·dr", "∮f(z)dz"],
        "usage_examples": ["∮_C z dz", "∮F·dr", "∮_γ f(z)dz", "∮|z|=1 1/z dz"]
    }
    Let symbols be List.append(symbols, contour_integral)
    
    Note: Surface integral
    Let surface_integral be {
        "symbol": "∯",
        "symbol_name": "surface integral",
        "integral_type": "surface",
        "dimension": 2,
        "notation_variants": ["∯", "∯_S F·dS", "∯[S]f dS", "∬_S f(x,y,z)dS"],
        "usage_examples": ["∯_S F·n dS", "∯F·dS", "∯_∂V F·n dS", "∯S f dS"]
    }
    Let symbols be List.append(symbols, surface_integral)
    
    Note: Volume integral
    Let volume_integral be {
        "symbol": "∰",
        "symbol_name": "volume integral",
        "integral_type": "volume",
        "dimension": 3,
        "notation_variants": ["∰", "∰_V F·dV", "∰[V]f dV", "∭_V f(x,y,z)dV"],
        "usage_examples": ["∰_V ∇·F dV", "∰F·dV", "∰_Ω f dV", "∰V ρ dV"]
    }
    Let symbols be List.append(symbols, volume_integral)
    
    Return symbols

Process called "single_integral_symbol" that returns IntegralSymbol:
    Note: Get single integral symbol (∫)
    
    Return {
        "symbol": "∫",
        "symbol_name": "integral",
        "integral_type": "single",
        "dimension": 1,
        "notation_variants": ["∫", "∫f(x)dx", "∫[a,b]f(x)dx", "∫_{a}^{b}f(x)dx", "∫^b_a f(x)dx"],
        "usage_examples": ["∫x dx is equal to x²/2 plus C", "∫₀¹ x² dx is equal to 1/3", "∫f(x)dx", "∫sin(x)dx is equal to -cos(x) plus C"],
        "properties": {
            "linearity": "∫(af plus bg)dx is equal to a∫f dx plus b∫g dx",
            "fundamental_theorem": "d/dx ∫f(t)dt is equal to f(x)",
            "integration_by_parts": "∫u dv is equal to uv minus ∫v du",
            "substitution": "∫f(g(x))g'(x)dx is equal to ∫f(u)du where u=g(x)"
        }
    }

Process called "double_integral_symbol" that returns IntegralSymbol:
    Note: Get double integral symbol (∬)
    
    Return {
        "symbol": "∬",
        "symbol_name": "double integral",
        "integral_type": "double",
        "dimension": 2,
        "notation_variants": ["∬", "∬f(x,y)dxdy", "∬[D]f(x,y)dA", "∫∫f(x,y)dxdy", "∬_D f dA"],
        "usage_examples": ["∬xy dxdy", "∬_D f(x,y)dA", "∬_R (x²+y²)dxdy", "∬1 dxdy is equal to Area(D)"],
        "properties": {
            "fubini_theorem": "∬_D f(x,y)dA is equal to ∫_a^b ∫_{g₁(x)}^{g₂(x)} f(x,y)dy dx",
            "change_of_variables": "∬_D f(x,y)dxdy is equal to ∬_D* f(x(u,v),y(u,v))|J|dudv",
            "polar_coordinates": "∬_D f(x,y)dxdy is equal to ∬_D* f(r cos θ, r sin θ) r dr dθ",
            "geometric_meaning": "volume under surface z is equal to f(x,y)"
        }
    }

Process called "triple_integral_symbol" that returns IntegralSymbol:
    Note: Get triple integral symbol (∭)
    
    Return {
        "symbol": "∭",
        "symbol_name": "triple integral",
        "integral_type": "triple",
        "dimension": 3,
        "notation_variants": ["∭", "∭f(x,y,z)dxdydz", "∭[V]f(x,y,z)dV", "∫∫∫f(x,y,z)dxdydz", "∭_V f dV"],
        "usage_examples": ["∭xyz dxdydz", "∭_V ρ(x,y,z) dV", "∭_E 1 dV is equal to Volume(E)", "∭(x²+y²+z²)dV"],
        "properties": {
            "fubini_theorem": "∭_V f(x,y,z)dV is equal to ∫∫∫ f(x,y,z)dz dy dx",
            "cylindrical_coordinates": "∭_V f dV is equal to ∭ f(r cos θ, r sin θ, z) r dr dθ dz",
            "spherical_coordinates": "∭_V f dV is equal to ∭ f(ρ sin φ cos θ, ρ sin φ sin θ, ρ cos φ) ρ² sin φ dρ dφ dθ",
            "geometric_meaning": "integral over 3D region",
            "mass_calculation": "mass is equal to ∭_V ρ(x,y,z) dV"
        }
    }

Process called "contour_integral_symbol" that returns IntegralSymbol:
    Note: Get contour integral symbol (∮)
    
    Return {
        "symbol": "∮",
        "symbol_name": "contour integral",
        "integral_type": "contour",
        "dimension": 1,
        "notation_variants": ["∮", "∮_C f(z)dz", "∮[C]F·dr", "∮f(z)dz", "∮_γ f dz"],
        "usage_examples": ["∮_C z dz", "∮F·dr", "∮_|z|=1 1/z dz is equal to 2πi", "∮_γ f(z)dz"],
        "properties": {
            "cauchys_theorem": "∮_C f(z)dz is equal to 0 if f is analytic inside C",
            "residue_theorem": "∮_C f(z)dz is equal to 2πi Σ Res(f,zₖ)",
            "independence_of_path": "depends only on endpoints for conservative fields",
            "greens_theorem": "∮_C P dx plus Q dy is equal to ∬_D (∂Q/∂x minus ∂P/∂y) dA",
            "line_integral": "∮_C F·dr is equal to ∮_C F·T ds"
        }
    }

Process called "surface_integral_symbol" that returns IntegralSymbol:
    Note: Get surface integral symbol (∯)
    
    Return {
        "symbol": "∯",
        "symbol_name": "surface integral",
        "integral_type": "surface",
        "dimension": 2,
        "notation_variants": ["∯", "∯_S F·dS", "∯[S]f dS", "∬_S f(x,y,z)dS", "∯_S F·n dS"],
        "usage_examples": ["∯_S F·n dS", "∯F·dS", "∯_∂V F·dS", "∯_S z dS"],
        "properties": {
            "divergence_theorem": "∯_∂V F·n dS is equal to ∭_V ∇·F dV",
            "flux_calculation": "flux is equal to ∯_S F·n dS",
            "parametric_surface": "∯_S f dS is equal to ∬_D f(r(u,v)) |rᵤ × rᵥ| du dv",
            "scalar_surface_integral": "∯_S f dS is equal to surface integral of scalar field",
            "vector_surface_integral": "∯_S F·dS is equal to flux through surface S"
        }
    }

Process called "volume_integral_symbol" that returns IntegralSymbol:
    Note: Get volume integral symbol (∰)
    
    Return {
        "symbol": "∰",
        "symbol_name": "volume integral",
        "integral_type": "volume",
        "dimension": 3,
        "notation_variants": ["∰", "∰_V F·dV", "∰[V]f dV", "∭_V f(x,y,z)dV", "∰_Ω f dV"],
        "usage_examples": ["∰_V ∇·F dV", "∰F·dV", "∰_Ω ρ dV", "∰_V div(F) dV"],
        "properties": {
            "divergence_theorem_usage": "∰_V ∇·F dV is equal to ∯_∂V F·n dS",
            "mass_center_calculation": "center of mass uses ∰_V ρr dV",
            "moment_of_inertia": "I is equal to ∰_V ρr² dV",
            "equivalent_to_triple": "∰_V f dV ≡ ∭_V f(x,y,z) dxdydz",
            "physical_meaning": "total quantity over 3D region"
        }
    }

Note: =====================================================================
Note: LIMIT NOTATION OPERATIONS
Note: =====================================================================

Process called "get_limit_symbols" that returns List[LimitSymbol]:
    Note: Get limit notation symbols (lim, →, ∞, ±∞)
    Let symbols be []
    
    Note: Limit symbol
    Let limit_sym be {
        "symbol": "lim",
        "symbol_name": "limit",
        "notation_type": "limit_operator",
        "usage_context": "function_limits",
        "notation_variants": ["lim", "lim_{x→a}", "lim_{x→a⁺}", "lim_{x→a⁻}", "lim_{x→∞}"],
        "usage_examples": ["lim_{x→0} sin(x)/x is equal to 1", "lim_{x→∞} 1/x is equal to 0", "lim_{x→2} (x²-4)/(x-2) is equal to 4"]
    }
    Let symbols be List.append(symbols, limit_sym)
    
    Note: Approaches symbol
    Let approaches_sym be {
        "symbol": "→",
        "symbol_name": "approaches",
        "notation_type": "direction_indicator",
        "usage_context": "limit_direction",
        "notation_variants": ["→", "→⁺", "→⁻", "↗", "↘"],
        "usage_examples": ["x→a", "x→∞", "x→0⁺", "x→0⁻"]
    }
    Let symbols be List.append(symbols, approaches_sym)
    
    Note: Infinity symbol
    Let infinity_sym be {
        "symbol": "∞",
        "symbol_name": "infinity",
        "notation_type": "infinity_notation",
        "usage_context": "infinite_limits",
        "notation_variants": ["∞", "+∞", "-∞", "±∞"],
        "usage_examples": ["lim_{x→∞} f(x)", "∫₋∞^∞ f(x)dx", "[0,∞)"]
    }
    Let symbols be List.append(symbols, infinity_sym)
    
    Note: Plus infinity symbol
    Let plus_infinity_sym be {
        "symbol": "+∞",
        "symbol_name": "plus infinity",
        "notation_type": "positive_infinity",
        "usage_context": "positive_infinite_limits",
        "notation_variants": ["+∞", "∞", "lim_{x→+∞}"],
        "usage_examples": ["lim_{x→+∞} eˣ is equal to +∞", "∫₀^{+∞} e^{-x}dx"]
    }
    Let symbols be List.append(symbols, plus_infinity_sym)
    
    Note: Minus infinity symbol
    Let minus_infinity_sym be {
        "symbol": "-∞",
        "symbol_name": "minus infinity",
        "notation_type": "negative_infinity",
        "usage_context": "negative_infinite_limits",
        "notation_variants": ["-∞", "lim_{x→-∞}"],
        "usage_examples": ["lim_{x→-∞} eˣ is equal to 0", "∫_{-∞}^0 e^x dx"]
    }
    Let symbols be List.append(symbols, minus_infinity_sym)
    
    Return symbols

Process called "limit_symbol" that returns LimitSymbol:
    Note: Get limit symbol (lim)
    
    Return {
        "symbol": "lim",
        "symbol_name": "limit",
        "notation_type": "limit_operator",
        "usage_context": "function_limits",
        "notation_variants": ["lim", "lim_{x→a}", "lim_{x→a⁺}", "lim_{x→a⁻}", "lim_{x→∞}", "lim_{n→∞}"],
        "usage_examples": ["lim_{x→0} sin(x)/x is equal to 1", "lim_{x→∞} 1/x is equal to 0", "lim_{x→2} (x²-4)/(x-2) is equal to 4", "lim_{n→∞} (1+1/n)ⁿ is equal to e"],
        "properties": {
            "linearity": "lim[af(x) plus bg(x)] is equal to a·lim f(x) plus b·lim g(x)",
            "product_rule": "lim[f(x)·g(x)] is equal to lim f(x) · lim g(x)",
            "quotient_rule": "lim[f(x)/g(x)] is equal to lim f(x) / lim g(x) if lim g(x) ≠ 0",
            "squeeze_theorem": "if g(x) ≤ f(x) ≤ h(x) and lim g(x) is equal to lim h(x) is equal to L, then lim f(x) is equal to L"
        }
    }

Process called "approaches_symbol" that returns LimitSymbol:
    Note: Get approaches symbol (→)
    
    Return {
        "symbol": "→",
        "symbol_name": "approaches",
        "notation_type": "direction_indicator",
        "usage_context": "limit_direction",
        "notation_variants": ["→", "→⁺", "→⁻", "↗", "↘", "⟶"],
        "usage_examples": ["x→a", "x→∞", "x→0⁺", "x→0⁻", "(x,y)→(a,b)"],
        "properties": {
            "right_approach": "x→a⁺ means x approaches a from the right",
            "left_approach": "x→a⁻ means x approaches a from the left",
            "two_sided": "x→a means both one-sided limits exist and are equal",
            "multivariable": "(x,y)→(a,b) indicates approach in multiple dimensions"
        }
    }

Process called "infinity_symbol" that returns LimitSymbol:
    Note: Get infinity symbol (∞)
    
    Return {
        "symbol": "∞",
        "symbol_name": "infinity",
        "notation_type": "infinity_notation",
        "usage_context": "infinite_limits",
        "notation_variants": ["∞", "+∞", "-∞", "±∞", "∞"],
        "usage_examples": ["lim_{x→∞} 1/x is equal to 0", "∫₋∞^∞ e^{-x²}dx is equal to √π", "[0,∞)", "∞ plus 1 is equal to ∞"],
        "properties": {
            "not_a_number": "∞ is a concept, not a real number",
            "arithmetic_rules": "a plus ∞ is equal to ∞ for any finite a, but ∞ minus ∞ is indeterminate",
            "comparison": "∞ is greater than a for any finite real number a",
            "extended_reals": "∞ is an element of the extended real line [-∞, +∞]"
        }
    }

Process called "plus_infinity_symbol" that returns LimitSymbol:
    Note: Get plus infinity symbol (+∞)
    
    Return {
        "symbol": "+∞",
        "symbol_name": "plus infinity",
        "notation_type": "positive_infinity",
        "usage_context": "positive_infinite_limits",
        "notation_variants": ["+∞", "∞", "lim_{x→+∞}", "∞⁺"],
        "usage_examples": ["lim_{x→+∞} eˣ is equal to +∞", "∫₀^{+∞} e^{-x}dx is equal to 1", "f(x) → +∞ as x → 0⁺"],
        "properties": {
            "positive_direction": "indicates unbounded growth in positive direction",
            "exponential_growth": "typical for exponential functions as x→+∞",
            "improper_integrals": "used in defining convergence of improper integrals",
            "vertical_asymptotes": "describes behavior near vertical asymptotes"
        }
    }

Process called "minus_infinity_symbol" that returns LimitSymbol:
    Note: Get minus infinity symbol (−∞)
    
    Return {
        "symbol": "-∞",
        "symbol_name": "minus infinity",
        "notation_type": "negative_infinity",
        "usage_context": "negative_infinite_limits",
        "notation_variants": ["-∞", "lim_{x→-∞}", "∞⁻"],
        "usage_examples": ["lim_{x→-∞} eˣ is equal to 0", "lim_{x→0⁺} ln(x) is equal to -∞", "∫_{-∞}^0 e^x dx is equal to 1"],
        "properties": {
            "negative_direction": "indicates unbounded growth in negative direction",
            "logarithmic_limits": "common for logarithmic functions near domain boundaries",
            "improper_integrals": "used in defining convergence over infinite intervals",
            "asymptotic_behavior": "describes left-hand infinite behavior"
        }
    }

Process called "right_limit_symbol" that returns LimitSymbol:
    Note: Get right limit symbol (→⁺)
    
    Return {
        "symbol": "→⁺",
        "symbol_name": "right limit",
        "notation_type": "one_sided_limit",
        "usage_context": "right_hand_limits",
        "notation_variants": ["→⁺", "→₊", "→ from right", "→ʳ"],
        "usage_examples": ["lim_{x→0⁺} 1/x is equal to +∞", "lim_{x→a⁺} f(x)", "x→2⁺"],
        "properties": {
            "direction": "approaches from values greater than the target",
            "discontinuity_detection": "used to detect jump discontinuities",
            "asymptote_analysis": "essential for analyzing vertical asymptotes",
            "existence_condition": "limit exists iff both one-sided limits exist and are equal"
        }
    }

Process called "left_limit_symbol" that returns LimitSymbol:
    Note: Get left limit symbol (→⁻)
    
    Return {
        "symbol": "→⁻",
        "symbol_name": "left limit",
        "notation_type": "one_sided_limit",
        "usage_context": "left_hand_limits",
        "notation_variants": ["→⁻", "→₋", "→ from left", "→ˡ"],
        "usage_examples": ["lim_{x→0⁻} 1/x is equal to -∞", "lim_{x→a⁻} f(x)", "x→2⁻"],
        "properties": {
            "direction": "approaches from values less than the target",
            "discontinuity_detection": "used to detect jump discontinuities",
            "asymptote_analysis": "essential for analyzing vertical asymptotes",
            "existence_condition": "two-sided limit exists iff both one-sided limits exist and are equal"
        }
    }

Note: =====================================================================
Note: SUMMATION AND PRODUCT OPERATIONS
Note: =====================================================================

Process called "get_summation_symbols" that returns List[CalculusSymbol]:
    Note: Get summation symbols (∑, ∏, ⋃, ⋂)
    Let symbols be []
    
    Note: Summation symbol
    Let summation_sym be {
        "symbol": "∑",
        "symbol_name": "summation",
        "symbol_type": "iterative_operator",
        "mathematical_domain": "discrete_mathematics",
        "notation_variants": ["∑", "∑_{i=1}^n", "∑_{i=a}^b f(i)", "Σ"],
        "usage_examples": ["∑_{i=1}^n i is equal to n(n+1)/2", "∑_{i=0}^∞ x^i is equal to 1/(1-x)", "∑_{k=1}^n k²"]
    }
    Let symbols be List.append(symbols, summation_sym)
    
    Note: Product symbol
    Let product_sym be {
        "symbol": "∏",
        "symbol_name": "product",
        "symbol_type": "iterative_operator",
        "mathematical_domain": "discrete_mathematics",
        "notation_variants": ["∏", "∏_{i=1}^n", "∏_{i=a}^b f(i)", "Π"],
        "usage_examples": ["∏_{i=1}^n i is equal to n!", "∏_{i=1}^n (1+x_i)", "∏_{k=2}^n (1-1/k²)"]
    }
    Let symbols be List.append(symbols, product_sym)
    
    Note: Coproduct symbol
    Let coproduct_sym be {
        "symbol": "∐",
        "symbol_name": "coproduct",
        "symbol_type": "iterative_operator",
        "mathematical_domain": "category_theory",
        "notation_variants": ["∐", "∐_{i}", "∐_{i=1}^n"],
        "usage_examples": ["∐_i X_i", "∐_{i=1}^n A_i"]
    }
    Let symbols be List.append(symbols, coproduct_sym)
    
    Note: Big union symbol
    Let big_union_sym be {
        "symbol": "⋃",
        "symbol_name": "big union",
        "symbol_type": "set_operation",
        "mathematical_domain": "set_theory",
        "notation_variants": ["⋃", "⋃_{i=1}^n", "⋃_{i∈I} A_i", "⋃_i"],
        "usage_examples": ["⋃_{i=1}^n A_i", "⋃_{i∈ℕ} [i, i+1)", "⋃_{x∈X} f(x)"]
    }
    Let symbols be List.append(symbols, big_union_sym)
    
    Note: Big intersection symbol
    Let big_intersection_sym be {
        "symbol": "⋂",
        "symbol_name": "big intersection",
        "symbol_type": "set_operation",
        "mathematical_domain": "set_theory",
        "notation_variants": ["⋂", "⋂_{i=1}^n", "⋂_{i∈I} A_i", "⋂_i"],
        "usage_examples": ["⋂_{i=1}^n A_i", "⋂_{n=1}^∞ (0,1/n)", "⋂_{x∈X} f(x)"]
    }
    Let symbols be List.append(symbols, big_intersection_sym)
    
    Return symbols

Process called "summation_symbol" that returns CalculusSymbol:
    Note: Get summation symbol (∑)
    
    Return {
        "symbol": "∑",
        "symbol_name": "summation",
        "symbol_type": "iterative_operator",
        "mathematical_domain": "discrete_mathematics",
        "notation_variants": ["∑", "∑_{i=1}^n", "∑_{i=a}^b f(i)", "Σ", "∑_{i}", "∑_{k=0}^∞"],
        "usage_examples": ["∑_{i=1}^n i is equal to n(n+1)/2", "∑_{i=0}^∞ x^i is equal to 1/(1-x) for |x|<1", "∑_{k=1}^n k² is equal to n(n+1)(2n+1)/6", "∑_{n=1}^∞ 1/n² is equal to π²/6"],
        "properties": {
            "linearity": "∑(af_i plus bg_i) is equal to a∑f_i plus b∑g_i",
            "telescoping": "∑_{i=1}^n (a_i minus a_{i+1}) is equal to a_1 minus a_{n+1}",
            "index_shifting": "∑_{i=m}^n f(i) is equal to ∑_{j=0}^{n-m} f(j+m)",
            "geometric_series": "∑_{k=0}^{n-1} r^k is equal to (1-r^n)/(1-r) for r≠1"
        }
    }

Process called "product_symbol" that returns CalculusSymbol:
    Note: Get product symbol (∏)
    
    Return {
        "symbol": "∏",
        "symbol_name": "product",
        "symbol_type": "iterative_operator",
        "mathematical_domain": "discrete_mathematics",
        "notation_variants": ["∏", "∏_{i=1}^n", "∏_{i=a}^b f(i)", "Π", "∏_{i}", "∏_{k=0}^∞"],
        "usage_examples": ["∏_{i=1}^n i is equal to n!", "∏_{i=1}^n (1+x_i)", "∏_{k=2}^n (1-1/k²) is equal to (n+1)/(2n)", "∏_{p prime} (1-1/p)⁻¹"],
        "properties": {
            "multiplicativity": "∏(f_i · g_i) is equal to (∏ f_i) · (∏ g_i)",
            "factorization": "∏_{i=1}^n i is equal to n!",
            "telescoping": "∏_{i=1}^n (a_i/a_{i+1}) is equal to a_1/a_{n+1}",
            "logarithmic_relation": "ln(∏ a_i) is equal to ∑ ln(a_i)"
        }
    }

Process called "coproduct_symbol" that returns CalculusSymbol:
    Note: Get coproduct symbol (∐)
    
    Return {
        "symbol": "∐",
        "symbol_name": "coproduct",
        "symbol_type": "iterative_operator",
        "mathematical_domain": "category_theory",
        "notation_variants": ["∐", "∐_{i}", "∐_{i=1}^n", "∐_{i∈I} A_i"],
        "usage_examples": ["∐_i X_i", "∐_{i=1}^n A_i", "∐_{i∈I} ℤ/n_iℤ"],
        "properties": {
            "categorical_dual": "dual to the product in category theory",
            "disjoint_union": "often represents disjoint union of sets",
            "free_product": "represents free products in algebra",
            "universal_property": "satisfies universal property for coproducts"
        }
    }

Process called "big_union_symbol" that returns CalculusSymbol:
    Note: Get big union symbol (⋃)
    
    Return {
        "symbol": "⋃",
        "symbol_name": "big union",
        "symbol_type": "set_operation",
        "mathematical_domain": "set_theory",
        "notation_variants": ["⋃", "⋃_{i=1}^n", "⋃_{i∈I} A_i", "⋃_i", "⋃_{i=1}^∞ A_i"],
        "usage_examples": ["⋃_{i=1}^n A_i", "⋃_{i∈ℕ} [i, i+1) is equal to [1,∞)", "⋃_{n=1}^∞ (0, 1-1/n) is equal to (0,1)", "⋃_{x∈X} B(x,r)"],
        "properties": {
            "associativity": "⋃(⋃ A_{i,j}) is equal to ⋃_{(i,j)} A_{i,j}",
            "commutativity": "order of indexing doesn't matter",
            "monotonicity": "if A_i ⊆ B_i for all i, then ⋃A_i ⊆ ⋃B_i",
            "distributivity": "A ∩ (⋃_i B_i) is equal to ⋃_i (A ∩ B_i)"
        }
    }

Process called "big_intersection_symbol" that returns CalculusSymbol:
    Note: Get big intersection symbol (⋂)
    
    Return {
        "symbol": "⋂",
        "symbol_name": "big intersection",
        "symbol_type": "set_operation",
        "mathematical_domain": "set_theory",
        "notation_variants": ["⋂", "⋂_{i=1}^n", "⋂_{i∈I} A_i", "⋂_i", "⋂_{i=1}^∞ A_i"],
        "usage_examples": ["⋂_{i=1}^n A_i", "⋂_{n=1}^∞ (0,1/n) is equal to ∅", "⋂_{n=1}^∞ [-n,n] is equal to ℝ", "⋂_{x∈X} f^{-1}(U_x)"],
        "properties": {
            "associativity": "⋂(⋂ A_{i,j}) is equal to ⋂_{(i,j)} A_{i,j}",
            "commutativity": "order of indexing doesn't matter",
            "monotonicity": "if A_i ⊆ B_i for all i, then ⋂A_i ⊆ ⋂B_i",
            "distributivity": "A ⋃ (⋂_i B_i) is equal to ⋂_i (A ⋃ B_i)"
        }
    }

Note: =====================================================================
Note: VECTOR CALCULUS OPERATIONS
Note: =====================================================================

Process called "get_vector_operators" that returns List[CalculusSymbol]:
    Note: Get vector calculus operators (∇, ∆, ×, ·, ⊗)
    Let operators be []
    
    Note: Gradient operator
    Let gradient_op be {
        "symbol": "∇",
        "symbol_name": "gradient",
        "symbol_type": "vector_operator",
        "mathematical_domain": "vector_calculus",
        "notation_variants": ["∇", "∇f", "grad f", "grad", "∂f/∂x î plus ∂f/∂y ĵ plus ∂f/∂z k̂"],
        "usage_examples": ["∇f", "grad(x²+y²+z²) is equal to 2xî plus 2yĵ plus 2zk̂", "∇·F", "∇×F"]
    }
    Let operators be List.append(operators, gradient_op)
    
    Note: Cross product operator
    Let cross_product_op be {
        "symbol": "×",
        "symbol_name": "cross product",
        "symbol_type": "vector_operation",
        "mathematical_domain": "vector_algebra",
        "notation_variants": ["×", "a×b", "cross(a,b)", "∧", "wedge"],
        "usage_examples": ["a×b", "î×ĵ is equal to k̂", "∇×F", "curl F is equal to ∇×F"]
    }
    Let operators be List.append(operators, cross_product_op)
    
    Note: Dot product operator
    Let dot_product_op be {
        "symbol": "·",
        "symbol_name": "dot product",
        "symbol_type": "vector_operation",
        "mathematical_domain": "vector_algebra",
        "notation_variants": ["·", "a·b", "<a,b>", "dot(a,b)", "(a,b)"],
        "usage_examples": ["a·b", "∇·F", "div F is equal to ∇·F", "F·dr"]
    }
    Let operators be List.append(operators, dot_product_op)
    
    Note: Tensor product operator
    Let tensor_product_op be {
        "symbol": "⊗",
        "symbol_name": "tensor product",
        "symbol_type": "tensor_operation",
        "mathematical_domain": "tensor_algebra",
        "notation_variants": ["⊗", "a⊗b", "tensor(a,b)", "⊗_{R}"],
        "usage_examples": ["u⊗v", "V⊗W", "∇u⊗∇v"]
    }
    Let operators be List.append(operators, tensor_product_op)
    
    Return operators

Process called "gradient_symbol" that returns CalculusSymbol:
    Note: Get gradient symbol (∇ or grad)
    
    Return {
        "symbol": "∇",
        "symbol_name": "gradient",
        "symbol_type": "vector_operator",
        "mathematical_domain": "vector_calculus",
        "notation_variants": ["∇", "∇f", "grad f", "grad", "∂f/∂x î plus ∂f/∂y ĵ plus ∂f/∂z k̂"],
        "usage_examples": ["∇f is equal to (∂f/∂x, ∂f/∂y, ∂f/∂z)", "grad(x²+y²) is equal to (2x, 2y)", "∇T points in direction of steepest increase"],
        "properties": {
            "linearity": "∇(af plus bg) is equal to a∇f plus b∇g",
            "product_rule": "∇(fg) is equal to f∇g plus g∇f",
            "chain_rule": "∇(f∘g) is equal to (∇f)∘g · ∇g",
            "directional_derivative": "D_u f is equal to ∇f · û"
        }
    }

Process called "divergence_symbol" that returns CalculusSymbol:
    Note: Get divergence symbol (∇· or div)
    
    Return {
        "symbol": "∇·",
        "symbol_name": "divergence",
        "symbol_type": "vector_operator",
        "mathematical_domain": "vector_calculus",
        "notation_variants": ["∇·", "∇·F", "div F", "div", "∂F_x/∂x plus ∂F_y/∂y plus ∂F_z/∂z"],
        "usage_examples": ["∇·F is equal to ∂F_x/∂x plus ∂F_y/∂y plus ∂F_z/∂z", "div(xî plus yĵ plus zk̂) is equal to 3", "∇·E is equal to ρ/ε₀"],
        "properties": {
            "linearity": "∇·(aF plus bG) is equal to a(∇·F) plus b(∇·G)",
            "product_rule": "∇·(fF) is equal to f(∇·F) plus F·(∇f)",
            "divergence_theorem": "∭_V (∇·F) dV is equal to ∯_{∂V} F·n dS",
            "physical_meaning": "measures outward flux density from a point"
        }
    }

Process called "curl_symbol" that returns CalculusSymbol:
    Note: Get curl symbol (∇× or curl or rot)
    
    Return {
        "symbol": "∇×",
        "symbol_name": "curl",
        "symbol_type": "vector_operator",
        "mathematical_domain": "vector_calculus",
        "notation_variants": ["∇×", "∇×F", "curl F", "rot F", "curl", "rot"],
        "usage_examples": ["∇×F", "curl(-yî plus xĵ) is equal to 2k̂", "∇×B is equal to μ₀J", "rot F measures rotation"],
        "properties": {
            "linearity": "∇×(aF plus bG) is equal to a(∇×F) plus b(∇×G)",
            "product_rule": "∇×(fF) is equal to f(∇×F) plus (∇f)×F",
            "stokes_theorem": "∯_S (∇×F)·n dS is equal to ∮_{∂S} F·dr",
            "irrotational": "if ∇×F is equal to 0, then F is conservative"
        }
    }

Process called "cross_product_symbol" that returns CalculusSymbol:
    Note: Get cross product symbol (×)
    
    Return {
        "symbol": "×",
        "symbol_name": "cross product",
        "symbol_type": "vector_operation",
        "mathematical_domain": "vector_algebra",
        "notation_variants": ["×", "a×b", "cross(a,b)", "∧", "a ∧ b"],
        "usage_examples": ["a×b is equal to |a||b|sin(θ)n̂", "î×ĵ is equal to k̂", "(2,1,0)×(1,3,0) is equal to (0,0,5)", "F is equal to q(v×B)"],
        "properties": {
            "anticommutativity": "a×b is equal to -(b×a)",
            "distributivity": "a×(b+c) is equal to a×b plus a×c",
            "scalar_multiplication": "(ka)×b is equal to k(a×b)",
            "geometric_meaning": "|a×b| is equal to area of parallelogram spanned by a and b"
        }
    }

Process called "dot_product_symbol" that returns CalculusSymbol:
    Note: Get dot product symbol (·)
    
    Return {
        "symbol": "·",
        "symbol_name": "dot product",
        "symbol_type": "vector_operation",
        "mathematical_domain": "vector_algebra",
        "notation_variants": ["·", "a·b", "<a,b>", "dot(a,b)", "(a,b)", "a^T b"],
        "usage_examples": ["a·b is equal to |a||b|cos(θ)", "(3,4)·(1,2) is equal to 3+8 is equal to 11", "∇·F is equal to div F", "work is equal to F·d"],
        "properties": {
            "commutativity": "a·b is equal to b·a",
            "distributivity": "a·(b+c) is equal to a·b plus a·c",
            "scalar_multiplication": "(ka)·b is equal to k(a·b)",
            "orthogonality": "a·b is equal to 0 iff a ⊥ b",
            "norm_relation": "a·a is equal to |a|²"
        }
    }

Process called "tensor_product_symbol" that returns CalculusSymbol:
    Note: Get tensor product symbol (⊗)
    
    Return {
        "symbol": "⊗",
        "symbol_name": "tensor product",
        "symbol_type": "tensor_operation",
        "mathematical_domain": "tensor_algebra",
        "notation_variants": ["⊗", "a⊗b", "tensor(a,b)", "⊗_R", "outer product"],
        "usage_examples": ["u⊗v creates rank-2 tensor", "V⊗W tensor product of vector spaces", "∇u⊗∇v", "stress tensor σ is equal to F⊗n"],
        "properties": {
            "bilinearity": "(au₁+bu₂)⊗v is equal to a(u₁⊗v) plus b(u₂⊗v)",
            "associativity": "(u⊗v)⊗w is equal to u⊗(v⊗w)",
            "dimension_product": "dim(V⊗W) is equal to dim(V)×dim(W)",
            "matrix_representation": "u⊗v represented as outer product uv^T",
            "quantum_states": "describes composite quantum systems"
        }
    }

Note: =====================================================================
Note: SERIES AND CONVERGENCE OPERATIONS
Note: =====================================================================

Process called "get_series_symbols" that returns List[CalculusSymbol]:
    Note: Get series notation symbols (∑, ∏, ⋯, ⋮)
    Let symbols be []
    
    Note: Series ellipsis
    Let series_ellipsis be {
        "symbol": "⋯",
        "symbol_name": "series ellipsis",
        "symbol_type": "continuation_notation",
        "mathematical_domain": "series_notation",
        "notation_variants": ["⋯", "...", "…"],
        "usage_examples": ["1 plus 2 plus 3 plus ⋯ plus n", "a_1, a_2, a_3, ⋯", "1, 1/2, 1/4, ⋯"]
    }
    Let symbols be List.append(symbols, series_ellipsis)
    
    Note: Vertical ellipsis
    Let vertical_ellipsis be {
        "symbol": "⋮",
        "symbol_name": "vertical ellipsis",
        "symbol_type": "continuation_notation",
        "mathematical_domain": "matrix_notation",
        "notation_variants": ["⋮", ":", "|"],
        "usage_examples": ["matrix with ⋮", "vector [a_1, a_2, ⋮, a_n]", "column continuation"]
    }
    Let symbols be List.append(symbols, vertical_ellipsis)
    
    Note: Diagonal ellipsis
    Let diagonal_ellipsis be {
        "symbol": "⋱",
        "symbol_name": "diagonal ellipsis",
        "symbol_type": "continuation_notation",
        "mathematical_domain": "matrix_notation",
        "notation_variants": ["⋱", "\\\\...\\\\"],
        "usage_examples": ["diagonal matrix with ⋱", "a_{11}, a_{22}, ⋱, a_{nn}"]
    }
    Let symbols be List.append(symbols, diagonal_ellipsis)
    
    Note: Convergence symbol
    Let convergence_sym be {
        "symbol": "→",
        "symbol_name": "convergence",
        "symbol_type": "limit_notation",
        "mathematical_domain": "analysis",
        "notation_variants": ["→", "converges to", "⇢", "⟶"],
        "usage_examples": ["a_n → L", "f_n → f", "x_n → a as n → ∞"]
    }
    Let symbols be List.append(symbols, convergence_sym)
    
    Note: Uniform convergence symbol
    Let uniform_convergence_sym be {
        "symbol": "⇉",
        "symbol_name": "uniform convergence",
        "symbol_type": "convergence_notation",
        "mathematical_domain": "functional_analysis",
        "notation_variants": ["⇉", "→ uniformly", "⇉_{unif}"],
        "usage_examples": ["f_n ⇉ f on [a,b]", "series converges uniformly"]
    }
    Let symbols be List.append(symbols, uniform_convergence_sym)
    
    Return symbols

Process called "series_ellipsis_symbol" that returns CalculusSymbol:
    Note: Get series ellipsis symbol (⋯)
    
    Return {
        "symbol": "⋯",
        "symbol_name": "series ellipsis",
        "symbol_type": "continuation_notation",
        "mathematical_domain": "series_notation",
        "notation_variants": ["⋯", "...", "…", "and so on"],
        "usage_examples": ["1 plus 2 plus 3 plus ⋯ plus n is equal to n(n+1)/2", "a_1 plus a_2 plus a_3 plus ⋯", "1, 1/2, 1/4, 1/8, ⋯"],
        "properties": {
            "indicates_pattern": "shows continuation of established pattern",
            "finite_vs_infinite": "can indicate finite or infinite sequences",
            "context_dependent": "meaning depends on surrounding mathematical context",
            "readability": "improves readability by avoiding repetitive notation"
        }
    }

Process called "vertical_ellipsis_symbol" that returns CalculusSymbol:
    Note: Get vertical ellipsis symbol (⋮)
    
    Return {
        "symbol": "⋮",
        "symbol_name": "vertical ellipsis",
        "symbol_type": "continuation_notation",
        "mathematical_domain": "matrix_notation",
        "notation_variants": ["⋮", ":", "|", "vertical dots"],
        "usage_examples": ["matrix [a_1; a_2; ⋮; a_n]", "vector column continuation", "system of equations with ⋮"],
        "properties": {
            "vertical_continuation": "indicates continuation in vertical direction",
            "matrix_usage": "commonly used in matrices and vectors",
            "equation_systems": "used in systems of equations",
            "column_vectors": "standard notation for long column vectors"
        }
    }

Process called "diagonal_ellipsis_symbol" that returns CalculusSymbol:
    Note: Get diagonal ellipsis symbol (⋱)
    
    Return {
        "symbol": "⋱",
        "symbol_name": "diagonal ellipsis",
        "symbol_type": "continuation_notation",
        "mathematical_domain": "matrix_notation",
        "notation_variants": ["⋱", "diagonal dots", "\\\\⋯\\\\"],
        "usage_examples": ["diagonal matrix with ⋱", "a_{11}, a_{22}, ⋱, a_{nn}", "identity matrix I_n"],
        "properties": {
            "diagonal_continuation": "indicates continuation along diagonal",
            "matrix_diagonals": "used for diagonal matrices",
            "pattern_indication": "shows diagonal pattern continuation",
            "square_matrices": "primarily used in square matrix notation"
        }
    }

Process called "convergence_symbol" that returns CalculusSymbol:
    Note: Get convergence symbol (→)
    
    Return {
        "symbol": "→",
        "symbol_name": "convergence",
        "symbol_type": "limit_notation",
        "mathematical_domain": "analysis",
        "notation_variants": ["→", "converges to", "⇢", "⟶", "tends to"],
        "usage_examples": ["a_n → L as n → ∞", "f(x) → L as x → a", "∑_{n=1}^∞ a_n converges"],
        "properties": {
            "pointwise_convergence": "f_n(x) → f(x) for each x",
            "uniform_convergence": "f_n ⇉ f on domain",
            "series_convergence": "∑ a_n converges if partial sums converge",
            "epsilon_delta": "formalized using ε-δ definition"
        }
    }

Process called "uniform_convergence_symbol" that returns CalculusSymbol:
    Note: Get uniform convergence symbol (⇉)
    
    Return {
        "symbol": "⇉",
        "symbol_name": "uniform convergence",
        "symbol_type": "convergence_notation",
        "mathematical_domain": "functional_analysis",
        "notation_variants": ["⇉", "→ uniformly", "⇉_{unif}", "uniform →"],
        "usage_examples": ["f_n ⇉ f on [a,b]", "power series converges uniformly on compact sets", "Weierstrass M-test"],
        "properties": {
            "stronger_than_pointwise": "uniform convergence implies pointwise convergence",
            "preserves_continuity": "uniform limit of continuous functions is continuous",
            "interchanges_limits": "allows interchange of limit and integration/differentiation",
            "weierstrass_m_test": "sufficient condition using dominating series"
        }
    }

Note: =====================================================================
Note: ASYMPTOTIC NOTATION OPERATIONS
Note: =====================================================================

Process called "get_asymptotic_symbols" that returns List[CalculusSymbol]:
    Note: Get asymptotic notation symbols (O, o, Θ, Ω, ω)
    Let symbols be []
    
    Note: Big O notation
    Let big_o_sym be {
        "symbol": "O",
        "symbol_name": "big O",
        "symbol_type": "asymptotic_notation",
        "mathematical_domain": "complexity_analysis",
        "notation_variants": ["O", "O(g(n))", "f(n) is equal to O(g(n))", "f ∈ O(g)"],
        "usage_examples": ["f(n) is equal to O(n²)", "3n plus 5 is equal to O(n)", "O(log n)", "O(1)"]
    }
    Let symbols be List.append(symbols, big_o_sym)
    
    Note: Little o notation
    Let little_o_sym be {
        "symbol": "o",
        "symbol_name": "little o",
        "symbol_type": "asymptotic_notation",
        "mathematical_domain": "complexity_analysis",
        "notation_variants": ["o", "o(g(n))", "f(n) is equal to o(g(n))", "f ∈ o(g)"],
        "usage_examples": ["f(n) is equal to o(n²)", "n is equal to o(n²)", "o(log n)", "o(1)"]
    }
    Let symbols be List.append(symbols, little_o_sym)
    
    Note: Big Theta notation
    Let big_theta_sym be {
        "symbol": "Θ",
        "symbol_name": "big Theta",
        "symbol_type": "asymptotic_notation",
        "mathematical_domain": "complexity_analysis",
        "notation_variants": ["Θ", "Θ(g(n))", "f(n) is equal to Θ(g(n))", "f ∈ Θ(g)"],
        "usage_examples": ["f(n) is equal to Θ(n log n)", "2n² plus 3n is equal to Θ(n²)", "Θ(n!)", "Θ(2ⁿ)"]
    }
    Let symbols be List.append(symbols, big_theta_sym)
    
    Note: Big Omega notation
    Let big_omega_sym be {
        "symbol": "Ω",
        "symbol_name": "big Omega",
        "symbol_type": "asymptotic_notation",
        "mathematical_domain": "complexity_analysis",
        "notation_variants": ["Ω", "Ω(g(n))", "f(n) is equal to Ω(g(n))", "f ∈ Ω(g)"],
        "usage_examples": ["f(n) is equal to Ω(n log n)", "n² is equal to Ω(n)", "Ω(log n)", "Ω(1)"]
    }
    Let symbols be List.append(symbols, big_omega_sym)
    
    Note: Little omega notation
    Let little_omega_sym be {
        "symbol": "ω",
        "symbol_name": "little omega",
        "symbol_type": "asymptotic_notation",
        "mathematical_domain": "complexity_analysis",
        "notation_variants": ["ω", "ω(g(n))", "f(n) is equal to ω(g(n))", "f ∈ ω(g)"],
        "usage_examples": ["n² is equal to ω(n)", "f(n) is equal to ω(log n)", "ω(1)", "n! is equal to ω(2ⁿ)"]
    }
    Let symbols be List.append(symbols, little_omega_sym)
    
    Return symbols

Process called "big_o_symbol" that returns CalculusSymbol:
    Note: Get big O notation symbol (O)
    
    Return {
        "symbol": "O",
        "symbol_name": "big O",
        "symbol_type": "asymptotic_notation",
        "mathematical_domain": "complexity_analysis",
        "notation_variants": ["O", "O(g(n))", "f(n) is equal to O(g(n))", "f ∈ O(g)", "O-notation"],
        "usage_examples": ["f(n) is equal to O(n²) means f grows at most quadratically", "3n plus 5 is equal to O(n)", "binary search is O(log n)", "matrix multiplication is O(n³)"],
        "properties": {
            "definition": "f(n) is equal to O(g(n)) iff ∃c,n₀ such that |f(n)| ≤ c|g(n)| for n ≥ n₀",
            "upper_bound": "provides asymptotic upper bound",
            "transitivity": "if f is equal to O(g) and g is equal to O(h), then f is equal to O(h)",
            "sum_rule": "O(f) plus O(g) is equal to O(max(f,g))",
            "product_rule": "O(f) × O(g) is equal to O(f × g)"
        }
    }

Process called "little_o_symbol" that returns CalculusSymbol:
    Note: Get little o notation symbol (o)
    
    Return {
        "symbol": "o",
        "symbol_name": "little o",
        "symbol_type": "asymptotic_notation",
        "mathematical_domain": "complexity_analysis",
        "notation_variants": ["o", "o(g(n))", "f(n) is equal to o(g(n))", "f ∈ o(g)", "o-notation"],
        "usage_examples": ["n is equal to o(n²) means n grows strictly slower than n²", "log n is equal to o(n)", "polynomial time is o(exponential time)"],
        "properties": {
            "definition": "f(n) is equal to o(g(n)) iff lim_{n→∞} f(n)/g(n) is equal to 0",
            "strict_upper_bound": "provides strict asymptotic upper bound",
            "stronger_than_big_o": "f is equal to o(g) implies f is equal to O(g), but not vice versa",
            "transitivity": "if f is equal to o(g) and g is equal to o(h), then f is equal to o(h)",
            "limit_definition": "defined using limits rather than constants"
        }
    }

Process called "big_theta_symbol" that returns CalculusSymbol:
    Note: Get big Theta notation symbol (Θ)
    
    Return {
        "symbol": "Θ",
        "symbol_name": "big Theta",
        "symbol_type": "asymptotic_notation",
        "mathematical_domain": "complexity_analysis",
        "notation_variants": ["Θ", "Θ(g(n))", "f(n) is equal to Θ(g(n))", "f ∈ Θ(g)", "Theta-notation"],
        "usage_examples": ["merge sort is Θ(n log n)", "2n² plus 3n plus 1 is equal to Θ(n²)", "factorial is Θ(n!/(e^n √(2πn)) by Stirling)"],
        "properties": {
            "definition": "f(n) is equal to Θ(g(n)) iff f(n) is equal to O(g(n)) and f(n) is equal to Ω(g(n))",
            "tight_bound": "provides asymptotically tight bound",
            "equivalence": "f is equal to Θ(g) means f and g have same growth rate",
            "symmetry": "f is equal to Θ(g) iff g is equal to Θ(f)",
            "transitivity": "if f is equal to Θ(g) and g is equal to Θ(h), then f is equal to Θ(h)"
        }
    }

Process called "big_omega_symbol" that returns CalculusSymbol:
    Note: Get big Omega notation symbol (Ω)
    
    Return {
        "symbol": "Ω",
        "symbol_name": "big Omega",
        "symbol_type": "asymptotic_notation",
        "mathematical_domain": "complexity_analysis",
        "notation_variants": ["Ω", "Ω(g(n))", "f(n) is equal to Ω(g(n))", "f ∈ Ω(g)", "Omega-notation"],
        "usage_examples": ["any comparison-based sorting is Ω(n log n)", "n² is equal to Ω(n)", "searching unsorted array is Ω(n)"],
        "properties": {
            "definition": "f(n) is equal to Ω(g(n)) iff ∃c,n₀ such that f(n) ≥ c·g(n) for n ≥ n₀",
            "lower_bound": "provides asymptotic lower bound",
            "complement_of_big_o": "f is equal to Ω(g) iff g is equal to O(f)",
            "transitivity": "if f is equal to Ω(g) and g is equal to Ω(h), then f is equal to Ω(h)",
            "best_case_analysis": "often used for lower bound proofs"
        }
    }

Process called "little_omega_symbol" that returns CalculusSymbol:
    Note: Get little omega notation symbol (ω)
    
    Return {
        "symbol": "ω",
        "symbol_name": "little omega",
        "symbol_type": "asymptotic_notation",
        "mathematical_domain": "complexity_analysis",
        "notation_variants": ["ω", "ω(g(n))", "f(n) is equal to ω(g(n))", "f ∈ ω(g)", "omega-notation"],
        "usage_examples": ["n² is equal to ω(n) means n² grows strictly faster than n", "exponential is equal to ω(polynomial)", "n! is equal to ω(2ⁿ)"],
        "properties": {
            "definition": "f(n) is equal to ω(g(n)) iff lim_{n→∞} f(n)/g(n) is equal to ∞",
            "strict_lower_bound": "provides strict asymptotic lower bound",
            "stronger_than_big_omega": "f is equal to ω(g) implies f is equal to Ω(g), but not vice versa",
            "complement_of_little_o": "f is equal to ω(g) iff g is equal to o(f)",
            "limit_definition": "defined using limits approaching infinity"
        }
    }

Note: =====================================================================
Note: EPSILON-DELTA NOTATION OPERATIONS
Note: =====================================================================

Process called "get_epsilon_delta_symbols" that returns List[CalculusSymbol]:
    Note: Get epsilon-delta notation symbols (ε, δ, |·|, is less than )
    Let symbols be []
    
    Note: Epsilon symbol for limits
    Let epsilon_sym be {
        "symbol": "ε",
        "symbol_name": "epsilon",
        "symbol_type": "limit_parameter",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["ε", "eps", "ε is greater than 0", "for all ε is greater than 0"],
        "usage_examples": ["for all ε is greater than 0, there exists δ is greater than 0", "|f(x) minus L| is less than ε", "ε-δ definition of limit"]
    }
    Let symbols be List.append(symbols, epsilon_sym)
    
    Note: Delta symbol for limits
    Let delta_sym be {
        "symbol": "δ",
        "symbol_name": "delta",
        "symbol_type": "limit_parameter",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["δ", "delta", "δ is greater than 0", "there exists δ is greater than 0"],
        "usage_examples": ["there exists δ is greater than 0 such that", "0 is less than |x minus a| is less than δ", "ε-δ proof"]
    }
    Let symbols be List.append(symbols, delta_sym)
    
    Note: Absolute value symbol
    Let abs_value_sym be {
        "symbol": "|·|",
        "symbol_name": "absolute value",
        "symbol_type": "metric_notation",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["|·|", "|x|", "abs(x)", "distance"],
        "usage_examples": ["|f(x) minus L| is less than ε", "|x minus a| is less than δ", "|x| is equal to max(x, -x)"]
    }
    Let symbols be List.append(symbols, abs_value_sym)
    
    Note: Less than symbol
    Let less_than_sym be {
        "symbol": "<",
        "symbol_name": "less than",
        "symbol_type": "comparison_operator",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["<", "less than", "strictly less"],
        "usage_examples": ["ε is greater than 0", "|f(x) minus L| is less than ε", "0 is less than |x minus a| is less than δ"]
    }
    Let symbols be List.append(symbols, less_than_sym)
    
    Return symbols

Process called "epsilon_symbol" that returns CalculusSymbol:
    Note: Get epsilon symbol (ε) for limit definitions
    
    Return {
        "symbol": "ε",
        "symbol_name": "epsilon",
        "symbol_type": "limit_parameter",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["ε", "eps", "ε is greater than 0", "for all ε is greater than 0", "arbitrary ε"],
        "usage_examples": ["lim_{x→a} f(x) is equal to L iff for all ε is greater than 0, ∃δ is greater than 0: 0<|x-a|<δ ⇒ |f(x)-L|<ε", "uniform continuity: ∀ε>0, ∃δ>0", "|f(x) minus L| is less than ε"],
        "properties": {
            "arbitrarily_small": "ε represents arbitrarily small positive number",
            "universal_quantification": "typically quantified with 'for all ε is greater than 0'",
            "precision_measure": "measures how close function values are to limit",
            "fundamental_analysis": "cornerstone of rigorous calculus definitions"
        }
    }

Process called "delta_symbol" that returns CalculusSymbol:
    Note: Get delta symbol (δ) for limit definitions
    
    Return {
        "symbol": "δ",
        "symbol_name": "delta",
        "symbol_type": "limit_parameter",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["δ", "delta", "δ is greater than 0", "there exists δ is greater than 0", "δ(ε)"],
        "usage_examples": ["there exists δ is greater than 0 such that 0 is less than |x minus a| is less than δ implies |f(x) minus L| is less than ε", "continuity: ∃δ>0 such that |x-a|<δ ⇒ |f(x)-f(a)|<ε"],
        "properties": {
            "response_to_epsilon": "δ chosen in response to given ε",
            "existential_quantification": "typically quantified with 'there exists δ is greater than 0'",
            "domain_constraint": "constrains how close x must be to a",
            "function_dependent": "δ often depends on both ε and the specific function"
        }
    }

Process called "absolute_value_symbol" that returns CalculusSymbol:
    Note: Get absolute value symbols (|·|)
    
    Return {
        "symbol": "|·|",
        "symbol_name": "absolute value",
        "symbol_type": "metric_notation",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["|·|", "|x|", "abs(x)", "||x||", "distance function"],
        "usage_examples": ["|f(x) minus L| is less than ε", "|x minus a| is less than δ", "|x| is equal to √(x²)", "triangle inequality: |a plus b| ≤ |a| plus |b|"],
        "properties": {
            "non_negativity": "|x| ≥ 0 for all real x",
            "definiteness": "|x| is equal to 0 iff x is equal to 0",
            "multiplicativity": "|xy| is equal to |x||y|",
            "triangle_inequality": "|x plus y| ≤ |x| plus |y|",
            "distance_interpretation": "|x minus y| measures distance between x and y"
        }
    }

Note: =====================================================================
Note: FUNCTION COMPOSITION OPERATIONS
Note: =====================================================================

Process called "get_composition_symbols" that returns List[CalculusSymbol]:
    Note: Get function composition symbols (∘, •, ⊙)
    Let symbols be []
    
    Note: Standard composition symbol
    Let composition_sym be {
        "symbol": "∘",
        "symbol_name": "function composition",
        "symbol_type": "function_operator",
        "mathematical_domain": "function_theory",
        "notation_variants": ["∘", "f∘g", "(f∘g)(x)", "compose(f,g)"],
        "usage_examples": ["(f∘g)(x) is equal to f(g(x))", "sin∘cos is equal to sin(cos(x))", "h is equal to f∘g"]
    }
    Let symbols be List.append(symbols, composition_sym)
    
    Note: Bullet composition symbol
    Let bullet_composition_sym be {
        "symbol": "•",
        "symbol_name": "bullet composition",
        "symbol_type": "function_operator",
        "mathematical_domain": "function_theory",
        "notation_variants": ["•", "f•g", "bullet operator"],
        "usage_examples": ["f•g alternative notation", "operator composition"]
    }
    Let symbols be List.append(symbols, bullet_composition_sym)
    
    Note: Ring composition symbol
    Let ring_composition_sym be {
        "symbol": "⊙",
        "symbol_name": "ring composition",
        "symbol_type": "function_operator",
        "mathematical_domain": "function_theory",
        "notation_variants": ["⊙", "f⊙g", "odot composition"],
        "usage_examples": ["f⊙g specialized composition", "categorical composition"]
    }
    Let symbols be List.append(symbols, ring_composition_sym)
    
    Return symbols

Process called "composition_symbol" that returns CalculusSymbol:
    Note: Get composition symbol (∘)
    
    Return {
        "symbol": "∘",
        "symbol_name": "function composition",
        "symbol_type": "function_operator",
        "mathematical_domain": "function_theory",
        "notation_variants": ["∘", "f∘g", "(f∘g)(x)", "compose(f,g)", "f after g"],
        "usage_examples": ["(f∘g)(x) is equal to f(g(x))", "if f(x) is equal to x² and g(x) is equal to x+1, then (f∘g)(x) is equal to (x+1)²", "derivative: (f∘g)' is equal to (f'∘g)·g'"],
        "properties": {
            "associativity": "(f∘g)∘h is equal to f∘(g∘h)",
            "non_commutativity": "generally f∘g ≠ g∘f",
            "identity_element": "id∘f is equal to f∘id is equal to f where id is identity function",
            "chain_rule": "derivative of composition follows chain rule",
            "domain_range_requirement": "range of g must be subset of domain of f"
        }
    }

Process called "bullet_composition_symbol" that returns CalculusSymbol:
    Note: Get bullet composition symbol (•)
    
    Return {
        "symbol": "•",
        "symbol_name": "bullet composition",
        "symbol_type": "function_operator",
        "mathematical_domain": "function_theory",
        "notation_variants": ["•", "f•g", "bullet operator", "dot composition"],
        "usage_examples": ["f•g as alternative to f∘g", "operator composition in some contexts"],
        "properties": {
            "alternative_notation": "alternative to ∘ symbol in some contexts",
            "context_dependent": "meaning varies by mathematical context",
            "operator_theory": "sometimes used in operator composition",
            "categorical_usage": "appears in category theory contexts"
        }
    }

Process called "ring_composition_symbol" that returns CalculusSymbol:
    Note: Get ring composition symbol (⊙)
    
    Return {
        "symbol": "⊙",
        "symbol_name": "ring composition",
        "symbol_type": "function_operator",
        "mathematical_domain": "function_theory",
        "notation_variants": ["⊙", "f⊙g", "odot composition", "circled dot"],
        "usage_examples": ["f⊙g specialized composition notation", "categorical morphism composition"],
        "properties": {
            "specialized_notation": "used for specific types of composition",
            "categorical_composition": "common in category theory for morphisms",
            "ring_operations": "sometimes used in ring theory contexts",
            "visual_distinction": "provides visual distinction from standard ∘"
        }
    }

Note: =====================================================================
Note: DERIVATIVE NOTATION VARIANTS
Note: =====================================================================

Process called "get_derivative_notations" that returns List[String]:
    Note: Get derivative notation variants (f', f'', f⁽ⁿ⁾, df/dx, ∂f/∂x)
    Let notations be []
    
    Note: Prime notation variants
    Let notations be List.append(notations, "f'(x)")
    Let notations be List.append(notations, "f''(x)")
    Let notations be List.append(notations, "f'''(x)")
    Let notations be List.append(notations, "f⁽⁴⁾(x)")
    Let notations be List.append(notations, "f⁽ⁿ⁾(x)")
    
    Note: Leibniz notation variants
    Let notations be List.append(notations, "df/dx")
    Let notations be List.append(notations, "d²f/dx²")
    Let notations be List.append(notations, "dⁿf/dxⁿ")
    Let notations be List.append(notations, "∂f/∂x")
    Let notations be List.append(notations, "∂²f/∂x²")
    
    Note: Newton dot notation
    Let notations be List.append(notations, "ẋ")
    Let notations be List.append(notations, "ẍ")
    Let notations be List.append(notations, "x⃛")
    
    Note: D-operator notation
    Let notations be List.append(notations, "Df")
    Let notations be List.append(notations, "D²f")
    Let notations be List.append(notations, "Dⁿf")
    
    Note: Operator notation
    Let notations be List.append(notations, "d/dx")
    Let notations be List.append(notations, "∂/∂x")
    Let notations be List.append(notations, "∇")
    
    Return notations

Process called "prime_notation" that returns List[String]:
    Note: Get prime notation for derivatives (', '', ''', ⁽⁴⁾)
    Let prime_notations be []
    
    Note: First derivative
    Let prime_notations be List.append(prime_notations, "f'(x)")
    Let prime_notations be List.append(prime_notations, "y'")
    Let prime_notations be List.append(prime_notations, "g'(t)")
    
    Note: Second derivative
    Let prime_notations be List.append(prime_notations, "f''(x)")
    Let prime_notations be List.append(prime_notations, "y''")
    Let prime_notations be List.append(prime_notations, "g''(t)")
    
    Note: Third derivative
    Let prime_notations be List.append(prime_notations, "f'''(x)")
    Let prime_notations be List.append(prime_notations, "y'''")
    Let prime_notations be List.append(prime_notations, "g'''(t)")
    
    Note: Fourth and higher derivatives
    Let prime_notations be List.append(prime_notations, "f⁽⁴⁾(x)")
    Let prime_notations be List.append(prime_notations, "f⁽⁵⁾(x)")
    Let prime_notations be List.append(prime_notations, "f⁽ⁿ⁾(x)")
    Let prime_notations be List.append(prime_notations, "y⁽ⁿ⁾")
    
    Note: Just the symbols
    Let prime_notations be List.append(prime_notations, "'")
    Let prime_notations be List.append(prime_notations, "''")
    Let prime_notations be List.append(prime_notations, "'''")
    Let prime_notations be List.append(prime_notations, "⁽⁴⁾")
    Let prime_notations be List.append(prime_notations, "⁽ⁿ⁾")
    
    Return prime_notations

Process called "leibniz_notation" that returns String:
    Note: Get Leibniz notation for derivatives (d/dx, ∂/∂x)
    
    Return {
        "single_variable": {
            "first_derivative": "df/dx",
            "second_derivative": "d²f/dx²",
            "nth_derivative": "dⁿf/dxⁿ",
            "operator_form": "d/dx",
            "examples": ["dy/dx", "d(sin x)/dx is equal to cos x", "d²y/dt²", "d/dx[x³] is equal to 3x²"]
        },
        "multivariable": {
            "partial_derivative": "∂f/∂x",
            "second_partial": "∂²f/∂x²",
            "mixed_partial": "∂²f/∂x∂y",
            "nth_partial": "∂ⁿf/∂xⁿ",
            "operator_form": "∂/∂x",
            "examples": ["∂z/∂x", "∂(x²y)/∂x is equal to 2xy", "∂²f/∂x∂y", "∂/∂x[xy²] is equal to y²"]
        },
        "properties": {
            "product_rule": "d(uv)/dx is equal to u(dv/dx) plus v(du/dx)",
            "chain_rule": "df/dx is equal to (df/du)(du/dx)",
            "quotient_rule": "d(u/v)/dx is equal to [v(du/dx) minus u(dv/dx)]/v²",
            "power_rule": "d(xⁿ)/dx is equal to nx^(n-1)",
            "linearity": "d(af plus bg)/dx is equal to a(df/dx) plus b(dg/dx)"
        }
    }

Process called "newton_notation" that returns String:
    Note: Get Newton dot notation for time derivatives (ẋ, ẍ)
    
    Return {
        "first_derivative": {
            "symbol": "ẋ",
            "name": "x dot",
            "meaning": "first time derivative of x",
            "usage": "velocity in physics",
            "examples": ["v is equal to ẋ", "if x(t) is equal to t², then ẋ is equal to 2t", "position → velocity"]
        },
        "second_derivative": {
            "symbol": "ẍ",
            "name": "x double dot",
            "meaning": "second time derivative of x",
            "usage": "acceleration in physics",
            "examples": ["a is equal to ẍ", "if x(t) is equal to t³, then ẍ is equal to 6t", "velocity → acceleration"]
        },
        "third_derivative": {
            "symbol": "x⃛",
            "name": "x triple dot",
            "meaning": "third time derivative of x",
            "usage": "jerk in physics",
            "examples": ["j is equal to x⃛", "rate of change of acceleration", "acceleration → jerk"]
        },
        "general_notation": {
            "pattern": "variable with dots above",
            "examples": ["θ̇ (angular velocity)", "ṙ (radial velocity)", "φ̇ (phase velocity)"]
        },
        "properties": {
            "time_specific": "primarily used for derivatives with respect to time",
            "physics_standard": "standard notation in classical mechanics",
            "compact_form": "more compact than d/dt notation",
            "newton_legacy": "introduced by Isaac Newton for calculus",
            "equivalence": "ẋ ≡ dx/dt, ẍ ≡ d²x/dt²"
        }
    }

Note: =====================================================================
Note: REAL ANALYSIS SYMBOLS
Note: =====================================================================

Process called "get_analysis_symbols" that returns List[CalculusSymbol]:
    Note: Get real analysis symbols (∀, ∃, ∈, ⊂, ∪, ∩)
    Let symbols be []
    
    Note: Supremum symbol
    Let supremum_sym be {
        "symbol": "sup",
        "symbol_name": "supremum",
        "symbol_type": "extremum_operator",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["sup", "sup_{x∈S}", "least upper bound", "lub"],
        "usage_examples": ["sup{1/n : n ∈ ℕ} is equal to 1", "sup[0,1) is equal to 1", "sup f(x) over domain"]
    }
    Let symbols be List.append(symbols, supremum_sym)
    
    Note: Infimum symbol
    Let infimum_sym be {
        "symbol": "inf",
        "symbol_name": "infimum",
        "symbol_type": "extremum_operator",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["inf", "inf_{x∈S}", "greatest lower bound", "glb"],
        "usage_examples": ["inf{1/n : n ∈ ℕ} is equal to 0", "inf(0,1] is equal to 0", "inf f(x) over domain"]
    }
    Let symbols be List.append(symbols, infimum_sym)
    
    Note: Maximum symbol
    Let maximum_sym be {
        "symbol": "max",
        "symbol_name": "maximum",
        "symbol_type": "extremum_operator",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["max", "max_{x∈S}", "maximum value"],
        "usage_examples": ["max{1,2,3} is equal to 3", "max[0,1] is equal to 1", "max f(x) on closed interval"]
    }
    Let symbols be List.append(symbols, maximum_sym)
    
    Note: Minimum symbol
    Let minimum_sym be {
        "symbol": "min",
        "symbol_name": "minimum",
        "symbol_type": "extremum_operator",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["min", "min_{x∈S}", "minimum value"],
        "usage_examples": ["min{1,2,3} is equal to 1", "min[0,1] is equal to 0", "min f(x) on closed interval"]
    }
    Let symbols be List.append(symbols, minimum_sym)
    
    Return symbols

Process called "supremum_symbol" that returns CalculusSymbol:
    Note: Get supremum symbol (sup)
    
    Return {
        "symbol": "sup",
        "symbol_name": "supremum",
        "symbol_type": "extremum_operator",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["sup", "sup_{x∈S}", "sup_{x∈S} f(x)", "least upper bound", "lub"],
        "usage_examples": ["sup{1/n : n ∈ ℕ} is equal to 1", "sup[0,1) is equal to 1", "sup_{x∈[0,1]} x² is equal to 1", "sup f exists for bounded above sets"],
        "properties": {
            "least_upper_bound": "smallest value that is ≥ all elements in set",
            "may_not_exist_in_set": "sup S may not be an element of S",
            "completeness_axiom": "every non-empty bounded above set has a supremum in ℝ",
            "monotonicity": "if A ⊆ B, then sup A ≤ sup B",
            "approximation_property": "for any ε is greater than 0, ∃ x ∈ S: sup S minus ε is less than x ≤ sup S"
        }
    }

Process called "infimum_symbol" that returns CalculusSymbol:
    Note: Get infimum symbol (inf)
    
    Return {
        "symbol": "inf",
        "symbol_name": "infimum",
        "symbol_type": "extremum_operator",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["inf", "inf_{x∈S}", "inf_{x∈S} f(x)", "greatest lower bound", "glb"],
        "usage_examples": ["inf{1/n : n ∈ ℕ} is equal to 0", "inf(0,1] is equal to 0", "inf_{x∈[1,∞)} 1/x is equal to 0", "inf f for bounded below sets"],
        "properties": {
            "greatest_lower_bound": "largest value that is ≤ all elements in set",
            "may_not_exist_in_set": "inf S may not be an element of S",
            "completeness_axiom": "every non-empty bounded below set has an infimum in ℝ",
            "monotonicity": "if A ⊆ B, then inf A ≥ inf B",
            "approximation_property": "for any ε is greater than 0, ∃ x ∈ S: inf S ≤ x is less than inf S plus ε"
        }
    }

Process called "maximum_symbol" that returns CalculusSymbol:
    Note: Get maximum symbol (max)
    
    Return {
        "symbol": "max",
        "symbol_name": "maximum",
        "symbol_type": "extremum_operator",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["max", "max_{x∈S}", "max_{x∈S} f(x)", "maximum value"],
        "usage_examples": ["max{1,2,3} is equal to 3", "max[0,1] is equal to 1", "max_{x∈[-1,1]} x² is equal to 1", "max f(x) on compact set"],
        "properties": {
            "attained_supremum": "maximum is supremum that belongs to the set",
            "existence_condition": "exists for finite sets and compact sets with continuous functions",
            "extreme_value_theorem": "continuous function on compact set attains max and min",
            "uniqueness": "if maximum exists, it may not be unique (constant functions)",
            "comparison_with_sup": "max S is equal to sup S when sup S ∈ S"
        }
    }

Process called "minimum_symbol" that returns CalculusSymbol:
    Note: Get minimum symbol (min)
    
    Return {
        "symbol": "min",
        "symbol_name": "minimum",
        "symbol_type": "extremum_operator",
        "mathematical_domain": "real_analysis",
        "notation_variants": ["min", "min_{x∈S}", "min_{x∈S} f(x)", "minimum value"],
        "usage_examples": ["min{1,2,3} is equal to 1", "min[0,1] is equal to 0", "min_{x∈[-1,1]} x² is equal to 0", "min f(x) on compact set"],
        "properties": {
            "attained_infimum": "minimum is infimum that belongs to the set",
            "existence_condition": "exists for finite sets and compact sets with continuous functions",
            "extreme_value_theorem": "continuous function on compact set attains max and min",
            "uniqueness": "if minimum exists, it may not be unique (constant functions)",
            "comparison_with_inf": "min S is equal to inf S when inf S ∈ S"
        }
    }

Process called "essential_supremum_symbol" that returns CalculusSymbol:
    Note: Get essential supremum symbol (ess sup)
    
    Return {
        "symbol": "ess sup",
        "symbol_name": "essential supremum",
        "symbol_type": "measure_theoretic_extremum",
        "mathematical_domain": "measure_theory",
        "notation_variants": ["ess sup", "ess sup_x", "essential supremum", "ess-sup"],
        "usage_examples": ["ess sup f is equal to inf{M : μ({x : f(x) is greater than M}) is equal to 0}", "||f||_∞ is equal to ess sup |f|", "ess sup of bounded measurable function"],
        "properties": {
            "measure_theoretic": "supremum ignoring sets of measure zero",
            "l_infinity_norm": "ess sup |f| defines L^∞ norm",
            "almost_everywhere_bound": "f(x) ≤ ess sup f for almost all x",
            "infimum_characterization": "ess sup f is equal to inf{M : f ≤ M a.e.}",
            "measurability": "ess sup of measurable function is measurable"
        }
    }

Process called "essential_infimum_symbol" that returns CalculusSymbol:
    Note: Get essential infimum symbol (ess inf)
    
    Return {
        "symbol": "ess inf",
        "symbol_name": "essential infimum",
        "symbol_type": "measure_theoretic_extremum",
        "mathematical_domain": "measure_theory",
        "notation_variants": ["ess inf", "ess inf_x", "essential infimum", "ess-inf"],
        "usage_examples": ["ess inf f is equal to sup{m : μ({x : f(x) is less than m}) is equal to 0}", "ess inf f ≤ f(x) for almost all x", "essential infimum of measurable function"],
        "properties": {
            "measure_theoretic": "infimum ignoring sets of measure zero",
            "dual_to_ess_sup": "ess inf f is equal to -ess sup(-f)",
            "almost_everywhere_bound": "ess inf f ≤ f(x) for almost all x",
            "supremum_characterization": "ess inf f is equal to sup{m : f ≥ m a.e.}",
            "measurability": "ess inf of measurable function is measurable",
            "monotonicity": "if f ≤ g a.e., then ess inf f ≤ ess inf g"
        }
    }

Note: =====================================================================
Note: MEASURE THEORY SYMBOLS
Note: =====================================================================

Process called "get_measure_symbols" that returns List[CalculusSymbol]:
    Note: Get measure theory symbols (μ, λ, σ, ∫, ⊗)
    Let symbols be []
    
    Note: General measure symbol
    Let measure_sym be {
        "symbol": "μ",
        "symbol_name": "measure",
        "symbol_type": "measure_operator",
        "mathematical_domain": "measure_theory",
        "notation_variants": ["μ", "μ(A)", "μ(E)", "measure of set"],
        "usage_examples": ["μ([0,1]) is equal to 1", "μ(∅) is equal to 0", "μ(⋃A_i) ≤ ∑μ(A_i)"]
    }
    Let symbols be List.append(symbols, measure_sym)
    
    Note: Lebesgue measure symbol
    Let lebesgue_sym be {
        "symbol": "λ",
        "symbol_name": "Lebesgue measure",
        "symbol_type": "measure_operator",
        "mathematical_domain": "measure_theory",
        "notation_variants": ["λ", "λ(A)", "Lebesgue measure", "m(A)"],
        "usage_examples": ["λ([a,b]) is equal to b-a", "λ(ℚ) is equal to 0", "λ(ℝ) is equal to ∞"]
    }
    Let symbols be List.append(symbols, lebesgue_sym)
    
    Note: Sigma-algebra symbol
    Let sigma_algebra_sym be {
        "symbol": "σ",
        "symbol_name": "sigma-algebra",
        "symbol_type": "algebraic_structure",
        "mathematical_domain": "measure_theory",
        "notation_variants": ["σ", "σ(E)", "σ-algebra", "σ-field"],
        "usage_examples": ["σ({A_i})", "Borel σ-algebra", "generated σ-algebra"]
    }
    Let symbols be List.append(symbols, sigma_algebra_sym)
    
    Note: Almost everywhere symbol
    Let almost_everywhere_sym be {
        "symbol": "a.e.",
        "symbol_name": "almost everywhere",
        "symbol_type": "measure_qualifier",
        "mathematical_domain": "measure_theory",
        "notation_variants": ["a.e.", "almost everywhere", "μ-a.e."],
        "usage_examples": ["f is equal to g a.e.", "convergent a.e.", "f(x) is greater than 0 a.e."]
    }
    Let symbols be List.append(symbols, almost_everywhere_sym)
    
    Return symbols

Process called "measure_symbol" that returns CalculusSymbol:
    Note: Get measure symbol (μ)
    
    Return {
        "symbol": "μ",
        "symbol_name": "measure",
        "symbol_type": "measure_operator",
        "mathematical_domain": "measure_theory",
        "notation_variants": ["μ", "μ(A)", "μ(E)", "measure of set", "μ-measure"],
        "usage_examples": ["μ([0,1]) is equal to 1 for Lebesgue measure", "μ(∅) is equal to 0", "μ(A ∪ B) ≤ μ(A) plus μ(B)", "probability measure: μ(Ω) is equal to 1"],
        "properties": {
            "non_negativity": "μ(A) ≥ 0 for all measurable A",
            "null_empty_set": "μ(∅) is equal to 0",
            "countable_additivity": "μ(⋃A_i) is equal to ∑μ(A_i) for disjoint A_i",
            "monotonicity": "if A ⊆ B, then μ(A) ≤ μ(B)",
            "continuity": "continuous from below and above for increasing/decreasing sequences"
        }
    }

Process called "lebesgue_measure_symbol" that returns CalculusSymbol:
    Note: Get Lebesgue measure symbol (λ)
    
    Return {
        "symbol": "λ",
        "symbol_name": "Lebesgue measure",
        "symbol_type": "measure_operator",
        "mathematical_domain": "measure_theory",
        "notation_variants": ["λ", "λ(A)", "Lebesgue measure", "m(A)", "Leb(A)"],
        "usage_examples": ["λ([a,b]) is equal to b-a", "λ(ℚ ∩ [0,1]) is equal to 0", "λ(Cantor set) is equal to 0", "λ(ℝ^n) is equal to ∞"],
        "properties": {
            "translation_invariant": "λ(A plus x) is equal to λ(A) for all x",
            "intervals": "λ([a,b]) is equal to λ((a,b)) is equal to λ([a,b)) is equal to λ((a,b]) is equal to b-a",
            "countable_sets": "λ(A) is equal to 0 for any countable set A",
            "regularity": "outer regular: λ(A) is equal to inf{λ(U) : A ⊆ U open}",
            "density_theorem": "almost every point is a density point"
        }
    }

Process called "sigma_algebra_symbol" that returns CalculusSymbol:
    Note: Get σ-algebra symbol (σ)
    
    Return {
        "symbol": "σ",
        "symbol_name": "sigma-algebra",
        "symbol_type": "algebraic_structure",
        "mathematical_domain": "measure_theory",
        "notation_variants": ["σ", "σ(E)", "σ-algebra", "σ-field", "generated σ-algebra"],
        "usage_examples": ["σ({A_i : i ∈ I}) is equal to smallest σ-algebra containing all A_i", "Borel σ-algebra B(ℝ)", "product σ-algebra"],
        "properties": {
            "contains_universal_set": "Ω ∈ σ",
            "closed_under_complements": "if A ∈ σ, then A^c ∈ σ",
            "closed_under_countable_unions": "if A_i ∈ σ, then ⋃A_i ∈ σ",
            "generated_algebra": "σ(E) is smallest σ-algebra containing collection E",
            "borel_sets": "Borel σ-algebra generated by open sets"
        }
    }

Process called "almost_everywhere_symbol" that returns CalculusSymbol:
    Note: Get almost everywhere symbol (a.e.)
    
    Return {
        "symbol": "a.e.",
        "symbol_name": "almost everywhere",
        "symbol_type": "measure_qualifier",
        "mathematical_domain": "measure_theory",
        "notation_variants": ["a.e.", "almost everywhere", "μ-a.e.", "a.s.", "almost surely"],
        "usage_examples": ["f is equal to g a.e. means {x : f(x) ≠ g(x)} has measure zero", "f_n → f a.e.", "f(x) is greater than 0 a.e. on [0,1]"],
        "properties": {
            "measure_zero_exception": "property holds except on set of measure zero",
            "equivalence_classes": "identifies functions differing on null sets",
            "convergence_types": "a.e. convergence vs convergence in measure",
            "integration": "functions equal a.e. have same integral",
            "probability_context": "almost surely (a.s.) in probability theory"
        }
    }

Note: =====================================================================
Note: TOPOLOGY SYMBOLS
Note: =====================================================================

Process called "get_topology_symbols" that returns List[CalculusSymbol]:
    Note: Get topology symbols (int, cl, ∂, °, ¯)
    Let symbols be []
    
    Note: Interior symbol
    Let interior_sym be {
        "symbol": "int",
        "symbol_name": "interior",
        "symbol_type": "topological_operator",
        "mathematical_domain": "topology",
        "notation_variants": ["int", "int(A)", "A°", "interior of A"],
        "usage_examples": ["int([0,1]) is equal to (0,1)", "int(Q) is equal to ∅", "int(open set) is equal to open set"]
    }
    Let symbols be List.append(symbols, interior_sym)
    
    Note: Closure symbol
    Let closure_sym be {
        "symbol": "cl",
        "symbol_name": "closure",
        "symbol_type": "topological_operator",
        "mathematical_domain": "topology",
        "notation_variants": ["cl", "cl(A)", "A̅", "closure of A", "A¯"],
        "usage_examples": ["cl((0,1)) is equal to [0,1]", "cl(Q) is equal to R", "cl(closed set) is equal to closed set"]
    }
    Let symbols be List.append(symbols, closure_sym)
    
    Note: Boundary symbol
    Let boundary_sym be {
        "symbol": "∂",
        "symbol_name": "boundary",
        "symbol_type": "topological_operator",
        "mathematical_domain": "topology",
        "notation_variants": ["∂", "∂A", "bd(A)", "boundary of A"],
        "usage_examples": ["∂[0,1] is equal to {0,1}", "∂(0,1) is equal to {0,1}", "∂Q is equal to R"]
    }
    Let symbols be List.append(symbols, boundary_sym)
    
    Note: Complement symbol
    Let complement_sym be {
        "symbol": "^c",
        "symbol_name": "complement",
        "symbol_type": "set_operator",
        "mathematical_domain": "topology",
        "notation_variants": ["^c", "A^c", "A'", "complement of A"],
        "usage_examples": ["[0,1]^c is equal to (-∞,0) ∪ (1,∞)", "(open)^c is equal to closed"]
    }
    Let symbols be List.append(symbols, complement_sym)
    
    Return symbols

Process called "interior_symbol" that returns CalculusSymbol:
    Note: Get interior symbol (int or °)
    
    Return {
        "symbol": "int",
        "symbol_name": "interior",
        "symbol_type": "topological_operator",
        "mathematical_domain": "topology",
        "notation_variants": ["int", "int(A)", "A°", "interior of A", "A°"],
        "usage_examples": ["int([0,1]) is equal to (0,1) in usual topology on R", "int(ℚ) is equal to ∅", "int(B(x,r)) is equal to B(x,r) for open ball"],
        "properties": {
            "largest_open_subset": "int(A) is largest open set contained in A",
            "idempotent": "int(int(A)) is equal to int(A)",
            "monotone": "if A ⊆ B, then int(A) ⊆ int(B)",
            "intersection": "int(A ∩ B) is equal to int(A) ∩ int(B)",
            "open_sets": "A is open iff A is equal to int(A)"
        }
    }

Process called "closure_symbol" that returns CalculusSymbol:
    Note: Get closure symbol (cl or ¯)
    
    Return {
        "symbol": "cl",
        "symbol_name": "closure",
        "symbol_type": "topological_operator",
        "mathematical_domain": "topology",
        "notation_variants": ["cl", "cl(A)", "A̅", "closure of A", "A¯", "Ā"],
        "usage_examples": ["cl((0,1)) is equal to [0,1] in usual topology", "cl(ℚ) is equal to ℝ", "cl(finite set) is equal to finite set in discrete topology"],
        "properties": {
            "smallest_closed_superset": "cl(A) is smallest closed set containing A",
            "idempotent": "cl(cl(A)) is equal to cl(A)",
            "monotone": "if A ⊆ B, then cl(A) ⊆ cl(B)",
            "union": "cl(A ∪ B) is equal to cl(A) ∪ cl(B)",
            "closed_sets": "A is closed iff A is equal to cl(A)",
            "limit_points": "cl(A) is equal to A ∪ {limit points of A}"
        }
    }

Process called "boundary_symbol" that returns CalculusSymbol:
    Note: Get boundary symbol (∂)
    
    Return {
        "symbol": "∂",
        "symbol_name": "boundary",
        "symbol_type": "topological_operator",
        "mathematical_domain": "topology",
        "notation_variants": ["∂", "∂A", "bd(A)", "boundary of A", "Fr(A)", "frontier"],
        "usage_examples": ["∂[0,1] is equal to {0,1}", "∂(0,1) is equal to {0,1}", "∂ℚ is equal to ℝ in usual topology", "∂B(x,r) is equal to S(x,r)"],
        "properties": {
            "closure_minus_interior": "∂A is equal to cl(A) \\ int(A)",
            "intersection_formula": "∂A is equal to cl(A) ∩ cl(A^c)",
            "always_closed": "boundary is always a closed set",
            "symmetric": "∂A is equal to ∂(A^c)",
            "disjoint_decomposition": "X is equal to int(A) ∪ ∂A ∪ int(A^c) (disjoint union)",
            "nowhere_dense": "int(∂A) is equal to ∅"
        }
    }

Note: =====================================================================
Note: VALIDATION AND UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_calculus_notation" that takes expression as String returns List[String]:
    Note: Validate calculus notation for correctness
    Let errors be []
    
    Note: Check for common notation errors
    If String.contains(expression, "d/d") && !String.contains(expression, "d/dx"):
        Let errors be List.append(errors, "Incomplete differential notation: use 'd/dx' not 'd/d'")
    
    If String.contains(expression, "∂/∂") && !String.contains(expression, "∂/∂x"):
        Let errors be List.append(errors, "Incomplete partial derivative notation: specify variable after ∂/∂")
    
    Note: Check for mismatched parentheses in integrals
    If String.count(expression, "∫") is greater than 0:
        If String.count(expression, "dx") is equal to 0 && String.count(expression, "dy") is equal to 0 && String.count(expression, "dt") is equal to 0:
            Let errors be List.append(errors, "Integral notation missing differential (dx, dy, dt, etc.)")
    
    Note: Check for proper limit notation
    If String.contains(expression, "lim") && !String.contains(expression, "→"):
        Let errors be List.append(errors, "Limit notation missing approach symbol (→)")
    
    Note: Check for proper summation indices
    If String.contains(expression, "∑") && !String.contains(expression, "="):
        Let errors be List.append(errors, "Summation notation missing index specification")
    
    Note: Check for unmatched delimiters
    Let open_parens be String.count(expression, "(")
    Let close_parens be String.count(expression, ")")
    If open_parens does not equal close_parens:
        Let errors be List.append(errors, "Mismatched parentheses in expression")
    
    Let open_brackets be String.count(expression, "[")
    Let close_brackets be String.count(expression, "]")
    If open_brackets does not equal close_brackets:
        Let errors be List.append(errors, "Mismatched brackets in expression")
    
    Note: Check for proper absolute value notation
    Let pipe_count be String.count(expression, "|")
    If pipe_count % 2 does not equal 0:
        Let errors be List.append(errors, "Unmatched absolute value notation (odd number of | symbols)")
    
    Note: Validate Greek letters are properly formatted
    If String.contains(expression, "alpha") && !String.contains(expression, "α"):
        Let errors be List.append(errors, "Consider using Unicode α instead of 'alpha'")
    
    If String.contains(expression, "beta") && !String.contains(expression, "β"):
        Let errors be List.append(errors, "Consider using Unicode β instead of 'beta'")
    
    Return errors

Process called "format_calculus_expression" that takes expression as String, style as String returns String:
    Note: Format calculus expression with proper symbols
    Let formatted_expression be expression
    
    Note: Apply formatting based on style
    If style is equal to "unicode":
        Note: Convert to Unicode symbols
        Set formatted_expression to String.replace(formatted_expression, "alpha", "α")
        Set formatted_expression to String.replace(formatted_expression, "beta", "β")
        Set formatted_expression to String.replace(formatted_expression, "gamma", "γ")
        Set formatted_expression to String.replace(formatted_expression, "delta", "δ")
        Set formatted_expression to String.replace(formatted_expression, "epsilon", "ε")
        Set formatted_expression to String.replace(formatted_expression, "lambda", "λ")
        Set formatted_expression to String.replace(formatted_expression, "mu", "μ")
        Set formatted_expression to String.replace(formatted_expression, "pi", "π")
        Set formatted_expression to String.replace(formatted_expression, "sigma", "σ")
        Set formatted_expression to String.replace(formatted_expression, "theta", "θ")
        Set formatted_expression to String.replace(formatted_expression, "infinity", "∞")
        Set formatted_expression to String.replace(formatted_expression, "integral", "∫")
        Set formatted_expression to String.replace(formatted_expression, "sum", "∑")
        Set formatted_expression to String.replace(formatted_expression, "product", "∏")
        Set formatted_expression to String.replace(formatted_expression, "partial", "∂")
        Set formatted_expression to String.replace(formatted_expression, "nabla", "∇")
    
    Otherwise if style is equal to "latex":
        Note: Convert to LaTeX commands
        Set formatted_expression to String.replace(formatted_expression, "α", "\\alpha")
        Set formatted_expression to String.replace(formatted_expression, "β", "\\beta")
        Set formatted_expression to String.replace(formatted_expression, "γ", "\\gamma")
        Set formatted_expression to String.replace(formatted_expression, "δ", "\\delta")
        Set formatted_expression to String.replace(formatted_expression, "ε", "\\epsilon")
        Set formatted_expression to String.replace(formatted_expression, "λ", "\\lambda")
        Set formatted_expression to String.replace(formatted_expression, "μ", "\\mu")
        Set formatted_expression to String.replace(formatted_expression, "π", "\\pi")
        Set formatted_expression to String.replace(formatted_expression, "σ", "\\sigma")
        Set formatted_expression to String.replace(formatted_expression, "θ", "\\theta")
        Set formatted_expression to String.replace(formatted_expression, "∞", "\\infty")
        Set formatted_expression to String.replace(formatted_expression, "∫", "\\int")
        Set formatted_expression to String.replace(formatted_expression, "∑", "\\sum")
        Set formatted_expression to String.replace(formatted_expression, "∏", "\\prod")
        Set formatted_expression to String.replace(formatted_expression, "∂", "\\partial")
        Set formatted_expression to String.replace(formatted_expression, "∇", "\\nabla")
    
    Otherwise if style is equal to "ascii":
        Note: Convert to ASCII-friendly notation
        Set formatted_expression to String.replace(formatted_expression, "α", "alpha")
        Set formatted_expression to String.replace(formatted_expression, "β", "beta")
        Set formatted_expression to String.replace(formatted_expression, "γ", "gamma")
        Set formatted_expression to String.replace(formatted_expression, "δ", "delta")
        Set formatted_expression to String.replace(formatted_expression, "ε", "epsilon")
        Set formatted_expression to String.replace(formatted_expression, "λ", "lambda")
        Set formatted_expression to String.replace(formatted_expression, "μ", "mu")
        Set formatted_expression to String.replace(formatted_expression, "π", "pi")
        Set formatted_expression to String.replace(formatted_expression, "σ", "sigma")
        Set formatted_expression to String.replace(formatted_expression, "θ", "theta")
        Set formatted_expression to String.replace(formatted_expression, "∞", "infinity")
        Set formatted_expression to String.replace(formatted_expression, "∫", "integral")
        Set formatted_expression to String.replace(formatted_expression, "∑", "sum")
        Set formatted_expression to String.replace(formatted_expression, "∏", "product")
        Set formatted_expression to String.replace(formatted_expression, "∂", "partial")
        Set formatted_expression to String.replace(formatted_expression, "∇", "nabla")
    
    Return formatted_expression

Process called "convert_calculus_notation" that takes expression as String, from_style as String, to_style as String returns String:
    Note: Convert between different calculus notation styles
    Let converted_expression be expression
    
    Note: First normalize to intermediate representation, then convert to target style
    If from_style is equal to "prime" && to_style is equal to "leibniz":
        Note: Convert prime notation to Leibniz notation
        Set converted_expression to String.replace(converted_expression, "f'(x)", "df/dx")
        Set converted_expression to String.replace(converted_expression, "f''(x)", "d²f/dx²")
        Set converted_expression to String.replace(converted_expression, "f'''(x)", "d³f/dx³")
        Set converted_expression to String.replace(converted_expression, "y'", "dy/dx")
        Set converted_expression to String.replace(converted_expression, "y''", "d²y/dx²")
    
    Otherwise if from_style is equal to "leibniz" && to_style is equal to "prime":
        Note: Convert Leibniz notation to prime notation
        Set converted_expression to String.replace(converted_expression, "df/dx", "f'(x)")
        Set converted_expression to String.replace(converted_expression, "d²f/dx²", "f''(x)")
        Set converted_expression to String.replace(converted_expression, "d³f/dx³", "f'''(x)")
        Set converted_expression to String.replace(converted_expression, "dy/dx", "y'")
        Set converted_expression to String.replace(converted_expression, "d²y/dx²", "y''")
    
    Otherwise if from_style is equal to "newton" && to_style is equal to "leibniz":
        Note: Convert Newton dot notation to Leibniz notation
        Set converted_expression to String.replace(converted_expression, "ẋ", "dx/dt")
        Set converted_expression to String.replace(converted_expression, "ẍ", "d²x/dt²")
        Set converted_expression to String.replace(converted_expression, "x⃛", "d³x/dt³")
    
    Otherwise if from_style is equal to "leibniz" && to_style is equal to "newton":
        Note: Convert Leibniz notation to Newton dot notation
        Set converted_expression to String.replace(converted_expression, "dx/dt", "ẋ")
        Set converted_expression to String.replace(converted_expression, "d²x/dt²", "ẍ")
        Set converted_expression to String.replace(converted_expression, "d³x/dt³", "x⃛")
    
    Otherwise if from_style is equal to "operator" && to_style is equal to "leibniz":
        Note: Convert operator notation to Leibniz notation
        Set converted_expression to String.replace(converted_expression, "Df", "df/dx")
        Set converted_expression to String.replace(converted_expression, "D²f", "d²f/dx²")
        Set converted_expression to String.replace(converted_expression, "D³f", "d³f/dx³")
    
    Otherwise if from_style is equal to "leibniz" && to_style is equal to "operator":
        Note: Convert Leibniz notation to operator notation
        Set converted_expression to String.replace(converted_expression, "df/dx", "Df")
        Set converted_expression to String.replace(converted_expression, "d²f/dx²", "D²f")
        Set converted_expression to String.replace(converted_expression, "d³f/dx³", "D³f")
    
    Note: Apply general formatting conversion
    Let converted_expression be format_calculus_expression(converted_expression, to_style)
    
    Return converted_expression

Process called "benchmark_calculus_symbols" that takes operation_types as List[String] returns Dictionary[String, Float]:
    Note: Benchmark performance of calculus symbol operations
    Let benchmarks be {}
    Let iterations be 1000
    
    Note: Benchmark each requested operation type
    For operation_type in operation_types:
        If operation_type is equal to "differential_operators":
            Let start_time be System.current_time_microseconds()
            Let i be 0
            While i is less than iterations:
                Let _ be get_differential_operators()
                Let _ be partial_derivative_symbol()
                Let _ be total_derivative_symbol()
                Set i to i plus 1
            Let end_time be System.current_time_microseconds()
            Let elapsed_ms be (end_time minus start_time) / 1000.0
            Set benchmarks["differential_operators"] to elapsed_ms
        
        Otherwise if operation_type is equal to "integral_symbols":
            Let start_time be System.current_time_microseconds()
            Let i be 0
            While i is less than iterations:
                Let _ be get_integral_symbols()
                Let _ be single_integral_symbol()
                Let _ be double_integral_symbol()
                Set i to i plus 1
            Let end_time be System.current_time_microseconds()
            Let elapsed_ms be (end_time minus start_time) / 1000.0
            Set benchmarks["integral_symbols"] to elapsed_ms
        
        Otherwise if operation_type is equal to "limit_notation":
            Let start_time be System.current_time_microseconds()
            Let i be 0
            While i is less than iterations:
                Let _ be get_limit_symbols()
                Let _ be limit_symbol()
                Let _ be approaches_symbol()
                Set i to i plus 1
            Let end_time be System.current_time_microseconds()
            Let elapsed_ms be (end_time minus start_time) / 1000.0
            Set benchmarks["limit_notation"] to elapsed_ms
        
        Otherwise if operation_type is equal to "vector_operators":
            Let start_time be System.current_time_microseconds()
            Let i be 0
            While i is less than iterations:
                Let _ be get_vector_operators()
                Let _ be gradient_symbol()
                Let _ be divergence_symbol()
                Let _ be curl_symbol()
                Set i to i plus 1
            Let end_time be System.current_time_microseconds()
            Let elapsed_ms be (end_time minus start_time) / 1000.0
            Set benchmarks["vector_operators"] to elapsed_ms
        
        Otherwise if operation_type is equal to "notation_validation":
            Let start_time be System.current_time_microseconds()
            Let test_expressions be ["df/dx", "∫f(x)dx", "lim_{x→0} f(x)", "∑_{i=1}^n a_i"]
            Let i be 0
            While i is less than iterations:
                For expr in test_expressions:
                    Let _ be validate_calculus_notation(expr)
                Set i to i plus 1
            Let end_time be System.current_time_microseconds()
            Let elapsed_ms be (end_time minus start_time) / 1000.0
            Set benchmarks["notation_validation"] to elapsed_ms
        
        Otherwise if operation_type is equal to "expression_formatting":
            Let start_time be System.current_time_microseconds()
            Let test_expr be "alpha plus beta multiplied by integral f(x) dx"
            Let i be 0
            While i is less than iterations:
                Let _ be format_calculus_expression(test_expr, "unicode")
                Let _ be format_calculus_expression(test_expr, "latex")
                Let _ be format_calculus_expression(test_expr, "ascii")
                Set i to i plus 1
            Let end_time be System.current_time_microseconds()
            Let elapsed_ms be (end_time minus start_time) / 1000.0
            Set benchmarks["expression_formatting"] to elapsed_ms
    
    Return benchmarks