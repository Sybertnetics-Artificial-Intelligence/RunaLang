Note:
math/symbols/formatting.runa
Mathematical Symbol Formatting and Display System

This module provides comprehensive mathematical symbol formatting including:
- Symbol alignment and spacing rules
- Multi-line mathematical expression formatting
- Symbol size and scaling adjustments
- Font style application and management
- Color coding for mathematical expressions
- Accessibility formatting for screen readers
- Print and digital media formatting differences
- Cross-platform symbol rendering compatibility
- Mathematical typesetting rules and conventions
- Symbol kerning and baseline adjustments
- Expression layout optimization
- Interactive symbol highlighting
- Dynamic symbol scaling for responsive display
- Mathematical notation style guide compliance
- Symbol substitution for limited character sets
:End Note

Import module "dev/debug/errors/core" as Errors

Note: =====================================================================
Note: FORMATTING DATA STRUCTURES
Note: =====================================================================

Type called "SymbolFormat":
    symbol as String
    font_family as String
    font_size as String
    font_weight as String
    font_style as String
    color as String
    background_color as String
    spacing_before as String
    spacing_after as String

Type called "ExpressionLayout":
    expression_parts as List[Dictionary[String, String]]
    alignment_type as String
    line_breaks as List[Integer]
    indentation_levels as List[Integer]
    baseline_adjustments as List[String]
    overall_width as String
    overall_height as String

Type called "RenderingContext":
    output_format as String
    target_medium as String
    resolution as String
    color_support as Boolean
    font_capabilities as Dictionary[String, Boolean]
    accessibility_features as List[String]

Type called "StyleGuide":
    guide_name as String
    symbol_preferences as Dictionary[String, String]
    spacing_rules as Dictionary[String, String]
    color_scheme as Dictionary[String, String]
    typography_rules as Dictionary[String, String]

Note: =====================================================================
Note: BASIC FORMATTING OPERATIONS
Note: =====================================================================

Process called "format_mathematical_symbol" that takes symbol as String, format_options as Dictionary[String, String] returns SymbolFormat:
    Note: Apply formatting to mathematical symbol
    
    Note: Extract formatting options or use defaults
    Let font_family be Dictionary.get(format_options, "font_family", "Latin Modern Math")
    Let font_size be Dictionary.get(format_options, "font_size", "1em")
    Let font_weight be Dictionary.get(format_options, "font_weight", "normal")
    Let font_style be Dictionary.get(format_options, "font_style", "normal")
    Let color be Dictionary.get(format_options, "color", "#000000")
    Let background_color be Dictionary.get(format_options, "background_color", "transparent")
    Let spacing_before be Dictionary.get(format_options, "spacing_before", "0")
    Let spacing_after be Dictionary.get(format_options, "spacing_after", "0")
    
    Note: Apply special formatting for specific symbol types
    If symbol is equal to "∇" || symbol is equal to "∆" || symbol is equal to "∂":
        Set font_weight to "bold"
        Set spacing_before to "0.2em"
        Set spacing_after to "0.1em"
    
    Otherwise if symbol is equal to "∫" || symbol is equal to "∑" || symbol is equal to "∏":
        Set font_size to "1.2em"
        Set spacing_before to "0.1em"
        Set spacing_after to "0.2em"
    
    Otherwise if String.length(symbol) is equal to 1 && String.is_greek_letter(symbol):
        Set font_style to "italic"
        Set spacing_before to "0.05em"
        Set spacing_after to "0.05em"
    
    Return {
        "symbol": symbol,
        "font_family": font_family,
        "font_size": font_size,
        "font_weight": font_weight,
        "font_style": font_style,
        "color": color,
        "background_color": background_color,
        "spacing_before": spacing_before,
        "spacing_after": spacing_after
    }

Process called "format_expression" that takes expression as String, formatting_style as String returns String:
    Note: Format complete mathematical expression
    Let formatted_expr be expression
    
    If formatting_style is equal to "display":
        Note: Display style for standalone equations
        Set formatted_expr to String.replace(formatted_expr, "∫", "<span class='display-integral'>∫</span>")
        Set formatted_expr to String.replace(formatted_expr, "∑", "<span class='display-sum'>∑</span>")
        Set formatted_expr to String.replace(formatted_expr, "=", " <span class='equals'>=</span> ")
        Set formatted_expr to String.replace(formatted_expr, "+", " <span class='operator'>+</span> ")
        Set formatted_expr to String.replace(formatted_expr, "-", " <span class='operator'>−</span> ")
    
    Otherwise if formatting_style is equal to "inline":
        Note: Inline style for text flow
        Set formatted_expr to String.replace(formatted_expr, "∫", "<span class='inline-integral'>∫</span>")
        Set formatted_expr to String.replace(formatted_expr, "∑", "<span class='inline-sum'>∑</span>")
        Set formatted_expr to String.replace(formatted_expr, "=", "<span class='inline-equals'>=</span>")
    
    Otherwise if formatting_style is equal to "compact":
        Note: Compact style for space-limited contexts
        Set formatted_expr to String.replace(formatted_expr, " ", "")
        Set formatted_expr to String.replace(formatted_expr, "∫ ", "∫")
        Set formatted_expr to String.replace(formatted_expr, "∑ ", "∑")
    
    Otherwise if formatting_style is equal to "accessible":
        Note: Accessible style with semantic markup
        Set formatted_expr to String.replace(formatted_expr, "∫", "<span role='math' aria-label='integral'>∫</span>")
        Set formatted_expr to String.replace(formatted_expr, "∑", "<span role='math' aria-label='sum'>∑</span>")
        Set formatted_expr to String.replace(formatted_expr, "∂", "<span role='math' aria-label='partial derivative'>∂</span>")
    
    Return formatted_expr

Process called "apply_font_style" that takes text as String, font_style as String returns String:
    Note: Apply font style to mathematical text (bold, italic, script, etc.)
    
    If font_style is equal to "bold":
        Note: Apply bold mathematical font
        Let styled_text be "<span style='font-weight: bold; font-family: \"Latin Modern Math\", \"STIX Two Math\", math;'>" plus text plus "</span>"
        Return styled_text
    
    Otherwise if font_style is equal to "italic":
        Note: Apply italic mathematical font  
        Let styled_text be "<span style='font-style: italic; font-family: \"Latin Modern Math\", \"STIX Two Math\", math;'>" plus text plus "</span>"
        Return styled_text
    
    Otherwise if font_style is equal to "script":
        Note: Apply script/calligraphic mathematical font
        Let styled_text be "<span style='font-family: \"Latin Modern Math\", \"STIX Two Math\", cursive; font-variant: stylistic(01);'>" plus text plus "</span>"
        Return styled_text
    
    Otherwise if font_style is equal to "blackboard":
        Note: Apply blackboard bold font (for sets like ℕ, ℝ, ℂ)
        Let styled_text be "<span style='font-family: \"Latin Modern Math\", \"STIX Two Math\", \"Blackboard Bold\", serif;'>" plus text plus "</span>"
        Return styled_text
    
    Otherwise if font_style is equal to "fraktur":
        Note: Apply Fraktur mathematical font
        Let styled_text be "<span style='font-family: \"Latin Modern Math\", \"STIX Two Math\", \"Fraktur\", serif;'>" plus text plus "</span>"
        Return styled_text
    
    Otherwise if font_style is equal to "monospace":
        Note: Apply monospace font for code-like math
        Let styled_text be "<span style='font-family: \"JuliaMono\", \"Fira Code\", \"Consolas\", monospace;'>" plus text plus "</span>"
        Return styled_text
    
    Otherwise if font_style is equal to "sans-serif":
        Note: Apply sans-serif mathematical font
        Let styled_text be "<span style='font-family: \"Latin Modern Sans\", \"Helvetica\", sans-serif;'>" plus text plus "</span>"
        Return styled_text
    
    Note: Default: return text unchanged
    Return text

Process called "adjust_symbol_size" that takes symbol as String, size_factor as Float returns String:
    Note: Adjust symbol size relative to base font size
    
    Note: Calculate size in em units
    Let size_em be Float.to_string(size_factor) plus "em"
    
    Note: Special handling for large operators
    If symbol is equal to "∫" || symbol is equal to "∑" || symbol is equal to "∏" || symbol is equal to "∬" || symbol is equal to "∭":
        Note: Large operators need additional vertical alignment
        Let adjusted_symbol be "<span style='font-size: " plus size_em plus "; vertical-align: -0.25em; display: inline-block;'>" plus symbol plus "</span>"
        Return adjusted_symbol
    
    Otherwise if symbol is equal to "∂" || symbol is equal to "∇" || symbol is equal to "∆":
        Note: Differential operators
        Let adjusted_symbol be "<span style='font-size: " plus size_em plus "; font-weight: bold;'>" plus symbol plus "</span>"
        Return adjusted_symbol
    
    Otherwise if size_factor is less than 0.8:
        Note: Small size minus subscript style
        Let adjusted_symbol be "<span style='font-size: " plus size_em plus "; vertical-align: sub;'>" plus symbol plus "</span>"
        Return adjusted_symbol
    
    Otherwise if size_factor is greater than 1.2:
        Note: Large size minus display style
        Let adjusted_symbol be "<span style='font-size: " plus size_em plus "; display: inline-block; vertical-align: middle;'>" plus symbol plus "</span>"
        Return adjusted_symbol
    
    Otherwise:
        Note: Normal size adjustment
        Let adjusted_symbol be "<span style='font-size: " plus size_em plus ";'>" plus symbol plus "</span>"
        Return adjusted_symbol

Note: =====================================================================
Note: SPACING AND ALIGNMENT OPERATIONS
Note: =====================================================================

Process called "calculate_symbol_spacing" that takes left_symbol as String, right_symbol as String, context as String returns String:
    Note: Calculate appropriate spacing between symbols
    
    Note: Define spacing categories
    Let operator_symbols be ["+", "-", "×", "÷", "=", "≠", "<", ">", "≤", "≥"]
    Let large_operators be ["∫", "∑", "∏", "∬", "∭", "∮"]
    Let delimiters be ["(", ")", "[", "]", "{", "}"]
    Let differential_ops be ["∂", "∇", "∆", "d"]
    
    Note: Check for operator spacing
    If List.contains(operator_symbols, left_symbol) || List.contains(operator_symbols, right_symbol):
        If context is equal to "inline":
            Return "0.2em"
        Otherwise:
            Return "0.3em"
    
    Note: Large operator spacing
    If List.contains(large_operators, left_symbol):
        If right_symbol is equal to "(" || right_symbol is equal to "{":
            Return "0.1em"
        Otherwise:
            Return "0.2em"
    
    Note: Differential operator spacing
    If List.contains(differential_ops, left_symbol) && right_symbol does not equal "/":
        Return "0.1em"
    
    Note: Delimiter spacing
    If List.contains(delimiters, left_symbol) || List.contains(delimiters, right_symbol):
        Return "0.05em"
    
    Note: Function name spacing (like sin, cos, log)
    If String.is_alphabetic(left_symbol) && String.is_alphabetic(right_symbol):
        Return "0.1em"
    
    Note: Subscript/superscript context
    If context is equal to "subscript" || context is equal to "superscript":
        Return "0.02em"
    
    Note: Default spacing
    Return "0.15em"

Process called "align_mathematical_expressions" that takes expressions as List[String], alignment_type as String returns ExpressionLayout:
    Note: Align multiple mathematical expressions
    Let expression_parts be []
    Let line_breaks be []
    Let indentation_levels be []
    Let baseline_adjustments be []
    
    Let i be 0
    For expr in expressions:
        If alignment_type is equal to "left":
            Let part be {
                "expression": expr,
                "alignment": "left",
                "margin_left": "0",
                "margin_right": "auto"
            }
            Let expression_parts be List.append(expression_parts, part)
            Let indentation_levels be List.append(indentation_levels, 0)
        
        Otherwise if alignment_type is equal to "center":
            Let part be {
                "expression": expr,
                "alignment": "center",
                "margin_left": "auto",
                "margin_right": "auto"
            }
            Let expression_parts be List.append(expression_parts, part)
            Let indentation_levels be List.append(indentation_levels, 0)
        
        Otherwise if alignment_type is equal to "equals":
            Note: Align on is equal to signs
            If String.contains(expr, "="):
                Let equals_position be String.index_of(expr, "=")
                Let part be {
                    "expression": expr,
                    "alignment": "equals",
                    "equals_position": Integer.to_string(equals_position)
                }
                Let expression_parts be List.append(expression_parts, part)
                Let indentation_levels be List.append(indentation_levels, equals_position)
            Otherwise:
                Let part be {
                    "expression": expr,
                    "alignment": "left",
                    "margin_left": "2em"
                }
                Let expression_parts be List.append(expression_parts, part)
                Let indentation_levels be List.append(indentation_levels, 2)
        
        Otherwise if alignment_type is equal to "right":
            Let part be {
                "expression": expr,
                "alignment": "right",
                "margin_left": "auto",
                "margin_right": "0"
            }
            Let expression_parts be List.append(expression_parts, part)
            Let indentation_levels be List.append(indentation_levels, 0)
        
        Let line_breaks be List.append(line_breaks, i)
        Let baseline_adjustments be List.append(baseline_adjustments, "0em")
        Set i to i plus 1
    
    Return {
        "expression_parts": expression_parts,
        "alignment_type": alignment_type,
        "line_breaks": line_breaks,
        "indentation_levels": indentation_levels,
        "baseline_adjustments": baseline_adjustments,
        "overall_width": "100%",
        "overall_height": "auto"
    }

Process called "apply_operator_spacing" that takes expression as String, operator_spacing_rules as Dictionary[String, String] returns String:
    Note: Apply proper spacing around mathematical operators
    Let spaced_expression be expression
    Let operators be ["+", "-", "*", "/", "=", "≠", "<", ">", "≤", "≥", "±", "∓", "×", "÷"]
    
    For each operator in operators:
        Let spacing_key be "spacing_" plus operator
        Let default_spacing be "0.2em"
        
        If operator is equal to "=" || operator is equal to "≠":
            Set default_spacing to "0.3em"
        Otherwise if operator is equal to "×" || operator is equal to "÷":
            Set default_spacing to "0.25em"
        Otherwise if operator is equal to "±" || operator is equal to "∓":
            Set default_spacing to "0.15em"
        Otherwise if operator is equal to "<" || operator is equal to ">" || operator is equal to "≤" || operator is equal to "≥":
            Set default_spacing to "0.25em"
        
        Let operator_spacing be Dictionary.get(operator_spacing_rules, spacing_key, default_spacing)
        
        If String.contains(spaced_expression, operator):
            Let unspaced_pattern be operator
            Let spaced_pattern be "<span style='margin: 0 " plus operator_spacing plus ";'>" plus operator plus "</span>"
            
            Set spaced_expression to String.replace(spaced_expression, " " plus operator plus " ", " " plus spaced_pattern plus " ")
            Set spaced_expression to String.replace(spaced_expression, operator, spaced_pattern)
    
    Return spaced_expression

Process called "format_subscript_superscript" that takes base as String, subscript as String, superscript as String returns String:
    Note: Format subscript and superscript positioning
    Let formatted_expression be base
    
    Note: Handle cases where both subscript and superscript are present
    If subscript does not equal "" && superscript does not equal "":
        Set formatted_expression to formatted_expression plus "<span style='position: relative;'>" +
            "<span style='position: absolute; font-size: 0.7em; vertical-align: sub; left: 0; bottom: -0.5em;'>" plus subscript plus "</span>" +
            "<span style='position: absolute; font-size: 0.7em; vertical-align: super; left: 0; top: -0.8em;'>" plus superscript plus "</span>" +
            "</span>"
    
    Note: Handle subscript only
    Otherwise if subscript does not equal "" && superscript is equal to "":
        Set formatted_expression to formatted_expression plus "<sub style='font-size: 0.7em; vertical-align: sub;'>" plus subscript plus "</sub>"
    
    Note: Handle superscript only  
    Otherwise if subscript is equal to "" && superscript does not equal "":
        Set formatted_expression to formatted_expression plus "<sup style='font-size: 0.7em; vertical-align: super;'>" plus superscript plus "</sup>"
    
    Note: Adjust spacing for mathematical context
    If subscript does not equal "" || superscript does not equal "":
        Set formatted_expression to "<span style='margin-right: 0.1em;'>" plus formatted_expression plus "</span>"
    
    Return formatted_expression

Note: =====================================================================
Note: MULTI-LINE FORMATTING OPERATIONS
Note: =====================================================================

Process called "format_multiline_equation" that takes equation_parts as List[String], alignment_points as List[String] returns ExpressionLayout:
    Note: Format equation across multiple lines with alignment
    Let line_heights be []
    Let line_widths be []
    Let alignment_offsets be []
    
    For each part in equation_parts:
        Let formatted_part be format_mathematical_symbol(part, {"font_size": "12pt"})
        Append formatted_part.height to line_heights
        Append formatted_part.width to line_widths
    
    Let max_width be 0
    For each width in line_widths:
        If width is greater than max_width:
            Set max_width to width
    
    For each i from 0 to length(alignment_points) minus 1:
        Let point be List.get(alignment_points, i)
        If point is equal to "left":
            Append 0 to alignment_offsets
        Otherwise if point is equal to "center":
            Let part_width be List.get(line_widths, i)
            Append (max_width minus part_width) / 2 to alignment_offsets
        Otherwise if point is equal to "right":
            Let part_width be List.get(line_widths, i)
            Append max_width minus part_width to alignment_offsets
        Otherwise:
            Append 0 to alignment_offsets
    
    Return {
        "layout_type": "multiline",
        "equation_parts": equation_parts,
        "line_heights": line_heights,
        "line_widths": line_widths,
        "alignment_offsets": alignment_offsets,
        "total_width": max_width,
        "total_height": Collections.sum(line_heights),
        "baseline_offsets": line_heights
    }

Process called "break_long_expression" that takes expression as String, max_width as Integer returns List[String]:
    Note: Break long expression into multiple lines
    Let lines be []
    Let current_line be ""
    Let current_width be 0
    Let operators be ["+", "-", "*", "/", "=", "<", ">", "≤", "≥", "≠"]
    
    Let i be 0
    While i is less than length(expression):
        Let char be String.charAt(expression, i)
        Let char_width be get_character_width(char)
        
        If current_width plus char_width is greater than max_width:
            If Collections.contains(operators, char) && current_line does not equal "":
                Append current_line to lines
                Set current_line to String.repeat(" ", 4) plus char
                Set current_width to 4 plus char_width
            Otherwise if current_line does not equal "":
                Append current_line to lines
                Set current_line to String.repeat(" ", 4) plus char
                Set current_width to 4 plus char_width
            Otherwise:
                Set current_line to current_line plus char
                Set current_width to current_width plus char_width
        Otherwise:
            Set current_line to current_line plus char
            Set current_width to current_width plus char_width
        
        Set i to i plus 1
    
    If current_line does not equal "":
        Append current_line to lines
    
    Return lines

Process called "indent_mathematical_content" that takes content as List[String], indentation_rules as Dictionary[String, String] returns List[String]:
    Note: Apply indentation to mathematical content
    Let indented_content be []
    Let base_indent be Dictionary.get(indentation_rules, "base_indent", "0")
    Let nested_indent be Dictionary.get(indentation_rules, "nested_indent", "4")
    Let equation_indent be Dictionary.get(indentation_rules, "equation_indent", "8")
    
    For each line in content:
        Let trimmed_line be String.trim(line)
        Let indent_amount be base_indent
        
        If String.startsWith(trimmed_line, "(") || String.startsWith(trimmed_line, "[") || String.startsWith(trimmed_line, "{"):
            Set indent_amount to nested_indent
        Otherwise if String.contains(trimmed_line, "=") || String.contains(trimmed_line, "∫") || String.contains(trimmed_line, "∑"):
            Set indent_amount to equation_indent
        
        Let indented_line be String.repeat(" ", String.toInteger(indent_amount)) plus trimmed_line
        Append indented_line to indented_content
    
    Return indented_content

Process called "format_nested_expressions" that takes nested_structure as Dictionary[String, String], nesting_level as Integer returns String:
    Note: Format nested mathematical expressions with proper hierarchy
    Let formatted_expression be ""
    Let indent_size be nesting_level multiplied by 2
    Let base_indent be String.repeat(" ", indent_size)
    
    Let expression_type be Dictionary.get(nested_structure, "type", "default")
    Let content be Dictionary.get(nested_structure, "content", "")
    Let children be Dictionary.get(nested_structure, "children", "")
    
    If expression_type is equal to "parentheses":
        Set formatted_expression to "("
    Otherwise if expression_type is equal to "brackets":
        Set formatted_expression to "["
    Otherwise if expression_type is equal to "braces":
        Set formatted_expression to "{"
    
    If nesting_level is greater than 0:
        Set formatted_expression to base_indent plus formatted_expression
    
    Set formatted_expression to formatted_expression plus content
    
    If children does not equal "":
        Set formatted_expression to formatted_expression plus "\n" plus format_nested_expressions(
            Dictionary.fromString(children), nesting_level plus 1
        )
    
    If expression_type is equal to "parentheses":
        Set formatted_expression to formatted_expression plus ")"
    Otherwise if expression_type is equal to "brackets":
        Set formatted_expression to formatted_expression plus "]"
    Otherwise if expression_type is equal to "braces":
        Set formatted_expression to formatted_expression plus "}"
    
    Return formatted_expression

Note: =====================================================================
Note: COLOR AND HIGHLIGHTING OPERATIONS
Note: =====================================================================

Process called "apply_color_coding" that takes expression as String, color_scheme as Dictionary[String, String] returns String:
    Note: Apply color coding to mathematical expression parts
    Let colored_expression be expression
    Let operators be ["+", "-", "*", "/", "=", "<", ">", "≤", "≥", "≠", "∫", "∑", "∏", "∇"]
    Let functions be ["sin", "cos", "tan", "log", "ln", "exp", "sqrt"]
    Let variables be ["x", "y", "z", "t", "n", "i", "j", "k"]
    
    Let operator_color be Dictionary.get(color_scheme, "operators", "#FF6B6B")
    Let function_color be Dictionary.get(color_scheme, "functions", "#4ECDC4")
    Let variable_color be Dictionary.get(color_scheme, "variables", "#45B7D1")
    Let constant_color be Dictionary.get(color_scheme, "constants", "#96CEB4")
    
    For each operator in operators:
        If String.contains(colored_expression, operator):
            Set colored_expression to String.replace(colored_expression, operator, 
                "<span style='color:" plus operator_color plus "'>" plus operator plus "</span>")
    
    For each func in functions:
        If String.contains(colored_expression, func):
            Set colored_expression to String.replace(colored_expression, func,
                "<span style='color:" plus function_color plus "'>" plus func plus "</span>")
    
    For each variable in variables:
        If String.contains(colored_expression, variable):
            Set colored_expression to String.replace(colored_expression, variable,
                "<span style='color:" plus variable_color plus "'>" plus variable plus "</span>")
    
    Return colored_expression

Process called "highlight_expression_parts" that takes expression as String, parts_to_highlight as List[String], highlight_style as String returns String:
    Note: Highlight specific parts of mathematical expression
    Let highlighted_expression be expression
    
    If highlight_style is equal to "background":
        Let highlight_prefix be "<mark style='background-color: #FFEB3B;'>"
        Let highlight_suffix be "</mark>"
    Otherwise if highlight_style is equal to "underline":
        Let highlight_prefix be "<u style='text-decoration: underline; text-decoration-color: #FF5722;'>"
        Let highlight_suffix be "</u>"
    Otherwise if highlight_style is equal to "bold":
        Let highlight_prefix be "<strong>"
        Let highlight_suffix be "</strong>"
    Otherwise:
        Let highlight_prefix be "<span style='background-color: #E3F2FD;'>"
        Let highlight_suffix be "</span>"
    
    For each part in parts_to_highlight:
        If String.contains(highlighted_expression, part):
            Set highlighted_expression to String.replace(highlighted_expression, part,
                highlight_prefix plus part plus highlight_suffix)
    
    Return highlighted_expression

Process called "create_color_gradient" that takes start_color as String, end_color as String, steps as Integer returns List[String]:
    Note: Create color gradient for mathematical visualization
    Let gradient_colors be []
    
    Note: Parse start color (assuming hex format #RRGGBB)
    Let start_red be String.toInteger(String.substring(start_color, 1, 3), 16)
    Let start_green be String.toInteger(String.substring(start_color, 3, 5), 16)
    Let start_blue be String.toInteger(String.substring(start_color, 5, 7), 16)
    
    Note: Parse end color
    Let end_red be String.toInteger(String.substring(end_color, 1, 3), 16)
    Let end_green be String.toInteger(String.substring(end_color, 3, 5), 16)
    Let end_blue be String.toInteger(String.substring(end_color, 5, 7), 16)
    
    Note: Calculate color steps
    Let red_step be (end_red minus start_red) / (steps minus 1)
    Let green_step be (end_green minus start_green) / (steps minus 1)
    Let blue_step be (end_blue minus start_blue) / (steps minus 1)
    
    Let i be 0
    While i is less than steps:
        Let current_red be start_red plus (red_step multiplied by i)
        Let current_green be start_green plus (green_step multiplied by i)
        Let current_blue be start_blue plus (blue_step multiplied by i)
        
        Note: Ensure values are within valid range
        Set current_red to Math.max(0, Math.min(255, Math.round(current_red)))
        Set current_green to Math.max(0, Math.min(255, Math.round(current_green)))
        Set current_blue to Math.max(0, Math.min(255, Math.round(current_blue)))
        
        Note: Convert back to hex format
        Let hex_red be String.toHex(current_red, 2)
        Let hex_green be String.toHex(current_green, 2)
        Let hex_blue be String.toHex(current_blue, 2)
        Let gradient_color be "#" plus hex_red plus hex_green plus hex_blue
        
        Append gradient_color to gradient_colors
        Set i to i plus 1
    
    Return gradient_colors

Process called "apply_syntax_highlighting" that takes mathematical_code as String, syntax_rules as Dictionary[String, String] returns String:
    Note: Apply syntax highlighting to mathematical code
    Let highlighted_code be mathematical_code
    
    Note: Get color scheme from syntax rules
    Let operator_color be Dictionary.get(syntax_rules, "operator_color", "#FF6B6B")
    Let function_color be Dictionary.get(syntax_rules, "function_color", "#4ECDC4")
    Let variable_color be Dictionary.get(syntax_rules, "variable_color", "#45B7D1")
    Let constant_color be Dictionary.get(syntax_rules, "constant_color", "#96CEB4")
    Let keyword_color be Dictionary.get(syntax_rules, "keyword_color", "#9B59B6")
    Let number_color be Dictionary.get(syntax_rules, "number_color", "#F39C12")
    Let string_color be Dictionary.get(syntax_rules, "string_color", "#2ECC71")
    
    Note: Define mathematical operators
    Let operators be ["+", "-", "*", "/", "=", "≠", "<", ">", "≤", "≥", "±", "∓", "×", "÷", "∫", "∑", "∏", "∇", "∂", "Δ"]
    
    Note: Define mathematical functions
    Let functions be ["sin", "cos", "tan", "sec", "csc", "cot", "asin", "acos", "atan", "sinh", "cosh", "tanh", 
                     "log", "ln", "exp", "sqrt", "abs", "floor", "ceil", "round", "max", "min"]
    
    Note: Define mathematical constants
    Let constants be ["π", "e", "φ", "∞", "i", "ℯ", "ℑ", "ℜ"]
    
    Note: Define mathematical keywords
    Let keywords be ["Let", "Set", "If", "Otherwise", "For", "While", "Return", "Process", "Type", "Import", "Note"]
    
    Note: Apply operator highlighting
    For each operator in operators:
        If String.contains(highlighted_code, operator):
            Set highlighted_code to String.replace(highlighted_code, operator,
                "<span style='color:" plus operator_color plus "; font-weight: bold;'>" plus operator plus "</span>")
    
    Note: Apply function highlighting
    For each function in functions:
        If String.contains(highlighted_code, function):
            Set highlighted_code to String.replace(highlighted_code, function,
                "<span style='color:" plus function_color plus "; font-style: italic;'>" plus function plus "</span>")
    
    Note: Apply constant highlighting
    For each constant in constants:
        If String.contains(highlighted_code, constant):
            Set highlighted_code to String.replace(highlighted_code, constant,
                "<span style='color:" plus constant_color plus "; font-weight: bold;'>" plus constant plus "</span>")
    
    Note: Apply keyword highlighting
    For each keyword in keywords:
        If String.contains(highlighted_code, keyword):
            Set highlighted_code to String.replace(highlighted_code, keyword,
                "<span style='color:" plus keyword_color plus "; font-weight: bold;'>" plus keyword plus "</span>")
    
    Note: Apply number highlighting using regex pattern
    Set highlighted_code to String.replaceRegex(highlighted_code, "\\b\\d+(\\.\\d+)?\\b",
        "<span style='color:" plus number_color plus ";'>$0</span>")
    
    Note: Apply string highlighting for quoted content
    Set highlighted_code to String.replaceRegex(highlighted_code, "\"([^\"]*?)\"",
        "<span style='color:" plus string_color plus ";'>\"$1\"</span>")
    
    Return highlighted_code

Note: =====================================================================
Note: ACCESSIBILITY FORMATTING OPERATIONS
Note: =====================================================================

Process called "format_for_screen_reader" that takes mathematical_expression as String, verbosity_level as String returns String:
    Note: Format mathematical expression for screen reader accessibility
    Let accessible_expression be mathematical_expression
    
    If verbosity_level is equal to "high":
        Set accessible_expression to String.replace(accessible_expression, "∫", "<span aria-label='integral from lower bound to upper bound of'>∫</span>")
        Set accessible_expression to String.replace(accessible_expression, "∑", "<span aria-label='summation from lower index to upper index of'>∑</span>")
        Set accessible_expression to String.replace(accessible_expression, "∏", "<span aria-label='product from lower index to upper index of'>∏</span>")
        Set accessible_expression to String.replace(accessible_expression, "∂", "<span aria-label='partial derivative with respect to'>∂</span>")
        Set accessible_expression to String.replace(accessible_expression, "∇", "<span aria-label='gradient operator'>∇</span>")
    Otherwise if verbosity_level is equal to "medium":
        Set accessible_expression to String.replace(accessible_expression, "∫", "<span aria-label='integral'>∫</span>")
        Set accessible_expression to String.replace(accessible_expression, "∑", "<span aria-label='sum'>∑</span>")
        Set accessible_expression to String.replace(accessible_expression, "∏", "<span aria-label='product'>∏</span>")
        Set accessible_expression to String.replace(accessible_expression, "∂", "<span aria-label='partial'>∂</span>")
        Set accessible_expression to String.replace(accessible_expression, "∇", "<span aria-label='nabla'>∇</span>")
    Otherwise:
        Set accessible_expression to String.replace(accessible_expression, "∫", "<span role='math'>∫</span>")
        Set accessible_expression to String.replace(accessible_expression, "∑", "<span role='math'>∑</span>")
        Set accessible_expression to String.replace(accessible_expression, "∏", "<span role='math'>∏</span>")
    
    Return accessible_expression

Process called "generate_alt_text" that takes mathematical_symbol as String, context as String returns String:
    Note: Generate alternative text description for mathematical symbol
    Let alt_text be ""
    
    If mathematical_symbol is equal to "∫":
        If context is equal to "definite":
            Set alt_text to "definite integral"
        Otherwise if context is equal to "indefinite":
            Set alt_text to "indefinite integral"
        Otherwise:
            Set alt_text to "integral"
    Otherwise if mathematical_symbol is equal to "∑":
        Set alt_text to "summation"
    Otherwise if mathematical_symbol is equal to "∏":
        Set alt_text to "product"
    Otherwise if mathematical_symbol is equal to "∂":
        Set alt_text to "partial derivative"
    Otherwise if mathematical_symbol is equal to "∇":
        If context is equal to "gradient":
            Set alt_text to "gradient"
        Otherwise if context is equal to "divergence":
            Set alt_text to "divergence"
        Otherwise:
            Set alt_text to "del operator"
    Otherwise if mathematical_symbol is equal to "Δ":
        Set alt_text to "delta"
    Otherwise if mathematical_symbol is equal to "π":
        Set alt_text to "pi"
    Otherwise if mathematical_symbol is equal to "∞":
        Set alt_text to "infinity"
    Otherwise if mathematical_symbol is equal to "≤":
        Set alt_text to "less than or equal to"
    Otherwise if mathematical_symbol is equal to "≥":
        Set alt_text to "greater than or equal to"
    Otherwise if mathematical_symbol is equal to "≠":
        Set alt_text to "not equal to"
    Otherwise if mathematical_symbol is equal to "±":
        Set alt_text to "plus or minus"
    Otherwise if mathematical_symbol is equal to "×":
        Set alt_text to "times"
    Otherwise if mathematical_symbol is equal to "÷":
        Set alt_text to "divided by"
    Otherwise:
        Set alt_text to "mathematical symbol " plus mathematical_symbol
    
    Return alt_text

Process called "create_braille_math_format" that takes expression as String returns String:
    Note: Convert mathematical expression to Braille format
    Let braille_expression be expression
    
    Note: Mathematical Braille symbol mappings (Nemeth Code)
    Set braille_expression to String.replace(braille_expression, "+", "⠖")
    Set braille_expression to String.replace(braille_expression, "-", "⠤")
    Set braille_expression to String.replace(braille_expression, "*", "⠦")
    Set braille_expression to String.replace(braille_expression, "×", "⠦")
    Set braille_expression to String.replace(braille_expression, "/", "⠌")
    Set braille_expression to String.replace(braille_expression, "÷", "⠌")
    Set braille_expression to String.replace(braille_expression, "=", "⠿")
    Set braille_expression to String.replace(braille_expression, "<", "⠅")
    Set braille_expression to String.replace(braille_expression, ">", "⠜")
    Set braille_expression to String.replace(braille_expression, "≤", "⠅⠿")
    Set braille_expression to String.replace(braille_expression, "≥", "⠜⠿")
    Set braille_expression to String.replace(braille_expression, "≠", "⠌⠿")
    
    Note: Greek letters and special symbols
    Set braille_expression to String.replace(braille_expression, "π", "⠏⠊")
    Set braille_expression to String.replace(braille_expression, "α", "⠁⠇⠏⠓⠁")
    Set braille_expression to String.replace(braille_expression, "β", "⠃⠑⠞⠁")
    Set braille_expression to String.replace(braille_expression, "γ", "⠛⠁⠍⠍⠁")
    Set braille_expression to String.replace(braille_expression, "∞", "⠊⠝⠋⠊⠝⠊⠞⠽")
    
    Note: Mathematical operators
    Set braille_expression to String.replace(braille_expression, "∫", "⠊⠝⠞⠑⠛⠗⠁⠇")
    Set braille_expression to String.replace(braille_expression, "∑", "⠎⠥⠍")
    Set braille_expression to String.replace(braille_expression, "∏", "⠏⠗⠕⠙⠥⠉⠞")
    Set braille_expression to String.replace(braille_expression, "∂", "⠏⠁⠗⠞⠊⠁⠇")
    Set braille_expression to String.replace(braille_expression, "∇", "⠙⠑⠇")
    Set braille_expression to String.replace(braille_expression, "√", "⠎⠟⠗⠞")
    
    Note: Parentheses and brackets
    Set braille_expression to String.replace(braille_expression, "(", "⠐⠣")
    Set braille_expression to String.replace(braille_expression, ")", "⠐⠜")
    Set braille_expression to String.replace(braille_expression, "[", "⠨⠣")
    Set braille_expression to String.replace(braille_expression, "]", "⠨⠜")
    Set braille_expression to String.replace(braille_expression, "{", "⠸⠣")
    Set braille_expression to String.replace(braille_expression, "}", "⠸⠜")
    
    Note: Numbers (using Nemeth numeric indicator)
    Set braille_expression to String.replace(braille_expression, "0", "⠼⠚")
    Set braille_expression to String.replace(braille_expression, "1", "⠼⠁")
    Set braille_expression to String.replace(braille_expression, "2", "⠼⠃")
    Set braille_expression to String.replace(braille_expression, "3", "⠼⠉")
    Set braille_expression to String.replace(braille_expression, "4", "⠼⠙")
    Set braille_expression to String.replace(braille_expression, "5", "⠼⠑")
    Set braille_expression to String.replace(braille_expression, "6", "⠼⠋")
    Set braille_expression to String.replace(braille_expression, "7", "⠼⠛")
    Set braille_expression to String.replace(braille_expression, "8", "⠼⠓")
    Set braille_expression to String.replace(braille_expression, "9", "⠼⠊")
    
    Return braille_expression

Process called "format_high_contrast" that takes expression as String, contrast_ratio as Float returns String:
    Note: Format expression for high contrast display
    Let high_contrast_expression be expression
    
    If contrast_ratio is greater than or equal to 7.0:
        Let text_color be "#000000"
        Let background_color be "#FFFFFF"
        Let operator_color be "#000000"
        Let highlight_color be "#FFFF00"
    Otherwise if contrast_ratio is greater than or equal to 4.5:
        Let text_color be "#1A1A1A"
        Let background_color be "#F5F5F5"
        Let operator_color be "#000000"
        Let highlight_color be "#FFEB3B"
    Otherwise:
        Let text_color be "#333333"
        Let background_color be "#FFFFFF"
        Let operator_color be "#000000"
        Let highlight_color be "#FFC107"
    
    Set high_contrast_expression to "<div style='color: " plus text_color plus "; background-color: " plus background_color plus "; font-weight: bold; font-size: 1.2em;'>" plus high_contrast_expression plus "</div>"
    
    Let operators be ["+", "-", "*", "/", "=", "<", ">", "≤", "≥"]
    For each operator in operators:
        If String.contains(high_contrast_expression, operator):
            Set high_contrast_expression to String.replace(high_contrast_expression, operator,
                "<span style='color: " plus operator_color plus "; font-weight: bold; background-color: " plus highlight_color plus "; padding: 0 0.1em;'>" plus operator plus "</span>")
    
    Return high_contrast_expression

Note: =====================================================================
Note: RESPONSIVE FORMATTING OPERATIONS
Note: =====================================================================

Process called "format_for_mobile" that takes expression as String, screen_size as Dictionary[String, Integer] returns String:
    Note: Format mathematical expression for mobile display
    Let mobile_expression be expression
    Let screen_width be Dictionary.get(screen_size, "width", 375)
    Let screen_height be Dictionary.get(screen_size, "height", 667)
    
    If screen_width is less than 400:
        Let font_size be "14px"
        Let line_height be "1.2"
        Let max_width be "90vw"
    Otherwise if screen_width is less than 600:
        Let font_size be "16px"
        Let line_height be "1.3"
        Let max_width be "85vw"
    Otherwise:
        Let font_size be "18px"
        Let line_height be "1.4"
        Let max_width be "80vw"
    
    Set mobile_expression to "<div style='font-size: " plus font_size plus "; line-height: " plus line_height plus "; max-width: " plus max_width plus "; overflow-x: auto; -webkit-overflow-scrolling: touch;'>" plus mobile_expression plus "</div>"
    
    If length(mobile_expression) is greater than 100:
        Let lines be break_long_expression(mobile_expression, screen_width / 10)
        Set mobile_expression to String.join(lines, "<br/>")
    
    Return mobile_expression

Process called "scale_for_resolution" that takes expression as String, target_resolution as Dictionary[String, Integer] returns String:
    Note: Scale mathematical expression for target resolution
    Let scaled_expression be expression
    Let target_width be Dictionary.get(target_resolution, "width", 1920)
    Let target_height be Dictionary.get(target_resolution, "height", 1080)
    Let target_dpi be Dictionary.get(target_resolution, "dpi", 96)
    
    Let scale_factor be target_dpi / 96.0
    Let base_font_size be 16.0 multiplied by scale_factor
    
    If target_width is less than 800:
        Set scale_factor to scale_factor multiplied by 0.8
    Otherwise if target_width is greater than 2560:
        Set scale_factor to scale_factor multiplied by 1.2
    
    Let scaled_font_size be String.fromFloat(base_font_size) plus "px"
    Let scaled_spacing be String.fromFloat(0.2 multiplied by scale_factor) plus "em"
    
    Set scaled_expression to "<div style='font-size: " plus scaled_font_size plus "; transform: scale(" plus String.fromFloat(scale_factor) plus "); transform-origin: top left;'>" plus scaled_expression plus "</div>"
    
    Let operators be ["+", "-", "=", "<", ">", "≤", "≥"]
    For each operator in operators:
        If String.contains(scaled_expression, operator):
            Set scaled_expression to String.replace(scaled_expression, operator,
                "<span style='margin: 0 " plus scaled_spacing plus ";'>" plus operator plus "</span>")
    
    Return scaled_expression

Process called "adapt_to_viewport" that takes expression as String, viewport_size as Dictionary[String, Integer] returns String:
    Note: Adapt expression formatting to viewport size
    Let adapted_expression be expression
    Let viewport_width be Dictionary.get(viewport_size, "width", 1024)
    Let viewport_height be Dictionary.get(viewport_size, "height", 768)
    
    If viewport_width is less than 480:
        Set adapted_expression to format_for_mobile(adapted_expression, viewport_size)
    Otherwise if viewport_width is less than 768:
        Let tablet_font_size be "18px"
        Let tablet_spacing be "0.25em"
        Set adapted_expression to "<div style='font-size: " plus tablet_font_size plus "; max-width: 95vw; margin: 0 auto;'>" plus adapted_expression plus "</div>"
    Otherwise if viewport_width is less than 1200:
        Let desktop_font_size be "20px"
        Let desktop_spacing be "0.3em"
        Set adapted_expression to "<div style='font-size: " plus desktop_font_size plus "; max-width: 90vw; margin: 0 auto;'>" plus adapted_expression plus "</div>"
    Otherwise:
        Let large_font_size be "22px"
        Let large_spacing be "0.35em"
        Set adapted_expression to "<div style='font-size: " plus large_font_size plus "; max-width: 85vw; margin: 0 auto;'>" plus adapted_expression plus "</div>"
    
    If viewport_height is less than 600:
        Set adapted_expression to String.replace(adapted_expression, "line-height: 1.4", "line-height: 1.2")
    
    Return adapted_expression

Process called "optimize_for_print" that takes expression as String, print_settings as Dictionary[String, String] returns String:
    Note: Optimize expression formatting for print media
    Let print_expression be expression
    Let paper_size be Dictionary.get(print_settings, "paper_size", "A4")
    Let print_quality be Dictionary.get(print_settings, "quality", "high")
    Let color_mode be Dictionary.get(print_settings, "color_mode", "grayscale")
    
    Set print_expression to clean_formatting_markup(print_expression)
    
    If color_mode is equal to "grayscale" || color_mode is equal to "black_white":
        Set print_expression to String.replace(print_expression, "color: #", "color: #000000; /* original: #")
    
    If print_quality is equal to "high":
        Let print_font_size be "12pt"
        Let print_line_height be "1.5"
    Otherwise:
        Let print_font_size be "11pt"
        Let print_line_height be "1.3"
    
    If paper_size is equal to "A4":
        Let max_width be "190mm"
    Otherwise if paper_size is equal to "Letter":
        Let max_width be "8in"
    Otherwise:
        Let max_width be "100%"
    
    Set print_expression to "<div style='font-size: " plus print_font_size plus "; line-height: " plus print_line_height plus "; max-width: " plus max_width plus "; margin: 0 auto; page-break-inside: avoid;'>" plus print_expression plus "</div>"
    
    Return print_expression

Note: =====================================================================
Note: FONT MANAGEMENT OPERATIONS
Note: =====================================================================

Process called "detect_font_capabilities" that takes font_name as String returns Dictionary[String, Boolean]:
    Note: Detect mathematical symbol capabilities of font
    Let capabilities be {}
    Let math_fonts be ["Latin Modern Math", "STIX Two Math", "Cambria Math", "Asana Math", "Libertinus Math"]
    Let standard_fonts be ["Arial", "Times New Roman", "Helvetica", "Georgia"]
    
    If Collections.contains(math_fonts, font_name):
        Set Dictionary.entry(capabilities, "unicode_math") to true
        Set Dictionary.entry(capabilities, "advanced_symbols") to true
        Set Dictionary.entry(capabilities, "matrix_support") to true
        Set Dictionary.entry(capabilities, "integral_variants") to true
        Set Dictionary.entry(capabilities, "script_fonts") to true
        Set Dictionary.entry(capabilities, "blackboard_bold") to true
        Set Dictionary.entry(capabilities, "fraktur") to true
    Otherwise if Collections.contains(standard_fonts, font_name):
        Set Dictionary.entry(capabilities, "unicode_math") to false
        Set Dictionary.entry(capabilities, "advanced_symbols") to false
        Set Dictionary.entry(capabilities, "matrix_support") to false
        Set Dictionary.entry(capabilities, "integral_variants") to false
        Set Dictionary.entry(capabilities, "script_fonts") to false
        Set Dictionary.entry(capabilities, "blackboard_bold") to false
        Set Dictionary.entry(capabilities, "fraktur") to false
    Otherwise:
        Set Dictionary.entry(capabilities, "unicode_math") to false
        Set Dictionary.entry(capabilities, "advanced_symbols") to false
        Set Dictionary.entry(capabilities, "matrix_support") to false
        Set Dictionary.entry(capabilities, "integral_variants") to false
        Set Dictionary.entry(capabilities, "script_fonts") to false
        Set Dictionary.entry(capabilities, "blackboard_bold") to false
        Set Dictionary.entry(capabilities, "fraktur") to false
    
    Return capabilities

Process called "suggest_font_fallbacks" that takes required_symbols as List[String], available_fonts as List[String] returns List[String]:
    Note: Suggest font fallback chain for required symbols
    Let fallback_chain be []
    Let math_fonts be ["Latin Modern Math", "STIX Two Math", "Cambria Math", "Asana Math", "Libertinus Math"]
    Let symbol_fonts be ["DejaVu Math", "Noto Math", "Computer Modern"]
    Let basic_fonts be ["Arial Unicode MS", "Lucida Sans Unicode"]
    
    Let needs_advanced_math be false
    Let advanced_symbols be ["∫", "∑", "∏", "∇", "∂", "∞", "π", "α", "β", "γ"]
    
    For each symbol in required_symbols:
        If Collections.contains(advanced_symbols, symbol):
            Set needs_advanced_math to true
    
    If needs_advanced_math:
        For each font in math_fonts:
            If Collections.contains(available_fonts, font):
                Append font to fallback_chain
    
    For each font in symbol_fonts:
        If Collections.contains(available_fonts, font):
            Append font to fallback_chain
    
    For each font in basic_fonts:
        If Collections.contains(available_fonts, font):
            Append font to fallback_chain
    
    If length(fallback_chain) is equal to 0:
        Append "serif" to fallback_chain
        Append "sans-serif" to fallback_chain
        Append "monospace" to fallback_chain
    
    Return fallback_chain

Process called "load_mathematical_fonts" that takes font_sources as List[String] returns Dictionary[String, Boolean]:
    Note: Load mathematical fonts from various sources
    Let loading_results be {}
    Let supported_formats be [".woff2", ".woff", ".ttf", ".otf"]
    
    For each source in font_sources:
        Let font_name be extract_font_name_from_source(source)
        Let is_supported_format be false
        
        For each format in supported_formats:
            If String.endsWith(source, format):
                Set is_supported_format to true
        
        If is_supported_format:
            Set Dictionary.entry(loading_results, font_name) to true
        Otherwise:
            Set Dictionary.entry(loading_results, font_name) to false
    
    Return loading_results

Process called "validate_font_coverage" that takes font as String, symbol_set as List[String] returns Dictionary[String, Boolean]:
    Note: Validate font coverage for mathematical symbols
    Let coverage_map be {}
    Let font_capabilities be detect_font_capabilities(font)
    
    For each symbol in symbol_set:
        Let is_covered be false
        
        If Dictionary.get(font_capabilities, "unicode_math", false):
            Set is_covered to true
        Otherwise if symbol is equal to "+" || symbol is equal to "-" || symbol is equal to "*" || symbol is equal to "/" || symbol is equal to "=":
            Set is_covered to true
        Otherwise if symbol is equal to "(") || symbol is equal to ")" || symbol is equal to "[" || symbol is equal to "]":
            Set is_covered to true
        Otherwise if Dictionary.get(font_capabilities, "advanced_symbols", false):
            Let advanced_symbols be ["∫", "∑", "∏", "∇", "∂", "π", "α", "β"]
            If Collections.contains(advanced_symbols, symbol):
                Set is_covered to true
        
        Set Dictionary.entry(coverage_map, symbol) to is_covered
    
    Return coverage_map

Note: =====================================================================
Note: STYLE GUIDE OPERATIONS
Note: =====================================================================

Process called "apply_style_guide" that takes expression as String, style_guide as StyleGuide returns String:
    Note: Apply mathematical style guide to expression
    Let styled_expression be expression
    
    Let font_settings be style_guide.font_preferences
    Let spacing_rules be style_guide.spacing_rules
    Let notation_preferences be style_guide.notation_preferences
    
    Let primary_font be Dictionary.get(font_settings, "primary_font", "Latin Modern Math")
    Let operator_spacing be Dictionary.get(spacing_rules, "operator_spacing", "0.2em")
    Let function_style be Dictionary.get(notation_preferences, "function_style", "normal")
    
    Set styled_expression to apply_font_style(styled_expression, function_style)
    
    Let operators be ["+", "-", "=", "<", ">", "≤", "≥"]
    For each operator in operators:
        If String.contains(styled_expression, operator):
            Set styled_expression to String.replace(styled_expression, operator,
                "<span style='margin: 0 " plus operator_spacing plus ";'>" plus operator plus "</span>")
    
    Set styled_expression to "<span style='font-family: " plus primary_font plus ";'>" plus styled_expression plus "</span>"
    
    Return styled_expression

Process called "validate_style_compliance" that takes expression as String, style_rules as Dictionary[String, String] returns List[String]:
    Note: Validate expression against style guidelines
    Let violations be []
    
    Let max_line_length be Dictionary.get(style_rules, "max_line_length", "80")
    Let required_font be Dictionary.get(style_rules, "required_font", "")
    Let operator_spacing be Dictionary.get(style_rules, "operator_spacing", "consistent")
    
    If length(expression) is greater than String.toInteger(max_line_length):
        Append "Expression exceeds maximum line length of " plus max_line_length to violations
    
    If required_font does not equal "" && !String.contains(expression, required_font):
        Append "Expression does not use required font: " plus required_font to violations
    
    If operator_spacing is equal to "consistent":
        Let operators be ["+", "-", "*", "/", "="]
        Let inconsistent_spacing be false
        For each operator in operators:
            If String.contains(expression, operator):
                If !String.contains(expression, " " plus operator plus " "):
                    Set inconsistent_spacing to true
        
        If inconsistent_spacing:
            Append "Inconsistent operator spacing detected" to violations
    
    Return violations

Process called "create_custom_style_guide" that takes preferences as Dictionary[String, String] returns StyleGuide:
    Note: Create custom mathematical style guide
    Let primary_font be Dictionary.get(preferences, "primary_font", "Latin Modern Math")
    Let operator_spacing be Dictionary.get(preferences, "operator_spacing", "0.2em")
    Let function_notation be Dictionary.get(preferences, "function_notation", "parentheses")
    Let variable_style be Dictionary.get(preferences, "variable_style", "italic")
    Let constant_style be Dictionary.get(preferences, "constant_style", "normal")
    
    Return {
        "guide_name": Dictionary.get(preferences, "guide_name", "Custom Style Guide"),
        "font_preferences": {
            "primary_font": primary_font,
            "fallback_fonts": ["STIX Two Math", "Cambria Math", "serif"],
            "symbol_font": primary_font,
            "text_font": Dictionary.get(preferences, "text_font", "Latin Modern Roman")
        },
        "spacing_rules": {
            "operator_spacing": operator_spacing,
            "function_spacing": Dictionary.get(preferences, "function_spacing", "0.1em"),
            "subscript_spacing": Dictionary.get(preferences, "subscript_spacing", "0"),
            "superscript_spacing": Dictionary.get(preferences, "superscript_spacing", "0")
        },
        "notation_preferences": {
            "function_notation": function_notation,
            "variable_style": variable_style,
            "constant_style": constant_style,
            "operator_style": Dictionary.get(preferences, "operator_style", "normal")
        },
        "layout_preferences": {
            "equation_alignment": Dictionary.get(preferences, "equation_alignment", "center"),
            "line_spacing": Dictionary.get(preferences, "line_spacing", "1.2"),
            "margin_style": Dictionary.get(preferences, "margin_style", "auto")
        }
    }

Process called "merge_style_guides" that takes primary_guide as StyleGuide, secondary_guide as StyleGuide returns StyleGuide:
    Note: Merge two style guides with conflict resolution
    Let merged_guide be {
        "guide_name": primary_guide.guide_name plus " plus " plus secondary_guide.guide_name,
        "font_preferences": {},
        "spacing_rules": {},
        "notation_preferences": {},
        "layout_preferences": {}
    }
    
    Let primary_fonts be primary_guide.font_preferences
    Let secondary_fonts be secondary_guide.font_preferences
    Set merged_guide.font_preferences to {
        "primary_font": Dictionary.get(primary_fonts, "primary_font", Dictionary.get(secondary_fonts, "primary_font", "Latin Modern Math")),
        "fallback_fonts": Dictionary.get(primary_fonts, "fallback_fonts", Dictionary.get(secondary_fonts, "fallback_fonts", [])),
        "symbol_font": Dictionary.get(primary_fonts, "symbol_font", Dictionary.get(secondary_fonts, "symbol_font", "Latin Modern Math")),
        "text_font": Dictionary.get(primary_fonts, "text_font", Dictionary.get(secondary_fonts, "text_font", "Latin Modern Roman"))
    }
    
    Let primary_spacing be primary_guide.spacing_rules
    Let secondary_spacing be secondary_guide.spacing_rules
    Set merged_guide.spacing_rules to {
        "operator_spacing": Dictionary.get(primary_spacing, "operator_spacing", Dictionary.get(secondary_spacing, "operator_spacing", "0.2em")),
        "function_spacing": Dictionary.get(primary_spacing, "function_spacing", Dictionary.get(secondary_spacing, "function_spacing", "0.1em")),
        "subscript_spacing": Dictionary.get(primary_spacing, "subscript_spacing", Dictionary.get(secondary_spacing, "subscript_spacing", "0")),
        "superscript_spacing": Dictionary.get(primary_spacing, "superscript_spacing", Dictionary.get(secondary_spacing, "superscript_spacing", "0"))
    }
    
    Let primary_notation be primary_guide.notation_preferences
    Let secondary_notation be secondary_guide.notation_preferences
    Set merged_guide.notation_preferences to {
        "function_notation": Dictionary.get(primary_notation, "function_notation", Dictionary.get(secondary_notation, "function_notation", "parentheses")),
        "variable_style": Dictionary.get(primary_notation, "variable_style", Dictionary.get(secondary_notation, "variable_style", "italic")),
        "constant_style": Dictionary.get(primary_notation, "constant_style", Dictionary.get(secondary_notation, "constant_style", "normal")),
        "operator_style": Dictionary.get(primary_notation, "operator_style", Dictionary.get(secondary_notation, "operator_style", "normal"))
    }
    
    Let primary_layout be primary_guide.layout_preferences
    Let secondary_layout be secondary_guide.layout_preferences
    Set merged_guide.layout_preferences to {
        "equation_alignment": Dictionary.get(primary_layout, "equation_alignment", Dictionary.get(secondary_layout, "equation_alignment", "center")),
        "line_spacing": Dictionary.get(primary_layout, "line_spacing", Dictionary.get(secondary_layout, "line_spacing", "1.2")),
        "margin_style": Dictionary.get(primary_layout, "margin_style", Dictionary.get(secondary_layout, "margin_style", "auto"))
    }
    
    Return merged_guide

Note: =====================================================================
Note: INTERACTIVE FORMATTING OPERATIONS
Note: =====================================================================

Process called "format_for_interaction" that takes expression as String, interaction_type as String returns String:
    Note: Format expression for interactive mathematical content
    Let interactive_expression be expression
    
    If interaction_type is equal to "tooltip":
        Let operators be ["+", "-", "*", "/", "=", "∫", "∑", "∏"]
        For each operator in operators:
            If String.contains(interactive_expression, operator):
                Let tooltip_text be generate_alt_text(operator, "general")
                Set interactive_expression to String.replace(interactive_expression, operator,
                    "<span class='math-tooltip' title='" plus tooltip_text plus "' style='cursor: help;'>" plus operator plus "</span>")
    
    Otherwise if interaction_type is equal to "editable":
        Set interactive_expression to "<div contenteditable='true' class='math-editable' style='border: 1px dashed #ccc; padding: 0.5em; min-height: 2em;'>" plus interactive_expression plus "</div>"
    
    Otherwise if interaction_type is equal to "selectable":
        Let symbols be String.split(interactive_expression, "")
        Let selectable_parts be []
        For each symbol in symbols:
            If symbol does not equal " ":
                Let selectable_symbol be "<span class='math-selectable' style='cursor: pointer; user-select: none;' onclick='selectMathSymbol(this)'>" plus symbol plus "</span>"
                Append selectable_symbol to selectable_parts
            Otherwise:
                Append symbol to selectable_parts
        Set interactive_expression to String.join(selectable_parts, "")
    
    Otherwise if interaction_type is equal to "expandable":
        Set interactive_expression to "<details class='math-expandable'><summary class='math-summary' style='cursor: pointer;'>" plus String.substring(interactive_expression, 0, 20) plus "...</summary><div class='math-full'>" plus interactive_expression plus "</div></details>"
    
    Otherwise if interaction_type is equal to "draggable":
        Set interactive_expression to "<div draggable='true' class='math-draggable' style='cursor: move; user-select: none;' ondragstart='dragMathExpression(event)'>" plus interactive_expression plus "</div>"
    
    Return interactive_expression

Process called "add_hover_effects" that takes expression as String, hover_rules as Dictionary[String, String] returns String:
    Note: Add hover effects to mathematical symbols
    Let hover_expression be expression
    
    Let hover_color be Dictionary.get(hover_rules, "hover_color", "#FF5722")
    Let hover_background be Dictionary.get(hover_rules, "hover_background", "#FFF3E0")
    Let hover_scale be Dictionary.get(hover_rules, "hover_scale", "1.1")
    Let transition_duration be Dictionary.get(hover_rules, "transition_duration", "0.2s")
    Let hover_effect be Dictionary.get(hover_rules, "effect_type", "highlight")
    
    Let base_styles be "transition: all " plus transition_duration plus " ease-in-out; cursor: pointer;"
    
    If hover_effect is equal to "highlight":
        Let hover_styles be base_styles plus " :hover { color: " plus hover_color plus "; background-color: " plus hover_background plus "; }"
    Otherwise if hover_effect is equal to "scale":
        Let hover_styles be base_styles plus " :hover { transform: scale(" plus hover_scale plus "); }"
    Otherwise if hover_effect is equal to "glow":
        Let hover_styles be base_styles plus " :hover { box-shadow: 0 0 10px " plus hover_color plus "; }"
    Otherwise if hover_effect is equal to "underline":
        Let hover_styles be base_styles plus " :hover { text-decoration: underline; text-decoration-color: " plus hover_color plus "; }"
    Otherwise:
        Let hover_styles be base_styles plus " :hover { color: " plus hover_color plus "; }"
    
    Let operators be ["+", "-", "*", "/", "=", "∫", "∑", "∏", "∇", "∂"]
    For each operator in operators:
        If String.contains(hover_expression, operator):
            Set hover_expression to String.replace(hover_expression, operator,
                "<span class='math-hover-" plus hover_effect plus "' style='" plus hover_styles plus "'>" plus operator plus "</span>")
    
    Return hover_expression

Process called "create_clickable_symbols" that takes expression as String, click_handlers as Dictionary[String, String] returns String:
    Note: Make mathematical symbols clickable with associated actions
    Let clickable_expression be expression
    
    Let symbols_to_make_clickable be Dictionary.keys(click_handlers)
    
    For each symbol in symbols_to_make_clickable:
        Let click_action be Dictionary.get(click_handlers, symbol, "")
        
        If String.contains(clickable_expression, symbol) && click_action does not equal "":
            Let clickable_span be "<span class='math-clickable' " +
                "style='cursor: pointer; user-select: none; color: #2196F3; text-decoration: underline;' " +
                "onclick='" plus click_action plus "' " +
                "role='button' " +
                "tabindex='0' " +
                "onkeydown='if(event.key===\"Enter\"||event.key===\" \"){" plus click_action plus "}'>" +
                symbol plus "</span>"
            
            Set clickable_expression to String.replace(clickable_expression, symbol, clickable_span)
    
    Note: Add global styles for clickable elements
    Let global_styles be "<style>" +
        ".math-clickable:hover { background-color: #E3F2FD; border-radius: 3px; padding: 0 2px; }" +
        ".math-clickable:focus { outline: 2px solid #2196F3; background-color: #E3F2FD; }" +
        ".math-clickable:active { background-color: #BBDEFB; }" +
        "</style>"
    
    Set clickable_expression to global_styles plus clickable_expression
    
    Return clickable_expression

Process called "animate_mathematical_transitions" that takes from_expression as String, to_expression as String, animation_type as String returns String:
    Note: Create animated transitions between mathematical expressions
    Let animation_id be "math_anim_" plus String.fromInteger(Math.random_int(1000, 9999))
    
    Let animation_css be "<style>" +
        "@keyframes " plus animation_id plus " {" +
        "  0% { opacity: 1; }" +
        "  50% { opacity: 0; }" +
        "  100% { opacity: 1; }" +
        "}" +
        "</style>"
    
    If animation_type is equal to "fade":
        Set animation_css to "<style>" +
            "@keyframes " plus animation_id plus "_fade {" +
            "  0% { opacity: 0; }" +
            "  100% { opacity: 1; }" +
            "}" +
            "</style>"
        Let animated_expression be "<div class='math-transition' style='animation: " plus animation_id plus "_fade 1s ease-in-out;'>" plus to_expression plus "</div>"
    
    Otherwise if animation_type is equal to "slide":
        Set animation_css to "<style>" +
            "@keyframes " plus animation_id plus "_slide {" +
            "  0% { transform: translateX(-100%); opacity: 0; }" +
            "  100% { transform: translateX(0); opacity: 1; }" +
            "}" +
            "</style>"
        Let animated_expression be "<div class='math-transition' style='animation: " plus animation_id plus "_slide 0.8s ease-out;'>" plus to_expression plus "</div>"
    
    Otherwise if animation_type is equal to "morph":
        Set animation_css to "<style>" +
            "@keyframes " plus animation_id plus "_morph {" +
            "  0% { transform: scale(1); }" +
            "  25% { transform: scale(0.8); }" +
            "  75% { transform: scale(1.1); }" +
            "  100% { transform: scale(1); }" +
            "}" +
            "</style>"
        Let animated_expression be "<div class='math-transition' style='animation: " plus animation_id plus "_morph 1.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);'>" plus to_expression plus "</div>"
    
    Otherwise if animation_type is equal to "typewriter":
        Set animation_css to "<style>" +
            "@keyframes " plus animation_id plus "_typewriter {" +
            "  0% { width: 0; }" +
            "  100% { width: 100%; }" +
            "}" +
            "</style>"
        Let animated_expression be "<div class='math-transition' style='overflow: hidden; white-space: nowrap; animation: " plus animation_id plus "_typewriter 2s steps(" plus String.fromInteger(length(to_expression)) plus ") forwards;'>" plus to_expression plus "</div>"
    
    Otherwise:
        Let animated_expression be "<div class='math-transition' style='animation: " plus animation_id plus " 1s ease-in-out;'>" plus to_expression plus "</div>"
    
    Return animation_css plus animated_expression

Note: =====================================================================
Note: CONVERSION AND EXPORT OPERATIONS
Note: =====================================================================

Process called "export_to_html" that takes formatted_expression as String, html_options as Dictionary[String, String] returns String:
    Note: Export formatted expression to HTML
    Let include_mathml be Dictionary.get(html_options, "include_mathml", "false")
    Let css_class be Dictionary.get(html_options, "css_class", "runa-math")
    Let inline_styles be Dictionary.get(html_options, "inline_styles", "true")
    
    Let html_output be "<div class='" plus css_class plus "'>"
    
    If inline_styles is equal to "true":
        Set html_output to html_output plus "<style>" +
            ".runa-math { font-family: 'Latin Modern Math', 'STIX Two Math', math; }" +
            ".runa-math .operator { margin: 0 0.2em; }" +
            ".runa-math .function { font-style: italic; }" +
            "</style>"
    
    Set html_output to html_output plus formatted_expression
    
    If include_mathml is equal to "true":
        Let mathml_version be export_to_mathml(formatted_expression, {})
        Set html_output to html_output plus "<!-- MathML: " plus mathml_version plus " -->"
    
    Set html_output to html_output plus "</div>"
    
    Return html_output

Process called "export_to_svg" that takes formatted_expression as String, svg_options as Dictionary[String, String] returns String:
    Note: Export formatted expression to SVG format
    Let width be Dictionary.get(svg_options, "width", "400")
    Let height be Dictionary.get(svg_options, "height", "100")
    Let font_size be Dictionary.get(svg_options, "font_size", "16")
    Let background_color be Dictionary.get(svg_options, "background_color", "white")
    
    Let svg_header be "<svg width='" plus width plus "' height='" plus height plus "' xmlns='http://www.w3.org/2000/svg'>"
    Let svg_background be "<rect width='100%' height='100%' fill='" plus background_color plus "'/>"
    Let svg_defs be "<defs><style>.math-text { font-family: 'Latin Modern Math', math; font-size: " plus font_size plus "px; }</style></defs>"
    
    Let clean_expression be String.replace(formatted_expression, "<span", "<tspan")
    Set clean_expression to String.replace(clean_expression, "</span>", "</tspan>")
    
    Let svg_text be "<text x='50%' y='50%' text-anchor='middle' dominant-baseline='central' class='math-text'>" plus clean_expression plus "</text>"
    Let svg_footer be "</svg>"
    
    Return svg_header plus svg_background plus svg_defs plus svg_text plus svg_footer

Process called "export_to_latex" that takes formatted_expression as String, latex_options as Dictionary[String, String] returns String:
    Note: Export formatted expression to LaTeX
    Let document_mode be Dictionary.get(latex_options, "document_mode", "inline")
    Let package_includes be Dictionary.get(latex_options, "packages", "amsmath,amssymb")
    
    Let latex_expression be formatted_expression
    
    Set latex_expression to String.replace(latex_expression, "∫", "\\int")
    Set latex_expression to String.replace(latex_expression, "∑", "\\sum")
    Set latex_expression to String.replace(latex_expression, "∏", "\\prod")
    Set latex_expression to String.replace(latex_expression, "∂", "\\partial")
    Set latex_expression to String.replace(latex_expression, "∇", "\\nabla")
    Set latex_expression to String.replace(latex_expression, "Δ", "\\Delta")
    Set latex_expression to String.replace(latex_expression, "π", "\\pi")
    Set latex_expression to String.replace(latex_expression, "α", "\\alpha")
    Set latex_expression to String.replace(latex_expression, "β", "\\beta")
    Set latex_expression to String.replace(latex_expression, "γ", "\\gamma")
    Set latex_expression to String.replace(latex_expression, "≤", "\\leq")
    Set latex_expression to String.replace(latex_expression, "≥", "\\geq")
    Set latex_expression to String.replace(latex_expression, "≠", "\\neq")
    Set latex_expression to String.replace(latex_expression, "∞", "\\infty")
    Set latex_expression to String.replace(latex_expression, "×", "\\times")
    Set latex_expression to String.replace(latex_expression, "·", "\\cdot")
    
    Set latex_expression to String.replace(latex_expression, "<span", "%SPAN_START%")
    Set latex_expression to String.replace(latex_expression, "</span>", "%SPAN_END%")
    Set latex_expression to String.replace(latex_expression, "<strong>", "\\mathbf{")
    Set latex_expression to String.replace(latex_expression, "</strong>", "}")
    Set latex_expression to String.replace(latex_expression, "%SPAN_START%", "")
    Set latex_expression to String.replace(latex_expression, "%SPAN_END%", "")
    
    If document_mode is equal to "display":
        Return "\\[" plus latex_expression plus "\\]"
    Otherwise if document_mode is equal to "equation":
        Return "\\begin{equation}" plus latex_expression plus "\\end{equation}"
    Otherwise:
        Return "$" plus latex_expression plus "$"

Process called "export_to_mathml" that takes formatted_expression as String, mathml_options as Dictionary[String, String] returns String:
    Note: Export formatted expression to MathML
    Let display_style be Dictionary.get(mathml_options, "display", "inline")
    Let namespace_prefix be Dictionary.get(mathml_options, "namespace", "")
    
    Let mathml_expression be formatted_expression
    
    Set mathml_expression to String.replace(mathml_expression, "<span", "<mi")
    Set mathml_expression to String.replace(mathml_expression, "</span>", "</mi>")
    Set mathml_expression to String.replace(mathml_expression, "<strong>", "<mi mathvariant='bold'>")
    Set mathml_expression to String.replace(mathml_expression, "</strong>", "</mi>")
    
    Set mathml_expression to String.replace(mathml_expression, "+", "<mo>+</mo>")
    Set mathml_expression to String.replace(mathml_expression, "-", "<mo>-</mo>")
    Set mathml_expression to String.replace(mathml_expression, "*", "<mo>×</mo>")
    Set mathml_expression to String.replace(mathml_expression, "/", "<mo>÷</mo>")
    Set mathml_expression to String.replace(mathml_expression, "=", "<mo>=</mo>")
    Set mathml_expression to String.replace(mathml_expression, "∫", "<mo>∫</mo>")
    Set mathml_expression to String.replace(mathml_expression, "∑", "<mo>∑</mo>")
    Set mathml_expression to String.replace(mathml_expression, "∏", "<mo>∏</mo>")
    
    Let mathml_header be ""
    If display_style is equal to "block":
        Set mathml_header to "<math display='block' xmlns='http://www.w3.org/1998/Math/MathML'>"
    Otherwise:
        Set mathml_header to "<math xmlns='http://www.w3.org/1998/Math/MathML'>"
    
    Let mathml_content be "<mrow>" plus mathml_expression plus "</mrow>"
    Let mathml_footer be "</math>"
    
    Return mathml_header plus mathml_content plus mathml_footer

Process called "export_to_image" that takes formatted_expression as String, image_format as String, resolution as Dictionary[String, Integer] returns String:
    Note: Export formatted expression to image format
    Let width be Dictionary.get(resolution, "width", 800)
    Let height be Dictionary.get(resolution, "height", 200)
    Let dpi be Dictionary.get(resolution, "dpi", 150)
    
    Let svg_version be export_to_svg(formatted_expression, {
        "width": String.fromInteger(width),
        "height": String.fromInteger(height),
        "font_size": "18",
        "background_color": "white"
    })
    
    If image_format is equal to "svg":
        Return svg_version
    Otherwise if image_format is equal to "png":
        Return "data:image/svg+xml;charset=utf-8," plus String.encodeURIComponent(svg_version)
    Otherwise if image_format is equal to "jpeg":
        Return "data:image/svg+xml;charset=utf-8," plus String.encodeURIComponent(svg_version)
    Otherwise:
        Return svg_version

Note: =====================================================================
Note: QUALITY ASSURANCE OPERATIONS
Note: =====================================================================

Process called "validate_formatting_quality" that takes formatted_expression as String, quality_criteria as Dictionary[String, String] returns Dictionary[String, Float]:
    Note: Validate quality of mathematical expression formatting
    Let quality_scores be {}
    
    Let readability_weight be String.toFloat(Dictionary.get(quality_criteria, "readability_weight", "0.3"))
    Let consistency_weight be String.toFloat(Dictionary.get(quality_criteria, "consistency_weight", "0.3"))
    Let accessibility_weight be String.toFloat(Dictionary.get(quality_criteria, "accessibility_weight", "0.2"))
    Let performance_weight be String.toFloat(Dictionary.get(quality_criteria, "performance_weight", "0.2"))
    
    Let readability_score be 1.0
    If length(formatted_expression) is greater than 200:
        Set readability_score to readability_score minus 0.2
    If String.count(formatted_expression, "<span") is greater than 10:
        Set readability_score to readability_score minus 0.1
    
    Let consistency_score be 1.0
    If !String.contains(formatted_expression, "font-family"):
        Set consistency_score to consistency_score minus 0.3
    If String.contains(formatted_expression, "style=") && String.count(formatted_expression, "style=") is less than 2:
        Set consistency_score to consistency_score minus 0.2
    
    Let accessibility_score be 1.0
    If !String.contains(formatted_expression, "aria-") && !String.contains(formatted_expression, "role="):
        Set accessibility_score to accessibility_score minus 0.4
    
    Let performance_score be 1.0
    Let span_count be String.count(formatted_expression, "<span")
    If span_count is greater than 20:
        Set performance_score to performance_score minus 0.3
    If span_count is greater than 50:
        Set performance_score to performance_score minus 0.5
    
    Let overall_score be (readability_score multiplied by readability_weight) plus 
                        (consistency_score multiplied by consistency_weight) +
                        (accessibility_score multiplied by accessibility_weight) +
                        (performance_score multiplied by performance_weight)
    
    Set Dictionary.entry(quality_scores, "readability") to readability_score
    Set Dictionary.entry(quality_scores, "consistency") to consistency_score
    Set Dictionary.entry(quality_scores, "accessibility") to accessibility_score
    Set Dictionary.entry(quality_scores, "performance") to performance_score
    Set Dictionary.entry(quality_scores, "overall") to overall_score
    
    Return quality_scores

Process called "optimize_rendering_performance" that takes expression as String, performance_targets as Dictionary[String, Float] returns String:
    Note: Optimize expression for rendering performance
    Let optimized_expression be expression
    Let max_spans be Dictionary.get(performance_targets, "max_spans", 10.0)
    Let min_font_size be Dictionary.get(performance_targets, "min_font_size", 12.0)
    
    Let span_count be String.count(optimized_expression, "<span")
    If Float.fromInteger(span_count) is greater than max_spans:
        Set optimized_expression to String.replace(optimized_expression, "<span style='font-size: 1em;'>", "")
        Set optimized_expression to String.replace(optimized_expression, "<span style='font-weight: normal;'>", "")
        
        Let simplified_spans be String.count(optimized_expression, "<span")
        While Float.fromInteger(simplified_spans) is greater than max_spans && simplified_spans is greater than 0:
            Set optimized_expression to String.replaceFirst(optimized_expression, "<span[^>]*>", "")
            Set optimized_expression to String.replaceFirst(optimized_expression, "</span>", "")
            Set simplified_spans to String.count(optimized_expression, "<span")
    
    Set optimized_expression to String.replace(optimized_expression, "font-size: 0.8em", "font-size: " plus String.fromFloat(min_font_size) plus "px")
    Set optimized_expression to String.replace(optimized_expression, "font-size: 0.9em", "font-size: " plus String.fromFloat(min_font_size) plus "px")
    
    Return optimized_expression

Process called "test_cross_platform_compatibility" that takes formatted_expression as String, target_platforms as List[String] returns Dictionary[String, Boolean]:
    Note: Test formatting compatibility across platforms
    
    Let compatibility_results be {}
    Let supported_platforms be ["web", "desktop", "mobile", "print", "pdf", "svg"]
    
    For each platform in target_platforms:
        Let is_compatible be true
        
        If platform is equal to "web":
            Note: Check for web-specific compatibility
            If String.contains(formatted_expression, "font-variant: stylistic"):
                Set is_compatible to false Note: Advanced font features not widely supported
            If String.count(formatted_expression, "<span") is greater than 100:
                Set is_compatible to false Note: Too many DOM elements for web performance
        
        Otherwise if platform is equal to "mobile":
            Note: Check mobile compatibility
            If String.contains(formatted_expression, "font-size") && String.contains(formatted_expression, "px"):
                Set is_compatible to false Note: Fixed pixel sizes not responsive
            If String.contains(formatted_expression, "Latin Modern Math"):
                Set is_compatible to false Note: Specialized math fonts may not be available
        
        Otherwise if platform is equal to "print":
            Note: Check print compatibility
            If String.contains(formatted_expression, "<span"):
                Set is_compatible to false Note: HTML markup not suitable for print
            If String.contains(formatted_expression, "color:") && !String.contains(formatted_expression, "black"):
                Set is_compatible to false Note: Color may not print well
        
        Otherwise if platform is equal to "pdf":
            Note: Check PDF compatibility
            If String.contains(formatted_expression, "font-variant:"):
                Set is_compatible to false Note: Advanced CSS features may not render in PDF
        
        Otherwise if platform is equal to "svg":
            Note: Check SVG compatibility
            If !String.contains(formatted_expression, "<"):
                Set is_compatible to true Note: Plain text compatible with SVG
        
        Otherwise if platform is equal to "desktop":
            Note: Desktop applications typically have good font support
            Set is_compatible to true
        
        Otherwise:
            Note: Unknown platform
            Set is_compatible to false
        
        Set Dictionary.entry(compatibility_results, platform) to is_compatible
    
    Return compatibility_results

Process called "measure_formatting_metrics" that takes formatted_expression as String returns Dictionary[String, Float]:
    Note: Measure formatting metrics (readability, aesthetics, etc.)
    
    Let metrics be {}
    
    Note: Measure complexity metrics
    Let total_length be length(formatted_expression)
    Let markup_length be String.count(formatted_expression, "<") multiplied by 10
    Let content_length be total_length minus markup_length
    Let complexity_ratio be markup_length / content_length
    
    Note: Measure readability metrics
    Let symbol_density be String.count(formatted_expression, "∫∑∏∇∂π") / content_length
    Let operator_spacing_quality be measure_operator_spacing_quality(formatted_expression)
    Let font_consistency be measure_font_consistency(formatted_expression)
    
    Note: Measure aesthetic metrics
    Let color_usage be String.count(formatted_expression, "color:") / String.count(formatted_expression, "<span")
    Let alignment_quality be measure_alignment_quality(formatted_expression)
    
    Note: Measure performance metrics
    Let dom_complexity be String.count(formatted_expression, "<span")
    Let css_efficiency be measure_css_efficiency(formatted_expression)
    
    Note: Calculate normalized scores (0.0 to 1.0)
    Set Dictionary.entry(metrics, "complexity_ratio") to Math.min(1.0, complexity_ratio)
    Set Dictionary.entry(metrics, "symbol_density") to Math.min(1.0, symbol_density multiplied by 10)
    Set Dictionary.entry(metrics, "operator_spacing_quality") to operator_spacing_quality
    Set Dictionary.entry(metrics, "font_consistency") to font_consistency
    Set Dictionary.entry(metrics, "color_usage") to Math.min(1.0, color_usage)
    Set Dictionary.entry(metrics, "alignment_quality") to alignment_quality
    Set Dictionary.entry(metrics, "dom_complexity") to Math.max(0.0, 1.0 minus (dom_complexity / 100.0))
    Set Dictionary.entry(metrics, "css_efficiency") to css_efficiency
    
    Note: Calculate overall quality score
    Let overall_quality be (
        Dictionary.get(metrics, "operator_spacing_quality", 0.0) multiplied by 0.2 +
        Dictionary.get(metrics, "font_consistency", 0.0) multiplied by 0.2 +
        Dictionary.get(metrics, "alignment_quality", 0.0) multiplied by 0.2 +
        Dictionary.get(metrics, "dom_complexity", 0.0) multiplied by 0.2 +
        Dictionary.get(metrics, "css_efficiency", 0.0) multiplied by 0.2
    )
    
    Set Dictionary.entry(metrics, "overall_quality") to overall_quality
    
    Return metrics

Note: =====================================================================
Note: TEMPLATE AND PATTERN OPERATIONS
Note: =====================================================================

Process called "create_formatting_template" that takes template_specification as Dictionary[String, String] returns String:
    Note: Create reusable formatting template
    Let template_name be Dictionary.get(template_specification, "template_name", "default")
    Let base_font be Dictionary.get(template_specification, "base_font", "Latin Modern Math")
    Let base_size be Dictionary.get(template_specification, "base_size", "16px")
    Let color_scheme be Dictionary.get(template_specification, "color_scheme", "default")
    
    Let template_css be ".math-template-" plus template_name plus " {\n"
    Set template_css to template_css plus "  font-family: '" plus base_font plus "', math;\n"
    Set template_css to template_css plus "  font-size: " plus base_size plus ";\n"
    Set template_css to template_css plus "  line-height: 1.4;\n"
    
    If color_scheme is equal to "dark":
        Set template_css to template_css plus "  color: #E0E0E0;\n"
        Set template_css to template_css plus "  background-color: #1E1E1E;\n"
    Otherwise if color_scheme is equal to "high_contrast":
        Set template_css to template_css plus "  color: #000000;\n"
        Set template_css to template_css plus "  background-color: #FFFFFF;\n"
        Set template_css to template_css plus "  font-weight: bold;\n"
    Otherwise:
        Set template_css to template_css plus "  color: #000000;\n"
        Set template_css to template_css plus "  background-color: #FFFFFF;\n"
    
    Set template_css to template_css plus "}\n"
    Set template_css to template_css plus ".math-template-" plus template_name plus " .operator { margin: 0 0.2em; }\n"
    Set template_css to template_css plus ".math-template-" plus template_name plus " .function { font-style: italic; }\n"
    Set template_css to template_css plus ".math-template-" plus template_name plus " .variable { font-style: italic; color: #0066CC; }\n"
    
    Return template_css

Process called "apply_formatting_pattern" that takes expression as String, pattern as String, substitutions as Dictionary[String, String] returns String:
    Note: Apply formatting pattern with substitutions
    Let formatted_expression be expression
    
    If pattern is equal to "equation":
        Set formatted_expression to "<div class='math-equation'>" plus formatted_expression plus "</div>"
    Otherwise if pattern is equal to "inline":
        Set formatted_expression to "<span class='math-inline'>" plus formatted_expression plus "</span>"
    Otherwise if pattern is equal to "display":
        Set formatted_expression to "<div class='math-display' style='text-align: center; margin: 1em 0;'>" plus formatted_expression plus "</div>"
    Otherwise if pattern is equal to "numbered":
        Let equation_number be Dictionary.get(substitutions, "number", "1")
        Set formatted_expression to "<div class='math-numbered'><span class='math-content'>" plus formatted_expression plus "</span><span class='equation-number'>(" plus equation_number plus ")</span></div>"
    
    For each key in Dictionary.keys(substitutions):
        Let placeholder be "{" plus key plus "}"
        Let replacement be Dictionary.get(substitutions, key, "")
        If String.contains(formatted_expression, placeholder):
            Set formatted_expression to String.replace(formatted_expression, placeholder, replacement)
    
    Return formatted_expression

Process called "detect_formatting_patterns" that takes expressions as List[String] returns List[Dictionary[String, String]]:
    Note: Detect common formatting patterns in expressions
    Let detected_patterns be []
    
    Let common_operators be ["+", "-", "*", "/", "=", "∫", "∑"]
    Let common_functions be ["sin", "cos", "tan", "log", "ln", "exp"]
    
    For each expression in expressions:
        Let pattern_info be {}
        
        Let operator_count be 0
        For each operator in common_operators:
            If String.contains(expression, operator):
                Set operator_count to operator_count plus 1
        
        Let function_count be 0
        For each function in common_functions:
            If String.contains(expression, function):
                Set function_count to function_count plus 1
        
        If operator_count is greater than 3:
            Set Dictionary.entry(pattern_info, "complexity") to "high"
            Set Dictionary.entry(pattern_info, "suggested_format") to "multiline"
        Otherwise if operator_count is greater than 1:
            Set Dictionary.entry(pattern_info, "complexity") to "medium"
            Set Dictionary.entry(pattern_info, "suggested_format") to "display"
        Otherwise:
            Set Dictionary.entry(pattern_info, "complexity") to "low"
            Set Dictionary.entry(pattern_info, "suggested_format") to "inline"
        
        If function_count is greater than 0:
            Set Dictionary.entry(pattern_info, "contains_functions") to "true"
            Set Dictionary.entry(pattern_info, "function_styling") to "italic"
        Otherwise:
            Set Dictionary.entry(pattern_info, "contains_functions") to "false"
        
        Set Dictionary.entry(pattern_info, "expression") to expression
        Append pattern_info to detected_patterns
    
    Return detected_patterns

Process called "standardize_expression_format" that takes expression as String, standardization_rules as Dictionary[String, String] returns String:
    Note: Standardize expression according to formatting rules
    Let standardized_expression be expression
    
    Let spacing_standard be Dictionary.get(standardization_rules, "spacing_standard", "consistent")
    Let operator_format be Dictionary.get(standardization_rules, "operator_format", "spaced")
    Let function_format be Dictionary.get(standardization_rules, "function_format", "parentheses")
    
    If spacing_standard is equal to "consistent":
        Set standardized_expression to String.replace(standardized_expression, "+", " plus ")
        Set standardized_expression to String.replace(standardized_expression, "-", " minus ")
        Set standardized_expression to String.replace(standardized_expression, "*", " × ")
        Set standardized_expression to String.replace(standardized_expression, "/", " ÷ ")
        Set standardized_expression to String.replace(standardized_expression, "=", " is equal to ")
        
        Set standardized_expression to String.replace(standardized_expression, "  plus  ", " plus ")
        Set standardized_expression to String.replace(standardized_expression, "  minus  ", " minus ")
        Set standardized_expression to String.replace(standardized_expression, "  ×  ", " × ")
    
    If operator_format is equal to "symbolic":
        Set standardized_expression to String.replace(standardized_expression, " × ", "×")
        Set standardized_expression to String.replace(standardized_expression, " ÷ ", "÷")
    
    If function_format is equal to "parentheses":
        Let functions be ["sin", "cos", "tan", "log", "ln", "exp"]
        For each func in functions:
            If String.contains(standardized_expression, func) && !String.contains(standardized_expression, func plus "("):
                Set standardized_expression to String.replace(standardized_expression, func plus " ", func plus "(")
                Set standardized_expression to standardized_expression plus ")"
    
    Return String.trim(standardized_expression)

Note: =====================================================================
Note: UTILITY AND MAINTENANCE OPERATIONS
Note: =====================================================================

Process called "clean_formatting_markup" that takes marked_up_expression as String returns String:
    Note: Remove or clean formatting markup from expression
    Let cleaned_expression be marked_up_expression
    
    Set cleaned_expression to String.replace(cleaned_expression, "<span[^>]*>", "")
    Set cleaned_expression to String.replace(cleaned_expression, "</span>", "")
    Set cleaned_expression to String.replace(cleaned_expression, "<div[^>]*>", "")
    Set cleaned_expression to String.replace(cleaned_expression, "</div>", "")
    Set cleaned_expression to String.replace(cleaned_expression, "<strong>", "")
    Set cleaned_expression to String.replace(cleaned_expression, "</strong>", "")
    Set cleaned_expression to String.replace(cleaned_expression, "<em>", "")
    Set cleaned_expression to String.replace(cleaned_expression, "</em>", "")
    Set cleaned_expression to String.replace(cleaned_expression, "<mark[^>]*>", "")
    Set cleaned_expression to String.replace(cleaned_expression, "</mark>", "")
    Set cleaned_expression to String.replace(cleaned_expression, "<u[^>]*>", "")
    Set cleaned_expression to String.replace(cleaned_expression, "</u>", "")
    
    Set cleaned_expression to String.replace(cleaned_expression, "  +", " +")
    Set cleaned_expression to String.replace(cleaned_expression, "  -", " -")
    Set cleaned_expression to String.replace(cleaned_expression, "  =", " =")
    
    Return String.trim(cleaned_expression)

Process called "analyze_formatting_consistency" that takes expressions as List[String] returns Dictionary[String, String]:
    Note: Analyze consistency of formatting across expressions
    Let consistency_analysis be {}
    Let font_families be []
    Let spacing_patterns be []
    
    For each expression in expressions:
        If String.contains(expression, "font-family:"):
            Let font_start be String.indexOf(expression, "font-family:") plus 12
            Let font_end be String.indexOf(expression, ";", font_start)
            If font_end is equal to -1:
                Set font_end to String.indexOf(expression, "'", font_start plus 1)
            Let font_family be String.substring(expression, font_start, font_end)
            Append font_family to font_families
        
        If String.contains(expression, "margin:"):
            Let margin_start be String.indexOf(expression, "margin:") plus 7
            Let margin_end be String.indexOf(expression, ";", margin_start)
            Let margin_value be String.substring(expression, margin_start, margin_end)
            Append margin_value to spacing_patterns
    
    Let unique_fonts be Collections.unique(font_families)
    Let unique_spacing be Collections.unique(spacing_patterns)
    
    If length(unique_fonts) is less than or equal to 2:
        Set Dictionary.entry(consistency_analysis, "font_consistency") to "high"
    Otherwise if length(unique_fonts) is less than or equal to 4:
        Set Dictionary.entry(consistency_analysis, "font_consistency") to "medium"
    Otherwise:
        Set Dictionary.entry(consistency_analysis, "font_consistency") to "low"
    
    If length(unique_spacing) is less than or equal to 2:
        Set Dictionary.entry(consistency_analysis, "spacing_consistency") to "high"
    Otherwise if length(unique_spacing) is less than or equal to 4:
        Set Dictionary.entry(consistency_analysis, "spacing_consistency") to "medium"
    Otherwise:
        Set Dictionary.entry(consistency_analysis, "spacing_consistency") to "low"
    
    Set Dictionary.entry(consistency_analysis, "total_expressions") to String.fromInteger(length(expressions))
    Set Dictionary.entry(consistency_analysis, "unique_fonts_count") to String.fromInteger(length(unique_fonts))
    Set Dictionary.entry(consistency_analysis, "unique_spacing_count") to String.fromInteger(length(unique_spacing))
    
    Return consistency_analysis

Process called "update_formatting_cache" that takes cache_entries as Dictionary[String, String] returns Boolean:
    Note: Update formatting cache for performance optimization
    Let cache_updated be false
    Let max_cache_size be 1000
    Let current_cache_size be Dictionary.size(cache_entries)
    
    If current_cache_size is less than max_cache_size:
        For each key in Dictionary.keys(cache_entries):
            Let value be Dictionary.get(cache_entries, key, "")
            If value does not equal "":
                Set cache_updated to true
    Otherwise:
        Let keys_to_remove be []
        Let removal_count be current_cache_size minus max_cache_size plus 100
        
        Let i be 0
        For each key in Dictionary.keys(cache_entries):
            If i is less than removal_count:
                Append key to keys_to_remove
                Set i to i plus 1
        
        For each key_to_remove in keys_to_remove:
            Dictionary.remove(cache_entries, key_to_remove)
        
        Set cache_updated to true
    
    Return cache_updated

Process called "benchmark_formatting_operations" that takes operation_types as List[String], test_expressions as List[String] returns Dictionary[String, Float]:
    Note: Benchmark performance of formatting operations
    Let benchmark_results be {}
    Let iterations be 100
    
    For each operation_type in operation_types:
        Let total_time be 0.0
        
        Let i be 0
        While i is less than iterations:
            Let start_time be DateTime.get_current_milliseconds()
            
            If operation_type is equal to "format_symbol":
                For each expr in test_expressions:
                    Let formatted be format_mathematical_symbol(expr, {})
            Otherwise if operation_type is equal to "apply_color":
                For each expr in test_expressions:
                    Let colored be apply_color_coding(expr, {})
            Otherwise if operation_type is equal to "export_latex":
                For each expr in test_expressions:
                    Let latex be export_to_latex(expr, {})
            Otherwise if operation_type is equal to "multiline_format":
                For each expr in test_expressions:
                    Let parts be [expr]
                    Let multiline be format_multiline_equation(parts, ["center"])
            
            Let end_time be DateTime.get_current_milliseconds()
            Set total_time to total_time plus (end_time minus start_time)
            Set i to i plus 1
        
        Let average_time be total_time / iterations
        Set Dictionary.entry(benchmark_results, operation_type) to average_time
    
    Return benchmark_results