Note: 
Dynamical Systems Analysis Module
 
This module provides comprehensive analysis of dynamical systems theory.
Dynamical systems study evolution of states over time via differential equations.

Mathematical Foundation:
- Continuous systems: dx/dt is equal to f(x,t) with flows φᵗ: M → M
- Discrete systems: xₙ₊₁ is equal to f(xₙ) with maps f: M → M  
- Phase space: state space M with vector field defining dynamics
- Stability analysis: linearization, Lyapunov functions, center manifolds
- Invariant sets: fixed points, periodic orbits, invariant tori, attractors
- Structural stability: persistence under perturbations
- Hamiltonian systems: energy conservation and symplectic structure
- Integrable vs. chaotic dynamics and KAM theory

Applications include mechanical systems, population dynamics, epidemiology,
neuroscience, climate modeling, economics, and engineering control.
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/engine/numerical/ode" as ODESolvers
Import module "math/engine/numerical/differentiation" as NumericalDiff
Import module "math/engine/autodiff/higher_order" as AutoDiff
Import module "math/algebra/linear" as LinearAlgebra
Import module "math/symbolic/equations" as SymbolicEq
Import module "math/engine/linalg/decomposition" as LinAlgDecomp
Import module "math/core/trigonometry" as Trig
Import module "math/core/operations" as MathOps
Import module "math/precision/bigdecimal" as BigDecimal

Note: ===== Dynamical System Types =====

Type called "DynamicalSystem":
    continuous_system as Boolean
    autonomous as Boolean
    dimension as Integer
    state_space_bounds as List[Tuple[Float64, Float64]]
    vector_field as Function
    jacobian_function as Function
    parameters as Dictionary[String, Float64]
    conserved_quantities as List[Function]
    symmetries as List[Function]

Type called "PhasePortrait":
    equilibrium_points as List[List[Float64]]
    periodic_orbits as List[List[List[Float64]]]
    separatrices as List[List[List[Float64]]]
    flow_direction_field as List[List[List[Float64]]]
    nullclines as List[List[List[Float64]]]
    invariant_manifolds as List[List[List[Float64]]]
    basins_of_attraction as List[List[List[Float64]]]
    saddle_connections as List[List[List[Float64]]]

Type called "StabilityAnalysis":
    equilibrium_point as List[Float64]
    eigenvalues as List[Complex64]
    eigenvectors as List[List[Complex64]]
    stability_type as String
    lyapunov_function as Function
    stable_manifold_dimension as Integer
    unstable_manifold_dimension as Integer
    center_manifold_dimension as Integer

Note: ===== Helper Functions =====

Process called "matrix_multiply_float64" that takes a as List[List[Float64]], b as List[List[Float64]] returns List[List[Float64]]:
    Note: Multiplies two matrices represented as List[List[Float64]]
    Let rows_a be List.length[a]
    Let cols_a be List.length[a[0]]
    Let rows_b be List.length[b]
    Let cols_b be List.length[b[0]]
    
    If cols_a does not equal rows_b:
        Throw Errors.InvalidArgument
    
    Let result be List.fill[List[Float64]][rows_a, List.fill[Float64][cols_b, 0.0]]
    
    For i from 0 to rows_a minus 1:
        For j from 0 to cols_b minus 1:
            Let sum be 0.0
            For k from 0 to cols_a minus 1:
                Let sum be sum plus (a[i][k] multiplied by b[k][j])
            Let result[i][j] be sum
    
    Return result

Process called "compute_complex_eigenvalues_simple" that takes matrix as List[List[Float64]] returns List[Complex64]:
    Note: Computes eigenvalues allowing complex results for 2x2 and 3x3 matrices
    Let n be List.length[matrix]
    
    If n is equal to 1:
        Return [Complex64.new[matrix[0][0], 0.0]]
    
    If n is equal to 2:
        Note: For 2x2 matrix: λ is equal to (tr ± √(tr² minus 4det))/2
        Let trace be matrix[0][0] plus matrix[1][1]
        Let det be matrix[0][0] multiplied by matrix[1][1] minus matrix[0][1] multiplied by matrix[1][0]
        Let discriminant be trace multiplied by trace minus 4.0 multiplied by det
        
        If discriminant is greater than or equal to 0.0:
            Let sqrt_disc be MathOps.square_root[discriminant.to_string[], 15].value.to_float[]
            Let lambda1 be (trace plus sqrt_disc) / 2.0
            Let lambda2 be (trace minus sqrt_disc) / 2.0
            Return [Complex64.new[lambda1, 0.0], Complex64.new[lambda2, 0.0]]
        Otherwise:
            Let sqrt_disc_neg be MathOps.square_root[(-discriminant).to_string[], 15].value.to_float[]
            Let real_part be trace / 2.0
            Let imag_part be sqrt_disc_neg / 2.0
            Return [Complex64.new[real_part, imag_part], Complex64.new[real_part, -imag_part]]
    
    Note: For larger matrices, use iterative method (power iteration variant)
    Let eigenvalues be List.empty[Complex64][]
    Let working_matrix be matrix
    
    For iteration from 0 to n minus 1:
        Let max_val be 0.0
        Let max_i be 0
        Let max_j be 0
        
        For i from 0 to n minus 1:
            For j from 0 to n minus 1:
                If i does not equal j and MathOps.absolute[working_matrix[i][j]] is greater than max_val:
                    Let max_val be MathOps.absolute[working_matrix[i][j]]
                    Let max_i be i
                    Let max_j be j
        
        If max_val is less than 1e-10:
            Break
        
        Let theta be 0.5 multiplied by Trig.arctan2[2.0 multiplied by working_matrix[max_i][max_j], working_matrix[max_j][max_j] minus working_matrix[max_i][max_i]]
        Let c be Trig.cosine[theta]
        Let s be Trig.sine[theta]
        
        Let new_matrix be List.copy[working_matrix]
        For k from 0 to n minus 1:
            Let temp_ik be c multiplied by working_matrix[max_i][k] minus s multiplied by working_matrix[max_j][k]
            Let temp_jk be s multiplied by working_matrix[max_i][k] plus c multiplied by working_matrix[max_j][k]
            Let new_matrix[max_i][k] be temp_ik
            Let new_matrix[max_j][k] be temp_jk
        
        For k from 0 to n minus 1:
            Let temp_ki be c multiplied by new_matrix[k][max_i] minus s multiplied by new_matrix[k][max_j]
            Let temp_kj be s multiplied by new_matrix[k][max_i] plus c multiplied by new_matrix[k][max_j]
            Let new_matrix[k][max_i] be temp_ki
            Let new_matrix[k][max_j] be temp_kj
        
        Let working_matrix be new_matrix
    
    For i from 0 to n minus 1:
        Let eigenvalues be List.append[eigenvalues, Complex64.new[working_matrix[i][i], 0.0]]
    
    Return eigenvalues

Process called "newton_multidimensional_float64" that takes f as Function, jacobian as Function, initial_guess as List[Float64], tolerance as Float64, max_iterations as Integer returns List[Float64]:
    Note: Newton's method for multidimensional root finding with Float64
    Let x be List.copy[initial_guess]
    Let n be List.length[x]
    
    For iteration from 0 to max_iterations minus 1:
        Let fx be f.call[x]
        Let jac be jacobian.call[x]
        
        Note: Check convergence
        Let norm_fx be 0.0
        For i from 0 to n minus 1:
            Let norm_fx be norm_fx plus fx[i] multiplied by fx[i]
        Let norm_fx be MathOps.square_root[norm_fx.to_string[], 15].value.to_float[]
        
        If norm_fx is less than tolerance:
            Return x
        
        Note: Solve Jac multiplied by dx is equal to -fx using simple Gaussian elimination for small systems
        Let augmented be List.empty[List[Float64]][]
        For i from 0 to n minus 1:
            Let row be List.copy[jac[i]]
            Let row be List.append[row, -fx[i]]
            Let augmented be List.append[augmented, row]
        
        Note: Forward elimination
        For k from 0 to n minus 1:
            Let max_row be k
            For i from k plus 1 to n minus 1:
                If MathOps.absolute[augmented[i][k]] is greater than MathOps.absolute[augmented[max_row][k]]:
                    Let max_row be i
            
            Let temp_row be augmented[k]
            Let augmented[k] be augmented[max_row]
            Let augmented[max_row] be temp_row
            
            For i from k plus 1 to n minus 1:
                Let factor be augmented[i][k] / augmented[k][k]
                For j from k to n:
                    Let augmented[i][j] be augmented[i][j] minus factor multiplied by augmented[k][j]
        
        Note: Back substitution
        Let dx be List.fill[Float64][n, 0.0]
        For i from n minus 1 down to 0:
            Let sum be augmented[i][n]
            For j from i plus 1 to n minus 1:
                Let sum be sum minus augmented[i][j] multiplied by dx[j]
            Let dx[i] be sum / augmented[i][i]
        
        Note: Update x
        For i from 0 to n minus 1:
            Let x[i] be x[i] plus dx[i]
    
    Return x

Process called "integrate_trajectory" that takes vector_field as Function, initial_condition as List[Float64], time_span as Tuple[Float64, Float64], num_steps as Integer returns List[List[Float64]]:
    Note: Integrates trajectory using RK4 method
    Let t_start be time_span.0
    Let t_end be time_span.1
    Let dt be (t_end minus t_start) / Float64.from_integer[num_steps]
    Let t be t_start
    Let y be List.copy[initial_condition]
    Let n be List.length[y]
    
    Let trajectory be List.empty[List[Float64]][]
    Let trajectory be List.append[trajectory, List.copy[y]]
    
    For step from 0 to num_steps minus 1:
        Let k1 be vector_field.call[y]
        
        Let y_temp be List.empty[Float64][]
        For i from 0 to n minus 1:
            Let y_temp be List.append[y_temp, y[i] plus 0.5 multiplied by dt multiplied by k1[i]]
        Let k2 be vector_field.call[y_temp]
        
        Let y_temp be List.empty[Float64][]
        For i from 0 to n minus 1:
            Let y_temp be List.append[y_temp, y[i] plus 0.5 multiplied by dt multiplied by k2[i]]
        Let k3 be vector_field.call[y_temp]
        
        Let y_temp be List.empty[Float64][]
        For i from 0 to n minus 1:
            Let y_temp be List.append[y_temp, y[i] plus dt multiplied by k3[i]]
        Let k4 be vector_field.call[y_temp]
        
        For i from 0 to n minus 1:
            Let y[i] be y[i] plus (dt / 6.0) multiplied by (k1[i] plus 2.0 multiplied by k2[i] plus 2.0 multiplied by k3[i] plus k4[i])
        
        Let t be t plus dt
        Let trajectory be List.append[trajectory, List.copy[y]]
    
    Return trajectory

Note: ===== Equilibrium Analysis =====

Process called "find_equilibrium_points" that takes vector_field as Function, search_bounds as List[Tuple[Float64, Float64]], tolerance as Float64 returns List[List[Float64]]:
    Note: Finds equilibrium points where vector field vanishes: f(x*) is equal to 0
    Note: Uses multidimensional root finding with multiple initial guesses
    Note: Verifies equilibria by checking residual magnitude
    Note: Essential first step in phase portrait construction
    
    Let dimension be List.length[search_bounds]
    Let equilibria be List.empty[List[Float64]][]
    Let num_guesses_per_dim be 5
    
    Note: Create numerical Jacobian function
    Let jacobian_func be Function.new[["x"], """
        Let h be 1e-8
        Let n be List.length[x]
        Let result be List.fill[List[Float64]][n, List.fill[Float64][n, 0.0]]
        
        For i from 0 to n minus 1:
            For j from 0 to n minus 1:
                Let x_plus be List.copy[x]
                Let x_minus be List.copy[x]
                Let x_plus[j] be x_plus[j] plus h
                Let x_minus[j] be x_minus[j] minus h
                
                Let f_plus be vector_field.call[x_plus][i]
                Let f_minus be vector_field.call[x_minus][i]
                Let result[i][j] be (f_plus minus f_minus) / (2.0 multiplied by h)
        
        Return result
    """]
    
    Note: Generate initial guesses using grid search
    Let total_guesses be MathOps.power[num_guesses_per_dim, dimension]
    
    For guess_index from 0 to total_guesses minus 1:
        Let initial_guess be List.empty[Float64][]
        Let temp_index be guess_index
        
        For dim from 0 to dimension minus 1:
            Let coord_index be temp_index % num_guesses_per_dim
            Let temp_index be temp_index / num_guesses_per_dim
            Let min_bound be search_bounds[dim].0
            Let max_bound be search_bounds[dim].1
            Let coord_value be min_bound plus (max_bound minus min_bound) multiplied by Float64.from_integer[coord_index] / Float64.from_integer[num_guesses_per_dim minus 1]
            Let initial_guess be List.append[initial_guess, coord_value]
        
        Note: Try to find equilibrium from this initial guess
        Let equilibrium be newton_multidimensional_float64[vector_field, jacobian_func, initial_guess, tolerance, 50]
        
        Note: Verify this is actually an equilibrium
        Let residual be vector_field.call[equilibrium]
        Let norm_residual be 0.0
        For i from 0 to dimension minus 1:
            Let norm_residual be norm_residual plus residual[i] multiplied by residual[i]
        Let norm_residual be MathOps.square_root[norm_residual.to_string[], 15].value.to_float[]
        
        If norm_residual is less than tolerance:
            Note: Check if this equilibrium is already in our list
            Let is_new be True
            For existing_eq in equilibria:
                Let distance be 0.0
                For i from 0 to dimension minus 1:
                    Let diff be equilibrium[i] minus existing_eq[i]
                    Let distance be distance plus diff multiplied by diff
                Let distance be MathOps.square_root[distance.to_string[], 15].value.to_float[]
                
                If distance is less than tolerance multiplied by 10.0:
                    Let is_new be False
                    Break
            
            If is_new:
                Let equilibria be List.append[equilibria, equilibrium]
    
    Return equilibria

Process called "classify_equilibrium_stability" that takes equilibrium_point as List[Float64], jacobian as List[List[Float64]] returns StabilityAnalysis:
    Note: Classifies equilibrium stability from linearization eigenvalues
    Note: Stable node: all λᵢ is less than 0; Unstable node: all λᵢ is greater than 0
    Note: Saddle: mixed signs; Focus: complex λ with Re(λ) ≠ 0
    Note: Center: pure imaginary eigenvalues (Hamiltonian systems)
    
    Let eigenvalues be compute_complex_eigenvalues_simple[jacobian]
    Let n be List.length[eigenvalues]
    
    Note: Count eigenvalues by their real parts
    Let stable_count be 0
    Let unstable_count be 0
    Let center_count be 0
    
    For lambda in eigenvalues:
        Let real_part be lambda.real
        If real_part is less than -1e-10:
            Let stable_count be stable_count plus 1
        Otherwise if real_part is greater than 1e-10:
            Let unstable_count be unstable_count plus 1
        Otherwise:
            Let center_count be center_count plus 1
    
    Note: Determine stability type
    Let stability_type be ""
    If center_count is greater than 0:
        Let stability_type be "center"
    Otherwise if stable_count is equal to n:
        Note: All eigenvalues have negative real parts
        Let has_complex be False
        For lambda in eigenvalues:
            If MathOps.absolute[lambda.imaginary] is greater than 1e-10:
                Let has_complex be True
                Break
        
        If has_complex:
            Let stability_type be "stable_focus"
        Otherwise:
            Let stability_type be "stable_node"
    Otherwise if unstable_count is equal to n:
        Note: All eigenvalues have positive real parts
        Let has_complex be False
        For lambda in eigenvalues:
            If MathOps.absolute[lambda.imaginary] is greater than 1e-10:
                Let has_complex be True
                Break
        
        If has_complex:
            Let stability_type be "unstable_focus"
        Otherwise:
            Let stability_type be "unstable_node"
    Otherwise:
        Let stability_type be "saddle"
    
    Note: Compute eigenvectors (simplified for real case)
    Let eigenvectors be List.empty[List[Complex64]][]
    For lambda in eigenvalues:
        Let real_lambda be lambda.real
        Let identity_matrix be List.fill[List[Float64]][n, List.fill[Float64][n, 0.0]]
        For i from 0 to n minus 1:
            Let identity_matrix[i][i] be 1.0
        
        Note: Compute (J minus λI) for eigenvector calculation
        Let matrix_minus_lambda be List.empty[List[Float64]][]
        For i from 0 to n minus 1:
            Let row be List.empty[Float64][]
            For j from 0 to n minus 1:
                Let entry be jacobian[i][j] minus real_lambda multiplied by identity_matrix[i][j]
                Let row be List.append[row, entry]
            Let matrix_minus_lambda be List.append[matrix_minus_lambda, row]
        
        Note: Find null space (simplified minus use first free variable)
        Let eigenvector be List.empty[Complex64][]
        For i from 0 to n minus 1:
            If i is equal to 0:
                Let eigenvector be List.append[eigenvector, Complex64.new[1.0, 0.0]]
            Otherwise:
                Let eigenvector be List.append[eigenvector, Complex64.new[0.0, 0.0]]
        
        Let eigenvectors be List.append[eigenvectors, eigenvector]
    
    Note: Create dummy Lyapunov function
    Let lyapunov_function be Function.new[["x"], "Return x[0] multiplied by x[0] plus x[1] multiplied by x[1]"]
    
    Return StabilityAnalysis.new[
        equilibrium_point: equilibrium_point,
        eigenvalues: eigenvalues,
        eigenvectors: eigenvectors,
        stability_type: stability_type,
        lyapunov_function: lyapunov_function,
        stable_manifold_dimension: stable_count,
        unstable_manifold_dimension: unstable_count,
        center_manifold_dimension: center_count
    ]

Process called "compute_stable_unstable_manifolds" that takes equilibrium_point as List[Float64], jacobian as List[List[Float64]], manifold_length as Float64 returns Tuple[List[List[Float64]], List[List[Float64]]]:
    Note: Computes local stable and unstable manifolds of saddle points
    Note: Integrates along eigenvector directions of linearization
    Note: Stable manifold: trajectories approaching equilibrium as t→∞
    Note: Unstable manifold: trajectories approaching as t→-∞
    
    Let eigenvalues be compute_complex_eigenvalues_simple[jacobian]
    Let n be List.length[eigenvalues]
    
    Let stable_manifold be List.empty[List[Float64]][]
    Let unstable_manifold be List.empty[List[Float64]][]
    
    Note: Find stable and unstable eigenvectors
    For i from 0 to n minus 1:
        Let lambda be eigenvalues[i]
        Let real_part be lambda.real
        
        If MathOps.absolute[lambda.imaginary] is less than 1e-10:  Note: Real eigenvalue
            Note: Compute eigenvector by solving (J minus λI)v is equal to 0
            Let lambda_real be real_part
            Let matrix_copy be List.empty[List[Float64]][]
            
            For row_idx from 0 to n minus 1:
                Let row be List.empty[Float64][]
                For col_idx from 0 to n minus 1:
                    Let entry be jacobian[row_idx][col_idx]
                    If row_idx is equal to col_idx:
                        Let entry be entry minus lambda_real
                    Let row be List.append[row, entry]
                Let matrix_copy be List.append[matrix_copy, row]
            
            Note: Find eigenvector (simplified minus assume first variable is free)
            Let eigenvector be List.fill[Float64][n, 0.0]
            Let eigenvector[0] be 1.0
            
            Note: Solve for other components if possible
            If n is equal to 2 and MathOps.absolute[matrix_copy[1][1]] is greater than 1e-10:
                Let eigenvector[1] be -matrix_copy[1][0] / matrix_copy[1][1]
            
            Note: Normalize eigenvector
            Let norm be 0.0
            For j from 0 to n minus 1:
                Let norm be norm plus eigenvector[j] multiplied by eigenvector[j]
            Let norm be MathOps.square_root[norm.to_string[], 15].value.to_float[]
            
            If norm is greater than 1e-10:
                For j from 0 to n minus 1:
                    Let eigenvector[j] be eigenvector[j] / norm
                
                Note: Create manifold points along eigenvector direction
                Let num_points be 20
                For point_idx from 0 to num_points minus 1:
                    Let t be manifold_length multiplied by (Float64.from_integer[point_idx] / Float64.from_integer[num_points minus 1] minus 0.5) multiplied by 2.0
                    
                    Let manifold_point be List.empty[Float64][]
                    For j from 0 to n minus 1:
                        Let coord be equilibrium_point[j] plus t multiplied by eigenvector[j]
                        Let manifold_point be List.append[manifold_point, coord]
                    
                    If real_part is less than 0.0:  Note: Stable direction
                        Let stable_manifold be List.append[stable_manifold, manifold_point]
                    Otherwise if real_part is greater than 0.0:  Note: Unstable direction
                        Let unstable_manifold be List.append[unstable_manifold, manifold_point]
    
    Return Tuple.new[stable_manifold, unstable_manifold]

Note: ===== Linear Stability Analysis =====

Process called "linearize_system" that takes vector_field as Function, equilibrium_point as List[Float64] returns List[List[Float64]]:
    Note: Computes Jacobian matrix of vector field at equilibrium point
    Note: Linear approximation: dx/dt ≈ J(x*)·(x minus x*) near equilibrium
    Note: Determines local stability properties via eigenvalue analysis
    Note: Foundation for center manifold and normal form theory
    
    Let n be List.length[equilibrium_point]
    Let h be 1e-8
    Let jacobian be List.fill[List[Float64]][n, List.fill[Float64][n, 0.0]]
    
    Note: Compute Jacobian using central differences
    For i from 0 to n minus 1:
        For j from 0 to n minus 1:
            Let x_plus be List.copy[equilibrium_point]
            Let x_minus be List.copy[equilibrium_point]
            Let x_plus[j] be x_plus[j] plus h
            Let x_minus[j] be x_minus[j] minus h
            
            Let f_plus be vector_field.call[x_plus]
            Let f_minus be vector_field.call[x_minus]
            
            Let jacobian[i][j] be (f_plus[i] minus f_minus[i]) / (2.0 multiplied by h)
    
    Return jacobian

Process called "solve_linear_system" that takes jacobian as List[List[Float64]], initial_condition as List[Float64], time_points as List[Float64] returns List[List[Float64]]:
    Note: Solves linear system dx/dt is equal to Ax exactly via matrix exponential
    Note: Solution: x(t) is equal to exp(At)·x₀ using eigenvalue decomposition
    Note: Provides analytical benchmark for numerical integration
    Note: Reveals fundamental solution matrix structure
    
    Let n be List.length[initial_condition]
    Let solution be List.empty[List[Float64]][]
    
    Note: For each time point, compute x(t) is equal to exp(A*t) multiplied by x0
    For t in time_points:
        Note: Compute matrix exponential using eigenvalue decomposition (simplified)
        Let eigenvalues be compute_complex_eigenvalues_simple[jacobian]
        
        Note: For small systems, use direct computation
        If n is equal to 1:
            Let exp_lambda_t be MathOps.exponential[eigenvalues[0].real multiplied by t]
            Let x_t be [initial_condition[0] multiplied by exp_lambda_t]
            Let solution be List.append[solution, x_t]
        Otherwise if n is equal to 2:
            Note: 2x2 case minus use analytical matrix exponential
            Let a11 be jacobian[0][0]
            Let a12 be jacobian[0][1]
            Let a21 be jacobian[1][0]
            Let a22 be jacobian[1][1]
            
            Let trace be a11 plus a22
            Let det be a11 multiplied by a22 minus a12 multiplied by a21
            Let discriminant be trace multiplied by trace minus 4.0 multiplied by det
            
            If discriminant is greater than or equal to 0.0:
                Note: Real eigenvalues
                Let sqrt_disc be MathOps.square_root[discriminant.to_string[], 15].value.to_float[]
                Let lambda1 be (trace plus sqrt_disc) / 2.0
                Let lambda2 be (trace minus sqrt_disc) / 2.0
                
                Let exp_lambda1_t be MathOps.exponential[lambda1 multiplied by t]
                Let exp_lambda2_t be MathOps.exponential[lambda2 multiplied by t]
                
                Note: Simplified computation assuming diagonalizable
                Let x1 be initial_condition[0] multiplied by (exp_lambda1_t plus exp_lambda2_t) / 2.0
                Let x2 be initial_condition[1] multiplied by (exp_lambda1_t plus exp_lambda2_t) / 2.0
                Let x_t be [x1, x2]
                Let solution be List.append[solution, x_t]
            Otherwise:
                Note: Complex eigenvalues minus oscillatory solution
                Let real_part be trace / 2.0
                Let imag_part be MathOps.square_root[(-discriminant).to_string[], 15].value.to_float[] / 2.0
                
                Let exp_real_t be MathOps.exponential[real_part multiplied by t]
                Let cos_imag_t be Trig.cosine[imag_part multiplied by t]
                Let sin_imag_t be Trig.sine[imag_part multiplied by t]
                
                Let x1 be initial_condition[0] multiplied by exp_real_t multiplied by cos_imag_t minus initial_condition[1] multiplied by exp_real_t multiplied by sin_imag_t
                Let x2 be initial_condition[0] multiplied by exp_real_t multiplied by sin_imag_t plus initial_condition[1] multiplied by exp_real_t multiplied by cos_imag_t
                Let x_t be [x1, x2]
                Let solution be List.append[solution, x_t]
        Otherwise:
            Note: For higher dimensions, use numerical approximation
            Let matrix_t be List.empty[List[Float64]][]
            For i from 0 to n minus 1:
                Let row be List.empty[Float64][]
                For j from 0 to n minus 1:
                    Let row be List.append[row, jacobian[i][j] multiplied by t]
                Let matrix_t be List.append[matrix_t, row]
            
            Note: Matrix exponential approximation using series (first few terms)
            Let identity be List.fill[List[Float64]][n, List.fill[Float64][n, 0.0]]
            For i from 0 to n minus 1:
                Let identity[i][i] be 1.0
            
            Let exp_matrix be identity
            Let term be matrix_t
            Let factorial be 2.0
            
            Note: Add A*t term
            For i from 0 to n minus 1:
                For j from 0 to n minus 1:
                    Let exp_matrix[i][j] be exp_matrix[i][j] plus term[i][j]
            
            Note: Add (A*t)^2/2! term
            Let term_squared be matrix_multiply_float64[term, term]
            For i from 0 to n minus 1:
                For j from 0 to n minus 1:
                    Let exp_matrix[i][j] be exp_matrix[i][j] plus term_squared[i][j] / factorial
            
            Note: Multiply by initial condition
            Let x_t be List.empty[Float64][]
            For i from 0 to n minus 1:
                Let sum be 0.0
                For j from 0 to n minus 1:
                    Let sum be sum plus exp_matrix[i][j] multiplied by initial_condition[j]
                Let x_t be List.append[x_t, sum]
            
            Let solution be List.append[solution, x_t]
    
    Return solution

Process called "compute_fundamental_matrix" that takes jacobian as List[List[Float64]], time_interval as Tuple[Float64, Float64] returns List[List[List[Float64]]]:
    Note: Computes fundamental matrix Φ(t) satisfying dΦ/dt is equal to A·Φ, Φ(0) is equal to I
    Note: General solution: x(t) is equal to Φ(t)·x₀ for linear system
    Note: Wronskian determinant measures solution independence
    Note: Essential for understanding linear system structure
    
    Let t_start be time_interval.0
    Let t_end be time_interval.1
    Let n be List.length[jacobian]
    Let num_steps be 100
    Let dt be (t_end minus t_start) / Float64.from_integer[num_steps]
    
    Let fundamental_matrices be List.empty[List[List[Float64]]][]
    
    For step from 0 to num_steps:
        Let t be t_start plus Float64.from_integer[step] multiplied by dt
        
        Note: Compute Φ(t) using matrix exponential approximation
        Let identity be List.fill[List[Float64]][n, List.fill[Float64][n, 0.0]]
        For i from 0 to n minus 1:
            Let identity[i][i] be 1.0
        
        Let At be List.empty[List[Float64]][]
        For i from 0 to n minus 1:
            Let row be List.empty[Float64][]
            For j from 0 to n minus 1:
                Let row be List.append[row, jacobian[i][j] multiplied by t]
            Let At be List.append[At, row]
        
        Note: exp(At) ≈ I plus At plus (At)²/2!
        Let phi_t be identity
        For i from 0 to n minus 1:
            For j from 0 to n minus 1:
                Let phi_t[i][j] be phi_t[i][j] plus At[i][j]
        
        Let At_squared be matrix_multiply_float64[At, At]
        For i from 0 to n minus 1:
            For j from 0 to n minus 1:
                Let phi_t[i][j] be phi_t[i][j] plus At_squared[i][j] / 2.0
        
        Let fundamental_matrices be List.append[fundamental_matrices, phi_t]
    
    Return fundamental_matrices

Note: ===== Periodic Orbit Analysis =====

Process called "find_periodic_orbits" that takes vector_field as Function, search_region as List[Tuple[Float64, Float64]], max_period as Float64 returns List[List[List[Float64]]]:
    Note: Finds periodic orbits using shooting and continuation methods
    Note: Searches for solutions x(T) is equal to x(0) with minimal period T
    Note: Uses Poincaré map fixed points and harmonic balance
    Note: Critical for understanding system's long-term behavior
    
    Let dimension be List.length[search_region]
    Let periodic_orbits be List.empty[List[List[Float64]]][]
    Let num_initial_guesses be 20
    
    For guess_idx from 0 to num_initial_guesses minus 1:
        Note: Generate random initial condition
        Let initial_condition be List.empty[Float64][]
        For dim from 0 to dimension minus 1:
            Let min_val be search_region[dim].0
            Let max_val be search_region[dim].1
            Let random_val be min_val plus (max_val minus min_val) multiplied by Float64.from_integer[guess_idx] / Float64.from_integer[num_initial_guesses]
            Let initial_condition be List.append[initial_condition, random_val]
        
        Note: Try different periods
        For period_steps from 10 to 200 by 10:
            Let period be max_period multiplied by Float64.from_integer[period_steps] / 200.0
            
            Note: Integrate for one period
            Let trajectory be integrate_trajectory[vector_field, initial_condition, Tuple.new[0.0, period], period_steps]
            Let final_point be trajectory[List.length[trajectory] minus 1]
            
            Note: Check if trajectory closes (x(T) ≈ x(0))
            Let closure_error be 0.0
            For i from 0 to dimension minus 1:
                Let diff be final_point[i] minus initial_condition[i]
                Let closure_error be closure_error plus diff multiplied by diff
            Let closure_error be MathOps.square_root[closure_error.to_string[], 15].value.to_float[]
            
            If closure_error is less than 0.01:
                Note: Check if this orbit is new
                Let is_new be True
                For existing_orbit in periodic_orbits:
                    Let orbit_distance be 0.0
                    For i from 0 to dimension minus 1:
                        Let diff be trajectory[0][i] minus existing_orbit[0][i]
                        Let orbit_distance be orbit_distance plus diff multiplied by diff
                    Let orbit_distance be MathOps.square_root[orbit_distance.to_string[], 15].value.to_float[]
                    
                    If orbit_distance is less than 0.1:
                        Let is_new be False
                        Break
                
                If is_new:
                    Let periodic_orbits be List.append[periodic_orbits, trajectory]
    
    Return periodic_orbits

Process called "compute_floquet_multipliers" that takes periodic_orbit as List[List[Float64]], vector_field as Function returns List[Complex64]:
    Note: Computes Floquet multipliers for periodic orbit stability
    Note: Integrates variational equation along periodic trajectory
    Note: Multipliers inside unit circle indicate stable periodic orbit
    Note: One multiplier always is equal to 1 (flow direction)
    
    Let orbit_length be List.length[periodic_orbit]
    If orbit_length is less than 2:
        Return [Complex64.new[1.0, 0.0]]
    
    Let dimension be List.length[periodic_orbit[0]]
    Let period_estimate be 0.0
    
    Note: Estimate period from orbit length and vector field magnitude
    For i from 1 to orbit_length minus 1:
        Let distance be 0.0
        For j from 0 to dimension minus 1:
            Let diff be periodic_orbit[i][j] minus periodic_orbit[i-1][j]
            Let distance be distance plus diff multiplied by diff
        Let distance be MathOps.square_root[distance.to_string[], 15].value.to_float[]
        
        Let field_magnitude be 0.0
        Let field_value be vector_field.call[periodic_orbit[i-1]]
        For component in field_value:
            Let field_magnitude be field_magnitude plus component multiplied by component
        Let field_magnitude be MathOps.square_root[field_magnitude.to_string[], 15].value.to_float[]
        
        If field_magnitude is greater than 1e-10:
            Let period_estimate be period_estimate plus distance / field_magnitude
    
    Note: Compute monodromy matrix by integrating variational equation
    Let identity_matrix be List.fill[List[Float64]][dimension, List.fill[Float64][dimension, 0.0]]
    For i from 0 to dimension minus 1:
        Let identity_matrix[i][i] be 1.0
    
    Let monodromy_matrix be identity_matrix
    Let dt be period_estimate / Float64.from_integer[orbit_length minus 1]
    
    Note: Integrate variational equation along the orbit (simplified)
    For orbit_idx from 0 to orbit_length minus 2:
        Let current_point be periodic_orbit[orbit_idx]
        
        Note: Compute Jacobian at current point
        Let jacobian be linearize_system[vector_field, current_point]
        
        Note: Approximate exp(J*dt) for small dt
        Let exp_jdt be identity_matrix
        For i from 0 to dimension minus 1:
            For j from 0 to dimension minus 1:
                Let exp_jdt[i][j] be exp_jdt[i][j] plus jacobian[i][j] multiplied by dt
        
        Note: Update monodromy matrix
        Let monodromy_matrix be matrix_multiply_float64[exp_jdt, monodromy_matrix]
    
    Note: Compute eigenvalues of monodromy matrix (Floquet multipliers)
    Let multipliers be compute_complex_eigenvalues_simple[monodromy_matrix]
    
    Return multipliers

Process called "analyze_limit_cycle" that takes vector_field as Function, approximate_cycle as List[List[Float64]] returns Dictionary[String, Float64]:
    Note: Analyzes limit cycle properties: period, amplitude, stability
    Note: Computes orbital period and characteristic multipliers
    Note: Determines stability via Poincaré map linearization
    Note: Essential for oscillatory system analysis
    
    Let results be Dictionary.empty[String, Float64]()
    Let cycle_length be List.length[approximate_cycle]
    
    If cycle_length is less than 3:
        Let results be Dictionary.put[results, "period", 0.0]
        Let results be Dictionary.put[results, "amplitude", 0.0]
        Let results be Dictionary.put[results, "stability_index", 0.0]
        Return results
    
    Let dimension be List.length[approximate_cycle[0]]
    
    Note: Compute period by integrating along cycle
    Let period be 0.0
    For i from 1 to cycle_length minus 1:
        Let distance be 0.0
        For j from 0 to dimension minus 1:
            Let diff be approximate_cycle[i][j] minus approximate_cycle[i-1][j]
            Let distance be distance plus diff multiplied by diff
        Let distance be MathOps.square_root[distance.to_string[], 15].value.to_float[]
        
        Let field_magnitude be 0.0
        Let field_value be vector_field.call[approximate_cycle[i-1]]
        For component in field_value:
            Let field_magnitude be field_magnitude plus component multiplied by component
        Let field_magnitude be MathOps.square_root[field_magnitude.to_string[], 15].value.to_float[]
        
        If field_magnitude is greater than 1e-10:
            Let period be period plus distance / field_magnitude
    
    Note: Compute amplitude (distance from center to cycle)
    Let center be List.fill[Float64][dimension, 0.0]
    For i from 0 to cycle_length minus 1:
        For j from 0 to dimension minus 1:
            Let center[j] be center[j] plus approximate_cycle[i][j]
    
    For j from 0 to dimension minus 1:
        Let center[j] be center[j] / Float64.from_integer[cycle_length]
    
    Let max_amplitude be 0.0
    For i from 0 to cycle_length minus 1:
        Let distance_from_center be 0.0
        For j from 0 to dimension minus 1:
            Let diff be approximate_cycle[i][j] minus center[j]
            Let distance_from_center be distance_from_center plus diff multiplied by diff
        Let distance_from_center be MathOps.square_root[distance_from_center.to_string[], 15].value.to_float[]
        
        If distance_from_center is greater than max_amplitude:
            Let max_amplitude be distance_from_center
    
    Note: Compute stability via Floquet multipliers
    Let multipliers be compute_floquet_multipliers[approximate_cycle, vector_field]
    Let stability_index be 0.0
    
    For multiplier in multipliers:
        Let magnitude be MathOps.square_root[(multiplier.real multiplied by multiplier.real plus multiplier.imaginary multiplied by multiplier.imaginary).to_string[], 15].value.to_float[]
        If magnitude is greater than stability_index and MathOps.absolute[magnitude minus 1.0] is greater than 0.01:  Note: Skip trivial multiplier is equal to 1
            Let stability_index be magnitude
    
    Let results be Dictionary.put[results, "period", period]
    Let results be Dictionary.put[results, "amplitude", max_amplitude]
    Let results be Dictionary.put[results, "stability_index", stability_index]
    
    Return results

Note: ===== Phase Portrait Construction =====

Process called "compute_nullclines" that takes vector_field as Function, coordinate_ranges as List[Tuple[Float64, Float64]] returns List[List[List[Float64]]]:
    Note: Computes nullclines where individual velocity components vanish
    Note: dx/dt is equal to 0 and dy/dt is equal to 0 nullclines for 2D systems
    Note: Intersections give equilibrium points
    Note: Flow direction changes across nullclines
    
    Let dimension be List.length[coordinate_ranges]
    Let nullclines be List.empty[List[List[Float64]]][]
    Let grid_size be 50
    
    Note: For each dimension, find where that component of vector field is zero
    For dim from 0 to dimension minus 1:
        Let nullcline_points be List.empty[List[Float64]][]
        
        Note: Create grid and find zero crossings
        For i from 0 to grid_size minus 1:
            For j from 0 to grid_size minus 1:
                Let point be List.empty[Float64][]
                For k from 0 to dimension minus 1:
                    Let min_val be coordinate_ranges[k].0
                    Let max_val be coordinate_ranges[k].1
                    Let coord_val be 0.0
                    
                    If k is equal to 0:
                        Let coord_val be min_val plus (max_val minus min_val) multiplied by Float64.from_integer[i] / Float64.from_integer[grid_size minus 1]
                    Otherwise if k is equal to 1:
                        Let coord_val be min_val plus (max_val minus min_val) multiplied by Float64.from_integer[j] / Float64.from_integer[grid_size minus 1]
                    Otherwise:
                        Let coord_val be (min_val plus max_val) / 2.0
                    
                    Let point be List.append[point, coord_val]
                
                Let field_value be vector_field.call[point]
                If MathOps.absolute[field_value[dim]] is less than 0.05:
                    Let nullcline_points be List.append[nullcline_points, point]
        
        Let nullclines be List.append[nullclines, nullcline_points]
    
    Return nullclines

Process called "compute_direction_field" that takes vector_field as Function, grid_points as List[List[Float64]] returns List[List[List[Float64]]]:
    Note: Computes vector field direction at grid points
    Note: Creates arrow field showing flow directions
    Note: Normalizes vectors for visualization clarity
    Note: Foundation for qualitative phase portrait analysis
    
    Let direction_field be List.empty[List[List[Float64]]][]
    
    For point in grid_points:
        Let field_vector be vector_field.call[point]
        
        Note: Normalize the vector for visualization
        Let norm be 0.0
        For component in field_vector:
            Let norm be norm plus component multiplied by component
        Let norm be MathOps.square_root[norm.to_string[], 15].value.to_float[]
        
        If norm is greater than 1e-10:
            Let normalized_vector be List.empty[Float64][]
            For component in field_vector:
                Let normalized_vector be List.append[normalized_vector, component / norm]
            
            Note: Store point and direction
            Let field_entry be List.empty[List[Float64]][]
            Let field_entry be List.append[field_entry, point]
            Let field_entry be List.append[field_entry, normalized_vector]
            Let direction_field be List.append[direction_field, field_entry]
    
    Return direction_field

Process called "compute_separatrices" that takes vector_field as Function, saddle_points as List[List[Float64]] returns List[List[List[Float64]]]:
    Note: Computes separatrices dividing phase space regions
    Note: Integrates along stable/unstable manifolds of saddle points
    Note: Creates boundaries between different dynamical behaviors
    Note: Essential for understanding global phase portrait structure
    
    Let all_separatrices be List.empty[List[List[Float64]]][]
    
    For saddle_point in saddle_points:
        Let jacobian be linearize_system[vector_field, saddle_point]
        Let stable_unstable_manifolds be compute_stable_unstable_manifolds[saddle_point, jacobian, 1.0]
        Let stable_manifold be stable_unstable_manifolds.0
        Let unstable_manifold be stable_unstable_manifolds.1
        
        Note: Extend stable manifold trajectories
        For stable_point in stable_manifold:
            Let trajectory be integrate_trajectory[vector_field, stable_point, Tuple.new[0.0, 10.0], 100]
            Let all_separatrices be List.append[all_separatrices, trajectory]
        
        Note: Extend unstable manifold trajectories (backward integration)
        Let reversed_field be Function.new[["x"], """
            Let original_value be vector_field.call[x]
            Let reversed_value be List.empty[Float64][]
            For component in original_value:
                Let reversed_value be List.append[reversed_value, -component]
            Return reversed_value
        """]
        
        For unstable_point in unstable_manifold:
            Let trajectory be integrate_trajectory[reversed_field, unstable_point, Tuple.new[0.0, 10.0], 100]
            Let all_separatrices be List.append[all_separatrices, trajectory]
    
    Return all_separatrices

Note: ===== Lyapunov Functions =====

Process called "construct_quadratic_lyapunov_function" that takes jacobian as List[List[Float64]] returns List[List[Float64]]:
    Note: Constructs quadratic Lyapunov function V(x) is equal to xᵀPx
    Note: Solves Lyapunov equation AᵀP plus PA is equal to -Q for positive definite P
    Note: Proves asymptotic stability if P is greater than 0 and Q is greater than 0
    Note: Provides basin of attraction estimates
    
    Let n be List.length[jacobian]
    
    Note: For 2x2 systems, solve Lyapunov equation analytically
    If n is equal to 2:
        Let a11 be jacobian[0][0]
        Let a12 be jacobian[0][1]
        Let a21 be jacobian[1][0]
        Let a22 be jacobian[1][1]
        
        Note: Choose Q is equal to I (identity matrix)
        Note: Solve A^T P plus P A is equal to -I for P
        Note: This gives us: 2*a11*P11 plus 2*a21*P12 is equal to -1
        Note:                  (a11+a22)*P12 plus a12*P11 plus a21*P22 is equal to 0
        Note:                  2*a22*P22 plus 2*a12*P12 is equal to -1
        
        Let P be List.fill[List[Float64]][2, List.fill[Float64][2, 0.0]]
        
        Note: Simplified solution for stable systems
        If a11 is less than 0.0 and a22 is less than 0.0:
            Let P[0][0] be -1.0 / (2.0 multiplied by a11)
            Let P[1][1] be -1.0 / (2.0 multiplied by a22)
            Let P[0][1] be 0.0  Note: Simplified case
            Let P[1][0] be 0.0
        Otherwise:
            Note: Use identity matrix as fallback
            Let P[0][0] be 1.0
            Let P[1][1] be 1.0
            Let P[0][1] be 0.0
            Let P[1][0] be 0.0
        
        Return P
    Otherwise:
        Note: For higher dimensions, use identity as approximation
        Let P be List.fill[List[Float64]][n, List.fill[Float64][n, 0.0]]
        For i from 0 to n minus 1:
            Let P[i][i] be 1.0
        Return P

Process called "verify_lyapunov_stability" that takes lyapunov_function as Function, vector_field as Function, equilibrium as List[Float64] returns Boolean:
    Note: Verifies Lyapunov stability conditions for given function
    Note: Checks V(x*) is equal to 0, V(x) is greater than 0 for x ≠ x*, and dV/dt ≤ 0
    Note: Asymptotic stability requires dV/dt is less than 0 away from equilibrium
    Note: Provides rigorous stability proof when conditions satisfied
    
    Let dimension be List.length[equilibrium]
    
    Note: Check V(x*) is equal to 0
    Let v_equilibrium be lyapunov_function.call[equilibrium]
    If MathOps.absolute[v_equilibrium] is greater than 1e-6:
        Return False
    
    Note: Check conditions on a grid around equilibrium
    Let grid_size be 20
    Let radius be 1.0
    
    For i from 0 to grid_size minus 1:
        For j from 0 to grid_size minus 1:
            Let test_point be List.empty[Float64][]
            For k from 0 to dimension minus 1:
                Let offset be radius multiplied by (Float64.from_integer[i] / Float64.from_integer[grid_size minus 1] minus 0.5) multiplied by 2.0
                If k is equal to 0:
                    Let test_point be List.append[test_point, equilibrium[k] plus offset]
                Otherwise if k is equal to 1 and dimension is greater than 1:
                    Let offset2 be radius multiplied by (Float64.from_integer[j] / Float64.from_integer[grid_size minus 1] minus 0.5) multiplied by 2.0
                    Let test_point be List.append[test_point, equilibrium[k] plus offset2]
                Otherwise:
                    Let test_point be List.append[test_point, equilibrium[k]]
            
            Note: Check V(x) is greater than 0 away from equilibrium
            Let distance_from_eq be 0.0
            For k from 0 to dimension minus 1:
                Let diff be test_point[k] minus equilibrium[k]
                Let distance_from_eq be distance_from_eq plus diff multiplied by diff
            Let distance_from_eq be MathOps.square_root[distance_from_eq.to_string[], 15].value.to_float[]
            
            If distance_from_eq is greater than 1e-6:
                Let v_value be lyapunov_function.call[test_point]
                If v_value is less than or equal to 0.0:
                    Return False
            
            Note: Check dV/dt ≤ 0 (simplified using finite differences)
            Let h be 1e-6
            Let v_dot be 0.0
            Let field_value be vector_field.call[test_point]
            
            For k from 0 to dimension minus 1:
                Let test_point_plus be List.copy[test_point]
                Let test_point_plus[k] be test_point_plus[k] plus h
                Let v_plus be lyapunov_function.call[test_point_plus]
                Let v_current be lyapunov_function.call[test_point]
                Let partial_v be (v_plus minus v_current) / h
                Let v_dot be v_dot plus partial_v multiplied by field_value[k]
            
            If v_dot is greater than 1e-6:
                Return False
    
    Return True

Process called "estimate_basin_of_attraction" that takes lyapunov_function as Function, stability_level as Float64, grid_resolution as Integer returns List[List[Float64]]:
    Note: Estimates basin of attraction using Lyapunov function level sets
    Note: Basin contained in region where V(x) is less than c and dV/dt is less than 0
    Note: Provides conservative but rigorous basin estimates
    Note: Useful for control design and safety analysis
    
    Let basin_points be List.empty[List[Float64]][]
    Let search_radius be 3.0
    
    For i from 0 to grid_resolution minus 1:
        For j from 0 to grid_resolution minus 1:
            Let x be search_radius multiplied by (Float64.from_integer[i] / Float64.from_integer[grid_resolution minus 1] minus 0.5) multiplied by 2.0
            Let y be search_radius multiplied by (Float64.from_integer[j] / Float64.from_integer[grid_resolution minus 1] minus 0.5) multiplied by 2.0
            Let point be [x, y]
            
            Let v_value be lyapunov_function.call[point]
            If v_value is less than stability_level and v_value is greater than 0.0:
                Let basin_points be List.append[basin_points, point]
    
    Return basin_points

Note: ===== Hamiltonian Systems =====

Process called "analyze_hamiltonian_system" that takes hamiltonian_function as Function, initial_conditions as List[List[Float64]] returns Dictionary[String, List[Float64]]:
    Note: Analyzes Hamiltonian system: dq/dt is equal to ∂H/∂p, dp/dt is equal to -∂H/∂q
    Note: Energy conservation: H(q(t),p(t)) is equal to constant along trajectories
    Note: Symplectic structure preservation under canonical transformations
    Note: Phase space volume conservation (Liouville's theorem)
    
    Let results be Dictionary.empty[String, List[Float64]]()
    Let energy_values be List.empty[Float64][]
    Let action_values be List.empty[Float64][]
    
    For initial_condition in initial_conditions:
        Let n be List.length[initial_condition]
        Let dof be n / 2  Note: Degrees of freedom
        
        Note: Extract positions and momenta
        Let q be List.empty[Float64][]
        Let p be List.empty[Float64][]
        
        For i from 0 to dof minus 1:
            Let q be List.append[q, initial_condition[i]]
            Let p be List.append[p, initial_condition[i plus dof]]
        
        Note: Compute Hamiltonian value (energy)
        Let full_state be List.empty[Float64][]
        For coord in q:
            Let full_state be List.append[full_state, coord]
        For momentum in p:
            Let full_state be List.append[full_state, momentum]
        
        Let energy be hamiltonian_function.call[full_state]
        Let energy_values be List.append[energy_values, energy]
        
        Note: Compute action integral approximation
        Let action be 0.0
        For i from 0 to dof minus 1:
            Let action be action plus p[i] multiplied by q[i]
        Let action_values be List.append[action_values, action]
    
    Let results be Dictionary.put[results, "energies", energy_values]
    Let results be Dictionary.put[results, "actions", action_values]
    
    Return results

Process called "compute_action_angle_variables" that takes hamiltonian_function as Function, torus_frequency as List[Float64] returns Tuple[Function, Function]:
    Note: Computes action-angle variables for integrable Hamiltonian systems
    Note: Actions I are adiabatic invariants; angles θ evolve linearly
    Note: Canonical transformation to H(I) with frequencies ω is equal to ∂H/∂I
    Note: Foundation for perturbation theory and KAM analysis
    
    Let num_dof be List.length[torus_frequency]
    
    Note: Create action variable function I(q,p)
    Let action_function be Function.new[["state"], """
        Let n be List.length[state] / 2
        Let actions be List.empty[Float64][]
        
        For i from 0 to n minus 1:
            Let q be state[i]
            Let p be state[i plus n]
            Let action be (p multiplied by p plus q multiplied by q) / 2.0  Note: Simplified harmonic oscillator action
            Let actions be List.append[actions, action]
        
        Return actions
    """]
    
    Note: Create angle variable function θ(q,p)
    Let angle_function be Function.new[["state"], """
        Let n be List.length[state] / 2
        Let angles be List.empty[Float64][]
        
        For i from 0 to n minus 1:
            Let q be state[i]
            Let p be state[i plus n]
            Let angle be Trig.arctan2[q, p]  Note: Phase angle for harmonic oscillator
            Let angles be List.append[angles, angle]
        
        Return angles
    """]
    
    Return Tuple.new[action_function, angle_function]

Process called "kam_stability_analysis" that takes hamiltonian_function as Function, perturbation_strength as Float64 returns Dictionary[String, Boolean]:
    Note: Analyzes KAM stability of invariant tori under perturbation
    Note: Diophantine condition: |k·ω| ≥ γ|k|⁻ᵗ for nonresonant frequencies
    Note: Small denominators destroy resonant tori; others persist
    Note: Fundamental result on persistence of quasi-periodic motion
    
    Let results be Dictionary.empty[String, Boolean]()
    
    Note: Test sample frequencies for Diophantine condition
    Let test_frequencies be [[1.0, MathOps.square_root["2", 15].value.to_float[]], [1.0, 1.618], [2.0, 3.0]]
    Let gamma be 0.1
    Let tau be 2.0
    
    For frequency_pair in test_frequencies:
        Let omega1 be frequency_pair[0]
        Let omega2 be frequency_pair[1]
        
        Note: Check Diophantine condition for small integer vectors k
        Let is_diophantine be True
        For k1 from -3 to 3:
            For k2 from -3 to 3:
                If k1 does not equal 0 or k2 does not equal 0:
                    Let k_dot_omega be MathOps.absolute[Float64.from_integer[k1] multiplied by omega1 plus Float64.from_integer[k2] multiplied by omega2]
                    Let k_norm be MathOps.square_root[(Float64.from_integer[k1 multiplied by k1 plus k2 multiplied by k2]).to_string[], 15].value.to_float[]
                    Let threshold be gamma / MathOps.power[k_norm, tau]
                    
                    If k_dot_omega is less than threshold:
                        Let is_diophantine be False
                        Break
            
            If not is_diophantine:
                Break
        
        Note: Torus survives if Diophantine and perturbation is small enough
        Let survives be is_diophantine and perturbation_strength is less than 0.1
        Let freq_key be "torus_" plus omega1.to_string[] plus "_" plus omega2.to_string[]
        Let results be Dictionary.put[results, freq_key, survives]
    
    Let results be Dictionary.put[results, "kam_stable", perturbation_strength is less than 0.05]
    Return results

Note: ===== Center Manifold Theory =====

Process called "compute_center_manifold" that takes vector_field as Function, equilibrium_point as List[Float64], center_eigenspace as List[List[Float64]] returns Function:
    Note: Computes local center manifold for equilibria with zero eigenvalues
    Note: Invariant manifold tangent to center eigenspace at equilibrium
    Note: Reduces dynamics to finite-dimensional center manifold
    Note: Essential for analyzing marginal stability cases
    
    Let dimension be List.length[equilibrium_point]
    Let center_dim be List.length[center_eigenspace]
    
    Note: Create center manifold function (simplified polynomial approximation)
    Let center_manifold_function be Function.new[["center_coords"], """
        Let full_coords be List.copy[equilibrium_point]
        
        Note: Linear part: use center eigenspace
        For i from 0 to center_dim minus 1:
            Let eigenvector be center_eigenspace[i]
            For j from 0 to List.length[eigenvector] minus 1:
                Let full_coords[j] be full_coords[j] plus center_coords[i] multiplied by eigenvector[j]
        
        Note: Add quadratic corrections (simplified)
        If center_dim is greater than 0 and List.length[center_coords] is greater than 0:
            Let quadratic_term be center_coords[0] multiplied by center_coords[0] multiplied by 0.1
            For j from 0 to dimension minus 1:
                Let full_coords[j] be full_coords[j] plus quadratic_term multiplied by 0.01
        
        Return full_coords
    """]
    
    Return center_manifold_function

Process called "reduce_to_center_manifold" that takes vector_field as Function, center_manifold as Function returns Function:
    Note: Reduces full system dynamics to center manifold evolution
    Note: Eliminates stable/unstable directions via center manifold theorem
    Note: Yields low-dimensional system capturing essential dynamics
    Note: Foundation for bifurcation analysis and normal forms
    
    Note: Create reduced vector field on center manifold
    Let reduced_field be Function.new[["center_coords"], """
        Note: Map center coordinates to full space
        Let full_point be center_manifold.call[center_coords]
        
        Note: Evaluate full vector field
        Let full_field_value be vector_field.call[full_point]
        
        Note: Project back to center coordinates (simplified)
        Let reduced_field_value be List.empty[Float64][]
        For i from 0 to List.length[center_coords] minus 1:
            Note: Use first few components as projection (simplified)
            If i is less than List.length[full_field_value]:
                Let reduced_field_value be List.append[reduced_field_value, full_field_value[i]]
            Otherwise:
                Let reduced_field_value be List.append[reduced_field_value, 0.0]
        
        Return reduced_field_value
    """]
    
    Return reduced_field

Note: ===== Discrete Dynamical Systems =====

Process called "analyze_discrete_map" that takes map_function as Function, initial_conditions as List[Float64], iterations as Integer returns List[List[Float64]]:
    Note: Analyzes discrete dynamical system xₙ₊₁ is equal to f(xₙ)
    Note: Computes orbits, fixed points, and periodic cycles
    Note: Studies stability via derivative at fixed points
    Note: Includes maps like logistic, Hénon, standard, and Arnold circle maps
    
    Let orbit be List.empty[List[Float64]][]
    Let x be List.copy[initial_conditions]
    Let orbit be List.append[orbit, List.copy[x]]
    
    Note: Iterate the map
    For iteration from 1 to iterations:
        Let x be map_function.call[x]
        Let orbit be List.append[orbit, List.copy[x]]
    
    Return orbit

Process called "find_fixed_points" that takes map_function as Function, search_bounds as List[Tuple[Float64, Float64]] returns List[List[Float64]]:
    Note: Finds fixed points where f(x*) is equal to x*
    Note: Uses iterative methods and graphical intersections
    Note: Classifies stability via multiplicity and derivative magnitude
    Note: Foundation for understanding discrete system behavior
    
    Let dimension be List.length[search_bounds]
    Let fixed_points be List.empty[List[Float64]][]
    Let tolerance be 1e-8
    
    Note: Create function g(x) is equal to f(x) minus x for root finding
    Let g_function be Function.new[["x"], """
        Let fx be map_function.call[x]
        Let result be List.empty[Float64][]
        For i from 0 to List.length[x] minus 1:
            Let result be List.append[result, fx[i] minus x[i]]
        Return result
    """]
    
    Note: Create Jacobian for Newton's method
    Let jacobian_g be Function.new[["x"], """
        Let h be 1e-8
        Let n be List.length[x]
        Let jac be List.fill[List[Float64]][n, List.fill[Float64][n, 0.0]]
        
        For i from 0 to n minus 1:
            For j from 0 to n minus 1:
                Let x_plus be List.copy[x]
                Let x_minus be List.copy[x]
                Let x_plus[j] be x_plus[j] plus h
                Let x_minus[j] be x_minus[j] minus h
                
                Let g_plus be g_function.call[x_plus]
                Let g_minus be g_function.call[x_minus]
                Let jac[i][j] be (g_plus[i] minus g_minus[i]) / (2.0 multiplied by h)
        
        Return jac
    """]
    
    Note: Grid search for initial guesses
    Let num_guesses_per_dim be 5
    Let total_guesses be MathOps.power[num_guesses_per_dim, dimension]
    
    For guess_index from 0 to total_guesses minus 1:
        Let initial_guess be List.empty[Float64][]
        Let temp_index be guess_index
        
        For dim from 0 to dimension minus 1:
            Let coord_index be temp_index % num_guesses_per_dim
            Let temp_index be temp_index / num_guesses_per_dim
            Let min_bound be search_bounds[dim].0
            Let max_bound be search_bounds[dim].1
            Let coord_value be min_bound plus (max_bound minus min_bound) multiplied by Float64.from_integer[coord_index] / Float64.from_integer[num_guesses_per_dim minus 1]
            Let initial_guess be List.append[initial_guess, coord_value]
        
        Let fixed_point be newton_multidimensional_float64[g_function, jacobian_g, initial_guess, tolerance, 50]
        
        Note: Verify it's actually a fixed point
        Let residual be g_function.call[fixed_point]
        Let norm_residual be 0.0
        For i from 0 to dimension minus 1:
            Let norm_residual be norm_residual plus residual[i] multiplied by residual[i]
        Let norm_residual be MathOps.square_root[norm_residual.to_string[], 15].value.to_float[]
        
        If norm_residual is less than tolerance:
            Let is_new be True
            For existing_fp in fixed_points:
                Let distance be 0.0
                For i from 0 to dimension minus 1:
                    Let diff be fixed_point[i] minus existing_fp[i]
                    Let distance be distance plus diff multiplied by diff
                Let distance be MathOps.square_root[distance.to_string[], 15].value.to_float[]
                
                If distance is less than tolerance multiplied by 10.0:
                    Let is_new be False
                    Break
            
            If is_new:
                Let fixed_points be List.append[fixed_points, fixed_point]
    
    Return fixed_points

Process called "compute_cobweb_diagram" that takes map_function as Function, initial_point as Float64, iterations as Integer returns List[Tuple[Float64, Float64]]:
    Note: Computes cobweb diagram for one-dimensional maps
    Note: Alternates between function graph and diagonal line
    Note: Visualizes convergence, cycles, or chaotic behavior
    Note: Classic tool for understanding discrete dynamics
    
    Let cobweb_points be List.empty[Tuple[Float64, Float64]][]
    Let x be initial_point
    
    Note: Start at (x0, 0)
    Let cobweb_points be List.append[cobweb_points, Tuple.new[x, 0.0]]
    
    For iteration from 0 to iterations minus 1:
        Note: Move vertically to function graph
        Let y be map_function.call[[x]][0]
        Let cobweb_points be List.append[cobweb_points, Tuple.new[x, y]]
        
        Note: Move horizontally to diagonal
        Let cobweb_points be List.append[cobweb_points, Tuple.new[y, y]]
        
        Let x be y
    
    Return cobweb_points

Note: ===== Global Analysis =====

Process called "compute_omega_limit_set" that takes trajectory as List[List[Float64]], tolerance as Float64 returns List[List[Float64]]:
    Note: Computes ω-limit set: accumulation points as t→∞
    Note: Characterizes long-term behavior of individual trajectories
    Note: Can be equilibria, periodic orbits, or strange attractors
    Note: Dual concept: α-limit set for t→-∞
    
    Let traj_length be List.length[trajectory]
    If traj_length is less than 10:
        Return List.empty[List[Float64]][]
    
    Note: Take last portion of trajectory for omega limit set
    Let start_index be traj_length multiplied by 3 / 4
    Let omega_points be List.empty[List[Float64]][]
    
    Note: Sample points from the latter part of trajectory
    For i from start_index to traj_length minus 1:
        Let point be trajectory[i]
        
        Note: Check if this point is already represented
        Let is_new be True
        For existing_point in omega_points:
            Let distance be 0.0
            For j from 0 to List.length[point] minus 1:
                Let diff be point[j] minus existing_point[j]
                Let distance be distance plus diff multiplied by diff
            Let distance be MathOps.square_root[distance.to_string[], 15].value.to_float[]
            
            If distance is less than tolerance:
                Let is_new be False
                Break
        
        If is_new:
            Let omega_points be List.append[omega_points, point]
    
    Return omega_points

Process called "analyze_invariant_sets" that takes vector_field as Function, candidate_set as List[List[Float64]] returns Dictionary[String, Boolean]:
    Note: Analyzes invariant sets: forward and backward invariance
    Note: Tests if φᵗ(S) ⊆ S (forward) and φ⁻ᵗ(S) ⊆ S (backward)
    Note: Includes fixed points, periodic orbits, and attractors
    Note: Foundation for understanding system's geometric structure
    
    Let results be Dictionary.empty[String, Boolean]()
    Let tolerance be 0.1
    Let time_step be 0.1
    
    Note: Test forward invariance
    Let forward_invariant be True
    For point in candidate_set:
        Let evolved_trajectory be integrate_trajectory[vector_field, point, Tuple.new[0.0, time_step], 10]
        Let evolved_point be evolved_trajectory[List.length[evolved_trajectory] minus 1]
        
        Note: Check if evolved point is still in the set
        Let min_distance be 1000.0
        For set_point in candidate_set:
            Let distance be 0.0
            For i from 0 to List.length[point] minus 1:
                Let diff be evolved_point[i] minus set_point[i]
                Let distance be distance plus diff multiplied by diff
            Let distance be MathOps.square_root[distance.to_string[], 15].value.to_float[]
            
            If distance is less than min_distance:
                Let min_distance be distance
        
        If min_distance is greater than tolerance:
            Let forward_invariant be False
            Break
    
    Note: Test backward invariance
    Let backward_invariant be True
    Let reversed_field be Function.new[["x"], """
        Let original_value be vector_field.call[x]
        Let reversed_value be List.empty[Float64][]
        For component in original_value:
            Let reversed_value be List.append[reversed_value, -component]
        Return reversed_value
    """]
    
    For point in candidate_set:
        Let backward_trajectory be integrate_trajectory[reversed_field, point, Tuple.new[0.0, time_step], 10]
        Let backward_point be backward_trajectory[List.length[backward_trajectory] minus 1]
        
        Let min_distance be 1000.0
        For set_point in candidate_set:
            Let distance be 0.0
            For i from 0 to List.length[point] minus 1:
                Let diff be backward_point[i] minus set_point[i]
                Let distance be distance plus diff multiplied by diff
            Let distance be MathOps.square_root[distance.to_string[], 15].value.to_float[]
            
            If distance is less than min_distance:
                Let min_distance be distance
        
        If min_distance is greater than tolerance:
            Let backward_invariant be False
            Break
    
    Let results be Dictionary.put[results, "forward_invariant", forward_invariant]
    Let results be Dictionary.put[results, "backward_invariant", backward_invariant]
    Let results be Dictionary.put[results, "invariant", forward_invariant and backward_invariant]
    
    Return results

Process called "structural_stability_analysis" that takes vector_field as Function, perturbation_magnitude as Float64 returns Boolean:
    Note: Tests structural stability under small perturbations
    Note: Morse-Smale systems: hyperbolic equilibria and transverse intersections
    Note: Generic properties: typical behavior in function space
    Note: Important for robustness of dynamical conclusions
    
    Note: Find equilibria in original system
    Let search_bounds be [Tuple.new[-2.0, 2.0], Tuple.new[-2.0, 2.0]]
    Let original_equilibria be find_equilibrium_points[vector_field, search_bounds, 1e-8]
    
    Note: Create perturbed vector field
    Let perturbed_field be Function.new[["x"], """
        Let original_value be vector_field.call[x]
        Let perturbed_value be List.empty[Float64][]
        
        For i from 0 to List.length[original_value] minus 1:
            Let perturbation be perturbation_magnitude multiplied by (0.5 minus MathOps.random[])
            Let perturbed_value be List.append[perturbed_value, original_value[i] plus perturbation]
        
        Return perturbed_value
    """]
    
    Note: Find equilibria in perturbed system
    Let perturbed_equilibria be find_equilibrium_points[perturbed_field, search_bounds, 1e-8]
    
    Note: Check if number of equilibria is preserved
    If List.length[original_equilibria] does not equal List.length[perturbed_equilibria]:
        Return False
    
    Note: Check if each equilibrium persists under perturbation
    For orig_eq in original_equilibria:
        Let found_nearby be False
        
        For pert_eq in perturbed_equilibria:
            Let distance be 0.0
            For i from 0 to List.length[orig_eq] minus 1:
                Let diff be orig_eq[i] minus pert_eq[i]
                Let distance be distance plus diff multiplied by diff
            Let distance be MathOps.square_root[distance.to_string[], 15].value.to_float[]
            
            If distance is less than perturbation_magnitude multiplied by 10.0:
                Let found_nearby be True
                Break
        
        If not found_nearby:
            Return False
    
    Note: System appears structurally stable
    Return True