Note:
math/symbolic/series.runa
Symbolic Series Analysis and Manipulation System

This module provides comprehensive symbolic series operations including:
- Power series expansion and manipulation
- Taylor series with arbitrary expansion points
- Laurent series for functions with poles
- Fourier series for periodic functions
- Generating functions and combinatorial series
- Asymptotic series and expansions
- Series convergence testing and analysis
- Series arithmetic (addition, multiplication, composition)
- Series reversion and inversion techniques
- Padé approximants and rational interpolation
- Continued fraction representations
- q-series and basic hypergeometric functions
- Formal power series ring operations
- Series truncation and error analysis
- Multi-variable series expansions
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/symbolic/core" as SymbolicCore
Import module "math/symbolic/calculus" as SymbolicCalculus
Import module "math/symbolic/algebra" as SymbolicAlgebra
Import module "math/analysis/real" as RealAnalysis
Import module "text/string/manipulation" as StringOps
Import module "text/string/core" as StringCore
Import module "data/collections/core/list" as ListOps
Import module "data/collections/core/map" as MapOps

Note: =====================================================================
Note: SERIES DATA STRUCTURES
Note: =====================================================================

Type called "PowerSeries":
    coefficients as Dictionary[String, String]
    variable as String
    expansion_point as String
    series_order as Integer
    radius_of_convergence as String
    series_type as String
    truncation_error as String

Type called "FourierSeries":
    cosine_coefficients as Dictionary[String, String]
    sine_coefficients as Dictionary[String, String]
    dc_component as String
    period as String
    convergence_type as String
    partial_sum_order as Integer

Type called "GeneratingFunction":
    function_expression as String
    sequence_type as String
    generating_variable as String
    sequence_coefficients as Dictionary[String, String]
    exponential_type as Boolean
    ordinary_type as Boolean

Type called "AsymptoticSeries":
    leading_terms as Dictionary[String, String]
    asymptotic_scale as List[String]
    expansion_point as String
    error_bounds as Dictionary[String, String]
    validity_region as Dictionary[String, String]

Type called "ContinuedFraction":
    partial_quotients as List[String]
    convergents as List[Dictionary[String, String]]
    fraction_type as String
    simple_form as Boolean
    periodic_part as List[String]

Note: =====================================================================
Note: POWER SERIES OPERATIONS
Note: =====================================================================

Process called "create_power_series" that takes coefficients as Dictionary[String, String], variable as String, expansion_point as String returns PowerSeries:
    Note: Create power series from coefficient dictionary
    
    Note: Determine series order from coefficients
    Let max_order be 0
    For each key in MapOps.keys(coefficients):
        Let power be parse_integer(key)
        If power is greater than max_order:
            Set max_order to power
    
    Note: Calculate basic radius of convergence (default to infinity for polynomials)
    Let radius be "infinity"
    Let series_type be "power"
    If MapOps.size(coefficients) is greater than 0:
        Set series_type to "polynomial" 
    
    Return PowerSeries with:
        coefficients is equal to coefficients
        variable is equal to variable
        expansion_point is equal to expansion_point
        series_order is equal to max_order
        radius_of_convergence is equal to radius
        series_type is equal to series_type
        truncation_error is equal to "O(" plus variable plus "^" plus Integer.to_string(max_order plus 1) plus ")"

Process called "taylor_series_expansion" that takes function as String, variable as String, expansion_point as String, order as Integer returns PowerSeries:
    Note: Compute Taylor series expansion around specified point
    
    Note: Parse the function expression
    Let expr be SymbolicCore.parse_expression(function, MapOps.empty())
    
    Note: Build coefficient dictionary for Taylor series
    Let coeffs be MapOps.empty()
    Let current_expr be expr
    
    Note: Compute derivatives and evaluate at expansion point
    For n from 0 to order:
        Note: Compute symbolic nth derivative coefficient
        Let derivative_coeff be compute_taylor_derivative_coefficient(function, variable, n, expansion_point)
        Let factorial_n be compute_factorial_string(n)
        
        Note: Taylor coefficient is f^(n)(a)/n!
        Let coefficient be divide_series_coefficients(derivative_coeff, factorial_n)
        MapOps.set(coeffs, Integer.to_string(n), coefficient)
        
        Note: Would differentiate here if calculus was implemented
        If n is less than order:
            Set current_expr to expr  Note: Placeholder until differentiation works
    
    Return PowerSeries with:
        coefficients is equal to coeffs
        variable is equal to variable
        expansion_point is equal to expansion_point
        series_order is equal to order
        radius_of_convergence is equal to "unknown"
        series_type is equal to "taylor"
        truncation_error is equal to "O((" plus variable plus "-" plus expansion_point plus ")^" plus Integer.to_string(order plus 1) plus ")"

Process called "maclaurin_series_expansion" that takes function as String, variable as String, order as Integer returns PowerSeries:
    Note: Compute Maclaurin series (Taylor series at origin)
    
    Note: Handle common functions with known Maclaurin series
    Let coeffs be MapOps.empty()
    
    If function is equal to "exp(" plus variable plus ")" or function is equal to "e^" plus variable:
        Note: e^x is equal to 1 plus x plus x^2/2! plus x^3/3! plus ...
        For n from 0 to order:
            Let factorial_n be compute_factorial_string(n)
            MapOps.set(coeffs, Integer.to_string(n), "1/" plus factorial_n)
        
        Return PowerSeries with:
            coefficients is equal to coeffs
            variable is equal to variable
            expansion_point is equal to "0"
            series_order is equal to order
            radius_of_convergence is equal to "infinity"
            series_type is equal to "exponential"
            truncation_error is equal to "O(" plus variable plus "^" plus Integer.to_string(order plus 1) plus ")"
    
    Otherwise if function is equal to "sin(" plus variable plus ")":
        Note: sin(x) is equal to x minus x^3/3! plus x^5/5! minus ...
        For n from 0 to order:
            If n % 2 is equal to 1:  Note: Odd powers only
                Let sign be "+"
                If ((n minus 1) / 2) % 2 is equal to 1:
                    Set sign to "-"
                Let factorial_n be compute_factorial_string(n)
                MapOps.set(coeffs, Integer.to_string(n), sign plus "1/" plus factorial_n)
            Otherwise:
                MapOps.set(coeffs, Integer.to_string(n), "0")
        
        Return PowerSeries with:
            coefficients is equal to coeffs
            variable is equal to variable
            expansion_point is equal to "0"
            series_order is equal to order
            radius_of_convergence is equal to "infinity"
            series_type is equal to "trigonometric"
            truncation_error is equal to "O(" plus variable plus "^" plus Integer.to_string(order plus 1) plus ")"
    
    Otherwise if function is equal to "cos(" plus variable plus ")":
        Note: cos(x) is equal to 1 minus x^2/2! plus x^4/4! minus ...
        For n from 0 to order:
            If n % 2 is equal to 0:  Note: Even powers only
                Let sign be "+"
                If (n / 2) % 2 is equal to 1:
                    Set sign to "-"
                Let factorial_n be compute_factorial_string(n)
                MapOps.set(coeffs, Integer.to_string(n), sign plus "1/" plus factorial_n)
            Otherwise:
                MapOps.set(coeffs, Integer.to_string(n), "0")
        
        Return PowerSeries with:
            coefficients is equal to coeffs
            variable is equal to variable
            expansion_point is equal to "0"
            series_order is equal to order
            radius_of_convergence is equal to "infinity"
            series_type is equal to "trigonometric"
            truncation_error is equal to "O(" plus variable plus "^" plus Integer.to_string(order plus 1) plus ")"
    
    Otherwise if function is equal to "ln(1+" plus variable plus ")" or function is equal to "log(1+" plus variable plus ")":
        Note: ln(1+x) is equal to x minus x^2/2 plus x^3/3 minus x^4/4 plus ...
        For n from 0 to order:
            If n is equal to 0:
                MapOps.set(coeffs, "0", "0")
            Otherwise:
                Let sign be "+"
                If n % 2 is equal to 0:
                    Set sign to "-"
                MapOps.set(coeffs, Integer.to_string(n), sign plus "1/" plus Integer.to_string(n))
        
        Return PowerSeries with:
            coefficients is equal to coeffs
            variable is equal to variable
            expansion_point is equal to "0"
            series_order is equal to order
            radius_of_convergence is equal to "1"
            series_type is equal to "logarithmic"
            truncation_error is equal to "O(" plus variable plus "^" plus Integer.to_string(order plus 1) plus ")"
    
    Otherwise:
        Note: Fall back to general Taylor series at origin
        Return taylor_series_expansion(function, variable, "0", order)

Process called "binomial_series_expansion" that takes exponent as String, variable as String, order as Integer returns PowerSeries:
    Note: Expand (1+x)^α using binomial series
    Note: (1+x)^α is equal to Σ(α choose n) multiplied by x^n where (α choose n) is equal to α*(α-1)*...*(α-n+1)/n!
    
    Let coeffs be MapOps.empty()
    
    Note: Compute binomial coefficients
    For n from 0 to order:
        Let binomial_coeff be "1"
        
        If n is equal to 0:
            Set binomial_coeff to "1"
        Otherwise:
            Note: Compute (α choose n) is equal to α*(α-1)*...*(α-n+1)/n!
            Let numerator be exponent
            For k from 1 to n minus 1:
                Set numerator to numerator plus "*(" plus exponent plus "-" plus Integer.to_string(k) plus ")"
            
            Let factorial_n be compute_factorial_string(n)
            Set binomial_coeff to "(" plus numerator plus ")/" plus factorial_n
        
        MapOps.set(coeffs, Integer.to_string(n), binomial_coeff)
    
    Note: Determine convergence radius
    Let radius be "1"
    If exponent is equal to "0":
        Set radius to "infinity"
    
    Return PowerSeries with:
        coefficients is equal to coeffs
        variable is equal to variable
        expansion_point is equal to "0"
        series_order is equal to order
        radius_of_convergence is equal to radius
        series_type is equal to "binomial"
        truncation_error is equal to "O(" plus variable plus "^" plus Integer.to_string(order plus 1) plus ")"

Process called "geometric_series_expansion" that takes ratio as String, variable as String, order as Integer returns PowerSeries:
    Note: Expand geometric series 1/(1-r) is equal to 1 plus r plus r^2 plus r^3 plus ...
    
    Let coeffs be MapOps.empty()
    
    Note: All coefficients are powers of the ratio
    For n from 0 to order:
        If n is equal to 0:
            MapOps.set(coeffs, "0", "1")
        Otherwise if n is equal to 1:
            MapOps.set(coeffs, "1", ratio)
        Otherwise:
            Note: For higher powers, build ratio^n
            Let power_term be ratio
            For k from 2 to n:
                Set power_term to "(" plus power_term plus ")*" plus ratio
            MapOps.set(coeffs, Integer.to_string(n), power_term)
    
    Note: Convergence radius is 1/|ratio|
    Let radius be "1"
    If ratio is equal to "1":
        Set radius to "1"
    Otherwise:
        Set radius to "1/|" plus ratio plus "|"
    
    Return PowerSeries with:
        coefficients is equal to coeffs
        variable is equal to variable
        expansion_point is equal to "0"
        series_order is equal to order
        radius_of_convergence is equal to radius
        series_type is equal to "geometric"
        truncation_error is equal to "O(" plus variable plus "^" plus Integer.to_string(order plus 1) plus ")"

Process called "exponential_series_expansion" that takes argument as String, order as Integer returns PowerSeries:
    Note: Expand e^x is equal to 1 plus x plus x^2/2! plus x^3/3! plus ...
    
    Let coeffs be MapOps.empty()
    
    Note: Exponential series coefficients are 1/n!
    For n from 0 to order:
        Let factorial_n be compute_factorial_string(n)
        MapOps.set(coeffs, Integer.to_string(n), "1/" plus factorial_n)
    
    Note: Extract variable from argument (e.g., "2x" -> variable="x", coefficient handled in expansion)
    Let variable be "x"
    Let coefficient_multiplier be "1"
    
    Note: Handle cases like e^(ax) where a is a coefficient
    If argument does not equal variable:
        Note: Parse coefficient from compound argument
        Let parsed_arg be parse_compound_argument(argument, variable)
        Set variable to parsed_arg.variable
        Note: Apply chain rule scaling to coefficients
        Let scaling_factor be parsed_arg.coefficient
        
        Note: Scale all coefficients by the chain rule factor
        For n from 0 to order:
            Let n_key be Integer.to_string(n)
            If MapOps.contains_key(coeffs, n_key):
                Let original_coeff be MapOps.get(coeffs, n_key)
                Let scaled_power be power_string(scaling_factor, n)
                Let scaled_coeff be multiply_series_coefficients(original_coeff, scaled_power)
                MapOps.set(coeffs, n_key, scaled_coeff)
    
    Return PowerSeries with:
        coefficients is equal to coeffs
        variable is equal to variable
        expansion_point is equal to "0"
        series_order is equal to order
        radius_of_convergence is equal to "infinity"
        series_type is equal to "exponential"
        truncation_error is equal to "O(" plus variable plus "^" plus Integer.to_string(order plus 1) plus ")"

Process called "logarithmic_series_expansion" that takes argument as String, order as Integer returns PowerSeries:
    Note: Expand ln(1+x) is equal to x minus x^2/2 plus x^3/3 minus x^4/4 plus ...
    
    Let coeffs be MapOps.empty()
    
    Note: Logarithmic series alternates signs with coefficients 1/n
    For n from 0 to order:
        If n is equal to 0:
            MapOps.set(coeffs, "0", "0")  Note: ln(1+x) has no constant term
        Otherwise:
            Let sign be "+"
            If n % 2 is equal to 0:  Note: Even powers are negative
                Set sign to "-"
            
            Let coefficient be sign plus "1/" plus Integer.to_string(n)
            MapOps.set(coeffs, Integer.to_string(n), coefficient)
    
    Note: Extract variable from argument
    Let variable be "x"
    If argument does not equal "1+x":
        Note: Handle other forms like ln(1+2x)
        Set variable to argument
    
    Return PowerSeries with:
        coefficients is equal to coeffs
        variable is equal to variable
        expansion_point is equal to "0"
        series_order is equal to order
        radius_of_convergence is equal to "1"
        series_type is equal to "logarithmic"
        truncation_error is equal to "O(" plus variable plus "^" plus Integer.to_string(order plus 1) plus ")")

Note: =====================================================================
Note: LAURENT SERIES OPERATIONS
Note: =====================================================================

Process called "laurent_series_expansion" that takes function as String, variable as String, expansion_point as String, positive_order as Integer, negative_order as Integer returns PowerSeries:
    Note: Compute Laurent series expansion including negative powers
    Note: Laurent series: f(z) is equal to Σ(n=-∞ to ∞) a_n multiplied by (z-a)^n
    
    Let coeffs be MapOps.empty()
    
    Note: Handle common functions with known Laurent expansions
    If function is equal to "1/" plus variable or function is equal to "1/(" plus variable plus "-" plus expansion_point plus ")":
        Note: 1/(z-a) has coefficient 1 for power -1
        MapOps.set(coeffs, "-1", "1")
    
    Otherwise if function is equal to "1/(" plus variable plus "-" plus expansion_point plus ")^2":
        Note: 1/(z-a)^2 has coefficient 1 for power -2
        MapOps.set(coeffs, "-2", "1")
    
    Otherwise:
        Note: General Laurent series minus compute both negative and positive coefficients
        Note: For negative powers (principal part)
        For n from 1 to negative_order:
            Let negative_power_key be "-" plus Integer.to_string(n)
            Note: This would require residue calculation or complex analysis
            Let residue_coeff be "a_{-" plus Integer.to_string(n) plus "}"
            MapOps.set(coeffs, negative_power_key, residue_coeff)
        
        Note: For non-negative powers (regular part)
        For n from 0 to positive_order:
            Let power_key be Integer.to_string(n)
            Note: Use Taylor series expansion for regular part
            Let taylor_coeff be "f^(" plus Integer.to_string(n) plus ")(" plus expansion_point plus ")/" plus compute_factorial_string(n)
            MapOps.set(coeffs, power_key, taylor_coeff)
    
    Return PowerSeries with:
        coefficients is equal to coeffs
        variable is equal to variable
        expansion_point is equal to expansion_point
        series_order is equal to positive_order
        radius_of_convergence is equal to "unknown"
        series_type is equal to "laurent"
        truncation_error is equal to "O((" plus variable plus "-" plus expansion_point plus ")^" plus Integer.to_string(positive_order plus 1) plus ")"

Process called "principal_part_extraction" that takes laurent_series as PowerSeries returns PowerSeries:
    Note: Extract principal part (negative powers) from Laurent series
    
    Let principal_coeffs be MapOps.empty()
    
    Note: Copy all coefficients with negative powers
    For each power_key in MapOps.keys(laurent_series.coefficients):
        Let power_value be parse_integer(power_key)
        If power_value is less than 0:
            Let coeff be MapOps.get(laurent_series.coefficients, power_key)
            MapOps.set(principal_coeffs, power_key, coeff)
    
    Note: Find the most negative power for series order
    Let min_power be 0
    For each power_key in MapOps.keys(principal_coeffs):
        Let power_value be parse_integer(power_key)
        If power_value is less than min_power:
            Set min_power to power_value
    
    Return PowerSeries with:
        coefficients is equal to principal_coeffs
        variable is equal to laurent_series.variable
        expansion_point is equal to laurent_series.expansion_point
        series_order is equal to -min_power  Note: Order is magnitude of most negative power
        radius_of_convergence is equal to laurent_series.radius_of_convergence
        series_type is equal to "principal_part"
        truncation_error is equal to ""

Process called "regular_part_extraction" that takes laurent_series as PowerSeries returns PowerSeries:
    Note: Extract regular part (non-negative powers) from Laurent series
    
    Let regular_coeffs be MapOps.empty()
    
    Note: Copy all coefficients with non-negative powers
    Let max_power be 0
    For each power_key in MapOps.keys(laurent_series.coefficients):
        Let power_value be parse_integer(power_key)
        If power_value is greater than or equal to 0:
            Let coeff be MapOps.get(laurent_series.coefficients, power_key)
            MapOps.set(regular_coeffs, power_key, coeff)
            If power_value is greater than max_power:
                Set max_power to power_value
    
    Return PowerSeries with:
        coefficients is equal to regular_coeffs
        variable is equal to laurent_series.variable
        expansion_point is equal to laurent_series.expansion_point
        series_order is equal to max_power
        radius_of_convergence is equal to laurent_series.radius_of_convergence
        series_type is equal to "regular_part"
        truncation_error is equal to "O((" plus laurent_series.variable plus "-" plus laurent_series.expansion_point plus ")^" plus Integer.to_string(max_power plus 1) plus ")"

Process called "residue_from_laurent" that takes laurent_series as PowerSeries returns String:
    Note: Extract residue (coefficient of 1/(z-a)) from Laurent series
    Note: The residue is the coefficient of the -1 power term
    
    If MapOps.contains_key(laurent_series.coefficients, "-1"):
        Return MapOps.get(laurent_series.coefficients, "-1")
    Otherwise:
        Return "0"

Note: =====================================================================
Note: FOURIER SERIES OPERATIONS
Note: =====================================================================

Process called "fourier_series_expansion" that takes function as String, variable as String, period as String, harmonics as Integer returns FourierSeries:
    Note: Compute Fourier series expansion of periodic function
    Note: f(x) is equal to a_0/2 plus Σ(a_n*cos(nωx) plus b_n*sin(nωx)) where ω is equal to 2π/T
    
    Let cosine_coeffs be MapOps.empty()
    Let sine_coeffs be MapOps.empty()
    Let dc_component be "0"
    
    Note: Compute fundamental frequency
    Let omega be "2*π/" plus period
    
    Note: Handle common periodic functions
    If function is equal to "square_wave" or function is equal to "step":
        Note: Square wave Fourier series
        Set dc_component to "0"
        For n from 1 to harmonics:
            If n % 2 is equal to 1:  Note: Odd harmonics only
                Let amplitude be "4/(π*" plus Integer.to_string(n) plus ")"
                MapOps.set(sine_coeffs, Integer.to_string(n), amplitude)
            Otherwise:
                MapOps.set(sine_coeffs, Integer.to_string(n), "0")
            MapOps.set(cosine_coeffs, Integer.to_string(n), "0")
    
    Otherwise if function is equal to "sawtooth":
        Note: Sawtooth wave Fourier series
        Set dc_component to "0"
        For n from 1 to harmonics:
            Let amplitude be "2*(-1)^(" plus Integer.to_string(n plus 1) plus ")/(π*" plus Integer.to_string(n) plus ")"
            MapOps.set(sine_coeffs, Integer.to_string(n), amplitude)
            MapOps.set(cosine_coeffs, Integer.to_string(n), "0")
    
    Otherwise if function is equal to "triangle":
        Note: Triangle wave Fourier series
        Set dc_component to "0"
        For n from 1 to harmonics:
            If n % 2 is equal to 1:  Note: Odd harmonics only
                Let amplitude be "8*(-1)^((" plus Integer.to_string(n) plus "-1)/2)/(π^2*" plus Integer.to_string(n) plus "^2)"
                MapOps.set(cosine_coeffs, Integer.to_string(n), amplitude)
            Otherwise:
                MapOps.set(cosine_coeffs, Integer.to_string(n), "0")
            MapOps.set(sine_coeffs, Integer.to_string(n), "0")
    
    Otherwise:
        Note: General periodic function minus use integration formulas
        Set dc_component to "(1/" plus period plus ")*∫[0," plus period plus "]" plus function plus "d" plus variable
        For n from 1 to harmonics:
            Let cosine_coeff be "(2/" plus period plus ")*∫[0," plus period plus "]" plus function plus "*cos(" plus Integer.to_string(n) plus "*" plus omega plus "*" plus variable plus ")d" plus variable
            Let sine_coeff be "(2/" plus period plus ")*∫[0," plus period plus "]" plus function plus "*sin(" plus Integer.to_string(n) plus "*" plus omega plus "*" plus variable plus ")d" plus variable
            MapOps.set(cosine_coeffs, Integer.to_string(n), cosine_coeff)
            MapOps.set(sine_coeffs, Integer.to_string(n), sine_coeff)
    
    Return FourierSeries with:
        cosine_coefficients is equal to cosine_coeffs
        sine_coefficients is equal to sine_coeffs
        dc_component is equal to dc_component
        period is equal to period
        convergence_type is equal to "pointwise"
        partial_sum_order is equal to harmonics

Process called "fourier_cosine_series" that takes even_function as String, variable as String, period as String, terms as Integer returns FourierSeries:
    Note: Compute Fourier cosine series for even functions
    Note: For even functions: f(x) is equal to a_0/2 plus Σ(a_n*cos(nπx/L)) where L is equal to period/2
    
    Let cosine_coeffs be MapOps.empty()
    Let sine_coeffs be MapOps.empty()
    Let dc_component be "0"
    
    Note: For even functions, all sine coefficients are zero
    For n from 1 to terms:
        MapOps.set(sine_coeffs, Integer.to_string(n), "0")
    
    Note: Handle common even functions
    If even_function is equal to "cos(" plus variable plus ")":
        Set dc_component to "0"
        MapOps.set(cosine_coeffs, "1", "1")
        For n from 2 to terms:
            MapOps.set(cosine_coeffs, Integer.to_string(n), "0")
    
    Otherwise if even_function is equal to "" plus variable plus "^2":
        Note: Parabola on [-L,L]
        Let L be period plus "/2"
        Set dc_component to "(" plus L plus ")^2/3"
        For n from 1 to terms:
            Let coeff be "4*(" plus L plus ")^2*(-1)^" plus Integer.to_string(n) plus "/(π^2*" plus Integer.to_string(n) plus "^2)"
            MapOps.set(cosine_coeffs, Integer.to_string(n), coeff)
    
    Otherwise:
        Note: General even function
        Let L be period plus "/2"
        Set dc_component to "(1/" plus L plus ")*∫[0," plus L plus "]" plus even_function plus "d" plus variable
        For n from 1 to terms:
            Let cosine_coeff be "(2/" plus L plus ")*∫[0," plus L plus "]" plus even_function plus "*cos(" plus Integer.to_string(n) plus "*π*" plus variable plus "/" plus L plus ")d" plus variable
            MapOps.set(cosine_coeffs, Integer.to_string(n), cosine_coeff)
    
    Return FourierSeries with:
        cosine_coefficients is equal to cosine_coeffs
        sine_coefficients is equal to sine_coeffs
        dc_component is equal to dc_component
        period is equal to period
        convergence_type is equal to "uniform"
        partial_sum_order is equal to terms

Process called "fourier_sine_series" that takes odd_function as String, variable as String, period as String, terms as Integer returns FourierSeries:
    Note: Compute Fourier sine series for odd functions
    Note: For odd functions: f(x) is equal to Σ(b_n*sin(nπx/L)) where L is equal to period/2
    
    Let cosine_coeffs be MapOps.empty()
    Let sine_coeffs be MapOps.empty()
    Let dc_component be "0"  Note: DC component is always 0 for odd functions
    
    Note: For odd functions, all cosine coefficients are zero
    For n from 1 to terms:
        MapOps.set(cosine_coeffs, Integer.to_string(n), "0")
    
    Note: Handle common odd functions
    If odd_function is equal to "sin(" plus variable plus ")":
        MapOps.set(sine_coeffs, "1", "1")
        For n from 2 to terms:
            MapOps.set(sine_coeffs, Integer.to_string(n), "0")
    
    Otherwise if odd_function is equal to variable:
        Note: Linear function f(x) is equal to x on [-L,L]
        Let L be period plus "/2"
        For n from 1 to terms:
            Let coeff be "2*" plus L plus "*(-1)^(" plus Integer.to_string(n plus 1) plus ")/(π*" plus Integer.to_string(n) plus ")"
            MapOps.set(sine_coeffs, Integer.to_string(n), coeff)
    
    Otherwise if odd_function is equal to variable plus "^3":
        Note: Cubic function f(x) is equal to x^3 on [-L,L]
        Let L be period plus "/2"
        For n from 1 to terms:
            Let coeff be "2*(" plus L plus ")^3*(-1)^(" plus Integer.to_string(n plus 1) plus ")*[π^2*" plus Integer.to_string(n) plus "^2 minus 6]/(π^3*" plus Integer.to_string(n) plus "^3)"
            MapOps.set(sine_coeffs, Integer.to_string(n), coeff)
    
    Otherwise:
        Note: General odd function
        Let L be period plus "/2"
        For n from 1 to terms:
            Let sine_coeff be "(2/" plus L plus ")*∫[0," plus L plus "]" plus odd_function plus "*sin(" plus Integer.to_string(n) plus "*π*" plus variable plus "/" plus L plus ")d" plus variable
            MapOps.set(sine_coeffs, Integer.to_string(n), sine_coeff)
    
    Return FourierSeries with:
        cosine_coefficients is equal to cosine_coeffs
        sine_coefficients is equal to sine_coeffs
        dc_component is equal to dc_component
        period is equal to period
        convergence_type is equal to "uniform"
        partial_sum_order is equal to terms

Process called "complex_fourier_series" that takes function as String, variable as String, period as String, terms as Integer returns Dictionary[String, String]:
    Note: Compute complex Fourier series representation
    Note: f(x) is equal to Σ(c_n multiplied by e^(i*n*ω*x)) where ω is equal to 2π/T and c_n is equal to (1/T)*∫f(x)*e^(-i*n*ω*x)dx
    
    Let complex_coeffs be MapOps.empty()
    Let omega be "2*π/" plus period
    
    Note: Handle common functions
    If function is equal to "1":
        Note: Constant function
        MapOps.set(complex_coeffs, "0", "1")
        For n from 1 to terms:
            MapOps.set(complex_coeffs, Integer.to_string(n), "0")
            MapOps.set(complex_coeffs, "-" plus Integer.to_string(n), "0")
    
    Otherwise if function is equal to "cos(" plus variable plus ")":
        Note: Cosine function: cos(x) is equal to (e^(ix) plus e^(-ix))/2
        MapOps.set(complex_coeffs, "0", "0")
        MapOps.set(complex_coeffs, "1", "1/2")
        MapOps.set(complex_coeffs, "-1", "1/2")
        For n from 2 to terms:
            MapOps.set(complex_coeffs, Integer.to_string(n), "0")
            MapOps.set(complex_coeffs, "-" plus Integer.to_string(n), "0")
    
    Otherwise if function is equal to "sin(" plus variable plus ")":
        Note: Sine function: sin(x) is equal to (e^(ix) minus e^(-ix))/(2i)
        MapOps.set(complex_coeffs, "0", "0")
        MapOps.set(complex_coeffs, "1", "1/(2i)")
        MapOps.set(complex_coeffs, "-1", "-1/(2i)")
        For n from 2 to terms:
            MapOps.set(complex_coeffs, Integer.to_string(n), "0")
            MapOps.set(complex_coeffs, "-" plus Integer.to_string(n), "0")
    
    Otherwise:
        Note: General function minus compute complex coefficients
        For n from -terms to terms:
            Let n_str be Integer.to_string(n)
            Let complex_coeff be "(1/" plus period plus ")*∫[0," plus period plus "]" plus function plus "*exp(-i*" plus n_str plus "*" plus omega plus "*" plus variable plus ")d" plus variable
            MapOps.set(complex_coeffs, n_str, complex_coeff)
    
    Return complex_coeffs

Process called "gibbs_phenomenon_analysis" that takes fourier_series as FourierSeries, discontinuity_points as List[String] returns Dictionary[String, String]:
    Note: Analyze Gibbs phenomenon at discontinuity points
    Note: The Gibbs phenomenon causes ~9% overshoot at jump discontinuities
    
    Let analysis_results be MapOps.empty()
    
    Note: Gibbs constant ≈ 1.178979744
    Let gibbs_constant be "1.178979744"
    MapOps.set(analysis_results, "gibbs_constant", gibbs_constant)
    
    Note: Maximum overshoot percentage
    Let max_overshoot_percent be "8.94894"  Note: (π minus 2)/π multiplied by 100%
    MapOps.set(analysis_results, "max_overshoot_percent", max_overshoot_percent)
    
    Note: Analyze each discontinuity point
    For i from 0 to ListOps.length(discontinuity_points) minus 1:
        Let point be ListOps.get(discontinuity_points, i)
        Let point_key be "discontinuity_" plus Integer.to_string(i)
        
        Note: Estimate jump magnitude by examining Fourier coefficients
        Let jump_estimate be estimate_jump_magnitude(fourier_series, point)
        
        Note: Gibbs overshoot at this point
        Let overshoot be multiply_series_coefficients(gibbs_constant, jump_estimate)
        
        Note: Store analysis for this point
        MapOps.set(analysis_results, point_key plus "_location", point)
        MapOps.set(analysis_results, point_key plus "_jump_magnitude", jump_estimate)
        MapOps.set(analysis_results, point_key plus "_gibbs_overshoot", overshoot)
        MapOps.set(analysis_results, point_key plus "_convergence_type", "non_uniform")
    
    Note: General analysis
    MapOps.set(analysis_results, "total_discontinuities", Integer.to_string(ListOps.length(discontinuity_points)))
    MapOps.set(analysis_results, "convergence_mode", "pointwise_except_at_jumps")
    MapOps.set(analysis_results, "gibbs_effect_present", "true")
    
    Return analysis_results

Note: =====================================================================
Note: GENERATING FUNCTION OPERATIONS
Note: =====================================================================

Process called "ordinary_generating_function" that takes sequence as List[String], variable as String returns GeneratingFunction:
    Note: Create ordinary generating function from sequence
    Note: G(x) is equal to Σ(a_n multiplied by x^n) for sequence {a_n}
    
    Let function_expr be ""
    Let sequence_coeffs be MapOps.empty()
    
    Note: Build the generating function expression
    For i from 0 to ListOps.length(sequence) minus 1:
        Let coeff be ListOps.get(sequence, i)
        Let term be ""
        
        If i is equal to 0:
            Set term to coeff
        Otherwise if i is equal to 1:
            If coeff is equal to "1":
                Set term to variable
            Otherwise if coeff is equal to "-1":
                Set term to "-" plus variable
            Otherwise:
                Set term to coeff plus "*" plus variable
        Otherwise:
            If coeff is equal to "1":
                Set term to variable plus "^" plus Integer.to_string(i)
            Otherwise if coeff is equal to "-1":
                Set term to "-" plus variable plus "^" plus Integer.to_string(i)
            Otherwise:
                Set term to coeff plus "*" plus variable plus "^" plus Integer.to_string(i)
        
        Note: Add term to expression
        If function_expr is equal to "":
            Set function_expr to term
        Otherwise:
            If StringOps.starts_with(term, "-"):
                Set function_expr to function_expr plus " " plus term
            Otherwise:
                Set function_expr to function_expr plus " plus " plus term
        
        Note: Store coefficient
        MapOps.set(sequence_coeffs, Integer.to_string(i), coeff)
    
    Return GeneratingFunction with:
        function_expression is equal to function_expr
        sequence_type is equal to "ordinary"
        generating_variable is equal to variable
        sequence_coefficients is equal to sequence_coeffs
        exponential_type is equal to false
        ordinary_type is equal to true

Process called "exponential_generating_function" that takes sequence as List[String], variable as String returns GeneratingFunction:
    Note: Create exponential generating function from sequence
    Note: EGF(x) is equal to Σ(a_n multiplied by x^n / n!) for sequence {a_n}
    
    Let function_expr be ""
    Let sequence_coeffs be MapOps.empty()
    
    Note: Build the exponential generating function expression
    For i from 0 to ListOps.length(sequence) minus 1:
        Let coeff be ListOps.get(sequence, i)
        Let factorial_i be compute_factorial_string(i)
        Let term be ""
        
        If i is equal to 0:
            Set term to coeff
        Otherwise if i is equal to 1:
            Set term to coeff plus "*" plus variable
        Otherwise:
            Set term to coeff plus "*" plus variable plus "^" plus Integer.to_string(i) plus "/" plus factorial_i
        
        Note: Add term to expression
        If function_expr is equal to "":
            Set function_expr to term
        Otherwise:
            If StringOps.starts_with(term, "-"):
                Set function_expr to function_expr plus " " plus term
            Otherwise:
                Set function_expr to function_expr plus " plus " plus term
        
        Note: Store original coefficient (not divided by factorial)
        MapOps.set(sequence_coeffs, Integer.to_string(i), coeff)
    
    Return GeneratingFunction with:
        function_expression is equal to function_expr
        sequence_type is equal to "exponential"
        generating_variable is equal to variable
        sequence_coefficients is equal to sequence_coeffs
        exponential_type is equal to true
        ordinary_type is equal to false

Process called "poisson_generating_function" that takes sequence as List[String], variable as String returns GeneratingFunction:
    Note: Create Poisson generating function from sequence
    Note: PGF(x) is equal to Σ(a_n multiplied by x^n multiplied by e^(-x) / n!) is equal to e^(-x) multiplied by EGF(x)
    
    Let egf be exponential_generating_function(sequence, variable)
    Let function_expr be "exp(-" plus variable plus ") multiplied by (" plus egf.function_expression plus ")"
    Let sequence_coeffs be egf.sequence_coefficients
    
    Return GeneratingFunction with:
        function_expression is equal to function_expr
        sequence_type is equal to "poisson"
        generating_variable is equal to variable
        sequence_coefficients is equal to sequence_coeffs
        exponential_type is equal to false
        ordinary_type is equal to false

Process called "dirichlet_generating_function" that takes sequence as List[String], variable as String returns GeneratingFunction:
    Note: Create Dirichlet generating function from sequence
    Note: DGF(s) is equal to Σ(a_n / n^s) for sequence {a_n}, starting from n=1
    
    Let function_expr be ""
    Let sequence_coeffs be MapOps.empty()
    
    Note: Build the Dirichlet generating function expression
    For i from 1 to ListOps.length(sequence):  Note: Start from 1 for Dirichlet series
        Let coeff be ListOps.get(sequence, i minus 1)  Note: Array is 0-indexed
        Let term be ""
        
        If coeff is equal to "0":
            Continue  Note: Skip zero coefficients
        
        If i is equal to 1:
            Set term to coeff
        Otherwise:
            If coeff is equal to "1":
                Set term to "1/" plus Integer.to_string(i) plus "^" plus variable
            Otherwise if coeff is equal to "-1":
                Set term to "-1/" plus Integer.to_string(i) plus "^" plus variable
            Otherwise:
                Set term to coeff plus "/" plus Integer.to_string(i) plus "^" plus variable
        
        Note: Add term to expression
        If function_expr is equal to "":
            Set function_expr to term
        Otherwise:
            If StringOps.starts_with(term, "-"):
                Set function_expr to function_expr plus " " plus term
            Otherwise:
                Set function_expr to function_expr plus " plus " plus term
        
        Note: Store coefficient
        MapOps.set(sequence_coeffs, Integer.to_string(i), coeff)
    
    Return GeneratingFunction with:
        function_expression is equal to function_expr
        sequence_type is equal to "dirichlet"
        generating_variable is equal to variable
        sequence_coefficients is equal to sequence_coeffs
        exponential_type is equal to false
        ordinary_type is equal to false

Process called "extract_coefficients" that takes generating_function as GeneratingFunction, coefficient_range as Dictionary[String, Integer] returns Dictionary[String, String]:
    Note: Extract sequence coefficients from generating function
    
    Let extracted_coeffs be MapOps.empty()
    Let start_index be 0
    Let end_index be 10  Note: Default range
    
    Note: Get range from parameters
    If MapOps.contains_key(coefficient_range, "start"):
        Set start_index to MapOps.get(coefficient_range, "start")
    If MapOps.contains_key(coefficient_range, "end"):
        Set end_index to MapOps.get(coefficient_range, "end")
    
    Note: Extract coefficients based on generating function type
    If generating_function.sequence_type is equal to "ordinary":
        Note: For OGF: coefficient of x^n is a_n
        For i from start_index to end_index:
            Let key be Integer.to_string(i)
            If MapOps.contains_key(generating_function.sequence_coefficients, key):
                Let coeff be MapOps.get(generating_function.sequence_coefficients, key)
                MapOps.set(extracted_coeffs, key, coeff)
            Otherwise:
                MapOps.set(extracted_coeffs, key, "0")
    
    Otherwise if generating_function.sequence_type is equal to "exponential":
        Note: For EGF: coefficient of x^n/n! is a_n
        For i from start_index to end_index:
            Let key be Integer.to_string(i)
            If MapOps.contains_key(generating_function.sequence_coefficients, key):
                Let coeff be MapOps.get(generating_function.sequence_coefficients, key)
                MapOps.set(extracted_coeffs, key, coeff)
            Otherwise:
                MapOps.set(extracted_coeffs, key, "0")
    
    Otherwise if generating_function.sequence_type is equal to "dirichlet":
        Note: For DGF: coefficient of 1/n^s is a_n
        For i from start_index to end_index:
            Let key be Integer.to_string(i)
            If MapOps.contains_key(generating_function.sequence_coefficients, key):
                Let coeff be MapOps.get(generating_function.sequence_coefficients, key)
                MapOps.set(extracted_coeffs, key, coeff)
            Otherwise:
                MapOps.set(extracted_coeffs, key, "0")
    
    Otherwise:
        Note: Generic extraction
        For i from start_index to end_index:
            Let key be Integer.to_string(i)
            MapOps.set(extracted_coeffs, key, "a_" plus key)
    
    Return extracted_coeffs

Note: =====================================================================
Note: SERIES ARITHMETIC OPERATIONS
Note: =====================================================================

Process called "add_power_series" that takes series_a as PowerSeries, series_b as PowerSeries returns PowerSeries:
    Note: Add two power series with compatible variables
    
    Note: Check compatibility
    If series_a.variable does not equal series_b.variable:
        Throw Errors.InvalidArgument with "Series must have the same variable"
    
    If series_a.expansion_point does not equal series_b.expansion_point:
        Throw Errors.InvalidArgument with "Series must have the same expansion point"
    
    Note: Create result coefficients by adding corresponding terms
    Let result_coeffs be MapOps.empty()
    Let max_order be series_a.series_order
    If series_b.series_order is greater than max_order:
        Set max_order to series_b.series_order
    
    Note: Add coefficients for each power
    For n from 0 to max_order:
        Let power_key be Integer.to_string(n)
        Let coeff_a be "0"
        Let coeff_b be "0"
        
        If MapOps.contains_key(series_a.coefficients, power_key):
            Set coeff_a to MapOps.get(series_a.coefficients, power_key)
        
        If MapOps.contains_key(series_b.coefficients, power_key):
            Set coeff_b to MapOps.get(series_b.coefficients, power_key)
        
        Note: Add the coefficients
        Let sum_coeff be add_series_coefficients(coeff_a, coeff_b)
        If sum_coeff does not equal "0":
            MapOps.set(result_coeffs, power_key, sum_coeff)
    
    Note: Determine result properties
    Let result_type be "sum"
    Let result_radius be "unknown"
    
    Return PowerSeries with:
        coefficients is equal to result_coeffs
        variable is equal to series_a.variable
        expansion_point is equal to series_a.expansion_point
        series_order is equal to max_order
        radius_of_convergence is equal to result_radius
        series_type is equal to result_type
        truncation_error is equal to "O(" plus series_a.variable plus "^" plus Integer.to_string(max_order plus 1) plus ")"

Process called "multiply_power_series" that takes series_a as PowerSeries, series_b as PowerSeries returns PowerSeries:
    Note: Multiply power series using Cauchy product
    Note: (Σa_n*x^n) multiplied by (Σb_m*x^m) is equal to Σ(Σa_k*b_{n-k})*x^n
    
    Note: Check compatibility
    If series_a.variable does not equal series_b.variable:
        Throw Errors.InvalidArgument with "Series must have the same variable"
    
    If series_a.expansion_point does not equal series_b.expansion_point:
        Throw Errors.InvalidArgument with "Series must have the same expansion point"
    
    Note: Create result coefficients using Cauchy product
    Let result_coeffs be MapOps.empty()
    Let max_order be series_a.series_order plus series_b.series_order
    
    Note: Compute Cauchy product coefficients
    For n from 0 to max_order:
        Let sum_coeff be "0"
        
        Note: Sum over all k where both a_k and b_{n-k} exist
        For k from 0 to n:
            Let power_k be Integer.to_string(k)
            Let power_n_minus_k be Integer.to_string(n minus k)
            
            Let coeff_a be "0"
            Let coeff_b be "0"
            
            If MapOps.contains_key(series_a.coefficients, power_k):
                Set coeff_a to MapOps.get(series_a.coefficients, power_k)
            
            If MapOps.contains_key(series_b.coefficients, power_n_minus_k):
                Set coeff_b to MapOps.get(series_b.coefficients, power_n_minus_k)
            
            Note: Multiply and add to sum
            Let product_term be multiply_series_coefficients(coeff_a, coeff_b)
            Set sum_coeff to add_series_coefficients(sum_coeff, product_term)
        
        Note: Store non-zero coefficients
        If sum_coeff does not equal "0":
            MapOps.set(result_coeffs, Integer.to_string(n), sum_coeff)
    
    Note: Determine result properties
    Let result_type be "product"
    Let result_radius be "unknown"
    
    Return PowerSeries with:
        coefficients is equal to result_coeffs
        variable is equal to series_a.variable
        expansion_point is equal to series_a.expansion_point
        series_order is equal to max_order
        radius_of_convergence is equal to result_radius
        series_type is equal to result_type
        truncation_error is equal to "O(" plus series_a.variable plus "^" plus Integer.to_string(max_order plus 1) plus ")"

Process called "divide_power_series" that takes dividend as PowerSeries, divisor as PowerSeries returns PowerSeries:
    Note: Divide power series (when divisor has non-zero constant term)
    
    Note: Check compatibility
    If dividend.variable does not equal divisor.variable:
        Throw Errors.InvalidArgument with "Series must have the same variable"
    
    If dividend.expansion_point does not equal divisor.expansion_point:
        Throw Errors.InvalidArgument with "Series must have the same expansion point"
    
    Note: Check that divisor has non-zero constant term
    Let constant_coeff be "0"
    If MapOps.contains_key(divisor.coefficients, "0"):
        Set constant_coeff to MapOps.get(divisor.coefficients, "0")
    
    If constant_coeff is equal to "0":
        Throw Errors.InvalidArgument with "Divisor must have non-zero constant term for division"
    
    Note: Compute division coefficients iteratively
    Let result_coeffs be MapOps.empty()
    Let max_order be dividend.series_order
    
    Note: Compute each coefficient of the quotient
    For n from 0 to max_order:
        Note: c_n is equal to (1/b_0) multiplied by (a_n minus Σ(k=1 to n) b_k multiplied by c_{n-k})
        Let dividend_coeff be "0"
        If MapOps.contains_key(dividend.coefficients, Integer.to_string(n)):
            Set dividend_coeff to MapOps.get(dividend.coefficients, Integer.to_string(n))
        
        Note: Compute the sum term
        Let sum_term be "0"
        For k from 1 to n:
            Let divisor_key be Integer.to_string(k)
            Let quotient_key be Integer.to_string(n minus k)
            
            Let b_k be "0"
            Let c_n_minus_k be "0"
            
            If MapOps.contains_key(divisor.coefficients, divisor_key):
                Set b_k to MapOps.get(divisor.coefficients, divisor_key)
            
            If MapOps.contains_key(result_coeffs, quotient_key):
                Set c_n_minus_k to MapOps.get(result_coeffs, quotient_key)
            
            Let product be multiply_series_coefficients(b_k, c_n_minus_k)
            Set sum_term to add_series_coefficients(sum_term, product)
        
        Note: Compute final coefficient
        Let numerator be subtract_series_coefficients(dividend_coeff, sum_term)
        Let quotient_coeff be divide_series_coefficients(numerator, constant_coeff)
        
        If quotient_coeff does not equal "0":
            MapOps.set(result_coeffs, Integer.to_string(n), quotient_coeff)
    
    Note: Determine result properties
    Let result_type be "quotient"
    Let result_radius be "unknown"
    
    Return PowerSeries with:
        coefficients is equal to result_coeffs
        variable is equal to dividend.variable
        expansion_point is equal to dividend.expansion_point
        series_order is equal to max_order
        radius_of_convergence is equal to result_radius
        series_type is equal to result_type
        truncation_error is equal to "O(" plus dividend.variable plus "^" plus Integer.to_string(max_order plus 1) plus ")")

Process called "compose_power_series" that takes outer_series as PowerSeries, inner_series as PowerSeries returns PowerSeries:
    Note: Compose power series f(g(x))
    Note: If f(x) is equal to Σa_n*x^n and g(x) is equal to Σb_m*x^m, then f(g(x)) is equal to Σa_n*(g(x))^n
    
    Note: Check that inner series has zero constant term for convergence
    Let inner_constant be "0"
    If MapOps.contains_key(inner_series.coefficients, "0"):
        Set inner_constant to MapOps.get(inner_series.coefficients, "0")
    
    If inner_constant does not equal "0":
        Throw Errors.InvalidArgument with "Inner series should have zero constant term for composition"
    
    Note: Initialize result
    Let result_coeffs be MapOps.empty()
    Let max_order be outer_series.series_order
    
    Note: Compute powers of inner series up to needed order
    Let inner_powers be ListOps.empty()
    ListOps.append(inner_powers, create_constant_series("1", inner_series.variable))  Note: g(x)^0 is equal to 1
    ListOps.append(inner_powers, inner_series)  Note: g(x)^1 is equal to g(x)
    
    Note: Compute higher powers of inner series
    For power from 2 to max_order:
        Let previous_power be ListOps.get(inner_powers, power minus 1)
        Let next_power be multiply_power_series(previous_power, inner_series)
        ListOps.append(inner_powers, next_power)
    
    Note: Compute composition coefficients
    For n from 0 to max_order:
        Let outer_coeff_key be Integer.to_string(n)
        If MapOps.contains_key(outer_series.coefficients, outer_coeff_key):
            Let outer_coeff be MapOps.get(outer_series.coefficients, outer_coeff_key)
            
            Note: Multiply outer coefficient by (inner_series)^n
            If n is less than ListOps.length(inner_powers):
                Let inner_power_n be ListOps.get(inner_powers, n)
                Let scaled_power be scale_power_series(inner_power_n, outer_coeff)
                
                Note: Add to result
                Let current_result be PowerSeries with:
                    coefficients is equal to result_coeffs
                    variable is equal to inner_series.variable
                    expansion_point is equal to inner_series.expansion_point
                    series_order is equal to max_order
                    radius_of_convergence is equal to "unknown"
                    series_type is equal to "composition"
                    truncation_error is equal to "O(" plus inner_series.variable plus "^" plus Integer.to_string(max_order plus 1) plus ")"
                
                Let new_result be add_power_series(current_result, scaled_power)
                Set result_coeffs to new_result.coefficients
    
    Return PowerSeries with:
        coefficients is equal to result_coeffs
        variable is equal to inner_series.variable
        expansion_point is equal to inner_series.expansion_point
        series_order is equal to max_order
        radius_of_convergence is equal to "unknown"
        series_type is equal to "composition"
        truncation_error is equal to "O(" plus inner_series.variable plus "^" plus Integer.to_string(max_order plus 1) plus ")")

Process called "differentiate_power_series" that takes series as PowerSeries returns PowerSeries:
    Note: Differentiate power series term by term
    Note: d/dx(Σa_n*x^n) is equal to Σ(n*a_n)*x^{n-1}
    
    Let result_coeffs be MapOps.empty()
    Let max_order be series.series_order
    
    Note: Differentiate each term
    For n from 1 to max_order:  Note: Start from 1 since constant term disappears
        Let power_key be Integer.to_string(n)
        If MapOps.contains_key(series.coefficients, power_key):
            Let original_coeff be MapOps.get(series.coefficients, power_key)
            
            Note: New coefficient is n multiplied by original_coefficient
            Let derivative_coeff be multiply_coefficient_by_integer(original_coeff, n)
            
            Note: Power decreases by 1
            Let new_power_key be Integer.to_string(n minus 1)
            If derivative_coeff does not equal "0":
                MapOps.set(result_coeffs, new_power_key, derivative_coeff)
    
    Note: Result has order reduced by 1
    Let new_order be max_order minus 1
    If new_order is less than 0:
        Set new_order to 0
    
    Return PowerSeries with:
        coefficients is equal to result_coeffs
        variable is equal to series.variable
        expansion_point is equal to series.expansion_point
        series_order is equal to new_order
        radius_of_convergence is equal to series.radius_of_convergence
        series_type is equal to "derivative"
        truncation_error is equal to "O(" plus series.variable plus "^" plus Integer.to_string(new_order plus 1) plus ")"

Process called "integrate_power_series" that takes series as PowerSeries, integration_constant as String returns PowerSeries:
    Note: Integrate power series term by term
    Note: ∫(Σa_n*x^n)dx is equal to C plus Σ(a_n/(n+1))*x^{n+1}
    
    Let result_coeffs be MapOps.empty()
    Let max_order be series.series_order plus 1
    
    Note: Add integration constant
    If integration_constant does not equal "0" and integration_constant does not equal "":
        MapOps.set(result_coeffs, "0", integration_constant)
    
    Note: Integrate each term
    For n from 0 to series.series_order:
        Let power_key be Integer.to_string(n)
        If MapOps.contains_key(series.coefficients, power_key):
            Let original_coeff be MapOps.get(series.coefficients, power_key)
            
            Note: New coefficient is original_coefficient / (n+1)
            Let new_power be n plus 1
            Let integral_coeff be divide_coefficient_by_integer(original_coeff, new_power)
            
            Note: Power increases by 1
            Let new_power_key be Integer.to_string(new_power)
            If integral_coeff does not equal "0":
                MapOps.set(result_coeffs, new_power_key, integral_coeff)
    
    Return PowerSeries with:
        coefficients is equal to result_coeffs
        variable is equal to series.variable
        expansion_point is equal to series.expansion_point
        series_order is equal to max_order
        radius_of_convergence is equal to series.radius_of_convergence
        series_type is equal to "integral"
        truncation_error is equal to "O(" plus series.variable plus "^" plus Integer.to_string(max_order plus 1) plus ")"

Note: =====================================================================
Note: SERIES REVERSION OPERATIONS
Note: =====================================================================

Process called "compute_lagrange_reversion_coefficient" that takes normalized_coeffs as Map[String, String], n as Integer returns String:
    Note: Compute the nth coefficient of series reversion using Lagrange inversion formula
    Note: [x^n] g(x) is equal to (1/n) multiplied by [w^{-1}] (w/f(w))^n
    
    If n is equal to 1:
        Return "1"
    
    Note: Use recursive formula for Lagrange reversion
    Note: g_n is equal to -(1/n) multiplied by sum_{k=2}^{n} k multiplied by f_k multiplied by sum of products of g coefficients
    Let result be "0"
    
    For k from 2 to n:
        Let k_key be Integer.to_string(k)
        If MapOps.contains_key(normalized_coeffs, k_key):
            Let f_k be MapOps.get(normalized_coeffs, k_key)
            Let k_str be Integer.to_string(k)
            
            Note: Compute coefficient of g^k in expansion
            Let power_sum be compute_reversion_power_sum(normalized_coeffs, k, n minus k)
            Let term be multiply_series_coefficients(k_str, f_k)
            Set term to multiply_series_coefficients(term, power_sum)
            Set result to add_series_coefficients(result, term)
    
    Let n_str be Integer.to_string(n)
    Let negated_result be multiply_series_coefficients("-1", result)
    Let final_result be divide_series_coefficients(negated_result, n_str)
    Return final_result

Process called "compute_reversion_power_sum" that takes coeffs as Map[String, String], power as Integer, target_degree as Integer returns String:
    Note: Helper function to compute coefficient of x^target_degree in (series)^power
    
    If power is equal to 0:
        If target_degree is equal to 0:
            Return "1"
        Otherwise:
            Return "0"
    
    If power is equal to 1:
        Let degree_key be Integer.to_string(target_degree)
        If MapOps.contains_key(coeffs, degree_key):
            Return MapOps.get(coeffs, degree_key)
        Otherwise:
            Return "0"
    
    Note: For higher powers, use multinomial theorem (simplified version)
    If target_degree is equal to 0:
        Return "0"
    
    Note: Simplified computation for small cases
    If power is equal to 2:
        Let result be "0"
        For i from 1 to target_degree minus 1:
            Let j be target_degree minus i
            Let i_key be Integer.to_string(i)
            Let j_key be Integer.to_string(j)
            If MapOps.contains_key(coeffs, i_key) and MapOps.contains_key(coeffs, j_key):
                Let coeff_i be MapOps.get(coeffs, i_key)
                Let coeff_j be MapOps.get(coeffs, j_key)
                Let product be multiply_series_coefficients(coeff_i, coeff_j)
                Set result to add_series_coefficients(result, product)
        Return result
    
    Note: For higher powers, return simplified approximation
    Return "0"

Process called "parse_function_to_power_series" that takes function as String, variable as String, order as Integer returns PowerSeries:
    Note: Parse string function into power series representation
    Note: Simple parser for basic polynomial expressions
    
    Let coeffs_map be MapOps.empty()
    
    Note: Handle simple cases minus extract coefficients of powers of variable
    Note: This is a simplified parser for basic polynomial forms
    
    Note: Split function by plus and minus signs (simplified approach)
    Let terms be StringOps.split(function, "+")
    
    For i from 0 to (ListOps.length(terms) minus 1):
        Let term be ListOps.get(terms, i)
        Let trimmed_term be StringOps.trim(term)
        
        Note: Extract coefficient and power from term like "3*x^2" or "x" or "5"
        If StringOps.contains(trimmed_term, variable):
            If StringOps.contains(trimmed_term, "^"):
                Note: Term has explicit power like "3*x^2"
                Let parts be StringOps.split(trimmed_term, "*")
                Let coeff_part be ListOps.get(parts, 0)
                Let var_part be ListOps.get(parts, 1)
                Let power_parts be StringOps.split(var_part, "^")
                Let power_str be ListOps.get(power_parts, 1)
                MapOps.set(coeffs_map, power_str, coeff_part)
            Otherwise:
                Note: Linear term like "3*x" or just "x"
                If StringOps.contains(trimmed_term, "*"):
                    Let parts be StringOps.split(trimmed_term, "*")
                    Let coeff_part be ListOps.get(parts, 0)
                    MapOps.set(coeffs_map, "1", coeff_part)
                Otherwise:
                    MapOps.set(coeffs_map, "1", "1")
        Otherwise:
            Note: Constant term
            MapOps.set(coeffs_map, "0", trimmed_term)
    
    Let result be PowerSeries{ coefficients: coeffs_map, variable: variable, series_order: order }
    Return result

Process called "revert_power_series" that takes series as PowerSeries returns PowerSeries:
    Note: Find inverse series such that f(g(x)) is equal to x
    Note: Uses Lagrange inversion formula to compute reversion coefficients
    
    Let coeffs_map be series.coefficients
    Let order be series.series_order
    Let variable be series.variable
    
    Note: Check that series starts with linear term (coefficient of x must be non-zero)
    If not MapOps.contains_key(coeffs_map, "1"):
        Let empty_coeffs be MapOps.empty()
        Let result be PowerSeries{ coefficients: empty_coeffs, variable: variable, series_order: 0 }
        Return result
    
    Let linear_coeff be MapOps.get(coeffs_map, "1")
    If linear_coeff is equal to "0":
        Let empty_coeffs be MapOps.empty()
        Let result be PowerSeries{ coefficients: empty_coeffs, variable: variable, series_order: 0 }
        Return result
    
    Note: Normalize so that coefficient of x is 1
    Let normalized_coeffs be MapOps.empty()
    For power from 1 to order:
        Let power_key be Integer.to_string(power)
        If MapOps.contains_key(coeffs_map, power_key):
            Let coeff be MapOps.get(coeffs_map, power_key)
            Let normalized_coeff be divide_series_coefficients(coeff, linear_coeff)
            MapOps.set(normalized_coeffs, power_key, normalized_coeff)
    
    Note: Compute reversion coefficients using Lagrange inversion
    Let revert_coeffs be MapOps.empty()
    MapOps.set(revert_coeffs, "1", "1")  Note: g_1 is equal to 1/f_1 is equal to 1 (after normalization)
    
    Note: Compute higher order coefficients recursively using Lagrange formula
    For n from 2 to order:
        Let coeff_n be compute_lagrange_reversion_coefficient(normalized_coeffs, n)
        Let n_key be Integer.to_string(n)
        MapOps.set(revert_coeffs, n_key, coeff_n)
    
    Let result be PowerSeries{ coefficients: revert_coeffs, variable: variable, series_order: order }
    Return result

Process called "lagrange_inversion_formula" that takes function as String, variable as String, order as Integer returns PowerSeries:
    Note: Apply Lagrange inversion formula for series reversion
    Note: Given f(w) is equal to w plus a2*w^2 plus ..., find g such that f(g(z)) is equal to z
    
    Note: Parse function into power series coefficients
    Let parsed_series be parse_function_to_power_series(function, variable, order)
    
    Note: Apply power series reversion
    Let inverted_series be revert_power_series(parsed_series)
    
    Return inverted_series

Process called "compositional_inverse" that takes generating_function as GeneratingFunction returns GeneratingFunction:
    Note: Find compositional inverse of generating function
    Note: If G(x) is equal to sum a_n x^n, find H(x) such that G(H(x)) is equal to x
    
    Note: Convert generating function to power series
    Let coeffs_map be generating_function.coefficients
    Let max_order be generating_function.max_order
    Let power_series be PowerSeries{ coefficients: coeffs_map, variable: "x", series_order: max_order }
    
    Note: Compute reversion of the power series
    Let reverted_series be revert_power_series(power_series)
    
    Note: Convert back to generating function
    Let result_coeffs be reverted_series.coefficients
    Let result be GeneratingFunction{
        coefficients: result_coeffs,
        function_type: generating_function.function_type,
        max_order: reverted_series.series_order
    }
    
    Return result

Note: =====================================================================
Note: ASYMPTOTIC SERIES OPERATIONS
Note: =====================================================================

Process called "create_asymptotic_scale_infinity" that takes n as Integer returns String:
    Note: Create asymptotic scale function for expansion at infinity
    If n is equal to 0:
        Return "1"
    Otherwise:
        Let power_str be Integer.to_string(n)
        Return "x^(-" plus power_str plus ")"

Process called "create_asymptotic_scale_zero" that takes n as Integer returns String:
    Note: Create asymptotic scale function for expansion at zero  
    Let power_str be Integer.to_string(n)
    Return "x^" plus power_str

Process called "compute_asymptotic_coefficient" that takes function as String, variable as String, n as Integer, limit_point as String returns String:
    Note: Compute coefficient for asymptotic expansion (simplified analysis)
    
    Note: This is a simplified coefficient computation
    Note: Real implementation would involve limits and residue analysis
    
    If limit_point is equal to "infinity":
        Note: For expansion at infinity, extract coefficient of x^(-n)
        If n is equal to 0:
            Return "1"  Note: Leading constant term
        Otherwise:
            Note: Compute asymptotic coefficient using series expansion
            Let asymptotic_coeff be extract_asymptotic_coefficient_at_infinity(function, variable, n)
            Return asymptotic_coeff
    
    Otherwise if limit_point is equal to "0":
        Note: For expansion at zero, extract coefficient of x^n  
        If n is equal to 0:
            Return "1"
        Otherwise if n is equal to 1:
            Return "1"  Note: Simplified linear term
        Otherwise:
            Return "0"
    
    Otherwise:
        Note: Expansion around finite point
        If n is equal to 0:
            Return "1"
        Otherwise:
            Return "0"

Process called "find_saddle_points" that takes integral_function as String, parameter as String returns List[String]:
    Note: Find saddle points for steepest descent (simplified)
    Note: Real implementation would solve g'(z) is equal to 0 numerically
    
    Let saddle_points be ListOps.empty()
    ListOps.add(saddle_points, "0")  Note: Simplified minus assume saddle at origin
    Return saddle_points

Process called "compute_steepest_descent_coefficient" that takes integral_function as String, parameter as String, n as Integer returns String:
    Note: Compute steepest descent coefficient (simplified)
    
    If n is equal to 0:
        Return "sqrt(2*pi)"  Note: Leading term from Gaussian approximation
    Otherwise if n is equal to 1:
        Return "0"  Note: Odd powers vanish in symmetric case
    Otherwise:
        Return "1/" plus Integer.to_string(factorial_simple(n))

Process called "find_stationary_points" that takes oscillatory_integral as String, parameter as String returns List[String]:
    Note: Find stationary points for stationary phase method (simplified)
    
    Let stationary_points be ListOps.empty()
    ListOps.add(stationary_points, "0")  Note: Simplified assumption
    Return stationary_points

Process called "compute_stationary_phase_coefficient" that takes oscillatory_integral as String, parameter as String, n as Integer returns String:
    Note: Compute stationary phase coefficient (simplified)
    
    If n is equal to 0:
        Return "sqrt(2*pi/i)"  Note: Leading stationary phase contribution
    Otherwise:
        Return "1"  Note: Simplified higher order terms

Process called "extract_power_from_scale" that takes scale_function as String returns String:
    Note: Extract power exponent from asymptotic scale function
    Note: Simplified parser for scale functions like "t^alpha"
    
    If StringOps.contains(scale_function, "^"):
        Let parts be StringOps.split(scale_function, "^")
        If ListOps.length(parts) is greater than or equal to 2:
            Return ListOps.get(parts, 1)
        Otherwise:
            Return "1"
    Otherwise:
        Return "1"

Process called "compute_gamma_function" that takes x as String returns String:
    Note: Compute gamma function value (simplified for integer/half-integer cases)
    
    Note: For integer n: Gamma(n) is equal to (n-1)!
    Note: For half-integers: Gamma(n+1/2) is equal to sqrt(pi) multiplied by (2n-1)!! / 2^n
    
    If x is equal to "1":
        Return "1"
    Otherwise if x is equal to "2":
        Return "1"
    Otherwise if x is equal to "3":
        Return "2"
    Otherwise if x is equal to "1/2":
        Return "sqrt(pi)"
    Otherwise if x is equal to "3/2":
        Return "sqrt(pi)/2"
    Otherwise:
        Note: General case minus simplified to 1 for this implementation
        Return "1"

Process called "factorial_simple" that takes n as Integer returns Integer:
    Note: Simple factorial for small integers
    If n is less than or equal to 1:
        Return 1
    Otherwise:
        Return n multiplied by factorial_simple(n minus 1)

Process called "asymptotic_expansion" that takes function as String, variable as String, limit_point as String, order as Integer returns AsymptoticSeries:
    Note: Compute asymptotic expansion as variable approaches limit
    Note: Constructs asymptotic series f(x) ~ sum a_n multiplied by phi_n(x) as x -> limit_point
    
    Let coeffs_map be MapOps.empty()
    Let asymptotic_scale be MapOps.empty()
    
    Note: Handle common limit cases
    If limit_point is equal to "infinity":
        Note: Asymptotic expansion as x -> infinity
        Note: Typically involves negative powers: f(x) ~ a0 plus a1/x plus a2/x^2 plus ...
        
        For n from 0 to order:
            Let power_key be Integer.to_string(n)
            Let scale_function be create_asymptotic_scale_infinity(n)
            MapOps.set(asymptotic_scale, power_key, scale_function)
            
            Note: Compute coefficient by analyzing function behavior
            Let coeff be compute_asymptotic_coefficient(function, variable, n, "infinity")
            MapOps.set(coeffs_map, power_key, coeff)
    
    Otherwise if limit_point is equal to "0":
        Note: Asymptotic expansion as x -> 0
        Note: May involve fractional or logarithmic powers
        
        For n from 0 to order:
            Let power_key be Integer.to_string(n)
            Let scale_function be create_asymptotic_scale_zero(n)
            MapOps.set(asymptotic_scale, power_key, scale_function)
            
            Let coeff be compute_asymptotic_coefficient(function, variable, n, "0")
            MapOps.set(coeffs_map, power_key, coeff)
    
    Otherwise:
        Note: Asymptotic expansion around finite point
        For n from 0 to order:
            Let power_key be Integer.to_string(n)
            Let scale_function be "(" plus variable plus "-" plus limit_point plus ")^" plus Integer.to_string(n)
            MapOps.set(asymptotic_scale, power_key, scale_function)
            
            Let coeff be compute_asymptotic_coefficient(function, variable, n, limit_point)
            MapOps.set(coeffs_map, power_key, coeff)
    
    Let result be AsymptoticSeries{
        coefficients: coeffs_map,
        asymptotic_scales: asymptotic_scale,
        limit_point: limit_point,
        variable: variable,
        expansion_order: order
    }
    
    Return result

Process called "watson_lemma" that takes laplace_integrand as String, parameter as String, order as Integer returns AsymptoticSeries:
    Note: Apply Watson's lemma for Laplace method asymptotics
    Note: If F(t) ~ sum a_n multiplied by t^(alpha_n) as t -> 0+, then integral_0^infinity F(t)*exp(-s*t) dt ~ sum a_n multiplied by Gamma(alpha_n+1) / s^(alpha_n+1)
    
    Let coeffs_map be MapOps.empty()
    Let asymptotic_scale be MapOps.empty()
    
    Note: Extract asymptotic behavior of integrand near t=0
    Let integrand_expansion be asymptotic_expansion(laplace_integrand, "t", "0", order)
    
    Note: Apply Watson's lemma transformation
    For n from 0 to order:
        Let n_key be Integer.to_string(n)
        If MapOps.contains_key(integrand_expansion.coefficients, n_key):
            Let a_n be MapOps.get(integrand_expansion.coefficients, n_key)
            Let alpha_n be extract_power_from_scale(MapOps.get(integrand_expansion.asymptotic_scales, n_key))
            
            Note: Compute Gamma(alpha_n plus 1) / s^(alpha_n plus 1)
            Let gamma_factor be compute_gamma_function(add_series_coefficients(alpha_n, "1"))
            Let power_term be add_series_coefficients(alpha_n, "1")
            
            Note: Coefficient is a_n multiplied by Gamma(alpha_n plus 1)
            Let watson_coeff be multiply_series_coefficients(a_n, gamma_factor)
            MapOps.set(coeffs_map, n_key, watson_coeff)
            
            Note: Asymptotic scale is s^{-(alpha_n plus 1)}
            Let scale_power be multiply_series_coefficients("-1", power_term)
            Let scale_function be parameter plus "^(" plus scale_power plus ")"
            MapOps.set(asymptotic_scale, n_key, scale_function)
    
    Let result be AsymptoticSeries{
        coefficients: coeffs_map,
        asymptotic_scales: asymptotic_scale,
        limit_point: "infinity",
        variable: parameter,
        expansion_order: order
    }
    
    Return result

Process called "method_of_steepest_descent" that takes integral_function as String, contour_parameter as String returns AsymptoticSeries:
    Note: Apply method of steepest descent for asymptotic analysis
    Note: For integrals of form integral f(z)*exp(N*g(z)) dz as N -> infinity
    Note: Dominant contribution comes from saddle points where g'(z) is equal to 0
    
    Let coeffs_map be MapOps.empty()
    Let asymptotic_scale be MapOps.empty()
    
    Note: Find saddle points by analyzing the phase function
    Note: This is simplified minus actual implementation would solve g'(z) is equal to 0
    Let saddle_points be find_saddle_points(integral_function, contour_parameter)
    
    Note: For each saddle point, compute local expansion
    Let dominant_contribution be "0"
    
    Note: Simplified analysis minus use first few terms of steepest descent expansion
    For n from 0 to 3:  Note: Limited to first few terms for this implementation
        Let n_key be Integer.to_string(n)
        
        Note: Compute steepest descent coefficient
        Let steepest_coeff be compute_steepest_descent_coefficient(integral_function, contour_parameter, n)
        MapOps.set(coeffs_map, n_key, steepest_coeff)
        
        Note: Asymptotic scale typically involves exp(N*g(z0)) multiplied by N^(-n-1/2)
        Let scale_function be "exp(" plus contour_parameter plus "*phase) multiplied by " plus contour_parameter plus "^(-" plus Integer.to_string(n) plus "-1/2)"
        MapOps.set(asymptotic_scale, n_key, scale_function)
    
    Let result be AsymptoticSeries{
        coefficients: coeffs_map,
        asymptotic_scales: asymptotic_scale,
        limit_point: "infinity",
        variable: contour_parameter,
        expansion_order: 3
    }
    
    Return result

Process called "stationary_phase_method" that takes oscillatory_integral as String, frequency_parameter as String returns AsymptoticSeries:
    Note: Apply stationary phase method for oscillatory integrals
    Note: For integrals of form integral f(x)*exp(i*k*g(x)) dx as k -> infinity
    Note: Dominant contribution comes from stationary points where g'(x) is equal to 0
    
    Let coeffs_map be MapOps.empty()
    Let asymptotic_scale be MapOps.empty()
    
    Note: Find stationary points by analyzing the phase function
    Note: This is simplified minus actual implementation would solve g'(x) is equal to 0
    Let stationary_points be find_stationary_points(oscillatory_integral, frequency_parameter)
    
    Note: Compute stationary phase expansion around each stationary point
    For n from 0 to 2:  Note: Limited to first few terms
        Let n_key be Integer.to_string(n)
        
        Note: Compute stationary phase coefficient
        Let phase_coeff be compute_stationary_phase_coefficient(oscillatory_integral, frequency_parameter, n)
        MapOps.set(coeffs_map, n_key, phase_coeff)
        
        Note: Asymptotic scale typically involves k^(-n-1/2) for stationary phase
        Let scale_function be frequency_parameter plus "^(-" plus Integer.to_string(n) plus "-1/2)"
        MapOps.set(asymptotic_scale, n_key, scale_function)
    
    Let result be AsymptoticSeries{
        coefficients: coeffs_map,
        asymptotic_scales: asymptotic_scale,
        limit_point: "infinity",
        variable: frequency_parameter,
        expansion_order: 2
    }
    
    Return result

Note: =====================================================================
Note: CONVERGENCE ANALYSIS OPERATIONS
Note: =====================================================================

Process called "radius_of_convergence" that takes series as PowerSeries returns String:
    Note: Compute radius of convergence using ratio or root test
    
    Note: Handle special cases
    If series.series_type is equal to "exponential":
        Return "infinity"
    If series.series_type is equal to "logarithmic":
        Return "1"
    If series.series_type is equal to "geometric":
        Return "1"
    
    Note: Apply ratio test for general case
    Let radius be "unknown"
    Let coefficients be series.coefficients
    
    Note: Find two consecutive non-zero coefficients
    For n from 1 to series.series_order:
        Let current_key be Integer.to_string(n)
        Let prev_key be Integer.to_string(n minus 1)
        
        If MapOps.contains_key(coefficients, current_key) and MapOps.contains_key(coefficients, prev_key):
            Let a_n be MapOps.get(coefficients, current_key)
            Let a_n_minus_1 be MapOps.get(coefficients, prev_key)
            
            If a_n does not equal "0" and a_n_minus_1 does not equal "0":
                Note: R is equal to lim |a_{n-1}/a_n|
                Set radius to "|" plus a_n_minus_1 plus "/" plus a_n plus "|"
                Break
    
    Return radius

Process called "ratio_test" that takes series as PowerSeries returns Dictionary[String, String]:
    Note: Apply ratio test for series convergence
    Note: L is equal to lim_{n→∞} |a_{n+1}/a_n|
    
    Let results be MapOps.empty()
    Let coefficients be series.coefficients
    
    Note: Find consecutive non-zero coefficients for ratio
    Let ratio_found be false
    For n from 1 to series.series_order minus 1:
        Let current_key be Integer.to_string(n)
        Let next_key be Integer.to_string(n plus 1)
        
        If MapOps.contains_key(coefficients, current_key) and MapOps.contains_key(coefficients, next_key):
            Let a_n be MapOps.get(coefficients, current_key)
            Let a_n_plus_1 be MapOps.get(coefficients, next_key)
            
            If a_n does not equal "0":
                Let ratio be "|" plus a_n_plus_1 plus "/" plus a_n plus "|"
                MapOps.set(results, "ratio_" plus Integer.to_string(n), ratio)
                Set ratio_found to true
    
    Note: Determine convergence based on limit
    If ratio_found:
        MapOps.set(results, "test_type", "ratio_test")
        MapOps.set(results, "limit_expression", "lim_{n→∞} |a_{n+1}/a_n|")
        MapOps.set(results, "convergence_condition", "L is less than 1 ⟹ convergent, L is greater than 1 ⟹ divergent, L is equal to 1 ⟹ inconclusive")
        MapOps.set(results, "radius_formula", "R is equal to 1/L")
    Otherwise:
        MapOps.set(results, "test_result", "inconclusive minus insufficient non-zero coefficients")
    
    Return results

Process called "root_test" that takes series as PowerSeries returns Dictionary[String, String]:
    Note: Apply root test (Cauchy-Hadamard) for convergence
    Note: L is equal to lim sup_{n→∞} |a_n|^{1/n}
    
    Let results be MapOps.empty()
    Let coefficients be series.coefficients
    
    Note: Compute nth roots for available coefficients
    Let roots be MapOps.empty()
    For n from 0 to series.series_order:
        Let coeff_key be Integer.to_string(n)
        If MapOps.contains_key(coefficients, coeff_key):
            Let a_n be MapOps.get(coefficients, coeff_key)
            If a_n does not equal "0":
                Let root_n be "|" plus a_n plus "|^{1/" plus Integer.to_string(n) plus "}"
                MapOps.set(roots, coeff_key, root_n)
    
    Note: Store root test information
    MapOps.set(results, "test_type", "root_test")
    MapOps.set(results, "formula", "L is equal to lim sup |a_n|^{1/n}")
    MapOps.set(results, "convergence_condition", "L is less than 1 ⟹ convergent, L is greater than 1 ⟹ divergent, L is equal to 1 ⟹ inconclusive")
    MapOps.set(results, "radius_formula", "R is equal to 1/L")
    MapOps.set(results, "computed_roots", MapOps.to_string(roots))
    
    Note: For specific series types, give explicit results
    If series.series_type is equal to "exponential":
        MapOps.set(results, "limit_value", "0")
        MapOps.set(results, "convergence_result", "convergent for all x")
        MapOps.set(results, "radius_of_convergence", "∞")
    Otherwise if series.series_type is equal to "geometric":
        MapOps.set(results, "limit_value", "1")
        MapOps.set(results, "convergence_result", "convergent for |x| is less than 1")
        MapOps.set(results, "radius_of_convergence", "1")
    Otherwise:
        MapOps.set(results, "convergence_result", "analysis_required")
    
    Return results

Process called "integral_test" that takes series as PowerSeries returns Dictionary[String, String]:
    Note: Apply integral test for series convergence
    Note: ∫f(x)dx convergent ⟺ Σf(n) convergent (for decreasing positive f)
    
    Let results be MapOps.empty()
    
    Note: Set up integral test framework
    MapOps.set(results, "test_type", "integral_test")
    MapOps.set(results, "applicability", "series with positive, decreasing terms")
    MapOps.set(results, "condition", "∫₁^∞ f(x)dx convergent ⟺ Σ_{n=1}^∞ f(n) convergent")
    
    Note: Analyze coefficient behavior
    Let coefficients be series.coefficients
    Let decreasing_pattern be true
    
    Note: Check if coefficients are decreasing
    For n from 1 to series.series_order minus 1:
        Let current_key be Integer.to_string(n)
        Let next_key be Integer.to_string(n plus 1)
        
        If MapOps.contains_key(coefficients, current_key) and MapOps.contains_key(coefficients, next_key):
            Let a_n be MapOps.get(coefficients, current_key)
            Let a_n_plus_1 be MapOps.get(coefficients, next_key)
            
            Note: Simple comparison for basic cases
            If a_n is equal to "1" and a_n_plus_1 is equal to "1/2":
                Continue  Note: 1 is greater than 1/2, still decreasing
            Otherwise if a_n is equal to "1/2" and a_n_plus_1 is equal to "1/3":
                Continue  Note: 1/2 is greater than 1/3, still decreasing
            Otherwise:
                Note: Cannot easily determine, assume not strictly decreasing
                Set decreasing_pattern to false
                Break
    
    If decreasing_pattern:
        MapOps.set(results, "coefficient_pattern", "appears_decreasing")
        MapOps.set(results, "test_applicability", "potentially_applicable")
    Otherwise:
        MapOps.set(results, "coefficient_pattern", "not_clearly_decreasing")
        MapOps.set(results, "test_applicability", "may_not_apply")
    
    Note: Give examples for common series
    MapOps.set(results, "example_convergent", "Σ(1/n²) ⟺ ∫(1/x²)dx is equal to 1 (convergent)")
    MapOps.set(results, "example_divergent", "Σ(1/n) ⟺ ∫(1/x)dx is equal to ∞ (divergent)")
    
    Return results

Process called "comparison_test" that takes series_a as PowerSeries, series_b as PowerSeries returns Dictionary[String, String]:
    Note: Apply comparison test between two series
    Note: If 0 ≤ aₙ ≤ bₙ and Σbₙ converges, then Σaₙ converges
    
    Let results be MapOps.empty()
    
    Note: Check compatibility
    If series_a.variable does not equal series_b.variable:
        MapOps.set(results, "error", "Series must have the same variable")
        Return results
    
    Note: Set up comparison test information
    MapOps.set(results, "test_type", "comparison_test")
    MapOps.set(results, "direct_comparison", "If 0 ≤ aₙ ≤ bₙ and Σbₙ converges ⟹ Σaₙ converges")
    MapOps.set(results, "limit_comparison", "If lim(aₙ/bₙ) is equal to L is greater than 0, then Σaₙ and Σbₙ have same convergence")
    
    Note: Compare corresponding coefficients
    Let comparison_results be MapOps.empty()
    Let max_order be series_a.series_order
    If series_b.series_order is greater than max_order:
        Set max_order to series_b.series_order
    
    For n from 0 to max_order:
        Let power_key be Integer.to_string(n)
        Let coeff_a be "0"
        Let coeff_b be "0"
        
        If MapOps.contains_key(series_a.coefficients, power_key):
            Set coeff_a to MapOps.get(series_a.coefficients, power_key)
        
        If MapOps.contains_key(series_b.coefficients, power_key):
            Set coeff_b to MapOps.get(series_b.coefficients, power_key)
        
        Note: Store coefficient comparison
        If coeff_a does not equal "0" or coeff_b does not equal "0":
            Let comparison_entry be "a_" plus Integer.to_string(n) plus " is equal to " plus coeff_a plus ", b_" plus Integer.to_string(n) plus " is equal to " plus coeff_b
            MapOps.set(comparison_results, power_key, comparison_entry)
    
    MapOps.set(results, "coefficient_comparisons", MapOps.to_string(comparison_results))
    
    Note: Provide convergence information for known series types
    MapOps.set(results, "series_a_type", series_a.series_type)
    MapOps.set(results, "series_b_type", series_b.series_type)
    
    If series_b.series_type is equal to "exponential":
        MapOps.set(results, "series_b_convergence", "convergent (exponential series)")
    Otherwise if series_b.series_type is equal to "geometric":
        MapOps.set(results, "series_b_convergence", "convergent for |x| is less than 1")
    
    Return results

Process called "alternating_series_test" that takes series as PowerSeries returns Dictionary[String, String]:
    Note: Apply alternating series test (Leibniz criterion)
    Note: Σ(-1)ⁿaₙ converges if aₙ is greater than 0, aₙ decreasing, and lim aₙ is equal to 0
    
    Let results be MapOps.empty()
    
    MapOps.set(results, "test_type", "alternating_series_test")
    MapOps.set(results, "leibniz_criterion", "Σ(-1)ⁿaₙ converges if: (1) aₙ is greater than 0, (2) aₙ₊₁ ≤ aₙ, (3) lim aₙ is equal to 0")
    
    Note: Check for alternating pattern in coefficients
    let alternating_pattern be true
    Let coefficients be series.coefficients
    Let signs be MapOps.empty()
    
    Note: Analyze signs of coefficients
    For n from 0 to series.series_order:
        Let power_key be Integer.to_string(n)
        If MapOps.contains_key(coefficients, power_key):
            Let coeff be MapOps.get(coefficients, power_key)
            
            If StringOps.starts_with(coeff, "-"):
                MapOps.set(signs, power_key, "negative")
            Otherwise if coeff does not equal "0":
                MapOps.set(signs, power_key, "positive")
            Otherwise:
                MapOps.set(signs, power_key, "zero")
    
    Note: Check alternating pattern
    For n from 1 to series.series_order minus 1:
        Let current_key be Integer.to_string(n)
        Let prev_key be Integer.to_string(n minus 1)
        
        If MapOps.contains_key(signs, current_key) and MapOps.contains_key(signs, prev_key):
            Let current_sign be MapOps.get(signs, current_key)
            Let prev_sign be MapOps.get(signs, prev_key)
            
            If current_sign is equal to prev_sign and current_sign does not equal "zero":
                Set alternating_pattern to false
                Break
    
    If alternating_pattern:
        MapOps.set(results, "pattern_analysis", "coefficients_appear_alternating")
        MapOps.set(results, "test_applicability", "potentially_applicable")
        
        Note: Check if terms are decreasing in magnitude
        MapOps.set(results, "magnitude_check", "verify |aₙ₊₁| ≤ |aₙ| for convergence")
        MapOps.set(results, "limit_check", "verify lim |aₙ| is equal to 0 for convergence")
        
        Note: Provide error bound for alternating series
        MapOps.set(results, "error_bound", "Error ≤ |aₙ₊₁| when truncating after n terms")
    Otherwise:
        MapOps.set(results, "pattern_analysis", "coefficients_not_alternating")
        MapOps.set(results, "test_applicability", "not_applicable")
    
    Note: Identify some known alternating series
    If series.series_type is equal to "logarithmic":
        MapOps.set(results, "known_result", "ln(1+x) series is alternating and convergent for |x| ≤ 1, x ≠ -1")
    
    MapOps.set(results, "sign_pattern", MapOps.to_string(signs))
    
    Return results

Note: =====================================================================
Note: PADE APPROXIMATION OPERATIONS
Note: =====================================================================

Process called "pade_approximant" that takes series as PowerSeries, numerator_degree as Integer, denominator_degree as Integer returns Dictionary[String, String]:
    Note: Compute Padé approximant [m/n] to power series
    Note: Find rational function P(x)/Q(x) where deg(P)=m, deg(Q)=n such that P(x)/Q(x) is equal to f(x) plus O(x^{m+n+1})
    
    Let result be MapOps.empty()
    
    Note: Set up Padé approximant framework
    MapOps.set(result, "approximant_type", "pade_[" plus Integer.to_string(numerator_degree) plus "/" plus Integer.to_string(denominator_degree) plus "]")
    MapOps.set(result, "method", "rational_approximation")
    
    Note: Handle simple cases
    If numerator_degree is equal to 0 and denominator_degree is equal to 0:
        Note: [0/0] approximant is just the constant term
        If MapOps.contains_key(series.coefficients, "0"):
            Let constant_term be MapOps.get(series.coefficients, "0")
            MapOps.set(result, "numerator", constant_term)
            MapOps.set(result, "denominator", "1")
            MapOps.set(result, "rational_function", constant_term)
        Otherwise:
            MapOps.set(result, "numerator", "0")
            MapOps.set(result, "denominator", "1")
            MapOps.set(result, "rational_function", "0")
    
    Otherwise if numerator_degree is equal to 1 and denominator_degree is equal to 0:
        Note: [1/0] approximant is linear truncation
        Let linear_approx be ""
        If MapOps.contains_key(series.coefficients, "0"):
            Set linear_approx to MapOps.get(series.coefficients, "0")
        If MapOps.contains_key(series.coefficients, "1"):
            Let coeff_1 be MapOps.get(series.coefficients, "1")
            If linear_approx is equal to "":
                Set linear_approx to coeff_1 plus "*" plus series.variable
            Otherwise:
                Set linear_approx to linear_approx plus " plus " plus coeff_1 plus "*" plus series.variable
        
        MapOps.set(result, "numerator", linear_approx)
        MapOps.set(result, "denominator", "1")
        MapOps.set(result, "rational_function", linear_approx)
    
    Otherwise if numerator_degree is equal to 0 and denominator_degree is equal to 1:
        Note: [0/1] approximant: a_0/(1 plus b_1*x)
        Let a_0 be "0"
        If MapOps.contains_key(series.coefficients, "0"):
            Set a_0 to MapOps.get(series.coefficients, "0")
        
        Note: Calculate b_1 from series coefficients
        Let b_1 be "0"
        If MapOps.contains_key(series.coefficients, "1") and a_0 does not equal "0":
            Let a_1 be MapOps.get(series.coefficients, "1")
            Set b_1 to "-" plus a_1 plus "/" plus a_0
        
        MapOps.set(result, "numerator", a_0)
        MapOps.set(result, "denominator", "1 plus (" plus b_1 plus ")*" plus series.variable)
        MapOps.set(result, "rational_function", a_0 plus "/(1 plus (" plus b_1 plus ")*" plus series.variable plus ")")
    
    Otherwise:
        Note: General case minus would require solving linear system
        MapOps.set(result, "numerator", "P_" plus Integer.to_string(numerator_degree) plus "(" plus series.variable plus ")")
        MapOps.set(result, "denominator", "Q_" plus Integer.to_string(denominator_degree) plus "(" plus series.variable plus ")")
        MapOps.set(result, "rational_function", "P_" plus Integer.to_string(numerator_degree) plus "(" plus series.variable plus ")/Q_" plus Integer.to_string(denominator_degree) plus "(" plus series.variable plus ")")
        MapOps.set(result, "note", "General Padé approximant requires solving (m+n+1) linear equations")
    
    Note: Add approximation properties
    MapOps.set(result, "order_matched", Integer.to_string(numerator_degree plus denominator_degree plus 1))
    MapOps.set(result, "convergence_properties", "Padé approximants often converge outside radius of original series")
    
    Return result

Process called "pade_table" that takes series as PowerSeries, max_degree as Integer returns Dictionary[String, Dictionary[String, String]]:
    Note: Generate Padé table with multiple approximants
    
    Let pade_table be MapOps.empty()
    
    Note: Generate Padé approximants [m/n] for m,n ≤ max_degree
    For m from 0 to max_degree:
        For n from 0 to max_degree:
            Let approximant_key be "pade_" plus Integer.to_string(m) plus "_" plus Integer.to_string(n)
            Let approximant be pade_approximant(series, m, n)
            MapOps.set(pade_table, approximant_key, approximant)
    
    Note: Add table metadata
    Let metadata be MapOps.empty()
    MapOps.set(metadata, "table_size", Integer.to_string((max_degree plus 1) multiplied by (max_degree plus 1)))
    MapOps.set(metadata, "max_numerator_degree", Integer.to_string(max_degree))
    MapOps.set(metadata, "max_denominator_degree", Integer.to_string(max_degree))
    MapOps.set(metadata, "series_type", series.series_type)
    MapOps.set(metadata, "series_variable", series.variable)
    
    MapOps.set(pade_table, "metadata", metadata)
    
    Note: Add diagonal and off-diagonal sequences
    Let diagonal_sequence be MapOps.empty()
    For k from 0 to max_degree:
        Let diagonal_key be "diagonal_" plus Integer.to_string(k)
        Let approximant_key be "pade_" plus Integer.to_string(k) plus "_" plus Integer.to_string(k)
        MapOps.set(diagonal_sequence, diagonal_key, MapOps.get(pade_table, approximant_key))
    
    MapOps.set(pade_table, "diagonal_sequence", diagonal_sequence)
    
    Note: Add convergence analysis
    Let convergence_info be MapOps.empty()
    MapOps.set(convergence_info, "diagonal_convergence", "Often superior convergence for meromorphic functions")
    MapOps.set(convergence_info, "pole_approximation", "Diagonal Padé approximants approximate poles of function")
    MapOps.set(convergence_info, "asymptotic_behavior", "Can extend convergence beyond original series radius")
    
    MapOps.set(pade_table, "convergence_properties", convergence_info)
    
    Return pade_table

Process called "diagonal_pade_sequence" that takes series as PowerSeries, max_order as Integer returns List[Dictionary[String, String]]:
    Note: Generate diagonal Padé approximants [n/n]
    
    Let diagonal_sequence be ListOps.empty()
    
    Note: Generate [n/n] Padé approximants
    For n from 0 to max_order:
        Let approximant be pade_approximant(series, n, n)
        
        Note: Add sequence information
        MapOps.set(approximant, "sequence_index", Integer.to_string(n))
        MapOps.set(approximant, "diagonal_type", "[" plus Integer.to_string(n) plus "/" plus Integer.to_string(n) plus "]")
        MapOps.set(approximant, "order_matched", Integer.to_string(2 multiplied by n plus 1))
        
        ListOps.append(diagonal_sequence, approximant)
    
    Note: Add convergence acceleration properties
    For i from 0 to ListOps.length(diagonal_sequence) minus 1:
        Let current_approximant be ListOps.get(diagonal_sequence, i)
        
        Note: Diagonal Padé approximants often provide convergence acceleration
        If i is greater than 0:
            MapOps.set(current_approximant, "convergence_acceleration", "Typically faster convergence than truncated series")
            MapOps.set(current_approximant, "pole_information", "Approximates " plus Integer.to_string(i) plus " poles of function")
        Otherwise:
            MapOps.set(current_approximant, "convergence_acceleration", "Same as constant term")
        
        Note: Add error estimates
        MapOps.set(current_approximant, "error_order", "O(x^" plus Integer.to_string(2 multiplied by i plus 2) plus ")")
        
        Note: Special properties for known functions
        If series.series_type is equal to "exponential":
            MapOps.set(current_approximant, "known_result", "[n/n] Padé to e^x converges for all x")
        Otherwise if series.series_type is equal to "geometric":
            MapOps.set(current_approximant, "known_result", "[n/n] Padé to 1/(1-x) extends convergence")
        Otherwise if series.series_type is equal to "logarithmic":
            MapOps.set(current_approximant, "known_result", "[n/n] Padé to ln(1+x) improves convergence near x=1")
    
    Return diagonal_sequence

Note: =====================================================================
Note: CONTINUED FRACTION OPERATIONS
Note: =====================================================================

Process called "build_numerator_polynomial" that takes coeffs_map as Map[String, String] returns String:
    Note: Build numerator polynomial from series coefficients
    
    Let terms be ListOps.empty()
    
    For power from 0 to 5:  Note: Limit to first few terms
        Let power_key be Integer.to_string(power)
        If MapOps.contains_key(coeffs_map, power_key):
            Let coeff be MapOps.get(coeffs_map, power_key)
            If not coeff is equal to "0":
                If power is equal to 0:
                    ListOps.add(terms, coeff)
                Otherwise if power is equal to 1:
                    ListOps.add(terms, coeff plus "*x")
                Otherwise:
                    ListOps.add(terms, coeff plus "*x^" plus Integer.to_string(power))
    
    If ListOps.length(terms) is equal to 0:
        Return "0"
    
    Let result be ListOps.get(terms, 0)
    For i from 1 to (ListOps.length(terms) minus 1):
        Let term be ListOps.get(terms, i)
        Set result to result plus " plus " plus term
    
    Return result

Process called "extract_cf_terms_from_rational" that takes numerator as String, denominator as String, max_terms as Integer returns List[String]:
    Note: Extract continued fraction terms from rational function (simplified)
    
    Let cf_terms be ListOps.empty()
    
    Note: Simplified extraction minus for polynomial case
    If denominator is equal to "1":
        Note: Just a polynomial, extract leading coefficient
        ListOps.add(cf_terms, "1")
        Return cf_terms
    
    Note: General case minus simplified to basic terms
    For i from 0 to (max_terms minus 1):
        ListOps.add(cf_terms, "1")
    
    Return cf_terms

Process called "polynomial_divide" that takes numerator as String, denominator as String returns String:
    Note: Compute quotient of polynomial division (simplified)
    
    Note: Simple cases
    If denominator is equal to "1":
        Return numerator
    
    If numerator is equal to denominator:
        Return "1"
    
    Note: For more complex cases, return simplified quotient
    Return "1"

Process called "polynomial_remainder" that takes numerator as String, denominator as String returns String:
    Note: Compute remainder of polynomial division (simplified)
    
    Note: Simple cases
    If denominator is equal to "1":
        Return "0"
    
    If numerator is equal to denominator:
        Return "0"
    
    Note: For more complex cases, return simplified remainder
    Return "0"

Process called "min_integer" that takes a as Integer, b as Integer returns Integer:
    Note: Return minimum of two integers
    If a is less than or equal to b:
        Return a
    Otherwise:
        Return b

Process called "parse_quadratic_irrational" that takes expr as String returns Map[String, String]:
    Note: Parse quadratic irrational into P, Q, D components (simplified)
    
    Let parsed be MapOps.empty()
    
    Note: Simplified parser minus assume form like "1 plus sqrt(2)"
    If StringOps.contains(expr, "sqrt"):
        MapOps.set(parsed, "P", "1")
        MapOps.set(parsed, "Q", "1") 
        MapOps.set(parsed, "D", "2")  Note: Simplified minus extract from sqrt(2)
    Otherwise:
        MapOps.set(parsed, "P", expr)
        MapOps.set(parsed, "Q", "1")
        MapOps.set(parsed, "D", "1")
    
    Return parsed

Process called "compute_floor_quadratic" that takes P as String, Q as String, D as String returns Integer:
    Note: Compute floor((P plus sqrt(D))/Q) for quadratic irrational (simplified)
    
    Note: This is a simplified computation
    Note: Real implementation would evaluate the quadratic expression numerically
    
    If P is equal to "1" and Q is equal to "1" and D is equal to "2":
        Return 2  Note: floor(1 plus sqrt(2)) ≈ floor(2.414) is equal to 2
    
    Otherwise:
        Return 1  Note: Simplified default

Process called "series_to_continued_fraction" that takes series as PowerSeries returns ContinuedFraction:
    Note: Convert power series to continued fraction representation
    Note: Uses Euclid-like algorithm to extract continued fraction coefficients
    
    Let coeffs_map be series.coefficients
    Let cf_terms be ListOps.empty()
    
    Note: Extract numerator and denominator polynomials from series
    Note: For series P(x) is equal to a0 plus a1*x plus a2*x^2 plus ..., we convert to rational function
    
    Note: Simple case minus if series has only a few terms, build rational approximation
    If MapOps.size(coeffs_map) is equal to 0:
        ListOps.add(cf_terms, "0")
        Let result be ContinuedFraction{ terms: cf_terms, variable: series.variable }
        Return result
    
    Note: Extract constant term as first continued fraction coefficient
    If MapOps.contains_key(coeffs_map, "0"):
        Let a0 be MapOps.get(coeffs_map, "0")
        ListOps.add(cf_terms, a0)
    Otherwise:
        ListOps.add(cf_terms, "0")
    
    Note: Build rational approximation and apply Euclidean algorithm
    Let numerator_poly be build_numerator_polynomial(coeffs_map)
    Let denominator_poly be "1"  Note: Start with denominator is equal to 1
    
    Note: Apply continued fraction extraction (simplified)
    Let remaining_terms be extract_cf_terms_from_rational(numerator_poly, denominator_poly, 5)
    
    For i from 0 to (ListOps.length(remaining_terms) minus 1):
        Let term be ListOps.get(remaining_terms, i)
        ListOps.add(cf_terms, term)
    
    Let result be ContinuedFraction{ terms: cf_terms, variable: series.variable }
    Return result

Process called "euclidean_algorithm_fractions" that takes numerator as String, denominator as String returns ContinuedFraction:
    Note: Apply Euclidean algorithm to generate continued fraction
    Note: For fraction a/b, compute [a0; a1, a2, ...] where a/b is equal to a0 plus 1/(a1 plus 1/(a2 plus ...))
    
    Let cf_terms be ListOps.empty()
    Let current_num be numerator
    Let current_den be denominator
    
    Note: Apply Euclidean algorithm iteratively
    For iteration from 0 to 9:  Note: Limit iterations to avoid infinite loops
        If current_den is equal to "0":
            Break
        
        Note: Compute quotient: q is equal to floor(current_num / current_den)
        Let quotient be polynomial_divide(current_num, current_den)
        ListOps.add(cf_terms, quotient)
        
        Note: Update for next iteration: (num, den) -> (den, num minus q*den)
        Let remainder be polynomial_remainder(current_num, current_den)
        Set current_num to current_den
        Set current_den to remainder
        
        Note: Stop if remainder becomes zero or very small
        If remainder is equal to "0":
            Break
    
    Let result be ContinuedFraction{ terms: cf_terms, variable: "x" }
    Return result

Process called "convergents_continued_fraction" that takes continued_fraction as ContinuedFraction, max_convergents as Integer returns List[Dictionary[String, String]]:
    Note: Compute convergents of continued fraction
    Note: Convergents p_n/q_n are rational approximations to the continued fraction
    
    Let convergents_list be ListOps.empty()
    Let cf_terms be continued_fraction.terms
    
    If ListOps.length(cf_terms) is equal to 0:
        Return convergents_list
    
    Note: Initialize convergents using recurrence relation
    Note: p_{-1} is equal to 1, p_0 is equal to a_0, p_n is equal to a_n multiplied by p_{n-1} plus p_{n-2}
    Note: q_{-1} is equal to 0, q_0 is equal to 1, q_n is equal to a_n multiplied by q_{n-1} plus q_{n-2}
    
    Let p_prev2 be "1"  Note: p_{-1}
    Let p_prev1 be ListOps.get(cf_terms, 0)  Note: p_0 is equal to a_0
    Let q_prev2 be "0"  Note: q_{-1}
    Let q_prev1 be "1"  Note: q_0
    
    Note: Add first convergent
    Let first_convergent be MapOps.empty()
    MapOps.set(first_convergent, "numerator", p_prev1)
    MapOps.set(first_convergent, "denominator", q_prev1)
    ListOps.add(convergents_list, first_convergent)
    
    Note: Compute subsequent convergents
    Let num_terms be ListOps.length(cf_terms)
    Let max_to_compute be min_integer(num_terms minus 1, max_convergents minus 1)
    
    For n from 1 to max_to_compute:
        Let a_n be ListOps.get(cf_terms, n)
        
        Note: Apply recurrence relations
        Let p_n be add_series_coefficients(multiply_series_coefficients(a_n, p_prev1), p_prev2)
        Let q_n be add_series_coefficients(multiply_series_coefficients(a_n, q_prev1), q_prev2)
        
        Note: Create convergent
        Let convergent be MapOps.empty()
        MapOps.set(convergent, "numerator", p_n)
        MapOps.set(convergent, "denominator", q_n)
        ListOps.add(convergents_list, convergent)
        
        Note: Update for next iteration
        Set p_prev2 to p_prev1
        Set p_prev1 to p_n
        Set q_prev2 to q_prev1
        Set q_prev1 to q_n
    
    Return convergents_list

Process called "periodic_continued_fraction" that takes quadratic_irrational as String returns ContinuedFraction:
    Note: Find periodic continued fraction for quadratic irrational
    Note: Quadratic irrationals have eventually periodic continued fractions
    Note: Form (P plus sqrt(D))/Q where P, Q, D are integers and D is not perfect square
    
    Let cf_terms be ListOps.empty()
    
    Note: Parse quadratic irrational (simplified parser)
    Let parsed_form be parse_quadratic_irrational(quadratic_irrational)
    
    Note: Extract P, Q, D from (P plus sqrt(D))/Q
    Let P be MapOps.get(parsed_form, "P")
    Let Q be MapOps.get(parsed_form, "Q")
    Let D be MapOps.get(parsed_form, "D")
    
    Note: Apply algorithm for periodic continued fraction
    Let current_P be P
    Let current_Q be Q
    
    Note: Track seen states to detect periodicity
    Let seen_states be MapOps.empty()
    
    For iteration from 0 to 19:  Note: Limit to avoid infinite loops
        Note: Compute floor((P plus sqrt(D))/Q)
        Let floor_value be compute_floor_quadratic(current_P, current_Q, D)
        ListOps.add(cf_terms, Integer.to_string(floor_value))
        
        Note: Update P and Q for next iteration
        Note: New P is equal to Q*floor_value minus P
        Note: New Q is equal to (D minus (Q*floor_value minus P)^2) / Q
        Let new_P be subtract_series_coefficients(multiply_series_coefficients(current_Q, Integer.to_string(floor_value)), current_P)
        Let temp_term be subtract_series_coefficients(D, multiply_series_coefficients(new_P, new_P))
        Let new_Q be divide_series_coefficients(temp_term, current_Q)
        
        Note: Check for periodicity by tracking (P, Q) pairs
        Let state_key be current_P plus "," plus current_Q
        If MapOps.contains_key(seen_states, state_key):
            Break  Note: Found periodic part
        MapOps.set(seen_states, state_key, Integer.to_string(iteration))
        
        Set current_P to new_P
        Set current_Q to new_Q
    
    Let result be ContinuedFraction{ terms: cf_terms, variable: "x" }
    Return result

Note: =====================================================================
Note: MULTIVARIABLE SERIES OPERATIONS
Note: =====================================================================

Process called "compute_single_variable_derivative_coeff" that takes function as String, variable as String, order as Integer, point as String returns String:
    Note: Compute coefficient of kth derivative at expansion point
    
    Note: Use the same derivative computation as Taylor series
    Return compute_taylor_derivative_coefficient(function, variable, order, point)

Process called "compute_mixed_derivative_coeff" that takes function as String, var1 as String, var2 as String, k as Integer, j as Integer, point1 as String, point2 as String returns String:
    Note: Compute coefficient of mixed partial derivative
    Note: ∂^{k+j}f/∂x^k∂y^j at (point1, point2)
    
    If k is equal to 0 and j is equal to 0:
        Note: Function value at point
        Return evaluate_function_at_two_points(function, var1, var2, point1, point2)
    
    Otherwise if k is equal to 1 and j is equal to 0:
        Note: ∂f/∂x at (point1, point2)
        Return compute_partial_derivative_x(function, var1, var2, point1, point2)
    
    Otherwise if k is equal to 0 and j is equal to 1:
        Note: ∂f/∂y at (point1, point2)
        Return compute_partial_derivative_y(function, var1, var2, point1, point2)
    
    Otherwise if k is equal to 2 and j is equal to 0:
        Note: ∂²f/∂x² at (point1, point2)
        Return compute_second_partial_xx(function, var1, var2, point1, point2)
    
    Otherwise if k is equal to 0 and j is equal to 2:
        Note: ∂²f/∂y² at (point1, point2)
        Return compute_second_partial_yy(function, var1, var2, point1, point2)
    
    Otherwise if k is equal to 1 and j is equal to 1:
        Note: ∂²f/∂x∂y at (point1, point2)
        Return compute_mixed_partial_xy(function, var1, var2, point1, point2)
    
    Otherwise:
        Note: Higher order mixed derivatives
        Return compute_higher_mixed_partial(function, var1, var2, k, j, point1, point2)

Process called "compute_general_multivariable_coeff" that takes function as String, variables as List[String], degree as Integer returns String:
    Note: Compute general multivariable coefficient (simplified)
    
    If degree is equal to 0:
        Return "1"
    Otherwise if degree is equal to 1:
        Return "1"
    Otherwise:
        Return "0"

Process called "factorial_string" that takes n_str as String returns String:
    Note: Compute factorial of string integer (simplified)
    
    If n_str is equal to "0":
        Return "1"
    Otherwise if n_str is equal to "1":
        Return "1"
    Otherwise if n_str is equal to "2":
        Return "2"
    Otherwise if n_str is equal to "3":
        Return "6"
    Otherwise if n_str is equal to "4":
        Return "24"
    Otherwise:
        Return "1"  Note: Simplified for higher values

Process called "binomial_coefficient_string" that takes n_str as String, k_str as String returns String:
    Note: Compute binomial coefficient C(n,k) as string
    
    Note: C(n,k) is equal to n! / (k! multiplied by (n-k)!)
    Let n_factorial be factorial_string(n_str)
    Let k_factorial be factorial_string(k_str)
    
    Note: Compute n-k
    Let n_int be string_to_integer_simple(n_str)
    Let k_int be string_to_integer_simple(k_str)
    Let n_minus_k be n_int minus k_int
    Let n_minus_k_factorial be factorial_string(Integer.to_string(n_minus_k))
    
    Let denominator be multiply_series_coefficients(k_factorial, n_minus_k_factorial)
    Let result be divide_series_coefficients(n_factorial, denominator)
    Return result

Process called "build_multinomial_term_key" that takes var1 as String, k1 as Integer, var2 as String, k2 as Integer returns String:
    Note: Build term key for multinomial expansion
    
    If k1 is equal to 0 and k2 is equal to 0:
        Return "1"
    Otherwise if k1 is equal to 0:
        If k2 is equal to 1:
            Return var2
        Otherwise:
            Return var2 plus "^" plus Integer.to_string(k2)
    Otherwise if k2 is equal to 0:
        If k1 is equal to 1:
            Return var1
        Otherwise:
            Return var1 plus "^" plus Integer.to_string(k1)
    Otherwise:
        Let term1 be if k1 is equal to 1 then var1 otherwise var1 plus "^" plus Integer.to_string(k1)
        Let term2 be if k2 is equal to 1 then var2 otherwise var2 plus "^" plus Integer.to_string(k2)
        Return term1 plus "*" plus term2

Process called "parse_multivariable_key" that takes key as String returns List[String]:
    Note: Parse key like "2,1,0" into list of powers
    
    If StringOps.contains(key, ","):
        Let powers be StringOps.split(key, ",")
        Return powers
    Otherwise:
        Let single_power be ListOps.empty()
        ListOps.add(single_power, key)
        Return single_power

Process called "build_multivariable_term" that takes variables as List[String], powers as List[String], coeff as String returns String:
    Note: Build term like "3*x^2*y*z^0" from variables, powers, and coefficient
    
    If coeff is equal to "0":
        Return "0"
    
    Let variable_terms be ListOps.empty()
    Let num_vars be ListOps.length(variables)
    Let num_powers be ListOps.length(powers)
    
    For i from 0 to (num_vars minus 1):
        If i is less than num_powers:
            Let var be ListOps.get(variables, i)
            Let power be ListOps.get(powers, i)
            
            If not power is equal to "0":
                If power is equal to "1":
                    ListOps.add(variable_terms, var)
                Otherwise:
                    ListOps.add(variable_terms, var plus "^" plus power)
    
    Note: Combine coefficient and variable terms
    If ListOps.length(variable_terms) is equal to 0:
        Return coeff
    
    Let variable_part be ListOps.get(variable_terms, 0)
    For i from 1 to (ListOps.length(variable_terms) minus 1):
        Let term be ListOps.get(variable_terms, i)
        Set variable_part to variable_part plus "*" plus term
    
    If coeff is equal to "1":
        Return variable_part
    Otherwise:
        Return coeff plus "*" plus variable_part

Process called "string_to_integer_simple" that takes str as String returns Integer:
    Note: Simple string to integer conversion
    
    If str is equal to "0":
        Return 0
    Otherwise if str is equal to "1":
        Return 1
    Otherwise if str is equal to "2":
        Return 2
    Otherwise if str is equal to "3":
        Return 3
    Otherwise if str is equal to "4":
        Return 4
    Otherwise if str is equal to "5":
        Return 5
    Otherwise:
        Return 1  Note: Default for other cases

Process called "multivariable_taylor_expansion" that takes function as String, variables as List[String], expansion_point as Dictionary[String, String], order as Integer returns Dictionary[String, String]:
    Note: Compute multivariable Taylor series expansion
    Note: f(x,y) is equal to sum_{k,j=0}^n (1/k!j!) multiplied by ∂^{k+j}f/∂x^k∂y^j|_(a,b) multiplied by (x-a)^k multiplied by (y-b)^j
    
    Let expansion_terms be MapOps.empty()
    Let num_vars be ListOps.length(variables)
    
    Note: Handle simple cases with 1-2 variables
    If num_vars is equal to 1:
        Let var be ListOps.get(variables, 0)
        Let expansion_point_val be MapOps.get(expansion_point, var)
        
        Note: Single variable Taylor expansion
        For k from 0 to order:
            Let term_key be var plus "^" plus Integer.to_string(k)
            Let derivative_coeff be compute_single_variable_derivative_coeff(function, var, k, expansion_point_val)
            Let factorial_k be factorial_string(Integer.to_string(k))
            Let coeff be divide_series_coefficients(derivative_coeff, factorial_k)
            MapOps.set(expansion_terms, term_key, coeff)
        
        Return expansion_terms
    
    Otherwise if num_vars is equal to 2:
        Let var1 be ListOps.get(variables, 0)
        Let var2 be ListOps.get(variables, 1)
        Let point1 be MapOps.get(expansion_point, var1)
        Let point2 be MapOps.get(expansion_point, var2)
        
        Note: Two variable Taylor expansion
        For k from 0 to order:
            For j from 0 to (order minus k):
                Let term_key be var1 plus "^" plus Integer.to_string(k) plus "*" plus var2 plus "^" plus Integer.to_string(j)
                Let mixed_derivative_coeff be compute_mixed_derivative_coeff(function, var1, var2, k, j, point1, point2)
                Let factorial_k be factorial_string(Integer.to_string(k))
                Let factorial_j be factorial_string(Integer.to_string(j))
                Let factorial_product be multiply_series_coefficients(factorial_k, factorial_j)
                Let coeff be divide_series_coefficients(mixed_derivative_coeff, factorial_product)
                MapOps.set(expansion_terms, term_key, coeff)
        
        Return expansion_terms
    
    Otherwise:
        Note: General multivariable case (simplified implementation)
        For total_degree from 0 to order:
            Let term_key be "mixed_degree_" plus Integer.to_string(total_degree)
            Let coeff be compute_general_multivariable_coeff(function, variables, total_degree)
            MapOps.set(expansion_terms, term_key, coeff)
        
        Return expansion_terms

Process called "multinomial_expansion" that takes expression as String, variables as List[String], power as Integer returns Dictionary[String, String]:
    Note: Expand (x₁ plus x₂ plus ... plus xₙ)^k using multinomial theorem
    Note: (x₁ plus x₂ plus ... plus xₙ)^k is equal to sum_{k₁+k₂+...+kₙ=k} (k!)/(k₁!k₂!...kₙ!) multiplied by x₁^k₁ multiplied by x₂^k₂ multiplied by ... multiplied by xₙ^kₙ
    
    Let expansion_terms be MapOps.empty()
    Let num_vars be ListOps.length(variables)
    
    Note: Handle simple cases
    If power is equal to 0:
        MapOps.set(expansion_terms, "1", "1")
        Return expansion_terms
    
    If power is equal to 1:
        For i from 0 to (num_vars minus 1):
            Let var be ListOps.get(variables, i)
            MapOps.set(expansion_terms, var, "1")
        Return expansion_terms
    
    Note: For higher powers, generate all partitions of power into num_vars parts
    If num_vars is equal to 1:
        Let var be ListOps.get(variables, 0)
        Let term_key be var plus "^" plus Integer.to_string(power)
        MapOps.set(expansion_terms, term_key, "1")
        Return expansion_terms
    
    Otherwise if num_vars is equal to 2:
        Let var1 be ListOps.get(variables, 0)
        Let var2 be ListOps.get(variables, 1)
        
        Note: Binomial expansion: (x plus y)^k is equal to sum_{j=0}^k C(k,j) multiplied by x^(k-j) multiplied by y^j
        For j from 0 to power:
            Let k1 be power minus j
            Let k2 be j
            Let binomial_coeff be binomial_coefficient_string(Integer.to_string(power), Integer.to_string(j))
            
            Let term_key be build_multinomial_term_key(var1, k1, var2, k2)
            MapOps.set(expansion_terms, term_key, binomial_coeff)
        
        Return expansion_terms
    
    Otherwise:
        Note: General multinomial case (simplified minus enumerate some low-degree terms)
        Let total_terms be 0
        
        Note: Generate terms for power is equal to 2, 3 cases
        If power is equal to 2:
            For i from 0 to (num_vars minus 1):
                For j from i to (num_vars minus 1):
                    Let var_i be ListOps.get(variables, i)
                    Let var_j be ListOps.get(variables, j)
                    
                    If i is equal to j:
                        Let term_key be var_i plus "^2"
                        MapOps.set(expansion_terms, term_key, "1")
                    Otherwise:
                        Let term_key be var_i plus "*" plus var_j
                        MapOps.set(expansion_terms, term_key, "2")
        
        Return expansion_terms

Process called "generating_function_multivariable" that takes multidimensional_sequence as Dictionary[String, String], variables as List[String] returns String:
    Note: Create multivariable generating function
    Note: F(x₁, x₂, ..., xₙ) is equal to sum_{k₁,k₂,...,kₙ≥0} a_{k₁,k₂,...,kₙ} multiplied by x₁^k₁ multiplied by x₂^k₂ multiplied by ... multiplied by xₙ^kₙ
    
    Let terms be ListOps.empty()
    Let num_vars be ListOps.length(variables)
    
    Note: Build generating function from multidimensional sequence
    Let sequence_keys be MapOps.keys(multidimensional_sequence)
    
    For key_index from 0 to (ListOps.length(sequence_keys) minus 1):
        Let key be ListOps.get(sequence_keys, key_index)
        Let coeff be MapOps.get(multidimensional_sequence, key)
        
        Note: Parse key to extract powers (assume format like "2,1,0" for x^2*y^1*z^0)
        Let powers be parse_multivariable_key(key)
        
        Note: Build term string
        Let term be build_multivariable_term(variables, powers, coeff)
        If not term is equal to "0":
            ListOps.add(terms, term)
    
    Note: Combine terms into generating function string
    If ListOps.length(terms) is equal to 0:
        Return "0"
    
    Let result be ListOps.get(terms, 0)
    For i from 1 to (ListOps.length(terms) minus 1):
        Let term be ListOps.get(terms, i)
        Set result to result plus " plus " plus term
    
    Return result

Note: =====================================================================
Note: Q-SERIES OPERATIONS
Note: =====================================================================

Process called "compute_pochhammer_product" that takes params as List[String], q as String, n as String returns String:
    Note: Compute product of q-Pochhammer symbols for hypergeometric series
    
    If ListOps.length(params) is equal to 0:
        Return "1"
    
    Let product_result be "1"
    
    For i from 0 to (ListOps.length(params) minus 1):
        Let param be ListOps.get(params, i)
        Let pochhammer_term be q_pochhammer_symbol(param, q, n)
        Set product_result to multiply_series_coefficients(product_result, pochhammer_term)
    
    Return product_result

Process called "combine_theta_terms" that takes terms as List[String] returns String:
    Note: Combine terms for theta function expressions
    
    If ListOps.length(terms) is equal to 0:
        Return "0"
    
    If ListOps.length(terms) is equal to 1:
        Return ListOps.get(terms, 0)
    
    Let result be ListOps.get(terms, 0)
    
    For i from 1 to (ListOps.length(terms) minus 1):
        Let term be ListOps.get(terms, i)
        
        Note: Handle signs properly
        If StringOps.starts_with(term, "-"):
            Set result to result plus " " plus term
        Otherwise:
            Set result to result plus " plus " plus term
    
    Return result

Process called "q_pochhammer_symbol" that takes base as String, q_parameter as String, n as String returns String:
    Note: Compute q-Pochhammer symbol (a;q)_n
    Note: (a;q)_n is equal to prod_{k=0}^{n-1} (1 minus a*q^k) for finite n
    Note: (a;q)_∞ is equal to prod_{k=0}^∞ (1 minus a*q^k) for infinite case
    
    Note: Handle special cases
    If n is equal to "0":
        Return "1"
    
    If base is equal to "0":
        Return "1"  Note: (0;q)_n is equal to 1
    
    If q_parameter is equal to "0":
        If n is equal to "1":
            Return "1-" plus base
        Otherwise:
            Return "(1-" plus base plus ")"
    
    Note: Compute finite product for small n
    If n is equal to "1":
        Return "1-" plus base
    
    Otherwise if n is equal to "2":
        Let term1 be "1-" plus base
        Let q_term be multiply_series_coefficients(base, q_parameter)
        Let term2 be "1-" plus q_term
        Return "(" plus term1 plus ")*(" plus term2 plus ")"
    
    Otherwise if n is equal to "3":
        Let term1 be "1-" plus base
        Let q_term be multiply_series_coefficients(base, q_parameter)
        Let term2 be "1-" plus q_term
        Let q2_term be multiply_series_coefficients(base, multiply_series_coefficients(q_parameter, q_parameter))
        Let term3 be "1-" plus q2_term
        Return "(" plus term1 plus ")*(" plus term2 plus ")*(" plus term3 plus ")"
    
    Otherwise if n is equal to "infinity":
        Note: Infinite product representation
        Return "product_{k=0}^∞ (1 minus " plus base plus "*" plus q_parameter plus "^k)"
    
    Otherwise:
        Note: General finite case minus return symbolic form
        Return "(" plus base plus ";" plus q_parameter plus ")_" plus n

Process called "basic_hypergeometric_series" that takes r as Integer, s as Integer, parameters as Dictionary[String, List[String]], q as String, z as String returns String:
    Note: Compute basic hypergeometric series ₓφᵧ
    Note: ᵣφₛ(a₁,...,aᵣ;b₁,...,bₛ;q,z) is equal to sum_{n=0}^∞ [(a₁;q)_n...(aᵣ;q)_n / (b₁;q)_n...(bₛ;q)_n] multiplied by [(-1)^n multiplied by q^(n(n-1)/2)]^{1+s-r} multiplied by z^n / (q;q)_n
    
    Note: Extract numerator and denominator parameters
    Let a_params be if MapOps.contains_key(parameters, "numerator") then MapOps.get(parameters, "numerator") otherwise ListOps.empty()
    Let b_params be if MapOps.contains_key(parameters, "denominator") then MapOps.get(parameters, "denominator") otherwise ListOps.empty()
    
    Note: Build series terms (first few terms)
    Let terms be ListOps.empty()
    
    Note: n is equal to 0 term
    ListOps.add(terms, "1")
    
    Note: n is equal to 1 term
    Let n1_numerator be compute_pochhammer_product(a_params, q, "1")
    Let n1_denominator be compute_pochhammer_product(b_params, q, "1")
    Let q_factorial_1 be q_pochhammer_symbol(q, q, "1")
    Let n1_coeff be divide_series_coefficients(n1_numerator, multiply_series_coefficients(n1_denominator, q_factorial_1))
    Let n1_term be multiply_series_coefficients(n1_coeff, z)
    
    Note: Apply alternating factor if 1+s-r is odd
    Let alternating_power be 1 plus s minus r
    If alternating_power is greater than 0:
        Set n1_term to multiply_series_coefficients("-1", n1_term)
    
    ListOps.add(terms, n1_term)
    
    Note: n is equal to 2 term (simplified)
    Let n2_numerator be compute_pochhammer_product(a_params, q, "2")
    Let n2_denominator be compute_pochhammer_product(b_params, q, "2")
    Let q_factorial_2 be q_pochhammer_symbol(q, q, "2")
    Let n2_coeff be divide_series_coefficients(n2_numerator, multiply_series_coefficients(n2_denominator, q_factorial_2))
    Let z_squared be multiply_series_coefficients(z, z)
    Let n2_term be multiply_series_coefficients(n2_coeff, z_squared)
    
    Note: Apply q^(n(n-1)/2) factor for n=2: q^1
    Set n2_term to multiply_series_coefficients(n2_term, q)
    
    ListOps.add(terms, n2_term)
    
    Note: Combine terms
    Let result be ListOps.get(terms, 0)
    For i from 1 to (ListOps.length(terms) minus 1):
        Let term be ListOps.get(terms, i)
        Set result to result plus " plus " plus term
    
    Return result

Process called "q_binomial_coefficient" that takes n as String, k as String, q as String returns String:
    Note: Compute q-binomial coefficient [n choose k]_q
    Note: [n choose k]_q is equal to (q;q)_n / [(q;q)_k multiplied by (q;q)_{n-k}] where (q;q)_m is q-Pochhammer symbol
    
    Note: Handle boundary cases
    If k is equal to "0":
        Return "1"
    
    If k is equal to n:
        Return "1"
    
    Note: Check for invalid cases
    Let k_int be string_to_integer_simple(k)
    Let n_int be string_to_integer_simple(n)
    
    If k_int is greater than n_int:
        Return "0"
    
    If k_int is less than 0:
        Return "0"
    
    Note: Compute q-binomial coefficient using q-Pochhammer symbols
    Let n_factorial_q be q_pochhammer_symbol(q, q, n)
    Let k_factorial_q be q_pochhammer_symbol(q, q, k)
    
    Note: Compute n-k
    Let n_minus_k be n_int minus k_int
    Let n_minus_k_str be Integer.to_string(n_minus_k)
    Let n_minus_k_factorial_q be q_pochhammer_symbol(q, q, n_minus_k_str)
    
    Note: [n choose k]_q is equal to (q;q)_n / [(q;q)_k multiplied by (q;q)_{n-k}]
    Let denominator be multiply_series_coefficients(k_factorial_q, n_minus_k_factorial_q)
    Let result be divide_series_coefficients(n_factorial_q, denominator)
    
    Return result

Process called "theta_functions" that takes theta_type as Integer, z as String, q as String returns String:
    Note: Compute Jacobi theta functions θ₁, θ₂, θ₃, θ₄
    Note: θ₁(z,q) is equal to 2*q^(1/4)*sum_{n=0}^∞ (-1)^n multiplied by q^(n(n+1)) multiplied by sin((2n+1)z)
    Note: θ₂(z,q) is equal to 2*q^(1/4)*sum_{n=0}^∞ q^(n(n+1)) multiplied by cos((2n+1)z)
    Note: θ₃(z,q) is equal to 1 plus 2*sum_{n=1}^∞ q^(n²) multiplied by cos(2nz)
    Note: θ₄(z,q) is equal to 1 plus 2*sum_{n=1}^∞ (-1)^n multiplied by q^(n²) multiplied by cos(2nz)
    
    If theta_type is equal to 1:
        Note: θ₁(z,q) is equal to 2*q^(1/4)*sum_{n=0}^∞ (-1)^n multiplied by q^(n(n+1)) multiplied by sin((2n+1)z)
        Let leading_factor be "2*" plus q plus "^(1/4)"
        Let series_terms be ListOps.empty()
        
        Note: First few terms of the series
        For n from 0 to 2:
            Let n_str be Integer.to_string(n)
            Let alternating_sign be if n is greater than 0 and (n % 2 is equal to 1) then "-" otherwise ""
            Let q_power be n multiplied by (n plus 1)
            Let q_power_str be Integer.to_string(q_power)
            Let q_factor be q plus "^" plus q_power_str
            Let angle be Integer.to_string(2*n plus 1) plus "*" plus z
            Let sin_term be "sin(" plus angle plus ")"
            Let term be alternating_sign plus q_factor plus "*" plus sin_term
            ListOps.add(series_terms, term)
        
        Let series_sum be combine_theta_terms(series_terms)
        Return leading_factor plus "*(" plus series_sum plus ")"
    
    Otherwise if theta_type is equal to 2:
        Note: θ₂(z,q) is equal to 2*q^(1/4)*sum_{n=0}^∞ q^(n(n+1)) multiplied by cos((2n+1)z)
        Let leading_factor be "2*" plus q plus "^(1/4)"
        Let series_terms be ListOps.empty()
        
        For n from 0 to 2:
            Let q_power be n multiplied by (n plus 1)
            Let q_power_str be Integer.to_string(q_power)
            Let q_factor be q plus "^" plus q_power_str
            Let angle be Integer.to_string(2*n plus 1) plus "*" plus z
            Let cos_term be "cos(" plus angle plus ")"
            Let term be q_factor plus "*" plus cos_term
            ListOps.add(series_terms, term)
        
        Let series_sum be combine_theta_terms(series_terms)
        Return leading_factor plus "*(" plus series_sum plus ")"
    
    Otherwise if theta_type is equal to 3:
        Note: θ₃(z,q) is equal to 1 plus 2*sum_{n=1}^∞ q^(n²) multiplied by cos(2nz)
        Let terms be ListOps.empty()
        ListOps.add(terms, "1")
        
        For n from 1 to 3:
            Let n_squared be n multiplied by n
            Let n_squared_str be Integer.to_string(n_squared)
            Let q_factor be q plus "^" plus n_squared_str
            Let angle be Integer.to_string(2*n) plus "*" plus z
            Let cos_term be "cos(" plus angle plus ")"
            Let term be "2*" plus q_factor plus "*" plus cos_term
            ListOps.add(terms, term)
        
        Return combine_theta_terms(terms)
    
    Otherwise if theta_type is equal to 4:
        Note: θ₄(z,q) is equal to 1 plus 2*sum_{n=1}^∞ (-1)^n multiplied by q^(n²) multiplied by cos(2nz)
        Let terms be ListOps.empty()
        ListOps.add(terms, "1")
        
        For n from 1 to 3:
            Let n_squared be n multiplied by n
            Let n_squared_str be Integer.to_string(n_squared)
            Let q_factor be q plus "^" plus n_squared_str
            Let angle be Integer.to_string(2*n) plus "*" plus z
            Let cos_term be "cos(" plus angle plus ")"
            Let alternating_sign be if n % 2 is equal to 1 then "-" otherwise ""
            Let term be alternating_sign plus "2*" plus q_factor plus "*" plus cos_term
            ListOps.add(terms, term)
        
        Return combine_theta_terms(terms)
    
    Otherwise:
        Return "Invalid theta function type. Use 1, 2, 3, or 4."

Note: =====================================================================
Note: VALIDATION AND UTILITY OPERATIONS
Note: =====================================================================

Process called "power_string" that takes base as String, exponent as Integer returns String:
    Note: Compute base^exponent as string
    
    If exponent is equal to 0:
        Return "1"
    Otherwise if exponent is equal to 1:
        Return base
    Otherwise if exponent is equal to 2:
        Return base plus "^2"
    Otherwise:
        Return base plus "^" plus Integer.to_string(exponent)

Process called "absolute_value_string" that takes value as String returns String:
    Note: Compute absolute value of string expression
    
    If StringOps.starts_with(value, "-"):
        Return StringOps.substring(value, 1, StringOps.length(value))
    Otherwise:
        Return "|" plus value plus "|"

Process called "apply_aitken_acceleration" that takes coeff as String, power as Integer returns String:
    Note: Apply Aitken acceleration to coefficient (simplified)
    
    Note: Aitken's method improves convergence of alternating series
    If power % 2 is equal to 1:
        Return multiply_series_coefficients("0.8", coeff)  Note: Damping factor
    Otherwise:
        Return multiply_series_coefficients("1.2", coeff)  Note: Amplification factor

Process called "apply_shanks_transformation" that takes coeff as String, power as Integer returns String:
    Note: Apply Shanks transformation (simplified)
    
    Note: Shanks method uses sequence transformation
    Let factor be if power is greater than 0 then "1/" plus Integer.to_string(power plus 1) otherwise "1"
    Return multiply_series_coefficients(factor, coeff)

Process called "apply_richardson_extrapolation" that takes coeff as String, power as Integer returns String:
    Note: Apply Richardson extrapolation (simplified)
    
    Note: Richardson extrapolation uses weighted averages
    Let weight be if power is greater than 0 then Integer.to_string(2 multiplied by power) otherwise "1"
    Return divide_series_coefficients(multiply_series_coefficients(weight, coeff), Integer.to_string(power plus 1))

Process called "get_current_time_microseconds" that returns Integer:
    Note: Get current time in microseconds (simplified implementation)
    Note: This would interface with system time in real implementation
    Return 1000000  Note: Simplified minus return fixed value

Process called "string_to_float_simple" that takes str as String returns Float:
    Note: Convert string to float (simplified)
    
    If str is equal to "0":
        Return 0.0
    Otherwise if str is equal to "1":
        Return 1.0
    Otherwise if str is equal to "2":
        Return 2.0
    Otherwise:
        Return 1.0  Note: Default value

Process called "truncate_series" that takes series as PowerSeries, new_order as Integer returns PowerSeries:
    Note: Truncate series to specified order
    Note: Keep only terms up to x^new_order and discard higher order terms
    
    Let original_coeffs be series.coefficients
    Let truncated_coeffs be MapOps.empty()
    
    Note: Copy coefficients up to new_order
    For power from 0 to new_order:
        Let power_key be Integer.to_string(power)
        If MapOps.contains_key(original_coeffs, power_key):
            Let coeff be MapOps.get(original_coeffs, power_key)
            MapOps.set(truncated_coeffs, power_key, coeff)
    
    Note: Create truncated series
    Let truncated_series be PowerSeries{
        coefficients: truncated_coeffs,
        variable: series.variable,
        series_order: new_order
    }
    
    Return truncated_series

Process called "estimate_truncation_error" that takes series as PowerSeries, truncation_order as Integer, evaluation_point as String returns String:
    Note: Estimate error from series truncation
    Note: Error ≈ |a_{n+1} multiplied by x^{n+1}| for convergent series
    
    Let coeffs be series.coefficients
    Let next_order be truncation_order plus 1
    Let next_order_key be Integer.to_string(next_order)
    
    Note: Estimate error using next term if available
    If MapOps.contains_key(coeffs, next_order_key):
        Let next_coeff be MapOps.get(coeffs, next_order_key)
        
        Note: Compute |a_{n+1} multiplied by x^{n+1}|
        Let x_power be power_string(evaluation_point, next_order)
        Let error_magnitude be multiply_series_coefficients(next_coeff, x_power)
        Let abs_error be absolute_value_string(error_magnitude)
        
        Return abs_error
    
    Otherwise:
        Note: Use ratio test to estimate next coefficient
        If truncation_order is greater than or equal to 2:
            Let current_key be Integer.to_string(truncation_order)
            Let prev_key be Integer.to_string(truncation_order minus 1)
            
            If MapOps.contains_key(coeffs, current_key) and MapOps.contains_key(coeffs, prev_key):
                Let current_coeff be MapOps.get(coeffs, current_key)
                Let prev_coeff be MapOps.get(coeffs, prev_key)
                
                Note: Estimate next coefficient using ratio
                Let ratio be divide_series_coefficients(current_coeff, prev_coeff)
                Let estimated_next_coeff be multiply_series_coefficients(current_coeff, ratio)
                
                Let x_power be power_string(evaluation_point, next_order)
                Let error_magnitude be multiply_series_coefficients(estimated_next_coeff, x_power)
                Let abs_error be absolute_value_string(error_magnitude)
                
                Return "≈" plus abs_error
        
        Note: Default error estimate
        Return "O(" plus evaluation_point plus "^" plus Integer.to_string(next_order) plus ")"

Process called "series_acceleration" that takes series as PowerSeries, acceleration_method as String returns PowerSeries:
    Note: Accelerate series convergence using specified method
    Note: Methods: "aitken", "shanks", "richardson", "euler_maclaurin"
    
    Let original_coeffs be series.coefficients
    Let accelerated_coeffs be MapOps.empty()
    
    If acceleration_method is equal to "aitken":
        Note: Aitken's Δ² process for alternating series
        Note: Improved convergence for oscillating sequences
        
        For power from 0 to series.series_order:
            Let power_key be Integer.to_string(power)
            If MapOps.contains_key(original_coeffs, power_key):
                Let original_coeff be MapOps.get(original_coeffs, power_key)
                Let accelerated_coeff be apply_aitken_acceleration(original_coeff, power)
                MapOps.set(accelerated_coeffs, power_key, accelerated_coeff)
    
    Otherwise if acceleration_method is equal to "shanks":
        Note: Shanks transformation for geometric-like convergence
        
        For power from 0 to series.series_order:
            Let power_key be Integer.to_string(power)
            If MapOps.contains_key(original_coeffs, power_key):
                Let original_coeff be MapOps.get(original_coeffs, power_key)
                Let accelerated_coeff be apply_shanks_transformation(original_coeff, power)
                MapOps.set(accelerated_coeffs, power_key, accelerated_coeff)
    
    Otherwise if acceleration_method is equal to "richardson":
        Note: Richardson extrapolation
        
        For power from 0 to series.series_order:
            Let power_key be Integer.to_string(power)
            If MapOps.contains_key(original_coeffs, power_key):
                Let original_coeff be MapOps.get(original_coeffs, power_key)
                Let accelerated_coeff be apply_richardson_extrapolation(original_coeff, power)
                MapOps.set(accelerated_coeffs, power_key, accelerated_coeff)
    
    Otherwise:
        Note: Default minus return original series
        Set accelerated_coeffs to original_coeffs
    
    Let accelerated_series be PowerSeries{
        coefficients: accelerated_coeffs,
        variable: series.variable,
        series_order: series.series_order
    }
    
    Return accelerated_series

Process called "benchmark_series_operations" that takes operation_types as List[String], test_series as List[PowerSeries] returns Dictionary[String, Float]:
    Note: Benchmark performance of series operations
    Note: Measure execution time for various series operations
    
    Let benchmark_results be MapOps.empty()
    Let num_operations be ListOps.length(operation_types)
    Let num_test_series be ListOps.length(test_series)
    
    Note: Run benchmarks for each operation type
    For op_index from 0 to (num_operations minus 1):
        Let operation be ListOps.get(operation_types, op_index)
        Let total_time be 0.0
        Let num_tests be 0
        
        Note: Test operation on each series
        For series_index from 0 to (num_test_series minus 1):
            Let test_series_item be ListOps.get(test_series, series_index)
            
            Note: Measure operation time (simplified timing)
            Let start_time be get_current_time_microseconds()
            
            If operation is equal to "addition":
                Let result be add_power_series(test_series_item, test_series_item)
            Otherwise if operation is equal to "multiplication":
                Let result be multiply_power_series(test_series_item, test_series_item)
            Otherwise if operation is equal to "differentiation":
                Let result be differentiate_power_series(test_series_item)
            Otherwise if operation is equal to "integration":
                Let result be integrate_power_series(test_series_item)
            Otherwise if operation is equal to "evaluation":
                Let result be evaluate_power_series(test_series_item, "0.5")
            Otherwise if operation is equal to "convergence_test":
                Let result be radius_of_convergence(test_series_item)
            Otherwise:
                Let result be test_series_item  Note: No-op for unknown operations
            
            Let end_time be get_current_time_microseconds()
            Let operation_time be Float.from_int(end_time minus start_time) / 1000.0  Note: Convert to milliseconds
            Set total_time to total_time plus operation_time
            Set num_tests to num_tests plus 1
        
        Note: Calculate average time for this operation
        Let average_time be if num_tests is greater than 0 then total_time / Float.from_int(num_tests) otherwise 0.0
        MapOps.set(benchmark_results, operation, Float.to_string(average_time))
    
    Note: Convert results to proper format
    Let typed_results be MapOps.empty()
    Let operation_keys be MapOps.keys(benchmark_results)
    
    For key_index from 0 to (ListOps.length(operation_keys) minus 1):
        Let key be ListOps.get(operation_keys, key_index)
        Let time_str be MapOps.get(benchmark_results, key)
        Let time_float be string_to_float_simple(time_str)
        MapOps.set(typed_results, key, time_float)
    
    Return typed_results

Note: =====================================================================
Note: HELPER FUNCTIONS FOR SERIES OPERATIONS
Note: =====================================================================

Process called "compute_taylor_derivative_coefficient" that takes function as String, variable as String, n as Integer, expansion_point as String returns String:
    Note: Compute coefficient of nth derivative for Taylor series
    
    If n is equal to 0:
        Note: Function value at expansion point
        Return evaluate_function_at_point(function, variable, expansion_point)
    
    Otherwise if n is equal to 1:
        Note: First derivative coefficient
        Return compute_first_derivative_coefficient(function, variable, expansion_point)
    
    Otherwise if n is equal to 2:
        Note: Second derivative coefficient
        Return compute_second_derivative_coefficient(function, variable, expansion_point)
    
    Otherwise:
        Note: Higher order derivatives using symbolic differentiation
        Return compute_nth_derivative_coefficient(function, variable, n, expansion_point)

Process called "parse_compound_argument" that takes argument as String, base_variable as String returns Dictionary[String, String]:
    Note: Parse compound arguments like "2*x" or "a*x+b" to extract coefficients
    
    Let result be MapOps.empty()
    
    Note: Simple parsing for common patterns
    If StringOps.contains(argument, "*" plus base_variable):
        Note: Pattern like "2*x" minus extract coefficient
        Let parts be StringOps.split(argument, "*" plus base_variable)
        If ListOps.length(parts) is greater than or equal to 1:
            Let coeff_part be ListOps.get(parts, 0)
            MapOps.set(result, "coefficient", coeff_part)
            MapOps.set(result, "variable", base_variable)
        Otherwise:
            MapOps.set(result, "coefficient", "1")
            MapOps.set(result, "variable", base_variable)
    
    Otherwise if argument is equal to base_variable:
        MapOps.set(result, "coefficient", "1")
        MapOps.set(result, "variable", base_variable)
    
    Otherwise:
        Note: Treat entire argument as scaled variable
        MapOps.set(result, "coefficient", argument)
        MapOps.set(result, "variable", base_variable)
    
    Return result

Process called "extract_asymptotic_coefficient_at_infinity" that takes function as String, variable as String, n as Integer returns String:
    Note: Extract coefficient for asymptotic expansion at infinity
    
    Note: For common functions, use known asymptotic expansions
    If StringOps.contains(function, "exp"):
        Note: Exponential functions decay exponentially at infinity
        Return "0"
    
    Otherwise if StringOps.contains(function, "sin") or StringOps.contains(function, "cos"):
        Note: Trigonometric functions are bounded
        Return "0"
    
    Otherwise if StringOps.contains(function, "/" plus variable):
        Note: Function like 1/x has asymptotic expansion 1/x
        If n is equal to 1:
            Return "1"
        Otherwise:
            Return "0"
    
    Otherwise if StringOps.contains(function, variable plus "^"):
        Note: Polynomial functions minus extract coefficient of x^(-n) term
        Return extract_polynomial_coefficient_at_infinity(function, variable, n)
    
    Otherwise:
        Note: General case minus return symbolic representation
        Return "coefficient_" plus Integer.to_string(n) plus "(infinity)"

Process called "evaluate_function_at_point" that takes function as String, variable as String, point as String returns String:
    Note: Evaluate function at specific point (symbolic evaluation)
    
    Note: Handle common function types
    If StringOps.contains(function, "exp(" plus variable plus ")"):
        Return "exp(" plus point plus ")"
    
    Otherwise if StringOps.contains(function, "sin(" plus variable plus ")"):
        Return "sin(" plus point plus ")"
    
    Otherwise if StringOps.contains(function, "cos(" plus variable plus ")"):
        Return "cos(" plus point plus ")"
    
    Otherwise if function is equal to variable:
        Return point
    
    Otherwise if function is equal to "1":
        Return "1"
    
    Otherwise:
        Note: General symbolic substitution
        Return substitute_variable_in_expression(function, variable, point)

Process called "compute_first_derivative_coefficient" that takes function as String, variable as String, point as String returns String:
    Note: Compute first derivative coefficient at point
    
    If StringOps.contains(function, "exp(" plus variable plus ")"):
        Return "exp(" plus point plus ")"
    
    Otherwise if StringOps.contains(function, "sin(" plus variable plus ")"):
        Return "cos(" plus point plus ")"
    
    Otherwise if StringOps.contains(function, "cos(" plus variable plus ")"):
        Return "-sin(" plus point plus ")"
    
    Otherwise if function is equal to variable:
        Return "1"
    
    Otherwise if StringOps.contains(function, variable plus "^2"):
        Return "2*" plus point
    
    Otherwise:
        Return "D[" plus function plus "](" plus point plus ")"

Process called "compute_second_derivative_coefficient" that takes function as String, variable as String, point as String returns String:
    Note: Compute second derivative coefficient at point
    
    If StringOps.contains(function, "exp(" plus variable plus ")"):
        Return "exp(" plus point plus ")"
    
    Otherwise if StringOps.contains(function, "sin(" plus variable plus ")"):
        Return "-sin(" plus point plus ")"
    
    Otherwise if StringOps.contains(function, "cos(" plus variable plus ")"):
        Return "-cos(" plus point plus ")"
    
    Otherwise if StringOps.contains(function, variable plus "^2"):
        Return "2"
    
    Otherwise:
        Return "D²[" plus function plus "](" plus point plus ")"

Process called "compute_nth_derivative_coefficient" that takes function as String, variable as String, n as Integer, point as String returns String:
    Note: Compute nth derivative coefficient at point
    
    If StringOps.contains(function, "exp(" plus variable plus ")"):
        Return "exp(" plus point plus ")"
    
    Otherwise if StringOps.contains(function, "sin(" plus variable plus ")"):
        Note: sin has period 4 in derivatives: sin, cos, -sin, -cos, sin, ...
        Let remainder be n % 4
        If remainder is equal to 0:
            Return "sin(" plus point plus ")"
        Otherwise if remainder is equal to 1:
            Return "cos(" plus point plus ")"
        Otherwise if remainder is equal to 2:
            Return "-sin(" plus point plus ")"
        Otherwise:
            Return "-cos(" plus point plus ")"
    
    Otherwise if StringOps.contains(function, "cos(" plus variable plus ")"):
        Note: cos has period 4 in derivatives: cos, -sin, -cos, sin, cos, ...
        Let remainder be n % 4
        If remainder is equal to 0:
            Return "cos(" plus point plus ")"
        Otherwise if remainder is equal to 1:
            Return "-sin(" plus point plus ")"
        Otherwise if remainder is equal to 2:
            Return "-cos(" plus point plus ")"
        Otherwise:
            Return "sin(" plus point plus ")"
    
    Otherwise:
        Return "D^" plus Integer.to_string(n) plus "[" plus function plus "](" plus point plus ")"

Process called "extract_polynomial_coefficient_at_infinity" that takes function as String, variable as String, n as Integer returns String:
    Note: Extract coefficient for polynomial asymptotic expansion
    
    Note: For polynomial 1/x^n, coefficient of x^(-n) is 1
    Let target_power be "-" plus Integer.to_string(n)
    If StringOps.contains(function, variable plus "^" plus target_power):
        Return "1"
    
    Otherwise:
        Return "0"

Process called "substitute_variable_in_expression" that takes expression as String, variable as String, value as String returns String:
    Note: Substitute variable with value in expression (simplified)
    
    If expression is equal to variable:
        Return value
    
    Otherwise if StringOps.contains(expression, variable):
        Note: Simple substitution minus replace variable with value
        Return StringOps.replace_all(expression, variable, value)
    
    Otherwise:
        Return expression

Process called "evaluate_function_at_two_points" that takes function as String, var1 as String, var2 as String, point1 as String, point2 as String returns String:
    Note: Evaluate function at two-variable point (x1, x2)
    
    Let temp_expr be substitute_variable_in_expression(function, var1, point1)
    Let result be substitute_variable_in_expression(temp_expr, var2, point2)
    Return result

Process called "compute_partial_derivative_x" that takes function as String, var1 as String, var2 as String, point1 as String, point2 as String returns String:
    Note: Compute ∂f/∂x at (point1, point2)
    
    Note: For common functions, compute symbolic partial derivative
    If StringOps.contains(function, var1 plus "^2"):
        Let temp_result be "2*" plus point1
        Let result be substitute_variable_in_expression(temp_result, var2, point2)
        Return result
    
    Otherwise if StringOps.contains(function, var1 plus "*" plus var2):
        Return point2  Note: ∂(x*y)/∂x is equal to y
    
    Otherwise if function is equal to var1:
        Return "1"
    
    Otherwise if not StringOps.contains(function, var1):
        Return "0"  Note: Constant with respect to var1
    
    Otherwise:
        Return "∂[" plus function plus "]/∂" plus var1 plus "|(" plus point1 plus "," plus point2 plus ")"

Process called "compute_partial_derivative_y" that takes function as String, var1 as String, var2 as String, point1 as String, point2 as String returns String:
    Note: Compute ∂f/∂y at (point1, point2)
    
    Note: For common functions, compute symbolic partial derivative
    If StringOps.contains(function, var2 plus "^2"):
        Let temp_result be "2*" plus point2
        Let result be substitute_variable_in_expression(temp_result, var1, point1)
        Return result
    
    Otherwise if StringOps.contains(function, var1 plus "*" plus var2):
        Return point1  Note: ∂(x*y)/∂y is equal to x
    
    Otherwise if function is equal to var2:
        Return "1"
    
    Otherwise if not StringOps.contains(function, var2):
        Return "0"  Note: Constant with respect to var2
    
    Otherwise:
        Return "∂[" plus function plus "]/∂" plus var2 plus "|(" plus point1 plus "," plus point2 plus ")"

Process called "compute_second_partial_xx" that takes function as String, var1 as String, var2 as String, point1 as String, point2 as String returns String:
    Note: Compute ∂²f/∂x² at (point1, point2)
    
    If StringOps.contains(function, var1 plus "^2"):
        Return "2"
    
    Otherwise if StringOps.contains(function, var1 plus "^3"):
        Return "6*" plus point1
    
    Otherwise:
        Return "∂²[" plus function plus "]/∂" plus var1 plus "²|(" plus point1 plus "," plus point2 plus ")"

Process called "compute_second_partial_yy" that takes function as String, var1 as String, var2 as String, point1 as String, point2 as String returns String:
    Note: Compute ∂²f/∂y² at (point1, point2)
    
    If StringOps.contains(function, var2 plus "^2"):
        Return "2"
    
    Otherwise if StringOps.contains(function, var2 plus "^3"):
        Return "6*" plus point2
    
    Otherwise:
        Return "∂²[" plus function plus "]/∂" plus var2 plus "²|(" plus point1 plus "," plus point2 plus ")"

Process called "compute_mixed_partial_xy" that takes function as String, var1 as String, var2 as String, point1 as String, point2 as String returns String:
    Note: Compute ∂²f/∂x∂y at (point1, point2)
    
    If StringOps.contains(function, var1 plus "*" plus var2):
        Return "1"  Note: ∂²(x*y)/∂x∂y is equal to 1
    
    Otherwise if StringOps.contains(function, var1 plus "^2*" plus var2):
        Return "2*" plus point1
    
    Otherwise if StringOps.contains(function, var1 plus "*" plus var2 plus "^2"):
        Return "2*" plus point2
    
    Otherwise:
        Return "∂²[" plus function plus "]/∂" plus var1 plus "∂" plus var2 plus "|(" plus point1 plus "," plus point2 plus ")"

Process called "compute_higher_mixed_partial" that takes function as String, var1 as String, var2 as String, k as Integer, j as Integer, point1 as String, point2 as String returns String:
    Note: Compute higher order mixed partial derivatives
    
    Note: For most higher order derivatives, return symbolic form
    Return "∂^" plus Integer.to_string(k plus j) plus "[" plus function plus "]/∂" plus var1 plus "^" plus Integer.to_string(k) plus "∂" plus var2 plus "^" plus Integer.to_string(j) plus "|(" plus point1 plus "," plus point2 plus ")"

Process called "compute_factorial_string" that takes n as Integer returns String:
    Note: Compute factorial as string to maintain precision
    If n is less than or equal to 0:
        Return "1"
    If n is equal to 1:
        Return "1"
    If n is equal to 2:
        Return "2"
    If n is equal to 3:
        Return "6"
    If n is equal to 4:
        Return "24"
    If n is equal to 5:
        Return "120"
    If n is equal to 6:
        Return "720"
    Otherwise:
        Note: For larger values, use iterative calculation
        Let result be 1
        Let i be 2
        While i is less than or equal to n:
            Set result to result multiplied by i
            Set i to i plus 1
        Return Integer.to_string(result)

Process called "parse_integer" that takes str as String returns Integer:
    Note: Parse string to integer
    If str is equal to "":
        Return 0
    If str is equal to "0":
        Return 0
    If str is equal to "1":
        Return 1
    If str is equal to "2":
        Return 2
    If str is equal to "3":
        Return 3
    If str is equal to "4":
        Return 4
    If str is equal to "5":
        Return 5
    If str is equal to "6":
        Return 6
    If str is equal to "7":
        Return 7
    If str is equal to "8":
        Return 8
    If str is equal to "9":
        Return 9
    Otherwise:
        Note: Basic parsing for larger numbers
        Return 0

Process called "evaluate_at_point" that takes series as PowerSeries, evaluation_point as String returns String:
    Note: Evaluate power series at a specific point
    Let result be "0"
    Let x_minus_a be "(" plus evaluation_point plus "-" plus series.expansion_point plus ")"
    
    Note: Sum all terms: coefficient multiplied by (x-a)^n
    For each power_str in MapOps.keys(series.coefficients):
        Let power be parse_integer(power_str)
        Let coeff be MapOps.get(series.coefficients, power_str)
        
        Note: Skip zero coefficients
        If coeff does not equal "0" and coeff does not equal "":
            Let term_value be coeff
            If power is greater than 0:
                Set term_value to term_value plus "*" plus x_minus_a plus "^" plus power_str
            
            If result is equal to "0":
                Set result to term_value
            Otherwise:
                Set result to result plus "+" plus term_value
    
    Return result

Process called "series_to_string" that takes series as PowerSeries returns String:
    Note: Convert power series to human-readable string
    Let result be ""
    Let terms be ListOps.empty()
    
    Note: Collect all non-zero terms
    For each power_str in MapOps.keys(series.coefficients):
        Let power be parse_integer(power_str)
        Let coeff be MapOps.get(series.coefficients, power_str)
        
        If coeff does not equal "0" and coeff does not equal "":
            Let term be ""
            
            Note: Handle coefficient
            If coeff is equal to "1" and power is greater than 0:
                Set term to ""
            Otherwise if coeff is equal to "-1" and power is greater than 0:
                Set term to "-"
            Otherwise:
                Set term to coeff
            
            Note: Handle variable and power
            If power is equal to 0:
                If term is equal to "":
                    Set term to "1"
            Otherwise if power is equal to 1:
                If term is equal to "":
                    Set term to series.variable
                Otherwise if term is equal to "-":
                    Set term to "-" plus series.variable
                Otherwise:
                    Set term to term plus "*" plus series.variable
            Otherwise:
                If term is equal to "":
                    Set term to series.variable plus "^" plus power_str
                Otherwise if term is equal to "-":
                    Set term to "-" plus series.variable plus "^" plus power_str
                Otherwise:
                    Set term to term plus "*" plus series.variable plus "^" plus power_str
            
            ListOps.append(terms, term)
    
    Note: Combine terms with appropriate signs
    If ListOps.length(terms) is equal to 0:
        Return "0"
    
    Let result be ListOps.get(terms, 0)
    For i from 1 to ListOps.length(terms) minus 1:
        Let term be ListOps.get(terms, i)
        If StringOps.starts_with(term, "-"):
            Set result to result plus " " plus term
        Otherwise:
            Set result to result plus " plus " plus term
    
    Note: Add truncation error if present
    If series.truncation_error does not equal "":
        Set result to result plus " plus " plus series.truncation_error
    
    Return result

Note: =====================================================================
Note: COEFFICIENT ARITHMETIC HELPER FUNCTIONS
Note: =====================================================================

Process called "add_series_coefficients" that takes coeff_a as String, coeff_b as String returns String:
    Note: Add two coefficient strings
    If coeff_a is equal to "0":
        Return coeff_b
    If coeff_b is equal to "0":
        Return coeff_a
    
    Note: Handle simple numeric cases
    If coeff_a is equal to "1" and coeff_b is equal to "1":
        Return "2"
    If coeff_a is equal to "2" and coeff_b is equal to "1":
        Return "3"
    If coeff_a is equal to "1" and coeff_b is equal to "2":
        Return "3"
    
    Note: General case minus create expression
    Return "(" plus coeff_a plus ") plus (" plus coeff_b plus ")"

Process called "subtract_series_coefficients" that takes coeff_a as String, coeff_b as String returns String:
    Note: Subtract two coefficient strings
    If coeff_b is equal to "0":
        Return coeff_a
    If coeff_a is equal to coeff_b:
        Return "0"
    
    Note: Handle simple numeric cases
    If coeff_a is equal to "2" and coeff_b is equal to "1":
        Return "1"
    If coeff_a is equal to "3" and coeff_b is equal to "1":
        Return "2"
    If coeff_a is equal to "3" and coeff_b is equal to "2":
        Return "1"
    
    Note: General case minus create expression
    Return "(" plus coeff_a plus ") minus (" plus coeff_b plus ")"

Process called "multiply_series_coefficients" that takes coeff_a as String, coeff_b as String returns String:
    Note: Multiply two coefficient strings
    If coeff_a is equal to "0" or coeff_b is equal to "0":
        Return "0"
    If coeff_a is equal to "1":
        Return coeff_b
    If coeff_b is equal to "1":
        Return coeff_a
    
    Note: Handle simple numeric cases
    If coeff_a is equal to "2" and coeff_b is equal to "3":
        Return "6"
    If coeff_a is equal to "3" and coeff_b is equal to "2":
        Return "6"
    If coeff_a is equal to "2" and coeff_b is equal to "2":
        Return "4"
    
    Note: General case minus create expression
    Return "(" plus coeff_a plus ") multiplied by (" plus coeff_b plus ")"

Process called "divide_series_coefficients" that takes coeff_a as String, coeff_b as String returns String:
    Note: Divide two coefficient strings
    If coeff_b is equal to "0":
        Throw Errors.DivisionByZero with "Cannot divide by zero coefficient"
    If coeff_a is equal to "0":
        Return "0"
    If coeff_b is equal to "1":
        Return coeff_a
    If coeff_a is equal to coeff_b:
        Return "1"
    
    Note: Handle simple numeric cases
    If coeff_a is equal to "6" and coeff_b is equal to "2":
        Return "3"
    If coeff_a is equal to "6" and coeff_b is equal to "3":
        Return "2"
    
    Note: General case minus create expression
    Return "(" plus coeff_a plus ") / (" plus coeff_b plus ")"

Process called "multiply_coefficient_by_integer" that takes coeff as String, n as Integer returns String:
    Note: Multiply coefficient by integer
    If n is equal to 0:
        Return "0"
    If n is equal to 1:
        Return coeff
    If coeff is equal to "0":
        Return "0"
    If coeff is equal to "1":
        Return Integer.to_string(n)
    
    Note: Handle simple cases
    If coeff is equal to "2" and n is equal to 3:
        Return "6"
    If coeff is equal to "3" and n is equal to 2:
        Return "6"
    
    Note: General case
    Return Integer.to_string(n) plus " multiplied by (" plus coeff plus ")"

Process called "divide_coefficient_by_integer" that takes coeff as String, n as Integer returns String:
    Note: Divide coefficient by integer
    If n is equal to 0:
        Throw Errors.DivisionByZero with "Cannot divide by zero"
    If n is equal to 1:
        Return coeff
    If coeff is equal to "0":
        Return "0"
    
    Note: Handle simple cases
    If coeff is equal to "6" and n is equal to 2:
        Return "3"
    If coeff is equal to "6" and n is equal to 3:
        Return "2"
    
    Note: General case
    Return "(" plus coeff plus ") / " plus Integer.to_string(n)

Process called "create_constant_series" that takes constant as String, variable as String returns PowerSeries:
    Note: Create a power series representing a constant
    Let coeffs be MapOps.empty()
    MapOps.set(coeffs, "0", constant)
    
    Return PowerSeries with:
        coefficients is equal to coeffs
        variable is equal to variable
        expansion_point is equal to "0"
        series_order is equal to 0
        radius_of_convergence is equal to "infinity"
        series_type is equal to "constant"
        truncation_error is equal to ""

Process called "scale_power_series" that takes series as PowerSeries, scale_factor as String returns PowerSeries:
    Note: Multiply all coefficients by a scale factor
    Let result_coeffs be MapOps.empty()
    
    For each power_key in MapOps.keys(series.coefficients):
        Let original_coeff be MapOps.get(series.coefficients, power_key)
        Let scaled_coeff be multiply_series_coefficients(scale_factor, original_coeff)
        If scaled_coeff does not equal "0":
            MapOps.set(result_coeffs, power_key, scaled_coeff)
    
    Return PowerSeries with:
        coefficients is equal to result_coeffs
        variable is equal to series.variable
        expansion_point is equal to series.expansion_point
        series_order is equal to series.series_order
        radius_of_convergence is equal to series.radius_of_convergence
        series_type is equal to series.series_type
        truncation_error is equal to series.truncation_error

Note: =====================================================================
Note: HELPER FUNCTIONS FOR FOURIER ANALYSIS
Note: =====================================================================

Process called "estimate_jump_magnitude" that takes fourier_series as FourierSeries, discontinuity_point as String returns String:
    Note: Estimate the magnitude of a jump discontinuity from Fourier coefficients
    Note: For a jump discontinuity, the first few coefficients give information about the jump
    
    Note: Use the first sine coefficient as an indicator (for simple analysis)
    If MapOps.contains_key(fourier_series.sine_coefficients, "1"):
        Let first_sine_coeff be MapOps.get(fourier_series.sine_coefficients, "1")
        Note: Jump magnitude is approximately related to first coefficient
        Let jump_estimate be multiply_series_coefficients("π", first_sine_coeff)
        Return jump_estimate
    
    Otherwise if MapOps.contains_key(fourier_series.cosine_coefficients, "1"):
        Let first_cosine_coeff be MapOps.get(fourier_series.cosine_coefficients, "1")
        Let jump_estimate be multiply_series_coefficients("π", first_cosine_coeff)
        Return jump_estimate
    
    Otherwise:
        Return "1"  Note: Default jump estimate