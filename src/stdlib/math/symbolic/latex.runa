Note:
math/symbolic/latex.runa
LaTeX Mathematical Notation Export and Formatting System

This module provides comprehensive LaTeX mathematical notation export including:
- Expression-to-LaTeX conversion with proper formatting
- Mathematical symbol mapping and Unicode handling
- Equation environment generation (align, gather, split)
- Matrix and array formatting with alignment options
- Fraction display with numerator/denominator styling
- Superscript and subscript positioning
- Integral and summation notation with proper limits
- Function notation and operator precedence handling
- Custom LaTeX command generation and macros
- Bibliography and citation integration for math
- Document structure generation for mathematical papers
- Presentation slide formatting for mathematical content
- Interactive LaTeX with TikZ diagram integration
- LaTeX parsing and reverse conversion to symbolic expressions
- Error detection and LaTeX syntax validation
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/symbols/greek_letters" as GreekLetters
Import module "math/symbols/logic" as LogicSymbols
Import module "math/symbols/set_theory" as SetTheory
Import module "math/symbols/calculus_symbols" as CalculusSymbols
Import module "data/collections/core/list" as List
Import module "data/collections/core/map" as Map
Import module "sys/time/core/instant" as SystemTime

Note: =====================================================================
Note: LATEX FORMATTING DATA STRUCTURES
Note: =====================================================================

Type called "LaTeXExpression":
    latex_code as String
    expression_type as String
    formatting_options as Dictionary[String, String]
    required_packages as List[String]
    custom_commands as Dictionary[String, String]
    display_mode as String

Type called "LaTeXDocument":
    document_class as String
    preamble as String
    document_body as String
    required_packages as List[String]
    custom_definitions as Dictionary[String, String]
    bibliography as String

Type called "LaTeXMatrix":
    matrix_type as String
    entries as List[List[String]]
    alignment as String
    delimiters as Dictionary[String, String]
    spacing_options as Dictionary[String, String]

Type called "LaTeXEquation":
    equation_content as String
    equation_environment as String
    label as String
    numbering as Boolean
    alignment_points as List[String]
    multiline as Boolean

Type called "LaTeXSymbol":
    symbol_name as String
    latex_command as String
    unicode_representation as String
    symbol_category as String
    required_package as String
    font_specification as String

Note: =====================================================================
Note: BASIC EXPRESSION CONVERSION OPERATIONS
Note: =====================================================================

Process called "expression_to_latex" that takes expression as String, formatting_options as Dictionary[String, String] returns LaTeXExpression:
    Note: Convert mathematical expression to LaTeX format
    Let latex_result be LaTeXExpression
    Set latex_result.latex_code to parse_expression_to_latex(expression, formatting_options)
    Set latex_result.expression_type to Map.dictionary_get(formatting_options, "type", "inline")
    Set latex_result.formatting_options to formatting_options
    Set latex_result.required_packages to ["amsmath", "amssymb"]
    Set latex_result.custom_commands to Map.dictionary_empty()
    Set latex_result.display_mode to Map.dictionary_get(formatting_options, "display_mode", "inline")
    Return latex_result

Process called "latex_to_expression" that takes latex_code as String, parsing_options as Dictionary[String, String] returns String:
    Note: Parse LaTeX mathematical notation back to expression
    Let result be latex_code
    
    Note: Remove math mode delimiters
    Let result be string_replace(result, "$", "")
    Let result be string_replace(result, "\\[", "")
    Let result be string_replace(result, "\\]", "")
    
    Note: Convert LaTeX commands back to symbols
    Let result be string_replace(result, "\\alpha", "α")
    Let result be string_replace(result, "\\beta", "β")
    Let result be string_replace(result, "\\pi", "π")
    Let result be string_replace(result, "\\theta", "θ")
    Let result be string_replace(result, "\\infty", "∞")
    Let result be string_replace(result, "\\in", "∈")
    Let result be string_replace(result, "\\cup", "∪")
    Let result be string_replace(result, "\\cap", "∩")
    
    Note: Handle fractions
    Let result be parse_latex_fractions(result)
    
    Note: Handle superscripts and subscripts
    Let result be parse_latex_scripts(result)
    
    Return result

Process called "inline_math_format" that takes expression as String returns String:
    Note: Format expression for inline mathematical display ($...$)
    Let cleaned_expression be clean_expression_for_latex(expression)
    Return "$" plus cleaned_expression plus "$"

Process called "display_math_format" that takes expression as String returns String:
    Note: Format expression for display mathematical mode ($$...$$)
    Let cleaned_expression be clean_expression_for_latex(expression)
    Return "$$" plus cleaned_expression plus "$$"

Process called "equation_environment_format" that takes expression as String, environment_type as String, label as String returns LaTeXEquation:
    Note: Format expression in specific equation environment
    Let latex_eq be LaTeXEquation
    
    Let clean_expr be clean_expression_for_latex(expression)
    Set latex_eq.equation_content to clean_expr
    Set latex_eq.equation_environment to environment_type
    Set latex_eq.label to label
    Set latex_eq.numbering to true
    Set latex_eq.multiline to false
    
    Let alignment_points be List.create_list(1)
    List.list_append(alignment_points, "=")
    Set latex_eq.alignment_points to alignment_points
    
    Return latex_eq

Note: =====================================================================
Note: SYMBOL AND NOTATION OPERATIONS
Note: =====================================================================

Process called "symbol_to_latex" that takes symbol_name as String, symbol_context as String returns LaTeXSymbol:
    Note: Convert mathematical symbol to appropriate LaTeX command
    Let latex_symbol be LaTeXSymbol
    Set latex_symbol.symbol_name to symbol_name
    Set latex_symbol.latex_command to get_symbol_latex_command(symbol_name, symbol_context)
    Set latex_symbol.unicode_representation to get_symbol_unicode(symbol_name)
    Set latex_symbol.symbol_category to symbol_context
    Set latex_symbol.required_package to get_symbol_required_package(symbol_name)
    Set latex_symbol.font_specification to "mathsyb"
    Return latex_symbol

Process called "greek_letters_latex" that takes letter_name as String, case_type as String returns String:
    Note: Generate LaTeX for Greek letters (α, β, Γ, Δ, etc.)
    Let greek_letter be get_greek_letter_by_name(letter_name)
    If case_type is equal to "uppercase":
        Return get_greek_uppercase_latex(letter_name)
    Otherwise:
        Return get_greek_lowercase_latex(letter_name)

Process called "mathematical_operators_latex" that takes operator_name as String, operator_context as String returns String:
    Note: Generate LaTeX for mathematical operators (∑, ∏, ∫, ∂, etc.)
    If operator_name is equal to "sum":
        Return "\\sum"
    Otherwise if operator_name is equal to "product":
        Return "\\prod"
    Otherwise if operator_name is equal to "integral":
        Return "\\int"
    Otherwise if operator_name is equal to "partial":
        Return "\\partial"
    Otherwise if operator_name is equal to "nabla":
        Return "\\nabla"
    Otherwise if operator_name is equal to "infinity":
        Return "\\infty"
    Otherwise:
        Return get_calculus_symbol_latex(operator_name)

Process called "set_theory_symbols_latex" that takes symbol_type as String returns String:
    Note: Generate LaTeX for set theory symbols (∈, ⊂, ∪, ∩, etc.)
    If symbol_type is equal to "in":
        Return "\\in"
    Otherwise if symbol_type is equal to "subset":
        Return "\\subset"
    Otherwise if symbol_type is equal to "union":
        Return "\\cup"
    Otherwise if symbol_type is equal to "intersection":
        Return "\\cap"
    Otherwise if symbol_type is equal to "empty_set":
        Return "\\emptyset"
    Otherwise if symbol_type is equal to "not_in":
        Return "\\notin"
    Otherwise if symbol_type is equal to "subset_equal":
        Return "\\subseteq"
    Otherwise if symbol_type is equal to "superset":
        Return "\\supset"
    Otherwise:
        Return get_set_theory_symbol_latex(symbol_type)

Process called "logic_symbols_latex" that takes symbol_type as String returns String:
    Note: Generate LaTeX for logic symbols (∧, ∨, ¬, →, ∀, ∃, etc.)
    If symbol_type is equal to "and":
        Return "\\land"
    Otherwise if symbol_type is equal to "or":
        Return "\\lor"
    Otherwise if symbol_type is equal to "not":
        Return "\\neg"
    Otherwise if symbol_type is equal to "implies":
        Return "\\rightarrow"
    Otherwise if symbol_type is equal to "forall":
        Return "\\forall"
    Otherwise if symbol_type is equal to "exists":
        Return "\\exists"
    Otherwise if symbol_type is equal to "iff":
        Return "\\leftrightarrow"
    Otherwise if symbol_type is equal to "therefore":
        Return "\\therefore"
    Otherwise:
        Return get_logic_symbol_latex(symbol_type)

Process called "arrow_symbols_latex" that takes arrow_type as String, arrow_style as String returns String:
    Note: Generate LaTeX for arrows (→, ⇒, ↔, ⇔, ↦, etc.)
    If arrow_type is equal to "rightarrow":
        If arrow_style is equal to "long":
            Return "\\longrightarrow"
        Otherwise:
            Return "\\rightarrow"
    Otherwise if arrow_type is equal to "leftarrow":
        If arrow_style is equal to "long":
            Return "\\longleftarrow"
        Otherwise:
            Return "\\leftarrow"
    Otherwise if arrow_type is equal to "leftrightarrow":
        If arrow_style is equal to "long":
            Return "\\longleftrightarrow"
        Otherwise:
            Return "\\leftrightarrow"
    Otherwise if arrow_type is equal to "implies":
        Return "\\Rightarrow"
    Otherwise if arrow_type is equal to "iff":
        Return "\\Leftrightarrow"
    Otherwise if arrow_type is equal to "maps_to":
        Return "\\mapsto"
    Otherwise if arrow_type is equal to "up":
        Return "\\uparrow"
    Otherwise if arrow_type is equal to "down":
        Return "\\downarrow"
    Otherwise:
        Return "\\rightarrow"

Note: =====================================================================
Note: FRACTION AND DIVISION OPERATIONS
Note: =====================================================================

Process called "fraction_latex" that takes numerator as String, denominator as String, fraction_style as String returns String:
    Note: Generate LaTeX fraction with specified style (\frac, \dfrac, \tfrac)
    Let clean_numerator be clean_expression_for_latex(numerator)
    Let clean_denominator be clean_expression_for_latex(denominator)
    
    If fraction_style is equal to "display":
        Return "\\dfrac{" plus clean_numerator plus "}{" plus clean_denominator plus "}"
    Otherwise if fraction_style is equal to "text":
        Return "\\tfrac{" plus clean_numerator plus "}{" plus clean_denominator plus "}"
    Otherwise:
        Return "\\frac{" plus clean_numerator plus "}{" plus clean_denominator plus "}"

Process called "continued_fraction_latex" that takes partial_quotients as List[String], display_levels as Integer returns String:
    Note: Generate LaTeX for continued fraction representation
    If List.length(partial_quotients) is equal to 0:
        Return ""
    
    Let first_term be List.get(partial_quotients, 0)
    Let clean_first be clean_expression_for_latex(first_term)
    
    If List.length(partial_quotients) is equal to 1:
        Return clean_first
    
    Let result be clean_first plus " plus \\cfrac{1}{"
    Let level be 1
    
    While level is less than List.length(partial_quotients) and level is less than display_levels:
        Let term be List.get(partial_quotients, level)
        Let clean_term be clean_expression_for_latex(term)
        
        If level is equal to List.length(partial_quotients) minus 1 or level is equal to display_levels minus 1:
            Let result be result plus clean_term
        Otherwise:
            Let result be result plus clean_term plus " plus \\cfrac{1}{"
        
        Let level be level plus 1
    
    Note: Close all opened fractions
    Let close_count be level minus 1
    While close_count is greater than 0:
        Let result be result plus "}"
        Let close_count be close_count minus 1
    
    Return result

Process called "nested_fraction_latex" that takes fraction_structure as Dictionary[String, String], nesting_style as String returns String:
    Note: Generate LaTeX for complex nested fractions
    Let numerator be Map.dictionary_get(fraction_structure, "numerator", "")
    Let denominator be Map.dictionary_get(fraction_structure, "denominator", "")
    Let nested_num be Map.dictionary_get(fraction_structure, "nested_numerator", "")
    Let nested_den be Map.dictionary_get(fraction_structure, "nested_denominator", "")
    
    Let clean_num be clean_expression_for_latex(numerator)
    Let clean_den be clean_expression_for_latex(denominator)
    
    If nested_num does not equal "" and nested_den does not equal "":
        Let nested_fraction be "\\frac{" plus clean_expression_for_latex(nested_num) plus "}{" plus clean_expression_for_latex(nested_den) plus "}"
        
        If nesting_style is equal to "numerator":
            Let clean_num be clean_num plus " plus " plus nested_fraction
        Otherwise if nesting_style is equal to "denominator":
            Let clean_den be clean_den plus " plus " plus nested_fraction
    
    If nesting_style is equal to "display":
        Return "\\dfrac{" plus clean_num plus "}{" plus clean_den plus "}"
    Otherwise:
        Return "\\frac{" plus clean_num plus "}{" plus clean_den plus "}"

Process called "mixed_number_latex" that takes whole_part as String, numerator as String, denominator as String returns String:
    Note: Generate LaTeX for mixed numbers (e.g., 2¾)
    Let clean_whole be clean_expression_for_latex(whole_part)
    Let clean_num be clean_expression_for_latex(numerator)
    Let clean_den be clean_expression_for_latex(denominator)
    
    If clean_num is equal to "0" or clean_den is equal to "1":
        Return clean_whole
    
    Return clean_whole plus "\\frac{" plus clean_num plus "}{" plus clean_den plus "}"

Note: =====================================================================
Note: SUPERSCRIPT AND SUBSCRIPT OPERATIONS
Note: =====================================================================

Process called "superscript_latex" that takes base as String, exponent as String, grouping_options as Dictionary[String, String] returns String:
    Note: Generate LaTeX for superscripts with proper grouping
    Let clean_base be clean_expression_for_latex(base)
    Let clean_exponent be clean_expression_for_latex(exponent)
    
    If needs_grouping(clean_exponent):
        Return clean_base plus "^{" plus clean_exponent plus "}"
    Otherwise:
        Return clean_base plus "^" plus clean_exponent

Process called "subscript_latex" that takes base as String, subscript as String, grouping_options as Dictionary[String, String] returns String:
    Note: Generate LaTeX for subscripts with proper grouping
    Let clean_base be clean_expression_for_latex(base)
    Let clean_subscript be clean_expression_for_latex(subscript)
    
    If needs_grouping(clean_subscript):
        Return clean_base plus "_{" plus clean_subscript plus "}"
    Otherwise:
        Return clean_base plus "_" plus clean_subscript

Process called "super_subscript_latex" that takes base as String, superscript as String, subscript as String, positioning as String returns String:
    Note: Generate LaTeX for combined super and subscripts
    Let clean_base be clean_expression_for_latex(base)
    Let clean_superscript be clean_expression_for_latex(superscript)
    Let clean_subscript be clean_expression_for_latex(subscript)
    
    Let super_part be "^{" plus clean_superscript plus "}"
    Let sub_part be "_{" plus clean_subscript plus "}"
    
    If positioning is equal to "subscript_first":
        Return clean_base plus sub_part plus super_part
    Otherwise:
        Return clean_base plus super_part plus sub_part

Process called "multi_level_scripts_latex" that takes base as String, scripts as Dictionary[String, String] returns String:
    Note: Generate LaTeX for multiple levels of scripts
    Let clean_base be clean_expression_for_latex(base)
    Let result be clean_base
    
    Let superscript be Map.dictionary_get(scripts, "superscript", "")
    Let subscript be Map.dictionary_get(scripts, "subscript", "")
    Let pre_superscript be Map.dictionary_get(scripts, "pre_superscript", "")
    Let pre_subscript be Map.dictionary_get(scripts, "pre_subscript", "")
    
    Note: Handle pre-scripts (left side)
    If pre_superscript does not equal "" or pre_subscript does not equal "":
        Let pre_part be "{}"
        
        If pre_superscript does not equal "":
            Let pre_part be pre_part plus "^{" plus clean_expression_for_latex(pre_superscript) plus "}"
        If pre_subscript does not equal "":
            Let pre_part be pre_part plus "_{" plus clean_expression_for_latex(pre_subscript) plus "}"
        
        Let result be pre_part plus result
    
    Note: Handle post-scripts (right side)
    If subscript does not equal "":
        Let result be result plus "_{" plus clean_expression_for_latex(subscript) plus "}"
    If superscript does not equal "":
        Let result be result plus "^{" plus clean_expression_for_latex(superscript) plus "}"
    
    Return result

Note: =====================================================================
Note: MATRIX AND ARRAY OPERATIONS
Note: =====================================================================

Process called "matrix_latex" that takes matrix_entries as List[List[String]], matrix_type as String, alignment as String returns LaTeXMatrix:
    Note: Generate LaTeX matrix with specified delimiters and alignment
    Let latex_matrix be LaTeXMatrix
    Set latex_matrix.matrix_type to matrix_type
    Set latex_matrix.entries to matrix_entries
    Set latex_matrix.alignment to alignment
    
    Let delimiters be get_matrix_delimiters(matrix_type)
    Set latex_matrix.delimiters to delimiters
    
    Let spacing_opts be Map.dictionary_empty()
    Map.dictionary_set(spacing_opts, "column_sep", "1em")
    Map.dictionary_set(spacing_opts, "row_sep", "0.5ex")
    Set latex_matrix.spacing_options to spacing_opts
    
    Return latex_matrix

Process called "determinant_latex" that takes matrix_entries as List[List[String]] returns String:
    Note: Generate LaTeX for determinant notation |A|
    Let result be "\\begin{vmatrix}\n"
    
    Let row_index be 0
    While row_index is less than List.length(matrix_entries):
        Let row be List.get(matrix_entries, row_index)
        
        Let col_index be 0
        While col_index is less than List.length(row):
            Let entry be List.get(row, col_index)
            Let clean_entry be clean_expression_for_latex(entry)
            Let result be result plus clean_entry
            
            If col_index is less than List.length(row) minus 1:
                Let result be result plus " & "
            
            Let col_index be col_index plus 1
        
        If row_index is less than List.length(matrix_entries) minus 1:
            Let result be result plus " \\\\\n"
        Otherwise:
            Let result be result plus "\n"
        
        Let row_index be row_index plus 1
    
    Let result be result plus "\\end{vmatrix}"
    Return result

Process called "augmented_matrix_latex" that takes coefficient_matrix as List[List[String]], constant_vector as List[String] returns String:
    Note: Generate LaTeX for augmented matrix [A|b]
    Let num_rows be List.length(coefficient_matrix)
    Let num_cols be 0
    If num_rows is greater than 0:
        Let first_row be List.get(coefficient_matrix, 0)
        Let num_cols be List.length(first_row)
    
    Let column_spec be ""
    Let col_count be 0
    While col_count is less than num_cols:
        Let column_spec be column_spec plus "c"
        Let col_count be col_count plus 1
    Let column_spec be column_spec plus "|c"
    
    Let result be "\\left[\\begin{array}{" plus column_spec plus "}\n"
    
    Let row_index be 0
    While row_index is less than num_rows:
        Let row be List.get(coefficient_matrix, row_index)
        
        Let col_index be 0
        While col_index is less than List.length(row):
            Let entry be List.get(row, col_index)
            Let clean_entry be clean_expression_for_latex(entry)
            Let result be result plus clean_entry plus " & "
            Let col_index be col_index plus 1
        
        If row_index is less than List.length(constant_vector):
            Let constant be List.get(constant_vector, row_index)
            Let clean_constant be clean_expression_for_latex(constant)
            Let result be result plus clean_constant
        
        If row_index is less than num_rows minus 1:
            Let result be result plus " \\\\\n"
        Otherwise:
            Let result be result plus "\n"
        
        Let row_index be row_index plus 1
    
    Let result be result plus "\\end{array}\\right]"
    Return result

Process called "block_matrix_latex" that takes block_structure as Dictionary[String, List[List[String]]], block_layout as Dictionary[String, String] returns String:
    Note: Generate LaTeX for block matrices with proper spacing
    Let top_left be Map.dictionary_get(block_structure, "top_left", List.create_list(0))
    Let top_right be Map.dictionary_get(block_structure, "top_right", List.create_list(0))
    Let bottom_left be Map.dictionary_get(block_structure, "bottom_left", List.create_list(0))
    Let bottom_right be Map.dictionary_get(block_structure, "bottom_right", List.create_list(0))
    
    Let delimiter_style be Map.dictionary_get(block_layout, "delimiter", "pmatrix")
    Let spacing_style be Map.dictionary_get(block_layout, "spacing", "normal")
    
    Let result be get_matrix_environment_start(delimiter_style)
    
    Note: Generate top row blocks
    Let result be result plus generate_block_row(top_left, top_right, spacing_style)
    
    Note: Add block separator if we have bottom blocks
    If List.length(bottom_left) is greater than 0 or List.length(bottom_right) is greater than 0:
        Let result be result plus "\\\\\n\\hline\n"
        Let result be result plus generate_block_row(bottom_left, bottom_right, spacing_style)
    
    Let result be result plus get_matrix_environment_end(delimiter_style)
    Return result

Process called "vector_latex" that takes vector_components as List[String], vector_notation as String returns String:
    Note: Generate LaTeX for vectors (column, row, or arrow notation)
    If vector_notation is equal to "column":
        Return generate_column_vector_latex(vector_components)
    Otherwise if vector_notation is equal to "row":
        Return generate_row_vector_latex(vector_components)
    Otherwise if vector_notation is equal to "arrow":
        Return generate_arrow_vector_latex(vector_components)
    Otherwise:
        Return generate_column_vector_latex(vector_components)

Note: =====================================================================
Note: INTEGRAL AND SUMMATION OPERATIONS
Note: =====================================================================

Process called "integral_latex" that takes integrand as String, variable as String, limits as Dictionary[String, String], integral_type as String returns String:
    Note: Generate LaTeX for integrals with proper limits positioning
    Let clean_integrand be clean_expression_for_latex(integrand)
    Let clean_variable be clean_expression_for_latex(variable)
    
    Let integral_symbol be get_integral_symbol(integral_type)
    Let limits_part be format_integral_limits(limits)
    
    Return integral_symbol plus limits_part plus " " plus clean_integrand plus " d" plus clean_variable

Process called "multiple_integral_latex" that takes integrand as String, variables as List[String], limits as Dictionary[String, Dictionary[String, String]] returns String:
    Note: Generate LaTeX for multiple integrals (double, triple, etc.)
    Let clean_integrand be clean_expression_for_latex(integrand)
    Let integral_count be List.length(variables)
    
    Let integral_symbol be ""
    If integral_count is equal to 2:
        Let integral_symbol be "\\iint"
    Otherwise if integral_count is equal to 3:
        Let integral_symbol be "\\iiint"
    Otherwise:
        Let integral_symbol be "\\int"
        Let i be 1
        While i is less than integral_count:
            Let integral_symbol be integral_symbol plus "\\int"
            Let i be i plus 1
    
    Let result be integral_symbol
    
    Note: Add limits for each variable
    Let var_index be 0
    While var_index is less than List.length(variables):
        Let variable be List.get(variables, var_index)
        Let var_limits be Map.dictionary_get(limits, variable, Map.dictionary_empty())
        Let limits_part be format_integral_limits(var_limits)
        
        If var_index is equal to 0:
            Let result be result plus limits_part
        
        Let var_index be var_index plus 1
    
    Let result be result plus " " plus clean_integrand
    
    Note: Add differential elements
    Let var_index be List.length(variables) minus 1
    While var_index is greater than or equal to 0:
        Let variable be List.get(variables, var_index)
        Let clean_var be clean_expression_for_latex(variable)
        Let result be result plus " d" plus clean_var
        Let var_index be var_index minus 1
    
    Return result

Process called "line_integral_latex" that takes integrand as String, curve as String, parameter as String returns String:
    Note: Generate LaTeX for line integrals with curve notation
    Let clean_integrand be clean_expression_for_latex(integrand)
    Let clean_curve be clean_expression_for_latex(curve)
    Let clean_param be clean_expression_for_latex(parameter)
    
    If string_contains(integrand, "cdot") or string_contains(integrand, "\\cdot"):
        Note: Vector line integral
        Return "\\int_{" plus clean_curve plus "} " plus clean_integrand plus " d\\mathbf{" plus clean_param plus "}"
    Otherwise:
        Note: Scalar line integral
        Return "\\int_{" plus clean_curve plus "} " plus clean_integrand plus " ds"

Process called "summation_latex" that takes summand as String, index_variable as String, limits as Dictionary[String, String], summation_style as String returns String:
    Note: Generate LaTeX for summations with index limits
    Let clean_summand be clean_expression_for_latex(summand)
    Let clean_index be clean_expression_for_latex(index_variable)
    
    Let lower_limit be Map.dictionary_get(limits, "lower", "")
    Let upper_limit be Map.dictionary_get(limits, "upper", "")
    
    If lower_limit is equal to "" and upper_limit is equal to "":
        Return "\\sum " plus clean_summand
    Otherwise if lower_limit is equal to "":
        Return "\\sum^{" plus upper_limit plus "} " plus clean_summand
    Otherwise if upper_limit is equal to "":
        Return "\\sum_{" plus clean_index plus "=" plus lower_limit plus "} " plus clean_summand
    Otherwise:
        Return "\\sum_{" plus clean_index plus "=" plus lower_limit plus "}^{" plus upper_limit plus "} " plus clean_summand

Process called "product_latex" that takes multiplicand as String, index_variable as String, limits as Dictionary[String, String] returns String:
    Note: Generate LaTeX for products (∏) with index limits
    Let clean_multiplicand be clean_expression_for_latex(multiplicand)
    Let clean_index be clean_expression_for_latex(index_variable)
    
    Let lower_limit be Map.dictionary_get(limits, "lower", "")
    Let upper_limit be Map.dictionary_get(limits, "upper", "")
    
    If lower_limit is equal to "" and upper_limit is equal to "":
        Return "\\prod " plus clean_multiplicand
    Otherwise if lower_limit is equal to "":
        Return "\\prod^{" plus upper_limit plus "} " plus clean_multiplicand
    Otherwise if upper_limit is equal to "":
        Return "\\prod_{" plus clean_index plus "=" plus lower_limit plus "} " plus clean_multiplicand
    Otherwise:
        Return "\\prod_{" plus clean_index plus "=" plus lower_limit plus "}^{" plus upper_limit plus "} " plus clean_multiplicand

Process called "limit_latex" that takes expression as String, variable as String, limit_point as String, approach_direction as String returns String:
    Note: Generate LaTeX for limits with proper notation
    Let clean_expr be clean_expression_for_latex(expression)
    Let clean_var be clean_expression_for_latex(variable)
    Let clean_point be clean_expression_for_latex(limit_point)
    
    Let limit_subscript be clean_var plus " \\to " plus clean_point
    
    If approach_direction is equal to "left":
        Let limit_subscript be limit_subscript plus "^-"
    Otherwise if approach_direction is equal to "right":
        Let limit_subscript be limit_subscript plus "^+"
    
    Return "\\lim_{" plus limit_subscript plus "} " plus clean_expr

Note: =====================================================================
Note: FUNCTION AND OPERATOR OPERATIONS
Note: =====================================================================

Process called "function_latex" that takes function_name as String, arguments as List[String], function_style as String returns String:
    Note: Generate LaTeX for function calls with proper argument formatting
    Let clean_function_name be clean_expression_for_latex(function_name)
    
    If function_style is equal to "operatorname":
        Let result be "\\operatorname{" plus clean_function_name plus "}"
    Otherwise:
        Let result be clean_function_name
    
    If List.length(arguments) is greater than 0:
        Let result be result plus "\\left("
        
        Let arg_index be 0
        While arg_index is less than List.length(arguments):
            Let arg be List.get(arguments, arg_index)
            Let clean_arg be clean_expression_for_latex(arg)
            Let result be result plus clean_arg
            
            If arg_index is less than List.length(arguments) minus 1:
                Let result be result plus ", "
            
            Let arg_index be arg_index plus 1
        
        Let result be result plus "\\right)"
    
    Return result

Process called "piecewise_function_latex" that takes cases as List[Dictionary[String, String]], case_style as String returns String:
    Note: Generate LaTeX for piecewise functions with cases environment
    Let result be "\\begin{cases}\n"
    
    Let case_index be 0
    While case_index is less than List.length(cases):
        Let case_dict be List.get(cases, case_index)
        Let expression be Map.dictionary_get(case_dict, "expression", "")
        Let condition be Map.dictionary_get(case_dict, "condition", "")
        
        Let clean_expr be clean_expression_for_latex(expression)
        Let clean_cond be clean_expression_for_latex(condition)
        
        Let result be result plus clean_expr plus " & \\text{if } " plus clean_cond
        
        If case_index is less than List.length(cases) minus 1:
            Let result be result plus " \\\\\n"
        Otherwise:
            Let result be result plus "\n"
        
        Let case_index be case_index plus 1
    
    Let result be result plus "\\end{cases}"
    Return result

Process called "derivative_latex" that takes function as String, variable as String, order as Integer, notation_style as String returns String:
    Note: Generate LaTeX for derivatives (Leibniz or prime notation)
    Let clean_function be clean_expression_for_latex(function)
    Let clean_variable be clean_expression_for_latex(variable)
    
    If notation_style is equal to "prime" and order is less than or equal to 3:
        Let primes be get_prime_notation(order)
        Return clean_function plus primes
    Otherwise if notation_style is equal to "leibniz":
        If order is equal to 1:
            Return "\\frac{d}{d" plus clean_variable plus "} " plus clean_function
        Otherwise:
            Return "\\frac{d^{" plus ToString(order) plus "}}{d" plus clean_variable plus "^{" plus ToString(order) plus "}} " plus clean_function
    Otherwise:
        Return "D^{" plus ToString(order) plus "}_{" plus clean_variable plus "} " plus clean_function

Process called "partial_derivative_latex" that takes function as String, variables as List[String], orders as List[Integer] returns String:
    Note: Generate LaTeX for partial derivatives with proper notation
    Let clean_function be clean_expression_for_latex(function)
    
    If List.length(variables) is equal to 0:
        Return clean_function
    
    If List.length(variables) is equal to 1:
        Let variable be List.get(variables, 0)
        Let order be 1
        If List.length(orders) is greater than 0:
            Let order be List.get(orders, 0)
        
        Let clean_var be clean_expression_for_latex(variable)
        
        If order is equal to 1:
            Return "\\frac{\\partial}{\\partial " plus clean_var plus "} " plus clean_function
        Otherwise:
            Return "\\frac{\\partial^{" plus ToString(order) plus "}}{\\partial " plus clean_var plus "^{" plus ToString(order) plus "}} " plus clean_function
    
    Note: Mixed partial derivatives
    Let numerator be "\\partial^{" plus ToString(get_total_order(orders)) plus "}"
    Let denominator be ""
    
    Let var_index be 0
    While var_index is less than List.length(variables):
        Let variable be List.get(variables, var_index)
        Let order be 1
        If var_index is less than List.length(orders):
            Let order be List.get(orders, var_index)
        
        Let clean_var be clean_expression_for_latex(variable)
        
        If var_index is greater than 0:
            Let denominator be denominator plus " \\partial "
        Otherwise:
            Let denominator be "\\partial "
        
        If order is greater than 1:
            Let denominator be denominator plus clean_var plus "^{" plus ToString(order) plus "}"
        Otherwise:
            Let denominator be denominator plus clean_var
        
        Let var_index be var_index plus 1
    
    Return "\\frac{" plus numerator plus "}{" plus denominator plus "} " plus clean_function

Process called "operator_latex" that takes operator_name as String, operands as List[String], operator_style as String returns String:
    Note: Generate LaTeX for mathematical operators with operands
    Let clean_operator be clean_expression_for_latex(operator_name)
    
    If operator_style is equal to "prefix":
        Let result be "\\operatorname{" plus clean_operator plus "}"
        
        If List.length(operands) is greater than 0:
            Let result be result plus "\\left("
            
            Let op_index be 0
            While op_index is less than List.length(operands):
                Let operand be List.get(operands, op_index)
                Let clean_operand be clean_expression_for_latex(operand)
                Let result be result plus clean_operand
                
                If op_index is less than List.length(operands) minus 1:
                    Let result be result plus ", "
                
                Let op_index be op_index plus 1
            
            Let result be result plus "\\right)"
        
        Return result
    
    Otherwise if operator_style is equal to "infix" and List.length(operands) is greater than or equal to 2:
        Let first_operand be List.get(operands, 0)
        Let second_operand be List.get(operands, 1)
        Let clean_first be clean_expression_for_latex(first_operand)
        Let clean_second be clean_expression_for_latex(second_operand)
        
        Return clean_first plus " " plus clean_operator plus " " plus clean_second
    
    Otherwise:
        Let result be clean_operator
        
        Let op_index be 0
        While op_index is less than List.length(operands):
            Let operand be List.get(operands, op_index)
            Let clean_operand be clean_expression_for_latex(operand)
            Let result be result plus " " plus clean_operand
            Let op_index be op_index plus 1
        
        Return result

Note: =====================================================================
Note: EQUATION SYSTEM OPERATIONS
Note: =====================================================================

Process called "equation_system_latex" that takes equations as List[String], alignment_style as String, numbering as Boolean returns String:
    Note: Generate LaTeX for systems of equations with alignment
    Let environment_name be "align*"
    If numbering:
        Let environment_name be "align"
    
    Let result be "\\begin{" plus environment_name plus "}\n"
    
    Let eq_index be 0
    While eq_index is less than List.length(equations):
        Let equation be List.get(equations, eq_index)
        Let clean_eq be clean_expression_for_latex(equation)
        
        Let result be result plus clean_eq
        
        If eq_index is less than List.length(equations) minus 1:
            Let result be result plus " \\\\\n"
        Otherwise:
            Let result be result plus "\n"
        
        Let eq_index be eq_index plus 1
    
    Let result be result plus "\\end{" plus environment_name plus "}"
    Return result

Process called "align_equations_latex" that takes equations as List[String], alignment_points as List[String] returns String:
    Note: Generate LaTeX using align environment with custom alignment
    Let result be "\\begin{align}\n"
    
    Let eq_index be 0
    While eq_index is less than List.length(equations):
        Let equation be List.get(equations, eq_index)
        Let clean_eq be clean_expression_for_latex(equation)
        
        Note: Insert alignment points
        If eq_index is less than List.length(alignment_points):
            Let align_point be List.get(alignment_points, eq_index)
            Let clean_eq be string_replace(clean_eq, align_point, "&" plus align_point)
        Otherwise:
            Note: Default alignment at is equal to sign
            Let clean_eq be string_replace(clean_eq, "=", "&=")
        
        Let result be result plus clean_eq
        
        If eq_index is less than List.length(equations) minus 1:
            Let result be result plus " \\\\\n"
        Otherwise:
            Let result be result plus "\n"
        
        Let eq_index be eq_index plus 1
    
    Let result be result plus "\\end{align}"
    Return result

Process called "multiline_equation_latex" that takes equation_parts as List[String], break_points as List[String] returns String:
    Note: Generate LaTeX for multiline equations with proper breaks
    Let result be "\\begin{multline}\n"
    
    Let part_index be 0
    While part_index is less than List.length(equation_parts):
        Let part be List.get(equation_parts, part_index)
        Let clean_part be clean_expression_for_latex(part)
        
        Note: Add indentation for middle lines
        If part_index is greater than 0 and part_index is less than List.length(equation_parts) minus 1:
            Let clean_part be "\\quad " plus clean_part
        
        Let result be result plus clean_part
        
        If part_index is less than List.length(equation_parts) minus 1:
            Let result be result plus " \\\\\n"
        Otherwise:
            Let result be result plus "\n"
        
        Let part_index be part_index plus 1
    
    Let result be result plus "\\end{multline}"
    Return result

Process called "equation_numbering_latex" that takes equations as List[String], numbering_scheme as String, labels as List[String] returns String:
    Note: Generate LaTeX with equation numbering and labeling
    Let environment be "align"
    
    If numbering_scheme is equal to "none":
        Let environment be "align*"
    Otherwise if numbering_scheme is equal to "single":
        Let environment be "equation"
    Otherwise if numbering_scheme is equal to "gather":
        Let environment be "gather"
    
    Let result be "\\begin{" plus environment plus "}\n"
    
    Let eq_index be 0
    While eq_index is less than List.length(equations):
        Let equation be List.get(equations, eq_index)
        Let clean_eq be clean_expression_for_latex(equation)
        
        Let result be result plus clean_eq
        
        Note: Add label if provided
        If eq_index is less than List.length(labels):
            Let label be List.get(labels, eq_index)
            If label does not equal "":
                Let result be result plus " \\label{" plus label plus "}"
        
        If eq_index is less than List.length(equations) minus 1:
            If environment is equal to "align" or environment is equal to "gather":
                Let result be result plus " \\\\\n"
            Otherwise:
                Let result be result plus "\n"
        Otherwise:
            Let result be result plus "\n"
        
        Let eq_index be eq_index plus 1
    
    Let result be result plus "\\end{" plus environment plus "}"
    Return result

Note: =====================================================================
Note: SPECIAL NOTATION OPERATIONS
Note: =====================================================================

Process called "binomial_coefficient_latex" that takes n as String, k as String, notation_style as String returns String:
    Note: Generate LaTeX for binomial coefficients (n choose k)
    Let clean_n be clean_expression_for_latex(n)
    Let clean_k be clean_expression_for_latex(k)
    
    If notation_style is equal to "parentheses":
        Return "\\binom{" plus clean_n plus "}{" plus clean_k plus "}"
    Otherwise if notation_style is equal to "bracket":
        Return "\\left[\\binom{" plus clean_n plus "}{" plus clean_k plus "}\\right]"
    Otherwise:
        Return "\\binom{" plus clean_n plus "}{" plus clean_k plus "}"

Process called "absolute_value_latex" that takes expression as String, delimiter_style as String returns String:
    Note: Generate LaTeX for absolute value with proper delimiters
    Let clean_expr be clean_expression_for_latex(expression)
    
    If delimiter_style is equal to "big":
        Return "\\left|" plus clean_expr plus "\\right|"
    Otherwise if delimiter_style is equal to "Big":
        Return "\\Big|" plus clean_expr plus "\\Big|"
    Otherwise:
        Return "|" plus clean_expr plus "|"

Process called "norm_latex" that takes expression as String, norm_type as String returns String:
    Note: Generate LaTeX for norms (L₁, L₂, L∞, etc.)
    Let clean_expr be clean_expression_for_latex(expression)
    
    If norm_type is equal to "L1":
        Return "\\|" plus clean_expr plus "\\|_1"
    Otherwise if norm_type is equal to "L2":
        Return "\\|" plus clean_expr plus "\\|_2"
    Otherwise if norm_type is equal to "Linf":
        Return "\\|" plus clean_expr plus "\\|_{\\infty}"
    Otherwise if norm_type is equal to "Frobenius":
        Return "\\|" plus clean_expr plus "\\|_F"
    Otherwise if norm_type is equal to "spectral":
        Return "\\|" plus clean_expr plus "\\|_2"
    Otherwise if norm_type is equal to "operator":
        Return "\\|" plus clean_expr plus "\\|_{\\text{op}}"
    Otherwise if norm_type is equal to "nuclear":
        Return "\\|" plus clean_expr plus "\\|_*"
    Otherwise:
        Return "\\|" plus clean_expr plus "\\|"

Process called "floor_ceiling_latex" that takes expression as String, function_type as String returns String:
    Note: Generate LaTeX for floor ⌊x⌋ and ceiling ⌈x⌉ functions
    Let clean_expr be clean_expression_for_latex(expression)
    
    If function_type is equal to "floor":
        Return "\\lfloor " plus clean_expr plus " \\rfloor"
    Otherwise if function_type is equal to "ceiling":
        Return "\\lceil " plus clean_expr plus " \\rceil"
    Otherwise if function_type is equal to "round":
        Return "\\lfloor " plus clean_expr plus " plus 0.5 \\rfloor"
    Otherwise:
        Return "\\lfloor " plus clean_expr plus " \\rfloor"

Process called "set_notation_latex" that takes set_elements as List[String], set_builder_condition as String, notation_style as String returns String:
    Note: Generate LaTeX for set notation {x | condition}
    Let result be "\\{"
    
    If List.length(set_elements) is greater than 0 and set_builder_condition is equal to "":
        Note: Enumerated set
        Let elem_index be 0
        While elem_index is less than List.length(set_elements):
            Let element be List.get(set_elements, elem_index)
            Let clean_element be clean_expression_for_latex(element)
            Let result be result plus clean_element
            
            If elem_index is less than List.length(set_elements) minus 1:
                Let result be result plus ", "
            
            Let elem_index be elem_index plus 1
    Otherwise if List.length(set_elements) is greater than 0 and set_builder_condition does not equal "":
        Note: Set builder notation
        Let variable be List.get(set_elements, 0)
        Let clean_var be clean_expression_for_latex(variable)
        Let clean_condition be clean_expression_for_latex(set_builder_condition)
        
        Let result be result plus clean_var plus " \\mid " plus clean_condition
    
    Let result be result plus "\\}"
    Return result

Note: =====================================================================
Note: DOCUMENT GENERATION OPERATIONS
Note: =====================================================================

Process called "create_latex_document" that takes document_type as String, title as String, author as String, content as String returns LaTeXDocument:
    Note: Create complete LaTeX document with proper structure
    Let latex_doc be LaTeXDocument
    Set latex_doc.document_class to document_type
    
    Let preamble be generate_document_preamble(document_type, title, author)
    Set latex_doc.preamble to preamble
    
    Let body be generate_document_body(content, title, author)
    Set latex_doc.document_body to body
    
    Set latex_doc.required_packages to ["amsmath", "amssymb", "amsfonts", "geometry"]
    Set latex_doc.custom_definitions to Map.dictionary_empty()
    Set latex_doc.bibliography to ""
    
    Return latex_doc

Process called "math_article_template" that takes title as String, author as String, abstract as String, sections as List[Dictionary[String, String]] returns LaTeXDocument:
    Note: Generate LaTeX template for mathematical articles
    Let latex_doc be LaTeXDocument
    Set latex_doc.document_class to "article"
    
    Let preamble be "\\documentclass[11pt,a4paper]{article}\n"
    Let preamble be preamble plus "\\usepackage{amsmath,amssymb,amsfonts,amsthm}\n"
    Let preamble be preamble plus "\\usepackage{geometry}\n"
    Let preamble be preamble plus "\\usepackage{graphicx}\n"
    Let preamble be preamble plus "\\usepackage{cite}\n"
    Let preamble be preamble plus "\\newtheorem{theorem}{Theorem}\n"
    Let preamble be preamble plus "\\newtheorem{lemma}{Lemma}\n"
    Let preamble be preamble plus "\\newtheorem{proposition}{Proposition}\n"
    Let preamble be preamble plus "\\newtheorem{corollary}{Corollary}\n"
    Let preamble be preamble plus "\\newtheorem{definition}{Definition}\n"
    Let preamble be preamble plus "\\title{" plus title plus "}\n"
    Let preamble be preamble plus "\\author{" plus author plus "}\n"
    Set latex_doc.preamble to preamble
    
    Let body be "\\begin{document}\n\\maketitle\n\n"
    
    If abstract does not equal "":
        Let body be body plus "\\begin{abstract}\n" plus abstract plus "\n\\end{abstract}\n\n"
    
    Let section_index be 0
    While section_index is less than List.length(sections):
        Let section be List.get(sections, section_index)
        Let section_title be Map.dictionary_get(section, "title", "")
        Let section_content be Map.dictionary_get(section, "content", "")
        
        Let body be body plus "\\section{" plus section_title plus "}\n"
        Let body be body plus section_content plus "\n\n"
        
        Let section_index be section_index plus 1
    
    Let body be body plus "\\end{document}"
    Set latex_doc.document_body to body
    
    Set latex_doc.required_packages to ["amsmath", "amssymb", "amsfonts", "amsthm", "geometry", "graphicx", "cite"]
    Set latex_doc.custom_definitions to Map.dictionary_empty()
    Set latex_doc.bibliography to ""
    
    Return latex_doc

Process called "beamer_presentation_template" that takes title as String, author as String, slides as List[Dictionary[String, String]] returns LaTeXDocument:
    Note: Generate LaTeX Beamer presentation for mathematical content
    Let latex_doc be LaTeXDocument
    Set latex_doc.document_class to "beamer"
    
    Let preamble be "\\documentclass{beamer}\n"
    Let preamble be preamble plus "\\usepackage{amsmath,amssymb,amsfonts}\n"
    Let preamble be preamble plus "\\usepackage{tikz}\n"
    Let preamble be preamble plus "\\usetheme{Madrid}\n"
    Let preamble be preamble plus "\\title{" plus title plus "}\n"
    Let preamble be preamble plus "\\author{" plus author plus "}\n"
    Let preamble be preamble plus "\\date{\\today}\n"
    Set latex_doc.preamble to preamble
    
    Let body be "\\begin{document}\n\n"
    Let body be body plus "\\frame{\\titlepage}\n\n"
    
    Let slide_index be 0
    While slide_index is less than List.length(slides):
        Let slide be List.get(slides, slide_index)
        Let slide_title be Map.dictionary_get(slide, "title", "")
        Let slide_content be Map.dictionary_get(slide, "content", "")
        
        Let body be body plus "\\begin{frame}{" plus slide_title plus "}\n"
        Let body be body plus slide_content plus "\n"
        Let body be body plus "\\end{frame}\n\n"
        
        Let slide_index be slide_index plus 1
    
    Let body be body plus "\\end{document}"
    Set latex_doc.document_body to body
    
    Set latex_doc.required_packages to ["beamer", "amsmath", "amssymb", "amsfonts", "tikz"]
    Set latex_doc.custom_definitions to Map.dictionary_empty()
    Set latex_doc.bibliography to ""
    
    Return latex_doc

Process called "homework_template" that takes course_info as Dictionary[String, String], problems as List[Dictionary[String, String]] returns LaTeXDocument:
    Note: Generate LaTeX template for mathematical homework
    Let latex_doc be LaTeXDocument
    Set latex_doc.document_class to "article"
    
    Let course_name be Map.dictionary_get(course_info, "course", "")
    Let assignment_name be Map.dictionary_get(course_info, "assignment", "")
    Let student_name be Map.dictionary_get(course_info, "student", "")
    Let due_date be Map.dictionary_get(course_info, "due_date", "")
    
    Let preamble be "\\documentclass[12pt]{article}\n"
    Let preamble be preamble plus "\\usepackage{amsmath,amssymb,amsfonts}\n"
    Let preamble be preamble plus "\\usepackage{geometry}\n"
    Let preamble be preamble plus "\\usepackage{fancyhdr}\n"
    Let preamble be preamble plus "\\geometry{margin=1in}\n"
    Let preamble be preamble plus "\\pagestyle{fancy}\n"
    Let preamble be preamble plus "\\fancyhf{}\n"
    Let preamble be preamble plus "\\rhead{" plus student_name plus "}\n"
    Let preamble be preamble plus "\\lhead{" plus course_name plus "}\n"
    Let preamble be preamble plus "\\cfoot{\\thepage}\n"
    Set latex_doc.preamble to preamble
    
    Let body be "\\begin{document}\n\n"
    Let body be body plus "\\begin{center}\n"
    Let body be body plus "\\Large \\textbf{" plus assignment_name plus "}\\\\\n"
    Let body be body plus "\\large " plus course_name plus "\\\\\n"
    Let body be body plus "Due: " plus due_date plus "\n"
    Let body be body plus "\\end{center}\n\n"
    
    Let problem_index be 0
    While problem_index is less than List.length(problems):
        Let problem be List.get(problems, problem_index)
        Let problem_text be Map.dictionary_get(problem, "problem", "")
        Let solution_space be Map.dictionary_get(problem, "solution_space", "2in")
        
        Let body be body plus "\\textbf{Problem " plus ToString(problem_index plus 1) plus ".} " plus problem_text plus "\n\n"
        Let body be body plus "\\vspace{" plus solution_space plus "}\n\n"
        
        Let problem_index be problem_index plus 1
    
    Let body be body plus "\\end{document}"
    Set latex_doc.document_body to body
    
    Set latex_doc.required_packages to ["amsmath", "amssymb", "amsfonts", "geometry", "fancyhdr"]
    Set latex_doc.custom_definitions to Map.dictionary_empty()
    Set latex_doc.bibliography to ""
    
    Return latex_doc

Note: =====================================================================
Note: TIKZ AND DIAGRAM OPERATIONS
Note: =====================================================================

Process called "function_plot_tikz" that takes function as String, domain as Dictionary[String, String], plot_options as Dictionary[String, String] returns String:
    Note: Generate TikZ code for function plotting
    Let clean_function be clean_expression_for_latex(function)
    Let x_min be Map.dictionary_get(domain, "x_min", "-5")
    Let x_max be Map.dictionary_get(domain, "x_max", "5")
    Let y_min be Map.dictionary_get(domain, "y_min", "-5")
    Let y_max be Map.dictionary_get(domain, "y_max", "5")
    
    Let samples be Map.dictionary_get(plot_options, "samples", "100")
    Let color be Map.dictionary_get(plot_options, "color", "blue")
    Let thickness be Map.dictionary_get(plot_options, "thickness", "thick")
    
    Let result be "\\begin{tikzpicture}\n"
    Let result be result plus "\\begin{axis}[\n"
    Let result be result plus "    axis lines is equal to left,\n"
    Let result be result plus "    xlabel is equal to $x$,\n"
    Let result be result plus "    ylabel is equal to {$f(x)$},\n"
    Let result be result plus "    xmin is equal to " plus x_min plus ", xmax is equal to " plus x_max plus ",\n"
    Let result be result plus "    ymin is equal to " plus y_min plus ", ymax is equal to " plus y_max plus ",\n"
    Let result be result plus "]\n"
    Let result be result plus "\\addplot [\n"
    Let result be result plus "    domain=" plus x_min plus ":" plus x_max plus ",\n"
    Let result be result plus "    samples=" plus samples plus ",\n"
    Let result be result plus "    color=" plus color plus ",\n"
    Let result be result plus "    " plus thickness plus "\n"
    Let result be result plus "]\n"
    Let result be result plus "{" plus clean_function plus "};\n"
    Let result be result plus "\\end{axis}\n"
    Let result be result plus "\\end{tikzpicture}"
    
    Return result

Process called "geometric_diagram_tikz" that takes geometric_objects as List[Dictionary[String, String]], diagram_options as Dictionary[String, String] returns String:
    Note: Generate TikZ code for geometric diagrams
    Let scale be Map.dictionary_get(diagram_options, "scale", "1")
    Let show_grid be Map.dictionary_get(diagram_options, "show_grid", "false")
    
    Let result be "\\begin{tikzpicture}[scale=" plus scale plus "]\n"
    
    If show_grid is equal to "true":
        Let result be result plus "\\draw[help lines] (-5,-5) grid (5,5);\n"
    
    Let obj_index be 0
    While obj_index is less than List.length(geometric_objects):
        Let obj be List.get(geometric_objects, obj_index)
        Let obj_type be Map.dictionary_get(obj, "type", "")
        
        If obj_type is equal to "point":
            Let x be Map.dictionary_get(obj, "x", "0")
            Let y be Map.dictionary_get(obj, "y", "0")
            Let label be Map.dictionary_get(obj, "label", "")
            Let result be result plus "\\filldraw (" plus x plus "," plus y plus ") circle (2pt)"
            If label does not equal "":
                Let result be result plus " node[above] {$" plus label plus "$}"
            Let result be result plus ";\n"
            
        Otherwise if obj_type is equal to "line":
            Let x1 be Map.dictionary_get(obj, "x1", "0")
            Let y1 be Map.dictionary_get(obj, "y1", "0")
            Let x2 be Map.dictionary_get(obj, "x2", "1")
            Let y2 be Map.dictionary_get(obj, "y2", "1")
            Let result be result plus "\\draw (" plus x1 plus "," plus y1 plus ") -- (" plus x2 plus "," plus y2 plus ");\n"
            
        Otherwise if obj_type is equal to "circle":
            Let cx be Map.dictionary_get(obj, "cx", "0")
            Let cy be Map.dictionary_get(obj, "cy", "0")
            Let radius be Map.dictionary_get(obj, "radius", "1")
            Let result be result plus "\\draw (" plus cx plus "," plus cy plus ") circle (" plus radius plus ");\n"
        
        Let obj_index be obj_index plus 1
    
    Let result be result plus "\\end{tikzpicture}"
    Return result

Process called "coordinate_system_tikz" that takes axis_type as String, range as Dictionary[String, String], grid_options as Dictionary[String, String] returns String:
    Note: Generate TikZ coordinate system with axes and grid
    Let x_min be Map.dictionary_get(range, "x_min", "-5")
    Let x_max be Map.dictionary_get(range, "x_max", "5")
    Let y_min be Map.dictionary_get(range, "y_min", "-5")
    Let y_max be Map.dictionary_get(range, "y_max", "5")
    
    Let grid_step be Map.dictionary_get(grid_options, "step", "1")
    Let show_numbers be Map.dictionary_get(grid_options, "show_numbers", "true")
    Let grid_color be Map.dictionary_get(grid_options, "color", "gray")
    
    Let result be "\\begin{tikzpicture}\n"
    
    Note: Draw grid
    Let result be result plus "\\draw[" plus grid_color plus "!30] (" plus x_min plus "," plus y_min plus ") grid[step=" plus grid_step plus "] (" plus x_max plus "," plus y_max plus ");\n"
    
    If axis_type is equal to "cartesian":
        Note: Draw axes
        Let result be result plus "\\draw[thick,->] (" plus x_min plus ",0) -- (" plus x_max plus ",0) node[right] {$x$};\n"
        Let result be result plus "\\draw[thick,->] (0," plus y_min plus ") -- (0," plus y_max plus ") node[above] {$y$};\n"
        
        If show_numbers is equal to "true":
            Note: Add tick marks and numbers
            Let result be result plus "\\foreach \\x in {" plus x_min plus ",...," plus x_max plus "} \\draw (\\x,1pt) -- (\\x,-1pt) node[anchor=north] {\\x};\n"
            Let result be result plus "\\foreach \\y in {" plus y_min plus ",...," plus y_max plus "} \\draw (1pt,\\y) -- (-1pt,\\y) node[anchor=east] {\\y};\n"
    
    Otherwise if axis_type is equal to "polar":
        Note: Draw polar coordinate system
        Let result be result plus "\\draw (0,0) circle (1);\n"
        Let result be result plus "\\draw (0,0) circle (2);\n"
        Let result be result plus "\\draw (0,0) circle (3);\n"
        Let result be result plus "\\draw (0,0) -- (3,0);\n"
        Let result be result plus "\\draw (0,0) -- (0,3);\n"
        Let result is equal to result plus "\\draw (0,0) -- (-3,0);\n"
        Let result be result plus "\\draw (0,0) -- (0,-3);\n"
    
    Let result be result plus "\\end{tikzpicture}"
    Return result

Process called "mathematical_tree_tikz" that takes tree_structure as Dictionary[String, String], node_labels as Dictionary[String, String] returns String:
    Note: Generate TikZ tree diagrams for mathematical structures
    Let tree_type be Map.dictionary_get(tree_structure, "type", "binary")
    Let root_label be Map.dictionary_get(node_labels, "root", "")
    Let depth be Map.dictionary_get(tree_structure, "depth", "3")
    
    Let result be "\\begin{tikzpicture}[\n"
    Let result be result plus "  level/.style={sibling distance is equal to 5cm/#1,\n"
    Let result be result plus "    level distance is equal to 1.5cm}\n"
    Let result be result plus "]\n"
    
    If tree_type is equal to "binary":
        Let result be result plus "\\node [circle,draw] {$" plus root_label plus "$}\n"
        
        Let left_child be Map.dictionary_get(node_labels, "left", "L")
        Let right_child be Map.dictionary_get(node_labels, "right", "R")
        
        Let result be result plus "  child { node [circle,draw] {$" plus left_child plus "$}\n"
        Let result be result plus "    child { node [circle,draw] {$" plus left_child plus "_1$} }\n"
        Let result be result plus "    child { node [circle,draw] {$" plus left_child plus "_2$} }\n"
        Let result be result plus "  }\n"
        Let result be result plus "  child { node [circle,draw] {$" plus right_child plus "$}\n"
        Let result be result plus "    child { node [circle,draw] {$" plus right_child plus "_1$} }\n"
        Let result be result plus "    child { node [circle,draw] {$" plus right_child plus "_2$} }\n"
        Let result be result plus "  }\n"
        
    Otherwise if tree_type is equal to "expression":
        Let operator be Map.dictionary_get(node_labels, "operator", "+")
        Let operand1 be Map.dictionary_get(node_labels, "operand1", "x")
        Let operand2 be Map.dictionary_get(node_labels, "operand2", "y")
        
        Let result be result plus "\\node [circle,draw] {$" plus operator plus "$}\n"
        Let result be result plus "  child { node [circle,draw] {$" plus operand1 plus "$} }\n"
        Let result be result plus "  child { node [circle,draw] {$" plus operand2 plus "$} }\n"
    
    Let result be result plus ";\n"
    Let result be result plus "\\end{tikzpicture}"
    Return result

Note: =====================================================================
Note: PACKAGE AND MACRO OPERATIONS
Note: =====================================================================

Process called "required_packages_analysis" that takes latex_content as String returns List[String]:
    Note: Analyze LaTeX content to determine required packages
    Let required_packages be List.create_list(10)
    
    Note: Always include basic math packages
    List.list_append(required_packages, "amsmath")
    List.list_append(required_packages, "amssymb")
    
    Note: Check for specific commands that require packages
    If string_contains(latex_content, "\\tikz") or string_contains(latex_content, "tikzpicture"):
        List.list_append(required_packages, "tikz")
    
    If string_contains(latex_content, "\\begin{align") or string_contains(latex_content, "\\begin{gather"):
        Note: amsmath already included
    
    If string_contains(latex_content, "\\mathbb") or string_contains(latex_content, "\\mathcal"):
        List.list_append(required_packages, "amsfonts")
    
    If string_contains(latex_content, "\\theorem") or string_contains(latex_content, "\\proof"):
        List.list_append(required_packages, "amsthm")
    
    If string_contains(latex_content, "\\includegraphics"):
        List.list_append(required_packages, "graphicx")
    
    If string_contains(latex_content, "\\cite") or string_contains(latex_content, "\\bibliography"):
        List.list_append(required_packages, "cite")
    
    If string_contains(latex_content, "\\textcolor") or string_contains(latex_content, "\\color"):
        List.list_append(required_packages, "xcolor")
    
    If string_contains(latex_content, "\\url") or string_contains(latex_content, "\\href"):
        List.list_append(required_packages, "url")
    
    Return List.list_unique(required_packages)

Process called "create_custom_command" that takes command_name as String, command_definition as String, parameters as Integer returns String:
    Note: Create custom LaTeX command definition
    Let clean_command_name be clean_expression_for_latex(command_name)
    Let clean_definition be clean_expression_for_latex(command_definition)
    
    If parameters is equal to 0:
        Return "\\newcommand{\\" plus clean_command_name plus "}{" plus clean_definition plus "}"
    Otherwise if parameters is equal to 1:
        Return "\\newcommand{\\" plus clean_command_name plus "}[1]{" plus clean_definition plus "}"
    Otherwise:
        Return "\\newcommand{\\" plus clean_command_name plus "}[" plus ToString(parameters) plus "]{" plus clean_definition plus "}"

Process called "mathematical_macros" that takes macro_category as String returns Dictionary[String, String]:
    Note: Generate common mathematical macros and shortcuts
    Let macros be Map.dictionary_empty()
    
    If macro_category is equal to "algebra":
        Map.dictionary_set(macros, "R", "\\mathbb{R}")
        Map.dictionary_set(macros, "C", "\\mathbb{C}")
        Map.dictionary_set(macros, "Z", "\\mathbb{Z}")
        Map.dictionary_set(macros, "Q", "\\mathbb{Q}")
        Map.dictionary_set(macros, "N", "\\mathbb{N}")
    
    Otherwise if macro_category is equal to "analysis":
        Map.dictionary_set(macros, "norm", "\\|#1\\|")
        Map.dictionary_set(macros, "abs", "\\left|#1\\right|")
        Map.dictionary_set(macros, "inner", "\\langle #1, #2 \\rangle")
        Map.dictionary_set(macros, "floor", "\\lfloor #1 \\rfloor")
        Map.dictionary_set(macros, "ceil", "\\lceil #1 \\rceil")
    
    Otherwise if macro_category is equal to "calculus":
        Map.dictionary_set(macros, "dd", "\\,\\mathrm{d}")
        Map.dictionary_set(macros, "deriv", "\\frac{d#1}{d#2}")
        Map.dictionary_set(macros, "pderiv", "\\frac{\\partial#1}{\\partial#2}")
        Map.dictionary_set(macros, "grad", "\\nabla")
        Map.dictionary_set(macros, "laplacian", "\\Delta")
    
    Otherwise if macro_category is equal to "probability":
        Map.dictionary_set(macros, "Pr", "\\mathbb{P}")
        Map.dictionary_set(macros, "E", "\\mathbb{E}")
        Map.dictionary_set(macros, "Var", "\\text{Var}")
        Map.dictionary_set(macros, "Cov", "\\text{Cov}")
        Map.dictionary_set(macros, "given", "\\mid")
    
    Otherwise if macro_category is equal to "linear_algebra":
        Map.dictionary_set(macros, "tr", "\\text{tr}")
        Map.dictionary_set(macros, "det", "\\det")
        Map.dictionary_set(macros, "rank", "\\text{rank}")
        Map.dictionary_set(macros, "span", "\\text{span}")
        Map.dictionary_set(macros, "ker", "\\text{ker}")
        Map.dictionary_set(macros, "im", "\\text{im}")
    
    Otherwise:
        Note: Default common macros
        Map.dictionary_set(macros, "R", "\\mathbb{R}")
        Map.dictionary_set(macros, "norm", "\\|#1\\|")
        Map.dictionary_set(macros, "deriv", "\\frac{d#1}{d#2}")
    
    Return macros

Process called "symbol_package_mapping" that takes symbols as List[String] returns Dictionary[String, String]:
    Note: Map mathematical symbols to their required LaTeX packages
    Let mapping be Map.dictionary_empty()
    
    Let symbol_index be 0
    While symbol_index is less than List.length(symbols):
        Let symbol be List.get(symbols, symbol_index)
        
        If symbol is equal to "\\mathbb" or string_contains(symbol, "\\mathbb"):
            Map.dictionary_set(mapping, symbol, "amsfonts")
        Otherwise if symbol is equal to "\\mathcal" or string_contains(symbol, "\\mathcal"):
            Map.dictionary_set(mapping, symbol, "amsfonts")
        Otherwise if symbol is equal to "\\mathfrak" or string_contains(symbol, "\\mathfrak"):
            Map.dictionary_set(mapping, symbol, "amsfonts")
        Otherwise if symbol is equal to "\\boldsymbol" or string_contains(symbol, "\\boldsymbol"):
            Map.dictionary_set(mapping, symbol, "amsmath")
        Otherwise if symbol is equal to "\\text" or string_contains(symbol, "\\text"):
            Map.dictionary_set(mapping, symbol, "amsmath")
        Otherwise if symbol is equal to "\\begin{align" or string_contains(symbol, "align"):
            Map.dictionary_set(mapping, symbol, "amsmath")
        Otherwise if symbol is equal to "\\begin{gather" or string_contains(symbol, "gather"):
            Map.dictionary_set(mapping, symbol, "amsmath")
        Otherwise if symbol is equal to "\\tikz" or string_contains(symbol, "tikz"):
            Map.dictionary_set(mapping, symbol, "tikz")
        Otherwise if symbol is equal to "\\color" or string_contains(symbol, "color"):
            Map.dictionary_set(mapping, symbol, "xcolor")
        Otherwise if symbol is equal to "\\url" or string_contains(symbol, "url"):
            Map.dictionary_set(mapping, symbol, "url")
        Otherwise:
            Note: Default to amssymb for mathematical symbols
            Map.dictionary_set(mapping, symbol, "amssymb")
        
        Let symbol_index be symbol_index plus 1
    
    Return mapping

Note: =====================================================================
Note: FORMATTING AND STYLING OPERATIONS
Note: =====================================================================

Process called "equation_spacing_optimize" that takes latex_equations as List[String], spacing_preferences as Dictionary[String, String] returns List[String]:
    Note: Optimize spacing in LaTeX equations for better readability
    Let optimized_equations be List.create_list(List.length(latex_equations))
    
    Let tight_spacing be Map.dictionary_get(spacing_preferences, "tight_spacing", "false")
    Let operator_spacing be Map.dictionary_get(spacing_preferences, "operator_spacing", "normal")
    Let fraction_spacing be Map.dictionary_get(spacing_preferences, "fraction_spacing", "normal")
    
    Let eq_index be 0
    While eq_index is less than List.length(latex_equations):
        Let equation be List.get(latex_equations, eq_index)
        Let optimized be equation
        
        Note: Optimize operator spacing
        If operator_spacing is equal to "tight":
            Let optimized be string_replace(optimized, " plus ", "+")
            Let optimized be string_replace(optimized, " minus ", "-")
            Let optimized be string_replace(optimized, " is equal to ", "=")
        Otherwise if operator_spacing is equal to "loose":
            Let optimized be string_replace(optimized, "+", " plus ")
            Let optimized be string_replace(optimized, "-", " minus ")
            Let optimized be string_replace(optimized, "=", " is equal to ")
            Let optimized be string_replace(optimized, " plus ", " \\, plus \\, ")
            Let optimized be string_replace(optimized, " minus ", " \\, minus \\, ")
            Let optimized be string_replace(optimized, " is equal to ", " \\, is equal to \\, ")
        
        Note: Optimize fraction spacing
        If fraction_spacing is equal to "tight":
            Let optimized be string_replace(optimized, "\\frac", "\\tfrac")
        Otherwise if fraction_spacing is equal to "display":
            Let optimized be string_replace(optimized, "\\frac", "\\dfrac")
        
        Note: Add general spacing improvements
        If tight_spacing is equal to "false":
            Let optimized be string_replace(optimized, "(", " (")
            Let optimized be string_replace(optimized, ")", ") ")
        
        List.list_append(optimized_equations, optimized)
        Let eq_index be eq_index plus 1
    
    Return optimized_equations

Process called "font_style_mathematics" that takes expression as String, font_style as String returns String:
    Note: Apply mathematical font styles (mathbf, mathit, mathcal, etc.)
    Let clean_expr be clean_expression_for_latex(expression)
    
    If font_style is equal to "bold":
        Return "\\mathbf{" plus clean_expr plus "}"
    Otherwise if font_style is equal to "italic":
        Return "\\mathit{" plus clean_expr plus "}"
    Otherwise if font_style is equal to "calligraphic":
        Return "\\mathcal{" plus clean_expr plus "}"
    Otherwise if font_style is equal to "script":
        Return "\\mathscr{" plus clean_expr plus "}"
    Otherwise if font_style is equal to "fraktur":
        Return "\\mathfrak{" plus clean_expr plus "}"
    Otherwise if font_style is equal to "blackboard":
        Return "\\mathbb{" plus clean_expr plus "}"
    Otherwise if font_style is equal to "roman":
        Return "\\mathrm{" plus clean_expr plus "}"
    Otherwise if font_style is equal to "sans_serif":
        Return "\\mathsf{" plus clean_expr plus "}"
    Otherwise if font_style is equal to "typewriter":
        Return "\\mathtt{" plus clean_expr plus "}"
    Otherwise:
        Return clean_expr

Process called "color_mathematical_expressions" that takes expression as String, color_scheme as Dictionary[String, String] returns String:
    Note: Apply color coding to mathematical expressions
    Let clean_expr be clean_expression_for_latex(expression)
    Let default_color be Map.dictionary_get(color_scheme, "default", "black")
    Let variable_color be Map.dictionary_get(color_scheme, "variables", "blue")
    Let constant_color be Map.dictionary_get(color_scheme, "constants", "red")
    Let operator_color be Map.dictionary_get(color_scheme, "operators", "purple")
    
    Let result be clean_expr
    
    Note: Color operators
    Let result be string_replace(result, "+", "\\textcolor{" plus operator_color plus "}{+}")
    Let result be string_replace(result, "-", "\\textcolor{" plus operator_color plus "}{-}")
    Let result be string_replace(result, "=", "\\textcolor{" plus operator_color plus "}{=}")
    Let result be string_replace(result, "\\times", "\\textcolor{" plus operator_color plus "}{\\times}")
    
    Note: Color constants (simple digit detection)
    Let result is equal to string_replace(result, "0", "\\textcolor{" plus constant_color plus "}{0}")
    Let result be string_replace(result, "1", "\\textcolor{" plus constant_color plus "}{1}")
    Let result be string_replace(result, "2", "\\textcolor{" plus constant_color plus "}{2}")
    Let result be string_replace(result, "\\pi", "\\textcolor{" plus constant_color plus "}{\\pi}")
    Let result be string_replace(result, "e", "\\textcolor{" plus constant_color plus "}{e}")
    
    Note: Color common variables
    Let result be string_replace(result, "x", "\\textcolor{" plus variable_color plus "}{x}")
    Let result be string_replace(result, "y", "\\textcolor{" plus variable_color plus "}{y}")
    Let result be string_replace(result, "z", "\\textcolor{" plus variable_color plus "}{z}")
    
    Return result

Process called "line_breaking_optimization" that takes long_expression as String, line_width as Integer returns String:
    Note: Optimize line breaking for long mathematical expressions
    Let clean_expr be clean_expression_for_latex(long_expression)
    
    If string_length(clean_expr) is less than or equal to line_width:
        Return clean_expr
    
    Let result be ""
    Let current_line_length be 0
    Let index be 0
    
    While index is less than string_length(clean_expr):
        Let char be get_character_at(clean_expr, index)
        
        Note: Look for good break points
        If char is equal to "+" or char is equal to "-" or char is equal to "=":
            If current_line_length is greater than line_width multiplied by 3 / 4:
                Let result be result plus char plus " \\\\\n&\\quad "
                Let current_line_length be 6
            Otherwise:
                Let result be result plus char
                Let current_line_length be current_line_length plus 1
        
        Otherwise if char is equal to ",":
            If current_line_length is greater than line_width multiplied by 2 / 3:
                Let result be result plus char plus " \\\\\n&\\quad "
                Let current_line_length be 6
            Otherwise:
                Let result be result plus char
                Let current_line_length be current_line_length plus 1
        
        Otherwise:
            Let result be result plus char
            Let current_line_length be current_line_length plus 1
        
        Let index be index plus 1
    
    Return result

Note: =====================================================================
Note: VALIDATION AND UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_latex_syntax" that takes latex_code as String returns List[String]:
    Note: Validate LaTeX mathematical syntax and report errors
    Let errors be List.create_list(5)
    
    Note: Check for balanced braces
    If not check_balanced_braces(latex_code):
        List.list_append(errors, "Unbalanced braces detected")
    
    Note: Check for invalid commands
    If contains_invalid_commands(latex_code):
        List.list_append(errors, "Invalid LaTeX commands found")
    
    Note: Check for proper math mode
    If not check_math_mode_consistency(latex_code):
        List.list_append(errors, "Inconsistent math mode usage")
    
    Return errors

Process called "latex_compilation_check" that takes latex_document as LaTeXDocument, compiler as String returns Dictionary[String, String]:
    Note: Check LaTeX document for compilation errors
    Let check_results be Map.dictionary_empty()
    
    Map.dictionary_set(check_results, "compiler", compiler)
    Map.dictionary_set(check_results, "status", "success")
    Map.dictionary_set(check_results, "warnings", "0")
    Map.dictionary_set(check_results, "errors", "0")
    
    Let full_document be latex_document.preamble plus "\n" plus latex_document.document_body
    
    Note: Check for basic structural errors
    If not check_balanced_braces(full_document):
        Map.dictionary_set(check_results, "status", "error")
        Map.dictionary_set(check_results, "errors", "1")
        Map.dictionary_set(check_results, "error_message", "Unbalanced braces detected")
        Return check_results
    
    Note: Check for missing required packages
    Let required_packages be required_packages_analysis(latex_document.document_body)
    Let missing_packages be List.create_list(5)
    
    Let pkg_index be 0
    While pkg_index is less than List.length(required_packages):
        Let required_pkg be List.get(required_packages, pkg_index)
        
        If not string_contains(latex_document.preamble, required_pkg):
            List.list_append(missing_packages, required_pkg)
        
        Let pkg_index be pkg_index plus 1
    
    If List.length(missing_packages) is greater than 0:
        Map.dictionary_set(check_results, "status", "warning")
        Map.dictionary_set(check_results, "warnings", ToString(List.length(missing_packages)))
        
        Let missing_list be List.list_reduce(missing_packages, "concatenate", "")
        Map.dictionary_set(check_results, "warning_message", "Missing packages: " plus missing_list)
    
    Note: Check for undefined commands
    If contains_invalid_commands(full_document):
        Map.dictionary_set(check_results, "status", "error")
        Map.dictionary_set(check_results, "errors", "1")
        Map.dictionary_set(check_results, "error_message", "Invalid LaTeX commands found")
    
    Return check_results

Process called "optimize_latex_performance" that takes latex_document as LaTeXDocument returns LaTeXDocument:
    Note: Optimize LaTeX document for faster compilation
    Let optimized_doc be latex_document
    
    Note: Optimize preamble
    Let optimized_preamble be latex_document.preamble
    
    Note: Remove duplicate package imports
    Let optimized_preamble be remove_duplicate_packages(optimized_preamble)
    
    Note: Optimize document body
    Let optimized_body be latex_document.document_body
    
    Note: Replace inefficient constructs
    Let optimized_body be string_replace(optimized_body, "\\dfrac", "\\frac")
    Let optimized_body be string_replace(optimized_body, "\\left(", "(")
    Let optimized_body be string_replace(optimized_body, "\\right)", ")")
    
    Note: Simplify repeated constructs
    Let optimized_body be string_replace(optimized_body, "\\quad\\quad", "\\qquad")
    Let optimized_body be string_replace(optimized_body, "\\,\\,", "\\;")
    
    Note: Remove excessive whitespace
    Let optimized_body be string_replace(optimized_body, "  ", " ")
    Let optimized_body is equal to string_replace(optimized_body, "\n\n\n", "\n\n")
    
    Set optimized_doc.preamble to optimized_preamble
    Set optimized_doc.document_body to optimized_body
    
    Return optimized_doc

Process called "convert_unicode_to_latex" that takes unicode_math as String returns String:
    Note: Convert Unicode mathematical symbols to LaTeX commands
    Let result be unicode_math
    
    Note: Greek letters
    Let result be string_replace(result, "α", "\\alpha")
    Let result be string_replace(result, "β", "\\beta")
    Let result be string_replace(result, "γ", "\\gamma")
    Let result be string_replace(result, "δ", "\\delta")
    Let result be string_replace(result, "ε", "\\epsilon")
    Let result be string_replace(result, "θ", "\\theta")
    Let result be string_replace(result, "λ", "\\lambda")
    Let result be string_replace(result, "μ", "\\mu")
    Let result be string_replace(result, "π", "\\pi")
    Let result be string_replace(result, "ρ", "\\rho")
    Let result be string_replace(result, "σ", "\\sigma")
    Let result be string_replace(result, "τ", "\\tau")
    Let result be string_replace(result, "φ", "\\phi")
    Let result be string_replace(result, "χ", "\\chi")
    Let result be string_replace(result, "ψ", "\\psi")
    Let result be string_replace(result, "ω", "\\omega")
    
    Note: Uppercase Greek letters
    Let result be string_replace(result, "Γ", "\\Gamma")
    Let result be string_replace(result, "Δ", "\\Delta")
    Let result be string_replace(result, "Θ", "\\Theta")
    Let result be string_replace(result, "Λ", "\\Lambda")
    Let result be string_replace(result, "Ξ", "\\Xi")
    Let result be string_replace(result, "Π", "\\Pi")
    Let result be string_replace(result, "Σ", "\\Sigma")
    Let result be string_replace(result, "Φ", "\\Phi")
    Let result be string_replace(result, "Ψ", "\\Psi")
    Let result be string_replace(result, "Ω", "\\Omega")
    
    Note: Mathematical operators
    Let result be string_replace(result, "∑", "\\sum")
    Let result be string_replace(result, "∏", "\\prod")
    Let result be string_replace(result, "∫", "\\int")
    Let result be string_replace(result, "∂", "\\partial")
    Let result be string_replace(result, "∇", "\\nabla")
    Let result be string_replace(result, "∞", "\\infty")
    
    Note: Set theory symbols
    Let result be string_replace(result, "∈", "\\in")
    Let result be string_replace(result, "∉", "\\notin")
    Let result be string_replace(result, "⊂", "\\subset")
    Let result be string_replace(result, "⊃", "\\supset")
    Let result be string_replace(result, "⊆", "\\subseteq")
    Let result be string_replace(result, "⊇", "\\supseteq")
    Let result be string_replace(result, "∪", "\\cup")
    Let result be string_replace(result, "∩", "\\cap")
    Let result be string_replace(result, "∅", "\\emptyset")
    
    Note: Logic symbols
    Let result be string_replace(result, "∧", "\\land")
    Let result be string_replace(result, "∨", "\\lor")
    Let result be string_replace(result, "¬", "\\neg")
    Let result be string_replace(result, "→", "\\rightarrow")
    Let result be string_replace(result, "↔", "\\leftrightarrow")
    Let result be string_replace(result, "∀", "\\forall")
    Let result be string_replace(result, "∃", "\\exists")
    
    Note: Comparison operators
    Let result be string_replace(result, "≤", "\\leq")
    Let result be string_replace(result, "≥", "\\geq")
    Let result be string_replace(result, "≠", "\\neq")
    Let result be string_replace(result, "≈", "\\approx")
    Let result be string_replace(result, "≡", "\\equiv")
    Let result be string_replace(result, "∝", "\\propto")
    
    Note: Arrows
    Let result be string_replace(result, "⇒", "\\Rightarrow")
    Let result be string_replace(result, "⇔", "\\Leftrightarrow")
    Let result be string_replace(result, "↦", "\\mapsto")
    
    Note: Misc symbols
    Let result be string_replace(result, "±", "\\pm")
    Let result be string_replace(result, "∓", "\\mp")
    Let result be string_replace(result, "×", "\\times")
    Let result be string_replace(result, "÷", "\\div")
    Let result be string_replace(result, "∗", "\\ast")
    
    Return result

Process called "benchmark_latex_operations" that takes operation_types as List[String], test_expressions as List[String] returns Dictionary[String, Float]:
    Note: Benchmark performance of LaTeX generation operations
    Let benchmark_results be Map.dictionary_empty()
    
    Let operation_index be 0
    While operation_index is less than List.length(operation_types):
        Let operation_type be List.get(operation_types, operation_index)
        Let start_time be get_current_time_milliseconds()
        
        Note: Run benchmark for this operation type
        Let expr_index be 0
        While expr_index is less than List.length(test_expressions):
            Let test_expr be List.get(test_expressions, expr_index)
            
            If operation_type is equal to "expression_conversion":
                Let temp_result be expression_to_latex(test_expr, Map.dictionary_empty())
            Otherwise if operation_type is equal to "inline_formatting":
                Let temp_result be inline_math_format(test_expr)
            
            Let expr_index be expr_index plus 1
        
        Let end_time be get_current_time_milliseconds()
        Let duration be end_time minus start_time
        Map.dictionary_set(benchmark_results, operation_type, ToString(duration))
        
        Let operation_index be operation_index plus 1
    
    Return benchmark_results

Note: =====================================================================
Note: HELPER FUNCTIONS FOR LATEX GENERATION
Note: =====================================================================

Process called "parse_expression_to_latex" that takes expression as String, options as Dictionary[String, String] returns String:
    Note: Parse and convert mathematical expression to LaTeX
    Let cleaned_expr be clean_expression_for_latex(expression)
    Let result be replace_special_symbols(cleaned_expr)
    Return result

Process called "clean_expression_for_latex" that takes expression as String returns String:
    Note: Clean and escape expression for LaTeX formatting
    Let result be expression
    
    Note: Replace common problematic characters
    Let result be string_replace(result, "&", "\\&")
    Let result be string_replace(result, "%", "\\%")
    Let result be string_replace(result, "$", "\\$")
    Let result be string_replace(result, "#", "\\#")
    Let result be string_replace(result, "_", "\\_")
    Let result be string_replace(result, "{", "\\{")
    Let result be string_replace(result, "}", "\\}")
    
    Return result

Process called "string_replace" that takes text as String, find as String, replace as String returns String:
    Note: Replace all occurrences of find with replace in text
    Let result be ""
    Let index be 0
    Let find_length be string_length(find)
    
    While index is less than string_length(text):
        Let remaining_text be substring_from(text, index)
        
        If starts_with(remaining_text, find):
            Let result be result plus replace
            Let index be index plus find_length
        Otherwise:
            Let char be get_character_at(text, index)
            Let result be result plus char
            Let index be index plus 1
    
    Return result

Process called "needs_grouping" that takes expression as String returns Boolean:
    Note: Check if expression needs braces for grouping
    If string_contains(expression, " "):
        Return true
    Otherwise if string_contains(expression, "+"):
        Return true
    Otherwise if string_contains(expression, "-"):
        Return true
    Otherwise if string_contains(expression, "*"):
        Return true
    Otherwise if string_contains(expression, "/"):
        Return true
    Otherwise:
        Return false

Process called "get_matrix_delimiters" that takes matrix_type as String returns Dictionary[String, String]:
    Note: Get delimiter pair for matrix type
    Let delimiters be Map.dictionary_empty()
    
    If matrix_type is equal to "pmatrix":
        Map.dictionary_set(delimiters, "left", "(")
        Map.dictionary_set(delimiters, "right", ")")
    Otherwise if matrix_type is equal to "bmatrix":
        Map.dictionary_set(delimiters, "left", "[")
        Map.dictionary_set(delimiters, "right", "]")
    Otherwise if matrix_type is equal to "vmatrix":
        Map.dictionary_set(delimiters, "left", "|")
        Map.dictionary_set(delimiters, "right", "|")
    Otherwise if matrix_type is equal to "Vmatrix":
        Map.dictionary_set(delimiters, "left", "||")
        Map.dictionary_set(delimiters, "right", "||")
    Otherwise:
        Map.dictionary_set(delimiters, "left", "")
        Map.dictionary_set(delimiters, "right", "")
    
    Return delimiters

Process called "generate_column_vector_latex" that takes components as List[String] returns String:
    Note: Generate LaTeX for column vector
    Let result be "\\begin{pmatrix}"
    Let index be 0
    
    While index is less than List.length(components):
        Let component be List.get(components, index)
        Let clean_component be clean_expression_for_latex(component)
        Let result be result plus clean_component
        
        If index is less than List.length(components) minus 1:
            Let result be result plus " \\\\ "
        
        Let index be index plus 1
    
    Let result be result plus "\\end{pmatrix}"
    Return result

Process called "generate_row_vector_latex" that takes components as List[String] returns String:
    Note: Generate LaTeX for row vector
    Let result be "\\begin{pmatrix}"
    Let index be 0
    
    While index is less than List.length(components):
        Let component be List.get(components, index)
        Let clean_component be clean_expression_for_latex(component)
        Let result be result plus clean_component
        
        If index is less than List.length(components) minus 1:
            Let result be result plus " & "
        
        Let index be index plus 1
    
    Let result be result plus "\\end{pmatrix}"
    Return result

Process called "generate_arrow_vector_latex" that takes components as List[String] returns String:
    Note: Generate LaTeX for arrow vector notation
    Let result be "\\vec{"
    
    If List.length(components) is equal to 1:
        Let component be List.get(components, 0)
        Let result be result plus clean_expression_for_latex(component)
    Otherwise:
        Let result be result plus "v"
    
    Let result be result plus "}"
    Return result

Note: Helper functions for symbols and special characters

Process called "get_symbol_latex_command" that takes symbol_name as String, context as String returns String:
    Note: Get LaTeX command for mathematical symbol
    If symbol_name is equal to "alpha":
        Return "\\alpha"
    Otherwise if symbol_name is equal to "beta":
        Return "\\beta"
    Otherwise if symbol_name is equal to "gamma":
        Return "\\gamma"
    Otherwise if symbol_name is equal to "delta":
        Return "\\delta"
    Otherwise if symbol_name is equal to "pi":
        Return "\\pi"
    Otherwise if symbol_name is equal to "theta":
        Return "\\theta"
    Otherwise:
        Return "\\" plus symbol_name

Process called "get_symbol_unicode" that takes symbol_name as String returns String:
    Note: Get Unicode representation of symbol
    If symbol_name is equal to "alpha":
        Return "α"
    Otherwise if symbol_name is equal to "beta":
        Return "β"
    Otherwise if symbol_name is equal to "gamma":
        Return "γ"
    Otherwise if symbol_name is equal to "pi":
        Return "π"
    Otherwise:
        Return symbol_name

Process called "get_symbol_required_package" that takes symbol_name as String returns String:
    Note: Get required LaTeX package for symbol
    Return "amssymb"

Process called "get_greek_letter_by_name" that takes letter_name as String returns String:
    Note: Get Greek letter information by name
    Return letter_name

Process called "get_greek_uppercase_latex" that takes letter_name as String returns String:
    Note: Get uppercase Greek letter LaTeX command
    If letter_name is equal to "alpha":
        Return "A"
    Otherwise if letter_name is equal to "beta":
        Return "B"
    Otherwise if letter_name is equal to "gamma":
        Return "\\Gamma"
    Otherwise if letter_name is equal to "delta":
        Return "\\Delta"
    Otherwise if letter_name is equal to "pi":
        Return "\\Pi"
    Otherwise if letter_name is equal to "theta":
        Return "\\Theta"
    Otherwise:
        Let uppercase_name be to_uppercase_first_letter(letter_name)
        Return "\\" plus uppercase_name

Process called "get_greek_lowercase_latex" that takes letter_name as String returns String:
    Note: Get lowercase Greek letter LaTeX command
    Return "\\" plus letter_name

Process called "get_integral_symbol" that takes integral_type as String returns String:
    Note: Get integral symbol based on type
    If integral_type is equal to "double":
        Return "\\iint"
    Otherwise if integral_type is equal to "triple":
        Return "\\iiint"
    Otherwise if integral_type is equal to "contour":
        Return "\\oint"
    Otherwise:
        Return "\\int"

Process called "format_integral_limits" that takes limits as Dictionary[String, String] returns String:
    Note: Format integral limits
    Let lower_limit be Map.dictionary_get(limits, "lower", "")
    Let upper_limit be Map.dictionary_get(limits, "upper", "")
    
    If lower_limit is equal to "" and upper_limit is equal to "":
        Return ""
    Otherwise if lower_limit is equal to "":
        Return "^{" plus upper_limit plus "}"
    Otherwise if upper_limit is equal to "":
        Return "_{" plus lower_limit plus "}"
    Otherwise:
        Return "_{" plus lower_limit plus "}^{" plus upper_limit plus "}"

Process called "get_prime_notation" that takes order as Integer returns String:
    Note: Get prime notation for derivatives
    If order is equal to 1:
        Return "'"
    Otherwise if order is equal to 2:
        Return "''"
    Otherwise if order is equal to 3:
        Return "'''"
    Otherwise:
        Return "^{(" plus ToString(order) plus ")}"

Note: Basic string utility functions

Process called "string_length" that takes text as String returns Integer:
    Note: Get length of string
    Return text.length()

Process called "substring_from" that takes text as String, start_index as Integer returns String:
    Note: Get substring from start index to end
    Return text.substring(start_index)

Process called "starts_with" that takes text as String, prefix as String returns Boolean:
    Note: Check if text starts with prefix
    Return text.startsWith(prefix)

Process called "string_contains" that takes text as String, substring as String returns Boolean:
    Note: Check if text contains substring
    Return text.contains(substring)

Process called "get_character_at" that takes text as String, index as Integer returns String:
    Note: Get character at specific index
    Return text.charAt(index)

Process called "to_uppercase_first_letter" that takes text as String returns String:
    Note: Convert first letter to uppercase
    If string_length(text) is equal to 0:
        Return text
    
    Let first_char be get_character_at(text, 0)
    Let rest be substring_from(text, 1)
    Let uppercase_first be first_char.toUpperCase()
    
    Return uppercase_first plus rest

Process called "get_current_time_milliseconds" that returns Integer:
    Note: Get current time in milliseconds for benchmarking
    Note: Uses system-specific time retrieval
    Let current_time be SystemTime.get_milliseconds()
    If current_time is greater than 0:
        Return current_time
    Otherwise:
        Note: Fallback for systems without millisecond precision
        Let seconds is equal to SystemTime.get_seconds()
        Return seconds multiplied by 1000

Process called "replace_special_symbols" that takes expression as String returns String:
    Note: Replace mathematical symbols with LaTeX equivalents
    Let result be expression
    
    Note: Replace common mathematical symbols
    Let result be string_replace(result, "α", "\\alpha")
    Let result be string_replace(result, "β", "\\beta")
    Let result be string_replace(result, "π", "\\pi")
    Let result be string_replace(result, "θ", "\\theta")
    Let result be string_replace(result, "∞", "\\infty")
    Let result be string_replace(result, "∈", "\\in")
    Let result be string_replace(result, "⊂", "\\subset")
    Let result be string_replace(result, "∪", "\\cup")
    Let result be string_replace(result, "∩", "\\cap")
    
    Return result

Note: Document generation helper functions

Process called "generate_document_preamble" that takes document_class as String, title as String, author as String returns String:
    Note: Generate LaTeX document preamble
    Let preamble be "\\documentclass{" plus document_class plus "}\n"
    Let preamble be preamble plus "\\usepackage{amsmath}\n"
    Let preamble be preamble plus "\\usepackage{amssymb}\n"
    Let preamble be preamble plus "\\usepackage{amsfonts}\n"
    Let preamble be preamble plus "\\usepackage{geometry}\n"
    
    If title does not equal "":
        Let preamble be preamble plus "\\title{" plus title plus "}\n"
    
    If author does not equal "":
        Let preamble be preamble plus "\\author{" plus author plus "}\n"
    
    Let preamble be preamble plus "\\date{\\today}\n"
    
    Return preamble

Process called "generate_document_body" that takes content as String, title as String, author as String returns String:
    Note: Generate LaTeX document body
    Let body be "\\begin{document}\n"
    
    If title does not equal "" or author does not equal "":
        Let body be body plus "\\maketitle\n\n"
    
    Let body be body plus content plus "\n"
    Let body be body plus "\\end{document}\n"
    
    Return body

Note: Validation helper functions

Process called "check_balanced_braces" that takes latex_code as String returns Boolean:
    Note: Check if braces are balanced in LaTeX code
    Let open_count be 0
    Let close_count be 0
    Let index be 0
    
    While index is less than string_length(latex_code):
        Let char be get_character_at(latex_code, index)
        
        If char is equal to "{":
            Let open_count be open_count plus 1
        Otherwise if char is equal to "}":
            Let close_count be close_count plus 1
        
        Let index be index plus 1
    
    Return open_count is equal to close_count

Process called "contains_invalid_commands" that takes latex_code as String returns Boolean:
    Note: Check for common invalid LaTeX command patterns
    Let invalid_patterns be List.create_list(10)
    
    Note: Malformed command patterns
    List.list_append(invalid_patterns, "\\\\\\")
    List.list_append(invalid_patterns, "\\begin{begin")
    List.list_append(invalid_patterns, "\\end{end")
    List.list_append(invalid_patterns, "\\}")
    List.list_append(invalid_patterns, "\\{")
    
    Note: Unmatched environment patterns  
    List.list_append(invalid_patterns, "\\begin{} ")
    List.list_append(invalid_patterns, "\\end{} ")
    
    Note: Invalid nesting patterns
    List.list_append(invalid_patterns, "\\begin{equation}\\begin{equation}")
    List.list_append(invalid_patterns, "\\end{align}\\end{equation}")
    
    Note: Malformed math mode
    List.list_append(invalid_patterns, "$$$")
    
    Let pattern_index be 0
    While pattern_index is less than List.length(invalid_patterns):
        Let pattern be List.get(invalid_patterns, pattern_index)
        
        If string_contains(latex_code, pattern):
            Return true
        
        Let pattern_index be pattern_index plus 1
    
    Return false

Process called "check_math_mode_consistency" that takes latex_code as String returns Boolean:
    Note: Check for consistent math mode usage
    Let dollar_count be count_character_occurrences(latex_code, "$")
    
    Note: Dollar signs should come in pairs
    Return dollar_count % 2 is equal to 0

Process called "count_character_occurrences" that takes text as String, character as String returns Integer:
    Note: Count occurrences of character in text
    Let count be 0
    Let index be 0
    
    While index is less than string_length(text):
        Let char be get_character_at(text, index)
        
        If char is equal to character:
            Let count be count plus 1
        
        Let index be index plus 1
    
    Return count

Note: Additional symbol helper functions

Process called "get_calculus_symbol_latex" that takes symbol_name as String returns String:
    Note: Get LaTeX for calculus symbols
    If symbol_name is equal to "gradient":
        Return "\\nabla"
    Otherwise if symbol_name is equal to "laplacian":
        Return "\\Delta"
    Otherwise if symbol_name is equal to "partial":
        Return "\\partial"
    Otherwise:
        Return "\\" plus symbol_name

Process called "get_set_theory_symbol_latex" that takes symbol_type as String returns String:
    Note: Get LaTeX for set theory symbols
    If symbol_type is equal to "complement":
        Return "^c"
    Otherwise if symbol_type is equal to "power_set":
        Return "\\mathcal{P}"
    Otherwise:
        Return "\\" plus symbol_type

Process called "get_logic_symbol_latex" that takes symbol_type as String returns String:
    Note: Get LaTeX for logic symbols
    If symbol_type is equal to "bottom":
        Return "\\bot"
    Otherwise if symbol_type is equal to "top":
        Return "\\top"
    Otherwise:
        Return "\\" plus symbol_type

Note: LaTeX parsing helper functions

Process called "parse_latex_fractions" that takes latex_code as String returns String:
    Note: Parse LaTeX fractions back to standard notation
    Let result be latex_code
    
    Note: Handle \frac{a}{b} format
    Let result be string_replace(result, "\\frac{", "(")
    Let result be string_replace(result, "}{", ")/(/")
    Let result be string_replace(result, "}", ")")
    
    Note: Clean up fraction formatting
    Let result be string_replace(result, ")/(/", ")/(")
    
    Return result

Process called "parse_latex_scripts" that takes latex_code as String returns String:
    Note: Parse LaTeX superscripts and subscripts
    Let result be latex_code
    
    Note: Handle superscripts
    Let result be string_replace(result, "^{", "^(")
    Let result be string_replace(result, "_{", "_(")
    
    Note: For simple single character scripts
    Let result be string_replace(result, "^2", "^2")
    Let result be string_replace(result, "^3", "^3")
    
    Return result

Note: Additional helper functions for the remaining implementations

Process called "get_total_order" that takes orders as List[Integer] returns Integer:
    Note: Calculate total order for mixed partial derivatives
    Let total be 0
    Let index be 0
    
    While index is less than List.length(orders):
        Let order be List.get(orders, index)
        Let total be total plus order
        Let index be index plus 1
    
    Return total

Process called "generate_block_row" that takes left_block as List[List[String]], right_block as List[List[String]], spacing_style as String returns String:
    Note: Generate a row of blocks for block matrix
    Let result be ""
    
    Note: Generate left block
    If List.length(left_block) is greater than 0:
        Let result be result plus generate_matrix_content(left_block)
    
    Note: Add block separator
    Let result be result plus " & "
    
    Note: Generate right block
    If List.length(right_block) is greater than 0:
        Let result be result plus generate_matrix_content(right_block)
    
    Return result

Process called "generate_matrix_content" that takes matrix_entries as List[List[String]] returns String:
    Note: Generate matrix content without environment
    Let result be ""
    
    Let row_index be 0
    While row_index is less than List.length(matrix_entries):
        Let row be List.get(matrix_entries, row_index)
        
        Let col_index be 0
        While col_index is less than List.length(row):
            Let entry be List.get(row, col_index)
            Let clean_entry be clean_expression_for_latex(entry)
            Let result be result plus clean_entry
            
            If col_index is less than List.length(row) minus 1:
                Let result be result plus " & "
            
            Let col_index be col_index plus 1
        
        If row_index is less than List.length(matrix_entries) minus 1:
            Let result be result plus " \\\\ "
        
        Let row_index be row_index plus 1
    
    Return result

Process called "get_matrix_environment_start" that takes delimiter_style as String returns String:
    Note: Get opening matrix environment
    If delimiter_style is equal to "pmatrix":
        Return "\\begin{pmatrix}\n"
    Otherwise if delimiter_style is equal to "bmatrix":
        Return "\\begin{bmatrix}\n"
    Otherwise if delimiter_style is equal to "vmatrix":
        Return "\\begin{vmatrix}\n"
    Otherwise:
        Return "\\begin{matrix}\n"

Process called "get_matrix_environment_end" that takes delimiter_style as String returns String:
    Note: Get closing matrix environment
    If delimiter_style is equal to "pmatrix":
        Return "\\end{pmatrix}"
    Otherwise if delimiter_style is equal to "bmatrix":
        Return "\\end{bmatrix}"
    Otherwise if delimiter_style is equal to "vmatrix":
        Return "\\end{vmatrix}"
    Otherwise:
        Return "\\end{matrix}"

Process called "remove_duplicate_packages" that takes preamble as String returns String:
    Note: Remove duplicate package imports from preamble
    Let lines be string_split_lines(preamble)
    Let unique_lines be List.create_list(List.length(lines))
    
    Let line_index be 0
    While line_index is less than List.length(lines):
        Let line be List.get(lines, line_index)
        
        If string_contains(line, "\\usepackage"):
            Note: Check if this package is already included
            Let already_included be false
            Let check_index be 0
            
            While check_index is less than List.length(unique_lines):
                Let existing_line be List.get(unique_lines, check_index)
                If line is equal to existing_line:
                    Let already_included be true
                    Break
                Let check_index be check_index plus 1
            
            If not already_included:
                List.list_append(unique_lines, line)
        Otherwise:
            List.list_append(unique_lines, line)
        
        Let line_index be line_index plus 1
    
    Return List.list_reduce(unique_lines, "concatenate", "")

Process called "string_split_lines" that takes text as String returns List[String]:
    Note: Split text into lines
    Let lines be List.create_list(10)
    Let current_line be ""
    Let index be 0
    
    While index is less than string_length(text):
        Let char be get_character_at(text, index)
        
        If char is equal to "\n":
            List.list_append(lines, current_line)
            Let current_line be ""
        Otherwise:
            Let current_line be current_line plus char
        
        Let index be index plus 1
    
    If current_line does not equal "":
        List.list_append(lines, current_line)
    
    Return lines