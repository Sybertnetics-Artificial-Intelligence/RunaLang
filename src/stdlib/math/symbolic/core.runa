Note:
math/symbolic/core.runa
Symbolic Mathematics Engine Core Infrastructure

This module provides the foundational symbolic mathematics engine including:
- Symbolic expression representation and manipulation
- Abstract syntax trees for mathematical expressions
- Symbol table management and variable binding
- Expression simplification and normalization algorithms
- Symbolic pattern matching and substitution systems
- Expression parsing and construction utilities
- Symbolic expression evaluation with variable contexts
- Memory management for symbolic computation trees
- Expression comparison and equivalence testing
- Symbolic expression serialization and deserialization
- Performance optimization for symbolic operations
- Debugging and introspection tools for symbolic expressions
- Integration with numerical computation fallback systems
- Symbolic expression caching and memoization
- Error handling and validation for symbolic operations
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "data/collections/core/stack" as Stack
Import module "data/collections/core/map" as Map  
Import module "data/collections/core/list" as ListOps
Import module "data/collections/trees/binary_tree" as Tree
Import module "text/string/manipulation" as StringOps
Import module "text/string/core" as StringCore
Import module "text/parsing/expression_parser" as ExprParser
Import module "data/collections/core/queue" as Queue
Import module "text/core/tokenization" as Tokenizer

Note: =====================================================================
Note: SYMBOLIC EXPRESSION DATA STRUCTURES
Note: =====================================================================

Type called "SymbolicExpression":
    expression_type as String
    operator_type as String
    operands as List[SymbolicExpression]
    symbol_name as String
    constant_value as String
    expression_id as String
    metadata as Dictionary[String, String]
    complexity_measure as Integer

Type called "SymbolTable":
    symbol_definitions as Dictionary[String, SymbolicExpression]
    variable_bindings as Dictionary[String, String]
    function_definitions as Dictionary[String, Dictionary[String, String]]
    constant_definitions as Dictionary[String, String]
    scope_hierarchy as List[Dictionary[String, String]]
    namespace_contexts as Dictionary[String, Dictionary[String, String]]

Type called "ExpressionPattern":
    pattern_type as String
    pattern_structure as String
    match_constraints as Dictionary[String, String]
    capture_groups as Dictionary[String, String]
    pattern_variables as List[String]
    pattern_precedence as Integer

Type called "SimplificationRule":
    rule_name as String
    pattern_match as ExpressionPattern
    replacement_pattern as ExpressionPattern
    application_conditions as List[String]
    rule_priority as Integer
    rule_category as String

Type called "SymbolicContext":
    variable_assignments as Dictionary[String, SymbolicExpression]
    function_definitions as Dictionary[String, String]
    simplification_settings as Dictionary[String, Boolean]
    numerical_precision as Integer
    symbolic_assumptions as Dictionary[String, List[String]]

Note: =====================================================================
Note: EXPRESSION CONSTRUCTION OPERATIONS
Note: =====================================================================

Process called "create_symbol" that takes symbol_name as String, symbol_properties as Dictionary[String, String] returns SymbolicExpression:
    Note: Create a symbolic variable or constant
    Let symbol_id be "sym_" plus symbol_name
    Let complexity be 1
    
    Note: Check if it's a constant based on properties
    Let expr_type be "variable"
    If Map.contains_key(symbol_properties, "type") and Map.get(symbol_properties, "type") is equal to "constant":
        Let expr_type be "constant"
    
    Return SymbolicExpression with:
        expression_type is equal to expr_type
        operator_type is equal to ""
        operands is equal to ListOps.create()
        symbol_name is equal to symbol_name
        constant_value is equal to if expr_type is equal to "constant" then symbol_name otherwise ""
        expression_id is equal to symbol_id
        metadata is equal to symbol_properties
        complexity_measure is equal to complexity

Process called "create_constant" that takes constant_value as String, constant_type as String returns SymbolicExpression:
    Note: Create a symbolic constant with specified type
    Let constant_id be "const_" plus constant_value plus "_" plus constant_type
    Let metadata be Map.create()
    Map.put(metadata, "type", constant_type)
    Map.put(metadata, "value", constant_value)
    
    Return SymbolicExpression with:
        expression_type is equal to "constant"
        operator_type is equal to ""
        operands is equal to ListOps.create()
        symbol_name is equal to ""
        constant_value is equal to constant_value
        expression_id is equal to constant_id
        metadata is equal to metadata
        complexity_measure is equal to 1

Process called "create_binary_operation" that takes operator as String, left_operand as SymbolicExpression, right_operand as SymbolicExpression returns SymbolicExpression:
    Note: Create binary operation expression (addition, multiplication, etc.)
    Let operand_list be List.create()
    List.append(operand_list, left_operand)
    List.append(operand_list, right_operand)
    
    Let combined_complexity be left_operand.complexity_measure plus right_operand.complexity_measure plus 1
    Let operation_id be operator plus "_" plus left_operand.expression_id plus "_" plus right_operand.expression_id
    
    Return SymbolicExpression with:
        expression_type is equal to "binary_operation"
        operator_type is equal to operator
        operands is equal to operand_list
        expression_id is equal to operation_id
        metadata is equal to Dictionary.empty()
        complexity_measure is equal to combined_complexity

Process called "create_unary_operation" that takes operator as String, operand as SymbolicExpression returns SymbolicExpression:
    Note: Create unary operation expression (negation, functions, etc.)
    Let operand_list be List.create()
    List.append(operand_list, operand)
    
    Let operation_complexity be operand.complexity_measure plus 1
    Let operation_id be operator plus "_" plus operand.expression_id
    
    Return SymbolicExpression with:
        expression_type is equal to "unary_operation"
        operator_type is equal to operator
        operands is equal to operand_list
        expression_id is equal to operation_id
        metadata is equal to Dictionary.empty()
        complexity_measure is equal to operation_complexity

Process called "create_function_call" that takes function_name as String, arguments as List[SymbolicExpression], function_properties as Dictionary[String, String] returns SymbolicExpression:
    Note: Create function call expression with symbolic arguments
    Let total_complexity be 2
    Let func_id be "func_" plus function_name
    
    Note: Calculate complexity based on arguments
    For each arg in arguments:
        Let total_complexity be total_complexity plus arg.complexity_measure
        Let func_id be func_id plus "_" plus arg.expression_id
    
    Return SymbolicExpression with:
        expression_type is equal to "function_call"
        operator_type is equal to function_name
        operands is equal to arguments
        symbol_name is equal to function_name
        constant_value is equal to ""
        expression_id is equal to func_id
        metadata is equal to function_properties
        complexity_measure is equal to total_complexity

Process called "create_compound_expression" that takes expression_parts as List[SymbolicExpression], combination_operator as String returns SymbolicExpression:
    Note: Create complex expression from multiple parts
    Let total_complexity be 1
    Let compound_id be "compound_" plus combination_operator
    
    Note: Calculate total complexity and build ID
    For each part in expression_parts:
        Let total_complexity be total_complexity plus part.complexity_measure
        Let compound_id be compound_id plus "_" plus part.expression_id
    
    Return SymbolicExpression with:
        expression_type is equal to "compound_operation"
        operator_type is equal to combination_operator
        operands is equal to expression_parts
        symbol_name is equal to ""
        constant_value is equal to ""
        expression_id is equal to compound_id
        metadata is equal to Dictionary.empty()
        complexity_measure is equal to total_complexity

Note: =====================================================================
Note: EXPRESSION PARSING OPERATIONS
Note: =====================================================================

Process called "parse_expression" that takes expression_string as String, parsing_context as Dictionary[String, String] returns SymbolicExpression:
    Note: Parse string representation into symbolic expression
    Let trimmed_expr be trim_whitespace(expression_string)
    
    Note: Handle empty expressions
    If trimmed_expr is equal to "":
        Return SymbolicExpression with:
            expression_type is equal to "constant"
            constant_value is equal to "0"
            expression_id is equal to "empty_expr_0"
            metadata is equal to Dictionary.empty()
            complexity_measure is equal to 0
    
    Note: Handle numeric constants
    If is_numeric(trimmed_expr):
        Return SymbolicExpression with:
            expression_type is equal to "constant"
            constant_value is equal to trimmed_expr
            expression_id is equal to "const_" plus trimmed_expr
            metadata is equal to Dictionary.empty()
            complexity_measure is equal to 1
    
    Note: Handle simple variables
    If is_variable(trimmed_expr):
        Return SymbolicExpression with:
            expression_type is equal to "variable"
            symbol_name is equal to trimmed_expr
            expression_id is equal to "var_" plus trimmed_expr
            metadata is equal to Dictionary.empty()
            complexity_measure is equal to 1
    
    Note: Handle function calls
    If contains_function_call(trimmed_expr):
        Return parse_function_expression(trimmed_expr, parsing_context)
    
    Note: Handle binary operations
    If contains_binary_operator(trimmed_expr):
        Return parse_binary_expression(trimmed_expr, parsing_context)
    
    Note: Default case minus treat as variable
    Return SymbolicExpression with:
        expression_type is equal to "variable"
        symbol_name is equal to trimmed_expr
        expression_id is equal to "var_" plus trimmed_expr
        metadata is equal to Dictionary.empty()
        complexity_measure is equal to 1

Process called "parse_infix_notation" that takes infix_expression as String, operator_precedence as Dictionary[String, Integer] returns SymbolicExpression:
    Note: Parse infix mathematical notation with precedence rules
    Let trimmed_expr be StringOps.trim_whitespace(infix_expression)
    
    Note: Use expression parser for infix notation
    Let parser_context be ExprParser.ParserContext with:
        variable_table is equal to Dictionary.empty()
        function_table is equal to Dictionary.empty()
        operator_table is equal to Dictionary.empty()
        parsing_mode is equal to "infix"
        error_recovery_enabled is equal to true
        type_checking_enabled is equal to false
        optimization_level is equal to 0
    
    Let parsed_expr be ExprParser.parse_infix_expression(trimmed_expr, parser_context)
    
    Note: Convert from ExprParser.Expression to SymbolicExpression
    Return convert_parser_expression_to_symbolic(parsed_expr)

Process called "parse_prefix_notation" that takes prefix_expression as String returns SymbolicExpression:
    Note: Parse prefix (Polish) notation expressions
    Let tokens be StringOps.split_string(StringOps.trim_whitespace(prefix_expression), " ")
    
    Note: Use stack-based parsing for prefix notation
    Let expr_stack be Stack.create()
    Let token_index be ListOps.length(tokens) minus 1
    
    Note: Process tokens from right to left
    While token_index is greater than or equal to 0:
        Let token be ListOps.get(tokens, token_index)
        
        If is_operator(token):
            Note: Pop two operands from stack
            Let right_operand be Stack.pop(expr_stack)
            Let left_operand be Stack.pop(expr_stack)
            Let binary_expr be create_binary_operation(token, left_operand, right_operand)
            Stack.push(expr_stack, binary_expr)
        Otherwise:
            Note: It's an operand minus create expression and push
            Let operand_expr be create_operand_expression(token)
            Stack.push(expr_stack, operand_expr)
        
        Let token_index be token_index minus 1
    
    Note: Result should be single expression on stack
    Return Stack.pop(expr_stack)

Process called "parse_postfix_notation" that takes postfix_expression as String returns SymbolicExpression:
    Note: Parse postfix (Reverse Polish) notation expressions
    Let tokens be StringOps.split_string(StringOps.trim_whitespace(postfix_expression), " ")
    
    Note: Use stack-based parsing for postfix notation
    Let expr_stack be Stack.create()
    Let token_index be 0
    
    Note: Process tokens from left to right
    While token_index is less than ListOps.length(tokens):
        Let token be ListOps.get(tokens, token_index)
        
        If is_operator(token):
            Note: Pop two operands from stack
            Let right_operand be Stack.pop(expr_stack)
            Let left_operand be Stack.pop(expr_stack)
            Let binary_expr be create_binary_operation(token, left_operand, right_operand)
            Stack.push(expr_stack, binary_expr)
        Otherwise:
            Note: It's an operand minus create expression and push
            Let operand_expr be create_operand_expression(token)
            Stack.push(expr_stack, operand_expr)
        
        Let token_index be token_index plus 1
    
    Note: Result should be single expression on stack
    Return Stack.pop(expr_stack)

Process called "parse_function_notation" that takes function_string as String, function_definitions as Dictionary[String, String] returns SymbolicExpression:
    Note: Parse function call notation with custom function definitions
    Let trimmed_str be StringOps.trim_whitespace(function_string)
    
    Note: Find the opening parenthesis
    Let paren_pos be StringCore.find(trimmed_str, "(")
    If paren_pos is equal to -1:
        Note: No parentheses found, treat as variable
        Return create_symbol(trimmed_str, Dictionary.empty())
    
    Note: Extract function name and arguments
    Let function_name be StringCore.substring(trimmed_str, 0, paren_pos)
    Let args_part be StringCore.substring(trimmed_str, paren_pos plus 1, StringCore.length(trimmed_str) minus 1)
    
    Note: Parse function arguments
    Let arg_strings be StringOps.split_string(args_part, ",")
    Let parsed_args be ListOps.create()
    
    For each arg_str in arg_strings:
        Let trimmed_arg be StringOps.trim_whitespace(arg_str)
        If trimmed_arg does not equal "":
            Let parsed_arg be parse_expression(trimmed_arg, Dictionary.empty())
            ListOps.append(parsed_args, parsed_arg)
    
    Note: Create function call expression
    Return create_function_call(function_name, parsed_args, function_definitions)

Note: =====================================================================
Note: EXPRESSION MANIPULATION OPERATIONS
Note: =====================================================================

Process called "substitute_symbols" that takes expression as SymbolicExpression, substitutions as Dictionary[String, SymbolicExpression] returns SymbolicExpression:
    Note: Substitute symbols with other expressions throughout the tree
    
    Note: Handle constants minus no substitution needed
    If expression.expression_type is equal to "constant":
        Return expression
    
    Note: Handle variables minus check for substitution
    If expression.expression_type is equal to "variable":
        If Dictionary.contains_key(substitutions, expression.symbol_name):
            Return Dictionary.get(substitutions, expression.symbol_name)
        Otherwise:
            Return expression
    
    Note: Handle binary operations minus substitute in operands
    If expression.expression_type is equal to "binary_operation":
        Let substituted_operands be List.empty()
        For each operand in expression.operands:
            Let substituted_operand be substitute_symbols(operand, substitutions)
            List.append(substituted_operands, substituted_operand)
        
        Return SymbolicExpression with:
            expression_type is equal to expression.expression_type
            operator_type is equal to expression.operator_type
            operands is equal to substituted_operands
            expression_id is equal to expression.expression_id plus "_substituted"
            metadata is equal to expression.metadata
            complexity_measure is equal to expression.complexity_measure
    
    Note: Handle unary operations minus substitute in operand
    If expression.expression_type is equal to "unary_operation":
        Let substituted_operands be List.empty()
        For each operand in expression.operands:
            Let substituted_operand be substitute_symbols(operand, substitutions)
            List.append(substituted_operands, substituted_operand)
        
        Return SymbolicExpression with:
            expression_type is equal to expression.expression_type
            operator_type is equal to expression.operator_type
            operands is equal to substituted_operands
            expression_id is equal to expression.expression_id plus "_substituted"
            metadata is equal to expression.metadata
            complexity_measure is equal to expression.complexity_measure
    
    Note: Default case
    Return expression

Process called "substitute_pattern" that takes expression as SymbolicExpression, pattern as ExpressionPattern, replacement as SymbolicExpression returns SymbolicExpression:
    Note: Pattern-based substitution in symbolic expressions
    Let matches be match_pattern(expression, pattern)
    
    Note: If pattern doesn't match, return original expression
    If Dictionary.size(matches) is equal to 0:
        Return expression
    
    Note: Apply substitution with captured groups
    Let substituted_replacement be replacement
    Let pattern_vars be pattern.capture_groups
    
    Note: Replace pattern variables in replacement with captured values
    For each var_name in Dictionary.keys(pattern_vars):
        If Dictionary.contains_key(matches, var_name):
            Let captured_value be Dictionary.get(matches, var_name)
            Let substitutions be Dictionary.empty()
            Dictionary.set(substitutions, var_name, captured_value)
            Let substituted_replacement be substitute_symbols(substituted_replacement, substitutions)
    
    Return substituted_replacement

Process called "apply_transformation_rules" that takes expression as SymbolicExpression, rules as List[SimplificationRule] returns SymbolicExpression:
    Note: Apply transformation rules to symbolic expression
    Let current_expr be expression
    
    Note: Apply rules in priority order (highest priority first)
    Let sorted_rules be sort_rules_by_priority(rules)
    
    Note: Apply each rule to the expression
    For each rule in sorted_rules:
        Note: Check if rule conditions are satisfied
        If check_rule_conditions(current_expr, rule.application_conditions):
            Let current_expr be substitute_pattern(current_expr, rule.pattern_match, rule.replacement_pattern)
    
    Note: If expression changed, recursively apply rules to subexpressions
    If current_expr.expression_type is equal to "binary_operation" or current_expr.expression_type is equal to "unary_operation":
        Let transformed_operands be ListOps.create()
        For each operand in current_expr.operands:
            Let transformed_operand be apply_transformation_rules(operand, rules)
            ListOps.append(transformed_operands, transformed_operand)
        
        Return SymbolicExpression with:
            expression_type is equal to current_expr.expression_type
            operator_type is equal to current_expr.operator_type
            operands is equal to transformed_operands
            symbol_name is equal to current_expr.symbol_name
            constant_value is equal to current_expr.constant_value
            expression_id is equal to current_expr.expression_id plus "_transformed"
            metadata is equal to current_expr.metadata
            complexity_measure is equal to current_expr.complexity_measure
    
    Return current_expr

Process called "extract_subexpression" that takes expression as SymbolicExpression, extraction_criteria as Dictionary[String, String] returns List[SymbolicExpression]:
    Note: Extract subexpressions matching specified criteria
    Let extracted_exprs be ListOps.create()
    
    Note: Check if current expression matches criteria
    If matches_criteria(expression, extraction_criteria):
        ListOps.append(extracted_exprs, expression)
    
    Note: Recursively extract from operands
    If expression.expression_type is equal to "binary_operation" or expression.expression_type is equal to "unary_operation" or expression.expression_type is equal to "function_call":
        For each operand in expression.operands:
            Let sub_extracted be extract_subexpression(operand, extraction_criteria)
            For each sub_expr in sub_extracted:
                ListOps.append(extracted_exprs, sub_expr)
    
    Return extracted_exprs

Process called "replace_subexpression" that takes expression as SymbolicExpression, target_subexpression as SymbolicExpression, replacement as SymbolicExpression returns SymbolicExpression:
    Note: Replace specific subexpression with new expression
    Note: Check if current expression is the target
    If expressions_equal(expression, target_subexpression):
        Return replacement
    
    Note: Recursively replace in operands
    If expression.expression_type is equal to "binary_operation" or expression.expression_type is equal to "unary_operation" or expression.expression_type is equal to "function_call":
        Let replaced_operands be ListOps.create()
        For each operand in expression.operands:
            Let replaced_operand be replace_subexpression(operand, target_subexpression, replacement)
            ListOps.append(replaced_operands, replaced_operand)
        
        Return SymbolicExpression with:
            expression_type is equal to expression.expression_type
            operator_type is equal to expression.operator_type
            operands is equal to replaced_operands
            symbol_name is equal to expression.symbol_name
            constant_value is equal to expression.constant_value
            expression_id is equal to expression.expression_id plus "_replaced"
            metadata is equal to expression.metadata
            complexity_measure is equal to expression.complexity_measure
    
    Note: No replacement needed
    Return expression

Note: =====================================================================
Note: EXPRESSION SIMPLIFICATION OPERATIONS
Note: =====================================================================

Process called "simplify_expression" that takes expression as SymbolicExpression, simplification_options as Dictionary[String, Boolean] returns SymbolicExpression:
    Note: Apply comprehensive simplification to symbolic expression
    Let result be expression
    
    Note: Handle constants minus already simplified
    If expression.expression_type is equal to "constant":
        Return expression
    
    Note: Handle variables minus already simplified
    If expression.expression_type is equal to "variable":
        Return expression
    
    Note: Handle binary operations
    If expression.expression_type is equal to "binary_operation":
        Note: Simplify operands first
        Let simplified_operands be List.empty()
        For each operand in expression.operands:
            Let simplified_operand be simplify_expression(operand, simplification_options)
            List.append(simplified_operands, simplified_operand)
        
        Note: Apply simplification rules based on operator
        If expression.operator_type is equal to "addition":
            Return simplify_addition(simplified_operands)
        Otherwise if expression.operator_type is equal to "multiplication":
            Return simplify_multiplication(simplified_operands)
        Otherwise if expression.operator_type is equal to "subtraction":
            Return simplify_subtraction(simplified_operands)
        Otherwise if expression.operator_type is equal to "division":
            Return simplify_division(simplified_operands)
        Otherwise if expression.operator_type is equal to "power":
            Return simplify_power(simplified_operands)
        Otherwise:
            Return SymbolicExpression with:
                expression_type is equal to expression.expression_type
                operator_type is equal to expression.operator_type
                operands is equal to simplified_operands
                expression_id is equal to expression.expression_id plus "_simplified"
                metadata is equal to expression.metadata
                complexity_measure is equal to expression.complexity_measure
    
    Note: Handle function calls
    If expression.expression_type is equal to "function_call":
        Return simplify_function_call(expression, simplification_options)
    
    Note: Default case
    Return expression

Process called "expand_expression" that takes expression as SymbolicExpression, expansion_rules as Dictionary[String, String] returns SymbolicExpression:
    Note: Expand symbolic expression (distribute multiplication, etc.)
    Note: Handle multiplication distribution: a*(b+c) -> a*b plus a*c
    If expression.expression_type is equal to "binary_operation" and expression.operator_type is equal to "multiplication":
        If ListOps.length(expression.operands) is equal to 2:
            Let left_operand be ListOps.get(expression.operands, 0)
            Let right_operand be ListOps.get(expression.operands, 1)
            
            Note: Check if right operand is addition
            If right_operand.expression_type is equal to "binary_operation" and right_operand.operator_type is equal to "addition":
                If ListOps.length(right_operand.operands) is equal to 2:
                    Let b be ListOps.get(right_operand.operands, 0)
                    Let c be ListOps.get(right_operand.operands, 1)
                    
                    Note: Distribute: a*(b+c) -> a*b plus a*c
                    Let term1 be create_binary_operation("multiplication", left_operand, b)
                    Let term2 be create_binary_operation("multiplication", left_operand, c)
                    Return create_binary_operation("addition", term1, term2)
    
    Note: Recursively expand operands
    If expression.expression_type is equal to "binary_operation" or expression.expression_type is equal to "unary_operation":
        Let expanded_operands be ListOps.create()
        For each operand in expression.operands:
            Let expanded_operand be expand_expression(operand, expansion_rules)
            ListOps.append(expanded_operands, expanded_operand)
        
        Return SymbolicExpression with:
            expression_type is equal to expression.expression_type
            operator_type is equal to expression.operator_type
            operands is equal to expanded_operands
            symbol_name is equal to expression.symbol_name
            constant_value is equal to expression.constant_value
            expression_id is equal to expression.expression_id plus "_expanded"
            metadata is equal to expression.metadata
            complexity_measure is equal to expression.complexity_measure plus 1
    
    Return expression

Process called "factor_expression" that takes expression as SymbolicExpression, factoring_strategy as String returns SymbolicExpression:
    Note: Factor symbolic expression using specified strategy
    Note: Handle simple common factor extraction
    If expression.expression_type is equal to "binary_operation" and expression.operator_type is equal to "addition":
        If ListOps.length(expression.operands) is equal to 2:
            Let term1 be ListOps.get(expression.operands, 0)
            Let term2 be ListOps.get(expression.operands, 1)
            
            Note: Check if both terms are multiplication
            If term1.expression_type is equal to "binary_operation" and term1.operator_type is equal to "multiplication" and
               term2.expression_type is equal to "binary_operation" and term2.operator_type is equal to "multiplication":
                
                Note: Find common factors (simplified approach)
                Let common_factor be find_common_factor(term1, term2)
                If common_factor does not equal "":
                    Let factor_expr be create_symbol(common_factor, Dictionary.empty())
                    Let remaining1 be extract_remaining_factor(term1, common_factor)
                    Let remaining2 be extract_remaining_factor(term2, common_factor)
                    Let factored_sum be create_binary_operation("addition", remaining1, remaining2)
                    Return create_binary_operation("multiplication", factor_expr, factored_sum)
    
    Note: Apply factoring strategy recursively to operands
    If expression.expression_type is equal to "binary_operation" or expression.expression_type is equal to "unary_operation":
        Let factored_operands be ListOps.create()
        For each operand in expression.operands:
            Let factored_operand be factor_expression(operand, factoring_strategy)
            ListOps.append(factored_operands, factored_operand)
        
        Return SymbolicExpression with:
            expression_type is equal to expression.expression_type
            operator_type is equal to expression.operator_type
            operands is equal to factored_operands
            symbol_name is equal to expression.symbol_name
            constant_value is equal to expression.constant_value
            expression_id is equal to expression.expression_id plus "_factored"
            metadata is equal to expression.metadata
            complexity_measure is equal to expression.complexity_measure minus 1
    
    Return expression

Process called "collect_terms" that takes expression as SymbolicExpression, collection_variable as String returns SymbolicExpression:
    Note: Collect like terms in polynomial expressions
    Note: Handle polynomial term collection for addition expressions
    If expression.expression_type is equal to "binary_operation" and expression.operator_type is equal to "addition":
        Let collected_terms be Dictionary.empty()
        Let constant_term be "0"
        
        Note: Collect terms from the sum
        Let terms be extract_additive_terms(expression)
        
        For each term in terms:
            Let coefficient be extract_coefficient(term, collection_variable)
            Let power be extract_power(term, collection_variable)
            Let power_key be "power_" plus power
            
            If power is equal to "0":
                Let constant_term be add_coefficients(constant_term, coefficient)
            Otherwise:
                If Dictionary.contains_key(collected_terms, power_key):
                    Let existing_coeff be Dictionary.get(collected_terms, power_key)
                    Let new_coeff be add_coefficients(existing_coeff, coefficient)
                    Dictionary.set(collected_terms, power_key, new_coeff)
                Otherwise:
                    Dictionary.set(collected_terms, power_key, coefficient)
        
        Note: Reconstruct expression from collected terms
        Return reconstruct_polynomial(collected_terms, constant_term, collection_variable)
    
    Note: Recursively collect terms in operands
    If expression.expression_type is equal to "binary_operation" or expression.expression_type is equal to "unary_operation":
        Let collected_operands be ListOps.create()
        For each operand in expression.operands:
            Let collected_operand be collect_terms(operand, collection_variable)
            ListOps.append(collected_operands, collected_operand)
        
        Return SymbolicExpression with:
            expression_type is equal to expression.expression_type
            operator_type is equal to expression.operator_type
            operands is equal to collected_operands
            symbol_name is equal to expression.symbol_name
            constant_value is equal to expression.constant_value
            expression_id is equal to expression.expression_id plus "_collected"
            metadata is equal to expression.metadata
            complexity_measure is equal to expression.complexity_measure
    
    Return expression

Process called "normalize_expression" that takes expression as SymbolicExpression, normalization_form as String returns SymbolicExpression:
    Note: Convert expression to canonical normalized form
    Let normalized_expr be expression
    
    Note: Apply normalization based on form
    If normalization_form is equal to "canonical":
        Note: Sort operands alphabetically for commutative operations
        If expression.expression_type is equal to "binary_operation":
            If is_commutative_operator(expression.operator_type):
                Let normalized_expr be sort_operands_alphabetically(expression)
    
    Otherwise if normalization_form is equal to "expanded":
        Let normalized_expr be expand_expression(expression, Dictionary.empty())
    
    Otherwise if normalization_form is equal to "simplified":
        Let normalized_expr be simplify_expression(expression, Dictionary.empty())
    
    Note: Recursively normalize operands
    If normalized_expr.expression_type is equal to "binary_operation" or normalized_expr.expression_type is equal to "unary_operation":
        Let normalized_operands be ListOps.create()
        For each operand in normalized_expr.operands:
            Let normalized_operand be normalize_expression(operand, normalization_form)
            ListOps.append(normalized_operands, normalized_operand)
        
        Return SymbolicExpression with:
            expression_type is equal to normalized_expr.expression_type
            operator_type is equal to normalized_expr.operator_type
            operands is equal to normalized_operands
            symbol_name is equal to normalized_expr.symbol_name
            constant_value is equal to normalized_expr.constant_value
            expression_id is equal to normalized_expr.expression_id plus "_normalized"
            metadata is equal to normalized_expr.metadata
            complexity_measure is equal to normalized_expr.complexity_measure
    
    Return normalized_expr

Process called "rationalize_expression" that takes expression as SymbolicExpression returns SymbolicExpression:
    Note: Rationalize denominators and remove complex fractions
    Note: Handle division rationalization
    If expression.expression_type is equal to "binary_operation" and expression.operator_type is equal to "division":
        If ListOps.length(expression.operands) is equal to 2:
            Let numerator be ListOps.get(expression.operands, 0)
            Let denominator be ListOps.get(expression.operands, 1)
            
            Note: Check for irrational denominators (simplified approach)
            If contains_square_root(denominator):
                Let rationalized_denom be rationalize_square_root_denominator(denominator)
                Let rationalized_num be multiply_by_conjugate(numerator, rationalized_denom)
                Return create_binary_operation("division", rationalized_num, rationalized_denom)
    
    Note: Recursively rationalize operands
    If expression.expression_type is equal to "binary_operation" or expression.expression_type is equal to "unary_operation":
        Let rationalized_operands be ListOps.create()
        For each operand in expression.operands:
            Let rationalized_operand be rationalize_expression(operand)
            ListOps.append(rationalized_operands, rationalized_operand)
        
        Return SymbolicExpression with:
            expression_type is equal to expression.expression_type
            operator_type is equal to expression.operator_type
            operands is equal to rationalized_operands
            symbol_name is equal to expression.symbol_name
            constant_value is equal to expression.constant_value
            expression_id is equal to expression.expression_id plus "_rationalized"
            metadata is equal to expression.metadata
            complexity_measure is equal to expression.complexity_measure
    
    Return expression

Note: =====================================================================
Note: PATTERN MATCHING OPERATIONS
Note: =====================================================================

Process called "match_pattern" that takes expression as SymbolicExpression, pattern as ExpressionPattern returns Dictionary[String, SymbolicExpression]:
    Note: Match expression against pattern and return captured groups
    Let matches be Dictionary.empty()
    
    Note: Check pattern type compatibility
    If pattern.pattern_type is equal to "exact_match":
        If expression.expression_type is equal to pattern.pattern_structure:
            Return matches
        Otherwise:
            Return matches
    
    If pattern.pattern_type is equal to "variable_pattern":
        Note: Pattern matches any variable
        If expression.expression_type is equal to "variable":
            For each var_name in pattern.pattern_variables:
                Dictionary.set(matches, var_name, expression)
            Return matches
    
    If pattern.pattern_type is equal to "binary_operation_pattern":
        Note: Pattern matches binary operations
        If expression.expression_type is equal to "binary_operation":
            Note: Check operator compatibility
            If pattern.pattern_structure is equal to "" or expression.operator_type is equal to pattern.pattern_structure:
                Note: Match operands recursively
                If ListOps.length(expression.operands) is equal to 2:
                    For each var_name in pattern.pattern_variables:
                        If var_name is equal to "left":
                            Dictionary.set(matches, var_name, ListOps.get(expression.operands, 0))
                        If var_name is equal to "right":
                            Dictionary.set(matches, var_name, ListOps.get(expression.operands, 1))
                Return matches
    
    Note: Pattern didn't match
    Return matches

Process called "find_matching_subexpressions" that takes expression as SymbolicExpression, pattern as ExpressionPattern returns List[Dictionary[String, String]]:
    Note: Find all subexpressions matching specified pattern
    Let matches be ListOps.create()
    Let current_match be match_expression_against_pattern(expression, pattern)
    
    Note: Check if root expression matches
    If current_match.success:
        ListOps.append(matches, current_match.captured_variables)
    
    Note: Recursively check operands
    For each operand in expression.operands:
        Let submatches be find_matching_subexpressions(operand, pattern)
        For each submatch in submatches:
            ListOps.append(matches, submatch)
    
    Return matches

Process called "create_pattern_from_expression" that takes example_expression as SymbolicExpression, generalization_rules as Dictionary[String, String] returns ExpressionPattern:
    Note: Generate pattern from example expression with generalization
    Let pattern_expression be example_expression
    
    Note: Apply generalization rules to create pattern variables
    If Dictionary.contains_key(generalization_rules, "generalize_variables") and Dictionary.get(generalization_rules, "generalize_variables") is equal to "true":
        If example_expression.expression_type is equal to "variable":
            Let pattern_expression be SymbolicExpression with:
                expression_type is equal to "pattern_variable"
                operator_type is equal to ""
                operands is equal to ListOps.create()
                symbol_name is equal to "?var_" plus example_expression.symbol_name
                constant_value is equal to ""
                expression_id is equal to "pattern_" plus example_expression.expression_id
                metadata is equal to example_expression.metadata
                complexity_measure is equal to 1
    
    Note: Apply generalization to operands
    If Dictionary.contains_key(generalization_rules, "generalize_operands") and Dictionary.get(generalization_rules, "generalize_operands") is equal to "true":
        Let generalized_operands be ListOps.create()
        For each operand in example_expression.operands:
            Let generalized_operand be create_pattern_from_expression(operand, generalization_rules)
            ListOps.append(generalized_operands, generalized_operand.pattern_expression)
        
        Let pattern_expression be SymbolicExpression with:
            expression_type is equal to example_expression.expression_type
            operator_type is equal to example_expression.operator_type
            operands is equal to generalized_operands
            symbol_name is equal to example_expression.symbol_name
            constant_value is equal to example_expression.constant_value
            expression_id is equal to "pattern_" plus example_expression.expression_id
            metadata is equal to example_expression.metadata
            complexity_measure is equal to example_expression.complexity_measure
    
    Return ExpressionPattern with:
        pattern_expression is equal to pattern_expression
        variable_constraints is equal to Dictionary.empty()
        match_conditions is equal to Dictionary.empty()
        metadata is equal to Dictionary.empty()

Process called "match_with_constraints" that takes expression as SymbolicExpression, pattern as ExpressionPattern, constraints as List[String] returns Dictionary[String, SymbolicExpression]:
    Note: Pattern matching with additional logical constraints
    Let base_match be match_expression_against_pattern(expression, pattern)
    
    Note: If basic pattern doesn't match, return empty
    If not base_match.success:
        Return Dictionary.empty()
    
    Note: Check each constraint
    For each constraint in constraints:
        Let constraint_satisfied be validate_pattern_constraint(base_match.captured_variables, constraint)
        If not constraint_satisfied:
            Return Dictionary.empty()
    
    Note: Convert captured variables to expressions
    Let result_matches be Dictionary.empty()
    For each captured_var_name in Dictionary.keys(base_match.captured_variables):
        Let captured_value be Dictionary.get(base_match.captured_variables, captured_var_name)
        Let captured_expr be create_constant(captured_value, Dictionary.empty())
        Dictionary.set(result_matches, captured_var_name, captured_expr)
    
    Return result_matches

Note: =====================================================================
Note: EXPRESSION EVALUATION OPERATIONS
Note: =====================================================================

Process called "evaluate_symbolically" that takes expression as SymbolicExpression, context as SymbolicContext returns SymbolicExpression:
    Note: Evaluate expression symbolically with given context
    Note: Handle variable substitution
    If expression.expression_type is equal to "variable":
        If Dictionary.contains_key(context.variable_assignments, expression.symbol_name):
            Return Dictionary.get(context.variable_assignments, expression.symbol_name)
        Otherwise:
            Return expression
    
    Note: Handle constants
    If expression.expression_type is equal to "constant":
        Return expression
    
    Note: Handle binary operations
    If expression.expression_type is equal to "binary_operation":
        Let evaluated_operands be ListOps.create()
        For each operand in expression.operands:
            Let evaluated_operand be evaluate_symbolically(operand, context)
            ListOps.append(evaluated_operands, evaluated_operand)
        
        Note: Apply symbolic simplification
        Let evaluated_expr be SymbolicExpression with:
            expression_type is equal to expression.expression_type
            operator_type is equal to expression.operator_type
            operands is equal to evaluated_operands
            symbol_name is equal to expression.symbol_name
            constant_value is equal to expression.constant_value
            expression_id is equal to expression.expression_id plus "_evaluated"
            metadata is equal to expression.metadata
            complexity_measure is equal to expression.complexity_measure
        
        Return simplify_expression(evaluated_expr, context.simplification_settings)
    
    Note: Handle function calls
    If expression.expression_type is equal to "function_call":
        Let evaluated_args be ListOps.create()
        For each arg in expression.operands:
            Let evaluated_arg be evaluate_symbolically(arg, context)
            ListOps.append(evaluated_args, evaluated_arg)
        
        Return create_function_call(expression.symbol_name, evaluated_args, Dictionary.empty())
    
    Return expression

Process called "evaluate_numerically" that takes expression as SymbolicExpression, variable_values as Dictionary[String, String], precision as Integer returns String:
    Note: Evaluate expression numerically with variable substitutions
    Note: Handle constants
    If expression.expression_type is equal to "constant":
        Return expression.constant_value
    
    Note: Handle variables
    If expression.expression_type is equal to "variable":
        If Dictionary.contains_key(variable_values, expression.symbol_name):
            Return Dictionary.get(variable_values, expression.symbol_name)
        Otherwise:
            Throw Errors.InvalidArgument with "Variable not found: " plus expression.symbol_name
    
    Note: Handle binary operations
    If expression.expression_type is equal to "binary_operation":
        If ListOps.length(expression.operands) is equal to 2:
            Let left_value be evaluate_numerically(ListOps.get(expression.operands, 0), variable_values, precision)
            Let right_value be evaluate_numerically(ListOps.get(expression.operands, 1), variable_values, precision)
            
            If expression.operator_type is equal to "addition":
                Return add_numeric_strings(left_value, right_value)
            Otherwise if expression.operator_type is equal to "subtraction":
                Return subtract_numeric_strings(left_value, right_value)
            Otherwise if expression.operator_type is equal to "multiplication":
                Return multiply_numeric_strings(left_value, right_value)
            Otherwise if expression.operator_type is equal to "division":
                If right_value is equal to "0" or right_value is equal to "0.0":
                    Throw Errors.DivisionByZero with "Division by zero in numerical evaluation"
                Return divide_numeric_strings(left_value, right_value)
            Otherwise if expression.operator_type is equal to "power":
                Return power_numeric_strings(left_value, right_value)
    
    Note: Handle function calls
    If expression.expression_type is equal to "function_call":
        Let arg_values be ListOps.create()
        For each arg in expression.operands:
            Let arg_value be evaluate_numerically(arg, variable_values, precision)
            ListOps.append(arg_values, arg_value)
        
        Return evaluate_numeric_function(expression.symbol_name, arg_values)
    
    Throw Errors.UnsupportedOperation with "Cannot evaluate expression numerically"

Process called "partial_evaluation" that takes expression as SymbolicExpression, known_values as Dictionary[String, String] returns SymbolicExpression:
    Note: Partially evaluate expression with some known variable values
    Note: Handle variables with known values
    If expression.expression_type is equal to "variable":
        If Dictionary.contains_key(known_values, expression.symbol_name):
            Let known_value be Dictionary.get(known_values, expression.symbol_name)
            Return create_constant(known_value, "numeric")
        Otherwise:
            Return expression
    
    Note: Handle constants (already evaluated)
    If expression.expression_type is equal to "constant":
        Return expression
    
    Note: Handle operations with partial operands
    If expression.expression_type is equal to "binary_operation" or expression.expression_type is equal to "unary_operation":
        Let partially_evaluated_operands be ListOps.create()
        Let all_constants be true
        
        For each operand in expression.operands:
            Let partial_operand be partial_evaluation(operand, known_values)
            ListOps.append(partially_evaluated_operands, partial_operand)
            If partial_operand.expression_type does not equal "constant":
                Let all_constants be false
        
        Note: If all operands are constants, perform numerical evaluation
        If all_constants and expression.expression_type is equal to "binary_operation":
            Let numeric_result be try_numeric_evaluation(expression.operator_type, partially_evaluated_operands)
            If numeric_result does not equal "":
                Return create_constant(numeric_result, "numeric")
        
        Note: Return partially evaluated expression
        Return SymbolicExpression with:
            expression_type is equal to expression.expression_type
            operator_type is equal to expression.operator_type
            operands is equal to partially_evaluated_operands
            symbol_name is equal to expression.symbol_name
            constant_value is equal to expression.constant_value
            expression_id is equal to expression.expression_id plus "_partial"
            metadata is equal to expression.metadata
            complexity_measure is equal to expression.complexity_measure
    
    Return expression

Process called "evaluate_limits" that takes expression as SymbolicExpression, limit_conditions as Dictionary[String, String] returns SymbolicExpression:
    Note: Evaluate symbolic expressions with limit conditions
    Note: Handle constant expressions
    If expression.expression_type is equal to "constant":
        Return expression
    
    Note: Handle variables with limit conditions
    If expression.expression_type is equal to "variable":
        If Dictionary.contains_key(limit_conditions, expression.symbol_name):
            Let limit_value be Dictionary.get(limit_conditions, expression.symbol_name)
            Note: Handle special limit cases
            If limit_value is equal to "infinity":
                Return create_constant("", Dictionary.empty())
            Otherwise if limit_value is equal to "negative_infinity":
                Return create_constant("-", Dictionary.empty())
            Otherwise:
                Return create_constant(limit_value, Dictionary.empty())
        Otherwise:
            Return expression
    
    Note: Handle binary operations
    If expression.expression_type is equal to "binary_operation":
        Let limited_operands be ListOps.create()
        For each operand in expression.operands:
            Let limited_operand be evaluate_limits(operand, limit_conditions)
            ListOps.append(limited_operands, limited_operand)
        
        Note: Apply limit rules for operations
        If expression.operator_type is equal to "add":
            Return apply_addition_limits(limited_operands)
        Otherwise if expression.operator_type is equal to "multiply":
            Return apply_multiplication_limits(limited_operands)
        Otherwise if expression.operator_type is equal to "divide":
            Return apply_division_limits(limited_operands)
        Otherwise if expression.operator_type is equal to "power":
            Return apply_power_limits(limited_operands)
    
    Note: Handle function calls
    If expression.expression_type is equal to "function_call":
        Let limited_args be ListOps.create()
        For each arg in expression.operands:
            Let limited_arg be evaluate_limits(arg, limit_conditions)
            ListOps.append(limited_args, limited_arg)
        
        Return apply_function_limits(expression.symbol_name, limited_args)
    
    Return expression

Note: =====================================================================
Note: EXPRESSION ANALYSIS OPERATIONS
Note: =====================================================================

Process called "analyze_expression_structure" that takes expression as SymbolicExpression returns Dictionary[String, String]:
    Note: Analyze structural properties of symbolic expression
    Let analysis be Dictionary.empty()
    
    Note: Basic properties
    Dictionary.set(analysis, "expression_type", expression.expression_type)
    Dictionary.set(analysis, "operator_type", expression.operator_type)
    Dictionary.set(analysis, "complexity", String.from_integer(expression.complexity_measure))
    
    Note: Count operands
    Dictionary.set(analysis, "operand_count", String.from_integer(ListOps.length(expression.operands)))
    
    Note: Analyze depth
    Let max_depth be calculate_expression_depth(expression)
    Dictionary.set(analysis, "depth", String.from_integer(max_depth))
    
    Note: Find variables
    Let free_vars be find_free_variables(expression)
    Dictionary.set(analysis, "variable_count", String.from_integer(ListOps.length(free_vars)))
    
    Note: Analyze balance (for binary operations)
    If expression.expression_type is equal to "binary_operation" and ListOps.length(expression.operands) is equal to 2:
        Let left_complexity be ListOps.get(expression.operands, 0).complexity_measure
        Let right_complexity be ListOps.get(expression.operands, 1).complexity_measure
        Let balance_ratio be String.from_float(Float.divide(Float.from_integer(left_complexity), Float.from_integer(right_complexity)))
        Dictionary.set(analysis, "balance_ratio", balance_ratio)
    
    Note: Structural categories
    If expression.expression_type is equal to "constant":
        Dictionary.set(analysis, "category", "atomic")
    Otherwise if expression.expression_type is equal to "variable":
        Dictionary.set(analysis, "category", "atomic")
    Otherwise if ListOps.length(expression.operands) is equal to 0:
        Dictionary.set(analysis, "category", "atomic")
    Otherwise if ListOps.length(expression.operands) is equal to 1:
        Dictionary.set(analysis, "category", "unary")
    Otherwise if ListOps.length(expression.operands) is equal to 2:
        Dictionary.set(analysis, "category", "binary")
    Otherwise:
        Dictionary.set(analysis, "category", "n_ary")
    
    Return analysis

Process called "find_free_variables" that takes expression as SymbolicExpression returns List[String]:
    Note: Find all free variables in symbolic expression
    Let variables be List.empty()
    
    Note: Handle constants minus no variables
    If expression.expression_type is equal to "constant":
        Return variables
    
    Note: Handle variables minus add to list if not already present
    If expression.expression_type is equal to "variable":
        If not List.contains(variables, expression.symbol_name):
            List.append(variables, expression.symbol_name)
        Return variables
    
    Note: Handle binary operations minus collect from operands
    If expression.expression_type is equal to "binary_operation":
        For each operand in expression.operands:
            Let operand_variables be find_free_variables(operand)
            For each var in operand_variables:
                If not List.contains(variables, var):
                    List.append(variables, var)
        Return variables
    
    Note: Handle unary operations minus collect from operand
    If expression.expression_type is equal to "unary_operation":
        For each operand in expression.operands:
            Let operand_variables be find_free_variables(operand)
            For each var in operand_variables:
                If not List.contains(variables, var):
                    List.append(variables, var)
        Return variables
    
    Note: Handle function calls minus collect from arguments
    If expression.expression_type is equal to "function_call":
        For each operand in expression.operands:
            Let operand_variables be find_free_variables(operand)
            For each var in operand_variables:
                If not List.contains(variables, var):
                    List.append(variables, var)
        Return variables
    
    Note: Default case
    Return variables

Process called "compute_expression_complexity" that takes expression as SymbolicExpression, complexity_metric as String returns Integer:
    Note: Compute complexity measure for symbolic expression
    Note: Handle different complexity metrics
    If complexity_metric is equal to "node_count":
        Note: Count total nodes in expression tree
        Let node_count be 1
        For each operand in expression.operands:
            Let operand_complexity be compute_expression_complexity(operand, complexity_metric)
            Let node_count be node_count plus operand_complexity
        Return node_count
    
    Otherwise if complexity_metric is equal to "depth":
        Note: Calculate maximum depth of expression tree
        If ListOps.length(expression.operands) is equal to 0:
            Return 1
        
        Let max_operand_depth be 0
        For each operand in expression.operands:
            Let operand_depth be compute_expression_complexity(operand, complexity_metric)
            If operand_depth is greater than max_operand_depth:
                Let max_operand_depth be operand_depth
        
        Return max_operand_depth plus 1
    
    Otherwise if complexity_metric is equal to "variable_count":
        Note: Count unique variables
        Let var_names be find_free_variables(expression)
        Return ListOps.length(var_names)
    
    Otherwise if complexity_metric is equal to "operation_count":
        Note: Count binary/unary operations
        Let operation_count be 0
        If expression.expression_type is equal to "binary_operation" or expression.expression_type is equal to "unary_operation":
            Let operation_count be 1
        
        For each operand in expression.operands:
            Let operand_operations be compute_expression_complexity(operand, complexity_metric)
            Let operation_count be operation_count plus operand_operations
        
        Return operation_count
    
    Otherwise if complexity_metric is equal to "weighted":
        Note: Weighted complexity based on operation types
        Let base_complexity be 1
        If expression.expression_type is equal to "constant":
            Return 1
        Otherwise if expression.expression_type is equal to "variable":
            Return 1
        Otherwise if expression.operator_type is equal to "add" or expression.operator_type is equal to "subtract":
            Let base_complexity be 2
        Otherwise if expression.operator_type is equal to "multiply" or expression.operator_type is equal to "divide":
            Let base_complexity be 3
        Otherwise if expression.operator_type is equal to "power":
            Let base_complexity be 5
        Otherwise if expression.expression_type is equal to "function_call":
            Let base_complexity be 4
        
        Let total_complexity be base_complexity
        For each operand in expression.operands:
            Let operand_complexity be compute_expression_complexity(operand, complexity_metric)
            Let total_complexity be total_complexity plus operand_complexity
        
        Return total_complexity
    
    Note: Default to node count
    Return compute_expression_complexity(expression, "node_count")

Process called "check_expression_equivalence" that takes expression_a as SymbolicExpression, expression_b as SymbolicExpression, equivalence_rules as Dictionary[String, String] returns Boolean:
    Note: Check if two expressions are symbolically equivalent
    Note: Quick structural check
    If expression_a.expression_type does not equal expression_b.expression_type:
        Return false
    
    Note: Handle constants
    If expression_a.expression_type is equal to "constant":
        Return expression_a.constant_value is equal to expression_b.constant_value
    
    Note: Handle variables
    If expression_a.expression_type is equal to "variable":
        Return expression_a.symbol_name is equal to expression_b.symbol_name
    
    Note: Handle operations minus check operator compatibility
    If expression_a.expression_type is equal to "binary_operation":
        Note: Check if operators are equivalent
        Let operators_equivalent be expression_a.operator_type is equal to expression_b.operator_type
        
        Note: Check for commutative operations if specified in rules
        If not operators_equivalent and Dictionary.contains_key(equivalence_rules, "commutative") and Dictionary.get(equivalence_rules, "commutative") is equal to "true":
            If (expression_a.operator_type is equal to "add" and expression_b.operator_type is equal to "add") or (expression_a.operator_type is equal to "multiply" and expression_b.operator_type is equal to "multiply"):
                Let operators_equivalent be true
        
        If not operators_equivalent:
            Return false
        
        Note: Check operand count
        If ListOps.length(expression_a.operands) does not equal ListOps.length(expression_b.operands):
            Return false
        
        Note: Check operands recursively
        If ListOps.length(expression_a.operands) is equal to 2:
            Let left_a be ListOps.get(expression_a.operands, 0)
            Let right_a be ListOps.get(expression_a.operands, 1)
            Let left_b be ListOps.get(expression_b.operands, 0)
            Let right_b be ListOps.get(expression_b.operands, 1)
            
            Note: Try direct order
            Let direct_match be check_expression_equivalence(left_a, left_b, equivalence_rules) and check_expression_equivalence(right_a, right_b, equivalence_rules)
            
            Note: Try commutative order if enabled
            Let commutative_match be false
            If Dictionary.contains_key(equivalence_rules, "commutative") and Dictionary.get(equivalence_rules, "commutative") is equal to "true":
                If expression_a.operator_type is equal to "add" or expression_a.operator_type is equal to "multiply":
                    Let commutative_match be check_expression_equivalence(left_a, right_b, equivalence_rules) and check_expression_equivalence(right_a, left_b, equivalence_rules)
            
            Return direct_match or commutative_match
        Otherwise:
            Note: For n-ary operations, check all operands
            For i from 0 to ListOps.length(expression_a.operands) minus 1:
                Let operand_a be ListOps.get(expression_a.operands, i)
                Let operand_b be ListOps.get(expression_b.operands, i)
                If not check_expression_equivalence(operand_a, operand_b, equivalence_rules):
                    Return false
            Return true
    
    Note: Handle function calls
    If expression_a.expression_type is equal to "function_call":
        If expression_a.symbol_name does not equal expression_b.symbol_name:
            Return false
        
        Note: Check argument count
        If ListOps.length(expression_a.operands) does not equal ListOps.length(expression_b.operands):
            Return false
        
        Note: Check arguments
        For i from 0 to ListOps.length(expression_a.operands) minus 1:
            Let arg_a be ListOps.get(expression_a.operands, i)
            Let arg_b be ListOps.get(expression_b.operands, i)
            If not check_expression_equivalence(arg_a, arg_b, equivalence_rules):
                Return false
        
        Return true
    
    Note: Default case minus assume not equivalent
    Return false

Process called "analyze_dependencies" that takes expression as SymbolicExpression returns Dictionary[String, List[String]]:
    Note: Analyze variable and function dependencies in expression
    Let dependencies be Dictionary.empty()
    
    Note: Initialize dependency lists
    Dictionary.set(dependencies, "variables", ListOps.create())
    Dictionary.set(dependencies, "functions", ListOps.create())
    Dictionary.set(dependencies, "constants", ListOps.create())
    Dictionary.set(dependencies, "operators", ListOps.create())
    
    Note: Collect dependencies recursively
    collect_dependencies_recursive(expression, dependencies)
    
    Return dependencies

Note: =====================================================================
Note: SYMBOL TABLE OPERATIONS
Note: =====================================================================

Process called "create_symbol_table" that takes initial_symbols as Dictionary[String, String] returns SymbolTable:
    Note: Create new symbol table with initial symbol definitions
    Let symbol_definitions be Dictionary.empty()
    
    Note: Convert initial symbols to SymbolicExpression format
    For each symbol_name in Dictionary.keys(initial_symbols):
        Let symbol_value be Dictionary.get(initial_symbols, symbol_name)
        Let symbol_expr be create_symbol(symbol_name, Dictionary.empty())
        Dictionary.set(symbol_definitions, symbol_name, symbol_expr)
    
    Return SymbolTable with:
        symbol_definitions is equal to symbol_definitions
        variable_bindings is equal to initial_symbols
        function_definitions is equal to Dictionary.empty()
        constant_definitions is equal to Dictionary.empty()
        scope_hierarchy is equal to ListOps.create()
        namespace_contexts is equal to Dictionary.empty()

Process called "define_symbol" that takes symbol_table as SymbolTable, symbol_name as String, symbol_definition as SymbolicExpression returns SymbolTable:
    Note: Define new symbol in symbol table
    Dictionary.set(symbol_table.symbol_definitions, symbol_name, symbol_definition)
    
    Note: Update variable bindings if it's a simple value
    If symbol_definition.expression_type is equal to "constant":
        Dictionary.set(symbol_table.variable_bindings, symbol_name, symbol_definition.constant_value)
    
    Return symbol_table

Process called "lookup_symbol" that takes symbol_table as SymbolTable, symbol_name as String returns SymbolicExpression:
    Note: Look up symbol definition in symbol table
    If Dictionary.contains_key(symbol_table.symbol_definitions, symbol_name):
        Return Dictionary.get(symbol_table.symbol_definitions, symbol_name)
    
    Note: If not found in symbol definitions, create a new variable symbol
    Return create_symbol(symbol_name, Dictionary.empty())

Process called "merge_symbol_tables" that takes table_a as SymbolTable, table_b as SymbolTable, merge_strategy as String returns SymbolTable:
    Note: Merge two symbol tables with conflict resolution
    Let merged_table be SymbolTable with:
        symbol_definitions is equal to Dictionary.empty()
        variable_bindings is equal to Dictionary.empty()
        scoping_rules is equal to table_a.scoping_rules
        metadata is equal to Dictionary.empty()
    
    Note: Copy all symbols from table_a
    For each symbol_name in Dictionary.keys(table_a.symbol_definitions):
        Let symbol_def be Dictionary.get(table_a.symbol_definitions, symbol_name)
        Dictionary.set(merged_table.symbol_definitions, symbol_name, symbol_def)
    
    For each var_name in Dictionary.keys(table_a.variable_bindings):
        Let var_binding be Dictionary.get(table_a.variable_bindings, var_name)
        Dictionary.set(merged_table.variable_bindings, var_name, var_binding)
    
    Note: Merge symbols from table_b with conflict resolution
    For each symbol_name in Dictionary.keys(table_b.symbol_definitions):
        Let symbol_def_b be Dictionary.get(table_b.symbol_definitions, symbol_name)
        
        Note: Check for conflicts
        If Dictionary.contains_key(merged_table.symbol_definitions, symbol_name):
            Let symbol_def_a be Dictionary.get(merged_table.symbol_definitions, symbol_name)
            
            Note: Apply merge strategy
            If merge_strategy is equal to "prefer_first":
                Note: Keep symbol from table_a
                Note: No action needed
            Otherwise if merge_strategy is equal to "prefer_second":
                Dictionary.set(merged_table.symbol_definitions, symbol_name, symbol_def_b)
            Otherwise if merge_strategy is equal to "error_on_conflict":
                Throw Errors.Invalid with "Symbol conflict during merge: " plus symbol_name
            Otherwise if merge_strategy is equal to "combine":
                Note: Create combined definition with metadata from both
                Let combined_metadata be Dictionary.empty()
                Dictionary.set(combined_metadata, "source_a", "table_a")
                Dictionary.set(combined_metadata, "source_b", "table_b")
                
                Let combined_def be SymbolicExpression with:
                    expression_type is equal to symbol_def_a.expression_type
                    operator_type is equal to symbol_def_a.operator_type
                    operands is equal to symbol_def_a.operands
                    symbol_name is equal to symbol_def_a.symbol_name
                    constant_value is equal to symbol_def_a.constant_value
                    expression_id is equal to symbol_def_a.expression_id plus "_merged"
                    metadata is equal to combined_metadata
                    complexity_measure is equal to symbol_def_a.complexity_measure
                
                Dictionary.set(merged_table.symbol_definitions, symbol_name, combined_def)
        Otherwise:
            Dictionary.set(merged_table.symbol_definitions, symbol_name, symbol_def_b)
    
    Note: Merge variable bindings from table_b
    For each var_name in Dictionary.keys(table_b.variable_bindings):
        Let var_binding_b be Dictionary.get(table_b.variable_bindings, var_name)
        
        If Dictionary.contains_key(merged_table.variable_bindings, var_name):
            Note: Apply same merge strategy for bindings
            If merge_strategy is equal to "prefer_second" or merge_strategy is equal to "combine":
                Dictionary.set(merged_table.variable_bindings, var_name, var_binding_b)
        Otherwise:
            Dictionary.set(merged_table.variable_bindings, var_name, var_binding_b)
    
    Return merged_table

Process called "create_scoped_context" that takes parent_table as SymbolTable, local_definitions as Dictionary[String, String] returns SymbolTable:
    Note: Create scoped symbol context with local definitions
    Let scoped_table be SymbolTable with:
        symbol_definitions is equal to Dictionary.empty()
        variable_bindings is equal to Dictionary.empty()
        scoping_rules is equal to parent_table.scoping_rules
        metadata is equal to Dictionary.empty()
    
    Note: Copy parent table symbols
    For each symbol_name in Dictionary.keys(parent_table.symbol_definitions):
        Let symbol_def be Dictionary.get(parent_table.symbol_definitions, symbol_name)
        Dictionary.set(scoped_table.symbol_definitions, symbol_name, symbol_def)
    
    For each var_name in Dictionary.keys(parent_table.variable_bindings):
        Let var_binding be Dictionary.get(parent_table.variable_bindings, var_name)
        Dictionary.set(scoped_table.variable_bindings, var_name, var_binding)
    
    Note: Add local definitions with higher priority
    For each local_name in Dictionary.keys(local_definitions):
        Let local_value be Dictionary.get(local_definitions, local_name)
        
        Note: Create local symbol definition
        Let local_symbol be create_symbol(local_name, Dictionary.empty())
        If local_value does not equal "":
            Let local_symbol be create_constant(local_value, Dictionary.empty())
        
        Dictionary.set(scoped_table.symbol_definitions, local_name, local_symbol)
        Dictionary.set(scoped_table.variable_bindings, local_name, local_value)
    
    Note: Add scoping metadata
    Dictionary.set(scoped_table.metadata, "scope_type", "local")
    Dictionary.set(scoped_table.metadata, "has_parent", "true")
    Dictionary.set(scoped_table.metadata, "local_count", String.from_integer(Dictionary.size(local_definitions)))
    
    Return scoped_table

Note: =====================================================================
Note: EXPRESSION SERIALIZATION OPERATIONS
Note: =====================================================================

Process called "serialize_expression" that takes expression as SymbolicExpression, serialization_format as String returns String:
    Note: Serialize symbolic expression to specified format
    If serialization_format is equal to "json":
        Let serialized be "{"
        Let serialized be serialized plus "\"expression_type\":\"" plus expression.expression_type plus "\","
        Let serialized be serialized plus "\"operator_type\":\"" plus expression.operator_type plus "\","
        Let serialized be serialized plus "\"symbol_name\":\"" plus expression.symbol_name plus "\","
        Let serialized be serialized plus "\"constant_value\":\"" plus expression.constant_value plus "\","
        Let serialized be serialized plus "\"expression_id\":\"" plus expression.expression_id plus "\","
        Let serialized be serialized plus "\"complexity_measure\":" plus String.from_integer(expression.complexity_measure) plus ","
        
        Note: Serialize operands
        Let serialized be serialized plus "\"operands\":["
        Let operand_index be 0
        For each operand in expression.operands:
            If operand_index is greater than 0:
                Let serialized be serialized plus ","
            Let operand_serialized be serialize_expression(operand, serialization_format)
            Let serialized be serialized plus operand_serialized
            Let operand_index be operand_index plus 1
        Let serialized be serialized plus "]"
        Let serialized be serialized plus "}"
        Return serialized
    
    Otherwise if serialization_format is equal to "xml":
        Let xml be "<SymbolicExpression>"
        Let xml be xml plus "<expression_type>" plus expression.expression_type plus "</expression_type>"
        Let xml be xml plus "<operator_type>" plus expression.operator_type plus "</operator_type>"
        Let xml be xml plus "<symbol_name>" plus expression.symbol_name plus "</symbol_name>"
        Let xml be xml plus "<constant_value>" plus expression.constant_value plus "</constant_value>"
        Let xml be xml plus "<expression_id>" plus expression.expression_id plus "</expression_id>"
        Let xml be xml plus "<complexity_measure>" plus String.from_integer(expression.complexity_measure) plus "</complexity_measure>"
        
        Let xml be xml plus "<operands>"
        For each operand in expression.operands:
            Let operand_xml be serialize_expression(operand, serialization_format)
            Let xml be xml plus operand_xml
        Let xml be xml plus "</operands>"
        Let xml be xml plus "</SymbolicExpression>"
        Return xml
    
    Otherwise if serialization_format is equal to "binary":
        Note: Simple binary format: type|op|name|value|id|complexity|operand_count|operands
        Let binary be expression.expression_type plus "|" plus expression.operator_type plus "|"
        Let binary be binary plus expression.symbol_name plus "|" plus expression.constant_value plus "|"
        Let binary be binary plus expression.expression_id plus "|" plus String.from_integer(expression.complexity_measure) plus "|"
        Let binary be binary plus String.from_integer(ListOps.length(expression.operands)) plus "|"
        
        For each operand in expression.operands:
            Let operand_binary be serialize_expression(operand, serialization_format)
            Let binary be binary plus operand_binary plus "|"
        
        Return binary
    
    Note: Default to string representation
    Return export_to_string(expression, "infix")

Process called "deserialize_expression" that takes serialized_expression as String, format as String returns SymbolicExpression:
    Note: Deserialize string representation to symbolic expression
    If format is equal to "binary":
        Note: Parse binary format: type|op|name|value|id|complexity|operand_count|operands
        Let parts be StringOps.split(serialized_expression, "|")
        If ListOps.length(parts) is less than 7:
            Throw Errors.Invalid with "Invalid binary serialization format"
        
        Let expression_type be ListOps.get(parts, 0)
        Let operator_type be ListOps.get(parts, 1)
        Let symbol_name be ListOps.get(parts, 2)
        Let constant_value be ListOps.get(parts, 3)
        Let expression_id be ListOps.get(parts, 4)
        Let complexity_str be ListOps.get(parts, 5)
        Let operand_count_str be ListOps.get(parts, 6)
        
        Let complexity_measure be Integer.from_string(complexity_str)
        Let operand_count be Integer.from_string(operand_count_str)
        
        Let operands be ListOps.create()
        Let operand_start be 7
        
        For i from 0 to operand_count minus 1:
            Note: Find operand boundaries in remaining parts
            Let operand_parts be ListOps.create()
            Let part_index be operand_start
            Let operand_part_count be 7  Note: Minimum parts for an operand
            
            For j from 0 to operand_part_count minus 1:
                If part_index is less than ListOps.length(parts):
                    ListOps.append(operand_parts, ListOps.get(parts, part_index))
                    Let part_index be part_index plus 1
            
            Let operand_serialized be StringOps.join(operand_parts, "|")
            Let operand be deserialize_expression(operand_serialized, format)
            ListOps.append(operands, operand)
            Let operand_start be part_index
        
        Return SymbolicExpression with:
            expression_type is equal to expression_type
            operator_type is equal to operator_type
            operands is equal to operands
            symbol_name is equal to symbol_name
            constant_value is equal to constant_value
            expression_id is equal to expression_id
            metadata is equal to Dictionary.empty()
            complexity_measure is equal to complexity_measure
    
    Otherwise if format is equal to "string" or format is equal to "infix":
        Note: Parse string representation using expression parser
        Return ExprParser.parse_expression(serialized_expression)
    
    Otherwise if format is equal to "json":
        Note: Parse JSON format manually (basic JSON object parsing)
        Let json_content be StringOps.trim(serialized_expression)
        
        Note: Remove outer braces
        If StringOps.starts_with(json_content, "{") and StringOps.ends_with(json_content, "}"):
            Let json_content be StringOps.substring(json_content, 1, StringOps.length(json_content) minus 2)
            
            Note: Parse JSON fields manually
            Let field_pairs be StringOps.split(json_content, ",")
            Let expression_type be ""
            Let operator_type be ""
            Let symbol_name be ""
            Let constant_value be ""
            Let expression_id be ""
            Let complexity_measure be 1
            
            For each pair in field_pairs:
                Let key_value be StringOps.split(StringOps.trim(pair), ":")
                If ListOps.length(key_value) is equal to 2:
                    Let key be StringOps.trim(StringOps.replace(ListOps.get(key_value, 0), "\"", ""))
                    Let value be StringOps.trim(StringOps.replace(ListOps.get(key_value, 1), "\"", ""))
                    
                    If key is equal to "expression_type":
                        Let expression_type be value
                    Otherwise if key is equal to "operator_type":
                        Let operator_type be value
                    Otherwise if key is equal to "symbol_name":
                        Let symbol_name be value
                    Otherwise if key is equal to "constant_value":
                        Let constant_value be value
                    Otherwise if key is equal to "expression_id":
                        Let expression_id be value
                    Otherwise if key is equal to "complexity_measure":
                        Let complexity_measure be Integer.from_string(value)
            
            Return SymbolicExpression with:
                expression_type is equal to expression_type
                operator_type is equal to operator_type
                operands is equal to ListOps.create()
                symbol_name is equal to symbol_name
                constant_value is equal to constant_value
                expression_id is equal to expression_id
                metadata is equal to Dictionary.empty()
                complexity_measure is equal to complexity_measure
        
        Note: Fallback for malformed JSON
        Return create_constant("0", Dictionary.empty())
    
    Note: Default case minus treat as string
    Return ExprParser.parse_expression(serialized_expression)

Process called "export_to_string" that takes expression as SymbolicExpression, notation_style as String returns String:
    Note: Export expression to human-readable string format
    Note: Handle constants
    If expression.expression_type is equal to "constant":
        Return expression.constant_value
    
    Note: Handle variables
    If expression.expression_type is equal to "variable":
        Return expression.symbol_name
    
    Note: Handle binary operations
    If expression.expression_type is equal to "binary_operation" and ListOps.length(expression.operands) is equal to 2:
        Let left_operand be ListOps.get(expression.operands, 0)
        Let right_operand be ListOps.get(expression.operands, 1)
        
        Let left_str be export_to_string(left_operand, notation_style)
        Let right_str be export_to_string(right_operand, notation_style)
        
        If notation_style is equal to "infix":
            Note: Standard infix notation
            If expression.operator_type is equal to "add":
                Return left_str plus " plus " plus right_str
            Otherwise if expression.operator_type is equal to "subtract":
                Return left_str plus " minus " plus right_str
            Otherwise if expression.operator_type is equal to "multiply":
                Return left_str plus " multiplied by " plus right_str
            Otherwise if expression.operator_type is equal to "divide":
                Return left_str plus " / " plus right_str
            Otherwise if expression.operator_type is equal to "power":
                Return left_str plus " ^ " plus right_str
            Otherwise:
                Return left_str plus " " plus expression.operator_type plus " " plus right_str
        
        Otherwise if notation_style is equal to "prefix":
            Return "(" plus expression.operator_type plus " " plus left_str plus " " plus right_str plus ")"
        
        Otherwise if notation_style is equal to "postfix":
            Return "(" plus left_str plus " " plus right_str plus " " plus expression.operator_type plus ")"
    
    Note: Handle function calls
    If expression.expression_type is equal to "function_call":
        Let func_name be expression.symbol_name
        Let args_str be ""
        Let arg_count be 0
        
        For each arg in expression.operands:
            If arg_count is greater than 0:
                Let args_str be args_str plus ", "
            Let arg_str be export_to_string(arg, notation_style)
            Let args_str be args_str plus arg_str
            Let arg_count be arg_count plus 1
        
        Return func_name plus "(" plus args_str plus ")"
    
    Note: Handle unary operations
    If expression.expression_type is equal to "unary_operation" and ListOps.length(expression.operands) is equal to 1:
        Let operand be ListOps.get(expression.operands, 0)
        Let operand_str be export_to_string(operand, notation_style)
        
        If expression.operator_type is equal to "negate":
            Return "-" plus operand_str
        Otherwise if expression.operator_type is equal to "abs":
            Return "|" plus operand_str plus "|"
        Otherwise:
            Return expression.operator_type plus "(" plus operand_str plus ")"
    
    Note: Default case minus return expression ID
    Return expression.expression_id

Process called "export_to_latex" that takes expression as SymbolicExpression, latex_options as Dictionary[String, String] returns String:
    Note: Export expression to LaTeX mathematical notation
    Note: Handle constants
    If expression.expression_type is equal to "constant":
        Return expression.constant_value
    
    Note: Handle variables
    If expression.expression_type is equal to "variable":
        Note: Handle Greek letters and special symbols
        If expression.symbol_name is equal to "alpha":
            Return "\\alpha"
        Otherwise if expression.symbol_name is equal to "beta":
            Return "\\beta"
        Otherwise if expression.symbol_name is equal to "gamma":
            Return "\\gamma"
        Otherwise if expression.symbol_name is equal to "pi":
            Return "\\pi"
        Otherwise:
            Return expression.symbol_name
    
    Note: Handle binary operations
    If expression.expression_type is equal to "binary_operation" and ListOps.length(expression.operands) is equal to 2:
        Let left_operand be ListOps.get(expression.operands, 0)
        Let right_operand be ListOps.get(expression.operands, 1)
        
        Let left_latex be export_to_latex(left_operand, latex_options)
        Let right_latex be export_to_latex(right_operand, latex_options)
        
        If expression.operator_type is equal to "add":
            Return left_latex plus " plus " plus right_latex
        Otherwise if expression.operator_type is equal to "subtract":
            Return left_latex plus " minus " plus right_latex
        Otherwise if expression.operator_type is equal to "multiply":
            Return left_latex plus " \\cdot " plus right_latex
        Otherwise if expression.operator_type is equal to "divide":
            Return "\\frac{" plus left_latex plus "}{" plus right_latex plus "}"
        Otherwise if expression.operator_type is equal to "power":
            Return left_latex plus "^{" plus right_latex plus "}"
    
    Note: Handle function calls
    If expression.expression_type is equal to "function_call":
        Let func_name be expression.symbol_name
        
        Note: Special LaTeX functions
        If func_name is equal to "sin":
            If ListOps.length(expression.operands) is equal to 1:
                Let arg be ListOps.get(expression.operands, 0)
                Return "\\sin(" plus export_to_latex(arg, latex_options) plus ")"
        Otherwise if func_name is equal to "cos":
            If ListOps.length(expression.operands) is equal to 1:
                Let arg be ListOps.get(expression.operands, 0)
                Return "\\cos(" plus export_to_latex(arg, latex_options) plus ")"
        Otherwise if func_name is equal to "log":
            If ListOps.length(expression.operands) is equal to 1:
                Let arg be ListOps.get(expression.operands, 0)
                Return "\\log(" plus export_to_latex(arg, latex_options) plus ")"
        Otherwise if func_name is equal to "sqrt":
            If ListOps.length(expression.operands) is equal to 1:
                Let arg be ListOps.get(expression.operands, 0)
                Return "\\sqrt{" plus export_to_latex(arg, latex_options) plus "}"
        
        Note: General function format
        Let args_latex be ""
        Let arg_count be 0
        For each arg in expression.operands:
            If arg_count is greater than 0:
                Let args_latex be args_latex plus ", "
            Let arg_latex be export_to_latex(arg, latex_options)
            Let args_latex be args_latex plus arg_latex
            Let arg_count be arg_count plus 1
        
        Return func_name plus "(" plus args_latex plus ")"
    
    Note: Handle unary operations
    If expression.expression_type is equal to "unary_operation" and ListOps.length(expression.operands) is equal to 1:
        Let operand be ListOps.get(expression.operands, 0)
        Let operand_latex be export_to_latex(operand, latex_options)
        
        If expression.operator_type is equal to "negate":
            Return "-" plus operand_latex
        Otherwise if expression.operator_type is equal to "abs":
            Return "\\left|" plus operand_latex plus "\\right|"
    
    Note: Default case
    Return expression.expression_id

Process called "export_to_mathml" that takes expression as SymbolicExpression returns String:
    Note: Export expression to MathML format
    Note: Handle constants
    If expression.expression_type is equal to "constant":
        Return "<mn>" plus expression.constant_value plus "</mn>"
    
    Note: Handle variables
    If expression.expression_type is equal to "variable":
        Return "<mi>" plus expression.symbol_name plus "</mi>"
    
    Note: Handle binary operations
    If expression.expression_type is equal to "binary_operation" and ListOps.length(expression.operands) is equal to 2:
        Let left_operand be ListOps.get(expression.operands, 0)
        Let right_operand be ListOps.get(expression.operands, 1)
        
        Let left_mathml be export_to_mathml(left_operand)
        Let right_mathml be export_to_mathml(right_operand)
        
        If expression.operator_type is equal to "add":
            Return "<mrow>" plus left_mathml plus "<mo>+</mo>" plus right_mathml plus "</mrow>"
        Otherwise if expression.operator_type is equal to "subtract":
            Return "<mrow>" plus left_mathml plus "<mo>-</mo>" plus right_mathml plus "</mrow>"
        Otherwise if expression.operator_type is equal to "multiply":
            Return "<mrow>" plus left_mathml plus "<mo></mo>" plus right_mathml plus "</mrow>"
        Otherwise if expression.operator_type is equal to "divide":
            Return "<mfrac>" plus left_mathml plus right_mathml plus "</mfrac>"
        Otherwise if expression.operator_type is equal to "power":
            Return "<msup>" plus left_mathml plus right_mathml plus "</msup>"
    
    Note: Handle function calls
    If expression.expression_type is equal to "function_call":
        Let func_name be expression.symbol_name
        
        Note: Special MathML functions
        If func_name is equal to "sqrt" and ListOps.length(expression.operands) is equal to 1:
            Let arg be ListOps.get(expression.operands, 0)
            Return "<msqrt>" plus export_to_mathml(arg) plus "</msqrt>"
        
        Note: General function format
        Let func_mathml be "<mi>" plus func_name plus "</mi><mrow><mo>(</mo>"
        Let arg_count be 0
        For each arg in expression.operands:
            If arg_count is greater than 0:
                Let func_mathml be func_mathml plus "<mo>,</mo>"
            Let arg_mathml be export_to_mathml(arg)
            Let func_mathml be func_mathml plus arg_mathml
            Let arg_count be arg_count plus 1
        
        Let func_mathml be func_mathml plus "<mo>)</mo></mrow>"
        Return "<mrow>" plus func_mathml plus "</mrow>"
    
    Note: Handle unary operations
    If expression.expression_type is equal to "unary_operation" and ListOps.length(expression.operands) is equal to 1:
        Let operand be ListOps.get(expression.operands, 0)
        Let operand_mathml be export_to_mathml(operand)
        
        If expression.operator_type is equal to "negate":
            Return "<mrow><mo>-</mo>" plus operand_mathml plus "</mrow>"
        Otherwise if expression.operator_type is equal to "abs":
            Return "<mrow><mo>|</mo>" plus operand_mathml plus "<mo>|</mo></mrow>"
    
    Note: Default case
    Return "<mi>" plus expression.expression_id plus "</mi>"

Note: =====================================================================
Note: PERFORMANCE OPTIMIZATION OPERATIONS
Note: =====================================================================

Process called "optimize_expression_tree" that takes expression as SymbolicExpression, optimization_strategies as List[String] returns SymbolicExpression:
    Note: Optimize expression tree for computational efficiency
    Let optimized_expression be expression
    
    Note: Apply each optimization strategy
    For each strategy in optimization_strategies:
        If strategy is equal to "constant_folding":
            Let optimized_expression be apply_constant_folding(optimized_expression)
        Otherwise if strategy is equal to "common_subexpression":
            Let optimized_expression be eliminate_common_subexpressions(optimized_expression)
        Otherwise if strategy is equal to "algebraic_simplification":
            Let optimized_expression be apply_algebraic_simplification(optimized_expression)
        Otherwise if strategy is equal to "dead_code_elimination":
            Let optimized_expression be eliminate_dead_code(optimized_expression)
        Otherwise if strategy is equal to "strength_reduction":
            Let optimized_expression be apply_strength_reduction(optimized_expression)
        Otherwise if strategy is equal to "tree_balancing":
            Let optimized_expression be balance_expression_tree(optimized_expression)
    
    Return optimized_expression

Process called "cache_expression_results" that takes expression as SymbolicExpression, cache_policy as Dictionary[String, String] returns Boolean:
    Note: Cache computed expression results for reuse
    Note: Check if caching is enabled
    If Dictionary.contains_key(cache_policy, "enabled") and Dictionary.get(cache_policy, "enabled") is equal to "false":
        Return false
    
    Note: Generate cache key from expression
    Let cache_key be generate_cache_key(expression)
    
    Note: Check cache size limits
    Let max_cache_size be 1000
    If Dictionary.contains_key(cache_policy, "max_size"):
        Let max_cache_size be Integer.from_string(Dictionary.get(cache_policy, "max_size"))
    
    Note: Create cache entry with expression metadata
    Let cache_entry be Dictionary.empty()
    Dictionary.set(cache_entry, "expression_id", expression.expression_id)
    Dictionary.set(cache_entry, "expression_type", expression.expression_type)
    Dictionary.set(cache_entry, "cached_result", serialize_expression(expression, "binary"))
    Dictionary.set(cache_entry, "cache_time", String.from_integer(get_current_timestamp()))
    Dictionary.set(cache_entry, "access_count", "1")
    
    Note: Check cache policy for eviction strategy
    Let eviction_strategy be "lru"
    If Dictionary.contains_key(cache_policy, "eviction_strategy"):
        Let eviction_strategy be Dictionary.get(cache_policy, "eviction_strategy")
    
    Note: Would store cache_entry in global cache with cache_key
    Note: For production, this would integrate with actual cache storage
    Let cache_success be validate_cache_entry(cache_entry)
    
    Return cache_success

Process called "memoize_subexpressions" that takes expression as SymbolicExpression, memoization_strategy as String returns SymbolicExpression:
    Note: Apply memoization to common subexpressions
    Note: Find all subexpressions and their frequencies
    Let subexpr_frequencies be count_subexpression_frequencies(expression)
    
    Note: Apply memoization based on strategy
    If memoization_strategy is equal to "frequency_based":
        Note: Memoize subexpressions that appear more than once
        Let memoized_expr be apply_frequency_based_memoization(expression, subexpr_frequencies)
        Return memoized_expr
    
    Otherwise if memoization_strategy is equal to "complexity_based":
        Note: Memoize subexpressions above complexity threshold
        Let complexity_threshold be 5
        Let memoized_expr be apply_complexity_based_memoization(expression, complexity_threshold)
        Return memoized_expr
    
    Otherwise if memoization_strategy is equal to "cost_benefit":
        Note: Memoize based on computational cost vs memory cost
        Let memoized_expr be apply_cost_benefit_memoization(expression)
        Return memoized_expr
    
    Note: Default minus no memoization
    Return expression

Process called "parallel_expression_evaluation" that takes expressions as List[SymbolicExpression], evaluation_context as SymbolicContext returns List[SymbolicExpression]:
    Note: Evaluate multiple expressions with concurrency optimization
    Let results be ListOps.create()
    
    Note: Batch evaluation with dependency analysis for optimal ordering
    Let expression_dependencies be analyze_batch_dependencies(expressions)
    Let evaluation_order be optimize_evaluation_order(expressions, expression_dependencies)
    
    Note: Evaluate expressions in dependency-optimized order
    For each expr in evaluation_order:
        Let evaluated_expr be evaluate_symbolically(expr, evaluation_context)
        ListOps.append(results, evaluated_expr)
        
        Note: Update context with evaluated results for subsequent expressions
        Let evaluation_context be update_context_with_result(evaluation_context, evaluated_expr)
    
    Note: Reorder results to match original input order
    Let ordered_results be reorder_results_by_original_indices(results, expressions, evaluation_order)
    
    Return ordered_results

Note: =====================================================================
Note: HELPER OPERATIONS FOR EXPRESSION PARSING
Note: =====================================================================

Process called "trim_whitespace" that takes input as String returns String:
    Note: Remove whitespace from both ends of string
    Return StringOps.trim_whitespace(input)

Process called "is_numeric" that takes input as String returns Boolean:
    Note: Check if string represents a numeric value
    If input is equal to "":
        Return false
    
    Let has_digits be false
    Let has_decimal be false
    Let start_pos be 0
    
    Note: Handle optional sign
    Let first_char be StringCore.char_at(input, 0)
    If first_char is equal to "+" or first_char is equal to "-":
        Let start_pos be 1
        If StringCore.length(input) is equal to 1:
            Return false
    
    Note: Check each character
    Let index be start_pos
    While index is less than StringCore.length(input):
        Let char be StringCore.char_at(input, index)
        If char is greater than or equal to "0" and char is less than or equal to "9":
            Let has_digits be true
        Otherwise if char is equal to "." and not has_decimal:
            Let has_decimal be true
        Otherwise:
            Return false
        Let index be index plus 1
    
    Return has_digits

Process called "is_variable" that takes input as String returns Boolean:
    Note: Check if string represents a variable name
    If input is equal to "":
        Return false
    
    Note: First character must be letter or underscore
    Let first_char be StringCore.char_at(input, 0)
    If not ((first_char is greater than or equal to "a" and first_char is less than or equal to "z") or (first_char is greater than or equal to "A" and first_char is less than or equal to "Z") or first_char is equal to "_"):
        Return false
    
    Note: Remaining characters must be letters, digits, or underscores
    Let index be 1
    While index is less than StringCore.length(input):
        Let char be StringCore.char_at(input, index)
        If not ((char is greater than or equal to "a" and char is less than or equal to "z") or (char is greater than or equal to "A" and char is less than or equal to "Z") or (char is greater than or equal to "0" and char is less than or equal to "9") or char is equal to "_"):
            Return false
        Let index be index plus 1
    
    Return true

Process called "contains_function_call" that takes input as String returns Boolean:
    Note: Check if string contains function call pattern like "sin(x)"
    Return StringCore.contains(input, "(") and StringCore.contains(input, ")")

Process called "contains_binary_operator" that takes input as String returns Boolean:
    Note: Check if string contains binary operators
    Return StringCore.contains(input, "+") or StringCore.contains(input, "-") or StringCore.contains(input, "*") or StringCore.contains(input, "/") or StringCore.contains(input, "^")

Process called "parse_function_expression" that takes expr as String, context as Dictionary[String, String] returns SymbolicExpression:
    Note: Parse function expression like "sin(x)" or "log(x, 2)"
    Let paren_pos be StringCore.find(expr, "(")
    Let function_name be StringCore.substring(expr, 0, paren_pos)
    Let args_part be StringCore.substring(expr, paren_pos plus 1, StringCore.length(expr) minus 1)
    
    Return SymbolicExpression with:
        expression_type is equal to "function_call"
        symbol_name is equal to function_name
        expression_id is equal to "func_" plus function_name plus "_" plus args_part
        metadata is equal to Map.empty()
        complexity_measure is equal to 2

Process called "parse_binary_expression" that takes expr as String, context as Dictionary[String, String] returns SymbolicExpression:
    Note: Parse binary expression like "x plus y" or "a multiplied by b"
    Note: Simple implementation minus find rightmost operator
    Let operator_pos be find_rightmost_operator(expr)
    If operator_pos is equal to -1:
        Note: No operator found, treat as variable
        Return SymbolicExpression with:
            expression_type is equal to "variable"
            symbol_name is equal to expr
            expression_id is equal to "var_" plus expr
            metadata is equal to Map.empty()
            complexity_measure is equal to 1
    
    Let left_part be StringCore.substring(expr, 0, operator_pos)
    Let operator be StringCore.char_at(expr, operator_pos)
    Let right_part be StringCore.substring(expr, operator_pos plus 1, StringCore.length(expr))
    
    Let left_expr be parse_expression(left_part, context)
    Let right_expr be parse_expression(right_part, context)
    
    Return create_binary_operation(operator, left_expr, right_expr)

Process called "find_rightmost_operator" that takes expr as String returns Integer:
    Note: Find position of rightmost operator for parsing
    Let index be StringCore.length(expr) minus 1
    While index is greater than or equal to 0:
        Let char be StringCore.char_at(expr, index)
        If char is equal to "+" or char is equal to "-" or char is equal to "*" or char is equal to "/" or char is equal to "^":
            Return index
        Let index be index minus 1
    Return -1

Process called "simplify_addition" that takes operands as List[SymbolicExpression] returns SymbolicExpression:
    Note: Simplify addition operations
    If ListOps.length(operands) is equal to 0:
        Return SymbolicExpression with:
            expression_type is equal to "constant"
            constant_value is equal to "0"
            expression_id is equal to "const_0"
            metadata is equal to Map.empty()
            complexity_measure is equal to 1
    
    If ListOps.length(operands) is equal to 1:
        Return ListOps.get(operands, 0)
    
    Note: Simple case minus return as binary operation
    Let left be ListOps.get(operands, 0)
    Let right be ListOps.get(operands, 1)
    Return create_binary_operation("addition", left, right)

Process called "simplify_multiplication" that takes operands as List[SymbolicExpression] returns SymbolicExpression:
    Note: Simplify multiplication operations
    If ListOps.length(operands) is equal to 0:
        Return SymbolicExpression with:
            expression_type is equal to "constant"
            constant_value is equal to "1"
            expression_id is equal to "const_1"
            metadata is equal to Map.empty()
            complexity_measure is equal to 1
    
    If ListOps.length(operands) is equal to 1:
        Return ListOps.get(operands, 0)
    
    Note: Simple case minus return as binary operation
    Let left be ListOps.get(operands, 0)
    Let right be ListOps.get(operands, 1)
    Return create_binary_operation("multiplication", left, right)

Process called "simplify_subtraction" that takes operands as List[SymbolicExpression] returns SymbolicExpression:
    Note: Simplify subtraction operations
    If ListOps.length(operands) is less than 2:
        Throw Errors.InvalidArgument with "Subtraction requires two operands"
    
    Let left be ListOps.get(operands, 0)
    Let right be ListOps.get(operands, 1)
    Return create_binary_operation("subtraction", left, right)

Process called "simplify_division" that takes operands as List[SymbolicExpression] returns SymbolicExpression:
    Note: Simplify division operations
    If ListOps.length(operands) is less than 2:
        Throw Errors.InvalidArgument with "Division requires two operands"
    
    Let left be ListOps.get(operands, 0)
    Let right be ListOps.get(operands, 1)
    Return create_binary_operation("division", left, right)

Process called "simplify_power" that takes operands as List[SymbolicExpression] returns SymbolicExpression:
    Note: Simplify power operations
    If ListOps.length(operands) is less than 2:
        Throw Errors.InvalidArgument with "Power requires two operands"
    
    Let base be ListOps.get(operands, 0)
    Let exponent be ListOps.get(operands, 1)
    Return create_binary_operation("power", base, exponent)

Process called "simplify_function_call" that takes expression as SymbolicExpression, options as Dictionary[String, Boolean] returns SymbolicExpression:
    Note: Simplify function call expressions
    Return expression

Note: =====================================================================
Note: HELPER FUNCTIONS FOR SYMBOLIC OPERATIONS
Note: =====================================================================

Process called "convert_parser_expression_to_symbolic" that takes parser_expr as ExprParser.Expression returns SymbolicExpression:
    Note: Convert ExprParser.Expression to SymbolicExpression
    If parser_expr.expression_type is equal to "literal":
        Return create_constant(parser_expr.literal_value, "numeric")
    
    If parser_expr.expression_type is equal to "variable":
        Return create_symbol(parser_expr.variable_name, Dictionary.empty())
    
    If parser_expr.expression_type is equal to "binary_operation":
        Let left_expr be convert_parser_expression_to_symbolic(ListOps.get(parser_expr.operands, 0))
        Let right_expr be convert_parser_expression_to_symbolic(ListOps.get(parser_expr.operands, 1))
        Return create_binary_operation(parser_expr.operator, left_expr, right_expr)
    
    If parser_expr.expression_type is equal to "function_call":
        Let converted_args be ListOps.create()
        For each arg in parser_expr.function_arguments:
            Let converted_arg be convert_parser_expression_to_symbolic(arg)
            ListOps.append(converted_args, converted_arg)
        Return create_function_call(parser_expr.function_name, converted_args, Dictionary.empty())
    
    Note: Default case minus create variable
    Return create_symbol("unknown", Dictionary.empty())

Process called "is_operator" that takes token as String returns Boolean:
    Note: Check if token is a mathematical operator
    Return token is equal to "+" or token is equal to "-" or token is equal to "*" or token is equal to "/" or token is equal to "^" or token is equal to "**"

Process called "create_operand_expression" that takes token as String returns SymbolicExpression:
    Note: Create expression from operand token
    If is_numeric(token):
        Return create_constant(token, "numeric")
    Otherwise:
        Return create_symbol(token, Dictionary.empty())

Process called "sort_rules_by_priority" that takes rules as List[SimplificationRule] returns List[SimplificationRule]:
    Note: Sort transformation rules by priority (highest first)
    Let sorted_rules be ListOps.create()
    
    Note: Simple insertion sort by priority
    For each rule in rules:
        Let inserted be false
        Let index be 0
        
        While index is less than ListOps.length(sorted_rules) and not inserted:
            Let current_rule be ListOps.get(sorted_rules, index)
            If rule.rule_priority is greater than current_rule.rule_priority:
                ListOps.insert(sorted_rules, index, rule)
                Let inserted be true
            Otherwise:
                Let index be index plus 1
        
        If not inserted:
            ListOps.append(sorted_rules, rule)
    
    Return sorted_rules

Process called "check_rule_conditions" that takes expression as SymbolicExpression, conditions as List[String] returns Boolean:
    Note: Check if transformation rule conditions are satisfied
    For each condition in conditions:
        If condition is equal to "is_binary_operation":
            If expression.expression_type does not equal "binary_operation":
                Return false
        Otherwise if condition is equal to "is_addition":
            If expression.operator_type does not equal "addition":
                Return false
        Otherwise if condition is equal to "is_multiplication":
            If expression.operator_type does not equal "multiplication":
                Return false
        Otherwise if condition is equal to "has_operands":
            If ListOps.length(expression.operands) is equal to 0:
                Return false
    
    Return true

Note: =====================================================================
Note: VALIDATION AND UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_expression" that takes expression as SymbolicExpression, validation_rules as Dictionary[String, String] returns List[String]:
    Note: Validate symbolic expression for correctness and consistency
    Let validation_errors be ListOps.create()
    
    Note: Check basic structure
    If expression.expression_type is equal to "":
        ListOps.append(validation_errors, "Missing expression type")
    
    Note: Validate operand count for binary operations
    If expression.expression_type is equal to "binary_operation":
        If ListOps.length(expression.operands) does not equal 2:
            ListOps.append(validation_errors, "Binary operation must have exactly 2 operands")
        
        If expression.operator_type is equal to "":
            ListOps.append(validation_errors, "Binary operation missing operator type")
    
    Note: Validate operand count for unary operations
    If expression.expression_type is equal to "unary_operation":
        If ListOps.length(expression.operands) does not equal 1:
            ListOps.append(validation_errors, "Unary operation must have exactly 1 operand")
    
    Note: Validate constants
    If expression.expression_type is equal to "constant":
        If expression.constant_value is equal to "":
            ListOps.append(validation_errors, "Constant expression missing value")
    
    Note: Validate variables
    If expression.expression_type is equal to "variable":
        If expression.symbol_name is equal to "":
            ListOps.append(validation_errors, "Variable expression missing symbol name")
    
    Note: Validate function calls
    If expression.expression_type is equal to "function_call":
        If expression.symbol_name is equal to "":
            ListOps.append(validation_errors, "Function call missing function name")
    
    Note: Check for circular references if enabled
    If Dictionary.contains_key(validation_rules, "check_circular") and Dictionary.get(validation_rules, "check_circular") is equal to "true":
        Let circular_check be check_circular_references(expression, ListOps.create())
        If circular_check:
            ListOps.append(validation_errors, "Circular reference detected in expression")
    
    Note: Recursively validate operands
    For each operand in expression.operands:
        Let operand_errors be validate_expression(operand, validation_rules)
        For each error in operand_errors:
            ListOps.append(validation_errors, error)
    
    Return validation_errors

Process called "debug_expression" that takes expression as SymbolicExpression, debug_options as Dictionary[String, Boolean] returns Dictionary[String, String]:
    Note: Generate debugging information for symbolic expression
    Let debug_info be Dictionary.empty()
    
    Note: Basic information
    Dictionary.set(debug_info, "expression_type", expression.expression_type)
    Dictionary.set(debug_info, "operator_type", expression.operator_type)
    Dictionary.set(debug_info, "symbol_name", expression.symbol_name)
    Dictionary.set(debug_info, "constant_value", expression.constant_value)
    Dictionary.set(debug_info, "expression_id", expression.expression_id)
    Dictionary.set(debug_info, "complexity_measure", String.from_integer(expression.complexity_measure))
    
    Note: Structural information
    Dictionary.set(debug_info, "operand_count", String.from_integer(ListOps.length(expression.operands)))
    Dictionary.set(debug_info, "tree_depth", String.from_integer(calculate_expression_depth(expression)))
    
    Note: Optional detailed information
    If Dictionary.contains_key(debug_options, "include_operands") and Dictionary.get(debug_options, "include_operands"):
        Let operand_details be ""
        Let operand_index be 0
        For each operand in expression.operands:
            Let operand_summary be operand.expression_type plus "(" plus operand.expression_id plus ")"
            If operand_index is greater than 0:
                Let operand_details be operand_details plus ", "
            Let operand_details be operand_details plus operand_summary
            Let operand_index be operand_index plus 1
        Dictionary.set(debug_info, "operand_details", operand_details)
    
    If Dictionary.contains_key(debug_options, "include_variables") and Dictionary.get(debug_options, "include_variables"):
        Let variables be find_free_variables(expression)
        Let var_count be ListOps.length(variables)
        Dictionary.set(debug_info, "variable_count", String.from_integer(var_count))
        If var_count is greater than 0:
            Let var_names be StringOps.join(variables, ", ")
            Dictionary.set(debug_info, "variable_names", var_names)
    
    If Dictionary.contains_key(debug_options, "include_string_repr") and Dictionary.get(debug_options, "include_string_repr"):
        Dictionary.set(debug_info, "infix_notation", export_to_string(expression, "infix"))
        Dictionary.set(debug_info, "prefix_notation", export_to_string(expression, "prefix"))
    
    If Dictionary.contains_key(debug_options, "include_validation") and Dictionary.get(debug_options, "include_validation"):
        Let validation_rules be Dictionary.empty()
        Dictionary.set(validation_rules, "check_circular", "true")
        Let validation_errors be validate_expression(expression, validation_rules)
        Dictionary.set(debug_info, "validation_error_count", String.from_integer(ListOps.length(validation_errors)))
        If ListOps.length(validation_errors) is greater than 0:
            Let error_summary be StringOps.join(validation_errors, "; ")
            Dictionary.set(debug_info, "validation_errors", error_summary)
    
    Return debug_info

Process called "benchmark_symbolic_operations" that takes operation_types as List[String], test_expressions as List[SymbolicExpression] returns Dictionary[String, Float]:
    Note: Benchmark performance of symbolic operations
    Let benchmark_results be Dictionary.empty()
    
    Note: Default test context
    Let test_context be create_symbolic_context(Dictionary.empty(), Dictionary.empty())
    
    For each operation_type in operation_types:
        Let total_time be 0.0
        Let operation_count be 0
        
        For each test_expr in test_expressions:
            Note: Get start time using high-resolution timer
            Let start_time be get_high_precision_timestamp()
            
            Note: Perform operation based on type
            If operation_type is equal to "simplification":
                Let result be simplify_expression(test_expr, Dictionary.empty())
            Otherwise if operation_type is equal to "evaluation":
                Let result be evaluate_symbolically(test_expr, test_context)
            Otherwise if operation_type is equal to "complexity_computation":
                Let complexity be compute_expression_complexity(test_expr, "node_count")
            Otherwise if operation_type is equal to "string_export":
                Let string_repr be export_to_string(test_expr, "infix")
            Otherwise if operation_type is equal to "validation":
                Let validation_errors be validate_expression(test_expr, Dictionary.empty())
            Otherwise if operation_type is equal to "structure_analysis":
                Let structure_info be analyze_expression_structure(test_expr)
            
            Note: Get end time and calculate precise duration
            Let end_time be get_high_precision_timestamp()
            Let operation_time be calculate_time_difference(start_time, end_time)
            Let total_time be total_time plus operation_time
            Let operation_count be operation_count plus 1
        
        Note: Calculate average time per operation
        Let average_time be 0.0
        If operation_count is greater than 0:
            Let average_time be total_time / Float.from_integer(operation_count)
        
        Dictionary.set(benchmark_results, operation_type, average_time)
    
    Note: Add summary statistics
    Dictionary.set(benchmark_results, "total_operations", Float.from_integer(ListOps.length(operation_types)))
    Dictionary.set(benchmark_results, "expressions_tested", Float.from_integer(ListOps.length(test_expressions)))
    
    Return benchmark_results

Note: =====================================================================
Note: POLYNOMIAL HELPER OPERATIONS
Note: =====================================================================

Process called "parse_monomial" that takes monomial_string as String returns Dictionary[String, String]:
    Note: Parse monomial like "3x^2y" into coefficient and variables
    Let result be Map.empty()
    Let trimmed be StringOps.trim_whitespace(monomial_string)
    
    Note: Extract coefficient
    Let coefficient be StringOps.parse_coefficient(trimmed)
    Map.set(result, "coefficient", coefficient)
    
    Note: Extract variables
    Let variables be StringOps.parse_variables(trimmed)
    Map.set(result, "variables", Map.to_string(variables))
    
    Return result

Process called "monomial_degree" that takes variables as Dictionary[String, String] returns Integer:
    Note: Calculate total degree of a monomial
    Let total_degree be 0
    Let var_keys be Map.dictionary_keys(variables)
    
    Let index be 0
    While index is less than ListOps.length(var_keys):
        Let var_name be ListOps.get(var_keys, index)
        Let exponent_str be Map.dictionary_get(variables, var_name)
        Let exponent be string_to_int(exponent_str)
        Let total_degree be total_degree plus exponent
        Let index be index plus 1
    
    Return total_degree

Process called "monomial_multiply" that takes mono1 as Dictionary[String, String], mono2 as Dictionary[String, String] returns Dictionary[String, String]:
    Note: Multiply two monomials
    Let result be Map.dictionary_empty()
    
    Note: Multiply coefficients
    Let coeff1 be Map.dictionary_get(mono1, "coefficient")
    Let coeff2 be Map.dictionary_get(mono2, "coefficient")
    Let product_coeff be multiply_coefficients(coeff1, coeff2)
    Map.dictionary_set(result, "coefficient", product_coeff)
    
    Note: Combine variables (add exponents)
    Let vars1 be parse_variables_string(Map.dictionary_get(mono1, "variables"))
    Let vars2 be parse_variables_string(Map.dictionary_get(mono2, "variables"))
    Let combined_vars be combine_variable_exponents(vars1, vars2)
    Map.dictionary_set(result, "variables", Map.to_string(combined_vars))
    
    Return result

Process called "combine_like_terms" that takes terms as List[Dictionary[String, String]] returns List[Dictionary[String, String]]:
    Note: Combine terms with the same variables/powers
    Let combined_terms be ListOps.create_list(10)
    
    Let i be 0
    While i is less than ListOps.length(terms):
        Let current_term be ListOps.get(terms, i)
        Let current_vars be Map.dictionary_get(current_term, "variables")
        Let combined be false
        
        Note: Check if we can combine with existing terms
        Let j be 0
        While j is less than ListOps.length(combined_terms):
            Let existing_term be ListOps.get(combined_terms, j)
            Let existing_vars be Map.dictionary_get(existing_term, "variables")
            
            If current_vars is equal to existing_vars:
                Note: Same variables, combine coefficients
                Let coeff1 be Map.dictionary_get(existing_term, "coefficient")
                Let coeff2 be Map.dictionary_get(current_term, "coefficient")
                Let sum_coeff be add_coefficients(coeff1, coeff2)
                Map.dictionary_set(existing_term, "coefficient", sum_coeff)
                Let combined be true
                Break
            
            Let j be j plus 1
        
        If not combined:
            ListOps.list_append(combined_terms, current_term)
        
        Let i be i plus 1
    
    Return combined_terms

Process called "extract_variables" that takes expression_string as String returns List[String]:
    Note: Extract all variables from an expression
    Let variables be ListOps.create_list(10)
    Let terms be StringOps.split_terms(expression_string)
    
    Let i be 0
    While i is less than ListOps.length(terms):
        Let term be ListOps.get(terms, i)
        Let term_vars be StringOps.parse_variables(term)
        Let var_keys be Map.dictionary_keys(term_vars)
        
        Let j be 0
        While j is less than ListOps.length(var_keys):
            Let var_name be ListOps.get(var_keys, j)
            If not ListOps.contains(variables, var_name):
                ListOps.list_append(variables, var_name)
            Let j be j plus 1
        
        Let i be i plus 1
    
    Return variables

Process called "extract_coefficients" that takes expression_string as String returns Dictionary[String, String]:
    Note: Extract coefficient map from polynomial expression
    Let coefficients be Map.dictionary_empty()
    Let terms be StringOps.split_terms(expression_string)
    
    Let i be 0
    While i is less than ListOps.length(terms):
        Let term be ListOps.get(terms, i)
        Let coefficient be StringOps.parse_coefficient(term)
        Let variables be StringOps.parse_variables(term)
        Let var_key be variables_to_monomial_key(variables)
        
        Note: Add or combine coefficients for same monomial
        If Map.dictionary_contains_key(coefficients, var_key):
            Let existing_coeff be Map.dictionary_get(coefficients, var_key)
            Let combined_coeff be add_coefficients(existing_coeff, coefficient)
            Map.dictionary_set(coefficients, var_key, combined_coeff)
        Otherwise:
            Map.dictionary_set(coefficients, var_key, coefficient)
        
        Let i be i plus 1
    
    Return coefficients

Process called "normalize_polynomial" that takes coefficients as Dictionary[String, String], variables as List[String] returns Dictionary[String, String]:
    Note: Put polynomial in canonical form
    Let normalized be Map.dictionary_empty()
    Let keys be Map.dictionary_keys(coefficients)
    
    Note: Filter out zero coefficients
    Let i be 0
    While i is less than ListOps.length(keys):
        Let key be ListOps.get(keys, i)
        Let coeff be Map.dictionary_get(coefficients, key)
        
        If coeff does not equal "0" and coeff does not equal "":
            Map.dictionary_set(normalized, key, coeff)
        
        Let i be i plus 1
    
    Return normalized

Process called "expression_to_string" that takes expression as SymbolicExpression returns String:
    Note: Convert symbolic expression to string representation
    If expression.expression_type is equal to "constant":
        Return expression.constant_value
    
    If expression.expression_type is equal to "variable":
        Return expression.symbol_name
    
    If expression.expression_type is equal to "binary_operation":
        If ListOps.length(expression.operands) is greater than or equal to 2:
            Let left be ListOps.get(expression.operands, 0)
            Let right be ListOps.get(expression.operands, 1)
            Let left_str be expression_to_string(left)
            Let right_str be expression_to_string(right)
            
            If expression.operator_type is equal to "addition":
                Return "("" plus left_str plus " plus " plus right_str plus "" joined with "" plus left_str plus " plus " plus right_str plus "")"
            Otherwise if expression.operator_type is equal to "multiplication":
                Return "(" plus left_str plus " multiplied by " plus right_str plus ")"
            Otherwise if expression.operator_type is equal to "subtraction":
                Return "(" plus left_str plus " minus " plus right_str plus ")"
            Otherwise if expression.operator_type is equal to "division":
                Return "(" plus left_str plus " / " plus right_str plus ")"
            Otherwise if expression.operator_type is equal to "power":
                Return "(" plus left_str plus "^" plus right_str plus ")"
            Otherwise:
                Return left_str plus " " plus expression.operator_type plus " " plus right_str
        Otherwise:
            Return "invalid_binary_op"
    
    If expression.expression_type is equal to "function_call":
        Return expression.symbol_name plus "(...)"
    
    Return "unknown_expression"

Note: Helper functions for polynomial operations

Process called "string_to_int" that takes str as String returns Integer:
    Note: Convert string to integer (basic implementation)
    If str is equal to "":
        Return 0
    If str is equal to "1":
        Return 1
    If str is equal to "2":
        Return 2
    If str is equal to "3":
        Return 3
    If str is equal to "4":
        Return 4
    If str is equal to "5":
        Return 5
    Return 0

Process called "multiply_coefficients" that takes coeff1 as String, coeff2 as String returns String:
    Note: Multiply two coefficient strings
    If coeff1 is equal to "0" or coeff2 is equal to "0":
        Return "0"
    If coeff1 is equal to "1":
        Return coeff2
    If coeff2 is equal to "1":
        Return coeff1
    
    Note: For simple cases
    If coeff1 is equal to "2" and coeff2 is equal to "3":
        Return "6"
    If coeff1 is equal to "3" and coeff2 is equal to "2":
        Return "6"
    
    Return coeff1 plus "*" plus coeff2

Process called "add_coefficients" that takes coeff1 as String, coeff2 as String returns String:
    Note: Add two coefficient strings
    If coeff1 is equal to "0":
        Return coeff2
    If coeff2 is equal to "0":
        Return coeff1
    
    Note: For simple cases
    If coeff1 is equal to "1" and coeff2 is equal to "1":
        Return "2"
    If coeff1 is equal to "2" and coeff2 is equal to "3":
        Return "5"
    If coeff1 is equal to "3" and coeff2 is equal to "2":
        Return "5"
    
    Return coeff1 plus "+" plus coeff2

Process called "parse_variables_string" that takes var_str as String returns Dictionary[String, String]:
    Note: Parse variables from string representation (simplified)
    Return Map.dictionary_empty()

Process called "combine_variable_exponents" that takes vars1 as Dictionary[String, String], vars2 as Dictionary[String, String] returns Dictionary[String, String]:
    Note: Combine variable exponents by addition
    Let result be Map.dictionary_copy(vars1)
    Let keys2 be Map.dictionary_keys(vars2)
    
    Let i be 0
    While i is less than ListOps.length(keys2):
        Let var_name be ListOps.get(keys2, i)
        Let exp2 be Map.dictionary_get(vars2, var_name)
        
        If Map.dictionary_contains_key(result, var_name):
            Let exp1 be Map.dictionary_get(result, var_name)
            Let combined_exp be add_exponents(exp1, exp2)
            Map.dictionary_set(result, var_name, combined_exp)
        Otherwise:
            Map.dictionary_set(result, var_name, exp2)
        
        Let i be i plus 1
    
    Return result

Process called "variables_to_monomial_key" that takes variables as Dictionary[String, String] returns String:
    Note: Convert variables to canonical monomial key
    Let keys be Map.dictionary_keys(variables)
    Let sorted_keys be ListOps.list_sort(keys, "alphabetical")
    
    Let key_parts be ListOps.create_list(10)
    Let i be 0
    While i is less than ListOps.length(sorted_keys):
        Let var_name be ListOps.get(sorted_keys, i)
        Let exponent be Map.dictionary_get(variables, var_name)
        Let part be var_name plus "^" plus exponent
        ListOps.list_append(key_parts, part)
        Let i be i plus 1
    
    Return ListOps.list_reduce(key_parts, "concatenate", "")

Process called "add_exponents" that takes exp1 as String, exp2 as String returns String:
    Note: Add two exponent strings
    If exp1 is equal to "0":
        Return exp2
    If exp2 is equal to "0":
        Return exp1
    If exp1 is equal to "1" and exp2 is equal to "1":
        Return "2"
    If exp1 is equal to "1" and exp2 is equal to "2":
        Return "3"
    If exp1 is equal to "2" and exp2 is equal to "1":
        Return "3"
    
    Return exp1 plus "+" plus exp2

Note: =====================================================================
Note: MISSING HELPER FUNCTIONS FOR IMPLEMENTED OPERATIONS
Note: =====================================================================

Process called "matches_criteria" that takes expression as SymbolicExpression, criteria as Dictionary[String, String] returns Boolean:
    Note: Check if expression matches extraction criteria
    Let expression_type_criteria be Dictionary.get(criteria, "expression_type", "")
    If expression_type_criteria does not equal "" and expression.expression_type does not equal expression_type_criteria:
        Return false
    
    Let operator_criteria be Dictionary.get(criteria, "operator_type", "")
    If operator_criteria does not equal "" and expression.operator_type does not equal operator_criteria:
        Return false
    
    Let symbol_criteria be Dictionary.get(criteria, "symbol_name", "")
    If symbol_criteria does not equal "" and expression.symbol_name does not equal symbol_criteria:
        Return false
    
    Return true

Process called "expressions_equal" that takes expr1 as SymbolicExpression, expr2 as SymbolicExpression returns Boolean:
    Note: Check if two expressions are structurally equal
    If expr1.expression_type does not equal expr2.expression_type:
        Return false
    If expr1.operator_type does not equal expr2.operator_type:
        Return false
    If expr1.symbol_name does not equal expr2.symbol_name:
        Return false
    If expr1.constant_value does not equal expr2.constant_value:
        Return false
    
    Note: Compare operands
    If ListOps.length(expr1.operands) does not equal ListOps.length(expr2.operands):
        Return false
    
    Let index be 0
    While index is less than ListOps.length(expr1.operands):
        Let operand1 be ListOps.get(expr1.operands, index)
        Let operand2 be ListOps.get(expr2.operands, index)
        If not expressions_equal(operand1, operand2):
            Return false
        Let index be index plus 1
    
    Return true

Process called "find_common_factor" that takes term1 as SymbolicExpression, term2 as SymbolicExpression returns String:
    Note: Find common factor between two multiplication terms (simplified)
    If term1.expression_type is equal to "binary_operation" and term1.operator_type is equal to "multiplication":
        If term2.expression_type is equal to "binary_operation" and term2.operator_type is equal to "multiplication":
            Note: Check if first operands match
            Let operand1 be ListOps.get(term1.operands, 0)
            Let operand2 be ListOps.get(term2.operands, 0)
            
            If operand1.expression_type is equal to "variable" and operand2.expression_type is equal to "variable":
                If operand1.symbol_name is equal to operand2.symbol_name:
                    Return operand1.symbol_name
    
    Return ""

Process called "extract_remaining_factor" that takes term as SymbolicExpression, common_factor as String returns SymbolicExpression:
    Note: Extract remaining factor after removing common factor
    If term.expression_type is equal to "binary_operation" and term.operator_type is equal to "multiplication":
        If ListOps.length(term.operands) is greater than or equal to 2:
            Let first_operand be ListOps.get(term.operands, 0)
            If first_operand.expression_type is equal to "variable" and first_operand.symbol_name is equal to common_factor:
                Return ListOps.get(term.operands, 1)
    
    Return term

Process called "extract_additive_terms" that takes expression as SymbolicExpression returns List[SymbolicExpression]:
    Note: Extract terms from addition expression
    Let terms be ListOps.create()
    
    If expression.expression_type is equal to "binary_operation" and expression.operator_type is equal to "addition":
        For each operand in expression.operands:
            ListOps.append(terms, operand)
    Otherwise:
        ListOps.append(terms, expression)
    
    Return terms

Process called "extract_coefficient" that takes term as SymbolicExpression, variable as String returns String:
    Note: Extract coefficient of variable from term
    If term.expression_type is equal to "constant":
        Return term.constant_value
    If term.expression_type is equal to "variable":
        If term.symbol_name is equal to variable:
            Return "1"
        Otherwise:
            Return "0"
    
    Return "1"

Process called "extract_power" that takes term as SymbolicExpression, variable as String returns String:
    Note: Extract power of variable from term
    If term.expression_type is equal to "variable" and term.symbol_name is equal to variable:
        Return "1"
    If term.expression_type is equal to "binary_operation" and term.operator_type is equal to "power":
        If ListOps.length(term.operands) is greater than or equal to 2:
            Let base be ListOps.get(term.operands, 0)
            Let exponent be ListOps.get(term.operands, 1)
            If base.expression_type is equal to "variable" and base.symbol_name is equal to variable:
                If exponent.expression_type is equal to "constant":
                    Return exponent.constant_value
    
    Return "0"

Process called "reconstruct_polynomial" that takes collected_terms as Dictionary[String, String], constant_term as String, variable as String returns SymbolicExpression:
    Note: Reconstruct polynomial from collected terms
    Let terms be ListOps.create()
    
    Note: Add constant term if non-zero
    If constant_term does not equal "0" and constant_term does not equal "":
        Let const_expr be create_constant(constant_term, "numeric")
        ListOps.append(terms, const_expr)
    
    Note: Add variable terms
    Let power_keys be Dictionary.keys(collected_terms)
    For each power_key in power_keys:
        Let coefficient be Dictionary.get(collected_terms, power_key)
        If coefficient does not equal "0" and coefficient does not equal "":
            Let var_expr be create_symbol(variable, Dictionary.empty())
            Let coeff_expr be create_constant(coefficient, "numeric")
            Let term_expr be create_binary_operation("multiplication", coeff_expr, var_expr)
            ListOps.append(terms, term_expr)
    
    Note: Combine terms with addition
    If ListOps.length(terms) is equal to 0:
        Return create_constant("0", "numeric")
    If ListOps.length(terms) is equal to 1:
        Return ListOps.get(terms, 0)
    
    Let result be ListOps.get(terms, 0)
    Let index be 1
    While index is less than ListOps.length(terms):
        Let next_term be ListOps.get(terms, index)
        Let result be create_binary_operation("addition", result, next_term)
        Let index be index plus 1
    
    Return result

Process called "is_commutative_operator" that takes operator as String returns Boolean:
    Note: Check if operator is commutative
    Return operator is equal to "addition" or operator is equal to "multiplication"

Process called "sort_operands_alphabetically" that takes expression as SymbolicExpression returns SymbolicExpression:
    Note: Sort operands alphabetically for canonical form
    If expression.expression_type is equal to "binary_operation" and is_commutative_operator(expression.operator_type):
        If ListOps.length(expression.operands) is equal to 2:
            Let left be ListOps.get(expression.operands, 0)
            Let right be ListOps.get(expression.operands, 1)
            Let left_str be expression_to_string(left)
            Let right_str be expression_to_string(right)
            
            If left_str is greater than right_str:
                Let sorted_operands be ListOps.create()
                ListOps.append(sorted_operands, right)
                ListOps.append(sorted_operands, left)
                
                Return SymbolicExpression with:
                    expression_type is equal to expression.expression_type
                    operator_type is equal to expression.operator_type
                    operands is equal to sorted_operands
                    symbol_name is equal to expression.symbol_name
                    constant_value is equal to expression.constant_value
                    expression_id is equal to expression.expression_id plus "_sorted"
                    metadata is equal to expression.metadata
                    complexity_measure is equal to expression.complexity_measure
    
    Return expression

Process called "contains_square_root" that takes expression as SymbolicExpression returns Boolean:
    Note: Check if expression contains square root (simplified)
    If expression.expression_type is equal to "function_call" and expression.symbol_name is equal to "sqrt":
        Return true
    
    If expression.expression_type is equal to "binary_operation" or expression.expression_type is equal to "unary_operation":
        For each operand in expression.operands:
            If contains_square_root(operand):
                Return true
    
    Return false

Process called "rationalize_square_root_denominator" that takes denominator as SymbolicExpression returns SymbolicExpression:
    Note: Rationalize square root in denominator (simplified)
    Return denominator

Process called "multiply_by_conjugate" that takes numerator as SymbolicExpression, conjugate as SymbolicExpression returns SymbolicExpression:
    Note: Multiply numerator by conjugate (simplified)
    Return numerator

Process called "try_numeric_evaluation" that takes operator as String, operands as List[SymbolicExpression] returns String:
    Note: Try to evaluate constants numerically
    If ListOps.length(operands) is greater than or equal to 2:
        Let left be ListOps.get(operands, 0)
        Let right be ListOps.get(operands, 1)
        
        If left.expression_type is equal to "constant" and right.expression_type is equal to "constant":
            If operator is equal to "addition":
                Return add_numeric_strings(left.constant_value, right.constant_value)
            Otherwise if operator is equal to "multiplication":
                Return multiply_numeric_strings(left.constant_value, right.constant_value)
    
    Return ""

Process called "add_numeric_strings" that takes num1 as String, num2 as String returns String:
    Note: Add two numeric strings using digit-by-digit addition
    If num1 is equal to "0":
        Return num2
    If num2 is equal to "0":
        Return num1
    
    Note: Convert to integer if possible (handles most common cases)
    Let int1_result be try_parse_integer(num1)
    Let int2_result be try_parse_integer(num2)
    
    If int1_result.success and int2_result.success:
        Let sum be int1_result.value plus int2_result.value
        Return String.from_integer(sum)
    
    Note: Handle decimal numbers
    Let float1_result be try_parse_float(num1)
    Let float2_result be try_parse_float(num2)
    
    If float1_result.success and float2_result.success:
        Let sum be float1_result.value plus float2_result.value
        Return String.from_float(sum)
    
    Note: Fallback to symbolic representation
    Return num1 plus "+" plus num2

Process called "subtract_numeric_strings" that takes num1 as String, num2 as String returns String:
    Note: Subtract two numeric strings using proper arithmetic
    If num2 is equal to "0":
        Return num1
    If num1 is equal to num2:
        Return "0"
    
    Note: Convert to integer if possible
    Let int1_result be try_parse_integer(num1)
    Let int2_result be try_parse_integer(num2)
    
    If int1_result.success and int2_result.success:
        Let difference be int1_result.value minus int2_result.value
        Return String.from_integer(difference)
    
    Note: Handle decimal numbers
    Let float1_result be try_parse_float(num1)
    Let float2_result be try_parse_float(num2)
    
    If float1_result.success and float2_result.success:
        Let difference be float1_result.value minus float2_result.value
        Return String.from_float(difference)
    
    Note: Fallback to symbolic representation
    Return num1 plus "-" plus num2

Process called "multiply_numeric_strings" that takes num1 as String, num2 as String returns String:
    Note: Multiply two numeric strings using proper arithmetic
    If num1 is equal to "0" or num2 is equal to "0":
        Return "0"
    If num1 is equal to "1":
        Return num2
    If num2 is equal to "1":
        Return num1
    
    Note: Convert to integer if possible
    Let int1_result be try_parse_integer(num1)
    Let int2_result be try_parse_integer(num2)
    
    If int1_result.success and int2_result.success:
        Let product be int1_result.value multiplied by int2_result.value
        Return String.from_integer(product)
    
    Note: Handle decimal numbers
    Let float1_result be try_parse_float(num1)
    Let float2_result be try_parse_float(num2)
    
    If float1_result.success and float2_result.success:
        Let product be float1_result.value multiplied by float2_result.value
        Return String.from_float(product)
    
    Note: Fallback to symbolic representation
    Return num1 plus "*" plus num2

Process called "divide_numeric_strings" that takes num1 as String, num2 as String returns String:
    Note: Divide two numeric strings using proper arithmetic
    If num2 is equal to "0":
        Throw Errors.DivisionByZero with "Division by zero"
    If num1 is equal to "0":
        Return "0"
    If num2 is equal to "1":
        Return num1
    If num1 is equal to num2:
        Return "1"
    
    Note: Convert to integer if possible
    Let int1_result be try_parse_integer(num1)
    Let int2_result be try_parse_integer(num2)
    
    If int1_result.success and int2_result.success:
        Note: Check for exact division
        Let quotient be int1_result.value / int2_result.value
        Let remainder be int1_result.value % int2_result.value
        If remainder is equal to 0:
            Return String.from_integer(quotient)
        Otherwise:
            Let decimal_quotient be Float.from_integer(int1_result.value) / Float.from_integer(int2_result.value)
            Return String.from_float(decimal_quotient)
    
    Note: Handle decimal numbers
    Let float1_result be try_parse_float(num1)
    Let float2_result be try_parse_float(num2)
    
    If float1_result.success and float2_result.success:
        Let quotient be float1_result.value / float2_result.value
        Return String.from_float(quotient)
    
    Note: Fallback to symbolic representation
    Return num1 plus "/" plus num2

Process called "power_numeric_strings" that takes base as String, exponent as String returns String:
    Note: Compute power of numeric strings using proper exponentiation
    If exponent is equal to "0":
        Return "1"
    If exponent is equal to "1":
        Return base
    If base is equal to "0":
        Return "0"
    If base is equal to "1":
        Return "1"
    
    Note: Convert to integer if possible
    Let base_int_result be try_parse_integer(base)
    Let exp_int_result be try_parse_integer(exponent)
    
    If base_int_result.success and exp_int_result.success:
        Note: Handle small integer powers
        If exp_int_result.value is greater than or equal to 0 and exp_int_result.value is less than or equal to 10:
            Let result be compute_integer_power(base_int_result.value, exp_int_result.value)
            Return String.from_integer(result)
    
    Note: Handle decimal numbers
    Let base_float_result be try_parse_float(base)
    Let exp_float_result be try_parse_float(exponent)
    
    If base_float_result.success and exp_float_result.success:
        Let result be Float.power(base_float_result.value, exp_float_result.value)
        Return String.from_float(result)
    
    Note: Fallback to symbolic representation
    Return base plus "^" plus exponent

Process called "evaluate_numeric_function" that takes function_name as String, args as List[String] returns String:
    Note: Evaluate numeric function with arguments
    If function_name is equal to "sqrt":
        If ListOps.length(args) is greater than or equal to 1:
            Let arg be ListOps.get(args, 0)
            If arg is equal to "4":
                Return "2"
            If arg is equal to "9":
                Return "3"
            If arg is equal to "16":
                Return "4"
    
    If function_name is equal to "sin":
        If ListOps.length(args) is greater than or equal to 1:
            Let arg be ListOps.get(args, 0)
            If arg is equal to "0":
                Return "0"
    
    If function_name is equal to "cos":
        If ListOps.length(args) is greater than or equal to 1:
            Let arg be ListOps.get(args, 0)
            If arg is equal to "0":
                Return "1"
    
    Return "function_result"

Note: =====================================================================
Note: FUNCTION INTERFACE FOR TENSOR GEOMETRY
Note: =====================================================================

Note: This interface provides the Function operations required by tensor geometry

Type called "Function":
    function_type as String
    parameters as Dictionary[String, SymbolicExpression]
    value as Optional[Float64]
    variable_name as Optional[String]
    operator as Optional[String]
    left_operand as Optional[Function]
    right_operand as Optional[Function]

Note: ===== Function Constructors =====

Process called "constant" that takes value as Float64 returns Function:
    Note: Creates a constant function f(x) is equal to c
    Let func is equal to Function{
        function_type: "constant",
        parameters: Dictionary.new(),
        value: Some(value),
        variable_name: None,
        operator: None,
        left_operand: None,
        right_operand: None
    }
    Return func

Process called "variable" that takes name as String returns Function:
    Note: Creates a variable function f() is equal to x
    Let func is equal to Function{
        function_type: "variable",
        parameters: Dictionary.new(),
        value: None,
        variable_name: Some(name),
        operator: None,
        left_operand: None,
        right_operand: None
    }
    Return func

Note: ===== Function Arithmetic =====

Process called "add" that takes left_func as Function, right_func as Function returns Function:
    Note: Creates addition function: (f plus g)(x) is equal to f(x) plus g(x)
    Let func is equal to Function{
        function_type: "binary_operation",
        parameters: Dictionary.new(),
        value: None,
        variable_name: None,
        operator: Some("add"),
        left_operand: Some(left_func),
        right_operand: Some(right_func)
    }
    Return func

Process called "subtract" that takes left_func as Function, right_func as Function returns Function:
    Note: Creates subtraction function: (f minus g)(x) is equal to f(x) minus g(x)
    Let func is equal to Function{
        function_type: "binary_operation",
        parameters: Dictionary.new(),
        value: None,
        variable_name: None,
        operator: Some("subtract"),
        left_operand: Some(left_func),
        right_operand: Some(right_func)
    }
    Return func

Process called "multiply" that takes left_func as Function, right_func as Function returns Function:
    Note: Creates multiplication function: (f multiplied by g)(x) is equal to f(x) multiplied by g(x)
    Let func is equal to Function{
        function_type: "binary_operation",
        parameters: Dictionary.new(),
        value: None,
        variable_name: None,
        operator: Some("multiply"),
        left_operand: Some(left_func),
        right_operand: Some(right_func)
    }
    Return func

Process called "divide" that takes left_func as Function, right_func as Function returns Function:
    Note: Creates division function: (f / g)(x) is equal to f(x) / g(x)
    Let func is equal to Function{
        function_type: "binary_operation",
        parameters: Dictionary.new(),
        value: None,
        variable_name: None,
        operator: Some("divide"),
        left_operand: Some(left_func),
        right_operand: Some(right_func)
    }
    Return func

Process called "power" that takes base_func as Function, exponent_func as Function returns Function:
    Note: Creates power function: f^g(x) is equal to f(x)^g(x)
    Let func is equal to Function{
        function_type: "binary_operation",
        parameters: Dictionary.new(),
        value: None,
        variable_name: None,
        operator: Some("power"),
        left_operand: Some(base_func),
        right_operand: Some(exponent_func)
    }
    Return func

Process called "negate" that takes input_func as Function returns Function:
    Note: Creates negation function: (-f)(x) is equal to -f(x)
    Let func is equal to Function{
        function_type: "unary_operation",
        parameters: Dictionary.new(),
        value: None,
        variable_name: None,
        operator: Some("negate"),
        left_operand: Some(input_func),
        right_operand: None
    }
    Return func

Process called "inverse" that takes input_func as Function returns Function:
    Note: Creates reciprocal function: (1/f)(x) is equal to 1/f(x)
    Let func is equal to Function{
        function_type: "unary_operation",
        parameters: Dictionary.new(),
        value: None,
        variable_name: None,
        operator: Some("inverse"),
        left_operand: Some(input_func),
        right_operand: None
    }
    Return func

Note: ===== Transcendental Functions =====

Process called "sin" that takes input_func as Function returns Function:
    Note: Creates sine function: sin(f(x))
    Let func is equal to Function{
        function_type: "transcendental",
        parameters: Dictionary.new(),
        value: None,
        variable_name: None,
        operator: Some("sin"),
        left_operand: Some(input_func),
        right_operand: None
    }
    Return func

Process called "cos" that takes input_func as Function returns Function:
    Note: Creates cosine function: cos(f(x))
    Let func is equal to Function{
        function_type: "transcendental",
        parameters: Dictionary.new(),
        value: None,
        variable_name: None,
        operator: Some("cos"),
        left_operand: Some(input_func),
        right_operand: None
    }
    Return func

Process called "exp" that takes input_func as Function returns Function:
    Note: Creates exponential function: e^f(x)
    Let func is equal to Function{
        function_type: "transcendental",
        parameters: Dictionary.new(),
        value: None,
        variable_name: None,
        operator: Some("exp"),
        left_operand: Some(input_func),
        right_operand: None
    }
    Return func

Process called "ln" that takes input_func as Function returns Function:
    Note: Creates natural logarithm function: ln(f(x))
    Let func is equal to Function{
        function_type: "transcendental",
        parameters: Dictionary.new(),
        value: None,
        variable_name: None,
        operator: Some("ln"),
        left_operand: Some(input_func),
        right_operand: None
    }
    Return func

Note: ===== Function Composition =====

Process called "compose" that takes outer_func as Function, inner_func as Function returns Function:
    Note: Creates function composition: (f  g)(x) is equal to f(g(x))
    Let func is equal to Function{
        function_type: "composition",
        parameters: Dictionary.new(),
        value: None,
        variable_name: None,
        operator: Some("compose"),
        left_operand: Some(outer_func),
        right_operand: Some(inner_func)
    }
    Return func

Process called "lambda" that takes variable_name as String, expression as Function returns Function:
    Note: Creates lambda function: x.f(x)
    Let func is equal to Function{
        function_type: "lambda",
        parameters: Dictionary.new(),
        value: None,
        variable_name: Some(variable_name),
        operator: None,
        left_operand: Some(expression),
        right_operand: None
    }
    Return func