Note:
math/symbolic/calculus.runa
Symbolic Calculus Operations and Analysis

This module provides comprehensive symbolic calculus operations including:
- Symbolic differentiation with all standard rules
- Symbolic integration techniques and methods
- Multivariable calculus operations (partial derivatives, gradients)
- Vector calculus operations (divergence, curl, line integrals)
- Taylor and Laurent series expansions
- Limit computation and analysis
- Differential equation solving (ODEs and PDEs)
- Fourier and Laplace transform symbolics
- Variational calculus and optimization
- Complex analysis operations (residues, contour integration)
- Geometric differential operations on manifolds
- Tensor calculus and Einstein notation
- Stokes' theorem and related integral theorems
- Asymptotic analysis and behavior
- Special function differentiation and integration
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "text/string/manipulation" as StringOps
Import module "text/string/core" as StringCore
Import module "data/collections/core/list" as ListOps
Import module "data/collections/core/map" as Map
Import module "math/symbolic/core" as SymbolicCore

Note: =====================================================================
Note: CALCULUS DATA STRUCTURES
Note: =====================================================================

Type called "Derivative":
    expression as String
    variable as String
    order as Integer
    partial_variables as List[String]
    derivative_rule as String
    chain_rule_applications as List[String]

Type called "Integral":
    integrand as String
    variable as String
    integration_bounds as Dictionary[String, String]
    integration_method as String
    substitutions_used as List[String]
    is_definite as Boolean
    convergence_status as String

Type called "SeriesExpansion":
    expression as String
    expansion_point as String
    expansion_variable as String
    series_type as String
    coefficients as Dictionary[String, String]
    radius_of_convergence as String
    truncation_order as Integer

Type called "LimitResult":
    expression as String
    limit_variable as String
    limit_point as String
    limit_value as String
    limit_type as String
    approach_direction as String
    indeterminate_form as String

Type called "VectorField":
    components as List[String]
    coordinate_system as String
    dimension as Integer
    divergence as String
    curl as List[String]
    gradient as List[String]

Note: =====================================================================
Note: CALCULUS HELPER FUNCTIONS
Note: =====================================================================

Process called "apply_chain_rule" that takes outer_expr as String, inner_expr as String, variable as String returns String:
    Note: Apply chain rule for composite function differentiation: d/dx[f(g(x))] is equal to f'(g(x)) multiplied by g'(x)
    Let outer_derivative be differentiate_basic_function(outer_expr, inner_expr)
    Let inner_derivative be differentiate_basic_function(inner_expr, variable)
    
    Note: Combine using multiplication
    If outer_derivative is equal to "0" or inner_derivative is equal to "0":
        Return "0"
    Otherwise if outer_derivative is equal to "1":
        Return inner_derivative
    Otherwise if inner_derivative is equal to "1":
        Return outer_derivative
    Otherwise:
        Return "(" plus outer_derivative plus ") multiplied by (" plus inner_derivative plus ")"

Process called "apply_product_rule" that takes left_expr as String, right_expr as String, variable as String returns String:
    Note: Apply product rule: d/dx[f(x)*g(x)] is equal to f'(x)*g(x) plus f(x)*g'(x)
    Let left_derivative be differentiate_basic_function(left_expr, variable)
    Let right_derivative be differentiate_basic_function(right_expr, variable)
    
    Note: f'(x)*g(x) plus f(x)*g'(x)
    Let term1 be "(" plus left_derivative plus ") multiplied by (" plus right_expr plus ")"
    Let term2 be "(" plus left_expr plus ") multiplied by (" plus right_derivative plus ")"
    
    Return term1 plus " plus " plus term2

Process called "apply_quotient_rule" that takes numerator as String, denominator as String, variable as String returns String:
    Note: Apply quotient rule: d/dx[f(x)/g(x)] is equal to [f'(x)*g(x) minus f(x)*g'(x)] / [g(x)]^2
    Let num_derivative be differentiate_basic_function(numerator, variable)
    Let den_derivative be differentiate_basic_function(denominator, variable)
    
    Let term1 be "(" plus num_derivative plus ") multiplied by (" plus denominator plus ")"
    Let term2 be "(" plus numerator plus ") multiplied by (" plus den_derivative plus ")"
    Let numerator_result be term1 plus " minus " plus term2
    Let denominator_result be "(" plus denominator plus ")^2"
    
    Return "(" plus numerator_result plus ") / (" plus denominator_result plus ")"

Process called "differentiate_basic_function" that takes expression as String, variable as String returns String:
    Note: Differentiate basic mathematical functions
    If expression is equal to variable:
        Return "1"
    
    Note: Check if expression is constant with respect to variable
    If not contains_variable(expression, variable):
        Return "0"
    
    Note: Handle basic functions
    If expression is equal to "sin(" plus variable plus ")":
        Return "cos(" plus variable plus ")"
    Otherwise if expression is equal to "cos(" plus variable plus ")":
        Return "-sin(" plus variable plus ")"
    Otherwise if expression is equal to "exp(" plus variable plus ")":
        Return "exp(" plus variable plus ")"
    Otherwise if expression is equal to "ln(" plus variable plus ")":
        Return "1/" plus variable
    Otherwise if starts_with_power(expression, variable):
        Return differentiate_power(expression, variable)
    Otherwise:
        Note: For complex expressions, return symbolic derivative
        Return "d/d" plus variable plus "[" plus expression plus "]"

Process called "contains_variable" that takes expression as String, variable as String returns Boolean:
    Note: Check if expression contains the given variable
    Return StringOps.replace_all_substrings(expression, variable, "VAR") does not equal expression

Process called "starts_with_power" that takes expression as String, variable as String returns Boolean:
    Note: Check if expression is a power of the variable like "x^2"
    Return StringCore.contains(expression, variable plus "^") or StringCore.contains(expression, "(" plus variable plus ")^")

Process called "differentiate_power" that takes power_expr as String, variable as String returns String:
    Note: Differentiate power expressions like x^n -> n*x^(n-1)
    Let caret_pos be StringCore.find(power_expr, "^")
    If caret_pos is equal to -1:
        Return "1"
    
    Let base_part be StringCore.substring(power_expr, 0, caret_pos)
    Let exp_part be StringCore.substring(power_expr, caret_pos plus 1, StringCore.length(power_expr))
    
    Note: Handle simple integer powers
    If exp_part is equal to "0":
        Return "0"
    Otherwise if exp_part is equal to "1":
        Return "1"
    Otherwise if exp_part is equal to "2":
        Return "2*" plus variable
    Otherwise if exp_part is equal to "3":
        Return "3*" plus variable plus "^2"
    Otherwise:
        Return exp_part plus "*" plus variable plus "^(" plus exp_part plus "-1)"

Process called "recognize_standard_integral" that takes expression as String, variable as String returns String:
    Note: Recognize and evaluate standard integral forms
    Note: Handle basic polynomial integrals
    If expression is equal to "1":
        Return variable
    Otherwise if expression is equal to variable:
        Return variable plus "^2/2"
    Otherwise if expression is equal to variable plus "^2":
        Return variable plus "^3/3"
    Otherwise if expression is equal to "1/" plus variable:
        Return "ln(abs(" plus variable plus "))"
    Otherwise if expression is equal to "sin(" plus variable plus ")":
        Return "-cos(" plus variable plus ")"
    Otherwise if expression is equal to "cos(" plus variable plus ")":
        Return "sin(" plus variable plus ")"
    Otherwise if expression is equal to "exp(" plus variable plus ")":
        Return "exp(" plus variable plus ")"
    Otherwise:
        Return "integral_not_recognized"

Process called "apply_integration_rules" that takes integrand as String, variable as String, method as String returns String:
    Note: Apply standard integration techniques
    If method is equal to "substitution":
        Return apply_substitution_method(integrand, variable)
    Otherwise if method is equal to "parts":
        Return apply_integration_by_parts(integrand, variable)
    Otherwise if method is equal to "partial_fractions":
        Return apply_partial_fractions(integrand, variable)
    Otherwise:
        Return recognize_standard_integral(integrand, variable)

Process called "apply_substitution_method" that takes integrand as String, variable as String returns String:
    Note: Apply u-substitution integration method
    Note: Look for composite functions and their derivatives
    
    If StringCore.contains(integrand, "sin(") and StringCore.contains(integrand, variable plus "^"):
        Note: Likely case: ∫ x sin(x²) dx, let u is equal to x², du is equal to 2x dx
        If StringCore.contains(integrand, variable plus " multiplied by sin(" plus variable plus "^2)"):
            Return "-(1/2) multiplied by cos(" plus variable plus "^2)"
        Otherwise if StringCore.contains(integrand, variable plus "^2 multiplied by sin(" plus variable plus "^3)"):
            Return "-(1/3) multiplied by cos(" plus variable plus "^3)"
        Otherwise:
            Note: General substitution case
            Return "∫ f(u) (du/" plus variable plus ") d" plus variable plus " where u is inner function"
    
    Otherwise if StringCore.contains(integrand, "cos(") and StringCore.contains(integrand, variable plus "^"):
        Note: Similar for cosine functions
        If StringCore.contains(integrand, variable plus " multiplied by cos(" plus variable plus "^2)"):
            Return "(1/2) multiplied by sin(" plus variable plus "^2)"
        Otherwise:
            Note: General substitution case
            Return "∫ f(u) (du/" plus variable plus ") d" plus variable plus " where u is inner function"
    
    Otherwise if StringCore.contains(integrand, "exp(") and StringCore.contains(integrand, variable):
        Note: Exponential substitution cases
        If StringCore.contains(integrand, variable plus " multiplied by exp(" plus variable plus "^2)"):
            Return "(1/2) multiplied by exp(" plus variable plus "^2)"
        Otherwise:
            Note: General exponential substitution case
            Return "∫ exp(u) (du/" plus variable plus ") d" plus variable plus " where u is exponent"
    
    Otherwise if StringCore.contains(integrand, "1/(" plus variable):
        Note: Logarithmic substitution
        Return "ln(abs(" plus variable plus ")) plus C"
    
    Otherwise:
        Return recognize_standard_integral(integrand, variable)

Process called "apply_integration_by_parts" that takes integrand as String, variable as String returns String:
    Note: Apply integration by parts: ∫u dv is equal to uv minus ∫v du
    Note: Complete integration by parts implementation
    If StringCore.contains(integrand, "*"):
        Let parts be StringCore.split(integrand, "*")
        If ListOps.length(parts) is equal to 2:
            Let u be ListOps.get(parts, 0)
            Let dv_expr be ListOps.get(parts, 1)
            
            Note: Integration by parts: ∫u dv is equal to uv minus ∫v du
            Let v be recognize_standard_integral(dv_expr, variable)
            Let du be differentiate_basic_function(u, variable)
            
            Note: Check if v is a recognized integral
            If v is equal to "integral_not_recognized":
                Note: If dv cannot be integrated, try swapping u and dv
                Let v_alt be recognize_standard_integral(u, variable)
                If v_alt does not equal "integral_not_recognized":
                    Let u_new be dv_expr
                    Let v_new be v_alt
                    Let du_new be differentiate_basic_function(u_new, variable)
                    Let remaining_integral be recognize_standard_integral(du_new, variable)
                    Return "(" plus u_new plus ") multiplied by (" plus v_new plus ") minus (" plus remaining_integral plus ")"
                Otherwise:
                    Return "∫(" plus integrand plus ")d" plus variable plus " requires advanced integration techniques"
            Otherwise:
                Note: Complete integration by parts formula
                Let remaining_integral be recognize_standard_integral(du plus " multiplied by " plus v, variable)
                If remaining_integral is equal to "integral_not_recognized":
                    Return "(" plus u plus ") multiplied by (" plus v plus ") minus ∫(" plus du plus " multiplied by " plus v plus ")d" plus variable
                Otherwise:
                    Return "(" plus u plus ") multiplied by (" plus v plus ") minus (" plus remaining_integral plus ")"
    
    Note: For non-product expressions, cannot apply integration by parts directly
    Return recognize_standard_integral(integrand, variable)

Process called "apply_partial_fractions" that takes rational_expr as String, variable as String returns String:
    Note: Apply partial fraction decomposition for rational functions
    If StringCore.contains(rational_expr, "/"):
        Return "partial_fractions(" plus rational_expr plus "," plus variable plus ")"
    Otherwise:
        Return recognize_standard_integral(rational_expr, variable)

Process called "compute_taylor_coefficients" that takes expression as String, variable as String, expansion_point as String, order as Integer returns Dictionary[String, String]:
    Note: Compute Taylor series coefficients using repeated differentiation
    Let coefficients be Map.empty()
    Let current_expr be expression
    Let factorial be 1
    
    Note: Compute coefficients up to specified order
    Let n be 0
    While n is less than or equal to order:
        Let coefficient_value be evaluate_at_point(current_expr, variable, expansion_point)
        Let coefficient be coefficient_value plus "/" plus Integer.to_string(factorial)
        Map.put(coefficients, Integer.to_string(n), coefficient)
        
        Note: Compute next derivative for next coefficient
        Let current_expr be differentiate_basic_function(current_expr, variable)
        Let factorial be factorial multiplied by (n plus 1)
        Let n be n plus 1
    
    Return coefficients

Process called "evaluate_at_point" that takes expression as String, variable as String, point as String returns String:
    Note: Evaluate expression at a specific point
    Return StringOps.replace_all_substrings(expression, variable, point)

Process called "apply_lhopital" that takes numerator as String, denominator as String, variable as String, limit_point as String returns String:
    Note: Apply L'Hôpital's rule for indeterminate forms
    Let num_at_point be evaluate_at_point(numerator, variable, limit_point)
    Let den_at_point be evaluate_at_point(denominator, variable, limit_point)
    
    Note: Check for 0/0 or ∞/∞ form
    If (num_at_point is equal to "0" and den_at_point is equal to "0") or (num_at_point is equal to "infinity" and den_at_point is equal to "infinity"):
        Let num_derivative be differentiate_basic_function(numerator, variable)
        Let den_derivative be differentiate_basic_function(denominator, variable)
        Return "lim[" plus variable plus "->" plus limit_point plus "] (" plus num_derivative plus ") / (" plus den_derivative plus ")"
    Otherwise:
        Return num_at_point plus "/" plus den_at_point

Process called "compute_partial_derivatives" that takes expression as String, variables as List[String], target_variable as String returns String:
    Note: Compute partial derivative treating other variables as constants
    If not ListOps.contains(variables, target_variable):
        Return "0"
    
    Note: For partial derivatives, treat other variables as constants
    Return differentiate_basic_function(expression, target_variable)

Process called "calculate_divergence" that takes vector_components as List[String], variables as List[String] returns String:
    Note: Calculate divergence: ∇·F is equal to ∂Fx/∂x plus ∂Fy/∂y plus ∂Fz/∂z
    Let divergence_terms be ListOps.empty()
    
    Let i be 0
    While i is less than ListOps.length(vector_components) and i is less than ListOps.length(variables):
        Let component be ListOps.get(vector_components, i)
        Let variable be ListOps.get(variables, i)
        Let partial_deriv be compute_partial_derivatives(component, variables, variable)
        ListOps.append(divergence_terms, partial_deriv)
        Let i be i plus 1
    
    Note: Sum all partial derivatives
    If ListOps.length(divergence_terms) is equal to 0:
        Return "0"
    
    Let result be ListOps.get(divergence_terms, 0)
    Let j be 1
    While j is less than ListOps.length(divergence_terms):
        Let result be result plus " plus " plus ListOps.get(divergence_terms, j)
        Let j be j plus 1
    
    Return result

Process called "calculate_curl" that takes vector_components as List[String], variables as List[String] returns List[String]:
    Note: Calculate curl in 3D: ∇×F is equal to (∂Fz/∂y minus ∂Fy/∂z, ∂Fx/∂z minus ∂Fz/∂x, ∂Fy/∂x minus ∂Fx/∂y)
    Let curl_components be ListOps.empty()
    
    If ListOps.length(vector_components) is greater than or equal to 3 and ListOps.length(variables) is greater than or equal to 3:
        Let Fx be ListOps.get(vector_components, 0)
        Let Fy be ListOps.get(vector_components, 1) 
        Let Fz be ListOps.get(vector_components, 2)
        Let x be ListOps.get(variables, 0)
        Let y be ListOps.get(variables, 1)
        Let z be ListOps.get(variables, 2)
        
        Note: Curl x-component: ∂Fz/∂y minus ∂Fy/∂z
        Let curl_x be compute_partial_derivatives(Fz, variables, y) plus " minus " plus compute_partial_derivatives(Fy, variables, z)
        ListOps.append(curl_components, curl_x)
        
        Note: Curl y-component: ∂Fx/∂z minus ∂Fz/∂x
        Let curl_y be compute_partial_derivatives(Fx, variables, z) plus " minus " plus compute_partial_derivatives(Fz, variables, x)
        ListOps.append(curl_components, curl_y)
        
        Note: Curl z-component: ∂Fy/∂x minus ∂Fx/∂y
        Let curl_z be compute_partial_derivatives(Fy, variables, x) plus " minus " plus compute_partial_derivatives(Fx, variables, y)
        ListOps.append(curl_components, curl_z)
    
    Return curl_components

Note: =====================================================================
Note: DIFFERENTIATION OPERATIONS
Note: =====================================================================

Process called "differentiate" that takes expression as String, variable as String returns Derivative:
    Note: Compute symbolic derivative with respect to variable
    Let derivative_expression be differentiate_basic_function(expression, variable)
    
    Return Derivative with:
        expression is equal to expression
        variable is equal to variable
        order is equal to 1
        partial_variables is equal to ListOps.empty()
        derivative_rule is equal to "basic_differentiation"
        chain_rule_applications is equal to ListOps.empty()

Process called "partial_differentiate" that takes expression as String, variable as String, other_variables as List[String] returns Derivative:
    Note: Compute partial derivative treating other variables as constants
    Let all_variables be ListOps.copy(other_variables)
    ListOps.append(all_variables, variable)
    
    Let partial_derivative be compute_partial_derivatives(expression, all_variables, variable)
    
    Return Derivative with:
        expression is equal to partial_derivative
        variable is equal to variable
        order is equal to 1
        partial_variables is equal to other_variables
        derivative_rule is equal to "partial_differentiation"
        chain_rule_applications is equal to ListOps.empty()

Process called "higher_order_derivative" that takes expression as String, variable as String, order as Integer returns Derivative:
    Note: Compute higher-order derivative using chain rule repeatedly
    Let current_expression be expression
    Let derivatives_applied be ListOps.empty()
    
    Let n be 0
    While n is less than order:
        Let current_expression be differentiate_basic_function(current_expression, variable)
        ListOps.append(derivatives_applied, "order_" plus Integer.to_string(n plus 1))
        Let n be n plus 1
    
    Return Derivative with:
        expression is equal to current_expression
        variable is equal to variable
        order is equal to order
        partial_variables is equal to ListOps.empty()
        derivative_rule is equal to "higher_order_differentiation"
        chain_rule_applications is equal to derivatives_applied

Process called "mixed_partial_derivative" that takes expression as String, variables as List[String], orders as List[Integer] returns Derivative:
    Note: Compute mixed partial derivatives with respect to multiple variables
    Let current_expression be expression
    Let applied_operations be ListOps.empty()
    
    Note: Apply partial derivatives in sequence
    Let i be 0
    While i is less than ListOps.length(variables):
        Let variable be ListOps.get(variables, i)
        Let order be ListOps.get(orders, i)
        
        Let j be 0
        While j is less than order:
            Let current_expression be compute_partial_derivatives(current_expression, variables, variable)
            ListOps.append(applied_operations, "∂/∂" plus variable)
            Let j be j plus 1
        
        Let i be i plus 1
    
    Return Derivative with:
        expression is equal to current_expression
        variable is equal to StringCore.join(variables, ",")
        order is equal to ListOps.sum(orders)
        partial_variables is equal to variables
        derivative_rule is equal to "mixed_partial_differentiation"
        chain_rule_applications is equal to applied_operations

Process called "implicit_differentiation" that takes equation as String, dependent_variable as String, independent_variable as String returns String:
    Note: Perform implicit differentiation on equation
    Note: Split equation at is equal to sign
    If StringCore.contains(equation, "="):
        Let parts be StringCore.split(equation, "=")
        If ListOps.length(parts) is equal to 2:
            Let left_side be ListOps.get(parts, 0)
            Let right_side be ListOps.get(parts, 1)
            
            Note: Differentiate both sides with respect to independent variable
            Let left_diff be differentiate_basic_function(left_side, independent_variable)
            Let right_diff be differentiate_basic_function(right_side, independent_variable)
            
            Note: Apply chain rule for dependent variable terms
            If contains_variable(left_diff, dependent_variable):
                Let left_diff be left_diff plus " multiplied by d" plus dependent_variable plus "/d" plus independent_variable
            
            If contains_variable(right_diff, dependent_variable):
                Let right_diff be right_diff plus " multiplied by d" plus dependent_variable plus "/d" plus independent_variable
            
            Return left_diff plus " is equal to " plus right_diff
    
    Return "Invalid equation format"

Process called "logarithmic_differentiation" that takes expression as String, variable as String returns Derivative:
    Note: Use logarithmic differentiation for complex expressions
    Note: Take natural log of expression and differentiate
    Let log_expression be "ln(" plus expression plus ")"
    Let log_derivative be differentiate_basic_function(log_expression, variable)
    
    Note: Apply chain rule: d/dx[ln(f(x))] is equal to f'(x)/f(x)
    Let result_expression be "(" plus log_derivative plus ") multiplied by (" plus expression plus ")"
    
    Return Derivative with:
        expression is equal to result_expression
        variable is equal to variable
        order is equal to 1
        partial_variables is equal to ListOps.empty()
        derivative_rule is equal to "logarithmic_differentiation"
        chain_rule_applications is equal to ListOps.create_with("ln_chain_rule")

Process called "parametric_differentiation" that takes x_expression as String, y_expression as String, parameter as String returns String:
    Note: Compute dy/dx for parametric equations
    Note: dy/dx is equal to (dy/dt) / (dx/dt)
    Let dy_dt be differentiate_basic_function(y_expression, parameter)
    Let dx_dt be differentiate_basic_function(x_expression, parameter)
    
    Return "(" plus dy_dt plus ") / (" plus dx_dt plus ")"

Note: =====================================================================
Note: INTEGRATION OPERATIONS
Note: =====================================================================

Process called "integrate" that takes expression as String, variable as String returns Integral:
    Note: Compute symbolic indefinite integral
    Let integral_result be recognize_standard_integral(expression, variable)
    
    Let integration_method be "standard_forms"
    If integral_result is equal to "integral_not_recognized":
        Let integral_result be apply_integration_rules(expression, variable, "substitution")
        Let integration_method be "substitution_attempted"
    
    Return Integral with:
        integrand is equal to expression
        variable is equal to variable
        integration_bounds is equal to Map.empty()
        integration_method is equal to integration_method
        substitutions_used is equal to ListOps.empty()
        is_definite is equal to false
        convergence_status is equal to "unknown"

Process called "definite_integrate" that takes expression as String, variable as String, lower_bound as String, upper_bound as String returns Integral:
    Note: Compute definite integral with specified bounds
    Let bounds be Map.empty()
    Map.put(bounds, "lower", lower_bound)
    Map.put(bounds, "upper", upper_bound)
    
    Let integral_result be recognize_standard_integral(expression, variable)
    Let integration_method be "standard_forms"
    
    If integral_result is equal to "integral_not_recognized":
        Let integral_result be apply_integration_rules(expression, variable, "substitution")
        Let integration_method be "substitution_attempted"
    
    Return Integral with:
        integrand is equal to expression
        variable is equal to variable
        integration_bounds is equal to bounds
        integration_method is equal to integration_method
        substitutions_used is equal to ListOps.empty()
        is_definite is equal to true
        convergence_status is equal to "convergent"

Process called "integrate_by_parts" that takes expression as String, variable as String, u_function as String returns Integral:
    Note: Apply integration by parts with specified u function
    Note: ∫u dv is equal to uv minus ∫v du
    Let result be apply_integration_by_parts(expression, variable)
    
    Return Integral with:
        integrand is equal to expression
        variable is equal to variable
        integration_bounds is equal to Map.empty()
        integration_method is equal to "integration_by_parts"
        substitutions_used is equal to ListOps.create_with("u=" plus u_function)
        is_definite is equal to false
        convergence_status is equal to "unknown"

Process called "integrate_by_substitution" that takes expression as String, variable as String, substitution as String returns Integral:
    Note: Apply u-substitution to integral
    Let result be apply_substitution_method(expression, variable)
    
    Return Integral with:
        integrand is equal to expression
        variable is equal to variable
        integration_bounds is equal to Map.empty()
        integration_method is equal to "u_substitution"
        substitutions_used is equal to ListOps.create_with(substitution)
        is_definite is equal to false
        convergence_status is equal to "unknown"

Process called "partial_fractions_integration" that takes rational_expression as String, variable as String returns Integral:
    Note: Integrate rational function using partial fractions
    Let result be apply_partial_fractions(rational_expression, variable)
    
    Return Integral with:
        integrand is equal to rational_expression
        variable is equal to variable
        integration_bounds is equal to Map.empty()
        integration_method is equal to "partial_fractions"
        substitutions_used is equal to ListOps.create_with("partial_fraction_decomposition")
        is_definite is equal to false
        convergence_status is equal to "unknown"

Process called "trigonometric_substitution" that takes expression as String, variable as String, substitution_type as String returns Integral:
    Note: Apply trigonometric substitution to integral
    Let substitution_used be ""
    
    If substitution_type is equal to "sin":
        Let substitution_used be variable plus " is equal to sin(θ)"
    Otherwise if substitution_type is equal to "tan":
        Let substitution_used be variable plus " is equal to tan(θ)"
    Otherwise if substitution_type is equal to "sec":
        Let substitution_used be variable plus " is equal to sec(θ)"
    Otherwise:
        Let substitution_used be "trigonometric_substitution"
    
    Let result be apply_substitution_method(expression, variable)
    
    Return Integral with:
        integrand is equal to expression
        variable is equal to variable
        integration_bounds is equal to Map.empty()
        integration_method is equal to "trigonometric_substitution"
        substitutions_used is equal to ListOps.create_with(substitution_used)
        is_definite is equal to false
        convergence_status is equal to "unknown"

Process called "improper_integral" that takes expression as String, variable as String, integration_bounds as Dictionary[String, String] returns Integral:
    Note: Evaluate improper integral with infinite or discontinuous bounds
    Let convergence be "unknown"
    
    Note: Check for infinite bounds
    Let lower_bound be Map.get(integration_bounds, "lower", "0")
    Let upper_bound be Map.get(integration_bounds, "upper", "1")
    
    If lower_bound is equal to "-∞" or upper_bound is equal to "∞":
        Let convergence be "convergent_if_conditions_met"
    
    Let result be recognize_standard_integral(expression, variable)
    
    Return Integral with:
        integrand is equal to expression
        variable is equal to variable
        integration_bounds is equal to integration_bounds
        integration_method is equal to "improper_integration"
        substitutions_used is equal to ListOps.empty()
        is_definite is equal to true
        convergence_status is equal to convergence

Note: =====================================================================
Note: MULTIVARIABLE CALCULUS OPERATIONS
Note: =====================================================================

Process called "compute_gradient" that takes scalar_field as String, variables as List[String] returns List[String]:
    Note: Compute gradient vector of scalar field
    Let gradient_components be ListOps.empty()
    
    For each var in variables:
        Let partial_deriv be compute_partial_derivatives(scalar_field, variables, var)
        ListOps.append(gradient_components, partial_deriv)
    
    Return gradient_components

Process called "compute_divergence" that takes vector_field as VectorField returns String:
    Note: Compute divergence of vector field
    Let variables be ListOps.create_with("x", "y", "z")
    Return calculate_divergence(vector_field.components, variables)

Process called "compute_curl" that takes vector_field as VectorField returns List[String]:
    Note: Compute curl of vector field
    Let variables be ListOps.create_with("x", "y", "z")
    Return calculate_curl(vector_field.components, variables)

Process called "compute_laplacian" that takes scalar_field as String, variables as List[String] returns String:
    Note: Compute Laplacian (divergence of gradient)
    Let gradient_components be compute_gradient(scalar_field, variables)
    Return calculate_divergence(gradient_components, variables)

Process called "directional_derivative" that takes scalar_field as String, direction_vector as List[String], point as Dictionary[String, String] returns String:
    Note: Compute directional derivative at specified point
    Note: Directional derivative is equal to ∇f · û where û is unit direction vector
    Let variables be Map.get_keys(point)
    Let gradient_components be compute_gradient(scalar_field, variables)
    
    Note: Compute dot product of gradient and direction vector
    Let dot_product_terms be ListOps.empty()
    Let i be 0
    While i is less than ListOps.length(gradient_components) and i is less than ListOps.length(direction_vector):
        Let grad_component be ListOps.get(gradient_components, i)
        Let dir_component be ListOps.get(direction_vector, i)
        Let term be "(" plus grad_component plus ") multiplied by (" plus dir_component plus ")"
        ListOps.append(dot_product_terms, term)
        Let i be i plus 1
    
    Note: Join terms with addition
    If ListOps.length(dot_product_terms) is equal to 0:
        Return "0"
    
    Let result be ListOps.get(dot_product_terms, 0)
    Let j be 1
    While j is less than ListOps.length(dot_product_terms):
        Let result be result plus " plus " plus ListOps.get(dot_product_terms, j)
        Let j be j plus 1
    
    Return result

Process called "compute_jacobian" that takes vector_function as List[String], variables as List[String] returns List[List[String]]:
    Note: Compute Jacobian matrix of vector function
    Let jacobian_matrix be ListOps.empty()
    
    Note: For each function component
    For each function_component in vector_function:
        Let jacobian_row be ListOps.empty()
        
        Note: Compute partial derivative with respect to each variable
        For each variable in variables:
            Let partial_deriv be compute_partial_derivatives(function_component, variables, variable)
            ListOps.append(jacobian_row, partial_deriv)
        
        ListOps.append(jacobian_matrix, jacobian_row)
    
    Return jacobian_matrix

Process called "compute_hessian" that takes scalar_field as String, variables as List[String] returns List[List[String]]:
    Note: Compute Hessian matrix of second partial derivatives
    Let hessian_matrix be ListOps.empty()
    
    Note: For each variable (row)
    For each var_i in variables:
        Let hessian_row be ListOps.empty()
        
        Note: For each variable (column)
        For each var_j in variables:
            Note: Compute mixed second partial derivative
            Let first_partial be compute_partial_derivatives(scalar_field, variables, var_i)
            Let second_partial be compute_partial_derivatives(first_partial, variables, var_j)
            ListOps.append(hessian_row, second_partial)
        
        ListOps.append(hessian_matrix, hessian_row)
    
    Return hessian_matrix

Note: =====================================================================
Note: SERIES EXPANSION OPERATIONS
Note: =====================================================================

Process called "taylor_series" that takes expression as String, variable as String, expansion_point as String, order as Integer returns SeriesExpansion:
    Note: Compute Taylor series expansion around specified point
    Let coefficients be compute_taylor_coefficients(expression, variable, expansion_point, order)
    
    Return SeriesExpansion with:
        expression is equal to expression
        expansion_point is equal to expansion_point
        expansion_variable is equal to variable
        series_type is equal to "taylor"
        coefficients is equal to coefficients
        radius_of_convergence is equal to "unknown"
        truncation_order is equal to order

Process called "maclaurin_series" that takes expression as String, variable as String, order as Integer returns SeriesExpansion:
    Note: Compute Maclaurin series (Taylor series at origin)
    Return taylor_series(expression, variable, "0", order)

Process called "laurent_series" that takes expression as String, variable as String, expansion_point as String, positive_order as Integer, negative_order as Integer returns SeriesExpansion:
    Note: Compute Laurent series expansion including negative powers
    Note: Laurent series allows negative powers for singularities
    Let coefficients be Map.empty()
    
    Note: Compute negative power coefficients
    Let n be -negative_order
    While n is less than or equal to positive_order:
        If n is less than 0:
            Note: For negative powers, compute residue-like coefficients
            Let power_expr be "(" plus variable plus " minus " plus expansion_point plus ")^" plus Integer.to_string(n)
            Let coefficient_expr be expression plus " multiplied by " plus power_expr
            Let coefficient_value be evaluate_at_point(coefficient_expr, variable, expansion_point)
            Map.put(coefficients, Integer.to_string(n), coefficient_value)
        Otherwise:
            Note: For non-negative powers, use regular Taylor expansion
            Let current_expr be expression
            Let factorial be 1
            Let k be 0
            While k is less than n:
                Let current_expr be differentiate_basic_function(current_expr, variable)
                Let factorial be factorial multiplied by (k plus 1)
                Let k be k plus 1
            Let coefficient_value be evaluate_at_point(current_expr, variable, expansion_point)
            Let coefficient be coefficient_value plus "/" plus Integer.to_string(factorial)
            Map.put(coefficients, Integer.to_string(n), coefficient)
        
        Let n be n plus 1
    
    Return SeriesExpansion with:
        expression is equal to expression
        expansion_point is equal to expansion_point
        expansion_variable is equal to variable
        series_type is equal to "laurent"
        coefficients is equal to coefficients
        radius_of_convergence is equal to "unknown"
        truncation_order is equal to positive_order

Process called "fourier_series" that takes expression as String, variable as String, period as String, harmonics as Integer returns SeriesExpansion:
    Note: Compute Fourier series expansion of periodic function
    Note: f(x) is equal to a0/2 plus Σ[an*cos(nπx/L) plus bn*sin(nπx/L)]
    Let coefficients be Map.empty()
    
    Note: Compute a0 coefficient (average value)
    Let a0_integrand be "2 multiplied by " plus expression plus " / " plus period
    Let a0_coefficient be definite_integrate(a0_integrand, variable, "0", period)
    Map.put(coefficients, "a0", a0_coefficient.integrand)
    
    Note: Compute an and bn coefficients for each harmonic
    Let n be 1
    While n is less than or equal to harmonics:
        Note: an coefficient: (2/L) multiplied by ∫f(x)*cos(nπx/L)dx
        Let cos_term be "cos(" plus Integer.to_string(n) plus "*π*" plus variable plus "/" plus period plus ")"
        Let an_integrand be "2 multiplied by " plus expression plus " multiplied by " plus cos_term plus " / " plus period
        Let an_coefficient be definite_integrate(an_integrand, variable, "0", period)
        Map.put(coefficients, "a" plus Integer.to_string(n), an_coefficient.integrand)
        
        Note: bn coefficient: (2/L) multiplied by ∫f(x)*sin(nπx/L)dx
        Let sin_term be "sin(" plus Integer.to_string(n) plus "*π*" plus variable plus "/" plus period plus ")"
        Let bn_integrand be "2 multiplied by " plus expression plus " multiplied by " plus sin_term plus " / " plus period
        Let bn_coefficient be definite_integrate(bn_integrand, variable, "0", period)
        Map.put(coefficients, "b" plus Integer.to_string(n), bn_coefficient.integrand)
        
        Let n be n plus 1
    
    Return SeriesExpansion with:
        expression is equal to expression
        expansion_point is equal to "0"
        expansion_variable is equal to variable
        series_type is equal to "fourier"
        coefficients is equal to coefficients
        radius_of_convergence is equal to "infinite_if_periodic"
        truncation_order is equal to harmonics

Process called "asymptotic_expansion" that takes expression as String, variable as String, limit_point as String, order as Integer returns SeriesExpansion:
    Note: Compute asymptotic expansion for large or small values
    Note: Asymptotic expansion f(x) ~ Σ an/x^n as x → ∞, or similar forms
    Let coefficients be Map.empty()
    
    If limit_point is equal to "infinity" or limit_point is equal to "∞":
        Note: Large x asymptotic expansion: substitute y is equal to 1/x and expand around y is equal to 0
        Let substituted_expr be StringOps.replace_all_substrings(expression, variable, "1/y_asymptotic")
        Let n be 0
        While n is less than or equal to order:
            Note: Extract coefficient of y^n term
            Let coefficient_expr be "coefficient_of_y_power_" plus Integer.to_string(n) plus "(" plus substituted_expr plus ")"
            Map.put(coefficients, Integer.to_string(n), coefficient_expr)
            Let n be n plus 1
    Otherwise if limit_point is equal to "0":
        Note: Small x asymptotic expansion: regular Taylor-like expansion
        Let current_expr be expression
        Let n be 0
        While n is less than or equal to order:
            If n is equal to 0:
                Let coefficient_value be evaluate_at_point(current_expr, variable, limit_point)
            Otherwise:
                Let factorial be 1
                Let k be 0
                While k is less than n:
                    Let current_expr be differentiate_basic_function(current_expr, variable)
                    Let factorial be factorial multiplied by (k plus 1)
                    Let k be k plus 1
                Let coefficient_value be evaluate_at_point(current_expr, variable, limit_point)
                Let coefficient_value be coefficient_value plus "/" plus Integer.to_string(factorial)
            
            Map.put(coefficients, Integer.to_string(n), coefficient_value)
            Let n be n plus 1
    Otherwise:
        Note: General asymptotic expansion around arbitrary point
        Let shifted_expr be StringOps.replace_all_substrings(expression, variable, "(" plus variable plus " minus " plus limit_point plus ")")
        Let n be 0
        While n is less than or equal to order:
            Let coefficient_expr be "asymptotic_coefficient_" plus Integer.to_string(n) plus "(" plus shifted_expr plus ")"
            Map.put(coefficients, Integer.to_string(n), coefficient_expr)
            Let n be n plus 1
    
    Return SeriesExpansion with:
        expression is equal to expression
        expansion_point is equal to limit_point
        expansion_variable is equal to variable
        series_type is equal to "asymptotic"
        coefficients is equal to coefficients
        radius_of_convergence is equal to "asymptotic_only"
        truncation_order is equal to order

Process called "series_convergence_test" that takes series as SeriesExpansion, convergence_tests as List[String] returns Dictionary[String, String]:
    Note: Test convergence of infinite series using various tests
    Let test_results be Map.empty()
    
    For each test_name in convergence_tests:
        If test_name is equal to "ratio_test":
            Note: Ratio test: lim |a_{n+1}/a_n| is equal to L
            Let ratio_result be "ratio_test_requires_coefficient_analysis"
            If series.series_type is equal to "taylor" or series.series_type is equal to "laurent":
                Let ratio_result be "convergent_if_ratio_less_than_1"
            Map.put(test_results, "ratio_test", ratio_result)
            
        Otherwise if test_name is equal to "root_test":
            Note: Root test: lim |a_n|^(1/n) is equal to L
            Let root_result be "root_test_requires_coefficient_analysis"
            If series.series_type is equal to "taylor":
                Let root_result be "convergent_if_root_less_than_1"
            Map.put(test_results, "root_test", root_result)
            
        Otherwise if test_name is equal to "integral_test":
            Note: Integral test for positive term series
            Let integral_result be "convergent_if_improper_integral_converges"
            If series.series_type is equal to "fourier":
                Let integral_result be "fourier_series_converges_if_piecewise_continuous"
            Map.put(test_results, "integral_test", integral_result)
            
        Otherwise if test_name is equal to "comparison_test":
            Note: Direct comparison with known convergent/divergent series
            Let comparison_result be "requires_comparison_series"
            Map.put(test_results, "comparison_test", comparison_result)
            
        Otherwise if test_name is equal to "alternating_series_test":
            Note: Leibniz test for alternating series
            Let alternating_result be "convergent_if_terms_decrease_to_zero"
            Map.put(test_results, "alternating_series_test", alternating_result)
            
        Otherwise if test_name is equal to "absolute_convergence":
            Note: Test absolute convergence
            Let absolute_result be "absolutely_convergent_if_series_of_absolute_values_converges"
            Map.put(test_results, "absolute_convergence", absolute_result)
            
        Otherwise:
            Map.put(test_results, test_name, "unknown_convergence_test")
    
    Note: Overall convergence assessment
    If series.series_type is equal to "taylor":
        Map.put(test_results, "overall_assessment", "converges_within_radius_of_convergence")
    Otherwise if series.series_type is equal to "fourier":
        Map.put(test_results, "overall_assessment", "converges_if_function_satisfies_dirichlet_conditions")
    Otherwise if series.series_type is equal to "laurent":
        Map.put(test_results, "overall_assessment", "converges_in_annular_region")
    Otherwise:
        Map.put(test_results, "overall_assessment", "convergence_analysis_required")
    
    Return test_results

Note: =====================================================================
Note: LIMIT OPERATIONS
Note: =====================================================================

Process called "compute_limit" that takes expression as String, variable as String, limit_point as String returns LimitResult:
    Note: Compute limit of expression as variable approaches point
    Let limit_value be evaluate_at_point(expression, variable, limit_point)
    
    Note: Check for indeterminate forms and apply L'Hôpital's rule if needed
    Let approach_type be "two_sided"
    Let indeterminate_check be "none"
    
    If limit_value is equal to "0/0" or limit_value is equal to "∞/∞":
        Let indeterminate_check be "indeterminate_form"
        If StringCore.contains(expression, "/"):
            Let parts be StringCore.split(expression, "/")
            If ListOps.length(parts) is equal to 2:
                Let numerator be ListOps.get(parts, 0)
                Let denominator be ListOps.get(parts, 1)
                Let limit_value be apply_lhopital(numerator, denominator, variable, limit_point)
    
    Return LimitResult with:
        expression is equal to expression
        limit_variable is equal to variable
        limit_point is equal to limit_point
        limit_value is equal to limit_value
        limit_type is equal to "finite"
        approach_direction is equal to approach_type
        indeterminate_form is equal to indeterminate_check

Process called "one_sided_limit" that takes expression as String, variable as String, limit_point as String, direction as String returns LimitResult:
    Note: Compute one-sided limit (left or right)
    Let approach_direction be direction
    Let limit_value be evaluate_at_point(expression, variable, limit_point)
    
    Note: For one-sided limits, we approximate by evaluating slightly off the point
    If direction is equal to "left":
        Let test_point be limit_point plus " minus 0.001"
        Let limit_value be evaluate_at_point(expression, variable, test_point)
        Let approach_direction be "left_sided"
    Otherwise if direction is equal to "right":
        Let test_point be limit_point plus " plus 0.001"
        Let limit_value be evaluate_at_point(expression, variable, test_point)
        Let approach_direction be "right_sided"
    
    Return LimitResult with:
        expression is equal to expression
        limit_variable is equal to variable
        limit_point is equal to limit_point
        limit_value is equal to limit_value
        limit_type is equal to "one_sided"
        approach_direction is equal to approach_direction
        indeterminate_form is equal to "none"

Process called "limit_at_infinity" that takes expression as String, variable as String, infinity_type as String returns LimitResult:
    Note: Compute limit as variable approaches positive or negative infinity
    Let limit_point be "∞"
    Let limit_value be "0"
    
    If infinity_type is equal to "positive":
        Let limit_point be "+∞"
        Note: For rational functions, check degree of numerator vs denominator
        If StringCore.contains(expression, "/"):
            Let limit_value be "analyze_rational_limit_at_infinity"
        Otherwise:
            Let limit_value be "∞"
    Otherwise if infinity_type is equal to "negative":
        Let limit_point be "-∞"
        Let limit_value be "analyze_limit_behavior"
    
    Return LimitResult with:
        expression is equal to expression
        limit_variable is equal to variable
        limit_point is equal to limit_point
        limit_value is equal to limit_value
        limit_type is equal to "infinite"
        approach_direction is equal to infinity_type
        indeterminate_form is equal to "none"

Process called "lhopitals_rule" that takes expression as String, variable as String, limit_point as String returns LimitResult:
    Note: Apply L'Hôpital's rule for indeterminate forms
    Let limit_value be "undefined"
    
    If StringCore.contains(expression, "/"):
        Let parts be StringCore.split(expression, "/")
        If ListOps.length(parts) is equal to 2:
            Let numerator be ListOps.get(parts, 0)
            Let denominator be ListOps.get(parts, 1)
            Let limit_value be apply_lhopital(numerator, denominator, variable, limit_point)
    
    Return LimitResult with:
        expression is equal to expression
        limit_variable is equal to variable
        limit_point is equal to limit_point
        limit_value is equal to limit_value
        limit_type is equal to "lhopital_application"
        approach_direction is equal to "two_sided"
        indeterminate_form is equal to "resolved"

Process called "squeeze_theorem" that takes expression as String, lower_bound as String, upper_bound as String, variable as String, limit_point as String returns LimitResult:
    Note: Apply squeeze theorem with bounding functions
    Note: If lower_bound ≤ expression ≤ upper_bound and lim lower_bound is equal to lim upper_bound is equal to L, then lim expression is equal to L
    Let lower_limit be evaluate_at_point(lower_bound, variable, limit_point)
    Let upper_limit be evaluate_at_point(upper_bound, variable, limit_point)
    
    Let limit_value be "undefined"
    If lower_limit is equal to upper_limit:
        Let limit_value be lower_limit
    Otherwise:
        Let limit_value be "squeeze_theorem_inconclusive"
    
    Return LimitResult with:
        expression is equal to expression
        limit_variable is equal to variable
        limit_point is equal to limit_point
        limit_value is equal to limit_value
        limit_type is equal to "squeeze_theorem"
        approach_direction is equal to "two_sided"
        indeterminate_form is equal to "resolved_by_squeeze"

Note: =====================================================================
Note: DIFFERENTIAL EQUATION OPERATIONS
Note: =====================================================================

Process called "solve_first_order_ode" that takes equation as String, dependent_variable as String, independent_variable as String returns String:
    Note: Solve first-order ordinary differential equation
    Note: Check for separable form: dy/dx is equal to f(x)g(y)
    If StringCore.contains(equation, "d" plus dependent_variable plus "/d" plus independent_variable):
        Note: Try separation of variables
        Note: Separable ODE solution method
        Return "Solution by separation: Rewrite as g(y)dy is equal to f(x)dx, then integrate: ∫g(y)dy is equal to ∫f(x)dx plus C"
    
    Note: Check for linear form: dy/dx plus P(x)y is equal to Q(x)
    If StringCore.contains(equation, dependent_variable) and StringCore.contains(equation, independent_variable):
        Note: Linear first-order ODE with integrating factor
        Return "Solution: y is equal to (1/μ(x))[∫μ(x)Q(x)dx plus C] where μ(x) is equal to exp(∫P(x)dx)"
    
    Note: General solution for linear first-order ODEs
    Return "C multiplied by exp(∫P(" plus independent_variable plus ")d" plus independent_variable plus ")"

Process called "solve_linear_ode" that takes equation as String, dependent_variable as String, independent_variable as String, order as Integer returns String:
    Note: Solve linear ordinary differential equation of specified order
    If order is equal to 1:
        Return solve_first_order_ode(equation, dependent_variable, independent_variable)
    
    If order is equal to 2:
        Note: Second-order linear ODE: ay'' plus by' plus cy is equal to 0
        Note: Solve characteristic equation: ar² plus br plus c is equal to 0
        Note: Second-order linear ODE via characteristic equation
        Return "Solution: Solve ar² plus br plus c is equal to 0 for characteristic roots, then y is equal to c₁e^(r₁x) plus c₂e^(r₂x)"
    
    Note: Higher-order case
    Return "higher_order_linear_solution(" plus equation plus ", order=" plus Integer.to_string(order) plus ")"

Process called "solve_separable_ode" that takes equation as String, dependent_variable as String, independent_variable as String returns String:
    Note: Solve separable differential equation
    Note: Separable form: dy/dx is equal to f(x)g(y) → ∫(1/g(y))dy is equal to ∫f(x)dx
    
    If StringCore.contains(equation, "="):
        Let parts be StringCore.split(equation, "=")
        If ListOps.length(parts) is equal to 2:
            Let left_side be ListOps.get(parts, 0)
            Let right_side be ListOps.get(parts, 1)
            
            Note: Check if it's already in separated form
            If StringCore.contains(left_side, "d" plus dependent_variable plus "/d" plus independent_variable):
                Note: Standard form dy/dx is equal to f(x,y), need to separate variables
                If StringCore.contains(right_side, "*"):
                    Note: Try to factor as f(x) multiplied by g(y)
                    Return "Separate variables: (1/g(" plus dependent_variable plus ")) d" plus dependent_variable plus " is equal to f(" plus independent_variable plus ") d" plus independent_variable plus ", then integrate both sides"
                Otherwise:
                    Note: Simple case where right side might be just f(x)
                    Let integrated_right be recognize_standard_integral(right_side, independent_variable)
                    Return dependent_variable plus " is equal to " plus integrated_right plus " plus C"
            Otherwise:
                Note: Already separated form minus integrate both sides
                Let left_integral be recognize_standard_integral(left_side, dependent_variable)
                Let right_integral be recognize_standard_integral(right_side, independent_variable)
                
                Return left_integral plus " is equal to " plus right_integral plus " plus C"
    
    Note: Handle common separable patterns
    If StringCore.contains(equation, "d" plus dependent_variable plus "/d" plus independent_variable plus " is equal to "):
        Note: Extract right-hand side after is equal to sign
        Let eq_parts be StringCore.split(equation, " is equal to ")
        If ListOps.length(eq_parts) is equal to 2:
            Let rhs be ListOps.get(eq_parts, 1)
            
            Note: Simple separable cases
            If rhs is equal to independent_variable:
                Return dependent_variable plus " is equal to " plus independent_variable plus "^2/2 plus C"
            Otherwise if rhs is equal to "1":
                Return dependent_variable plus " is equal to " plus independent_variable plus " plus C"
            Otherwise if rhs is equal to dependent_variable:
                Return "ln(|" plus dependent_variable plus "|) is equal to " plus independent_variable plus " plus C, so " plus dependent_variable plus " is equal to C*exp(" plus independent_variable plus ")"
            Otherwise if rhs is equal to independent_variable plus "*" plus dependent_variable:
                Return "ln(|" plus dependent_variable plus "|) is equal to " plus independent_variable plus "^2/2 plus C, so " plus dependent_variable plus " is equal to C*exp(" plus independent_variable plus "^2/2)"
    
    Note: Handle general separable forms by attempting standard patterns
    If StringCore.contains(equation, "y") and StringCore.contains(equation, "x"):
        Note: General separable ODE minus attempt standard solution forms
        If StringCore.contains(equation, "y^2"):
            Return "Solution involves integrating 1/y^2 terms: -1/y is equal to ∫f(x)dx plus C"
        Otherwise if StringCore.contains(equation, "sin(y)") or StringCore.contains(equation, "cos(y)"):
            Return "Trigonometric separable form: integrate ∫(1/trig(y))dy is equal to ∫f(x)dx"
        Otherwise:
            Note: Provide general separation guidance with specific equation
            Return "For equation " plus equation plus ", separate as g(y)dy is equal to f(x)dx, then integrate both sides"
    Otherwise:
        Return "Unable to determine separable form for: " plus equation

Process called "solve_exact_ode" that takes equation as String, dependent_variable as String, independent_variable as String returns String:
    Note: Solve exact differential equation
    Note: Exact form: M(x,y)dx plus N(x,y)dy is equal to 0 where ∂M/∂y is equal to ∂N/∂x
    
    Note: Parse equation to extract M and N coefficients
    If StringCore.contains(equation, "dx") and StringCore.contains(equation, "dy"):
        Note: Extract M(x,y) and N(x,y) from M(x,y)dx plus N(x,y)dy is equal to 0 form
        If StringCore.contains(equation, "+"):
            Let equation_parts be StringCore.split(equation, "+")
            If ListOps.length(equation_parts) is greater than or equal to 2:
                Let m_term be ListOps.get(equation_parts, 0)
                Let n_term be ListOps.get(equation_parts, 1)
                
                Note: Remove dx and dy to get M and N
                Let M_expr be StringOps.replace_all_substrings(m_term, "dx", "")
                Let N_expr be StringOps.replace_all_substrings(n_term, "dy", "")
                Let N_expr be StringOps.replace_all_substrings(N_expr, " ", "")
                
                Note: Check exactness condition: ∂M/∂y is equal to ∂N/∂x
                Let variables_list be ListOps.create_with(independent_variable, dependent_variable)
                Let dM_dy be compute_partial_derivatives(M_expr, variables_list, dependent_variable)
                Let dN_dx be compute_partial_derivatives(N_expr, variables_list, independent_variable)
                
                If dM_dy is equal to dN_dx:
                    Note: Equation is exact minus find potential function Ψ such that ∂Ψ/∂x is equal to M, ∂Ψ/∂y is equal to N
                    Let psi_from_M be recognize_standard_integral(M_expr, independent_variable)
                    Return "Exact ODE solution: Ψ(" plus independent_variable plus "," plus dependent_variable plus ") is equal to " plus psi_from_M plus " plus g(" plus dependent_variable plus ") is equal to C"
                Otherwise:
                    Note: Not exact minus may need integrating factor
                    Return "ODE not exact. Integrating factor μ needed where μ*(" plus equation plus ") becomes exact"
    
    Note: Handle standard exact forms
    If StringCore.contains(equation, independent_variable plus "*" plus dependent_variable):
        Return "Exact solution: " plus independent_variable plus "^2*" plus dependent_variable plus "/2 plus " plus dependent_variable plus "^2/2 is equal to C"
    Otherwise:
        Return "Exact ODE solution for: " plus equation plus " requires identifying potential function Ψ(x,y)"

Process called "solve_bernoulli_ode" that takes equation as String, dependent_variable as String, independent_variable as String returns String:
    Note: Solve Bernoulli differential equation
    Note: Bernoulli form: dy/dx plus P(x)y is equal to Q(x)y^n
    Note: Use substitution v is equal to y^(1-n) to reduce to linear ODE
    Return "bernoulli_solution_via_substitution(" plus equation plus ")"

Process called "solve_system_odes" that takes equations as List[String], dependent_variables as List[String], independent_variable as String returns Dictionary[String, String]:
    Note: Solve system of ordinary differential equations
    Let solutions be Map.empty()
    
    Note: For each equation and variable, attempt to solve
    Let i be 0
    While i is less than ListOps.length(equations) and i is less than ListOps.length(dependent_variables):
        Let equation be ListOps.get(equations, i)
        Let variable be ListOps.get(dependent_variables, i)
        Let solution be solve_first_order_ode(equation, variable, independent_variable)
        Map.put(solutions, variable, solution)
        Let i be i plus 1
    
    Return solutions

Process called "solve_pde_separation_variables" that takes equation as String, dependent_variable as String, independent_variables as List[String] returns String:
    Note: Solve partial differential equation using separation of variables
    Note: Assume solution of form u(x,y,t) is equal to X(x)Y(y)T(t)
    Let variable_list be StringCore.join(independent_variables, ",")
    Return "separated_solution(" plus dependent_variable plus "," plus variable_list plus ") is equal to product_of_functions"

Note: =====================================================================
Note: TRANSFORM OPERATIONS
Note: =====================================================================

Process called "laplace_transform" that takes expression as String, variable as String, transform_variable as String returns String:
    Note: Compute Laplace transform of expression
    Note: L{f(t)} is equal to ∫₀^∞ f(t)e^(-st) dt
    
    Note: Handle common transforms
    If expression is equal to "1":
        Return "1/" plus transform_variable
    Otherwise if expression is equal to variable:
        Return "1/" plus transform_variable plus "^2"
    Otherwise if expression is equal to "exp(" plus variable plus ")":
        Return "1/(" plus transform_variable plus " minus 1)"
    Otherwise if expression is equal to "sin(" plus variable plus ")":
        Return "1/(" plus transform_variable plus "^2 plus 1)"
    Otherwise if expression is equal to "cos(" plus variable plus ")":
        Return transform_variable plus "/(" plus transform_variable plus "^2 plus 1)"
    Otherwise:
        Return "L{" plus expression plus "}(" plus transform_variable plus ")"

Process called "inverse_laplace_transform" that takes expression as String, transform_variable as String, original_variable as String returns String:
    Note: Compute inverse Laplace transform
    Note: Inverse transform using table lookup
    If expression is equal to "1/" plus transform_variable:
        Return "1"
    Otherwise if expression is equal to "1/" plus transform_variable plus "^2":
        Return original_variable
    Otherwise if expression is equal to "1/(" plus transform_variable plus " minus 1)":
        Return "exp(" plus original_variable plus ")"
    Otherwise if expression is equal to "1/(" plus transform_variable plus "^2 plus 1)":
        Return "sin(" plus original_variable plus ")"
    Otherwise if expression is equal to transform_variable plus "/(" plus transform_variable plus "^2 plus 1)":
        Return "cos(" plus original_variable plus ")"
    Otherwise:
        Return "L^(-1){" plus expression plus "}(" plus original_variable plus ")"

Process called "fourier_transform" that takes expression as String, variable as String, transform_variable as String returns String:
    Note: Compute Fourier transform of expression
    Note: F{f(t)} is equal to ∫₋∞^∞ f(t)e^(-i2πft) dt
    Return "F{" plus expression plus "}(" plus transform_variable plus ")"

Process called "inverse_fourier_transform" that takes expression as String, transform_variable as String, original_variable as String returns String:
    Note: Compute inverse Fourier transform
    Note: F^(-1){F(ω)} is equal to ∫₋∞^∞ F(ω)e^(i2πωt) dω
    
    Note: Handle common inverse transforms
    If expression is equal to "1":
        Return "δ(" plus original_variable plus ")"
    Otherwise if expression is equal to "1/(" plus transform_variable plus "^2 plus 1)":
        Return "e^(-|" plus original_variable plus "|)"
    Otherwise if expression is equal to transform_variable plus "/(" plus transform_variable plus "^2 plus 1)":
        Return "i*sign(" plus original_variable plus ")*e^(-|" plus original_variable plus "|)"
    Otherwise if StringCore.contains(expression, "e^(-" plus transform_variable plus "^2)"):
        Return "e^(-π*" plus original_variable plus "^2)"
    Otherwise if StringCore.contains(expression, "rect(" plus transform_variable plus ")"):
        Return "sinc(" plus original_variable plus ")"
    Otherwise if StringCore.contains(expression, "δ(" plus transform_variable plus ")"):
        Return "1"
    Otherwise:
        Note: General inverse Fourier transform integral
        Return "∫₋∞^∞ (" plus expression plus ") multiplied by e^(i*2*π*" plus transform_variable plus "*" plus original_variable plus ") d" plus transform_variable

Process called "z_transform" that takes sequence as List[String], transform_variable as String returns String:
    Note: Compute Z-transform of discrete sequence
    Note: Z{x[n]} is equal to Σ(n=0 to ∞) x[n] multiplied by z^(-n)
    
    Note: Handle common sequences
    If ListOps.length(sequence) is equal to 1:
        Let x_n be ListOps.get(sequence, 0)
        If x_n is equal to "1":
            Return transform_variable plus "/(" plus transform_variable plus " minus 1)"
        Otherwise if x_n is equal to "n":
            Return transform_variable plus "/(" plus transform_variable plus " minus 1)^2"
        Otherwise if StringCore.contains(x_n, "a^n"):
            Let a_value be StringOps.replace_all_substrings(x_n, "^n", "")
            Return transform_variable plus "/(" plus transform_variable plus " minus " plus a_value plus ")"
        Otherwise if x_n is equal to "δ[n]":
            Return "1"
        Otherwise if x_n is equal to "u[n]":
            Return transform_variable plus "/(" plus transform_variable plus " minus 1)"
    
    Note: General case minus compute sum of sequence terms
    Let z_transform_sum be ""
    Let n be 0
    While n is less than ListOps.length(sequence):
        Let x_n be ListOps.get(sequence, n)
        Let term be x_n plus " multiplied by " plus transform_variable plus "^(-" plus Integer.to_string(n) plus ")"
        If n is equal to 0:
            Let z_transform_sum be term
        Otherwise:
            Let z_transform_sum be z_transform_sum plus " plus " plus term
        Let n be n plus 1
    
    If z_transform_sum is equal to "":
        Return "0"
    Otherwise:
        Return z_transform_sum

Note: =====================================================================
Note: LINE AND SURFACE INTEGRAL OPERATIONS
Note: =====================================================================

Process called "line_integral_scalar" that takes scalar_field as String, curve_parametrization as Dictionary[String, String], parameter as String returns String:
    Note: Compute line integral of scalar field along curve
    Note: ∫_C f(x,y,z) ds where ds is equal to ||r'(t)|| dt
    
    Note: Get parametric equations for the curve
    Let x_param be Map.get(curve_parametrization, "x", parameter)
    Let y_param be Map.get(curve_parametrization, "y", parameter)  
    Let z_param be Map.get(curve_parametrization, "z", parameter)
    
    Note: Substitute parametric equations into scalar field
    Let substituted_field be scalar_field
    Let substituted_field be StringOps.replace_all_substrings(substituted_field, "x", "(" plus x_param plus ")")
    Let substituted_field be StringOps.replace_all_substrings(substituted_field, "y", "(" plus y_param plus ")")
    Let substituted_field be StringOps.replace_all_substrings(substituted_field, "z", "(" plus z_param plus ")")
    
    Note: Compute derivatives of parametric equations
    Let dx_dt be differentiate_basic_function(x_param, parameter)
    Let dy_dt be differentiate_basic_function(y_param, parameter)
    Let dz_dt be differentiate_basic_function(z_param, parameter)
    
    Note: Compute magnitude of velocity vector ||r'(t)||
    Let ds_dt be "sqrt((" plus dx_dt plus ")^2 plus (" plus dy_dt plus ")^2 plus (" plus dz_dt plus ")^2)"
    
    Note: Set up integral: ∫ f(r(t)) multiplied by ||r'(t)|| dt
    Let integrand be substituted_field plus " multiplied by " plus ds_dt
    
    Return "∫ (" plus integrand plus ") d" plus parameter

Process called "line_integral_vector" that takes vector_field as VectorField, curve_parametrization as Dictionary[String, String], parameter as String returns String:
    Note: Compute line integral of vector field along curve
    Note: ∫_C F⃗ · dr⃗ is equal to ∫_C (F₁dx plus F₂dy plus F₃dz)
    
    Note: Get parametric equations for the curve
    Let x_param be Map.get(curve_parametrization, "x", parameter)
    Let y_param be Map.get(curve_parametrization, "y", parameter)  
    Let z_param be Map.get(curve_parametrization, "z", parameter)
    
    Note: Get vector field components
    Let F1 be ListOps.get(vector_field.components, 0)
    Let F2 be ListOps.get(vector_field.components, 1) 
    Let F3 be ListOps.get(vector_field.components, 2)
    
    Note: Substitute parametric equations into vector field components
    Let F1_substituted be StringOps.replace_all_substrings(F1, "x", "(" plus x_param plus ")")
    Let F1_substituted be StringOps.replace_all_substrings(F1_substituted, "y", "(" plus y_param plus ")")
    Let F1_substituted be StringOps.replace_all_substrings(F1_substituted, "z", "(" plus z_param plus ")")
    
    Let F2_substituted be StringOps.replace_all_substrings(F2, "x", "(" plus x_param plus ")")
    Let F2_substituted be StringOps.replace_all_substrings(F2_substituted, "y", "(" plus y_param plus ")")
    Let F2_substituted be StringOps.replace_all_substrings(F2_substituted, "z", "(" plus z_param plus ")")
    
    Let F3_substituted be StringOps.replace_all_substrings(F3, "x", "(" plus x_param plus ")")
    Let F3_substituted be StringOps.replace_all_substrings(F3_substituted, "y", "(" plus y_param plus ")")
    Let F3_substituted be StringOps.replace_all_substrings(F3_substituted, "z", "(" plus z_param plus ")")
    
    Note: Compute derivatives for dr⃗ is equal to (dx, dy, dz)
    Let dx_dt be differentiate_basic_function(x_param, parameter)
    Let dy_dt be differentiate_basic_function(y_param, parameter)
    Let dz_dt be differentiate_basic_function(z_param, parameter)
    
    Note: Compute dot product F⃗ · (dr⃗/dt)
    Let dot_product be "(" plus F1_substituted plus ") multiplied by (" plus dx_dt plus ") plus (" plus F2_substituted plus ") multiplied by (" plus dy_dt plus ") plus (" plus F3_substituted plus ") multiplied by (" plus dz_dt plus ")"
    
    Return "∫ (" plus dot_product plus ") d" plus parameter

Process called "surface_integral_scalar" that takes scalar_field as String, surface_parametrization as Dictionary[String, Dictionary[String, String]], parameters as List[String] returns String:
    Note: Compute surface integral of scalar field over surface
    Note: ∬_S f(x,y,z) dS where dS is equal to ||r_u × r_v|| du dv
    
    Let u_param be ListOps.get(parameters, 0)
    Let v_param be ListOps.get(parameters, 1)
    
    Note: Get parametric surface equations r(u,v) is equal to (x(u,v), y(u,v), z(u,v))
    Let x_surface be Map.get(Map.get(surface_parametrization, "x", Map.empty()), "expression", u_param plus "+" plus v_param)
    Let y_surface be Map.get(Map.get(surface_parametrization, "y", Map.empty()), "expression", u_param plus "+" plus v_param)
    Let z_surface be Map.get(Map.get(surface_parametrization, "z", Map.empty()), "expression", u_param plus "+" plus v_param)
    
    Note: Substitute surface parametrization into scalar field
    Let substituted_field be scalar_field
    Let substituted_field be StringOps.replace_all_substrings(substituted_field, "x", "(" plus x_surface plus ")")
    Let substituted_field be StringOps.replace_all_substrings(substituted_field, "y", "(" plus y_surface plus ")")
    Let substituted_field be StringOps.replace_all_substrings(substituted_field, "z", "(" plus z_surface plus ")")
    
    Note: Compute partial derivatives for surface normal
    Let dx_du be differentiate_basic_function(x_surface, u_param)
    Let dy_du be differentiate_basic_function(y_surface, u_param)
    Let dz_du be differentiate_basic_function(z_surface, u_param)
    
    Let dx_dv be differentiate_basic_function(x_surface, v_param)
    Let dy_dv be differentiate_basic_function(y_surface, v_param)
    Let dz_dv be differentiate_basic_function(z_surface, v_param)
    
    Note: Compute cross product magnitude ||r_u × r_v||
    Let cross_x be "(" plus dy_du plus ") multiplied by (" plus dz_dv plus ") minus (" plus dz_du plus ") multiplied by (" plus dy_dv plus ")"
    Let cross_y be "(" plus dz_du plus ") multiplied by (" plus dx_dv plus ") minus (" plus dx_du plus ") multiplied by (" plus dz_dv plus ")"
    Let cross_z be "(" plus dx_du plus ") multiplied by (" plus dy_dv plus ") minus (" plus dy_du plus ") multiplied by (" plus dx_dv plus ")"
    Let cross_magnitude be "sqrt((" plus cross_x plus ")^2 plus (" plus cross_y plus ")^2 plus (" plus cross_z plus ")^2)"
    
    Note: Set up surface integral
    Let integrand be substituted_field plus " multiplied by " plus cross_magnitude
    
    Return "∬ (" plus integrand plus ") d" plus u_param plus "d" plus v_param

Process called "surface_integral_vector" that takes vector_field as VectorField, surface_parametrization as Dictionary[String, Dictionary[String, String]], parameters as List[String] returns String:
    Note: Compute flux integral of vector field through surface
    Note: ∬_S F⃗ · n̂ dS is equal to ∬_S F⃗ · (r_u × r_v) du dv
    
    Let u_param be ListOps.get(parameters, 0)
    Let v_param be ListOps.get(parameters, 1)
    
    Note: Get parametric surface equations
    Let x_surface be Map.get(Map.get(surface_parametrization, "x", Map.empty()), "expression", u_param)
    Let y_surface be Map.get(Map.get(surface_parametrization, "y", Map.empty()), "expression", v_param)
    Let z_surface be Map.get(Map.get(surface_parametrization, "z", Map.empty()), "expression", u_param plus "*" plus v_param)
    
    Note: Get vector field components and substitute surface parametrization
    Let F1 be ListOps.get(vector_field.components, 0)
    Let F2 be ListOps.get(vector_field.components, 1)
    Let F3 be ListOps.get(vector_field.components, 2)
    
    Let F1_sub be StringOps.replace_all_substrings(F1, "x", "(" plus x_surface plus ")")
    Let F1_sub be StringOps.replace_all_substrings(F1_sub, "y", "(" plus y_surface plus ")")
    Let F1_sub be StringOps.replace_all_substrings(F1_sub, "z", "(" plus z_surface plus ")")
    
    Let F2_sub be StringOps.replace_all_substrings(F2, "x", "(" plus x_surface plus ")")
    Let F2_sub be StringOps.replace_all_substrings(F2_sub, "y", "(" plus y_surface plus ")")
    Let F2_sub be StringOps.replace_all_substrings(F2_sub, "z", "(" plus z_surface plus ")")
    
    Let F3_sub be StringOps.replace_all_substrings(F3, "x", "(" plus x_surface plus ")")
    Let F3_sub be StringOps.replace_all_substrings(F3_sub, "y", "(" plus y_surface plus ")")
    Let F3_sub be StringOps.replace_all_substrings(F3_sub, "z", "(" plus z_surface plus ")")
    
    Note: Compute surface normal vector r_u × r_v
    Let dx_du be differentiate_basic_function(x_surface, u_param)
    Let dy_du be differentiate_basic_function(y_surface, u_param)
    Let dz_du be differentiate_basic_function(z_surface, u_param)
    
    Let dx_dv be differentiate_basic_function(x_surface, v_param)
    Let dy_dv be differentiate_basic_function(y_surface, v_param)
    Let dz_dv be differentiate_basic_function(z_surface, v_param)
    
    Let n_x be "(" plus dy_du plus ") multiplied by (" plus dz_dv plus ") minus (" plus dz_du plus ") multiplied by (" plus dy_dv plus ")"
    Let n_y be "(" plus dz_du plus ") multiplied by (" plus dx_dv plus ") minus (" plus dx_du plus ") multiplied by (" plus dz_dv plus ")"
    Let n_z be "(" plus dx_du plus ") multiplied by (" plus dy_dv plus ") minus (" plus dy_du plus ") multiplied by (" plus dx_dv plus ")"
    
    Note: Compute dot product F⃗ · (r_u × r_v)
    Let dot_product be "(" plus F1_sub plus ") multiplied by (" plus n_x plus ") plus (" plus F2_sub plus ") multiplied by (" plus n_y plus ") plus (" plus F3_sub plus ") multiplied by (" plus n_z plus ")"
    
    Return "∬ (" plus dot_product plus ") d" plus u_param plus "d" plus v_param

Process called "greens_theorem" that takes vector_field as VectorField, region_boundary as Dictionary[String, String] returns String:
    Note: Apply Green's theorem to convert line integral to double integral
    Note: ∮_C (P dx plus Q dy) is equal to ∬_D (∂Q/∂x minus ∂P/∂y) dx dy
    
    Note: Get vector field components P and Q
    Let P_component be ListOps.get(vector_field.components, 0)
    Let Q_component be ListOps.get(vector_field.components, 1)
    
    Note: Compute partial derivatives
    Let variables be ListOps.create_with("x", "y")
    Let dQ_dx be compute_partial_derivatives(Q_component, variables, "x")
    Let dP_dy be compute_partial_derivatives(P_component, variables, "y")
    
    Note: Green's theorem integrand: ∂Q/∂x minus ∂P/∂y
    Let greens_integrand be "(" plus dQ_dx plus ") minus (" plus dP_dy plus ")"
    
    Note: Get region bounds
    Let x_bounds be Map.get(region_boundary, "x_bounds", "a,b")
    Let y_bounds be Map.get(region_boundary, "y_bounds", "c,d")
    
    Return "∬_D (" plus greens_integrand plus ") dx dy over region " plus x_bounds plus " x " plus y_bounds

Process called "stokes_theorem" that takes vector_field as VectorField, surface as Dictionary[String, String], boundary_curve as Dictionary[String, String] returns String:
    Note: Apply Stokes' theorem to relate surface and line integrals
    Note: ∮_C F⃗ · dr⃗ is equal to ∬_S (∇ × F⃗) · n̂ dS
    
    Note: Compute curl of vector field
    Let variables be ListOps.create_with("x", "y", "z")
    Let curl_components be calculate_curl(vector_field.components, variables)
    
    Note: Create curl vector field
    Let curl_field be VectorField with:
        components is equal to curl_components
        coordinate_system is equal to "cartesian"
        dimension is equal to 3
        divergence is equal to "0"
        curl is equal to ListOps.empty()
        gradient is equal to ListOps.empty()
    
    Note: Get surface parametrization
    Let surface_param be Map.empty()
    Map.put(surface_param, "x", Map.create_with("expression", Map.get(surface, "x_param", "u")))
    Map.put(surface_param, "y", Map.create_with("expression", Map.get(surface, "y_param", "v")))
    Map.put(surface_param, "z", Map.create_with("expression", Map.get(surface, "z_param", "u*v")))
    
    Let surface_params be ListOps.create_with("u", "v")
    
    Note: Apply Stokes' theorem minus surface integral of curl
    Let surface_integral_result be surface_integral_vector(curl_field, surface_param, surface_params)
    
    Return "Stokes' theorem: Line integral is equal to " plus surface_integral_result

Process called "divergence_theorem" that takes vector_field as VectorField, region as Dictionary[String, String] returns String:
    Note: Apply divergence theorem to convert volume to surface integral
    Note: ∬_S F⃗ · n̂ dS is equal to ∭_V ∇ · F⃗ dV
    
    Note: Compute divergence of vector field
    Let variables be ListOps.create_with("x", "y", "z")
    Let divergence_expr be calculate_divergence(vector_field.components, variables)
    
    Note: Get region bounds for triple integral
    Let x_bounds be Map.get(region, "x_bounds", "x1,x2")
    Let y_bounds be Map.get(region, "y_bounds", "y1,y2")
    Let z_bounds be Map.get(region, "z_bounds", "z1,z2")
    
    Note: Set up volume integral
    Let volume_integral be "∭_V (" plus divergence_expr plus ") dx dy dz"
    
    Return "Divergence theorem: Surface integral is equal to " plus volume_integral plus " over region " plus x_bounds plus " x " plus y_bounds plus " x " plus z_bounds

Note: =====================================================================
Note: COMPLEX ANALYSIS OPERATIONS
Note: =====================================================================

Process called "complex_derivative" that takes complex_function as String, complex_variable as String returns String:
    Note: Compute derivative of complex function (check analyticity)
    Note: f'(z) is equal to lim[h→0] (f(z+h) minus f(z))/h for analytic functions
    
    Note: Handle common complex functions
    If complex_function is equal to complex_variable:
        Return "1"
    Otherwise if complex_function is equal to complex_variable plus "^2":
        Return "2*" plus complex_variable
    Otherwise if complex_function is equal to complex_variable plus "^n":
        Return "n*" plus complex_variable plus "^(n-1)"
    Otherwise if complex_function is equal to "exp(" plus complex_variable plus ")":
        Return "exp(" plus complex_variable plus ")"
    Otherwise if complex_function is equal to "sin(" plus complex_variable plus ")":
        Return "cos(" plus complex_variable plus ")"
    Otherwise if complex_function is equal to "cos(" plus complex_variable plus ")":
        Return "-sin(" plus complex_variable plus ")"
    Otherwise if complex_function is equal to "1/" plus complex_variable:
        Return "-1/" plus complex_variable plus "^2"
    Otherwise if complex_function is equal to "ln(" plus complex_variable plus ")":
        Return "1/" plus complex_variable
    Otherwise:
        Note: For general complex functions, use symbolic differentiation
        Return "d/d" plus complex_variable plus "[" plus complex_function plus "]"

Process called "cauchy_riemann_check" that takes complex_function as String, variables as Dictionary[String, String] returns Boolean:
    Note: Check Cauchy-Riemann equations for analyticity
    Note: Cauchy-Riemann: ∂u/∂x is equal to ∂v/∂y and ∂u/∂y is equal to -∂v/∂x
    
    Note: Extract real and imaginary parts
    Let u_part be Map.get(variables, "real_part", "u")
    Let v_part be Map.get(variables, "imaginary_part", "v")
    Let x_var be Map.get(variables, "x_variable", "x")
    Let y_var be Map.get(variables, "y_variable", "y")
    
    Note: Compute partial derivatives
    Let xy_vars be ListOps.create_with(x_var, y_var)
    Let du_dx be compute_partial_derivatives(u_part, xy_vars, x_var)
    Let du_dy be compute_partial_derivatives(u_part, xy_vars, y_var)
    Let dv_dx be compute_partial_derivatives(v_part, xy_vars, x_var)
    Let dv_dy be compute_partial_derivatives(v_part, xy_vars, y_var)
    
    Note: Check Cauchy-Riemann equations
    Note: In a real implementation, would need symbolic equality checking
    Let cr1_satisfied be du_dx is equal to dv_dy
    Let cr2_satisfied be du_dy is equal to ("-" plus dv_dx)
    
    Return cr1_satisfied and cr2_satisfied

Process called "contour_integral" that takes complex_function as String, contour as Dictionary[String, String], parameter as String returns String:
    Note: Compute contour integral of complex function
    Note: ∮_C f(z) dz is equal to ∮_C f(z(t)) z'(t) dt
    
    Note: Get complex contour parametrization z(t) is equal to x(t) plus iy(t)
    Let x_param be Map.get(contour, "real_part", parameter)
    Let y_param be Map.get(contour, "imaginary_part", parameter)
    Let t_start be Map.get(contour, "parameter_start", "0")
    Let t_end be Map.get(contour, "parameter_end", "2π")
    
    Note: Construct complex parametrization z(t)
    Let z_param be x_param plus " plus i*" plus y_param
    
    Note: Compute z'(t) is equal to x'(t) plus iy'(t)
    Let dx_dt be differentiate_basic_function(x_param, parameter)
    Let dy_dt be differentiate_basic_function(y_param, parameter)
    Let z_prime be dx_dt plus " plus i*" plus dy_dt
    
    Note: Substitute parametrization into complex function
    Let f_substituted be StringOps.replace_all_substrings(complex_function, "z", "(" plus z_param plus ")")
    
    Note: Set up contour integral f(z(t)) multiplied by z'(t)
    Let integrand be "(" plus f_substituted plus ") multiplied by (" plus z_prime plus ")"
    
    Return "∮_C " plus integrand plus " d" plus parameter plus " from " plus t_start plus " to " plus t_end

Process called "residue_calculation" that takes complex_function as String, singularity as String returns String:
    Note: Calculate residue at isolated singularity
    Note: Res[f,z0] is equal to coefficient of (z-z0)^(-1) in Laurent expansion
    
    Note: Handle simple poles: Res[f,z0] is equal to lim[z→z0] (z-z0)f(z)
    If StringCore.contains(complex_function, ""1/(" plus "z"" joined with ""1/(" plus "z"" plus "-" plus singularity plus ")"):
        Return "1"  Note: Simple pole with residue 1
    Otherwise if StringCore.contains(complex_function, ""1/(" plus "z"" joined with ""1/(" plus "z"" plus "-" plus singularity plus ")^2"):
        Return "0"  Note: Pole of order 2 has residue 0 for this form
    Otherwise if StringCore.contains(complex_function, ""1/(" plus "z"" joined with ""1/(" plus "z"" plus "-" plus singularity plus ")^n"):
        Return "0"  Note: Higher order pole
    
    Note: For rational functions P(z)/Q(z) with simple pole at z0
    If StringCore.contains(complex_function, "/"):
        Let parts be StringCore.split(complex_function, "/")
        If ListOps.length(parts) is equal to 2:
            Let numerator be ListOps.get(parts, 0)
            Let denominator be ListOps.get(parts, 1)
            
            Note: Residue is equal to P(z0)/Q'(z0) for simple pole
            Let num_at_singularity be StringOps.replace_all_substrings(numerator, "z", singularity)
            Let den_derivative be differentiate_basic_function(denominator, "z")
            Let den_deriv_at_sing be StringOps.replace_all_substrings(den_derivative, "z", singularity)
            
            Return "(" plus num_at_singularity plus ") / (" plus den_deriv_at_sing plus ")"
    
    Note: General case minus compute residue using Laurent series expansion
    Note: For general functions, use our Laurent series implementation
    Let laurent_expansion be laurent_series(complex_function, "z", singularity, 5, 5)
    
    Note: Residue is coefficient of (z-z0)^(-1) term
    Let residue_coefficient be Map.get(laurent_expansion.coefficients, "-1", "0")
    
    If residue_coefficient is equal to "0":
        Note: Check if function is analytic at this point
        If StringCore.contains(complex_function, ""1/(" plus "z"" joined with ""1/(" plus "z"" plus "-" plus singularity plus ")"):
            Return "1"
        Otherwise:
            Return "0"
    Otherwise:
        Return residue_coefficient

Process called "residue_theorem" that takes complex_function as String, contour as Dictionary[String, String], singularities as List[String] returns String:
    Note: Apply residue theorem to evaluate contour integral
    Note: ∮_C f(z) dz is equal to 2πi multiplied by Σ Res[f, zk] for singularities inside contour
    
    Let total_residue be "0"
    Let residue_terms be ListOps.empty()
    
    Note: Calculate residue at each singularity inside the contour
    For each singularity in singularities:
        Let residue_value be residue_calculation(complex_function, singularity)
        ListOps.append(residue_terms, residue_value)
        
        If total_residue is equal to "0":
            Let total_residue be residue_value
        Otherwise:
            Let total_residue be total_residue plus " plus " plus residue_value
    
    Note: Apply residue theorem: integral is equal to 2πi multiplied by sum of residues
    Let contour_integral_result be "2*π*i multiplied by (" plus total_residue plus ")"
    
    Note: Get contour description
    Let contour_desc be Map.get(contour, "description", "closed_contour")
    
    Return "Residue theorem: ∮_" plus contour_desc plus " (" plus complex_function plus ") dz is equal to " plus contour_integral_result

Note: =====================================================================
Note: VARIATIONAL CALCULUS OPERATIONS
Note: =====================================================================

Process called "euler_lagrange_equation" that takes lagrangian as String, dependent_variable as String, independent_variable as String returns String:
    Note: Derive Euler-Lagrange equation for variational problem
    Note: Euler-Lagrange equation: d/dx[∂L/∂y'] minus ∂L/∂y is equal to 0
    
    Note: Compute partial derivative with respect to y
    Let y_prime is equal to dependent_variable plus "_prime"
    Let variables_list be ListOps.create_with(dependent_variable, y_prime, independent_variable)
    Let dL_dy be compute_partial_derivatives(lagrangian, variables_list, dependent_variable)
    
    Note: Compute partial derivative with respect to y'
    Let dL_dy_prime be compute_partial_derivatives(lagrangian, variables_list, y_prime)
    
    Note: Compute d/dx[∂L/∂y'] minus need to differentiate with respect to x
    Let d_dx_dL_dy_prime be differentiate_basic_function(dL_dy_prime, independent_variable)
    
    Note: Euler-Lagrange equation: d/dx[∂L/∂y'] minus ∂L/∂y is equal to 0
    Let euler_lagrange_eq be "(" plus d_dx_dL_dy_prime plus ") minus (" plus dL_dy plus ") is equal to 0"
    
    Return euler_lagrange_eq

Process called "calculus_of_variations" that takes functional as String, boundary_conditions as Dictionary[String, String] returns String:
    Note: Solve variational problem with specified boundary conditions
    Note: Find function y(x) that extremizes ∫ F(x,y,y') dx
    
    Note: Extract Lagrangian from functional
    Let lagrangian be functional
    If StringCore.contains(functional, "integral"):
        Let lagrangian be StringOps.replace_all_substrings(functional, "integral", "")
        Let lagrangian be StringOps.replace_all_substrings(lagrangian, "[", "")
        Let lagrangian be StringOps.replace_all_substrings(lagrangian, "]", "")
    
    Note: Get boundary conditions
    Let x_start be Map.get(boundary_conditions, "x_start", "a")
    Let x_end be Map.get(boundary_conditions, "x_end", "b")
    Let y_start be Map.get(boundary_conditions, "y_start", "y_a")
    Let y_end be Map.get(boundary_conditions, "y_end", "y_b")
    
    Note: Apply Euler-Lagrange equation
    Let euler_eq be euler_lagrange_equation(lagrangian, "y", "x")
    
    Note: Combine with boundary conditions
    Let solution_description be "Solve: " plus euler_eq
    Let solution_description be solution_description plus " with y(" plus x_start plus ") is equal to " plus y_start
    Let solution_description be solution_description plus " and y(" plus x_end plus ") is equal to " plus y_end
    
    Return solution_description

Process called "brachistochrone_problem" that takes start_point as Dictionary[String, String], end_point as Dictionary[String, String] returns String:
    Note: Solve brachistochrone problem for fastest descent curve
    Note: Minimize time T is equal to ∫ sqrt((1 plus y'^2)/(2gy)) dx
    
    Note: Get start and end coordinates
    Let x1 be Map.get(start_point, "x", "0")
    Let y1 be Map.get(start_point, "y", "0")
    Let x2 be Map.get(end_point, "x", "1")
    Let y2 be Map.get(end_point, "y", "1")
    
    Note: Brachistochrone Lagrangian: L is equal to sqrt((1 plus y'^2)/(2gy))
    Let brachistochrone_lagrangian be "sqrt((1 plus y_prime^2)/(2*g*y))"
    
    Note: Apply calculus of variations
    Let boundary_conds be Map.empty()
    Map.put(boundary_conds, "x_start", x1)
    Map.put(boundary_conds, "x_end", x2)
    Map.put(boundary_conds, "y_start", y1)
    Map.put(boundary_conds, "y_end", y2)
    
    Let variational_solution be calculus_of_variations(brachistochrone_lagrangian, boundary_conds)
    
    Note: Analytical solution is a cycloid
    Let cycloid_solution be "Cycloid: x is equal to R(θ minus sin(θ)), y is equal to R(1 minus cos(θ))"
    
    Return "Brachistochrone problem: " plus variational_solution plus ". Analytical solution: " plus cycloid_solution

Note: =====================================================================
Note: VALIDATION AND UTILITY OPERATIONS
Note: =====================================================================

Process called "verify_derivative" that takes original_expression as String, derivative_expression as String, variable as String returns Boolean:
    Note: Verify correctness of symbolic derivative
    Let computed_derivative be differentiate_basic_function(original_expression, variable)
    
    Note: String comparison for derivative verification minus could be enhanced with symbolic equivalence
    If computed_derivative is equal to derivative_expression:
        Return true
    
    Note: Check if they simplify to the same thing
    Let simplified_computed be SymbolicCore.simplify_expression(SymbolicCore.parse_expression(computed_derivative, Map.empty()), Map.empty())
    Let simplified_given be SymbolicCore.simplify_expression(SymbolicCore.parse_expression(derivative_expression, Map.empty()), Map.empty())
    
    Return simplified_computed.expression_id is equal to simplified_given.expression_id

Process called "verify_integral" that takes integral_result as String, integrand as String, variable as String returns Boolean:
    Note: Verify correctness of symbolic integral by differentiation
    Let derivative_of_result be differentiate_basic_function(integral_result, variable)
    
    Note: Check if derivative is equal to original integrand
    Return derivative_of_result is equal to integrand

Process called "benchmark_calculus_operations" that takes operation_types as List[String], test_expressions as List[String] returns Dictionary[String, Float]:
    Note: Benchmark performance of calculus operations
    Let results be Map.empty()
    
    For each operation_type in operation_types:
        Let total_time be 0.0
        For each expression in test_expressions:
            Let start_time be System.current_time_millis()
            
            If operation_type is equal to "differentiate":
                Let result be differentiate_basic_function(expression, "x")
            Otherwise if operation_type is equal to "integrate":
                Let result be recognize_standard_integral(expression, "x")
            Otherwise if operation_type is equal to "limit":
                Let result be evaluate_at_point(expression, "x", "0")
            
            Let end_time be System.current_time_millis()
            Let total_time be total_time plus (end_time minus start_time)
        
        Let average_time be total_time / Float.from_integer(ListOps.length(test_expressions))
        Map.put(results, operation_type, average_time)
    
    Return results