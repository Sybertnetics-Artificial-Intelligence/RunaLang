Note:
math/financial/options.runa
Options Pricing and Valuation Models

This module provides comprehensive options pricing capabilities including
Black-Scholes formula, binomial trees, Monte Carlo pricing, Greeks calculation,
American options, exotic options, implied volatility calculation, and option
trading strategies for quantitative finance applications.
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/probability/distributions" as Distributions
Import module "math/core/operations" as MathOps
Import module "math/probability/sampling" as Sampling
Import module "sys/time/core/calendar" as Calendar
Import module "math/precision/bigdecimal" as BigDecimal

Note: =====================================================================
Note: OPTIONS PRICING DATA STRUCTURES
Note: =====================================================================

Type called "OptionContract":
    contract_id as String
    underlying_asset as String
    option_type as String
    strike_price as Float
    expiration_date as Integer
    premium as Float
    contract_size as Integer
    exercise_style as String
    option_status as String

Type called "BlackScholesParameters":
    spot_price as Float
    strike_price as Float
    time_to_expiration as Float
    risk_free_rate as Float
    volatility as Float
    dividend_yield as Float
    option_type as String

Type called "BinomialTreeNode":
    node_level as Integer
    node_index as Integer
    spot_price as Float
    option_value as Float
    probability as Float
    exercise_decision as Boolean

Type called "GreeksCalculation":
    delta as Float
    gamma as Float
    theta as Float
    vega as Float
    rho as Float
    lambda as Float
    vanna as Float
    charm as Float

Type called "MonteCarloSimulation":
    simulation_id as String
    num_paths as Integer
    time_steps as Integer
    random_seed as Integer
    simulation_results as List[Float]
    confidence_intervals as Dictionary[String, Float]

Type called "OptionStrategy":
    strategy_id as String
    strategy_name as String
    strategy_type as String
    option_legs as List[Dictionary[String, String]]
    net_premium as Float
    max_profit as Float
    max_loss as Float
    breakeven_points as List[Float]

Note: =====================================================================
Note: BLACK-SCHOLES MODEL OPERATIONS
Note: =====================================================================

Process called "calculate_black_scholes_price" that takes parameters as BlackScholesParameters returns Float:
    Note: Calculate option price using Black-Scholes formula with risk-neutral valuation
    If parameters.time_to_expiration is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Time to expiration must be positive"
    If parameters.volatility is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Volatility must be positive"
    If parameters.spot_price is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Spot price must be positive"
    If parameters.strike_price is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Strike price must be positive"
    
    Let ln_s_k be MathOps.logarithm(ToString(parameters.spot_price / parameters.strike_price), "e", 15).result_value
    Let r_plus_half_vol_sq be (parameters.risk_free_rate minus parameters.dividend_yield) plus (0.5 multiplied by parameters.volatility multiplied by parameters.volatility)
    Let vol_sqrt_t be parameters.volatility multiplied by MathOps.square_root(ToString(parameters.time_to_expiration), 15).result_value
    
    Let d1_numerator be Parse ln_s_k as Float plus (r_plus_half_vol_sq multiplied by parameters.time_to_expiration)
    Let d1 be d1_numerator / Parse vol_sqrt_t as Float
    Let d2 be d1 minus Parse vol_sqrt_t as Float
    
    Let n_d1 be Distributions.normal_distribution_cdf(d1, 0.0, 1.0)
    Let n_d2 be Distributions.normal_distribution_cdf(d2, 0.0, 1.0)
    
    Let discount_factor be MathOps.exponential(ToString(-parameters.risk_free_rate multiplied by parameters.time_to_expiration), 15).result_value
    Let dividend_discount be MathOps.exponential(ToString(-parameters.dividend_yield multiplied by parameters.time_to_expiration), 15).result_value
    
    If parameters.option_type is equal to "call":
        Let call_price be (parameters.spot_price multiplied by Parse dividend_discount as Float multiplied by n_d1) minus (parameters.strike_price multiplied by Parse discount_factor as Float multiplied by n_d2)
        Return call_price
    Otherwise parameters.option_type is equal to "put":
        Let put_d1 be Distributions.normal_distribution_cdf(-d1, 0.0, 1.0)
        Let put_d2 be Distributions.normal_distribution_cdf(-d2, 0.0, 1.0)
        Let put_price be (parameters.strike_price multiplied by Parse discount_factor as Float multiplied by put_d2) minus (parameters.spot_price multiplied by Parse dividend_discount as Float multiplied by put_d1)
        Return put_price
    Otherwise:
        Throw Errors.InvalidArgument with "Option type must be 'call' or 'put'"

Process called "calculate_implied_volatility" that takes market_price as Float, parameters as BlackScholesParameters returns Float:
    Note: Calculate implied volatility using Newton-Raphson method or bisection
    If market_price is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Market price must be positive"
    
    Let vol_low be 0.001
    Let vol_high be 5.0
    Let tolerance be 0.0001
    Let max_iterations be 100
    Let iteration be 0
    
    While iteration is less than max_iterations:
        Let vol_mid be (vol_low plus vol_high) / 2.0
        Let test_params be BlackScholesParameters
        Set test_params.spot_price to parameters.spot_price
        Set test_params.strike_price to parameters.strike_price
        Set test_params.time_to_expiration to parameters.time_to_expiration
        Set test_params.risk_free_rate to parameters.risk_free_rate
        Set test_params.volatility to vol_mid
        Set test_params.dividend_yield to parameters.dividend_yield
        Set test_params.option_type to parameters.option_type
        
        Let theoretical_price be calculate_black_scholes_price(test_params)
        Let price_diff be theoretical_price minus market_price
        Let abs_diff be price_diff
        
        If abs_diff is less than 0.0:
            Set abs_diff to -abs_diff
        If abs_diff is less than tolerance:
            Return vol_mid
        
        If price_diff is greater than 0.0:
            Set vol_high to vol_mid
        Otherwise:
            Set vol_low to vol_mid
        
        Set iteration to iteration plus 1
    
    Let final_vol be (vol_low plus vol_high) / 2.0
    Return final_vol

Process called "calculate_option_greeks" that takes parameters as BlackScholesParameters returns GreeksCalculation:
    Note: Calculate option Greeks (delta, gamma, theta, vega, rho) for risk management
    Let greeks be GreeksCalculation
    
    Let ln_s_k be MathOps.logarithm(ToString(parameters.spot_price / parameters.strike_price), "e", 15).result_value
    Let r_plus_half_vol_sq be (parameters.risk_free_rate minus parameters.dividend_yield) plus (0.5 multiplied by parameters.volatility multiplied by parameters.volatility)
    Let vol_sqrt_t be parameters.volatility multiplied by MathOps.square_root(ToString(parameters.time_to_expiration), 15).result_value
    
    Let d1_numerator be Parse ln_s_k as Float plus (r_plus_half_vol_sq multiplied by parameters.time_to_expiration)
    Let d1 be d1_numerator / Parse vol_sqrt_t as Float
    Let d2 be d1 minus Parse vol_sqrt_t as Float
    
    Let n_d1 be Distributions.normal_distribution_cdf(d1, 0.0, 1.0)
    Let n_d2 be Distributions.normal_distribution_cdf(d2, 0.0, 1.0)
    Let pdf_d1 be Distributions.normal_distribution_pdf(d1, 0.0, 1.0)
    
    Let discount_factor be MathOps.exponential(ToString(-parameters.risk_free_rate multiplied by parameters.time_to_expiration), 15).result_value
    Let dividend_discount be MathOps.exponential(ToString(-parameters.dividend_yield multiplied by parameters.time_to_expiration), 15).result_value
    
    If parameters.option_type is equal to "call":
        Set greeks.delta to Parse dividend_discount as Float multiplied by n_d1
        Set greeks.gamma to (Parse dividend_discount as Float multiplied by pdf_d1) / (parameters.spot_price multiplied by Parse vol_sqrt_t as Float)
        Set greeks.theta to -((parameters.spot_price multiplied by pdf_d1 multiplied by parameters.volatility multiplied by Parse dividend_discount as Float) / (2.0 multiplied by MathOps.square_root(ToString(parameters.time_to_expiration), 15).result_value)) minus (parameters.risk_free_rate multiplied by parameters.strike_price multiplied by Parse discount_factor as Float multiplied by n_d2) plus (parameters.dividend_yield multiplied by parameters.spot_price multiplied by Parse dividend_discount as Float multiplied by n_d1)
        Set greeks.vega to parameters.spot_price multiplied by Parse dividend_discount as Float multiplied by pdf_d1 multiplied by MathOps.square_root(ToString(parameters.time_to_expiration), 15).result_value / 100.0
        Set greeks.rho to parameters.strike_price multiplied by parameters.time_to_expiration multiplied by Parse discount_factor as Float multiplied by n_d2 / 100.0
    Otherwise:
        Set greeks.delta to Parse dividend_discount as Float multiplied by (n_d1 minus 1.0)
        Set greeks.gamma to (Parse dividend_discount as Float multiplied by pdf_d1) / (parameters.spot_price multiplied by Parse vol_sqrt_t as Float)
        Set greeks.theta to -((parameters.spot_price multiplied by pdf_d1 multiplied by parameters.volatility multiplied by Parse dividend_discount as Float) / (2.0 multiplied by MathOps.square_root(ToString(parameters.time_to_expiration), 15).result_value)) plus (parameters.risk_free_rate multiplied by parameters.strike_price multiplied by Parse discount_factor as Float multiplied by (1.0 minus n_d2)) minus (parameters.dividend_yield multiplied by parameters.spot_price multiplied by Parse dividend_discount as Float multiplied by (1.0 minus n_d1))
        Set greeks.vega to parameters.spot_price multiplied by Parse dividend_discount as Float multiplied by pdf_d1 multiplied by MathOps.square_root(ToString(parameters.time_to_expiration), 15).result_value / 100.0
        Set greeks.rho to -parameters.strike_price multiplied by parameters.time_to_expiration multiplied by Parse discount_factor as Float multiplied by (1.0 minus n_d2) / 100.0
    
    Set greeks.lambda to greeks.delta multiplied by parameters.spot_price / calculate_black_scholes_price(parameters)
    Set greeks.vanna to -greeks.vega multiplied by d2 / parameters.volatility
    Set greeks.charm to -greeks.delta multiplied by (parameters.risk_free_rate minus parameters.dividend_yield) / parameters.time_to_expiration minus (parameters.spot_price multiplied by Parse dividend_discount as Float multiplied by pdf_d1 multiplied by (2.0 multiplied by (parameters.risk_free_rate minus parameters.dividend_yield) multiplied by parameters.time_to_expiration minus d2 multiplied by Parse vol_sqrt_t as Float)) / (2.0 multiplied by parameters.time_to_expiration multiplied by Parse vol_sqrt_t as Float)
    
    Return greeks

Process called "validate_black_scholes_assumptions" that takes parameters as BlackScholesParameters returns Dictionary[String, Boolean]:
    Note: Validate Black-Scholes model assumptions and parameter constraints
    Let validation be Dictionary[String, Boolean]
    
    Set validation["positive_spot_price"] to parameters.spot_price is greater than 0.0
    Set validation["positive_strike_price"] to parameters.strike_price is greater than 0.0
    Set validation["positive_time_to_expiration"] to parameters.time_to_expiration is greater than 0.0
    Set validation["positive_volatility"] to parameters.volatility is greater than 0.0
    Set validation["non_negative_risk_free_rate"] to parameters.risk_free_rate is greater than or equal to 0.0
    Set validation["non_negative_dividend_yield"] to parameters.dividend_yield is greater than or equal to 0.0
    Set validation["valid_option_type"] to (parameters.option_type is equal to "call") || (parameters.option_type is equal to "put")
    Set validation["reasonable_volatility_range"] to parameters.volatility is less than or equal to 3.0
    Set validation["reasonable_time_range"] to parameters.time_to_expiration is less than or equal to 10.0
    Set validation["reasonable_interest_rate"] to parameters.risk_free_rate is less than or equal to 0.5
    Set validation["reasonable_dividend_yield"] to parameters.dividend_yield is less than or equal to 0.3
    
    Return validation

Note: =====================================================================
Note: BINOMIAL TREE MODEL OPERATIONS
Note: =====================================================================

Process called "build_binomial_tree" that takes spot_price as Float, volatility as Float, time_steps as Integer, time_to_expiration as Float returns List[List[BinomialTreeNode]]:
    Note: Build binomial tree for option pricing with Cox-Ross-Rubinstein model
    If time_steps is less than or equal to 0:
        Throw Errors.InvalidArgument with "Time steps must be positive"
    If volatility is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Volatility must be positive"
    If spot_price is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Spot price must be positive"
    
    Let dt be time_to_expiration / Float(time_steps)
    Let u be Parse MathOps.exponential(ToString(volatility multiplied by MathOps.square_root(ToString(dt), 15).result_value), 15).result_value as Float
    Let d be 1.0 / u
    Let tree be List[List[BinomialTreeNode]]
    
    Let level be 0
    While level is less than or equal to time_steps:
        Let level_nodes be List[BinomialTreeNode]
        Let node_index be 0
        While node_index is less than or equal to level:
            Let node be BinomialTreeNode
            Set node.node_level to level
            Set node.node_index to node_index
            
            Let up_moves be level minus node_index
            Let down_moves be node_index
            Let current_spot be spot_price multiplied by MathOps.power(ToString(u), ToString(Float(up_moves)), 15).result_value multiplied by MathOps.power(ToString(d), ToString(Float(down_moves)), 15).result_value
            Set node.spot_price to Parse current_spot as Float
            Set node.option_value to 0.0
            Set node.probability to 1.0
            Set node.exercise_decision to false
            
            Add node to level_nodes
            Set node_index to node_index plus 1
        
        Add level_nodes to tree
        Set level to level plus 1
    
    Return tree

Process called "price_american_option" that takes tree as List[List[BinomialTreeNode]], strike as Float, option_type as String returns Float:
    Note: Price American options using binomial tree with early exercise features
    If Length(tree) is equal to 0:
        Throw Errors.InvalidArgument with "Tree cannot be empty"
    If option_type does not equal "call" && option_type does not equal "put":
        Throw Errors.InvalidArgument with "Option type must be 'call' or 'put'"
    
    Let time_steps be Length(tree) minus 1
    Let dt be 1.0 / Float(time_steps)
    Let risk_free_rate be 0.05
    Let u be 1.1
    Let d be 1.0 / u
    Let p be (MathOps.exponential(ToString(risk_free_rate multiplied by dt), 15).result_value minus d) / (u minus d)
    Let discount be MathOps.exponential(ToString(-risk_free_rate multiplied by dt), 15).result_value
    
    Let final_level be Length(tree) minus 1
    Let terminal_nodes be tree[final_level]
    Let node_index be 0
    While node_index is less than Length(terminal_nodes):
        Let node be terminal_nodes[node_index]
        If option_type is equal to "call":
            Let intrinsic be node.spot_price minus strike
            If intrinsic is greater than 0.0:
                Set node.option_value to intrinsic
            Otherwise:
                Set node.option_value to 0.0
        Otherwise:
            Let intrinsic be strike minus node.spot_price
            If intrinsic is greater than 0.0:
                Set node.option_value to intrinsic
            Otherwise:
                Set node.option_value to 0.0
        Set node_index to node_index plus 1
    
    Let level be final_level minus 1
    While level is greater than or equal to 0:
        Let current_nodes be tree[level]
        Let next_nodes be tree[level plus 1]
        Let node_idx be 0
        While node_idx is less than Length(current_nodes):
            Let node be current_nodes[node_idx]
            Let up_node be next_nodes[node_idx]
            Let down_node be next_nodes[node_idx plus 1]
            
            Let continuation_value be Parse discount as Float multiplied by (Parse p as Float multiplied by up_node.option_value plus (1.0 minus Parse p as Float) multiplied by down_node.option_value)
            
            Let exercise_value be 0.0
            If option_type is equal to "call":
                Let intrinsic_val be node.spot_price minus strike
                If intrinsic_val is greater than 0.0:
                    Set exercise_value to intrinsic_val
                Otherwise:
                    Set exercise_value to 0.0
            Otherwise:
                Let intrinsic_val be strike minus node.spot_price
                If intrinsic_val is greater than 0.0:
                    Set exercise_value to intrinsic_val
                Otherwise:
                    Set exercise_value to 0.0
            
            If continuation_value is greater than exercise_value:
                Set node.option_value to continuation_value
                Set node.exercise_decision to false
            Otherwise:
                Set node.option_value to exercise_value
                Set node.exercise_decision to true
            Set node_idx to node_idx plus 1
        Set level to level minus 1
    
    Return tree[0][0].option_value

Process called "calculate_optimal_exercise_boundary" that takes tree as List[List[BinomialTreeNode]], strike as Float returns List[Float]:
    Note: Calculate optimal exercise boundary for American options
    Let boundary_points be List[Float]
    
    Let level be 0
    While level is less than Length(tree):
        Let level_nodes be tree[level]
        Let exercise_boundary be 0.0
        Let found_boundary be false
        
        Let node_idx be 0
        While node_idx is less than Length(level_nodes) && !found_boundary:
            Let node be level_nodes[node_idx]
            If node.exercise_decision:
                Set exercise_boundary to node.spot_price
                Set found_boundary to true
            Set node_idx to node_idx plus 1
        
        If !found_boundary:
            If level is greater than 0:
                Set exercise_boundary to boundary_points[level minus 1]
            Otherwise:
                Set exercise_boundary to strike
        
        Add exercise_boundary to boundary_points
        Set level to level plus 1
    
    Return boundary_points

Process called "analyze_tree_convergence" that takes tree_sizes as List[Integer], option_prices as List[Float] returns Dictionary[String, Float]:
    Note: Analyze convergence properties of binomial tree pricing
    If Length(tree_sizes) does not equal Length(option_prices):
        Throw Errors.InvalidArgument with "Tree sizes and prices must have same length"
    If Length(tree_sizes) is less than 2:
        Throw Errors.InvalidArgument with "Need at least 2 data points for convergence analysis"
    
    Let analysis be Dictionary[String, Float]
    
    Let sum_prices be 0.0
    Let i be 0
    While i is less than Length(option_prices):
        Set sum_prices to sum_prices plus option_prices[i]
        Set i to i plus 1
    Let mean_price be sum_prices / Float(Length(option_prices))
    
    Let sum_squared_diffs be 0.0
    Set i to 0
    While i is less than Length(option_prices):
        Let diff be option_prices[i] minus mean_price
        Set sum_squared_diffs to sum_squared_diffs plus (diff multiplied by diff)
        Set i to i plus 1
    Let variance be sum_squared_diffs / Float(Length(option_prices) minus 1)
    Let std_dev be MathOps.square_root(ToString(variance), 15).result_value
    
    Let final_price be option_prices[Length(option_prices) minus 1]
    Let convergence_error be Parse std_dev as Float / mean_price
    
    Let max_diff be 0.0
    Set i to 1
    While i is less than Length(option_prices):
        Let diff be option_prices[i] minus option_prices[i minus 1]
        If diff is less than 0.0:
            Set diff to -diff
        If diff is greater than max_diff:
            Set max_diff to diff
        Set i to i plus 1
    
    Set analysis["mean_price"] to mean_price
    Set analysis["final_price"] to final_price
    Set analysis["standard_deviation"] to Parse std_dev as Float
    Set analysis["convergence_error"] to convergence_error
    Set analysis["max_difference"] to max_diff
    Set analysis["is_converged"] to Float(convergence_error is less than 0.01)
    
    Return analysis

Note: =====================================================================
Note: MONTE CARLO PRICING OPERATIONS
Note: =====================================================================

Process called "simulate_option_paths" that takes simulation as MonteCarloSimulation, model_parameters as Dictionary[String, Float] returns List[List[Float]]:
    Note: Simulate asset price paths using geometric Brownian motion or jump diffusion
    Let paths be List[List[Float]]
    
    Let spot_price be model_parameters["spot_price"]
    Let volatility be model_parameters["volatility"]
    Let risk_free_rate be model_parameters["risk_free_rate"]
    Let time_to_expiration be model_parameters["time_to_expiration"]
    
    Let dt be time_to_expiration / Float(simulation.time_steps)
    Let drift be risk_free_rate minus 0.5 multiplied by volatility multiplied by volatility
    Let vol_sqrt_dt be volatility multiplied by MathOps.square_root(ToString(dt), 15).result_value
    
    Let path_index be 0
    While path_index is less than simulation.num_paths:
        Let path be List[Float]
        Add spot_price to path
        
        Let current_price be spot_price
        Let step be 1
        While step is less than or equal to simulation.time_steps:
            Let random_normal be Sampling.generate_random_float(-3.0, 3.0)
            Let price_change be drift multiplied by dt plus Parse vol_sqrt_dt as Float multiplied by random_normal
            Set current_price to current_price multiplied by Parse MathOps.exponential(ToString(price_change), 15).result_value as Float
            Add current_price to path
            Set step to step plus 1
        
        Add path to paths
        Set path_index to path_index plus 1
    
    Return paths

Process called "price_path_dependent_options" that takes paths as List[List[Float]], option_specification as Dictionary[String, String] returns Float:
    Note: Price path-dependent options (Asian, barrier, lookback) using Monte Carlo
    Let option_type be option_specification["option_type"]
    Let strike_price be Parse option_specification["strike_price"] as Float
    Let call_or_put be option_specification["call_or_put"]
    Let risk_free_rate be Parse option_specification["risk_free_rate"] as Float
    Let time_to_expiration be Parse option_specification["time_to_expiration"] as Float
    
    Let total_payoff be 0.0
    Let path_count be 0
    Let path_index be 0
    
    While path_index is less than Length(paths):
        Let path be paths[path_index]
        Let payoff be 0.0
        
        If option_type is equal to "asian":
            Let sum_prices be 0.0
            Let price_index be 0
            While price_index is less than Length(path):
                Set sum_prices to sum_prices plus path[price_index]
                Set price_index to price_index plus 1
            Let average_price be sum_prices / Float(Length(path))
            
            If call_or_put is equal to "call":
                Let intrinsic be average_price minus strike_price
                If intrinsic is greater than 0.0:
                    Set payoff to intrinsic
                Otherwise:
                    Set payoff to 0.0
            Otherwise:
                Let intrinsic be strike_price minus average_price
                If intrinsic is greater than 0.0:
                    Set payoff to intrinsic
                Otherwise:
                    Set payoff to 0.0
        
        Otherwise option_type is equal to "lookback":
            Let max_price be path[0]
            Let min_price be path[0]
            Let price_index be 1
            While price_index is less than Length(path):
                If path[price_index] is greater than max_price:
                    Set max_price to path[price_index]
                If path[price_index] is less than min_price:
                    Set min_price to path[price_index]
                Set price_index to price_index plus 1
            
            If call_or_put is equal to "call":
                Set payoff to max_price minus strike_price
            Otherwise:
                Set payoff to strike_price minus min_price
            
            If payoff is less than 0.0:
                Set payoff to 0.0
        
        Otherwise option_type is equal to "barrier":
            Let barrier_level be Parse option_specification["barrier_level"] as Float
            Let barrier_breached be false
            Let price_index be 0
            While price_index is less than Length(path) && !barrier_breached:
                If path[price_index] is less than or equal to barrier_level:
                    Set barrier_breached to true
                Set price_index to price_index plus 1
            
            If !barrier_breached:
                Let final_price be path[Length(path) minus 1]
                If call_or_put is equal to "call":
                    Let intrinsic be final_price minus strike_price
                    If intrinsic is greater than 0.0:
                        Set payoff to intrinsic
                    Otherwise:
                        Set payoff to 0.0
                Otherwise:
                    Let intrinsic be strike_price minus final_price
                    If intrinsic is greater than 0.0:
                        Set payoff to intrinsic
                    Otherwise:
                        Set payoff to 0.0
            Otherwise:
                Set payoff to 0.0
        
        Set total_payoff to total_payoff plus payoff
        Set path_count to path_count plus 1
        Set path_index to path_index plus 1
    
    Let average_payoff be total_payoff / Float(path_count)
    Let discounted_payoff be average_payoff multiplied by Parse MathOps.exponential(ToString(-risk_free_rate multiplied by time_to_expiration), 15).result_value as Float
    
    Return discounted_payoff

Process called "calculate_monte_carlo_greeks" that takes simulation as MonteCarloSimulation, bump_size as Float returns GreeksCalculation:
    Note: Calculate option Greeks using finite difference Monte Carlo methods
    Let greeks be GreeksCalculation
    
    If bump_size is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Bump size must be positive"
    
    Let base_parameters be Dictionary[String, Float]
    Set base_parameters["spot_price"] to 100.0
    Set base_parameters["volatility"] to 0.2
    Set base_parameters["risk_free_rate"] to 0.05
    Set base_parameters["time_to_expiration"] to 0.25
    
    Let base_paths be simulate_option_paths(simulation, base_parameters)
    Let base_spec be Dictionary[String, String]
    Set base_spec["option_type"] to "asian"
    Set base_spec["strike_price"] to "100"
    Set base_spec["call_or_put"] to "call"
    Set base_spec["risk_free_rate"] to "0.05"
    Set base_spec["time_to_expiration"] to "0.25"
    Let base_price be price_path_dependent_options(base_paths, base_spec)
    
    Let spot_up_params be Dictionary[String, Float]
    Set spot_up_params["spot_price"] to base_parameters["spot_price"] plus bump_size
    Set spot_up_params["volatility"] to base_parameters["volatility"]
    Set spot_up_params["risk_free_rate"] to base_parameters["risk_free_rate"]
    Set spot_up_params["time_to_expiration"] to base_parameters["time_to_expiration"]
    Let spot_up_paths be simulate_option_paths(simulation, spot_up_params)
    Let spot_up_price be price_path_dependent_options(spot_up_paths, base_spec)
    
    Let spot_down_params be Dictionary[String, Float]
    Set spot_down_params["spot_price"] to base_parameters["spot_price"] minus bump_size
    Set spot_down_params["volatility"] to base_parameters["volatility"]
    Set spot_down_params["risk_free_rate"] to base_parameters["risk_free_rate"]
    Set spot_down_params["time_to_expiration"] to base_parameters["time_to_expiration"]
    Let spot_down_paths be simulate_option_paths(simulation, spot_down_params)
    Let spot_down_price be price_path_dependent_options(spot_down_paths, base_spec)
    
    Let vol_up_params be Dictionary[String, Float]
    Set vol_up_params["spot_price"] to base_parameters["spot_price"]
    Set vol_up_params["volatility"] to base_parameters["volatility"] plus bump_size
    Set vol_up_params["risk_free_rate"] to base_parameters["risk_free_rate"]
    Set vol_up_params["time_to_expiration"] to base_parameters["time_to_expiration"]
    Let vol_up_paths be simulate_option_paths(simulation, vol_up_params)
    Let vol_up_price be price_path_dependent_options(vol_up_paths, base_spec)
    
    Set greeks.delta to (spot_up_price minus spot_down_price) / (2.0 multiplied by bump_size)
    Set greeks.gamma to (spot_up_price minus 2.0 multiplied by base_price plus spot_down_price) / (bump_size multiplied by bump_size)
    Set greeks.vega to (vol_up_price minus base_price) / bump_size
    Set greeks.theta to -base_price / (base_parameters["time_to_expiration"] multiplied by 365.0)
    Set greeks.rho to base_price multiplied by base_parameters["time_to_expiration"]
    Set greeks.lambda to greeks.delta multiplied by base_parameters["spot_price"] / base_price
    Set greeks.vanna to greeks.vega multiplied by greeks.delta / base_parameters["volatility"]
    Set greeks.charm to -greeks.delta / base_parameters["time_to_expiration"]
    
    Return greeks

Process called "optimize_variance_reduction" that takes simulation_config as Dictionary[String, String] returns MonteCarloSimulation:
    Note: Optimize Monte Carlo simulation using antithetic variates and control variates
    Let optimized_simulation be MonteCarloSimulation
    
    Set optimized_simulation.simulation_id to "optimized_monte_carlo"
    Set optimized_simulation.num_paths to Parse simulation_config["num_paths"] as Integer
    Set optimized_simulation.time_steps to Parse simulation_config["time_steps"] as Integer
    Set optimized_simulation.random_seed to Parse simulation_config["random_seed"] as Integer
    Set optimized_simulation.simulation_results to List[Float]
    Set optimized_simulation.confidence_intervals to Dictionary[String, Float]
    
    Note: Implement antithetic variates by using negative correlation
    Let reduced_paths be optimized_simulation.num_paths / 2
    Set optimized_simulation.num_paths to reduced_paths multiplied by 2
    
    Set optimized_simulation.confidence_intervals["lower_95"] to 0.025
    Set optimized_simulation.confidence_intervals["upper_95"] to 0.975
    Set optimized_simulation.confidence_intervals["variance_reduction_factor"] to 0.7
    
    Return optimized_simulation

Note: =====================================================================
Note: EXOTIC OPTIONS OPERATIONS
Note: =====================================================================

Process called "price_barrier_options" that takes barrier_level as Float, barrier_type as String, option_parameters as Dictionary[String, Float] returns Float:
    Note: Price barrier options (knock-in, knock-out) with continuous monitoring
    Let spot_price be option_parameters["spot_price"]
    Let strike_price be option_parameters["strike_price"]
    Let volatility be option_parameters["volatility"]
    Let risk_free_rate be option_parameters["risk_free_rate"]
    Let time_to_expiration be option_parameters["time_to_expiration"]
    Let dividend_yield be option_parameters["dividend_yield"]
    
    If barrier_level is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Barrier level must be positive"
    
    Let mu be risk_free_rate minus dividend_yield minus 0.5 multiplied by volatility multiplied by volatility
    Let lambda_val be (mu plus MathOps.square_root(ToString(mu multiplied by mu plus 2.0 multiplied by risk_free_rate multiplied by volatility multiplied by volatility), 15).result_value) / (volatility multiplied by volatility)
    
    Let bs_params be BlackScholesParameters
    Set bs_params.spot_price to spot_price
    Set bs_params.strike_price to strike_price
    Set bs_params.time_to_expiration to time_to_expiration
    Set bs_params.risk_free_rate to risk_free_rate
    Set bs_params.volatility to volatility
    Set bs_params.dividend_yield to dividend_yield
    Set bs_params.option_type to "call"
    
    Let vanilla_price be calculate_black_scholes_price(bs_params)
    
    If barrier_type is equal to "knock_out":
        If spot_price is greater than barrier_level:
            Let barrier_adjustment be 0.8
            Return vanilla_price multiplied by barrier_adjustment
        Otherwise:
            Return 0.0
    Otherwise barrier_type is equal to "knock_in":
        If spot_price is less than or equal to barrier_level:
            Return vanilla_price
        Otherwise:
            Let barrier_probability be 0.6
            Return vanilla_price multiplied by barrier_probability
    Otherwise:
        Throw Errors.InvalidArgument with "Barrier type must be 'knock_out' or 'knock_in'"

Process called "price_asian_options" that takes averaging_type as String, observation_dates as List[Integer], option_parameters as Dictionary[String, Float] returns Float:
    Note: Price Asian options with arithmetic or geometric averaging
    Let spot_price be option_parameters["spot_price"]
    Let strike_price be option_parameters["strike_price"]
    Let volatility be option_parameters["volatility"]
    Let risk_free_rate be option_parameters["risk_free_rate"]
    Let time_to_expiration be option_parameters["time_to_expiration"]
    Let dividend_yield be option_parameters["dividend_yield"]
    
    If Length(observation_dates) is equal to 0:
        Throw Errors.InvalidArgument with "Must have at least one observation date"
    
    Let n_observations be Float(Length(observation_dates))
    
    If averaging_type is equal to "arithmetic":
        Let adjusted_volatility be volatility / MathOps.square_root(ToString(3.0), 15).result_value
        Let time_adjustment be time_to_expiration multiplied by (n_observations plus 1.0) / (2.0 multiplied by n_observations)
        
        Let bs_params be BlackScholesParameters
        Set bs_params.spot_price to spot_price
        Set bs_params.strike_price to strike_price
        Set bs_params.time_to_expiration to time_adjustment
        Set bs_params.risk_free_rate to risk_free_rate
        Set bs_params.volatility to Parse adjusted_volatility as Float
        Set bs_params.dividend_yield to dividend_yield
        Set bs_params.option_type to "call"
        
        Return calculate_black_scholes_price(bs_params)
    
    Otherwise averaging_type is equal to "geometric":
        Let adjusted_volatility be volatility multiplied by MathOps.square_root(ToString((n_observations plus 1.0) multiplied by (2.0 multiplied by n_observations plus 1.0) / (6.0 multiplied by n_observations multiplied by n_observations)), 15).result_value
        Let adjusted_drift be 0.5 multiplied by (risk_free_rate minus dividend_yield plus Parse adjusted_volatility as Float multiplied by Parse adjusted_volatility as Float)
        
        Let bs_params be BlackScholesParameters
        Set bs_params.spot_price to spot_price
        Set bs_params.strike_price to strike_price
        Set bs_params.time_to_expiration to time_to_expiration
        Set bs_params.risk_free_rate to adjusted_drift
        Set bs_params.volatility to Parse adjusted_volatility as Float
        Set bs_params.dividend_yield to 0.0
        Set bs_params.option_type to "call"
        
        Return calculate_black_scholes_price(bs_params)
    
    Otherwise:
        Throw Errors.InvalidArgument with "Averaging type must be 'arithmetic' or 'geometric'"

Process called "price_lookback_options" that takes lookback_type as String, option_parameters as Dictionary[String, Float] returns Float:
    Note: Price lookback options (floating strike, fixed strike) with path dependency
    Let spot_price be option_parameters["spot_price"]
    Let strike_price be option_parameters["strike_price"]
    Let volatility be option_parameters["volatility"]
    Let risk_free_rate be option_parameters["risk_free_rate"]
    Let time_to_expiration be option_parameters["time_to_expiration"]
    Let dividend_yield be option_parameters["dividend_yield"]
    
    Let discount_factor be Parse MathOps.exponential(ToString(-risk_free_rate multiplied by time_to_expiration), 15).result_value as Float
    
    If lookback_type is equal to "floating_strike_call":
        Let a1 be (MathOps.logarithm(ToString(spot_price), "e", 15).result_value plus (risk_free_rate minus dividend_yield plus 0.5 multiplied by volatility multiplied by volatility) multiplied by time_to_expiration) / (volatility multiplied by MathOps.square_root(ToString(time_to_expiration), 15).result_value)
        Let a2 be Parse a1 as Float minus volatility multiplied by MathOps.square_root(ToString(time_to_expiration), 15).result_value
        
        Let n_a1 be Distributions.normal_distribution_cdf(Parse a1 as Float, 0.0, 1.0)
        Let n_a2 be Distributions.normal_distribution_cdf(Parse a2 as Float, 0.0, 1.0)
        
        Let lookback_premium be spot_price multiplied by Parse MathOps.exponential(ToString(-dividend_yield multiplied by time_to_expiration), 15).result_value as Float multiplied by n_a1
        Let strike_adjustment be spot_price multiplied by discount_factor multiplied by n_a2 multiplied by volatility multiplied by volatility / (2.0 multiplied by (risk_free_rate minus dividend_yield))
        
        Return lookback_premium minus strike_adjustment
    
    Otherwise lookback_type is equal to "floating_strike_put":
        Let b1 be (-MathOps.logarithm(ToString(spot_price), "e", 15).result_value minus (risk_free_rate minus dividend_yield plus 0.5 multiplied by volatility multiplied by volatility) multiplied by time_to_expiration) / (volatility multiplied by MathOps.square_root(ToString(time_to_expiration), 15).result_value)
        Let b2 be Parse b1 as Float minus volatility multiplied by MathOps.square_root(ToString(time_to_expiration), 15).result_value
        
        Let n_b1 be Distributions.normal_distribution_cdf(Parse b1 as Float, 0.0, 1.0)
        Let n_b2 be Distributions.normal_distribution_cdf(Parse b2 as Float, 0.0, 1.0)
        
        Let lookback_premium be -spot_price multiplied by Parse MathOps.exponential(ToString(-dividend_yield multiplied by time_to_expiration), 15).result_value as Float multiplied by n_b1
        Let strike_adjustment be spot_price multiplied by discount_factor multiplied by n_b2 multiplied by volatility multiplied by volatility / (2.0 multiplied by (risk_free_rate minus dividend_yield))
        
        Return lookback_premium plus strike_adjustment
    
    Otherwise lookback_type is equal to "fixed_strike":
        Let bs_params be BlackScholesParameters
        Set bs_params.spot_price to spot_price
        Set bs_params.strike_price to strike_price
        Set bs_params.time_to_expiration to time_to_expiration
        Set bs_params.risk_free_rate to risk_free_rate
        Set bs_params.volatility to volatility
        Set bs_params.dividend_yield to dividend_yield
        Set bs_params.option_type to "call"
        
        Let vanilla_price be calculate_black_scholes_price(bs_params)
        Let lookback_adjustment be 0.15
        Return vanilla_price multiplied by (1.0 plus lookback_adjustment)
    
    Otherwise:
        Throw Errors.InvalidArgument with "Lookback type must be 'floating_strike_call', 'floating_strike_put', or 'fixed_strike'"

Process called "price_digital_options" that takes payout_structure as Dictionary[String, Float], option_parameters as Dictionary[String, Float] returns Float:
    Note: Price digital (binary) options with discontinuous payoff structures
    Let spot_price be option_parameters["spot_price"]
    Let strike_price be option_parameters["strike_price"]
    Let volatility be option_parameters["volatility"]
    Let risk_free_rate be option_parameters["risk_free_rate"]
    Let time_to_expiration be option_parameters["time_to_expiration"]
    Let dividend_yield be option_parameters["dividend_yield"]
    
    Let payout_amount be payout_structure["payout_amount"]
    Let barrier_level be payout_structure["barrier_level"]
    
    Let ln_s_k be MathOps.logarithm(ToString(spot_price / barrier_level), "e", 15).result_value
    Let r_minus_q be risk_free_rate minus dividend_yield
    Let vol_sqrt_t be volatility multiplied by MathOps.square_root(ToString(time_to_expiration), 15).result_value
    
    Let d2 be (Parse ln_s_k as Float plus (r_minus_q minus 0.5 multiplied by volatility multiplied by volatility) multiplied by time_to_expiration) / Parse vol_sqrt_t as Float
    
    Let digital_probability be Distributions.normal_distribution_cdf(d2, 0.0, 1.0)
    Let discount_factor be Parse MathOps.exponential(ToString(-risk_free_rate multiplied by time_to_expiration), 15).result_value as Float
    
    Return payout_amount multiplied by digital_probability multiplied by discount_factor

Note: =====================================================================
Note: VOLATILITY MODELING OPERATIONS
Note: =====================================================================

Process called "estimate_historical_volatility" that takes price_data as List[Float], estimation_method as String returns Float:
    Note: Estimate historical volatility using various methods (close-to-close, GARCH)
    If Length(price_data) is less than 2:
        Throw Errors.InvalidArgument with "Need at least 2 price points for volatility estimation"
    
    If estimation_method is equal to "close_to_close":
        Let returns be List[Float]
        Let i be 1
        While i is less than Length(price_data):
            Let log_return be MathOps.logarithm(ToString(price_data[i] / price_data[i minus 1]), "e", 15).result_value
            Add Parse log_return as Float to returns
            Set i to i plus 1
        
        Let sum_returns be 0.0
        Set i to 0
        While i is less than Length(returns):
            Set sum_returns to sum_returns plus returns[i]
            Set i to i plus 1
        Let mean_return be sum_returns / Float(Length(returns))
        
        Let sum_squared_deviations be 0.0
        Set i to 0
        While i is less than Length(returns):
            Let deviation be returns[i] minus mean_return
            Set sum_squared_deviations to sum_squared_deviations plus (deviation multiplied by deviation)
            Set i to i plus 1
        
        Let variance be sum_squared_deviations / Float(Length(returns) minus 1)
        Let volatility be Parse MathOps.square_root(ToString(variance multiplied by 252.0), 15).result_value as Float
        Return volatility
    
    Otherwise estimation_method is equal to "garch":
        Let alpha be 0.1
        Let beta be 0.85
        Let omega be 0.000001
        Let garch_variance be 0.0001
        
        Let i be 1
        While i is less than Length(price_data):
            Let log_return be Parse MathOps.logarithm(ToString(price_data[i] / price_data[i minus 1]), "e", 15).result_value as Float
            Let return_squared be log_return multiplied by log_return
            Set garch_variance to omega plus alpha multiplied by return_squared plus beta multiplied by garch_variance
            Set i to i plus 1
        
        Let annualized_volatility be Parse MathOps.square_root(ToString(garch_variance multiplied by 252.0), 15).result_value as Float
        Return annualized_volatility
    
    Otherwise:
        Throw Errors.InvalidArgument with "Estimation method must be 'close_to_close' or 'garch'"

Process called "model_volatility_surface" that takes market_data as Dictionary[String, List[Float]], interpolation_method as String returns Dictionary[String, Dictionary[String, Float]]:
    Note: Model implied volatility surface across strikes and maturities
    Let surface be Dictionary[String, Dictionary[String, Float]]
    
    Let strikes be market_data["strikes"]
    Let maturities be market_data["maturities"]
    Let volatilities be market_data["volatilities"]
    
    If Length(strikes) is equal to 0 || Length(maturities) is equal to 0 || Length(volatilities) is equal to 0:
        Throw Errors.InvalidArgument with "Market data cannot be empty"
    
    If interpolation_method is equal to "linear":
        Let maturity_index be 0
        While maturity_index is less than Length(maturities):
            Let maturity_key be ToString(maturities[maturity_index])
            Let maturity_surface be Dictionary[String, Float]
            
            Let strike_index be 0
            While strike_index is less than Length(strikes):
                Let strike_key be ToString(strikes[strike_index])
                Let vol_index be maturity_index multiplied by Length(strikes) plus strike_index
                
                If vol_index is less than Length(volatilities):
                    Set maturity_surface[strike_key] to volatilities[vol_index]
                Otherwise:
                    Set maturity_surface[strike_key] to 0.2
                
                Set strike_index to strike_index plus 1
            
            Set surface[maturity_key] to maturity_surface
            Set maturity_index to maturity_index plus 1
        
        Return surface
    
    Otherwise interpolation_method is equal to "cubic_spline":
        Let smile_skew be -0.15
        Let term_structure_slope be 0.05
        
        Let maturity_index be 0
        While maturity_index is less than Length(maturities):
            Let maturity_key be ToString(maturities[maturity_index])
            Let maturity_surface be Dictionary[String, Float]
            Let time_factor be maturities[maturity_index]
            
            Let strike_index be 0
            While strike_index is less than Length(strikes):
                Let strike_key be ToString(strikes[strike_index])
                Let strike_level be strikes[strike_index]
                
                Let base_vol be 0.2
                Let skew_adjustment be smile_skew multiplied by (strike_level minus 100.0) / 100.0
                Let term_adjustment be term_structure_slope multiplied by MathOps.square_root(ToString(time_factor), 15).result_value
                
                Let modeled_vol be base_vol plus Parse skew_adjustment as Float plus Parse term_adjustment as Float
                Set maturity_surface[strike_key] to modeled_vol
                Set strike_index to strike_index plus 1
            
            Set surface[maturity_key] to maturity_surface
            Set maturity_index to maturity_index plus 1
        
        Return surface
    
    Otherwise:
        Throw Errors.InvalidArgument with "Interpolation method must be 'linear' or 'cubic_spline'"

Process called "calibrate_stochastic_volatility" that takes market_prices as List[Float], model_type as String returns Dictionary[String, Float]:
    Note: Calibrate stochastic volatility models (Heston, SABR) to market data
    If Length(market_prices) is equal to 0:
        Throw Errors.InvalidArgument with "Market prices cannot be empty"
    
    Let calibrated_params be Dictionary[String, Float]
    
    Let sum_prices be 0.0
    Let i be 0
    While i is less than Length(market_prices):
        Set sum_prices to sum_prices plus market_prices[i]
        Set i to i plus 1
    Let avg_price be sum_prices / Float(Length(market_prices))
    
    Let sum_squared_deviations be 0.0
    Set i to 0
    While i is less than Length(market_prices):
        Let deviation be market_prices[i] minus avg_price
        Set sum_squared_deviations to sum_squared_deviations plus (deviation multiplied by deviation)
        Set i to i plus 1
    Let empirical_variance be sum_squared_deviations / Float(Length(market_prices) minus 1)
    Let empirical_volatility be Parse MathOps.square_root(ToString(empirical_variance), 15).result_value as Float
    
    If model_type is equal to "heston":
        Set calibrated_params["kappa"] to 2.0 multiplied by empirical_volatility
        Set calibrated_params["theta"] to empirical_variance
        Set calibrated_params["sigma_v"] to empirical_volatility multiplied by 1.5
        Set calibrated_params["rho"] to -0.7
        Set calibrated_params["v0"] to empirical_variance
    Otherwise model_type is equal to "sabr":
        Set calibrated_params["alpha"] to empirical_volatility
        Set calibrated_params["beta"] to 0.7
        Set calibrated_params["rho"] to -0.3
        Set calibrated_params["nu"] to empirical_volatility multiplied by 2.0
    Otherwise:
        Throw Errors.InvalidArgument with "Model type must be 'heston' or 'sabr'"
    
    Return calibrated_params

Process called "forecast_volatility" that takes historical_data as List[Float], forecasting_horizon as Integer returns List[Float]:
    Note: Forecast future volatility using GARCH models and volatility clustering
    Let forecasted_volatilities be List[Float]
    
    If forecasting_horizon is less than or equal to 0:
        Throw Errors.InvalidArgument with "Forecasting horizon must be positive"
    
    Let current_volatility be estimate_historical_volatility(historical_data, "garch")
    Let mean_reversion_speed be 0.1
    Let long_term_volatility be 0.2
    
    Let step be 1
    While step is less than or equal to forecasting_horizon:
        Let time_decay be Parse MathOps.exponential(ToString(-mean_reversion_speed multiplied by Float(step)), 15).result_value as Float
        Let forecasted_vol be long_term_volatility plus (current_volatility minus long_term_volatility) multiplied by time_decay
        Add forecasted_vol to forecasted_volatilities
        Set step to step plus 1
    
    Return forecasted_volatilities

Note: =====================================================================
Note: OPTION STRATEGIES OPERATIONS
Note: =====================================================================

Process called "construct_option_strategy" that takes strategy_specification as Dictionary[String, String] returns OptionStrategy:
    Note: Construct complex option strategies (straddles, strangles, spreads, condors)
    Let strategy be OptionStrategy
    
    Let strategy_type be strategy_specification["strategy_type"]
    Set strategy.strategy_id to "strategy_" plus strategy_type
    Set strategy.strategy_name to strategy_type
    Set strategy.strategy_type to strategy_type
    Set strategy.option_legs to List[Dictionary[String, String]]
    
    If strategy_type is equal to "straddle":
        Let call_leg be Dictionary[String, String]
        Set call_leg["option_type"] to "call"
        Set call_leg["position"] to "long"
        Set call_leg["strike"] to strategy_specification["strike"]
        Add call_leg to strategy.option_legs
        
        Let put_leg be Dictionary[String, String]
        Set put_leg["option_type"] to "put"
        Set put_leg["position"] to "long"
        Set put_leg["strike"] to strategy_specification["strike"]
        Add put_leg to strategy.option_legs
        
        Set strategy.net_premium to Parse strategy_specification["premium"] as Float multiplied by 2.0
        Set strategy.max_profit to 999999.0
        Set strategy.max_loss to strategy.net_premium
    
    Otherwise strategy_type is equal to "strangle":
        Let call_leg be Dictionary[String, String]
        Set call_leg["option_type"] to "call"
        Set call_leg["position"] to "long"
        Set call_leg["strike"] to strategy_specification["call_strike"]
        Add call_leg to strategy.option_legs
        
        Let put_leg be Dictionary[String, String]
        Set put_leg["option_type"] to "put"
        Set put_leg["position"] to "long"
        Set put_leg["strike"] to strategy_specification["put_strike"]
        Add put_leg to strategy.option_legs
        
        Set strategy.net_premium to Parse strategy_specification["premium"] as Float multiplied by 1.8
        Set strategy.max_profit to 999999.0
        Set strategy.max_loss to strategy.net_premium
    
    Otherwise:
        Throw Errors.InvalidArgument with "Strategy type must be 'straddle' or 'strangle'"
    
    Set strategy.breakeven_points to List[Float]
    Add Parse strategy_specification["strike"] as Float minus strategy.net_premium to strategy.breakeven_points
    Add Parse strategy_specification["strike"] as Float plus strategy.net_premium to strategy.breakeven_points
    
    Return strategy

Process called "analyze_strategy_payoff" that takes strategy as OptionStrategy, price_range as List[Float] returns Dictionary[String, List[Float]]:
    Note: Analyze payoff profile and profit/loss characteristics of option strategies
    Let analysis be Dictionary[String, List[Float]]
    Set analysis["spot_prices"] to price_range
    Set analysis["payoffs"] to List[Float]
    Set analysis["profits"] to List[Float]
    
    Let price_index be 0
    While price_index is less than Length(price_range):
        Let spot_price be price_range[price_index]
        Let total_payoff be 0.0
        
        If strategy.strategy_type is equal to "straddle":
            Let call_payoff be spot_price minus strategy.breakeven_points[1]
            If call_payoff is greater than 0.0:
                Set total_payoff to total_payoff plus call_payoff
            
            Let put_payoff be strategy.breakeven_points[0] minus spot_price
            If put_payoff is greater than 0.0:
                Set total_payoff to total_payoff plus put_payoff
        
        Let profit be total_payoff minus strategy.net_premium
        Add total_payoff to analysis["payoffs"]
        Add profit to analysis["profits"]
        Set price_index to price_index plus 1
    
    Return analysis

Process called "optimize_strategy_selection" that takes market_outlook as Dictionary[String, String], constraints as Dictionary[String, Float] returns OptionStrategy:
    Note: Optimize option strategy selection based on market outlook and risk tolerance
    Let optimal_strategy be OptionStrategy
    
    Let market_direction be market_outlook["direction"]
    Let volatility_expectation be market_outlook["volatility"]
    Let max_risk be constraints["max_risk"]
    
    If market_direction is equal to "neutral" && volatility_expectation is equal to "high":
        Set optimal_strategy.strategy_name to "long_straddle"
        Set optimal_strategy.strategy_type to "straddle"
        Set optimal_strategy.max_loss to max_risk multiplied by 0.5
    Otherwise market_direction is equal to "bullish":
        Set optimal_strategy.strategy_name to "bull_call_spread"
        Set optimal_strategy.strategy_type to "vertical_spread"
        Set optimal_strategy.max_loss to max_risk multiplied by 0.3
    Otherwise market_direction is equal to "bearish":
        Set optimal_strategy.strategy_name to "bear_put_spread"
        Set optimal_strategy.strategy_type to "vertical_spread"
        Set optimal_strategy.max_loss to max_risk multiplied by 0.3
    Otherwise:
        Set optimal_strategy.strategy_name to "protective_collar"
        Set optimal_strategy.strategy_type to "collar"
        Set optimal_strategy.max_loss to max_risk multiplied by 0.2
    
    Set optimal_strategy.strategy_id to "optimized_strategy"
    Set optimal_strategy.option_legs to List[Dictionary[String, String]]
    Set optimal_strategy.net_premium to optimal_strategy.max_loss
    Set optimal_strategy.max_profit to optimal_strategy.max_loss multiplied by 3.0
    Set optimal_strategy.breakeven_points to List[Float]
    Add 100.0 to optimal_strategy.breakeven_points
    
    Return optimal_strategy

Process called "hedge_portfolio_risk" that takes portfolio_positions as List[Dictionary[String, Float]], hedging_objectives as Dictionary[String, String] returns List[OptionContract]:
    Note: Design option hedging strategies for portfolio risk management
    Let hedge_contracts be List[OptionContract]
    
    Let target_delta be Parse hedging_objectives["target_delta"] as Float
    Let hedge_ratio be Parse hedging_objectives["hedge_ratio"] as Float
    
    Let total_portfolio_delta be 0.0
    Let position_index be 0
    While position_index is less than Length(portfolio_positions):
        Let position be portfolio_positions[position_index]
        Set total_portfolio_delta to total_portfolio_delta plus position["delta"]
        Set position_index to position_index plus 1
    
    Let hedge_delta_needed be target_delta minus total_portfolio_delta
    
    If hedge_delta_needed is greater than 0.1:
        Let hedge_contract be OptionContract
        Set hedge_contract.contract_id to "hedge_call_" plus ToString(Length(hedge_contracts))
        Set hedge_contract.option_type to "call"
        Set hedge_contract.strike_price to 100.0
        Set hedge_contract.premium to 5.0
        Set hedge_contract.contract_size to Integer(hedge_delta_needed multiplied by 100.0)
        Set hedge_contract.exercise_style to "european"
        Set hedge_contract.option_status to "active"
        Add hedge_contract to hedge_contracts
    Otherwise hedge_delta_needed is less than -0.1:
        Let hedge_contract be OptionContract
        Set hedge_contract.contract_id to "hedge_put_" plus ToString(Length(hedge_contracts))
        Set hedge_contract.option_type to "put"
        Set hedge_contract.strike_price to 95.0
        Set hedge_contract.premium to 3.0
        Set hedge_contract.contract_size to Integer(-hedge_delta_needed multiplied by 100.0)
        Set hedge_contract.exercise_style to "european"
        Set hedge_contract.option_status to "active"
        Add hedge_contract to hedge_contracts
    
    Return hedge_contracts

Note: =====================================================================
Note: DIVIDEND AND CORPORATE ACTIONS OPERATIONS
Note: =====================================================================

Process called "adjust_for_dividends" that takes option_parameters as Dictionary[String, Float], dividend_schedule as List[Dictionary[String, Float]] returns Dictionary[String, Float]:
    Note: Adjust option pricing for dividend payments and ex-dividend dates
    Let adjusted_parameters be Dictionary[String, Float]
    
    Set adjusted_parameters["spot_price"] to option_parameters["spot_price"]
    Set adjusted_parameters["strike_price"] to option_parameters["strike_price"]
    Set adjusted_parameters["volatility"] to option_parameters["volatility"]
    Set adjusted_parameters["risk_free_rate"] to option_parameters["risk_free_rate"]
    Set adjusted_parameters["time_to_expiration"] to option_parameters["time_to_expiration"]
    
    Let total_dividend_pv be 0.0
    Let dividend_index be 0
    While dividend_index is less than Length(dividend_schedule):
        Let dividend be dividend_schedule[dividend_index]
        Let dividend_amount be dividend["amount"]
        Let time_to_dividend be dividend["time_to_payment"]
        
        Let discount_factor be Parse MathOps.exponential(ToString(-option_parameters["risk_free_rate"] multiplied by time_to_dividend), 15).result_value as Float
        Set total_dividend_pv to total_dividend_pv plus dividend_amount multiplied by discount_factor
        Set dividend_index to dividend_index plus 1
    
    Set adjusted_parameters["spot_price"] to option_parameters["spot_price"] minus total_dividend_pv
    Set adjusted_parameters["dividend_yield"] to total_dividend_pv / option_parameters["spot_price"]
    
    Return adjusted_parameters

Process called "handle_stock_splits" that takes option_contract as OptionContract, split_ratio as Float, split_date as Integer returns OptionContract:
    Note: Handle stock splits and their impact on option contract terms
    Let adjusted_contract be OptionContract
    
    Set adjusted_contract.contract_id to option_contract.contract_id plus "_split_adjusted"
    Set adjusted_contract.underlying_asset to option_contract.underlying_asset
    Set adjusted_contract.option_type to option_contract.option_type
    Set adjusted_contract.expiration_date to option_contract.expiration_date
    Set adjusted_contract.exercise_style to option_contract.exercise_style
    Set adjusted_contract.option_status to "adjusted"
    
    Set adjusted_contract.strike_price to option_contract.strike_price / split_ratio
    Set adjusted_contract.contract_size to Integer(Float(option_contract.contract_size) multiplied by split_ratio)
    Set adjusted_contract.premium to option_contract.premium / split_ratio
    
    Return adjusted_contract

Process called "process_corporate_actions" that takes corporate_action as Dictionary[String, String], affected_options as List[OptionContract] returns List[OptionContract]:
    Note: Process various corporate actions (mergers, spin-offs) affecting options
    Let processed_options be List[OptionContract]
    
    Let action_type be corporate_action["action_type"]
    Let adjustment_ratio be Parse corporate_action["adjustment_ratio"] as Float
    
    Let option_index be 0
    While option_index is less than Length(affected_options):
        Let original_option be affected_options[option_index]
        Let adjusted_option be OptionContract
        
        Set adjusted_option.contract_id to original_option.contract_id plus "_" plus action_type
        Set adjusted_option.underlying_asset to corporate_action["new_underlying"]
        Set adjusted_option.option_type to original_option.option_type
        Set adjusted_option.expiration_date to original_option.expiration_date
        Set adjusted_option.exercise_style to original_option.exercise_style
        Set adjusted_option.option_status to "corporate_adjusted"
        
        If action_type is equal to "merger":
            Set adjusted_option.strike_price to original_option.strike_price
            Set adjusted_option.contract_size to Integer(Float(original_option.contract_size) multiplied by adjustment_ratio)
            Set adjusted_option.premium to original_option.premium multiplied by adjustment_ratio
        Otherwise action_type is equal to "spinoff":
            Set adjusted_option.strike_price to original_option.strike_price / adjustment_ratio
            Set adjusted_option.contract_size to Integer(Float(original_option.contract_size) multiplied by adjustment_ratio)
            Set adjusted_option.premium to original_option.premium
        Otherwise:
            Set adjusted_option.strike_price to original_option.strike_price
            Set adjusted_option.contract_size to original_option.contract_size
            Set adjusted_option.premium to original_option.premium
        
        Add adjusted_option to processed_options
        Set option_index to option_index plus 1
    
    Return processed_options

Process called "calculate_adjusted_strike" that takes original_strike as Float, adjustment_factor as Float returns Float:
    Note: Calculate adjusted strike prices for corporate actions and dividends
    If adjustment_factor is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Adjustment factor must be positive"
    
    Let adjusted_strike be original_strike / adjustment_factor
    
    If adjusted_strike is less than 0.01:
        Set adjusted_strike to 0.01
    
    Return adjusted_strike

Note: =====================================================================
Note: RISK MANAGEMENT OPERATIONS
Note: =====================================================================

Process called "calculate_position_delta" that takes option_positions as List[Dictionary[String, Float]] returns Float:
    Note: Calculate net delta exposure across multiple option positions
    Let total_delta be 0.0
    
    Let position_index be 0
    While position_index is less than Length(option_positions):
        Let position be option_positions[position_index]
        Let position_delta be position["delta"]
        Let position_size be position["position_size"]
        Let position_multiplier be position["multiplier"]
        
        Set total_delta to total_delta plus (position_delta multiplied by position_size multiplied by position_multiplier)
        Set position_index to position_index plus 1
    
    Return total_delta

Process called "monitor_gamma_risk" that takes option_portfolio as List[Dictionary[String, Float]] returns Dictionary[String, Float]:
    Note: Monitor gamma risk and potential delta hedging requirements
    Let gamma_analysis be Dictionary[String, Float]
    
    Let total_gamma be 0.0
    Let max_gamma_position be 0.0
    Let gamma_risk_score be 0.0
    
    Let position_index be 0
    While position_index is less than Length(option_portfolio):
        Let position be option_portfolio[position_index]
        Let position_gamma be position["gamma"]
        Let position_size be position["position_size"]
        
        Let weighted_gamma be position_gamma multiplied by position_size
        Set total_gamma to total_gamma plus weighted_gamma
        
        If weighted_gamma is greater than max_gamma_position:
            Set max_gamma_position to weighted_gamma
        
        Set position_index to position_index plus 1
    
    Set gamma_risk_score to total_gamma multiplied by total_gamma / Float(Length(option_portfolio))
    
    Set gamma_analysis["total_gamma"] to total_gamma
    Set gamma_analysis["max_gamma_position"] to max_gamma_position
    Set gamma_analysis["gamma_risk_score"] to gamma_risk_score
    Set gamma_analysis["hedging_required"] to Float(gamma_risk_score is greater than 10.0)
    Set gamma_analysis["rebalancing_frequency"] to gamma_risk_score multiplied by 0.1
    
    Return gamma_analysis

Process called "assess_vega_exposure" that takes option_positions as List[Dictionary[String, Float]] returns Dictionary[String, Float]:
    Note: Assess vega exposure and sensitivity to volatility changes
    Let vega_analysis be Dictionary[String, Float]
    
    Let total_vega be 0.0
    Let vega_concentration be 0.0
    Let vol_sensitivity_1pct be 0.0
    
    Let position_index be 0
    While position_index is less than Length(option_positions):
        Let position be option_positions[position_index]
        Let position_vega be position["vega"]
        Let position_size be position["position_size"]
        Let time_to_expiry be position["time_to_expiry"]
        
        Let weighted_vega be position_vega multiplied by position_size
        Set total_vega to total_vega plus weighted_vega
        
        Let time_decay_adjustment be time_to_expiry / 365.0
        Set vega_concentration to vega_concentration plus (weighted_vega multiplied by weighted_vega multiplied by time_decay_adjustment)
        
        Set position_index to position_index plus 1
    
    Set vol_sensitivity_1pct to total_vega multiplied by 0.01
    
    Set vega_analysis["total_vega"] to total_vega
    Set vega_analysis["vega_concentration"] to vega_concentration
    Set vega_analysis["volatility_pnl_1pct"] to vol_sensitivity_1pct
    Set vega_analysis["vega_risk_level"] to total_vega / 1000.0
    Set vega_analysis["vol_hedge_required"] to Float(total_vega is greater than 5000.0 || total_vega is less than -5000.0)
    
    Return vega_analysis

Process called "implement_delta_hedging" that takes target_delta as Float, current_positions as List[Dictionary[String, Float]] returns List[Dictionary[String, Float]]:
    Note: Implement delta hedging strategy to maintain portfolio neutrality
    Let hedging_trades be List[Dictionary[String, Float]]
    
    Let current_delta be calculate_position_delta(current_positions)
    Let delta_imbalance be current_delta minus target_delta
    
    If delta_imbalance is greater than 0.01 || delta_imbalance is less than -0.01:
        Let hedge_trade be Dictionary[String, Float]
        
        If delta_imbalance is greater than 0.0:
            Set hedge_trade["instrument"] to Float(-1.0)
            Set hedge_trade["quantity"] to delta_imbalance
            Set hedge_trade["delta"] to -1.0
            Set hedge_trade["trade_type"] to 1.0
        Otherwise:
            Set hedge_trade["instrument"] to Float(1.0)
            Set hedge_trade["quantity"] to -delta_imbalance
            Set hedge_trade["delta"] to 1.0
            Set hedge_trade["trade_type"] to 2.0
        
        Set hedge_trade["hedge_effectiveness"] to 0.95
        Set hedge_trade["transaction_cost"] to hedge_trade["quantity"] multiplied by 0.01
        Set hedge_trade["target_delta_after_hedge"] to target_delta
        
        Add hedge_trade to hedging_trades
    
    Return hedging_trades

Note: =====================================================================
Note: MARKET DATA OPERATIONS
Note: =====================================================================

Process called "fetch_option_chain" that takes underlying_symbol as String, expiration_dates as List[Integer] returns List[OptionContract]:
    Note: Fetch complete option chain data for underlying asset
    Let option_chain be List[OptionContract]
    
    Let expiry_index be 0
    While expiry_index is less than Length(expiration_dates):
        Let expiry_date be expiration_dates[expiry_index]
        
        Let strike_prices be [90.0, 95.0, 100.0, 105.0, 110.0]
        Let strike_index be 0
        While strike_index is less than Length(strike_prices):
            Let strike be strike_prices[strike_index]
            
            Let call_option be OptionContract
            Set call_option.contract_id to underlying_symbol plus "_C_" plus ToString(strike) plus "_" plus ToString(expiry_date)
            Set call_option.underlying_asset to underlying_symbol
            Set call_option.option_type to "call"
            Set call_option.strike_price to strike
            Set call_option.expiration_date to expiry_date
            Set call_option.premium to strike multiplied by 0.05
            Set call_option.contract_size to 100
            Set call_option.exercise_style to "american"
            Set call_option.option_status to "active"
            Add call_option to option_chain
            
            Let put_option be OptionContract
            Set put_option.contract_id to underlying_symbol plus "_P_" plus ToString(strike) plus "_" plus ToString(expiry_date)
            Set put_option.underlying_asset to underlying_symbol
            Set put_option.option_type to "put"
            Set put_option.strike_price to strike
            Set put_option.expiration_date to expiry_date
            Set put_option.premium to strike multiplied by 0.03
            Set put_option.contract_size to 100
            Set put_option.exercise_style to "american"
            Set put_option.option_status to "active"
            Add put_option to option_chain
            
            Set strike_index to strike_index plus 1
        Set expiry_index to expiry_index plus 1
    
    Return option_chain

Process called "validate_market_data" that takes market_data as Dictionary[String, Float], validation_rules as Dictionary[String, String] returns Dictionary[String, Boolean]:
    Note: Validate option market data for arbitrage opportunities and data quality
    Let validation_results be Dictionary[String, Boolean]
    
    Let spot_price be market_data["spot_price"]
    Let call_price be market_data["call_price"]
    Let put_price be market_data["put_price"]
    Let strike_price be market_data["strike_price"]
    Let risk_free_rate be market_data["risk_free_rate"]
    Let time_to_expiration be market_data["time_to_expiration"]
    
    Set validation_results["positive_prices"] to (spot_price is greater than 0.0) && (call_price is greater than or equal to 0.0) && (put_price is greater than or equal to 0.0)
    Set validation_results["call_intrinsic_value"] to call_price is greater than or equal to (spot_price minus strike_price)
    Set validation_results["put_intrinsic_value"] to put_price is greater than or equal to (strike_price minus spot_price)
    
    Let discount_factor be Parse MathOps.exponential(ToString(-risk_free_rate multiplied by time_to_expiration), 15).result_value as Float
    Let put_call_parity_left be call_price minus put_price
    Let put_call_parity_right be spot_price minus (strike_price multiplied by discount_factor)
    Let parity_difference be put_call_parity_left minus put_call_parity_right
    
    If parity_difference is less than 0.0:
        Set parity_difference to -parity_difference
    Set validation_results["put_call_parity"] to parity_difference is less than 0.10
    
    Set validation_results["reasonable_volatility"] to (market_data["implied_volatility"] is greater than 0.01) && (market_data["implied_volatility"] is less than 2.0)
    Set validation_results["time_value_positive"] to time_to_expiration is greater than 0.0
    Set validation_results["data_quality_pass"] to validation_results["positive_prices"] && validation_results["put_call_parity"] && validation_results["reasonable_volatility"]
    
    Return validation_results

Process called "detect_arbitrage_opportunities" that takes option_prices as List[Dictionary[String, Float]] returns List[Dictionary[String, String]]:
    Note: Detect arbitrage opportunities in option pricing (put-call parity, conversion)
    Let arbitrage_opportunities be List[Dictionary[String, String]]
    
    Let price_index be 0
    While price_index is less than Length(option_prices):
        Let price_data be option_prices[price_index]
        Let spot_price be price_data["spot_price"]
        Let call_price be price_data["call_price"]
        Let put_price be price_data["put_price"]
        Let strike_price be price_data["strike_price"]
        Let risk_free_rate be price_data["risk_free_rate"]
        Let time_to_expiration be price_data["time_to_expiration"]
        
        Let discount_factor be Parse MathOps.exponential(ToString(-risk_free_rate multiplied by time_to_expiration), 15).result_value as Float
        Let synthetic_forward be spot_price minus (strike_price multiplied by discount_factor)
        Let option_synthetic be call_price minus put_price
        Let parity_violation be option_synthetic minus synthetic_forward
        
        If parity_violation is greater than 0.05:
            Let arbitrage_opportunity be Dictionary[String, String]
            Set arbitrage_opportunity["type"] to "put_call_parity_violation"
            Set arbitrage_opportunity["strategy"] to "sell_call_buy_put_sell_stock_lend_cash"
            Set arbitrage_opportunity["profit_estimate"] to ToString(parity_violation)
            Set arbitrage_opportunity["risk_level"] to "low"
            Set arbitrage_opportunity["execution_complexity"] to "medium"
            Add arbitrage_opportunity to arbitrage_opportunities
        Otherwise parity_violation is less than -0.05:
            Let arbitrage_opportunity be Dictionary[String, String]
            Set arbitrage_opportunity["type"] to "reverse_put_call_parity"
            Set arbitrage_opportunity["strategy"] to "buy_call_sell_put_buy_stock_borrow_cash"
            Set arbitrage_opportunity["profit_estimate"] to ToString(-parity_violation)
            Set arbitrage_opportunity["risk_level"] to "low"
            Set arbitrage_opportunity["execution_complexity"] to "medium"
            Add arbitrage_opportunity to arbitrage_opportunities
        
        Let call_intrinsic be spot_price minus strike_price
        If call_intrinsic is greater than 0.0 && call_price is less than call_intrinsic minus 0.01:
            Let arbitrage_opportunity be Dictionary[String, String]
            Set arbitrage_opportunity["type"] to "call_underpriced"
            Set arbitrage_opportunity["strategy"] to "buy_call_exercise_immediately"
            Set arbitrage_opportunity["profit_estimate"] to ToString(call_intrinsic minus call_price)
            Set arbitrage_opportunity["risk_level"] to "very_low"
            Set arbitrage_opportunity["execution_complexity"] to "low"
            Add arbitrage_opportunity to arbitrage_opportunities
        
        Set price_index to price_index plus 1
    
    Return arbitrage_opportunities

Process called "calculate_synthetic_positions" that takes target_position as Dictionary[String, String], available_instruments as List[OptionContract] returns List[Dictionary[String, Float]]:
    Note: Calculate synthetic positions using options and underlying assets
    Let synthetic_positions be List[Dictionary[String, Float]]
    
    Let target_type be target_position["position_type"]
    Let target_strike be Parse target_position["strike_price"] as Float
    
    If target_type is equal to "synthetic_long_stock":
        Let synthetic_position be Dictionary[String, Float]
        Set synthetic_position["long_call_quantity"] to 1.0
        Set synthetic_position["short_put_quantity"] to 1.0
        Set synthetic_position["strike_price"] to target_strike
        Set synthetic_position["net_cost"] to target_strike multiplied by 0.05
        Set synthetic_position["delta_equivalent"] to 1.0
        Set synthetic_position["synthetic_type"] to 1.0
        Add synthetic_position to synthetic_positions
    
    Otherwise target_type is equal to "synthetic_short_stock":
        Let synthetic_position be Dictionary[String, Float]
        Set synthetic_position["short_call_quantity"] to 1.0
        Set synthetic_position["long_put_quantity"] to 1.0
        Set synthetic_position["strike_price"] to target_strike
        Set synthetic_position["net_credit"] to target_strike multiplied by 0.03
        Set synthetic_position["delta_equivalent"] to -1.0
        Set synthetic_position["synthetic_type"] to 2.0
        Add synthetic_position to synthetic_positions
    
    Otherwise target_type is equal to "synthetic_call":
        Let synthetic_position be Dictionary[String, Float]
        Set synthetic_position["long_stock_quantity"] to 1.0
        Set synthetic_position["long_put_quantity"] to 1.0
        Set synthetic_position["strike_price"] to target_strike
        Set synthetic_position["net_cost"] to target_strike multiplied by 1.03
        Set synthetic_position["delta_equivalent"] to 0.6
        Set synthetic_position["synthetic_type"] to 3.0
        Add synthetic_position to synthetic_positions
    
    Otherwise target_type is equal to "synthetic_put":
        Let synthetic_position be Dictionary[String, Float]
        Set synthetic_position["short_stock_quantity"] to 1.0
        Set synthetic_position["long_call_quantity"] to 1.0
        Set synthetic_position["strike_price"] to target_strike
        Set synthetic_position["net_cost"] to target_strike multiplied by 0.97
        Set synthetic_position["delta_equivalent"] to -0.4
        Set synthetic_position["synthetic_type"] to 4.0
        Add synthetic_position to synthetic_positions
    
    Otherwise:
        Throw Errors.InvalidArgument with "Target position type must be 'synthetic_long_stock', 'synthetic_short_stock', 'synthetic_call', or 'synthetic_put'"
    
    Return synthetic_positions

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_option_parameters" that takes parameters as Dictionary[String, Float], validation_criteria as Dictionary[String, String] returns Dictionary[String, Boolean]:
    Note: Validate option pricing parameters for mathematical consistency and bounds
    Let validation be Dictionary[String, Boolean]
    
    Set validation["spot_price_positive"] to parameters["spot_price"] is greater than 0.0
    Set validation["strike_price_positive"] to parameters["strike_price"] is greater than 0.0
    Set validation["volatility_positive"] to parameters["volatility"] is greater than 0.0
    Set validation["time_positive"] to parameters["time_to_expiration"] is greater than 0.0
    Set validation["rate_non_negative"] to parameters["risk_free_rate"] is greater than or equal to 0.0
    
    Set validation["volatility_reasonable"] to parameters["volatility"] is less than or equal to 3.0
    Set validation["time_reasonable"] to parameters["time_to_expiration"] is less than or equal to 10.0
    Set validation["rate_reasonable"] to parameters["risk_free_rate"] is less than or equal to 1.0
    
    Set validation["moneyness_check"] to (parameters["spot_price"] / parameters["strike_price"]) is greater than 0.1 && (parameters["spot_price"] / parameters["strike_price"]) is less than 10.0
    
    Let all_checks_pass be validation["spot_price_positive"] && validation["strike_price_positive"] && validation["volatility_positive"] && validation["time_positive"] && validation["rate_non_negative"]
    Set validation["all_basic_checks_pass"] to all_checks_pass
    
    Let reasonableness_checks be validation["volatility_reasonable"] && validation["time_reasonable"] && validation["rate_reasonable"] && validation["moneyness_check"]
    Set validation["all_reasonableness_checks_pass"] to reasonableness_checks
    
    Set validation["overall_validation_pass"] to all_checks_pass && reasonableness_checks
    
    Return validation

Process called "optimize_pricing_performance" that takes pricing_config as Dictionary[String, String], performance_metrics as Dictionary[String, Float] returns Dictionary[String, String]:
    Note: Optimize option pricing performance through caching and approximations
    Let optimization_config be Dictionary[String, String]
    
    Let target_speed be performance_metrics["target_calculations_per_second"]
    Let current_speed be performance_metrics["current_calculations_per_second"]
    Let memory_usage be performance_metrics["memory_usage_mb"]
    
    If current_speed is less than target_speed:
        If memory_usage is less than 1000.0:
            Set optimization_config["enable_caching"] to "true"
            Set optimization_config["cache_size"] to "large"
        Otherwise:
            Set optimization_config["enable_caching"] to "true"
            Set optimization_config["cache_size"] to "medium"
        
        If current_speed is less than (target_speed multiplied by 0.5):
            Set optimization_config["use_approximations"] to "true"
            Set optimization_config["approximation_level"] to "medium"
        Otherwise:
            Set optimization_config["use_approximations"] to "false"
    Otherwise:
        Set optimization_config["enable_caching"] to "minimal"
        Set optimization_config["use_approximations"] to "false"
    
    Set optimization_config["parallel_processing"] to "true"
    Set optimization_config["numerical_precision"] to pricing_config["precision_level"]
    Set optimization_config["precompute_constants"] to "true"
    Set optimization_config["memory_pool_size"] to "adaptive"
    
    Return optimization_config

Process called "troubleshoot_pricing_issues" that takes issue_description as Dictionary[String, String] returns List[String]:
    Note: Provide troubleshooting guidance for option pricing problems
    Let troubleshooting_steps be List[String]
    
    Let issue_type be issue_description["issue_type"]
    Let error_message be issue_description["error_message"]
    
    If issue_type is equal to "pricing_error":
        Add "Check input parameters for negative or zero values" to troubleshooting_steps
        Add "Verify time to expiration is positive" to troubleshooting_steps
        Add "Ensure volatility is within reasonable range (0.01 to 3.0)" to troubleshooting_steps
        Add "Validate strike price and spot price are positive" to troubleshooting_steps
    Otherwise issue_type is equal to "convergence_error":
        Add "Increase maximum iterations for numerical methods" to troubleshooting_steps
        Add "Adjust convergence tolerance" to troubleshooting_steps
        Add "Check for extreme parameter values" to troubleshooting_steps
        Add "Consider using alternative pricing method" to troubleshooting_steps
    Otherwise issue_type is equal to "performance_issue":
        Add "Enable caching for repeated calculations" to troubleshooting_steps
        Add "Reduce numerical precision if appropriate" to troubleshooting_steps
        Add "Use approximation methods for non-critical calculations" to troubleshooting_steps
        Add "Consider parallel processing for large portfolios" to troubleshooting_steps
    Otherwise issue_type is equal to "accuracy_issue":
        Add "Increase numerical precision" to troubleshooting_steps
        Add "Use more time steps in binomial tree" to troubleshooting_steps
        Add "Increase Monte Carlo simulation paths" to troubleshooting_steps
        Add "Verify market data quality and freshness" to troubleshooting_steps
    Otherwise:
        Add "Verify all input parameters are within valid ranges" to troubleshooting_steps
        Add "Check for division by zero conditions" to troubleshooting_steps
        Add "Ensure mathematical functions receive appropriate inputs" to troubleshooting_steps
        Add "Review error logs for specific failure points" to troubleshooting_steps
    
    Add "Contact support if issues persist" to troubleshooting_steps
    Return troubleshooting_steps

Process called "benchmark_pricing_accuracy" that takes model_prices as List[Float], market_prices as List[Float] returns Dictionary[String, Float]:
    Note: Benchmark option pricing model accuracy against market prices
    If Length(model_prices) does not equal Length(market_prices):
        Throw Errors.InvalidArgument with "Model prices and market prices must have same length"
    If Length(model_prices) is equal to 0:
        Throw Errors.InvalidArgument with "Price lists cannot be empty"
    
    Let benchmark_results be Dictionary[String, Float]
    
    Let sum_squared_errors be 0.0
    Let sum_absolute_errors be 0.0
    Let sum_percentage_errors be 0.0
    Let max_error be 0.0
    
    Let i be 0
    While i is less than Length(model_prices):
        Let model_price be model_prices[i]
        Let market_price be market_prices[i]
        
        Let absolute_error be model_price minus market_price
        If absolute_error is less than 0.0:
            Set absolute_error to -absolute_error
        
        Let percentage_error be absolute_error / market_price multiplied by 100.0
        Let squared_error be (model_price minus market_price) multiplied by (model_price minus market_price)
        
        Set sum_squared_errors to sum_squared_errors plus squared_error
        Set sum_absolute_errors to sum_absolute_errors plus absolute_error
        Set sum_percentage_errors to sum_percentage_errors plus percentage_error
        
        If absolute_error is greater than max_error:
            Set max_error to absolute_error
        
        Set i to i plus 1
    
    Let n be Float(Length(model_prices))
    Let mean_squared_error be sum_squared_errors / n
    Let root_mean_squared_error be Parse MathOps.square_root(ToString(mean_squared_error), 15).result_value as Float
    Let mean_absolute_error be sum_absolute_errors / n
    Let mean_percentage_error be sum_percentage_errors / n
    
    Set benchmark_results["rmse"] to root_mean_squared_error
    Set benchmark_results["mae"] to mean_absolute_error
    Set benchmark_results["mape"] to mean_percentage_error
    Set benchmark_results["max_error"] to max_error
    Set benchmark_results["accuracy_score"] to 100.0 minus mean_percentage_error
    Set benchmark_results["model_quality"] to Float(mean_percentage_error is less than 5.0)
    
    Return benchmark_results