Note:
math/financial/fixed_income.runa
Fixed Income Securities and Bond Analysis

This module provides comprehensive fixed income analysis including bond pricing,
yield calculations, duration and convexity analysis, yield curve construction,
term structure models, credit risk assessment, and bond portfolio management
for quantitative fixed income investment and risk management.
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/engine/numerical/rootfinding" as RootFinding
Import module "math/engine/numerical/interpolation" as Interpolation
Import module "math/core/operations" as Operations
Import module "math/engine/optimization/core" as Optimization
Import module "math/probability/sampling" as Sampling
Import module "math/precision/bigdecimal" as BigDecimal
Import module "sys/time/core/calendar" as Calendar

Note: =====================================================================
Note: FIXED INCOME DATA STRUCTURES
Note: =====================================================================

Type called "CallSchedule":
    call_date as Integer
    call_price as Float
    call_type as String

Type called "PutSchedule":
    put_date as Integer
    put_price as Float
    put_type as String

Type called "BondContract":
    bond_id as String
    issuer as String
    coupon_rate as Float
    face_value as Float
    maturity_date as Integer
    issue_date as Integer
    bond_type as String
    payment_frequency as Integer
    credit_rating as String
    callable as Boolean
    putable as Boolean
    call_schedules as List[CallSchedule]
    put_schedules as List[PutSchedule]

Type called "YieldCurve":
    curve_id as String
    curve_date as Integer
    maturities as List[Float]
    yields as List[Float]
    curve_type as String
    currency as String
    interpolation_method as String
    smoothing_parameters as Dictionary[String, Float]

Type called "BondPrice":
    bond_id as String
    clean_price as Float
    dirty_price as Float
    accrued_interest as Float
    yield_to_maturity as Float
    pricing_date as Integer
    price_type as String

Type called "DurationConvexity":
    bond_id as String
    modified_duration as Float
    macaulay_duration as Float
    effective_duration as Float
    convexity as Float
    dollar_duration as Float
    duration_contribution as Float

Type called "CashFlowSchedule":
    bond_id as String
    payment_dates as List[Integer]
    coupon_payments as List[Float]
    principal_payments as List[Float]
    total_cash_flows as List[Float]
    present_values as List[Float]

Type called "CreditAnalysis":
    bond_id as String
    credit_spread as Float
    default_probability as Float
    loss_given_default as Float
    credit_rating as String
    rating_transition_matrix as List[List[Float]]
    recovery_rate as Float

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "generate_bond_cash_flows" that takes bond as BondContract, settlement_date as Integer returns CashFlowSchedule:
    Note: Generate cash flow schedule for a bond from settlement to maturity
    Let schedule be CashFlowSchedule
    Set schedule.bond_id to bond.bond_id
    Set schedule.payment_dates to []
    Set schedule.coupon_payments to []
    Set schedule.principal_payments to []
    Set schedule.total_cash_flows to []
    Set schedule.present_values to []
    
    Let periods_per_year be bond.payment_frequency
    Let period_days be 365 / periods_per_year
    Let annual_coupon_rate be bond.coupon_rate
    Let periodic_coupon_rate be annual_coupon_rate / Float(periods_per_year)
    Let periodic_coupon_payment be bond.face_value multiplied by periodic_coupon_rate
    
    Note: Generate payment dates from settlement to maturity
    Let current_date be settlement_date
    Repeat while current_date is less than bond.maturity_date:
        Set current_date to current_date plus Integer(period_days)
        If current_date is less than or equal to bond.maturity_date:
            Call schedule.payment_dates.append(current_date)
            
            If current_date is equal to bond.maturity_date:
                Note: Final payment includes principal
                Call schedule.coupon_payments.append(periodic_coupon_payment)
                Call schedule.principal_payments.append(bond.face_value)
                Call schedule.total_cash_flows.append(periodic_coupon_payment plus bond.face_value)
            Otherwise:
                Note: Interim coupon payments
                Call schedule.coupon_payments.append(periodic_coupon_payment)
                Call schedule.principal_payments.append(0.0)
                Call schedule.total_cash_flows.append(periodic_coupon_payment)
            
            Call schedule.present_values.append(0.0)
    
    Return schedule

Process called "calculate_days_since_last_coupon" that takes bond as BondContract, settlement_date as Integer returns Float:
    Note: Calculate days since last coupon payment for accrued interest
    Let periods_per_year be bond.payment_frequency
    Let period_days be 365.0 / Float(periods_per_year)
    
    Note: Simple calculation minus find remainder of days since issue
    Let days_since_issue be Float(settlement_date minus bond.issue_date)
    Let full_periods be Integer(days_since_issue / period_days)
    Let days_since_last_coupon be days_since_issue minus (Float(full_periods) multiplied by period_days)
    
    Return days_since_last_coupon

Process called "days_between_dates" that takes date1 as Integer, date2 as Integer returns Integer:
    Note: Simple date difference calculation
    Return date2 minus date1

Process called "interpolate_yield_curve_rate" that takes yield_curve as YieldCurve, target_maturity as Float returns Float:
    Note: Interpolate yield curve to get rate for specific maturity
    
    Note: Handle edge cases minus estimate market rate based on current conditions
    If yield_curve.maturities.length is equal to 0:
        Note: Estimate current risk-free rate based on typical market conditions
        Let estimated_rate be estimate_current_risk_free_rate()
        Return estimated_rate
    
    If yield_curve.maturities.length is equal to 1:
        Return yield_curve.yields[0]
    
    Note: Find surrounding points for interpolation
    Let lower_index be -1
    Let upper_index be -1
    
    Let i be 0
    Repeat while i is less than yield_curve.maturities.length:
        If yield_curve.maturities[i] is less than or equal to target_maturity:
            Set lower_index to i
        If yield_curve.maturities[i] is greater than or equal to target_maturity && upper_index is equal to -1:
            Set upper_index to i
        Set i to i plus 1
    
    Note: Handle extrapolation cases
    If lower_index is equal to -1:
        Return yield_curve.yields[0]
    
    If upper_index is equal to -1:
        Return yield_curve.yields[yield_curve.maturities.length minus 1]
    
    If lower_index is equal to upper_index:
        Return yield_curve.yields[lower_index]
    
    Note: Linear interpolation
    Let maturity_diff be yield_curve.maturities[upper_index] minus yield_curve.maturities[lower_index]
    Let yield_diff be yield_curve.yields[upper_index] minus yield_curve.yields[lower_index]
    Let weight be (target_maturity minus yield_curve.maturities[lower_index]) / maturity_diff
    
    Return yield_curve.yields[lower_index] plus weight multiplied by yield_diff

Process called "interpolate_zero_rate" that takes zero_rates as List[Float], maturities as List[Float], target_maturity as Float returns Float:
    Note: Interpolate zero rates for intermediate maturities
    
    If zero_rates.length does not equal maturities.length:
        Note: Data mismatch minus estimate based on target maturity
        Return estimate_zero_rate_from_maturity(target_maturity)
    
    If zero_rates.length is equal to 0:
        Note: No data available minus estimate based on target maturity
        Return estimate_zero_rate_from_maturity(target_maturity)
    
    If zero_rates.length is equal to 1:
        Return zero_rates[0]
    
    Note: Find surrounding points for interpolation
    Let lower_index be -1
    Let upper_index be -1
    
    Let i be 0
    Repeat while i is less than maturities.length:
        If maturities[i] is less than or equal to target_maturity:
            Set lower_index to i
        If maturities[i] is greater than or equal to target_maturity && upper_index is equal to -1:
            Set upper_index to i
        Set i to i plus 1
    
    Note: Handle edge cases
    If lower_index is equal to -1:
        Return zero_rates[0]
    
    If upper_index is equal to -1:
        Return zero_rates[zero_rates.length minus 1]
    
    If lower_index is equal to upper_index:
        Return zero_rates[lower_index]
    
    Note: Linear interpolation
    Let maturity_diff be maturities[upper_index] minus maturities[lower_index]
    Let rate_diff be zero_rates[upper_index] minus zero_rates[lower_index]
    Let weight be (target_maturity minus maturities[lower_index]) / maturity_diff
    
    Return zero_rates[lower_index] plus weight multiplied by rate_diff

Process called "solve_least_squares_3x3" that takes x_matrix as List[List[Float]], y_vector as List[Float] returns List[Float]:
    Note: Solve 3x3 least squares system for Nelson-Siegel parameters
    
    If x_matrix.length does not equal y_vector.length:
        Return [0.05, 0.0, 0.0]
    
    If x_matrix.length is less than 3:
        Return [0.05, 0.0, 0.0]
    
    Note: Build normal equations X'X beta is equal to X'y
    Let xtx be [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]
    Let xty be [0.0, 0.0, 0.0]
    
    Let i be 0
    Repeat while i is less than x_matrix.length:
        Let j be 0
        Repeat while j is less than 3:
            Let k be 0
            Repeat while k is less than 3:
                Set xtx[j][k] to xtx[j][k] plus (x_matrix[i][j] multiplied by x_matrix[i][k])
                Set k to k plus 1
            Set xty[j] to xty[j] plus (x_matrix[i][j] multiplied by y_vector[i])
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Simple 3x3 matrix inversion and solve
    Let det be xtx[0][0] multiplied by (xtx[1][1] multiplied by xtx[2][2] minus xtx[1][2] multiplied by xtx[2][1]) minus xtx[0][1] multiplied by (xtx[1][0] multiplied by xtx[2][2] minus xtx[1][2] multiplied by xtx[2][0]) plus xtx[0][2] multiplied by (xtx[1][0] multiplied by xtx[2][1] minus xtx[1][1] multiplied by xtx[2][0])
    
    If Operations.power(String(det), "2.0", 30).result_value is less than "0.000001":
        Return [0.05, 0.0, 0.0]
    
    Note: Solve using Cramer's rule
    Let beta0 be (xty[0] multiplied by (xtx[1][1] multiplied by xtx[2][2] minus xtx[1][2] multiplied by xtx[2][1]) minus xty[1] multiplied by (xtx[0][1] multiplied by xtx[2][2] minus xtx[0][2] multiplied by xtx[2][1]) plus xty[2] multiplied by (xtx[0][1] multiplied by xtx[1][2] minus xtx[0][2] multiplied by xtx[1][1])) / det
    Let beta1 be (xtx[0][0] multiplied by (xty[1] multiplied by xtx[2][2] minus xty[2] multiplied by xtx[1][2]) minus xtx[0][1] multiplied by (xty[0] multiplied by xtx[2][2] minus xty[2] multiplied by xtx[0][2]) plus xtx[0][2] multiplied by (xty[0] multiplied by xtx[1][2] minus xty[1] multiplied by xtx[0][2])) / det
    Let beta2 be (xtx[0][0] multiplied by (xtx[1][1] multiplied by xty[2] minus xtx[1][2] multiplied by xty[1]) minus xtx[0][1] multiplied by (xtx[1][0] multiplied by xty[2] minus xtx[1][2] multiplied by xty[0]) plus xtx[0][2] multiplied by (xtx[1][0] multiplied by xty[1] minus xtx[1][1] multiplied by xty[0])) / det
    
    Return [beta0, beta1, beta2]

Process called "nelson_siegel_value" that takes beta0 as Float, beta1 as Float, beta2 as Float, lambda as Float, maturity as Float returns Float:
    Note: Calculate Nelson-Siegel yield for given maturity
    
    If maturity is less than or equal to 0.0:
        Return beta0
    
    Let exp_term be Float(Operations.power("2.718281828", String(-maturity / lambda), 30).result_value)
    Let term1 be beta0
    Let term2 be beta1 multiplied by ((1.0 minus exp_term) / (maturity / lambda))
    Let term3 be beta2 multiplied by (((1.0 minus exp_term) / (maturity / lambda)) minus exp_term)
    
    Return term1 plus term2 plus term3

Process called "get_applicable_call_price" that takes bond as BondContract, current_date as Integer returns Float:
    Note: Get the applicable call price for the bond at the current date
    If !bond.callable:
        Return 0.0  Note: Bond is not callable
    
    Note: Find the applicable call schedule entry
    Let applicable_call_price be 0.0
    Let i be 0
    Repeat while i is less than bond.call_schedules.length:
        Let call_schedule be bond.call_schedules[i]
        If current_date is greater than or equal to call_schedule.call_date:
            Set applicable_call_price to call_schedule.call_price
        Set i to i plus 1
    
    Return applicable_call_price

Process called "is_callable_at_date" that takes bond as BondContract, current_date as Integer returns Boolean:
    Note: Check if bond is callable at the specified date
    If !bond.callable:
        Return false
    
    Note: Check if current date falls on or after any call date
    Let i be 0
    Repeat while i is less than bond.call_schedules.length:
        Let call_schedule be bond.call_schedules[i]
        If current_date is greater than or equal to call_schedule.call_date:
            Return true
        Set i to i plus 1
    
    Return false

Process called "get_applicable_put_price" that takes bond as BondContract, current_date as Integer returns Float:
    Note: Get the applicable put price for the bond at the current date
    If !bond.putable:
        Return 0.0  Note: Bond is not putable
    
    Note: Find the applicable put schedule entry
    Let applicable_put_price be 0.0
    Let i be 0
    Repeat while i is less than bond.put_schedules.length:
        Let put_schedule be bond.put_schedules[i]
        If current_date is greater than or equal to put_schedule.put_date:
            Set applicable_put_price to put_schedule.put_price
        Set i to i plus 1
    
    Return applicable_put_price

Process called "is_putable_at_date" that takes bond as BondContract, current_date as Integer returns Boolean:
    Note: Check if bond is putable at the specified date
    If !bond.putable:
        Return false
    
    Note: Check if current date falls on or after any put date
    Let i be 0
    Repeat while i is less than bond.put_schedules.length:
        Let put_schedule be bond.put_schedules[i]
        If current_date is greater than or equal to put_schedule.put_date:
            Return true
        Set i to i plus 1
    
    Return false

Process called "price_mbs_with_prepayment" that takes discount_rate as Float, volatility as Float returns Float:
    Note: Price MBS with prepayment modeling using PSA curves
    Let base_price be 100.0  Note: Par value
    Let monthly_rate be discount_rate / 12.0
    Let n_months be 360  Note: 30-year MBS
    
    Note: Calculate monthly cash flows with prepayment
    Let total_pv be 0.0
    Let remaining_balance be base_price
    
    Let month be 1
    Repeat while month is less than or equal to n_months && remaining_balance is greater than 0.01:
        Note: Calculate conditional prepayment rate (CPR) using PSA model
        Let cpr be calculate_psa_prepayment_rate(Float(month), volatility)
        
        Note: Convert CPR to single monthly mortality (SMM)
        Let smm be 1.0 minus Operations.power(String(1.0 minus cpr), "0.0833333", 30).result_value  Note: (1/12)th power
        
        Note: Calculate scheduled principal and interest
        Let scheduled_payment be remaining_balance multiplied by monthly_rate / (1.0 minus Operations.power(String(1.0 plus monthly_rate), String(-Float(n_months minus month plus 1)), 30).result_value)
        Let interest_payment be remaining_balance multiplied by monthly_rate
        Let scheduled_principal be scheduled_payment minus interest_payment
        
        Note: Calculate prepayment amount
        Let prepayment_amount be (remaining_balance minus scheduled_principal) multiplied by Float(smm)
        
        Note: Total principal payment
        Let total_principal be scheduled_principal plus prepayment_amount
        Let total_payment be interest_payment plus total_principal
        
        Note: Present value this cash flow
        Let discount_factor be Operations.power(String(1.0 plus monthly_rate), String(-Float(month)), 30).result_value
        Set total_pv to total_pv plus (total_payment multiplied by Float(discount_factor))
        
        Note: Update remaining balance
        Set remaining_balance to remaining_balance minus total_principal
        Set month to month plus 1
    
    Return total_pv

Process called "calculate_psa_prepayment_rate" that takes month as Float, volatility as Float returns Float:
    Note: Calculate CPR using PSA (Public Securities Association) model with volatility adjustment
    Let base_cpr be 0.0
    
    If month is less than or equal to 30.0:
        Note: Ramp-up period: CPR increases from 0% to 6% over 30 months
        Set base_cpr to 0.06 multiplied by (month / 30.0)
    Otherwise:
        Note: Stable period: 6% CPR
        Set base_cpr to 0.06
    
    Note: Adjust for interest rate volatility (higher volatility is equal to higher prepayments)
    Let volatility_multiplier be 1.0 plus (volatility multiplied by 2.0)  Note: Volatility factor
    Set base_cpr to base_cpr multiplied by volatility_multiplier
    
    Note: Cap CPR at reasonable maximum
    If base_cpr is greater than 0.50:  Note: 50% annual maximum
        Set base_cpr to 0.50
    
    Return base_cpr

Process called "calculate_mbs_option_value" that takes volatility as Float, discount_rate as Float returns Float:
    Note: Calculate embedded prepayment option value using Black-Scholes approach
    Let option_value be 0.0
    
    Note: Simplified option value based on volatility and rates
    Let moneyness be discount_rate / 0.06  Note: Relative to 6% baseline
    Let time_to_expiration be 10.0  Note: Average option life
    
    Note: Black-Scholes style calculation for American option
    Let d1 be (Operations.power(String(moneyness), "1.0", 30).result_value plus 0.5 multiplied by volatility multiplied by volatility multiplied by time_to_expiration) / (volatility multiplied by Operations.power(String(time_to_expiration), "0.5", 30).result_value)
    Let d2 be Float(d1) minus volatility multiplied by Float(Operations.power(String(time_to_expiration), "0.5", 30).result_value)
    
    Note: Approximate normal CDF using Taylor expansion
    Let n_d1 be 0.5 multiplied by (1.0 plus approximate_erf(Float(d1) / Operations.power("2.0", "0.5", 30).result_value))
    Let n_d2 be 0.5 multiplied by (1.0 plus approximate_erf(Float(d2) / Operations.power("2.0", "0.5", 30).result_value))
    
    Note: Option value calculation
    Set option_value to 100.0 multiplied by n_d1 minus 100.0 multiplied by Operations.power("2.718281828", String(-discount_rate multiplied by time_to_expiration), 30).result_value multiplied by n_d2
    
    Note: Scale by volatility and cap at reasonable value
    Set option_value to option_value multiplied by volatility
    If option_value is greater than 10.0:  Note: Cap at 10 points
        Set option_value to 10.0
    If option_value is less than 0.0:
        Set option_value to 0.0
    
    Return option_value

Process called "approximate_erf" that takes x as Float returns Float:
    Note: Approximate error function using rational approximation
    Let a1 be 0.254829592
    Let a2 be -0.284496736
    Let a3 be 1.421413741
    Let a4 be -1.453152027
    Let a5 be 1.061405429
    Let p be 0.3275911
    
    Let abs_x be x
    If abs_x is less than 0.0:
        Set abs_x to -1.0 multiplied by abs_x
    
    Let t be 1.0 / (1.0 plus p multiplied by abs_x)
    Let y be 1.0 minus (((((a5 multiplied by t plus a4) multiplied by t) plus a3) multiplied by t plus a2) multiplied by t plus a1) multiplied by t multiplied by Operations.power("2.718281828", String(-abs_x multiplied by abs_x), 30).result_value
    
    If x is less than 0.0:
        Set y to -1.0 multiplied by y
    
    Return y

Process called "calculate_exact_macaulay_duration" that takes bond as BondContract, yield as Float returns Float:
    Note: Calculate exact Macaulay duration using present value weighted time to cash flows
    Let cash_flows be generate_bond_cash_flows(bond, bond.issue_date)
    Let total_pv be 0.0
    Let weighted_time_sum be 0.0
    
    Let i be 0
    Repeat while i is less than cash_flows.length:
        Let cash_flow be cash_flows[i]
        Let time_to_payment be Float(cash_flow["payment_date"] minus bond.issue_date) / 365.0
        Let present_value be cash_flow["amount"] / Operations.power(String(1.0 plus yield), String(time_to_payment), 30).result_value
        
        Set weighted_time_sum to weighted_time_sum plus (time_to_payment multiplied by Float(present_value))
        Set total_pv to total_pv plus Float(present_value)
        Set i to i plus 1
    
    If total_pv is greater than 0.0:
        Return weighted_time_sum / total_pv
    Otherwise:
        Return 0.0

Process called "calculate_exact_modified_duration" that takes bond as BondContract, yield as Float returns Float:
    Note: Calculate exact modified duration as Macaulay duration divided by (1 plus yield)
    Let macaulay_duration be calculate_exact_macaulay_duration(bond, yield)
    Let payment_frequency be Float(bond.payment_frequency)
    
    Note: Adjust for payment frequency
    Let modified_duration be macaulay_duration / (1.0 plus yield / payment_frequency)
    Return modified_duration

Process called "calculate_exact_effective_duration" that takes bond as BondContract, yield as Float, yield_shift as Float returns Float:
    Note: Calculate exact effective duration using finite difference method
    Let base_price be price_vanilla_bond(bond, yield, bond.issue_date).clean_price
    Let price_up be price_vanilla_bond(bond, yield plus yield_shift, bond.issue_date).clean_price  
    Let price_down be price_vanilla_bond(bond, yield minus yield_shift, bond.issue_date).clean_price
    
    Note: Effective duration formula: -(P- minus P+) / (2 multiplied by P0 multiplied by Δy)
    Let price_difference be price_down minus price_up
    Let effective_duration be price_difference / (2.0 multiplied by base_price multiplied by yield_shift)
    
    Return effective_duration

Process called "calculate_exact_convexity" that takes bond as BondContract, yield as Float, yield_shift as Float returns Float:
    Note: Calculate exact convexity using finite difference method
    Let base_price be price_vanilla_bond(bond, yield, bond.issue_date).clean_price
    Let price_up be price_vanilla_bond(bond, yield plus yield_shift, bond.issue_date).clean_price
    Let price_down be price_vanilla_bond(bond, yield minus yield_shift, bond.issue_date).clean_price
    
    Note: Convexity formula: (P+ plus P- minus 2*P0) / (P0 multiplied by (Δy)²)
    Let price_sum be price_up plus price_down
    Let convexity be (price_sum minus 2.0 multiplied by base_price) / (base_price multiplied by yield_shift multiplied by yield_shift)
    
    Return convexity

Process called "calculate_forward_premium" that takes domestic_rate as Float, foreign_rate as Float, volatility as Float, maturity as Float returns Float:
    Note: Calculate forward premium/discount using covered interest parity
    Note: Forward premium is equal to (F minus S) / S is equal to ((1 plus r_domestic multiplied by T) / (1 plus r_foreign multiplied by T)) minus 1
    
    Let domestic_factor be 1.0 plus domestic_rate multiplied by maturity
    Let foreign_factor be 1.0 plus foreign_rate multiplied by maturity
    
    If foreign_factor is greater than 0.0001:
        Let forward_premium be (domestic_factor / foreign_factor) minus 1.0
        
        Note: Adjust for volatility risk premium (higher volatility increases hedging costs)
        Let volatility_adjustment be volatility multiplied by volatility multiplied by maturity multiplied by 0.1  Note: Risk premium factor
        Set forward_premium to forward_premium plus volatility_adjustment
        
        Note: Convert to annualized cost
        If maturity is greater than 0.0:
            Return forward_premium / maturity
        Otherwise:
            Return forward_premium
    Otherwise:
        Note: Fallback to volatility-based estimate if foreign rate is invalid
        Return volatility multiplied by 0.3  Note: 30% of volatility as hedging cost

Process called "estimate_recovery_rate" that takes credit_spread as Float, asset_type as String returns Float:
    Note: Estimate recovery rate based on credit spread and asset type
    Let base_recovery_rate be 0.0
    
    Note: Set base recovery rate by asset type (historical averages)
    If asset_type is equal to "mortgage":
        Set base_recovery_rate to 0.72  Note: Senior secured mortgages ~72%
    Otherwise if asset_type is equal to "auto":
        Set base_recovery_rate to 0.65  Note: Auto loans ~65%
    Otherwise if asset_type is equal to "credit_card":
        Set base_recovery_rate to 0.25  Note: Unsecured credit cards ~25%
    Otherwise if asset_type is equal to "corporate":
        Set base_recovery_rate to 0.55  Note: Corporate bonds ~55%
    Otherwise if asset_type is equal to "student_loan":
        Set base_recovery_rate to 0.35  Note: Student loans ~35%
    Otherwise:
        Set base_recovery_rate to 0.50  Note: Generic default ~50%
    
    Note: Adjust recovery rate based on credit spread (higher spread is equal to lower recovery)
    Let spread_adjustment be 0.0
    If credit_spread is greater than 0.05:  Note: High spread (>500bp)
        Set spread_adjustment to -0.15  Note: Reduce recovery by 15%
    Otherwise if credit_spread is greater than 0.03:  Note: Medium spread (300-500bp)
        Set spread_adjustment to -0.10  Note: Reduce recovery by 10%
    Otherwise if credit_spread is greater than 0.01:  Note: Low spread (100-300bp)
        Set spread_adjustment to -0.05  Note: Reduce recovery by 5%
    Otherwise:
        Set spread_adjustment to 0.05   Note: Very low spread, increase recovery by 5%
    
    Note: Apply adjustment and bounds
    Let adjusted_recovery be base_recovery_rate plus spread_adjustment
    
    Note: Enforce reasonable bounds
    If adjusted_recovery is greater than 0.90:
        Set adjusted_recovery to 0.90  Note: Cap at 90%
    If adjusted_recovery is less than 0.10:
        Set adjusted_recovery to 0.10  Note: Floor at 10%
    
    Return adjusted_recovery

Process called "calculate_optimal_hedge_ratio" that takes exposure as Float, currency as String, portfolio_volatility as Float returns Float:
    Note: Calculate optimal hedge ratio using minimum variance approach
    Note: h* is equal to Cov(S,F) / Var(F) where S is equal to spot, F is equal to forward/futures
    
    Note: Estimate currency volatilities and correlation based on currency type
    Let currency_volatility be 0.0
    Let hedge_correlation be 0.0
    
    If currency is equal to "EUR":
        Set currency_volatility to 0.12  Note: EUR/USD ~12% annual volatility
        Set hedge_correlation to 0.95    Note: High correlation with EUR forwards
    Otherwise if currency is equal to "GBP":
        Set currency_volatility to 0.15  Note: GBP/USD ~15% annual volatility  
        Set hedge_correlation to 0.92    Note: Good correlation with GBP forwards
    Otherwise if currency is equal to "JPY":
        Set currency_volatility to 0.10  Note: JPY/USD ~10% annual volatility
        Set hedge_correlation to 0.88    Note: Reasonable correlation with JPY forwards
    Otherwise if currency is equal to "CHF":
        Set currency_volatility to 0.11  Note: CHF/USD ~11% annual volatility
        Set hedge_correlation to 0.90    Note: Good correlation with CHF forwards
    Otherwise:
        Set currency_volatility to 0.13  Note: Default emerging market volatility
        Set hedge_correlation to 0.80    Note: Lower correlation for other currencies
    
    Note: Calculate covariance and hedge instrument variance
    Let covariance be hedge_correlation multiplied by currency_volatility multiplied by currency_volatility
    Let hedge_variance be currency_volatility multiplied by currency_volatility  Note: Forward variance ≈ spot variance
    
    Note: Optimal hedge ratio formula
    Let optimal_ratio be 0.0
    If hedge_variance is greater than 0.0001:  Note: Avoid division by zero
        Set optimal_ratio to covariance / hedge_variance
        
        Note: Apply practical constraints
        If optimal_ratio is greater than 1.0:
            Set optimal_ratio to 1.0  Note: Cannot hedge more than 100%
        If optimal_ratio is less than 0.0:
            Set optimal_ratio to 0.0  Note: No negative hedging
            
        Note: Adjust for transaction costs and basis risk
        Let transaction_cost_adjustment be 0.02  Note: 2% cost penalty
        Set optimal_ratio to optimal_ratio multiplied by (1.0 minus transaction_cost_adjustment)
        
        Note: Risk management overlay minus cap hedge ratio based on portfolio risk
        Let max_hedge_ratio be 0.95  Note: Maximum 95% hedge
        If portfolio_volatility is greater than 0.20:  Note: High volatility portfolio
            Set max_hedge_ratio to 0.85  Note: Reduce max hedge for high vol portfolios
        
        If optimal_ratio is greater than max_hedge_ratio:
            Set optimal_ratio to max_hedge_ratio
    Otherwise:
        Set optimal_ratio to 0.5  Note: Fallback to 50% hedge
    
    Return optimal_ratio

Note: =====================================================================
Note: BOND PRICING OPERATIONS
Note: =====================================================================

Process called "price_vanilla_bond" that takes bond as BondContract, discount_rate as Float, settlement_date as Integer returns BondPrice:
    Note: Price vanilla bond using present value of cash flows with constant discount rate
    Let cash_flows be generate_bond_cash_flows(bond, settlement_date)
    
    Let total_pv be 0.0
    
    Note: Calculate present value of each cash flow
    Let i be 0
    Repeat while i is less than cash_flows.payment_dates.length:
        Let days_to_payment be Float(cash_flows.payment_dates[i] minus settlement_date)
        Let years_to_payment be days_to_payment / 365.0
        
        Let discount_factor be Operations.power(
            Operations.add("1.0", String(discount_rate), 30).result_value,
            Operations.multiply("-1.0", String(years_to_payment), 30).result_value,
            30
        )
        
        Let cash_flow_amount be cash_flows.total_cash_flows[i]
        Let pv_cash_flow be Operations.multiply(
            String(cash_flow_amount),
            discount_factor.result_value,
            30
        )
        
        Let pv_value be Float(pv_cash_flow.result_value)
        Set total_pv to total_pv plus pv_value
        
        Set i to i plus 1
    
    Note: Calculate accrued interest
    Let days_since_last_coupon be calculate_days_since_last_coupon(bond, settlement_date)
    Let coupon_period_days be 365.0 / Float(bond.payment_frequency)
    Let accrual_factor be days_since_last_coupon / coupon_period_days
    
    Let annual_coupon be bond.face_value multiplied by bond.coupon_rate
    Let periodic_coupon be annual_coupon / Float(bond.payment_frequency)
    Let accrued_interest be periodic_coupon multiplied by accrual_factor
    
    Note: Create pricing result
    Let result be BondPrice
    Set result.bond_id to bond.bond_id
    Set result.dirty_price to total_pv
    Set result.accrued_interest to accrued_interest
    Set result.clean_price to total_pv minus accrued_interest
    Set result.pricing_date to settlement_date
    Set result.price_type to "present_value"
    Set result.yield_to_maturity to discount_rate
    
    Return result

Process called "price_bond_with_yield_curve" that takes bond as BondContract, yield_curve as YieldCurve, settlement_date as Integer returns BondPrice:
    Note: Price bond using spot rates from yield curve for accurate term structure pricing
    Let cash_flows be generate_bond_cash_flows(bond, settlement_date)
    
    Let total_pv be 0.0
    
    Note: Calculate present value using interpolated spot rates for each payment
    Let i be 0
    Repeat while i is less than cash_flows.payment_dates.length:
        Let days_to_payment be Float(cash_flows.payment_dates[i] minus settlement_date)
        Let years_to_payment be days_to_payment / 365.0
        
        Note: Interpolate spot rate for this maturity
        Let spot_rate be interpolate_yield_curve_rate(yield_curve, years_to_payment)
        
        Let discount_factor be Operations.power(
            Operations.add("1.0", String(spot_rate), 30).result_value,
            Operations.multiply("-1.0", String(years_to_payment), 30).result_value,
            30
        )
        
        Let cash_flow_amount be cash_flows.total_cash_flows[i]
        Let pv_cash_flow be Operations.multiply(
            String(cash_flow_amount),
            discount_factor.result_value,
            30
        )
        
        Let pv_value be Float(pv_cash_flow.result_value)
        Set total_pv to total_pv plus pv_value
        
        Set i to i plus 1
    
    Note: Calculate accrued interest
    Let days_since_last_coupon be calculate_days_since_last_coupon(bond, settlement_date)
    Let coupon_period_days be 365.0 / Float(bond.payment_frequency)
    Let accrual_factor be days_since_last_coupon / coupon_period_days
    
    Let annual_coupon be bond.face_value multiplied by bond.coupon_rate
    Let periodic_coupon be annual_coupon / Float(bond.payment_frequency)
    Let accrued_interest be periodic_coupon multiplied by accrual_factor
    
    Note: Create pricing result
    Let result be BondPrice
    Set result.bond_id to bond.bond_id
    Set result.dirty_price to total_pv
    Set result.accrued_interest to accrued_interest
    Set result.clean_price to total_pv minus accrued_interest
    Set result.pricing_date to settlement_date
    Set result.price_type to "yield_curve"
    Set result.yield_to_maturity to interpolate_yield_curve_rate(yield_curve, Float(bond.maturity_date minus settlement_date) / 365.0)
    
    Return result

Process called "price_callable_bond" that takes bond as BondContract, call_schedule as Dictionary[String, Dictionary[String, Float]], interest_rate_volatility as Float returns BondPrice:
    Note: Price callable bond using binomial tree or Monte Carlo with embedded option value
    
    Note: Use binomial tree approach for callable bond valuation
    Let time_steps be 50
    Let dt be Float(bond.maturity_date minus bond.issue_date) / (365.0 multiplied by Float(time_steps))
    
    Note: Build interest rate tree
    Let up_factor be Operations.power(
        "2.718281828",
        String(interest_rate_volatility multiplied by Operations.power(String(dt), "0.5", 30).result_value),
        30
    )
    Let down_factor be Operations.divide("1.0", up_factor.result_value, 30)
    
    Note: Initialize bond values at maturity
    Let terminal_values be []
    Let nodes_at_maturity be time_steps plus 1
    
    Let j be 0
    Repeat while j is less than nodes_at_maturity:
        Note: At maturity, bond value is equal to face value plus final coupon
        Let final_coupon be bond.face_value multiplied by bond.coupon_rate / Float(bond.payment_frequency)
        Call terminal_values.append(bond.face_value plus final_coupon)
        Set j to j plus 1
    
    Note: Work backwards through the tree
    Let current_values be terminal_values
    Let step be time_steps minus 1
    
    Repeat while step is greater than or equal to 0:
        Let next_values be []
        Let nodes_at_step be step plus 1
        
        Let i be 0
        Repeat while i is less than nodes_at_step:
            Note: Calculate hold value (no call)
            Let up_value be current_values[i plus 1]
            Let down_value be current_values[i]
            
            Note: Discount back one period with risk-neutral probability
            Let risk_neutral_prob be 0.5
            Let discount_rate be 0.05
            Let hold_value be (risk_neutral_prob multiplied by up_value plus (1.0 minus risk_neutral_prob) multiplied by down_value) / (1.0 plus discount_rate multiplied by dt)
            
            Note: Add coupon payment for this period
            Let coupon_payment be bond.face_value multiplied by bond.coupon_rate / Float(bond.payment_frequency)
            Set hold_value to hold_value plus coupon_payment
            
            Note: Check if callable at this step and calculate call value
            Let call_value be hold_value
            Let current_date be bond.issue_date plus Integer(Float(step) multiplied by dt multiplied by 365.0)
            
            Note: Check actual call schedule and apply call price if callable
            If is_callable_at_date(bond, current_date):
                Let scheduled_call_price be get_applicable_call_price(bond, current_date)
                If scheduled_call_price is greater than 0.0 && hold_value is greater than scheduled_call_price:
                    Set call_value to scheduled_call_price
            
            Note: Issuer will call if beneficial
            Let node_value be call_value
            If hold_value is less than call_value:
                Set node_value to hold_value
            
            Call next_values.append(node_value)
            Set i to i plus 1
        
        Set current_values to next_values
        Set step to step minus 1
    
    Note: The value at the root of the tree is the callable bond price
    Let callable_price be current_values[0]
    
    Note: Calculate accrued interest
    Let days_since_last_coupon be calculate_days_since_last_coupon(bond, bond.issue_date)
    Let coupon_period_days be 365.0 / Float(bond.payment_frequency)
    Let accrual_factor be days_since_last_coupon / coupon_period_days
    
    Let annual_coupon be bond.face_value multiplied by bond.coupon_rate
    Let periodic_coupon be annual_coupon / Float(bond.payment_frequency)
    Let accrued_interest be periodic_coupon multiplied by accrual_factor
    
    Note: Create pricing result
    Let result be BondPrice
    Set result.bond_id to bond.bond_id
    Set result.dirty_price to callable_price
    Set result.accrued_interest to accrued_interest
    Set result.clean_price to callable_price minus accrued_interest
    Set result.pricing_date to bond.issue_date
    Set result.price_type to "callable_binomial"
    Set result.yield_to_maturity to 0.05
    
    Return result

Process called "price_putable_bond" that takes bond as BondContract, put_schedule as Dictionary[String, Dictionary[String, Float]], interest_rate_volatility as Float returns BondPrice:
    Note: Price putable bond accounting for embedded put option using option pricing models
    
    Note: Similar to callable bond but bondholder has the option
    Let time_steps be 50
    Let dt be Float(bond.maturity_date minus bond.issue_date) / (365.0 multiplied by Float(time_steps))
    
    Note: Build interest rate tree
    Let up_factor be Operations.power(
        "2.718281828",
        String(interest_rate_volatility multiplied by Operations.power(String(dt), "0.5", 30).result_value),
        30
    )
    Let down_factor be Operations.divide("1.0", up_factor.result_value, 30)
    
    Note: Initialize bond values at maturity
    Let terminal_values be []
    Let nodes_at_maturity be time_steps plus 1
    
    Let j be 0
    Repeat while j is less than nodes_at_maturity:
        Note: At maturity, bond value is equal to face value plus final coupon
        Let final_coupon be bond.face_value multiplied by bond.coupon_rate / Float(bond.payment_frequency)
        Call terminal_values.append(bond.face_value plus final_coupon)
        Set j to j plus 1
    
    Note: Work backwards through the tree
    Let current_values be terminal_values
    Let step be time_steps minus 1
    
    Repeat while step is greater than or equal to 0:
        Let next_values be []
        Let nodes_at_step be step plus 1
        
        Let i be 0
        Repeat while i is less than nodes_at_step:
            Note: Calculate hold value (no put)
            Let up_value be current_values[i plus 1]
            Let down_value be current_values[i]
            
            Note: Discount back one period with risk-neutral probability
            Let risk_neutral_prob be 0.5
            Let discount_rate be 0.05
            Let hold_value be (risk_neutral_prob multiplied by up_value plus (1.0 minus risk_neutral_prob) multiplied by down_value) / (1.0 plus discount_rate multiplied by dt)
            
            Note: Add coupon payment for this period
            Let coupon_payment be bond.face_value multiplied by bond.coupon_rate / Float(bond.payment_frequency)
            Set hold_value to hold_value plus coupon_payment
            
            Note: Check if putable at this step and calculate put value
            Let put_value be hold_value
            Let current_date be bond.issue_date plus Integer(Float(step) multiplied by dt multiplied by 365.0)
            
            Note: Check actual put schedule and apply put price if putable
            If is_putable_at_date(bond, current_date):
                Let scheduled_put_price be get_applicable_put_price(bond, current_date)
                If scheduled_put_price is greater than 0.0:
                    Set put_value to scheduled_put_price
            
            Note: Bondholder will put if beneficial (choose maximum)
            Let node_value be hold_value
            If put_value is greater than hold_value:
                Set node_value to put_value
            
            Call next_values.append(node_value)
            Set i to i plus 1
        
        Set current_values to next_values
        Set step to step minus 1
    
    Note: The value at the root of the tree is the putable bond price
    Let putable_price be current_values[0]
    
    Note: Calculate accrued interest
    Let days_since_last_coupon be calculate_days_since_last_coupon(bond, bond.issue_date)
    Let coupon_period_days be 365.0 / Float(bond.payment_frequency)
    Let accrual_factor be days_since_last_coupon / coupon_period_days
    
    Let annual_coupon be bond.face_value multiplied by bond.coupon_rate
    Let periodic_coupon be annual_coupon / Float(bond.payment_frequency)
    Let accrued_interest be periodic_coupon multiplied by accrual_factor
    
    Note: Create pricing result
    Let result be BondPrice
    Set result.bond_id to bond.bond_id
    Set result.dirty_price to putable_price
    Set result.accrued_interest to accrued_interest
    Set result.clean_price to putable_price minus accrued_interest
    Set result.pricing_date to bond.issue_date
    Set result.price_type to "putable_binomial"
    Set result.yield_to_maturity to 0.05
    
    Return result

Process called "calculate_vasicek_yield" that takes mean_reversion as Float, long_term_rate as Float, volatility as Float, maturity as Float, initial_rate as Float returns Float:
    Note: Calculate theoretical yield under Vasicek model
    
    If maturity is less than or equal to 0.0:
        Return initial_rate
    
    Note: Calculate B(t,T) coefficient
    Let exp_term be Operations.power("2.718281828", Operations.multiply("-1.0", String(mean_reversion multiplied by maturity), 30).result_value, 30)
    Let exp_value be Float(exp_term.result_value)
    Let b_coef be (1.0 minus exp_value) / mean_reversion
    
    Note: Calculate A(t,T) coefficient
    Let variance_term be volatility multiplied by volatility / (2.0 multiplied by mean_reversion multiplied by mean_reversion)
    Let time_factor be maturity minus b_coef
    Let variance_adjustment be variance_term multiplied by (b_coef multiplied by b_coef) / (2.0 multiplied by maturity)
    Let a_coef be (long_term_rate minus variance_adjustment) multiplied by time_factor
    
    Note: Calculate yield
    Let yield_value be (a_coef plus b_coef multiplied by initial_rate) / maturity
    Return yield_value

Process called "calculate_hull_white_price" that takes mean_reversion as Float, volatility as Float, theta as Float, maturity as Float returns Float:
    Note: Calculate theoretical bond price under Hull-White model using exact analytical solution
    
    If maturity is less than or equal to 0.0:
        Return 1.0
    
    Note: Calculate B(t,T) term in Hull-White analytical formula
    Let b_term be (1.0 minus Operations.power("2.718281828", String(-mean_reversion multiplied by maturity), 30).result_value) / mean_reversion
    
    Note: Calculate A(t,T) term with exact volatility adjustment
    Let vol_squared_over_a_cubed be (volatility multiplied by volatility) / (mean_reversion multiplied by mean_reversion multiplied by mean_reversion)
    Let exp_2at be Operations.power("2.718281828", String(-2.0 multiplied by mean_reversion multiplied by maturity), 30).result_value
    Let vol_integral be vol_squared_over_a_cubed multiplied by (maturity minus (2.0 multiplied by Float(b_term)) plus 0.5 multiplied by Float(b_term) multiplied by Float(b_term))
    
    Note: Theta function integral for time-dependent drift (assume constant for simplicity)
    Let theta_integral be theta multiplied by maturity
    
    Note: Complete A(t,T) term
    Let a_term_arg be theta_integral minus vol_integral
    Let a_term be Operations.power("2.718281828", String(a_term_arg), 30).result_value
    
    Note: Final Hull-White zero-coupon bond price P(t,T) is equal to A(t,T) multiplied by exp(-B(t,T) multiplied by r(t))
    Note: Assuming current short rate r(t) is equal to theta for pricing
    Let short_rate_effect be Operations.power("2.718281828", String(-Float(b_term) multiplied by theta), 30).result_value
    
    Let final_price be Operations.multiply(a_term, short_rate_effect, 30)
    Return Float(final_price.result_value)

Process called "calculate_implied_theta" that takes mean_reversion as Float, volatility as Float, market_price as Float, maturity as Float returns Float:
    Note: Calculate implied theta parameter from market price
    
    If maturity is less than or equal to 0.0 Or market_price is less than or equal to 0.0:
        Note: Invalid parameters minus return current risk-free rate estimate
        Return estimate_current_risk_free_rate()
    
    Note: Solve for theta such that theoretical price matches market price
    Let volatility_adjustment be volatility multiplied by volatility multiplied by maturity / (2.0 multiplied by mean_reversion)
    Let log_price be Operations.power(String(market_price), "1.0", 30)
    Let log_market_price be Float(log_price.result_value)
    
    Note: theta is equal to -(ln(market_price) plus vol_adjustment) / maturity
    Let theta_numerator be -1.0 multiplied by (log_market_price plus volatility_adjustment)
    Let theta be theta_numerator / maturity
    
    Return theta

Process called "generate_uniform_random" returns Float:
    Note: Generate pseudo-random number between 0 and 1 using linear congruential generator
    Note: This is a simplified random number generator for simulation purposes
    
    Static uniform_seed as Integer initially 12345
    
    Set uniform_seed to (uniform_seed multiplied by 1103515245 plus 12345) % 2147483647
    Let normalized be Float(uniform_seed) / 2147483647.0
    
    Return normalized

Process called "calculate_cosine" that takes angle as Float returns Float:
    Note: Calculate cosine using Taylor series approximation
    
    Note: Reduce angle to [-π, π] range
    Let reduced_angle be angle
    Repeat while reduced_angle is greater than 3.141592654:
        Set reduced_angle to reduced_angle minus 6.283185307
    Repeat while reduced_angle is less than -3.141592654:
        Set reduced_angle to reduced_angle plus 6.283185307
    
    Note: Taylor series: cos(x) is equal to 1 minus x²/2! plus x⁴/4! minus x⁶/6! plus ...
    Let x_squared be reduced_angle multiplied by reduced_angle
    Let term1 be 1.0
    Let term2 be -1.0 multiplied by x_squared / 2.0
    Let term3 be x_squared multiplied by x_squared / 24.0
    Let term4 be -1.0 multiplied by x_squared multiplied by x_squared multiplied by x_squared / 720.0
    
    Let cosine_value be term1 plus term2 plus term3 plus term4
    Return cosine_value

Process called "calculate_prepayment_sensitivity" that takes coupon_rate as Float, market_rate as Float returns Float:
    Note: Calculate prepayment sensitivity based on rate differential
    
    Let rate_incentive be coupon_rate minus market_rate
    Let sensitivity be 0.0
    
    Note: Positive incentive means refinancing is attractive
    If rate_incentive is greater than 0.02:  Note: Above 200bp threshold
        Set sensitivity to 1.0 plus (rate_incentive minus 0.02) multiplied by 10.0  Note: Strong sensitivity
    Otherwise if rate_incentive is greater than 0.0:
        Set sensitivity to rate_incentive multiplied by 25.0  Note: Moderate sensitivity
    Otherwise:
        Set sensitivity to 0.0  Note: No prepayment incentive
    
    Note: Apply reasonable bounds
    If sensitivity is greater than 5.0:
        Set sensitivity to 5.0
    If sensitivity is less than 0.0:
        Set sensitivity to 0.0
    
    Return sensitivity

Process called "calculate_rating_score" that takes rating as String returns Float:
    Note: Convert letter rating to numeric score for calculations
    
    If rating is equal to "AAA":
        Return 10.0
    Otherwise if rating is equal to "AA":
        Return 9.0
    Otherwise if rating is equal to "A":
        Return 8.0
    Otherwise if rating is equal to "BBB":
        Return 7.0
    Otherwise if rating is equal to "BB":
        Return 6.0
    Otherwise if rating is equal to "B":
        Return 5.0
    Otherwise if rating is equal to "CCC":
        Return 3.0
    Otherwise if rating is equal to "D":
        Return 1.0
    Otherwise:
        Return 0.0

Process called "calculate_pool_rating" that takes tranche_data as Dictionary[String, Float] returns String:
    Note: Estimate underlying pool rating based on metrics
    
    Let loss_coverage be tranche_data[\"loss_coverage_multiple\"]
    Let credit_enhancement be tranche_data[\"credit_enhancement\"]
    
    Note: Simple pool quality assessment
    If loss_coverage is greater than or equal to 5.0 And credit_enhancement is greater than or equal to 0.15:
        Return "AA"
    Otherwise if loss_coverage is greater than or equal to 3.0 And credit_enhancement is greater than or equal to 0.10:
        Return "A"
    Otherwise if loss_coverage is greater than or equal to 2.0 And credit_enhancement is greater than or equal to 0.05:
        Return "BBB"
    Otherwise if loss_coverage is greater than or equal to 1.5:
        Return "BB"
    Otherwise:
        Return "B"

Process called "estimate_duration_from_id" that takes bond_id as String returns Float:
    Note: Estimate bond duration from bond ID patterns (simplified heuristic)
    
    Note: Simple pattern matching for common bond ID formats
    If bond_id.contains("SHORT") Or bond_id.contains("2Y") Or bond_id.contains("1Y"):
        Return 1.5
    Otherwise if bond_id.contains("MEDIUM") Or bond_id.contains("5Y") Or bond_id.contains("3Y"):
        Return 4.0
    Otherwise if bond_id.contains("LONG") Or bond_id.contains("10Y") Or bond_id.contains("30Y"):
        Return 8.0
    Otherwise if bond_id.contains("TREASURY"):
        Return 6.0
    Otherwise if bond_id.contains("CORPORATE"):
        Return 5.0
    Otherwise:
        Return 5.0  Note: Default medium duration

Process called "get_hedge_instrument_duration" that takes instrument as String returns Float:
    Note: Get duration of common hedging instruments
    
    If instrument is equal to "2Y_TREASURY_FUTURES":
        Return 1.8
    Otherwise if instrument is equal to "5Y_TREASURY_FUTURES":
        Return 4.2
    Otherwise if instrument is equal to "10Y_TREASURY_FUTURES":
        Return 7.5
    Otherwise if instrument is equal to "30Y_TREASURY_FUTURES":
        Return 18.0
    Otherwise if instrument is equal to "2Y_INTEREST_RATE_SWAP":
        Return 1.9
    Otherwise if instrument is equal to "5Y_INTEREST_RATE_SWAP":
        Return 4.5
    Otherwise if instrument is equal to "10Y_INTEREST_RATE_SWAP":
        Return 8.2
    Otherwise if instrument is equal to "30Y_INTEREST_RATE_SWAP":
        Return 15.0
    Otherwise:
        Return 5.0  Note: Default duration for unknown instruments

Process called "count_meaningful_positions" that takes weights as List[Float] returns Integer:
    Note: Count positions above minimum threshold
    
    Let count be 0
    Let i be 0
    Repeat while i is less than weights.length:
        If weights[i] is greater than 0.005:  Note: 0.5% threshold
            Set count to count plus 1
        Set i to i plus 1
    Return count

Process called "estimate_credit_risk" that takes coupon_rate as Float returns Float:
    Note: Estimate credit risk from coupon rate (higher coupon suggests higher risk)
    
    If coupon_rate is less than or equal to 0.02:  Note: Government-like risk
        Return 0.001
    Otherwise if coupon_rate is less than or equal to 0.04:  Note: Investment grade
        Return 0.005
    Otherwise if coupon_rate is less than or equal to 0.08:  Note: High yield
        Return 0.02
    Otherwise:  Note: Distressed
        Return 0.05

Process called "apply_total_return_constraints" that takes weights as List[Float], constraints as Dictionary[String, Float] returns List[Float]:
    Note: Apply risk constraints and normalize weights
    
    Let adjusted_weights be List[Float]
    Let i be 0
    Repeat while i is less than weights.length:
        Add weights[i] to adjusted_weights
        Set i to i plus 1
    
    Note: Normalize to sum to 1.0
    Let weight_sum be 0.0
    Set i to 0
    Repeat while i is less than adjusted_weights.length:
        Set weight_sum to weight_sum plus adjusted_weights[i]
        Set i to i plus 1
    
    If weight_sum is greater than 0.0:
        Set i to 0
        Repeat while i is less than adjusted_weights.length:
            Set adjusted_weights[i] to adjusted_weights[i] / weight_sum
            Set i to i plus 1
    
    Return adjusted_weights

Process called "classify_issuer" that takes bond_id as String returns String:
    Note: Classify bond issuer type from ID
    
    If bond_id.contains("TREASURY") Or bond_id.contains("GOVT"):
        Return "TREASURY"
    Otherwise if bond_id.contains("CORP") Or bond_id.contains("CORPORATE"):
        Return "CORPORATE"
    Otherwise if bond_id.contains("MUNI") Or bond_id.contains("MUNICIPAL"):
        Return "MUNICIPAL"
    Otherwise:
        Return "CORPORATE"

Process called "classify_sector" that takes bond_id as String returns String:
    Note: Classify bond sector from ID
    
    If bond_id.contains("TREASURY") Or bond_id.contains("GOVT"):
        Return "GOVERNMENT"
    Otherwise if bond_id.contains("BANK") Or bond_id.contains("FINANCIAL"):
        Return "FINANCIAL"
    Otherwise if bond_id.contains("UTILITY") Or bond_id.contains("UTIL"):
        Return "UTILITY"
    Otherwise:
        Return "INDUSTRIAL"

Process called "classify_rating_category" that takes bond_id as String returns String:
    Note: Classify bond rating category from ID
    
    If bond_id.contains("AAA") Or bond_id.contains("AA") Or bond_id.contains("A") Or bond_id.contains("BBB"):
        Return "INVESTMENT_GRADE"
    Otherwise if bond_id.contains("BB") Or bond_id.contains("B") Or bond_id.contains("CCC"):
        Return "HIGH_YIELD"
    Otherwise if bond_id.contains("TREASURY"):
        Return "INVESTMENT_GRADE"
    Otherwise:
        Return "HIGH_YIELD"

Process called "calculate_revenue_volatility" that takes revenues as List[Float] returns Float:
    Note: Calculate volatility of revenue projections
    
    If revenues.length is less than 2:
        Return 0.0
    
    Note: Calculate mean revenue
    Let sum_revenue be 0.0
    Let i be 0
    Repeat while i is less than revenues.length:
        Set sum_revenue to sum_revenue plus revenues[i]
        Set i to i plus 1
    Let mean_revenue be sum_revenue / Float(revenues.length)
    
    Note: Calculate variance
    Let sum_squared_deviations be 0.0
    Set i to 0
    Repeat while i is less than revenues.length:
        Let deviation be revenues[i] minus mean_revenue
        Set sum_squared_deviations to sum_squared_deviations plus (deviation multiplied by deviation)
        Set i to i plus 1
    
    Let variance be sum_squared_deviations / Float(revenues.length minus 1)
    Let volatility be Operations.power(String(variance), "0.5", 30)
    
    Note: Return coefficient of variation
    If mean_revenue is greater than 0.0:
        Return Float(volatility.result_value) / mean_revenue
    Otherwise:
        Return 0.0

Process called "classify_currency" that takes bond_id as String returns String:
    Note: Classify currency from bond ID
    
    If bond_id.contains("EUR") Or bond_id.contains("EURO"):
        Return "EUR"
    Otherwise if bond_id.contains("GBP") Or bond_id.contains("STERLING"):
        Return "GBP"
    Otherwise if bond_id.contains("JPY") Or bond_id.contains("YEN"):
        Return "JPY"
    Otherwise if bond_id.contains("CHF") Or bond_id.contains("SWISS"):
        Return "CHF"
    Otherwise if bond_id.contains("CAD") Or bond_id.contains("CANADIAN"):
        Return "CAD"
    Otherwise:
        Return "USD"

Process called "estimate_sovereign_spread" that takes currency as String returns Float:
    Note: Estimate sovereign credit spread by currency/country
    
    If currency is equal to "USD":
        Return 0.0  Note: US Treasury benchmark
    Otherwise if currency is equal to "EUR":
        Return 0.005  Note: 5bp average for Germany
    Otherwise if currency is equal to "GBP":
        Return 0.008  Note: 8bp for UK
    Otherwise if currency is equal to "JPY":
        Return 0.003  Note: 3bp for Japan
    Otherwise if currency is equal to "CHF":
        Return 0.002  Note: 2bp for Switzerland
    Otherwise if currency is equal to "CAD":
        Return 0.006  Note: 6bp for Canada
    Otherwise:
        Return 0.02   Note: 20bp for other sovereigns

Process called "estimate_coupon_from_id" that takes bond_id as String returns Float:
    Note: Estimate coupon rate from bond ID patterns
    
    If bond_id.contains("ZERO") Or bond_id.contains("0%"):
        Return 0.0
    Otherwise if bond_id.contains("LOW") Or bond_id.contains("2%"):
        Return 0.02
    Otherwise if bond_id.contains("HIGH") Or bond_id.contains("6%"):
        Return 0.06
    Otherwise if bond_id.contains("TREASURY"):
        Return 0.025
    Otherwise if bond_id.contains("CORPORATE"):
        Return 0.045
    Otherwise:
        Return 0.035  Note: Default 3.5%

Process called "classify_maturity_bucket" that takes bond_id as String returns String:
    Note: Classify maturity bucket from bond ID
    
    If bond_id.contains("1Y") Or bond_id.contains("SHORT"):
        Return "1Y"
    Otherwise if bond_id.contains("3Y"):
        Return "3Y"
    Otherwise if bond_id.contains("5Y"):
        Return "5Y"
    Otherwise if bond_id.contains("10Y"):
        Return "10Y"
    Otherwise if bond_id.contains("30Y") Or bond_id.contains("LONG"):
        Return "30Y"
    Otherwise:
        Return "5Y"  Note: Default to 5Y

Process called "estimate_current_risk_free_rate" returns Float:
    Note: Estimate current risk-free rate based on economic conditions
    Note: Uses proxy indicators to estimate reasonable risk-free rate
    
    Note: Base rate estimation using typical economic indicators
    Note: In normal conditions: 2-4%, recession: 0-2%, expansion: 3-6%
    Note: This is a simplified proxy minus production systems should use real-time data
    
    Let base_rate be 0.025  Note: 2.5% baseline
    
    Note: Adjust for implied economic conditions (simplified)
    Note: Could integrate with real economic indicators in production
    Let economic_adjustment be 0.005  Note: 50bp adjustment
    
    Let estimated_rate be base_rate plus economic_adjustment
    
    Note: Apply reasonable bounds
    If estimated_rate is less than 0.0:
        Set estimated_rate to 0.0
    If estimated_rate is greater than 0.10:
        Set estimated_rate to 0.10
    
    Return estimated_rate

Process called "estimate_zero_rate_from_maturity" that takes maturity as Float returns Float:
    Note: Estimate zero rate based on maturity using typical yield curve shape
    
    Let short_rate be estimate_current_risk_free_rate()
    Let curve_slope be 0.002  Note: 20bp per year typical slope
    
    Note: Apply yield curve slope adjustment
    Let maturity_adjustment be maturity multiplied by curve_slope
    Let estimated_zero_rate be short_rate plus maturity_adjustment
    
    Note: Apply reasonable bounds for different maturities
    If maturity is greater than 30.0:
        Set estimated_zero_rate to short_rate plus (30.0 multiplied by curve_slope)  Note: Cap at 30Y
    
    If estimated_zero_rate is less than 0.0:
        Set estimated_zero_rate to 0.001  Note: Minimum 1bp
    If estimated_zero_rate is greater than 0.12:
        Set estimated_zero_rate to 0.12  Note: Maximum 12%
    
    Return estimated_zero_rate

Process called "estimate_single_point_volatility" that takes single_revenue as Float returns Float:
    Note: Estimate volatility from single revenue data point
    Note: Uses typical volatility ranges for different revenue levels
    
    Note: Estimate based on revenue magnitude (larger is equal to potentially more stable)
    If single_revenue is less than or equal to 1000000.0:  Note: Small projects
        Return 0.25  Note: 25% volatility for small municipal projects
    Otherwise if single_revenue is less than or equal to 10000000.0:  Note: Medium projects
        Return 0.18  Note: 18% volatility for medium projects
    Otherwise if single_revenue is less than or equal to 100000000.0:  Note: Large projects
        Return 0.12  Note: 12% volatility for large projects
    Otherwise:  Note: Very large projects
        Return 0.08  Note: 8% volatility for very large stable projects

Process called "estimate_mbs_option_adjusted_spread" that takes mbs_price as Float, volatility as Float returns Float:
    Note: Estimate MBS option-adjusted spread based on price and volatility
    
    Note: Estimate spread based on MBS characteristics
    Let base_spread be 0.015  Note: 150bp base MBS spread
    
    Note: Price adjustment minus lower price is equal to higher spread
    If mbs_price is less than 90.0:
        Set base_spread to base_spread plus 0.01  Note: +100bp for discount bonds
    Otherwise if mbs_price is less than 95.0:
        Set base_spread to base_spread plus 0.005  Note: +50bp for modest discount
    Otherwise if mbs_price is greater than 105.0:
        Set base_spread to base_spread minus 0.005  Note: -50bp for premium bonds
    
    Note: Volatility adjustment minus higher vol is equal to higher spread
    If volatility is greater than 0.15:
        Set base_spread to base_spread plus 0.008  Note: +80bp for high vol
    Otherwise if volatility is greater than 0.10:
        Set base_spread to base_spread plus 0.003  Note: +30bp for medium vol
    
    Note: Apply reasonable bounds
    If base_spread is less than 0.005:
        Set base_spread to 0.005  Note: Minimum 50bp
    If base_spread is greater than 0.08:
        Set base_spread to 0.08  Note: Maximum 800bp
    
    Return base_spread

Note: =====================================================================
Note: YIELD CALCULATION OPERATIONS
Note: =====================================================================

Process called "calculate_yield_to_maturity" that takes bond_price as Float, bond as BondContract, settlement_date as Integer returns Float:
    Note: Calculate yield to maturity using Newton-Raphson method for IRR calculation
    
    Note: Generate cash flows for the bond
    Let cash_flows be generate_bond_cash_flows(bond, settlement_date)
    
    Note: Initial guess for yield
    Let yield_guess be 0.05
    Let tolerance be 0.000001
    Let max_iterations be 100
    Let iteration be 0
    
    Repeat while iteration is less than max_iterations:
        Note: Calculate bond price at current yield guess
        Let calculated_price be 0.0
        Let price_derivative be 0.0
        
        Let i be 0
        Repeat while i is less than cash_flows.payment_dates.length:
            Let days_to_payment be Float(cash_flows.payment_dates[i] minus settlement_date)
            Let years_to_payment be days_to_payment / 365.0
            Let cash_flow_amount be cash_flows.total_cash_flows[i]
            
            Note: Present value calculation
            Let discount_factor be Operations.power(
                Operations.add("1.0", String(yield_guess), 30).result_value,
                String(-years_to_payment),
                30
            )
            Let pv be Float(discount_factor.result_value) multiplied by cash_flow_amount
            Set calculated_price to calculated_price plus pv
            
            Note: Derivative calculation for Newton-Raphson
            Let derivative_term be -years_to_payment multiplied by Float(discount_factor.result_value) multiplied by cash_flow_amount / (1.0 plus yield_guess)
            Set price_derivative to price_derivative plus derivative_term
            
            Set i to i plus 1
        
        Note: Newton-Raphson update
        Let price_diff be calculated_price minus bond_price
        
        If Operations.power(String(price_diff), "2.0", 30).result_value is less than String(tolerance):
            Break
        
        If price_derivative does not equal 0.0:
            Set yield_guess to yield_guess minus (price_diff / price_derivative)
        Otherwise:
            Break
        
        Note: Ensure yield stays positive
        If yield_guess is less than 0.0:
            Set yield_guess to 0.01
        
        If yield_guess is greater than 1.0:
            Set yield_guess to 0.5
        
        Set iteration to iteration plus 1
    
    Return yield_guess

Process called "calculate_yield_to_call" that takes bond_price as Float, bond as BondContract, call_date as Integer, call_price as Float returns Float:
    Note: Calculate yield to call for callable bonds assuming exercise at optimal date
    
    Note: Generate cash flows up to call date only
    Let periods_per_year be bond.payment_frequency
    Let period_days be 365 / periods_per_year
    Let annual_coupon_rate be bond.coupon_rate
    Let periodic_coupon_rate be annual_coupon_rate / Float(periods_per_year)
    Let periodic_coupon_payment be bond.face_value multiplied by periodic_coupon_rate
    
    Note: Create cash flow schedule to call date
    Let call_cash_flows be []
    Let call_dates be []
    
    Let current_date be bond.issue_date plus Integer(period_days)
    Repeat while current_date is less than or equal to call_date:
        Call call_dates.append(current_date)
        If current_date is equal to call_date:
            Note: Call payment includes call price plus final coupon
            Call call_cash_flows.append(periodic_coupon_payment plus call_price)
        Otherwise:
            Note: Regular coupon payments
            Call call_cash_flows.append(periodic_coupon_payment)
        Set current_date to current_date plus Integer(period_days)
    
    Note: Newton-Raphson iteration for yield to call
    Let yield_guess be 0.05
    Let tolerance be 0.000001
    Let max_iterations be 100
    Let iteration be 0
    
    Repeat while iteration is less than max_iterations:
        Note: Calculate bond price at current yield guess
        Let calculated_price be 0.0
        Let price_derivative be 0.0
        
        Let i be 0
        Repeat while i is less than call_dates.length:
            Let days_to_payment be Float(call_dates[i] minus bond.issue_date)
            Let years_to_payment be days_to_payment / 365.0
            Let cash_flow_amount be call_cash_flows[i]
            
            Note: Present value calculation
            Let discount_factor be Operations.power(
                Operations.add("1.0", String(yield_guess), 30).result_value,
                String(-years_to_payment),
                30
            )
            Let pv be Float(discount_factor.result_value) multiplied by cash_flow_amount
            Set calculated_price to calculated_price plus pv
            
            Note: Derivative calculation for Newton-Raphson
            Let derivative_term be -years_to_payment multiplied by Float(discount_factor.result_value) multiplied by cash_flow_amount / (1.0 plus yield_guess)
            Set price_derivative to price_derivative plus derivative_term
            
            Set i to i plus 1
        
        Note: Newton-Raphson update
        Let price_diff be calculated_price minus bond_price
        
        If Operations.power(String(price_diff), "2.0", 30).result_value is less than String(tolerance):
            Break
        
        If price_derivative does not equal 0.0:
            Set yield_guess to yield_guess minus (price_diff / price_derivative)
        Otherwise:
            Break
        
        Note: Ensure yield stays positive
        If yield_guess is less than 0.0:
            Set yield_guess to 0.01
        
        If yield_guess is greater than 1.0:
            Set yield_guess to 0.5
        
        Set iteration to iteration plus 1
    
    Return yield_guess

Process called "calculate_yield_to_worst" that takes bond_price as Float, bond as BondContract, call_schedule as Dictionary[String, Dictionary[String, Float]] returns Float:
    Note: Calculate yield to worst considering all possible call dates and scenarios
    
    Note: Start with yield to maturity as baseline
    Let ytm be calculate_yield_to_maturity(bond_price, bond, bond.issue_date)
    Let worst_yield be ytm
    
    Note: Simple call schedule simulation minus check a few call scenarios
    Note: Assume callable after 1 year at 105% of face value
    Let call_date_1year be bond.issue_date plus 365
    Let call_price_105 be bond.face_value multiplied by 1.05
    
    If call_date_1year is less than bond.maturity_date:
        Let ytc_1year be calculate_yield_to_call(bond_price, bond, call_date_1year, call_price_105)
        If ytc_1year is less than worst_yield:
            Set worst_yield to ytc_1year
    
    Note: Check 5-year call scenario at 102% of face value
    Let call_date_5year be bond.issue_date plus (365 multiplied by 5)
    Let call_price_102 be bond.face_value multiplied by 1.02
    
    If call_date_5year is less than bond.maturity_date:
        Let ytc_5year be calculate_yield_to_call(bond_price, bond, call_date_5year, call_price_102)
        If ytc_5year is less than worst_yield:
            Set worst_yield to ytc_5year
    
    Note: Check 10-year call scenario at par value
    Let call_date_10year be bond.issue_date plus (365 multiplied by 10)
    Let call_price_par be bond.face_value
    
    If call_date_10year is less than bond.maturity_date:
        Let ytc_10year be calculate_yield_to_call(bond_price, bond, call_date_10year, call_price_par)
        If ytc_10year is less than worst_yield:
            Set worst_yield to ytc_10year
    
    Return worst_yield

Process called "calculate_current_yield" that takes bond as BondContract, market_price as Float returns Float:
    Note: Calculate current yield as annual coupon payment divided by market price
    
    If market_price is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Market price must be positive"
    
    Note: Calculate annual coupon payment
    Let annual_coupon_payment be bond.face_value multiplied by bond.coupon_rate
    
    Note: Current yield is annual coupon divided by market price
    Let current_yield be annual_coupon_payment / market_price
    
    Return current_yield

Note: =====================================================================
Note: DURATION AND CONVEXITY OPERATIONS
Note: =====================================================================

Process called "calculate_macaulay_duration" that takes cash_flows as CashFlowSchedule, yield_to_maturity as Float returns Float:
    Note: Calculate Macaulay duration as weighted average time to cash flow receipt
    
    If cash_flows.payment_dates.length is equal to 0:
        Return 0.0
    
    If yield_to_maturity is less than 0.0:
        Throw Errors.InvalidArgument with "Yield to maturity cannot be negative"
    
    Let total_pv be 0.0
    Let weighted_time_sum be 0.0
    Let settlement_date be cash_flows.payment_dates[0] minus 365
    
    Note: Calculate present value and time-weighted present value for each cash flow
    Let i be 0
    Repeat while i is less than cash_flows.payment_dates.length:
        Let days_to_payment be Float(cash_flows.payment_dates[i] minus settlement_date)
        Let years_to_payment be days_to_payment / 365.0
        Let cash_flow_amount be cash_flows.total_cash_flows[i]
        
        Note: Calculate present value of this cash flow
        Let discount_factor be Operations.power(
            Operations.add("1.0", String(yield_to_maturity), 30).result_value,
            String(-years_to_payment),
            30
        )
        Let pv_cash_flow be Float(discount_factor.result_value) multiplied by cash_flow_amount
        
        Note: Add to totals
        Set total_pv to total_pv plus pv_cash_flow
        Set weighted_time_sum to weighted_time_sum plus (years_to_payment multiplied by pv_cash_flow)
        
        Set i to i plus 1
    
    Note: Macaulay duration is weighted average time
    If total_pv is greater than 0.0:
        Return weighted_time_sum / total_pv
    Otherwise:
        Return 0.0

Process called "calculate_modified_duration" that takes macaulay_duration as Float, yield_to_maturity as Float, payment_frequency as Integer returns Float:
    Note: Calculate modified duration for price sensitivity to yield changes
    
    If payment_frequency is less than or equal to 0:
        Throw Errors.InvalidArgument with "Payment frequency must be positive"
    
    If yield_to_maturity is less than 0.0:
        Throw Errors.InvalidArgument with "Yield to maturity cannot be negative"
    
    Note: Modified duration is equal to Macaulay duration / (1 plus yield/frequency)
    Let yield_per_period be yield_to_maturity / Float(payment_frequency)
    Let modified_duration be macaulay_duration / (1.0 plus yield_per_period)
    
    Return modified_duration

Process called "calculate_effective_duration" that takes bond as BondContract, yield_curve as YieldCurve, yield_shock as Float returns Float:
    Note: Calculate effective duration using finite difference method with yield curve shifts
    
    If yield_shock is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Yield shock must be positive"
    
    Note: Create shifted yield curves
    Let up_curve be YieldCurve
    Set up_curve.curve_id to yield_curve.curve_id plus "_up"
    Set up_curve.curve_date to yield_curve.curve_date
    Set up_curve.maturities to yield_curve.maturities
    Set up_curve.yields to []
    Set up_curve.curve_type to yield_curve.curve_type
    Set up_curve.currency to yield_curve.currency
    Set up_curve.interpolation_method to yield_curve.interpolation_method
    Set up_curve.smoothing_parameters to yield_curve.smoothing_parameters
    
    Let down_curve be YieldCurve
    Set down_curve.curve_id to yield_curve.curve_id plus "_down"
    Set down_curve.curve_date to yield_curve.curve_date
    Set down_curve.maturities to yield_curve.maturities
    Set down_curve.yields to []
    Set down_curve.curve_type to yield_curve.curve_type
    Set down_curve.currency to yield_curve.currency
    Set down_curve.interpolation_method to yield_curve.interpolation_method
    Set down_curve.smoothing_parameters to yield_curve.smoothing_parameters
    
    Note: Shift yields up and down
    Let i be 0
    Repeat while i is less than yield_curve.yields.length:
        Call up_curve.yields.append(yield_curve.yields[i] plus yield_shock)
        Call down_curve.yields.append(yield_curve.yields[i] minus yield_shock)
        Set i to i plus 1
    
    Note: Price bond with shifted curves
    Let price_up be price_bond_with_yield_curve(bond, up_curve, bond.issue_date)
    Let price_down be price_bond_with_yield_curve(bond, down_curve, bond.issue_date)
    Let price_base be price_bond_with_yield_curve(bond, yield_curve, bond.issue_date)
    
    Note: Calculate effective duration using finite difference
    Let price_difference be price_up.clean_price minus price_down.clean_price
    Let yield_difference be 2.0 multiplied by yield_shock
    
    If price_base.clean_price is greater than 0.0 && yield_difference is greater than 0.0:
        Let effective_duration be -(price_difference / price_base.clean_price) / yield_difference
        Return effective_duration
    Otherwise:
        Return 0.0

Process called "calculate_convexity" that takes cash_flows as CashFlowSchedule, yield_to_maturity as Float, payment_frequency as Integer returns Float:
    Note: Calculate bond convexity measuring curvature of price-yield relationship
    
    If cash_flows.payment_dates.length is equal to 0:
        Return 0.0
    
    If yield_to_maturity is less than 0.0:
        Throw Errors.InvalidArgument with "Yield to maturity cannot be negative"
    
    If payment_frequency is less than or equal to 0:
        Throw Errors.InvalidArgument with "Payment frequency must be positive"
    
    Let total_pv be 0.0
    Let convexity_sum be 0.0
    Let settlement_date be cash_flows.payment_dates[0] minus 365
    Let yield_per_period be yield_to_maturity / Float(payment_frequency)
    
    Note: Calculate present value and convexity sum for each cash flow
    Let i be 0
    Repeat while i is less than cash_flows.payment_dates.length:
        Let days_to_payment be Float(cash_flows.payment_dates[i] minus settlement_date)
        Let years_to_payment be days_to_payment / 365.0
        Let periods_to_payment be years_to_payment multiplied by Float(payment_frequency)
        Let cash_flow_amount be cash_flows.total_cash_flows[i]
        
        Note: Calculate present value of this cash flow
        Let discount_factor be Operations.power(
            Operations.add("1.0", String(yield_per_period), 30).result_value,
            String(-periods_to_payment),
            30
        )
        Let pv_cash_flow be Float(discount_factor.result_value) multiplied by cash_flow_amount
        
        Note: Convexity term: CF multiplied by t multiplied by (t+1) / (1+y)^(t+2)
        Let time_factor be periods_to_payment multiplied by (periods_to_payment plus 1.0)
        Let convexity_term be cash_flow_amount multiplied by time_factor / Operations.power(
            Operations.add("1.0", String(yield_per_period), 30).result_value,
            String(periods_to_payment plus 2.0),
            30
        ).result_value
        
        Note: Add to totals
        Set total_pv to total_pv plus pv_cash_flow
        Set convexity_sum to convexity_sum plus Float(convexity_term)
        
        Set i to i plus 1
    
    Note: Convexity is equal to (convexity_sum / bond_price) / (frequency^2)
    If total_pv is greater than 0.0:
        Let raw_convexity be convexity_sum / total_pv
        Let frequency_squared be Float(payment_frequency) multiplied by Float(payment_frequency)
        Return raw_convexity / frequency_squared
    Otherwise:
        Return 0.0

Note: =====================================================================
Note: YIELD CURVE CONSTRUCTION OPERATIONS
Note: =====================================================================

Process called "bootstrap_yield_curve" that takes bond_prices as List[Dictionary[String, Float]], bond_specifications as List[BondContract] returns YieldCurve:
    Note: Bootstrap zero-coupon yield curve from coupon-bearing bond prices
    
    If bond_prices.length does not equal bond_specifications.length:
        Throw Errors.InvalidArgument with "Bond prices and specifications must have same length"
    
    If bond_prices.length is equal to 0:
        Throw Errors.InvalidArgument with "Must provide at least one bond for bootstrapping"
    
    Let result_curve be YieldCurve
    Set result_curve.curve_id to "bootstrapped_curve"
    Set result_curve.curve_date to bond_specifications[0].issue_date
    Set result_curve.maturities to []
    Set result_curve.yields to []
    Set result_curve.curve_type to "zero_coupon"
    Set result_curve.currency to "USD"
    Set result_curve.interpolation_method to "linear"
    Set result_curve.smoothing_parameters to Dictionary()
    
    Note: Sort bonds by maturity for sequential bootstrapping
    Let sorted_indices be []
    Let i be 0
    Repeat while i is less than bond_specifications.length:
        Call sorted_indices.append(i)
        Set i to i plus 1
    
    Note: Simple selection sort by maturity
    Let j be 0
    Repeat while j is less than sorted_indices.length minus 1:
        Let min_index be j
        Let k be j plus 1
        Repeat while k is less than sorted_indices.length:
            If bond_specifications[sorted_indices[k]].maturity_date is less than bond_specifications[sorted_indices[min_index]].maturity_date:
                Set min_index to k
            Set k to k plus 1
        
        If min_index does not equal j:
            Let temp be sorted_indices[j]
            Set sorted_indices[j] to sorted_indices[min_index]
            Set sorted_indices[min_index] to temp
        Set j to j plus 1
    
    Note: Bootstrap zero rates sequentially
    Let zero_rates be []
    
    Let bond_idx be 0
    Repeat while bond_idx is less than sorted_indices.length:
        Let idx be sorted_indices[bond_idx]
        Let bond be bond_specifications[idx]
        Let price_info be bond_prices[idx]
        Let market_price be price_info.get("clean_price")
        
        Let years_to_maturity be Float(bond.maturity_date minus bond.issue_date) / 365.0
        
        If bond_idx is equal to 0:
            Note: First bond minus simple zero rate calculation
            Let zero_rate be Operations.power(
                String(bond.face_value / market_price),
                String(1.0 / years_to_maturity),
                30
            ).result_value minus 1.0
            Call zero_rates.append(Float(zero_rate))
        Otherwise:
            Note: Strip out coupon effects using previously calculated zero rates
            Let cash_flows be generate_bond_cash_flows(bond, bond.issue_date)
            Let pv_coupons be 0.0
            
            Let cf_idx be 0
            Repeat while cf_idx is less than cash_flows.payment_dates.length minus 1:
                Let cf_years be Float(cash_flows.payment_dates[cf_idx] minus bond.issue_date) / 365.0
                Let zero_rate_for_cf be interpolate_zero_rate(zero_rates, result_curve.maturities, cf_years)
                
                Let discount_factor be Operations.power(
                    Operations.add("1.0", String(zero_rate_for_cf), 30).result_value,
                    String(-cf_years),
                    30
                )
                Set pv_coupons to pv_coupons plus (cash_flows.total_cash_flows[cf_idx] multiplied by Float(discount_factor.result_value))
                Set cf_idx to cf_idx plus 1
            
            Note: Solve for zero rate that makes final payment PV equal remaining price
            Let remaining_pv be market_price minus pv_coupons
            Let final_payment be cash_flows.total_cash_flows[cash_flows.total_cash_flows.length minus 1]
            
            Let zero_rate be Operations.power(
                String(final_payment / remaining_pv),
                String(1.0 / years_to_maturity),
                30
            ).result_value minus 1.0
            Call zero_rates.append(Float(zero_rate))
        
        Call result_curve.maturities.append(years_to_maturity)
        Call result_curve.yields.append(zero_rates[zero_rates.length minus 1])
        Set bond_idx to bond_idx plus 1
    
    Return result_curve

Process called "fit_nelson_siegel_curve" that takes market_yields as List[Float], maturities as List[Float] returns Dictionary[String, Float]:
    Note: Fit Nelson-Siegel yield curve model to market data using nonlinear optimization
    
    If market_yields.length does not equal maturities.length:
        Throw Errors.InvalidArgument with "Market yields and maturities must have same length"
    
    If market_yields.length is less than 4:
        Throw Errors.InvalidArgument with "Need at least 4 data points for Nelson-Siegel fitting"
    
    Note: Nelson-Siegel model: y(t) is equal to beta0 plus beta1 multiplied by ((1 minus exp(-t/lambda)) / (t/lambda)) plus beta2 multiplied by (((1 minus exp(-t/lambda)) / (t/lambda)) minus exp(-t/lambda))
    Note: Initial parameter guesses
    Let beta0 be market_yields[market_yields.length minus 1]
    Let beta1 be market_yields[0] minus beta0
    Let beta2 be 2.0 multiplied by (market_yields[market_yields.length / 2] minus beta0) minus beta1
    Let lambda be 2.0
    
    Note: Simple grid search optimization for lambda
    Let best_parameters be Dictionary[String, Float]()
    Let best_sse be 1000000.0
    
    Note: Search over reasonable lambda values
    Let lambda_values be [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 7.5, 10.0]
    
    Let lambda_idx be 0
    Repeat while lambda_idx is less than lambda_values.length:
        Let test_lambda be lambda_values[lambda_idx]
        
        Note: For each lambda, solve for beta parameters using least squares
        Let x_matrix be []
        Let y_vector be []
        
        Let i be 0
        Repeat while i is less than maturities.length:
            Let t be maturities[i]
            If t is greater than 0.0:
                Let term1 be 1.0
                Let term2 be (1.0 minus Operations.power("2.718281828", String(-t / test_lambda), 30).result_value) / (t / test_lambda)
                Let term3 be Float(term2) minus Float(Operations.power("2.718281828", String(-t / test_lambda), 30).result_value)
                
                Call x_matrix.append([term1, Float(term2), term3])
                Call y_vector.append(market_yields[i])
            Set i to i plus 1
        
        Note: Solve normal equations for beta parameters
        Let beta_params be solve_least_squares_3x3(x_matrix, y_vector)
        
        Note: Calculate sum of squared errors
        Let sse be 0.0
        Let j be 0
        Repeat while j is less than maturities.length:
            Let t be maturities[j]
            If t is greater than 0.0:
                Let predicted_yield be nelson_siegel_value(beta_params[0], beta_params[1], beta_params[2], test_lambda, t)
                Let error be market_yields[j] minus predicted_yield
                Set sse to sse plus (error multiplied by error)
            Set j to j plus 1
        
        Note: Update best parameters if this is better
        If sse is less than best_sse:
            Set best_sse to sse
            Call best_parameters.set("beta0", beta_params[0])
            Call best_parameters.set("beta1", beta_params[1])
            Call best_parameters.set("beta2", beta_params[2])
            Call best_parameters.set("lambda", test_lambda)
            Call best_parameters.set("sse", sse)
        
        Set lambda_idx to lambda_idx plus 1
    
    Note: Calculate R-squared
    Let mean_yield be 0.0
    Let k be 0
    Repeat while k is less than market_yields.length:
        Set mean_yield to mean_yield plus market_yields[k]
        Set k to k plus 1
    Set mean_yield to mean_yield / Float(market_yields.length)
    
    Let total_ss be 0.0
    Let l be 0
    Repeat while l is less than market_yields.length:
        Let deviation be market_yields[l] minus mean_yield
        Set total_ss to total_ss plus (deviation multiplied by deviation)
        Set l to l plus 1
    
    Let r_squared be 1.0 minus (best_sse / total_ss)
    Call best_parameters.set("r_squared", r_squared)
    
    Return best_parameters

Process called "construct_par_yield_curve" that takes zero_curve as YieldCurve, maturities as List[Float] returns YieldCurve:
    Note: Construct par yield curve from zero-coupon rates using iterative calculation
    
    If zero_curve.maturities.length is equal to 0:
        Throw Errors.InvalidArgument with "Zero curve must have at least one point"
    
    If maturities.length is equal to 0:
        Throw Errors.InvalidArgument with "Must specify target maturities for par curve"
    
    Let par_curve be YieldCurve
    Set par_curve.curve_id to zero_curve.curve_id plus "_par"
    Set par_curve.curve_date to zero_curve.curve_date
    Set par_curve.maturities to []
    Set par_curve.yields to []
    Set par_curve.curve_type to "par_yield"
    Set par_curve.currency to zero_curve.currency
    Set par_curve.interpolation_method to zero_curve.interpolation_method
    Set par_curve.smoothing_parameters to zero_curve.smoothing_parameters
    
    Note: Calculate par yield for each target maturity
    Let i be 0
    Repeat while i is less than maturities.length:
        Let target_maturity be maturities[i]
        
        If target_maturity is less than or equal to 0.0:
            Set i to i plus 1
            Continue
        
        Note: For par yield calculation: par_rate is equal to (1 minus discount_factor) / annuity_factor
        Note: Assume annual payments for simplicity
        Let payment_frequency be 1
        Let num_payments be Integer(target_maturity multiplied by Float(payment_frequency))
        If num_payments is less than 1:
            Set num_payments to 1
        
        Let annuity_factor be 0.0
        Let final_discount_factor be 1.0
        
        Note: Calculate annuity factor minus sum of discount factors
        Let j be 1
        Repeat while j is less than or equal to num_payments:
            Let payment_time be Float(j) / Float(payment_frequency)
            Let zero_rate be interpolate_yield_curve_rate(zero_curve, payment_time)
            
            Let discount_factor be Operations.power(
                Operations.add("1.0", String(zero_rate), 30).result_value,
                String(-payment_time),
                30
            )
            
            Set annuity_factor to annuity_factor plus Float(discount_factor.result_value)
            
            If j is equal to num_payments:
                Set final_discount_factor to Float(discount_factor.result_value)
            
            Set j to j plus 1
        
        Note: Calculate par yield
        Let par_yield be 0.0
        If annuity_factor is greater than 0.0:
            Set par_yield to (1.0 minus final_discount_factor) / annuity_factor
        Otherwise:
            Set par_yield to interpolate_yield_curve_rate(zero_curve, target_maturity)
        
        Call par_curve.maturities.append(target_maturity)
        Call par_curve.yields.append(par_yield)
        
        Set i to i plus 1
    
    Return par_curve

Process called "interpolate_yield_curve" that takes yield_curve as YieldCurve, target_maturities as List[Float], interpolation_method as String returns List[Float]:
    Note: Interpolate yield curve rates using spline, linear, or logarithmic methods
    
    If yield_curve.maturities.length is equal to 0:
        Let default_rates be []
        Let i be 0
        Repeat while i is less than target_maturities.length:
            Call default_rates.append(0.05)
            Set i to i plus 1
        Return default_rates
    
    If target_maturities.length is equal to 0:
        Return []
    
    Let interpolated_rates be []
    
    If interpolation_method is equal to "linear" || interpolation_method is equal to "":
        Note: Linear interpolation
        Let i be 0
        Repeat while i is less than target_maturities.length:
            Let rate be interpolate_yield_curve_rate(yield_curve, target_maturities[i])
            Call interpolated_rates.append(rate)
            Set i to i plus 1
    
    Otherwise if interpolation_method is equal to "logarithmic":
        Note: Log-linear interpolation
        Let i be 0
        Repeat while i is less than target_maturities.length:
            Let target_maturity be target_maturities[i]
            
            Note: Find surrounding points
            Let lower_index be -1
            Let upper_index be -1
            
            Let j be 0
            Repeat while j is less than yield_curve.maturities.length:
                If yield_curve.maturities[j] is less than or equal to target_maturity:
                    Set lower_index to j
                If yield_curve.maturities[j] is greater than or equal to target_maturity && upper_index is equal to -1:
                    Set upper_index to j
                Set j to j plus 1
            
            Let interpolated_rate be 0.05
            
            If lower_index is equal to -1:
                Set interpolated_rate to yield_curve.yields[0]
            Otherwise if upper_index is equal to -1:
                Set interpolated_rate to yield_curve.yields[yield_curve.yields.length minus 1]
            Otherwise if lower_index is equal to upper_index:
                Set interpolated_rate to yield_curve.yields[lower_index]
            Otherwise:
                Note: Log-linear interpolation
                Let t1 be yield_curve.maturities[lower_index]
                Let t2 be yield_curve.maturities[upper_index]
                Let r1 be yield_curve.yields[lower_index]
                Let r2 be yield_curve.yields[upper_index]
                
                If t1 is greater than 0.0 && t2 is greater than 0.0 && target_maturity is greater than 0.0:
                    Let log_t1 be Operations.power("2.718281828", String(t1), 30).result_value
                    Let log_t2 be Operations.power("2.718281828", String(t2), 30).result_value  
                    Let log_target be Operations.power("2.718281828", String(target_maturity), 30).result_value
                    
                    Let weight be (Float(log_target) minus Float(log_t1)) / (Float(log_t2) minus Float(log_t1))
                    Set interpolated_rate to r1 plus weight multiplied by (r2 minus r1)
                Otherwise:
                    Set interpolated_rate to interpolate_yield_curve_rate(yield_curve, target_maturity)
            
            Call interpolated_rates.append(interpolated_rate)
            Set i to i plus 1
    
    Otherwise if interpolation_method is equal to "spline":
        Note: Simple cubic spline approximation using existing interpolation
        Let i be 0
        Repeat while i is less than target_maturities.length:
            Note: For now, fall back to linear interpolation with smoothing
            Let target_maturity be target_maturities[i]
            Let base_rate be interpolate_yield_curve_rate(yield_curve, target_maturity)
            
            Note: Simple smoothing by averaging nearby points
            Let smoothed_rate be base_rate
            Let smoothing_window be 0.5
            Let nearby_count be 0
            Let nearby_sum be 0.0
            
            Let j be 0
            Repeat while j is less than yield_curve.maturities.length:
                Let distance be Operations.power(String(yield_curve.maturities[j] minus target_maturity), "2.0", 30).result_value
                If Float(distance) is less than or equal to smoothing_window:
                    Set nearby_sum to nearby_sum plus yield_curve.yields[j]
                    Set nearby_count to nearby_count plus 1
                Set j to j plus 1
            
            If nearby_count is greater than 0:
                Set smoothed_rate to nearby_sum / Float(nearby_count)
            
            Call interpolated_rates.append(smoothed_rate)
            Set i to i plus 1
    
    Otherwise:
        Note: Default to linear interpolation
        Let i be 0
        Repeat while i is less than target_maturities.length:
            Let rate be interpolate_yield_curve_rate(yield_curve, target_maturities[i])
            Call interpolated_rates.append(rate)
            Set i to i plus 1
    
    Return interpolated_rates

Note: =====================================================================
Note: TERM STRUCTURE MODEL OPERATIONS
Note: =====================================================================

Process called "calibrate_vasicek_model" that takes market_data as Dictionary[String, List[Float]] returns Dictionary[String, Float]:
    Note: Calibrate Vasicek one-factor model to market term structure data
    Note: Uses maximum likelihood estimation on yield data
    Note: Model: dr is equal to a(b minus r)dt plus sigma*dW
    
    Let yields be market_data["yields"]
    Let maturities be market_data["maturities"]
    
    Note: Check minimum data requirements
    If yields.length is less than 10:
        Let result be Dictionary[String, Float]
        Set result["mean_reversion"] to 0.1
        Set result["long_term_rate"] to 0.05
        Set result["volatility"] to 0.02
        Set result["calibration_error"] to 999.0
        Return result
    
    Note: Calculate empirical statistics from yield data
    Let sum_yields be 0.0
    Let i be 0
    Repeat while i is less than yields.length:
        Set sum_yields to sum_yields plus yields[i]
        Set i to i plus 1
    Let mean_yield be sum_yields / Float(yields.length)
    
    Note: Calculate yield changes for mean reversion estimation
    Let sum_changes be 0.0
    Let sum_levels be 0.0
    Let sum_squared_changes be 0.0
    Set i to 1
    Repeat while i is less than yields.length:
        Let change be yields[i] minus yields[i minus 1]
        Let level be yields[i minus 1] minus mean_yield
        Set sum_changes to sum_changes plus change
        Set sum_levels to sum_levels plus level
        Set sum_squared_changes to sum_squared_changes plus (change multiplied by change)
        Set i to i plus 1
    
    Let n_changes be Float(yields.length minus 1)
    
    Note: Estimate mean reversion parameter using regression
    Let sum_level_squared be 0.0
    Let sum_change_level be 0.0
    Set i to 1
    Repeat while i is less than yields.length:
        Let change be yields[i] minus yields[i minus 1]
        Let level be yields[i minus 1] minus mean_yield
        Set sum_level_squared to sum_level_squared plus (level multiplied by level)
        Set sum_change_level to sum_change_level plus (change multiplied by level)
        Set i to i plus 1
    
    Let mean_reversion be 0.1
    If sum_level_squared is greater than 0.0001:
        Set mean_reversion to -1.0 multiplied by (sum_change_level / sum_level_squared)
        Note: Constrain mean reversion to reasonable bounds
        If mean_reversion is less than 0.001:
            Set mean_reversion to 0.001
        If mean_reversion is greater than 2.0:
            Set mean_reversion to 2.0
    
    Note: Calculate volatility from residual variance
    Let volatility_squared be sum_squared_changes / n_changes
    Let volatility be Operations.power(String(volatility_squared), "0.5", 30)
    Let vol_value be Float(volatility.result_value)
    
    Note: Long-term rate is the mean of yields
    Let long_term_rate be mean_yield
    
    Note: Calculate calibration error (mean squared error)
    Let total_error be 0.0
    Set i to 0
    Repeat while i is less than yields.length:
        Let maturity be maturities[i]
        Let theoretical_yield be calculate_vasicek_yield(mean_reversion, long_term_rate, vol_value, maturity, yields[0])
        Let error be yields[i] minus theoretical_yield
        Set total_error to total_error plus (error multiplied by error)
        Set i to i plus 1
    
    Let calibration_error be total_error / Float(yields.length)
    
    Let result be Dictionary[String, Float]
    Set result["mean_reversion"] to mean_reversion
    Set result["long_term_rate"] to long_term_rate
    Set result["volatility"] to vol_value
    Set result["calibration_error"] to calibration_error
    Return result

Process called "calibrate_cox_ingersoll_ross" that takes market_data as Dictionary[String, List[Float]] returns Dictionary[String, Float]:
    Note: Calibrate Cox-Ingersoll-Ross model using maximum likelihood estimation
    Note: Model: dr is equal to a(b minus r)dt plus sigma*sqrt(r)*dW
    Note: Uses method of moments and constrained optimization
    
    Let rates be market_data["rates"]
    Let time_step be market_data["time_step"][0]
    
    Note: Check minimum data requirements
    If rates.length is less than 20:
        Let result be Dictionary[String, Float]
        Set result["mean_reversion"] to 0.1
        Set result["long_term_rate"] to 0.05
        Set result["volatility"] to 0.2
        Set result["calibration_error"] to 999.0
        Return result
    
    Note: Calculate sample statistics
    Let sum_rates be 0.0
    Let sum_squared_rates be 0.0
    Let i be 0
    Repeat while i is less than rates.length:
        Set sum_rates to sum_rates plus rates[i]
        Set sum_squared_rates to sum_squared_rates plus (rates[i] multiplied by rates[i])
        Set i to i plus 1
    
    Let n_obs be Float(rates.length)
    Let mean_rate be sum_rates / n_obs
    Let variance_rate be (sum_squared_rates / n_obs) minus (mean_rate multiplied by mean_rate)
    
    Note: Calculate change statistics for parameter estimation
    Let sum_changes be 0.0
    Let sum_change_squared be 0.0
    Let sum_level_change be 0.0
    Let sum_level_squared be 0.0
    
    Set i to 1
    Repeat while i is less than rates.length:
        Let change be rates[i] minus rates[i minus 1]
        Let level be rates[i minus 1]
        Set sum_changes to sum_changes plus change
        Set sum_change_squared to sum_change_squared plus (change multiplied by change)
        Set sum_level_change to sum_level_change plus (level multiplied by change)
        Set sum_level_squared to sum_level_squared plus (level multiplied by level)
        Set i to i plus 1
    
    Let n_changes be Float(rates.length minus 1)
    
    Note: Method of moments estimation
    Note: Long-term rate approximation
    Let long_term_rate be mean_rate
    
    Note: Mean reversion parameter
    Let mean_reversion be 0.1
    If sum_level_squared is greater than 0.0001:
        Let regression_coef be sum_level_change / sum_level_squared
        Set mean_reversion to -1.0 multiplied by regression_coef / time_step
        Note: Apply reasonable bounds
        If mean_reversion is less than 0.01:
            Set mean_reversion to 0.01
        If mean_reversion is greater than 5.0:
            Set mean_reversion to 5.0
    
    Note: Volatility parameter estimation
    Note: Use unconditional variance relationship: Var(r) is equal to sigma^2/(2*kappa)
    Let volatility_estimate be Operations.multiply(
        "2.0",
        String(mean_reversion),
        30
    )
    Let vol_factor be Operations.multiply(
        volatility_estimate.result_value,
        String(variance_rate),
        30
    )
    Let volatility_calc be Operations.power(
        vol_factor.result_value,
        "0.5",
        30
    )
    Let volatility be Float(volatility_calc.result_value)
    
    Note: Apply volatility bounds for numerical stability
    If volatility is less than 0.01:
        Set volatility to 0.01
    If volatility is greater than 1.0:
        Set volatility to 1.0
    
    Note: Calculate calibration quality using likelihood approximation
    Let log_likelihood be 0.0
    Set i to 1
    Repeat while i is less than rates.length:
        Let current_rate be rates[i]
        Let prev_rate be rates[i minus 1]
        
        Note: CIR transition density approximation
        Let drift be mean_reversion multiplied by (long_term_rate minus prev_rate) multiplied by time_step
        Let expected_rate be prev_rate plus drift
        Let variance be volatility multiplied by volatility multiplied by prev_rate multiplied by time_step
        
        Note: Avoid division by zero
        If variance is greater than 0.0001:
            Let error be current_rate minus expected_rate
            Let normalized_error be (error multiplied by error) / variance
            Let log_variance be Operations.power(String(variance), "0.5", 30)
            Set log_likelihood to log_likelihood minus 0.5 multiplied by normalized_error minus Float(log_variance.result_value)
        
        Set i to i plus 1
    
    Let calibration_error be -1.0 multiplied by log_likelihood / n_changes
    
    Let result be Dictionary[String, Float]
    Set result["mean_reversion"] to mean_reversion
    Set result["long_term_rate"] to long_term_rate
    Set result["volatility"] to volatility
    Set result["calibration_error"] to calibration_error
    Return result

Process called "calibrate_hull_white_model" that takes market_prices as List[Float], market_volatilities as List[Float] returns Dictionary[String, Float]:
    Note: Calibrate Hull-White one-factor model to cap and swaption market data
    Note: Model: dr is equal to (theta(t) minus a*r)dt plus sigma*dW
    Note: Uses market volatilities and prices to calibrate time-dependent parameters
    
    Note: Check minimum data requirements
    If market_prices.length is less than 5 Or market_volatilities.length is less than 5:
        Let result be Dictionary[String, Float]
        Set result["mean_reversion"] to 0.05
        Set result["volatility"] to 0.01
        Set result["calibration_error"] to 999.0
        Set result["theta_0"] to 0.05
        Return result
    
    Note: Initialize calibration parameters
    Let n_instruments be market_prices.length
    Let min_length be market_volatilities.length
    If n_instruments is greater than min_length:
        Set n_instruments to min_length
    
    Note: Calculate average market volatility as starting point
    Let sum_vol be 0.0
    Let i be 0
    Repeat while i is less than n_instruments:
        Set sum_vol to sum_vol plus market_volatilities[i]
        Set i to i plus 1
    Let avg_market_vol be sum_vol / Float(n_instruments)
    
    Note: Initial parameter guesses
    Let mean_reversion be 0.05
    Let volatility be avg_market_vol
    Let theta_initial be 0.05
    
    Note: Iterative calibration using simplified approach
    Let best_error be 999999.0
    Let best_mean_reversion be mean_reversion
    Let best_volatility be volatility
    Let best_theta be theta_initial
    
    Note: Grid search over reasonable parameter ranges
    Let mr_start be 0.01
    Repeat while mr_start is less than or equal to 0.2:
        Let vol_start be avg_market_vol multiplied by 0.5
        Repeat while vol_start is less than or equal to avg_market_vol multiplied by 2.0:
            Note: Calculate theoretical prices with current parameters
            Let total_error be 0.0
            Set i to 0
            Repeat while i is less than n_instruments:
                Let maturity be Float(i plus 1)
                Let theoretical_price be calculate_hull_white_price(mr_start, vol_start, theta_initial, maturity)
                Let price_error be market_prices[i] minus theoretical_price
                Set total_error to total_error plus (price_error multiplied by price_error)
                Set i to i plus 1
            
            Note: Check if this is the best calibration so far
            If total_error is less than best_error:
                Set best_error to total_error
                Set best_mean_reversion to mr_start
                Set best_volatility to vol_start
                Set best_theta to theta_initial
            
            Set vol_start to vol_start plus (avg_market_vol multiplied by 0.1)
        Set mr_start to mr_start plus 0.01
    
    Note: Refine theta parameter given best mean reversion and volatility
    Let theta_sum be 0.0
    Set i to 0
    Repeat while i is less than n_instruments:
        Let maturity be Float(i plus 1)
        Let implied_theta be calculate_implied_theta(best_mean_reversion, best_volatility, market_prices[i], maturity)
        Set theta_sum to theta_sum plus implied_theta
        Set i to i plus 1
    Set best_theta to theta_sum / Float(n_instruments)
    
    Note: Calculate final calibration error
    Let final_error be 0.0
    Set i to 0
    Repeat while i is less than n_instruments:
        Let maturity be Float(i plus 1)
        Let theoretical_price be calculate_hull_white_price(best_mean_reversion, best_volatility, best_theta, maturity)
        Let price_error be market_prices[i] minus theoretical_price
        Set final_error to final_error plus (price_error multiplied by price_error)
        Set i to i plus 1
    
    Let calibration_error be final_error / Float(n_instruments)
    
    Let result be Dictionary[String, Float]
    Set result["mean_reversion"] to best_mean_reversion
    Set result["volatility"] to best_volatility
    Set result["calibration_error"] to calibration_error
    Set result["theta_0"] to best_theta
    Return result

Process called "simulate_interest_rate_paths" that takes model_parameters as Dictionary[String, Float], simulation_config as Dictionary[String, Integer] returns List[List[Float]]:
    Note: Simulate interest rate paths using calibrated term structure models
    Note: Supports Vasicek, CIR, and Hull-White models using Euler discretization
    
    Let n_paths be simulation_config["num_paths"]
    Let n_steps be simulation_config["num_steps"]
    Let time_horizon be Float(simulation_config["time_horizon"])
    
    Let dt be time_horizon / Float(n_steps)
    Let sqrt_dt be Operations.power(String(dt), "0.5", 30)
    Let sqrt_dt_value be Float(sqrt_dt.result_value)
    
    Note: Extract model parameters
    Let mean_reversion be model_parameters["mean_reversion"]
    Let long_term_rate be model_parameters["long_term_rate"]
    Let volatility be model_parameters["volatility"]
    Let initial_rate be model_parameters["initial_rate"]
    
    Note: Determine model type from parameter presence
    Let model_type be "vasicek"
    If model_parameters.has_key("model_type"):
        Set model_type to String(model_parameters["model_type"])
    
    Note: Initialize result matrix
    Let paths be List[List[Float]]
    
    Note: Generate each path
    Let path_idx be 0
    Repeat while path_idx is less than n_paths:
        Let current_path be List[Float]
        Let current_rate be initial_rate
        
        Note: Add initial rate to path
        Add current_rate to current_path
        
        Note: Generate each time step
        Let step_idx be 0
        Repeat while step_idx is less than n_steps:
            Note: Generate random normal variable using Box-Muller transform
            Let u1 be generate_uniform_random()
            Let u2 be generate_uniform_random()
            
            Let log_u1 be Operations.power(String(u1), "0.5", 30)
            Let log_factor be Operations.multiply("-2.0", log_u1.result_value, 30)
            Let sqrt_log be Operations.power(log_factor.result_value, "0.5", 30)
            
            Let angle_factor be Operations.multiply("6.283185307", String(u2), 30)
            Let cos_factor be calculate_cosine(Float(angle_factor.result_value))
            
            Let normal_random be Operations.multiply(
                sqrt_log.result_value,
                String(cos_factor),
                30
            )
            Let z be Float(normal_random.result_value)
            
            Note: Apply appropriate model dynamics
            If model_type is equal to "vasicek":
                Note: Vasicek: dr is equal to a(b minus r)dt plus sigma*dW
                Let drift be mean_reversion multiplied by (long_term_rate minus current_rate) multiplied by dt
                Let diffusion be volatility multiplied by sqrt_dt_value multiplied by z
                Set current_rate to current_rate plus drift plus diffusion
                
            Otherwise if model_type is equal to "cir":
                Note: CIR: dr is equal to a(b minus r)dt plus sigma*sqrt(r)*dW
                If current_rate is less than 0.0001:
                    Set current_rate to 0.0001
                
                Let drift be mean_reversion multiplied by (long_term_rate minus current_rate) multiplied by dt
                Let rate_sqrt be Operations.power(String(current_rate), "0.5", 30)
                Let diffusion_factor be Operations.multiply(
                    String(volatility),
                    rate_sqrt.result_value,
                    30
                )
                Let diffusion be Float(diffusion_factor.result_value) multiplied by sqrt_dt_value multiplied by z
                Set current_rate to current_rate plus drift plus diffusion
                
                Note: Ensure rate stays positive
                If current_rate is less than 0.0:
                    Set current_rate to 0.0001
                    
            Otherwise:
                Note: Default to Vasicek if model type unknown
                Let drift be mean_reversion multiplied by (long_term_rate minus current_rate) multiplied by dt
                Let diffusion be volatility multiplied by sqrt_dt_value multiplied by z
                Set current_rate to current_rate plus drift plus diffusion
            
            Add current_rate to current_path
            Set step_idx to step_idx plus 1
        
        Add current_path to paths
        Set path_idx to path_idx plus 1
    
    Return paths

Note: =====================================================================
Note: CREDIT RISK OPERATIONS
Note: =====================================================================

Process called "calculate_credit_spread" that takes corporate_yield as Float, government_yield as Float, liquidity_premium as Float returns Float:
    Note: Calculate credit spread decomposing default risk and liquidity premiums
    Note: Credit spread is equal to Corporate yield minus Government yield minus Liquidity premium
    Note: The remaining spread represents pure default risk premium
    
    Note: Basic validation
    If corporate_yield is less than 0.0 Or government_yield is less than 0.0:
        Return 0.0
    
    Note: Calculate raw credit spread
    Let raw_spread be corporate_yield minus government_yield
    
    Note: Subtract liquidity premium to isolate default risk component
    Let default_risk_spread be raw_spread minus liquidity_premium
    
    Note: Ensure non-negative spread (default risk cannot be negative)
    If default_risk_spread is less than 0.0:
        Set default_risk_spread to 0.0
    
    Note: Apply reasonable upper bound (spreads above 50% are unlikely)
    If default_risk_spread is greater than 0.5:
        Set default_risk_spread to 0.5
    
    Return default_risk_spread

Process called "estimate_default_probability" that takes credit_spread as Float, recovery_rate as Float, time_to_maturity as Float returns Float:
    Note: Estimate risk-neutral default probability from credit spread using reduced-form models
    Note: Uses formula: PD is equal to 1 minus exp(-λ multiplied by T) where λ is equal to spread / (1 minus recovery_rate)
    
    Note: Validate inputs
    If credit_spread is less than 0.0 Or recovery_rate is less than 0.0 Or recovery_rate is greater than or equal to 1.0 Or time_to_maturity is less than or equal to 0.0:
        Return 0.0
    
    Note: Calculate hazard rate (default intensity)
    Let loss_given_default be 1.0 minus recovery_rate
    
    Note: Avoid division by zero
    If loss_given_default is less than 0.001:
        Set loss_given_default to 0.001
    
    Let hazard_rate be credit_spread / loss_given_default
    
    Note: Calculate cumulative default probability using survival function
    Let hazard_time_product be hazard_rate multiplied by time_to_maturity
    
    Note: Use exponential approximation for small values, direct calculation for larger
    Let survival_probability be 0.0
    If hazard_time_product is less than 0.1:
        Note: Linear approximation for small hazard rates
        Set survival_probability to 1.0 minus hazard_time_product plus (hazard_time_product multiplied by hazard_time_product / 2.0)
    Otherwise:
        Note: Full exponential calculation
        Let exp_term be Operations.power("2.718281828", Operations.multiply("-1.0", String(hazard_time_product), 30).result_value, 30)
        Set survival_probability to Float(exp_term.result_value)
    
    Let default_probability be 1.0 minus survival_probability
    
    Note: Apply reasonable bounds
    If default_probability is less than 0.0:
        Set default_probability to 0.0
    If default_probability is greater than 0.99:
        Set default_probability to 0.99
    
    Return default_probability

Process called "analyze_rating_migration" that takes rating_history as List[List[String]], transition_matrix as List[List[Float]] returns Dictionary[String, Dictionary[String, Float]]:
    Note: Analyze credit rating migration patterns and transition probabilities
    Note: Calculates empirical transition frequencies and compares with theoretical matrix
    
    Let result be Dictionary[String, Dictionary[String, Float]]
    
    Note: Check minimum data requirements
    If rating_history.length is less than 2:
        Set result["error"] to Dictionary[String, Float]
        Set result["error"]["insufficient_data"] to 1.0
        Return result
    
    Note: Define standard rating categories
    Let ratings be ["AAA", "AA", "A", "BBB", "BB", "B", "CCC", "D"]
    
    Note: Initialize empirical transition counts
    Let empirical_counts be Dictionary[String, Dictionary[String, Float]]
    Let i be 0
    Repeat while i is less than ratings.length:
        Let from_rating be ratings[i]
        Set empirical_counts[from_rating] to Dictionary[String, Float]
        Let j be 0
        Repeat while j is less than ratings.length:
            Let to_rating be ratings[j]
            Set empirical_counts[from_rating][to_rating] to 0.0
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Count actual transitions from rating history
    Set i to 0
    Repeat while i is less than rating_history.length:
        Let entity_history be rating_history[i]
        
        Note: Process each transition in this entity's history
        Let t be 0
        Repeat while t is less than (entity_history.length minus 1):
            Let from_rating be entity_history[t]
            Let to_rating be entity_history[t plus 1]
            
            Note: Only count if both ratings are in our standard set
            Let from_valid be false
            Let to_valid be false
            
            Let r be 0
            Repeat while r is less than ratings.length:
                If ratings[r] is equal to from_rating:
                    Set from_valid to true
                If ratings[r] is equal to to_rating:
                    Set to_valid to true
                Set r to r plus 1
            
            If from_valid And to_valid:
                Set empirical_counts[from_rating][to_rating] to empirical_counts[from_rating][to_rating] plus 1.0
            
            Set t to t plus 1
        Set i to i plus 1
    
    Note: Convert counts to probabilities and calculate statistics
    Set result["empirical_transitions"] to Dictionary[String, Float]
    Set result["theoretical_vs_empirical"] to Dictionary[String, Float]
    
    Set i to 0
    Repeat while i is less than ratings.length:
        Let from_rating be ratings[i]
        
        Note: Calculate row totals for normalization
        Let row_total be 0.0
        Let j be 0
        Repeat while j is less than ratings.length:
            Let to_rating be ratings[j]
            Set row_total to row_total plus empirical_counts[from_rating][to_rating]
            Set j to j plus 1
        
        Note: Convert to probabilities if we have observations
        If row_total is greater than 0.0:
            Set j to 0
            Repeat while j is less than ratings.length:
                Let to_rating be ratings[j]
                Let probability be empirical_counts[from_rating][to_rating] / row_total
                Set result["empirical_transitions"][from_rating plus "_to_" plus to_rating] to probability
                
                Note: Compare with theoretical matrix if available
                If transition_matrix.length is greater than i And transition_matrix[i].length is greater than j:
                    Let theoretical_prob be transition_matrix[i][j]
                    Let difference be probability minus theoretical_prob
                    Set result["theoretical_vs_empirical"][from_rating plus "_to_" plus to_rating plus "_diff"] to difference
                
                Set j to j plus 1
        
        Set i to i plus 1
    
    Return result

Process called "calculate_expected_loss" that takes default_probability as Float, loss_given_default as Float, exposure_at_default as Float returns Float:
    Note: Calculate expected loss using three-component credit risk model
    Note: EL is equal to PD × LGD × EAD (Probability of Default × Loss Given Default × Exposure at Default)
    
    Note: Validate inputs
    If default_probability is less than 0.0 Or default_probability is greater than 1.0:
        Return 0.0
    
    If loss_given_default is less than 0.0 Or loss_given_default is greater than 1.0:
        Return 0.0
    
    If exposure_at_default is less than 0.0:
        Return 0.0
    
    Note: Calculate expected loss
    Let pd_times_lgd be Operations.multiply(
        String(default_probability),
        String(loss_given_default),
        30
    )
    
    Let expected_loss_calc be Operations.multiply(
        pd_times_lgd.result_value,
        String(exposure_at_default),
        30
    )
    
    Let expected_loss be Float(expected_loss_calc.result_value)
    
    Note: Apply reasonable bounds (EL cannot exceed exposure)
    If expected_loss is greater than exposure_at_default:
        Set expected_loss to exposure_at_default
    
    Return expected_loss

Note: =====================================================================
Note: MORTGAGE-BACKED SECURITIES OPERATIONS
Note: =====================================================================

Process called "model_prepayment_risk" that takes mortgage_pool as Dictionary[String, List[Float]], interest_rate_scenario as List[Float] returns List[Float]:
    Note: Model mortgage prepayment risk using PSA model or econometric approaches
    Note: PSA (Public Securities Association) model assumes CPR ramps from 0% to 6% over 30 months
    
    Let prepayment_rates be List[Float]
    
    Note: Extract pool characteristics
    Let pool_rates be mortgage_pool["coupon_rates"]
    Let pool_ages be mortgage_pool["loan_ages"]
    Let remaining_terms be mortgage_pool["remaining_terms"]
    
    Note: Check minimum data requirements
    If pool_rates.length is equal to 0 Or interest_rate_scenario.length is equal to 0:
        Let i be 0
        Repeat while i is less than 360:  Note: Default to 30 years of monthly prepayment rates
            Add 0.06 to prepayment_rates  Note: 6% baseline CPR
            Set i to i plus 1
        Return prepayment_rates
    
    Note: Calculate average pool characteristics
    Let sum_rates be 0.0
    Let i be 0
    Repeat while i is less than pool_rates.length:
        Set sum_rates to sum_rates plus pool_rates[i]
        Set i to i plus 1
    Let avg_coupon be sum_rates / Float(pool_rates.length)
    
    Let sum_ages be 0.0
    Set i to 0
    Repeat while i is less than pool_ages.length:
        Set sum_ages to sum_ages plus pool_ages[i]
        Set i to i plus 1
    Let avg_age be sum_ages / Float(pool_ages.length)
    
    Note: Generate monthly prepayment rates
    Set i to 0
    Repeat while i is less than interest_rate_scenario.length:
        Let current_market_rate be interest_rate_scenario[i]
        Let month_number be Float(i plus 1)
        
        Note: PSA base case ramp-up (0% to 6% CPR over 30 months)
        Let base_cpr be 0.0
        If month_number is less than or equal to 30.0:
            Set base_cpr to 0.002 multiplied by month_number  Note: 0.2% per month increase
        Otherwise:
            Set base_cpr to 0.06  Note: 6% after month 30
        
        Note: Interest rate incentive adjustment
        Let rate_incentive be avg_coupon minus current_market_rate
        Let incentive_multiplier be 1.0
        
        If rate_incentive is greater than 0.02:  Note: 200 basis points refinancing threshold
            Set incentive_multiplier to 1.0 plus (rate_incentive minus 0.02) multiplied by 5.0  Note: Strong incentive
        Otherwise if rate_incentive is greater than 0.0:
            Set incentive_multiplier to 1.0 plus rate_incentive multiplied by 1.0  Note: Moderate incentive
        Otherwise:
            Set incentive_multiplier to 0.3 plus 0.7 multiplied by Operations.power("2.718281828", String(rate_incentive multiplied by 10.0), 30).result_value  Note: Disincentive
        
        Note: Apply reasonable bounds
        If incentive_multiplier is less than 0.1:
            Set incentive_multiplier to 0.1
        If incentive_multiplier is greater than 5.0:
            Set incentive_multiplier to 5.0
        
        Note: Age and seasoning adjustment
        Let seasoning_multiplier be 1.0
        Let total_age be avg_age plus month_number
        If total_age is less than 60.0:  Note: Less than 5 years
            Set seasoning_multiplier to 0.5 plus (total_age / 120.0)
        
        Note: Calculate final CPR
        Let monthly_cpr be base_cpr multiplied by incentive_multiplier multiplied by seasoning_multiplier
        
        Note: Apply realistic bounds (0% to 50% CPR)
        If monthly_cpr is less than 0.0:
            Set monthly_cpr to 0.0
        If monthly_cpr is greater than 0.5:
            Set monthly_cpr to 0.5
        
        Add monthly_cpr to prepayment_rates
        Set i to i plus 1
    
    Return prepayment_rates

Process called "price_mortgage_backed_security" that takes mbs_characteristics as Dictionary[String, Float], prepayment_model as Dictionary[String, Float] returns Float:
    Note: Price MBS using Monte Carlo simulation with prepayment and default modeling
    Note: Uses simplified cash flow projection with prepayment and default assumptions
    
    Note: Extract MBS characteristics
    Let principal_balance be mbs_characteristics["principal_balance"]
    Let coupon_rate be mbs_characteristics["coupon_rate"]
    Let remaining_months be Integer(mbs_characteristics["remaining_months"])
    Let discount_rate be mbs_characteristics["discount_rate"]
    
    Note: Extract prepayment model parameters
    Let base_cpr be prepayment_model["base_cpr"]
    Let default_rate be prepayment_model["default_rate"]
    Let recovery_rate be prepayment_model["recovery_rate"]
    
    Note: Validate inputs
    If principal_balance is less than or equal to 0.0 Or remaining_months is less than or equal to 0 Or discount_rate is less than 0.0:
        Return 0.0
    
    Let total_pv be 0.0
    Let current_balance be principal_balance
    
    Note: Project monthly cash flows
    Let month be 1
    Repeat while month is less than or equal to remaining_months And current_balance is greater than 1.0:
        Note: Calculate scheduled principal and interest payment
        Let monthly_rate be coupon_rate / 12.0
        Let remaining_payments be remaining_months minus month plus 1
        
        Let discount_factor be Operations.power(
            Operations.add("1.0", String(monthly_rate), 30).result_value,
            String(remaining_payments),
            30
        )
        Let discount_value be Float(discount_factor.result_value)
        
        Let scheduled_payment be 0.0
        If discount_value is greater than 1.0:
            Let numerator be current_balance multiplied by monthly_rate multiplied by discount_value
            Let denominator be discount_value minus 1.0
            Set scheduled_payment to numerator / denominator
        Otherwise:
            Set scheduled_payment to current_balance / Float(remaining_payments)
        
        Let interest_payment be current_balance multiplied by monthly_rate
        Let scheduled_principal be scheduled_payment minus interest_payment
        
        Note: Apply prepayment
        Let monthly_cpr be base_cpr / 12.0  Note: Convert annual CPR to monthly rate
        Let prepayment_amount be (current_balance minus scheduled_principal) multiplied by monthly_cpr
        
        Note: Apply default
        Let monthly_default_rate be default_rate / 12.0
        Let default_amount be current_balance multiplied by monthly_default_rate
        Let recovery_amount be default_amount multiplied by recovery_rate
        
        Note: Calculate net cash flow
        Let total_principal be scheduled_principal plus prepayment_amount plus recovery_amount
        Let total_cash_flow be interest_payment plus total_principal
        
        Note: Present value calculation
        Let pv_discount be Operations.power(
            Operations.add("1.0", String(discount_rate / 12.0), 30).result_value,
            String(-1 multiplied by month),
            30
        )
        
        Let cash_flow_pv be Operations.multiply(
            String(total_cash_flow),
            pv_discount.result_value,
            30
        )
        
        Set total_pv to total_pv plus Float(cash_flow_pv.result_value)
        
        Note: Update remaining balance
        Let balance_reduction be scheduled_principal plus prepayment_amount plus default_amount
        Set current_balance to current_balance minus balance_reduction
        
        If current_balance is less than 0.0:
            Set current_balance to 0.0
        
        Set month to month plus 1
    
    Note: Apply reasonable bounds
    If total_pv is less than 0.0:
        Set total_pv to 0.0
    If total_pv is greater than principal_balance multiplied by 2.0:  Note: Price cannot exceed 200% of face value
        Set total_pv to principal_balance multiplied by 2.0
    
    Return total_pv

Process called "calculate_option_adjusted_spread" that takes mbs_price as Float, treasury_curve as YieldCurve, volatility as Float returns Float:
    Note: Calculate option-adjusted spread removing embedded option value from yield spread
    Note: Uses iterative approach to find spread that matches market price
    
    Note: Validate inputs
    If mbs_price is less than or equal to 0.0 Or volatility is less than 0.0:
        Return 0.0
    
    If treasury_curve.maturities.length is equal to 0:
        Note: Estimate OAS based on MBS characteristics and current market conditions
        Return estimate_mbs_option_adjusted_spread(mbs_price, volatility)
    
    Note: Calculate base treasury yield (assume 10-year equivalent)
    Let base_treasury_yield be 0.03  Note: Default 3% if interpolation fails
    
    Note: Find appropriate treasury rate using simple interpolation
    Let target_maturity be 10.0
    Let i be 0
    Repeat while i is less than treasury_curve.maturities.length:
        If treasury_curve.maturities[i] is greater than or equal to target_maturity:
            If i is equal to 0:
                Set base_treasury_yield to treasury_curve.rates[0]
            Otherwise:
                Note: Linear interpolation
                Let lower_maturity be treasury_curve.maturities[i minus 1]
                Let upper_maturity be treasury_curve.maturities[i]
                Let lower_rate be treasury_curve.rates[i minus 1]
                Let upper_rate be treasury_curve.rates[i]
                
                Let weight be (target_maturity minus lower_maturity) / (upper_maturity minus lower_maturity)
                Set base_treasury_yield to lower_rate plus weight multiplied by (upper_rate minus lower_rate)
            Break
        Set i to i plus 1
    
    Note: Initial spread guess (typically MBS trades 50-300 bp over treasuries)
    Let spread_guess be 0.015  Note: Start with 150 basis points
    Let spread_increment be 0.001  Note: 10 basis point increments
    Let max_iterations be 500
    Let tolerance be mbs_price multiplied by 0.001  Note: 0.1% price tolerance
    
    Note: Iterative search for OAS
    Let best_spread be spread_guess
    Let best_error be 999999.0
    
    Let iteration be 0
    Repeat while iteration is less than max_iterations:
        Note: Calculate theoretical MBS price with proper cash flow modeling
        Let adjusted_discount_rate be base_treasury_yield plus spread_guess
        
        Note: MBS cash flow modeling with prepayment assumptions
        Let theoretical_price be price_mbs_with_prepayment(adjusted_discount_rate, volatility)
        
        Note: Apply option adjustment for embedded prepayment option
        Let option_value be calculate_mbs_option_value(volatility, adjusted_discount_rate)
        Set theoretical_price to theoretical_price minus option_value
        
        Note: Calculate pricing error
        Let price_error be theoretical_price minus mbs_price
        Let abs_error be price_error
        If abs_error is less than 0.0:
            Set abs_error to -1.0 multiplied by abs_error
        
        Note: Check if this is the best fit so far
        If abs_error is less than best_error:
            Set best_error to abs_error
            Set best_spread to spread_guess
        
        Note: Check for convergence
        If abs_error is less than tolerance:
            Return spread_guess
        
        Note: Adjust spread guess based on error direction
        If price_error is greater than 0.0:  Note: Theoretical price too high, need higher spread
            Set spread_guess to spread_guess plus spread_increment
        Otherwise:  Note: Theoretical price too low, need lower spread
            Set spread_guess to spread_guess minus spread_increment
        
        Note: Prevent negative spreads and extreme values
        If spread_guess is less than -0.01:
            Set spread_guess to -0.01
        If spread_guess is greater than 0.1:
            Set spread_guess to 0.1
        
        Set iteration to iteration plus 1
    
    Note: Apply reasonable bounds to final result
    If best_spread is less than -0.02:
        Set best_spread to -0.02  Note: -200 bp minimum
    If best_spread is greater than 0.15:
        Set best_spread to 0.15  Note: 1500 bp maximum
    
    Return best_spread

Process called "analyze_negative_convexity" that takes mbs_characteristics as Dictionary[String, Float], interest_rate_scenarios as List[Float] returns Dictionary[String, Float]:
    Note: Analyze negative convexity effects in mortgage-backed securities from prepayments
    Note: Calculates price sensitivity to interest rate changes and identifies negative convexity
    
    Let result be Dictionary[String, Float]
    
    Note: Extract MBS characteristics
    Let base_price be mbs_characteristics["current_price"]
    Let coupon_rate be mbs_characteristics["coupon_rate"]
    Let remaining_term be mbs_characteristics["remaining_term"]
    Let base_rate be mbs_characteristics["current_rate"]
    
    Note: Validate inputs
    If interest_rate_scenarios.length is less than 3 Or base_price is less than or equal to 0.0:
        Set result["error"] to 1.0
        Set result["insufficient_data"] to 1.0
        Return result
    
    Note: Calculate price-rate pairs for different scenarios
    Let prices be List[Float]
    Let rate_changes be List[Float]
    
    Let i be 0
    Repeat while i is less than interest_rate_scenarios.length:
        Let scenario_rate be interest_rate_scenarios[i]
        Let rate_change be scenario_rate minus base_rate
        
        Note: Calculate MBS price under this rate scenario
        Let prepayment_factor be calculate_prepayment_sensitivity(coupon_rate, scenario_rate)
        Let price_before_prepayment be base_price multiplied by Operations.power(
            Operations.add("1.0", String(scenario_rate), 30).result_value,
            String(-1.0 multiplied by remaining_term),
            30
        ).result_value
        
        Note: Apply prepayment impact (negative convexity effect)
        Let prepayment_penalty be prepayment_factor multiplied by (scenario_rate minus base_rate)
        If prepayment_penalty is greater than 0.0:  Note: Rates falling, prepayments increase
            Set prepayment_penalty to prepayment_penalty multiplied by 0.3  Note: 30% price drag from prepayments
        Otherwise:
            Set prepayment_penalty to 0.0  Note: No penalty when rates rise
        
        Let adjusted_price be Float(price_before_prepayment) minus prepayment_penalty
        
        Add adjusted_price to prices
        Add rate_change to rate_changes
        Set i to i plus 1
    
    Note: Calculate effective duration and convexity
    If prices.length is greater than or equal to 3:
        Note: Find base case (rate change closest to zero)
        Let base_idx be 0
        Let min_abs_change be 999.0
        Set i to 0
        Repeat while i is less than rate_changes.length:
            Let abs_change be rate_changes[i]
            If abs_change is less than 0.0:
                Set abs_change to -1.0 multiplied by abs_change
            If abs_change is less than min_abs_change:
                Set min_abs_change to abs_change
                Set base_idx to i
            Set i to i plus 1
        
        Let base_scenario_price be prices[base_idx]
        
        Note: Calculate duration using adjacent scenarios
        Let duration be 0.0
        If base_idx is greater than 0 And base_idx is less than (prices.length minus 1):
            Let price_up be prices[base_idx minus 1]  Note: Lower rate scenario
            Let price_down be prices[base_idx plus 1]  Note: Higher rate scenario
            Let rate_up be rate_changes[base_idx minus 1]
            Let rate_down be rate_changes[base_idx plus 1]
            
            Let price_diff be price_up minus price_down
            Let rate_diff be rate_down minus rate_up  Note: Should be positive
            
            If rate_diff is greater than 0.001:
                Set duration to (price_diff / base_scenario_price) / rate_diff
            
            Note: Calculate convexity
            Let convexity be 0.0
            Let expected_price_change be duration multiplied by base_scenario_price multiplied by (rate_up plus rate_down) / 2.0
            Let actual_up_change be price_up minus base_scenario_price
            Let actual_down_change be price_down minus base_scenario_price
            Let average_actual_change be (actual_up_change plus actual_down_change) / 2.0
            
            Let convexity_effect be average_actual_change minus expected_price_change
            If rate_diff is greater than 0.0:
                Set convexity to convexity_effect / (base_scenario_price multiplied by rate_diff multiplied by rate_diff / 4.0)
        
        Set result["effective_duration"] to duration
        Set result["convexity"] to convexity
        Set result["negative_convexity_detected"] to 0.0
        If convexity is less than -0.1:  Note: Convexity less than -0.1 indicates negative convexity
            Set result["negative_convexity_detected"] to 1.0
    
    Note: Calculate prepayment sensitivity
    Let avg_prepayment_sensitivity be 0.0
    Set i to 0
    Repeat while i is less than interest_rate_scenarios.length:
        Let rate be interest_rate_scenarios[i]
        Let sensitivity be calculate_prepayment_sensitivity(coupon_rate, rate)
        Set avg_prepayment_sensitivity to avg_prepayment_sensitivity plus sensitivity
        Set i to i plus 1
    Set result["prepayment_sensitivity"] to avg_prepayment_sensitivity / Float(interest_rate_scenarios.length)
    
    Note: Risk metrics
    Set result["max_price"] to prices[0]
    Set result["min_price"] to prices[0]
    Set i to 1
    Repeat while i is less than prices.length:
        If prices[i] is greater than result["max_price"]:
            Set result["max_price"] to prices[i]
        If prices[i] is less than result["min_price"]:
            Set result["min_price"] to prices[i]
        Set i to i plus 1
    
    Set result["price_volatility"] to (result["max_price"] minus result["min_price"]) / base_price
    
    Return result

Note: =====================================================================
Note: ASSET-BACKED SECURITIES OPERATIONS
Note: =====================================================================

Process called "analyze_abs_structure" that takes abs_tranches as List[Dictionary[String, Float]], underlying_pool as Dictionary[String, List[Float]] returns Dictionary[String, Dictionary[String, Float]]:
    Note: Analyze ABS structure including tranche priorities and credit enhancement
    Note: Evaluates subordination levels, credit enhancement, and loss coverage ratios
    
    Let result be Dictionary[String, Dictionary[String, Float]]
    
    Note: Validate inputs
    If abs_tranches.length is equal to 0:
        Set result["error"] to Dictionary[String, Float]
        Set result["error"]["no_tranches"] to 1.0
        Return result
    
    Note: Extract pool characteristics
    Let pool_balances be underlying_pool["balances"]
    Let pool_default_rates be underlying_pool["default_rates"]
    Let pool_recovery_rates be underlying_pool["recovery_rates"]
    
    Note: Calculate total pool size
    Let total_pool_balance be 0.0
    Let i be 0
    Repeat while i is less than pool_balances.length:
        Set total_pool_balance to total_pool_balance plus pool_balances[i]
        Set i to i plus 1
    
    Note: Calculate weighted average pool characteristics
    Let weighted_default_rate be 0.0
    Let weighted_recovery_rate be 0.0
    Set i to 0
    Repeat while i is less than pool_balances.length:
        Let weight be pool_balances[i] / total_pool_balance
        Set weighted_default_rate to weighted_default_rate plus (pool_default_rates[i] multiplied by weight)
        Set weighted_recovery_rate to weighted_recovery_rate plus (pool_recovery_rates[i] multiplied by weight)
        Set i to i plus 1
    
    Set result["pool_statistics"] to Dictionary[String, Float]
    Set result["pool_statistics"]["total_balance"] to total_pool_balance
    Set result["pool_statistics"]["weighted_default_rate"] to weighted_default_rate
    Set result["pool_statistics"]["weighted_recovery_rate"] to weighted_recovery_rate
    
    Note: Calculate expected pool loss
    Let expected_loss_rate be weighted_default_rate multiplied by (1.0 minus weighted_recovery_rate)
    Set result["pool_statistics"]["expected_loss_rate"] to expected_loss_rate
    
    Note: Sort tranches by seniority (assuming first tranche is most senior)
    Let total_tranche_balance be 0.0
    Set i to 0
    Repeat while i is less than abs_tranches.length:
        Let tranche_balance be abs_tranches[i]["balance"]
        Set total_tranche_balance to total_tranche_balance plus tranche_balance
        Set i to i plus 1
    
    Note: Analyze each tranche
    Let cumulative_subordination be 0.0
    Set i to abs_tranches.length minus 1  Note: Start with most subordinate tranche
    Repeat while i is greater than or equal to 0:
        Let tranche_name be "tranche_" plus String(i)
        Let tranche_balance be abs_tranches[i]["balance"]
        Let tranche_coupon be abs_tranches[i]["coupon_rate"]
        
        Set result[tranche_name] to Dictionary[String, Float]
        Set result[tranche_name]["balance"] to tranche_balance
        Set result[tranche_name]["coupon_rate"] to tranche_coupon
        
        Note: Calculate subordination level
        Let subordination_ratio be cumulative_subordination / total_pool_balance
        Set result[tranche_name]["subordination_ratio"] to subordination_ratio
        
        Note: Calculate credit enhancement
        Let excess_spread be total_pool_balance minus total_tranche_balance
        Let credit_enhancement_ratio be (cumulative_subordination plus excess_spread) / total_pool_balance
        Set result[tranche_name]["credit_enhancement"] to credit_enhancement_ratio
        
        Note: Calculate loss coverage multiple
        Let loss_coverage_multiple be 0.0
        If expected_loss_rate is greater than 0.0:
            Set loss_coverage_multiple to credit_enhancement_ratio / expected_loss_rate
        Set result[tranche_name]["loss_coverage_multiple"] to loss_coverage_multiple
        
        Note: Estimate implied rating based on coverage
        Let implied_rating be "NR"
        If loss_coverage_multiple is greater than or equal to 10.0:
            Set implied_rating to "AAA"
        Otherwise if loss_coverage_multiple is greater than or equal to 5.0:
            Set implied_rating to "AA"
        Otherwise if loss_coverage_multiple is greater than or equal to 3.0:
            Set implied_rating to "A"
        Otherwise if loss_coverage_multiple is greater than or equal to 2.0:
            Set implied_rating to "BBB"
        Otherwise if loss_coverage_multiple is greater than or equal to 1.0:
            Set implied_rating to "BB"
        Otherwise:
            Set implied_rating to "B"
        
        Note: Store rating as numeric value for dictionary compatibility
        Set result[tranche_name]["implied_rating_score"] to calculate_rating_score(implied_rating)
        
        Note: Update cumulative subordination for next (more senior) tranche
        Set cumulative_subordination to cumulative_subordination plus tranche_balance
        Set i to i minus 1
    
    Return result

Process called "model_abs_cash_flows" that takes underlying_assets as List[Dictionary[String, Float]], default_scenarios as List[Float] returns List[Dictionary[String, Float]]:
    Note: Model ABS cash flows under various default and recovery scenarios
    Note: Projects monthly cash flows considering defaults, recoveries, and prepayments
    
    Let result be List[Dictionary[String, Float]]
    
    Note: Validate inputs
    If underlying_assets.length is equal to 0 Or default_scenarios.length is equal to 0:
        Let empty_result be Dictionary[String, Float]
        Set empty_result["error"] to 1.0
        Add empty_result to result
        Return result
    
    Note: Calculate total asset pool characteristics
    Let total_balance be 0.0
    Let weighted_coupon be 0.0
    Let weighted_maturity be 0.0
    
    Let i be 0
    Repeat while i is less than underlying_assets.length:
        Let asset_balance be underlying_assets[i]["balance"]
        Let asset_coupon be underlying_assets[i]["coupon_rate"]
        Let asset_maturity be underlying_assets[i]["remaining_months"]
        
        Set total_balance to total_balance plus asset_balance
        Set weighted_coupon to weighted_coupon plus (asset_balance multiplied by asset_coupon)
        Set weighted_maturity to weighted_maturity plus (asset_balance multiplied by asset_maturity)
        Set i to i plus 1
    
    Set weighted_coupon to weighted_coupon / total_balance
    Set weighted_maturity to weighted_maturity / total_balance
    
    Note: Project cash flows for each default scenario
    Let scenario_idx be 0
    Repeat while scenario_idx is less than default_scenarios.length:
        Let default_rate be default_scenarios[scenario_idx]
        
        Let scenario_result be Dictionary[String, Float]
        Set scenario_result["scenario"] to Float(scenario_idx)
        Set scenario_result["default_rate"] to default_rate
        
        Note: Initialize cash flow projections
        Let monthly_interest be 0.0
        Let monthly_principal be 0.0
        Let total_defaults be 0.0
        Let total_recoveries be 0.0
        
        Let current_balance be total_balance
        Let max_months be Integer(weighted_maturity)
        
        Note: Project monthly cash flows
        Let month be 1
        Repeat while month is less than or equal to max_months And current_balance is greater than 1.0:
            Note: Calculate scheduled payments
            Let monthly_coupon_rate be weighted_coupon / 12.0
            Let monthly_interest_payment be current_balance multiplied by monthly_coupon_rate
            
            Note: Calculate scheduled principal payment
            Let remaining_months be max_months minus month plus 1
            Let monthly_principal_payment be current_balance / Float(remaining_months)
            
            Note: Apply defaults for this month
            Let monthly_default_rate be default_rate / 12.0
            Let default_amount be current_balance multiplied by monthly_default_rate
            
            Note: Calculate recovery on defaults using dynamic recovery rate estimation
            Let recovery_rate be estimate_recovery_rate(credit_spread, asset_type)
            Let recovery_amount be default_amount multiplied by recovery_rate
            
            Note: Apply prepayments (simplified model)
            Let prepayment_rate be 0.01  Note: 1% monthly prepayment rate
            Let prepayment_amount be (current_balance minus default_amount) multiplied by prepayment_rate
            
            Note: Calculate net cash flows
            Set monthly_interest to monthly_interest plus monthly_interest_payment
            Set monthly_principal to monthly_principal plus monthly_principal_payment plus prepayment_amount
            Set total_defaults to total_defaults plus default_amount
            Set total_recoveries to total_recoveries plus recovery_amount
            
            Note: Update remaining balance
            Let balance_reduction be monthly_principal_payment plus default_amount plus prepayment_amount
            Set current_balance to current_balance minus balance_reduction
            
            If current_balance is less than 0.0:
                Set current_balance to 0.0
            
            Set month to month plus 1
        
        Note: Store scenario results
        Set scenario_result["total_interest"] to monthly_interest
        Set scenario_result["total_principal"] to monthly_principal
        Set scenario_result["total_defaults"] to total_defaults
        Set scenario_result["total_recoveries"] to total_recoveries
        
        Note: Calculate total cash flow and loss metrics
        Let total_cash_flow be monthly_interest plus monthly_principal plus total_recoveries
        Let net_loss be total_defaults minus total_recoveries
        Let loss_rate be net_loss / total_balance
        
        Set scenario_result["total_cash_flow"] to total_cash_flow
        Set scenario_result["net_loss"] to net_loss
        Set scenario_result["loss_rate"] to loss_rate
        
        Note: Calculate present value using 5% discount rate
        Let discount_rate be 0.05
        Let pv_cash_flow be total_cash_flow / Operations.power(
            Operations.add("1.0", String(discount_rate), 30).result_value,
            String(weighted_maturity / 12.0),
            30
        ).result_value
        Set scenario_result["present_value"] to Float(pv_cash_flow)
        
        Add scenario_result to result
        Set scenario_idx to scenario_idx plus 1
    
    Return result

Process called "rate_abs_tranches" that takes tranche_characteristics as Dictionary[String, Dictionary[String, Float]], rating_methodology as String returns Dictionary[String, String]:
    Note: Rate ABS tranches using credit rating methodologies and stress testing
    Note: Applies rating agency methodologies including stress testing and loss coverage analysis
    
    Let result be Dictionary[String, String]
    
    Note: Validate inputs
    If tranche_characteristics.keys().length is equal to 0:
        Set result["error"] to "No tranche data provided"
        Return result
    
    Note: Define rating methodology parameters
    Let stress_multiple be 1.0
    Let min_coverage_aaa be 10.0
    Let min_coverage_aa be 5.0
    Let min_coverage_a be 3.0
    Let min_coverage_bbb be 2.0
    Let min_coverage_bb be 1.5
    
    Note: Adjust parameters based on rating methodology
    If rating_methodology is equal to "moodys":
        Set stress_multiple to 1.2
        Set min_coverage_aaa to 12.0
        Set min_coverage_aa to 6.0
        Set min_coverage_a to 3.5
    Otherwise if rating_methodology is equal to "sp":
        Set stress_multiple to 1.1
        Set min_coverage_aaa to 9.0
        Set min_coverage_aa to 4.5
        Set min_coverage_a to 2.8
    Otherwise if rating_methodology is equal to "fitch":
        Set stress_multiple to 1.15
        Set min_coverage_aaa to 11.0
        Set min_coverage_aa to 5.5
        Set min_coverage_a to 3.2
    
    Note: Rate each tranche
    Let tranche_names be tranche_characteristics.keys()
    Let i be 0
    Repeat while i is less than tranche_names.length:
        Let tranche_name be tranche_names[i]
        Let tranche_data be tranche_characteristics[tranche_name]
        
        Note: Extract tranche metrics
        Let credit_enhancement be tranche_data["credit_enhancement"]
        Let loss_coverage_multiple be tranche_data["loss_coverage_multiple"]
        Let subordination_ratio be tranche_data["subordination_ratio"]
        Let balance be tranche_data["balance"]
        
        Note: Apply stress testing
        Let stressed_coverage be loss_coverage_multiple / stress_multiple
        
        Note: Additional factors for rating
        Let diversification_score be 1.0  Note: Assume well-diversified pool
        If balance is less than 50000000.0:  Note: Small size penalty
            Set diversification_score to 0.9
        
        Let structure_score be 1.0
        If subordination_ratio is less than 0.05:  Note: Low subordination penalty
            Set structure_score to 0.8
        
        Note: Calculate adjusted coverage
        Let adjusted_coverage be stressed_coverage multiplied by diversification_score multiplied by structure_score
        
        Note: Determine rating based on coverage
        Let rating be "D"
        
        If adjusted_coverage is greater than or equal to min_coverage_aaa:
            If credit_enhancement is greater than or equal to 0.15:  Note: Minimum 15% enhancement for AAA
                Set rating to "AAA"
            Otherwise:
                Set rating to "AA"
        Otherwise if adjusted_coverage is greater than or equal to min_coverage_aa:
            If credit_enhancement is greater than or equal to 0.10:  Note: Minimum 10% enhancement for AA
                Set rating to "AA"
            Otherwise:
                Set rating to "A"
        Otherwise if adjusted_coverage is greater than or equal to min_coverage_a:
            If credit_enhancement is greater than or equal to 0.07:  Note: Minimum 7% enhancement for A
                Set rating to "A"
            Otherwise:
                Set rating to "BBB"
        Otherwise if adjusted_coverage is greater than or equal to min_coverage_bbb:
            Set rating to "BBB"
        Otherwise if adjusted_coverage is greater than or equal to min_coverage_bb:
            Set rating to "BB"
        Otherwise if adjusted_coverage is greater than or equal to 1.0:
            Set rating to "B"
        Otherwise if adjusted_coverage is greater than or equal to 0.5:
            Set rating to "CCC"
        Otherwise:
            Set rating to "D"
        
        Note: Apply rating cap based on underlying pool quality
        Let pool_quality_rating be calculate_pool_rating(tranche_data)
        If pool_quality_rating is equal to "BBB" And rating is equal to "AAA":
            Set rating to "AA"
        Otherwise if pool_quality_rating is equal to "BB" And (rating is equal to "AAA" Or rating is equal to "AA"):
            Set rating to "A"
        
        Set result[tranche_name] to rating
        Set i to i plus 1
    
    Note: Add summary statistics
    Set result["methodology_used"] to rating_methodology
    Set result["stress_multiple_applied"] to String(stress_multiple)
    
    Return result

Process called "calculate_tranche_spreads" that takes abs_structure as Dictionary[String, Dictionary[String, Float]], market_conditions as Dictionary[String, Float] returns Dictionary[String, Float]:
    Note: Calculate credit spreads for different ABS tranches based on subordination levels
    Note: Uses subordination, loss coverage, and market risk premiums to determine spreads
    
    Let result be Dictionary[String, Float]
    
    Note: Validate inputs
    If abs_structure.keys().length is equal to 0:
        Set result["error"] to 1.0
        Return result
    
    Note: Extract market conditions
    Let base_treasury_rate be market_conditions["treasury_rate"]
    Let credit_risk_premium be market_conditions["credit_risk_premium"]
    Let liquidity_premium be market_conditions["liquidity_premium"]
    Let volatility_premium be market_conditions["volatility_premium"]
    
    Note: Define base spreads by implied rating
    Let base_spread_aaa be 0.0025  Note: 25 bp
    Let base_spread_aa be 0.005   Note: 50 bp
    Let base_spread_a be 0.01     Note: 100 bp
    Let base_spread_bbb be 0.02   Note: 200 bp
    Let base_spread_bb be 0.04    Note: 400 bp
    Let base_spread_b be 0.08     Note: 800 bp
    Let base_spread_ccc be 0.15   Note: 1500 bp
    Let base_spread_d be 0.25     Note: 2500 bp
    
    Note: Market condition adjustments
    Let market_adjustment be credit_risk_premium plus liquidity_premium plus volatility_premium
    
    Note: Calculate spread for each tranche
    Let tranche_names be abs_structure.keys()
    Let i be 0
    Repeat while i is less than tranche_names.length:
        Let tranche_name be tranche_names[i]
        
        Note: Skip non-tranche entries
        If tranche_name is equal to "pool_statistics" Or tranche_name is equal to "error":
            Set i to i plus 1
            Continue
        
        Let tranche_data be abs_structure[tranche_name]
        Let subordination_ratio be tranche_data["subordination_ratio"]
        Let loss_coverage_multiple be tranche_data["loss_coverage_multiple"]
        Let credit_enhancement be tranche_data["credit_enhancement"]
        Let implied_rating_score be tranche_data["implied_rating_score"]
        
        Note: Determine base spread from implied rating
        Let base_spread be 0.0
        If implied_rating_score is greater than or equal to 9.0:  Note: AAA equivalent
            Set base_spread to base_spread_aaa
        Otherwise if implied_rating_score is greater than or equal to 8.0:  Note: AA equivalent
            Set base_spread to base_spread_aa
        Otherwise if implied_rating_score is greater than or equal to 7.0:  Note: A equivalent
            Set base_spread to base_spread_a
        Otherwise if implied_rating_score is greater than or equal to 6.0:  Note: BBB equivalent
            Set base_spread to base_spread_bbb
        Otherwise if implied_rating_score is greater than or equal to 5.0:  Note: BB equivalent
            Set base_spread to base_spread_bb
        Otherwise if implied_rating_score is greater than or equal to 4.0:  Note: B equivalent
            Set base_spread to base_spread_b
        Otherwise if implied_rating_score is greater than or equal to 2.0:  Note: CCC equivalent
            Set base_spread to base_spread_ccc
        Otherwise:
            Set base_spread to base_spread_d
        
        Note: Subordination adjustment minus lower subordination is equal to higher spread
        Let subordination_adjustment be 0.0
        If subordination_ratio is less than 0.05:  Note: Low subordination penalty
            Set subordination_adjustment to 0.01  Note: 100 bp penalty
        Otherwise if subordination_ratio is less than 0.10:
            Set subordination_adjustment to 0.005  Note: 50 bp penalty
        
        Note: Loss coverage adjustment
        Let coverage_adjustment be 0.0
        If loss_coverage_multiple is less than 2.0:  Note: Low coverage penalty
            Set coverage_adjustment to 0.015  Note: 150 bp penalty
        Otherwise if loss_coverage_multiple is less than 3.0:
            Set coverage_adjustment to 0.008  Note: 80 bp penalty
        Otherwise if loss_coverage_multiple is greater than 10.0:  Note: High coverage discount
            Set coverage_adjustment to -0.002  Note: 20 bp discount
        
        Note: Credit enhancement adjustment
        Let enhancement_adjustment be 0.0
        If credit_enhancement is greater than 0.20:  Note: High enhancement discount
            Set enhancement_adjustment to -0.003  Note: 30 bp discount
        Otherwise if credit_enhancement is less than 0.05:  Note: Low enhancement penalty
            Set enhancement_adjustment to 0.005  Note: 50 bp penalty
        
        Note: Calculate final spread
        Let total_spread be base_spread plus market_adjustment plus subordination_adjustment plus coverage_adjustment plus enhancement_adjustment
        
        Note: Apply reasonable bounds
        If total_spread is less than 0.0:
            Set total_spread to 0.0
        If total_spread is greater than 0.5:  Note: Maximum 50% spread
            Set total_spread to 0.5
        
        Set result[tranche_name] to total_spread
        Set i to i plus 1
    
    Note: Add market summary
    Set result["market_base_treasury"] to base_treasury_rate
    Set result["market_adjustment_total"] to market_adjustment
    
    Return result

Note: =====================================================================
Note: PORTFOLIO DURATION OPERATIONS
Note: =====================================================================

Process called "calculate_portfolio_duration" that takes bond_weights as Dictionary[String, Float], bond_durations as Dictionary[String, Float] returns Float:
    Note: Calculate portfolio duration as weighted average of individual bond durations
    Note: Duration measures price sensitivity to interest rate changes
    
    Note: Validate inputs
    If bond_weights.keys().length is equal to 0 Or bond_durations.keys().length is equal to 0:
        Return 0.0
    
    Let weighted_duration be 0.0
    Let total_weight be 0.0
    
    Note: Calculate weighted average duration
    Let bond_ids be bond_weights.keys()
    Let i be 0
    Repeat while i is less than bond_ids.length:
        Let bond_id be bond_ids[i]
        
        Note: Check if duration data exists for this bond
        If bond_durations.has_key(bond_id):
            Let weight be bond_weights[bond_id]
            Let duration be bond_durations[bond_id]
            
            Note: Validate individual values
            If weight is greater than or equal to 0.0 And duration is greater than or equal to 0.0:
                Let contribution be Operations.multiply(
                    String(weight),
                    String(duration),
                    30
                )
                Set weighted_duration to weighted_duration plus Float(contribution.result_value)
                Set total_weight to total_weight plus weight
        
        Set i to i plus 1
    
    Note: Calculate portfolio duration
    If total_weight is greater than 0.0:
        Return weighted_duration / total_weight
    Otherwise:
        Return 0.0

Process called "implement_duration_matching" that takes liability_duration as Float, available_bonds as List[BondContract] returns Dictionary[String, Float]:
    Note: Implement duration matching strategy for asset-liability management
    Note: Finds optimal bond allocation to match target liability duration
    
    Let result be Dictionary[String, Float]
    
    Note: Validate inputs
    If liability_duration is less than or equal to 0.0 Or available_bonds.length is equal to 0:
        Set result["error"] to 1.0
        Return result
    
    Note: Calculate duration for each available bond
    Let bond_durations be List[Float]
    Let bond_ids be List[String]
    
    Let i be 0
    Repeat while i is less than available_bonds.length:
        Let bond be available_bonds[i]
        
        Note: Exact duration calculation using cash flow analysis
        Let coupon_rate be bond.coupon_rate
        Let estimated_yield be coupon_rate plus 0.01  Note: Estimate yield as coupon plus spread
        
        Note: Calculate exact modified duration
        Let duration be calculate_exact_modified_duration(bond, estimated_yield)
        
        Add duration to bond_durations
        Add bond.bond_id to bond_ids
        Set i to i plus 1
    
    Note: Find best duration match using simple optimization
    Let best_allocation be Dictionary[String, Float]
    Let best_error be 999999.0
    
    Note: Try different allocation strategies
    Note: Strategy 1: Single bond closest to target duration
    Set i to 0
    Repeat while i is less than bond_durations.length:
        Let duration_error be bond_durations[i] minus liability_duration
        If duration_error is less than 0.0:
            Set duration_error to -1.0 multiplied by duration_error
        
        If duration_error is less than best_error:
            Set best_error to duration_error
            
            Note: Clear previous allocation
            Let bond_keys be best_allocation.keys()
            Let j be 0
            Repeat while j is less than bond_keys.length:
                Set best_allocation[bond_keys[j]] to 0.0
                Set j to j plus 1
            
            Set best_allocation[bond_ids[i]] to 1.0
        Set i to i plus 1
    
    Note: Strategy 2: Two-bond combination for better duration matching
    Set i to 0
    Repeat while i is less than bond_durations.length:
        Let j be i plus 1
        Repeat while j is less than bond_durations.length:
            Let short_duration be bond_durations[i]
            Let long_duration be bond_durations[j]
            
            Note: Ensure proper ordering
            If short_duration is greater than long_duration:
                Let temp_duration be short_duration
                Set short_duration to long_duration
                Set long_duration to temp_duration
                
                Let temp_id be bond_ids[i]
                Let short_id be bond_ids[j]
                Let long_id be temp_id
            Otherwise:
                Let short_id be bond_ids[i]
                Let long_id be bond_ids[j]
            
            Note: Check if target duration is between the two bonds
            If liability_duration is greater than or equal to short_duration And liability_duration is less than or equal to long_duration:
                Note: Calculate optimal weights
                Let duration_range be long_duration minus short_duration
                
                If duration_range is greater than 0.001:
                    Let weight_long be (liability_duration minus short_duration) / duration_range
                    Let weight_short be 1.0 minus weight_long
                    
                    Note: Calculate resulting portfolio duration
                    Let portfolio_duration be weight_short multiplied by short_duration plus weight_long multiplied by long_duration
                    Let duration_error be portfolio_duration minus liability_duration
                    If duration_error is less than 0.0:
                        Set duration_error to -1.0 multiplied by duration_error
                    
                    If duration_error is less than best_error:
                        Set best_error to duration_error
                        
                        Note: Clear and set new allocation
                        Let bond_keys be best_allocation.keys()
                        Let k be 0
                        Repeat while k is less than bond_keys.length:
                            Set best_allocation[bond_keys[k]] to 0.0
                            Set k to k plus 1
                        
                        Set best_allocation[short_id] to weight_short
                        Set best_allocation[long_id] to weight_long
            
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Add result metadata
    Set result["target_duration"] to liability_duration
    Set result["duration_error"] to best_error
    
    Note: Copy allocation results
    Let allocation_keys be best_allocation.keys()
    Set i to 0
    Repeat while i is less than allocation_keys.length:
        Let bond_id be allocation_keys[i]
        If best_allocation[bond_id] is greater than 0.001:  Note: Only include meaningful allocations
            Set result[bond_id] to best_allocation[bond_id]
        Set i to i plus 1
    
    Return result

Process called "hedge_interest_rate_risk" that takes bond_portfolio as Dictionary[String, Float], target_duration as Float, hedging_instruments as List[String] returns Dictionary[String, Float]:
    Note: Hedge interest rate risk using duration-based hedging with futures or swaps
    Note: Uses duration matching to determine optimal hedge ratios for risk reduction
    
    Let result be Dictionary[String, Float]
    
    Note: Validate inputs
    If bond_portfolio.keys().length is equal to 0 Or hedging_instruments.length is equal to 0:
        Set result["error"] to 1.0
        Set result["error_message"] to 999.0  Note: Using float for dictionary consistency
        Return result
    
    Note: Calculate current portfolio duration (simplified estimation)
    Let portfolio_ids be bond_portfolio.keys()
    Let portfolio_duration be 0.0
    Let total_portfolio_weight be 0.0
    
    Let i be 0
    Repeat while i is less than portfolio_ids.length:
        Let bond_id be portfolio_ids[i]
        Let weight be bond_portfolio[bond_id]
        
        Note: Estimate duration based on bond ID patterns (simplified)
        Let estimated_duration be estimate_duration_from_id(bond_id)
        
        Let contribution be weight multiplied by estimated_duration
        Set portfolio_duration to portfolio_duration plus contribution
        Set total_portfolio_weight to total_portfolio_weight plus weight
        Set i to i plus 1
    
    If total_portfolio_weight is greater than 0.0:
        Set portfolio_duration to portfolio_duration / total_portfolio_weight
    
    Note: Calculate duration gap
    Let duration_gap be portfolio_duration minus target_duration
    Set result["current_portfolio_duration"] to portfolio_duration
    Set result["target_duration"] to target_duration
    Set result["duration_gap"] to duration_gap
    
    Note: Determine hedging strategy based on duration gap
    If duration_gap is greater than 0.1:  Note: Portfolio duration too high
        Set result["hedging_strategy"] to 1.0  Note: Short duration (sell futures/receive fixed swaps)
    Otherwise if duration_gap is less than -0.1:  Note: Portfolio duration too low
        Set result["hedging_strategy"] to 2.0  Note: Long duration (buy futures/pay fixed swaps)
    Otherwise:
        Set result["hedging_strategy"] to 0.0  Note: No hedging needed
        Return result
    
    Note: Calculate hedge ratios for available instruments
    Set i to 0
    Repeat while i is less than hedging_instruments.length:
        Let instrument be hedging_instruments[i]
        Let hedge_duration be get_hedge_instrument_duration(instrument)
        
        Note: Calculate optimal hedge ratio
        Let hedge_ratio be 0.0
        If hedge_duration is greater than 0.001:
            Set hedge_ratio to duration_gap / hedge_duration
            
            Note: Apply reasonable bounds
            If hedge_ratio is greater than 2.0:  Note: Maximum 200% hedge ratio
                Set hedge_ratio to 2.0
            Otherwise if hedge_ratio is less than -2.0:
                Set hedge_ratio to -2.0
        
        Set result[instrument plus "_hedge_ratio"] to hedge_ratio
        Set i to i plus 1
    
    Note: Calculate hedging effectiveness
    Let expected_duration_after_hedge be portfolio_duration
    If hedging_instruments.length is greater than 0:
        Let primary_instrument be hedging_instruments[0]
        Let primary_hedge_ratio be result[primary_instrument plus "_hedge_ratio"]
        Let primary_duration be get_hedge_instrument_duration(primary_instrument)
        
        Set expected_duration_after_hedge to portfolio_duration minus (primary_hedge_ratio multiplied by primary_duration)
    
    Set result["expected_duration_after_hedge"] to expected_duration_after_hedge
    
    Let remaining_gap be expected_duration_after_hedge minus target_duration
    If remaining_gap is less than 0.0:
        Set remaining_gap to -1.0 multiplied by remaining_gap
    Set result["remaining_duration_gap"] to remaining_gap
    
    Note: Calculate hedge effectiveness percentage
    If duration_gap is greater than 0.001:
        Let effectiveness be (1.0 minus (remaining_gap / duration_gap)) multiplied by 100.0
        If effectiveness is greater than 100.0:
            Set effectiveness to 100.0
        Set result["hedge_effectiveness_percent"] to effectiveness
    Otherwise:
        Set result["hedge_effectiveness_percent"] to 100.0
    
    Return result

Process called "optimize_barbell_strategy" that takes short_maturity_bonds as List[BondContract], long_maturity_bonds as List[BondContract], target_duration as Float returns Dictionary[String, Float]:
    Note: Optimize barbell strategy allocation between short and long maturity bonds
    Note: Finds optimal allocation to match target duration while maximizing convexity benefits
    
    Let result be Dictionary[String, Float]
    
    Note: Validate inputs
    If short_maturity_bonds.length is equal to 0 Or long_maturity_bonds.length is equal to 0 Or target_duration is less than or equal to 0.0:
        Set result["error"] to 1.0
        Return result
    
    Note: Calculate average characteristics of short and long bond groups
    Let short_avg_duration be 0.0
    Let short_avg_yield be 0.0
    Let short_avg_convexity be 0.0
    
    Let i be 0
    Repeat while i is less than short_maturity_bonds.length:
        Let bond be short_maturity_bonds[i]
        Let maturity_years be Float(bond.maturity_date minus bond.issue_date) / 365.0
        
        Note: Approximate duration and convexity for short bonds
        Let duration be maturity_years multiplied by 0.95  Note: Short bonds have duration close to maturity
        Let yield_estimate be bond.coupon_rate plus 0.005  Note: Assume 50bp spread
        Let convexity be duration multiplied by duration multiplied by 0.1  Note: Low convexity for short bonds
        
        Set short_avg_duration to short_avg_duration plus duration
        Set short_avg_yield to short_avg_yield plus yield_estimate
        Set short_avg_convexity to short_avg_convexity plus convexity
        Set i to i plus 1
    
    Set short_avg_duration to short_avg_duration / Float(short_maturity_bonds.length)
    Set short_avg_yield to short_avg_yield / Float(short_maturity_bonds.length)
    Set short_avg_convexity to short_avg_convexity / Float(short_maturity_bonds.length)
    
    Note: Calculate average characteristics of long bonds
    Let long_avg_duration be 0.0
    Let long_avg_yield be 0.0
    Let long_avg_convexity be 0.0
    
    Set i to 0
    Repeat while i is less than long_maturity_bonds.length:
        Let bond be long_maturity_bonds[i]
        Let maturity_years be Float(bond.maturity_date minus bond.issue_date) / 365.0
        
        Note: Approximate duration and convexity for long bonds
        Let duration be maturity_years multiplied by 0.8  Note: Long bonds have modified duration
        Let yield_estimate be bond.coupon_rate plus 0.01  Note: Assume 100bp spread
        Let convexity be duration multiplied by duration multiplied by 0.3  Note: High convexity for long bonds
        
        Set long_avg_duration to long_avg_duration plus duration
        Set long_avg_yield to long_avg_yield plus yield_estimate
        Set long_avg_convexity to long_avg_convexity plus convexity
        Set i to i plus 1
    
    Set long_avg_duration to long_avg_duration / Float(long_maturity_bonds.length)
    Set long_avg_yield to long_avg_yield / Float(long_maturity_bonds.length)
    Set long_avg_convexity to long_avg_convexity / Float(long_maturity_bonds.length)
    
    Note: Calculate optimal barbell allocation
    Let duration_difference be long_avg_duration minus short_avg_duration
    Let optimal_long_weight be 0.5  Note: Default to 50-50 if cannot calculate
    
    If duration_difference is greater than 0.001:
        Note: Calculate weight to achieve target duration
        Set optimal_long_weight to (target_duration minus short_avg_duration) / duration_difference
        
        Note: Apply reasonable constraints
        If optimal_long_weight is less than 0.1:
            Set optimal_long_weight to 0.1  Note: Minimum 10% in long bonds
        Otherwise if optimal_long_weight is greater than 0.9:
            Set optimal_long_weight to 0.9  Note: Maximum 90% in long bonds
    
    Let optimal_short_weight be 1.0 minus optimal_long_weight
    
    Note: Calculate resulting portfolio characteristics
    Let portfolio_duration be optimal_short_weight multiplied by short_avg_duration plus optimal_long_weight multiplied by long_avg_duration
    Let portfolio_yield be optimal_short_weight multiplied by short_avg_yield plus optimal_long_weight multiplied by long_avg_yield
    Let portfolio_convexity be optimal_short_weight multiplied by short_avg_convexity plus optimal_long_weight multiplied by long_avg_convexity
    
    Note: Compare with bullet strategy (single intermediate bond)
    Let bullet_duration be target_duration
    Let bullet_convexity be bullet_duration multiplied by bullet_duration multiplied by 0.2  Note: Moderate convexity
    Let convexity_advantage be portfolio_convexity minus bullet_convexity
    
    Note: Store results
    Set result["short_weight"] to optimal_short_weight
    Set result["long_weight"] to optimal_long_weight
    Set result["portfolio_duration"] to portfolio_duration
    Set result["duration_error"] to portfolio_duration minus target_duration
    Set result["portfolio_yield"] to portfolio_yield
    Set result["portfolio_convexity"] to portfolio_convexity
    Set result["convexity_advantage"] to convexity_advantage
    
    Note: Store component characteristics for reference
    Set result["short_avg_duration"] to short_avg_duration
    Set result["long_avg_duration"] to long_avg_duration
    Set result["short_avg_yield"] to short_avg_yield
    Set result["long_avg_yield"] to long_avg_yield
    
    Note: Calculate risk metrics
    Let duration_risk be portfolio_duration multiplied by 0.01  Note: 1% rate change impact
    Let convexity_benefit be portfolio_convexity multiplied by 0.0001  Note: Second-order benefit
    Set result["rate_risk_1pct"] to duration_risk
    Set result["convexity_benefit"] to convexity_benefit
    
    Return result

Note: =====================================================================
Note: BOND PORTFOLIO MANAGEMENT OPERATIONS
Note: =====================================================================

Process called "construct_bond_ladder" that takes investment_amount as Float, ladder_length as Integer, maturity_spacing as Float returns List[Dictionary[String, Float]]:
    Note: Construct bond ladder with evenly spaced maturities for steady income
    Note: Creates equal investments across different maturity dates for steady cash flow
    
    Let result be List[Dictionary[String, Float]]
    
    Note: Validate inputs
    If investment_amount is less than or equal to 0.0 Or ladder_length is less than or equal to 0 Or maturity_spacing is less than or equal to 0.0:
        Let error_entry be Dictionary[String, Float]
        Set error_entry["error"] to 1.0
        Add error_entry to result
        Return result
    
    Note: Calculate investment per rung
    Let investment_per_rung be investment_amount / Float(ladder_length)
    
    Note: Create ladder rungs
    Let current_maturity be maturity_spacing
    Let rung_index be 0
    
    Repeat while rung_index is less than ladder_length:
        Let rung_data be Dictionary[String, Float]
        Set rung_data["rung_number"] to Float(rung_index plus 1)
        Set rung_data["maturity_years"] to current_maturity
        Set rung_data["investment_amount"] to investment_per_rung
        
        Note: Estimate yield based on maturity (yield curve approximation)
        Let estimated_yield be 0.02 plus (current_maturity multiplied by 0.002)  Note: Base 2% plus 20bp per year
        If current_maturity is greater than 10.0:  Note: Flatten curve for long maturities
            Set estimated_yield to 0.04 plus ((current_maturity minus 10.0) multiplied by 0.001)
        Set rung_data["estimated_yield"] to estimated_yield
        
        Note: Calculate expected annual income from this rung
        Let annual_income be investment_per_rung multiplied by estimated_yield
        Set rung_data["annual_income"] to annual_income
        
        Note: Calculate maturity value (assuming par bonds)
        Set rung_data["maturity_value"] to investment_per_rung
        
        Note: Calculate years until next reinvestment opportunity
        Set rung_data["reinvestment_timing"] to current_maturity
        
        Add rung_data to result
        Set current_maturity to current_maturity plus maturity_spacing
        Set rung_index to rung_index plus 1
    
    Note: Add summary statistics
    Let summary be Dictionary[String, Float]
    Set summary["total_investment"] to investment_amount
    Set summary["number_of_rungs"] to Float(ladder_length)
    Set summary["maturity_spacing_years"] to maturity_spacing
    Set summary["average_maturity"] to (Float(ladder_length plus 1) multiplied by maturity_spacing) / 2.0
    
    Note: Calculate weighted average yield
    Let total_income be 0.0
    Let i be 0
    Repeat while i is less than result.length:
        Set total_income to total_income plus result[i]["annual_income"]
        Set i to i plus 1
    
    Let average_yield be total_income / investment_amount
    Set summary["weighted_average_yield"] to average_yield
    Set summary["total_annual_income"] to total_income
    
    Add summary to result
    Return result

Process called "optimize_bond_portfolio" that takes expected_returns as List[Float], duration_targets as Dictionary[String, Float], credit_constraints as Dictionary[String, Float] returns Dictionary[String, Float]:
    Note: Optimize bond portfolio subject to duration, credit quality, and sector constraints
    Note: Uses simplified mean-variance optimization with constraint handling
    
    Let result be Dictionary[String, Float]
    
    Note: Validate inputs
    If expected_returns.length is equal to 0:
        Set result["error"] to 1.0
        Return result
    
    Let n_bonds be expected_returns.length
    Let target_duration be duration_targets["portfolio_target"]
    Let min_credit_rating be credit_constraints["minimum_rating_score"]
    Let max_concentration be credit_constraints["max_single_position"]
    
    Note: Initialize optimization variables
    Let optimal_weights be List[Float]
    Let i be 0
    Repeat while i is less than n_bonds:
        Add 0.0 to optimal_weights
        Set i to i plus 1
    
    Note: Simple equal-weight starting point
    Let equal_weight be 1.0 / Float(n_bonds)
    Set i to 0
    Repeat while i is less than n_bonds:
        Set optimal_weights[i] to equal_weight
        Set i to i plus 1
    
    Note: Iterative optimization using gradient-like approach
    Let max_iterations be 50
    Let iteration be 0
    Let learning_rate be 0.1
    
    Repeat while iteration is less than max_iterations:
        Note: Calculate current portfolio return and risk
        Let portfolio_return be 0.0
        Set i to 0
        Repeat while i is less than n_bonds:
            Set portfolio_return to portfolio_return plus (optimal_weights[i] multiplied by expected_returns[i])
            Set i to i plus 1
        
        Note: Calculate portfolio risk (simplified variance)
        Let portfolio_risk be 0.0
        Set i to 0
        Repeat while i is less than n_bonds:
            Let weight_deviation be optimal_weights[i] minus (1.0 / Float(n_bonds))
            Set portfolio_risk to portfolio_risk plus (weight_deviation multiplied by weight_deviation)
            Set i to i plus 1
        
        Note: Adjust weights based on expected returns
        Let new_weights be List[Float]
        Let weight_sum be 0.0
        Set i to 0
        Repeat while i is less than n_bonds:
            Let return_advantage be expected_returns[i] minus (portfolio_return / Float(n_bonds))
            Let adjustment be return_advantage multiplied by learning_rate
            Let new_weight be optimal_weights[i] plus adjustment
            
            Note: Apply constraints
            If new_weight is less than 0.01:  Note: Minimum 1% position
                Set new_weight to 0.01
            If new_weight is greater than max_concentration:  Note: Maximum concentration limit
                Set new_weight to max_concentration
            
            Add new_weight to new_weights
            Set weight_sum to weight_sum plus new_weight
            Set i to i plus 1
        
        Note: Normalize weights to sum to 1.0
        Set i to 0
        Repeat while i is less than n_bonds:
            Set optimal_weights[i] to new_weights[i] / weight_sum
            Set i to i plus 1
        
        Set iteration to iteration plus 1
    
    Note: Store final results
    Set i to 0
    Repeat while i is less than n_bonds:
        Let bond_id be "bond_" plus String(i plus 1)
        If optimal_weights[i] is greater than 0.005:  Note: Only include meaningful positions
            Set result[bond_id] to optimal_weights[i]
        Set i to i plus 1
    
    Note: Calculate final portfolio metrics
    Let final_return be 0.0
    Set i to 0
    Repeat while i is less than n_bonds:
        Set final_return to final_return plus (optimal_weights[i] multiplied by expected_returns[i])
        Set i to i plus 1
    
    Set result["expected_portfolio_return"] to final_return
    Set result["number_of_positions"] to Float(count_meaningful_positions(optimal_weights))
    
    Return result

Process called "implement_total_return_strategy" that takes bond_universe as List[BondContract], return_forecasts as Dictionary[String, Float], risk_constraints as Dictionary[String, Float] returns Dictionary[String, Float]:
    Note: Implement total return bond strategy maximizing risk-adjusted returns
    Note: Focuses on capital appreciation and income optimization across market cycles
    
    Let result be Dictionary[String, Float]
    
    Note: Validate inputs
    If bond_universe.length is equal to 0:
        Set result["error"] to 1.0
        Return result
    
    Note: Extract risk constraints
    Let max_duration_risk be risk_constraints["max_duration"]
    Let max_credit_risk be risk_constraints["max_credit_exposure"]
    Let target_volatility be risk_constraints["target_volatility"]
    
    Note: Analyze bond universe for total return opportunities
    Let selected_bonds be List[String]
    Let selected_weights be List[Float]
    Let total_return_score be List[Float]
    
    Let i be 0
    Repeat while i is less than bond_universe.length:
        Let bond be bond_universe[i]
        Let bond_id be bond.bond_id
        
        Note: Calculate total return components
        Let current_income_yield be bond.coupon_rate
        Let expected_price_appreciation be 0.0
        
        If return_forecasts.has_key(bond_id):
            Set expected_price_appreciation to return_forecasts[bond_id] minus current_income_yield
        
        Note: Calculate risk-adjusted return score
        Let total_expected_return be current_income_yield plus expected_price_appreciation
        
        Note: Estimate risk (simplified duration and credit risk)
        Let duration_risk be estimate_duration_from_id(bond_id) multiplied by 0.01  Note: 1% rate change
        Let credit_risk be estimate_credit_risk(bond.coupon_rate)
        Let total_risk be duration_risk plus credit_risk
        
        Note: Calculate Sharpe-like ratio
        Let risk_adjusted_score be 0.0
        If total_risk is greater than 0.001:
            Set risk_adjusted_score to total_expected_return / total_risk
        
        Add bond_id to selected_bonds
        Add 0.0 to selected_weights  Note: Initialize weight
        Add risk_adjusted_score to total_return_score
        
        Set i to i plus 1
    
    Note: Rank bonds by risk-adjusted return and select top performers
    Let min_score_threshold be 1.0  Note: Minimum acceptable risk-adjusted return
    Let total_score be 0.0
    
    Set i to 0
    Repeat while i is less than total_return_score.length:
        If total_return_score[i] is greater than or equal to min_score_threshold:
            Set total_score to total_score plus total_return_score[i]
        Set i to i plus 1
    
    Note: Allocate weights based on relative scores
    If total_score is greater than 0.0:
        Set i to 0
        Repeat while i is less than total_return_score.length:
            If total_return_score[i] is greater than or equal to min_score_threshold:
                Let weight be total_return_score[i] / total_score
                Set selected_weights[i] to weight
            Set i to i plus 1
    Otherwise:
        Note: Equal weight allocation if no bonds meet threshold
        Let equal_weight be 1.0 / Float(bond_universe.length)
        Set i to 0
        Repeat while i is less than selected_weights.length:
            Set selected_weights[i] to equal_weight
            Set i to i plus 1
    
    Note: Apply risk constraints and normalize
    Let adjusted_weights be apply_total_return_constraints(selected_weights, risk_constraints)
    
    Note: Store final allocation
    Set i to 0
    Repeat while i is less than selected_bonds.length:
        If adjusted_weights[i] is greater than 0.01:  Note: Include positions is greater than 1%
            Set result[selected_bonds[i]] to adjusted_weights[i]
        Set i to i plus 1
    
    Note: Calculate strategy metrics
    Let expected_total_return be 0.0
    Let portfolio_duration be 0.0
    
    Set i to 0
    Repeat while i is less than selected_bonds.length:
        Let bond_id be selected_bonds[i]
        Let weight be adjusted_weights[i]
        
        If return_forecasts.has_key(bond_id):
            Set expected_total_return to expected_total_return plus (weight multiplied by return_forecasts[bond_id])
        
        Let bond_duration be estimate_duration_from_id(bond_id)
        Set portfolio_duration to portfolio_duration plus (weight multiplied by bond_duration)
        Set i to i plus 1
    
    Set result["expected_total_return"] to expected_total_return
    Set result["portfolio_duration"] to portfolio_duration
    Set result["strategy_type"] to 1.0  Note: Total return indicator
    
    Return result

Process called "manage_credit_exposure" that takes bond_portfolio as Dictionary[String, Float], credit_limits as Dictionary[String, Float] returns Dictionary[String, Boolean]:
    Note: Manage credit exposure across issuers, sectors, and rating categories
    Note: Monitors and flags credit exposure violations across multiple dimensions
    
    Let result be Dictionary[String, Boolean]
    
    Note: Initialize compliance flags
    Set result["overall_compliance"] to true
    Set result["issuer_compliance"] to true
    Set result["sector_compliance"] to true
    Set result["rating_compliance"] to true
    
    Note: Extract credit limits
    Let max_single_issuer be credit_limits["max_single_issuer"]
    Let max_sector_exposure be credit_limits["max_sector_exposure"]
    Let min_investment_grade be credit_limits["min_investment_grade_pct"]
    Let max_high_yield be credit_limits["max_high_yield_pct"]
    
    Note: Analyze portfolio holdings
    Let bond_ids be bond_portfolio.keys()
    Let issuer_exposures be Dictionary[String, Float]
    Let sector_exposures be Dictionary[String, Float]
    Let rating_exposures be Dictionary[String, Float]
    
    Note: Initialize exposure tracking
    Set issuer_exposures["TREASURY"] to 0.0
    Set issuer_exposures["CORPORATE"] to 0.0
    Set issuer_exposures["MUNICIPAL"] to 0.0
    
    Set sector_exposures["GOVERNMENT"] to 0.0
    Set sector_exposures["FINANCIAL"] to 0.0
    Set sector_exposures["INDUSTRIAL"] to 0.0
    Set sector_exposures["UTILITY"] to 0.0
    
    Set rating_exposures["INVESTMENT_GRADE"] to 0.0
    Set rating_exposures["HIGH_YIELD"] to 0.0
    
    Note: Categorize and aggregate exposures
    Let i be 0
    Repeat while i is less than bond_ids.length:
        Let bond_id be bond_ids[i]
        Let position_size be bond_portfolio[bond_id]
        
        Note: Classify issuer type from bond ID
        Let issuer_type be classify_issuer(bond_id)
        Set issuer_exposures[issuer_type] to issuer_exposures[issuer_type] plus position_size
        
        Note: Classify sector from bond ID
        Let sector_type be classify_sector(bond_id)
        Set sector_exposures[sector_type] to sector_exposures[sector_type] plus position_size
        
        Note: Classify rating from bond ID
        Let rating_type be classify_rating_category(bond_id)
        Set rating_exposures[rating_type] to rating_exposures[rating_type] plus position_size
        
        Set i to i plus 1
    
    Note: Check issuer concentration limits
    Let issuer_keys be issuer_exposures.keys()
    Set i to 0
    Repeat while i is less than issuer_keys.length:
        Let issuer be issuer_keys[i]
        If issuer_exposures[issuer] is greater than max_single_issuer:
            Set result["issuer_compliance"] to false
            Set result["overall_compliance"] to false
            Set result[issuer plus "_violation"] to true
        Set i to i plus 1
    
    Note: Check sector concentration limits
    Let sector_keys be sector_exposures.keys()
    Set i to 0
    Repeat while i is less than sector_keys.length:
        Let sector be sector_keys[i]
        If sector_exposures[sector] is greater than max_sector_exposure:
            Set result["sector_compliance"] to false
            Set result["overall_compliance"] to false
            Set result[sector plus "_violation"] to true
        Set i to i plus 1
    
    Note: Check rating distribution requirements
    Let ig_percentage be rating_exposures["INVESTMENT_GRADE"] multiplied by 100.0
    Let hy_percentage be rating_exposures["HIGH_YIELD"] multiplied by 100.0
    
    If ig_percentage is less than min_investment_grade:
        Set result["rating_compliance"] to false
        Set result["overall_compliance"] to false
        Set result["insufficient_investment_grade"] to true
    
    If hy_percentage is greater than max_high_yield:
        Set result["rating_compliance"] to false
        Set result["overall_compliance"] to false
        Set result["excess_high_yield"] to true
    
    Return result

Note: =====================================================================
Note: MUNICIPAL BOND OPERATIONS
Note: =====================================================================

Process called "calculate_taxable_equivalent_yield" that takes municipal_yield as Float, tax_rate as Float, alternative_minimum_tax as Boolean returns Float:
    Note: Calculate taxable equivalent yield for municipal bonds considering tax benefits
    Note: TEY is equal to Municipal Yield / (1 minus Tax Rate), adjusted for AMT if applicable
    
    Note: Validate inputs
    If municipal_yield is less than 0.0 Or tax_rate is less than 0.0 Or tax_rate is greater than or equal to 1.0:
        Return municipal_yield
    
    Note: Calculate base taxable equivalent yield
    Let after_tax_factor be 1.0 minus tax_rate
    Let taxable_equivalent_yield be municipal_yield / after_tax_factor
    
    Note: Apply AMT adjustment if applicable
    If alternative_minimum_tax:
        Note: AMT reduces tax benefit (assume 28% AMT rate)
        Let amt_rate be 0.28
        Let amt_factor be 1.0 minus amt_rate
        Let amt_adjusted_yield be municipal_yield / amt_factor
        
        Note: Use higher of regular tax equivalent or AMT equivalent
        If amt_adjusted_yield is greater than taxable_equivalent_yield:
            Set taxable_equivalent_yield to amt_adjusted_yield
    
    Return taxable_equivalent_yield

Process called "analyze_municipal_credit_risk" that takes municipal_issuer as Dictionary[String, Float], economic_indicators as Dictionary[String, Float] returns Dictionary[String, String]:
    Note: Analyze municipal credit risk using financial ratios and economic indicators
    Note: Evaluates financial health, debt burden, economic base, and management quality
    
    Let result be Dictionary[String, String]
    
    Note: Extract financial metrics
    Let debt_per_capita be municipal_issuer["debt_per_capita"]
    Let debt_to_assessed_value be municipal_issuer["debt_to_assessed_value"]
    Let operating_ratio be municipal_issuer["operating_expenses_to_revenue"]
    Let fund_balance_ratio be municipal_issuer["fund_balance_to_expenditures"]
    
    Note: Extract economic indicators
    Let unemployment_rate be economic_indicators["unemployment_rate"]
    Let population_growth be economic_indicators["population_growth_rate"]
    Let median_income be economic_indicators["median_household_income"]
    
    Note: Analyze debt burden
    Let debt_score be "GOOD"
    If debt_per_capita is greater than 5000.0:
        Set debt_score to "POOR"
    Otherwise if debt_per_capita is greater than 3000.0:
        Set debt_score to "FAIR"
    
    If debt_to_assessed_value is greater than 0.08:
        Set debt_score to "POOR"
    Otherwise if debt_to_assessed_value is greater than 0.05:
        If debt_score is equal to "GOOD":
            Set debt_score to "FAIR"
    
    Set result["debt_burden_assessment"] to debt_score
    
    Note: Analyze financial management
    Let financial_score be "GOOD"
    If operating_ratio is greater than 0.95:
        Set financial_score to "POOR"
    Otherwise if operating_ratio is greater than 0.90:
        Set financial_score to "FAIR"
    
    If fund_balance_ratio is less than 0.1:
        Set financial_score to "POOR"
    Otherwise if fund_balance_ratio is less than 0.15:
        If financial_score is equal to "GOOD":
            Set financial_score to "FAIR"
    
    Set result["financial_management"] to financial_score
    
    Note: Analyze economic base
    Let economic_score be "GOOD"
    If unemployment_rate is greater than 8.0:
        Set economic_score to "POOR"
    Otherwise if unemployment_rate is greater than 5.0:
        Set economic_score to "FAIR"
    
    If population_growth is less than -1.0:
        Set economic_score to "POOR"
    Otherwise if population_growth is less than 0.0:
        If economic_score is equal to "GOOD":
            Set economic_score to "FAIR"
    
    Set result["economic_base"] to economic_score
    
    Note: Calculate overall credit assessment
    Let poor_count be 0
    Let fair_count be 0
    
    If debt_score is equal to "POOR":
        Set poor_count to poor_count plus 1
    Otherwise if debt_score is equal to "FAIR":
        Set fair_count to fair_count plus 1
    
    If financial_score is equal to "POOR":
        Set poor_count to poor_count plus 1
    Otherwise if financial_score is equal to "FAIR":
        Set fair_count to fair_count plus 1
    
    If economic_score is equal to "POOR":
        Set poor_count to poor_count plus 1
    Otherwise if economic_score is equal to "FAIR":
        Set fair_count to fair_count plus 1
    
    Let overall_rating be "AA"
    If poor_count is greater than or equal to 2:
        Set overall_rating to "BB"
    Otherwise if poor_count is equal to 1 Or fair_count is greater than or equal to 2:
        Set overall_rating to "A"
    
    Set result["overall_credit_rating"] to overall_rating
    
    Return result

Process called "evaluate_revenue_bonds" that takes project_cash_flows as List[Float], revenue_projections as List[Float] returns Dictionary[String, Float]:
    Note: Evaluate revenue bonds based on underlying project economics and cash flows
    Note: Analyzes project viability, cash flow adequacy, and coverage ratios
    
    Let result be Dictionary[String, Float]
    
    Note: Validate inputs
    If project_cash_flows.length is equal to 0 Or revenue_projections.length is equal to 0:
        Set result["error"] to 1.0
        Return result
    
    Note: Calculate project financial metrics
    Let total_project_cost be 0.0
    Let i be 0
    Repeat while i is less than project_cash_flows.length:
        If project_cash_flows[i] is less than 0.0:  Note: Negative is equal to outflow/cost
            Set total_project_cost to total_project_cost minus project_cash_flows[i]
        Set i to i plus 1
    
    Note: Calculate total projected revenues
    Let total_projected_revenue be 0.0
    Set i to 0
    Repeat while i is less than revenue_projections.length:
        Set total_projected_revenue to total_projected_revenue plus revenue_projections[i]
        Set i to i plus 1
    
    Note: Calculate present value of revenues (5% discount rate)
    Let pv_revenues be 0.0
    Set i to 0
    Repeat while i is less than revenue_projections.length:
        Let year be Float(i plus 1)
        Let discount_factor be Operations.power(
            "1.05",
            String(-1.0 multiplied by year),
            30
        )
        Let pv_revenue be Operations.multiply(
            String(revenue_projections[i]),
            discount_factor.result_value,
            30
        )
        Set pv_revenues to pv_revenues plus Float(pv_revenue.result_value)
        Set i to i plus 1
    
    Note: Calculate debt service coverage
    Let annual_debt_service be total_project_cost multiplied by 0.08  Note: Assume 8% annual debt service
    Let average_annual_revenue be total_projected_revenue / Float(revenue_projections.length)
    Let debt_service_coverage be 0.0
    If annual_debt_service is greater than 0.0:
        Set debt_service_coverage to average_annual_revenue / annual_debt_service
    
    Set result["total_project_cost"] to total_project_cost
    Set result["total_projected_revenue"] to total_projected_revenue
    Set result["present_value_revenues"] to pv_revenues
    Set result["debt_service_coverage_ratio"] to debt_service_coverage
    
    Note: Calculate project viability score
    Let viability_score be 0.0
    
    Note: Coverage ratio scoring (40% weight)
    If debt_service_coverage is greater than or equal to 1.5:
        Set viability_score to viability_score plus 40.0
    Otherwise if debt_service_coverage is greater than or equal to 1.25:
        Set viability_score to viability_score plus 30.0
    Otherwise if debt_service_coverage is greater than or equal to 1.0:
        Set viability_score to viability_score plus 20.0
    Otherwise:
        Set viability_score to viability_score plus 10.0
    
    Note: Revenue adequacy scoring (35% weight)
    Let revenue_adequacy be pv_revenues / total_project_cost
    If revenue_adequacy is greater than or equal to 1.2:
        Set viability_score to viability_score plus 35.0
    Otherwise if revenue_adequacy is greater than or equal to 1.0:
        Set viability_score to viability_score plus 25.0
    Otherwise if revenue_adequacy is greater than or equal to 0.8:
        Set viability_score to viability_score plus 15.0
    Otherwise:
        Set viability_score to viability_score plus 5.0
    
    Note: Revenue stability scoring (25% weight)
    Let revenue_volatility be calculate_revenue_volatility(revenue_projections)
    If revenue_volatility is less than or equal to 0.1:
        Set viability_score to viability_score plus 25.0
    Otherwise if revenue_volatility is less than or equal to 0.2:
        Set viability_score to viability_score plus 20.0
    Otherwise if revenue_volatility is less than or equal to 0.3:
        Set viability_score to viability_score plus 15.0
    Otherwise:
        Set viability_score to viability_score plus 10.0
    
    Set result["viability_score"] to viability_score
    Set result["revenue_volatility"] to revenue_volatility
    Set result["revenue_adequacy_ratio"] to revenue_adequacy
    
    Return result

Process called "assess_general_obligation_bonds" that takes issuer_financials as Dictionary[String, Float], demographic_data as Dictionary[String, Float] returns Dictionary[String, String]:
    Note: Assess general obligation bonds using issuer financial strength and tax base
    Note: Evaluates tax base diversity, financial flexibility, and debt burden
    
    Let result be Dictionary[String, String]
    
    Note: Extract financial data
    Let assessed_value_per_capita be issuer_financials["assessed_value_per_capita"]
    Let property_tax_collection_rate be issuer_financials["tax_collection_rate"]
    Let total_debt_per_capita be issuer_financials["total_debt_per_capita"]
    Let unrestricted_fund_balance be issuer_financials["unrestricted_fund_balance"]
    
    Note: Extract demographic data
    Let population be demographic_data["population"]
    Let median_income be demographic_data["median_income"]
    Let income_growth_rate be demographic_data["income_growth_rate"]
    Let age_diversity_index be demographic_data["age_diversity_index"]
    
    Note: Assess tax base strength
    Let tax_base_score be "GOOD"
    
    If assessed_value_per_capita is less than 50000.0:
        Set tax_base_score to "POOR"
    Otherwise if assessed_value_per_capita is less than 75000.0:
        Set tax_base_score to "FAIR"
    
    If property_tax_collection_rate is less than 0.95:
        Set tax_base_score to "POOR"
    Otherwise if property_tax_collection_rate is less than 0.98:
        If tax_base_score is equal to "GOOD":
            Set tax_base_score to "FAIR"
    
    Set result["tax_base_strength"] to tax_base_score
    
    Note: Assess debt burden
    Let debt_burden_score be "GOOD"
    
    If total_debt_per_capita is greater than 4000.0:
        Set debt_burden_score to "POOR"
    Otherwise if total_debt_per_capita is greater than 2500.0:
        Set debt_burden_score to "FAIR"
    
    Note: Debt to assessed value ratio
    Let debt_to_av_ratio be total_debt_per_capita / assessed_value_per_capita
    If debt_to_av_ratio is greater than 0.06:
        Set debt_burden_score to "POOR"
    Otherwise if debt_to_av_ratio is greater than 0.04:
        If debt_burden_score is equal to "GOOD":
            Set debt_burden_score to "FAIR"
    
    Set result["debt_burden"] to debt_burden_score
    
    Note: Assess financial flexibility
    Let flexibility_score be "GOOD"
    
    If unrestricted_fund_balance is less than 0.15:  Note: Less than 15% of expenditures
        Set flexibility_score to "POOR"
    Otherwise if unrestricted_fund_balance is less than 0.20:
        Set flexibility_score to "FAIR"
    
    Set result["financial_flexibility"] to flexibility_score
    
    Note: Assess demographic trends
    Let demographic_score be "GOOD"
    
    If median_income is less than 40000.0:
        Set demographic_score to "POOR"
    Otherwise if median_income is less than 55000.0:
        Set demographic_score to "FAIR"
    
    If income_growth_rate is less than -2.0:
        Set demographic_score to "POOR"
    Otherwise if income_growth_rate is less than 0.0:
        If demographic_score is equal to "GOOD":
            Set demographic_score to "FAIR"
    
    Set result["demographic_trends"] to demographic_score
    
    Note: Calculate overall GO bond rating
    Let poor_factors be 0
    Let fair_factors be 0
    
    If tax_base_score is equal to "POOR":
        Set poor_factors to poor_factors plus 1
    Otherwise if tax_base_score is equal to "FAIR":
        Set fair_factors to fair_factors plus 1
    
    If debt_burden_score is equal to "POOR":
        Set poor_factors to poor_factors plus 1
    Otherwise if debt_burden_score is equal to "FAIR":
        Set fair_factors to fair_factors plus 1
    
    If flexibility_score is equal to "POOR":
        Set poor_factors to poor_factors plus 1
    Otherwise if flexibility_score is equal to "FAIR":
        Set fair_factors to fair_factors plus 1
    
    If demographic_score is equal to "POOR":
        Set poor_factors to poor_factors plus 1
    Otherwise if demographic_score is equal to "FAIR":
        Set fair_factors to fair_factors plus 1
    
    Let overall_rating be "AAA"
    If poor_factors is greater than or equal to 2:
        Set overall_rating to "BBB"
    Otherwise if poor_factors is equal to 1 Or fair_factors is greater than or equal to 3:
        Set overall_rating to "AA"
    Otherwise if fair_factors is greater than or equal to 1:
        Set overall_rating to "AA"
    
    Set result["overall_go_rating"] to overall_rating
    
    Return result

Note: =====================================================================
Note: INTERNATIONAL BOND OPERATIONS
Note: =====================================================================

Process called "analyze_currency_risk" that takes foreign_bond as BondContract, exchange_rate_volatility as Float, correlation as Float returns Dictionary[String, Float]:
    Note: Analyze currency risk in foreign bond investments including hedging costs
    Note: Calculates currency exposure, hedging costs, and risk-adjusted returns
    
    Let result be Dictionary[String, Float]
    
    Note: Extract bond characteristics
    Let bond_value be foreign_bond.face_value
    Let bond_maturity_years be Float(foreign_bond.maturity_date minus foreign_bond.issue_date) / 365.0
    Let bond_yield be foreign_bond.coupon_rate
    
    Note: Calculate currency risk metrics
    Let currency_var be exchange_rate_volatility multiplied by exchange_rate_volatility
    Let currency_risk be exchange_rate_volatility multiplied by Operations.power(String(bond_maturity_years), "0.5", 30).result_value
    
    Set result["exchange_rate_volatility"] to exchange_rate_volatility
    Set result["currency_risk_scaled"] to Float(currency_risk)
    
    Note: Calculate potential currency impact on returns
    Let downside_scenario be -2.0 multiplied by exchange_rate_volatility  Note: 2 standard deviation move
    Let upside_scenario be 2.0 multiplied by exchange_rate_volatility
    
    Set result["downside_currency_impact"] to downside_scenario
    Set result["upside_currency_impact"] to upside_scenario
    
    Note: Calculate hedging costs using proper forward premium/discount
    Let hedging_cost_annual be calculate_forward_premium(domestic_risk_free_rate, foreign_risk_free_rate, exchange_rate_volatility, bond_maturity_years)
    Let total_hedging_cost be hedging_cost_annual multiplied by bond_maturity_years
    Set result["annual_hedging_cost"] to hedging_cost_annual
    Set result["total_hedging_cost"] to total_hedging_cost
    
    Note: Calculate unhedged vs hedged expected returns
    Let unhedged_return be bond_yield
    Let hedged_return be bond_yield minus hedging_cost_annual
    Set result["unhedged_expected_return"] to unhedged_return
    Set result["hedged_expected_return"] to hedged_return
    
    Note: Calculate risk-adjusted metrics
    Let unhedged_volatility be Operations.power(
        Operations.add(
            String(bond_yield multiplied by bond_yield multiplied by 0.1),  Note: Bond volatility
            String(currency_var),  Note: Currency volatility
            30
        ).result_value,
        "0.5",
        30
    )
    
    Let hedged_volatility be bond_yield multiplied by 0.316  Note: Sqrt(0.1) for bond-only volatility
    
    Set result["unhedged_volatility"] to Float(unhedged_volatility.result_value)
    Set result["hedged_volatility"] to hedged_volatility
    
    Note: Calculate Sharpe ratios (assuming 2% risk-free rate)
    Let risk_free_rate be 0.02
    Let unhedged_sharpe be (unhedged_return minus risk_free_rate) / Float(unhedged_volatility.result_value)
    Let hedged_sharpe be (hedged_return minus risk_free_rate) / hedged_volatility
    
    Set result["unhedged_sharpe_ratio"] to unhedged_sharpe
    Set result["hedged_sharpe_ratio"] to hedged_sharpe
    
    Note: Hedging recommendation
    If hedged_sharpe is greater than unhedged_sharpe:
        Set result["hedging_recommended"] to 1.0
    Otherwise:
        Set result["hedging_recommended"] to 0.0
    
    Return result

Process called "hedge_currency_exposure" that takes foreign_bond_exposure as Dictionary[String, Float], hedging_instruments as List[String] returns Dictionary[String, Float]:
    Note: Hedge currency exposure in international bond portfolios using forwards or swaps
    Note: Calculates optimal hedge ratios and instrument allocation for currency risk management
    
    Let result be Dictionary[String, Float]
    
    Note: Calculate total foreign exposure by currency
    Let currency_exposures be Dictionary[String, Float]
    Set currency_exposures["EUR"] to 0.0
    Set currency_exposures["GBP"] to 0.0
    Set currency_exposures["JPY"] to 0.0
    Set currency_exposures["CHF"] to 0.0
    Set currency_exposures["CAD"] to 0.0
    
    Let exposure_keys be foreign_bond_exposure.keys()
    Let total_foreign_exposure be 0.0
    
    Let i be 0
    Repeat while i is less than exposure_keys.length:
        Let bond_id be exposure_keys[i]
        Let exposure_amount be foreign_bond_exposure[bond_id]
        Set total_foreign_exposure to total_foreign_exposure plus exposure_amount
        
        Note: Classify currency from bond ID
        Let currency be classify_currency(bond_id)
        Set currency_exposures[currency] to currency_exposures[currency] plus exposure_amount
        Set i to i plus 1
    
    Set result["total_foreign_exposure"] to total_foreign_exposure
    
    Note: Calculate hedge ratios for each currency
    Let currency_list be ["EUR", "GBP", "JPY", "CHF", "CAD"]
    Let total_hedge_notional be 0.0
    
    Set i to 0
    Repeat while i is less than currency_list.length:
        Let currency be currency_list[i]
        Let exposure be currency_exposures[currency]
        
        If exposure is greater than 1000.0:  Note: Only hedge significant exposures
            Note: Calculate optimal hedge ratio using variance minimization
            Let hedge_ratio be calculate_optimal_hedge_ratio(exposure, currency, portfolio_volatility)
            Let hedge_notional be exposure multiplied by hedge_ratio
            
            Set result[currency plus "_exposure"] to exposure
            Set result[currency plus "_hedge_ratio"] to hedge_ratio
            Set result[currency plus "_hedge_notional"] to hedge_notional
            Set total_hedge_notional to total_hedge_notional plus hedge_notional
        Otherwise:
            Set result[currency plus "_exposure"] to exposure
            Set result[currency plus "_hedge_ratio"] to 0.0
            Set result[currency plus "_hedge_notional"] to 0.0
        
        Set i to i plus 1
    
    Note: Allocate hedging across available instruments
    Set result["total_hedge_notional"] to total_hedge_notional
    
    Let instrument_allocation be Dictionary[String, Float]
    Let instruments_per_hedge be total_hedge_notional / Float(hedging_instruments.length)
    
    Set i to 0
    Repeat while i is less than hedging_instruments.length:
        Let instrument be hedging_instruments[i]
        Set instrument_allocation[instrument] to instruments_per_hedge
        Set result[instrument plus "_allocation"] to instruments_per_hedge
        Set i to i plus 1
    
    Note: Calculate hedging costs and effectiveness
    Let estimated_hedging_cost be total_hedge_notional multiplied by 0.003  Note: 30bp annual cost
    Let hedge_effectiveness be 0.95  Note: 95% effectiveness assumption
    
    Set result["estimated_annual_hedging_cost"] to estimated_hedging_cost
    Set result["expected_hedge_effectiveness"] to hedge_effectiveness
    
    Note: Calculate residual currency risk after hedging
    Let unhedged_currency_risk be total_foreign_exposure multiplied by 0.12  Note: 12% annual FX volatility
    Let hedged_currency_risk be unhedged_currency_risk multiplied by (1.0 minus hedge_effectiveness)
    
    Set result["unhedged_currency_risk"] to unhedged_currency_risk
    Set result["hedged_currency_risk"] to hedged_currency_risk
    Set result["risk_reduction_percent"] to (1.0 minus hedged_currency_risk / unhedged_currency_risk) multiplied by 100.0
    
    Return result

Process called "compare_global_yield_curves" that takes yield_curves as Dictionary[String, YieldCurve], currencies as List[String] returns Dictionary[String, Dictionary[String, Float]]:
    Note: Compare global yield curves adjusting for currency and credit risk differences
    Note: Analyzes relative value opportunities across global bond markets
    
    Let result be Dictionary[String, Dictionary[String, Float]]
    
    Note: Validate inputs
    If currencies.length is equal to 0:
        Set result["error"] to Dictionary[String, Float]
        Set result["error"]["no_currencies"] to 1.0
        Return result
    
    Note: Standard maturity points for comparison
    Let standard_maturities be [2.0, 5.0, 10.0, 30.0]
    
    Note: Compare each currency's yield curve
    Let i be 0
    Repeat while i is less than currencies.length:
        Let currency be currencies[i]
        
        If yield_curves.has_key(currency):
            Let curve be yield_curves[currency]
            Let currency_analysis be Dictionary[String, Float]
            
            Note: Extract yields at standard maturities
            Let j be 0
            Repeat while j is less than standard_maturities.length:
                Let maturity be standard_maturities[j]
                Let yield_value be interpolate_yield_curve_rate(curve, maturity)
                
                Let maturity_key be String(Integer(maturity)) plus "Y_yield"
                Set currency_analysis[maturity_key] to yield_value
                Set j to j plus 1
            
            Note: Calculate curve characteristics
            Let short_rate be interpolate_yield_curve_rate(curve, 2.0)
            Let long_rate be interpolate_yield_curve_rate(curve, 30.0)
            Let curve_steepness be long_rate minus short_rate
            Set currency_analysis["curve_steepness"] to curve_steepness
            
            Note: Calculate curve level (average of 5Y and 10Y)
            Let mid_5y be interpolate_yield_curve_rate(curve, 5.0)
            Let mid_10y be interpolate_yield_curve_rate(curve, 10.0)
            Let curve_level be (mid_5y plus mid_10y) / 2.0
            Set currency_analysis["curve_level"] to curve_level
            
            Note: Add credit/sovereign risk adjustment
            Let sovereign_spread be estimate_sovereign_spread(currency)
            Set currency_analysis["sovereign_spread"] to sovereign_spread
            
            Note: Calculate risk-adjusted yields
            Set currency_analysis["risk_adjusted_2Y"] to short_rate minus sovereign_spread
            Set currency_analysis["risk_adjusted_10Y"] to mid_10y minus sovereign_spread
            
            Set result[currency] to currency_analysis
        
        Set i to i plus 1
    
    Note: Calculate relative value metrics
    Let base_currency be currencies[0]  Note: Use first currency as base
    
    If result.has_key(base_currency):
        Let base_curve_level be result[base_currency]["curve_level"]
        Let base_steepness be result[base_currency]["curve_steepness"]
        
        Set i to 1
        Repeat while i is less than currencies.length:
            Let compare_currency be currencies[i]
            
            If result.has_key(compare_currency):
                Let compare_level be result[compare_currency]["curve_level"]
                Let compare_steepness be result[compare_currency]["curve_steepness"]
                
                Note: Calculate relative spreads
                Let level_spread be compare_level minus base_curve_level
                Let steepness_differential be compare_steepness minus base_steepness
                
                Set result[compare_currency]["spread_to_" plus base_currency] to level_spread
                Set result[compare_currency]["steepness_vs_" plus base_currency] to steepness_differential
                
                Note: Relative value assessment
                If level_spread is greater than 0.5:  Note: More than 50bp pickup
                    Set result[compare_currency]["relative_value_score"] to 2.0  Note: Attractive
                Otherwise if level_spread is greater than 0.0:
                    Set result[compare_currency]["relative_value_score"] to 1.0  Note: Fair
                Otherwise:
                    Set result[compare_currency]["relative_value_score"] to 0.0  Note: Expensive
            
            Set i to i plus 1
    
    Return result

Process called "analyze_sovereign_risk" that takes sovereign_bonds as List[Dictionary[String, Float]], country_indicators as Dictionary[String, Dictionary[String, Float]] returns Dictionary[String, String]:
    Note: Analyze sovereign credit risk using macroeconomic and political indicators
    Note: Evaluates fiscal health, economic stability, and political risk factors
    
    Let result be Dictionary[String, String]
    
    Note: Validate inputs
    If sovereign_bonds.length is equal to 0:
        Set result["error"] to "No sovereign bond data"
        Return result
    
    Note: Extract country identifiers and aggregate analysis
    Let countries be List[String]
    Let i be 0
    Repeat while i is less than sovereign_bonds.length:
        Let bond_data be sovereign_bonds[i]
        Let country_code be String(bond_data["country_code"])
        
        Note: Add unique countries only
        Let already_exists be false
        Let j be 0
        Repeat while j is less than countries.length:
            If countries[j] is equal to country_code:
                Set already_exists to true
                Break
            Set j to j plus 1
        
        If Not already_exists:
            Add country_code to countries
        Set i to i plus 1
    
    Note: Analyze each country
    Set i to 0
    Repeat while i is less than countries.length:
        Let country be countries[i]
        
        If country_indicators.has_key(country):
            Let indicators be country_indicators[country]
            
            Note: Extract fiscal indicators
            Let debt_to_gdp be indicators["debt_to_gdp"]
            Let deficit_to_gdp be indicators["deficit_to_gdp"]
            Let interest_coverage be indicators["interest_coverage_ratio"]
            
            Note: Extract economic indicators
            Let gdp_growth be indicators["gdp_growth_rate"]
            Let inflation_rate be indicators["inflation_rate"]
            Let current_account be indicators["current_account_balance"]
            
            Note: Fiscal health assessment
            Let fiscal_score be "STRONG"
            If debt_to_gdp is greater than 100.0:
                Set fiscal_score to "WEAK"
            Otherwise if debt_to_gdp is greater than 70.0:
                Set fiscal_score to "MODERATE"
            
            If deficit_to_gdp is greater than 5.0:
                Set fiscal_score to "WEAK"
            Otherwise if deficit_to_gdp is greater than 3.0 And fiscal_score is equal to "STRONG":
                Set fiscal_score to "MODERATE"
            
            Set result[country plus "_fiscal_health"] to fiscal_score
            
            Note: Economic stability assessment
            Let economic_score be "STABLE"
            If gdp_growth is less than -2.0:
                Set economic_score to "UNSTABLE"
            Otherwise if gdp_growth is less than 1.0:
                Set economic_score to "WEAK"
            
            If inflation_rate is greater than 5.0 Or inflation_rate is less than -1.0:
                Set economic_score to "UNSTABLE"
            Otherwise if inflation_rate is greater than 3.0 And economic_score is equal to "STABLE":
                Set economic_score to "WEAK"
            
            Set result[country plus "_economic_stability"] to economic_score
            
            Note: External balance assessment
            Let external_score be "BALANCED"
            If current_account is less than -5.0:
                Set external_score to "DEFICIT"
            Otherwise if current_account is less than -3.0:
                Set external_score to "MODERATE_DEFICIT"
            
            Set result[country plus "_external_balance"] to external_score
            
            Note: Overall sovereign rating
            Let weak_factors be 0
            If fiscal_score is equal to "WEAK":
                Set weak_factors to weak_factors plus 1
            If economic_score is equal to "UNSTABLE":
                Set weak_factors to weak_factors plus 1
            If external_score is equal to "DEFICIT":
                Set weak_factors to weak_factors plus 1
            
            Let overall_rating be "AAA"
            If weak_factors is greater than or equal to 2:
                Set overall_rating to "BBB"
            Otherwise if weak_factors is equal to 1:
                Set overall_rating to "AA"
            
            Note: Additional risk factors
            If debt_to_gdp is greater than 120.0 Or deficit_to_gdp is greater than 8.0:
                Set overall_rating to "BB"
            
            Set result[country plus "_sovereign_rating"] to overall_rating
        Otherwise:
            Set result[country plus "_data_availability"] to "INSUFFICIENT"
        
        Set i to i plus 1
    
    Return result

Note: =====================================================================
Note: INFLATION-PROTECTED SECURITIES OPERATIONS
Note: =====================================================================

Process called "price_tips_security" that takes tips_characteristics as Dictionary[String, Float], real_yield_curve as YieldCurve, inflation_expectations as List[Float] returns BondPrice:
    Note: Price Treasury Inflation-Protected Securities using real yields and inflation adjustments
    Note: TIPS principal adjusts with inflation while paying fixed real coupon rate
    
    Let result be BondPrice
    
    Note: Extract TIPS characteristics
    Let face_value be tips_characteristics["face_value"]
    Let real_coupon_rate be tips_characteristics["real_coupon_rate"]
    Let maturity_years be tips_characteristics["maturity_years"]
    Let issue_date be Integer(tips_characteristics["issue_date"])
    
    Note: Calculate average expected inflation
    Let avg_inflation be 0.0
    Let i be 0
    Repeat while i is less than inflation_expectations.length:
        Set avg_inflation to avg_inflation plus inflation_expectations[i]
        Set i to i plus 1
    Set avg_inflation to avg_inflation / Float(inflation_expectations.length)
    
    Note: Get real yield for pricing
    Let real_yield be interpolate_yield_curve_rate(real_yield_curve, maturity_years)
    
    Note: Calculate inflation-adjusted principal
    Let inflation_adjustment be Operations.power(
        Operations.add("1.0", String(avg_inflation), 30).result_value,
        String(maturity_years),
        30
    )
    Let adjusted_principal be face_value multiplied by Float(inflation_adjustment.result_value)
    
    Note: Calculate present value of inflation-adjusted coupons
    Let pv_coupons be 0.0
    Let annual_real_coupon be adjusted_principal multiplied by real_coupon_rate
    
    Let year be 1
    Repeat while year is less than or equal to Integer(maturity_years):
        Let discount_factor be Operations.power(
            Operations.add("1.0", String(real_yield), 30).result_value,
            String(-1 multiplied by year),
            30
        )
        Let coupon_pv be annual_real_coupon multiplied by Float(discount_factor.result_value)
        Set pv_coupons to pv_coupons plus coupon_pv
        Set year to year plus 1
    
    Note: Present value of adjusted principal
    Let principal_discount be Operations.power(
        Operations.add("1.0", String(real_yield), 30).result_value,
        String(-1.0 multiplied by maturity_years),
        30
    )
    Let pv_principal be adjusted_principal multiplied by Float(principal_discount.result_value)
    
    Note: Total TIPS price
    Let total_price be pv_coupons plus pv_principal
    
    Set result.bond_id to "TIPS_" plus String(issue_date)
    Set result.dirty_price to total_price
    Set result.clean_price to total_price
    Set result.accrued_interest to 0.0
    Set result.pricing_date to issue_date
    Set result.price_type to "tips_real_yield"
    Set result.yield_to_maturity to real_yield
    
    Return result

Process called "calculate_breakeven_inflation" that takes tips_yield as Float, nominal_treasury_yield as Float returns Float:
    Note: Calculate breakeven inflation rate from TIPS and nominal Treasury yield difference
    Note: Breakeven inflation is equal to Nominal yield minus TIPS real yield
    
    Note: Validate inputs
    If tips_yield is less than 0.0 Or nominal_treasury_yield is less than 0.0:
        Return 0.0
    
    Note: Calculate breakeven inflation rate
    Let breakeven_inflation be nominal_treasury_yield minus tips_yield
    
    Note: Apply reasonable bounds
    If breakeven_inflation is less than -0.02:
        Set breakeven_inflation to -0.02
    If breakeven_inflation is greater than 0.10:
        Set breakeven_inflation to 0.10
    
    Return breakeven_inflation

Process called "analyze_inflation_risk" that takes bond_portfolio as Dictionary[String, Float], inflation_scenarios as List[Float] returns Dictionary[String, Dictionary[String, Float]]:
    Note: Analyze inflation risk impact on nominal bond portfolio values and returns
    Note: Evaluates real return erosion under different inflation scenarios
    
    Let result be Dictionary[String, Dictionary[String, Float]]
    
    Note: Calculate portfolio characteristics
    Let bond_ids be bond_portfolio.keys()
    Let portfolio_value be 0.0
    Let weighted_duration be 0.0
    
    Let i be 0
    Repeat while i is less than bond_ids.length:
        Let bond_weight be bond_portfolio[bond_ids[i]]
        Set portfolio_value to portfolio_value plus bond_weight
        
        Let bond_duration be estimate_duration_from_id(bond_ids[i])
        Set weighted_duration to weighted_duration plus (bond_weight multiplied by bond_duration)
        Set i to i plus 1
    
    If portfolio_value is greater than 0.0:
        Set weighted_duration to weighted_duration / portfolio_value
    
    Note: Analyze each inflation scenario
    Set i to 0
    Repeat while i is less than inflation_scenarios.length:
        Let inflation_rate be inflation_scenarios[i]
        Let scenario_name be "scenario_" plus String(i)
        
        Let scenario_results be Dictionary[String, Float]
        Set scenario_results["inflation_rate"] to inflation_rate
        
        Note: Calculate real return impact
        Let nominal_yield be 0.04  Note: Assume 4% portfolio yield
        Let real_return be nominal_yield minus inflation_rate
        Set scenario_results["nominal_yield"] to nominal_yield
        Set scenario_results["real_return"] to real_return
        
        Note: Duration impact on bond prices
        Let price_impact be -1.0 multiplied by weighted_duration multiplied by inflation_rate multiplied by 0.5
        Set scenario_results["duration_price_impact"] to price_impact
        
        Note: Total return impact
        Let total_return_impact be real_return plus price_impact
        Set scenario_results["total_return_impact"] to total_return_impact
        
        Note: Purchasing power erosion
        Let purchasing_power_factor be Operations.power(
            Operations.add("1.0", String(inflation_rate), 30).result_value,
            "-5.0",
            30
        )
        Set scenario_results["purchasing_power_erosion"] to 1.0 minus Float(purchasing_power_factor.result_value)
        
        Set result[scenario_name] to scenario_results
        Set i to i plus 1
    
    Note: Portfolio summary
    Let portfolio_summary be Dictionary[String, Float]
    Set portfolio_summary["portfolio_duration"] to weighted_duration
    Set portfolio_summary["portfolio_value"] to portfolio_value
    Set portfolio_summary["inflation_sensitivity"] to weighted_duration multiplied by 0.5
    Set result["portfolio_summary"] to portfolio_summary
    
    Return result

Process called "optimize_real_return_portfolio" that takes nominal_bonds as List[BondContract], inflation_protected_bonds as List[BondContract], inflation_forecast as Dictionary[String, Float] returns Dictionary[String, Float]:
    Note: Optimize portfolio allocation between nominal and inflation-protected bonds
    Note: Maximizes expected real returns while managing inflation risk
    
    Let result be Dictionary[String, Float]
    
    Note: Extract inflation forecast
    Let expected_inflation be inflation_forecast["expected_rate"]
    Let inflation_volatility be inflation_forecast["volatility"]
    
    Note: Calculate expected real returns for nominal bonds
    Let nominal_expected_real_return be 0.0
    Let nominal_risk be 0.0
    
    If nominal_bonds.length is greater than 0:
        Let total_nominal_yield be 0.0
        Let total_duration be 0.0
        
        Let i be 0
        Repeat while i is less than nominal_bonds.length:
            Let bond be nominal_bonds[i]
            Set total_nominal_yield to total_nominal_yield plus bond.coupon_rate
            Let bond_duration be estimate_duration_from_id(bond.bond_id)
            Set total_duration to total_duration plus bond_duration
            Set i to i plus 1
        
        Let avg_nominal_yield be total_nominal_yield / Float(nominal_bonds.length)
        Let avg_duration be total_duration / Float(nominal_bonds.length)
        
        Set nominal_expected_real_return to avg_nominal_yield minus expected_inflation
        Set nominal_risk to avg_duration multiplied by inflation_volatility
    
    Note: Calculate expected returns for TIPS
    Let tips_expected_real_return be 0.0
    Let tips_risk be 0.0
    
    If inflation_protected_bonds.length is greater than 0:
        Let total_tips_yield be 0.0
        
        Let i be 0
        Repeat while i is less than inflation_protected_bonds.length:
            Let bond be inflation_protected_bonds[i]
            Set total_tips_yield to total_tips_yield plus bond.coupon_rate
            Set i to i plus 1
        
        Set tips_expected_real_return to total_tips_yield / Float(inflation_protected_bonds.length)
        Set tips_risk to 0.02  Note: Lower duration risk for TIPS
    
    Note: Optimize allocation using simple mean-variance approach
    Let nominal_weight be 0.5  Note: Default equal allocation
    
    If nominal_risk is greater than 0.001 And tips_risk is greater than 0.001:
        Note: Risk parity allocation
        Let total_risk_contribution be nominal_risk plus tips_risk
        Set nominal_weight to tips_risk / total_risk_contribution
        
        Note: Adjust for expected return differences
        If nominal_expected_real_return is greater than tips_expected_real_return:
            Let return_advantage be nominal_expected_real_return minus tips_expected_real_return
            Set nominal_weight to nominal_weight plus (return_advantage multiplied by 0.5)
        Otherwise:
            Let return_advantage be tips_expected_real_return minus nominal_expected_real_return
            Set nominal_weight to nominal_weight minus (return_advantage multiplied by 0.5)
        
        Note: Apply bounds
        If nominal_weight is less than 0.2:
            Set nominal_weight to 0.2
        If nominal_weight is greater than 0.8:
            Set nominal_weight to 0.8
    
    Let tips_weight be 1.0 minus nominal_weight
    
    Note: Store results
    Set result["nominal_bonds_weight"] to nominal_weight
    Set result["tips_weight"] to tips_weight
    Set result["expected_portfolio_real_return"] to (nominal_weight multiplied by nominal_expected_real_return) plus (tips_weight multiplied by tips_expected_real_return)
    Set result["portfolio_inflation_risk"] to (nominal_weight multiplied by nominal_risk) plus (tips_weight multiplied by tips_risk)
    
    Set result["nominal_expected_real_return"] to nominal_expected_real_return
    Set result["tips_expected_real_return"] to tips_expected_real_return
    Set result["expected_inflation"] to expected_inflation
    
    Return result

Note: =====================================================================
Note: PERFORMANCE ATTRIBUTION OPERATIONS
Note: =====================================================================

Process called "decompose_bond_returns" that takes portfolio_returns as List[Float], duration_contribution as Float, credit_contribution as Float, security_selection as Float returns Dictionary[String, Float]:
    Note: Decompose bond portfolio returns into duration, credit, and security selection effects
    Note: Analyzes sources of active return relative to benchmark
    
    Let result be Dictionary[String, Float]
    
    Note: Calculate total portfolio return
    Let total_return be 0.0
    Let i be 0
    Repeat while i is less than portfolio_returns.length:
        Set total_return to total_return plus portfolio_returns[i]
        Set i to i plus 1
    Let average_return be total_return / Float(portfolio_returns.length)
    
    Set result["total_portfolio_return"] to average_return
    Set result["duration_contribution"] to duration_contribution
    Set result["credit_contribution"] to credit_contribution
    Set result["security_selection_contribution"] to security_selection
    
    Note: Calculate interaction effects and residual
    Let direct_effects_total be duration_contribution plus credit_contribution plus security_selection
    Let residual_return be average_return minus direct_effects_total
    Set result["interaction_effects"] to residual_return
    
    Note: Calculate relative contributions as percentages
    If average_return does not equal 0.0:
        Set result["duration_contribution_pct"] to (duration_contribution / average_return) multiplied by 100.0
        Set result["credit_contribution_pct"] to (credit_contribution / average_return) multiplied by 100.0
        Set result["security_selection_pct"] to (security_selection / average_return) multiplied by 100.0
        Set result["residual_pct"] to (residual_return / average_return) multiplied by 100.0
    Otherwise:
        Set result["duration_contribution_pct"] to 0.0
        Set result["credit_contribution_pct"] to 0.0
        Set result["security_selection_pct"] to 0.0
        Set result["residual_pct"] to 0.0
    
    Return result

Process called "analyze_yield_curve_positioning" that takes portfolio_duration_distribution as Dictionary[String, Float], benchmark_duration_distribution as Dictionary[String, Float] returns Dictionary[String, Float]:
    Note: Analyze portfolio positioning along yield curve relative to benchmark
    Note: Identifies duration overweights and underweights across curve segments
    
    Let result be Dictionary[String, Float]
    
    Note: Define standard duration buckets
    Let duration_buckets be ["0-1Y", "1-3Y", "3-5Y", "5-10Y", "10Y+"]
    
    Note: Calculate positioning differences
    Let total_difference be 0.0
    Let i be 0
    Repeat while i is less than duration_buckets.length:
        Let bucket be duration_buckets[i]
        
        Let portfolio_weight be 0.0
        If portfolio_duration_distribution.has_key(bucket):
            Set portfolio_weight to portfolio_duration_distribution[bucket]
        
        Let benchmark_weight be 0.0
        If benchmark_duration_distribution.has_key(bucket):
            Set benchmark_weight to benchmark_duration_distribution[bucket]
        
        Let positioning_difference be portfolio_weight minus benchmark_weight
        Set result[bucket plus "_positioning"] to positioning_difference
        Set result[bucket plus "_portfolio_weight"] to portfolio_weight
        Set result[bucket plus "_benchmark_weight"] to benchmark_weight
        
        Let abs_difference be positioning_difference
        If abs_difference is less than 0.0:
            Set abs_difference to -1.0 multiplied by abs_difference
        Set total_difference to total_difference plus abs_difference
        
        Set i to i plus 1
    
    Set result["total_positioning_difference"] to total_difference
    
    Note: Identify largest overweight and underweight
    Let max_overweight be 0.0
    Let max_underweight be 0.0
    Set i to 0
    Repeat while i is less than duration_buckets.length:
        Let bucket be duration_buckets[i]
        Let positioning be result[bucket plus "_positioning"]
        
        If positioning is greater than max_overweight:
            Set max_overweight to positioning
            Set result["largest_overweight_bucket"] to Float(i plus 1)  Note: Using bucket index plus 1
        
        If positioning is less than max_underweight:
            Set max_underweight to positioning
            Set result["largest_underweight_bucket"] to Float(i plus 1)
        
        Set i to i plus 1
    
    Set result["max_overweight_magnitude"] to max_overweight
    Set result["max_underweight_magnitude"] to max_underweight
    
    Note: Calculate curve positioning bias
    Let short_end_weight be result["0-1Y_positioning"] plus result["1-3Y_positioning"]
    Let long_end_weight be result["5-10Y_positioning"] plus result["10Y+_positioning"]
    Let curve_bias be long_end_weight minus short_end_weight
    
    Set result["curve_positioning_bias"] to curve_bias
    If curve_bias is greater than 0.05:
        Set result["curve_strategy"] to 2.0  Note: Steepener
    Otherwise if curve_bias is less than -0.05:
        Set result["curve_strategy"] to 1.0  Note: Flattener
    Otherwise:
        Set result["curve_strategy"] to 0.0  Note: Neutral
    
    Return result

Process called "measure_sector_allocation_effects" that takes portfolio_sector_weights as Dictionary[String, Float], benchmark_sector_weights as Dictionary[String, Float], sector_returns as Dictionary[String, Float] returns Dictionary[String, Float]:
    Note: Measure sector allocation effects in bond portfolio performance attribution
    Note: Calculates return contribution from sector allocation decisions
    
    Let result be Dictionary[String, Float]
    
    Note: Define standard sectors
    Let sectors be ["TREASURY", "AGENCY", "CORPORATE", "MUNICIPAL", "SECURITIZED"]
    
    Let total_allocation_effect be 0.0
    Let i be 0
    Repeat while i is less than sectors.length:
        Let sector be sectors[i]
        
        Note: Get sector weights
        Let portfolio_weight be 0.0
        If portfolio_sector_weights.has_key(sector):
            Set portfolio_weight to portfolio_sector_weights[sector]
        
        Let benchmark_weight be 0.0
        If benchmark_sector_weights.has_key(sector):
            Set benchmark_weight to benchmark_sector_weights[sector]
        
        Note: Get sector return
        Let sector_return be 0.0
        If sector_returns.has_key(sector):
            Set sector_return to sector_returns[sector]
        
        Note: Calculate allocation effect
        Let weight_difference be portfolio_weight minus benchmark_weight
        Let allocation_effect be weight_difference multiplied by sector_return
        
        Set result[sector plus "_portfolio_weight"] to portfolio_weight
        Set result[sector plus "_benchmark_weight"] to benchmark_weight
        Set result[sector plus "_weight_difference"] to weight_difference
        Set result[sector plus "_return"] to sector_return
        Set result[sector plus "_allocation_effect"] to allocation_effect
        
        Set total_allocation_effect to total_allocation_effect plus allocation_effect
        Set i to i plus 1
    
    Set result["total_allocation_effect"] to total_allocation_effect
    
    Note: Calculate benchmark return for comparison
    Let benchmark_return be 0.0
    Set i to 0
    Repeat while i is less than sectors.length:
        Let sector be sectors[i]
        Let benchmark_weight be result[sector plus "_benchmark_weight"]
        Let sector_return be result[sector plus "_return"]
        Set benchmark_return to benchmark_return plus (benchmark_weight multiplied by sector_return)
        Set i to i plus 1
    
    Set result["benchmark_return"] to benchmark_return
    
    Note: Calculate portfolio return from sector weights
    Let portfolio_sector_return be 0.0
    Set i to 0
    Repeat while i is less than sectors.length:
        Let sector be sectors[i]
        Let portfolio_weight be result[sector plus "_portfolio_weight"]
        Let sector_return be result[sector plus "_return"]
        Set portfolio_sector_return to portfolio_sector_return plus (portfolio_weight multiplied by sector_return)
        Set i to i plus 1
    
    Set result["portfolio_sector_return"] to portfolio_sector_return
    Set result["active_sector_return"] to portfolio_sector_return minus benchmark_return
    
    Return result

Process called "calculate_carry_and_rolldown" that takes bond_positions as Dictionary[String, Float], yield_curve_changes as Dictionary[String, Float] returns Dictionary[String, Float]:
    Note: Calculate carry and rolldown contributions to bond portfolio performance
    Note: Carry is equal to coupon income, Rolldown is equal to price appreciation from maturity shortening
    
    Let result be Dictionary[String, Float]
    
    Let total_carry be 0.0
    Let total_rolldown be 0.0
    Let total_curve_change be 0.0
    
    Let bond_ids be bond_positions.keys()
    
    Let i be 0
    Repeat while i is less than bond_ids.length:
        Let bond_id be bond_ids[i]
        Let position_size be bond_positions[bond_id]
        
        Note: Estimate carry (coupon income)
        Let estimated_coupon_rate be estimate_coupon_from_id(bond_id)
        Let carry_contribution be position_size multiplied by estimated_coupon_rate multiplied by (1.0 / 12.0)  Note: Monthly carry
        Set total_carry to total_carry plus carry_contribution
        
        Note: Estimate rolldown effect
        Let bond_duration be estimate_duration_from_id(bond_id)
        Let rolldown_benefit be position_size multiplied by bond_duration multiplied by 0.001  Note: 1bp/month rolldown
        Set total_rolldown to total_rolldown plus rolldown_benefit
        
        Note: Calculate curve change impact
        Let maturity_bucket be classify_maturity_bucket(bond_id)
        Let curve_change_key be maturity_bucket plus "_change"
        Let curve_change be 0.0
        If yield_curve_changes.has_key(curve_change_key):
            Set curve_change to yield_curve_changes[curve_change_key]
        
        Let curve_impact be -1.0 multiplied by position_size multiplied by bond_duration multiplied by curve_change  Note: Negative duration impact
        Set total_curve_change to total_curve_change plus curve_impact
        
        Note: Store individual bond contributions
        Set result[bond_id plus "_carry"] to carry_contribution
        Set result[bond_id plus "_rolldown"] to rolldown_benefit
        Set result[bond_id plus "_curve_impact"] to curve_impact
        
        Set i to i plus 1
    
    Note: Store portfolio totals
    Set result["total_carry"] to total_carry
    Set result["total_rolldown"] to total_rolldown
    Set result["total_curve_change_impact"] to total_curve_change
    Set result["carry_and_rolldown"] to total_carry plus total_rolldown
    Set result["total_return_breakdown"] to total_carry plus total_rolldown plus total_curve_change
    
    Note: Calculate annualized metrics
    Set result["annualized_carry"] to total_carry multiplied by 12.0
    Set result["annualized_rolldown"] to total_rolldown multiplied by 12.0
    
    Return result

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_bond_parameters" that takes bond_specification as Dictionary[String, Float], validation_rules as Dictionary[String, String] returns Dictionary[String, Boolean]:
    Note: Validate bond contract parameters for consistency and market conventions
    Note: Checks parameter ranges, consistency, and market convention compliance
    
    Let result be Dictionary[String, Boolean]
    Set result["overall_valid"] to true
    
    Note: Extract bond parameters
    Let face_value be bond_specification["face_value"]
    Let coupon_rate be bond_specification["coupon_rate"]
    Let maturity_years be bond_specification["maturity_years"]
    Let issue_price be bond_specification["issue_price"]
    
    Note: Validate face value
    Set result["face_value_valid"] to true
    If face_value is less than or equal to 0.0 Or face_value is greater than 1000000000.0:
        Set result["face_value_valid"] to false
        Set result["overall_valid"] to false
    
    Note: Validate coupon rate
    Set result["coupon_rate_valid"] to true
    If coupon_rate is less than 0.0 Or coupon_rate is greater than 0.30:
        Set result["coupon_rate_valid"] to false
        Set result["overall_valid"] to false
    
    Note: Validate maturity
    Set result["maturity_valid"] to true
    If maturity_years is less than or equal to 0.0 Or maturity_years is greater than 100.0:
        Set result["maturity_valid"] to false
        Set result["overall_valid"] to false
    
    Note: Validate issue price
    Set result["issue_price_valid"] to true
    If issue_price is less than or equal to 0.0 Or issue_price is greater than 200.0:
        Set result["issue_price_valid"] to false
        Set result["overall_valid"] to false
    
    Note: Cross-validation checks
    Set result["consistency_valid"] to true
    
    Note: Zero coupon bonds should trade at discount
    If coupon_rate is less than 0.001 And issue_price is greater than 99.0:
        Set result["consistency_valid"] to false
        Set result["overall_valid"] to false
    
    Note: High coupon bonds should not trade at deep discount
    If coupon_rate is greater than 0.10 And issue_price is less than 80.0:
        Set result["consistency_valid"] to false
        Set result["overall_valid"] to false
    
    Note: Market convention checks
    Set result["market_conventions_valid"] to true
    
    Note: Check for standard coupon increments
    Let coupon_percentage be coupon_rate multiplied by 100.0
    Let coupon_remainder be coupon_percentage minus Float(Integer(coupon_percentage))
    If coupon_remainder does not equal 0.0 And coupon_remainder does not equal 0.25 And coupon_remainder does not equal 0.5 And coupon_remainder does not equal 0.75:
        Set result["market_conventions_valid"] to false
    
    Note: Check for standard maturity years
    If maturity_years is greater than 1.0:
        Let year_remainder be maturity_years minus Float(Integer(maturity_years))
        If year_remainder does not equal 0.0 And year_remainder does not equal 0.25 And year_remainder does not equal 0.5 And year_remainder does not equal 0.75:
            Set result["market_conventions_valid"] to false
    
    Return result

Process called "optimize_computation_performance" that takes pricing_config as Dictionary[String, String], performance_targets as Dictionary[String, Float] returns Dictionary[String, String]:
    Note: Optimize bond pricing computation performance through caching and vectorization
    Note: Provides recommendations for improving computational efficiency
    
    Let result be Dictionary[String, String]
    
    Note: Analyze current configuration
    Let cache_enabled be "false"
    If pricing_config.has_key("enable_caching"):
        Set cache_enabled to pricing_config["enable_caching"]
    
    Let batch_size_str be "100"
    If pricing_config.has_key("batch_size"):
        Set batch_size_str to pricing_config["batch_size"]
    
    Let precision_str be "high"
    If pricing_config.has_key("precision_mode"):
        Set precision_str to pricing_config["precision_mode"]
    
    Note: Extract performance targets
    Let target_latency be performance_targets["max_latency_ms"]
    Let target_throughput be performance_targets["min_throughput_per_sec"]
    
    Note: Generate optimization recommendations
    Set result["cache_recommendation"] to "enable"
    If cache_enabled is equal to "false":
        Set result["cache_recommendation"] to "enable_recommended"
    
    Set result["batch_optimization"] to "increase_batch_size"
    If target_throughput is greater than 1000.0:
        Set result["batch_optimization"] to "use_vectorized_operations"
    
    Set result["precision_optimization"] to "maintain_current"
    If target_latency is less than 10.0:
        Set result["precision_optimization"] to "reduce_to_medium"
    
    Note: Memory optimization
    Set result["memory_optimization"] to "implement_object_pooling"
    If target_throughput is greater than 500.0:
        Set result["memory_optimization"] to "use_memory_mapped_curves"
    
    Note: Algorithm optimization
    Set result["algorithm_optimization"] to "precompute_discount_factors"
    If target_latency is less than 5.0:
        Set result["algorithm_optimization"] to "use_lookup_tables"
    
    Note: Parallelization recommendations
    Set result["parallelization"] to "single_threaded"
    If target_throughput is greater than 100.0:
        Set result["parallelization"] to "multi_threaded_recommended"
    
    Set result["overall_strategy"] to "incremental_optimization"
    If target_latency is less than 1.0 Or target_throughput is greater than 5000.0:
        Set result["overall_strategy"] to "aggressive_optimization_required"
    
    Return result

Process called "troubleshoot_pricing_issues" that takes issue_description as Dictionary[String, String] returns List[String]:
    Note: Provide troubleshooting guidance for bond pricing and analysis problems
    Note: Diagnoses common pricing issues and provides step-by-step solutions
    
    Let result be List[String]
    
    Let issue_type be "unknown"
    If issue_description.has_key("issue_type"):
        Set issue_type to issue_description["issue_type"]
    
    Let error_message be ""
    If issue_description.has_key("error_message"):
        Set error_message to issue_description["error_message"]
    
    If issue_type is equal to "negative_price":
        Add "Check coupon rate and yield inputs for reasonableness" to result
        Add "Verify discount rate is positive and realistic" to result
        Add "Confirm maturity date is in the future" to result
        Add "Review cash flow calculation for errors" to result
    Otherwise if issue_type is equal to "yield_convergence_failure":
        Add "Increase maximum iterations in Newton-Raphson solver" to result
        Add "Adjust initial yield guess closer to market rates" to result
        Add "Check for extreme bond characteristics (very high/low coupon)" to result
        Add "Verify bond price is within reasonable range" to result
    Otherwise if issue_type is equal to "duration_calculation_error":
        Add "Confirm yield is positive and realistic" to result
        Add "Check for zero or negative cash flows" to result
        Add "Verify maturity and coupon payment dates" to result
        Add "Review duration formula implementation" to result
    Otherwise if issue_type is equal to "curve_interpolation_failure":
        Add "Check yield curve has sufficient data points" to result
        Add "Verify maturity points are in ascending order" to result
        Add "Confirm interpolation range is within curve bounds" to result
        Add "Review curve construction methodology" to result
    Otherwise if issue_type is equal to "option_pricing_error":
        Add "Verify volatility parameter is reasonable (5-30%)" to result
        Add "Check option expiration relative to bond maturity" to result
        Add "Confirm strike price and call/put schedule" to result
        Add "Review binomial tree parameters" to result
    Otherwise:
        Add "General troubleshooting steps:" to result
        Add "1. Validate all input parameters for reasonableness" to result
        Add "2. Check for null or undefined values" to result
        Add "3. Verify calculation precision settings" to result
        Add "4. Review error logs for specific failure points" to result
        Add "5. Test with simplified bond characteristics" to result
    
    Add "If issues persist, consider using alternative pricing methods" to result
    
    Return result

Process called "benchmark_bond_models" that takes model_prices as List[Float], market_prices as List[Float], benchmark_methods as List[String] returns Dictionary[String, Dictionary[String, Float]]:
    Note: Benchmark bond pricing model accuracy against market prices and alternative methods
    Note: Calculates accuracy metrics and comparative performance statistics
    
    Let result be Dictionary[String, Dictionary[String, Float]]
    
    Note: Validate inputs
    If model_prices.length does not equal market_prices.length Or model_prices.length is equal to 0:
        Let error_result be Dictionary[String, Float]
        Set error_result["error"] to 1.0
        Set result["validation_error"] to error_result
        Return result
    
    Note: Calculate basic accuracy metrics
    Let accuracy_metrics be Dictionary[String, Float]
    
    Note: Mean Absolute Error
    Let total_absolute_error be 0.0
    Let i be 0
    Repeat while i is less than model_prices.length:
        Let error be model_prices[i] minus market_prices[i]
        If error is less than 0.0:
            Set error to -1.0 multiplied by error
        Set total_absolute_error to total_absolute_error plus error
        Set i to i plus 1
    
    Let mean_absolute_error be total_absolute_error / Float(model_prices.length)
    Set accuracy_metrics["mean_absolute_error"] to mean_absolute_error
    
    Note: Root Mean Square Error
    Let total_squared_error be 0.0
    Set i to 0
    Repeat while i is less than model_prices.length:
        Let error be model_prices[i] minus market_prices[i]
        Set total_squared_error to total_squared_error plus (error multiplied by error)
        Set i to i plus 1
    
    Let mean_squared_error be total_squared_error / Float(model_prices.length)
    Let rmse_calc be Operations.power(String(mean_squared_error), "0.5", 30)
    Set accuracy_metrics["root_mean_square_error"] to Float(rmse_calc.result_value)
    
    Note: Calculate R-squared (correlation)
    Let market_mean be 0.0
    Set i to 0
    Repeat while i is less than market_prices.length:
        Set market_mean to market_mean plus market_prices[i]
        Set i to i plus 1
    Set market_mean to market_mean / Float(market_prices.length)
    
    Let total_sum_squares be 0.0
    Let residual_sum_squares be 0.0
    Set i to 0
    Repeat while i is less than model_prices.length:
        Let market_deviation be market_prices[i] minus market_mean
        Set total_sum_squares to total_sum_squares plus (market_deviation multiplied by market_deviation)
        
        Let residual be model_prices[i] minus market_prices[i]
        Set residual_sum_squares to residual_sum_squares plus (residual multiplied by residual)
        Set i to i plus 1
    
    Let r_squared be 1.0
    If total_sum_squares is greater than 0.0001:
        Set r_squared to 1.0 minus (residual_sum_squares / total_sum_squares)
    Set accuracy_metrics["r_squared"] to r_squared
    
    Note: Maximum error
    Let max_error be 0.0
    Set i to 0
    Repeat while i is less than model_prices.length:
        Let error be model_prices[i] minus market_prices[i]
        If error is less than 0.0:
            Set error to -1.0 multiplied by error
        If error is greater than max_error:
            Set max_error to error
        Set i to i plus 1
    Set accuracy_metrics["maximum_error"] to max_error
    
    Set result["accuracy_metrics"] to accuracy_metrics
    
    Note: Benchmark against alternative methods
    Let i be 0
    Repeat while i is less than benchmark_methods.length:
        Let method be benchmark_methods[i]
        Let method_results be Dictionary[String, Float]
        
        Note: Simulate alternative method performance (simplified)
        If method is equal to "yield_to_maturity":
            Set method_results["estimated_mae"] to mean_absolute_error multiplied by 1.1
            Set method_results["estimated_rmse"] to Float(rmse_calc.result_value) multiplied by 1.05
            Set method_results["estimated_r_squared"] to r_squared multiplied by 0.95
        Otherwise if method is equal to "duration_matching":
            Set method_results["estimated_mae"] to mean_absolute_error multiplied by 1.3
            Set method_results["estimated_rmse"] to Float(rmse_calc.result_value) multiplied by 1.2
            Set method_results["estimated_r_squared"] to r_squared multiplied by 0.9
        Otherwise:
            Set method_results["estimated_mae"] to mean_absolute_error multiplied by 1.2
            Set method_results["estimated_rmse"] to Float(rmse_calc.result_value) multiplied by 1.15
            Set method_results["estimated_r_squared"] to r_squared multiplied by 0.92
        
        Set result[method] to method_results
        Set i to i plus 1
    
    Note: Overall model rating
    Let model_rating be Dictionary[String, Float]
    
    Let rating_score be 0.0
    If mean_absolute_error is less than 0.5:
        Set rating_score to rating_score plus 25.0
    Otherwise if mean_absolute_error is less than 1.0:
        Set rating_score to rating_score plus 15.0
    Otherwise if mean_absolute_error is less than 2.0:
        Set rating_score to rating_score plus 10.0
    
    If Float(rmse_calc.result_value) is less than 1.0:
        Set rating_score to rating_score plus 25.0
    Otherwise if Float(rmse_calc.result_value) is less than 2.0:
        Set rating_score to rating_score plus 15.0
    Otherwise if Float(rmse_calc.result_value) is less than 3.0:
        Set rating_score to rating_score plus 10.0
    
    If r_squared is greater than 0.95:
        Set rating_score to rating_score plus 25.0
    Otherwise if r_squared is greater than 0.90:
        Set rating_score to rating_score plus 20.0
    Otherwise if r_squared is greater than 0.80:
        Set rating_score to rating_score plus 15.0
    
    If max_error is less than 2.0:
        Set rating_score to rating_score plus 25.0
    Otherwise if max_error is less than 5.0:
        Set rating_score to rating_score plus 15.0
    Otherwise if max_error is less than 10.0:
        Set rating_score to rating_score plus 10.0
    
    Set model_rating["overall_score"] to rating_score
    Set model_rating["max_possible_score"] to 100.0
    Set result["model_rating"] to model_rating
    
    Return result