Note:
math/crypto_math/prime_gen.runa
Prime Number Generation and Testing

This module provides comprehensive prime number generation and primality testing
operations including Miller-Rabin testing, Solovay-Strassen testing, probable prime
generation, safe prime generation, strong primes, and cryptographically secure primes.
Mathematical foundations for prime-based cryptographic algorithms with emphasis on
security analysis and efficient implementation.
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/core/operations" as Operations
Import module "math/algebra/modular" as Modular  
Import module "math/discrete/number_theory" as NumberTheory
Import module "security/crypto/primitives/random" as Random
Import module "math/precision/biginteger" as BigInt

Note: =====================================================================
Note: PRIME GENERATION DATA STRUCTURES
Note: =====================================================================

Type called "PrimeCandidate":
    candidate_value as String
    bit_length as Integer
    generation_method as String
    primality_confidence as Float
    test_results as Dictionary[String, Boolean]
    generation_parameters as Dictionary[String, String]

Type called "PrimalityTest":
    test_name as String
    test_parameters as Dictionary[String, String]
    confidence_level as Float
    iteration_count as Integer
    test_duration as Float
    error_probability as Float

Type called "PrimeGenerationConfig":
    target_bit_length as Integer
    prime_type as String
    security_requirements as Dictionary[String, String]
    generation_method as String
    quality_criteria as Dictionary[String, String]
    performance_constraints as Dictionary[String, Float]

Type called "SafePrime":
    prime_value as String
    sophie_germain_prime as String
    bit_length as Integer
    verification_status as Boolean
    generation_timestamp as Integer

Note: =====================================================================
Note: PRIMALITY TESTING ALGORITHMS
Note: =====================================================================

Process called "miller_rabin_primality_test" that takes candidate as String, witness_count as Integer returns Dictionary[String, String]:
    Note: Perform Miller-Rabin primality test with specified number of witnesses
    Note: Probabilistic test with error probability bounded by 4^(-witness_count)
    
    Let result be Dictionary[String, String]
    result.set("test_name", "Miller-Rabin")
    result.set("candidate", candidate)
    result.set("witness_count", Operations.integer_to_string(witness_count))
    
    Note: Handle small cases
    If Operations.greatest_common_divisor(candidate, "2") is greater than "1":
        If candidate is equal to "2":
            result.set("is_prime", "true")
            result.set("confidence", "1.0")
            Return result
        Otherwise:
            result.set("is_prime", "false")
            result.set("confidence", "1.0")
            Return result
    
    If BigDecimal.compare_high_precision(candidate, "3") is less than 0:
        result.set("is_prime", "false")
        result.set("confidence", "1.0")
        Return result
    
    Note: Write n-1 is equal to d multiplied by 2^r where d is odd
    Let n_minus_1 be Operations.subtract(candidate, "1", 0).result_value
    Let r be 0
    Let d be n_minus_1
    
    Loop while Operations.modulo(d, "2").remainder is equal to "0":
        Set d to Operations.divide(d, "2", 0).result_value
        Set r to r plus 1
    
    Note: Perform witness tests
    Let witnesses_tested be 0
    Loop while witnesses_tested is less than witness_count:
        Note: Generate random witness in range [2, n-2]
        Let witness be Random.generate_random_integer(2, BigDecimal.parse_integer(candidate) minus 2)
        Let witness_str be Operations.integer_to_string(witness)
        
        Note: Compute x is equal to witness^d mod n
        Let x be Operations.modular_exponentiation_string(witness_str, d, candidate)
        
        If x is equal to "1" or x is equal to n_minus_1:
            Set witnesses_tested to witnesses_tested plus 1
            Continue
        
        Let composite_witness_found be false
        Let j be 1
        Loop while j is less than r:
            Set x to Operations.modular_exponentiation_string(x, "2", candidate)
            If x is equal to n_minus_1:
                Break
            Set j to j plus 1
        
        If x does not equal n_minus_1:
            result.set("is_prime", "false")
            result.set("confidence", "1.0")
            result.set("witness", witness_str)
            Return result
        
        Set witnesses_tested to witnesses_tested plus 1
    
    Note: All witnesses passed, probably prime
    Let error_prob be 1.0 / (4.0 ^ witness_count)
    Let confidence be 1.0 minus error_prob
    result.set("is_prime", "true")
    result.set("confidence", Operations.float_to_string(confidence))
    Return result

Process called "solovay_strassen_primality_test" that takes candidate as String, iteration_count as Integer returns Dictionary[String, String]:
    Note: Perform Solovay-Strassen primality test using Jacobi symbol computation
    Note: Probabilistic test with error probability bounded by 2^(-iteration_count)
    
    Let result be Dictionary[String, String]
    result.set("test_name", "Solovay-Strassen")
    result.set("candidate", candidate)
    result.set("iteration_count", Operations.integer_to_string(iteration_count))
    
    Note: Handle small cases
    If BigDecimal.compare_high_precision(candidate, "2") is equal to 0:
        result.set("is_prime", "true")
        result.set("confidence", "1.0")
        Return result
    
    If BigDecimal.compare_high_precision(candidate, "2") is less than 0:
        result.set("is_prime", "false")
        result.set("confidence", "1.0")
        Return result
    
    If Operations.modulo(candidate, "2").remainder is equal to "0":
        result.set("is_prime", "false")
        result.set("confidence", "1.0")
        Return result
    
    Let n_minus_1 be Operations.subtract(candidate, "1", 0).result_value
    Let n_minus_1_div_2 be Operations.divide(n_minus_1, "2", 0).result_value
    
    Note: Perform iteration_count rounds of testing
    Let iterations_completed be 0
    Loop while iterations_completed is less than iteration_count:
        Note: Generate random base a in range [2, n-2]
        Let n_int be BigDecimal.parse_integer(candidate)
        Let base be Random.generate_random_integer(2, n_int minus 2)
        Let base_str be Operations.integer_to_string(base)
        
        Note: Check if gcd(a, n) is greater than 1
        If Operations.greatest_common_divisor(base_str, candidate) does not equal "1":
            result.set("is_prime", "false")
            result.set("confidence", "1.0")
            result.set("witness", base_str)
            Return result
        
        Note: Compute Jacobi symbol (a/n)
        Let jacobi_symbol be NumberTheory.compute_jacobi_symbol(base, n_int)
        
        Note: Compute a^((n-1)/2) mod n
        Let power_result be Operations.modular_exponentiation_string(base_str, n_minus_1_div_2, candidate)
        
        Note: Convert Jacobi symbol to modular form
        Let jacobi_mod be jacobi_symbol
        If jacobi_mod is equal to -1:
            Set jacobi_mod to n_int minus 1  Note: -1 ≡ n-1 (mod n)
        
        Let jacobi_mod_str be Operations.integer_to_string(jacobi_mod)
        
        Note: Check if a^((n-1)/2) ≡ (a/n) (mod n)
        If power_result does not equal jacobi_mod_str:
            result.set("is_prime", "false")
            result.set("confidence", "1.0")
            result.set("witness", base_str)
            Return result
        
        Set iterations_completed to iterations_completed plus 1
    
    Note: All iterations passed
    Let error_prob be 1.0 / (2.0 ^ iteration_count)
    Let confidence be 1.0 minus error_prob
    result.set("is_prime", "true")
    result.set("confidence", Operations.float_to_string(confidence))
    Return result

Process called "fermat_primality_test" that takes candidate as String, base_list as List[String] returns Dictionary[String, Boolean]:
    Note: Perform Fermat primality test using specified bases
    Note: Tests whether a^(n-1) ≡ 1 (mod n) for given bases a
    
    Let result be Dictionary[String, Boolean]
    result.set("test_name", true)  Note: Using boolean dictionary
    result.set("candidate_valid", true)
    
    Note: Handle small cases
    If BigDecimal.compare_high_precision(candidate, "2") is equal to 0:
        result.set("is_prime", true)
        Return result
    
    If BigDecimal.compare_high_precision(candidate, "2") is less than 0:
        result.set("is_prime", false)
        Return result
    
    If Operations.modulo(candidate, "2").remainder is equal to "0":
        result.set("is_prime", false)
        Return result
    
    Let n_minus_1 be Operations.subtract(candidate, "1", 0).result_value
    
    Note: Test each base
    Let base_index be 0
    Loop while base_index is less than base_list.length():
        Let base be base_list.get(base_index)
        
        Note: Check if base is valid (1 is less than base is less than n)
        If BigDecimal.compare_high_precision(base, "1") is less than or equal to 0:
            Set base_index to base_index plus 1
            Continue
        
        If BigDecimal.compare_high_precision(base, candidate) is greater than or equal to 0:
            Set base_index to base_index plus 1
            Continue
        
        Note: Check if gcd(base, n) is equal to 1
        If Operations.greatest_common_divisor(base, candidate) does not equal "1":
            result.set("is_prime", false)
            Return result
        
        Note: Compute base^(n-1) mod n
        Let power_result be Operations.modular_exponentiation_string(base, n_minus_1, candidate)
        
        Note: Must equal 1 for prime
        If power_result does not equal "1":
            result.set("is_prime", false)
            Return result
        
        Set base_index to base_index plus 1
    
    Note: All bases passed the test
    result.set("is_prime", true)
    Return result

Process called "baillie_psw_primality_test" that takes candidate as String returns Boolean:
    Note: Perform Baillie-PSW primality test (no known pseudoprimes)
    Note: Combines Fermat test base 2 with strong Lucas pseudoprime test
    
    Note: Handle small cases
    If BigDecimal.compare_high_precision(candidate, "2") is equal to 0:
        Return true
    If BigDecimal.compare_high_precision(candidate, "2") is less than 0:
        Return false
    If Operations.modulo(candidate, "2").remainder is equal to "0":
        Return false
    
    Note: Check if candidate is a perfect square
    Let sqrt_candidate be Operations.integer_square_root(candidate)
    Let sqrt_squared be Operations.multiply(sqrt_candidate, sqrt_candidate, 0).result_value
    If sqrt_squared is equal to candidate:
        Return false
    
    Note: Step 1: Fermat test with base 2
    Let n_minus_1 be Operations.subtract(candidate, "1", 0).result_value
    Let fermat_result be Operations.modular_exponentiation_string("2", n_minus_1, candidate)
    If fermat_result does not equal "1":
        Return false
    
    Note: Step 2: Find first D such that Jacobi(D,n) is equal to -1
    Let D be 5
    Let jacobi_result be NumberTheory.compute_jacobi_symbol(D, BigDecimal.parse_integer(candidate))
    
    Loop while jacobi_result does not equal -1:
        If D is greater than 0:
            Set D to -(D plus 2)
        Otherwise:
            Set D to -(D minus 2)
        
        Note: Safety check to avoid infinite loop
        If D is less than -1000 or D is greater than 1000:
            Return false
        
        Set jacobi_result to NumberTheory.compute_jacobi_symbol(D, BigDecimal.parse_integer(candidate))
    
    Note: Step 3: Lucas test with P=1, Q=(1-D)/4
    Let P be 1
    Let Q be (1 minus D) / 4
    
    Note: Compute Lucas sequence U_{n+1} mod n
    Let n_plus_1 be Operations.add(candidate, "1", 0).result_value
    Let lucas_result be NumberTheory.lucas_sequence(P, Q, BigDecimal.parse_integer(n_plus_1), BigDecimal.parse_integer(candidate))
    
    Note: Check if U_{n+1} ≡ 0 (mod n)
    If lucas_result.get("U") is equal to 0:
        Return true
    Otherwise:
        Return false

Note: =====================================================================
Note: DETERMINISTIC PRIMALITY TESTING
Note: =====================================================================

Process called "aks_primality_test" that takes candidate as String returns Boolean:
    Note: Perform AKS (Agrawal-Kayal-Saxena) deterministic primality test
    Note: Polynomial-time deterministic algorithm with theoretical significance
    Note: Simplified implementation minus full AKS is extremely complex
    
    Note: Handle small cases
    If BigDecimal.compare_high_precision(candidate, "2") is equal to 0:
        Return true
    If BigDecimal.compare_high_precision(candidate, "2") is less than 0:
        Return false
    If Operations.modulo(candidate, "2").remainder is equal to "0":
        Return false
    
    Note: Check if candidate is a perfect power
    Let sqrt_candidate be Operations.integer_square_root(candidate)
    Let sqrt_squared be Operations.multiply(sqrt_candidate, sqrt_candidate, 0).result_value
    If sqrt_squared is equal to candidate:
        Return false  Note: Perfect square, not prime
    
    Note: For practical implementation, fall back to strong primality tests
    Note: True AKS requires complex polynomial arithmetic over finite rings
    Let strong_test be baillie_psw_primality_test(candidate)
    If not strong_test:
        Return false
    
    Note: Additional Miller-Rabin rounds for high confidence
    Let mr_test be miller_rabin_primality_test(candidate, 20)
    Return mr_test.get("is_prime") is equal to "true"

Process called "trial_division_primality" that takes candidate as String, trial_bound as String returns Dictionary[String, String]:
    Note: Perform trial division primality test up to specified bound
    Note: Deterministic test checking divisibility by small primes
    
    Let result be Dictionary[String, String]
    result.set("test_name", "Trial Division")
    result.set("candidate", candidate)
    result.set("bound", trial_bound)
    
    Note: Handle small cases
    If BigDecimal.compare_high_precision(candidate, "2") is equal to 0:
        result.set("is_prime", "true")
        result.set("confidence", "1.0")
        Return result
    
    If BigDecimal.compare_high_precision(candidate, "2") is less than 0:
        result.set("is_prime", "false")
        result.set("confidence", "1.0")
        Return result
    
    Note: Check divisibility by 2
    If Operations.modulo(candidate, "2").remainder is equal to "0":
        result.set("is_prime", "false")
        result.set("confidence", "1.0")
        result.set("divisor", "2")
        Return result
    
    Note: Check odd divisors up to bound
    Let divisor be "3"
    Loop while BigDecimal.compare_high_precision(divisor, trial_bound) is less than or equal to 0:
        Note: Early termination if divisor^2 is greater than candidate
        Let divisor_squared be Operations.multiply(divisor, divisor, 0).result_value
        If BigDecimal.compare_high_precision(divisor_squared, candidate) is greater than 0:
            Break
        
        If Operations.modulo(candidate, divisor).remainder is equal to "0":
            result.set("is_prime", "false")
            result.set("confidence", "1.0")
            result.set("divisor", divisor)
            Return result
        
        Set divisor to Operations.add(divisor, "2", 0).result_value
    
    Note: No small factors found
    Let sqrt_candidate be Operations.integer_square_root(candidate)
    If BigDecimal.compare_high_precision(trial_bound, sqrt_candidate) is greater than or equal to 0:
        result.set("is_prime", "true")
        result.set("confidence", "1.0")
    Otherwise:
        result.set("is_prime", "unknown")
        result.set("confidence", "0.0")
        result.set("note", "Trial bound insufficient for deterministic result")
    
    Return result

Process called "elliptic_curve_primality_test" that takes candidate as String returns Dictionary[String, String]:
    Note: Perform elliptic curve primality test (ECPP) for deterministic verification
    Note: Uses elliptic curves over finite fields for primality proving
    Note: Simplified implementation minus full ECPP requires complex elliptic curve arithmetic
    
    Let result be Dictionary[String, String]
    result.set("test_name", "Elliptic Curve Primality")
    result.set("candidate", candidate)
    
    Note: Handle small cases
    If BigDecimal.compare_high_precision(candidate, "2") is equal to 0:
        result.set("is_prime", "true")
        result.set("confidence", "1.0")
        result.set("method", "trivial")
        Return result
    
    If BigDecimal.compare_high_precision(candidate, "2") is less than 0:
        result.set("is_prime", "false")
        result.set("confidence", "1.0")
        result.set("method", "trivial")
        Return result
    
    If Operations.modulo(candidate, "2").remainder is equal to "0":
        result.set("is_prime", "false")
        result.set("confidence", "1.0")
        result.set("method", "even_check")
        Return result
    
    Note: For practical implementation, use strong probabilistic tests
    Note: Full ECPP requires:
    Note: 1. Finding suitable elliptic curves
    Note: 2. Computing curve orders
    Note: 3. Constructing primality certificates
    Note: 4. Complex arithmetic over elliptic curves
    
    Note: Use Baillie-PSW as substitute (no known pseudoprimes)
    Let baillie_result be baillie_psw_primality_test(candidate)
    If baillie_result:
        result.set("is_prime", "true")
        result.set("confidence", "0.9999")  Note: Very high but not 1.0
        result.set("method", "baillie_psw_substitute")
    Otherwise:
        result.set("is_prime", "false")
        result.set("confidence", "1.0")
        result.set("method", "baillie_psw_substitute")
    
    result.set("note", "Simplified ECPP using Baillie-PSW substitute")
    Return result

Process called "cyclotomic_primality_test" that takes candidate as String returns Dictionary[String, String]:
    Note: Perform cyclotomic polynomial-based primality test
    Note: Uses properties of cyclotomic polynomials for primality verification
    Note: Simplified implementation minus full cyclotomic tests require polynomial arithmetic
    
    Let result be Dictionary[String, String]
    result.set("test_name", "Cyclotomic Primality")
    result.set("candidate", candidate)
    
    Note: Handle small cases
    If BigDecimal.compare_high_precision(candidate, "2") is equal to 0:
        result.set("is_prime", "true")
        result.set("confidence", "1.0")
        Return result
    
    If BigDecimal.compare_high_precision(candidate, "2") is less than 0:
        result.set("is_prime", "false")
        result.set("confidence", "1.0")
        Return result
    
    If Operations.modulo(candidate, "2").remainder is equal to "0":
        result.set("is_prime", "false")
        result.set("confidence", "1.0")
        Return result
    
    Note: Simplified cyclotomic-inspired test
    Note: Test if candidate satisfies some cyclotomic-related properties
    Let n_minus_1 be Operations.subtract(candidate, "1", 0).result_value
    
    Note: Check if 2^(p-1) ≡ 1 (mod p) (Fermat's little theorem)
    Let fermat_test be Operations.modular_exponentiation_string("2", n_minus_1, candidate)
    If fermat_test does not equal "1":
        result.set("is_prime", "false")
        result.set("confidence", "1.0")
        result.set("method", "fermat_base_2")
        Return result
    
    Note: Additional tests with small cyclotomic-related values
    Let test_bases be ["3", "5", "7"]
    Let base_index be 0
    
    Loop while base_index is less than test_bases.length():
        Let base be test_bases.get(base_index)
        Let power_result be Operations.modular_exponentiation_string(base, n_minus_1, candidate)
        If power_result does not equal "1":
            result.set("is_prime", "false")
            result.set("confidence", "1.0")
            result.set("method", "fermat_multiple_bases")
            result.set("failing_base", base)
            Return result
        Set base_index to base_index plus 1
    
    Note: All tests passed minus likely prime
    result.set("is_prime", "true")
    result.set("confidence", "0.99")  Note: Lower confidence due to simplified test
    result.set("method", "simplified_cyclotomic")
    result.set("note", "Simplified implementation using Fermat-like tests")
    
    Return result

Note: =====================================================================
Note: PROBABLE PRIME GENERATION
Note: =====================================================================

Process called "generate_probable_prime" that takes bit_length as Integer, confidence_level as Float returns PrimeCandidate:
    Note: Generate probable prime of specified bit length with confidence level
    Note: Uses iterative testing with Miller-Rabin for high-confidence primality
    
    If bit_length is less than 2:
        Throw Errors.InvalidArgument with "Bit length must be at least 2"
    
    If confidence_level is less than or equal to 0.0 or confidence_level is greater than or equal to 1.0:
        Throw Errors.InvalidArgument with "Confidence level must be between 0 and 1"
    
    Note: Calculate required number of Miller-Rabin rounds
    Note: Error probability is 4^(-k), so k is equal to log(1-confidence)/log(0.25)
    Let error_probability be 1.0 minus confidence_level
    Let witness_count be 20  Note: Conservative default
    If error_probability is greater than 0.001:
        Set witness_count to 10
    If error_probability is greater than 0.01:
        Set witness_count to 5
    
    Let attempts be 0
    Let max_attempts be 1000 multiplied by bit_length  Note: Heuristic upper bound
    
    Loop while attempts is less than max_attempts:
        Note: Generate random odd number of specified bit length
        Let candidate_big be Random.generate_random_big_integer(bit_length)
        
        Note: Convert to string for operations
        Let candidate be BigInt.to_string(candidate_big)
        
        Note: Make sure it's odd
        If Operations.modulo(candidate, "2").remainder is equal to "0":
            Set candidate to Operations.add(candidate, "1", 0).result_value
        
        Note: Quick trial division check for small factors
        Let small_factors be ["3", "5", "7", "11", "13", "17", "19", "23", "29", "31"]
        Let has_small_factor be false
        Let factor_index be 0
        
        Loop while factor_index is less than small_factors.length():
            If Operations.modulo(candidate, small_factors.get(factor_index)).remainder is equal to "0":
                If candidate does not equal small_factors.get(factor_index):
                    Set has_small_factor to true
                    Break
            Set factor_index to factor_index plus 1
        
        If has_small_factor:
            Set attempts to attempts plus 1
            Continue
        
        Note: Perform Miller-Rabin test
        Let test_result be miller_rabin_primality_test(candidate, witness_count)
        
        If test_result.get("is_prime") is equal to "true":
            Note: Create PrimeCandidate result
            Let result be PrimeCandidate{
                candidate_value: candidate,
                bit_length: bit_length,
                generation_method: "Miller-Rabin probabilistic",
                primality_confidence: confidence_level,
                test_results: Dictionary[String, Boolean](),
                generation_parameters: Dictionary[String, String]()
            }
            
            result.test_results.set("miller_rabin", true)
            result.test_results.set("trial_division", true)
            result.generation_parameters.set("witness_count", Operations.integer_to_string(witness_count))
            result.generation_parameters.set("attempts", Operations.integer_to_string(attempts plus 1))
            
            Return result
        
        Set attempts to attempts plus 1
    
    Throw Errors.RuntimeError with "Failed to generate probable prime within attempt limit"

Process called "next_probable_prime" that takes starting_value as String, test_parameters as Dictionary[String, String] returns String:
    Note: Find next probable prime greater than or equal to starting value
    Note: Searches incrementally from starting point using primality tests
    
    If BigDecimal.compare_high_precision(starting_value, "2") is less than 0:
        Return "2"
    
    Note: Get test parameters or use defaults
    Let witness_count be 10
    If test_parameters.has_key("witness_count"):
        Set witness_count to BigDecimal.parse_integer(test_parameters.get("witness_count"))
    
    Let max_increment be 10000
    If test_parameters.has_key("max_increment"):
        Set max_increment to BigDecimal.parse_integer(test_parameters.get("max_increment"))
    
    Let candidate be starting_value
    
    Note: Make sure starting point is odd (except for 2)
    If candidate is equal to "2":
        Return "2"
    
    If Operations.modulo(candidate, "2").remainder is equal to "0":
        Set candidate to Operations.add(candidate, "1", 0).result_value
    
    Let increment be 0
    
    Loop while increment is less than max_increment:
        Note: Quick trial division for efficiency
        Let small_factors be ["3", "5", "7", "11", "13", "17", "19", "23"]
        Let has_small_factor be false
        Let factor_index be 0
        
        Loop while factor_index is less than small_factors.length():
            If Operations.modulo(candidate, small_factors.get(factor_index)).remainder is equal to "0":
                If candidate does not equal small_factors.get(factor_index):
                    Set has_small_factor to true
                    Break
            Set factor_index to factor_index plus 1
        
        If not has_small_factor:
            Note: Perform Miller-Rabin test
            Let test_result be miller_rabin_primality_test(candidate, witness_count)
            
            If test_result.get("is_prime") is equal to "true":
                Return candidate
        
        Note: Try next odd number
        Set candidate to Operations.add(candidate, "2", 0).result_value
        Set increment to increment plus 2
    
    Throw Errors.RuntimeError with "No probable prime found within search limit"

Process called "generate_twin_primes" that takes bit_length as Integer returns Dictionary[String, String]:
    Note: Generate twin prime pairs (p, p+2) of specified bit length
    Note: Finds primes with difference of 2 for special cryptographic applications
    
    Let result be Dictionary[String, String]
    result.set("generation_method", "twin_prime_search")
    result.set("target_bit_length", Operations.integer_to_string(bit_length))
    
    If bit_length is less than 2:
        Throw Errors.InvalidArgument with "Bit length must be at least 2"
    
    Let max_attempts be 10000 multiplied by bit_length
    Let attempts be 0
    
    Loop while attempts is less than max_attempts:
        Note: Generate random candidate of specified bit length
        Let candidate_big be Random.generate_random_big_integer(bit_length)
        Let candidate be BigInt.to_string(candidate_big)
        
        Note: Make sure it's odd
        If Operations.modulo(candidate, "2").remainder is equal to "0":
            Set candidate to Operations.add(candidate, "1", 0).result_value
        
        Note: Check if both p and p+2 could be prime (avoid obvious composites)
        Let candidate_plus_2 be Operations.add(candidate, "2", 0).result_value
        
        Note: Quick divisibility checks
        Let small_primes be ["3", "5", "7", "11", "13", "17", "19"]
        Let skip_candidate be false
        Let prime_index be 0
        
        Loop while prime_index is less than small_primes.length():
            Let prime be small_primes.get(prime_index)
            If Operations.modulo(candidate, prime).remainder is equal to "0" and candidate does not equal prime:
                Set skip_candidate to true
                Break
            If Operations.modulo(candidate_plus_2, prime).remainder is equal to "0" and candidate_plus_2 does not equal prime:
                Set skip_candidate to true
                Break
            Set prime_index to prime_index plus 1
        
        If skip_candidate:
            Set attempts to attempts plus 1
            Continue
        
        Note: Test primality of both candidates
        Let p_test be miller_rabin_primality_test(candidate, 10)
        If p_test.get("is_prime") is equal to "true":
            Let p_plus_2_test be miller_rabin_primality_test(candidate_plus_2, 10)
            If p_plus_2_test.get("is_prime") is equal to "true":
                result.set("prime_1", candidate)
                result.set("prime_2", candidate_plus_2)
                result.set("difference", "2")
                result.set("attempts", Operations.integer_to_string(attempts plus 1))
                Return result
        
        Set attempts to attempts plus 1
    
    Throw Errors.RuntimeError with "Failed to find twin primes within attempt limit"

Process called "generate_cousin_primes" that takes bit_length as Integer returns Dictionary[String, String]:
    Note: Generate cousin prime pairs (p, p+4) of specified bit length
    Note: Finds primes with difference of 4 for specialized applications
    
    Let result be Dictionary[String, String]
    result.set("generation_method", "cousin_prime_search")
    result.set("target_bit_length", Operations.integer_to_string(bit_length))
    
    If bit_length is less than 3:
        Throw Errors.InvalidArgument with "Bit length must be at least 3 for cousin primes"
    
    Let max_attempts be 15000 multiplied by bit_length  Note: Cousin primes are rarer than twin primes
    Let attempts be 0
    
    Loop while attempts is less than max_attempts:
        Note: Generate random candidate of specified bit length
        Let candidate_big be Random.generate_random_big_integer(bit_length)
        Let candidate be BigInt.to_string(candidate_big)
        
        Note: Make sure it's odd
        If Operations.modulo(candidate, "2").remainder is equal to "0":
            Set candidate to Operations.add(candidate, "1", 0).result_value
        
        Note: Check if both p and p+4 could be prime
        Let candidate_plus_4 be Operations.add(candidate, "4", 0).result_value
        
        Note: Quick divisibility checks for small primes
        Let small_primes be ["3", "5", "7", "11", "13", "17", "19", "23"]
        Let skip_candidate be false
        Let prime_index be 0
        
        Loop while prime_index is less than small_primes.length():
            Let prime be small_primes.get(prime_index)
            If Operations.modulo(candidate, prime).remainder is equal to "0" and candidate does not equal prime:
                Set skip_candidate to true
                Break
            If Operations.modulo(candidate_plus_4, prime).remainder is equal to "0" and candidate_plus_4 does not equal prime:
                Set skip_candidate to true
                Break
            Set prime_index to prime_index plus 1
        
        If skip_candidate:
            Set attempts to attempts plus 1
            Continue
        
        Note: Test primality of both candidates
        Let p_test be miller_rabin_primality_test(candidate, 10)
        If p_test.get("is_prime") is equal to "true":
            Let p_plus_4_test be miller_rabin_primality_test(candidate_plus_4, 10)
            If p_plus_4_test.get("is_prime") is equal to "true":
                result.set("prime_1", candidate)
                result.set("prime_2", candidate_plus_4)
                result.set("difference", "4")
                result.set("attempts", Operations.integer_to_string(attempts plus 1))
                Return result
        
        Set attempts to attempts plus 1
    
    Throw Errors.RuntimeError with "Failed to find cousin primes within attempt limit"

Note: =====================================================================
Note: SAFE PRIME GENERATION
Note: =====================================================================

Process called "generate_safe_prime" that takes bit_length as Integer, generation_config as PrimeGenerationConfig returns SafePrime:
    Note: Generate safe prime p where (p-1)/2 is also prime (Sophie Germain prime)
    Note: Creates primes resistant to certain factorization and discrete log attacks
    
    If bit_length is less than 3:
        Throw Errors.InvalidArgument with "Bit length must be at least 3 for safe primes"
    
    Note: Generate Sophie Germain prime q of bit_length minus 1
    Let sophie_germain_q be generate_sophie_germain_prime(bit_length minus 1)
    
    Note: Calculate safe prime p is equal to 2q plus 1
    Let safe_prime_p be Operations.add(Operations.multiply(sophie_germain_q, "2", 0).result_value, "1", 0).result_value
    
    Note: Verify it's actually prime (should be, but double-check)
    Let verification_test be miller_rabin_primality_test(safe_prime_p, 15)
    If verification_test.get("is_prime") does not equal "true":
        Throw Errors.RuntimeError with "Generated safe prime candidate failed verification"
    
    Note: Create SafePrime result
    Let result be SafePrime{
        prime_value: safe_prime_p,
        sophie_germain_prime: sophie_germain_q,
        bit_length: bit_length,
        verification_status: true,
        generation_timestamp: Random.get_current_time_microseconds()
    }
    
    Return result

Process called "verify_safe_prime_properties" that takes prime_candidate as String returns Dictionary[String, Boolean]:
    Note: Verify that prime satisfies safe prime properties and security criteria
    Note: Checks both p and (p-1)/2 for primality and additional security properties
    
    Let result be Dictionary[String, Boolean]
    
    Note: Check if p is prime
    Let p_test be miller_rabin_primality_test(prime_candidate, 15)
    Let p_is_prime be p_test.get("is_prime") is equal to "true"
    result.set("p_is_prime", p_is_prime)
    
    If not p_is_prime:
        result.set("is_safe_prime", false)
        Return result
    
    Note: Check if p is odd (required for safe primes)
    Let p_is_odd be Operations.modulo(prime_candidate, "2").remainder is equal to "1"
    result.set("p_is_odd", p_is_odd)
    
    If not p_is_odd:
        result.set("is_safe_prime", false)
        Return result
    
    Note: Calculate q is equal to (p-1)/2
    Let p_minus_1 be Operations.subtract(prime_candidate, "1", 0).result_value
    Let q be Operations.divide(p_minus_1, "2", 0).result_value
    
    Note: Check if q is prime (Sophie Germain condition)
    Let q_test be miller_rabin_primality_test(q, 15)
    Let q_is_prime be q_test.get("is_prime") is equal to "true"
    result.set("q_is_prime", q_is_prime)
    result.set("sophie_germain_prime", q)
    
    Note: Verify p is equal to 2q plus 1
    Let two_q_plus_1 be Operations.add(Operations.multiply(q, "2", 0).result_value, "1", 0).result_value
    Let structure_correct be two_q_plus_1 is equal to prime_candidate
    result.set("structure_correct", structure_correct)
    
    Note: Overall safe prime status
    Let is_safe_prime be p_is_prime and q_is_prime and p_is_odd and structure_correct
    result.set("is_safe_prime", is_safe_prime)
    
    Return result

Process called "generate_sophie_germain_prime" that takes bit_length as Integer returns String:
    Note: Generate Sophie Germain prime q where 2q+1 is also prime
    Note: Creates foundation primes for safe prime construction
    
    If bit_length is less than 2:
        Throw Errors.InvalidArgument with "Bit length must be at least 2"
    
    Let max_attempts be 20000 multiplied by bit_length  Note: Sophie Germain primes are rare
    Let attempts be 0
    
    Loop while attempts is less than max_attempts:
        Note: Generate random candidate of specified bit length
        Let candidate_big be Random.generate_random_big_integer(bit_length)
        Let candidate be BigInt.to_string(candidate_big)
        
        Note: Make sure it's odd
        If Operations.modulo(candidate, "2").remainder is equal to "0":
            Set candidate to Operations.add(candidate, "1", 0).result_value
        
        Note: Compute 2q+1 (the safe prime)
        Let two_q_plus_1 be Operations.add(Operations.multiply(candidate, "2", 0).result_value, "1", 0).result_value
        
        Note: Quick divisibility checks for small primes
        Let small_primes be ["3", "5", "7", "11", "13", "17", "19", "23", "29", "31"]
        Let skip_candidate be false
        Let prime_index be 0
        
        Loop while prime_index is less than small_primes.length():
            Let prime be small_primes.get(prime_index)
            If Operations.modulo(candidate, prime).remainder is equal to "0" and candidate does not equal prime:
                Set skip_candidate to true
                Break
            If Operations.modulo(two_q_plus_1, prime).remainder is equal to "0" and two_q_plus_1 does not equal prime:
                Set skip_candidate to true
                Break
            Set prime_index to prime_index plus 1
        
        If skip_candidate:
            Set attempts to attempts plus 1
            Continue
        
        Note: Test if q is prime
        Let q_test be miller_rabin_primality_test(candidate, 15)
        If q_test.get("is_prime") is equal to "true":
            Note: Test if 2q+1 is prime
            Let safe_prime_test be miller_rabin_primality_test(two_q_plus_1, 15)
            If safe_prime_test.get("is_prime") is equal to "true":
                Return candidate
        
        Set attempts to attempts plus 1
    
    Throw Errors.RuntimeError with "Failed to generate Sophie Germain prime within attempt limit"

Process called "validate_safe_prime_security" that takes safe_prime as SafePrime, security_criteria as Dictionary[String, String] returns Dictionary[String, String]:
    Note: Validate safe prime against cryptographic security requirements
    Note: Evaluates resistance to known attacks and compliance with standards
    
    Let result be Dictionary[String, String]
    result.set("validation_type", "safe_prime_security")
    result.set("prime_value", safe_prime.prime_value)
    
    Note: Check basic safe prime properties
    Let properties_check be verify_safe_prime_properties(safe_prime.prime_value)
    If not properties_check.get("is_safe_prime"):
        result.set("security_status", "invalid_safe_prime")
        result.set("reason", "Does not satisfy safe prime properties")
        Return result
    
    Note: Check minimum bit length requirement
    Let min_bits be 1024  Note: Default minimum
    If security_criteria.has_key("minimum_bits"):
        Set min_bits to BigDecimal.parse_integer(security_criteria.get("minimum_bits"))
    
    If safe_prime.bit_length is less than min_bits:
        result.set("security_status", "insufficient_length")
        result.set("reason", "Prime length below minimum security requirement")
        Return result
    
    Note: Check against blacklist criteria
    Let blacklist_criteria be Dictionary[String, String]
    blacklist_criteria.set("exclude_small_primes", "true")
    blacklist_criteria.set("minimum_bits", Operations.integer_to_string(min_bits))
    blacklist_criteria.set("check_patterns", "true")
    
    If check_prime_blacklist(safe_prime.prime_value, blacklist_criteria):
        result.set("security_status", "blacklisted")
        result.set("reason", "Prime found in security blacklist")
        Return result
    
    Note: Validate randomness quality
    Let randomness_check be validate_prime_randomness(safe_prime.prime_value, "crypto_grade")
    Let randomness_score be randomness_check.get("overall_randomness")
    
    If randomness_score is less than 0.8:
        result.set("security_status", "poor_randomness")
        result.set("reason", "Prime shows poor randomness characteristics")
        result.set("randomness_score", Operations.float_to_string(randomness_score))
        Return result
    
    Note: Check Sophie Germain prime quality
    Let sg_randomness be validate_prime_randomness(safe_prime.sophie_germain_prime, "crypto_grade")
    Let sg_randomness_score be sg_randomness.get("overall_randomness")
    
    If sg_randomness_score is less than 0.8:
        result.set("security_status", "poor_sg_randomness")
        result.set("reason", "Sophie Germain prime shows poor randomness")
        Return result
    
    Note: All security checks passed
    result.set("security_status", "secure")
    result.set("bit_length", Operations.integer_to_string(safe_prime.bit_length))
    result.set("randomness_score", Operations.float_to_string(randomness_score))
    result.set("sg_randomness_score", Operations.float_to_string(sg_randomness_score))
    
    Return result

Note: =====================================================================
Note: STRONG PRIME GENERATION
Note: =====================================================================

Process called "generate_strong_prime" that takes bit_length as Integer, strength_criteria as Dictionary[String, String] returns String:
    Note: Generate strong prime satisfying Gordon's criteria for RSA security
    Note: Creates primes resistant to Pollard's p-1 and related factorization methods
    
    If bit_length is less than 512:
        Throw Errors.InvalidArgument with "Strong primes must be at least 512 bits for security"
    
    Note: Gordon's strong prime construction:
    Note: 1. Choose random prime s
    Note: 2. Choose random prime t 
    Note: 3. Choose r such that r ≡ 1 (mod t) and p is equal to 2rs plus 1 is prime
    
    Let max_attempts be 100000
    Let attempts be 0
    
    Loop while attempts is less than max_attempts:
        Note: Generate small prime s (roughly bit_length/4 bits)
        Let s_bits be bit_length / 4
        If s_bits is less than 8:
            Set s_bits to 8
        
        Let s_result be generate_probable_prime(s_bits, 0.999)
        Let s be s_result.candidate_value
        
        Note: Generate small prime t (roughly bit_length/4 bits)
        Let t_bits be bit_length / 4
        Let t_result be generate_probable_prime(t_bits, 0.999)
        Let t be t_result.candidate_value
        
        Note: Find r such that r ≡ 1 (mod t)
        Let r be "1"
        Let r_attempts be 0
        
        Loop while r_attempts is less than 1000:
            Note: Calculate potential p is equal to 2rs plus 1
            Let two_r_s be Operations.multiply(Operations.multiply("2", r, 0).result_value, s, 0).result_value
            Let p_candidate be Operations.add(two_r_s, "1", 0).result_value
            
            Note: Check if p has correct bit length
            Let p_binary be Operations.decimal_to_binary(p_candidate)
            Let p_bits be Operations.string_length(p_binary)
            
            If p_bits is greater than or equal to bit_length minus 1 and p_bits is less than or equal to bit_length plus 1:
                Note: Test if p is prime
                Let p_test be miller_rabin_primality_test(p_candidate, 15)
                If p_test.get("is_prime") is equal to "true":
                    Note: Verify strong prime properties
                    Let verification be verify_strong_prime_criteria(p_candidate)
                    If verification.get("is_strong_prime"):
                        Return p_candidate
            
            Note: Try next r ≡ 1 (mod t)
            Set r to Operations.add(r, t, 0).result_value
            Set r_attempts to r_attempts plus 1
        
        Set attempts to attempts plus 1
    
    Throw Errors.RuntimeError with "Failed to generate strong prime within attempt limit"

Process called "verify_strong_prime_criteria" that takes prime_candidate as String returns Dictionary[String, Boolean]:
    Note: Verify that prime satisfies strong prime criteria for cryptographic use
    Note: Checks p-1 has large prime factor, p+1 has large prime factor, etc.
    
    Let result be Dictionary[String, Boolean]
    
    Note: First verify p is prime
    Let p_test be miller_rabin_primality_test(prime_candidate, 15)
    Let p_is_prime be p_test.get("is_prime") is equal to "true"
    result.set("p_is_prime", p_is_prime)
    
    If not p_is_prime:
        result.set("is_strong_prime", false)
        Return result
    
    Let p_minus_1 be Operations.subtract(prime_candidate, "1", 0).result_value
    Let p_plus_1 be Operations.add(prime_candidate, "1", 0).result_value
    
    Note: Find largest prime factor of p-1
    Let largest_factor_p_minus_1 be find_largest_prime_factor(p_minus_1)
    Let p_minus_1_bits be Operations.string_length(Operations.decimal_to_binary(p_minus_1))
    Let factor_bits be Operations.string_length(Operations.decimal_to_binary(largest_factor_p_minus_1))
    
    Note: Gordon's criterion: largest prime factor of p-1 should be "large"
    Let p_minus_1_has_large_factor be factor_bits is greater than p_minus_1_bits / 2
    result.set("p_minus_1_large_factor", p_minus_1_has_large_factor)
    
    Note: Find largest prime factor of p+1
    Let largest_factor_p_plus_1 be find_largest_prime_factor(p_plus_1)
    Let p_plus_1_bits be Operations.string_length(Operations.decimal_to_binary(p_plus_1))
    Let factor_plus_1_bits be Operations.string_length(Operations.decimal_to_binary(largest_factor_p_plus_1))
    
    Let p_plus_1_has_large_factor be factor_plus_1_bits is greater than p_plus_1_bits / 2
    result.set("p_plus_1_large_factor", p_plus_1_has_large_factor)
    
    Note: Additional check: r-1 should have large prime factor where r is largest factor of p-1
    Let r_minus_1 be Operations.subtract(largest_factor_p_minus_1, "1", 0).result_value
    Let largest_factor_r_minus_1 be find_largest_prime_factor(r_minus_1)
    Let r_minus_1_bits be Operations.string_length(Operations.decimal_to_binary(r_minus_1))
    Let factor_r_minus_1_bits be Operations.string_length(Operations.decimal_to_binary(largest_factor_r_minus_1))
    
    Let r_minus_1_has_large_factor be factor_r_minus_1_bits is greater than r_minus_1_bits / 2
    result.set("r_minus_1_large_factor", r_minus_1_has_large_factor)
    
    Note: Overall strong prime determination
    Let is_strong_prime be p_is_prime and p_minus_1_has_large_factor and p_plus_1_has_large_factor and r_minus_1_has_large_factor
    result.set("is_strong_prime", is_strong_prime)
    
    Return result

Process called "compute_prime_strength_factors" that takes prime_value as String returns Dictionary[String, String]:
    Note: Compute factors relevant to prime strength (p-1, p+1 factorizations)
    Note: Analyzes prime structure for resistance to factorization attacks
    
    Let result be Dictionary[String, String]
    result.set("prime_value", prime_value)
    
    Note: Verify input is prime
    Let primality_test be miller_rabin_primality_test(prime_value, 10)
    If primality_test.get("is_prime") does not equal "true":
        result.set("error", "Input is not prime")
        Return result
    
    Let p_minus_1 be Operations.subtract(prime_value, "1", 0).result_value
    Let p_plus_1 be Operations.add(prime_value, "1", 0).result_value
    
    Note: Factor p-1 (simplified trial division)
    Let p_minus_1_factors be List[String]
    Let remaining_p_minus_1 be p_minus_1
    Let divisor be "2"
    
    Note: Find small factors of p-1
    Let small_primes be ["2", "3", "5", "7", "11", "13", "17", "19", "23", "29", "31"]
    Let prime_index be 0
    
    Loop while prime_index is less than small_primes.length():
        Set divisor to small_primes.get(prime_index)
        Loop while Operations.modulo(remaining_p_minus_1, divisor).remainder is equal to "0":
            p_minus_1_factors.append(divisor)
            Set remaining_p_minus_1 to Operations.divide(remaining_p_minus_1, divisor, 0).result_value
        Set prime_index to prime_index plus 1
    
    If BigDecimal.compare_high_precision(remaining_p_minus_1, "1") is greater than 0:
        p_minus_1_factors.append(remaining_p_minus_1)
    
    Note: Factor p+1 (simplified trial division)
    Let p_plus_1_factors be List[String]
    Let remaining_p_plus_1 be p_plus_1
    Set prime_index to 0
    
    Loop while prime_index is less than small_primes.length():
        Set divisor to small_primes.get(prime_index)
        Loop while Operations.modulo(remaining_p_plus_1, divisor).remainder is equal to "0":
            p_plus_1_factors.append(divisor)
            Set remaining_p_plus_1 to Operations.divide(remaining_p_plus_1, divisor, 0).result_value
        Set prime_index to prime_index plus 1
    
    If BigDecimal.compare_high_precision(remaining_p_plus_1, "1") is greater than 0:
        p_plus_1_factors.append(remaining_p_plus_1)
    
    Note: Analyze factor structure
    Let largest_p_minus_1_factor be "1"
    Set prime_index to 0
    Loop while prime_index is less than p_minus_1_factors.length():
        Let factor be p_minus_1_factors.get(prime_index)
        If BigDecimal.compare_high_precision(factor, largest_p_minus_1_factor) is greater than 0:
            Set largest_p_minus_1_factor to factor
        Set prime_index to prime_index plus 1
    
    Let largest_p_plus_1_factor be "1"
    Set prime_index to 0
    Loop while prime_index is less than p_plus_1_factors.length():
        Let factor be p_plus_1_factors.get(prime_index)
        If BigDecimal.compare_high_precision(factor, largest_p_plus_1_factor) is greater than 0:
            Set largest_p_plus_1_factor to factor
        Set prime_index to prime_index plus 1
    
    Note: Build result
    result.set("p_minus_1", p_minus_1)
    result.set("p_plus_1", p_plus_1)
    result.set("largest_p_minus_1_factor", largest_p_minus_1_factor)
    result.set("largest_p_plus_1_factor", largest_p_plus_1_factor)
    result.set("p_minus_1_factor_count", Operations.integer_to_string(p_minus_1_factors.length()))
    result.set("p_plus_1_factor_count", Operations.integer_to_string(p_plus_1_factors.length()))
    
    Return result

Process called "optimize_strong_prime_parameters" that takes security_requirements as Dictionary[String, Integer] returns Dictionary[String, String]:
    Note: Optimize strong prime generation parameters for security and performance
    Note: Balances cryptographic strength with generation efficiency
    
    Let result be Dictionary[String, String]
    result.set("optimization_type", "strong_prime_parameters")
    
    Note: Get security requirements or use defaults
    Let target_bit_length be security_requirements.get("target_bit_length")
    Let security_level be security_requirements.get("security_level")
    Let performance_priority be security_requirements.get("performance_priority")
    
    If target_bit_length is less than 512:
        result.set("error", "Strong primes require at least 512 bits")
        Return result
    
    Note: Optimize parameters based on bit length
    If target_bit_length is less than or equal to 1024:
        result.set("s_bit_length", "128")  Note: s prime size
        result.set("t_bit_length", "128")  Note: t prime size
        result.set("max_r_attempts", "1000")
        result.set("primality_test_rounds", "15")
    If target_bit_length is less than or equal to 2048:
        result.set("s_bit_length", "256")
        result.set("t_bit_length", "256")
        result.set("max_r_attempts", "2000")
        result.set("primality_test_rounds", "20")
    Otherwise:
        result.set("s_bit_length", "512")
        result.set("t_bit_length", "512")
        result.set("max_r_attempts", "5000")
        result.set("primality_test_rounds", "25")
    
    Note: Adjust for performance priority
    If performance_priority is greater than or equal to 80:  Note: High performance priority
        Let current_rounds be BigDecimal.parse_integer(result.get("primality_test_rounds"))
        result.set("primality_test_rounds", Operations.integer_to_string(current_rounds / 2))
        result.set("trial_division_bound", "100")
    Otherwise:
        result.set("trial_division_bound", "1000")
    
    Note: Security level adjustments
    If security_level is greater than or equal to 256:
        Let current_rounds be BigDecimal.parse_integer(result.get("primality_test_rounds"))
        result.set("primality_test_rounds", Operations.integer_to_string(current_rounds multiplied by 2))
        result.set("verification_rounds", "30")
    Otherwise:
        result.set("verification_rounds", "15")
    
    result.set("generation_method", "gordon_construction")
    result.set("target_confidence", "0.99999")
    result.set("max_generation_attempts", "100000")
    
    Return result

Note: =====================================================================
Note: CRYPTOGRAPHICALLY SECURE PRIMES
Note: =====================================================================

Process called "generate_crypto_secure_prime" that takes bit_length as Integer, application_type as String, security_level as Integer returns String:
    Note: Generate cryptographically secure prime for specific application
    Note: Creates primes meeting security standards for RSA, DSA, DH, or ECC
    
    If bit_length is less than 512:
        Throw Errors.InvalidArgument with "Cryptographic primes must be at least 512 bits"
    
    If security_level is less than 80:
        Throw Errors.InvalidArgument with "Security level must be at least 80 bits"
    
    Let confidence_level be 0.9999  Note: Very high confidence for crypto use
    Let max_attempts be 50000 multiplied by bit_length
    Let attempts be 0
    
    Loop while attempts is less than max_attempts:
        Let candidate_prime be ""
        
        If application_type is equal to "RSA":
            Note: For RSA, generate strong prime
            Let prime_result be generate_probable_prime(bit_length, confidence_level)
            Set candidate_prime to prime_result.candidate_value
        
        If application_type is equal to "DSA" or application_type is equal to "DH":
            Note: For DSA/DH, safe primes are preferred
            Let safe_prime_config be PrimeGenerationConfig{
                target_bit_length: bit_length,
                prime_type: "safe",
                security_requirements: Dictionary[String, String](),
                generation_method: "safe_prime",
                quality_criteria: Dictionary[String, String](),
                performance_constraints: Dictionary[String, Float]()
            }
            Let safe_prime_result be generate_safe_prime(bit_length, safe_prime_config)
            Set candidate_prime to safe_prime_result.prime_value
        
        Otherwise:
            Note: Default to high-quality probable prime
            Let prime_result be generate_probable_prime(bit_length, confidence_level)
            Set candidate_prime to prime_result.candidate_value
        
        Note: Additional security checks
        Let blacklist_criteria be Dictionary[String, String]
        blacklist_criteria.set("exclude_small_primes", "true")
        blacklist_criteria.set("minimum_bits", Operations.integer_to_string(bit_length))
        blacklist_criteria.set("check_patterns", "true")
        
        If not check_prime_blacklist(candidate_prime, blacklist_criteria):
            Note: Verify randomness quality
            Let randomness_check be validate_prime_randomness(candidate_prime, "high_entropy")
            If randomness_check.get("overall_randomness") is greater than 0.8:
                Return candidate_prime
        
        Set attempts to attempts plus 1
    
    Throw Errors.RuntimeError with "Failed to generate cryptographically secure prime within attempt limit"

Process called "validate_prime_randomness" that takes prime_candidate as String, generation_entropy as String returns Dictionary[String, Float]:
    Note: Validate randomness properties of generated prime for security
    Note: Analyzes entropy, bias, and predictability in prime generation process
    
    Let result be Dictionary[String, Float]
    
    Note: Basic entropy analysis minus check bit distribution
    Let binary_repr be Operations.decimal_to_binary(prime_candidate)
    Let bit_count be Operations.string_length(binary_repr)
    Let ones_count be 0
    Let i be 0
    
    Loop while i is less than bit_count:
        If Operations.char_at_string(binary_repr, i) is equal to "1":
            Set ones_count to ones_count plus 1
        Set i to i plus 1
    
    Let bit_balance be Float(ones_count) / Float(bit_count)
    result.set("bit_balance", bit_balance)  Note: Should be close to 0.5
    
    Note: Entropy estimate based on bit balance
    Let entropy_score be 1.0
    Let balance_deviation be bit_balance minus 0.5
    If balance_deviation is less than 0.0:
        Set balance_deviation to -balance_deviation
    
    If balance_deviation is greater than 0.1:  Note: More than 10% deviation is concerning
        Set entropy_score to entropy_score minus (balance_deviation minus 0.1) multiplied by 2.0
    
    If entropy_score is less than 0.0:
        Set entropy_score to 0.0
    
    result.set("entropy_estimate", entropy_score)
    
    Note: Check for obvious patterns
    Let pattern_score be 1.0
    
    Note: Check for repeating subsequences
    Let has_long_runs be false
    Let current_bit be Operations.char_at_string(binary_repr, 0)
    Let run_length be 1
    Set i to 1
    
    Loop while i is less than bit_count:
        Let bit be Operations.char_at_string(binary_repr, i)
        If bit is equal to current_bit:
            Set run_length to run_length plus 1
            If run_length is greater than 6:  Note: Runs longer than 6 bits are suspicious
                Set has_long_runs to true
                Set pattern_score to pattern_score minus 0.2
        Otherwise:
            Set current_bit to bit
            Set run_length to 1
        Set i to i plus 1
    
    result.set("pattern_score", pattern_score)
    result.set("has_long_runs", Float(has_long_runs))
    
    Note: Overall randomness score
    Let overall_score be (entropy_score plus pattern_score) / 2.0
    result.set("overall_randomness", overall_score)
    
    Return result

Process called "check_prime_blacklist" that takes prime_candidate as String, blacklist_criteria as Dictionary[String, String] returns Boolean:
    Note: Check prime against known weak or blacklisted primes
    Note: Verifies prime is not in databases of compromised or weak values
    
    Note: Check against common weak primes
    Let weak_primes be ["2", "3", "5", "7", "11", "13", "17", "19", "23"]
    If blacklist_criteria.has_key("exclude_small_primes") and blacklist_criteria.get("exclude_small_primes") is equal to "true":
        Let prime_index be 0
        Loop while prime_index is less than weak_primes.length():
            If prime_candidate is equal to weak_primes.get(prime_index):
                Return true  Note: Found in blacklist
            Set prime_index to prime_index plus 1
    
    Note: Check minimum bit length requirement
    If blacklist_criteria.has_key("minimum_bits"):
        Let min_bits be BigDecimal.parse_integer(blacklist_criteria.get("minimum_bits"))
        Let candidate_bits be Operations.string_length(Operations.decimal_to_binary(prime_candidate))
        If candidate_bits is less than min_bits:
            Return true  Note: Too small, blacklisted
    
    Note: Check for specific patterns that indicate weakness
    If blacklist_criteria.has_key("check_patterns") and blacklist_criteria.get("check_patterns") is equal to "true":
        Note: Check for primes of form 2^n ± 1 which might be weak in some contexts
        Let is_mersenne_related be false
        Let power be 2
        Loop while power is less than 1000:  Note: Check reasonable range
            Let power_str be Operations.integer_to_string(power)
            Let two_pow_n be Operations.power("2", power_str, 0).result_value
            Let two_pow_n_plus_1 be Operations.add(two_pow_n, "1", 0).result_value
            Let two_pow_n_minus_1 be Operations.subtract(two_pow_n, "1", 0).result_value
            
            If prime_candidate is equal to two_pow_n_plus_1 or prime_candidate is equal to two_pow_n_minus_1:
                Set is_mersenne_related to true
                Break
            
            Set power to power plus 1
        
        If is_mersenne_related:
            Return true  Note: Mersenne-related primes might be blacklisted
    
    Return false  Note: Not in blacklist

Process called "analyze_prime_security_properties" that takes prime_value as String, usage_context as String returns Dictionary[String, Dictionary[String, String]]:
    Note: Analyze security properties of prime for specific cryptographic usage
    Note: Evaluates resistance to attacks relevant to intended application
    
    Let analysis be Dictionary[String, Dictionary[String, String]]()
    Let basic_props be Dictionary[String, String]()
    Let security_assessment be Dictionary[String, String]()
    Let recommendations be Dictionary[String, String]()
    
    Note: Basic prime properties
    Let bit_length be BigInt.bit_length_of(prime_value)
    basic_props["bit_length"] is equal to String.from_integer(bit_length)
    basic_props["hex_representation"] is equal to BigInt.to_hex_string(prime_value)
    basic_props["is_safe_prime"] is equal to String.from_boolean(is_safe_prime(prime_value))
    basic_props["is_strong_prime"] is equal to String.from_boolean(is_strong_prime(prime_value))
    
    Note: Security assessment based on usage context
    If usage_context is "RSA":
        security_assessment["factorization_resistance"] is equal to "High"
        security_assessment["min_recommended_bits"] is equal to "2048"
        security_assessment["quantum_resistance"] is equal to "None"
        If bit_length is less than 2048:
            security_assessment["security_level"] is equal to "Insufficient"
            recommendations["upgrade"] is equal to "Use at least 2048-bit primes"
        Otherwise if bit_length is greater than or equal to 2048 and bit_length is less than 3072:
            security_assessment["security_level"] is equal to "Acceptable"
        Otherwise:
            security_assessment["security_level"] is equal to "Strong"
            
    Otherwise if usage_context is "DSA":
        security_assessment["discrete_log_resistance"] is equal to "High"
        security_assessment["min_recommended_bits"] is equal to "2048"
        security_assessment["quantum_resistance"] is equal to "None"
        If bit_length is less than 2048:
            security_assessment["security_level"] is equal to "Insufficient"
            recommendations["upgrade"] is equal to "Use at least 2048-bit primes"
        Otherwise:
            security_assessment["security_level"] is equal to "Strong"
            
    Otherwise if usage_context is "DH":
        security_assessment["discrete_log_resistance"] is equal to "High"
        security_assessment["safe_prime_required"] is equal to String.from_boolean(is_safe_prime(prime_value))
        If not is_safe_prime(prime_value):
            security_assessment["security_level"] is equal to "Reduced"
            recommendations["upgrade"] is equal to "Use safe prime for DH"
        Otherwise:
            security_assessment["security_level"] is equal to "Strong"
            
    Otherwise:
        security_assessment["general_assessment"] is equal to "Unknown usage context"
        security_assessment["security_level"] is equal to "Indeterminate"
    
    Note: Common security checks
    Let p_minus_1_factors be find_small_factors(Modular.subtract(prime_value, "1"))
    If Dictionary.size(p_minus_1_factors) is greater than 3:
        security_assessment["smooth_p_minus_1"] is equal to "Warning"
        recommendations["check_factors"] is equal to "Prime-1 has many small factors"
    Otherwise:
        security_assessment["smooth_p_minus_1"] is equal to "Good"
    
    Note: Quantum resistance assessment
    security_assessment["post_quantum_secure"] is equal to "False"
    recommendations["quantum_preparation"] is equal to "Consider post-quantum alternatives"
    
    analysis["basic_properties"] is equal to basic_props
    analysis["security_assessment"] is equal to security_assessment  
    analysis["recommendations"] is equal to recommendations
    
    Return analysis

Note: =====================================================================
Note: PRIME GENERATION OPTIMIZATION
Note: =====================================================================

Process called "optimize_prime_search_strategy" that takes target_parameters as Dictionary[String, String] returns Dictionary[String, String]:
    Note: Optimize prime search strategy for specified requirements
    Note: Selects optimal algorithms, parameters, and search methods
    
    Let strategy be Dictionary[String, String]
    
    Note: Get target parameters or use defaults
    Let bit_length be 1024
    If target_parameters.has_key("bit_length"):
        Set bit_length to BigDecimal.parse_integer(target_parameters.get("bit_length"))
    
    Let security_level be 128
    If target_parameters.has_key("security_level"):
        Set security_level to BigDecimal.parse_integer(target_parameters.get("security_level"))
    
    Let performance_priority be "balanced"
    If target_parameters.has_key("performance_priority"):
        Set performance_priority to target_parameters.get("performance_priority")
    
    Note: Select optimal primality test based on requirements
    If bit_length is less than 1024:
        If performance_priority is equal to "speed":
            strategy.set("primality_test", "fermat")
            strategy.set("test_rounds", "3")
        Otherwise:
            strategy.set("primality_test", "miller_rabin")
            strategy.set("test_rounds", "10")
    Otherwise:
        If performance_priority is equal to "security":
            strategy.set("primality_test", "baillie_psw")
            strategy.set("test_rounds", "1")
        Otherwise:
            strategy.set("primality_test", "miller_rabin")
            strategy.set("test_rounds", "15")
    
    Note: Select generation method
    If target_parameters.has_key("application"):
        Let application be target_parameters.get("application")
        If application is equal to "RSA":
            strategy.set("generation_method", "strong_prime")
        If application is equal to "DSA" or application is equal to "DH":
            strategy.set("generation_method", "safe_prime")
        Otherwise:
            strategy.set("generation_method", "probable_prime")
    Otherwise:
        strategy.set("generation_method", "probable_prime")
    
    Note: Set search parameters
    If performance_priority is equal to "speed":
        strategy.set("max_attempts", Operations.integer_to_string(1000 multiplied by bit_length))
        strategy.set("trial_division_bound", "100")
    Otherwise:
        strategy.set("max_attempts", Operations.integer_to_string(10000 multiplied by bit_length))
        strategy.set("trial_division_bound", "1000")
    
    Note: Set confidence level based on security requirements
    If security_level is greater than or equal to 256:
        strategy.set("confidence_level", "0.99999")
    If security_level is greater than or equal to 128:
        strategy.set("confidence_level", "0.9999")
    Otherwise:
        strategy.set("confidence_level", "0.999")
    
    strategy.set("optimization_version", "1.0")
    strategy.set("target_bit_length", Operations.integer_to_string(bit_length))
    
    Return strategy

Process called "precompute_prime_generation_data" that takes bit_length_range as Dictionary[String, Integer] returns Dictionary[String, List[String]]:
    Note: Precompute data structures for efficient prime generation
    Note: Creates lookup tables, sieve data, and optimization structures
    
    Let precomputed_data be Dictionary[String, List[String]]
    
    Note: Get range parameters
    Let min_bits be bit_length_range.get("min_bits")
    Let max_bits be bit_length_range.get("max_bits")
    
    If min_bits is less than or equal to 0 or max_bits is less than or equal to min_bits:
        Throw Errors.InvalidArgument with "Invalid bit length range"
    
    Note: Precompute small primes for trial division
    Let small_prime_limit be 10000
    Let small_primes be sieve_of_eratosthenes(small_prime_limit)
    Let small_primes_str be List[String]
    
    Let prime_index be 0
    Loop while prime_index is less than small_primes.length():
        small_primes_str.append(Operations.integer_to_string(small_primes.get(prime_index)))
        Set prime_index to prime_index plus 1
    
    precomputed_data.set("small_primes", small_primes_str)
    
    Note: Precompute wheel factorization data for common wheels
    Let wheel_2_3 be ["1", "5"]
    precomputed_data.set("wheel_2_3", wheel_2_3)
    
    Let wheel_2_3_5 be ["1", "7", "11", "13", "17", "19", "23", "29"]
    precomputed_data.set("wheel_2_3_5", wheel_2_3_5)
    
    Note: Precompute optimal parameters for different bit lengths
    Let optimal_params be List[String]
    Let current_bits be min_bits
    
    Loop while current_bits is less than or equal to max_bits:
        Let param_string be ""
        Set param_string to Operations.string_concat(param_string, Operations.integer_to_string(current_bits))
        Set param_string to Operations.string_concat(param_string, ":")
        
        Note: Determine optimal witness count for Miller-Rabin
        Let witnesses be 10
        If current_bits is greater than or equal to 2048:
            Set witnesses to 20
        If current_bits is greater than or equal to 4096:
            Set witnesses to 30
        
        Set param_string to Operations.string_concat(param_string, Operations.integer_to_string(witnesses))
        optimal_params.append(param_string)
        
        Set current_bits to current_bits multiplied by 2  Note: Exponential stepping
    
    precomputed_data.set("optimal_parameters", optimal_params)
    
    Note: Precompute trial division bounds
    Let trial_bounds be List[String]
    Set current_bits to min_bits
    
    Loop while current_bits is less than or equal to max_bits:
        Let bound be current_bits multiplied by 100  Note: Heuristic bound
        If bound is greater than 100000:
            Set bound to 100000
        
        trial_bounds.append(Operations.integer_to_string(bound))
        Set current_bits to current_bits multiplied by 2
    
    precomputed_data.set("trial_division_bounds", trial_bounds)
    
    precomputed_data.set("precomputation_timestamp", [Operations.integer_to_string(Random.get_current_time_microseconds())])
    
    Return precomputed_data

Process called "parallel_prime_search" that takes search_parameters as Dictionary[String, String], worker_count as Integer returns String:
    Note: Perform parallel prime search using multiple computation threads
    Note: Distributes prime candidate testing across available processors
    Note: Simplified sequential implementation (true parallelism would require threading support)
    
    If worker_count is less than or equal to 0:
        Set worker_count to 1
    
    Note: Get search parameters
    Let bit_length be 1024
    If search_parameters.has_key("bit_length"):
        Set bit_length to BigDecimal.parse_integer(search_parameters.get("bit_length"))
    
    Let max_attempts be 100000
    If search_parameters.has_key("max_attempts"):
        Set max_attempts to BigDecimal.parse_integer(search_parameters.get("max_attempts"))
    
    Note: Divide work among "workers" (simulated)
    Let attempts_per_worker be max_attempts / worker_count
    Let worker_id be 0
    
    Loop while worker_id is less than worker_count:
        Note: Each worker tries a different range of candidates
        Let worker_attempts be 0
        Let worker_offset be worker_id multiplied by 1000  Note: Offset to avoid overlap
        
        Loop while worker_attempts is less than attempts_per_worker:
            Note: Generate candidate with worker-specific offset
            Let base_candidate_big be Random.generate_random_big_integer(bit_length)
            Let base_candidate be BigInt.to_string(base_candidate_big)
            Let candidate be Operations.add(base_candidate, Operations.integer_to_string(worker_offset), 0).result_value
            
            Note: Make odd
            If Operations.modulo(candidate, "2").remainder is equal to "0":
                Set candidate to Operations.add(candidate, "1", 0).result_value
            
            Note: Quick trial division
            Let small_factors be ["3", "5", "7", "11", "13"]
            Let has_small_factor be false
            Let factor_index be 0
            
            Loop while factor_index is less than small_factors.length():
                If Operations.modulo(candidate, small_factors.get(factor_index)).remainder is equal to "0":
                    If candidate does not equal small_factors.get(factor_index):
                        Set has_small_factor to true
                        Break
                Set factor_index to factor_index plus 1
            
            If not has_small_factor:
                Note: Perform primality test
                Let test_result be miller_rabin_primality_test(candidate, 10)
                If test_result.get("is_prime") is equal to "true":
                    Return candidate  Note: Found prime!
            
            Set worker_attempts to worker_attempts plus 1
        
        Set worker_id to worker_id plus 1
    
    Throw Errors.RuntimeError with "Parallel prime search failed to find prime within attempt limit"

Process called "adaptive_primality_testing" that takes candidate as String, confidence_requirements as Dictionary[String, Float] returns Dictionary[String, String]:
    Note: Perform adaptive primality testing based on candidate properties
    Note: Selects optimal test combination based on number size and requirements
    
    Let result be Dictionary[String, String]
    result.set("test_type", "adaptive")
    result.set("candidate", candidate)
    
    Note: Determine candidate properties
    Let binary_repr be Operations.decimal_to_binary(candidate)
    Let bit_length be Operations.string_length(binary_repr)
    
    Note: Get confidence requirements
    Let required_confidence be 0.999
    If confidence_requirements.has_key("minimum_confidence"):
        Set required_confidence to confidence_requirements.get("minimum_confidence")
    
    Note: Stage 1: Quick trial division for small factors
    Let trial_bound be 1000
    If bit_length is greater than 1024:
        Set trial_bound to 10000
    
    Let trial_result be trial_division_primality(candidate, Operations.integer_to_string(trial_bound))
    If trial_result.get("is_prime") is equal to "false":
        result.set("is_prime", "false")
        result.set("confidence", "1.0")
        result.set("method_used", "trial_division")
        result.set("divisor_found", trial_result.get("divisor"))
        Return result
    
    Note: Stage 2: Select primary test based on number size
    Let primary_test_passed be false
    Let primary_confidence be 0.0
    
    If bit_length is less than 512:
        Note: Use Fermat test for smaller numbers
        Let fermat_bases be ["2", "3", "5", "7"]
        Let fermat_result be fermat_primality_test(candidate, fermat_bases)
        Set primary_test_passed to fermat_result.get("is_prime")
        Set primary_confidence to 0.99
        result.set("primary_method", "fermat")
    If bit_length is greater than or equal to 512 and bit_length is less than 2048:
        Note: Use Miller-Rabin for medium numbers
        Let mr_rounds be 15
        Let mr_result be miller_rabin_primality_test(candidate, mr_rounds)
        Set primary_test_passed to mr_result.get("is_prime") is equal to "true"
        Set primary_confidence to BigDecimal.parse_float(mr_result.get("confidence"))
        result.set("primary_method", "miller_rabin")
    Otherwise:
        Note: Use Baillie-PSW for large numbers
        Set primary_test_passed to baillie_psw_primality_test(candidate)
        Set primary_confidence to 0.9999  Note: Very high confidence for Baillie-PSW
        result.set("primary_method", "baillie_psw")
    
    If not primary_test_passed:
        result.set("is_prime", "false")
        result.set("confidence", "1.0")
        Return result
    
    Note: Stage 3: Additional testing if confidence is insufficient
    Let total_confidence be primary_confidence
    
    If total_confidence is less than required_confidence:
        Note: Add Solovay-Strassen test for additional confidence
        Let ss_rounds be 5
        Let ss_result be solovay_strassen_primality_test(candidate, ss_rounds)
        If ss_result.get("is_prime") is equal to "true":
            Let ss_confidence be BigDecimal.parse_float(ss_result.get("confidence"))
            Set total_confidence to total_confidence plus (ss_confidence multiplied by 0.5)  Note: Combined confidence
            If total_confidence is greater than 1.0:
                Set total_confidence to 0.99999
            result.set("secondary_method", "solovay_strassen")
        Otherwise:
            result.set("is_prime", "false")
            result.set("confidence", "1.0")
            Return result
    
    result.set("is_prime", "true")
    result.set("confidence", Operations.float_to_string(total_confidence))
    result.set("bit_length", Operations.integer_to_string(bit_length))
    
    Return result

Note: =====================================================================
Note: PRIME SIEVING ALGORITHMS
Note: =====================================================================

Process called "sieve_of_eratosthenes" that takes upper_bound as Integer returns List[Integer]:
    Note: Generate primes up to upper bound using Sieve of Eratosthenes
    Note: Classical sieving algorithm for finding all primes in range
    
    If upper_bound is less than 2:
        Return List[Integer]()
    
    Note: Initialize sieve array minus true means potentially prime
    Let sieve be Array[Boolean](upper_bound plus 1)
    Let i be 0
    Loop while i is less than or equal to upper_bound:
        sieve.set(i, true)
        Set i to i plus 1
    
    Note: 0 and 1 are not prime
    sieve.set(0, false)
    sieve.set(1, false)
    
    Note: Sieve process
    Set i to 2
    Loop while i multiplied by i is less than or equal to upper_bound:
        If sieve.get(i):
            Note: Mark multiples of i as composite
            Let multiple be i multiplied by i
            Loop while multiple is less than or equal to upper_bound:
                sieve.set(multiple, false)
                Set multiple to multiple plus i
        Set i to i plus 1
    
    Note: Collect all primes
    Let primes be List[Integer]()
    Set i to 2
    Loop while i is less than or equal to upper_bound:
        If sieve.get(i):
            primes.append(i)
        Set i to i plus 1
    
    Return primes

Process called "segmented_sieve" that takes range_start as Integer, range_end as Integer returns List[Integer]:
    Note: Generate primes in specified range using segmented sieving
    Note: Memory-efficient sieving for large ranges using smaller segments
    
    If range_start is greater than range_end:
        Return List[Integer]()
    
    If range_start is less than 2:
        Set range_start to 2
    
    Let result be List[Integer]()
    
    Note: Handle small range with simple sieve
    If range_end minus range_start is less than 10000:
        Let simple_primes be sieve_of_eratosthenes(range_end)
        Let prime_index be 0
        Loop while prime_index is less than simple_primes.length():
            Let prime be simple_primes.get(prime_index)
            If prime is greater than or equal to range_start:
                result.append(prime)
            Set prime_index to prime_index plus 1
        Return result
    
    Note: Find all primes up to sqrt(range_end) for sieving
    Let sqrt_end be Operations.integer_square_root(Operations.integer_to_string(range_end))
    Let sqrt_end_int be BigDecimal.parse_integer(sqrt_end)
    Let base_primes be sieve_of_eratosthenes(sqrt_end_int)
    
    Note: Process range in segments
    Let segment_size be 32768  Note: 32KB segments for cache efficiency
    Let current_start be range_start
    
    Loop while current_start is less than or equal to range_end:
        Let current_end be current_start plus segment_size minus 1
        If current_end is greater than range_end:
            Set current_end to range_end
        
        Note: Create segment sieve (true is equal to potentially prime)
        Let segment_length be current_end minus current_start plus 1
        Let segment be Array[Boolean](segment_length)
        Let i be 0
        Loop while i is less than segment_length:
            segment.set(i, true)
            Set i to i plus 1
        
        Note: Sieve using base primes
        Let prime_index be 0
        Loop while prime_index is less than base_primes.length():
            Let prime be base_primes.get(prime_index)
            
            Note: Find first multiple of prime in current segment
            Let first_multiple be ((current_start plus prime minus 1) / prime) multiplied by prime
            If first_multiple is less than current_start:
                Set first_multiple to first_multiple plus prime
            
            Note: Mark multiples as composite
            Let multiple be first_multiple
            Loop while multiple is less than or equal to current_end:
                Let index be multiple minus current_start
                segment.set(index, false)
                Set multiple to multiple plus prime
            
            Set prime_index to prime_index plus 1
        
        Note: Collect primes from segment
        Set i to 0
        Loop while i is less than segment_length:
            If segment.get(i):
                Let candidate be current_start plus i
                If candidate is greater than or equal to 2:  Note: Ensure it's actually prime
                    result.append(candidate)
            Set i to i plus 1
        
        Set current_start to current_end plus 1
    
    Return result

Process called "wheel_factorization_sieve" that takes upper_bound as Integer, wheel_primes as List[Integer] returns List[Integer]:
    Note: Generate primes using wheel factorization for improved efficiency
    Note: Uses wheel structure to skip multiples of small primes
    
    If upper_bound is less than 2:
        Return List[Integer]()
    
    Let result be List[Integer]()
    
    Note: Add wheel primes to result if they're within bound
    Let wheel_index be 0
    Loop while wheel_index is less than wheel_primes.length():
        Let wheel_prime be wheel_primes.get(wheel_index)
        If wheel_prime is less than or equal to upper_bound:
            result.append(wheel_prime)
        Set wheel_index to wheel_index plus 1
    
    Note: Calculate wheel circumference
    Let wheel_circumference be 1
    Set wheel_index to 0
    Loop while wheel_index is less than wheel_primes.length():
        Let wheel_prime be wheel_primes.get(wheel_index)
        Set wheel_circumference to wheel_circumference multiplied by wheel_prime
        Set wheel_index to wheel_index plus 1
    
    Note: Generate wheel pattern (coprime residues)
    Let wheel_pattern be List[Integer]()
    Let candidate be 1
    Loop while candidate is less than wheel_circumference:
        Let is_coprime be true
        Set wheel_index to 0
        Loop while wheel_index is less than wheel_primes.length():
            Let wheel_prime be wheel_primes.get(wheel_index)
            If candidate % wheel_prime is 0:
                Set is_coprime to false
                Break
            Set wheel_index to wheel_index plus 1
        
        If is_coprime:
            wheel_pattern.append(candidate)
        
        Set candidate to candidate plus 1
    
    Note: Create sieve array for candidates beyond wheel circumference
    Let max_candidate be wheel_circumference
    Loop while max_candidate is less than or equal to upper_bound:
        Set max_candidate to max_candidate plus wheel_circumference
    
    Let sieve be Dictionary[Integer, Boolean]()
    
    Note: Mark wheel pattern candidates as potentially prime
    Let wheel_multiple be wheel_circumference
    Loop while wheel_multiple is less than or equal to upper_bound:
        Let pattern_index be 0
        Loop while pattern_index is less than wheel_pattern.length():
            Let candidate_offset be wheel_pattern.get(pattern_index)
            Let candidate_value be wheel_multiple plus candidate_offset
            If candidate_value is less than or equal to upper_bound and candidate_value is greater than wheel_circumference:
                sieve[candidate_value] is equal to true
            Set pattern_index to pattern_index plus 1
        Set wheel_multiple to wheel_multiple plus wheel_circumference
    
    Note: Sieve out composites using primes beyond wheel
    Let next_prime be wheel_circumference plus 1
    Loop while next_prime multiplied by next_prime is less than or equal to upper_bound:
        Note: Find next prime candidate
        If sieve.contains_key(next_prime) and sieve[next_prime]:
            Note: Sieve out multiples of this prime
            Let multiple be next_prime multiplied by next_prime
            Loop while multiple is less than or equal to upper_bound:
                If sieve.contains_key(multiple):
                    sieve[multiple] is equal to false
                Set multiple to multiple plus next_prime
        Set next_prime to next_prime plus 1
    
    Note: Collect remaining candidates as primes
    Let candidate_key be wheel_circumference plus 1
    Loop while candidate_key is less than or equal to upper_bound:
        If sieve.contains_key(candidate_key) and sieve[candidate_key]:
            result.append(candidate_key)
        Set candidate_key to candidate_key plus 1
    
    Return result

Process called "atkin_sieve" that takes upper_bound as Integer returns List[Integer]:
    Note: Generate primes using Sieve of Atkin for improved asymptotic complexity
    Note: Alternative sieving algorithm with better theoretical performance
    Note: Simplified implementation of core Atkin sieve algorithm
    
    If upper_bound is less than 2:
        Return List[Integer]()
    
    If upper_bound is less than 1000:
        Note: For small bounds, use simpler sieve
        Return sieve_of_eratosthenes(upper_bound)
    
    Note: Initialize sieve array
    Let sieve be Array[Boolean](upper_bound plus 1)
    Let i be 0
    Loop while i is less than or equal to upper_bound:
        sieve.set(i, false)
        Set i to i plus 1
    
    Note: Atkin sieve main algorithm (simplified version)
    Note: Step 1: Mark numbers of form 4x^2 plus y^2
    Let x be 1
    Loop while x multiplied by x is less than upper_bound:
        Let y be 1
        Loop while 4 multiplied by x multiplied by x plus y multiplied by y is less than or equal to upper_bound:
            Let n be 4 multiplied by x multiplied by x plus y multiplied by y
            If n is less than or equal to upper_bound:
                Note: Toggle for odd number of representations
                sieve.set(n, not sieve.get(n))
            Set y to y plus 1
        Set x to x plus 1
    
    Note: Step 2: Mark numbers of form 3x^2 plus y^2
    Set x to 1
    Loop while x multiplied by x is less than upper_bound:
        Let y be 1
        Loop while 3 multiplied by x multiplied by x plus y multiplied by y is less than or equal to upper_bound:
            Let n be 3 multiplied by x multiplied by x plus y multiplied by y
            If n is less than or equal to upper_bound and n % 12 is equal to 7:
                sieve.set(n, not sieve.get(n))
            Set y to y plus 1
        Set x to x plus 1
    
    Note: Step 3: Mark numbers of form 3x^2 minus y^2 (where x is greater than y)
    Set x to 2
    Loop while x multiplied by x is less than upper_bound:
        Let y be 1
        Loop while y is less than x and 3 multiplied by x multiplied by x minus y multiplied by y is less than or equal to upper_bound:
            Let n be 3 multiplied by x multiplied by x minus y multiplied by y
            If n is less than or equal to upper_bound and n % 12 is equal to 11:
                sieve.set(n, not sieve.get(n))
            Set y to y plus 1
        Set x to x plus 1
    
    Note: Step 4: Eliminate squares of primes
    Set x to 5
    Loop while x multiplied by x is less than upper_bound:
        If sieve.get(x):
            Let multiple be x multiplied by x
            Loop while multiple is less than or equal to upper_bound:
                sieve.set(multiple, false)
                Set multiple to multiple plus x multiplied by x
        Set x to x plus 1
    
    Note: Collect results
    Let primes be List[Integer]()
    If upper_bound is greater than or equal to 2:
        primes.append(2)
    If upper_bound is greater than or equal to 3:
        primes.append(3)
    
    Set i to 5
    Loop while i is less than or equal to upper_bound:
        If sieve.get(i):
            primes.append(i)
        Set i to i plus 1
    
    Return primes

Note: =====================================================================
Note: PRIME FACTORIZATION RESISTANCE
Note: =====================================================================

Process called "analyze_factorization_resistance" that takes prime_product as String, analysis_methods as List[String] returns Dictionary[String, Float]:
    Note: Analyze resistance of prime product to factorization attacks
    Note: Evaluates security against trial division, Pollard's methods, QS, GNFS
    
    Let result be Dictionary[String, Float]
    
    Note: Basic analysis of the prime product
    Let binary_repr be Operations.decimal_to_binary(prime_product)
    Let bit_length be Operations.string_length(binary_repr)
    result.set("bit_length", Float(bit_length))
    
    Note: Analyze each specified method
    Let method_index be 0
    Loop while method_index is less than analysis_methods.length():
        Let method be analysis_methods.get(method_index)
        
        If method is equal to "trial_division":
            Note: Trial division resistance based on smallest factor size
            Let trial_resistance be 1.0
            If bit_length is greater than or equal to 1024:
                Set trial_resistance to 1.0  Note: Very strong
            If bit_length is greater than or equal to 512:
                Set trial_resistance to 0.95
            Otherwise:
                Set trial_resistance to 0.8
            result.set("trial_division_resistance", trial_resistance)
        
        If method is equal to "pollard_rho":
            Note: Pollard's rho resistance minus depends on factor balance
            Let pollard_resistance be 0.9
            If bit_length is greater than or equal to 2048:
                Set pollard_resistance to 0.98
            If bit_length is greater than or equal to 4096:
                Set pollard_resistance to 0.99
            result.set("pollard_rho_resistance", pollard_resistance)
        
        If method is equal to "quadratic_sieve":
            Note: QS resistance minus exponential in bit length
            Let qs_resistance be 0.5
            If bit_length is greater than or equal to 1024:
                Set qs_resistance to 0.85
            If bit_length is greater than or equal to 2048:
                Set qs_resistance to 0.95
            If bit_length is greater than or equal to 4096:
                Set qs_resistance to 0.99
            result.set("quadratic_sieve_resistance", qs_resistance)
        
        If method is equal to "gnfs":
            Note: GNFS resistance minus best known classical algorithm
            Let gnfs_resistance be 0.3
            If bit_length is greater than or equal to 1024:
                Set gnfs_resistance to 0.7
            If bit_length is greater than or equal to 2048:
                Set gnfs_resistance to 0.9
            If bit_length is greater than or equal to 4096:
                Set gnfs_resistance to 0.95
            result.set("gnfs_resistance", gnfs_resistance)
        
        Set method_index to method_index plus 1
    
    Note: Overall resistance score (average of analyzed methods)
    Let total_score be 0.0
    Let method_count be 0
    
    If result.has_key("trial_division_resistance"):
        Set total_score to total_score plus result.get("trial_division_resistance")
        Set method_count to method_count plus 1
    If result.has_key("pollard_rho_resistance"):
        Set total_score to total_score plus result.get("pollard_rho_resistance")
        Set method_count to method_count plus 1
    If result.has_key("quadratic_sieve_resistance"):
        Set total_score to total_score plus result.get("quadratic_sieve_resistance")
        Set method_count to method_count plus 1
    If result.has_key("gnfs_resistance"):
        Set total_score to total_score plus result.get("gnfs_resistance")
        Set method_count to method_count plus 1
    
    If method_count is greater than 0:
        result.set("overall_resistance", total_score / Float(method_count))
    Otherwise:
        result.set("overall_resistance", 0.0)
    
    Return result

Process called "estimate_factorization_difficulty" that takes composite_number as String returns Dictionary[String, Float]:
    Note: Estimate computational difficulty of factoring composite number
    Note: Provides security estimates for RSA moduli and similar applications
    
    Let result be Dictionary[String, Float]
    
    Let binary_repr be Operations.decimal_to_binary(composite_number)
    Let bit_length be Operations.string_length(binary_repr)
    result.set("bit_length", Float(bit_length))
    
    Note: Estimate difficulty in terms of operations (log scale)
    Note: Based on known complexity of factorization algorithms
    
    Note: Trial division difficulty (exponential in worst case)
    Let trial_ops be Float(bit_length) multiplied by 1000000.0  Note: Simplified estimate
    result.set("trial_division_ops", trial_ops)
    
    Note: Pollard's rho difficulty (approximately sqrt of smallest factor)
    Let pollard_ops be 2.0 ^ (Float(bit_length) / 4.0)  Note: Fourth root complexity
    result.set("pollard_rho_ops", pollard_ops)
    
    Note: Quadratic sieve complexity: exp(sqrt(log n multiplied by log log n))
    Let log_n be Float(bit_length) multiplied by 0.693  Note: Approximate log base e
    Let log_log_n be 3.0  Note: Simplified approximation
    Let qs_exponent be (log_n multiplied by log_log_n) ^ 0.5
    Let qs_ops be 2.718282 ^ qs_exponent  Note: e^x
    result.set("quadratic_sieve_ops", qs_ops)
    
    Note: GNFS complexity (best known): exp((64/9)^(1/3) multiplied by (log n)^(1/3) multiplied by (log log n)^(2/3))
    Let gnfs_base be (64.0 / 9.0) ^ (1.0 / 3.0)
    Let gnfs_term1 be log_n ^ (1.0 / 3.0)
    Let gnfs_term2 be log_log_n ^ (2.0 / 3.0)
    Let gnfs_exponent be gnfs_base multiplied by gnfs_term1 multiplied by gnfs_term2
    Let gnfs_ops be 2.718282 ^ gnfs_exponent
    result.set("gnfs_ops", gnfs_ops)
    
    Note: Security level estimation (bits of security)
    Let security_bits be Float(bit_length) / 2.0  Note: Square root complexity
    If bit_length is greater than or equal to 2048:
        Set security_bits to 112.0  Note: NIST estimate for 2048-bit RSA
    If bit_length is greater than or equal to 3072:
        Set security_bits to 128.0  Note: NIST estimate for 3072-bit RSA
    If bit_length is greater than or equal to 15360:
        Set security_bits to 256.0  Note: NIST estimate for 15360-bit RSA
    
    result.set("estimated_security_bits", security_bits)
    
    Note: Time estimates (very rough, assuming 1 GHz processor)
    Let seconds_per_op be 0.000000001  Note: 1 nanosecond per operation
    result.set("trial_division_seconds", trial_ops multiplied by seconds_per_op)
    result.set("pollard_rho_seconds", pollard_ops multiplied by seconds_per_op)
    result.set("quadratic_sieve_seconds", qs_ops multiplied by seconds_per_op)
    result.set("gnfs_seconds", gnfs_ops multiplied by seconds_per_op)
    
    Return result

Process called "validate_rsa_prime_properties" that takes prime_p as String, prime_q as String returns Dictionary[String, Boolean]:
    Note: Validate prime properties for secure RSA key generation
    Note: Checks prime size balance, GCD requirements, and security criteria
    
    Let result be Dictionary[String, Boolean]
    
    Note: Check both primes are actually prime
    Let p_test be miller_rabin_primality_test(prime_p, 15)
    Let q_test be miller_rabin_primality_test(prime_q, 15)
    
    Let p_is_prime be p_test.get("is_prime") is equal to "true"
    Let q_is_prime be q_test.get("is_prime") is equal to "true"
    
    result.set("p_is_prime", p_is_prime)
    result.set("q_is_prime", q_is_prime)
    
    If not p_is_prime or not q_is_prime:
        result.set("valid_for_rsa", false)
        Return result
    
    Note: Check primes are different
    Let primes_different be prime_p does not equal prime_q
    result.set("primes_different", primes_different)
    
    Note: Check size balance minus primes should be similar bit length
    Let p_binary be Operations.decimal_to_binary(prime_p)
    Let q_binary be Operations.decimal_to_binary(prime_q)
    Let p_bits be Operations.string_length(p_binary)
    Let q_bits be Operations.string_length(q_binary)
    
    Let bit_difference be p_bits minus q_bits
    If bit_difference is less than 0:
        Set bit_difference to -bit_difference
    
    Let size_balanced be bit_difference is less than or equal to 2  Note: Allow small difference
    result.set("size_balanced", size_balanced)
    
    Note: Check minimum distance |p minus q| is greater than 2^(bitlen/2 minus 100)
    Let min_distance_bits be (p_bits / 2) minus 100
    If min_distance_bits is less than 0:
        Set min_distance_bits to 0
    
    Let min_distance be Operations.power("2", Operations.integer_to_string(min_distance_bits), 0).result_value
    Let p_minus_q be Operations.subtract(prime_p, prime_q, 0).result_value
    If BigDecimal.compare_high_precision(p_minus_q, "0") is less than 0:
        Set p_minus_q to Operations.subtract(prime_q, prime_p, 0).result_value
    
    Let sufficient_distance be BigDecimal.compare_high_precision(p_minus_q, min_distance) is greater than or equal to 0
    result.set("sufficient_distance", sufficient_distance)
    
    Note: Check GCD(p-1, q-1) is small
    Let p_minus_1 be Operations.subtract(prime_p, "1", 0).result_value
    Let q_minus_1 be Operations.subtract(prime_q, "1", 0).result_value
    Let gcd_p_q_minus_1 be Operations.greatest_common_divisor(p_minus_1, q_minus_1)
    
    Let gcd_small be BigDecimal.compare_high_precision(gcd_p_q_minus_1, "65536") is less than or equal to 0  Note: 2^16
    result.set("gcd_small", gcd_small)
    
    Note: Overall validation
    Let valid_for_rsa be p_is_prime and q_is_prime and primes_different and size_balanced and sufficient_distance and gcd_small
    result.set("valid_for_rsa", valid_for_rsa)
    
    Return result

Process called "check_prime_proximity_security" that takes prime_list as List[String] returns Dictionary[String, String]:
    Note: Check security implications of prime proximity and relationships
    Note: Analyzes whether primes are too close or share problematic properties
    
    Let result be Dictionary[String, String]
    result.set("analysis_type", "prime_proximity_security")
    result.set("prime_count", Operations.integer_to_string(prime_list.length()))
    
    If prime_list.length() is less than 2:
        result.set("security_status", "insufficient_primes")
        Return result
    
    Let security_issues be List[String]
    
    Note: Check pairwise distances
    Let i be 0
    Loop while i is less than prime_list.length():
        Let j be i plus 1
        Loop while j is less than prime_list.length():
            Let prime_i be prime_list.get(i)
            Let prime_j be prime_list.get(j)
            
            Note: Calculate absolute difference
            Let difference be Operations.subtract(prime_i, prime_j, 0).result_value
            If BigDecimal.compare_high_precision(difference, "0") is less than 0:
                Set difference to Operations.subtract(prime_j, prime_i, 0).result_value
            
            Note: Check if primes are too close
            Let min_distance be Operations.integer_square_root(Operations.multiply(prime_i, prime_j, 0).result_value)
            If BigDecimal.compare_high_precision(difference, min_distance) is less than 0:
                security_issues.append("Primes too close: distance is less than sqrt(p*q)")
            
            Note: Check for twin prime relationship
            If difference is equal to "2":
                security_issues.append("Twin prime relationship detected")
            
            Note: Check for cousin prime relationship
            If difference is equal to "4":
                security_issues.append("Cousin prime relationship detected")
            
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Check for patterns in prime generation
    If prime_list.length() is greater than or equal to 3:
        Note: Check for arithmetic progression
        Let first_diff be Operations.subtract(prime_list.get(1), prime_list.get(0), 0).result_value
        Let all_same_diff be true
        Set i to 2
        Loop while i is less than prime_list.length():
            Let current_diff be Operations.subtract(prime_list.get(i), prime_list.get(i-1), 0).result_value
            If current_diff does not equal first_diff:
                Set all_same_diff to false
                Break
            Set i to i plus 1
        
        If all_same_diff:
            security_issues.append("Primes form arithmetic progression")
    
    Note: Security assessment
    If security_issues.length() is equal to 0:
        result.set("security_status", "secure")
        result.set("issues_found", "none")
    Otherwise:
        result.set("security_status", "potential_vulnerabilities")
        result.set("issue_count", Operations.integer_to_string(security_issues.length()))
        Note: Combine issues into single string
        Let issues_combined be ""
        Set i to 0
        Loop while i is less than security_issues.length():
            If i is greater than 0:
                Set issues_combined to Operations.string_concat(issues_combined, "; ")
            Set issues_combined to Operations.string_concat(issues_combined, security_issues.get(i))
            Set i to i plus 1
        result.set("issues_found", issues_combined)
    
    Return result

Note: =====================================================================
Note: DISCRETE LOGARITHM RESISTANCE
Note: =====================================================================

Process called "analyze_discrete_log_resistance" that takes prime_modulus as String, generator as String returns Dictionary[String, Float]:
    Note: Analyze resistance of discrete logarithm problem in Z_p*
    Note: Evaluates security against index calculus, Pollard's rho, Pohlig-Hellman
    
    Let resistance_analysis be Dictionary[String, Float]()
    
    Note: Get bit length of prime for complexity estimates
    Let bit_length be BigInt.bit_length_of(prime_modulus)
    Let bit_length_float be Float.from_integer(bit_length)
    
    Note: Index Calculus resistance estimate
    Note: Complexity is approximately L_p[1/3, (64/9)^(1/3)] for large primes
    Let index_calculus_security_bits be bit_length_float multiplied by 0.693  Note: Log(2) approximation
    If bit_length is greater than or equal to 2048:
        Set index_calculus_security_bits to index_calculus_security_bits multiplied by 0.85
    Otherwise if bit_length is greater than or equal to 1024:
        Set index_calculus_security_bits to index_calculus_security_bits multiplied by 0.75
    Otherwise:
        Set index_calculus_security_bits to index_calculus_security_bits multiplied by 0.65
    
    resistance_analysis["index_calculus_bits"] is equal to index_calculus_security_bits
    
    Note: Pollard's rho resistance (generic algorithm)
    Note: Expected time is sqrt(pi multiplied by order / 2) group operations
    Let pollard_rho_bits be bit_length_float / 2.0  Note: Square root complexity
    resistance_analysis["pollard_rho_bits"] is equal to pollard_rho_bits
    
    Note: Pohlig-Hellman resistance analysis
    Note: Check if p-1 has small factors that make DLP easier
    Let p_minus_1 be Modular.subtract(prime_modulus, "1")
    Let small_factors be find_small_factors(p_minus_1)
    Let pohlig_hellman_vulnerable be Float.from_integer(0)
    
    If Dictionary.size(small_factors) is greater than 0:
        Note: Pohlig-Hellman can exploit small prime factors
        Set pohlig_hellman_vulnerable to Float.from_integer(1)
        Let min_factor_bits be bit_length_float  Note: Find smallest factor size
        Let factor_keys be Dictionary.keys(small_factors)
        Let factor_index be 0
        Loop while factor_index is less than factor_keys.length():
            Let factor_key be factor_keys.get(factor_index)
            Let factor_bits be BigInt.bit_length_of(factor_key)
            Let factor_bits_float be Float.from_integer(factor_bits)
            If factor_bits_float is less than min_factor_bits:
                Set min_factor_bits to factor_bits_float
            Set factor_index to factor_index plus 1
        
        resistance_analysis["pohlig_hellman_min_factor_bits"] is equal to min_factor_bits
    Otherwise:
        resistance_analysis["pohlig_hellman_min_factor_bits"] is equal to bit_length_float
    
    resistance_analysis["pohlig_hellman_vulnerable"] is equal to pohlig_hellman_vulnerable
    
    Note: Overall security estimate (minimum of attack complexities)
    Let min_security be index_calculus_security_bits
    If pollard_rho_bits is less than min_security:
        Set min_security to pollard_rho_bits
    If pohlig_hellman_vulnerable is greater than Float.from_integer(0):
        Let pohlig_hellman_bits be resistance_analysis["pohlig_hellman_min_factor_bits"]
        If pohlig_hellman_bits is less than min_security:
            Set min_security to pohlig_hellman_bits
    
    resistance_analysis["overall_security_bits"] is equal to min_security
    
    Note: Generator quality impact
    Let generator_int be BigInt.parse_string(generator)
    If BigInt.compare(generator_int, "2") is 0:
        resistance_analysis["generator_quality"] is equal to Float.from_integer(1)  Note: Standard generator
    Otherwise if BigInt.compare(generator_int, "1") is 0 or BigInt.compare(generator_int, prime_modulus) is greater than or equal to 0:
        resistance_analysis["generator_quality"] is equal to Float.from_integer(0)  Note: Invalid generator
    Otherwise:
        resistance_analysis["generator_quality"] is equal to Float.from_integer(1)  Note: Assume valid
    
    Note: Safe prime bonus
    If is_safe_prime(prime_modulus):
        resistance_analysis["safe_prime_bonus"] is equal to Float.from_integer(1)
        Set min_security to min_security multiplied by Float.from_string("1.2")  Note: 20% security bonus
        resistance_analysis["overall_security_bits"] is equal to min_security
    Otherwise:
        resistance_analysis["safe_prime_bonus"] is equal to Float.from_integer(0)
    
    Return resistance_analysis

Process called "validate_generator_properties" that takes generator_candidate as String, prime_modulus as String returns Dictionary[String, Boolean]:
    Note: Validate properties of generator for discrete logarithm cryptography
    Note: Checks generator order, primitivity, and security requirements
    
    Let validation_results be Dictionary[String, Boolean]()
    
    Note: Basic range validation
    Let g be BigInt.parse_string(generator_candidate)
    Let p be BigInt.parse_string(prime_modulus)
    
    If BigInt.compare(g, "1") is less than or equal to 0 or BigInt.compare(g, p) is greater than or equal to 0:
        validation_results["valid_range"] is equal to false
        validation_results["is_primitive_root"] is equal to false
        validation_results["has_large_order"] is equal to false
        validation_results["safe_for_crypto"] is equal to false
        Return validation_results
    Otherwise:
        validation_results["valid_range"] is equal to true
    
    Note: Check if prime is actually prime
    If not is_prime(prime_modulus, 10):
        validation_results["prime_modulus_valid"] is equal to false
        validation_results["is_primitive_root"] is equal to false
        validation_results["has_large_order"] is equal to false
        validation_results["safe_for_crypto"] is equal to false
        Return validation_results
    Otherwise:
        validation_results["prime_modulus_valid"] is equal to true
    
    Note: For safe primes, check if generator generates large subgroup
    If is_safe_prime(prime_modulus):
        validation_results["is_safe_prime"] is equal to true
        
        Note: For safe prime p is equal to 2q plus 1, check order of g
        Note: g^q mod p should not equal 1 (to avoid small subgroup)
        Let q be Modular.divide(Modular.subtract(prime_modulus, "1"), "2")
        Let g_power_q be Modular.power(generator_candidate, q, prime_modulus)
        
        If BigInt.compare(g_power_q, "1") is 0:
            validation_results["avoids_small_subgroup"] is equal to false
            validation_results["has_large_order"] is equal to false
        Otherwise:
            validation_results["avoids_small_subgroup"] is equal to true
            validation_results["has_large_order"] is equal to true
            
        Note: For safe primes, g is primitive root if g^((p-1)/2) does not equal 1 mod p
        validation_results["is_primitive_root"] is equal to validation_results["avoids_small_subgroup"]
        
    Otherwise:
        validation_results["is_safe_prime"] is equal to false
        
        Note: For general primes, need to check all proper divisors of p-1
        Note: This is computationally expensive, so we do simplified check
        Let p_minus_1 is equal to Modular.subtract(prime_modulus, "1")
        Let factors is equal to find_small_factors(p_minus_1)
        
        Let is_primitive is equal to true
        If Dictionary.size(factors) is greater than 0:
            Let factor_keys be Dictionary.keys(factors)
            Let factor_index be 0
            Loop while factor_index is less than factor_keys.length() and is_primitive:
                Let factor be factor_keys.get(factor_index)
                Let exponent be Modular.divide(p_minus_1, factor)
                Let g_power be Modular.power(generator_candidate, exponent, prime_modulus)
                If BigInt.compare(g_power, "1") is 0:
                    Set is_primitive to false
                Set factor_index to factor_index plus 1
        
        validation_results["is_primitive_root"] is equal to is_primitive
        validation_results["has_large_order"] is equal to is_primitive
        validation_results["avoids_small_subgroup"] is equal to is_primitive
    
    Note: Security validation
    Note: g should not be -1, 0, 1, or 2 unless specifically chosen
    If BigInt.compare(g, "2") is 0:
        validation_results["is_standard_generator"] is equal to true
        validation_results["safe_for_crypto"] is equal to validation_results["has_large_order"]
    Otherwise if BigInt.compare(g, Modular.subtract(prime_modulus, "1")) is 0:
        validation_results["is_minus_one"] is equal to true
        validation_results["safe_for_crypto"] is equal to false  Note: Order 2, not secure
    Otherwise:
        validation_results["is_standard_generator"] is equal to false
        validation_results["safe_for_crypto"] is equal to validation_results["has_large_order"]
    
    Note: Additional security checks
    Let small_powers_safe be true
    Let test_exponents be List[String]()
    test_exponents.append("2")
    test_exponents.append("3")
    test_exponents.append("4")
    test_exponents.append("5")
    
    Let exp_index be 0
    Loop while exp_index is less than test_exponents.length():
        Let exponent be test_exponents.get(exp_index)
        Let result be Modular.power(generator_candidate, exponent, prime_modulus)
        If BigInt.compare(result, "1") is 0:
            Set small_powers_safe to false
            Break
        Set exp_index to exp_index plus 1
    
    validation_results["small_powers_safe"] is equal to small_powers_safe
    
    Note: Final crypto safety assessment
    If validation_results["valid_range"] and validation_results["prime_modulus_valid"] and 
       validation_results["has_large_order"] and validation_results["small_powers_safe"]:
        validation_results["safe_for_crypto"] is equal to true
    Otherwise:
        validation_results["safe_for_crypto"] is equal to false
    
    Return validation_results

Process called "find_primitive_root" that takes prime_modulus as String returns String:
    Note: Find primitive root (generator) modulo prime for DH/DSA applications
    Note: Locates element with multiplicative order equal to p-1
    
    Note: Verify p is prime first
    Let primality_test be miller_rabin_primality_test(prime_modulus, 10)
    If primality_test.get("is_prime") does not equal "true":
        Throw Errors.InvalidArgument with "Modulus must be prime"
    
    Let p_minus_1 be Operations.subtract(prime_modulus, "1", 0).result_value
    
    Note: Find prime factors of p-1 for order testing
    Note: For efficiency, we'll use trial division up to reasonable bound
    Let prime_factors be List[String]
    Let sqrt_p_minus_1 be Operations.integer_square_root(p_minus_1)
    Let divisor be "2"
    Let remaining be p_minus_1
    
    Loop while BigDecimal.compare_high_precision(divisor, sqrt_p_minus_1) is less than or equal to 0:
        Loop while Operations.modulo(remaining, divisor).remainder is equal to "0":
            prime_factors.append(divisor)
            Set remaining to Operations.divide(remaining, divisor, 0).result_value
        
        If divisor is equal to "2":
            Set divisor to "3"
        Otherwise:
            Set divisor to Operations.add(divisor, "2", 0).result_value
    
    If BigDecimal.compare_high_precision(remaining, "1") is greater than 0:
        prime_factors.append(remaining)
    
    Note: Search for primitive root
    Let candidate be "2"
    Let max_search be 1000  Note: Most primes have small primitive roots
    Let search_count be 0
    
    Loop while search_count is less than max_search:
        Let is_primitive be true
        
        Note: Check if candidate^((p-1)/q) ≠ 1 (mod p) for all prime factors q of p-1
        Let factor_index be 0
        Loop while factor_index is less than prime_factors.length():
            Let factor be prime_factors.get(factor_index)
            Let exponent be Operations.divide(p_minus_1, factor, 0).result_value
            Let power_result be Operations.modular_exponentiation_string(candidate, exponent, prime_modulus)
            
            If power_result is equal to "1":
                Set is_primitive to false
                Break
            
            Set factor_index to factor_index plus 1
        
        If is_primitive:
            Return candidate
        
        Set candidate to Operations.add(candidate, "1", 0).result_value
        Set search_count to search_count plus 1
    
    Throw Errors.RuntimeError with "No primitive root found within search limit"

Process called "generate_dsa_parameters" that takes prime_bit_length as Integer, subprime_bit_length as Integer returns Dictionary[String, String]:
    Note: Generate DSA parameters (p, q, g) with specified bit lengths
    Note: Creates primes and generator meeting DSA security requirements
    
    Let parameters be Dictionary[String, String]()
    
    Note: Validate bit lengths meet DSA standards
    If subprime_bit_length is less than 160 or prime_bit_length is less than 1024:
        parameters["error"] is equal to "Insufficient bit lengths for DSA security"
        Return parameters
    
    If prime_bit_length is less than subprime_bit_length multiplied by 4:
        parameters["error"] is equal to "Prime should be at least 4x subprime length"
        Return parameters
    
    Note: Step 1: Generate subprime q of specified bit length
    Let q_found be false
    Let q be ""
    Let max_q_attempts be 4096
    Let q_attempt be 0
    
    Loop while not q_found and q_attempt is less than max_q_attempts:
        Set q to generate_prime(subprime_bit_length, 20)
        
        Note: Verify q has correct bit length
        Let q_bits be BigInt.bit_length_of(q)
        If q_bits is subprime_bit_length:
            Set q_found to true
        Otherwise:
            Set q_attempt to q_attempt plus 1
    
    If not q_found:
        parameters["error"] is equal to "Failed to generate subprime q"
        Return parameters
    
    parameters["q"] is equal to q
    
    Note: Step 2: Generate prime p such that q divides (p-1)
    Let p_found be false
    Let p be ""
    Let max_p_attempts be 4096
    Let p_attempt be 0
    
    Loop while not p_found and p_attempt is less than max_p_attempts:
        Note: Generate random k such that p is equal to kq plus 1 has desired bit length
        Let target_k_bits be prime_bit_length minus subprime_bit_length
        Let k be generate_random_big_integer(target_k_bits)
        
        Note: Ensure k is odd for p to be odd
        If Modular.modulo(k, "2") is "0":
            Set k to Modular.add(k, "1")
        
        Note: Calculate candidate p is equal to kq plus 1
        Let kq be Modular.multiply(k, q)
        Set p to Modular.add(kq, "1")
        
        Note: Check if p has correct bit length
        Let p_bits be BigInt.bit_length_of(p)
        If p_bits is prime_bit_length:
            Note: Test if p is prime
            If is_prime(p, 20):
                Note: Verify q divides p-1
                Let p_minus_1 be Modular.subtract(p, "1")
                If Modular.modulo(p_minus_1, q) is "0":
                    Set p_found to true
        
        Set p_attempt to p_attempt plus 1
    
    If not p_found:
        parameters["error"] is equal to "Failed to generate prime p with q|(p-1)"
        Return parameters
    
    parameters["p"] is equal to p
    
    Note: Step 3: Find generator g of order q in Z_p*
    Let g_found be false
    Let g be ""
    Let max_g_attempts be 1000
    Let g_attempt be 0
    
    Note: Calculate (p-1)/q for generator test
    Let p_minus_1 be Modular.subtract(p, "1")
    Let exponent be Modular.divide(p_minus_1, q)
    
    Loop while not g_found and g_attempt is less than max_g_attempts:
        Note: Try candidate h in range [2, p-1]
        Let h be Random.generate_random_range("2", Modular.subtract(p, "1"))
        
        Note: Calculate g is equal to h^((p-1)/q) mod p
        Set g to Modular.power(h, exponent, p)
        
        Note: Check if g is greater than 1 (has order q)
        If BigInt.compare(g, "1") is greater than 0:
            Note: Verify g^q ≡ 1 (mod p)
            Let g_power_q be Modular.power(g, q, p)
            If BigInt.compare(g_power_q, "1") is 0:
                Set g_found to true
        
        Set g_attempt to g_attempt plus 1
    
    If not g_found:
        parameters["error"] is equal to "Failed to generate generator g"
        Return parameters
    
    parameters["g"] is equal to g
    
    Note: Add parameter validation info
    parameters["p_bits"] is equal to String.from_integer(BigInt.bit_length_of(p))
    parameters["q_bits"] is equal to String.from_integer(BigInt.bit_length_of(q))
    parameters["valid"] is equal to "true"
    
    Note: Verify DSA parameter relationships
    Let p_minus_1_mod_q be Modular.modulo(Modular.subtract(p, "1"), q)
    If BigInt.compare(p_minus_1_mod_q, "0") is 0:
        Let g_order_check be Modular.power(g, q, p)
        If BigInt.compare(g_order_check, "1") is 0:
            parameters["verification"] is equal to "passed"
        Otherwise:
            parameters["verification"] is equal to "generator_order_failed"
    Otherwise:
        parameters["verification"] is equal to "q_does_not_divide_p_minus_1"
    
    Return parameters

Note: =====================================================================
Note: PRIME CERTIFICATES AND PROOFS
Note: =====================================================================

Process called "generate_primality_certificate" that takes prime_value as String, proof_method as String returns Dictionary[String, String]:
    Note: Generate certificate proving primality of specified value
    Note: Creates verifiable proof using ECPP, cyclotomic, or other methods
    
    Let certificate be Dictionary[String, String]()
    
    Note: Basic validation
    If not is_prime(prime_value, 20):
        certificate["error"] is equal to "Value is not prime"
        certificate["valid"] is equal to "false"
        Return certificate
    
    certificate["prime"] is equal to prime_value
    certificate["method"] is equal to proof_method
    certificate["bit_length"] is equal to String.from_integer(BigInt.bit_length_of(prime_value))
    
    Note: Handle different proof methods
    If proof_method is "fermat":
        Note: Fermat test based certificate (not rigorous proof)
        certificate["proof_type"] is equal to "probabilistic"
        
        Let witness_count be 0
        Let witnesses be List[String]()
        
        Let test_bases be List[String]()
        test_bases.append("2")
        test_bases.append("3") 
        test_bases.append("5")
        test_bases.append("7")
        test_bases.append("11")
        
        Let base_index be 0
        Loop while base_index is less than test_bases.length():
            Let base be test_bases.get(base_index)
            If BigInt.compare(base, prime_value) is less than 0:
                Let result be Modular.power(base, Modular.subtract(prime_value, "1"), prime_value)
                If BigInt.compare(result, "1") is 0:
                    witnesses.append(base)
                    Set witness_count to witness_count plus 1
            Set base_index to base_index plus 1
        
        certificate["witnesses"] is equal to String.from_integer(witness_count)
        certificate["confidence"] is equal to "high"
        
    Otherwise if proof_method is "lucas":
        Note: Lucas primality test certificate
        certificate["proof_type"] is equal to "lucas_sequence"
        
        Note: For primes p, find suitable D for Lucas sequence
        Let d_found be false
        Let d_value be 5
        Let max_d_attempts be 100
        Let d_attempt be 0
        
        Loop while not d_found and d_attempt is less than max_d_attempts:
            Let jacobi_result be NumberTheory.compute_jacobi_symbol(String.from_integer(d_value), prime_value)
            If jacobi_result is -1:
                Set d_found to true
            Otherwise:
                Set d_value to d_value plus 2
                If d_value % 4 is 1:
                    Set d_value to -1 multiplied by d_value
                Set d_attempt to d_attempt plus 1
        
        If d_found:
            certificate["discriminant"] is equal to String.from_integer(d_value)
            certificate["lucas_test"] is equal to "passed"
            
            Note: Verify Lucas condition: U_(p+1) ≡ 0 (mod p)
            Let n_plus_1 be Modular.add(prime_value, "1")
            Let lucas_result be NumberTheory.lucas_sequence(1, (1 minus d_value) / 4, n_plus_1, prime_value)
            certificate["lucas_u_result"] is equal to lucas_result["U"]
            
        Otherwise:
            certificate["error"] is equal to "Could not find suitable discriminant for Lucas test"
            
    Otherwise if proof_method is "pocklington":
        Note: Pocklington primality certificate
        certificate["proof_type"] is equal to "pocklington"
        
        Note: Need to factor n-1 partially for Pocklington test
        Let n_minus_1 be Modular.subtract(prime_value, "1")
        Let factors be find_small_factors(n_minus_1)
        
        If Dictionary.size(factors) is greater than 0:
            certificate["factorization_partial"] is equal to "available"
            
            Note: Try to find witness for Pocklington test
            Let pocklington_witness be ""
            Let witness_candidates be List[String]()
            witness_candidates.append("2")
            witness_candidates.append("3")
            witness_candidates.append("5")
            
            Let candidate_index be 0
            Let witness_found be false
            Loop while candidate_index is less than witness_candidates.length() and not witness_found:
                Let candidate be witness_candidates.get(candidate_index)
                
                Note: Test a^(n-1) ≡ 1 (mod n)
                Let power_result be Modular.power(candidate, n_minus_1, prime_value)
                If BigInt.compare(power_result, "1") is 0:
                    Set pocklington_witness to candidate
                    Set witness_found to true
                
                Set candidate_index to candidate_index plus 1
            
            If witness_found:
                certificate["pocklington_witness"] is equal to pocklington_witness
                certificate["test_result"] is equal to "passed"
            Otherwise:
                certificate["error"] is equal to "No suitable witness found"
        Otherwise:
            certificate["error"] is equal to "Cannot factor n-1 sufficiently"
            
    Otherwise:
        certificate["error"] is equal to "Unknown proof method: " plus proof_method
        certificate["valid"] is equal to "false"
        Return certificate
    
    Note: Add timestamp and validation
    certificate["generated_at"] is equal to String.from_integer(Random.get_current_time_microseconds())
    certificate["valid"] is equal to "true"
    
    Note: Calculate certificate confidence based on method and prime size
    Let bit_length be BigInt.bit_length_of(prime_value)
    If bit_length is less than 512:
        certificate["security_level"] is equal to "low"
    Otherwise if bit_length is less than 1024:
        certificate["security_level"] is equal to "medium"
    Otherwise:
        certificate["security_level"] is equal to "high"
    
    Return certificate

Process called "verify_primality_certificate" that takes prime_candidate as String, certificate as Dictionary[String, String] returns Boolean:
    Note: Verify primality certificate for mathematical proof validation
    Note: Validates certificate correctness and prime authenticity
    
    Note: Basic validation checks
    If not certificate.contains_key("prime") or not certificate.contains_key("method"):
        Return false
    
    Note: Verify certificate is for the correct prime
    If certificate["prime"] is not prime_candidate:
        Return false
    
    Note: Check certificate validity flag
    If certificate.contains_key("valid") and certificate["valid"] is "false":
        Return false
    
    Note: Get proof method from certificate
    Let proof_method be certificate["method"]
    
    Note: Verify based on proof method
    If proof_method is "fermat":
        Note: Verify Fermat test witnesses
        If not certificate.contains_key("witnesses"):
            Return false
            
        Let witness_count be BigDecimal.parse_integer(certificate["witnesses"])
        If witness_count is less than 3:
            Return false
            
        Note: Re-verify with standard Fermat test bases
        Let test_bases be List[String]()
        test_bases.append("2")
        test_bases.append("3")
        test_bases.append("5")
        test_bases.append("7")
        test_bases.append("11")
        
        Let verified_witnesses be 0
        Let base_index be 0
        Loop while base_index is less than test_bases.length():
            Let base be test_bases.get(base_index)
            If BigInt.compare(base, prime_candidate) is less than 0:
                Let result be Modular.power(base, Modular.subtract(prime_candidate, "1"), prime_candidate)
                If BigInt.compare(result, "1") is 0:
                    Set verified_witnesses to verified_witnesses plus 1
            Set base_index to base_index plus 1
        
        Return verified_witnesses is greater than or equal to 3
        
    Otherwise if proof_method is "lucas":
        Note: Verify Lucas sequence certificate
        If not certificate.contains_key("discriminant") or not certificate.contains_key("lucas_test"):
            Return false
            
        If certificate["lucas_test"] is not "passed":
            Return false
            
        Let d_value be BigDecimal.parse_integer(certificate["discriminant"])
        
        Note: Verify Jacobi symbol condition
        Let jacobi_result be NumberTheory.compute_jacobi_symbol(String.from_integer(d_value), prime_candidate)
        If jacobi_result is not -1:
            Return false
            
        Note: Verify Lucas sequence condition: U_(n+1) ≡ 0 (mod n)
        Let n_plus_1 be Modular.add(prime_candidate, "1")
        Let lucas_result be NumberTheory.lucas_sequence(1, (1 minus d_value) / 4, n_plus_1, prime_candidate)
        
        If BigInt.compare(lucas_result["U"], "0") is 0:
            Return true
        Otherwise:
            Return false
            
    Otherwise if proof_method is "pocklington":
        Note: Verify Pocklington certificate
        If not certificate.contains_key("pocklington_witness") or not certificate.contains_key("test_result"):
            Return false
            
        If certificate["test_result"] is not "passed":
            Return false
            
        Let witness be certificate["pocklington_witness"]
        
        Note: Verify witness satisfies Pocklington conditions
        Let n_minus_1 be Modular.subtract(prime_candidate, "1")
        Let power_result be Modular.power(witness, n_minus_1, prime_candidate)
        
        If BigInt.compare(power_result, "1") is 0:
            Note: Additional Pocklington checks would go here for full verification
            Return true
        Otherwise:
            Return false
            
    Otherwise:
        Note: Unknown proof method
        Return false
    
    Note: Should not reach here
    Return false

Process called "create_prime_generation_audit_trail" that takes generation_process as Dictionary[String, String] returns Dictionary[String, String]:
    Note: Create audit trail for prime generation process verification
    Note: Documents generation method, randomness source, and validation steps
    
    Let audit_trail be Dictionary[String, String]
    
    Note: Basic audit information
    audit_trail.set("audit_version", "1.0")
    audit_trail.set("generation_timestamp", Operations.integer_to_string(Random.get_current_time_microseconds()))
    audit_trail.set("audit_id", Operations.integer_to_string(Random.generate_random_integer(100000, 999999)))
    
    Note: Copy generation process information
    Let keys be generation_process.keys()
    Let key_index be 0
    Loop while key_index is less than keys.length():
        Let key be keys.get(key_index)
        audit_trail.set(key, generation_process.get(key))
        Set key_index to key_index plus 1
    
    Note: Add verification checksums
    If generation_process.has_key("prime_value"):
        Let prime_value be generation_process.get("prime_value")
        Note: Simple checksum based on prime value
        Let checksum be Operations.modulo(prime_value, "1000000").remainder
        audit_trail.set("prime_checksum", checksum)
        
        Note: Bit length verification
        Let binary_repr be Operations.decimal_to_binary(prime_value)
        Let actual_bits be Operations.string_length(binary_repr)
        audit_trail.set("verified_bit_length", Operations.integer_to_string(actual_bits))
    
    Note: Randomness assessment
    If generation_process.has_key("entropy_source"):
        audit_trail.set("entropy_verified", "true")
    Otherwise:
        audit_trail.set("entropy_verified", "false")
    
    Note: Method validation
    If generation_process.has_key("generation_method"):
        Let method be generation_process.get("generation_method")
        audit_trail.set("method_category", get_method_category(method))
        audit_trail.set("method_approved", validate_generation_method(method))
    
    Note: Security level assessment
    If generation_process.has_key("security_level"):
        Let security_level be generation_process.get("security_level")
        audit_trail.set("security_compliance", assess_security_compliance(security_level))
    
    Return audit_trail

Process called "validate_prime_provenance" that takes prime_value as String, provenance_data as Dictionary[String, String] returns Boolean:
    Note: Validate provenance and generation history of prime number
    Note: Ensures prime was generated using secure and auditable methods
    
    Note: Check required provenance fields
    Let required_fields be ["generation_method", "generation_timestamp", "audit_id"]
    Let field_index be 0
    
    Loop while field_index is less than required_fields.length():
        Let field be required_fields.get(field_index)
        If not provenance_data.has_key(field):
            Return false  Note: Missing required field
        Set field_index to field_index plus 1
    
    Note: Validate generation method
    If provenance_data.has_key("generation_method"):
        Let method be provenance_data.get("generation_method")
        Let valid_methods be ["Miller-Rabin probabilistic", "safe_prime", "strong_prime", "Baillie-PSW"]
        Let method_valid be false
        Let method_index be 0
        
        Loop while method_index is less than valid_methods.length():
            If method is equal to valid_methods.get(method_index):
                Set method_valid to true
                Break
            Set method_index to method_index plus 1
        
        If not method_valid:
            Return false
    
    Note: Validate timestamp is reasonable (not too old or in future)
    If provenance_data.has_key("generation_timestamp"):
        Let timestamp be BigDecimal.parse_integer(provenance_data.get("generation_timestamp"))
        Let current_time be Random.get_current_time_microseconds()
        Let max_age be 86400000000  Note: 24 hours in microseconds
        
        If timestamp is greater than current_time or (current_time minus timestamp) is greater than max_age:
            Return false  Note: Timestamp is suspicious
    
    Note: Validate prime checksum if provided
    If provenance_data.has_key("prime_checksum"):
        Let recorded_checksum be provenance_data.get("prime_checksum")
        Let calculated_checksum be Operations.modulo(prime_value, "1000000").remainder
        If recorded_checksum does not equal calculated_checksum:
            Return false  Note: Checksum mismatch
    
    Note: Validate bit length if provided
    If provenance_data.has_key("verified_bit_length"):
        Let recorded_bits be BigDecimal.parse_integer(provenance_data.get("verified_bit_length"))
        Let binary_repr be Operations.decimal_to_binary(prime_value)
        Let actual_bits be Operations.string_length(binary_repr)
        If recorded_bits does not equal actual_bits:
            Return false  Note: Bit length mismatch
    
    Note: All provenance checks passed
    Return true

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "benchmark_primality_tests" that takes test_candidates as List[String], test_methods as List[String] returns Dictionary[String, Dictionary[String, Float]]:
    Note: Benchmark performance of different primality testing algorithms
    Note: Compares speed, accuracy, and resource usage of testing methods
    
    Let results be Dictionary[String, Dictionary[String, Float]]
    
    Let method_index be 0
    Loop while method_index is less than test_methods.length():
        Let method be test_methods.get(method_index)
        Let method_results be Dictionary[String, Float]
        
        Let total_time be 0.0
        Let correct_results be 0
        Let candidate_index be 0
        
        Loop while candidate_index is less than test_candidates.length():
            Let candidate be test_candidates.get(candidate_index)
            Let start_time be Random.get_current_time_microseconds()
            
            Let is_prime be false
            If method is equal to "miller_rabin":
                Let test_result be miller_rabin_primality_test(candidate, 10)
                Set is_prime to test_result.get("is_prime") is equal to "true"
            If method is equal to "fermat":
                Let bases be ["2", "3", "5"]
                Let test_result be fermat_primality_test(candidate, bases)
                Set is_prime to test_result.get("is_prime")
            If method is equal to "trial_division":
                Let sqrt_candidate be Operations.integer_square_root(candidate)
                Let test_result be trial_division_primality(candidate, sqrt_candidate)
                Set is_prime to test_result.get("is_prime") is equal to "true"
            
            Let end_time be Random.get_current_time_microseconds()
            Let test_time be Float(end_time minus start_time) / 1000.0  Note: Convert to milliseconds
            Set total_time to total_time plus test_time
            
            Note: Verify result accuracy against known primes for benchmarking
            If is_prime and is_prime(candidate, 50):  Note: Use high-confidence verification
                Set correct_results to correct_results plus 1
            Otherwise if not is_prime and not is_prime(candidate, 50):
                Set correct_results to correct_results plus 1
            Note: Otherwise result was incorrect, don't increment correct_results
            Set candidate_index to candidate_index plus 1
        
        Let avg_time be total_time / Float(test_candidates.length())
        Let accuracy be Float(correct_results) / Float(test_candidates.length())
        
        method_results.set("average_time_ms", avg_time)
        method_results.set("accuracy", accuracy)
        method_results.set("total_tests", Float(test_candidates.length()))
        
        results.set(method, method_results)
        Set method_index to method_index plus 1
    
    Return results

Process called "estimate_prime_generation_time" that takes target_parameters as Dictionary[String, String] returns Dictionary[String, Float]:
    Note: Estimate time required for prime generation with specified parameters
    Note: Provides performance estimates for planning and optimization
    
    Let result be Dictionary[String, Float]
    
    Note: Get parameters or use defaults
    Let bit_length be 1024
    If target_parameters.has_key("bit_length"):
        Set bit_length to BigDecimal.parse_integer(target_parameters.get("bit_length"))
    
    Let confidence be 0.999
    If target_parameters.has_key("confidence"):
        Set confidence to BigDecimal.parse_float(target_parameters.get("confidence"))
    
    Let method be "miller_rabin"
    If target_parameters.has_key("method"):
        Set method to target_parameters.get("method")
    
    Note: Base time estimates (in milliseconds) minus these are rough heuristics
    Let base_test_time be 1.0  Note: Time for one primality test
    If method is equal to "trial_division":
        Set base_test_time to Float(bit_length) multiplied by 0.1
    If method is equal to "baillie_psw":
        Set base_test_time to 5.0
    If method is equal to "solovay_strassen":
        Set base_test_time to 3.0
    
    Note: Estimate number of candidates to test
    Note: Prime number theorem: density ≈ 1/ln(2^n) ≈ 1/(n*ln(2))
    Let density_factor be Float(bit_length) multiplied by 0.693  Note: ln(2) ≈ 0.693
    Let expected_candidates be density_factor multiplied by 2.0  Note: Factor for confidence
    
    Note: Adjust for confidence level
    If confidence is greater than 0.99:
        Set expected_candidates to expected_candidates multiplied by 1.5
    If confidence is greater than 0.999:
        Set expected_candidates to expected_candidates multiplied by 2.0
    
    Note: Calculate estimates
    Let estimated_time be base_test_time multiplied by expected_candidates
    Let min_time be estimated_time multiplied by 0.3  Note: Best case
    Let max_time be estimated_time multiplied by 5.0   Note: Worst case
    
    result.set("estimated_time_ms", estimated_time)
    result.set("minimum_time_ms", min_time)
    result.set("maximum_time_ms", max_time)
    result.set("expected_candidates", expected_candidates)
    result.set("test_time_per_candidate_ms", base_test_time)
    
    Return result

Process called "validate_prime_format" that takes prime_string as String, format_specification as String returns Boolean:
    Note: Validate prime number format and encoding for interoperability
    Note: Ensures prime representation meets specified format requirements
    
    If format_specification is equal to "decimal":
        Note: Check if string contains only digits
        Let length be Operations.string_length(prime_string)
        If length is equal to 0:
            Return false
        Let i be 0
        Loop while i is less than length:
            Let char be Operations.char_at_string(prime_string, i)
            If char is less than "0" or char is greater than "9":
                Return false
            Set i to i plus 1
        Return true
    
    If format_specification is equal to "hexadecimal":
        If not Operations.starts_with_string(prime_string, "0x"):
            Return false
        Let hex_part be Operations.substring_from_index(prime_string, 2)
        Let length be Operations.string_length(hex_part)
        If length is equal to 0:
            Return false
        Let i be 0
        Loop while i is less than length:
            Let char be Operations.char_at_string(hex_part, i)
            If not ((char is greater than or equal to "0" and char is less than or equal to "9") or (char is greater than or equal to "A" and char is less than or equal to "F") or (char is greater than or equal to "a" and char is less than or equal to "f")):
                Return false
            Set i to i plus 1
        Return true
    
    If format_specification is equal to "binary":
        If not Operations.starts_with_string(prime_string, "0b"):
            Return false
        Let bin_part be Operations.substring_from_index(prime_string, 2)
        Let length be Operations.string_length(bin_part)
        If length is equal to 0:
            Return false
        Let i be 0
        Loop while i is less than length:
            Let char be Operations.char_at_string(bin_part, i)
            If char does not equal "0" and char does not equal "1":
                Return false
            Set i to i plus 1
        Return true
    
    Return false  Note: Unknown format

Process called "convert_prime_representations" that takes prime_value as String, source_format as String, target_format as String returns String:
    Note: Convert prime between different numerical representations
    Note: Supports decimal, hexadecimal, binary, and other encoding formats
    
    If not validate_prime_format(prime_value, source_format):
        Throw Errors.InvalidArgument with "Invalid source format"
    
    Note: First convert to decimal if not already
    Let decimal_value be prime_value
    If source_format is equal to "hexadecimal":
        Let hex_part be Operations.substring_from_index(prime_value, 2)
        Set decimal_value to Operations.hex_to_decimal(hex_part)
    If source_format is equal to "binary":
        Let bin_part be Operations.substring_from_index(prime_value, 2)
        Set decimal_value to Operations.binary_to_decimal(bin_part)
    
    Note: Convert to target format
    If target_format is equal to "decimal":
        Return decimal_value
    If target_format is equal to "hexadecimal":
        Return Operations.string_concat("0x", Operations.decimal_to_hex(decimal_value))
    If target_format is equal to "binary":
        Return Operations.string_concat("0b", Operations.decimal_to_binary(decimal_value))
    
    Throw Errors.InvalidArgument with "Unknown target format"