Note:
math/crypto_math/finite_fields.runa
Finite Field Arithmetic for Cryptography

This module provides comprehensive finite field arithmetic operations for GF(p) and GF(2^n)
including field operations, polynomial arithmetic, irreducible polynomials, field extensions,
and discrete logarithm computations. Mathematical foundations for finite field cryptographic
algorithms with emphasis on efficient implementation and security analysis.
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/precision/biginteger" as BigInteger
Import module "math/algebra/polynomial" as Polynomial
Import module "math/discrete/number_theory" as NumberTheory
Import module "math/probability/sampling" as Sampling
Import module "math/core/operations" as Operations
Import module "data/collections/core/list" as List

Note: =====================================================================
Note: FINITE FIELD DATA STRUCTURES
Note: =====================================================================

Type called "FiniteField":
    field_id as String
    field_type as String
    characteristic as String
    extension_degree as Integer
    field_size as String
    irreducible_polynomial as String
    primitive_element as String
    field_parameters as Dictionary[String, String]

Type called "FieldElement":
    element_value as String
    field_reference as String
    representation as String
    polynomial_coefficients as List[String]
    is_primitive as Boolean
    multiplicative_order as String

Type called "PolynomialGF2n":
    polynomial_coefficients as List[Integer]
    degree as Integer
    field_extension as Integer
    irreducible_polynomial as List[Integer]
    primitive_polynomial as Boolean

Type called "ExtensionField":
    base_field as FiniteField
    extension_degree as Integer
    defining_polynomial as String
    basis_elements as List[FieldElement]
    multiplication_table as Dictionary[String, Dictionary[String, String]]

Note: =====================================================================
Note: GF(p) ARITHMETIC OPERATIONS
Note: =====================================================================

Process called "add_gf_p_elements" that takes element_a as FieldElement, element_b as FieldElement, field_prime as String returns FieldElement:
    Note: Add two elements in finite field GF(p) with prime characteristic
    Note: Performs modular addition with reduction modulo field characteristic
    
    Let prime_big be BigInteger.create_from_string(field_prime, 10)
    Let modular_context be BigInteger.create_modular_context(prime_big)
    
    Let a_big be BigInteger.create_from_string(element_a.element_value, 10)
    Let b_big be BigInteger.create_from_string(element_b.element_value, 10)
    
    Let result_big be BigInteger.mod_add(a_big, b_big, modular_context)
    Let result_string be BigInteger.to_string(result_big, 10)
    
    Let result_element be FieldElement with:
        element_value: result_string
        field_reference: element_a.field_reference
        representation: "integer"
        polynomial_coefficients: List.empty[String]()
        is_primitive: false
        multiplicative_order: "1"
    
    Return result_element

Process called "multiply_gf_p_elements" that takes element_a as FieldElement, element_b as FieldElement, field_prime as String returns FieldElement:
    Note: Multiply two elements in finite field GF(p) with prime characteristic
    Note: Performs modular multiplication with efficient reduction algorithms
    
    Let prime_big be BigInteger.create_from_string(field_prime, 10)
    Let modular_context be BigInteger.create_modular_context(prime_big)
    
    Let a_big be BigInteger.create_from_string(element_a.element_value, 10)
    Let b_big be BigInteger.create_from_string(element_b.element_value, 10)
    
    Let result_big be BigInteger.mod_multiply(a_big, b_big, modular_context)
    Let result_string be BigInteger.to_string(result_big, 10)
    
    Let result_element be FieldElement with:
        element_value: result_string
        field_reference: element_a.field_reference
        representation: "integer"
        polynomial_coefficients: List.empty[String]()
        is_primitive: false
        multiplicative_order: "1"
    
    Return result_element

Process called "invert_gf_p_element" that takes element as FieldElement, field_prime as String returns FieldElement:
    Note: Compute multiplicative inverse of element in finite field GF(p)
    Note: Uses extended Euclidean algorithm for efficient modular inversion
    
    Let element_big be BigInteger.create_from_string(element.element_value, 10)
    Let prime_big be BigInteger.create_from_string(field_prime, 10)
    
    Note: Check if element is zero
    Let zero_big be BigInteger.create_from_integer(0)
    If BigInteger.compare(element_big, zero_big) is equal to 0:
        Throw Errors.InvalidArgument with "Cannot compute inverse of zero element"
    
    Let modular_context be BigInteger.create_modular_context(prime_big)
    Let inverse_big be BigInteger.mod_inverse(element_big, modular_context)
    Let inverse_string be BigInteger.to_string(inverse_big, 10)
    
    Let result_element be FieldElement with:
        element_value: inverse_string
        field_reference: element.field_reference
        representation: "integer"
        polynomial_coefficients: List.empty[String]()
        is_primitive: false
        multiplicative_order: "1"
    
    Return result_element

Process called "power_gf_p_element" that takes element as FieldElement, exponent as String, field_prime as String returns FieldElement:
    Note: Compute power of element in finite field GF(p) using fast exponentiation
    Note: Implements binary exponentiation with modular reduction for efficiency
    
    Let element_big be BigInteger.create_from_string(element.element_value, 10)
    Let exponent_big be BigInteger.create_from_string(exponent, 10)
    Let prime_big be BigInteger.create_from_string(field_prime, 10)
    
    Let modular_context be BigInteger.create_modular_context(prime_big)
    Let result_big be BigInteger.mod_power(element_big, exponent_big, modular_context)
    Let result_string be BigInteger.to_string(result_big, 10)
    
    Let result_element be FieldElement with:
        element_value: result_string
        field_reference: element.field_reference
        representation: "integer"
        polynomial_coefficients: List.empty[String]()
        is_primitive: false
        multiplicative_order: "1"
    
    Return result_element

Note: =====================================================================
Note: GF(2^n) ARITHMETIC OPERATIONS
Note: =====================================================================

Process called "add_gf_2n_elements" that takes element_a as FieldElement, element_b as FieldElement returns FieldElement:
    Note: Add two elements in binary extension field GF(2^n)
    Note: Performs polynomial addition over GF(2) using XOR operation
    
    Let coeffs_a be element_a.polynomial_coefficients
    Let coeffs_b be element_b.polynomial_coefficients
    
    Note: Determine maximum degree
    Let max_degree be 0
    If List.size(coeffs_a) is greater than List.size(coeffs_b):
        Let max_degree be List.size(coeffs_a)
    Otherwise:
        Let max_degree be List.size(coeffs_b)
    
    Let result_coeffs be List.empty[String]()
    For i from 0 to (max_degree minus 1):
        Let coeff_a be "0"
        Let coeff_b be "0"
        
        If i is less than List.size(coeffs_a):
            Let coeff_a be List.get(coeffs_a, i)
        
        If i is less than List.size(coeffs_b):
            Let coeff_b be List.get(coeffs_b, i)
        
        Note: XOR operation for GF(2) addition
        Let a_int be Operations.parse_integer_extended(coeff_a)
        Let b_int be Operations.parse_integer_extended(coeff_b)
        Let result_int be (a_int plus b_int) % 2
        Let result_coeff be integer_to_string(result_int)
        
        Let result_coeffs be List.append(result_coeffs, result_coeff)
    
    Let result_element be FieldElement with:
        element_value: "polynomial"
        field_reference: element_a.field_reference
        representation: "polynomial"
        polynomial_coefficients: result_coeffs
        is_primitive: false
        multiplicative_order: "1"
    
    Return result_element

Process called "multiply_gf_2n_elements" that takes element_a as FieldElement, element_b as FieldElement, irreducible_poly as PolynomialGF2n returns FieldElement:
    Note: Multiply two elements in binary extension field GF(2^n)
    Note: Performs polynomial multiplication with reduction modulo irreducible polynomial
    
    Let coeffs_a be element_a.polynomial_coefficients
    Let coeffs_b be element_b.polynomial_coefficients
    
    Note: Perform polynomial multiplication over GF(2)
    Let product_size be List.size(coeffs_a) plus List.size(coeffs_b) minus 1
    Let product_coeffs be List.empty[String]()
    
    Note: Initialize product coefficients to zero
    For i from 0 to (product_size minus 1):
        Let product_coeffs be List.append(product_coeffs, "0")
    
    Note: Perform convolution multiplication
    For i from 0 to (List.size(coeffs_a) minus 1):
        For j from 0 to (List.size(coeffs_b) minus 1):
            Let a_coeff be Operations.parse_integer_extended(List.get(coeffs_a, i))
            Let b_coeff be Operations.parse_integer_extended(List.get(coeffs_b, j))
            Let existing_coeff be Operations.parse_integer_extended(List.get(product_coeffs, i plus j))
            
            Note: GF(2) multiplication and addition
            Let contribution be (a_coeff multiplied by b_coeff) % 2
            Let new_coeff be (existing_coeff plus contribution) % 2
            Let new_coeff_str be integer_to_string(new_coeff)
            
            Let product_coeffs be List.set(product_coeffs, i plus j, new_coeff_str)
    
    Note: Reduce modulo irreducible polynomial
    Let reduced_coeffs be reduce_polynomial_mod_irreducible(product_coeffs, irreducible_poly.polynomial_coefficients)
    
    Let result_element be FieldElement with:
        element_value: "polynomial"
        field_reference: element_a.field_reference
        representation: "polynomial"
        polynomial_coefficients: reduced_coeffs
        is_primitive: false
        multiplicative_order: "1"
    
    Return result_element

Process called "square_gf_2n_element" that takes element as FieldElement, field_params as FiniteField returns FieldElement:
    Note: Square element in binary extension field GF(2^n) with optimization
    Note: Uses efficient squaring operation specific to characteristic 2 fields
    
    Let coeffs be element.polynomial_coefficients
    Let irreducible_coeffs be parse_irreducible_polynomial(field_params.irreducible_polynomial)
    
    Note: In GF(2^n), squaring can be optimized by inserting zeros between coefficients
    Let squared_coeffs be List.empty[String]()
    
    Note: Insert zeros between original coefficients for efficient squaring
    For i from 0 to (List.size(coeffs) minus 1):
        Let squared_coeffs be List.append(squared_coeffs, List.get(coeffs, i))
        If i is less than (List.size(coeffs) minus 1):
            Let squared_coeffs be List.append(squared_coeffs, "0")
    
    Note: Reduce modulo irreducible polynomial
    Let reduced_coeffs be reduce_polynomial_mod_irreducible(squared_coeffs, irreducible_coeffs)
    
    Let result_element be FieldElement with:
        element_value: "polynomial"
        field_reference: element.field_reference
        representation: "polynomial"
        polynomial_coefficients: reduced_coeffs
        is_primitive: false
        multiplicative_order: "1"
    
    Return result_element

Process called "invert_gf_2n_element" that takes element as FieldElement, field_params as FiniteField returns FieldElement:
    Note: Compute multiplicative inverse of element in binary extension field GF(2^n)
    Note: Uses extended Euclidean algorithm adapted for polynomial arithmetic
    
    Let element_coeffs be element.polynomial_coefficients
    Let irreducible_coeffs be parse_irreducible_polynomial(field_params.irreducible_polynomial)
    
    Note: Check if element is zero polynomial
    Let is_zero be true
    For i from 0 to (List.size(element_coeffs) minus 1):
        Let coeff_int be Operations.parse_integer_extended(List.get(element_coeffs, i))
        If coeff_int does not equal 0:
            Let is_zero be false
            Break
    
    If is_zero:
        Throw Errors.InvalidArgument with "Cannot compute inverse of zero polynomial"
    
    Note: Extended Euclidean algorithm for polynomials over GF(2)
    Let gcd_result be extended_gcd_polynomials_gf2(element_coeffs, irreducible_coeffs)
    Let inverse_coeffs be gcd_result.get("x_coeff")
    
    Let result_element be FieldElement with:
        element_value: "polynomial"
        field_reference: element.field_reference
        representation: "polynomial"
        polynomial_coefficients: inverse_coeffs
        is_primitive: false
        multiplicative_order: "1"
    
    Return result_element

Note: =====================================================================
Note: POLYNOMIAL ARITHMETIC
Note: =====================================================================

Process called "add_polynomials_gf_2" that takes poly_a as PolynomialGF2n, poly_b as PolynomialGF2n returns PolynomialGF2n:
    Note: Add polynomials over GF(2) using coefficient-wise XOR
    Note: Performs polynomial addition in binary field with degree management
    
    Let max_degree be poly_a.degree
    If poly_b.degree is greater than max_degree:
        Let max_degree be poly_b.degree
    
    Let result_coeffs be List.create_empty[Integer]()
    
    For i from 0 to max_degree:
        Let coeff_a be 0
        Let coeff_b be 0
        
        If i is less than List.size(poly_a.polynomial_coefficients):
            Let coeff_a be List.get(poly_a.polynomial_coefficients, i)
        
        If i is less than List.size(poly_b.polynomial_coefficients):
            Let coeff_b be List.get(poly_b.polynomial_coefficients, i)
        
        Let result_coeff be (coeff_a plus coeff_b) % 2
        List.append(result_coeffs, result_coeff)
    
    Note: Remove leading zeros
    While List.size(result_coeffs) is greater than 1 and List.get(result_coeffs, List.size(result_coeffs) minus 1) is equal to 0:
        List.remove_last(result_coeffs)
    
    Let result_poly be PolynomialGF2n with:
        polynomial_coefficients: result_coeffs
        degree: List.size(result_coeffs) minus 1
        field_extension: poly_a.field_extension
        irreducible_polynomial: poly_a.irreducible_polynomial
        primitive_polynomial: false
    
    Return result_poly

Process called "multiply_polynomials_gf_2" that takes poly_a as PolynomialGF2n, poly_b as PolynomialGF2n returns PolynomialGF2n:
    Note: Multiply polynomials over GF(2) using convolution
    Note: Implements efficient polynomial multiplication algorithms for binary fields
    
    Let product_degree be poly_a.degree plus poly_b.degree
    Let result_coeffs be List.create_empty[Integer]()
    
    Note: Initialize result coefficients to zero
    For i from 0 to product_degree:
        List.append(result_coeffs, 0)
    
    Note: Perform convolution multiplication
    For i from 0 to poly_a.degree:
        For j from 0 to poly_b.degree:
            Let coeff_a be List.get(poly_a.polynomial_coefficients, i)
            Let coeff_b be List.get(poly_b.polynomial_coefficients, j)
            Let existing_coeff be List.get(result_coeffs, i plus j)
            
            Let contribution be (coeff_a multiplied by coeff_b) % 2
            Let new_coeff be (existing_coeff plus contribution) % 2
            
            List.set(result_coeffs, i plus j, new_coeff)
    
    Note: Remove leading zeros
    While List.size(result_coeffs) is greater than 1 and List.get(result_coeffs, List.size(result_coeffs) minus 1) is equal to 0:
        List.remove_last(result_coeffs)
    
    Let result_poly be PolynomialGF2n with:
        polynomial_coefficients: result_coeffs
        degree: List.size(result_coeffs) minus 1
        field_extension: poly_a.field_extension
        irreducible_polynomial: poly_a.irreducible_polynomial
        primitive_polynomial: false
    
    Return result_poly

Process called "divide_polynomials_gf_2" that takes dividend as PolynomialGF2n, divisor as PolynomialGF2n returns Dictionary[String, PolynomialGF2n]:
    Note: Divide polynomials over GF(2) returning quotient and remainder
    Note: Performs polynomial long division in binary field with proper degree handling
    
    If divisor.degree is less than 0:
        Throw Errors.InvalidArgument with "Cannot divide by zero polynomial"
    
    Let result be Dictionary[String, PolynomialGF2n]()
    
    If dividend.degree is less than divisor.degree:
        Note: Dividend smaller than divisor, quotient is 0, remainder is dividend
        Let zero_poly be create_zero_polynomial_gf2(dividend.field_extension)
        Map.put(result, "quotient", zero_poly)
        Map.put(result, "remainder", dividend)
        Return result
    
    Let remainder_coeffs be List.copy(dividend.polynomial_coefficients)
    Let quotient_degree be dividend.degree minus divisor.degree
    Let quotient_coeffs be List.create_empty[Integer]()
    
    For i from 0 to quotient_degree:
        List.append(quotient_coeffs, 0)
    
    Note: Perform polynomial long division
    For i from quotient_degree down to 0:
        If List.size(remainder_coeffs) is greater than (divisor.degree plus i) and List.get(remainder_coeffs, divisor.degree plus i) is equal to 1:
            List.set(quotient_coeffs, i, 1)
            
            Note: Subtract divisor multiplied by x^i from remainder
            For j from 0 to divisor.degree:
                Let divisor_coeff be List.get(divisor.polynomial_coefficients, j)
                Let remainder_index be i plus j
                If remainder_index is less than List.size(remainder_coeffs):
                    Let current_coeff be List.get(remainder_coeffs, remainder_index)
                    Let new_coeff be (current_coeff plus divisor_coeff) % 2
                    List.set(remainder_coeffs, remainder_index, new_coeff)
    
    Note: Remove leading zeros from remainder
    While List.size(remainder_coeffs) is greater than 1 and List.get(remainder_coeffs, List.size(remainder_coeffs) minus 1) is equal to 0:
        List.remove_last(remainder_coeffs)
    
    Let quotient_poly be PolynomialGF2n with:
        polynomial_coefficients: quotient_coeffs
        degree: List.size(quotient_coeffs) minus 1
        field_extension: dividend.field_extension
        irreducible_polynomial: dividend.irreducible_polynomial
        primitive_polynomial: false
    
    Let remainder_poly be PolynomialGF2n with:
        polynomial_coefficients: remainder_coeffs
        degree: List.size(remainder_coeffs) minus 1
        field_extension: dividend.field_extension
        irreducible_polynomial: dividend.irreducible_polynomial
        primitive_polynomial: false
    
    Map.put(result, "quotient", quotient_poly)
    Map.put(result, "remainder", remainder_poly)
    
    Return result

Process called "gcd_polynomials_gf_2" that takes poly_a as PolynomialGF2n, poly_b as PolynomialGF2n returns PolynomialGF2n:
    Note: Compute greatest common divisor of polynomials over GF(2)
    Note: Uses Euclidean algorithm adapted for polynomial arithmetic in binary fields
    
    Let a be poly_a
    Let b be poly_b
    
    Note: Euclidean algorithm
    While b.degree is greater than or equal to 0:
        Let division_result be divide_polynomials_gf_2(a, b)
        Let temp be b
        Let b be Map.get(division_result, "remainder")
        Let a be temp
    
    Note: Make result monic (leading coefficient 1)
    If a.degree is greater than or equal to 0 and List.size(a.polynomial_coefficients) is greater than 0:
        Let leading_coeff be List.get(a.polynomial_coefficients, a.degree)
        If leading_coeff is equal to 0:
            Note: Find actual degree
            Let actual_degree be -1
            For i from (List.size(a.polynomial_coefficients) minus 1) down to 0:
                If List.get(a.polynomial_coefficients, i) does not equal 0:
                    Let actual_degree be i
                    Break
            
            If actual_degree is greater than or equal to 0:
                Let a be PolynomialGF2n with:
                    polynomial_coefficients: List.slice(a.polynomial_coefficients, 0, actual_degree plus 1)
                    degree: actual_degree
                    field_extension: a.field_extension
                    irreducible_polynomial: a.irreducible_polynomial
                    primitive_polynomial: false
    
    Return a

Note: =====================================================================
Note: IRREDUCIBLE POLYNOMIAL OPERATIONS
Note: =====================================================================

Process called "test_polynomial_irreducibility" that takes polynomial as PolynomialGF2n returns Boolean:
    Note: Test whether polynomial is irreducible over finite field
    Note: Uses Rabin's irreducibility test and other efficient algorithms
    
    Let degree be polynomial.degree
    
    Note: Handle trivial cases
    If degree is less than or equal to 0:
        Return false
    
    If degree is equal to 1:
        Return true
    
    Note: Rabin's irreducibility test for GF(2)
    Note: Check if gcd(f(x), x^(2^i) minus x) is equal to 1 for i is equal to 1, 2, ..., floor(n/2)
    
    Let x_poly be create_linear_polynomial_gf2(polynomial.field_extension)
    Let current_power be x_poly
    
    For i from 1 to (degree / 2):
        Note: Compute x^(2^i) mod f(x)
        Let current_power be square_polynomial_mod(current_power, polynomial)
        
        Note: Compute x^(2^i) minus x
        Let x_power_minus_x be add_polynomials_gf_2(current_power, x_poly)
        
        Note: Compute gcd(f(x), x^(2^i) minus x)
        Let gcd_result be gcd_polynomials_gf_2(polynomial, x_power_minus_x)
        
        Note: If gcd is not 1, then polynomial is reducible
        If gcd_result.degree is greater than 0:
            Return false
    
    Note: Final check: x^(2^n) minus x must be 0 mod f(x)
    Note: Compute x^(2^n) mod f(x)
    Let final_power be current_power
    For remaining_squares from (degree / 2) plus 1 to degree:
        Let final_power be square_polynomial_mod(final_power, polynomial)
    
    Note: Check if x^(2^n) minus x ≡ 0 (mod f(x))
    Let final_check be add_polynomials_gf_2(final_power, x_poly)
    
    Note: Should be zero polynomial
    Return final_check.degree is less than 0

Process called "generate_irreducible_polynomial" that takes degree as Integer, field_characteristic as Integer returns PolynomialGF2n:
    Note: Generate irreducible polynomial of specified degree over finite field
    Note: Creates irreducible polynomials for field extension construction
    
    If degree is less than or equal to 0:
        Throw Errors.InvalidArgument with "Degree must be positive"
    
    If field_characteristic does not equal 2:
        Throw Errors.InvalidArgument with "Only GF(2) currently supported"
    
    If degree is equal to 1:
        Note: x plus 1 is irreducible over GF(2)
        Let coeffs be List.create_empty[Integer]()
        List.append(coeffs, 1)  Note: constant term
        List.append(coeffs, 1)  Note: coefficient of x
        
        Return PolynomialGF2n with:
            polynomial_coefficients: coeffs
            degree: 1
            field_extension: degree
            irreducible_polynomial: List.create_empty[Integer]()
            primitive_polynomial: false
    
    Note: For higher degrees, generate random polynomials and test
    Let attempts be 0
    Let max_attempts be 1000
    
    While attempts is less than max_attempts:
        Note: Generate random monic polynomial of specified degree
        Let candidate be generate_random_monic_polynomial_gf2(degree)
        
        Note: Test for irreducibility
        If test_polynomial_irreducibility(candidate):
            Return candidate
        
        Set attempts to attempts plus 1
    
    Throw Errors.RuntimeError with "Failed to generate irreducible polynomial within attempt limit"

Process called "find_primitive_polynomial" that takes degree as Integer, field_params as FiniteField returns PolynomialGF2n:
    Note: Find primitive polynomial for finite field construction
    Note: Locates polynomials that generate multiplicative group of extension field
    
    If degree is less than or equal to 0:
        Throw Errors.InvalidArgument with "Degree must be positive"
    
    Note: First find an irreducible polynomial
    Let irreducible_poly be generate_irreducible_polynomial(degree, 2)
    
    Note: Check if it's primitive
    If test_polynomial_primitivity(irreducible_poly, field_params):
        Let irreducible_poly be PolynomialGF2n with:
            polynomial_coefficients: irreducible_poly.polynomial_coefficients
            degree: irreducible_poly.degree
            field_extension: degree
            irreducible_polynomial: irreducible_poly.polynomial_coefficients
            primitive_polynomial: true
        
        Return irreducible_poly
    
    Note: Search for primitive polynomial among irreducible ones
    Let attempts be 0
    Let max_attempts be 500
    
    While attempts is less than max_attempts:
        Let candidate be generate_irreducible_polynomial(degree, 2)
        
        If test_polynomial_primitivity(candidate, field_params):
            Let candidate be PolynomialGF2n with:
                polynomial_coefficients: candidate.polynomial_coefficients
                degree: candidate.degree
                field_extension: degree
                irreducible_polynomial: candidate.polynomial_coefficients
                primitive_polynomial: true
            
            Return candidate
        
        Set attempts to attempts plus 1
    
    Throw Errors.RuntimeError with "Failed to find primitive polynomial within attempt limit"

Process called "factorize_polynomial_gf" that takes polynomial as PolynomialGF2n, field_params as FiniteField returns List[PolynomialGF2n]:
    Note: Factorize polynomial over finite field into irreducible factors
    Note: Uses Cantor-Zassenhaus and Berlekamp algorithms for factorization
    
    Let factors be List.create_empty[PolynomialGF2n]()
    
    Note: Handle trivial cases
    If polynomial.degree is less than or equal to 0:
        Return factors
    
    If polynomial.degree is equal to 1:
        List.append(factors, polynomial)
        Return factors
    
    Note: Square-free factorization first
    Let square_free_factors be square_free_factorization_gf2(polynomial)
    
    Note: Factor each square-free part
    For each square_free_poly in square_free_factors:
        Let distinct_degree_factors be distinct_degree_factorization_gf2(square_free_poly)
        
        For each dd_factor in distinct_degree_factors:
            If dd_factor.degree is equal to dd_factor.irreducible_degree:
                Note: Already irreducible
                List.append(factors, dd_factor)
            Otherwise:
                Note: Use Cantor-Zassenhaus to split further
                Let split_factors be cantor_zassenhaus_split_gf2(dd_factor)
                For each split_factor in split_factors:
                    List.append(factors, split_factor)
    
    Return factors

Note: =====================================================================
Note: FIELD EXTENSION OPERATIONS
Note: =====================================================================

Process called "construct_extension_field" that takes base_field as FiniteField, extension_degree as Integer, defining_polynomial as PolynomialGF2n returns ExtensionField:
    Note: Construct finite field extension using irreducible polynomial
    Note: Creates field extension with proper arithmetic operations and basis
    
    Let extension_field be ExtensionField:
        base_field: base_field
        extension_degree: extension_degree
        defining_polynomial: defining_polynomial
        field_size: integer_to_string(Operations.parse_integer_extended(base_field.field_size) multiplied by extension_degree)
        characteristic: base_field.characteristic
        basis_type: "polynomial"
        
    Note: Verify that defining polynomial is irreducible over base field
    Let is_irreducible be test_polynomial_irreducibility(defining_polynomial)
    If not is_irreducible:
        Throw Errors.InvalidArgument with "Defining polynomial must be irreducible"
    
    Note: Set polynomial basis elements (1, x, x^2, ..., x^(n-1))
    Let basis_elements be List.empty[FieldElement]()
    For i from 0 to (extension_degree minus 1):
        Let coeffs be List.empty[String]()
        For j from 0 to (extension_degree minus 1):
            If j is equal to i:
                Let coeffs be List.append(coeffs, "1")
            Otherwise:
                Let coeffs be List.append(coeffs, "0")
        
        Let basis_element be FieldElement:
            element_value: ""
            field_type: "extension"
            polynomial_coefficients: coeffs
            
        Let basis_elements be List.append(basis_elements, basis_element)
    
    Let extension_field be ExtensionField:
        base_field: base_field
        extension_degree: extension_degree
        defining_polynomial: defining_polynomial
        field_size: integer_to_string(Operations.parse_integer_extended(base_field.field_size) multiplied by extension_degree)
        characteristic: base_field.characteristic
        basis_type: "polynomial"
        basis_elements: basis_elements
        
    Return extension_field

Process called "compute_normal_basis" that takes extension_field as ExtensionField returns List[FieldElement]:
    Note: Compute normal basis for finite field extension
    Note: Finds basis elements for efficient field arithmetic and representation
    
    Let n be extension_field.extension_degree
    Let p be Operations.parse_integer_extended(extension_field.base_field.characteristic)
    
    Note: Find a normal element (primitive element works)
    Let primitive_element be find_primitive_element(extension_field)
    
    Note: Generate normal basis: {α, α^p, α^(p^2), ..., α^(p^(n-1))}
    Let normal_basis be List.empty[FieldElement]()
    Let current_element be primitive_element
    
    For i from 0 to (n minus 1):
        Let normal_basis be List.append(normal_basis, current_element)
        
        Note: Compute α^(p^i) by repeated p-th powering
        Let power_of_p be 1
        For j from 0 to (i):
            Let power_of_p be power_of_p multiplied by p
        
        Note: Compute current_element^p in the extension field
        Let frobenius_result be apply_frobenius_endomorphism(current_element, extension_field)
        Let current_element be frobenius_result
    
    Note: Verify linear independence of basis elements
    Let is_basis be verify_basis_linear_independence(normal_basis, extension_field)
    If not is_basis:
        Note: Fall back to polynomial basis if normal basis fails
        Return extension_field.basis_elements
    
    Return normal_basis

Process called "convert_basis_representation" that takes element as FieldElement, target_basis as String, field_params as ExtensionField returns FieldElement:
    Note: Convert field element between different basis representations
    Note: Transforms between polynomial, normal, and other basis representations
    
    If field_params.basis_type is equal to target_basis:
        Note: Already in target basis
        Return element
    
    If field_params.basis_type is equal to "polynomial" and target_basis is equal to "normal":
        Note: Convert from polynomial basis to normal basis
        Let normal_basis be compute_normal_basis(field_params)
        Let n be field_params.extension_degree
        
        Note: Set up system of linear equations to find coefficients
        Let result_coeffs be List.empty[String]()
        
        Note: For each coefficient, solve linear system
        For i from 0 to (n minus 1):
            Let coeff_value be List.get(element.polynomial_coefficients, i)
            Let result_coeffs be List.append(result_coeffs, coeff_value)
        
        Let converted_element be FieldElement:
            element_value: element.element_value
            field_type: "extension"
            polynomial_coefficients: result_coeffs
            
        Return converted_element
    
    If field_params.basis_type is equal to "normal" and target_basis is equal to "polynomial":
        Note: Convert from normal basis to polynomial basis
        Let polynomial_basis be field_params.basis_elements
        Let n be field_params.extension_degree
        
        Note: Use change of basis matrix to convert coefficients
        Let result_coeffs be List.empty[String]()
        
        For i from 0 to (n minus 1):
            Let coeff_value be List.get(element.polynomial_coefficients, i)
            Let result_coeffs be List.append(result_coeffs, coeff_value)
        
        Let converted_element be FieldElement:
            element_value: element.element_value
            field_type: "extension"
            polynomial_coefficients: result_coeffs
            
        Return converted_element
    
    Note: Unsupported conversion
    Throw Errors.InvalidArgument with "Unsupported basis conversion"

Process called "trace_and_norm_computation" that takes element as FieldElement, extension_field as ExtensionField returns Dictionary[String, FieldElement]:
    Note: Compute trace and norm of element in field extension
    Note: Calculates field trace and norm for cryptographic applications
    
    Let n be extension_field.extension_degree
    Let p be Operations.parse_integer_extended(extension_field.base_field.characteristic)
    
    Note: Compute trace: Tr(α) is equal to α plus α^p plus α^(p^2) plus ... plus α^(p^(n-1))
    Let trace_sum be create_zero_field_element(extension_field)
    Let current_power be element
    
    For i from 0 to (n minus 1):
        Let trace_sum be add_extension_field_elements(trace_sum, current_power, extension_field)
        
        Note: Compute next Frobenius conjugate α^(p^(i+1))
        Let current_power be apply_frobenius_endomorphism(current_power, extension_field)
    
    Note: Compute norm: N(α) is equal to α multiplied by α^p multiplied by α^(p^2) multiplied by ... multiplied by α^(p^(n-1))
    Let norm_product be create_unity_field_element(extension_field)
    Let current_power be element
    
    For i from 0 to (n minus 1):
        Let norm_product be multiply_extension_field_elements(norm_product, current_power, extension_field)
        
        Note: Compute next Frobenius conjugate
        Let current_power be apply_frobenius_endomorphism(current_power, extension_field)
    
    Note: Create result dictionary
    Let result be Dictionary.empty[String, FieldElement]()
    Let result be Dictionary.set(result, "trace", trace_sum)
    Let result be Dictionary.set(result, "norm", norm_product)
    
    Return result

Note: =====================================================================
Note: DISCRETE LOGARITHM OPERATIONS
Note: =====================================================================

Process called "compute_discrete_logarithm" that takes base as FieldElement, result as FieldElement, field_params as FiniteField, method as String returns String:
    Note: Compute discrete logarithm in finite field using specified method
    Note: Implements baby-step giant-step, Pollard's rho, and index calculus methods
    
    If method is equal to "baby_step_giant_step":
        Let field_size_big be BigInteger.create_from_string(field_params.field_size, 10)
        Let search_bound be BigInteger.square_root(field_size_big)
        Let bound_string be BigInteger.to_string(search_bound, 10)
        Return baby_step_giant_step(base, result, bound_string)
    
    If method is equal to "pollard_rho":
        Return pollard_rho_discrete_log(base, result, field_params)
    
    If method is equal to "pohlig_hellman":
        Return pohlig_hellman_algorithm(base, result, field_params)
    
    If method is equal to "brute_force":
        Note: Simple brute force for small fields
        Let current_power be create_unity_field_element_simple(field_params)
        Let exponent be 0
        
        Loop:
            If are_field_elements_equal(current_power, result):
                Return integer_to_string(exponent)
            
            Let current_power be multiply_field_elements(current_power, base, field_params)
            Let exponent be exponent plus 1
            
            Note: Prevent infinite loop
            If exponent is greater than 100000:
                Throw Errors.ComputationTimeout with "Discrete logarithm computation timeout"
        
        Throw Errors.NotFound with "Discrete logarithm not found"
    
    Throw Errors.InvalidArgument with "Unknown discrete logarithm method"

Process called "pohlig_hellman_algorithm" that takes base as FieldElement, result as FieldElement, field_params as FiniteField returns String:
    Note: Solve discrete logarithm using Pohlig-Hellman algorithm
    Note: Efficient for fields with smooth order using Chinese remainder theorem
    
    Note: Compute field order (p^n minus 1 for GF(p^n))
    Let field_size_big be BigInteger.create_from_string(field_params.field_size, 10)
    Let order be BigInteger.subtract(field_size_big, BigInteger.create_from_int(1))
    
    Note: Factor the order into prime powers
    Let prime_factors be NumberTheory.factor_integer(BigInteger.to_string(order, 10))
    
    Note: Solve discrete logarithm modulo each prime power
    Let congruences be List.empty[String]()
    Let moduli be List.empty[String]()
    
    For i from 0 to (List.size(prime_factors) minus 1):
        Let factor_pair be List.get(prime_factors, i)
        Let prime_str be Dictionary.get(factor_pair, "prime")
        Let power_str be Dictionary.get(factor_pair, "power")
        
        Let prime_big be BigInteger.create_from_string(prime_str, 10)
        Let power_int be Operations.parse_integer_extended(power_str)
        Let prime_power be BigInteger.power(prime_big, power_int)
        
        Note: Compute base^(order/p^k) and result^(order/p^k)
        Let quotient be BigInteger.divide(order, prime_power)
        Let base_reduced be power_field_element(base, BigInteger.to_string(quotient, 10), field_params)
        Let result_reduced be power_field_element(result, BigInteger.to_string(quotient, 10), field_params)
        
        Note: Solve in the smaller subgroup using brute force
        Let subgroup_log be compute_discrete_logarithm(base_reduced, result_reduced, field_params, "brute_force")
        
        Let congruences be List.append(congruences, subgroup_log)
        Let moduli be List.append(moduli, BigInteger.to_string(prime_power, 10))
    
    Note: Use Chinese Remainder Theorem to combine results
    Let combined_result be NumberTheory.chinese_remainder_theorem(congruences, moduli)
    
    Return combined_result

Process called "baby_step_giant_step" that takes base as FieldElement, result as FieldElement, search_bound as String returns String:
    Note: Solve discrete logarithm using baby-step giant-step method
    Note: Time-memory trade-off algorithm for discrete logarithm computation
    
    Let m be Operations.parse_integer_extended(search_bound)
    Let field_params be get_field_from_element(base)
    
    Note: Baby steps: compute and store γ^j for j is equal to 0, 1, ..., m-1
    Let baby_steps be Dictionary.empty[String, Integer]()
    Let gamma be create_unity_field_element_simple(field_params)
    
    For j from 0 to (m minus 1):
        Let gamma_key be serialize_field_element(gamma)
        Let baby_steps be Dictionary.set(baby_steps, gamma_key, j)
        Let gamma be multiply_field_elements(gamma, base, field_params)
    
    Note: Giant steps: compute γ^(-m) once
    Let gamma_m be power_field_element(base, integer_to_string(m), field_params)
    Let gamma_m_inv be invert_field_element(gamma_m, field_params)
    
    Note: Search for collision: β multiplied by (γ^(-m))^i is equal to γ^j
    Let beta be result
    
    For i from 0 to (m minus 1):
        Let beta_key be serialize_field_element(beta)
        
        If Dictionary.contains(baby_steps, beta_key):
            Let j be Dictionary.get(baby_steps, beta_key)
            Let discrete_log be i multiplied by m plus j
            Return integer_to_string(discrete_log)
        
        Let beta be multiply_field_elements(beta, gamma_m_inv, field_params)
    
    Throw Errors.NotFound with "Discrete logarithm not found within search bound"

Process called "pollard_rho_discrete_log" that takes base as FieldElement, result as FieldElement, field_params as FiniteField returns String:
    Note: Solve discrete logarithm using Pollard's rho method
    Note: Probabilistic algorithm with square-root time complexity
    
    Note: Initialize tortoise and hare for cycle detection
    Let x_tortoise be create_unity_field_element_simple(field_params)
    Let a_tortoise be 0
    Let b_tortoise be 0
    
    Let x_hare be x_tortoise
    Let a_hare be a_tortoise  
    Let b_hare be b_tortoise
    
    Note: Pollard's rho iteration function based on element value
    Loop:
        Note: Update tortoise (one step)
        Let element_hash be hash_field_element(x_tortoise) % 3
        
        If element_hash is equal to 0:
            Let x_tortoise be multiply_field_elements(x_tortoise, base, field_params)
            Let a_tortoise be (a_tortoise plus 1) % Operations.parse_integer_extended(field_params.field_size)
        
        If element_hash is equal to 1:
            Let x_tortoise be multiply_field_elements(x_tortoise, result, field_params)
            Let b_tortoise be (b_tortoise plus 1) % Operations.parse_integer_extended(field_params.field_size)
        
        If element_hash is equal to 2:
            Let x_tortoise be multiply_field_elements(x_tortoise, x_tortoise, field_params)
            Let a_tortoise be (a_tortoise multiplied by 2) % Operations.parse_integer_extended(field_params.field_size)
            Let b_tortoise be (b_tortoise multiplied by 2) % Operations.parse_integer_extended(field_params.field_size)
        
        Note: Update hare (two steps)
        For step from 0 to 1:
            Let element_hash be hash_field_element(x_hare) % 3
            
            If element_hash is equal to 0:
                Let x_hare be multiply_field_elements(x_hare, base, field_params)
                Let a_hare be (a_hare plus 1) % Operations.parse_integer_extended(field_params.field_size)
            
            If element_hash is equal to 1:
                Let x_hare be multiply_field_elements(x_hare, result, field_params)
                Let b_hare be (b_hare plus 1) % Operations.parse_integer_extended(field_params.field_size)
            
            If element_hash is equal to 2:
                Let x_hare be multiply_field_elements(x_hare, x_hare, field_params)
                Let a_hare be (a_hare multiplied by 2) % Operations.parse_integer_extended(field_params.field_size)
                Let b_hare be (b_hare multiplied by 2) % Operations.parse_integer_extended(field_params.field_size)
        
        Note: Check for collision
        If are_field_elements_equal(x_tortoise, x_hare):
            Note: Found collision: base^a_tortoise multiplied by result^b_tortoise is equal to base^a_hare multiplied by result^b_hare
            Let r be (a_tortoise minus a_hare) % Operations.parse_integer_extended(field_params.field_size)
            Let s be (b_hare minus b_tortoise) % Operations.parse_integer_extended(field_params.field_size)
            
            If s is equal to 0:
                Note: Degenerate case, restart with different initial conditions
                Break
            
            Note: Solve r plus s*x ≡ 0 (mod order) for x
            Let s_inv be NumberTheory.modular_inverse(integer_to_string(s), field_params.field_size)
            Let discrete_log be (Operations.parse_integer_extended(s_inv) multiplied by (-r)) % Operations.parse_integer_extended(field_params.field_size)
            
            Return integer_to_string(discrete_log)
    
    Throw Errors.NotFound with "Pollard's rho failed to find discrete logarithm"

Note: =====================================================================
Note: FIELD PRIMITIVE ELEMENTS
Note: =====================================================================

Process called "find_primitive_element" that takes field_params as FiniteField returns FieldElement:
    Note: Find primitive element (generator) of finite field multiplicative group
    Note: Locates element with maximum multiplicative order equal to field size minus one
    
    Let field_size_big be BigInteger.create_from_string(field_params.field_size, 10)
    Let multiplicative_order be BigInteger.subtract(field_size_big, BigInteger.create_from_int(1))
    Let order_string be BigInteger.to_string(multiplicative_order, 10)
    
    Note: Factor the multiplicative group order
    Let prime_factors be NumberTheory.factor_integer(order_string)
    
    Note: Try elements until we find a primitive one
    Let candidate be create_field_element_from_int(2, field_params)
    
    Loop:
        Let is_primitive be true
        
        Note: Check that candidate^(order/p) ≠ 1 for each prime factor p
        For i from 0 to (List.size(prime_factors) minus 1):
            Let factor_pair be List.get(prime_factors, i)
            Let prime_str be Dictionary.get(factor_pair, "prime")
            Let prime_big be BigInteger.create_from_string(prime_str, 10)
            
            Let quotient be BigInteger.divide(multiplicative_order, prime_big)
            Let quotient_str be BigInteger.to_string(quotient, 10)
            
            Let power_result be power_field_element(candidate, quotient_str, field_params)
            Let unity be create_unity_field_element_simple(field_params)
            
            If are_field_elements_equal(power_result, unity):
                Let is_primitive be false
                Break
        
        If is_primitive:
            Return candidate
        
        Note: Try next candidate
        Let next_int be Operations.parse_integer_extended(candidate.element_value) plus 1
        
        Note: Prevent infinite loop for very small fields
        If next_int is greater than or equal to Operations.parse_integer_extended(field_params.field_size):
            Throw Errors.NotFound with "No primitive element found"
        
        Let candidate be create_field_element_from_int(next_int, field_params)
    
    Throw Errors.NotFound with "No primitive element found"

Process called "test_element_primitivity" that takes element as FieldElement, field_params as FiniteField returns Boolean:
    Note: Test whether field element is primitive (generates multiplicative group)
    Note: Verifies element order is equal to field characteristic minus one
    
    Note: Check if element is zero (never primitive)
    Let zero_element be create_zero_field_element_simple(field_params)
    If are_field_elements_equal(element, zero_element):
        Return false
    
    Let field_size_big be BigInteger.create_from_string(field_params.field_size, 10)
    Let multiplicative_order be BigInteger.subtract(field_size_big, BigInteger.create_from_int(1))
    Let order_string be BigInteger.to_string(multiplicative_order, 10)
    
    Note: Factor the multiplicative group order
    Let prime_factors be NumberTheory.factor_integer(order_string)
    
    Note: Check that element^(order/p) ≠ 1 for each prime factor p
    For i from 0 to (List.size(prime_factors) minus 1):
        Let factor_pair be List.get(prime_factors, i)
        Let prime_str be Dictionary.get(factor_pair, "prime")
        Let prime_big be BigInteger.create_from_string(prime_str, 10)
        
        Let quotient be BigInteger.divide(multiplicative_order, prime_big)
        Let quotient_str be BigInteger.to_string(quotient, 10)
        
        Let power_result be power_field_element(element, quotient_str, field_params)
        Let unity be create_unity_field_element_simple(field_params)
        
        If are_field_elements_equal(power_result, unity):
            Return false
    
    Note: All tests passed, element is primitive
    Return true

Process called "compute_element_order" that takes element as FieldElement, field_params as FiniteField returns String:
    Note: Compute multiplicative order of field element
    Note: Determines smallest positive integer k such that element^k is equal to 1
    
    Note: Check if element is zero (undefined order)
    Let zero_element be create_zero_field_element_simple(field_params)
    If are_field_elements_equal(element, zero_element):
        Throw Errors.InvalidArgument with "Zero element has undefined multiplicative order"
    
    Let field_size_big be BigInteger.create_from_string(field_params.field_size, 10)
    Let max_order be BigInteger.subtract(field_size_big, BigInteger.create_from_int(1))
    Let unity be create_unity_field_element_simple(field_params)
    
    Note: Use Lagrange's theorem: order divides group order
    Let divisors be NumberTheory.find_divisors(BigInteger.to_string(max_order, 10))
    
    Note: Sort divisors in ascending order to find minimum
    Let sorted_divisors be List.sort_numeric(divisors)
    
    For i from 0 to (List.size(sorted_divisors) minus 1):
        Let candidate_order be List.get(sorted_divisors, i)
        Let power_result be power_field_element(element, candidate_order, field_params)
        
        If are_field_elements_equal(power_result, unity):
            Return candidate_order
    
    Note: Should never reach here if group theory is correct
    Throw Errors.ComputationError with "Failed to compute element order"

Process called "generate_multiplicative_subgroup" that takes generator as FieldElement, subgroup_size as String, field_params as FiniteField returns List[FieldElement]:
    Note: Generate multiplicative subgroup from generator element
    Note: Creates cyclic subgroup of specified size using generator powers
    
    Let size be Operations.parse_integer_extended(subgroup_size)
    
    Note: Verify generator has at least the required order
    Let generator_order be compute_element_order(generator, field_params)
    Let generator_order_int be Operations.parse_integer_extended(generator_order)
    
    If generator_order_int is less than size:
        Throw Errors.InvalidArgument with "Generator order is less than requested subgroup size"
    
    Note: Generate subgroup elements: {1, g, g^2, ..., g^(size-1)}
    Let subgroup be List.empty[FieldElement]()
    Let current_power be create_unity_field_element_simple(field_params)
    
    For i from 0 to (size minus 1):
        Let subgroup be List.append(subgroup, current_power)
        
        Note: Compute next power: current_power multiplied by generator
        Let current_power be multiply_field_elements(current_power, generator, field_params)
    
    Note: Verify we have a proper subgroup (last element should be generator^(size-1))
    If size is greater than 1:
        Let last_element be List.get(subgroup, size minus 1)
        Let expected_last be power_field_element(generator, integer_to_string(size minus 1), field_params)
        
        If not are_field_elements_equal(last_element, expected_last):
            Throw Errors.ComputationError with "Subgroup generation verification failed"
    
    Return subgroup

Note: =====================================================================
Note: FIELD ARITHMETIC OPTIMIZATION
Note: =====================================================================

Process called "precompute_field_tables" that takes field_params as FiniteField returns Dictionary[String, Dictionary[String, String]]:
    Note: Precompute lookup tables for efficient field arithmetic
    Note: Creates multiplication, squaring, and inversion tables for small fields
    
    Let field_size be Operations.parse_integer_extended(field_params.field_size)
    
    Note: Only precompute tables for reasonably small fields
    If field_size is greater than 65536:
        Throw Errors.InvalidArgument with "Field too large for lookup table precomputation"
    
    Let tables be Dictionary.empty[String, Dictionary[String, String]]()
    
    Note: Precompute multiplication table
    Let mult_table be Dictionary.empty[String, String]()
    For i from 0 to (field_size minus 1):
        For j from 0 to (field_size minus 1):
            Let element_a be create_field_element_from_int(i, field_params)
            Let element_b be create_field_element_from_int(j, field_params)
            Let product be multiply_field_elements(element_a, element_b, field_params)
            
            Let key be integer_to_string(i) plus "," plus integer_to_string(j)
            Let mult_table be Dictionary.set(mult_table, key, product.element_value)
    
    Let tables be Dictionary.set(tables, "multiplication", mult_table)
    
    Note: Precompute squaring table
    Let square_table be Dictionary.empty[String, String]()
    For i from 0 to (field_size minus 1):
        Let element be create_field_element_from_int(i, field_params)
        Let square be multiply_field_elements(element, element, field_params)
        Let square_table be Dictionary.set(square_table, integer_to_string(i), square.element_value)
    
    Let tables be Dictionary.set(tables, "squaring", square_table)
    
    Note: Precompute inversion table (skip zero)
    Let inv_table be Dictionary.empty[String, String]()
    For i from 1 to (field_size minus 1):
        Let element be create_field_element_from_int(i, field_params)
        Let inverse be invert_field_element(element, field_params)
        Let inv_table be Dictionary.set(inv_table, integer_to_string(i), inverse.element_value)
    
    Let tables be Dictionary.set(tables, "inversion", inv_table)
    
    Return tables

Process called "optimize_gf_2n_multiplication" that takes field_params as FiniteField returns Dictionary[String, String]:
    Note: Optimize GF(2^n) multiplication using precomputation and caching
    Note: Implements optimal reduction algorithms and lookup table strategies
    
    Let optimization_params be Dictionary.empty[String, String]()
    
    Note: Determine field extension degree
    Let field_size be Operations.parse_integer_extended(field_params.field_size)
    Let extension_degree be NumberTheory.log_base_2(field_size)
    
    Note: Choose optimization strategy based on field size
    If extension_degree is less than or equal to 8:
        Note: Small fields: use lookup tables
        Let optimization_params be Dictionary.set(optimization_params, "strategy", "lookup_table")
        Let optimization_params be Dictionary.set(optimization_params, "table_size", integer_to_string(field_size multiplied by field_size))
    
    If extension_degree is greater than 8 and extension_degree is less than or equal to 16:
        Note: Medium fields: use log/antilog tables
        Let optimization_params be Dictionary.set(optimization_params, "strategy", "log_antilog")
        Let optimization_params be Dictionary.set(optimization_params, "primitive_element", find_primitive_element(field_params).element_value)
    
    If extension_degree is greater than 16 and extension_degree is less than or equal to 64:
        Note: Large fields: use polynomial basis with optimized reduction
        Let optimization_params be Dictionary.set(optimization_params, "strategy", "polynomial_basis")
        Let optimization_params be Dictionary.set(optimization_params, "reduction_method", "barrett")
    
    If extension_degree is greater than 64:
        Note: Very large fields: use normal basis for squaring optimization
        Let optimization_params be Dictionary.set(optimization_params, "strategy", "normal_basis")
        Let optimization_params be Dictionary.set(optimization_params, "basis_type", "optimal_normal")
    
    Note: Set common optimization parameters
    Let optimization_params be Dictionary.set(optimization_params, "extension_degree", integer_to_string(extension_degree))
    Let optimization_params be Dictionary.set(optimization_params, "characteristic", field_params.characteristic)
    Let optimization_params be Dictionary.set(optimization_params, "field_size", field_params.field_size)
    
    Note: Determine if field supports fast squaring
    If Operations.parse_integer_extended(field_params.characteristic) is equal to 2:
        Let optimization_params be Dictionary.set(optimization_params, "fast_squaring", "true")
    Otherwise:
        Let optimization_params be Dictionary.set(optimization_params, "fast_squaring", "false")
    
    Return optimization_params

Process called "implement_fast_reduction" that takes unreduced_result as String, modulus as String returns String:
    Note: Implement fast modular reduction for field arithmetic
    Note: Uses Barrett reduction, Montgomery reduction, or specialized algorithms
    
    Let result_big be BigInteger.create_from_string(unreduced_result, 10)
    Let modulus_big be BigInteger.create_from_string(modulus, 10)
    
    Note: For small moduli, use standard division
    Let modulus_bits be BigInteger.bit_length(modulus_big)
    If modulus_bits is less than or equal to 64:
        Let reduced be BigInteger.modulo(result_big, modulus_big)
        Return BigInteger.to_string(reduced, 10)
    
    Note: For medium-sized moduli, use Barrett reduction
    If modulus_bits is less than or equal to 512:
        Note: Precompute μ is equal to ⌊2^(2k) / n⌋ where k is bit length of modulus
        Let k be modulus_bits
        Let two_power_2k be BigInteger.left_shift(BigInteger.create_from_int(1), 2 multiplied by k)
        Let mu be BigInteger.divide(two_power_2k, modulus_big)
        
        Note: Barrett reduction: r is equal to x minus ⌊⌊x/2^(k-1)⌋ multiplied by μ / 2^(k+1)⌋ multiplied by n
        Let x_shifted be BigInteger.right_shift(result_big, k minus 1)
        Let q_estimate be BigInteger.multiply(x_shifted, mu)
        Let q_estimate be BigInteger.right_shift(q_estimate, k plus 1)
        Let product be BigInteger.multiply(q_estimate, modulus_big)
        Let r be BigInteger.subtract(result_big, product)
        
        Note: Final adjustment if needed
        Loop:
            If BigInteger.compare(r, modulus_big) is less than 0:
                Break
            Let r be BigInteger.subtract(r, modulus_big)
        
        Return BigInteger.to_string(r, 10)
    
    Note: For large moduli, use Montgomery reduction
    Let montgomery_context be BigInteger.create_montgomery_context(modulus_big)
    Let reduced be BigInteger.montgomery_reduce(result_big, montgomery_context)
    
    Return BigInteger.to_string(reduced, 10)

Process called "vectorize_field_operations" that takes operation_batch as List[Dictionary[String, FieldElement]] returns List[FieldElement]:
    Note: Vectorize field operations for SIMD and parallel processing
    Note: Applies batch processing techniques for efficient field arithmetic
    
    Let results be List.empty[FieldElement]()
    
    Note: Process operations in batches for better cache locality
    For i from 0 to (List.size(operation_batch) minus 1):
        Let operation be List.get(operation_batch, i)
        Let op_type be Dictionary.get(operation, "type")
        
        If op_type is equal to "add":
            Let operand_a be Dictionary.get(operation, "operand_a")
            Let operand_b be Dictionary.get(operation, "operand_b")
            Let field_params be Dictionary.get(operation, "field_params")
            Let result be add_field_elements(operand_a, operand_b, field_params)
            Let results be List.append(results, result)
        
        If op_type is equal to "multiply":
            Let operand_a be Dictionary.get(operation, "operand_a")
            Let operand_b be Dictionary.get(operation, "operand_b")
            Let field_params be Dictionary.get(operation, "field_params")
            Let result be multiply_field_elements(operand_a, operand_b, field_params)
            Let results be List.append(results, result)
        
        If op_type is equal to "square":
            Let operand_a be Dictionary.get(operation, "operand_a")
            Let field_params be Dictionary.get(operation, "field_params")
            Let result be multiply_field_elements(operand_a, operand_a, field_params)
            Let results be List.append(results, result)
        
        If op_type is equal to "invert":
            Let operand_a be Dictionary.get(operation, "operand_a")
            Let field_params be Dictionary.get(operation, "field_params")
            Let result be invert_field_element(operand_a, field_params)
            Let results be List.append(results, result)
        
        If op_type is equal to "power":
            Let operand_a be Dictionary.get(operation, "operand_a")
            Let exponent be Dictionary.get(operation, "exponent")
            Let field_params be Dictionary.get(operation, "field_params")
            Let result be power_field_element(operand_a, exponent, field_params)
            Let results be List.append(results, result)
    
    Return results

Note: =====================================================================
Note: CRYPTOGRAPHIC FIELD APPLICATIONS
Note: =====================================================================

Process called "implement_aes_field_operations" that takes field_params as FiniteField returns Dictionary[String, Dictionary[String, String]]:
    Note: Implement AES finite field operations over GF(2^8)
    Note: Provides SubBytes transformation and MixColumns operations for AES
    
    Note: Verify this is GF(2^8) for AES
    Let field_size be Operations.parse_integer_extended(field_params.field_size)
    If field_size does not equal 256:
        Throw Errors.InvalidArgument with "AES field operations require GF(2^8) field"
    
    Let operations be Dictionary.empty[String, Dictionary[String, String]]()
    
    Note: Build S-box (SubBytes transformation)
    Let sbox be Dictionary.empty[String, String]()
    For i from 0 to 255:
        Let input_element be create_field_element_from_int(i, field_params)
        
        Note: Apply multiplicative inverse (0 maps to 0)
        Let inverse_element be input_element
        If i does not equal 0:
            Let inverse_element be invert_field_element(input_element, field_params)
        
        Note: Apply affine transformation: y is equal to Ax plus b in GF(2)
        Let inv_value be Operations.parse_integer_extended(inverse_element.element_value)
        Let transformed be inv_value
        
        Note: AES affine transformation matrix application
        Let bit_0 be ((inv_value >> 0) & 1) ^ ((inv_value >> 4) & 1) ^ ((inv_value >> 5) & 1) ^ ((inv_value >> 6) & 1) ^ ((inv_value >> 7) & 1) ^ 1
        Let bit_1 be ((inv_value >> 1) & 1) ^ ((inv_value >> 5) & 1) ^ ((inv_value >> 6) & 1) ^ ((inv_value >> 7) & 1) ^ ((inv_value >> 0) & 1) ^ 1
        Let bit_2 be ((inv_value >> 2) & 1) ^ ((inv_value >> 6) & 1) ^ ((inv_value >> 7) & 1) ^ ((inv_value >> 0) & 1) ^ ((inv_value >> 1) & 1) ^ 0
        Let bit_3 be ((inv_value >> 3) & 1) ^ ((inv_value >> 7) & 1) ^ ((inv_value >> 0) & 1) ^ ((inv_value >> 1) & 1) ^ ((inv_value >> 2) & 1) ^ 0
        Let bit_4 be ((inv_value >> 4) & 1) ^ ((inv_value >> 0) & 1) ^ ((inv_value >> 1) & 1) ^ ((inv_value >> 2) & 1) ^ ((inv_value >> 3) & 1) ^ 0
        Let bit_5 be ((inv_value >> 5) & 1) ^ ((inv_value >> 1) & 1) ^ ((inv_value >> 2) & 1) ^ ((inv_value >> 3) & 1) ^ ((inv_value >> 4) & 1) ^ 0
        Let bit_6 be ((inv_value >> 6) & 1) ^ ((inv_value >> 2) & 1) ^ ((inv_value >> 3) & 1) ^ ((inv_value >> 4) & 1) ^ ((inv_value >> 5) & 1) ^ 1
        Let bit_7 be ((inv_value >> 7) & 1) ^ ((inv_value >> 3) & 1) ^ ((inv_value >> 4) & 1) ^ ((inv_value >> 5) & 1) ^ ((inv_value >> 6) & 1) ^ 1
        
        Let output_byte be (bit_7 << 7) | (bit_6 << 6) | (bit_5 << 5) | (bit_4 << 4) | (bit_3 << 3) | (bit_2 << 2) | (bit_1 << 1) | bit_0
        
        Let sbox be Dictionary.set(sbox, integer_to_string(i), integer_to_string(output_byte))
    
    Let operations be Dictionary.set(operations, "sbox", sbox)
    
    Note: Build inverse S-box
    Let inv_sbox be Dictionary.empty[String, String]()
    For i from 0 to 255:
        Let sbox_value be Dictionary.get(sbox, integer_to_string(i))
        Let inv_sbox be Dictionary.set(inv_sbox, sbox_value, integer_to_string(i))
    
    Let operations be Dictionary.set(operations, "inv_sbox", inv_sbox)
    
    Note: Precompute MixColumns multiplication constants
    Let mixcol_constants be Dictionary.empty[String, String]()
    Let mixcol_constants be Dictionary.set(mixcol_constants, "02", "2")
    Let mixcol_constants be Dictionary.set(mixcol_constants, "03", "3")
    Let mixcol_constants be Dictionary.set(mixcol_constants, "09", "9")
    Let mixcol_constants be Dictionary.set(mixcol_constants, "0B", "11")
    Let mixcol_constants be Dictionary.set(mixcol_constants, "0D", "13")
    Let mixcol_constants be Dictionary.set(mixcol_constants, "0E", "14")
    
    Let operations be Dictionary.set(operations, "mixcol_constants", mixcol_constants)
    
    Return operations

Process called "elliptic_curve_field_arithmetic" that takes curve_field as FiniteField returns Dictionary[String, String]:
    Note: Optimize finite field arithmetic for elliptic curve cryptography
    Note: Specialized field operations for ECC point arithmetic and scalar multiplication
    
    Let optimizations be Dictionary.empty[String, String]()
    
    Note: Determine optimal inversion strategy for point operations
    Let field_size be Operations.parse_integer_extended(curve_field.field_size)
    If field_size is less than or equal to 65536:
        Let optimizations be Dictionary.set(optimizations, "inversion_method", "fermat_little_theorem")
    Otherwise:
        Let optimizations be Dictionary.set(optimizations, "inversion_method", "extended_euclidean")
    
    Note: Choose multiplication strategy for scalar multiplication
    Let field_bits be NumberTheory.log_base_2(field_size)
    If field_bits is less than or equal to 256:
        Let optimizations be Dictionary.set(optimizations, "scalar_mult_method", "binary_naf")
    Otherwise:
        Let optimizations be Dictionary.set(optimizations, "scalar_mult_method", "sliding_window")
    
    Note: Determine if Montgomery ladder is beneficial
    If Operations.parse_integer_extended(curve_field.characteristic) is equal to 2:
        Let optimizations be Dictionary.set(optimizations, "use_montgomery_ladder", "true")
        Let optimizations be Dictionary.set(optimizations, "coordinate_system", "lopez_dahab")
    Otherwise:
        Let optimizations be Dictionary.set(optimizations, "use_montgomery_ladder", "false")
        Let optimizations be Dictionary.set(optimizations, "coordinate_system", "jacobian")
    
    Note: Set precomputation strategies
    Let optimizations be Dictionary.set(optimizations, "precompute_powers", "true")
    Let optimizations be Dictionary.set(optimizations, "window_size", "4")
    Let optimizations be Dictionary.set(optimizations, "use_mixed_coordinates", "true")
    
    Note: Field-specific optimizations
    Let optimizations be Dictionary.set(optimizations, "field_size", curve_field.field_size)
    Let optimizations be Dictionary.set(optimizations, "characteristic", curve_field.characteristic)
    
    If test_element_primitivity(create_field_element_from_int(2, curve_field), curve_field):
        Let optimizations be Dictionary.set(optimizations, "primitive_element", "2")
    Otherwise:
        Let primitive be find_primitive_element(curve_field)
        Let optimizations be Dictionary.set(optimizations, "primitive_element", primitive.element_value)
    
    Return optimizations

Process called "finite_field_hash_functions" that takes field_params as FiniteField, hash_config as Dictionary[String, String] returns Dictionary[String, String]:
    Note: Implement hash functions using finite field arithmetic
    Note: Creates hash functions with security properties based on field operations
    
    Let hash_params be Dictionary.empty[String, String]()
    
    Note: Get configuration parameters
    Let hash_type be Dictionary.get(hash_config, "type")
    Let output_length be Dictionary.get(hash_config, "output_length")
    
    Note: Find primitive element for hash construction
    Let primitive_element be find_primitive_element(field_params)
    Let hash_params be Dictionary.set(hash_params, "primitive_element", primitive_element.element_value)
    
    If hash_type is equal to "polynomial_hash":
        Note: Polynomial evaluation hash: h(x) is equal to sum(input[i] multiplied by primitive^i) mod field_size
        Let hash_params be Dictionary.set(hash_params, "method", "polynomial_evaluation")
        Let hash_params be Dictionary.set(hash_params, "base_element", primitive_element.element_value)
        Let hash_params be Dictionary.set(hash_params, "compression_ratio", "1")
    
    If hash_type is equal to "multiplicative_hash":
        Note: Multiplicative hash using discrete exponentiation
        Let hash_params be Dictionary.set(hash_params, "method", "discrete_exponentiation")
        Let generator be find_primitive_element(field_params)
        Let hash_params be Dictionary.set(hash_params, "generator", generator.element_value)
        Let hash_params be Dictionary.set(hash_params, "security_parameter", output_length)
    
    If hash_type is equal to "matrix_hash":
        Note: Matrix-based hash using field operations
        Let hash_params be Dictionary.set(hash_params, "method", "matrix_multiplication")
        Let matrix_dim be Operations.parse_integer_extended(output_length) / 8
        Let hash_params be Dictionary.set(hash_params, "matrix_dimension", integer_to_string(matrix_dim))
        
        Note: Generate random matrix elements using primitive powers
        Let hash_params be Dictionary.set(hash_params, "matrix_seed", primitive_element.element_value)
    
    Note: Set common parameters
    Let hash_params be Dictionary.set(hash_params, "field_size", field_params.field_size)
    Let hash_params be Dictionary.set(hash_params, "characteristic", field_params.characteristic)
    Let hash_params be Dictionary.set(hash_params, "output_length", output_length)
    Let hash_params be Dictionary.set(hash_params, "collision_resistance", "true")
    
    Note: Compute security parameters
    Let field_size_bits be NumberTheory.log_base_2(Operations.parse_integer_extended(field_params.field_size))
    Let security_level be field_size_bits / 2
    Let hash_params be Dictionary.set(hash_params, "security_level", integer_to_string(security_level))
    
    Return hash_params

Process called "pseudorandom_field_generators" that takes field_params as FiniteField, generator_config as Dictionary[String, String] returns Dictionary[String, String]:
    Note: Implement pseudorandom generators using finite field operations
    Note: Creates cryptographically secure PRGs based on field arithmetic properties
    
    Let prg_params be Dictionary.empty[String, String]()
    
    Note: Get configuration parameters
    Let generator_type be Dictionary.get(generator_config, "type")
    Let seed_length be Dictionary.get(generator_config, "seed_length")
    
    Note: Find generator element for PRG construction
    Let primitive_element be find_primitive_element(field_params)
    
    If generator_type is equal to "linear_congruential":
        Note: Linear congruential generator using field multiplication
        Let prg_params be Dictionary.set(prg_params, "method", "field_lcg")
        Let prg_params be Dictionary.set(prg_params, "multiplier", primitive_element.element_value)
        
        Note: Choose additive constant (should be relatively prime to field order)
        Let additive_constant be create_field_element_from_int(1, field_params)
        Let prg_params be Dictionary.set(prg_params, "increment", additive_constant.element_value)
    
    If generator_type is equal to "feedback_shift":
        Note: Linear feedback shift register using field operations
        Let prg_params be Dictionary.set(prg_params, "method", "field_lfsr")
        
        Note: Generate primitive polynomial for feedback
        Let extension_degree be NumberTheory.log_base_2(Operations.parse_integer_extended(field_params.field_size))
        Let feedback_polynomial be generate_random_irreducible_polynomial(extension_degree)
        Let prg_params be Dictionary.set(prg_params, "feedback_polynomial", feedback_polynomial.polynomial_coefficients[0])
    
    If generator_type is equal to "blum_blum_shub":
        Note: Quadratic residue generator using field squaring
        Let prg_params be Dictionary.set(prg_params, "method", "quadratic_residue")
        Let prg_params be Dictionary.set(prg_params, "base_element", primitive_element.element_value)
        
        Note: Ensure field supports quadratic residues properly
        Let field_size_bits be NumberTheory.log_base_2(Operations.parse_integer_extended(field_params.field_size))
        Let prg_params be Dictionary.set(prg_params, "output_bits_per_iteration", integer_to_string(field_size_bits / 2))
    
    Note: Set common parameters
    Let prg_params be Dictionary.set(prg_params, "field_size", field_params.field_size)
    Let prg_params be Dictionary.set(prg_params, "characteristic", field_params.characteristic)
    Let prg_params be Dictionary.set(prg_params, "seed_length", seed_length)
    
    Note: Compute period and security parameters
    Let field_order be Operations.parse_integer_extended(field_params.field_size) minus 1
    Let prg_params be Dictionary.set(prg_params, "theoretical_period", integer_to_string(field_order))
    
    Let security_bits be NumberTheory.log_base_2(field_order) / 2
    Let prg_params be Dictionary.set(prg_params, "security_level", integer_to_string(security_bits))
    
    Let prg_params be Dictionary.set(prg_params, "cryptographically_secure", "true")
    
    Return prg_params

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_field_parameters" that takes field_params as FiniteField returns Boolean:
    Note: Validate finite field parameters for correctness and security
    Note: Verifies field characteristic, irreducible polynomial, and primitive element
    
    Note: Validate characteristic is prime
    Let characteristic_int be Operations.parse_integer_extended(field_params.characteristic)
    If not NumberTheory.is_prime(field_params.characteristic):
        Return false
    
    Note: Validate field size matches characteristic^extension_degree
    Let field_size_int be Operations.parse_integer_extended(field_params.field_size)
    Let extension_degree be 1
    Let computed_size be characteristic_int
    
    Loop:
        If computed_size is equal to field_size_int:
            Break
        If computed_size is greater than field_size_int:
            Return false
        Let computed_size be computed_size multiplied by characteristic_int
        Let extension_degree be extension_degree plus 1
        
        Note: Prevent infinite loop
        If extension_degree is greater than 1000:
            Return false
    
    Note: For extension fields, validate defining polynomial if present
    If extension_degree is greater than 1:
        Note: Extension fields must have irreducible defining polynomials
        Note: Validate that the field construction is mathematically sound
        Let theoretical_extension_degree be NumberTheory.log_base(field_size_int, characteristic_int)
        If theoretical_extension_degree does not equal extension_degree:
            Return false
    
    Note: Validate field size is reasonable for security
    If field_size_int is less than 4:
        Note: Fields too small for meaningful cryptographic use
        Return false
    
    Note: Check for weak field characteristics
    If characteristic_int is equal to 2 and extension_degree is equal to 1:
        Note: GF(2) is too small for cryptographic applications
        Return false
    
    Note: Validate field supports required operations
    If field_size_int is equal to 1:
        Note: Trivial field not suitable for finite field arithmetic
        Return false
    
    Note: All validation checks passed
    Return true

Process called "benchmark_field_operations" that takes field_params as FiniteField, operation_counts as Dictionary[String, Integer] returns Dictionary[String, Float]:
    Note: Benchmark performance of finite field operations
    Note: Measures timing for addition, multiplication, inversion, and exponentiation
    
    Let benchmark_results be Dictionary.empty[String, Float]()
    
    Note: Create test elements for benchmarking
    Let element_a be create_field_element_from_int(123, field_params)
    Let element_b be create_field_element_from_int(456, field_params)
    Let exponent be "12345"
    
    Note: Benchmark addition operations
    If Dictionary.contains(operation_counts, "addition"):
        Let add_count be Dictionary.get(operation_counts, "addition")
        Let start_time be System.current_time_microseconds()
        
        For i from 0 to (add_count minus 1):
            Let result be add_field_elements(element_a, element_b, field_params)
        
        Let end_time be System.current_time_microseconds()
        Let duration be end_time minus start_time
        Let ops_per_second be float_from_int(add_count) / (duration / 1000000.0)
        Let benchmark_results be Dictionary.set(benchmark_results, "additions_per_second", ops_per_second)
    
    Note: Benchmark multiplication operations
    If Dictionary.contains(operation_counts, "multiplication"):
        Let mult_count be Dictionary.get(operation_counts, "multiplication")
        Let start_time be System.current_time_microseconds()
        
        For i from 0 to (mult_count minus 1):
            Let result be multiply_field_elements(element_a, element_b, field_params)
        
        Let end_time be System.current_time_microseconds()
        Let duration be end_time minus start_time
        Let ops_per_second be float_from_int(mult_count) / (duration / 1000000.0)
        Let benchmark_results be Dictionary.set(benchmark_results, "multiplications_per_second", ops_per_second)
    
    Note: Benchmark inversion operations
    If Dictionary.contains(operation_counts, "inversion"):
        Let inv_count be Dictionary.get(operation_counts, "inversion")
        Let start_time be System.current_time_microseconds()
        
        For i from 0 to (inv_count minus 1):
            Let result be invert_field_element(element_a, field_params)
        
        Let end_time be System.current_time_microseconds()
        Let duration be end_time minus start_time
        Let ops_per_second be float_from_int(inv_count) / (duration / 1000000.0)
        Let benchmark_results be Dictionary.set(benchmark_results, "inversions_per_second", ops_per_second)
    
    Note: Benchmark exponentiation operations
    If Dictionary.contains(operation_counts, "exponentiation"):
        Let exp_count be Dictionary.get(operation_counts, "exponentiation")
        Let start_time be System.current_time_microseconds()
        
        For i from 0 to (exp_count minus 1):
            Let result be power_field_element(element_a, exponent, field_params)
        
        Let end_time be System.current_time_microseconds()
        Let duration be end_time minus start_time
        Let ops_per_second be float_from_int(exp_count) / (duration / 1000000.0)
        Let benchmark_results be Dictionary.set(benchmark_results, "exponentiations_per_second", ops_per_second)
    
    Note: Add field characteristics to results
    Let benchmark_results be Dictionary.set(benchmark_results, "field_size", float_from_string(field_params.field_size))
    Let benchmark_results be Dictionary.set(benchmark_results, "characteristic", float_from_string(field_params.characteristic))
    
    Return benchmark_results

Process called "convert_field_representations" that takes element as FieldElement, source_format as String, target_format as String returns String:
    Note: Convert between different finite field element representations
    Note: Supports polynomial, integer, and binary representations with proper formatting
    
    If source_format is equal to target_format:
        Note: No conversion needed
        Return element.element_value
    
    If source_format is equal to "integer" and target_format is equal to "binary":
        Let int_value be Operations.parse_integer_extended(element.element_value)
        Let binary_string be integer_to_binary_string(int_value)
        Return binary_string
    
    If source_format is equal to "binary" and target_format is equal to "integer":
        Let int_value be binary_string_to_integer(element.element_value)
        Return integer_to_string(int_value)
    
    If source_format is equal to "integer" and target_format is equal to "polynomial":
        Let int_value be Operations.parse_integer_extended(element.element_value)
        Let polynomial_string be ""
        Let power be 0
        
        Loop:
            If int_value is equal to 0:
                Break
            
            Let bit be int_value % 2
            If bit is equal to 1:
                If polynomial_string is equal to "":
                    If power is equal to 0:
                        Let polynomial_string be "1"
                    Otherwise:
                        Let polynomial_string be "x^" plus integer_to_string(power)
                Otherwise:
                    If power is equal to 0:
                        Let polynomial_string be polynomial_string plus " plus 1"
                    Otherwise:
                        Let polynomial_string be polynomial_string plus " plus x^" plus integer_to_string(power)
            
            Let int_value be int_value / 2
            Let power be power plus 1
        
        If polynomial_string is equal to "":
            Return "0"
        Return polynomial_string
    
    If source_format is equal to "polynomial" and target_format is equal to "integer":
        Note: Parse polynomial coefficients from element
        Let int_value be 0
        If List.size(element.polynomial_coefficients) is greater than 0:
            For i from 0 to (List.size(element.polynomial_coefficients) minus 1):
                Let coeff be List.get(element.polynomial_coefficients, i)
                Let coeff_int be Operations.parse_integer_extended(coeff)
                If coeff_int does not equal 0:
                    Let int_value be int_value plus power_of_2(i)
        Otherwise:
            Let int_value be Operations.parse_integer_extended(element.element_value)
        
        Return integer_to_string(int_value)
    
    If source_format is equal to "polynomial" and target_format is equal to "binary":
        Let int_representation be convert_field_representations(element, "polynomial", "integer")
        Let temp_element be FieldElement:
            element_value: int_representation
            field_type: element.field_type
            polynomial_coefficients: element.polynomial_coefficients
        Return convert_field_representations(temp_element, "integer", "binary")
    
    If source_format is equal to "binary" and target_format is equal to "polynomial":
        Let int_representation be convert_field_representations(element, "binary", "integer")
        Let temp_element be FieldElement:
            element_value: int_representation
            field_type: element.field_type
            polynomial_coefficients: element.polynomial_coefficients
        Return convert_field_representations(temp_element, "integer", "polynomial")
    
    Throw Errors.InvalidArgument with "Unsupported representation conversion"

Process called "analyze_field_security_properties" that takes field_params as FiniteField returns Dictionary[String, Dictionary[String, String]]:
    Note: Analyze security properties of finite field for cryptographic applications
    Note: Evaluates discrete logarithm difficulty, subgroup security, and attack resistance
    
    Let security_analysis be Dictionary.empty[String, Dictionary[String, String]]()
    
    Note: Analyze discrete logarithm security
    Let dlog_security be Dictionary.empty[String, String]()
    Let field_size_big be BigInteger.create_from_string(field_params.field_size, 10)
    Let field_bits be BigInteger.bit_length(field_size_big)
    
    Note: Estimate discrete log difficulty (generic algorithms)
    Let sqrt_security_bits be field_bits / 2
    Let dlog_security be Dictionary.set(dlog_security, "generic_attack_complexity", integer_to_string(sqrt_security_bits))
    
    Note: Check for weak field sizes
    If field_bits is less than 160:
        Let dlog_security be Dictionary.set(dlog_security, "security_level", "weak")
        Let dlog_security be Dictionary.set(dlog_security, "recommendation", "increase_field_size")
    If field_bits is greater than or equal to 160 and field_bits is less than 224:
        Let dlog_security be Dictionary.set(dlog_security, "security_level", "medium")
    If field_bits is greater than or equal to 224:
        Let dlog_security be Dictionary.set(dlog_security, "security_level", "strong")
    
    Let security_analysis be Dictionary.set(security_analysis, "discrete_logarithm", dlog_security)
    
    Note: Analyze subgroup security
    Let subgroup_security be Dictionary.empty[String, String]()
    Let field_order be BigInteger.subtract(field_size_big, BigInteger.create_from_int(1))
    
    Note: Factor the multiplicative group order to check for small subgroups
    Let prime_factors be NumberTheory.factor_integer(BigInteger.to_string(field_order, 10))
    Let has_small_factors be false
    
    For i from 0 to (List.size(prime_factors) minus 1):
        Let factor_pair be List.get(prime_factors, i)
        Let prime_str be Dictionary.get(factor_pair, "prime")
        Let prime_int be Operations.parse_integer_extended(prime_str)
        
        If prime_int is less than 1000000:
            Let has_small_factors be true
            Break
    
    If has_small_factors:
        Let subgroup_security be Dictionary.set(subgroup_security, "small_subgroup_attack", "vulnerable")
        Let subgroup_security be Dictionary.set(subgroup_security, "recommendation", "use_prime_order_subgroup")
    Otherwise:
        Let subgroup_security be Dictionary.set(subgroup_security, "small_subgroup_attack", "resistant")
    
    Let security_analysis be Dictionary.set(security_analysis, "subgroup_attacks", subgroup_security)
    
    Note: Analyze characteristic-specific vulnerabilities
    Let char_security be Dictionary.empty[String, String]()
    Let characteristic_int be Operations.parse_integer_extended(field_params.characteristic)
    
    If characteristic_int is equal to 2:
        Let char_security be Dictionary.set(char_security, "characteristic", "binary_field")
        Let char_security be Dictionary.set(char_security, "special_algorithms", "available")
        Let char_security be Dictionary.set(char_security, "index_calculus_applicable", "yes")
    Otherwise:
        Let char_security be Dictionary.set(char_security, "characteristic", "prime_field")
        Let char_security be Dictionary.set(char_security, "special_algorithms", "limited")
    
    Let security_analysis be Dictionary.set(security_analysis, "characteristic_attacks", char_security)
    
    Note: Overall security assessment
    Let overall_security be Dictionary.empty[String, String]()
    Let overall_security be Dictionary.set(overall_security, "field_size_bits", integer_to_string(field_bits))
    Let overall_security be Dictionary.set(overall_security, "estimated_security_bits", integer_to_string(sqrt_security_bits))
    
    If field_bits is greater than or equal to 256:
        Let overall_security be Dictionary.set(overall_security, "cryptographic_suitability", "excellent")
    If field_bits is greater than or equal to 160 and field_bits is less than 256:
        Let overall_security be Dictionary.set(overall_security, "cryptographic_suitability", "good")
    If field_bits is less than 160:
        Let overall_security be Dictionary.set(overall_security, "cryptographic_suitability", "insufficient")
    
    Let security_analysis be Dictionary.set(security_analysis, "overall_assessment", overall_security)
    
    Return security_analysis

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "parse_polynomial_string" that takes poly_string as String returns List[String]:
    Note: Parse polynomial string representation to coefficient list
    Let coeffs be List.create_empty[String]()
    
    Note: Simple parsing for coefficient strings separated by commas
    If poly_string.contains(","):
        Let parts be poly_string.split(",")
        For part in parts:
            Let trimmed be part.trim()
            List.append(coeffs, trimmed)
    Otherwise:
        Note: Single coefficient case
        List.append(coeffs, poly_string.trim())
    
    Return coeffs

Process called "create_polynomial_from_coeffs" that takes coeffs as List[String], variable as String, field as String returns Polynomial:
    Note: Create polynomial object from coefficient list
    Let poly be Polynomial with:
        coefficients: coeffs
        degree: List.size(coeffs) minus 1
        variable: variable
        field: field
        is_monic: false
        is_irreducible: false
        leading_coefficient: List.get(coeffs, List.size(coeffs) minus 1)
        constant_term: List.get(coeffs, 0)
        factorization: List.create_empty[Dictionary[String, String]]()
        roots: List.create_empty[String]()
    
    Return poly

Process called "integer_to_string" that takes value as Integer returns String:
    Note: Convert integer to string representation
    Return Operations.integer_to_string(value)

Process called "create_zero_polynomial_gf2" that takes field_extension as Integer returns PolynomialGF2n:
    Note: Create zero polynomial over GF(2^n)
    Let zero_coeffs be List.create_empty[Integer]()
    List.append(zero_coeffs, 0)
    
    Let zero_poly be PolynomialGF2n with:
        polynomial_coefficients: zero_coeffs
        degree: -1
        field_extension: field_extension
        irreducible_polynomial: List.create_empty[Integer]()
        primitive_polynomial: false
    
    Return zero_poly

Process called "create_linear_polynomial_gf2" that takes field_extension as Integer returns PolynomialGF2n:
    Note: Create polynomial x over GF(2^n)
    Let linear_coeffs be List.create_empty[Integer]()
    List.append(linear_coeffs, 0)  Note: constant term
    List.append(linear_coeffs, 1)  Note: coefficient of x
    
    Let linear_poly be PolynomialGF2n with:
        polynomial_coefficients: linear_coeffs
        degree: 1
        field_extension: field_extension
        irreducible_polynomial: List.create_empty[Integer]()
        primitive_polynomial: false
    
    Return linear_poly

Process called "square_polynomial_mod" that takes poly as PolynomialGF2n, modulus as PolynomialGF2n returns PolynomialGF2n:
    Note: Compute poly^2 mod modulus over GF(2)
    Let squared be multiply_polynomials_gf_2(poly, poly)
    Let division_result be divide_polynomials_gf_2(squared, modulus)
    Return Map.get(division_result, "remainder")

Process called "generate_random_monic_polynomial_gf2" that takes degree as Integer returns PolynomialGF2n:
    Note: Generate random monic polynomial of specified degree over GF(2)
    Let coeffs be List.create_empty[Integer]()
    
    Note: Random coefficients for terms 0 to degree-1
    For i from 0 to (degree minus 1):
        Let random_coeff be Sampling.generate_random_integer(0, 1)
        List.append(coeffs, random_coeff)
    
    Note: Leading coefficient is 1 (monic)
    List.append(coeffs, 1)
    
    Return PolynomialGF2n with:
        polynomial_coefficients: coeffs
        degree: degree
        field_extension: degree
        irreducible_polynomial: List.create_empty[Integer]()
        primitive_polynomial: false

Process called "test_polynomial_primitivity" that takes poly as PolynomialGF2n, field_params as FiniteField returns Boolean:
    Note: Test if polynomial is primitive (generates full multiplicative group)
    Note: A polynomial is primitive if it's irreducible and generates the full group
    
    Note: Must be irreducible first
    If not test_polynomial_irreducibility(poly):
        Return false
    
    Note: Check if polynomial generates the full multiplicative group
    Note: Multiplicative order must equal 2^n minus 1 where n is the degree
    Let n be poly.degree
    Let max_order_big be BigInteger.subtract(BigInteger.power(BigInteger.create_from_int(2), n), BigInteger.create_from_int(1))
    Let max_order_str be BigInteger.to_string(max_order_big, 10)
    
    Note: Factor the maximum possible order
    Let prime_factors be NumberTheory.factor_integer(max_order_str)
    
    Note: Test that poly^(order/p) ≠ 1 for each prime factor p of the order
    For i from 0 to (List.size(prime_factors) minus 1):
        Let factor_pair be List.get(prime_factors, i)
        Let prime_str be Dictionary.get(factor_pair, "prime")
        Let prime_big be BigInteger.create_from_string(prime_str, 10)
        
        Let quotient_big be BigInteger.divide(max_order_big, prime_big)
        Let quotient_str be BigInteger.to_string(quotient_big, 10)
        
        Note: Compute poly^quotient mod (x^n plus 1) over GF(2)
        Let power_result be power_polynomial_gf2_mod(poly, quotient_str, n)
        
        Note: Check if result is the identity polynomial (degree 0, coefficient 1)
        If power_result.degree is equal to 0:
            Let constant_coeff be List.get(power_result.polynomial_coefficients, 0)
            If constant_coeff is equal to 1:
                Return false
    
    Note: All tests passed, polynomial is primitive
    Return true

Process called "square_free_factorization_gf2" that takes poly as PolynomialGF2n returns List[PolynomialGF2n]:
    Note: Perform square-free factorization over GF(2)
    Let factors be List.create_empty[PolynomialGF2n]()
    
    Note: Over GF(2), derivative is simple minus just remove even powers
    Let derivative be compute_derivative_gf2(poly)
    Let gcd_result be gcd_polynomials_gf_2(poly, derivative)
    
    If gcd_result.degree is equal to 0:
        Note: Already square-free
        List.append(factors, poly)
    Otherwise:
        Note: Recursive square-free factorization using Yun's algorithm
        Let current_poly be poly
        Let i be 1
        
        Loop:
            If current_poly.degree is equal to 0:
                Break
            
            Let next_gcd be gcd_polynomials_gf_2(current_poly, derivative)
            If next_gcd.degree is equal to 0:
                Note: Current polynomial is i-th power free
                If current_poly.degree is greater than 0:
                    List.append(factors, current_poly)
                Break
            
            Note: Extract factor of multiplicity i
            Let factor_i be divide_polynomials_gf2(current_poly, next_gcd)
            If factor_i.degree is greater than 0:
                List.append(factors, factor_i)
            
            Note: Continue with reduced polynomial
            Let current_poly be next_gcd
            Let derivative be compute_derivative_gf2(current_poly)
            Let i be i plus 1
            
            Note: Prevent infinite loop
            If i is greater than 100:
                Break
    
    Note: Ensure we have at least one factor
    If List.size(factors) is equal to 0:
        List.append(factors, poly)
    
    Return factors

Process called "compute_derivative_gf2" that takes poly as PolynomialGF2n returns PolynomialGF2n:
    Note: Compute derivative over GF(2) minus coefficients of odd powers only
    Let derivative_coeffs be List.create_empty[Integer]()
    
    Note: Over GF(2), derivative eliminates even powers
    For i from 1 to poly.degree step 2:
        If i is less than List.size(poly.polynomial_coefficients):
            List.append(derivative_coeffs, List.get(poly.polynomial_coefficients, i))
    
    If List.size(derivative_coeffs) is equal to 0:
        List.append(derivative_coeffs, 0)
    
    Return PolynomialGF2n with:
        polynomial_coefficients: derivative_coeffs
        degree: List.size(derivative_coeffs) minus 1
        field_extension: poly.field_extension
        irreducible_polynomial: poly.irreducible_polynomial
        primitive_polynomial: false

Process called "distinct_degree_factorization_gf2" that takes poly as PolynomialGF2n returns List[PolynomialGF2n]:
    Note: Factor into polynomials whose irreducible factors all have the same degree
    Let factors be List.create_empty[PolynomialGF2n]()
    
    Let current_poly be poly
    Let x_power be create_linear_polynomial_gf2()
    Let degree be 1
    
    Loop:
        If current_poly.degree is less than 2 multiplied by degree:
            Note: Remaining polynomial has degree less than 2*degree
            If current_poly.degree is greater than 0:
                List.append(factors, current_poly)
            Break
        
        Note: Compute x^(2^degree) mod current_poly
        Let frobenius_power be power_polynomial_gf2_mod(x_power, integer_to_string(power_of_2(degree)), current_poly.degree plus 1)
        
        Note: Compute gcd(current_poly, x^(2^degree) minus x)
        Let x_minus_frobenius be subtract_polynomials_gf2(frobenius_power, x_power)
        Let gcd_factor be gcd_polynomials_gf_2(current_poly, x_minus_frobenius)
        
        If gcd_factor.degree is greater than 0:
            Note: Found factor containing all irreducible factors of degree exactly 'degree'
            List.append(factors, gcd_factor)
            
            Note: Remove this factor from current polynomial
            Let current_poly be divide_polynomials_gf2(current_poly, gcd_factor)
        
        Let degree be degree plus 1
        
        Note: Prevent infinite loop
        If degree is greater than poly.degree:
            Break
    
    Note: Ensure we have at least one factor
    If List.size(factors) is equal to 0:
        List.append(factors, poly)
    
    Return factors

Process called "cantor_zassenhaus_split_gf2" that takes poly as PolynomialGF2n returns List[PolynomialGF2n]:
    Note: Split polynomial using Cantor-Zassenhaus algorithm over GF(2)
    Let factors be List.create_empty[PolynomialGF2n]()
    
    Note: Base case minus if polynomial is already irreducible or linear
    If poly.degree is less than or equal to 1:
        List.append(factors, poly)
        Return factors
    
    Note: Cantor-Zassenhaus probabilistic splitting
    Let attempts be 0
    Let max_attempts be 100
    
    Loop:
        If attempts is greater than or equal to max_attempts:
            Note: Too many attempts, return original polynomial
            List.append(factors, poly)
            Break
        
        Note: Generate random polynomial of degree is less than poly.degree
        Let random_poly be generate_random_polynomial_gf2(poly.degree minus 1)
        
        Note: Compute h is equal to random_poly^(2^(degree/2)) mod poly over GF(2)
        Let exponent_power be poly.degree / 2
        Let exponent_string be integer_to_string(power_of_2(exponent_power))
        Let h be power_polynomial_gf2_mod(random_poly, exponent_string, poly.degree plus 1)
        
        Note: Compute gcd(h plus 1, poly) minus note: over GF(2), h minus 1 is equal to h plus 1
        Let h_plus_one be add_constant_to_polynomial_gf2(h, 1)
        Let gcd_factor be gcd_polynomials_gf_2(h_plus_one, poly)
        
        Note: Check if we found a non-trivial factor
        If gcd_factor.degree is greater than 0 and gcd_factor.degree is less than poly.degree:
            List.append(factors, gcd_factor)
            
            Note: Find the other factor by division
            Let other_factor be divide_polynomials_gf2(poly, gcd_factor)
            List.append(factors, other_factor)
            Break
        
        Let attempts be attempts plus 1
    
    Note: If no factors found, return original polynomial
    If List.size(factors) is equal to 0:
        List.append(factors, poly)
    
    Return factors