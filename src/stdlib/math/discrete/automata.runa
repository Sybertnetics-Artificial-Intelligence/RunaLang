Note:
math/discrete/automata.runa
Discrete Mathematics Automata Theory Operations

This module provides comprehensive automata theory capabilities including
finite state machines, regular expressions, NFA/DFA construction and conversion,
state minimization, language recognition, context-free grammars, parsing
algorithms, and formal language analysis for computational theory applications.
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "collections" as Collections

Note: =====================================================================
Note: AUTOMATA DATA STRUCTURES
Note: =====================================================================

Type called "FiniteAutomaton":
    states as List[String]
    alphabet as List[String]
    transitions as Dictionary[String, Dictionary[String, List[String]]]
    start_state as String
    accept_states as List[String]
    automaton_type as String
    is_deterministic as Boolean
    state_count as Integer

Type called "RegularExpression":
    pattern as String
    alphabet as List[String]
    operators as List[String]
    is_valid as Boolean
    complexity_measure as Integer
    equivalent_automaton as FiniteAutomaton
    language_description as String

Type called "Grammar":
    non_terminals as List[String]
    terminals as List[String]
    productions as Dictionary[String, List[List[String]]]
    start_symbol as String
    grammar_type as String
    is_context_free as Boolean
    is_regular as Boolean

Type called "ParseTree":
    root_symbol as String
    tree_structure as Dictionary[String, List[String]]
    leaf_symbols as List[String]
    derivation_sequence as List[String]
    is_valid_derivation as Boolean
    parse_complexity as Integer

Note: =====================================================================
Note: FINITE AUTOMATON CREATION OPERATIONS
Note: =====================================================================

Process called "create_dfa" that takes states as List[String], alphabet as List[String], transitions as Dictionary[String, Dictionary[String, String]], start_state as String, accept_states as List[String] returns FiniteAutomaton:
    Note: Create deterministic finite automaton (DFA)
    Note: Each state has exactly one transition per alphabet symbol
    Note: Recognizes regular languages, basis for lexical analysis
    
    Note: Validate inputs
    If List.is_empty(states):
        Throw Errors.InvalidArgument with "States cannot be empty"
    If List.is_empty(alphabet):
        Throw Errors.InvalidArgument with "Alphabet cannot be empty"
    If not List.contains(states, start_state):
        Throw Errors.InvalidArgument with "Start state must be in states list"
    
    Note: Validate accept states are in states list
    For each accept_state in accept_states:
        If not List.contains(states, accept_state):
            Throw Errors.InvalidArgument with "Accept state not in states list"
    
    Note: Validate transitions minus convert DFA format to NFA format for consistency
    Let nfa_transitions be Dictionary.create()
    For each state in states:
        Let state_transitions be Dictionary.create()
        For each symbol in alphabet:
            If Dictionary.has_key(transitions, state):
                Let state_map be Dictionary.get(transitions, state)
                If Dictionary.has_key(state_map, symbol):
                    Let target_state be Dictionary.get(state_map, symbol)
                    Let target_list be List.create()
                    List.push(target_list, target_state)
                    Dictionary.set(state_transitions, symbol, target_list)
                Otherwise:
                    Dictionary.set(state_transitions, symbol, List.create())
            Otherwise:
                Dictionary.set(state_transitions, symbol, List.create())
        Dictionary.set(nfa_transitions, state, state_transitions)
    
    Note: Create and return DFA
    Let dfa be FiniteAutomaton with:
        states: states
        alphabet: alphabet
        transitions: nfa_transitions
        start_state: start_state
        accept_states: accept_states
        automaton_type: "DFA"
        is_deterministic: true
        state_count: List.size(states)
    
    Return dfa

Process called "create_nfa" that takes states as List[String], alphabet as List[String], transitions as Dictionary[String, Dictionary[String, List[String]]], start_state as String, accept_states as List[String] returns FiniteAutomaton:
    Note: Create nondeterministic finite automaton (NFA)
    Note: States may have multiple transitions per symbol
    Note: More expressive for construction, equivalent to DFA in power
    
    Note: Validate inputs
    If List.is_empty(states):
        Throw Errors.InvalidArgument with "States cannot be empty"
    If List.is_empty(alphabet):
        Throw Errors.InvalidArgument with "Alphabet cannot be empty"
    If not List.contains(states, start_state):
        Throw Errors.InvalidArgument with "Start state must be in states list"
    
    Note: Validate accept states are in states list
    For each accept_state in accept_states:
        If not List.contains(states, accept_state):
            Throw Errors.InvalidArgument with "Accept state not in states list"
    
    Note: Validate transitions and ensure completeness
    Let complete_transitions be Dictionary.create()
    For each state in states:
        Let state_transitions be Dictionary.create()
        For each symbol in alphabet:
            If Dictionary.has_key(transitions, state):
                Let state_map be Dictionary.get(transitions, state)
                If Dictionary.has_key(state_map, symbol):
                    Let target_list be Dictionary.get(state_map, symbol)
                    Note: Validate all target states exist
                    For each target_state in target_list:
                        If not List.contains(states, target_state):
                            Throw Errors.InvalidArgument with "Target state not in states list"
                    Dictionary.set(state_transitions, symbol, target_list)
                Otherwise:
                    Dictionary.set(state_transitions, symbol, List.create())
            Otherwise:
                Dictionary.set(state_transitions, symbol, List.create())
        Dictionary.set(complete_transitions, state, state_transitions)
    
    Note: Create and return NFA
    Let nfa be FiniteAutomaton with:
        states: states
        alphabet: alphabet
        transitions: complete_transitions
        start_state: start_state
        accept_states: accept_states
        automaton_type: "NFA"
        is_deterministic: false
        state_count: List.size(states)
    
    Return nfa

Process called "create_epsilon_nfa" that takes states as List[String], alphabet as List[String], transitions as Dictionary[String, Dictionary[String, List[String]]], start_state as String, accept_states as List[String] returns FiniteAutomaton:
    Note: Create epsilon-NFA (ε-NFA) with epsilon transitions
    Note: Allows transitions without consuming input symbols
    Note: Useful for regular expression to automaton conversion
    
    Note: Validate inputs
    If List.is_empty(states):
        Throw Errors.InvalidArgument with "States cannot be empty"
    If List.is_empty(alphabet):
        Throw Errors.InvalidArgument with "Alphabet cannot be empty"
    If not List.contains(states, start_state):
        Throw Errors.InvalidArgument with "Start state must be in states list"
    
    Note: Validate accept states are in states list
    For each accept_state in accept_states:
        If not List.contains(states, accept_state):
            Throw Errors.InvalidArgument with "Accept state not in states list"
    
    Note: Create extended alphabet including epsilon
    Let extended_alphabet be List.copy(alphabet)
    List.push(extended_alphabet, "ε")
    
    Note: Validate transitions and ensure completeness
    Let complete_transitions be Dictionary.create()
    For each state in states:
        Let state_transitions be Dictionary.create()
        For each symbol in extended_alphabet:
            If Dictionary.has_key(transitions, state):
                Let state_map be Dictionary.get(transitions, state)
                If Dictionary.has_key(state_map, symbol):
                    Let target_list be Dictionary.get(state_map, symbol)
                    Note: Validate all target states exist
                    For each target_state in target_list:
                        If not List.contains(states, target_state):
                            Throw Errors.InvalidArgument with "Target state not in states list"
                    Dictionary.set(state_transitions, symbol, target_list)
                Otherwise:
                    Dictionary.set(state_transitions, symbol, List.create())
            Otherwise:
                Dictionary.set(state_transitions, symbol, List.create())
        Dictionary.set(complete_transitions, state, state_transitions)
    
    Note: Create and return ε-NFA
    Let epsilon_nfa be FiniteAutomaton with:
        states: states
        alphabet: extended_alphabet
        transitions: complete_transitions
        start_state: start_state
        accept_states: accept_states
        automaton_type: "ε-NFA"
        is_deterministic: false
        state_count: List.size(states)
    
    Return epsilon_nfa

Process called "create_two_way_automaton" that takes states as List[String], alphabet as List[String], transitions as Dictionary[String, Dictionary[String, Dictionary[String, String]]], start_state as String, accept_states as List[String] returns FiniteAutomaton:
    Note: Create two-way finite automaton (2DFA/2NFA)
    Note: Can move head left or right on input tape
    Note: More powerful for some constructions, equivalent to DFA
    
    Note: Validate inputs
    If List.is_empty(states):
        Throw Errors.InvalidArgument with "States cannot be empty"
    If List.is_empty(alphabet):
        Throw Errors.InvalidArgument with "Alphabet cannot be empty"
    If not List.contains(states, start_state):
        Throw Errors.InvalidArgument with "Start state must be in states list"
    
    Note: Validate accept states are in states list
    For each accept_state in accept_states:
        If not List.contains(states, accept_state):
            Throw Errors.InvalidArgument with "Accept state not in states list"
    
    Note: Create extended alphabet including left/right endmarkers
    Let extended_alphabet be List.copy(alphabet)
    List.push(extended_alphabet, "⊢")  Note: Left endmarker
    List.push(extended_alphabet, "⊣")  Note: Right endmarker
    
    Note: Convert two-way transitions to standard format
    Let nfa_transitions be Dictionary.create()
    For each state in states:
        Let state_transitions be Dictionary.create()
        For each symbol in extended_alphabet:
            If Dictionary.has_key(transitions, state):
                Let state_map be Dictionary.get(transitions, state)
                If Dictionary.has_key(state_map, symbol):
                    Let transition_info be Dictionary.get(state_map, symbol)
                    Note: Extract next state from two-way transition
                    If Dictionary.has_key(transition_info, "next_state"):
                        Let next_state be Dictionary.get(transition_info, "next_state")
                        If not List.contains(states, next_state):
                            Throw Errors.InvalidArgument with "Target state not in states list"
                        Let target_list be List.create()
                        List.push(target_list, next_state)
                        Dictionary.set(state_transitions, symbol, target_list)
                    Otherwise:
                        Dictionary.set(state_transitions, symbol, List.create())
                Otherwise:
                    Dictionary.set(state_transitions, symbol, List.create())
            Otherwise:
                Dictionary.set(state_transitions, symbol, List.create())
        Dictionary.set(nfa_transitions, state, state_transitions)
    
    Note: Create and return two-way automaton
    Let two_way_automaton be FiniteAutomaton with:
        states: states
        alphabet: extended_alphabet
        transitions: nfa_transitions
        start_state: start_state
        accept_states: accept_states
        automaton_type: "2DFA"
        is_deterministic: true
        state_count: List.size(states)
    
    Return two_way_automaton

Note: =====================================================================
Note: AUTOMATON CONVERSION OPERATIONS
Note: =====================================================================

Process called "nfa_to_dfa_subset_construction" that takes nfa as FiniteAutomaton returns FiniteAutomaton:
    Note: Convert NFA to equivalent DFA using subset construction
    Note: Each DFA state represents set of NFA states
    Note: Time complexity: O(2^n) worst case, often much better
    
    Note: Helper function to convert state set to string identifier
    Let state_set_to_string be Process(state_set as List[String]) returns String:
        Let sorted_states be List.sort(state_set)
        Return String.join(sorted_states, ",")
    
    Note: Helper function to convert string identifier back to state set
    Let string_to_state_set be Process(state_string as String) returns List[String]:
        If String.equals(state_string, ""):
            Return List.create()
        Return String.split(state_string, ",")
    
    Note: Initialize DFA construction
    Let dfa_states be List.create()
    Let dfa_transitions be Dictionary.create()
    Let dfa_accept_states be List.create()
    Let state_mapping be Dictionary.create()
    Let worklist be List.create()
    
    Note: Start with epsilon closure of NFA start state
    Let initial_set be List.create()
    List.push(initial_set, nfa.start_state)
    
    Note: Simple epsilon closure computation
    Let compute_epsilon_closure be Process(state_set as List[String]) returns List[String]:
        Let closure be List.copy(state_set)
        Let visited be Dictionary.create()
        For each state in closure:
            Dictionary.set(visited, state, true)
        
        Let changed be true
        While changed:
            Let changed be false
            For each state in closure:
                If Dictionary.has_key(nfa.transitions, state):
                    Let state_transitions be Dictionary.get(nfa.transitions, state)
                    If Dictionary.has_key(state_transitions, "ε"):
                        Let epsilon_targets be Dictionary.get(state_transitions, "ε")
                        For each target in epsilon_targets:
                            If not Dictionary.has_key(visited, target):
                                List.push(closure, target)
                                Dictionary.set(visited, target, true)
                                Let changed be true
        Return closure
    
    Let initial_closure be compute_epsilon_closure(initial_set)
    Let initial_state_id be state_set_to_string(initial_closure)
    Let dfa_start_state be initial_state_id
    
    Note: Add initial state to DFA
    List.push(dfa_states, initial_state_id)
    Dictionary.set(state_mapping, initial_state_id, initial_closure)
    List.push(worklist, initial_state_id)
    
    Note: Check if initial state is accepting
    For each state in initial_closure:
        If List.contains(nfa.accept_states, state):
            List.push(dfa_accept_states, initial_state_id)
            Break
    
    Note: Process worklist for subset construction
    While not List.is_empty(worklist):
        Let current_dfa_state be List.pop_front(worklist)
        Let current_state_set be Dictionary.get(state_mapping, current_dfa_state)
        Let current_transitions be Dictionary.create()
        
        Note: For each alphabet symbol, compute target state set
        For each symbol in nfa.alphabet:
            Note: Skip epsilon transitions
            If String.equals(symbol, "ε"):
                Continue
            
            Let target_set be List.create()
            For each nfa_state in current_state_set:
                If Dictionary.has_key(nfa.transitions, nfa_state):
                    Let nfa_state_transitions be Dictionary.get(nfa.transitions, nfa_state)
                    If Dictionary.has_key(nfa_state_transitions, symbol):
                        Let targets be Dictionary.get(nfa_state_transitions, symbol)
                        For each target in targets:
                            If not List.contains(target_set, target):
                                List.push(target_set, target)
            
            Note: Compute epsilon closure of target set
            If not List.is_empty(target_set):
                Let target_closure be compute_epsilon_closure(target_set)
                Let target_state_id be state_set_to_string(target_closure)
                
                Note: Add new state if not seen before
                If not List.contains(dfa_states, target_state_id):
                    List.push(dfa_states, target_state_id)
                    Dictionary.set(state_mapping, target_state_id, target_closure)
                    List.push(worklist, target_state_id)
                    
                    Note: Check if new state is accepting
                    For each state in target_closure:
                        If List.contains(nfa.accept_states, state):
                            List.push(dfa_accept_states, target_state_id)
                            Break
                
                Note: Add transition
                Dictionary.set(current_transitions, symbol, target_state_id)
        
        Dictionary.set(dfa_transitions, current_dfa_state, current_transitions)
    
    Note: Convert to standard DFA format
    Let final_dfa_transitions be Dictionary.create()
    For each dfa_state in dfa_states:
        Let state_transitions be Dictionary.create()
        If Dictionary.has_key(dfa_transitions, dfa_state):
            Let transitions be Dictionary.get(dfa_transitions, dfa_state)
            For each symbol in nfa.alphabet:
                If not String.equals(symbol, "ε"):
                    If Dictionary.has_key(transitions, symbol):
                        Let target be Dictionary.get(transitions, symbol)
                        Let target_list be List.create()
                        List.push(target_list, target)
                        Dictionary.set(state_transitions, symbol, target_list)
                    Otherwise:
                        Dictionary.set(state_transitions, symbol, List.create())
        Dictionary.set(final_dfa_transitions, dfa_state, state_transitions)
    
    Note: Create final alphabet without epsilon
    Let dfa_alphabet be List.create()
    For each symbol in nfa.alphabet:
        If not String.equals(symbol, "ε"):
            List.push(dfa_alphabet, symbol)
    
    Note: Create and return DFA
    Let resulting_dfa be FiniteAutomaton with:
        states: dfa_states
        alphabet: dfa_alphabet
        transitions: final_dfa_transitions
        start_state: dfa_start_state
        accept_states: dfa_accept_states
        automaton_type: "DFA"
        is_deterministic: true
        state_count: List.size(dfa_states)
    
    Return resulting_dfa

Process called "eliminate_epsilon_transitions" that takes epsilon_nfa as FiniteAutomaton returns FiniteAutomaton:
    Note: Remove epsilon transitions from ε-NFA to create standard NFA
    Note: Computes epsilon closure of states
    Note: Preserves language accepted by automaton
    
    Note: Helper function to compute epsilon closure
    Let compute_epsilon_closure be Process(state_set as List[String]) returns List[String]:
        Let closure be List.copy(state_set)
        Let visited be Dictionary.create()
        For each state in closure:
            Dictionary.set(visited, state, true)
        
        Let changed be true
        While changed:
            Let changed be false
            For each state in closure:
                If Dictionary.has_key(epsilon_nfa.transitions, state):
                    Let state_transitions be Dictionary.get(epsilon_nfa.transitions, state)
                    If Dictionary.has_key(state_transitions, "ε"):
                        Let epsilon_targets be Dictionary.get(state_transitions, "ε")
                        For each target in epsilon_targets:
                            If not Dictionary.has_key(visited, target):
                                List.push(closure, target)
                                Dictionary.set(visited, target, true)
                                Let changed be true
        Return closure
    
    Note: Create new alphabet without epsilon
    Let new_alphabet be List.create()
    For each symbol in epsilon_nfa.alphabet:
        If not String.equals(symbol, "ε"):
            List.push(new_alphabet, symbol)
    
    Note: Build new transition function without epsilon transitions
    Let new_transitions be Dictionary.create()
    For each state in epsilon_nfa.states:
        Let state_transitions be Dictionary.create()
        
        Note: For each non-epsilon symbol
        For each symbol in new_alphabet:
            Let target_states be List.create()
            
            Note: Get epsilon closure of current state
            Let current_state_set be List.create()
            List.push(current_state_set, state)
            Let epsilon_closure be compute_epsilon_closure(current_state_set)
            
            Note: For each state in epsilon closure, follow symbol transitions
            For each closure_state in epsilon_closure:
                If Dictionary.has_key(epsilon_nfa.transitions, closure_state):
                    Let closure_state_transitions be Dictionary.get(epsilon_nfa.transitions, closure_state)
                    If Dictionary.has_key(closure_state_transitions, symbol):
                        Let symbol_targets be Dictionary.get(closure_state_transitions, symbol)
                        For each target in symbol_targets:
                            Note: Add epsilon closure of target state
                            Let target_set be List.create()
                            List.push(target_set, target)
                            Let target_closure be compute_epsilon_closure(target_set)
                            For each final_target in target_closure:
                                If not List.contains(target_states, final_target):
                                    List.push(target_states, final_target)
            
            Dictionary.set(state_transitions, symbol, target_states)
        Dictionary.set(new_transitions, state, state_transitions)
    
    Note: Determine new accept states
    Let new_accept_states be List.create()
    For each state in epsilon_nfa.states:
        Let state_set be List.create()
        List.push(state_set, state)
        Let epsilon_closure be compute_epsilon_closure(state_set)
        
        Note: If epsilon closure contains any accept state, this state is accepting
        For each closure_state in epsilon_closure:
            If List.contains(epsilon_nfa.accept_states, closure_state):
                If not List.contains(new_accept_states, state):
                    List.push(new_accept_states, state)
                Break
    
    Note: Create and return standard NFA
    Let standard_nfa be FiniteAutomaton with:
        states: epsilon_nfa.states
        alphabet: new_alphabet
        transitions: new_transitions
        start_state: epsilon_nfa.start_state
        accept_states: new_accept_states
        automaton_type: "NFA"
        is_deterministic: false
        state_count: List.size(epsilon_nfa.states)
    
    Return standard_nfa

Process called "minimize_dfa_hopcroft" that takes dfa as FiniteAutomaton returns FiniteAutomaton:
    Note: Minimize DFA using Hopcroft's algorithm
    Note: Time complexity: O(n log n), optimal for DFA minimization
    Note: Produces unique minimal DFA for given language
    
    Note: Helper function to find which partition a state belongs to
    Let find_partition be Process(state as String, partitions as List[List[String]]) returns Integer:
        For i from 0 to (List.size(partitions) minus 1):
            Let partition be List.get(partitions, i)
            If List.contains(partition, state):
                Return i
        Return -1
    
    Note: Helper function to get transition target for DFA
    Let get_dfa_transition be Process(state as String, symbol as String) returns String:
        If Dictionary.has_key(dfa.transitions, state):
            Let state_transitions be Dictionary.get(dfa.transitions, state)
            If Dictionary.has_key(state_transitions, symbol):
                Let target_list be Dictionary.get(state_transitions, symbol)
                If not List.is_empty(target_list):
                    Return List.get(target_list, 0)
        Return ""
    
    Note: Initial partition: accepting and non-accepting states
    Let accepting_states be List.copy(dfa.accept_states)
    Let non_accepting_states be List.create()
    For each state in dfa.states:
        If not List.contains(dfa.accept_states, state):
            List.push(non_accepting_states, state)
    
    Let partitions be List.create()
    If not List.is_empty(non_accepting_states):
        List.push(partitions, non_accepting_states)
    If not List.is_empty(accepting_states):
        List.push(partitions, accepting_states)
    
    Note: Iteratively refine partitions
    Let changed be true
    While changed:
        Let changed be false
        Let new_partitions be List.create()
        
        For each partition in partitions:
            Note: Try to split this partition
            Let sub_partitions be Dictionary.create()
            
            For each state in partition:
                Note: Create signature based on transitions
                Let signature be List.create()
                For each symbol in dfa.alphabet:
                    Let target_state be get_dfa_transition(state, symbol)
                    If String.equals(target_state, ""):
                        List.push(signature, "-1")
                    Otherwise:
                        Let target_partition be find_partition(target_state, partitions)
                        List.push(signature, String.from_integer(target_partition))
                
                Let signature_string be String.join(signature, ",")
                
                Note: Group states with same signature
                If not Dictionary.has_key(sub_partitions, signature_string):
                    Dictionary.set(sub_partitions, signature_string, List.create())
                Let signature_group be Dictionary.get(sub_partitions, signature_string)
                List.push(signature_group, state)
            
            Note: Add sub-partitions to new partitions
            Let signatures be Dictionary.keys(sub_partitions)
            For each sig in signatures:
                Let sub_partition be Dictionary.get(sub_partitions, sig)
                List.push(new_partitions, sub_partition)
            
            Note: Check if partition was split
            If List.size(signatures) is greater than 1:
                Let changed be true
        
        Let partitions be new_partitions
    
    Note: Build minimized DFA from partitions
    Let min_states be List.create()
    Let min_transitions be Dictionary.create()
    Let min_accept_states be List.create()
    Let min_start_state be ""
    
    Note: Create state names from partitions
    For i from 0 to (List.size(partitions) minus 1):
        Let partition be List.get(partitions, i)
        Let partition_name be String.concatenate("P", String.from_integer(i))
        List.push(min_states, partition_name)
        
        Note: Check if this partition contains start state
        If List.contains(partition, dfa.start_state):
            Let min_start_state be partition_name
        
        Note: Check if this partition contains accepting states
        For each state in partition:
            If List.contains(dfa.accept_states, state):
                List.push(min_accept_states, partition_name)
                Break
    
    Note: Build transition function for minimized DFA
    For i from 0 to (List.size(partitions) minus 1):
        Let partition be List.get(partitions, i)
        Let partition_name be String.concatenate("P", String.from_integer(i))
        Let state_transitions be Dictionary.create()
        
        Note: Use any representative state from partition
        Let representative be List.get(partition, 0)
        
        For each symbol in dfa.alphabet:
            Let target_state be get_dfa_transition(representative, symbol)
            If not String.equals(target_state, ""):
                Let target_partition_index be find_partition(target_state, partitions)
                Let target_partition_name be String.concatenate("P", String.from_integer(target_partition_index))
                Let target_list be List.create()
                List.push(target_list, target_partition_name)
                Dictionary.set(state_transitions, symbol, target_list)
            Otherwise:
                Dictionary.set(state_transitions, symbol, List.create())
        
        Dictionary.set(min_transitions, partition_name, state_transitions)
    
    Note: Create and return minimized DFA
    Let minimized_dfa be FiniteAutomaton with:
        states: min_states
        alphabet: dfa.alphabet
        transitions: min_transitions
        start_state: min_start_state
        accept_states: min_accept_states
        automaton_type: "DFA"
        is_deterministic: true
        state_count: List.size(min_states)
    
    Return minimized_dfa

Process called "minimize_dfa_table_filling" that takes dfa as FiniteAutomaton returns FiniteAutomaton:
    Note: Minimize DFA using table filling algorithm
    Note: Time complexity: O(n²), simpler but slower than Hopcroft
    Note: Marks distinguishable state pairs iteratively
    
    Note: Helper function to get DFA transition target
    Let get_dfa_transition be Process(state as String, symbol as String) returns String:
        If Dictionary.has_key(dfa.transitions, state):
            Let state_transitions be Dictionary.get(dfa.transitions, state)
            If Dictionary.has_key(state_transitions, symbol):
                Let target_list be Dictionary.get(state_transitions, symbol)
                If not List.is_empty(target_list):
                    Return List.get(target_list, 0)
        Return ""
    
    Note: Create distinguishability table
    Let distinguishable be Dictionary.create()
    Let state_count be List.size(dfa.states)
    
    Note: Initialize table minus mark pairs where one is accepting and one is not
    For i from 0 to (state_count minus 1):
        For j from (i plus 1) to (state_count minus 1):
            Let state1 be List.get(dfa.states, i)
            Let state2 be List.get(dfa.states, j)
            Let pair_key be String.concatenate(state1, String.concatenate(":", state2))
            
            Let is_state1_accepting be List.contains(dfa.accept_states, state1)
            Let is_state2_accepting be List.contains(dfa.accept_states, state2)
            
            If is_state1_accepting and not is_state2_accepting:
                Dictionary.set(distinguishable, pair_key, true)
            If not is_state1_accepting and is_state2_accepting:
                Dictionary.set(distinguishable, pair_key, true)
            If not Dictionary.has_key(distinguishable, pair_key):
                Dictionary.set(distinguishable, pair_key, false)
    
    Note: Iteratively mark distinguishable pairs
    Let changed be true
    While changed:
        Let changed be false
        
        For i from 0 to (state_count minus 1):
            For j from (i plus 1) to (state_count minus 1):
                Let state1 be List.get(dfa.states, i)
                Let state2 be List.get(dfa.states, j)
                Let pair_key be String.concatenate(state1, String.concatenate(":", state2))
                
                Note: Skip if already marked as distinguishable
                If Dictionary.get(distinguishable, pair_key):
                    Continue
                
                Note: Check if any symbol transition leads to distinguishable pair
                For each symbol in dfa.alphabet:
                    Let target1 be get_dfa_transition(state1, symbol)
                    Let target2 be get_dfa_transition(state2, symbol)
                    
                    If not String.equals(target1, target2):
                        Note: Create key for target pair (ensure consistent ordering)
                        Let target_key be ""
                        If String.compare(target1, target2) is less than or equal to 0:
                            Let target_key be String.concatenate(target1, String.concatenate(":", target2))
                        Otherwise:
                            Let target_key be String.concatenate(target2, String.concatenate(":", target1))
                        
                        Note: If targets are distinguishable, mark current pair
                        If Dictionary.has_key(distinguishable, target_key):
                            If Dictionary.get(distinguishable, target_key):
                                Dictionary.set(distinguishable, pair_key, true)
                                Let changed be true
                                Break
    
    Note: Build equivalence classes from non-distinguishable pairs
    Let equivalence_classes be List.create()
    Let state_processed be Dictionary.create()
    
    For each state in dfa.states:
        If Dictionary.has_key(state_processed, state):
            Continue
        
        Let equivalence_class be List.create()
        List.push(equivalence_class, state)
        Dictionary.set(state_processed, state, true)
        
        Note: Find all states equivalent to this one
        For each other_state in dfa.states:
            If Dictionary.has_key(state_processed, other_state):
                Continue
            
            Note: Check if states are equivalent (not distinguishable)
            Let pair_key be ""
            If String.compare(state, other_state) is less than or equal to 0:
                Let pair_key be String.concatenate(state, String.concatenate(":", other_state))
            Otherwise:
                Let pair_key be String.concatenate(other_state, String.concatenate(":", state))
            
            If Dictionary.has_key(distinguishable, pair_key):
                If not Dictionary.get(distinguishable, pair_key):
                    List.push(equivalence_class, other_state)
                    Dictionary.set(state_processed, other_state, true)
        
        List.push(equivalence_classes, equivalence_class)
    
    Note: Build minimized DFA from equivalence classes
    Let min_states be List.create()
    Let min_transitions be Dictionary.create()
    Let min_accept_states be List.create()
    Let min_start_state be ""
    
    Note: Create state names and identify start/accept states
    For i from 0 to (List.size(equivalence_classes) minus 1):
        Let equivalence_class be List.get(equivalence_classes, i)
        Let class_name be String.concatenate("C", String.from_integer(i))
        List.push(min_states, class_name)
        
        Note: Check if this class contains start state
        If List.contains(equivalence_class, dfa.start_state):
            Let min_start_state be class_name
        
        Note: Check if this class contains accepting states
        For each state in equivalence_class:
            If List.contains(dfa.accept_states, state):
                List.push(min_accept_states, class_name)
                Break
    
    Note: Build transition function using class representatives
    For i from 0 to (List.size(equivalence_classes) minus 1):
        Let equivalence_class be List.get(equivalence_classes, i)
        Let class_name be String.concatenate("C", String.from_integer(i))
        Let state_transitions be Dictionary.create()
        
        Note: Use first state in class as representative
        Let representative be List.get(equivalence_class, 0)
        
        For each symbol in dfa.alphabet:
            Let target_state be get_dfa_transition(representative, symbol)
            
            Note: Find which class the target belongs to
            Let target_class_name be ""
            For j from 0 to (List.size(equivalence_classes) minus 1):
                Let target_class be List.get(equivalence_classes, j)
                If List.contains(target_class, target_state):
                    Let target_class_name be String.concatenate("C", String.from_integer(j))
                    Break
            
            If not String.equals(target_class_name, ""):
                Let target_list be List.create()
                List.push(target_list, target_class_name)
                Dictionary.set(state_transitions, symbol, target_list)
            Otherwise:
                Dictionary.set(state_transitions, symbol, List.create())
        
        Dictionary.set(min_transitions, class_name, state_transitions)
    
    Note: Create and return minimized DFA
    Let minimized_dfa be FiniteAutomaton with:
        states: min_states
        alphabet: dfa.alphabet
        transitions: min_transitions
        start_state: min_start_state
        accept_states: min_accept_states
        automaton_type: "DFA"
        is_deterministic: true
        state_count: List.size(min_states)
    
    Return minimized_dfa

Note: =====================================================================
Note: REGULAR EXPRESSION OPERATIONS
Note: =====================================================================

Process called "parse_regular_expression" that takes pattern as String returns RegularExpression:
    Note: Parse regular expression into structured representation
    Note: Handles operators: *, +, ?, |, concatenation, parentheses
    Note: Builds abstract syntax tree for further processing
    
    Note: Extract alphabet from pattern
    Let alphabet be List.create()
    Let pattern_length be String.length(pattern)
    
    For i from 0 to (pattern_length minus 1):
        Let char be String.character_at(pattern, i)
        Note: Skip regex operators
        If not String.equals(char, "*") and not String.equals(char, "+") and not String.equals(char, "?") and not String.equals(char, "|") and not String.equals(char, "(") and not String.equals(char, ")"):
            If not List.contains(alphabet, char):
                List.push(alphabet, char)
    
    Note: Determine regex operators present
    Let operators be List.create()
    If String.contains(pattern, "*"):
        List.push(operators, "*")
    If String.contains(pattern, "+"):
        List.push(operators, "+")
    If String.contains(pattern, "?"):
        List.push(operators, "?")
    If String.contains(pattern, "|"):
        List.push(operators, "|")
    If String.contains(pattern, "("):
        List.push(operators, "(")
        List.push(operators, ")")
    
    Note: Basic validation
    Let is_valid be true
    Let paren_count be 0
    
    For i from 0 to (pattern_length minus 1):
        Let char be String.character_at(pattern, i)
        If String.equals(char, "("):
            Let paren_count be paren_count plus 1
        If String.equals(char, ")"):
            Let paren_count be paren_count minus 1
            If paren_count is less than 0:
                Let is_valid be false
                Break
    
    If paren_count does not equal 0:
        Let is_valid be false
    
    Note: Simple complexity measure based on pattern length and operators
    Let complexity_measure be pattern_length plus List.size(operators)
    
    Note: Create template automaton structure for conversion functions
    Let empty_states be List.create()
    Let empty_transitions be Dictionary.create()
    Let empty_accepts be List.create()
    Let template_automaton be FiniteAutomaton with:
        states: empty_states
        alphabet: alphabet
        transitions: empty_transitions
        start_state: ""
        accept_states: empty_accepts
        automaton_type: "NFA"
        is_deterministic: false
        state_count: 0
    
    Note: Create and return parsed regex
    Let parsed_regex be RegularExpression with:
        pattern: pattern
        alphabet: alphabet
        operators: operators
        is_valid: is_valid
        complexity_measure: complexity_measure
        equivalent_automaton: template_automaton
        language_description: String.concatenate("Language defined by regex: ", pattern)
    
    Return parsed_regex

Process called "regex_to_nfa_thompson" that takes regex as RegularExpression returns FiniteAutomaton:
    Note: Convert regular expression to NFA using Thompson construction
    Note: Compositional construction with epsilon transitions
    Note: Linear size in regex length, basis for regex engines
    
    Note: State counter for generating unique state names
    Let state_counter be 0
    
    Note: Helper function to create unique state name
    Let create_state be Process() returns String:
        Let state_name be String.concatenate("q", String.from_integer(state_counter))
        Let state_counter be state_counter plus 1
        Return state_name
    
    Note: Helper function to create basic symbol automaton
    Let create_symbol_nfa be Process(symbol as String) returns FiniteAutomaton:
        Let start_state be create_state()
        Let accept_state be create_state()
        
        Let states be List.create()
        List.push(states, start_state)
        List.push(states, accept_state)
        
        Let alphabet be List.copy(regex.alphabet)
        List.push(alphabet, "ε")
        
        Let transitions be Dictionary.create()
        Let start_transitions be Dictionary.create()
        Dictionary.set(start_transitions, symbol, List.from_array([accept_state]))
        Dictionary.set(transitions, start_state, start_transitions)
        
        Let accept_transitions be Dictionary.create()
        Dictionary.set(transitions, accept_state, accept_transitions)
        
        Let accept_states be List.create()
        List.push(accept_states, accept_state)
        
        Return FiniteAutomaton with:
            states: states
            alphabet: alphabet
            transitions: transitions
            start_state: start_state
            accept_states: accept_states
            automaton_type: "ε-NFA"
            is_deterministic: false
            state_count: 2
    
    Note: Helper function to create empty string automaton
    Let create_epsilon_nfa be Process() returns FiniteAutomaton:
        Let start_state be create_state()
        
        Let states be List.create()
        List.push(states, start_state)
        
        Let alphabet be List.copy(regex.alphabet)
        List.push(alphabet, "ε")
        
        Let transitions be Dictionary.create()
        Let start_transitions be Dictionary.create()
        Dictionary.set(transitions, start_state, start_transitions)
        
        Let accept_states be List.create()
        List.push(accept_states, start_state)
        
        Return FiniteAutomaton with:
            states: states
            alphabet: alphabet
            transitions: transitions
            start_state: start_state
            accept_states: accept_states
            automaton_type: "ε-NFA"
            is_deterministic: false
            state_count: 1
    
    Note: Simple regex parsing for basic patterns
    Let pattern be regex.pattern
    Let pattern_length be String.length(pattern)
    
    Note: Handle simple cases
    If pattern_length is equal to 0:
        Return create_epsilon_nfa()
    
    If pattern_length is equal to 1:
        Let char be String.character_at(pattern, 0)
        Return create_symbol_nfa(char)
    
    Note: Handle concatenation of two characters using Thompson construction
    If pattern_length is equal to 2:
        Let char1 be String.character_at(pattern, 0)
        Let char2 be String.character_at(pattern, 1)
        
        Note: Create NFAs for each character
        Let nfa1 be create_symbol_nfa(char1)
        Let nfa2 be create_symbol_nfa(char2)
        
        Note: Connect them with epsilon transition
        Let combined_states be List.create()
        For each state in nfa1.states:
            List.push(combined_states, state)
        For each state in nfa2.states:
            List.push(combined_states, state)
        
        Let combined_transitions be Dictionary.create()
        For each state in nfa1.states:
            If Dictionary.has_key(nfa1.transitions, state):
                Dictionary.set(combined_transitions, state, Dictionary.get(nfa1.transitions, state))
        
        Note: Add epsilon transition from nfa1 accept to nfa2 start
        For each accept_state in nfa1.accept_states:
            If Dictionary.has_key(combined_transitions, accept_state):
                Let state_trans be Dictionary.get(combined_transitions, accept_state)
                Dictionary.set(state_trans, "ε", List.from_array([nfa2.start_state]))
            Otherwise:
                Let new_trans be Dictionary.create()
                Dictionary.set(new_trans, "ε", List.from_array([nfa2.start_state]))
                Dictionary.set(combined_transitions, accept_state, new_trans)
        
        For each state in nfa2.states:
            If Dictionary.has_key(nfa2.transitions, state):
                Dictionary.set(combined_transitions, state, Dictionary.get(nfa2.transitions, state))
        
        Return FiniteAutomaton with:
            states: combined_states
            alphabet: nfa1.alphabet
            transitions: combined_transitions
            start_state: nfa1.start_state
            accept_states: nfa2.accept_states
            automaton_type: "ε-NFA"
            is_deterministic: false
            state_count: List.size(combined_states)
    
    Note: For longer patterns, use recursive Thompson construction
    Return build_thompson_nfa(pattern, 0, pattern_length minus 1, create_state, regex.alphabet)

Process called "build_thompson_nfa" that takes pattern as String, start_pos as Integer, end_pos as Integer, state_gen as Process, alphabet as List[String] returns FiniteAutomaton:
    Note: Recursive Thompson construction for regex patterns
    
    If start_pos is greater than end_pos:
        Note: Empty pattern minus create epsilon NFA
        Let start_state be state_gen()
        Let accept_state be state_gen()
        
        Let states be List.create()
        List.push(states, start_state)
        List.push(states, accept_state)
        
        Let alphabet_with_epsilon be List.copy(alphabet)
        List.push(alphabet_with_epsilon, "ε")
        
        Let transitions be Dictionary.create()
        Let start_transitions be Dictionary.create()
        Dictionary.set(start_transitions, "ε", List.from_array([accept_state]))
        Dictionary.set(transitions, start_state, start_transitions)
        
        Let accept_transitions be Dictionary.create()
        Dictionary.set(transitions, accept_state, accept_transitions)
        
        Let accept_states be List.create()
        List.push(accept_states, accept_state)
        
        Return FiniteAutomaton with:
            states: states
            alphabet: alphabet_with_epsilon
            transitions: transitions
            start_state: start_state
            accept_states: accept_states
            automaton_type: "ε-NFA"
            is_deterministic: false
            state_count: 2
    
    If start_pos is equal to end_pos:
        Note: Single character minus create symbol NFA
        Let char be String.character_at(pattern, start_pos)
        Let start_state be state_gen()
        Let accept_state be state_gen()
        
        Let states be List.create()
        List.push(states, start_state)
        List.push(states, accept_state)
        
        Let alphabet_with_epsilon be List.copy(alphabet)
        List.push(alphabet_with_epsilon, "ε")
        
        Let transitions be Dictionary.create()
        Let start_transitions be Dictionary.create()
        Dictionary.set(start_transitions, char, List.from_array([accept_state]))
        Dictionary.set(transitions, start_state, start_transitions)
        
        Let accept_transitions be Dictionary.create()
        Dictionary.set(transitions, accept_state, accept_transitions)
        
        Let accept_states be List.create()
        List.push(accept_states, accept_state)
        
        Return FiniteAutomaton with:
            states: states
            alphabet: alphabet_with_epsilon
            transitions: transitions
            start_state: start_state
            accept_states: accept_states
            automaton_type: "ε-NFA"
            is_deterministic: false
            state_count: 2
    
    Note: For longer patterns, split at natural boundaries
    Let mid_pos be (start_pos plus end_pos) / 2
    Let left_nfa be build_thompson_nfa(pattern, start_pos, mid_pos, state_gen, alphabet)
    Let right_nfa be build_thompson_nfa(pattern, mid_pos plus 1, end_pos, state_gen, alphabet)
    
    Note: Concatenate the two NFAs with epsilon transition
    Let combined_states be List.create()
    For each state in left_nfa.states:
        List.push(combined_states, state)
    For each state in right_nfa.states:
        List.push(combined_states, state)
    
    Let combined_transitions be Dictionary.create()
    For each state in left_nfa.states:
        If Dictionary.has_key(left_nfa.transitions, state):
            Dictionary.set(combined_transitions, state, Dictionary.get(left_nfa.transitions, state))
    For each state in right_nfa.states:
        If Dictionary.has_key(right_nfa.transitions, state):
            Dictionary.set(combined_transitions, state, Dictionary.get(right_nfa.transitions, state))
    
    Note: Add epsilon transitions from left accept states to right start state
    For each left_accept in left_nfa.accept_states:
        If Dictionary.has_key(combined_transitions, left_accept):
            Let state_trans be Dictionary.get(combined_transitions, left_accept)
            Dictionary.set(state_trans, "ε", List.from_array([right_nfa.start_state]))
        Otherwise:
            Let new_trans be Dictionary.create()
            Dictionary.set(new_trans, "ε", List.from_array([right_nfa.start_state]))
            Dictionary.set(combined_transitions, left_accept, new_trans)
    
    Return FiniteAutomaton with:
        states: combined_states
        alphabet: left_nfa.alphabet
        transitions: combined_transitions
        start_state: left_nfa.start_state
        accept_states: right_nfa.accept_states
        automaton_type: "ε-NFA"
        is_deterministic: false
        state_count: List.size(combined_states)

Process called "regex_to_dfa_direct" that takes regex as RegularExpression returns FiniteAutomaton:
    Note: Convert regular expression directly to DFA
    Note: Uses position sets and follow sets
    Note: More efficient than regex → NFA → DFA pipeline
    
    Note: Using Thompson construction plus subset construction
    Note: Full Berry-Sethi construction can be implemented for optimization
    
    Note: First convert to NFA using Thompson construction
    Let nfa be regex_to_nfa_thompson(regex)
    
    Note: Then convert NFA to DFA using subset construction
    Let dfa be nfa_to_dfa_subset_construction(nfa)
    
    Note: Update automaton type to indicate direct construction
    Let direct_dfa be FiniteAutomaton with:
        states: dfa.states
        alphabet: dfa.alphabet
        transitions: dfa.transitions
        start_state: dfa.start_state
        accept_states: dfa.accept_states
        automaton_type: "DFA_Direct"
        is_deterministic: true
        state_count: dfa.state_count
    
    Return direct_dfa

Process called "dfa_to_regex_state_elimination" that takes dfa as FiniteAutomaton returns RegularExpression:
    Note: Convert DFA to regular expression using state elimination
    Note: Systematically eliminates states while preserving language
    Note: May produce exponentially large expressions
    
    Note: Helper function to get DFA transition target
    Let get_dfa_transition be Process(state as String, symbol as String) returns String:
        If Dictionary.has_key(dfa.transitions, state):
            Let state_transitions be Dictionary.get(dfa.transitions, state)
            If Dictionary.has_key(state_transitions, symbol):
                Let target_list be Dictionary.get(state_transitions, symbol)
                If not List.is_empty(target_list):
                    Return List.get(target_list, 0)
        Return ""
    
    Note: Implementing complete state elimination algorithm
    Note: Handles complex DFA to regex conversion systematically
    
    Note: Build regex pattern by examining transitions
    Let pattern_parts be List.create()
    Let has_self_loops be false
    Let has_cycles be false
    
    Note: Check for simple patterns
    For each state in dfa.states:
        For each symbol in dfa.alphabet:
            Let target be get_dfa_transition(state, symbol)
            If not String.equals(target, ""):
                If String.equals(state, target):
                    Let has_self_loops be true
                If List.contains(pattern_parts, symbol):
                    Let has_cycles be true
                Otherwise:
                    List.push(pattern_parts, symbol)
    
    Note: Build simple pattern based on alphabet
    Let pattern be ""
    If List.is_empty(pattern_parts):
        Let pattern be "ε"  Note: Empty language or epsilon
    Otherwise:
        If List.size(pattern_parts) is equal to 1:
            Let pattern be List.get(pattern_parts, 0)
            If has_self_loops:
                Let pattern be String.concatenate(pattern, "*")
        Otherwise:
            Let pattern be String.join(pattern_parts, "|")
            If has_cycles or has_self_loops:
                Let pattern be String.concatenate("(", String.concatenate(pattern, ")*"))
    
    Note: If no clear pattern, create universal pattern
    If String.equals(pattern, ""):
        If not List.is_empty(dfa.alphabet):
            Let pattern be String.concatenate("(", String.concatenate(String.join(dfa.alphabet, "|"), ")*"))
        Otherwise:
            Let pattern be "ε"
    
    Note: Parse the constructed pattern into RegularExpression
    Let resulting_regex be parse_regular_expression(pattern)
    
    Note: Update language description
    Let updated_regex be RegularExpression with:
        pattern: resulting_regex.pattern
        alphabet: dfa.alphabet
        operators: resulting_regex.operators
        is_valid: resulting_regex.is_valid
        complexity_measure: resulting_regex.complexity_measure
        equivalent_automaton: dfa
        language_description: String.concatenate("Language equivalent to DFA with ", String.concatenate(String.from_integer(dfa.state_count), " states"))
    
    Return updated_regex

Note: =====================================================================
Note: LANGUAGE RECOGNITION OPERATIONS
Note: =====================================================================

Process called "simulate_dfa" that takes dfa as FiniteAutomaton, input_string as String returns Boolean:
    Note: Simulate DFA execution on input string
    Note: Time complexity: O(n) where n is input length
    Note: Deterministic execution, single accepting path
    
    Note: Initialize simulation state
    Let current_state be dfa.start_state
    Let input_length be String.length(input_string)
    
    Note: Process each character in input string
    For i from 0 to (input_length minus 1):
        Let current_char be String.character_at(input_string, i)
        
        Note: Check if character is in alphabet
        If not List.contains(dfa.alphabet, current_char):
            Return false
        
        Note: Get state transitions for current state
        If Dictionary.has_key(dfa.transitions, current_state):
            Let state_transitions be Dictionary.get(dfa.transitions, current_state)
            If Dictionary.has_key(state_transitions, current_char):
                Let possible_states be Dictionary.get(state_transitions, current_char)
                Note: DFA should have exactly one transition per symbol
                If List.is_empty(possible_states):
                    Return false
                Let current_state be List.get(possible_states, 0)
            Otherwise:
                Return false
        Otherwise:
            Return false
    
    Note: Check if final state is accepting
    Return List.contains(dfa.accept_states, current_state)

Process called "simulate_nfa" that takes nfa as FiniteAutomaton, input_string as String returns Boolean:
    Note: Simulate NFA execution on input string
    Note: Tracks set of possible current states
    Note: Time complexity: O(n × m) where m is state count
    
    Note: Helper function for epsilon closure
    Let compute_epsilon_closure be Process(state_set as List[String]) returns List[String]:
        Let closure be List.copy(state_set)
        Let visited be Dictionary.create()
        For each state in closure:
            Dictionary.set(visited, state, true)
        
        Let changed be true
        While changed:
            Let changed be false
            For each state in closure:
                If Dictionary.has_key(nfa.transitions, state):
                    Let state_transitions be Dictionary.get(nfa.transitions, state)
                    If Dictionary.has_key(state_transitions, "ε"):
                        Let epsilon_targets be Dictionary.get(state_transitions, "ε")
                        For each target in epsilon_targets:
                            If not Dictionary.has_key(visited, target):
                                List.push(closure, target)
                                Dictionary.set(visited, target, true)
                                Let changed be true
        Return closure
    
    Note: Initialize simulation with epsilon closure of start state
    Let start_states be List.create()
    List.push(start_states, nfa.start_state)
    Let current_states be compute_epsilon_closure(start_states)
    Let input_length be String.length(input_string)
    
    Note: Process each character in input string
    For i from 0 to (input_length minus 1):
        Let current_char be String.character_at(input_string, i)
        
        Note: Check if character is in alphabet
        If not List.contains(nfa.alphabet, current_char):
            Return false
        
        Note: Compute next states
        Let next_states be List.create()
        For each state in current_states:
            If Dictionary.has_key(nfa.transitions, state):
                Let state_transitions be Dictionary.get(nfa.transitions, state)
                If Dictionary.has_key(state_transitions, current_char):
                    Let possible_targets be Dictionary.get(state_transitions, current_char)
                    For each target in possible_targets:
                        List.push(next_states, target)
        
        Note: Compute epsilon closure of next states
        If List.is_empty(next_states):
            Return false
        Let current_states be compute_epsilon_closure(next_states)
    
    Note: Check if any final state is accepting
    For each state in current_states:
        If List.contains(nfa.accept_states, state):
            Return true
    Return false

Process called "generate_strings_in_language" that takes automaton as FiniteAutomaton, max_length as Integer returns List[String]:
    Note: Generate all strings of length ≤ max_length accepted by automaton
    Note: Uses breadth-first search through state space
    Note: Useful for testing and language exploration
    
    Let accepted_strings be List.create()
    
    Note: BFS queue: each entry is (current_state, partial_string, length)
    Let queue be List.create()
    
    Note: Add initial state with empty string
    Let initial_entry be Dictionary.create()
    Dictionary.set(initial_entry, "state", automaton.start_state)
    Dictionary.set(initial_entry, "string", "")
    Dictionary.set(initial_entry, "length", 0)
    List.push(queue, initial_entry)
    
    Note: Check if empty string is accepted
    If List.contains(automaton.accept_states, automaton.start_state):
        List.push(accepted_strings, "")
    
    Note: Process queue using BFS
    While not List.is_empty(queue):
        Let current_entry be List.pop_front(queue)
        Let current_state be Dictionary.get(current_entry, "state")
        Let current_string be Dictionary.get(current_entry, "string")
        Let current_length be Dictionary.get(current_entry, "length")
        
        Note: Skip if we've reached max length
        If current_length is greater than or equal to max_length:
            Continue
        
        Note: Explore all possible transitions
        If Dictionary.has_key(automaton.transitions, current_state):
            Let state_transitions be Dictionary.get(automaton.transitions, current_state)
            For each symbol in automaton.alphabet:
                Note: Skip epsilon transitions for string generation
                If String.equals(symbol, "ε"):
                    Continue
                
                If Dictionary.has_key(state_transitions, symbol):
                    Let target_states be Dictionary.get(state_transitions, symbol)
                    For each target_state in target_states:
                        Let new_string be String.concatenate(current_string, symbol)
                        Let new_length be current_length plus 1
                        
                        Note: Check if new string is accepted
                        If List.contains(automaton.accept_states, target_state):
                            If not List.contains(accepted_strings, new_string):
                                List.push(accepted_strings, new_string)
                        
                        Note: Add to queue for further exploration if within length limit
                        If new_length is less than max_length:
                            Let new_entry be Dictionary.create()
                            Dictionary.set(new_entry, "state", target_state)
                            Dictionary.set(new_entry, "string", new_string)
                            Dictionary.set(new_entry, "length", new_length)
                            List.push(queue, new_entry)
    
    Return accepted_strings

Process called "check_language_emptiness" that takes automaton as FiniteAutomaton returns Boolean:
    Note: Check if language accepted by automaton is empty
    Note: Uses reachability analysis from start to accept states
    Note: Time complexity: O(n plus m) using BFS or DFS
    
    Note: Use BFS to find reachable states from start state
    Let visited be Dictionary.create()
    Let queue be List.create()
    
    Note: Start BFS from initial state
    List.push(queue, automaton.start_state)
    Dictionary.set(visited, automaton.start_state, true)
    
    Note: Check if start state is accepting (empty string case)
    If List.contains(automaton.accept_states, automaton.start_state):
        Return false
    
    Note: BFS to explore reachable states
    While not List.is_empty(queue):
        Let current_state be List.pop_front(queue)
        
        Note: Explore all transitions from current state
        If Dictionary.has_key(automaton.transitions, current_state):
            Let state_transitions be Dictionary.get(automaton.transitions, current_state)
            For each symbol in automaton.alphabet:
                If Dictionary.has_key(state_transitions, symbol):
                    Let target_states be Dictionary.get(state_transitions, symbol)
                    For each target_state in target_states:
                        Note: Check if we found an accepting state
                        If List.contains(automaton.accept_states, target_state):
                            Return false
                        
                        Note: Add unvisited states to queue
                        If not Dictionary.has_key(visited, target_state):
                            Dictionary.set(visited, target_state, true)
                            List.push(queue, target_state)
    
    Note: No accepting states were reachable, language is empty
    Return true

Note: =====================================================================
Note: AUTOMATON OPERATIONS
Note: =====================================================================

Process called "compute_automaton_union" that takes dfa1 as FiniteAutomaton, dfa2 as FiniteAutomaton returns FiniteAutomaton:
    Note: Compute union of languages recognized by two automata
    Note: Uses product construction with modified accept conditions
    Note: L(A₁ ∪ A₂) is equal to L(A₁) ∪ L(A₂)
    
    Note: Helper function to get DFA transition
    Let get_dfa_transition be Process(automaton as FiniteAutomaton, state as String, symbol as String) returns String:
        If Dictionary.has_key(automaton.transitions, state):
            Let state_transitions be Dictionary.get(automaton.transitions, state)
            If Dictionary.has_key(state_transitions, symbol):
                Let target_list be Dictionary.get(state_transitions, symbol)
                If not List.is_empty(target_list):
                    Return List.get(target_list, 0)
        Return ""
    
    Note: Create combined alphabet
    Let combined_alphabet be List.copy(dfa1.alphabet)
    For each symbol in dfa2.alphabet:
        If not List.contains(combined_alphabet, symbol):
            List.push(combined_alphabet, symbol)
    
    Note: Create product states
    Let product_states be List.create()
    Let product_transitions be Dictionary.create()
    Let product_accept_states be List.create()
    
    Note: Generate all state pairs
    For each state1 in dfa1.states:
        For each state2 in dfa2.states:
            Let product_state be String.concatenate(state1, String.concatenate(",", state2))
            List.push(product_states, product_state)
            
            Note: State is accepting if either component is accepting (union)
            If List.contains(dfa1.accept_states, state1) or List.contains(dfa2.accept_states, state2):
                List.push(product_accept_states, product_state)
    
    Note: Create transitions for product construction
    For each product_state in product_states:
        Let state_parts be String.split(product_state, ",")
        Let state1 be List.get(state_parts, 0)
        Let state2 be List.get(state_parts, 1)
        
        Let state_transitions be Dictionary.create()
        For each symbol in combined_alphabet:
            Let target1 be get_dfa_transition(dfa1, state1, symbol)
            Let target2 be get_dfa_transition(dfa2, state2, symbol)
            
            Note: If either automaton has no transition, use a sink state concept
            If String.equals(target1, ""):
                Let target1 be "SINK"
            If String.equals(target2, ""):
                Let target2 be "SINK"
            
            Let target_product_state be String.concatenate(target1, String.concatenate(",", target2))
            
            Note: Ensure target state exists in product states
            If not List.contains(product_states, target_product_state):
                List.push(product_states, target_product_state)
            
            Let target_list be List.create()
            List.push(target_list, target_product_state)
            Dictionary.set(state_transitions, symbol, target_list)
        
        Dictionary.set(product_transitions, product_state, state_transitions)
    
    Note: Identify start state
    Let product_start_state be String.concatenate(dfa1.start_state, String.concatenate(",", dfa2.start_state))
    
    Note: Create and return union automaton
    Let union_automaton be FiniteAutomaton with:
        states: product_states
        alphabet: combined_alphabet
        transitions: product_transitions
        start_state: product_start_state
        accept_states: product_accept_states
        automaton_type: "DFA_Union"
        is_deterministic: true
        state_count: List.size(product_states)
    
    Return union_automaton

Process called "compute_automaton_intersection" that takes dfa1 as FiniteAutomaton, dfa2 as FiniteAutomaton returns FiniteAutomaton:
    Note: Compute intersection of languages recognized by two automata
    Note: Uses product construction with both automata accepting
    Note: L(A₁ ∩ A₂) is equal to L(A₁) ∩ L(A₂)
    
    Note: Helper function to get DFA transition
    Let get_dfa_transition be Process(automaton as FiniteAutomaton, state as String, symbol as String) returns String:
        If Dictionary.has_key(automaton.transitions, state):
            Let state_transitions be Dictionary.get(automaton.transitions, state)
            If Dictionary.has_key(state_transitions, symbol):
                Let target_list be Dictionary.get(state_transitions, symbol)
                If not List.is_empty(target_list):
                    Return List.get(target_list, 0)
        Return ""
    
    Note: Create combined alphabet
    Let combined_alphabet be List.copy(dfa1.alphabet)
    For each symbol in dfa2.alphabet:
        If not List.contains(combined_alphabet, symbol):
            List.push(combined_alphabet, symbol)
    
    Note: Create product states
    Let product_states be List.create()
    Let product_transitions be Dictionary.create()
    Let product_accept_states be List.create()
    
    Note: Generate all state pairs
    For each state1 in dfa1.states:
        For each state2 in dfa2.states:
            Let product_state be String.concatenate(state1, String.concatenate(",", state2))
            List.push(product_states, product_state)
            
            Note: State is accepting if both components are accepting (intersection)
            If List.contains(dfa1.accept_states, state1) and List.contains(dfa2.accept_states, state2):
                List.push(product_accept_states, product_state)
    
    Note: Create transitions for product construction
    For each product_state in product_states:
        Let state_parts be String.split(product_state, ",")
        Let state1 be List.get(state_parts, 0)
        Let state2 be List.get(state_parts, 1)
        
        Let state_transitions be Dictionary.create()
        For each symbol in combined_alphabet:
            Let target1 be get_dfa_transition(dfa1, state1, symbol)
            Let target2 be get_dfa_transition(dfa2, state2, symbol)
            
            Note: If either automaton has no transition, use a sink state concept
            If String.equals(target1, ""):
                Let target1 be "SINK"
            If String.equals(target2, ""):
                Let target2 be "SINK"
            
            Let target_product_state be String.concatenate(target1, String.concatenate(",", target2))
            
            Note: Ensure target state exists in product states
            If not List.contains(product_states, target_product_state):
                List.push(product_states, target_product_state)
            
            Let target_list be List.create()
            List.push(target_list, target_product_state)
            Dictionary.set(state_transitions, symbol, target_list)
        
        Dictionary.set(product_transitions, product_state, state_transitions)
    
    Note: Identify start state
    Let product_start_state be String.concatenate(dfa1.start_state, String.concatenate(",", dfa2.start_state))
    
    Note: Create and return intersection automaton
    Let intersection_automaton be FiniteAutomaton with:
        states: product_states
        alphabet: combined_alphabet
        transitions: product_transitions
        start_state: product_start_state
        accept_states: product_accept_states
        automaton_type: "DFA_Intersection"
        is_deterministic: true
        state_count: List.size(product_states)
    
    Return intersection_automaton

Process called "compute_automaton_complement" that takes dfa as FiniteAutomaton returns FiniteAutomaton:
    Note: Compute complement of language recognized by DFA
    Note: Switches accept and non-accept states
    Note: Only works directly for complete DFAs
    
    Note: Helper function to get DFA transition
    Let get_dfa_transition be Process(state as String, symbol as String) returns String:
        If Dictionary.has_key(dfa.transitions, state):
            Let state_transitions be Dictionary.get(dfa.transitions, state)
            If Dictionary.has_key(state_transitions, symbol):
                Let target_list be Dictionary.get(state_transitions, symbol)
                If not List.is_empty(target_list):
                    Return List.get(target_list, 0)
        Return ""
    
    Note: Ensure DFA is complete by adding sink state if needed
    Let complete_states be List.copy(dfa.states)
    Let complete_transitions be Dictionary.create()
    Let sink_state_needed be false
    
    Note: Check if DFA is complete
    For each state in dfa.states:
        For each symbol in dfa.alphabet:
            Let target be get_dfa_transition(state, symbol)
            If String.equals(target, ""):
                Let sink_state_needed be true
                Break
        If sink_state_needed:
            Break
    
    Note: Add sink state if needed
    Let sink_state be "SINK"
    If sink_state_needed:
        List.push(complete_states, sink_state)
    
    Note: Build complete transition function
    For each state in complete_states:
        Let state_transitions be Dictionary.create()
        
        For each symbol in dfa.alphabet:
            If String.equals(state, sink_state):
                Note: Sink state transitions to itself
                Let target_list be List.create()
                List.push(target_list, sink_state)
                Dictionary.set(state_transitions, symbol, target_list)
            Otherwise:
                Let target be get_dfa_transition(state, symbol)
                If String.equals(target, ""):
                    Note: Missing transition goes to sink state
                    Let target_list be List.create()
                    List.push(target_list, sink_state)
                    Dictionary.set(state_transitions, symbol, target_list)
                Otherwise:
                    If Dictionary.has_key(dfa.transitions, state):
                        Let original_transitions be Dictionary.get(dfa.transitions, state)
                        If Dictionary.has_key(original_transitions, symbol):
                            Dictionary.set(state_transitions, symbol, Dictionary.get(original_transitions, symbol))
        
        Dictionary.set(complete_transitions, state, state_transitions)
    
    Note: Create complement accept states (all states except original accept states)
    Let complement_accept_states be List.create()
    For each state in complete_states:
        If not List.contains(dfa.accept_states, state):
            List.push(complement_accept_states, state)
    
    Note: Create and return complement automaton
    Let complement_automaton be FiniteAutomaton with:
        states: complete_states
        alphabet: dfa.alphabet
        transitions: complete_transitions
        start_state: dfa.start_state
        accept_states: complement_accept_states
        automaton_type: "DFA_Complement"
        is_deterministic: true
        state_count: List.size(complete_states)
    
    Return complement_automaton

Process called "compute_automaton_difference" that takes dfa1 as FiniteAutomaton, dfa2 as FiniteAutomaton returns FiniteAutomaton:
    Note: Compute difference L(A₁) minus L(A₂) of two languages
    Note: Uses intersection with complement: A₁ ∩ complement(A₂)
    Note: Removes from first language what second language accepts
    
    Note: Compute complement of second automaton
    Let complement_dfa2 be compute_automaton_complement(dfa2)
    
    Note: Compute intersection of first automaton with complement of second
    Let difference_automaton be compute_automaton_intersection(dfa1, complement_dfa2)
    
    Note: Update automaton type to indicate difference operation
    Let final_difference_automaton be FiniteAutomaton with:
        states: difference_automaton.states
        alphabet: difference_automaton.alphabet
        transitions: difference_automaton.transitions
        start_state: difference_automaton.start_state
        accept_states: difference_automaton.accept_states
        automaton_type: "DFA_Difference"
        is_deterministic: true
        state_count: difference_automaton.state_count
    
    Return final_difference_automaton

Note: =====================================================================
Note: CONTEXT-FREE GRAMMAR OPERATIONS
Note: =====================================================================

Process called "create_context_free_grammar" that takes non_terminals as List[String], terminals as List[String], productions as Dictionary[String, List[List[String]]], start_symbol as String returns Grammar:
    Note: Create context-free grammar (CFG)
    Note: Productions have single non-terminal on left side
    Note: More powerful than regular grammars, recognizes context-free languages
    
    Note: Validate inputs
    If List.is_empty(non_terminals):
        Throw Errors.InvalidArgument with "Non-terminals cannot be empty"
    If List.is_empty(terminals):
        Throw Errors.InvalidArgument with "Terminals cannot be empty"
    If not List.contains(non_terminals, start_symbol):
        Throw Errors.InvalidArgument with "Start symbol must be in non-terminals"
    
    Note: Validate that non-terminals and terminals are disjoint
    For each terminal in terminals:
        If List.contains(non_terminals, terminal):
            Throw Errors.InvalidArgument with "Terminals and non-terminals must be disjoint"
    
    Note: Validate productions
    For each non_terminal in non_terminals:
        If not Dictionary.has_key(productions, non_terminal):
            Note: Create empty production list for non-terminals without productions
            Dictionary.set(productions, non_terminal, List.create())
    
    Note: Validate production rules
    For each lhs in Dictionary.keys(productions):
        If not List.contains(non_terminals, lhs):
            Throw Errors.InvalidArgument with "Production left-hand side must be non-terminal"
        
        Let production_list be Dictionary.get(productions, lhs)
        For each production in production_list:
            For each symbol in production:
                If not List.contains(non_terminals, symbol) and not List.contains(terminals, symbol) and not String.equals(symbol, "ε"):
                    Throw Errors.InvalidArgument with "Production symbols must be terminals, non-terminals, or epsilon"
    
    Note: Determine grammar properties
    Let is_context_free be true
    Let is_regular be true
    
    Note: Check if grammar is regular (right-linear)
    For each lhs in Dictionary.keys(productions):
        Let production_list be Dictionary.get(productions, lhs)
        For each production in production_list:
            Let production_length be List.size(production)
            If production_length is greater than 2:
                Let is_regular be false
            If production_length is equal to 2:
                Let first_symbol be List.get(production, 0)
                Let second_symbol be List.get(production, 1)
                If not List.contains(terminals, first_symbol) or not List.contains(non_terminals, second_symbol):
                    Let is_regular be false
    
    Note: Create and return grammar
    Let cfg be Grammar with:
        non_terminals: non_terminals
        terminals: terminals
        productions: productions
        start_symbol: start_symbol
        grammar_type: "Context-Free"
        is_context_free: is_context_free
        is_regular: is_regular
    
    Return cfg

Process called "eliminate_left_recursion" that takes grammar as Grammar returns Grammar:
    Note: Eliminate left recursion from context-free grammar
    Note: Transforms A → Aα | β to A → βA', A' → αA' | ε
    Note: Required for top-down parsing algorithms
    
    Note: Create new grammar components
    Let new_non_terminals be List.copy(grammar.non_terminals)
    Let new_productions be Dictionary.create()
    Let prime_counter be 0
    
    Note: Copy original productions first
    For each non_terminal in grammar.non_terminals:
        If Dictionary.has_key(grammar.productions, non_terminal):
            Dictionary.set(new_productions, non_terminal, Dictionary.get(grammar.productions, non_terminal))
        Otherwise:
            Dictionary.set(new_productions, non_terminal, List.create())
    
    Note: Process each non-terminal for left recursion
    For each non_terminal in grammar.non_terminals:
        If Dictionary.has_key(grammar.productions, non_terminal):
            Let productions_list be Dictionary.get(grammar.productions, non_terminal)
            Let alpha_productions be List.create()  Note: A → Aα productions
            Let beta_productions be List.create()   Note: A → β productions
            
            Note: Classify productions
            For each production in productions_list:
                If not List.is_empty(production):
                    Let first_symbol be List.get(production, 0)
                    If String.equals(first_symbol, non_terminal):
                        Note: Left recursive production A → Aα
                        Let alpha_part be List.create()
                        For i from 1 to (List.size(production) minus 1):
                            List.push(alpha_part, List.get(production, i))
                        List.push(alpha_productions, alpha_part)
                    Otherwise:
                        Note: Non-left-recursive production A → β
                        List.push(beta_productions, production)
                Otherwise:
                    Note: Empty production A → ε
                    List.push(beta_productions, production)
            
            Note: If left recursion found, eliminate it
            If not List.is_empty(alpha_productions):
                Note: Create new non-terminal A'
                Let prime_non_terminal be String.concatenate(non_terminal, "'")
                While List.contains(new_non_terminals, prime_non_terminal):
                    Let prime_counter be prime_counter plus 1
                    Let prime_non_terminal be String.concatenate(non_terminal, String.concatenate("'", String.from_integer(prime_counter)))
                
                List.push(new_non_terminals, prime_non_terminal)
                
                Note: Transform A → β to A → βA'
                Let transformed_productions be List.create()
                For each beta in beta_productions:
                    Let new_beta be List.copy(beta)
                    List.push(new_beta, prime_non_terminal)
                    List.push(transformed_productions, new_beta)
                
                Note: If no beta productions, add A → A'
                If List.is_empty(beta_productions):
                    Let epsilon_prime_production be List.create()
                    List.push(epsilon_prime_production, prime_non_terminal)
                    List.push(transformed_productions, epsilon_prime_production)
                
                Dictionary.set(new_productions, non_terminal, transformed_productions)
                
                Note: Create A' → αA' | ε productions
                Let prime_productions be List.create()
                For each alpha in alpha_productions:
                    Let alpha_prime_production be List.copy(alpha)
                    List.push(alpha_prime_production, prime_non_terminal)
                    List.push(prime_productions, alpha_prime_production)
                
                Note: Add epsilon production A' → ε
                Let epsilon_production be List.create()
                List.push(epsilon_production, "ε")
                List.push(prime_productions, epsilon_production)
                
                Dictionary.set(new_productions, prime_non_terminal, prime_productions)
    
    Note: Create and return new grammar
    Let new_grammar be Grammar with:
        non_terminals: new_non_terminals
        terminals: grammar.terminals
        productions: new_productions
        start_symbol: grammar.start_symbol
        grammar_type: "Context-Free-NoLeftRec"
        is_context_free: true
        is_regular: false
    
    Return new_grammar

Process called "compute_first_sets" that takes grammar as Grammar returns Dictionary[String, List[String]]:
    Note: Compute FIRST sets for grammar symbols
    Note: FIRST(X) is equal to set of terminals that begin strings derived from X
    Note: Essential for predictive parsing algorithm construction
    
    Let first_sets be Dictionary.create()
    
    Note: Initialize FIRST sets for all symbols
    For each terminal in grammar.terminals:
        Let terminal_first_set be List.create()
        List.push(terminal_first_set, terminal)
        Dictionary.set(first_sets, terminal, terminal_first_set)
    
    For each non_terminal in grammar.non_terminals:
        Dictionary.set(first_sets, non_terminal, List.create())
    
    Note: Add epsilon to its own FIRST set
    If not Dictionary.has_key(first_sets, "ε"):
        Let epsilon_first_set be List.create()
        List.push(epsilon_first_set, "ε")
        Dictionary.set(first_sets, "ε", epsilon_first_set)
    
    Note: Iteratively compute FIRST sets until no changes
    Let changed be true
    While changed:
        Let changed be false
        
        For each non_terminal in grammar.non_terminals:
            If Dictionary.has_key(grammar.productions, non_terminal):
                Let productions_list be Dictionary.get(grammar.productions, non_terminal)
                
                For each production in productions_list:
                    If List.is_empty(production):
                        Note: Empty production, add epsilon
                        Let current_first_set be Dictionary.get(first_sets, non_terminal)
                        If not List.contains(current_first_set, "ε"):
                            List.push(current_first_set, "ε")
                            Let changed be true
                    Otherwise:
                        Note: Process production symbols from left to right
                        Let all_have_epsilon be true
                        For i from 0 to (List.size(production) minus 1):
                            Let symbol be List.get(production, i)
                            
                            If Dictionary.has_key(first_sets, symbol):
                                Let symbol_first_set be Dictionary.get(first_sets, symbol)
                                Let current_first_set be Dictionary.get(first_sets, non_terminal)
                                
                                Note: Add all non-epsilon symbols from FIRST(symbol)
                                For each first_symbol in symbol_first_set:
                                    If not String.equals(first_symbol, "ε") and not List.contains(current_first_set, first_symbol):
                                        List.push(current_first_set, first_symbol)
                                        Let changed be true
                                
                                Note: If epsilon not in FIRST(symbol), stop
                                If not List.contains(symbol_first_set, "ε"):
                                    Let all_have_epsilon be false
                                    Break
                            Otherwise:
                                Let all_have_epsilon be false
                                Break
                        
                        Note: If all symbols can derive epsilon, add epsilon to FIRST(non_terminal)
                        If all_have_epsilon:
                            Let current_first_set be Dictionary.get(first_sets, non_terminal)
                            If not List.contains(current_first_set, "ε"):
                                List.push(current_first_set, "ε")
                                Let changed be true
    
    Return first_sets

Process called "compute_follow_sets" that takes grammar as Grammar returns Dictionary[String, List[String]]:
    Note: Compute FOLLOW sets for non-terminal symbols
    Note: FOLLOW(A) is equal to set of terminals that can appear after A
    Note: Used with FIRST sets for LL parser construction
    
    Note: First compute FIRST sets which are needed for FOLLOW computation
    Let first_sets be compute_first_sets(grammar)
    Let follow_sets be Dictionary.create()
    
    Note: Initialize FOLLOW sets for all non-terminals
    For each non_terminal in grammar.non_terminals:
        Dictionary.set(follow_sets, non_terminal, List.create())
    
    Note: Add $ to FOLLOW(start_symbol)
    Let start_follow_set be Dictionary.get(follow_sets, grammar.start_symbol)
    List.push(start_follow_set, "$")
    
    Note: Iteratively compute FOLLOW sets until no changes
    Let changed be true
    While changed:
        Let changed be false
        
        For each non_terminal in grammar.non_terminals:
            If Dictionary.has_key(grammar.productions, non_terminal):
                Let productions_list be Dictionary.get(grammar.productions, non_terminal)
                
                For each production in productions_list:
                    For i from 0 to (List.size(production) minus 1):
                        Let symbol be List.get(production, i)
                        
                        Note: Only process non-terminals
                        If List.contains(grammar.non_terminals, symbol):
                            Let symbol_follow_set be Dictionary.get(follow_sets, symbol)
                            
                            Note: Look at symbols after current symbol
                            If i is less than (List.size(production) minus 1):
                                Note: Process beta is equal to symbols after current symbol
                                Let beta_first_set be List.create()
                                Let all_beta_have_epsilon be true
                                
                                For j from (i plus 1) to (List.size(production) minus 1):
                                    Let beta_symbol be List.get(production, j)
                                    
                                    If Dictionary.has_key(first_sets, beta_symbol):
                                        Let beta_symbol_first be Dictionary.get(first_sets, beta_symbol)
                                        
                                        Note: Add non-epsilon symbols from FIRST(beta_symbol)
                                        For each first_sym in beta_symbol_first:
                                            If not String.equals(first_sym, "ε") and not List.contains(beta_first_set, first_sym):
                                                List.push(beta_first_set, first_sym)
                                        
                                        Note: If epsilon not in FIRST(beta_symbol), stop
                                        If not List.contains(beta_symbol_first, "ε"):
                                            Let all_beta_have_epsilon be false
                                            Break
                                    Otherwise:
                                        Let all_beta_have_epsilon be false
                                        Break
                                
                                Note: Add FIRST(beta) minus {ε} to FOLLOW(symbol)
                                For each beta_first in beta_first_set:
                                    If not List.contains(symbol_follow_set, beta_first):
                                        List.push(symbol_follow_set, beta_first)
                                        Let changed be true
                                
                                Note: If epsilon in FIRST(beta), add FOLLOW(non_terminal) to FOLLOW(symbol)
                                If all_beta_have_epsilon:
                                    Let lhs_follow_set be Dictionary.get(follow_sets, non_terminal)
                                    For each lhs_follow in lhs_follow_set:
                                        If not List.contains(symbol_follow_set, lhs_follow):
                                            List.push(symbol_follow_set, lhs_follow)
                                            Let changed be true
                            Otherwise:
                                Note: Symbol is at end of production, add FOLLOW(non_terminal) to FOLLOW(symbol)
                                Let lhs_follow_set be Dictionary.get(follow_sets, non_terminal)
                                For each lhs_follow in lhs_follow_set:
                                    If not List.contains(symbol_follow_set, lhs_follow):
                                        List.push(symbol_follow_set, lhs_follow)
                                        Let changed be true
    
    Return follow_sets

Note: =====================================================================
Note: PARSING OPERATIONS
Note: =====================================================================

Process called "parse_cky_algorithm" that takes grammar as Grammar, input_string as String returns ParseTree:
    Note: Parse string using CYK (Cocke-Younger-Kasami) algorithm
    Note: Dynamic programming approach for CFGs in Chomsky Normal Form
    Note: Time complexity: O(n³ × |G|), works for any CFG
    
    Let n be String.length(input_string)
    
    Note: Handle empty string case
    If n is equal to 0:
        Note: Check if start symbol can derive epsilon
        If Dictionary.has_key(grammar.productions, grammar.start_symbol):
            Let start_productions be Dictionary.get(grammar.productions, grammar.start_symbol)
            For each production in start_productions:
                If List.size(production) is equal to 1 and String.equals(List.get(production, 0), "ε"):
                    Let empty_tree be ParseTree with:
                        root_symbol: grammar.start_symbol
                        tree_structure: Dictionary.create()
                        leaf_symbols: List.create()
                        derivation_sequence: List.from_array([grammar.start_symbol])
                        is_valid_derivation: true
                    Return empty_tree
        
        Note: Empty string not accepted
        Let invalid_tree be ParseTree with:
            root_symbol: ""
            tree_structure: Dictionary.create()
            leaf_symbols: List.create()
            derivation_sequence: List.create()
            is_valid_derivation: false
        Return invalid_tree
    
    Note: Initialize CYK table minus table[i][j] contains non-terminals that can derive substring from i with length j
    Let table be Dictionary.create()
    For i from 0 to (n minus 1):
        Dictionary.set(table, String.from_integer(i), Dictionary.create())
        For j from 1 to (n minus i):
            Let i_dict be Dictionary.get(table, String.from_integer(i))
            Dictionary.set(i_dict, String.from_integer(j), List.create())
    
    Note: Fill table for length 1 (terminals)
    For i from 0 to (n minus 1):
        Let terminal be String.character_at(input_string, i)
        Let i_dict be Dictionary.get(table, String.from_integer(i))
        Let cell_1 be Dictionary.get(i_dict, "1")
        
        Note: Find non-terminals that can derive this terminal
        For each non_terminal in grammar.non_terminals:
            If Dictionary.has_key(grammar.productions, non_terminal):
                Let productions_list be Dictionary.get(grammar.productions, non_terminal)
                For each production in productions_list:
                    If List.size(production) is equal to 1 and String.equals(List.get(production, 0), terminal):
                        If not List.contains(cell_1, non_terminal):
                            List.push(cell_1, non_terminal)
    
    Note: Fill table for lengths 2 to n
    For length from 2 to n:
        For i from 0 to (n minus length):
            Let i_dict be Dictionary.get(table, String.from_integer(i))
            Let current_cell be Dictionary.get(i_dict, String.from_integer(length))
            
            Note: Try all possible splits
            For k from 1 to (length minus 1):
                Let left_cell be Dictionary.get(i_dict, String.from_integer(k))
                Let right_i be i plus k
                Let right_dict be Dictionary.get(table, String.from_integer(right_i))
                Let right_cell be Dictionary.get(right_dict, String.from_integer(length minus k))
                
                Note: Check all combinations of left and right non-terminals
                For each left_nt in left_cell:
                    For each right_nt in right_cell:
                        Note: Find productions A → BC where B is left_nt and C is right_nt
                        For each non_terminal in grammar.non_terminals:
                            If Dictionary.has_key(grammar.productions, non_terminal):
                                Let productions_list be Dictionary.get(grammar.productions, non_terminal)
                                For each production in productions_list:
                                    If List.size(production) is equal to 2:
                                        Let first_symbol be List.get(production, 0)
                                        Let second_symbol be List.get(production, 1)
                                        If String.equals(first_symbol, left_nt) and String.equals(second_symbol, right_nt):
                                            If not List.contains(current_cell, non_terminal):
                                                List.push(current_cell, non_terminal)
    
    Note: Check if start symbol can derive the entire string
    Let start_dict be Dictionary.get(table, "0")
    Let final_cell be Dictionary.get(start_dict, String.from_integer(n))
    
    If List.contains(final_cell, grammar.start_symbol):
        Note: Construct parse tree from CYK parsing table
        Let tree_structure be Dictionary.create()
        Dictionary.set(tree_structure, grammar.start_symbol, List.from_array([input_string]))
        
        Let leaf_symbols be List.create()
        For i from 0 to (n minus 1):
            List.push(leaf_symbols, String.character_at(input_string, i))
        
        Let derivation_sequence be List.create()
        List.push(derivation_sequence, grammar.start_symbol)
        List.push(derivation_sequence, input_string)
        
        Let parse_tree be ParseTree with:
            root_symbol: grammar.start_symbol
            tree_structure: tree_structure
            leaf_symbols: leaf_symbols
            derivation_sequence: derivation_sequence
            is_valid_derivation: true
        
        Return parse_tree
    Otherwise:
        Note: String not in language
        Let invalid_tree be ParseTree with:
            root_symbol: ""
            tree_structure: Dictionary.create()
            leaf_symbols: List.create()
            derivation_sequence: List.create()
            is_valid_derivation: false
        
        Return invalid_tree

Process called "parse_earley_algorithm" that takes grammar as Grammar, input_string as String returns ParseTree:
    Note: Parse string using Earley's algorithm
    Note: Works with any CFG, handles ambiguous grammars
    Note: Time complexity: O(n³) general, O(n²) unambiguous, O(n) deterministic
    
    Let n be String.length(input_string)
    
    Note: Initialize Earley chart minus chart[i] contains items for position i
    Let chart be List.create()
    For i from 0 to n:
        List.push(chart, List.create())
    
    Note: Helper function to create Earley item
    Let create_item be Process(lhs as String, rhs as List[String], dot as Integer, origin as Integer) returns Dictionary[String, String]:
        Let item be Dictionary.create()
        Dictionary.set(item, "lhs", lhs)
        Dictionary.set(item, "rhs", String.join(rhs, " "))
        Dictionary.set(item, "dot", String.from_integer(dot))
        Dictionary.set(item, "origin", String.from_integer(origin))
        Return item
    
    Note: Helper function to check if item already exists in chart
    Let item_exists be Process(chart_set as List[Dictionary[String, String]], item as Dictionary[String, String]) returns Boolean:
        For each existing_item in chart_set:
            If String.equals(Dictionary.get(existing_item, "lhs"), Dictionary.get(item, "lhs")) and 
               String.equals(Dictionary.get(existing_item, "rhs"), Dictionary.get(item, "rhs")) and
               String.equals(Dictionary.get(existing_item, "dot"), Dictionary.get(item, "dot")) and
               String.equals(Dictionary.get(existing_item, "origin"), Dictionary.get(item, "origin")):
                Return true
        Return false
    
    Note: Initialize chart with start items
    Let start_chart be List.get(chart, 0)
    If Dictionary.has_key(grammar.productions, grammar.start_symbol):
        Let start_productions be Dictionary.get(grammar.productions, grammar.start_symbol)
        For each production in start_productions:
            Let start_item be create_item(grammar.start_symbol, production, 0, 0)
            List.push(start_chart, start_item)
    
    Note: Process each chart position
    For i from 0 to n:
        Let current_chart be List.get(chart, i)
        Let j be 0
        While j is less than List.size(current_chart):
            Let item be List.get(current_chart, j)
            Let lhs be Dictionary.get(item, "lhs")
            Let rhs_str be Dictionary.get(item, "rhs")
            Let rhs be String.split(rhs_str, " ")
            Let dot be String.to_integer(Dictionary.get(item, "dot"))
            Let origin be String.to_integer(Dictionary.get(item, "origin"))
            
            If dot is less than List.size(rhs):
                Let next_symbol be List.get(rhs, dot)
                
                Note: Predict step minus if next symbol is non-terminal
                If List.contains(grammar.non_terminals, next_symbol):
                    If Dictionary.has_key(grammar.productions, next_symbol):
                        Let next_productions be Dictionary.get(grammar.productions, next_symbol)
                        For each next_production in next_productions:
                            Let predict_item be create_item(next_symbol, next_production, 0, i)
                            If not item_exists(current_chart, predict_item):
                                List.push(current_chart, predict_item)
                
                Note: Scan step minus if next symbol matches current input
                If i is less than n:
                    Let current_char be String.character_at(input_string, i)
                    If String.equals(next_symbol, current_char):
                        Let next_chart be List.get(chart, i plus 1)
                        Let scan_item be create_item(lhs, rhs, dot plus 1, origin)
                        If not item_exists(next_chart, scan_item):
                            List.push(next_chart, scan_item)
            Otherwise:
                Note: Complete step minus item is complete
                Let origin_chart be List.get(chart, origin)
                For each origin_item in origin_chart:
                    Let origin_lhs be Dictionary.get(origin_item, "lhs")
                    Let origin_rhs_str be Dictionary.get(origin_item, "rhs")
                    Let origin_rhs be String.split(origin_rhs_str, " ")
                    Let origin_dot be String.to_integer(Dictionary.get(origin_item, "dot"))
                    Let origin_origin be String.to_integer(Dictionary.get(origin_item, "origin"))
                    
                    If origin_dot is less than List.size(origin_rhs):
                        Let expected_symbol be List.get(origin_rhs, origin_dot)
                        If String.equals(expected_symbol, lhs):
                            Let complete_item be create_item(origin_lhs, origin_rhs, origin_dot plus 1, origin_origin)
                            If not item_exists(current_chart, complete_item):
                                List.push(current_chart, complete_item)
            
            Let j be j plus 1
    
    Note: Check if parsing succeeded
    Let final_chart be List.get(chart, n)
    For each final_item in final_chart:
        Let final_lhs be Dictionary.get(final_item, "lhs")
        Let final_rhs_str be Dictionary.get(final_item, "rhs")
        Let final_rhs be String.split(final_rhs_str, " ")
        Let final_dot be String.to_integer(Dictionary.get(final_item, "dot"))
        Let final_origin be String.to_integer(Dictionary.get(final_item, "origin"))
        
        If String.equals(final_lhs, grammar.start_symbol) and final_dot is equal to List.size(final_rhs) and final_origin is equal to 0:
            Note: Successful parse minus construct tree
            Let tree_structure be Dictionary.create()
            Dictionary.set(tree_structure, grammar.start_symbol, List.from_array([input_string]))
            
            Let leaf_symbols be List.create()
            For k from 0 to (n minus 1):
                List.push(leaf_symbols, String.character_at(input_string, k))
            
            Let derivation_sequence be List.create()
            List.push(derivation_sequence, grammar.start_symbol)
            List.push(derivation_sequence, input_string)
            
            Let parse_tree be ParseTree with:
                root_symbol: grammar.start_symbol
                tree_structure: tree_structure
                leaf_symbols: leaf_symbols
                derivation_sequence: derivation_sequence
                is_valid_derivation: true
            
            Return parse_tree
    
    Note: Parsing failed
    Let invalid_tree be ParseTree with:
        root_symbol: ""
        tree_structure: Dictionary.create()
        leaf_symbols: List.create()
        derivation_sequence: List.create()
        is_valid_derivation: false
    
    Return invalid_tree

Process called "parse_ll_recursive_descent" that takes grammar as Grammar, input_string as String returns ParseTree:
    Note: Parse using LL recursive descent parser
    Note: Top-down parsing with recursive procedures for non-terminals
    Note: Requires LL(k) grammar, no left recursion
    
    Note: Get FIRST and FOLLOW sets needed for LL parsing
    Let first_sets be compute_first_sets(grammar)
    Let follow_sets be compute_follow_sets(grammar)
    
    Note: Global parsing state
    Let input_tokens be List.create()
    For i from 0 to (String.length(input_string) minus 1):
        List.push(input_tokens, String.character_at(input_string, i))
    List.push(input_tokens, "$")  Note: End marker
    
    Let current_token_index be 0
    Let derivation_steps be List.create()
    Let parse_successful be true
    
    Note: Helper function to get current token
    Let current_token be Process() returns String:
        If current_token_index is less than List.size(input_tokens):
            Return List.get(input_tokens, current_token_index)
        Return "$"
    
    Note: Helper function to consume token
    Let consume_token be Process(expected as String) returns Boolean:
        Let token be current_token()
        If String.equals(token, expected):
            Let current_token_index be current_token_index plus 1
            Return true
        Otherwise:
            Let parse_successful be false
            Return false
    
    Note: Helper function to parse non-terminal
    Let parse_non_terminal be Process(non_terminal as String) returns Boolean:
        List.push(derivation_steps, String.concatenate("Expanding ", non_terminal))
        
        If not Dictionary.has_key(grammar.productions, non_terminal):
            Let parse_successful be false
            Return false
        
        Let productions_list be Dictionary.get(grammar.productions, non_terminal)
        Let token be current_token()
        
        Note: Find production to use based on FIRST sets
        For each production in productions_list:
            Let can_use_production be false
            
            If List.is_empty(production):
                Note: Epsilon production
                If Dictionary.has_key(follow_sets, non_terminal):
                    Let follow_set be Dictionary.get(follow_sets, non_terminal)
                    If List.contains(follow_set, token):
                        Let can_use_production be true
            Otherwise:
                Let first_symbol be List.get(production, 0)
                
                If List.contains(grammar.terminals, first_symbol):
                    Note: Production starts with terminal
                    If String.equals(first_symbol, token):
                        Let can_use_production be true
                Otherwise:
                    Note: Production starts with non-terminal
                    If Dictionary.has_key(first_sets, first_symbol):
                        Let first_symbol_set be Dictionary.get(first_sets, first_symbol)
                        If List.contains(first_symbol_set, token):
                            Let can_use_production be true
                        If List.contains(first_symbol_set, "ε"):
                            Note: Check if token can follow this production
                            If Dictionary.has_key(follow_sets, non_terminal):
                                Let follow_set be Dictionary.get(follow_sets, non_terminal)
                                If List.contains(follow_set, token):
                                    Let can_use_production be true
            
            If can_use_production:
                List.push(derivation_steps, String.concatenate(non_terminal, String.concatenate(" → ", String.join(production, " "))))
                
                Note: Parse each symbol in production
                For each symbol in production:
                    If String.equals(symbol, "ε"):
                        Note: Skip epsilon
                        Continue
                    
                    If List.contains(grammar.terminals, symbol):
                        If not consume_token(symbol):
                            Return false
                    Otherwise:
                        If not parse_non_terminal(symbol):
                            Return false
                
                Return true
        
        Note: No suitable production found
        Let parse_successful be false
        Return false
    
    Note: Start parsing from start symbol
    Let parsing_result be parse_non_terminal(grammar.start_symbol)
    
    Note: Check if we consumed all input
    If parsing_result and String.equals(current_token(), "$"):
        Note: Successful parse
        Let tree_structure be Dictionary.create()
        Dictionary.set(tree_structure, grammar.start_symbol, List.from_array([input_string]))
        
        Let leaf_symbols be List.create()
        For i from 0 to (String.length(input_string) minus 1):
            List.push(leaf_symbols, String.character_at(input_string, i))
        
        Let parse_tree be ParseTree with:
            root_symbol: grammar.start_symbol
            tree_structure: tree_structure
            leaf_symbols: leaf_symbols
            derivation_sequence: derivation_steps
            is_valid_derivation: true
        
        Return parse_tree
    Otherwise:
        Note: Parse failed
        Let invalid_tree be ParseTree with:
            root_symbol: ""
            tree_structure: Dictionary.create()
            leaf_symbols: List.create()
            derivation_sequence: derivation_steps
            is_valid_derivation: false
        
        Return invalid_tree

Process called "parse_lr_shift_reduce" that takes grammar as Grammar, input_string as String returns ParseTree:
    Note: Parse using LR shift-reduce parser
    Note: Bottom-up parsing with shift/reduce actions
    Note: More powerful than LL, handles left-recursive grammars
    
    Note: Initialize parsing stack and input buffer
    Let stack be List.create()
    Let input_buffer be List.create()
    For i from 0 to (String.length(input_string) minus 1):
        List.push(input_buffer, String.character_at(input_string, i))
    List.push(input_buffer, "$")  Note: End marker
    
    Let reduction_steps be List.create()
    Let current_input_index be 0
    
    Note: Helper function to get next input symbol
    Let peek_input be Process() returns String:
        If current_input_index is less than List.size(input_buffer):
            Return List.get(input_buffer, current_input_index)
        Return "$"
    
    Note: Helper function to shift symbol onto stack
    Let shift_symbol be Process() returns Void:
        If current_input_index is less than List.size(input_buffer):
            Let symbol be List.get(input_buffer, current_input_index)
            List.push(stack, symbol)
            Let current_input_index be current_input_index plus 1
    
    Note: Helper function to check for possible reductions
    Let try_reduce be Process() returns Boolean:
        For each lhs in Dictionary.keys(grammar.productions):
            Let productions_list be Dictionary.get(grammar.productions, lhs)
            For each production in productions_list:
                Let production_length be List.size(production)
                
                Note: Skip epsilon productions for simplicity
                If production_length is equal to 0 or (production_length is equal to 1 and String.equals(List.get(production, 0), "ε")):
                    Continue
                
                Note: Check if top of stack matches production right-hand side
                If List.size(stack) is greater than or equal to production_length:
                    Let matches be true
                    For i from 0 to (production_length minus 1):
                        Let stack_index be List.size(stack) minus production_length plus i
                        Let stack_symbol be List.get(stack, stack_index)
                        Let production_symbol be List.get(production, i)
                        If not String.equals(stack_symbol, production_symbol):
                            Let matches be false
                            Break
                    
                    If matches:
                        Note: Perform reduction
                        For i from 0 to (production_length minus 1):
                            List.pop(stack)
                        
                        List.push(stack, lhs)
                        List.push(reduction_steps, String.concatenate("Reduce: ", String.concatenate(lhs, String.concatenate(" ← ", String.join(production, " ")))))
                        Return true
        
        Return false
    
    Note: Main parsing loop
    While true:
        Note: Try reductions first
        While try_reduce():
            Continue
        
        Note: Check for acceptance
        If List.size(stack) is equal to 1 and String.equals(List.get(stack, 0), grammar.start_symbol) and String.equals(peek_input(), "$"):
            Note: Successful parse
            Let tree_structure be Dictionary.create()
            Dictionary.set(tree_structure, grammar.start_symbol, List.from_array([input_string]))
            
            Let leaf_symbols be List.create()
            For i from 0 to (String.length(input_string) minus 1):
                List.push(leaf_symbols, String.character_at(input_string, i))
            
            Let parse_tree be ParseTree with:
                root_symbol: grammar.start_symbol
                tree_structure: tree_structure
                leaf_symbols: leaf_symbols
                derivation_sequence: reduction_steps
                is_valid_derivation: true
            
            Return parse_tree
        
        Note: Check for parsing error
        Let input_symbol be peek_input()
        If String.equals(input_symbol, "$"):
            Note: End of input but not accepted
            Break
        
        Note: Shift next input symbol
        shift_symbol()
        List.push(reduction_steps, String.concatenate("Shift: ", input_symbol))
        
        Note: Safety check to prevent infinite loops
        If current_input_index is greater than String.length(input_string) plus 10:
            Break
    
    Note: Parse failed
    Let invalid_tree be ParseTree with:
        root_symbol: ""
        tree_structure: Dictionary.create()
        leaf_symbols: List.create()
        derivation_sequence: reduction_steps
        is_valid_derivation: false
    
    Return invalid_tree

Note: =====================================================================
Note: PUSHDOWN AUTOMATON OPERATIONS
Note: =====================================================================

Process called "create_pushdown_automaton" that takes states as List[String], input_alphabet as List[String], stack_alphabet as List[String], transitions as Dictionary[String, List[Dictionary[String, String]]], start_state as String, start_stack_symbol as String, accept_states as List[String] returns Dictionary[String, String]:
    Note: Create pushdown automaton (PDA) for context-free languages
    Note: Has input tape and stack for memory
    Note: Equivalent in power to context-free grammars
    
    Note: Validate inputs
    If List.is_empty(states):
        Throw Errors.InvalidArgument with "States cannot be empty"
    If List.is_empty(input_alphabet):
        Throw Errors.InvalidArgument with "Input alphabet cannot be empty"
    If List.is_empty(stack_alphabet):
        Throw Errors.InvalidArgument with "Stack alphabet cannot be empty"
    If not List.contains(states, start_state):
        Throw Errors.InvalidArgument with "Start state must be in states list"
    If not List.contains(stack_alphabet, start_stack_symbol):
        Throw Errors.InvalidArgument with "Start stack symbol must be in stack alphabet"
    
    Note: Validate accept states
    For each accept_state in accept_states:
        If not List.contains(states, accept_state):
            Throw Errors.InvalidArgument with "Accept state not in states list"
    
    Note: Validate transition function
    For each state in Dictionary.keys(transitions):
        If not List.contains(states, state):
            Throw Errors.InvalidArgument with "Transition state not in states list"
        
        Let state_transitions be Dictionary.get(transitions, state)
        For each transition in state_transitions:
            Note: Each transition should have: input_symbol, stack_top, next_state, stack_push
            If not Dictionary.has_key(transition, "input_symbol"):
                Throw Errors.InvalidArgument with "Transition missing input_symbol"
            If not Dictionary.has_key(transition, "stack_top"):
                Throw Errors.InvalidArgument with "Transition missing stack_top"
            If not Dictionary.has_key(transition, "next_state"):
                Throw Errors.InvalidArgument with "Transition missing next_state"
            If not Dictionary.has_key(transition, "stack_push"):
                Throw Errors.InvalidArgument with "Transition missing stack_push"
            
            Let input_symbol be Dictionary.get(transition, "input_symbol")
            Let stack_top be Dictionary.get(transition, "stack_top")
            Let next_state be Dictionary.get(transition, "next_state")
            Let stack_push be Dictionary.get(transition, "stack_push")
            
            Note: Validate symbols are in appropriate alphabets
            If not String.equals(input_symbol, "ε") and not List.contains(input_alphabet, input_symbol):
                Throw Errors.InvalidArgument with "Input symbol not in input alphabet"
            If not List.contains(stack_alphabet, stack_top):
                Throw Errors.InvalidArgument with "Stack symbol not in stack alphabet"
            If not List.contains(states, next_state):
                Throw Errors.InvalidArgument with "Next state not in states list"
            
            Note: Validate stack push string
            For i from 0 to (String.length(stack_push) minus 1):
                Let push_char be String.character_at(stack_push, i)
                If not String.equals(push_char, "ε") and not List.contains(stack_alphabet, push_char):
                    Throw Errors.InvalidArgument with "Push symbol not in stack alphabet"
    
    Note: Create PDA representation
    Let pda be Dictionary.create()
    Dictionary.set(pda, "states", String.join(states, ","))
    Dictionary.set(pda, "input_alphabet", String.join(input_alphabet, ","))
    Dictionary.set(pda, "stack_alphabet", String.join(stack_alphabet, ","))
    Dictionary.set(pda, "start_state", start_state)
    Dictionary.set(pda, "start_stack_symbol", start_stack_symbol)
    Dictionary.set(pda, "accept_states", String.join(accept_states, ","))
    Dictionary.set(pda, "type", "PDA")
    Dictionary.set(pda, "state_count", String.from_integer(List.size(states)))
    
    Note: Serialize transitions
    Let transition_strings be List.create()
    For each state in Dictionary.keys(transitions):
        Let state_transitions be Dictionary.get(transitions, state)
        For each transition in state_transitions:
            Let input_symbol be Dictionary.get(transition, "input_symbol")
            Let stack_top be Dictionary.get(transition, "stack_top")
            Let next_state be Dictionary.get(transition, "next_state")
            Let stack_push be Dictionary.get(transition, "stack_push")
            
            Let transition_str be String.concatenate(state, String.concatenate(":", String.concatenate(input_symbol, String.concatenate(":", String.concatenate(stack_top, String.concatenate(":", String.concatenate(next_state, String.concatenate(":", stack_push))))))))
            List.push(transition_strings, transition_str)
    
    Dictionary.set(pda, "transitions", String.join(transition_strings, ";"))
    
    Return pda

Process called "simulate_pushdown_automaton" that takes pda as Dictionary[String, String], input_string as String returns Boolean:
    Note: Simulate PDA execution on input string
    Note: Nondeterministic execution with stack operations
    Note: Accepts if reaches accept state with empty stack (or accept state)
    
    Note: Parse PDA components
    Let states_str be Dictionary.get(pda, "states")
    Let states be String.split(states_str, ",")
    Let input_alphabet_str be Dictionary.get(pda, "input_alphabet")
    Let input_alphabet be String.split(input_alphabet_str, ",")
    Let stack_alphabet_str be Dictionary.get(pda, "stack_alphabet")
    Let stack_alphabet be String.split(stack_alphabet_str, ",")
    Let start_state be Dictionary.get(pda, "start_state")
    Let start_stack_symbol be Dictionary.get(pda, "start_stack_symbol")
    Let accept_states_str be Dictionary.get(pda, "accept_states")
    Let accept_states be String.split(accept_states_str, ",")
    
    Note: Parse transitions
    Let transitions_str be Dictionary.get(pda, "transitions")
    Let transition_list be String.split(transitions_str, ";")
    Let transitions be Dictionary.create()
    
    For each trans_str in transition_list:
        If not String.equals(trans_str, ""):
            Let parts be String.split(trans_str, ":")
            If List.size(parts) is equal to 5:
                Let from_state be List.get(parts, 0)
                Let input_symbol be List.get(parts, 1)
                Let stack_top be List.get(parts, 2)
                Let to_state be List.get(parts, 3)
                Let stack_push be List.get(parts, 4)
                
                Note: Create transition key
                Let trans_key be String.concatenate(from_state, String.concatenate(":", String.concatenate(input_symbol, String.concatenate(":", stack_top))))
                
                If not Dictionary.has_key(transitions, trans_key):
                    Dictionary.set(transitions, trans_key, List.create())
                
                Let target_list be Dictionary.get(transitions, trans_key)
                Let target_info be Dictionary.create()
                Dictionary.set(target_info, "to_state", to_state)
                Dictionary.set(target_info, "stack_push", stack_push)
                List.push(target_list, target_info)
    
    Note: Configuration: (state, input_position, stack)
    Let configurations be List.create()
    Let initial_stack be List.create()
    List.push(initial_stack, start_stack_symbol)
    
    Let initial_config be Dictionary.create()
    Dictionary.set(initial_config, "state", start_state)
    Dictionary.set(initial_config, "input_pos", "0")
    Dictionary.set(initial_config, "stack", String.join(initial_stack, ""))
    List.push(configurations, initial_config)
    
    Let input_length be String.length(input_string)
    Let max_steps be 1000  Note: Prevent infinite loops
    Let step_count be 0
    
    Note: BFS through configurations
    While not List.is_empty(configurations) and step_count is less than max_steps:
        Let step_count be step_count plus 1
        Let current_config be List.pop_front(configurations)
        Let current_state be Dictionary.get(current_config, "state")
        Let input_pos be String.to_integer(Dictionary.get(current_config, "input_pos"))
        Let stack_str be Dictionary.get(current_config, "stack")
        
        Note: Check acceptance conditions
        Let is_accept_state be List.contains(accept_states, current_state)
        Let is_end_of_input be (input_pos is greater than or equal to input_length)
        Let is_empty_stack be String.equals(stack_str, "")
        
        If is_accept_state and is_end_of_input:
            Return true  Note: Accept by final state
        
        If is_accept_state and is_end_of_input and is_empty_stack:
            Return true  Note: Accept by empty stack
        
        Note: Get current input symbol
        Let current_input be "ε"
        If input_pos is less than input_length:
            Let current_input be String.character_at(input_string, input_pos)
        
        Note: Get stack top
        Let stack_top be "ε"
        If not String.equals(stack_str, ""):
            Let stack_top be String.character_at(stack_str, String.length(stack_str) minus 1)
        
        Note: Try epsilon transitions
        Let epsilon_key be String.concatenate(current_state, String.concatenate(":", String.concatenate("ε", String.concatenate(":", stack_top))))
        If Dictionary.has_key(transitions, epsilon_key):
            Let epsilon_targets be Dictionary.get(transitions, epsilon_key)
            For each target in epsilon_targets:
                Let to_state be Dictionary.get(target, "to_state")
                Let stack_push be Dictionary.get(target, "stack_push")
                
                Note: Compute new stack
                Let new_stack be stack_str
                If not String.equals(stack_str, ""):
                    Let new_stack be String.substring(stack_str, 0, String.length(stack_str) minus 1)
                
                If not String.equals(stack_push, "ε"):
                    Let new_stack be String.concatenate(new_stack, stack_push)
                
                Note: Add new configuration
                Let new_config be Dictionary.create()
                Dictionary.set(new_config, "state", to_state)
                Dictionary.set(new_config, "input_pos", String.from_integer(input_pos))
                Dictionary.set(new_config, "stack", new_stack)
                List.push(configurations, new_config)
        
        Note: Try input symbol transitions
        If input_pos is less than input_length:
            Let input_key be String.concatenate(current_state, String.concatenate(":", String.concatenate(current_input, String.concatenate(":", stack_top))))
            If Dictionary.has_key(transitions, input_key):
                Let input_targets be Dictionary.get(transitions, input_key)
                For each target in input_targets:
                    Let to_state be Dictionary.get(target, "to_state")
                    Let stack_push be Dictionary.get(target, "stack_push")
                    
                    Note: Compute new stack
                    Let new_stack be stack_str
                    If not String.equals(stack_str, ""):
                        Let new_stack be String.substring(stack_str, 0, String.length(stack_str) minus 1)
                    
                    If not String.equals(stack_push, "ε"):
                        Let new_stack be String.concatenate(new_stack, stack_push)
                    
                    Note: Add new configuration
                    Let new_config be Dictionary.create()
                    Dictionary.set(new_config, "state", to_state)
                    Dictionary.set(new_config, "input_pos", String.from_integer(input_pos plus 1))
                    Dictionary.set(new_config, "stack", new_stack)
                    List.push(configurations, new_config)
    
    Note: No accepting configuration found
    Return false

Process called "cfg_to_pda_conversion" that takes grammar as Grammar returns Dictionary[String, String]:
    Note: Convert context-free grammar to equivalent PDA
    Note: Standard construction using stack to simulate derivations
    Note: Demonstrates equivalence of CFGs and PDAs
    
    Note: Create PDA components
    Let states be List.create()
    List.push(states, "q0")  Note: Start state
    List.push(states, "q1")  Note: Main processing state
    List.push(states, "q2")  Note: Accept state
    
    Let alphabet be List.copy(grammar.terminals)
    List.remove_all(alphabet, "ε")  Note: Remove epsilon from alphabet
    
    Let stack_alphabet be List.create()
    List.push(stack_alphabet, "Z0")  Note: Bottom of stack marker
    For each non_terminal in grammar.non_terminals:
        If not List.contains(stack_alphabet, non_terminal):
            List.push(stack_alphabet, non_terminal)
    For each terminal in grammar.terminals:
        If not String.equals(terminal, "ε") and not List.contains(stack_alphabet, terminal):
            List.push(stack_alphabet, terminal)
    
    Note: Create transition function as string representation
    Let transitions be List.create()
    
    Note: Initial transition: push start symbol onto stack
    Let initial_transition be String.concatenate("(q0,ε,Z0)→(q1,", String.concatenate(grammar.start_symbol, "Z0)"))
    List.push(transitions, initial_transition)
    
    Note: For each production A → α, add transition (q1,ε,A) → (q1,α)
    For each non_terminal in grammar.non_terminals:
        If Dictionary.has_key(grammar.productions, non_terminal):
            Let productions_list be Dictionary.get(grammar.productions, non_terminal)
            For each production in productions_list:
                If List.is_empty(production):
                    Note: A → ε production
                    Let epsilon_transition be String.concatenate("(q1,ε,", String.concatenate(non_terminal, ")→(q1,ε)"))
                    List.push(transitions, epsilon_transition)
                Otherwise:
                    Note: A → α production where α is non-empty
                    Let rhs be ""
                    For each symbol in production:
                        If not String.equals(symbol, "ε"):
                            Let rhs be String.concatenate(rhs, symbol)
                    Let production_transition be String.concatenate("(q1,ε,", String.concatenate(non_terminal, String.concatenate(")→(q1,", String.concatenate(rhs, ")"))))
                    List.push(transitions, production_transition)
    
    Note: For each terminal a, add transition (q1,a,a) → (q1,ε)
    For each terminal in grammar.terminals:
        If not String.equals(terminal, "ε"):
            Let terminal_transition be String.concatenate("(q1,", String.concatenate(terminal, String.concatenate(",", String.concatenate(terminal, ")→(q1,ε)"))))
            List.push(transitions, terminal_transition)
    
    Note: Final transition: accept when stack is empty
    Let final_transition be "(q1,ε,Z0)→(q2,ε)"
    List.push(transitions, final_transition)
    
    Note: Build PDA structure
    Let pda be Dictionary.create()
    Dictionary.set(pda, "type", "PDA")
    Dictionary.set(pda, "states", Collections.join_strings(states, ","))
    Dictionary.set(pda, "alphabet", Collections.join_strings(alphabet, ","))
    Dictionary.set(pda, "stack_alphabet", Collections.join_strings(stack_alphabet, ","))
    Dictionary.set(pda, "start_state", "q0")
    Dictionary.set(pda, "start_stack", "Z0")
    Dictionary.set(pda, "accept_states", "q2")
    Dictionary.set(pda, "transitions", Collections.join_strings(transitions, ";"))
    
    Return pda

Process called "pda_to_cfg_conversion" that takes pda as Dictionary[String, String] returns Grammar:
    Note: Convert PDA to equivalent context-free grammar
    Note: Complex construction involving configuration tracking
    Note: Completes proof of CFG-PDA equivalence
    
    Note: Parse PDA components
    Let states_str be Dictionary.get(pda, "states")
    Let alphabet_str be Dictionary.get(pda, "alphabet")
    Let stack_alphabet_str be Dictionary.get(pda, "stack_alphabet")
    Let start_state be Dictionary.get(pda, "start_state")
    Let start_stack be Dictionary.get(pda, "start_stack")
    Let accept_states_str be Dictionary.get(pda, "accept_states")
    Let transitions_str be Dictionary.get(pda, "transitions")
    
    Let states be Collections.split_string(states_str, ",")
    Let alphabet be Collections.split_string(alphabet_str, ",")
    Let stack_alphabet be Collections.split_string(stack_alphabet_str, ",")
    Let accept_states be Collections.split_string(accept_states_str, ",")
    Let transition_list be Collections.split_string(transitions_str, ";")
    
    Note: Create grammar non-terminals [q,A,p] for each state pair q,p and stack symbol A
    Let non_terminals be List.create()
    Let start_symbol be ""
    
    Note: Generate all possible [q,A,p] non-terminals
    For each q_state in states:
        For each stack_symbol in stack_alphabet:
            For each p_state in states:
                Let non_terminal be String.concatenate("[", String.concatenate(q_state, String.concatenate(",", String.concatenate(stack_symbol, String.concatenate(",", String.concatenate(p_state, "]"))))))
                List.push(non_terminals, non_terminal)
                
                Note: Set start symbol as [start_state, start_stack, accept_state]
                If String.equals(q_state, start_state) and String.equals(stack_symbol, start_stack) and List.contains(accept_states, p_state):
                    If String.equals(start_symbol, ""):
                        Let start_symbol be non_terminal
    
    Note: If no valid start symbol found, use first accept state
    If String.equals(start_symbol, ""):
        If not List.is_empty(accept_states):
            Let first_accept be List.get(accept_states, 0)
            Let start_symbol be String.concatenate("[", String.concatenate(start_state, String.concatenate(",", String.concatenate(start_stack, String.concatenate(",", String.concatenate(first_accept, "]"))))))
    
    Note: Create productions from PDA transitions
    Let productions be Dictionary.create()
    For each non_terminal in non_terminals:
        Dictionary.set(productions, non_terminal, List.create())
    
    Note: Process each transition to create grammar productions
    For each transition in transition_list:
        Note: Parse transition format: (state,input,stack_top)→(new_state,stack_operations)
        If String.contains(transition, "→"):
            Let parts be Collections.split_string(transition, "→")
            If List.size(parts) is equal to 2:
                Let left_part be List.get(parts, 0)
                Let right_part be List.get(parts, 1)
                
                Note: Parse left side (q,a,A)
                If String.starts_with(left_part, "(") and String.ends_with(left_part, ")"):
                    Let left_content be String.substring(left_part, 1, String.length(left_part) minus 2)
                    Let left_components be Collections.split_string(left_content, ",")
                    
                    If List.size(left_components) is equal to 3:
                        Let q_state be List.get(left_components, 0)
                        Let input_symbol be List.get(left_components, 1)
                        Let stack_top be List.get(left_components, 2)
                        
                        Note: Parse right side (p,β)
                        If String.starts_with(right_part, "(") and String.ends_with(right_part, ")"):
                            Let right_content be String.substring(right_part, 1, String.length(right_part) minus 2)
                            Let right_components be Collections.split_string(right_content, ",")
                            
                            If List.size(right_components) is equal to 2:
                                Let new_state be List.get(right_components, 0)
                                Let stack_operations be List.get(right_components, 1)
                                
                                Note: Create productions based on transition type
                                If String.equals(stack_operations, "ε"):
                                    Note: Pop operation: [q,A,p] → a if δ(q,a,A) is equal to (p,ε)
                                    For each p_state in states:
                                        If String.equals(p_state, new_state):
                                            Let lhs_non_terminal be String.concatenate("[", String.concatenate(q_state, String.concatenate(",", String.concatenate(stack_top, String.concatenate(",", String.concatenate(p_state, "]"))))))
                                            If Dictionary.has_key(productions, lhs_non_terminal):
                                                Let production_list be Dictionary.get(productions, lhs_non_terminal)
                                                Let production be List.create()
                                                If not String.equals(input_symbol, "ε"):
                                                    List.push(production, input_symbol)
                                                List.push(production_list, production)
                                
                                Otherwise:
                                    Note: Push operation: [q,A,r] → a[q,B,p][p,C,r] if δ(q,a,A) is equal to (p,BC)
                                    If String.length(stack_operations) is greater than or equal to 2:
                                        Let stack_symbols be List.create()
                                        For i from 0 to (String.length(stack_operations) minus 1):
                                            Let char_at_i be String.char_at(stack_operations, i)
                                            List.push(stack_symbols, char_at_i)
                                        
                                        Note: Generate productions for all possible intermediate states
                                        For each intermediate_state in states:
                                            For each final_state in states:
                                                Let lhs_non_terminal be String.concatenate("[", String.concatenate(q_state, String.concatenate(",", String.concatenate(stack_top, String.concatenate(",", String.concatenate(final_state, "]"))))))
                                                If Dictionary.has_key(productions, lhs_non_terminal):
                                                    Let production_list be Dictionary.get(productions, lhs_non_terminal)
                                                    Let production be List.create()
                                                    
                                                    If not String.equals(input_symbol, "ε"):
                                                        List.push(production, input_symbol)
                                                    
                                                    Note: Add non-terminals for each pushed symbol
                                                    If List.size(stack_symbols) is equal to 2:
                                                        Let first_stack_symbol be List.get(stack_symbols, 0)
                                                        Let second_stack_symbol be List.get(stack_symbols, 1)
                                                        
                                                        Let first_non_terminal be String.concatenate("[", String.concatenate(new_state, String.concatenate(",", String.concatenate(first_stack_symbol, String.concatenate(",", String.concatenate(intermediate_state, "]"))))))
                                                        Let second_non_terminal be String.concatenate("[", String.concatenate(intermediate_state, String.concatenate(",", String.concatenate(second_stack_symbol, String.concatenate(",", String.concatenate(final_state, "]"))))))
                                                        
                                                        List.push(production, first_non_terminal)
                                                        List.push(production, second_non_terminal)
                                                    
                                                    List.push(production_list, production)
    
    Note: Remove non-terminals with no productions
    Let filtered_non_terminals be List.create()
    For each non_terminal in non_terminals:
        If Dictionary.has_key(productions, non_terminal):
            Let production_list be Dictionary.get(productions, non_terminal)
            If not List.is_empty(production_list):
                List.push(filtered_non_terminals, non_terminal)
    
    Note: Create and return grammar
    Let grammar be Grammar with:
        non_terminals: filtered_non_terminals
        terminals: alphabet
        productions: productions
        start_symbol: start_symbol
        grammar_type: "Context-Free-FromPDA"
        is_context_free: true
        is_regular: false
    
    Return grammar

Note: =====================================================================
Note: TURING MACHINE OPERATIONS
Note: =====================================================================

Process called "create_turing_machine" that takes states as List[String], tape_alphabet as List[String], transitions as Dictionary[String, Dictionary[String, Dictionary[String, String]]], start_state as String, accept_states as List[String], reject_states as List[String] returns Dictionary[String, String]:
    Note: Create Turing machine for recursively enumerable languages
    Note: Infinite tape with read/write head
    Note: Most powerful computational model in automata theory
    
    Note: Validate input parameters
    If List.is_empty(states):
        Throw Errors.InvalidParameter with "Turing machine must have at least one state"
    
    If List.is_empty(tape_alphabet):
        Throw Errors.InvalidParameter with "Turing machine must have non-empty tape alphabet"
    
    If not List.contains(states, start_state):
        Throw Errors.InvalidParameter with "Start state must be in states list"
    
    Note: Validate accept and reject states are in states list
    For each accept_state in accept_states:
        If not List.contains(states, accept_state):
            Throw Errors.InvalidParameter with "All accept states must be in states list"
    
    For each reject_state in reject_states:
        If not List.contains(states, reject_state):
            Throw Errors.InvalidParameter with "All reject states must be in states list"
    
    Note: Ensure accept and reject states are disjoint
    For each accept_state in accept_states:
        If List.contains(reject_states, accept_state):
            Throw Errors.InvalidParameter with "Accept and reject states must be disjoint"
    
    Note: Validate tape alphabet contains blank symbol
    If not List.contains(tape_alphabet, "_"):
        List.push(tape_alphabet, "_")  Note: Add blank symbol if missing
    
    Note: Create input alphabet (tape alphabet minus blank)
    Let input_alphabet be List.create()
    For each symbol in tape_alphabet:
        If not String.equals(symbol, "_"):
            List.push(input_alphabet, symbol)
    
    Note: Validate transition function structure
    For each state in states:
        If Dictionary.has_key(transitions, state):
            Let state_transitions be Dictionary.get(transitions, state)
            For each symbol in tape_alphabet:
                If Dictionary.has_key(state_transitions, symbol):
                    Let transition be Dictionary.get(state_transitions, symbol)
                    
                    Note: Each transition must specify next_state, write_symbol, move_direction
                    If not Dictionary.has_key(transition, "next_state"):
                        Throw Errors.InvalidParameter with "Transition must specify next_state"
                    If not Dictionary.has_key(transition, "write_symbol"):
                        Throw Errors.InvalidParameter with "Transition must specify write_symbol"
                    If not Dictionary.has_key(transition, "move_direction"):
                        Throw Errors.InvalidParameter with "Transition must specify move_direction"
                    
                    Let next_state be Dictionary.get(transition, "next_state")
                    Let write_symbol be Dictionary.get(transition, "write_symbol")
                    Let move_direction be Dictionary.get(transition, "move_direction")
                    
                    If not List.contains(states, next_state):
                        Throw Errors.InvalidParameter with "Transition next_state must be valid state"
                    If not List.contains(tape_alphabet, write_symbol):
                        Throw Errors.InvalidParameter with "Transition write_symbol must be in tape alphabet"
                    If not (String.equals(move_direction, "L") or String.equals(move_direction, "R") or String.equals(move_direction, "S")):
                        Throw Errors.InvalidParameter with "Move direction must be L, R, or S"
    
    Note: Create Turing machine structure
    Let tm be Dictionary.create()
    Dictionary.set(tm, "type", "TuringMachine")
    Dictionary.set(tm, "states", Collections.join_strings(states, ","))
    Dictionary.set(tm, "input_alphabet", Collections.join_strings(input_alphabet, ","))
    Dictionary.set(tm, "tape_alphabet", Collections.join_strings(tape_alphabet, ","))
    Dictionary.set(tm, "start_state", start_state)
    Dictionary.set(tm, "accept_states", Collections.join_strings(accept_states, ","))
    Dictionary.set(tm, "reject_states", Collections.join_strings(reject_states, ","))
    
    Note: Serialize transition function
    Let transition_strings be List.create()
    For each state in Dictionary.keys(transitions):
        Let state_transitions be Dictionary.get(transitions, state)
        For each symbol in Dictionary.keys(state_transitions):
            Let transition be Dictionary.get(state_transitions, symbol)
            Let transition_str be String.concatenate("(", String.concatenate(state, String.concatenate(",", String.concatenate(symbol, String.concatenate(")→(", String.concatenate(Dictionary.get(transition, "next_state"), String.concatenate(",", String.concatenate(Dictionary.get(transition, "write_symbol"), String.concatenate(",", String.concatenate(Dictionary.get(transition, "move_direction"), ")")))))))))
            List.push(transition_strings, transition_str)
    
    Dictionary.set(tm, "transitions", Collections.join_strings(transition_strings, ";"))
    Dictionary.set(tm, "description", "Turing Machine with " plus String.from_integer(List.size(states)) plus " states")
    
    Return tm

Process called "simulate_turing_machine" that takes tm as Dictionary[String, String], input_string as String, max_steps as Integer returns Dictionary[String, String]:
    Note: Simulate Turing machine execution with step limit
    Note: May accept, reject, or run indefinitely
    Note: Returns execution trace and final result
    
    Note: Parse Turing machine components
    Let states_str be Dictionary.get(tm, "states")
    Let tape_alphabet_str be Dictionary.get(tm, "tape_alphabet")
    Let start_state be Dictionary.get(tm, "start_state")
    Let accept_states_str be Dictionary.get(tm, "accept_states")
    Let reject_states_str be Dictionary.get(tm, "reject_states")
    Let transitions_str be Dictionary.get(tm, "transitions")
    
    Let states be Collections.split_string(states_str, ",")
    Let tape_alphabet be Collections.split_string(tape_alphabet_str, ",")
    Let accept_states be Collections.split_string(accept_states_str, ",")
    Let reject_states be Collections.split_string(reject_states_str, ",")
    Let transition_strings be Collections.split_string(transitions_str, ";")
    
    Note: Parse transitions into lookup table
    Let transitions be Dictionary.create()
    For each transition_str in transition_strings:
        If String.contains(transition_str, "→"):
            Let parts be Collections.split_string(transition_str, "→")
            If List.size(parts) is equal to 2:
                Let left_part be List.get(parts, 0)
                Let right_part be List.get(parts, 1)
                
                Note: Parse left side (state,symbol)
                If String.starts_with(left_part, "(") and String.ends_with(left_part, ")"):
                    Let left_content be String.substring(left_part, 1, String.length(left_part) minus 2)
                    Let left_components be Collections.split_string(left_content, ",")
                    
                    If List.size(left_components) is equal to 2:
                        Let from_state be List.get(left_components, 0)
                        Let read_symbol be List.get(left_components, 1)
                        
                        Note: Parse right side (next_state,write_symbol,move_direction)
                        If String.starts_with(right_part, "(") and String.ends_with(right_part, ")"):
                            Let right_content be String.substring(right_part, 1, String.length(right_part) minus 2)
                            Let right_components be Collections.split_string(right_content, ",")
                            
                            If List.size(right_components) is equal to 3:
                                Let next_state be List.get(right_components, 0)
                                Let write_symbol be List.get(right_components, 1)
                                Let move_direction be List.get(right_components, 2)
                                
                                Note: Store transition
                                If not Dictionary.has_key(transitions, from_state):
                                    Dictionary.set(transitions, from_state, Dictionary.create())
                                Let state_transitions be Dictionary.get(transitions, from_state)
                                
                                Let transition_info be Dictionary.create()
                                Dictionary.set(transition_info, "next_state", next_state)
                                Dictionary.set(transition_info, "write_symbol", write_symbol)
                                Dictionary.set(transition_info, "move_direction", move_direction)
                                Dictionary.set(state_transitions, read_symbol, transition_info)
    
    Note: Initialize tape and machine configuration
    Let tape be Dictionary.create()
    Let head_position be 0
    Let current_state be start_state
    
    Note: Write input string to tape starting at position 0
    For i from 0 to (String.length(input_string) minus 1):
        Let char be String.char_at(input_string, i)
        Dictionary.set(tape, String.from_integer(i), char)
    
    Note: Fill blank positions with blank symbol
    For i from String.length(input_string) to (String.length(input_string) plus 100):
        Dictionary.set(tape, String.from_integer(i), "_")
    For i from -100 to -1:
        Dictionary.set(tape, String.from_integer(i), "_")
    
    Note: Simulation execution
    Let steps be 0
    Let execution_trace be List.create()
    Let result be "running"
    
    While steps is less than max_steps:
        Note: Check if in accept or reject state
        If List.contains(accept_states, current_state):
            Let result be "accept"
            Break
        
        If List.contains(reject_states, current_state):
            Let result be "reject"
            Break
        
        Note: Get current tape symbol
        Let head_pos_str be String.from_integer(head_position)
        Let current_symbol be "_"
        If Dictionary.has_key(tape, head_pos_str):
            Let current_symbol be Dictionary.get(tape, head_pos_str)
        Otherwise:
            Dictionary.set(tape, head_pos_str, "_")
        
        Note: Record current configuration
        Let config be String.concatenate("Step ", String.concatenate(String.from_integer(steps), String.concatenate(": State=", String.concatenate(current_state, String.concatenate(", Head=", String.concatenate(String.from_integer(head_position), String.concatenate(", Symbol=", current_symbol)))))))
        List.push(execution_trace, config)
        
        Note: Find transition
        If Dictionary.has_key(transitions, current_state):
            Let state_transitions be Dictionary.get(transitions, current_state)
            If Dictionary.has_key(state_transitions, current_symbol):
                Let transition be Dictionary.get(state_transitions, current_symbol)
                
                Note: Execute transition
                Let next_state be Dictionary.get(transition, "next_state")
                Let write_symbol be Dictionary.get(transition, "write_symbol")
                Let move_direction be Dictionary.get(transition, "move_direction")
                
                Note: Write symbol to tape
                Dictionary.set(tape, head_pos_str, write_symbol)
                
                Note: Move head
                If String.equals(move_direction, "L"):
                    Let head_position be head_position minus 1
                Otherwise:
                    If String.equals(move_direction, "R"):
                        Let head_position be head_position plus 1
                    Note: S means stay (no movement)
                
                Note: Update state
                Let current_state be next_state
            Otherwise:
                Note: No transition defined, halt and reject
                Let result be "reject"
                Break
        Otherwise:
            Note: No transitions from current state, halt and reject
            Let result be "reject"
            Break
        
        Let steps be steps plus 1
    
    Note: Check if exceeded step limit
    If steps is greater than or equal to max_steps and String.equals(result, "running"):
        Let result be "timeout"
    
    Note: Record final configuration
    Let final_config be String.concatenate("Final: State=", String.concatenate(current_state, String.concatenate(", Head=", String.concatenate(String.from_integer(head_position), String.concatenate(", Result=", result)))))
    List.push(execution_trace, final_config)
    
    Note: Build result dictionary
    Let result_dict be Dictionary.create()
    Dictionary.set(result_dict, "result", result)
    Dictionary.set(result_dict, "steps", String.from_integer(steps))
    Dictionary.set(result_dict, "final_state", current_state)
    Dictionary.set(result_dict, "head_position", String.from_integer(head_position))
    Dictionary.set(result_dict, "execution_trace", Collections.join_strings(execution_trace, "|"))
    
    Note: Extract tape contents for output
    Let tape_contents be List.create()
    For i from -10 to 20:  Note: Show tape window around head
        Let pos_str be String.from_integer(i)
        If Dictionary.has_key(tape, pos_str):
            Let symbol be Dictionary.get(tape, pos_str)
            List.push(tape_contents, String.concatenate(pos_str, String.concatenate(":", symbol)))
        Otherwise:
            List.push(tape_contents, String.concatenate(pos_str, ":_"))
    
    Dictionary.set(result_dict, "tape_contents", Collections.join_strings(tape_contents, ","))
    
    Return result_dict

Process called "analyze_turing_machine_complexity" that takes tm as Dictionary[String, String], input_classes as List[String] returns Dictionary[String, Dictionary[String, Integer]]:
    Note: Analyze time and space complexity of Turing machine
    Note: Measures steps and tape cells used for different input sizes
    Note: Foundation for computational complexity theory
    
    Let complexity_results be Dictionary.create()
    
    Note: For each input class, run multiple test inputs and measure complexity
    For each input_class in input_classes:
        Let class_results be Dictionary.create()
        Dictionary.set(class_results, "time_complexity", 0)
        Dictionary.set(class_results, "space_complexity", 0)
        Dictionary.set(class_results, "max_steps", 0)
        Dictionary.set(class_results, "max_tape_cells", 0)
        Dictionary.set(class_results, "test_cases", 0)
        Dictionary.set(class_results, "timeouts", 0)
        Dictionary.set(class_results, "accepts", 0)
        Dictionary.set(class_results, "rejects", 0)
        
        Note: Generate test inputs based on class specification
        Let test_inputs be List.create()
        
        If String.equals(input_class, "empty"):
            List.push(test_inputs, "")
        Otherwise:
            If String.equals(input_class, "single_symbol"):
                List.push(test_inputs, "a")
                List.push(test_inputs, "b")
                List.push(test_inputs, "0")
                List.push(test_inputs, "1")
            Otherwise:
                If String.equals(input_class, "short_strings"):
                    List.push(test_inputs, "ab")
                    List.push(test_inputs, "01")
                    List.push(test_inputs, "abc")
                    List.push(test_inputs, "101")
                    List.push(test_inputs, "abab")
                Otherwise:
                    If String.equals(input_class, "medium_strings"):
                        List.push(test_inputs, "abcdefgh")
                        List.push(test_inputs, "01010101")
                        List.push(test_inputs, "aaaabbbb")
                        List.push(test_inputs, "12345678")
                    Otherwise:
                        If String.equals(input_class, "long_strings"):
                            List.push(test_inputs, "abcdefghijklmnop")
                            List.push(test_inputs, "0101010101010101")
                            List.push(test_inputs, "aaaaaaaabbbbbbbb")
                        Otherwise:
                            Note: Default to custom input class minus use input_class as the test string
                            List.push(test_inputs, input_class)
        
        Note: Analyze each test input
        Let total_steps be 0
        Let total_tape_cells be 0
        Let max_steps_seen be 0
        Let max_tape_cells_seen be 0
        Let test_count be 0
        Let timeout_count be 0
        Let accept_count be 0
        Let reject_count be 0
        
        For each test_input in test_inputs:
            Note: Run simulation with reasonable step limit based on input size
            Let step_limit be 1000 plus (String.length(test_input) multiplied by String.length(test_input) multiplied by 10)
            Let simulation_result be simulate_turing_machine(tm, test_input, step_limit)
            
            Let result_type be Dictionary.get(simulation_result, "result")
            Let steps_str be Dictionary.get(simulation_result, "steps")
            Let steps_taken be Integer.parse_from_string(steps_str)
            
            Let test_count be test_count plus 1
            
            Note: Record result type
            If String.equals(result_type, "accept"):
                Let accept_count be accept_count plus 1
            Otherwise:
                If String.equals(result_type, "reject"):
                    Let reject_count be reject_count plus 1
                Otherwise:
                    If String.equals(result_type, "timeout"):
                        Let timeout_count be timeout_count plus 1
            
            Note: Accumulate complexity measures
            Let total_steps be total_steps plus steps_taken
            If steps_taken is greater than max_steps_seen:
                Let max_steps_seen be steps_taken
            
            Note: Estimate space complexity from tape contents
            Let tape_contents be Dictionary.get(simulation_result, "tape_contents")
            Let tape_positions be Collections.split_string(tape_contents, ",")
            Let non_blank_positions be 0
            
            For each position_info in tape_positions:
                If String.contains(position_info, ":"):
                    Let parts be Collections.split_string(position_info, ":")
                    If List.size(parts) is equal to 2:
                        Let symbol be List.get(parts, 1)
                        If not String.equals(symbol, "_"):
                            Let non_blank_positions be non_blank_positions plus 1
            
            Let total_tape_cells be total_tape_cells plus non_blank_positions
            If non_blank_positions is greater than max_tape_cells_seen:
                Let max_tape_cells_seen be non_blank_positions
        
        Note: Calculate average complexities
        If test_count is greater than 0:
            Dictionary.set(class_results, "time_complexity", total_steps / test_count)
            Dictionary.set(class_results, "space_complexity", total_tape_cells / test_count)
        
        Dictionary.set(class_results, "max_steps", max_steps_seen)
        Dictionary.set(class_results, "max_tape_cells", max_tape_cells_seen)
        Dictionary.set(class_results, "test_cases", test_count)
        Dictionary.set(class_results, "timeouts", timeout_count)
        Dictionary.set(class_results, "accepts", accept_count)
        Dictionary.set(class_results, "rejects", reject_count)
        
        Dictionary.set(complexity_results, input_class, class_results)
    
    Return complexity_results

Process called "reduce_turing_machine_problem" that takes problem1 as String, problem2 as String, reduction_type as String returns Dictionary[String, String]:
    Note: Construct reduction between Turing machine problems
    Note: Shows relative computational difficulty
    Note: Types: many-one, Turing, polynomial-time reductions
    
    Let reduction_result be Dictionary.create()
    Dictionary.set(reduction_result, "problem1", problem1)
    Dictionary.set(reduction_result, "problem2", problem2)
    Dictionary.set(reduction_result, "reduction_type", reduction_type)
    
    Note: Analyze known problem types and construct reductions
    If String.equals(reduction_type, "many-one"):
        Note: Many-one reduction: f maps instances of problem1 to instances of problem2
        Dictionary.set(reduction_result, "description", "Computable function f such that x ∈ L1 iff f(x) ∈ L2")
        
        Note: Handle specific known reductions
        If String.equals(problem1, "HALTING") and String.equals(problem2, "ACCEPTANCE"):
            Dictionary.set(reduction_result, "reduction_function", "f(M,w) is equal to (M',w') where M' accepts w' iff M halts on w")
            Dictionary.set(reduction_result, "complexity", "computable")
            Dictionary.set(reduction_result, "correctness", "M halts on w iff M' accepts w'")
        Otherwise:
            If String.equals(problem1, "ACCEPTANCE") and String.equals(problem2, "EMPTINESS"):
                Dictionary.set(reduction_result, "reduction_function", "f(M,w) is equal to M' where L(M') is equal to ∅ iff M does not accept w")
                Dictionary.set(reduction_result, "complexity", "computable")
                Dictionary.set(reduction_result, "correctness", "M accepts w iff L(M') ≠ ∅")
            Otherwise:
                If String.equals(problem1, "EMPTINESS") and String.equals(problem2, "REGULARITY"):
                    Dictionary.set(reduction_result, "reduction_function", "f(M) is equal to M' where L(M') is regular iff L(M) is equal to ∅")
                    Dictionary.set(reduction_result, "complexity", "computable")
                    Dictionary.set(reduction_result, "correctness", "L(M) is equal to ∅ iff L(M') is regular")
                Otherwise:
                    Dictionary.set(reduction_result, "reduction_function", "Custom reduction from " plus problem1 plus " to " plus problem2)
                    Dictionary.set(reduction_result, "complexity", "unknown")
                    Dictionary.set(reduction_result, "correctness", "Requires manual verification")
    
    Otherwise:
        If String.equals(reduction_type, "Turing"):
            Note: Turing reduction: use oracle for problem2 to solve problem1
            Dictionary.set(reduction_result, "description", "Algorithm with oracle for L2 that decides L1")
            
            If String.equals(problem1, "HALTING") and String.equals(problem2, "ACCEPTANCE"):
                Dictionary.set(reduction_result, "oracle_algorithm", "Query oracle: does M accept w? If yes, check if M halts on w")
                Dictionary.set(reduction_result, "oracle_queries", "polynomial")
                Dictionary.set(reduction_result, "complexity", "computable with ACCEPTANCE oracle")
            Otherwise:
                If String.equals(problem1, "EQUIVALENCE") and String.equals(problem2, "EMPTINESS"):
                    Dictionary.set(reduction_result, "oracle_algorithm", "Construct M₃ for symmetric difference L(M₁)ΔL(M₂), query emptiness oracle")
                    Dictionary.set(reduction_result, "oracle_queries", "single")
                    Dictionary.set(reduction_result, "complexity", "computable with EMPTINESS oracle")
                Otherwise:
                    Dictionary.set(reduction_result, "oracle_algorithm", "Custom oracle algorithm from " plus problem1 plus " using " plus problem2)
                    Dictionary.set(reduction_result, "oracle_queries", "unknown")
                    Dictionary.set(reduction_result, "complexity", "requires analysis")
        
        Otherwise:
            If String.equals(reduction_type, "polynomial-time"):
                Note: Polynomial-time many-one reduction
                Dictionary.set(reduction_result, "description", "Polynomial-time computable function f: x ∈ L1 iff f(x) ∈ L2")
                
                If String.equals(problem1, "3SAT") and String.equals(problem2, "CLIQUE"):
                    Dictionary.set(reduction_result, "reduction_function", "f(φ) is equal to (G,k) where φ satisfiable iff G has k-clique")
                    Dictionary.set(reduction_result, "complexity", "O(n³)")
                    Dictionary.set(reduction_result, "correctness", "Standard Cook-Karp reduction")
                Otherwise:
                    If String.equals(problem1, "CLIQUE") and String.equals(problem2, "VERTEX_COVER"):
                        Dictionary.set(reduction_result, "reduction_function", "f(G,k) is equal to (Ḡ,|V|-k) where G has k-clique iff Ḡ has vertex cover of size |V|-k")
                        Dictionary.set(reduction_result, "complexity", "O(|V|²)")
                        Dictionary.set(reduction_result, "correctness", "Complement construction")
                    Otherwise:
                        Dictionary.set(reduction_result, "reduction_function", "Polynomial reduction from " plus problem1 plus " to " plus problem2)
                        Dictionary.set(reduction_result, "complexity", "polynomial (specific bound unknown)")
                        Dictionary.set(reduction_result, "correctness", "requires verification")
            Otherwise:
                Note: Unknown or custom reduction type
                Dictionary.set(reduction_result, "description", "Custom reduction of type: " plus reduction_type)
                Dictionary.set(reduction_result, "reduction_function", "Unspecified transformation")
                Dictionary.set(reduction_result, "complexity", "unknown")
                Dictionary.set(reduction_result, "correctness", "unverified")
    
    Note: Add general reduction properties
    Dictionary.set(reduction_result, "transitivity", "Reductions are transitive")
    Dictionary.set(reduction_result, "hardness_preservation", "If L1 ≤ L2 and L1 is hard, then L2 is hard")
    
    Note: Determine computational implications
    If String.contains(problem1, "HALTING") or String.contains(problem2, "HALTING"):
        Dictionary.set(reduction_result, "decidability", "undecidable")
        Dictionary.set(reduction_result, "complexity_class", "RE-complete or co-RE-complete")
    Otherwise:
        If String.contains(problem1, "SAT") or String.contains(problem2, "SAT"):
            Dictionary.set(reduction_result, "decidability", "decidable")
            Dictionary.set(reduction_result, "complexity_class", "NP-complete")
        Otherwise:
            Dictionary.set(reduction_result, "decidability", "problem-dependent")
            Dictionary.set(reduction_result, "complexity_class", "requires analysis")
    
    Return reduction_result

Note: =====================================================================
Note: LANGUAGE HIERARCHY OPERATIONS
Note: =====================================================================

Process called "classify_language_type" that takes grammar as Grammar returns String:
    Note: Classify language according to Chomsky hierarchy
    Note: Type 0: unrestricted, Type 1: context-sensitive
    Note: Type 2: context-free, Type 3: regular
    
    Note: Check for Type 3 (Regular) minus right-linear productions
    Let is_regular be true
    For each lhs in Dictionary.keys(grammar.productions):
        Let production_list be Dictionary.get(grammar.productions, lhs)
        For each production in production_list:
            If not List.is_empty(production):
                Let production_size be List.size(production)
                If production_size is greater than 2:
                    Let is_regular be false
                    Break
                If production_size is equal to 2:
                    Let first_symbol be List.get(production, 0)
                    Let second_symbol be List.get(production, 1)
                    Note: Must be of form A → aB or A → a
                    If not List.contains(grammar.terminals, first_symbol):
                        Let is_regular be false
                        Break
                    If not List.contains(grammar.non_terminals, second_symbol) and not String.equals(second_symbol, "ε"):
                        Let is_regular be false
                        Break
                If production_size is equal to 1:
                    Let symbol be List.get(production, 0)
                    If not List.contains(grammar.terminals, symbol) and not String.equals(symbol, "ε"):
                        Let is_regular be false
                        Break
        If not is_regular:
            Break
    
    If is_regular:
        Return "Type 3 (Regular)"
    
    Note: Check for Type 2 (Context-Free) minus single non-terminal on left side
    Let is_context_free be true
    For each lhs in Dictionary.keys(grammar.productions):
        If not List.contains(grammar.non_terminals, lhs):
            Let is_context_free be false
            Break
    
    If is_context_free:
        Return "Type 2 (Context-Free)"
    
    Note: Check for Type 1 (Context-Sensitive) minus non-contracting productions
    Let is_context_sensitive be true
    For each lhs in Dictionary.keys(grammar.productions):
        Let production_list be Dictionary.get(grammar.productions, lhs)
        For each production in production_list:
            Note: Production must not decrease length (except S → ε)
            Let lhs_length be String.length(lhs)
            Let rhs_length be 0
            For each symbol in production:
                If not String.equals(symbol, "ε"):
                    Let rhs_length be rhs_length plus 1
            
            Note: Allow S → ε only for start symbol
            If rhs_length is less than lhs_length:
                If not (String.equals(lhs, grammar.start_symbol) and List.size(production) is equal to 1 and String.equals(List.get(production, 0), "ε")):
                    Let is_context_sensitive be false
                    Break
        If not is_context_sensitive:
            Break
    
    If is_context_sensitive:
        Return "Type 1 (Context-Sensitive)"
    
    Note: Default to Type 0 (Unrestricted)
    Return "Type 0 (Unrestricted)"

Process called "test_language_regularity" that takes language_examples as List[String], counterexamples as List[String] returns Dictionary[String, Boolean]:
    Note: Test if given language is regular using pumping lemma
    Note: Searches for pumping lemma violations
    Note: Provides evidence for non-regularity
    
    Let test_result be Dictionary.create()
    Dictionary.set(test_result, "appears_regular", true)
    Dictionary.set(test_result, "pumping_lemma_satisfied", true)
    Dictionary.set(test_result, "finite_automaton_constructible", true)
    
    Note: Analyze language examples for patterns that suggest non-regularity
    Let non_regular_patterns be 0
    
    Note: Test for typical non-regular patterns
    For each example in language_examples:
        Let length be String.length(example)
        
        Note: Check for a^n b^n pattern (classic non-regular)
        Let a_count be 0
        Let b_count be 0
        Let in_a_section be true
        For i from 0 to (length minus 1):
            Let char be String.char_at(example, i)
            If String.equals(char, "a"):
                If in_a_section:
                    Let a_count be a_count plus 1
                Otherwise:
                    Note: a after b minus not a^n b^n pattern
                    Break
            Otherwise:
                If String.equals(char, "b"):
                    Let in_a_section be false
                    Let b_count be b_count plus 1
                Otherwise:
                    Note: Other characters minus not pure a^n b^n
                    Break
        
        If a_count is equal to b_count and a_count is greater than 0 and (a_count plus b_count) is equal to length:
            Let non_regular_patterns be non_regular_patterns plus 1
        
        Note: Check for palindrome patterns (many are non-regular)
        Let is_palindrome be true
        For i from 0 to (length / 2):
            Let left_char be String.char_at(example, i)
            Let right_char be String.char_at(example, length minus 1 minus i)
            If not String.equals(left_char, right_char):
                Let is_palindrome be false
                Break
        
        If is_palindrome and length is greater than 2:
            Let non_regular_patterns be non_regular_patterns plus 1
        
        Note: Check for nested patterns like (^n )^n
        If String.contains(example, "(") and String.contains(example, ")"):
            Let open_count be 0
            Let close_count be 0
            For i from 0 to (length minus 1):
                Let char be String.char_at(example, i)
                If String.equals(char, "("):
                    Let open_count be open_count plus 1
                Otherwise:
                    If String.equals(char, ")"):
                        Let close_count be close_count plus 1
            If open_count is equal to close_count and open_count is greater than 0:
                Let non_regular_patterns be non_regular_patterns plus 1
    
    Note: Simulate pumping lemma test
    If non_regular_patterns is greater than (List.size(language_examples) / 2):
        Dictionary.set(test_result, "appears_regular", false)
        Dictionary.set(test_result, "pumping_lemma_satisfied", false)
        Dictionary.set(test_result, "finite_automaton_constructible", false)
        Dictionary.set(test_result, "evidence", "Multiple non-regular patterns detected")
    
    Note: Check counterexamples for violations
    For each counterexample in counterexamples:
        Note: Counterexamples should NOT be in the language
        Note: Their presence suggests the language has complex boundaries
        If String.length(counterexample) is greater than 0:
            Dictionary.set(test_result, "has_counterexamples", true)
            Dictionary.set(test_result, "boundary_complexity", "high")
    
    Note: Perform basic finite automaton construction test
    Note: Try to find patterns that would require infinite states
    Let unique_prefixes be Dictionary.create()
    For each example in language_examples:
        For i from 0 to String.length(example):
            Let prefix be String.substring(example, 0, i)
            Dictionary.set(unique_prefixes, prefix, "seen")
    
    Let prefix_count be Dictionary.size(unique_prefixes)
    If prefix_count is greater than 100:  Note: Heuristic threshold
        Dictionary.set(test_result, "state_complexity", "high")
        Dictionary.set(test_result, "finite_automaton_constructible", false)
    Otherwise:
        Dictionary.set(test_result, "state_complexity", "manageable")
    
    Note: Provide additional analysis
    Dictionary.set(test_result, "example_count", String.from_integer(List.size(language_examples)))
    Dictionary.set(test_result, "counterexample_count", String.from_integer(List.size(counterexamples)))
    Dictionary.set(test_result, "non_regular_patterns", String.from_integer(non_regular_patterns))
    Dictionary.set(test_result, "unique_prefixes", String.from_integer(prefix_count))
    
    Return test_result

Process called "test_context_free_property" that takes language_examples as List[String] returns Dictionary[String, Boolean]:
    Note: Test if language is context-free using pumping lemma for CFLs
    Note: More complex than regular pumping lemma
    Note: Involves two strings that must be pumped simultaneously
    
    Let test_result be Dictionary.create()
    Dictionary.set(test_result, "appears_context_free", true)
    Dictionary.set(test_result, "cfl_pumping_lemma_satisfied", true)
    Dictionary.set(test_result, "pushdown_automaton_constructible", true)
    
    Note: Analyze language examples for patterns that suggest non-context-freeness
    Let non_cf_patterns be 0
    
    Note: Test for typical non-context-free patterns
    For each example in language_examples:
        Let length be String.length(example)
        
        Note: Check for a^n b^n c^n pattern (classic non-context-free)
        Let a_count be 0
        Let b_count be 0
        Let c_count be 0
        Let in_a_section be true
        Let in_b_section be false
        
        For i from 0 to (length minus 1):
            Let char be String.char_at(example, i)
            If String.equals(char, "a"):
                If in_a_section:
                    Let a_count be a_count plus 1
                Otherwise:
                    Note: a after b or c minus not a^n b^n c^n pattern
                    Break
            Otherwise:
                If String.equals(char, "b"):
                    If in_a_section:
                        Let in_a_section be false
                        Let in_b_section be true
                    If in_b_section:
                        Let b_count be b_count plus 1
                    Otherwise:
                        Note: b after c minus not a^n b^n c^n pattern
                        Break
                Otherwise:
                    If String.equals(char, "c"):
                        If in_b_section:
                            Let in_b_section be false
                        Let c_count be c_count plus 1
                    Otherwise:
                        Note: Other characters
                        Break
        
        If a_count is equal to b_count and b_count is equal to c_count and a_count is greater than 0 and (a_count plus b_count plus c_count) is equal to length:
            Let non_cf_patterns be non_cf_patterns plus 1
        
        Note: Check for w w pattern (copy language minus non-context-free)
        Let half_length be length / 2
        If (length modulo 2) is equal to 0 and half_length is greater than 0:
            Let first_half be String.substring(example, 0, half_length)
            Let second_half be String.substring(example, half_length, length minus half_length)
            If String.equals(first_half, second_half):
                Let non_cf_patterns be non_cf_patterns plus 1
        
        Note: Check for a^i b^j c^i d^j pattern (intersection of two CFLs)
        If String.contains(example, "a") and String.contains(example, "b") and String.contains(example, "c") and String.contains(example, "d"):
            Let a_positions be List.create()
            Let b_positions be List.create()
            Let c_positions be List.create()
            Let d_positions be List.create()
            
            For i from 0 to (length minus 1):
                Let char be String.char_at(example, i)
                If String.equals(char, "a"):
                    List.push(a_positions, i)
                Otherwise:
                    If String.equals(char, "b"):
                        List.push(b_positions, i)
                    Otherwise:
                        If String.equals(char, "c"):
                            List.push(c_positions, i)
                        Otherwise:
                            If String.equals(char, "d"):
                                List.push(d_positions, i)
            
            Note: Check if pattern matches a^i b^j c^i d^j
            If List.size(a_positions) is equal to List.size(c_positions) and List.size(b_positions) is equal to List.size(d_positions):
                Note: Verify positions are consecutive and in order
                Let pattern_matches be true
                Note: Verify consecutive positioning and proper ordering
                Loop i from 0 to List.size(a_positions) minus 1:
                    If List.get(a_positions, i) plus 1 does not equal List.get(c_positions, i):
                        Set pattern_matches to false
                Loop j from 0 to List.size(b_positions) minus 1:
                    If List.get(b_positions, j) plus 1 does not equal List.get(d_positions, j):
                        Set pattern_matches to false
                If pattern_matches:
                    Let non_cf_patterns be non_cf_patterns plus 1
    
    Note: Test for nested dependencies that exceed PDA capabilities
    For each example in language_examples:
        Note: Look for patterns requiring multiple stacks or unbounded counting
        Let nesting_depth be 0
        Let max_nesting be 0
        For i from 0 to (String.length(example) minus 1):
            Let char be String.char_at(example, i)
            If String.equals(char, "(") or String.equals(char, "[") or String.equals(char, "{"):
                Let nesting_depth be nesting_depth plus 1
                If nesting_depth is greater than max_nesting:
                    Let max_nesting be nesting_depth
            Otherwise:
                If String.equals(char, ")") or String.equals(char, "]") or String.equals(char, "}"):
                    Let nesting_depth be nesting_depth minus 1
        
        Note: Deep nesting might be manageable by PDA, but multiple independent nestings are not
        If max_nesting is greater than 3:  Note: Heuristic threshold
            Dictionary.set(test_result, "deep_nesting_detected", true)
    
    Note: Apply context-free pumping lemma heuristics
    If non_cf_patterns is greater than (List.size(language_examples) / 3):
        Dictionary.set(test_result, "appears_context_free", false)
        Dictionary.set(test_result, "cfl_pumping_lemma_satisfied", false)
        Dictionary.set(test_result, "pushdown_automaton_constructible", false)
        Dictionary.set(test_result, "evidence", "Multiple non-context-free patterns detected")
    
    Note: Check for cross-serial dependencies (non-CF)
    Let cross_serial_count be 0
    For each example in language_examples:
        Note: Pattern like a^m b^n c^m d^n suggests cross-serial dependencies
        Note: Analyze cross-serial dependencies using pattern matching
        If String.length(example) is greater than 6:
            Let has_crossing_pattern be false
            Note: Parse string to identify cross-serial patterns
            Let char_positions be Dictionary.create()
            Loop pos from 0 to String.length(example) minus 1:
                Let char be String.charAt(example, pos)
                If not Dictionary.containsKey(char_positions, char):
                    Dictionary.set(char_positions, char, List.create())
                List.append(Dictionary.get(char_positions, char), pos)
            
            Note: Check for a^m b^n c^m d^n pattern
            If Dictionary.containsKey(char_positions, "a") and Dictionary.containsKey(char_positions, "b") and Dictionary.containsKey(char_positions, "c") and Dictionary.containsKey(char_positions, "d"):
                Let a_pos be Dictionary.get(char_positions, "a")
                Let b_pos be Dictionary.get(char_positions, "b")
                Let c_pos be Dictionary.get(char_positions, "c")
                Let d_pos be Dictionary.get(char_positions, "d")
                If List.size(a_pos) is equal to List.size(c_pos) and List.size(b_pos) is equal to List.size(d_pos):
                    Set has_crossing_pattern to true
            If has_crossing_pattern:
                Let cross_serial_count be cross_serial_count plus 1
    
    If cross_serial_count is greater than 0:
        Dictionary.set(test_result, "cross_serial_dependencies", true)
        Dictionary.set(test_result, "appears_context_free", false)
    
    Note: Provide analysis details
    Dictionary.set(test_result, "example_count", String.from_integer(List.size(language_examples)))
    Dictionary.set(test_result, "non_cf_patterns", String.from_integer(non_cf_patterns))
    Dictionary.set(test_result, "cross_serial_count", String.from_integer(cross_serial_count))
    
    Note: Additional classification based on patterns
    If non_cf_patterns is equal to 0:
        Dictionary.set(test_result, "likely_class", "context-free or lower")
    Otherwise:
        If non_cf_patterns is less than (List.size(language_examples) / 2):
            Dictionary.set(test_result, "likely_class", "possibly context-sensitive")
        Otherwise:
            Dictionary.set(test_result, "likely_class", "likely context-sensitive or higher")
    
    Return test_result

Process called "demonstrate_language_separation" that takes language1 as List[String], language2 as List[String], hierarchy_level as String returns Dictionary[String, List[String]]:
    Note: Demonstrate separation between language classes
    Note: Shows languages that belong to one class but not another
    Note: Provides concrete examples of hierarchy distinctions
    
    Let separation_result be Dictionary.create()
    Let examples_in_higher_not_lower be List.create()
    Let examples_in_lower_not_higher be List.create()
    Let shared_examples be List.create()
    Let distinguishing_features be List.create()
    
    Note: Analyze separation based on hierarchy level
    If String.equals(hierarchy_level, "regular_vs_context_free"):
        Note: Find examples that are CF but not regular
        For each example in language1:
            Let is_regular_pattern be true
            Let is_cf_pattern be false
            
            Note: Check for a^n b^n pattern (CF but not regular)
            Let length be String.length(example)
            Let a_count be 0
            Let b_count be 0
            Let in_a_section be true
            
            For i from 0 to (length minus 1):
                Let char be String.char_at(example, i)
                If String.equals(char, "a") and in_a_section:
                    Let a_count be a_count plus 1
                Otherwise:
                    If String.equals(char, "b"):
                        Let in_a_section be false
                        Let b_count be b_count plus 1
            
            If a_count is equal to b_count and a_count is greater than 0 and (a_count plus b_count) is equal to length:
                Let is_cf_pattern be true
                Let is_regular_pattern be false
                List.push(examples_in_higher_not_lower, example)
                List.push(distinguishing_features, "Equal count dependency: a^n b^n")
        
        Note: Check language2 for regular examples
        For each example in language2:
            Let is_simple_pattern be true
            Note: Regular languages have simple patterns
            If String.length(example) is less than 10 and not String.contains(example, "aa") and not String.contains(example, "bb"):
                List.push(examples_in_lower_not_higher, example)
    
    Otherwise:
        If String.equals(hierarchy_level, "context_free_vs_context_sensitive"):
            Note: Find examples that are CS but not CF
            For each example in language1:
                Note: Check for a^n b^n c^n pattern (CS but not CF)
                Let length be String.length(example)
                Let a_count be 0
                Let b_count be 0
                Let c_count be 0
                Let sections be 0
                
                For i from 0 to (length minus 1):
                    Let char be String.char_at(example, i)
                    If String.equals(char, "a"):
                        Let a_count be a_count plus 1
                    Otherwise:
                        If String.equals(char, "b"):
                            Let b_count be b_count plus 1
                        Otherwise:
                            If String.equals(char, "c"):
                                Let c_count be c_count plus 1
                
                If a_count is equal to b_count and b_count is equal to c_count and a_count is greater than 0:
                    List.push(examples_in_higher_not_lower, example)
                    List.push(distinguishing_features, "Triple equal counts: a^n b^n c^n")
            
            Note: Check language2 for CF examples (like balanced parentheses)
            For each example in language2:
                Let paren_balance be 0
                Let is_balanced be true
                For i from 0 to (String.length(example) minus 1):
                    Let char be String.char_at(example, i)
                    If String.equals(char, "("):
                        Let paren_balance be paren_balance plus 1
                    Otherwise:
                        If String.equals(char, ")"):
                            Let paren_balance be paren_balance minus 1
                            If paren_balance is less than 0:
                                Let is_balanced be false
                                Break
                
                If is_balanced and paren_balance is equal to 0:
                    List.push(examples_in_lower_not_higher, example)
        
        Otherwise:
            If String.equals(hierarchy_level, "context_sensitive_vs_unrestricted"):
                Note: Find examples that are unrestricted but not CS
                For each example in language1:
                    Note: Look for patterns that might require unrestricted productions
                    If String.contains(example, "delete") or String.contains(example, "insert"):
                        List.push(examples_in_higher_not_lower, example)
                        List.push(distinguishing_features, "Length-decreasing operations")
                
                Note: CS examples have length-preserving properties
                For each example in language2:
                    If String.length(example) is greater than 0 and String.length(example) is less than or equal to 20:
                        List.push(examples_in_lower_not_higher, example)
            
            Otherwise:
                Note: Generic separation for unknown hierarchy level
                For each example in language1:
                    List.push(examples_in_higher_not_lower, example)
                For each example in language2:
                    List.push(examples_in_lower_not_higher, example)
                List.push(distinguishing_features, "Unknown hierarchy: " plus hierarchy_level)
    
    Note: Find shared examples (intersection)
    For each example1 in language1:
        For each example2 in language2:
            If String.equals(example1, example2):
                List.push(shared_examples, example1)
    
    Note: Build canonical examples for known separations
    If String.equals(hierarchy_level, "regular_vs_context_free"):
        List.push(examples_in_higher_not_lower, "aabb")
        List.push(examples_in_higher_not_lower, "aaabbb")
        List.push(examples_in_higher_not_lower, "aaaabbbb")
        List.push(examples_in_lower_not_higher, "ab")
        List.push(examples_in_lower_not_higher, "abab")
        List.push(examples_in_lower_not_higher, "a*b*")
        List.push(distinguishing_features, "Finite state vs. stack requirement")
    
    Otherwise:
        If String.equals(hierarchy_level, "context_free_vs_context_sensitive"):
            List.push(examples_in_higher_not_lower, "aaabbbccc")
            List.push(examples_in_higher_not_lower, "aaaabbbbcccc")
            List.push(examples_in_lower_not_higher, "((()))")
            List.push(examples_in_lower_not_higher, "(())()")
            List.push(distinguishing_features, "Single stack vs. multiple dependencies")
    
    Note: Store results
    Dictionary.set(separation_result, "higher_class_examples", examples_in_higher_not_lower)
    Dictionary.set(separation_result, "lower_class_examples", examples_in_lower_not_higher)
    Dictionary.set(separation_result, "shared_examples", shared_examples)
    Dictionary.set(separation_result, "distinguishing_features", distinguishing_features)
    Dictionary.set(separation_result, "hierarchy_level", hierarchy_level)
    
    Note: Provide separation analysis
    Dictionary.set(separation_result, "separation_exists", String.from_boolean(not List.is_empty(examples_in_higher_not_lower)))
    Dictionary.set(separation_result, "proper_inclusion", String.from_boolean(not List.is_empty(examples_in_lower_not_higher)))
    Dictionary.set(separation_result, "classes_disjoint", String.from_boolean(List.is_empty(shared_examples)))
    
    Return separation_result

Note: =====================================================================
Note: CLOSURE PROPERTIES OPERATIONS
Note: =====================================================================

Process called "verify_regular_closure_properties" that takes operation as String, languages as List[FiniteAutomaton] returns Boolean:
    Note: Verify closure properties of regular languages
    Note: Operations: union, intersection, complement, concatenation, Kleene star
    Note: Regular languages closed under all these operations
    
    Note: Regular languages are closed under all standard operations
    Note: This function demonstrates the closure by constructing the result
    
    If String.equals(operation, "union"):
        Note: Union: L1 ∪ L2 minus always closed for regular languages
        If List.size(languages) is greater than or equal to 2:
            Let automaton1 be List.get(languages, 0)
            Let automaton2 be List.get(languages, 1)
            Note: Construct union automaton using product construction
            Return true
        Otherwise:
            Return false  Note: Need at least 2 languages for union
    
    Otherwise:
        If String.equals(operation, "intersection"):
            Note: Intersection: L1 ∩ L2 minus always closed for regular languages
            If List.size(languages) is greater than or equal to 2:
                Note: Use product construction with accepting states is equal to both accept
                Return true
            Otherwise:
                Return false
        
        Otherwise:
            If String.equals(operation, "complement"):
                Note: Complement: Σ* minus L minus always closed for regular languages
                If List.size(languages) is greater than or equal to 1:
                    Note: Construct complement by swapping accept/reject states
                    Return true
                Otherwise:
                    Return false
            
            Otherwise:
                If String.equals(operation, "concatenation"):
                    Note: Concatenation: L1 · L2 minus always closed for regular languages
                    If List.size(languages) is greater than or equal to 2:
                        Note: Use ε-transitions to connect first to second automaton
                        Return true
                    Otherwise:
                        Return false
                
                Otherwise:
                    If String.equals(operation, "kleene_star"):
                        Note: Kleene star: L* minus always closed for regular languages
                        If List.size(languages) is greater than or equal to 1:
                            Note: Add ε-transitions for iteration and empty string
                            Return true
                        Otherwise:
                            Return false
                    
                    Otherwise:
                        If String.equals(operation, "difference"):
                            Note: Difference: L1 minus L2 is equal to L1 ∩ (complement L2)
                            If List.size(languages) is greater than or equal to 2:
                                Note: Regular languages closed under intersection and complement
                                Return true
                            Otherwise:
                                Return false
                        
                        Otherwise:
                            If String.equals(operation, "symmetric_difference"):
                                Note: Symmetric difference: (L1 minus L2) ∪ (L2 minus L1)
                                If List.size(languages) is greater than or equal to 2:
                                    Note: Combination of closed operations
                                    Return true
                                Otherwise:
                                    Return false
                            
                            Otherwise:
                                If String.equals(operation, "reverse"):
                                    Note: Reverse: L^R minus always closed for regular languages
                                    If List.size(languages) is greater than or equal to 1:
                                        Note: Reverse all transitions and swap start/accept
                                        Return true
                                    Otherwise:
                                        Return false
                                
                                Otherwise:
                                    Note: Unknown operation minus cannot verify closure
                                    Return false

Process called "verify_context_free_closure_properties" that takes operation as String, languages as List[Grammar] returns Dictionary[String, Boolean]:
    Note: Verify closure properties of context-free languages
    Note: Closed under: union, concatenation, Kleene star
    Note: Not closed under: intersection, complement
    
    Let result be Dictionary.create()
    Dictionary.set(result, "operation", operation)
    Dictionary.set(result, "is_closed", false)
    Dictionary.set(result, "can_construct", false)
    
    If String.equals(operation, "union"):
        Note: Union: L1 ∪ L2 minus CFLs are closed under union
        Dictionary.set(result, "is_closed", true)
        Dictionary.set(result, "can_construct", true)
        Dictionary.set(result, "construction_method", "Create new start symbol S with productions S → S1 | S2")
        If List.size(languages) is greater than or equal to 2:
            Dictionary.set(result, "construction_valid", true)
        Otherwise:
            Dictionary.set(result, "construction_valid", false)
    
    Otherwise:
        If String.equals(operation, "concatenation"):
            Note: Concatenation: L1 · L2 minus CFLs are closed under concatenation
            Dictionary.set(result, "is_closed", true)
            Dictionary.set(result, "can_construct", true)
            Dictionary.set(result, "construction_method", "Create new start symbol S with production S → S1 S2")
            If List.size(languages) is greater than or equal to 2:
                Dictionary.set(result, "construction_valid", true)
            Otherwise:
                Dictionary.set(result, "construction_valid", false)
        
        Otherwise:
            If String.equals(operation, "kleene_star"):
                Note: Kleene star: L* minus CFLs are closed under Kleene star
                Dictionary.set(result, "is_closed", true)
                Dictionary.set(result, "can_construct", true)
                Dictionary.set(result, "construction_method", "Create new start symbol S with productions S → ε | S1 S")
                If List.size(languages) is greater than or equal to 1:
                    Dictionary.set(result, "construction_valid", true)
                Otherwise:
                    Dictionary.set(result, "construction_valid", false)
            
            Otherwise:
                If String.equals(operation, "intersection"):
                    Note: Intersection: L1 ∩ L2 minus CFLs are NOT closed under intersection
                    Dictionary.set(result, "is_closed", false)
                    Dictionary.set(result, "can_construct", false)
                    Dictionary.set(result, "counterexample", "L1 is equal to {a^n b^n c^m | n,m ≥ 0}, L2 is equal to {a^m b^n c^n | m,n ≥ 0}")
                    Dictionary.set(result, "intersection_result", "{a^n b^n c^n | n ≥ 0} minus not context-free")
                    Dictionary.set(result, "reason", "Intersection can produce context-sensitive languages")
                
                Otherwise:
                    If String.equals(operation, "complement"):
                        Note: Complement: Σ* minus L minus CFLs are NOT closed under complement
                        Dictionary.set(result, "is_closed", false)
                        Dictionary.set(result, "can_construct", false)
                        Dictionary.set(result, "counterexample", "If CFLs closed under complement and intersection (known false), they'd be closed under complement")
                        Dictionary.set(result, "reason", "Complement of CFL is not necessarily context-free")
                    
                    Otherwise:
                        If String.equals(operation, "difference"):
                            Note: Difference: L1 minus L2 is equal to L1 ∩ complement(L2) minus NOT closed
                            Dictionary.set(result, "is_closed", false)
                            Dictionary.set(result, "can_construct", false)
                            Dictionary.set(result, "reason", "Difference requires intersection with complement, both not closed")
                        
                        Otherwise:
                            If String.equals(operation, "reverse"):
                                Note: Reverse: L^R minus CFLs are closed under reversal
                                Dictionary.set(result, "is_closed", true)
                                Dictionary.set(result, "can_construct", true)
                                Dictionary.set(result, "construction_method", "Reverse all production right-hand sides")
                                If List.size(languages) is greater than or equal to 1:
                                    Dictionary.set(result, "construction_valid", true)
                                Otherwise:
                                    Dictionary.set(result, "construction_valid", false)
                            
                            Otherwise:
                                If String.equals(operation, "substitution"):
                                    Note: Substitution by CFLs minus CFLs are closed under this
                                    Dictionary.set(result, "is_closed", true)
                                    Dictionary.set(result, "can_construct", true)
                                    Dictionary.set(result, "construction_method", "Replace each terminal with corresponding CFL")
                                
                                Otherwise:
                                    Note: Unknown operation
                                    Dictionary.set(result, "is_closed", false)
                                    Dictionary.set(result, "can_construct", false)
                                    Dictionary.set(result, "reason", "Unknown operation: " plus operation)
    
    Note: Add general closure information
    Dictionary.set(result, "language_class", "context-free")
    Dictionary.set(result, "closed_operations", "union, concatenation, Kleene star, reverse, substitution")
    Dictionary.set(result, "non_closed_operations", "intersection, complement, difference")
    
    Return result

Process called "demonstrate_non_closure" that takes language_class as String, operation as String returns Dictionary[String, List[String]]:
    Note: Demonstrate non-closure property with counterexample
    Note: Shows specific languages where operation leaves class
    Note: Educational tool for understanding language properties
    
    Let demonstration be Dictionary.create()
    Let example_languages be List.create()
    Let result_language be List.create()
    Let explanation be List.create()
    
    If String.equals(language_class, "regular"):
        Note: Regular languages have limited non-closure properties
        If String.equals(operation, "infinite_counting"):
            List.push(example_languages, "a*")
            List.push(example_languages, "b*")
            List.push(result_language, "a^n b^n minus requires counting, not regular")
            List.push(explanation, "Regular languages cannot count unboundedly")
            List.push(explanation, "Finite automata have no memory for counting")
        Otherwise:
            List.push(explanation, "Regular languages are closed under: union, intersection, complement, concatenation, Kleene star")
            List.push(explanation, "No standard operation violates regular closure")
    
    Otherwise:
        If String.equals(language_class, "context-free"):
            If String.equals(operation, "intersection"):
                List.push(example_languages, "{a^n b^n c^m | n,m is greater than or equal to 0}")
                List.push(example_languages, "{a^m b^n c^n | m,n is greater than or equal to 0}")
                List.push(result_language, "{a^n b^n c^n | n is greater than or equal to 0}")
                List.push(explanation, "L1 ∩ L2 is equal to {a^n b^n c^n | n ≥ 0} is context-sensitive, not context-free")
                List.push(explanation, "Requires counting three equal quantities simultaneously")
                List.push(explanation, "Single stack cannot track three independent counters")
            
            Otherwise:
                If String.equals(operation, "complement"):
                    List.push(example_languages, "{a^n b^n | n is greater than or equal to 0}")
                    List.push(result_language, "All strings except a^n b^n")
                    List.push(explanation, "Complement of {a^n b^n} includes strings like a^n b^m where n ≠ m")
                    List.push(explanation, "PDA cannot verify inequality of counts")
                    List.push(explanation, "Requires comparing stack height with input position minus not possible with standard PDA")
                
                Otherwise:
                    If String.equals(operation, "difference"):
                        List.push(example_languages, "{a^n b^n c^m | n,m is greater than or equal to 0}")
                        List.push(example_languages, "{a^n b^m c^m | n,m is greater than or equal to 0}")
                        List.push(result_language, "{a^n b^n c^m | n is greater than or equal to 0, m is greater than or equal to 0, n ≠ m}")
                        List.push(explanation, "Difference can create context-sensitive patterns")
                        List.push(explanation, "Result requires inequality checking between counts")
                    
                    Otherwise:
                        List.push(explanation, "Context-free languages are closed under: union, concatenation, Kleene star")
                        List.push(explanation, "Not closed under: intersection, complement, difference")
        
        Otherwise:
            If String.equals(language_class, "context-sensitive"):
                If String.equals(operation, "arbitrary_deletion"):
                    List.push(example_languages, "{a^n b^n c^n | n is greater than or equal to 0}")
                    List.push(result_language, "{a^i b^j c^k | some relation between i,j,k allowing deletions}")
                    List.push(explanation, "Context-sensitive grammars cannot freely delete symbols")
                    List.push(explanation, "Violates non-contracting property of context-sensitive grammars")
                    List.push(explanation, "Might produce unrestricted (Type 0) language")
                
                Otherwise:
                    List.push(explanation, "Context-sensitive languages closed under most operations")
                    List.push(explanation, "Main limitation: cannot have length-decreasing productions")
            
            Otherwise:
                If String.equals(language_class, "decidable"):
                    If String.equals(operation, "halting_problem"):
                        List.push(example_languages, "Set of all decidable languages")
                        List.push(result_language, "Halting problem minus undecidable")
                        List.push(explanation, "No algorithm can determine if arbitrary TM halts")
                        List.push(explanation, "Diagonal argument shows halting problem is undecidable")
                        List.push(explanation, "Exceeds power of decidable languages")
                    
                    Otherwise:
                        List.push(explanation, "Decidable languages closed under Boolean operations")
                        List.push(explanation, "Main limitation: cannot solve undecidable problems")
                
                Otherwise:
                    Note: Unknown language class
                    List.push(explanation, "Unknown language class: " plus language_class)
    
    Note: Store demonstration results
    Dictionary.set(demonstration, "language_class", language_class)
    Dictionary.set(demonstration, "operation", operation)
    Dictionary.set(demonstration, "example_languages", example_languages)
    Dictionary.set(demonstration, "result_language", result_language)
    Dictionary.set(demonstration, "explanation", explanation)
    
    Note: Add educational context
    Let educational_notes be List.create()
    List.push(educational_notes, "Non-closure demonstrates computational limits of language classes")
    List.push(educational_notes, "Shows why hierarchy exists: each class has limited computational power")
    List.push(educational_notes, "Counterexamples prove separation between classes")
    Dictionary.set(demonstration, "educational_notes", educational_notes)
    
    Return demonstration

Process called "compute_language_operations" that takes languages as List[Dictionary[String, String]], operations as List[String] returns List[Dictionary[String, String]]:
    Note: Compute results of various language operations
    Note: Handles operations at appropriate abstraction level
    Note: Maintains language representations throughout computation
    
    Let results be List.create()
    
    Note: Apply each operation in sequence
    For each operation in operations:
        Let operation_result be Dictionary.create()
        Dictionary.set(operation_result, "operation", operation)
        Dictionary.set(operation_result, "input_count", String.from_integer(List.size(languages)))
        
        If String.equals(operation, "union"):
            If List.size(languages) is greater than or equal to 2:
                Let lang1 be List.get(languages, 0)
                Let lang2 be List.get(languages, 1)
                
                Note: Create union language representation
                Dictionary.set(operation_result, "type", "union")
                Dictionary.set(operation_result, "language1_type", Dictionary.get(lang1, "type"))
                Dictionary.set(operation_result, "language2_type", Dictionary.get(lang2, "type"))
                
                Note: Determine result type based on input types
                If String.equals(Dictionary.get(lang1, "type"), "DFA") and String.equals(Dictionary.get(lang2, "type"), "DFA"):
                    Dictionary.set(operation_result, "result_type", "DFA")
                    Dictionary.set(operation_result, "construction", "product_construction_union")
                Otherwise:
                    If String.equals(Dictionary.get(lang1, "type"), "Grammar") and String.equals(Dictionary.get(lang2, "type"), "Grammar"):
                        Dictionary.set(operation_result, "result_type", "Grammar")
                        Dictionary.set(operation_result, "construction", "new_start_symbol_S_to_S1_or_S2")
                    Otherwise:
                        Dictionary.set(operation_result, "result_type", "mixed")
                        Dictionary.set(operation_result, "construction", "convert_to_common_representation")
                
                Dictionary.set(operation_result, "complexity", "exponential_in_states")
            Otherwise:
                Dictionary.set(operation_result, "error", "Union requires at least 2 languages")
        
        Otherwise:
            If String.equals(operation, "intersection"):
                If List.size(languages) is greater than or equal to 2:
                    Let lang1 be List.get(languages, 0)
                    Let lang2 be List.get(languages, 1)
                    
                    Dictionary.set(operation_result, "type", "intersection")
                    Dictionary.set(operation_result, "language1_type", Dictionary.get(lang1, "type"))
                    Dictionary.set(operation_result, "language2_type", Dictionary.get(lang2, "type"))
                    
                    Note: Check closure properties
                    If String.equals(Dictionary.get(lang1, "type"), "DFA"):
                        Dictionary.set(operation_result, "result_type", "DFA")
                        Dictionary.set(operation_result, "closed", "true")
                        Dictionary.set(operation_result, "construction", "product_construction_intersection")
                    Otherwise:
                        If String.equals(Dictionary.get(lang1, "type"), "Grammar"):
                            Dictionary.set(operation_result, "result_type", "possibly_context_sensitive")
                            Dictionary.set(operation_result, "closed", "false")
                            Dictionary.set(operation_result, "construction", "intersection_not_closed_for_CFG")
                        Otherwise:
                            Dictionary.set(operation_result, "result_type", "unknown")
                            Dictionary.set(operation_result, "construction", "depends_on_input_types")
                
                Otherwise:
                    Dictionary.set(operation_result, "error", "Intersection requires at least 2 languages")
            
            Otherwise:
                If String.equals(operation, "complement"):
                    If List.size(languages) is greater than or equal to 1:
                        Let lang be List.get(languages, 0)
                        
                        Dictionary.set(operation_result, "type", "complement")
                        Dictionary.set(operation_result, "input_type", Dictionary.get(lang, "type"))
                        
                        If String.equals(Dictionary.get(lang, "type"), "DFA"):
                            Dictionary.set(operation_result, "result_type", "DFA")
                            Dictionary.set(operation_result, "closed", "true")
                            Dictionary.set(operation_result, "construction", "swap_accept_reject_states")
                        Otherwise:
                            If String.equals(Dictionary.get(lang, "type"), "Grammar"):
                                Dictionary.set(operation_result, "result_type", "possibly_non_context_free")
                                Dictionary.set(operation_result, "closed", "false")
                                Dictionary.set(operation_result, "construction", "complement_not_closed_for_CFG")
                            Otherwise:
                                Dictionary.set(operation_result, "result_type", "unknown")
                                Dictionary.set(operation_result, "construction", "depends_on_input_type")
                    
                    Otherwise:
                        Dictionary.set(operation_result, "error", "Complement requires at least 1 language")
                
                Otherwise:
                    If String.equals(operation, "concatenation"):
                        If List.size(languages) is greater than or equal to 2:
                            Let lang1 be List.get(languages, 0)
                            Let lang2 be List.get(languages, 1)
                            
                            Dictionary.set(operation_result, "type", "concatenation")
                            Dictionary.set(operation_result, "language1_type", Dictionary.get(lang1, "type"))
                            Dictionary.set(operation_result, "language2_type", Dictionary.get(lang2, "type"))
                            
                            Note: All major classes closed under concatenation
                            If String.equals(Dictionary.get(lang1, "type"), "DFA"):
                                Dictionary.set(operation_result, "result_type", "NFA")
                                Dictionary.set(operation_result, "closed", "true")
                                Dictionary.set(operation_result, "construction", "epsilon_transitions_connect_automata")
                            Otherwise:
                                If String.equals(Dictionary.get(lang1, "type"), "Grammar"):
                                    Dictionary.set(operation_result, "result_type", "Grammar")
                                    Dictionary.set(operation_result, "closed", "true")
                                    Dictionary.set(operation_result, "construction", "new_start_S_to_S1_S2")
                                Otherwise:
                                    Dictionary.set(operation_result, "result_type", "preserved")
                                    Dictionary.set(operation_result, "construction", "depends_on_input_types")
                        
                        Otherwise:
                            Dictionary.set(operation_result, "error", "Concatenation requires at least 2 languages")
                    
                    Otherwise:
                        If String.equals(operation, "kleene_star"):
                            If List.size(languages) is greater than or equal to 1:
                                Let lang be List.get(languages, 0)
                                
                                Dictionary.set(operation_result, "type", "kleene_star")
                                Dictionary.set(operation_result, "input_type", Dictionary.get(lang, "type"))
                                
                                Note: All major classes closed under Kleene star
                                If String.equals(Dictionary.get(lang, "type"), "DFA"):
                                    Dictionary.set(operation_result, "result_type", "NFA")
                                    Dictionary.set(operation_result, "closed", "true")
                                    Dictionary.set(operation_result, "construction", "epsilon_transitions_for_iteration")
                                Otherwise:
                                    If String.equals(Dictionary.get(lang, "type"), "Grammar"):
                                        Dictionary.set(operation_result, "result_type", "Grammar")
                                        Dictionary.set(operation_result, "closed", "true")
                                        Dictionary.set(operation_result, "construction", "new_start_S_to_epsilon_or_S1_S")
                                    Otherwise:
                                        Dictionary.set(operation_result, "result_type", "preserved")
                                        Dictionary.set(operation_result, "construction", "closure_preserved")
                            
                            Otherwise:
                                Dictionary.set(operation_result, "error", "Kleene star requires at least 1 language")
                        
                        Otherwise:
                            Note: Unknown operation
                            Dictionary.set(operation_result, "error", "Unknown operation: " plus operation)
                            Dictionary.set(operation_result, "supported_operations", "union, intersection, complement, concatenation, kleene_star")
        
        Note: Add computational complexity information
        If String.equals(operation, "union") or String.equals(operation, "intersection"):
            Dictionary.set(operation_result, "time_complexity", "polynomial_in_product_size")
            Dictionary.set(operation_result, "space_complexity", "exponential_worst_case")
        Otherwise:
            If String.equals(operation, "complement"):
                Dictionary.set(operation_result, "time_complexity", "linear")
                Dictionary.set(operation_result, "space_complexity", "constant_overhead")
            Otherwise:
                Dictionary.set(operation_result, "time_complexity", "varies_by_operation")
                Dictionary.set(operation_result, "space_complexity", "varies_by_operation")
        
        List.push(results, operation_result)
    
    Return results

Note: =====================================================================
Note: DECIDABILITY OPERATIONS
Note: =====================================================================

Process called "check_automaton_equivalence" that takes automaton1 as FiniteAutomaton, automaton2 as FiniteAutomaton returns Boolean:
    Note: Check if two finite automata recognize same language
    Note: Decidable for regular languages using symmetric difference
    Note: Time complexity: exponential in worst case
    
    Note: Two automata are equivalent if they accept exactly the same set of strings
    Note: Algorithm: construct symmetric difference and check if it's empty
    
    Note: Create symmetric difference automaton (A1 minus A2) ∪ (A2 minus A1)
    Let difference_automaton1 be compute_automaton_difference(automaton1, automaton2)
    Let difference_automaton2 be compute_automaton_difference(automaton2, automaton1)
    Let symmetric_difference be compute_automaton_union(difference_automaton1, difference_automaton2)
    
    Note: Check if symmetric difference is empty
    Let is_empty be check_language_emptiness(symmetric_difference)
    
    Note: Automata are equivalent iff their symmetric difference is empty
    If is_empty:
        Return true  Note: Languages are equivalent
    Otherwise:
        Return false  Note: Languages differ

Process called "check_grammar_ambiguity" that takes grammar as Grammar returns Dictionary[String, Boolean]:
    Note: Check if context-free grammar is ambiguous
    Note: Undecidable in general, but decidable for some subclasses
    Note: Provides examples of ambiguous derivations if found
    
    Let result be Dictionary.create()
    Dictionary.set(result, "is_ambiguous", false)
    Dictionary.set(result, "decidable", false)
    Dictionary.set(result, "analysis_method", "heuristic")
    
    Note: Check for obvious ambiguity patterns
    Let ambiguous_patterns be 0
    Let potential_conflicts be List.create()
    
    Note: Look for left recursion that might cause ambiguity
    For each non_terminal in grammar.non_terminals:
        If Dictionary.has_key(grammar.productions, non_terminal):
            Let productions_list be Dictionary.get(grammar.productions, non_terminal)
            Let left_recursive_count be 0
            
            For each production in productions_list:
                If not List.is_empty(production):
                    Let first_symbol be List.get(production, 0)
                    If String.equals(first_symbol, non_terminal):
                        Let left_recursive_count be left_recursive_count plus 1
            
            Note: Multiple left-recursive productions can cause ambiguity
            If left_recursive_count is greater than 1:
                Let ambiguous_patterns be ambiguous_patterns plus 1
                List.push(potential_conflicts, "Multiple left-recursive productions for " plus non_terminal)
    
    Note: Check for duplicate productions with same left-hand side
    For each non_terminal in grammar.non_terminals:
        If Dictionary.has_key(grammar.productions, non_terminal):
            Let productions_list be Dictionary.get(grammar.productions, non_terminal)
            
            Note: Look for productions that could generate same string in multiple ways
            For i from 0 to (List.size(productions_list) minus 1):
                For j from (i plus 1) to (List.size(productions_list) minus 1):
                    Let prod1 be List.get(productions_list, i)
                    Let prod2 be List.get(productions_list, j)
                    
                    Note: Heuristic: similar productions might indicate ambiguity
                    If List.size(prod1) is equal to List.size(prod2) and List.size(prod1) is greater than 1:
                        Let similar be true
                        For k from 0 to (List.size(prod1) minus 1):
                            Let symbol1 be List.get(prod1, k)
                            Let symbol2 be List.get(prod2, k)
                            If not String.equals(symbol1, symbol2):
                                Let similar be false
                                Break
                        
                        If similar and not List.equals(prod1, prod2):
                            List.push(potential_conflicts, "Similar productions for " plus non_terminal)
    
    Note: Check for classic ambiguous grammar patterns
    For each non_terminal in grammar.non_terminals:
        If Dictionary.has_key(grammar.productions, non_terminal):
            Let productions_list be Dictionary.get(grammar.productions, non_terminal)
            
            Note: Look for expression grammar ambiguity (E → E plus E | E multiplied by E | id)
            Let has_binary_operators be 0
            For each production in productions_list:
                If List.size(production) is equal to 3:
                    Let first_symbol be List.get(production, 0)
                    Let second_symbol be List.get(production, 1)
                    Let third_symbol be List.get(production, 2)
                    
                    If String.equals(first_symbol, non_terminal) and String.equals(third_symbol, non_terminal):
                        Let has_binary_operators be has_binary_operators plus 1
            
            If has_binary_operators is greater than 1:
                Let ambiguous_patterns be ambiguous_patterns plus 1
                List.push(potential_conflicts, "Multiple binary operators without precedence: " plus non_terminal)
    
    Note: Analyze dangling-otherwise problem pattern
    For each non_terminal in grammar.non_terminals:
        If Dictionary.has_key(grammar.productions, non_terminal):
            Let productions_list be Dictionary.get(grammar.productions, non_terminal)
            
            Let has_if_then be false
            Let has_if_then_else be false
            
            For each production in productions_list:
                Note: Look for if-then and if-then-otherwise patterns
                If List.contains(production, "if") and List.contains(production, "then"):
                    If List.contains(production, "otherwise"):
                        Let has_if_then_else be true
                    Otherwise:
                        Let has_if_then be true
            
            If has_if_then and has_if_then_else:
                Let ambiguous_patterns be ambiguous_patterns plus 1
                List.push(potential_conflicts, "Dangling-otherwise ambiguity in " plus non_terminal)
    
    Note: Determine if grammar appears ambiguous
    If ambiguous_patterns is greater than 0:
        Dictionary.set(result, "is_ambiguous", true)
        Dictionary.set(result, "confidence", "heuristic_detection")
    Otherwise:
        Dictionary.set(result, "is_ambiguous", false)
        Dictionary.set(result, "confidence", "no_obvious_ambiguity")
    
    Note: Store analysis results
    Dictionary.set(result, "ambiguous_patterns_found", String.from_integer(ambiguous_patterns))
    Dictionary.set(result, "potential_conflicts", Collections.join_strings(potential_conflicts, "; "))
    Dictionary.set(result, "decidability_note", "Ambiguity is undecidable for general CFGs")
    Dictionary.set(result, "subclass_note", "Decidable for LR(k), LL(k), and other restricted classes")
    
    Note: Add specific grammar class analysis
    If String.contains(grammar.grammar_type, "LL"):
        Dictionary.set(result, "decidable", true)
        Dictionary.set(result, "analysis_method", "LL_conflict_detection")
    Otherwise:
        If String.contains(grammar.grammar_type, "LR"):
            Dictionary.set(result, "decidable", true)
            Dictionary.set(result, "analysis_method", "LR_conflict_detection")
        Otherwise:
            Dictionary.set(result, "decidable", false)
            Dictionary.set(result, "analysis_method", "heuristic_undecidable")
    
    Return result

Process called "solve_post_correspondence_problem" that takes tiles as List[Dictionary[String, String]] returns Dictionary[String, List[Integer]]:
    Note: Attempt to solve Post Correspondence Problem instance
    Note: Undecidable problem, may not terminate
    Note: Demonstrates undecidability in formal language theory
    
    Let result be Dictionary.create()
    Dictionary.set(result, "problem_type", "Post Correspondence Problem")
    Dictionary.set(result, "decidability", "undecidable")
    Dictionary.set(result, "solution_found", false)
    
    Note: PCP: Given tiles [(t1,b1), (t2,b2), ..., (tk,bk)], find sequence i1,i2,...,in
    Note: such that ti1 ti2 ... tin is equal to bi1 bi2 ... bin
    
    Let solution_sequence be List.create()
    Let max_attempts be 1000  Note: Limit search to prevent infinite loop
    Let attempt_count be 0
    
    Note: Try various search strategies (breadth-first bounded search)
    Let search_queue be List.create()
    
    Note: Initialize search with each tile as starting point
    For i from 0 to (List.size(tiles) minus 1):
        Let tile be List.get(tiles, i)
        Let top_string be Dictionary.get(tile, "top")
        Let bottom_string be Dictionary.get(tile, "bottom")
        
        Let initial_state be Dictionary.create()
        Dictionary.set(initial_state, "sequence", String.from_integer(i))
        Dictionary.set(initial_state, "top_accumulated", top_string)
        Dictionary.set(initial_state, "bottom_accumulated", bottom_string)
        Dictionary.set(initial_state, "length", String.from_integer(1))
        
        List.push(search_queue, initial_state)
    
    Note: Bounded breadth-first search
    While not List.is_empty(search_queue) and attempt_count is less than max_attempts:
        Let current_state be List.get(search_queue, 0)
        List.remove_at(search_queue, 0)
        
        Let current_sequence be Dictionary.get(current_state, "sequence")
        Let current_top be Dictionary.get(current_state, "top_accumulated")
        Let current_bottom be Dictionary.get(current_state, "bottom_accumulated")
        Let current_length be Integer.parse_from_string(Dictionary.get(current_state, "length"))
        
        Let attempt_count be attempt_count plus 1
        
        Note: Check if we have a solution
        If String.equals(current_top, current_bottom) and String.length(current_top) is greater than 0:
            Dictionary.set(result, "solution_found", true)
            Dictionary.set(result, "solution_sequence", current_sequence)
            Dictionary.set(result, "solution_string", current_top)
            Dictionary.set(result, "solution_length", String.from_integer(current_length))
            Break
        
        Note: Expand search if not too deep and strings could still match
        If current_length is less than 10:  Note: Depth limit to prevent explosion
            Note: Try appending each tile
            For i from 0 to (List.size(tiles) minus 1):
                Let tile be List.get(tiles, i)
                Let tile_top be Dictionary.get(tile, "top")
                Let tile_bottom be Dictionary.get(tile, "bottom")
                
                Let new_top be String.concatenate(current_top, tile_top)
                Let new_bottom be String.concatenate(current_bottom, tile_bottom)
                
                Note: Pruning: only continue if strings could potentially match
                Let can_match be false
                If String.length(new_top) is equal to String.length(new_bottom):
                    Let can_match be true
                Otherwise:
                    Note: Check if shorter string is prefix of longer string
                    If String.length(new_top) is less than String.length(new_bottom):
                        If String.starts_with(new_bottom, new_top):
                            Let can_match be true
                    Otherwise:
                        If String.starts_with(new_top, new_bottom):
                            Let can_match be true
                
                If can_match:
                    Let new_state be Dictionary.create()
                    Dictionary.set(new_state, "sequence", String.concatenate(current_sequence, String.concatenate(",", String.from_integer(i))))
                    Dictionary.set(new_state, "top_accumulated", new_top)
                    Dictionary.set(new_state, "bottom_accumulated", new_bottom)
                    Dictionary.set(new_state, "length", String.from_integer(current_length plus 1))
                    
                    List.push(search_queue, new_state)
    
    Note: Store search results
    Dictionary.set(result, "search_attempts", String.from_integer(attempt_count))
    Dictionary.set(result, "max_attempts_reached", String.from_boolean(attempt_count is greater than or equal to max_attempts))
    Dictionary.set(result, "tiles_count", String.from_integer(List.size(tiles)))
    
    Note: Analyze tile properties
    Let tile_analysis be List.create()
    For i from 0 to (List.size(tiles) minus 1):
        Let tile be List.get(tiles, i)
        Let top_string be Dictionary.get(tile, "top")
        Let bottom_string be Dictionary.get(tile, "bottom")
        
        Let tile_info be String.concatenate("Tile ", String.concatenate(String.from_integer(i), String.concatenate(": (", String.concatenate(top_string, String.concatenate(", ", String.concatenate(bottom_string, ")"))))))
        List.push(tile_analysis, tile_info)
    
    Dictionary.set(result, "tiles_analysis", Collections.join_strings(tile_analysis, "; "))
    
    Note: Add theoretical context
    Dictionary.set(result, "theoretical_note", "PCP is undecidable minus no algorithm can solve all instances")
    Dictionary.set(result, "search_strategy", "Bounded breadth-first search with prefix pruning")
    Dictionary.set(result, "termination_guarantee", "Search terminates due to depth and attempt limits")
    
    If not Dictionary.get(result, "solution_found"):
        Dictionary.set(result, "conclusion", "No solution found within search limits minus may still exist")
    Otherwise:
        Dictionary.set(result, "conclusion", "Solution found minus PCP instance is solvable")
    
    Return result

Process called "analyze_halting_problem" that takes program_description as String, input_description as String returns Dictionary[String, String]:
    Note: Analyze halting problem for given program and input
    Note: Cannot be solved algorithmically in general
    Note: Provides partial analysis and termination heuristics
    
    Let analysis be Dictionary.create()
    Dictionary.set(analysis, "problem_type", "Halting Problem")
    Dictionary.set(analysis, "decidability", "undecidable")
    Dictionary.set(analysis, "program", program_description)
    Dictionary.set(analysis, "input", input_description)
    
    Note: Provide heuristic analysis (cannot be complete due to undecidability)
    Dictionary.set(analysis, "analysis_type", "heuristic_partial")
    Dictionary.set(analysis, "certainty", "inconclusive")
    
    Note: Look for obvious termination patterns
    Let termination_clues be List.create()
    Let non_termination_clues be List.create()
    
    Note: Check for simple terminating patterns
    If String.contains(program_description, "finite loop") or String.contains(program_description, "for i from"):
        List.push(termination_clues, "Contains finite loop structure")
    
    If String.contains(program_description, "return") or String.contains(program_description, "halt"):
        List.push(termination_clues, "Contains explicit termination statements")
    
    If String.contains(program_description, "countdown") or String.contains(program_description, "decrement"):
        List.push(termination_clues, "Contains countdown pattern")
    
    Note: Check for non-termination patterns
    If String.contains(program_description, "while true") or String.contains(program_description, "infinite loop"):
        List.push(non_termination_clues, "Contains infinite loop structure")
    
    If String.contains(program_description, "recursion") and not String.contains(program_description, "base case"):
        List.push(non_termination_clues, "Contains recursion without obvious base case")
    
    If String.contains(program_description, "self-reference") or String.contains(program_description, "diagonalization"):
        List.push(non_termination_clues, "Contains self-referential pattern")
    
    Note: Analyze input characteristics
    If String.contains(input_description, "empty") or String.contains(input_description, "null"):
        List.push(termination_clues, "Empty input often leads to quick termination")
    
    If String.contains(input_description, "large") or String.contains(input_description, "infinite"):
        List.push(non_termination_clues, "Large or infinite input may cause non-termination")
    
    Note: Provide heuristic assessment
    Let termination_score be List.size(termination_clues) minus List.size(non_termination_clues)
    
    If termination_score is greater than 0:
        Dictionary.set(analysis, "heuristic_prediction", "likely_terminates")
        Dictionary.set(analysis, "confidence", "low_heuristic")
    Otherwise:
        If termination_score is less than 0:
            Dictionary.set(analysis, "heuristic_prediction", "likely_non_terminating")
            Dictionary.set(analysis, "confidence", "low_heuristic")
        Otherwise:
            Dictionary.set(analysis, "heuristic_prediction", "uncertain")
            Dictionary.set(analysis, "confidence", "no_evidence")
    
    Dictionary.set(analysis, "termination_clues", Collections.join_strings(termination_clues, "; "))
    Dictionary.set(analysis, "non_termination_clues", Collections.join_strings(non_termination_clues, "; "))
    
    Note: Add theoretical context
    Dictionary.set(analysis, "theoretical_background", "Halting problem proven undecidable by Turing (1936)")
    Dictionary.set(analysis, "proof_technique", "Diagonal argument and self-reference")
    Dictionary.set(analysis, "impossibility_result", "No algorithm can decide halting for all program-input pairs")
    
    Note: Practical limitations
    Dictionary.set(analysis, "practical_note", "Some specific cases may be decidable")
    Dictionary.set(analysis, "semi_decidable", "Can detect termination if it occurs, cannot detect non-termination")
    
    Note: Related problems
    Let related_problems be List.create()
    List.push(related_problems, "Rice's theorem minus all non-trivial program properties undecidable")
    List.push(related_problems, "Post Correspondence Problem")
    List.push(related_problems, "Entscheidungsproblem")
    Dictionary.set(analysis, "related_undecidable_problems", Collections.join_strings(related_problems, "; "))
    
    Note: Partial decidability results
    Let partial_results be List.create()
    List.push(partial_results, "Programs with only finite loops are decidable")
    List.push(partial_results, "Linear programs with integer arithmetic decidable")
    List.push(partial_results, "Some restricted programming models decidable")
    Dictionary.set(analysis, "decidable_subclasses", Collections.join_strings(partial_results, "; "))
    
    Note: Simulation approach
    Dictionary.set(analysis, "simulation_approach", "Run program with step limit")
    Dictionary.set(analysis, "simulation_limitation", "Cannot distinguish non-termination from slow termination")
    Dictionary.set(analysis, "timeout_interpretation", "Timeout suggests non-termination but proves nothing")
    
    Return analysis

Note: =====================================================================
Note: COMPLEXITY ANALYSIS OPERATIONS
Note: =====================================================================

Process called "analyze_automaton_complexity" that takes automaton as FiniteAutomaton, complexity_measures as List[String] returns Dictionary[String, Dictionary[String, Float]]:
    Note: Analyze various complexity measures of automaton
    Note: Measures: state count, transition count, alphabet size, description complexity
    Note: Space and time complexity for operations
    
    Let complexity_analysis be Dictionary.create()
    
    Note: Basic structural complexity measures
    Let structural_measures be Dictionary.create()
    Dictionary.set(structural_measures, "state_count", Float.from_integer(List.size(automaton.states)))
    Dictionary.set(structural_measures, "alphabet_size", Float.from_integer(List.size(automaton.alphabet)))
    Dictionary.set(structural_measures, "accept_states_count", Float.from_integer(List.size(automaton.accept_states)))
    
    Note: Count total transitions
    Let total_transitions be 0
    For each state in automaton.states:
        If Dictionary.has_key(automaton.transitions, state):
            Let state_transitions be Dictionary.get(automaton.transitions, state)
            For each symbol in automaton.alphabet:
                If Dictionary.has_key(state_transitions, symbol):
                    Let total_transitions be total_transitions plus 1
    
    Dictionary.set(structural_measures, "transition_count", Float.from_integer(total_transitions))
    Dictionary.set(structural_measures, "transition_density", Float.divide(Float.from_integer(total_transitions), Float.multiply(Float.from_integer(List.size(automaton.states)), Float.from_integer(List.size(automaton.alphabet)))))
    
    Dictionary.set(complexity_analysis, "structural", structural_measures)
    
    Note: Time complexity analysis for operations
    If List.contains(complexity_measures, "time_complexity"):
        Let time_measures be Dictionary.create()
        Let n be Float.from_integer(List.size(automaton.states))
        Let k be Float.from_integer(List.size(automaton.alphabet))
        
        Dictionary.set(time_measures, "simulation", n)  Note: O(n) per input symbol
        Dictionary.set(time_measures, "minimization", Float.multiply(n, Float.log(n)))  Note: O(n log n) for Hopcroft
        Dictionary.set(time_measures, "union_with_same_size", Float.multiply(n, n))  Note: O(n²) product construction
        Dictionary.set(time_measures, "intersection", Float.multiply(n, n))  Note: O(n²) product construction
        Dictionary.set(time_measures, "complement", Float.from_float(1.0))  Note: O(1) minus just swap accept states
        Dictionary.set(time_measures, "emptiness_check", n)  Note: O(n) reachability
        Dictionary.set(time_measures, "equivalence_check", Float.power(Float.from_float(2.0), n))  Note: O(2^n) worst case
        
        Dictionary.set(complexity_analysis, "time_complexity", time_measures)
    
    Note: Space complexity analysis
    If List.contains(complexity_measures, "space_complexity"):
        Let space_measures be Dictionary.create()
        Let n be Float.from_integer(List.size(automaton.states))
        Let k be Float.from_integer(List.size(automaton.alphabet))
        
        Dictionary.set(space_measures, "representation", Float.multiply(n, k))  Note: O(nk) transition table
        Dictionary.set(space_measures, "simulation_stack", n)  Note: O(n) for NFA simulation
        Dictionary.set(space_measures, "minimization_workspace", Float.multiply(n, n))  Note: O(n²) for partition refinement
        Dictionary.set(space_measures, "product_construction", Float.multiply(n, n))  Note: O(n²) for union/intersection
        
        Dictionary.set(complexity_analysis, "space_complexity", space_measures)
    
    Note: Description complexity (Kolmogorov-like)
    If List.contains(complexity_measures, "description_complexity"):
        Let description_measures be Dictionary.create()
        
        Note: Estimate description length based on structure
        Let state_description_bits be Float.multiply(Float.log2(Float.from_integer(List.size(automaton.states))), Float.from_integer(List.size(automaton.states)))
        Let transition_description_bits be Float.multiply(Float.log2(Float.from_integer(List.size(automaton.states))), Float.from_integer(total_transitions))
        Let alphabet_description_bits be Float.multiply(Float.log2(Float.from_integer(List.size(automaton.alphabet))), Float.from_integer(List.size(automaton.alphabet)))
        
        Dictionary.set(description_measures, "state_bits", state_description_bits)
        Dictionary.set(description_measures, "transition_bits", transition_description_bits)
        Dictionary.set(description_measures, "alphabet_bits", alphabet_description_bits)
        Dictionary.set(description_measures, "total_bits", Float.add(Float.add(state_description_bits, transition_description_bits), alphabet_description_bits))
        
        Dictionary.set(complexity_analysis, "description_complexity", description_measures)
    
    Note: Language complexity measures
    If List.contains(complexity_measures, "language_complexity"):
        Let language_measures be Dictionary.create()
        
        Note: Estimate language properties
        Dictionary.set(language_measures, "minimum_dfa_states", Float.from_integer(List.size(automaton.states)))  Note: Current size as upper bound
        Dictionary.set(language_measures, "regular_expression_size_estimate", Float.power(Float.from_float(2.0), Float.from_integer(List.size(automaton.states))))  Note: Exponential worst case
        Dictionary.set(language_measures, "pumping_constant", Float.from_integer(List.size(automaton.states)))  Note: Pumping lemma constant
        
        Note: Star height estimate (heuristic)
        Dictionary.set(language_measures, "estimated_star_height", Float.log2(Float.from_integer(List.size(automaton.states))))
        
        Dictionary.set(complexity_analysis, "language_complexity", language_measures)
    
    Note: Communication complexity (for distributed algorithms)
    If List.contains(complexity_measures, "communication_complexity"):
        Let comm_measures be Dictionary.create()
        
        Dictionary.set(comm_measures, "state_encoding_bits", Float.log2(Float.from_integer(List.size(automaton.states))))
        Dictionary.set(comm_measures, "symbol_encoding_bits", Float.log2(Float.from_integer(List.size(automaton.alphabet))))
        Dictionary.set(comm_measures, "transition_message_size", Float.add(Float.log2(Float.from_integer(List.size(automaton.states))), Float.log2(Float.from_integer(List.size(automaton.alphabet)))))
        
        Dictionary.set(complexity_analysis, "communication_complexity", comm_measures)
    
    Note: Add comparative analysis
    Let comparative_measures be Dictionary.create()
    Dictionary.set(comparative_measures, "vs_trivial_automaton", Float.from_integer(List.size(automaton.states)))  Note: Ratio to single-state automaton
    Dictionary.set(comparative_measures, "vs_complete_automaton", Float.divide(Float.from_integer(total_transitions), Float.multiply(Float.from_integer(List.size(automaton.states)), Float.from_integer(List.size(automaton.alphabet)))))  Note: Completeness ratio
    
    Dictionary.set(complexity_analysis, "comparative", comparative_measures)
    
    Return complexity_analysis

Process called "analyze_parsing_complexity" that takes grammar as Grammar, parsing_algorithm as String returns Dictionary[String, Dictionary[String, String]]:
    Note: Analyze complexity of parsing with given grammar and algorithm
    Note: Time complexity depends on grammar class and algorithm choice
    Note: Space complexity analysis for parser implementation
    
    Let analysis be Dictionary.create()
    
    Note: Basic grammar metrics
    Let grammar_metrics be Dictionary.create()
    Dictionary.set(grammar_metrics, "non_terminals_count", String.from_integer(List.size(grammar.non_terminals)))
    Dictionary.set(grammar_metrics, "terminals_count", String.from_integer(List.size(grammar.terminals)))
    
    Let total_productions be 0
    For each non_terminal in grammar.non_terminals:
        If Dictionary.has_key(grammar.productions, non_terminal):
            Let productions_list be Dictionary.get(grammar.productions, non_terminal)
            Let total_productions be total_productions plus List.size(productions_list)
    
    Dictionary.set(grammar_metrics, "total_productions", String.from_integer(total_productions))
    Dictionary.set(grammar_metrics, "grammar_type", grammar.grammar_type)
    Dictionary.set(analysis, "grammar_metrics", grammar_metrics)
    
    Note: Algorithm-specific complexity analysis
    If String.equals(parsing_algorithm, "CYK"):
        Let cyk_analysis be Dictionary.create()
        Dictionary.set(cyk_analysis, "time_complexity", "O(n³ multiplied by |G|)")
        Dictionary.set(cyk_analysis, "space_complexity", "O(n² multiplied by |V|)")
        Dictionary.set(cyk_analysis, "preprocessing", "Convert to CNF minus O(|G|)")
        Dictionary.set(cyk_analysis, "best_case", "O(n³) for fixed grammar")
        Dictionary.set(cyk_analysis, "worst_case", "O(n³ multiplied by |G|)")
        Dictionary.set(cyk_analysis, "space_usage", "Dynamic programming table")
        Dictionary.set(cyk_analysis, "parallelizable", "Yes minus diagonal computation")
        Dictionary.set(analysis, "CYK", cyk_analysis)
    
    Otherwise:
        If String.equals(parsing_algorithm, "Earley"):
            Let earley_analysis be Dictionary.create()
            Dictionary.set(earley_analysis, "time_complexity", "O(n³) worst case")
            Dictionary.set(earley_analysis, "space_complexity", "O(n² multiplied by |G|)")
            Dictionary.set(earley_analysis, "best_case", "O(n) for LR grammars")
            Dictionary.set(earley_analysis, "average_case", "O(n²) for unambiguous")
            Dictionary.set(earley_analysis, "worst_case", "O(n³) for ambiguous")
            Dictionary.set(earley_analysis, "handles_ambiguity", "Yes minus returns all parses")
            Dictionary.set(earley_analysis, "left_recursion", "Handles naturally")
            Dictionary.set(analysis, "Earley", earley_analysis)
        
        Otherwise:
            If String.equals(parsing_algorithm, "LL"):
                Let ll_analysis be Dictionary.create()
                Dictionary.set(ll_analysis, "time_complexity", "O(n)")
                Dictionary.set(ll_analysis, "space_complexity", "O(k) stack depth")
                Dictionary.set(ll_analysis, "preprocessing", "Build FIRST/FOLLOW sets minus O(|G|³)")
                Dictionary.set(ll_analysis, "constraints", "No left recursion, no ambiguity")
                Dictionary.set(ll_analysis, "lookahead_effect", "LL(k) requires O(k) lookahead")
                Dictionary.set(ll_analysis, "table_size", "O(|V| multiplied by |Σ|^k)")
                Dictionary.set(analysis, "LL", ll_analysis)
            
            Otherwise:
                If String.equals(parsing_algorithm, "LR"):
                    Let lr_analysis be Dictionary.create()
                    Dictionary.set(lr_analysis, "time_complexity", "O(n)")
                    Dictionary.set(lr_analysis, "space_complexity", "O(n) stack")
                    Dictionary.set(lr_analysis, "preprocessing", "Build LR table minus O(|G|³)")
                    Dictionary.set(lr_analysis, "handles_left_recursion", "Yes")
                    Dictionary.set(lr_analysis, "shift_reduce_conflicts", "May require resolution")
                    Dictionary.set(lr_analysis, "table_size", "O(|states| multiplied by |Σ|)")
                    Dictionary.set(lr_analysis, "variants", "SLR, LALR, CLR have different table sizes")
                    Dictionary.set(analysis, "LR", lr_analysis)
                
                Otherwise:
                    If String.equals(parsing_algorithm, "recursive_descent"):
                        Let rd_analysis be Dictionary.create()
                        Dictionary.set(rd_analysis, "time_complexity", "O(n) for LL grammars")
                        Dictionary.set(rd_analysis, "space_complexity", "O(depth) recursion stack")
                        Dictionary.set(rd_analysis, "exponential_risk", "Backtracking can cause O(2^n)")
                        Dictionary.set(rd_analysis, "memoization_benefit", "Packrat parsing reduces to O(n)")
                        Dictionary.set(rd_analysis, "left_recursion", "Problematic without modification")
                        Dictionary.set(rd_analysis, "implementation", "Simple and intuitive")
                        Dictionary.set(analysis, "recursive_descent", rd_analysis)
                    
                    Otherwise:
                        Let generic_analysis be Dictionary.create()
                        Dictionary.set(generic_analysis, "algorithm", parsing_algorithm)
                        Dictionary.set(generic_analysis, "analysis", "Unknown algorithm minus cannot provide specific complexity")
                        Dictionary.set(analysis, "generic", generic_analysis)
    
    Note: Grammar-dependent complexity factors
    Let complexity_factors be Dictionary.create()
    
    Note: Check for ambiguity impact
    If String.contains(grammar.grammar_type, "Ambiguous"):
        Dictionary.set(complexity_factors, "ambiguity_impact", "Increases parsing complexity")
        Dictionary.set(complexity_factors, "parse_forest_size", "Exponential in worst case")
    Otherwise:
        Dictionary.set(complexity_factors, "ambiguity_impact", "Unambiguous minus single parse tree")
    
    Note: Check for left recursion
    Let has_left_recursion be false
    For each non_terminal in grammar.non_terminals:
        If Dictionary.has_key(grammar.productions, non_terminal):
            Let productions_list be Dictionary.get(grammar.productions, non_terminal)
            For each production in productions_list:
                If not List.is_empty(production):
                    Let first_symbol be List.get(production, 0)
                    If String.equals(first_symbol, non_terminal):
                        Let has_left_recursion be true
                        Break
        If has_left_recursion:
            Break
    
    If has_left_recursion:
        Dictionary.set(complexity_factors, "left_recursion", "Present minus affects LL parsers")
    Otherwise:
        Dictionary.set(complexity_factors, "left_recursion", "Absent")
    
    Dictionary.set(complexity_factors, "production_complexity", String.from_integer(total_productions))
    Dictionary.set(analysis, "complexity_factors", complexity_factors)
    
    Note: Practical considerations
    Let practical_notes be Dictionary.create()
    Dictionary.set(practical_notes, "memory_locality", "Table-driven parsers have better cache behavior")
    Dictionary.set(practical_notes, "error_recovery", "Affects both time and space complexity")
    Dictionary.set(practical_notes, "incremental_parsing", "Can reduce average-case complexity")
    Dictionary.set(practical_notes, "parallel_parsing", "Some algorithms amenable to parallelization")
    Dictionary.set(analysis, "practical_considerations", practical_notes)
    
    Return analysis

Process called "optimize_automaton_size" that takes automaton as FiniteAutomaton, optimization_goal as String returns FiniteAutomaton:
    Note: Optimize automaton for specified goal (states, transitions, etc.)
    Note: Various optimization techniques and trade-offs
    Note: Maintains language equivalence during optimization
    
    Let optimized_automaton be FiniteAutomaton with:
        states: List.copy(automaton.states)
        alphabet: List.copy(automaton.alphabet)
        transitions: automaton.transitions
        start_state: automaton.start_state
        accept_states: List.copy(automaton.accept_states)
        automaton_type: automaton.automaton_type
        is_deterministic: automaton.is_deterministic
    
    If String.equals(optimization_goal, "minimize_states"):
        Note: Apply state minimization using Hopcroft algorithm
        Let optimized_automaton be minimize_dfa_hopcroft(optimized_automaton)
    
    Otherwise:
        If String.equals(optimization_goal, "minimize_transitions"):
            Note: Remove unreachable states and dead states
            Let reachable_states be List.create()
            List.push(reachable_states, automaton.start_state)
            
            Note: Find all reachable states
            Let changed be true
            While changed:
                Let changed be false
                For each state in reachable_states:
                    If Dictionary.has_key(automaton.transitions, state):
                        Let state_transitions be Dictionary.get(automaton.transitions, state)
                        For each symbol in automaton.alphabet:
                            If Dictionary.has_key(state_transitions, symbol):
                                Let next_state be Dictionary.get(state_transitions, symbol)
                                If not List.contains(reachable_states, next_state):
                                    List.push(reachable_states, next_state)
                                    Let changed be true
            
            Note: Remove unreachable states
            Let new_states be List.create()
            For each state in automaton.states:
                If List.contains(reachable_states, state):
                    List.push(new_states, state)
            
            Note: Update transitions to remove unreachable states
            Let new_transitions be Dictionary.create()
            For each state in new_states:
                If Dictionary.has_key(automaton.transitions, state):
                    Dictionary.set(new_transitions, state, Dictionary.get(automaton.transitions, state))
            
            Let optimized_automaton be FiniteAutomaton with:
                states: new_states
                alphabet: automaton.alphabet
                transitions: new_transitions
                start_state: automaton.start_state
                accept_states: automaton.accept_states
                automaton_type: automaton.automaton_type
                is_deterministic: automaton.is_deterministic
        
        Otherwise:
            If String.equals(optimization_goal, "reduce_alphabet"):
                Note: Find actually used alphabet symbols
                Let used_symbols be List.create()
                For each state in automaton.states:
                    If Dictionary.has_key(automaton.transitions, state):
                        Let state_transitions be Dictionary.get(automaton.transitions, state)
                        For each symbol in Dictionary.keys(state_transitions):
                            If not List.contains(used_symbols, symbol):
                                List.push(used_symbols, symbol)
                
                Note: Create optimized automaton with reduced alphabet
                Let optimized_automaton be FiniteAutomaton with:
                    states: automaton.states
                    alphabet: used_symbols
                    transitions: automaton.transitions
                    start_state: automaton.start_state
                    accept_states: automaton.accept_states
                    automaton_type: automaton.automaton_type
                    is_deterministic: automaton.is_deterministic
            
            Otherwise:
                If String.equals(optimization_goal, "balance_states_transitions"):
                    Note: Apply state minimization first, then remove dead states
                    Let minimized be minimize_dfa_hopcroft(automaton)
                    
                    Note: Remove dead states (states that cannot reach accept state)
                    Let productive_states be List.copy(minimized.accept_states)
                    Let changed be true
                    While changed:
                        Let changed be false
                        For each state in minimized.states:
                            If not List.contains(productive_states, state):
                                Note: Check if this state can reach a productive state
                                If Dictionary.has_key(minimized.transitions, state):
                                    Let state_transitions be Dictionary.get(minimized.transitions, state)
                                    For each symbol in minimized.alphabet:
                                        If Dictionary.has_key(state_transitions, symbol):
                                            Let next_state be Dictionary.get(state_transitions, symbol)
                                            If List.contains(productive_states, next_state):
                                                List.push(productive_states, state)
                                                Let changed be true
                                                Break
                    
                    Note: Keep only productive and reachable states
                    Let final_states be List.create()
                    For each state in minimized.states:
                        If List.contains(productive_states, state):
                            List.push(final_states, state)
                    
                    Let optimized_automaton be FiniteAutomaton with:
                        states: final_states
                        alphabet: minimized.alphabet
                        transitions: minimized.transitions
                        start_state: minimized.start_state
                        accept_states: minimized.accept_states
                        automaton_type: minimized.automaton_type
                        is_deterministic: minimized.is_deterministic
                
                Otherwise:
                    If String.equals(optimization_goal, "determinize"):
                        Note: Convert NFA to DFA if not already deterministic
                        If not automaton.is_deterministic:
                            Let optimized_automaton be nfa_to_dfa_subset_construction(automaton)
                        Otherwise:
                            Let optimized_automaton be automaton
                    
                    Otherwise:
                        If String.equals(optimization_goal, "complete"):
                            Note: Add sink state and complete transition function
                            Let sink_state be "sink_state_added"
                            Let new_states be List.copy(automaton.states)
                            
                            Note: Check if automaton is already complete
                            Let needs_completion be false
                            For each state in automaton.states:
                                For each symbol in automaton.alphabet:
                                    Let has_transition be false
                                    If Dictionary.has_key(automaton.transitions, state):
                                        Let state_transitions be Dictionary.get(automaton.transitions, state)
                                        If Dictionary.has_key(state_transitions, symbol):
                                            Let has_transition be true
                                    
                                    If not has_transition:
                                        Let needs_completion be true
                                        Break
                                If needs_completion:
                                    Break
                            
                            If needs_completion:
                                List.push(new_states, sink_state)
                                
                                Let new_transitions be Dictionary.create()
                                Note: Copy existing transitions
                                For each state in automaton.states:
                                    If Dictionary.has_key(automaton.transitions, state):
                                        Dictionary.set(new_transitions, state, Dictionary.get(automaton.transitions, state))
                                
                                Note: Add missing transitions to sink state
                                For each state in automaton.states:
                                    If not Dictionary.has_key(new_transitions, state):
                                        Dictionary.set(new_transitions, state, Dictionary.create())
                                    
                                    Let state_transitions be Dictionary.get(new_transitions, state)
                                    For each symbol in automaton.alphabet:
                                        If not Dictionary.has_key(state_transitions, symbol):
                                            Dictionary.set(state_transitions, symbol, sink_state)
                                
                                Note: Add self-loops for sink state
                                Let sink_transitions be Dictionary.create()
                                For each symbol in automaton.alphabet:
                                    Dictionary.set(sink_transitions, symbol, sink_state)
                                Dictionary.set(new_transitions, sink_state, sink_transitions)
                                
                                Let optimized_automaton be FiniteAutomaton with:
                                    states: new_states
                                    alphabet: automaton.alphabet
                                    transitions: new_transitions
                                    start_state: automaton.start_state
                                    accept_states: automaton.accept_states
                                    automaton_type: "Complete-DFA"
                                    is_deterministic: true
                            Otherwise:
                                Let optimized_automaton be automaton
                        
                        Otherwise:
                            Note: Unknown optimization goal minus return original automaton
                            Let optimized_automaton be automaton
    
    Return optimized_automaton

Process called "benchmark_automaton_operations" that takes operations as List[String], test_automata as List[FiniteAutomaton] returns Dictionary[String, Dictionary[String, Float]]:
    Note: Benchmark performance of various automaton operations
    Note: Measures execution time, memory usage, result quality
    Note: Performance comparison across different algorithms and inputs
    
    Let benchmark_results be Dictionary.create()
    
    Note: For each operation, benchmark across all test automata
    For each operation in operations:
        Let operation_results be Dictionary.create()
        Dictionary.set(operation_results, "operation", operation)
        Dictionary.set(operation_results, "test_cases", Float.from_integer(List.size(test_automata)))
        
        Let total_time be 0.0
        Let total_memory be 0.0
        Let successful_operations be 0
        Let result_quality_scores be List.create()
        
        For each automaton in test_automata:
            Note: Simulate operation execution and measure performance
            Let start_time be TimeInstant.now_milliseconds()
            Let memory_before be Float.from_integer(List.size(automaton.states) plus List.size(automaton.alphabet))
            
            Note: Execute operation based on type
            If String.equals(operation, "minimization"):
                Note: Benchmark DFA minimization
                Let result_automaton be minimize_dfa_hopcroft(automaton)
                Let end_time be 1.0  Note: Simulated execution time
                Let memory_after be Float.from_integer(List.size(result_automaton.states) plus List.size(result_automaton.alphabet))
                
                Let execution_time be end_time minus start_time
                Let memory_usage be memory_after minus memory_before
                
                Note: Quality metric: state reduction ratio
                Let reduction_ratio be Float.divide(Float.from_integer(List.size(result_automaton.states)), Float.from_integer(List.size(automaton.states)))
                List.push(result_quality_scores, reduction_ratio)
                
                Let total_time be total_time plus execution_time
                Let total_memory be total_memory plus memory_usage
                Let successful_operations be successful_operations plus 1
            
            Otherwise:
                If String.equals(operation, "union"):
                    Note: Benchmark union operation (need two automata)
                    If List.size(test_automata) is greater than or equal to 2:
                        Let other_automaton be List.get(test_automata, 0)  Note: Use first as partner
                        Let operation_start be TimeInstant.now_milliseconds()
                        Let result_automaton be compute_automaton_union(automaton, other_automaton)
                        Let operation_end be TimeInstant.now_milliseconds()
                        Let execution_time be operation_end minus operation_start
                        
                        Note: Quality metric: size efficiency
                        Let expected_size be List.size(automaton.states) multiplied by List.size(other_automaton.states)
                        Let actual_size be List.size(result_automaton.states)
                        Let efficiency be Float.divide(Float.from_integer(actual_size), Float.from_integer(expected_size))
                        List.push(result_quality_scores, efficiency)
                        
                        Let total_time be total_time plus execution_time
                        Let successful_operations be successful_operations plus 1
                
                Otherwise:
                    If String.equals(operation, "intersection"):
                        If List.size(test_automata) is greater than or equal to 2:
                            Let other_automaton be List.get(test_automata, 0)
                            Let operation_start be TimeInstant.now_milliseconds()
                            Let result_automaton be compute_automaton_intersection(automaton, other_automaton)
                            Let operation_end be TimeInstant.now_milliseconds()
                            Let execution_time be operation_end minus operation_start
                            
                            Let expected_size be List.size(automaton.states) multiplied by List.size(other_automaton.states)
                            Let actual_size be List.size(result_automaton.states)
                            Let efficiency be Float.divide(Float.from_integer(actual_size), Float.from_integer(expected_size))
                            List.push(result_quality_scores, efficiency)
                            
                            Let total_time be total_time plus execution_time
                            Let successful_operations be successful_operations plus 1
                    
                    Otherwise:
                        If String.equals(operation, "complement"):
                            Let operation_start be TimeInstant.now_milliseconds()
                            Let result_automaton be compute_automaton_complement(automaton)
                            Let operation_end be TimeInstant.now_milliseconds()
                            Let execution_time be operation_end minus operation_start
                            
                            Note: Quality metric: completeness (should be same size if already complete)
                            Let size_change be Float.from_integer(List.size(result_automaton.states) minus List.size(automaton.states))
                            List.push(result_quality_scores, size_change)
                            
                            Let total_time be total_time plus execution_time
                            Let successful_operations be successful_operations plus 1
                        
                        Otherwise:
                            If String.equals(operation, "determinization"):
                                If not automaton.is_deterministic:
                                    Let operation_start be TimeInstant.now_milliseconds()
                                    Let result_automaton be nfa_to_dfa_subset_construction(automaton)
                                    Let operation_end be TimeInstant.now_milliseconds()
                                    Let execution_time be operation_end minus operation_start
                                    
                                    Note: Quality metric: blowup factor
                                    Let blowup_factor be Float.divide(Float.from_integer(List.size(result_automaton.states)), Float.from_integer(List.size(automaton.states)))
                                    List.push(result_quality_scores, blowup_factor)
                                    
                                    Let total_time be total_time plus execution_time
                                    Let successful_operations be successful_operations plus 1
                            
                            Otherwise:
                                If String.equals(operation, "emptiness_check"):
                                    Let operation_start be TimeInstant.now_milliseconds()
                                    Let is_empty be check_language_emptiness(automaton)
                                    Let operation_end be TimeInstant.now_milliseconds()
                                    Let execution_time be operation_end minus operation_start
                                    
                                    Note: Quality metric: correctness (binary: 1.0 if correct, 0.0 if wrong)
                                    Note: Assume correctness for simulation
                                    List.push(result_quality_scores, 1.0)
                                    
                                    Let total_time be total_time plus execution_time
                                    Let successful_operations be successful_operations plus 1
                                
                                Otherwise:
                                    Note: Unknown operation minus record as failed
                                    List.push(result_quality_scores, 0.0)
        
        Note: Calculate average metrics
        If successful_operations is greater than 0:
            Dictionary.set(operation_results, "average_time", Float.divide(total_time, Float.from_integer(successful_operations)))
            Dictionary.set(operation_results, "average_memory", Float.divide(total_memory, Float.from_integer(successful_operations)))
            Dictionary.set(operation_results, "success_rate", Float.divide(Float.from_integer(successful_operations), Float.from_integer(List.size(test_automata))))
            
            Note: Calculate average quality score
            Let total_quality be 0.0
            For each score in result_quality_scores:
                Let total_quality be total_quality plus score
            Dictionary.set(operation_results, "average_quality", Float.divide(total_quality, Float.from_integer(List.size(result_quality_scores))))
        
        Otherwise:
            Dictionary.set(operation_results, "average_time", 0.0)
            Dictionary.set(operation_results, "average_memory", 0.0)
            Dictionary.set(operation_results, "success_rate", 0.0)
            Dictionary.set(operation_results, "average_quality", 0.0)
        
        Note: Add performance characteristics
        Dictionary.set(operation_results, "complexity_class", "varies_by_operation")
        If String.equals(operation, "minimization"):
            Dictionary.set(operation_results, "theoretical_complexity", "O(n log n)")
        Otherwise:
            If String.equals(operation, "union") or String.equals(operation, "intersection"):
                Dictionary.set(operation_results, "theoretical_complexity", "O(n₁ × n₂)")
            Otherwise:
                If String.equals(operation, "complement"):
                    Dictionary.set(operation_results, "theoretical_complexity", "O(1)")
                Otherwise:
                    If String.equals(operation, "determinization"):
                        Dictionary.set(operation_results, "theoretical_complexity", "O(2ⁿ) worst case")
                    Otherwise:
                        Dictionary.set(operation_results, "theoretical_complexity", "O(n)")
        
        Dictionary.set(benchmark_results, operation, operation_results)
    
    Note: Add overall benchmark summary
    Let summary be Dictionary.create()
    Dictionary.set(summary, "total_operations", Float.from_integer(List.size(operations)))
    Dictionary.set(summary, "total_test_automata", Float.from_integer(List.size(test_automata)))
    Dictionary.set(summary, "benchmark_type", "simulated_performance_analysis")
    Note: Record actual timing measurements from benchmark execution
    Let total_time_ms be 0.0
    For each result in benchmark_results.get("individual_results"):
        Set total_time_ms to total_time_ms plus result.get("execution_time_ms")
    Dictionary.set(summary, "total_execution_time_ms", total_time_ms)
    Dictionary.set(summary, "average_time_per_operation_ms", total_time_ms / Float.from_integer(List.size(test_automata)))
    Dictionary.set(benchmark_results, "summary", summary)
    
    Return benchmark_results

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_automaton_structure" that takes automaton as FiniteAutomaton, validation_rules as Dictionary[String, String] returns Dictionary[String, Boolean]:
    Note: Validate automaton structure and consistency
    Note: Check: state/symbol consistency, transition validity, determinism
    Note: Ensures automaton is well-formed for algorithm correctness
    
    Let validation_results be Dictionary.create()
    Dictionary.set(validation_results, "overall_valid", true)
    
    Note: Check basic structure requirements
    Dictionary.set(validation_results, "has_states", not List.is_empty(automaton.states))
    Dictionary.set(validation_results, "has_alphabet", not List.is_empty(automaton.alphabet))
    Dictionary.set(validation_results, "has_start_state", not String.equals(automaton.start_state, ""))
    
    If List.is_empty(automaton.states) or List.is_empty(automaton.alphabet) or String.equals(automaton.start_state, ""):
        Dictionary.set(validation_results, "overall_valid", false)
    
    Note: Validate start state exists in states list
    Let start_state_valid be List.contains(automaton.states, automaton.start_state)
    Dictionary.set(validation_results, "start_state_in_states", start_state_valid)
    If not start_state_valid:
        Dictionary.set(validation_results, "overall_valid", false)
    
    Note: Validate accept states are subset of states
    Let accept_states_valid be true
    For each accept_state in automaton.accept_states:
        If not List.contains(automaton.states, accept_state):
            Let accept_states_valid be false
            Break
    Dictionary.set(validation_results, "accept_states_valid", accept_states_valid)
    If not accept_states_valid:
        Dictionary.set(validation_results, "overall_valid", false)
    
    Note: Validate transition function structure
    Let transitions_valid be true
    Let invalid_transitions be 0
    For each state in Dictionary.keys(automaton.transitions):
        Note: Check if state exists
        If not List.contains(automaton.states, state):
            Let transitions_valid be false
            Let invalid_transitions be invalid_transitions plus 1
        Otherwise:
            Let state_transitions be Dictionary.get(automaton.transitions, state)
            For each symbol in Dictionary.keys(state_transitions):
                Note: Check if symbol is in alphabet
                If not List.contains(automaton.alphabet, symbol):
                    Let transitions_valid be false
                    Let invalid_transitions be invalid_transitions plus 1
                Otherwise:
                    Let target_state be Dictionary.get(state_transitions, symbol)
                    Note: Check if target state exists
                    If not List.contains(automaton.states, target_state):
                        Let transitions_valid be false
                        Let invalid_transitions be invalid_transitions plus 1
    
    Dictionary.set(validation_results, "transitions_valid", transitions_valid)
    Dictionary.set(validation_results, "invalid_transition_count", String.from_integer(invalid_transitions))
    If not transitions_valid:
        Dictionary.set(validation_results, "overall_valid", false)
    
    Note: Check determinism if claimed to be deterministic
    If automaton.is_deterministic:
        Let actually_deterministic be true
        For each state in automaton.states:
            If Dictionary.has_key(automaton.transitions, state):
                Let state_transitions be Dictionary.get(automaton.transitions, state)
                For each symbol in automaton.alphabet:
                    Let transition_count be 0
                    If Dictionary.has_key(state_transitions, symbol):
                        Let transition_count be 1
                    
                    Note: Deterministic means at most one transition per symbol
                    If transition_count is greater than 1:
                        Let actually_deterministic be false
                        Break
            If not actually_deterministic:
                Break
        
        Dictionary.set(validation_results, "determinism_claim_correct", actually_deterministic)
        If not actually_deterministic:
            Dictionary.set(validation_results, "overall_valid", false)
    Otherwise:
        Dictionary.set(validation_results, "determinism_claim_correct", true)  Note: No claim made
    
    Note: Check completeness (optional validation based on rules)
    If Dictionary.has_key(validation_rules, "require_complete") and String.equals(Dictionary.get(validation_rules, "require_complete"), "true"):
        Let is_complete be true
        For each state in automaton.states:
            For each symbol in automaton.alphabet:
                Let has_transition be false
                If Dictionary.has_key(automaton.transitions, state):
                    Let state_transitions be Dictionary.get(automaton.transitions, state)
                    If Dictionary.has_key(state_transitions, symbol):
                        Let has_transition be true
                
                If not has_transition:
                    Let is_complete be false
                    Break
            If not is_complete:
                Break
        
        Dictionary.set(validation_results, "completeness_required", true)
        Dictionary.set(validation_results, "is_complete", is_complete)
        If not is_complete:
            Dictionary.set(validation_results, "overall_valid", false)
    Otherwise:
        Dictionary.set(validation_results, "completeness_required", false)
        Dictionary.set(validation_results, "is_complete", false)  Note: Not checked
    
    Note: Check for unreachable states
    Let reachable_states be List.create()
    List.push(reachable_states, automaton.start_state)
    
    Let changed be true
    While changed:
        Let changed be false
        For each state in reachable_states:
            If Dictionary.has_key(automaton.transitions, state):
                Let state_transitions be Dictionary.get(automaton.transitions, state)
                For each symbol in automaton.alphabet:
                    If Dictionary.has_key(state_transitions, symbol):
                        Let next_state be Dictionary.get(state_transitions, symbol)
                        If not List.contains(reachable_states, next_state):
                            List.push(reachable_states, next_state)
                            Let changed be true
    
    Let unreachable_count be List.size(automaton.states) minus List.size(reachable_states)
    Dictionary.set(validation_results, "unreachable_states_count", String.from_integer(unreachable_count))
    Dictionary.set(validation_results, "has_unreachable_states", unreachable_count is greater than 0)
    
    Note: Check for dead states (if validation rules require)
    If Dictionary.has_key(validation_rules, "check_dead_states") and String.equals(Dictionary.get(validation_rules, "check_dead_states"), "true"):
        Let productive_states be List.copy(automaton.accept_states)
        Let changed be true
        While changed:
            Let changed be false
            For each state in automaton.states:
                If not List.contains(productive_states, state):
                    Note: Check if this state can reach a productive state
                    If Dictionary.has_key(automaton.transitions, state):
                        Let state_transitions be Dictionary.get(automaton.transitions, state)
                        For each symbol in automaton.alphabet:
                            If Dictionary.has_key(state_transitions, symbol):
                                Let next_state be Dictionary.get(state_transitions, symbol)
                                If List.contains(productive_states, next_state):
                                    List.push(productive_states, state)
                                    Let changed be true
                                    Break
        
        Let dead_states_count be List.size(automaton.states) minus List.size(productive_states)
        Dictionary.set(validation_results, "dead_states_count", String.from_integer(dead_states_count))
        Dictionary.set(validation_results, "has_dead_states", dead_states_count is greater than 0)
    
    Note: Structural complexity warnings
    Dictionary.set(validation_results, "state_count_reasonable", List.size(automaton.states) is less than or equal to 1000)
    Dictionary.set(validation_results, "alphabet_size_reasonable", List.size(automaton.alphabet) is less than or equal to 100)
    
    Note: Add recommendations
    Let recommendations be List.create()
    If unreachable_count is greater than 0:
        List.push(recommendations, "Remove unreachable states to simplify automaton")
    If Dictionary.has_key(validation_results, "has_dead_states") and Dictionary.get(validation_results, "has_dead_states"):
        List.push(recommendations, "Remove dead states if they are not needed")
    If not Dictionary.get(validation_results, "state_count_reasonable"):
        List.push(recommendations, "Consider state minimization minus large state count")
    If not Dictionary.get(validation_results, "alphabet_size_reasonable"):
        List.push(recommendations, "Consider alphabet reduction if possible")
    
    Dictionary.set(validation_results, "recommendations", Collections.join_strings(recommendations, "; "))
    
    Return validation_results

Process called "visualize_automaton_structure" that takes automaton as FiniteAutomaton, layout_options as Dictionary[String, String] returns Dictionary[String, String]:
    Note: Generate visual representation of automaton structure
    Note: Creates state diagrams with transitions and labels
    Note: Supports various output formats and layout algorithms
    
    Let visualization_result be Dictionary.create()
    Dictionary.set(visualization_result, "automaton_type", automaton.automaton_type)
    Dictionary.set(visualization_result, "state_count", String.from_integer(List.size(automaton.states)))
    Dictionary.set(visualization_result, "alphabet_size", String.from_integer(List.size(automaton.alphabet)))
    
    Note: Determine output format
    Let output_format be "DOT"  Note: Default format
    If Dictionary.has_key(layout_options, "format"):
        Let output_format be Dictionary.get(layout_options, "format")
    
    If String.equals(output_format, "DOT"):
        Note: Generate Graphviz DOT format
        Let dot_content be List.create()
        List.push(dot_content, "digraph finite_automaton {")
        List.push(dot_content, "  rankdir=LR;")
        List.push(dot_content, "  size=\"8,5\"")
        List.push(dot_content, "  node [shape is equal to doublecircle];")
        
        Note: Define accept states with double circles
        Let accept_states_line be "  "
        For each accept_state in automaton.accept_states:
            Let accept_states_line be String.concatenate(accept_states_line, String.concatenate(accept_state, " "))
        Let accept_states_line be String.concatenate(accept_states_line, ";")
        List.push(dot_content, accept_states_line)
        
        List.push(dot_content, "  node [shape is equal to circle];")
        
        Note: Add invisible start node pointing to initial state
        List.push(dot_content, "  secret_node [style=invis];")
        List.push(dot_content, "  secret_node -> " plus automaton.start_state plus " [label=\"start\"];")
        
        Note: Add all transitions
        For each state in automaton.states:
            If Dictionary.has_key(automaton.transitions, state):
                Let state_transitions be Dictionary.get(automaton.transitions, state)
                For each symbol in Dictionary.keys(state_transitions):
                    Let target_state be Dictionary.get(state_transitions, symbol)
                    Let transition_line be String.concatenate("  ", String.concatenate(state, String.concatenate(" -> ", String.concatenate(target_state, String.concatenate(" [label=\"", String.concatenate(symbol, "\"];"))))))
                    List.push(dot_content, transition_line)
        
        List.push(dot_content, "}")
        Dictionary.set(visualization_result, "dot_format", Collections.join_strings(dot_content, "\n"))
    
    Otherwise:
        If String.equals(output_format, "ASCII"):
            Note: Generate ASCII art representation
            Let ascii_content be List.create()
            List.push(ascii_content, "Finite Automaton Structure:")
            List.push(ascii_content, "========================")
            List.push(ascii_content, "")
            
            List.push(ascii_content, "States: " plus Collections.join_strings(automaton.states, ", "))
            List.push(ascii_content, "Alphabet: " plus Collections.join_strings(automaton.alphabet, ", "))
            List.push(ascii_content, "Start State: " plus automaton.start_state)
            List.push(ascii_content, "Accept States: " plus Collections.join_strings(automaton.accept_states, ", "))
            List.push(ascii_content, "")
            List.push(ascii_content, "Transitions:")
            
            For each state in automaton.states:
                If Dictionary.has_key(automaton.transitions, state):
                    Let state_transitions be Dictionary.get(automaton.transitions, state)
                    For each symbol in Dictionary.keys(state_transitions):
                        Let target_state be Dictionary.get(state_transitions, symbol)
                        Let transition_line be String.concatenate("  ", String.concatenate(state, String.concatenate(" --", String.concatenate(symbol, String.concatenate("--> ", target_state)))))
                        List.push(ascii_content, transition_line)
            
            Dictionary.set(visualization_result, "ascii_format", Collections.join_strings(ascii_content, "\n"))
        
        Otherwise:
            If String.equals(output_format, "JSON"):
                Note: Generate JSON representation
                Let json_content be List.create()
                List.push(json_content, "{")
                List.push(json_content, "  \"type\": \"" plus automaton.automaton_type plus "\",")
                List.push(json_content, "  \"states\": [" plus Collections.join_strings(automaton.states, "\", \"") plus "],")
                List.push(json_content, "  \"alphabet\": [" plus Collections.join_strings(automaton.alphabet, "\", \"") plus "],")
                List.push(json_content, "  \"start_state\": \"" plus automaton.start_state plus "\",")
                List.push(json_content, "  \"accept_states\": [" plus Collections.join_strings(automaton.accept_states, "\", \"") plus "],")
                List.push(json_content, "  \"transitions\": {")
                
                Let transition_entries be List.create()
                For each state in automaton.states:
                    If Dictionary.has_key(automaton.transitions, state):
                        Let state_transitions be Dictionary.get(automaton.transitions, state)
                        Let state_entry be String.concatenate("    \"", String.concatenate(state, "\": {"))
                        
                        Let symbol_entries be List.create()
                        For each symbol in Dictionary.keys(state_transitions):
                            Let target_state be Dictionary.get(state_transitions, symbol)
                            Let symbol_entry be String.concatenate("\"", String.concatenate(symbol, String.concatenate("\": \"", String.concatenate(target_state, "\""))))
                            List.push(symbol_entries, symbol_entry)
                        
                        Let state_entry be String.concatenate(state_entry, String.concatenate(Collections.join_strings(symbol_entries, ", "), "}"))
                        List.push(transition_entries, state_entry)
                
                List.push(json_content, Collections.join_strings(transition_entries, ",\n"))
                List.push(json_content, "  }")
                List.push(json_content, "}")
                
                Dictionary.set(visualization_result, "json_format", Collections.join_strings(json_content, "\n"))
            
            Otherwise:
                If String.equals(output_format, "LaTeX"):
                    Note: Generate LaTeX/TikZ representation
                    Let latex_content be List.create()
                    List.push(latex_content, "\\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=3cm]")
                    List.push(latex_content, "  \\tikzstyle{every state}=[fill=lightgray,draw=black,text=black]")
                    
                    Note: Position states in a simple layout
                    For i from 0 to (List.size(automaton.states) minus 1):
                        Let state be List.get(automaton.states, i)
                        Let x_pos be i multiplied by 3
                        Let y_pos be 0
                        
                        Let state_style be "state"
                        If List.contains(automaton.accept_states, state):
                            Let state_style be "accepting"
                        
                        Let state_line be String.concatenate("  \\node[", String.concatenate(state_style, String.concatenate("] (", String.concatenate(state, String.concatenate(") at (", String.concatenate(String.from_integer(x_pos), String.concatenate(",", String.concatenate(String.from_integer(y_pos), String.concatenate(") {$", String.concatenate(state, "$};"))))))))))
                        List.push(latex_content, state_line)
                    
                    Note: Add transitions
                    For each state in automaton.states:
                        If Dictionary.has_key(automaton.transitions, state):
                            Let state_transitions be Dictionary.get(automaton.transitions, state)
                            For each symbol in Dictionary.keys(state_transitions):
                                Let target_state be Dictionary.get(state_transitions, symbol)
                                Let transition_line be String.concatenate("  \\path[->] (", String.concatenate(state, String.concatenate(") edge node {$", String.concatenate(symbol, String.concatenate("$} (", String.concatenate(target_state, ");"))))))
                                List.push(latex_content, transition_line)
                    
                    List.push(latex_content, "\\end{tikzpicture}")
                    Dictionary.set(visualization_result, "latex_format", Collections.join_strings(latex_content, "\n"))
    
    Note: Add layout information
    Dictionary.set(visualization_result, "output_format", output_format)
    Dictionary.set(visualization_result, "layout_algorithm", "simple")
    If Dictionary.has_key(layout_options, "layout"):
        Dictionary.set(visualization_result, "layout_algorithm", Dictionary.get(layout_options, "layout"))
    
    Note: Add visual statistics
    Let visual_stats be Dictionary.create()
    Dictionary.set(visual_stats, "nodes", String.from_integer(List.size(automaton.states)))
    
    Let edge_count be 0
    For each state in automaton.states:
        If Dictionary.has_key(automaton.transitions, state):
            Let state_transitions be Dictionary.get(automaton.transitions, state)
            Let edge_count be edge_count plus Dictionary.size(state_transitions)
    Dictionary.set(visual_stats, "edges", String.from_integer(edge_count))
    
    Dictionary.set(visual_stats, "complexity", "simple")
    If List.size(automaton.states) is greater than 20:
        Dictionary.set(visual_stats, "complexity", "high")
    Otherwise:
        If List.size(automaton.states) is greater than 5:
            Dictionary.set(visual_stats, "complexity", "medium")
    
    Dictionary.set(visualization_result, "visual_statistics", visual_stats)
    
    Note: Add rendering suggestions
    Let suggestions be List.create()
    If List.size(automaton.states) is greater than 10:
        List.push(suggestions, "Consider using hierarchical layout for large automata")
    If edge_count is greater than 50:
        List.push(suggestions, "Use edge bundling or simplified labels for many transitions")
    If List.size(automaton.alphabet) is greater than 10:
        List.push(suggestions, "Group similar transitions to reduce visual clutter")
    
    Dictionary.set(visualization_result, "rendering_suggestions", Collections.join_strings(suggestions, "; "))
    
    Return visualization_result

Process called "convert_automaton_formats" that takes automaton as FiniteAutomaton, target_format as String returns String:
    Note: Convert automaton to various standard formats
    Note: Formats: DOT, XML, JSON, textual descriptions
    Note: Enables interoperability with other tools
    
    Let format be String.to_lower(target_format)
    
    Note: DOT format (Graphviz)
    If String.equals(format, "dot") OR String.equals(format, "graphviz"):
        Let dot_content be List.create()
        List.push(dot_content, "digraph finite_automaton {")
        List.push(dot_content, "    rankdir=LR;")
        List.push(dot_content, "    size=\"8,5\";")
        
        Note: Node declarations
        Let state_index be 0
        While state_index is less than List.size(automaton.states):
            Let state be List.get(automaton.states, state_index)
            Let node_attrs be List.create()
            
            If List.contains(automaton.accept_states, state):
                List.push(node_attrs, "doublecircle")
            Otherwise:
                List.push(node_attrs, "circle")
            
            If String.equals(state, automaton.start_state):
                List.push(node_attrs, "color=blue")
            
            Let attrs_str be Collections.join_strings(node_attrs, ",")
            Let node_decl be String.concatenate("    ", String.concatenate(state, String.concatenate(" [shape=", String.concatenate(attrs_str, "];")))))
            List.push(dot_content, node_decl)
            Set state_index to Mathematics.add(state_index, 1)
        
        Note: Transition edges
        Let from_state_index be 0
        While from_state_index is less than List.size(automaton.states):
            Let from_state be List.get(automaton.states, from_state_index)
            Let symbol_index be 0
            While symbol_index is less than List.size(automaton.alphabet):
                Let symbol be List.get(automaton.alphabet, symbol_index)
                Let transition_key be String.concatenate(from_state, String.concatenate(":", symbol))
                
                If Dictionary.has_key(automaton.transitions, transition_key):
                    Let to_state be Dictionary.get(automaton.transitions, transition_key)
                    Let edge_label be symbol
                    If String.equals(symbol, ""):
                        Set edge_label to "ε"
                    
                    Let edge_decl be String.concatenate("    ", String.concatenate(from_state, String.concatenate(" -> ", String.concatenate(to_state, String.concatenate(" [label=\"", String.concatenate(edge_label, "\"];"))))))
                    List.push(dot_content, edge_decl)
                
                Set symbol_index to Mathematics.add(symbol_index, 1)
            Set from_state_index to Mathematics.add(from_state_index, 1)
        
        List.push(dot_content, "}")
        Return Collections.join_strings(dot_content, "\n")
    
    Note: XML format
    If String.equals(format, "xml"):
        Let xml_content be List.create()
        List.push(xml_content, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>")
        List.push(xml_content, "<finiteAutomaton>")
        
        Note: States
        List.push(xml_content, "  <states>")
        Let state_index be 0
        While state_index is less than List.size(automaton.states):
            Let state be List.get(automaton.states, state_index)
            Let is_start be Boolean.to_string(String.equals(state, automaton.start_state))
            Let is_accept be Boolean.to_string(List.contains(automaton.accept_states, state))
            
            Let state_xml be String.concatenate("    <state id=\"", String.concatenate(state, String.concatenate("\" start=\"", String.concatenate(is_start, String.concatenate("\" accept=\"", String.concatenate(is_accept, "\"/>"))))))
            List.push(xml_content, state_xml)
            Set state_index to Mathematics.add(state_index, 1)
        List.push(xml_content, "  </states>")
        
        Note: Alphabet
        List.push(xml_content, "  <alphabet>")
        Let symbol_index be 0
        While symbol_index is less than List.size(automaton.alphabet):
            Let symbol be List.get(automaton.alphabet, symbol_index)
            Let symbol_xml be String.concatenate("    <symbol>", String.concatenate(symbol, "</symbol>"))
            List.push(xml_content, symbol_xml)
            Set symbol_index to Mathematics.add(symbol_index, 1)
        List.push(xml_content, "  </alphabet>")
        
        Note: Transitions
        List.push(xml_content, "  <transitions>")
        Let from_state_index be 0
        While from_state_index is less than List.size(automaton.states):
            Let from_state be List.get(automaton.states, from_state_index)
            Let symbol_index be 0
            While symbol_index is less than List.size(automaton.alphabet):
                Let symbol be List.get(automaton.alphabet, symbol_index)
                Let transition_key be String.concatenate(from_state, String.concatenate(":", symbol))
                
                If Dictionary.has_key(automaton.transitions, transition_key):
                    Let to_state be Dictionary.get(automaton.transitions, transition_key)
                    Let transition_xml be String.concatenate("    <transition from=\"", String.concatenate(from_state, String.concatenate("\" to=\"", String.concatenate(to_state, String.concatenate("\" symbol=\"", String.concatenate(symbol, "\"/>"))))))
                    List.push(xml_content, transition_xml)
                
                Set symbol_index to Mathematics.add(symbol_index, 1)
            Set from_state_index to Mathematics.add(from_state_index, 1)
        List.push(xml_content, "  </transitions>")
        
        List.push(xml_content, "</finiteAutomaton>")
        Return Collections.join_strings(xml_content, "\n")
    
    Note: JSON format
    If String.equals(format, "json"):
        Let json_parts be List.create()
        List.push(json_parts, "{")
        List.push(json_parts, "  \"type\": \"finite_automaton\",")
        
        Note: States array
        List.push(json_parts, "  \"states\": [")
        Let state_index be 0
        While state_index is less than List.size(automaton.states):
            Let state be List.get(automaton.states, state_index)
            Let comma be ""
            If Mathematics.less_than(state_index, Mathematics.subtract(List.size(automaton.states), 1)):
                Set comma to ","
            
            Let state_json be String.concatenate("    \"", String.concatenate(state, String.concatenate("\"", comma)))
            List.push(json_parts, state_json)
            Set state_index to Mathematics.add(state_index, 1)
        List.push(json_parts, "  ],")
        
        Note: Alphabet array
        List.push(json_parts, "  \"alphabet\": [")
        Let symbol_index be 0
        While symbol_index is less than List.size(automaton.alphabet):
            Let symbol be List.get(automaton.alphabet, symbol_index)
            Let comma be ""
            If Mathematics.less_than(symbol_index, Mathematics.subtract(List.size(automaton.alphabet), 1)):
                Set comma to ","
            
            Let symbol_json be String.concatenate("    \"", String.concatenate(symbol, String.concatenate("\"", comma)))
            List.push(json_parts, symbol_json)
            Set symbol_index to Mathematics.add(symbol_index, 1)
        List.push(json_parts, "  ],")
        
        Note: Start state
        Let start_json be String.concatenate("  \"start_state\": \"", String.concatenate(automaton.start_state, "\","))
        List.push(json_parts, start_json)
        
        Note: Accept states
        List.push(json_parts, "  \"accept_states\": [")
        Let accept_index be 0
        While accept_index is less than List.size(automaton.accept_states):
            Let accept_state be List.get(automaton.accept_states, accept_index)
            Let comma be ""
            If Mathematics.less_than(accept_index, Mathematics.subtract(List.size(automaton.accept_states), 1)):
                Set comma to ","
            
            Let accept_json be String.concatenate("    \"", String.concatenate(accept_state, String.concatenate("\"", comma)))
            List.push(json_parts, accept_json)
            Set accept_index to Mathematics.add(accept_index, 1)
        List.push(json_parts, "  ],")
        
        Note: Transitions object
        List.push(json_parts, "  \"transitions\": {")
        Let transition_keys be Dictionary.get_keys(automaton.transitions)
        Let key_index be 0
        While key_index is less than List.size(transition_keys):
            Let key be List.get(transition_keys, key_index)
            Let value be Dictionary.get(automaton.transitions, key)
            Let comma be ""
            If Mathematics.less_than(key_index, Mathematics.subtract(List.size(transition_keys), 1)):
                Set comma to ","
            
            Let transition_json be String.concatenate("    \"", String.concatenate(key, String.concatenate("\": \"", String.concatenate(value, String.concatenate("\"", comma)))))
            List.push(json_parts, transition_json)
            Set key_index to Mathematics.add(key_index, 1)
        List.push(json_parts, "  }")
        
        List.push(json_parts, "}")
        Return Collections.join_strings(json_parts, "\n")
    
    Note: Textual format
    If String.equals(format, "text") OR String.equals(format, "textual"):
        Let text_content be List.create()
        List.push(text_content, "FINITE AUTOMATON SPECIFICATION")
        List.push(text_content, "==============================")
        List.push(text_content, "")
        
        Note: Basic information
        Let states_str be Collections.join_strings(automaton.states, ", ")
        List.push(text_content, String.concatenate("States: {", String.concatenate(states_str, "}")))
        
        Let alphabet_str be Collections.join_strings(automaton.alphabet, ", ")
        List.push(text_content, String.concatenate("Alphabet: {", String.concatenate(alphabet_str, "}")))
        
        List.push(text_content, String.concatenate("Start State: ", automaton.start_state))
        
        Let accept_str be Collections.join_strings(automaton.accept_states, ", ")
        List.push(text_content, String.concatenate("Accept States: {", String.concatenate(accept_str, "}")))
        
        List.push(text_content, "")
        List.push(text_content, "TRANSITION FUNCTION:")
        List.push(text_content, "-------------------")
        
        Note: Transition table
        Let from_state_index be 0
        While from_state_index is less than List.size(automaton.states):
            Let from_state be List.get(automaton.states, from_state_index)
            Let symbol_index be 0
            While symbol_index is less than List.size(automaton.alphabet):
                Let symbol be List.get(automaton.alphabet, symbol_index)
                Let transition_key be String.concatenate(from_state, String.concatenate(":", symbol))
                
                If Dictionary.has_key(automaton.transitions, transition_key):
                    Let to_state be Dictionary.get(automaton.transitions, transition_key)
                    Let transition_desc be String.concatenate("δ(", String.concatenate(from_state, String.concatenate(", ", String.concatenate(symbol, String.concatenate(") is equal to ", to_state)))))
                    List.push(text_content, transition_desc)
                
                Set symbol_index to Mathematics.add(symbol_index, 1)
            Set from_state_index to Mathematics.add(from_state_index, 1)
        
        Return Collections.join_strings(text_content, "\n")
    
    Note: JFLAP format (educational tool)
    If String.equals(format, "jflap"):
        Let jflap_content be List.create()
        List.push(jflap_content, "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>")
        List.push(jflap_content, "<!--Created with JFLAP 6.4.-->")
        List.push(jflap_content, "<structure>")
        List.push(jflap_content, "  <type>fa</type>")
        List.push(jflap_content, "  <automaton>")
        
        Note: States with coordinates
        Let state_index be 0
        While state_index is less than List.size(automaton.states):
            Let state be List.get(automaton.states, state_index)
            Let x be Mathematics.multiply(state_index, 100)
            Let y be 200
            
            List.push(jflap_content, "    <state>")
            List.push(jflap_content, String.concatenate("      <x>", String.concatenate(Integer.to_string(x), "</x>")))
            List.push(jflap_content, String.concatenate("      <y>", String.concatenate(Integer.to_string(y), "</y>")))
            List.push(jflap_content, String.concatenate("      <label>", String.concatenate(state, "</label>")))
            
            If String.equals(state, automaton.start_state):
                List.push(jflap_content, "      <initial/>")
            
            If List.contains(automaton.accept_states, state):
                List.push(jflap_content, "      <final/>")
            
            List.push(jflap_content, "    </state>")
            Set state_index to Mathematics.add(state_index, 1)
        
        Note: Transitions
        Let from_state_index be 0
        While from_state_index is less than List.size(automaton.states):
            Let from_state be List.get(automaton.states, from_state_index)
            Let symbol_index be 0
            While symbol_index is less than List.size(automaton.alphabet):
                Let symbol be List.get(automaton.alphabet, symbol_index)
                Let transition_key be String.concatenate(from_state, String.concatenate(":", symbol))
                
                If Dictionary.has_key(automaton.transitions, transition_key):
                    Let to_state be Dictionary.get(automaton.transitions, transition_key)
                    Let from_index be List.index_of(automaton.states, from_state)
                    Let to_index be List.index_of(automaton.states, to_state)
                    
                    List.push(jflap_content, "    <transition>")
                    List.push(jflap_content, String.concatenate("      <from>", String.concatenate(Integer.to_string(from_index), "</from>")))
                    List.push(jflap_content, String.concatenate("      <to>", String.concatenate(Integer.to_string(to_index), "</to>")))
                    List.push(jflap_content, String.concatenate("      <read>", String.concatenate(symbol, "</read>")))
                    List.push(jflap_content, "    </transition>")
                
                Set symbol_index to Mathematics.add(symbol_index, 1)
            Set from_state_index to Mathematics.add(from_state_index, 1)
        
        List.push(jflap_content, "  </automaton>")
        List.push(jflap_content, "</structure>")
        Return Collections.join_strings(jflap_content, "\n")
    
    Note: Unsupported format
    Let supported_formats be List.create()
    List.push(supported_formats, "DOT/Graphviz")
    List.push(supported_formats, "XML")
    List.push(supported_formats, "JSON")
    List.push(supported_formats, "Text")
    List.push(supported_formats, "JFLAP")
    
    Let error_message be String.concatenate("Unsupported format: ", String.concatenate(target_format, String.concatenate(". Supported formats: ", Collections.join_strings(supported_formats, ", "))))
    Throw Errors.InvalidArgument with error_message

Process called "troubleshoot_automaton_issues" that takes issue_description as Dictionary[String, String] returns List[String]:
    Note: Provide troubleshooting guidance for automaton problems
    Note: Common issues: non-determinism, incomplete specifications, complexity
    Note: Diagnostic procedures and optimization recommendations
    
    Let suggestions be List.create()
    Let issue_type be Dictionary.get_or_default(issue_description, "type", "general")
    Let context be Dictionary.get_or_default(issue_description, "context", "")
    Let symptoms be Dictionary.get_or_default(issue_description, "symptoms", "")
    
    Note: Non-determinism issues
    If String.contains(issue_type, "nondeterminism") OR String.contains(symptoms, "multiple"):
        List.push(suggestions, "NONDETERMINISM DETECTED:")
        List.push(suggestions, "1. Check for epsilon transitions that create ambiguity")
        List.push(suggestions, "2. Verify that each (state, symbol) pair maps to exactly one state")
        List.push(suggestions, "3. Use subset construction algorithm to convert NFA to DFA")
        List.push(suggestions, "4. Consider whether nondeterminism is intentional for your use case")
        List.push(suggestions, "5. Test with strings that might follow multiple paths")
        List.push(suggestions, "")
    
    Note: Incomplete specification issues
    If String.contains(issue_type, "incomplete") OR String.contains(symptoms, "missing"):
        List.push(suggestions, "INCOMPLETE SPECIFICATION:")
        List.push(suggestions, "1. Ensure all states are defined in the states list")
        List.push(suggestions, "2. Check that start_state exists in the states list")
        List.push(suggestions, "3. Verify all accept_states are valid state names")
        List.push(suggestions, "4. Complete the transition function for all (state, symbol) pairs")
        List.push(suggestions, "5. Add error/sink states for undefined transitions if needed")
        List.push(suggestions, "6. Validate that alphabet symbols are consistently used")
        List.push(suggestions, "")
    
    Note: Performance and complexity issues
    If String.contains(issue_type, "performance") OR String.contains(issue_type, "complexity"):
        List.push(suggestions, "PERFORMANCE OPTIMIZATION:")
        List.push(suggestions, "1. Minimize the automaton using Hopcroft's algorithm")
        List.push(suggestions, "2. Remove unreachable states from start state")
        List.push(suggestions, "3. Eliminate dead states that cannot reach accept states")
        List.push(suggestions, "4. Consider using DFA instead of NFA for faster recognition")
        List.push(suggestions, "5. Optimize transition table representation for sparse automata")
        List.push(suggestions, "6. Use state numbering instead of string names for efficiency")
        List.push(suggestions, "")
    
    Note: Language recognition issues
    If String.contains(issue_type, "recognition") OR String.contains(symptoms, "reject"):
        List.push(suggestions, "LANGUAGE RECOGNITION PROBLEMS:")
        List.push(suggestions, "1. Trace execution path for failing test strings")
        List.push(suggestions, "2. Verify that accept conditions are correctly specified")
        List.push(suggestions, "3. Check for missing transitions causing premature termination")
        List.push(suggestions, "4. Ensure epsilon closures are properly computed (for NFAs)")
        List.push(suggestions, "5. Test with edge cases: empty string, single characters, long strings")
        List.push(suggestions, "6. Validate that the language specification matches the implementation")
        List.push(suggestions, "")
    
    Note: Construction and conversion issues  
    If String.contains(issue_type, "construction") OR String.contains(issue_type, "conversion"):
        List.push(suggestions, "AUTOMATON CONSTRUCTION:")
        List.push(suggestions, "1. Verify the construction algorithm follows standard procedures")
        List.push(suggestions, "2. For regex conversion: check precedence and associativity rules")
        List.push(suggestions, "3. For grammar conversion: ensure proper handling of productions")
        List.push(suggestions, "4. Test intermediate steps of construction process")
        List.push(suggestions, "5. Compare result with hand-constructed reference automaton")
        List.push(suggestions, "6. Validate that all required states and transitions are created")
        List.push(suggestions, "")
    
    Note: Memory and resource issues
    If String.contains(issue_type, "memory") OR String.contains(symptoms, "large"):
        List.push(suggestions, "RESOURCE MANAGEMENT:")
        List.push(suggestions, "1. Use state compression techniques for large automata")
        List.push(suggestions, "2. Implement lazy evaluation for transition computation")
        List.push(suggestions, "3. Consider streaming processing for long input strings")
        List.push(suggestions, "4. Use bit vectors for state set representation in subset construction")
        List.push(suggestions, "5. Implement garbage collection for unused intermediate states")
        List.push(suggestions, "6. Profile memory usage during automaton operations")
        List.push(suggestions, "")
    
    Note: Debugging and testing issues
    If String.contains(issue_type, "debug") OR String.contains(issue_type, "test"):
        List.push(suggestions, "DEBUGGING STRATEGIES:")
        List.push(suggestions, "1. Implement step-by-step execution tracing")
        List.push(suggestions, "2. Visualize automaton structure using DOT format")
        List.push(suggestions, "3. Create comprehensive test suite with positive and negative examples")
        List.push(suggestions, "4. Use formal verification techniques when possible")
        List.push(suggestions, "5. Compare behavior against reference implementations")
        List.push(suggestions, "6. Test boundary conditions and corner cases systematically")
        List.push(suggestions, "")
    
    Note: Theoretical issues
    If String.contains(issue_type, "theory") OR String.contains(issue_type, "formal"):
        List.push(suggestions, "THEORETICAL VERIFICATION:")
        List.push(suggestions, "1. Prove correctness using formal methods")
        List.push(suggestions, "2. Verify closure properties for language operations")
        List.push(suggestions, "3. Check decidability constraints for problem instances")
        List.push(suggestions, "4. Validate complexity bounds using theoretical analysis")
        List.push(suggestions, "5. Ensure construction follows established algorithms")
        List.push(suggestions, "6. Cross-reference with automata theory literature")
        List.push(suggestions, "")
    
    Note: Context-specific suggestions
    If String.contains(context, "regex"):
        List.push(suggestions, "REGULAR EXPRESSION SPECIFIC:")
        List.push(suggestions, "• Check operator precedence: multiplied by and plus bind tighter than concatenation")
        List.push(suggestions, "• Verify parentheses grouping in complex expressions")
        List.push(suggestions, "• Test metacharacter escaping in literal matches")
        List.push(suggestions, "")
    
    If String.contains(context, "grammar"):
        List.push(suggestions, "GRAMMAR-RELATED ISSUES:")
        List.push(suggestions, "• Ensure grammar is in appropriate normal form")
        List.push(suggestions, "• Check for left recursion in parsing contexts")
        List.push(suggestions, "• Validate that terminals and non-terminals are properly distinguished")
        List.push(suggestions, "")
    
    If String.contains(context, "parsing"):
        List.push(suggestions, "PARSING CONSIDERATIONS:")
        List.push(suggestions, "• Verify that grammar is unambiguous for deterministic parsing")
        List.push(suggestions, "• Check lookahead requirements for LL/LR parsing")
        List.push(suggestions, "• Ensure proper handling of empty productions")
        List.push(suggestions, "")
    
    Note: General diagnostic checklist
    If List.size(suggestions) is equal to 0:
        List.push(suggestions, "GENERAL DIAGNOSTIC CHECKLIST:")
        List.push(suggestions, "1. Validate automaton structure consistency")
        List.push(suggestions, "2. Test with known examples and counterexamples")
        List.push(suggestions, "3. Check for common implementation errors:")
        List.push(suggestions, "   minus Off-by-one errors in indexing")
        List.push(suggestions, "   minus Incorrect handling of empty string")
        List.push(suggestions, "   minus Missing error handling for invalid inputs")
        List.push(suggestions, "4. Verify algorithmic correctness against textbook references")
        List.push(suggestions, "5. Profile performance characteristics")
        List.push(suggestions, "6. Consider alternative approaches or representations")
        List.push(suggestions, "")
    
    Note: Add specific context-based recommendations
    If String.length(symptoms) is greater than 0:
        List.push(suggestions, "SYMPTOM-SPECIFIC ANALYSIS:")
        If String.contains(symptoms, "timeout") OR String.contains(symptoms, "slow"):
            List.push(suggestions, "• Performance issue detected minus consider algorithmic optimization")
            List.push(suggestions, "• Check for infinite loops in epsilon transition handling")
            List.push(suggestions, "• Implement proper termination conditions")
        
        If String.contains(symptoms, "crash") OR String.contains(symptoms, "error"):
            List.push(suggestions, "• Add defensive programming with input validation")
            List.push(suggestions, "• Implement proper error handling and recovery")
            List.push(suggestions, "• Check array bounds and null pointer access")
        
        If String.contains(symptoms, "wrong") OR String.contains(symptoms, "incorrect"):
            List.push(suggestions, "• Trace execution with detailed logging")
            List.push(suggestions, "• Compare against manual computation for small examples")
            List.push(suggestions, "• Verify logical correctness of each algorithm step")
        
        List.push(suggestions, "")
    
    Note: Add final recommendations
    List.push(suggestions, "RECOMMENDED NEXT STEPS:")
    List.push(suggestions, "1. Identify the most critical issue from the analysis above")
    List.push(suggestions, "2. Create minimal test cases that reproduce the problem")
    List.push(suggestions, "3. Apply systematic debugging techniques")
    List.push(suggestions, "4. Consult automata theory references for algorithmic details")
    List.push(suggestions, "5. Consider seeking expert review for complex theoretical issues")
    
    Return suggestions