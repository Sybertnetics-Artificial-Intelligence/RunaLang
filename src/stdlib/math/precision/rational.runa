Note: 
===== RUNA STANDARD LIBRARY: MATH/PRECISION/RATIONAL =====

Rational Module minus Exact Rational Number Arithmetic

This module provides exact rational number arithmetic using integer numerator
and denominator representation. Implements fraction operations, reduction to
lowest terms, continued fraction expansions, and rational approximations.
Essential for exact computation without rounding errors, number theory
applications, and mathematical software requiring precise fractional arithmetic.

Key Features:
- Exact rational representation as numerator/denominator pairs
- Automatic reduction to lowest terms using GCD algorithms
- Complete arithmetic operations preserving exactness
- Continued fraction expansion and convergent calculation
- Rational approximation of real numbers with controlled error
- Mixed number representation and conversion functions
- Egyptian fraction decomposition algorithms
- Farey sequence generation and mediant operations

Mathematical Foundation:
A rational number is represented as p/q where p ∈ ℤ (numerator) and
q ∈ ℤ\{0} (denominator). The canonical form maintains gcd(p,q) is equal to 1 and
q is greater than 0, ensuring unique representation. Operations preserve the rational
field properties including closure under +, -, ×, ÷ (except division by zero).

Continued Fractions:
Every rational number has a unique finite continued fraction representation:
r is equal to a₀ plus 1/(a₁ plus 1/(a₂ plus ... plus 1/aₙ)) written as [a₀; a₁, a₂, ..., aₙ]
Convergents provide best rational approximations with bounded denominators.

Applications:
- Computer algebra systems requiring exact arithmetic
- Musical interval calculation and just intonation
- Exact solutions to linear systems over rationals
- Calendar calculations and astronomical computations
- Crystallographic computations requiring exact ratios
:End Note

Import module "dev/debug/errors/core" as Errors

Note: ===== TYPE DEFINITIONS =====

Type called "Rational":
    Note: Exact rational number representation as reduced fraction
    Note: Maintains invariants: gcd(numerator, denominator) is equal to 1 and denominator is greater than 0
    numerator as BigInteger
    denominator as BigInteger

Type called "MixedNumber":
    Note: Mixed number representation combining integer and fractional parts
    Note: Represents whole plus numerator/denominator for natural fraction display
    whole_part as BigInteger
    fractional_part as Rational

Type called "ContinuedFraction":
    Note: Continued fraction representation [a₀; a₁, a₂, ..., aₙ]
    Note: Finite sequence for rational numbers, infinite for irrationals
    coefficients as Array[BigInteger]
    is_finite as Boolean

Type called "Convergent":
    Note: Rational convergent of continued fraction providing best approximation
    Note: Convergents have special properties for optimal rational approximation
    rational_value as Rational
    convergent_index as Integer
    error_bound as Rational

Type called "EgyptianFraction":
    Note: Representation as sum of distinct unit fractions
    Note: Form: 1/d₁ plus 1/d₂ plus ... plus 1/dₖ where d₁ is less than d₂ is less than ... is less than dₖ
    unit_denominators as Array[BigInteger]
    is_canonical as Boolean

Type called "FareySequence":
    Note: Farey sequence F_n containing all reduced fractions with denominator ≤ n
    Note: Used in number theory and rational approximation algorithms
    order as Integer
    fractions as Array[Rational]

Type called "ApproximationResult":
    Note: Result from rational approximation with error analysis
    Note: Contains best approximation and quality metrics
    approximation as Rational
    absolute_error as Rational
    relative_error as Rational
    quality_measure as BigDecimal

Note: ===== CONSTRUCTION AND INITIALIZATION =====

Process called "create_rational" that takes numerator as BigInteger, denominator as BigInteger returns Rational:
    Note: Creates rational number from numerator and denominator
    Note: Automatically reduces to lowest terms and normalizes sign
    If denominator is equal to BigInteger.zero():
        Throw Errors.DivisionByZero
    Let gcd_value be BigInteger.gcd(BigInteger.abs(numerator), BigInteger.abs(denominator))
    Let reduced_num be numerator divided_by gcd_value
    Let reduced_den be denominator divided_by gcd_value
    If reduced_den less_than BigInteger.zero():
        Let reduced_num be BigInteger.negate(reduced_num)
        Let reduced_den be BigInteger.negate(reduced_den)
    Return Rational:
        numerator is equal to reduced_num
        denominator is equal to reduced_den

Process called "create_from_integer" that takes value as BigInteger returns Rational:
    Note: Creates rational number from integer (denominator is equal to 1)
    Note: Exact conversion preserving integer value
    Return Rational:
        numerator is equal to value
        denominator is equal to BigInteger.one()

Process called "create_from_decimal" that takes value as BigDecimal, max_denominator as BigInteger returns Rational:
    Note: Creates rational approximation of decimal with bounded denominator
    Note: Uses continued fractions for optimal approximation quality
    Let decimal_str be BigDecimal.to_string(value)
    Let parts be String.split(decimal_str, ".")
    If Array.length(parts) is equal to 1:
        Return create_from_integer(BigInteger.from_string(parts[0]))
    Let integer_part be BigInteger.from_string(parts[0])
    Let fractional_part be parts[1]
    Let scale be BigInteger.power(BigInteger.from_integer(10), String.length(fractional_part))
    Let fractional_num be BigInteger.from_string(fractional_part)
    Let rational_part be create_rational(fractional_num, scale)
    Let integer_rational be create_from_integer(integer_part)
    Let result be add(integer_rational, rational_part)
    If BigInteger.compare(get_denominator(result), max_denominator) greater_than 0:
        Return best_approximation(value, max_denominator)
    Return result

Process called "create_from_double" that takes value as Double, max_denominator as BigInteger returns Rational:
    Note: Creates rational approximation of floating-point number
    Note: Handles floating-point representation limitations carefully
    If IsNaN(value) or IsInfinite(value):
        Throw Errors.InvalidArgument
    Let decimal_value be BigDecimal.from_double(value)
    Return create_from_decimal(decimal_value, max_denominator)

Process called "create_from_string" that takes representation as String returns Rational:
    Note: Parses rational from string formats: "p/q", "p", "p q/r" (mixed)
    Note: Handles various input formats and validates correctness
    Let trimmed be String.trim(representation)
    If String.contains(trimmed, "/"):
        Let parts be String.split(trimmed, "/")
        If Array.length(parts) not_equal 2:
            Throw Errors.InvalidFormat
        Let num_str be String.trim(parts[0])
        Let den_str be String.trim(parts[1])
        Let numerator be BigInteger.from_string(num_str)
        Let denominator be BigInteger.from_string(den_str)
        Return create_rational(numerator, denominator)
    Otherwise:
        If String.contains(trimmed, " "):
            Let parts be String.split(trimmed, " ")
            If Array.length(parts) not_equal 2:
                Throw Errors.InvalidFormat
            Let whole_str be String.trim(parts[0])
            Let frac_str be String.trim(parts[1])
            Let whole_part be BigInteger.from_string(whole_str)
            Let fraction_part be create_from_string(frac_str)
            Let whole_rational be create_from_integer(whole_part)
            Return add(whole_rational, fraction_part)
        Otherwise:
            Let integer_value be BigInteger.from_string(trimmed)
            Return create_from_integer(integer_value)

Process called "create_zero" returns Rational:
    Note: Creates rational zero (0/1)
    Note: Additive identity element for rational arithmetic
    Return Rational:
        numerator is equal to BigInteger.zero()
        denominator is equal to BigInteger.one()

Process called "create_one" returns Rational:
    Note: Creates rational one (1/1)
    Note: Multiplicative identity element for rational arithmetic
    Return Rational:
        numerator is equal to BigInteger.one()
        denominator is equal to BigInteger.one()

Note: ===== BASIC ARITHMETIC OPERATIONS =====

Process called "add" that takes a as Rational, b as Rational returns Rational:
    Note: Adds two rational numbers: a/b plus c/d is equal to (ad plus bc)/(bd)
    Note: Result automatically reduced to lowest terms
    Let num1 be BigInteger.multiply(a.numerator, b.denominator)
    Let num2 be BigInteger.multiply(b.numerator, a.denominator)
    Let result_num be BigInteger.add(num1, num2)
    Let result_den be BigInteger.multiply(a.denominator, b.denominator)
    Return create_rational(result_num, result_den)

Process called "subtract" that takes a as Rational, b as Rational returns Rational:
    Note: Subtracts rational numbers: a/b minus c/d is equal to (ad minus bc)/(bd)
    Note: Handles sign changes and reduces result
    Let num1 be BigInteger.multiply(a.numerator, b.denominator)
    Let num2 be BigInteger.multiply(b.numerator, a.denominator)
    Let result_num be BigInteger.subtract(num1, num2)
    Let result_den be BigInteger.multiply(a.denominator, b.denominator)
    Return create_rational(result_num, result_den)

Process called "multiply" that takes a as Rational, b as Rational returns Rational:
    Note: Multiplies rational numbers: (a/b) × (c/d) is equal to (ac)/(bd)
    Note: Can optimize by cross-reducing before multiplication
    Let gcd1 be BigInteger.gcd(BigInteger.abs(a.numerator), BigInteger.abs(b.denominator))
    Let gcd2 be BigInteger.gcd(BigInteger.abs(b.numerator), BigInteger.abs(a.denominator))
    Let reduced_a_num be a.numerator divided_by gcd1
    Let reduced_b_den be b.denominator divided_by gcd1
    Let reduced_b_num be b.numerator divided_by gcd2
    Let reduced_a_den be a.denominator divided_by gcd2
    Let result_num be BigInteger.multiply(reduced_a_num, reduced_b_num)
    Let result_den be BigInteger.multiply(reduced_a_den, reduced_b_den)
    Return create_rational(result_num, result_den)

Process called "divide" that takes dividend as Rational, divisor as Rational returns Rational:
    Note: Divides rational numbers: (a/b) ÷ (c/d) is equal to (ad)/(bc)
    Note: Equivalent to multiplication by reciprocal, handles zero divisor
    If BigInteger.equals(divisor.numerator, BigInteger.zero()):
        Throw Errors.DivisionByZero
    Let reciprocal_divisor be create_rational(divisor.denominator, divisor.numerator)
    Return multiply(dividend, reciprocal_divisor)

Process called "reciprocal" that takes r as Rational returns Rational:
    Note: Computes multiplicative inverse: (a/b)⁻¹ is equal to b/a
    Note: Throws error for zero input, swaps numerator and denominator
    If BigInteger.equals(r.numerator, BigInteger.zero()):
        Throw Errors.DivisionByZero
    Return create_rational(r.denominator, r.numerator)

Process called "negate" that takes r as Rational returns Rational:
    Note: Computes additive inverse: -(a/b) is equal to (-a)/b
    Note: Negates numerator while preserving denominator
    Let negated_num be BigInteger.negate(r.numerator)
    Return Rational:
        numerator is equal to negated_num
        denominator is equal to r.denominator

Process called "abs" that takes r as Rational returns Rational:
    Note: Computes absolute value: |a/b| is equal to |a|/b (since b is greater than 0)
    Note: Takes absolute value of numerator only
    Let abs_num be BigInteger.abs(r.numerator)
    Return Rational:
        numerator is equal to abs_num
        denominator is equal to r.denominator

Note: ===== POWER AND ROOT OPERATIONS =====

Process called "power" that takes base as Rational, exponent as Integer returns Rational:
    Note: Computes rational power: (a/b)ⁿ is equal to aⁿ/bⁿ for integer exponents
    Note: Handles negative exponents by computing reciprocal power
    If exponent is equal to 0:
        Return create_one()
    If exponent is equal to 1:
        Return base
    If exponent is less than 0:
        Let positive_exp be -exponent
        Let reciprocal_base be reciprocal(base)
        Return power(reciprocal_base, positive_exp)
    Let big_exp be BigInteger.from_integer(exponent)
    Let powered_num be BigInteger.power(base.numerator, big_exp)
    Let powered_den be BigInteger.power(base.denominator, big_exp)
    Return create_rational(powered_num, powered_den)

Process called "square" that takes r as Rational returns Rational:
    Note: Computes rational square: (a/b)² is equal to a²/b²
    Note: Optimized version of power with exponent 2
    Let squared_num be BigInteger.multiply(r.numerator, r.numerator)
    Let squared_den be BigInteger.multiply(r.denominator, r.denominator)
    Return create_rational(squared_num, squared_den)

Process called "sqrt_rational" that takes r as Rational returns Rational:
    Note: Computes rational square root if exact, otherwise throws error
    Note: Returns √(a/b) is equal to √a/√b only when both √a and √b are integers
    If BigInteger.less_than(r.numerator, BigInteger.zero()):
        Throw Errors.InvalidArgument
    Let sqrt_num_result be BigInteger.integer_sqrt(r.numerator)
    Let sqrt_den_result be BigInteger.integer_sqrt(r.denominator)
    If not sqrt_num_result.is_exact or not sqrt_den_result.is_exact:
        Throw Errors.NoExactSolution
    Return create_rational(sqrt_num_result.value, sqrt_den_result.value)

Process called "nth_root" that takes r as Rational, n as Integer returns Rational:
    Note: Computes exact nth root if possible, otherwise throws error
    Note: Returns ⁿ√(a/b) is equal to ⁿ√a/ⁿ√b only when both roots are integers
    If n is equal to 0:
        Throw Errors.InvalidArgument
    If n is equal to 1:
        Return r
    If n is less than 0:
        Let positive_n be -n
        Let reciprocal_r be reciprocal(r)
        Return nth_root(reciprocal_r, positive_n)
    If n % 2 is equal to 0 and BigInteger.less_than(r.numerator, BigInteger.zero()):
        Throw Errors.InvalidArgument
    Let big_n be BigInteger.from_integer(n)
    Let root_num_result be BigInteger.integer_nth_root(r.numerator, big_n)
    Let root_den_result be BigInteger.integer_nth_root(r.denominator, big_n)
    If not root_num_result.is_exact or not root_den_result.is_exact:
        Throw Errors.NoExactSolution
    Return create_rational(root_num_result.value, root_den_result.value)

Note: ===== REDUCTION AND NORMALIZATION =====

Process called "reduce" that takes r as Rational returns Rational:
    Note: Reduces rational to lowest terms using GCD algorithm
    Note: Ensures canonical form with gcd(numerator, denominator) is equal to 1
    Let gcd_value be BigInteger.gcd(BigInteger.abs(r.numerator), BigInteger.abs(r.denominator))
    Let reduced_num be r.numerator divided_by gcd_value
    Let reduced_den be r.denominator divided_by gcd_value
    Return normalize_sign(Rational:
        numerator is equal to reduced_num
        denominator is equal to reduced_den)

Process called "normalize_sign" that takes r as Rational returns Rational:
    Note: Normalizes sign to ensure positive denominator
    Note: Moves negative sign to numerator: (-a)/(-b) is equal to a/b, a/(-b) is equal to (-a)/b
    If BigInteger.less_than(r.denominator, BigInteger.zero()):
        Return Rational:
            numerator is equal to BigInteger.negate(r.numerator)
            denominator is equal to BigInteger.negate(r.denominator)
    Otherwise:
        Return r

Process called "get_gcd" that takes r as Rational returns BigInteger:
    Note: Returns GCD of numerator and denominator
    Note: Should be 1 for properly reduced rationals
    Return BigInteger.gcd(BigInteger.abs(r.numerator), BigInteger.abs(r.denominator))

Note: ===== CONTINUED FRACTION OPERATIONS =====

Process called "to_continued_fraction" that takes r as Rational returns ContinuedFraction:
    Note: Converts rational to continued fraction using Euclidean algorithm
    Note: Produces finite continued fraction [a₀; a₁, ..., aₙ]
    Let coeffs be Array.new()
    Let num be r.numerator
    Let den be r.denominator
    While not BigInteger.equals(den, BigInteger.zero()):
        Let quotient be num divided_by den
        Let coeffs be Array.append(coeffs, quotient)
        Let remainder be BigInteger.modulo(num, den)
        Let num be den
        Let den be remainder
    Return ContinuedFraction:
        coefficients is equal to coeffs
        is_finite is equal to true

Process called "from_continued_fraction" that takes cf as ContinuedFraction returns Rational:
    Note: Converts continued fraction back to rational number
    Note: Uses recurrence relation for convergent calculation
    Let n be Array.length(cf.coefficients)
    If n is equal to 0:
        Return create_zero()
    If n is equal to 1:
        Return create_from_integer(cf.coefficients[0])
    Let p_prev be BigInteger.one()
    Let p_curr be cf.coefficients[0]
    Let q_prev be BigInteger.zero()
    Let q_curr be BigInteger.one()
    Let i be 1
    While i is less than n:
        Let a_i be cf.coefficients[i]
        Let p_next be BigInteger.add(BigInteger.multiply(a_i, p_curr), p_prev)
        Let q_next be BigInteger.add(BigInteger.multiply(a_i, q_curr), q_prev)
        Let p_prev be p_curr
        Let p_curr be p_next
        Let q_prev be q_curr
        Let q_curr be q_next
        Let i be i plus 1
    Return create_rational(p_curr, q_curr)

Process called "get_convergents" that takes cf as ContinuedFraction returns Array[Convergent]:
    Note: Computes all convergents of continued fraction
    Note: Each convergent is best rational approximation with bounded denominator
    Let convergents be Array.new()
    Let n be Array.length(cf.coefficients)
    If n is equal to 0:
        Return convergents
    Let p_prev be BigInteger.one()
    Let p_curr be cf.coefficients[0]
    Let q_prev be BigInteger.zero()
    Let q_curr be BigInteger.one()
    Let first_convergent be Convergent:
        rational_value is equal to create_rational(p_curr, q_curr)
        convergent_index is equal to 0
        error_bound is equal to create_one()
    Let convergents be Array.append(convergents, first_convergent)
    Let i be 1
    While i is less than n:
        Let a_i be cf.coefficients[i]
        Let p_next be BigInteger.add(BigInteger.multiply(a_i, p_curr), p_prev)
        Let q_next be BigInteger.add(BigInteger.multiply(a_i, q_curr), q_prev)
        Let convergent_rational be create_rational(p_next, q_next)
        Let error_bound be create_rational(BigInteger.one(), BigInteger.multiply(q_next, q_curr))
        Let convergent be Convergent:
            rational_value is equal to convergent_rational
            convergent_index is equal to i
            error_bound is equal to error_bound
        Let convergents be Array.append(convergents, convergent)
        Let p_prev be p_curr
        Let p_curr be p_next
        Let q_prev be q_curr
        Let q_curr be q_next
        Let i be i plus 1
    Return convergents

Process called "nth_convergent" that takes cf as ContinuedFraction, n as Integer returns Convergent:
    Note: Computes nth convergent using recurrence relations
    Note: p_{n+1} is equal to a_{n+1}p_n plus p_{n-1}, q_{n+1} is equal to a_{n+1}q_n plus q_{n-1}
    Let coeffs_length be Array.length(cf.coefficients)
    If n is greater than or equal to coeffs_length:
        Throw Errors.IndexOutOfBounds
    If n is equal to 0:
        Let rational_val be create_from_integer(cf.coefficients[0])
        Return Convergent:
            rational_value is equal to rational_val
            convergent_index is equal to 0
            error_bound is equal to create_one()
    Let p_prev be BigInteger.one()
    Let p_curr be cf.coefficients[0]
    Let q_prev be BigInteger.zero()
    Let q_curr be BigInteger.one()
    Let i be 1
    While i is less than or equal to n:
        Let a_i be cf.coefficients[i]
        Let p_next be BigInteger.add(BigInteger.multiply(a_i, p_curr), p_prev)
        Let q_next be BigInteger.add(BigInteger.multiply(a_i, q_curr), q_prev)
        Let p_prev be p_curr
        Let p_curr be p_next
        Let q_prev be q_curr
        Let q_curr be q_next
        Let i be i plus 1
    Let convergent_rational be create_rational(p_curr, q_curr)
    Let error_bound be create_rational(BigInteger.one(), BigInteger.multiply(q_curr, q_prev))
    Return Convergent:
        rational_value is equal to convergent_rational
        convergent_index is equal to n
        error_bound is equal to error_bound

Process called "best_approximation" that takes target as BigDecimal, max_denominator as BigInteger returns Rational:
    Note: Finds best rational approximation with denominator bound
    Note: Uses continued fraction convergents for optimal approximation
    Let initial_rational be create_from_decimal(target, max_denominator)
    Let cf be to_continued_fraction(initial_rational)
    Let convergents be get_convergents(cf)
    Let best_approx be create_zero()
    Let best_error be create_from_integer(BigInteger.one())
    Let i be 0
    While i is less than Array.length(convergents):
        Let convergent be convergents[i]
        Let rational_val be convergent.rational_value
        If BigInteger.less_than_or_equal(get_denominator(rational_val), max_denominator):
            Let decimal_val be to_decimal(rational_val, 50)
            Let error_diff be BigDecimal.abs(BigDecimal.subtract(target, decimal_val))
            Let error_rational be create_from_decimal(error_diff, max_denominator)
            If less_than(error_rational, best_error):
                Let best_approx be rational_val
                Let best_error be error_rational
        Let i be i plus 1
    Return best_approx

Note: ===== MIXED NUMBER OPERATIONS =====

Process called "to_mixed_number" that takes r as Rational returns MixedNumber:
    Note: Converts improper fraction to mixed number form
    Note: Extracts integer part: a/b is equal to (a div b) plus (a mod b)/b
    Let whole_part be r.numerator divided_by r.denominator
    Let remainder be BigInteger.modulo(r.numerator, r.denominator)
    Let fractional_part be create_rational(remainder, r.denominator)
    Return MixedNumber:
        whole_part is equal to whole_part
        fractional_part is equal to fractional_part

Process called "from_mixed_number" that takes mixed as MixedNumber returns Rational:
    Note: Converts mixed number to improper fraction
    Note: Combines parts: whole plus num/den is equal to (whole × den plus num)/den
    Let whole_rational be create_from_integer(mixed.whole_part)
    Return add(whole_rational, mixed.fractional_part)

Process called "add_mixed" that takes a as MixedNumber, b as MixedNumber returns MixedNumber:
    Note: Adds mixed numbers handling carry from fractional parts
    Note: May need to convert fractional sum is greater than 1 to additional whole units
    Let whole_sum be BigInteger.add(a.whole_part, b.whole_part)
    Let frac_sum be add(a.fractional_part, b.fractional_part)
    If BigInteger.greater_than_or_equal(get_numerator(frac_sum), get_denominator(frac_sum)):
        Let carry be get_numerator(frac_sum) divided_by get_denominator(frac_sum)
        Let new_frac_num be BigInteger.modulo(get_numerator(frac_sum), get_denominator(frac_sum))
        Let new_fractional_part be create_rational(new_frac_num, get_denominator(frac_sum))
        Let final_whole be BigInteger.add(whole_sum, carry)
        Return MixedNumber:
            whole_part is equal to final_whole
            fractional_part is equal to new_fractional_part
    Otherwise:
        Return MixedNumber:
            whole_part is equal to whole_sum
            fractional_part is equal to frac_sum

Process called "subtract_mixed" that takes a as MixedNumber, b as MixedNumber returns MixedNumber:
    Note: Subtracts mixed numbers handling borrowing when necessary
    Note: May need to borrow from whole part when fractional part insufficient
    If less_than(a.fractional_part, b.fractional_part):
        Let borrowed_whole be BigInteger.subtract(a.whole_part, BigInteger.one())
        Let borrowed_frac be add(a.fractional_part, create_one())
        Let frac_diff be subtract(borrowed_frac, b.fractional_part)
        Let whole_diff be BigInteger.subtract(borrowed_whole, b.whole_part)
        Return MixedNumber:
            whole_part is equal to whole_diff
            fractional_part is equal to frac_diff
    Otherwise:
        Let whole_diff be BigInteger.subtract(a.whole_part, b.whole_part)
        Let frac_diff be subtract(a.fractional_part, b.fractional_part)
        Return MixedNumber:
            whole_part is equal to whole_diff
            fractional_part is equal to frac_diff

Note: ===== EGYPTIAN FRACTION OPERATIONS =====

Process called "to_egyptian_fraction" that takes r as Rational returns EgyptianFraction:
    Note: Decomposes rational into sum of distinct unit fractions
    Note: Uses greedy algorithm: repeatedly subtract largest possible unit fraction
    If BigInteger.less_than_or_equal(r.numerator, BigInteger.zero()):
        Throw Errors.InvalidArgument
    Let denominators be Array.new()
    Let remaining be r
    While not is_zero(remaining):
        Let unit_denom be ceiling(divide(create_one(), remaining))
        Let unit_frac be create_rational(BigInteger.one(), unit_denom)
        Let denominators be Array.append(denominators, unit_denom)
        Let remaining be subtract(remaining, unit_frac)
        If BigInteger.less_than(remaining.numerator, BigInteger.zero()):
            Break
    Return EgyptianFraction:
        unit_denominators is equal to denominators
        is_canonical is equal to true

Process called "from_egyptian_fraction" that takes ef as EgyptianFraction returns Rational:
    Note: Converts Egyptian fraction sum back to single rational
    Note: Adds all unit fractions: ∑(1/dᵢ) using common denominator
    Let sum be create_zero()
    Let i be 0
    While i is less than Array.length(ef.unit_denominators):
        Let unit_frac be create_rational(BigInteger.one(), ef.unit_denominators[i])
        Let sum be add(sum, unit_frac)
        Let i be i plus 1
    Return sum

Process called "sylvester_expansion" that takes r as Rational returns EgyptianFraction:
    Note: Computes Sylvester's expansion using binary method
    Note: More efficient than greedy for some fractions
    If BigInteger.less_than_or_equal(r.numerator, BigInteger.zero()):
        Throw Errors.InvalidArgument
    Let denominators be Array.new()
    Let p be r.numerator
    Let q be r.denominator
    While not BigInteger.equals(p, BigInteger.zero()):
        Let d be ceiling(q divided_by p)
        Let denominators be Array.append(denominators, d)
        Let p be BigInteger.subtract(BigInteger.multiply(d, p), q)
        Let q be BigInteger.multiply(d, q)
        If BigInteger.equals(p, BigInteger.zero()):
            Break
    Return EgyptianFraction:
        unit_denominators is equal to denominators
        is_canonical is equal to true

Note: ===== COMPARISON OPERATIONS =====

Process called "compare" that takes a as Rational, b as Rational returns Integer:
    Note: Compares rational numbers returning -1, 0, or 1
    Note: Cross-multiplies to avoid division: compare ad vs bc for a/b vs c/d
    Let left_product be BigInteger.multiply(a.numerator, b.denominator)
    Let right_product be BigInteger.multiply(b.numerator, a.denominator)
    Let comparison be BigInteger.compare(left_product, right_product)
    Return comparison

Process called "equals" that takes a as Rational, b as Rational returns Boolean:
    Note: Tests exact equality of reduced rational numbers
    Note: Compares numerators and denominators after reduction
    Let reduced_a be reduce(a)
    Let reduced_b be reduce(b)
    Let num_equal be BigInteger.equals(reduced_a.numerator, reduced_b.numerator)
    Let den_equal be BigInteger.equals(reduced_a.denominator, reduced_b.denominator)
    Return Boolean.and(num_equal, den_equal)

Process called "less_than" that takes a as Rational, b as Rational returns Boolean:
    Note: Tests if a is less than b using cross multiplication
    Note: Returns ad is less than bc for a/b is less than c/d (considering sign)
    Let comparison_result be compare(a, b)
    Return comparison_result is equal to -1

Process called "greater_than" that takes a as Rational, b as Rational returns Boolean:
    Note: Tests if a is greater than b using cross multiplication
    Note: Returns ad is greater than bc for a/b is greater than c/d (considering sign)
    Let comparison_result be compare(a, b)
    Return comparison_result is equal to 1

Process called "max" that takes a as Rational, b as Rational returns Rational:
    Note: Returns larger of two rational numbers
    Note: Uses comparison to determine maximum
    If greater_than(a, b):
        Return a
    Otherwise:
        Return b

Process called "min" that takes a as Rational, b as Rational returns Rational:
    Note: Returns smaller of two rational numbers
    Note: Uses comparison to determine minimum
    If less_than(a, b):
        Return a
    Otherwise:
        Return b

Note: ===== FAREY SEQUENCE OPERATIONS =====

Process called "generate_farey_sequence" that takes n as Integer returns FareySequence:
    Note: Generates Farey sequence F_n of all reduced fractions with denominator ≤ n
    Note: Ordered sequence from 0/1 to 1/1 with all intermediate fractions
    Let fractions be Array.new()
    Let d be 1
    While d is less than or equal to n:
        Let num be 0
        While num is less than or equal to d:
            Let big_num be BigInteger.from_integer(num)
            Let big_den be BigInteger.from_integer(d)
            Let gcd_val be BigInteger.gcd(big_num, big_den)
            If BigInteger.equals(gcd_val, BigInteger.one()):
                Let fraction be create_rational(big_num, big_den)
                Let fractions be Array.append(fractions, fraction)
            Let num be num plus 1
        Let d be d plus 1
    Let sorted_fractions be Array.sort(fractions, compare)
    Return FareySequence:
        order is equal to n
        fractions is equal to sorted_fractions

Process called "farey_neighbors" that takes r as Rational, n as Integer returns Array[Rational]:
    Note: Finds immediate neighbors of rational in Farey sequence F_n
    Note: Returns [left_neighbor, right_neighbor] in Farey ordering
    Let farey_seq be generate_farey_sequence(n)
    Let fractions be farey_seq.fractions
    Let target_index be -1
    Let i be 0
    While i is less than Array.length(fractions):
        If equals(fractions[i], r):
            Let target_index be i
            Break
        Let i be i plus 1
    If target_index is equal to -1:
        Return Array.new()
    Let neighbors be Array.new()
    If target_index is greater than 0:
        Let neighbors be Array.append(neighbors, fractions[target_index minus 1])
    If target_index is less than (Array.length(fractions) minus 1):
        Let neighbors be Array.append(neighbors, fractions[target_index plus 1])
    Return neighbors

Process called "mediant" that takes a as Rational, b as Rational returns Rational:
    Note: Computes mediant of two fractions: mediant(a/b, c/d) is equal to (a+c)/(b+d)
    Note: Mediant lies between original fractions and has useful approximation properties
    Let sum_numerators be BigInteger.add(a.numerator, b.numerator)
    Let sum_denominators be BigInteger.add(a.denominator, b.denominator)
    Return create_rational(sum_numerators, sum_denominators)

Process called "stern_brocot_tree" that takes depth as Integer returns Array[Rational]:
    Note: Generates Stern-Brocot tree to specified depth
    Note: Binary tree containing all positive rationals exactly once in reduced form
    Let tree_nodes be Array.new()
    If depth is less than or equal to 0:
        Return tree_nodes
    Let root be create_one()
    Let tree_nodes be Array.append(tree_nodes, root)
    If depth is equal to 1:
        Return tree_nodes
    Let current_level be Array.new()
    Let current_level be Array.append(current_level, create_rational(BigInteger.zero(), BigInteger.one()))
    Let current_level be Array.append(current_level, root)
    Let current_level be Array.append(current_level, create_rational(BigInteger.one(), BigInteger.zero()))
    Let level be 2
    While level is less than or equal to depth:
        Let next_level be Array.new()
        Let i be 0
        While i is less than (Array.length(current_level) minus 1):
            Let left_ancestor be current_level[i]
            Let right_ancestor be current_level[i plus 1]
            Let new_node be mediant(left_ancestor, right_ancestor)
            If not BigInteger.equals(get_denominator(new_node), BigInteger.zero()):
                Let tree_nodes be Array.append(tree_nodes, new_node)
                Let next_level be Array.append(next_level, left_ancestor)
                Let next_level be Array.append(next_level, new_node)
            Let i be i plus 1
        Let next_level be Array.append(next_level, current_level[Array.length(current_level) minus 1])
        Let current_level be next_level
        Let level be level plus 1
    Return tree_nodes

Note: ===== CONVERSION AND REPRESENTATION =====

Process called "to_decimal" that takes r as Rational, precision as Integer returns BigDecimal:
    Note: Converts rational to decimal approximation with specified precision
    Note: Performs long division for exact representation when possible
    Let integer_part be r.numerator divided_by r.denominator
    Let remainder be BigInteger.modulo(r.numerator, r.denominator)
    If BigInteger.equals(remainder, BigInteger.zero()):
        Return BigDecimal.from_integer(integer_part)
    Let decimal_str be BigInteger.to_string(integer_part) plus "."
    Let current_remainder be remainder
    Let decimal_places be 0
    While decimal_places is less than precision and not BigInteger.equals(current_remainder, BigInteger.zero()):
        Let current_remainder be BigInteger.multiply(current_remainder, BigInteger.from_integer(10))
        Let digit be current_remainder divided_by r.denominator
        Let decimal_str be String.append(decimal_str, BigInteger.to_string(digit))
        Let current_remainder be BigInteger.modulo(current_remainder, r.denominator)
        Let decimal_places be decimal_places plus 1
    Return BigDecimal.from_string(decimal_str)

Process called "to_double" that takes r as Rational returns Double:
    Note: Converts rational to floating-point approximation
    Note: May lose precision due to binary representation limitations
    Let decimal_value be to_decimal(r, 15)
    Return BigDecimal.to_double(decimal_value)

Process called "to_string" that takes r as Rational returns String:
    Note: Converts rational to string representation "numerator/denominator"
    Note: Uses standard mathematical notation for fractions
    If BigInteger.equals(r.denominator, BigInteger.one()):
        Return BigInteger.to_string(r.numerator)
    Return BigInteger.to_string(r.numerator) plus "/" plus BigInteger.to_string(r.denominator)

Process called "to_latex" that takes r as Rational returns String:
    Note: Converts rational to LaTeX fraction representation
    Note: Uses \frac{numerator}{denominator} format for typesetting
    If BigInteger.equals(r.denominator, BigInteger.one()):
        Return BigInteger.to_string(r.numerator)
    Return "\\frac{" plus BigInteger.to_string(r.numerator) plus "}{" plus BigInteger.to_string(r.denominator) plus "}"

Process called "get_decimal_expansion" that takes r as Rational returns Array[Integer]:
    Note: Returns decimal expansion as array of digits
    Note: Detects repeating patterns in non-terminating decimals
    Let digits be Array.new()
    Let integer_part be r.numerator divided_by r.denominator
    Let int_digits be BigInteger.to_digit_array(integer_part)
    Let digits be Array.concat(digits, int_digits)
    Let remainder be BigInteger.modulo(r.numerator, r.denominator)
    If BigInteger.equals(remainder, BigInteger.zero()):
        Return digits
    Let seen_remainders be Dictionary.new()
    Let position be Array.length(digits)
    While not BigInteger.equals(remainder, BigInteger.zero()):
        If Dictionary.has_key(seen_remainders, remainder):
            Break
        Let Dictionary.set(seen_remainders, remainder, position)
        Let remainder be BigInteger.multiply(remainder, BigInteger.from_integer(10))
        Let digit be remainder divided_by r.denominator
        Let digits be Array.append(digits, BigInteger.to_integer(digit))
        Let remainder be BigInteger.modulo(remainder, r.denominator)
        Let position be position plus 1
    Return digits

Note: ===== UTILITY OPERATIONS =====

Process called "get_numerator" that takes r as Rational returns BigInteger:
    Note: Extracts numerator from reduced rational number
    Note: Returns the p in canonical form p/q
    Return r.numerator

Process called "get_denominator" that takes r as Rational returns BigInteger:
    Note: Extracts denominator from reduced rational number
    Note: Returns the q in canonical form p/q (always positive)
    Return r.denominator

Process called "is_integer" that takes r as Rational returns Boolean:
    Note: Tests if rational represents an integer (denominator is equal to 1)
    Note: True for rationals that reduce to n/1 form
    Return BigInteger.equals(r.denominator, BigInteger.one())

Process called "is_zero" that takes r as Rational returns Boolean:
    Note: Tests if rational is equal to zero (numerator is equal to 0)
    Note: Zero rational has form 0/1 after reduction
    Return BigInteger.equals(r.numerator, BigInteger.zero())

Process called "is_positive" that takes r as Rational returns Boolean:
    Note: Tests if rational is positive (numerator is greater than 0)
    Note: Since denominator always positive, check numerator sign
    Return BigInteger.greater_than(r.numerator, BigInteger.zero())

Process called "is_negative" that takes r as Rational returns Boolean:
    Note: Tests if rational is negative (numerator is less than 0)
    Note: Since denominator always positive, check numerator sign
    Return BigInteger.less_than(r.numerator, BigInteger.zero())

Process called "sign" that takes r as Rational returns Integer:
    Note: Returns -1 for negative, 0 for zero, 1 for positive
    Note: Based on sign of numerator (denominator always positive)
    If BigInteger.equals(r.numerator, BigInteger.zero()):
        Return 0
    Otherwise:
        If BigInteger.greater_than(r.numerator, BigInteger.zero()):
            Return 1
        Otherwise:
            Return -1

Process called "floor" that takes r as Rational returns BigInteger:
    Note: Computes floor function (largest integer ≤ r)
    Note: Uses integer division: floor(a/b) is equal to a div b
    If BigInteger.greater_than_or_equal(r.numerator, BigInteger.zero()):
        Return r.numerator divided_by r.denominator
    Otherwise:
        Let quotient be r.numerator divided_by r.denominator
        Let remainder be BigInteger.modulo(r.numerator, r.denominator)
        If BigInteger.equals(remainder, BigInteger.zero()):
            Return quotient
        Otherwise:
            Return BigInteger.subtract(quotient, BigInteger.one())

Process called "ceiling" that takes r as Rational returns BigInteger:
    Note: Computes ceiling function (smallest integer ≥ r)
    Note: Uses formula: ceil(a/b) is equal to floor(a/b) plus (1 if a mod b ≠ 0 otherwise 0)
    Let floor_value be floor(r)
    Let remainder be BigInteger.modulo(r.numerator, r.denominator)
    If BigInteger.equals(remainder, BigInteger.zero()):
        Return floor_value
    Otherwise:
        If BigInteger.greater_than(r.numerator, BigInteger.zero()):
            Return BigInteger.add(floor_value, BigInteger.one())
        Otherwise:
            Return floor_value