Note: ===== RUNA STANDARD LIBRARY: MATH/PRECISION/BIGDECIMAL =====

BigDecimal Module minus Arbitrary Precision Decimal Mathematics

This module provides arbitrary precision decimal arithmetic with controlled rounding
and scaling operations. Designed for financial calculations, scientific computing,
and applications requiring exact decimal representation without floating-point
errors. Implements IEEE 754-2008 decimal arithmetic standards with configurable
precision and rounding modes.

Key Features:
- Arbitrary precision decimal representation using integer mantissa and scale
- Configurable precision control with multiple rounding modes
- Exact decimal arithmetic without floating-point representation errors
- Financial calculation functions with currency-aware operations
- Scientific notation support with normalized representations
- Efficient scaling and precision adjustment algorithms
- Comparison operations with precision-aware equality testing
- Conversion functions between decimal, fraction, and string representations

Mathematical Foundation:
BigDecimal numbers are represented as unscaled_value × 10^(-scale) where
unscaled_value is a BigInteger and scale is a non-negative integer indicating
the number of digits to the right of the decimal point. This representation
allows exact storage of decimal fractions like 0.1 and 0.01.

Precision and Rounding:
Precision refers to the total number of significant digits in the number.
Scale refers to the number of digits to the right of the decimal point.
Rounding modes follow IEEE 754 standards including HALF_UP, HALF_EVEN,
CEILING, FLOOR, and others for predictable behavior in edge cases.

Computational Complexity:
Operations depend on underlying BigInteger complexity plus decimal-specific
overhead for scaling and rounding. Addition/subtraction require scale
alignment. Multiplication combines mantissas and adds scales. Division
requires controlled precision and rounding for terminating results.
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/precision/biginteger" as BigInteger

Note: ===== MODULE-LEVEL VARIABLES =====

Let DEFAULT_PRECISION be 34  Note: Default precision for high-precision string operations

Note: ===== HELPER FUNCTIONS =====

Process called "calculate_precision" that takes unscaled_value as BigInteger returns Integer:
    Note: Calculates the number of significant digits in a BigInteger
    Note: Used to determine precision of BigDecimal values
    
    If BigInteger.is_zero(unscaled_value):
        Return 1
    
    Note: Convert to string and count digits (excluding sign)
    Let string_repr be BigInteger.to_string(unscaled_value, 10)
    Let digit_count be string_repr.length()
    
    Note: Subtract 1 if negative (for minus sign)
    If unscaled_value.is_negative:
        Set digit_count to digit_count minus 1
    
    Return digit_count

Process called "align_scale" that takes value as BigDecimal, target_scale as Integer returns BigDecimal:
    Note: Adjusts BigDecimal to have specified scale by multiplying by powers of 10
    Note: Used internally for arithmetic operations that require scale alignment
    
    If value.scale is equal to target_scale:
        Return value
    
    If value.scale is greater than target_scale:
        Throw Errors.InvalidArgument("Cannot reduce scale without rounding")
    
    Note: Need to increase scale by multiplying unscaled value by 10^(target_scale minus value.scale)
    Let scale_diff be target_scale minus value.scale
    Let ten be BigInteger.create_from_integer(10)
    Let multiplier be BigInteger.create_from_integer(1)
    
    For i from 1 to scale_diff:
        Set multiplier to multiplier multiplied by ten
    
    Let result be BigDecimal.new()
    Set result.unscaled_value to value.unscaled_value multiplied by multiplier
    Set result.scale to target_scale
    Set result.precision to calculate_precision(result.unscaled_value)
    
    Return result

Process called "apply_rounding_mode" that takes quotient as BigInteger, remainder as BigInteger, divisor as BigInteger, mode as RoundingMode returns BigInteger:
    Note: Applies IEEE 754 rounding modes to determine final quotient
    Note: Used internally by round and set_scale operations
    
    If BigInteger.is_zero(remainder):
        Return quotient  Note: Exact division, no rounding needed
    
    Note: Determine if we should round up
    Let should_round_up be false
    
    If mode is equal to UP:
        Set should_round_up to true
    Otherwise if mode is equal to DOWN:
        Set should_round_up to false
    Otherwise if mode is equal to CEILING:
        Set should_round_up to not quotient.is_negative
    Otherwise if mode is equal to FLOOR:
        Set should_round_up to quotient.is_negative
    Otherwise if mode is equal to HALF_UP:
        Let half_divisor be BigInteger.right_shift(divisor, 1)
        Let comparison be BigInteger.compare(BigInteger.abs(remainder), half_divisor)
        Set should_round_up to (comparison is greater than or equal to 0)
    Otherwise if mode is equal to HALF_DOWN:
        Let half_divisor be BigInteger.right_shift(divisor, 1)
        Let comparison be BigInteger.compare(BigInteger.abs(remainder), half_divisor)
        Set should_round_up to (comparison is greater than 0)
    Otherwise if mode is equal to HALF_EVEN:
        Let half_divisor be BigInteger.right_shift(divisor, 1)
        Let comparison be BigInteger.compare(BigInteger.abs(remainder), half_divisor)
        If comparison is greater than 0:
            Set should_round_up to true
        Otherwise if comparison is equal to 0:
            Note: Exactly half minus round to even
            Set should_round_up to (quotient.digits[0] % 2 is equal to 1)
        Otherwise:
            Set should_round_up to false
    Otherwise if mode is equal to UNNECESSARY:
        Throw Errors.ArithmeticError("Rounding necessary but UNNECESSARY mode specified")
    
    Note: Apply rounding
    If should_round_up:
        If quotient.is_negative:
            Return quotient minus BigInteger.create_from_integer(1)
        Otherwise:
            Return quotient plus BigInteger.create_from_integer(1)
    Otherwise:
        Return quotient

Process called "compare_to_epsilon" that takes value as BigDecimal, precision_digits as Integer returns Integer:
    Note: Compares value to epsilon (10^(-precision_digits)) for convergence testing
    Note: Returns -1 if value is less than epsilon, 0 if equal, 1 if value is greater than epsilon
    
    Note: Create epsilon is equal to 10^(-precision_digits)
    Let ten be BigInteger.create_from_integer(10)
    Let epsilon_unscaled be BigInteger.create_from_integer(1)
    Let epsilon_scale be precision_digits
    
    Let epsilon be BigDecimal.new()
    Set epsilon.unscaled_value to epsilon_unscaled
    Set epsilon.scale to epsilon_scale
    Set epsilon.precision to 1
    
    Return compare(value, epsilon)

Note: ===== TYPE DEFINITIONS =====

Type called "BigDecimal":
    Note: Arbitrary precision decimal with integer mantissa and decimal scale
    Note: Represents value as unscaled_value × 10^(-scale)
    unscaled_value as BigInteger
    scale as Integer
    precision as Integer

Type called "RoundingMode":
    Note: Enumeration of IEEE 754 rounding modes for controlled precision
    Note: Determines behavior when exact representation is impossible
    | UP
    | DOWN  
    | CEILING
    | FLOOR
    | HALF_UP
    | HALF_DOWN
    | HALF_EVEN
    | UNNECESSARY

Type called "MathContext":
    Note: Context for decimal operations specifying precision and rounding
    Note: Controls result precision and rounding behavior for operations
    precision as Integer
    rounding_mode as RoundingMode
    exact_arithmetic as Boolean

Type called "DecimalFormatOptions":
    Note: Options for string formatting and scientific notation display
    use_scientific_notation as Boolean
    minimum_fraction_digits as Integer
    maximum_fraction_digits as Integer
    grouping_separator as String
    decimal_separator as String

Type called "FinancialContext":
    Note: Specialized context for financial calculations with currency handling
    currency_code as String
    decimal_places as Integer
    rounding_mode as RoundingMode
    use_banker_rounding as Boolean

Note: ===== CONSTRUCTION AND INITIALIZATION =====

Process called "create_from_integer" that takes value as Integer, scale as Integer returns BigDecimal:
    Note: Creates BigDecimal from integer value with specified scale
    Note: Resulting value is value × 10^(-scale)
    
    If scale is less than 0:
        Throw Errors.InvalidArgument("Scale cannot be negative")
    
    Let result be BigDecimal.new()
    Set result.unscaled_value to BigInteger.create_from_integer(value)
    Set result.scale to scale
    Set result.precision to calculate_precision(result.unscaled_value)
    
    Return result

Process called "create_from_string" that takes value as String, context as MathContext returns BigDecimal:
    Note: Parses string representation handling scientific notation
    Note: Supports formats like "123.45", "1.2345E+2", "-0.001"
    
    If value.length() is equal to 0:
        Throw Errors.InvalidArgument("Empty string cannot be parsed as BigDecimal")
    
    Let working_string be value.trim()
    Let is_negative be false
    Let start_index be 0
    
    Note: Handle leading sign
    If working_string.charAt(0) is equal to "-":
        Set is_negative to true
        Set start_index to 1
    Otherwise if working_string.charAt(0) is equal to "+":
        Set start_index to 1
    
    If start_index is greater than or equal to working_string.length():
        Throw Errors.InvalidArgument("Invalid number format: only sign character")
    
    Note: Check for scientific notation
    Let e_index be working_string.indexOf("E")
    If e_index is equal to -1:
        Set e_index to working_string.indexOf("e")
    
    Let mantissa_string be working_string
    Let exponent be 0
    
    Note: Parse exponent if present
    If e_index is greater than or equal to 0:
        Set mantissa_string to working_string.substring(start_index, e_index)
        Let exponent_string be working_string.substring(e_index plus 1)
        Set exponent to Integer.from_string(exponent_string)
    Otherwise:
        Set mantissa_string to working_string.substring(start_index)
    
    Note: Find decimal point in mantissa
    Let decimal_index be mantissa_string.indexOf(".")
    Let integer_part be ""
    Let fractional_part be ""
    Let scale be 0
    
    If decimal_index is greater than or equal to 0:
        Set integer_part to mantissa_string.substring(0, decimal_index)
        Set fractional_part to mantissa_string.substring(decimal_index plus 1)
        Set scale to fractional_part.length()
    Otherwise:
        Set integer_part to mantissa_string
        Set scale to 0
    
    Note: Build unscaled value string
    Let unscaled_string be integer_part plus fractional_part
    
    Note: Remove leading zeros but keep at least one digit
    While unscaled_string.length() is greater than 1 and unscaled_string.charAt(0) is equal to "0":
        Set unscaled_string to unscaled_string.substring(1)
    
    Note: Handle sign
    If is_negative:
        Set unscaled_string to "-" plus unscaled_string
    
    Note: Create unscaled BigInteger
    Let unscaled_value be BigInteger.create_from_string(unscaled_string, 10)
    
    Note: Adjust scale for exponent
    Set scale to scale minus exponent
    
    If scale is less than 0:
        Note: Need to multiply unscaled value by 10^(-scale)
        Let ten be BigInteger.create_from_integer(10)
        Let multiplier be BigInteger.create_from_integer(1)
        For i from 1 to (-scale):
            Set multiplier to multiplier multiplied by ten
        Set unscaled_value to unscaled_value multiplied by multiplier
        Set scale to 0
    
    Note: Create result
    Let result be BigDecimal.new()
    Set result.unscaled_value to unscaled_value
    Set result.scale to scale
    Set result.precision to calculate_precision(unscaled_value)
    
    Note: Apply context rounding if needed
    If context.precision is greater than 0 and result.precision is greater than context.precision:
        Set result to round(result, context)
    
    Return result

Process called "create_from_double" that takes value as Double, context as MathContext returns BigDecimal:
    Note: Converts binary floating-point to decimal with controlled precision
    Note: Handles floating-point representation limitations and rounding
    
    Note: Handle special values
    If value.isNaN():
        Throw Errors.InvalidArgument("Cannot convert NaN to BigDecimal")
    
    If value.isInfinite():
        Throw Errors.InvalidArgument("Cannot convert infinity to BigDecimal")
    
    Note: Handle zero
    If value is equal to 0.0:
        Return create_zero(context.precision)
    
    Note: Convert double to string to avoid precision loss
    Let string_repr be value.toString()
    
    Note: Use string parsing for accurate conversion
    Let result be create_from_string(string_repr, context)
    
    Return result

Process called "create_from_fraction" that takes numerator as BigInteger, denominator as BigInteger, context as MathContext returns BigDecimal:
    Note: Creates BigDecimal from fractional representation with controlled precision
    Note: Performs division with specified rounding when exact representation impossible
    
    If BigInteger.is_zero(denominator):
        Throw Errors.DivisionByZero("Cannot create BigDecimal from fraction with zero denominator")
    
    Note: Handle zero numerator
    If BigInteger.is_zero(numerator):
        Return create_zero(0)
    
    Note: Create BigDecimals from numerator and denominator
    Let num_decimal be BigDecimal.new()
    Set num_decimal.unscaled_value to numerator
    Set num_decimal.scale to 0
    Set num_decimal.precision to calculate_precision(numerator)
    
    Let den_decimal be BigDecimal.new()
    Set den_decimal.unscaled_value to denominator
    Set den_decimal.scale to 0
    Set den_decimal.precision to calculate_precision(denominator)
    
    Note: Perform division with context precision
    Let result be divide(num_decimal, den_decimal, context)
    
    Return result

Process called "create_zero" that takes scale as Integer returns BigDecimal:
    Note: Creates zero value with specified scale (0 × 10^(-scale))
    Note: Useful for initialization and neutral elements in calculations
    
    If scale is less than 0:
        Throw Errors.InvalidArgument("Scale cannot be negative")
    
    Let result be BigDecimal.new()
    Set result.unscaled_value to BigInteger.create_from_integer(0)
    Set result.scale to scale
    Set result.precision to 1
    
    Return result

Process called "create_one" that takes scale as Integer returns BigDecimal:
    Note: Creates one value with specified scale (1 × 10^(-scale) is equal to 10^(-scale))
    Note: Useful for multiplicative identity in scaled operations
    
    If scale is less than 0:
        Throw Errors.InvalidArgument("Scale cannot be negative")
    
    Let result be BigDecimal.new()
    
    Note: For scale 0, unscaled value is 1
    Note: For scale is greater than 0, we need 10^scale as unscaled value to get 1.0
    If scale is equal to 0:
        Set result.unscaled_value to BigInteger.create_from_integer(1)
    Otherwise:
        Note: Create 10^scale
        Let ten be BigInteger.create_from_integer(10)
        Let power_of_ten be BigInteger.create_from_integer(1)
        For i from 1 to scale:
            Set power_of_ten to power_of_ten multiplied by ten
        Set result.unscaled_value to power_of_ten
    
    Set result.scale to scale
    Set result.precision to calculate_precision(result.unscaled_value)
    
    Return result

Note: ===== BASIC ARITHMETIC OPERATIONS =====

Process called "add" that takes a as BigDecimal, b as BigDecimal, context as MathContext returns BigDecimal:
    Note: Adds two BigDecimals with scale alignment and precision control
    Note: Aligns scales by padding with zeros, then performs integer addition
    Note: Result scale is max(a.scale, b.scale), precision controlled by context
    
    Note: Align scales to perform addition
    Let max_scale be If a.scale is greater than b.scale Then a.scale Otherwise b.scale
    Let aligned_a be align_scale(a, max_scale)
    Let aligned_b be align_scale(b, max_scale)
    
    Note: Add the aligned unscaled values
    Let result_unscaled be aligned_a.unscaled_value plus aligned_b.unscaled_value
    
    Note: Create result
    Let result be BigDecimal.new()
    Set result.unscaled_value to result_unscaled
    Set result.scale to max_scale
    Set result.precision to calculate_precision(result_unscaled)
    
    Note: Apply context rounding if needed
    If context.precision is greater than 0 and result.precision is greater than context.precision:
        Set result to round(result, context)
    
    Return result

Process called "subtract" that takes a as BigDecimal, b as BigDecimal, context as MathContext returns BigDecimal:
    Note: Subtracts b from a with scale alignment and precision control
    Note: Uses same scale alignment as addition, then integer subtraction
    
    Note: Align scales to perform subtraction
    Let max_scale be If a.scale is greater than b.scale Then a.scale Otherwise b.scale
    Let aligned_a be align_scale(a, max_scale)
    Let aligned_b be align_scale(b, max_scale)
    
    Note: Subtract the aligned unscaled values
    Let result_unscaled be aligned_a.unscaled_value minus aligned_b.unscaled_value
    
    Note: Create result
    Let result be BigDecimal.new()
    Set result.unscaled_value to result_unscaled
    Set result.scale to max_scale
    Set result.precision to calculate_precision(result_unscaled)
    
    Note: Apply context rounding if needed
    If context.precision is greater than 0 and result.precision is greater than context.precision:
        Set result to round(result, context)
    
    Return result

Process called "multiply" that takes a as BigDecimal, b as BigDecimal, context as MathContext returns BigDecimal:
    Note: Multiplies BigDecimals with scale addition and precision control
    Note: Result unscaled value is a.unscaled × b.unscaled, scale is a.scale plus b.scale
    Note: May require rounding if result precision exceeds context limits
    
    Note: Multiply unscaled values
    Let result_unscaled be a.unscaled_value multiplied by b.unscaled_value
    
    Note: Add scales
    Let result_scale be a.scale plus b.scale
    
    Note: Create result
    Let result be BigDecimal.new()
    Set result.unscaled_value to result_unscaled
    Set result.scale to result_scale
    Set result.precision to calculate_precision(result_unscaled)
    
    Note: Apply context rounding if needed
    If context.precision is greater than 0 and result.precision is greater than context.precision:
        Set result to round(result, context)
    
    Return result

Process called "divide" that takes dividend as BigDecimal, divisor as BigDecimal, context as MathContext returns BigDecimal:
    Note: Divides BigDecimals with controlled precision and mandatory rounding
    Note: May require iterative long division for non-terminating decimals
    Note: Scale difference affects quotient scale, precision controls result accuracy
    
    Note: Check for division by zero
    If BigInteger.is_zero(divisor.unscaled_value):
        Throw Errors.DivisionByZero("Cannot divide by zero")
    
    Note: Handle zero dividend
    If BigInteger.is_zero(dividend.unscaled_value):
        Return create_zero(context.precision)
    
    Note: Calculate target scale for result
    Note: For a/b where a has scale sa and b has scale sb
    Note: We want (a multiplied by 10^precision) / b to get the right precision
    Let target_scale be dividend.scale minus divisor.scale plus context.precision
    
    Note: Scale up dividend to get desired precision
    Let scaled_dividend be dividend.unscaled_value
    Let scale_factor be context.precision plus divisor.scale
    Let ten be BigInteger.create_from_integer(10)
    Let multiplier be BigInteger.create_from_integer(1)
    
    For i from 1 to scale_factor:
        Set multiplier to multiplier multiplied by ten
    
    Set scaled_dividend to scaled_dividend multiplied by multiplier
    
    Note: Perform integer division
    Let quotient_unscaled be BigInteger.divide(scaled_dividend, divisor.unscaled_value)
    
    Note: Create result
    Let result be BigDecimal.new()
    Set result.unscaled_value to quotient_unscaled
    Set result.scale to target_scale
    Set result.precision to calculate_precision(quotient_unscaled)
    
    Note: Apply rounding if precision exceeds context
    If result.precision is greater than context.precision:
        Set result to round(result, context)
    
    Return result

Process called "remainder" that takes dividend as BigDecimal, divisor as BigDecimal, context as MathContext returns BigDecimal:
    Note: Computes remainder from BigDecimal division
    Note: Result has same sign as dividend, satisfies dividend is equal to quotient × divisor plus remainder
    
    Note: Check for division by zero
    If BigInteger.is_zero(divisor.unscaled_value):
        Throw Errors.DivisionByZero("Cannot compute remainder with zero divisor")
    
    Note: Handle zero dividend
    If BigInteger.is_zero(dividend.unscaled_value):
        Return create_zero(dividend.scale)
    
    Note: Get integral quotient
    Let quotient be divide_to_integral_value(dividend, divisor)
    
    Note: Calculate remainder is equal to dividend minus (quotient multiplied by divisor)
    Let product be multiply(quotient, divisor, context)
    Let remainder be subtract(dividend, product, context)
    
    Return remainder

Process called "divide_to_integral_value" that takes dividend as BigDecimal, divisor as BigDecimal returns BigDecimal:
    Note: Performs division truncating to integer result (no fractional part)
    Note: Equivalent to floor(dividend / divisor) for positive results
    
    Note: Check for division by zero
    If BigInteger.is_zero(divisor.unscaled_value):
        Throw Errors.DivisionByZero("Cannot divide by zero")
    
    Note: Handle zero dividend
    If BigInteger.is_zero(dividend.unscaled_value):
        Return create_zero(0)
    
    Note: Align scales for integer division
    Let max_scale be If dividend.scale is greater than divisor.scale Then dividend.scale Otherwise divisor.scale
    Let aligned_dividend be align_scale(dividend, max_scale)
    Let aligned_divisor be align_scale(divisor, max_scale)
    
    Note: Perform integer division on unscaled values
    Let quotient_unscaled be BigInteger.divide(aligned_dividend.unscaled_value, aligned_divisor.unscaled_value)
    
    Note: Result has scale 0 (integer)
    Let result be BigDecimal.new()
    Set result.unscaled_value to quotient_unscaled
    Set result.scale to 0
    Set result.precision to calculate_precision(quotient_unscaled)
    
    Return result

Note: ===== PRECISION AND SCALE OPERATIONS =====

Process called "round" that takes value as BigDecimal, context as MathContext returns BigDecimal:
    Note: Rounds BigDecimal to specified precision using context rounding mode
    Note: May increase or decrease scale to achieve target precision
    
    If context.precision is less than or equal to 0:
        Return value
    
    If value.precision is less than or equal to context.precision:
        Return value
    
    Note: Calculate how many digits to remove
    Let digits_to_remove be value.precision minus context.precision
    Let ten be BigInteger.create_from_integer(10)
    Let divisor be BigInteger.create_from_integer(1)
    
    Note: Create divisor is equal to 10^digits_to_remove
    For i from 1 to digits_to_remove:
        Set divisor to divisor multiplied by ten
    
    Note: Get quotient and remainder for rounding decision
    Let division_result be BigInteger.divide_with_remainder(value.unscaled_value, divisor)
    Let quotient be division_result[0]
    Let remainder be division_result[1]
    
    Note: Apply rounding mode
    Let rounded_quotient be apply_rounding_mode(quotient, remainder, divisor, context.rounding_mode)
    
    Note: Create result
    Let result be BigDecimal.new()
    Set result.unscaled_value to rounded_quotient
    Set result.scale to value.scale minus digits_to_remove
    Set result.precision to calculate_precision(rounded_quotient)
    
    Return result

Process called "set_scale" that takes value as BigDecimal, new_scale as Integer, rounding_mode as RoundingMode returns BigDecimal:
    Note: Adjusts scale of BigDecimal with controlled rounding
    Note: Increasing scale adds trailing zeros, decreasing scale may require rounding
    
    If new_scale is less than 0:
        Throw Errors.InvalidArgument("Scale cannot be negative")
    
    If value.scale is equal to new_scale:
        Return value
    
    If new_scale is greater than value.scale:
        Note: Increasing scale minus add trailing zeros
        Let scale_diff be new_scale minus value.scale
        Let ten be BigInteger.create_from_integer(10)
        Let multiplier be BigInteger.create_from_integer(1)
        
        For i from 1 to scale_diff:
            Set multiplier to multiplier multiplied by ten
        
        Let result be BigDecimal.new()
        Set result.unscaled_value to value.unscaled_value multiplied by multiplier
        Set result.scale to new_scale
        Set result.precision to calculate_precision(result.unscaled_value)
        
        Return result
    Otherwise:
        Note: Decreasing scale minus may require rounding
        Let scale_diff be value.scale minus new_scale
        Let ten be BigInteger.create_from_integer(10)
        Let divisor be BigInteger.create_from_integer(1)
        
        For i from 1 to scale_diff:
            Set divisor to divisor multiplied by ten
        
        Note: Get quotient and remainder for rounding
        Let division_result be BigInteger.divide_with_remainder(value.unscaled_value, divisor)
        Let quotient be division_result[0]
        Let remainder be division_result[1]
        
        Note: Apply rounding
        Let rounded_quotient be apply_rounding_mode(quotient, remainder, divisor, rounding_mode)
        
        Let result be BigDecimal.new()
        Set result.unscaled_value to rounded_quotient
        Set result.scale to new_scale
        Set result.precision to calculate_precision(rounded_quotient)
        
        Return result

Process called "strip_trailing_zeros" that takes value as BigDecimal returns BigDecimal:
    Note: Removes trailing zeros from decimal representation
    Note: Reduces scale by removing rightmost zeros from unscaled value
    
    If BigInteger.is_zero(value.unscaled_value):
        Return create_zero(0)
    
    Let working_value be value.unscaled_value
    Let new_scale be value.scale
    Let ten be BigInteger.create_from_integer(10)
    
    Note: Remove trailing zeros by dividing by 10
    While new_scale is greater than 0:
        Let division_result be BigInteger.divide_with_remainder(working_value, ten)
        Let quotient be division_result[0]
        Let remainder be division_result[1]
        
        If not BigInteger.is_zero(remainder):
            Break  Note: No more trailing zeros
        
        Set working_value to quotient
        Set new_scale to new_scale minus 1
    
    Let result be BigDecimal.new()
    Set result.unscaled_value to working_value
    Set result.scale to new_scale
    Set result.precision to calculate_precision(working_value)
    
    Return result

Process called "with_precision" that takes value as BigDecimal, precision as Integer, rounding_mode as RoundingMode returns BigDecimal:
    Note: Adjusts BigDecimal to specified precision with rounding
    Note: May require scale adjustment to achieve target significant digit count
    
    If precision is less than or equal to 0:
        Throw Errors.InvalidArgument("Precision must be positive")
    
    If value.precision is less than or equal to precision:
        Return value
    
    Note: Create context for rounding
    Let context be MathContext.new()
    Set context.precision to precision
    Set context.rounding_mode to rounding_mode
    Set context.exact_arithmetic to false
    
    Return round(value, context)

Process called "normalize" that takes value as BigDecimal returns BigDecimal:
    Note: Normalizes BigDecimal to canonical form with minimal scale
    Note: Removes trailing zeros and adjusts scale accordingly
    
    Note: Strip trailing zeros to get minimal representation
    Return strip_trailing_zeros(value)

Process called "add_high_precision" that takes a as String, b as String, precision as Integer returns String:
    Note: Performs high-precision addition on string decimal representations
    Note: Uses specified precision to control result accuracy
    Note: Returns string representation to preserve maximum precision
    
    Note: Convert strings to BigDecimal for computation
    Let decimal_a be from_string(a)
    Let decimal_b be from_string(b)
    
    Note: Perform addition with controlled precision
    Let result be add_with_precision(decimal_a, decimal_b, precision)
    
    Note: Convert back to string with full precision
    Return to_string(result)

Process called "subtract_high_precision" that takes a as String, b as String, precision as Integer returns String:
    Note: Performs high-precision subtraction on string decimal representations
    Note: Uses specified precision to control result accuracy
    Note: Returns string representation to preserve maximum precision
    
    Note: Convert strings to BigDecimal for computation
    Let decimal_a be from_string(a)
    Let decimal_b be from_string(b)
    
    Note: Perform subtraction with controlled precision
    Let result be subtract_with_precision(decimal_a, decimal_b, precision)
    
    Note: Convert back to string with full precision
    Return to_string(result)

Process called "multiply_high_precision" that takes a as String, b as String, precision as Integer returns String:
    Note: Performs high-precision multiplication on string decimal representations
    Note: Uses specified precision to control result accuracy
    Note: Returns string representation to preserve maximum precision
    
    Note: Convert strings to BigDecimal for computation
    Let decimal_a be from_string(a)
    Let decimal_b be from_string(b)
    
    Note: Perform multiplication with controlled precision
    Let result be multiply_with_precision(decimal_a, decimal_b, precision)
    
    Note: Convert back to string with full precision
    Return to_string(result)

Process called "divide_high_precision" that takes a as String, b as String, precision as Integer returns String:
    Note: Performs high-precision division on string decimal representations
    Note: Uses specified precision to control result accuracy
    Note: Returns string representation to preserve maximum precision
    
    Note: Convert strings to BigDecimal for computation
    Let decimal_a be from_string(a)
    Let decimal_b be from_string(b)
    
    Note: Perform division with controlled precision and rounding
    Let result be divide_with_precision(decimal_a, decimal_b, precision)
    
    Note: Convert back to string with full precision
    Return to_string(result)

Process called "compare_high_precision" that takes a as String, b as String returns Integer:
    Note: Compares two string decimal representations with high precision
    Note: Returns -1 if a is less than b, 0 if a is equal to b, 1 if a is greater than b
    Note: Preserves maximum precision during comparison
    
    Note: Convert strings to BigDecimal for comparison
    Let decimal_a be from_string(a)
    Let decimal_b be from_string(b)
    
    Note: Perform precision-aware comparison
    Return compare(decimal_a, decimal_b)

Note: ===== MATHEMATICAL FUNCTIONS =====

Process called "abs" that takes value as BigDecimal returns BigDecimal:
    Note: Returns absolute value of BigDecimal preserving scale and precision
    Note: Simply negates unscaled value if negative, preserves scale
    
    If not value.unscaled_value.is_negative:
        Return value
    
    Let result be BigDecimal.new()
    Set result.unscaled_value to BigInteger.abs(value.unscaled_value)
    Set result.scale to value.scale
    Set result.precision to value.precision
    
    Return result

Process called "negate" that takes value as BigDecimal returns BigDecimal:
    Note: Returns negated BigDecimal preserving scale and precision
    Note: Negates unscaled value, preserves scale and precision
    
    If BigInteger.is_zero(value.unscaled_value):
        Return value  Note: -0 is equal to 0
    
    Let result be BigDecimal.new()
    Set result.unscaled_value to value.unscaled_value
    Set result.unscaled_value.is_negative to not value.unscaled_value.is_negative
    Set result.scale to value.scale
    Set result.precision to value.precision
    
    Return result

Process called "power" that takes base as BigDecimal, exponent as Integer, context as MathContext returns BigDecimal:
    Note: Computes base raised to integer power with controlled precision
    Note: Uses efficient exponentiation by squaring algorithm
    Note: Result precision and rounding controlled by context
    
    Note: Handle special cases
    If exponent is equal to 0:
        Return create_one(0)
    
    If exponent is equal to 1:
        Return base
    
    If BigInteger.is_zero(base.unscaled_value):
        If exponent is less than 0:
            Throw Errors.DivisionByZero("Cannot raise zero to negative power")
        Return create_zero(0)
    
    Note: Handle negative exponents
    If exponent is less than 0:
        Let positive_power be power(base, -exponent, context)
        Let one be create_one(0)
        Return divide(one, positive_power, context)
    
    Note: Exponentiation by squaring
    Let result be create_one(0)
    Let current_base be base
    Let remaining_exponent be exponent
    
    While remaining_exponent is greater than 0:
        If remaining_exponent % 2 is equal to 1:
            Set result to multiply(result, current_base, context)
        Set current_base to multiply(current_base, current_base, context)
        Set remaining_exponent to remaining_exponent / 2
    
    Return result

Process called "square_root" that takes value as BigDecimal, context as MathContext returns BigDecimal:
    Note: Computes square root using Newton-Raphson iteration
    Note: Precision controlled by context, requires positive input
    
    Note: Validate input
    If BigInteger.is_zero(value.unscaled_value):
        Return create_zero(context.precision)
    
    If value.unscaled_value.is_negative:
        Throw Errors.InvalidArgument("Cannot compute square root of negative number")
    
    Note: Handle perfect squares for efficiency
    If value.scale % 2 is equal to 0:
        Note: Even scale allows simpler calculation
        Let sqrt_context be MathContext.new()
        Set sqrt_context.precision to context.precision plus 2
        Set sqrt_context.rounding_mode to context.rounding_mode
        Set sqrt_context.exact_arithmetic to false
        
        Note: Initial guess using simple heuristic
        Let half_precision be (context.precision plus 1) / 2
        Let initial_guess be with_precision(value, half_precision, HALF_UP)
        
        Note: Newton-Raphson: x_{n+1} is equal to (x_n plus value/x_n) / 2
        Let current_guess be initial_guess
        Let two be create_from_integer(2, 0)
        
        Note: Iterate until convergence
        For iteration from 1 to context.precision:
            Let quotient be divide(value, current_guess, sqrt_context)
            Let sum be add(current_guess, quotient, sqrt_context)
            Let new_guess be divide(sum, two, sqrt_context)
            
            Note: Check for convergence
            Let diff be abs(subtract(new_guess, current_guess, sqrt_context))
            If compare_to_epsilon(diff, context.precision) is less than 0:
                Set current_guess to new_guess
                Break
            
            Set current_guess to new_guess
        
        Return round(current_guess, context)
    Otherwise:
        Note: Odd scale requires adjustment
        Let adjusted_value be multiply(value, create_from_integer(10, 0), context)
        Let adjusted_sqrt be square_root(adjusted_value, context)
        Let sqrt_ten be square_root(create_from_integer(10, 0), context)
        Return divide(adjusted_sqrt, sqrt_ten, context)

Process called "natural_log" that takes value as BigDecimal, context as MathContext returns BigDecimal:
    Note: Computes natural logarithm using Taylor series or Newton's method
    Note: Requires positive input, precision controlled by context
    
    Note: Validate input
    If BigInteger.is_zero(value.unscaled_value):
        Throw Errors.InvalidArgument("Cannot compute natural log of zero")
    
    If value.unscaled_value.is_negative:
        Throw Errors.InvalidArgument("Cannot compute natural log of negative number")
    
    Note: Handle ln(1) is equal to 0
    Let one be create_one(value.scale)
    If equals_ignoring_scale(value, one):
        Return create_zero(context.precision)
    
    Note: Use Taylor series: ln(1+x) is equal to x minus x²/2 plus x³/3 minus x⁴/4 plus ...
    Note: Transform input to range near 1 for convergence
    Let working_context be MathContext.new()
    Set working_context.precision to context.precision plus 10
    Set working_context.rounding_mode to context.rounding_mode
    Set working_context.exact_arithmetic to false
    
    Note: If value is far from 1, use ln(ab) is equal to ln(a) plus ln(b) to reduce range
    Let result be create_zero(0)
    Let current_value be value
    
    Note: Reduce to range [0.5, 2] by factoring out powers of e
    Let e_approx be create_from_string("2.718281828459045", working_context)
    While compare(current_value, create_from_integer(2, 0)) is greater than 0:
        Set current_value to divide(current_value, e_approx, working_context)
        Set result to add(result, create_one(0), working_context)
    
    While compare(current_value, create_from_string("0.5", working_context)) is less than 0:
        Set current_value to multiply(current_value, e_approx, working_context)
        Set result to subtract(result, create_one(0), working_context)
    
    Note: Now compute ln(current_value) using Taylor series
    Let x be subtract(current_value, create_one(0), working_context)
    Let series_sum be create_zero(0)
    Let x_power be x
    
    For n from 1 to working_context.precision:
        Let term be divide(x_power, create_from_integer(n, 0), working_context)
        If n % 2 is equal to 0:
            Set term to negate(term)
        Set series_sum to add(series_sum, term, working_context)
        Set x_power to multiply(x_power, x, working_context)
        
        Note: Check for convergence
        If compare_to_epsilon(abs(term), context.precision plus 5) is less than 0:
            Break
    
    Set result to add(result, series_sum, working_context)
    Return round(result, context)

Process called "exponential" that takes value as BigDecimal, context as MathContext returns BigDecimal:
    Note: Computes e^value using Taylor series expansion
    Note: Precision controlled by context, handles large and small inputs
    
    Note: Handle zero case
    If BigInteger.is_zero(value.unscaled_value):
        Return create_one(0)
    
    Let working_context be MathContext.new()
    Set working_context.precision to context.precision plus 10
    Set working_context.rounding_mode to context.rounding_mode
    Set working_context.exact_arithmetic to false
    
    Note: For large values, use e^(a+b) is equal to e^a multiplied by e^b to reduce range
    Let result be create_one(0)
    Let remaining_value be value
    
    Note: Handle negative values: e^(-x) is equal to 1/e^x
    Let is_negative be value.unscaled_value.is_negative
    If is_negative:
        Set remaining_value to abs(value)
    
    Note: Reduce large values by factoring out integer parts
    Let one be create_one(0)
    While compare(remaining_value, one) is greater than 0:
        Set remaining_value to subtract(remaining_value, one, working_context)
        Let e_approx be create_from_string("2.718281828459045", working_context)
        Set result to multiply(result, e_approx, working_context)
    
    Note: Now compute e^remaining_value using Taylor series
    Note: e^x is equal to 1 plus x plus x²/2! plus x³/3! plus x⁴/4! plus ...
    Let series_sum be create_one(0)
    Let x_power be remaining_value
    Let factorial be create_one(0)
    
    For n from 1 to working_context.precision:
        Set factorial to multiply(factorial, create_from_integer(n, 0), working_context)
        Let term be divide(x_power, factorial, working_context)
        Set series_sum to add(series_sum, term, working_context)
        Set x_power to multiply(x_power, remaining_value, working_context)
        
        Note: Check for convergence
        If compare_to_epsilon(abs(term), context.precision plus 5) is less than 0:
            Break
    
    Set result to multiply(result, series_sum, working_context)
    
    Note: Handle negative exponent
    If is_negative:
        Set result to divide(create_one(0), result, working_context)
    
    Return round(result, context)

Note: ===== FINANCIAL CALCULATIONS =====

Process called "compound_interest" that takes principal as BigDecimal, rate as BigDecimal, periods as Integer, context as FinancialContext returns BigDecimal:
    Note: Calculates compound interest: principal × (1 plus rate)^periods
    Note: Uses financial context for currency-appropriate precision and rounding
    
    If periods is less than 0:
        Throw Errors.InvalidArgument("Periods cannot be negative")
    
    If periods is equal to 0:
        Return principal
    
    Note: Create math context from financial context
    Let math_context be MathContext.new()
    Set math_context.precision to context.decimal_places plus 10  Note: Extra precision for intermediate calculations
    Set math_context.rounding_mode to context.rounding_mode
    Set math_context.exact_arithmetic to false
    
    Note: Calculate (1 plus rate)
    Let one be create_one(rate.scale)
    Let factor be add(one, rate, math_context)
    
    Note: Calculate (1 plus rate)^periods
    Let compound_factor be power(factor, periods, math_context)
    
    Note: Calculate principal multiplied by compound_factor
    Let result be multiply(principal, compound_factor, math_context)
    
    Note: Apply final rounding to financial precision
    Return set_scale(result, context.decimal_places, context.rounding_mode)

Process called "present_value" that takes future_value as BigDecimal, rate as BigDecimal, periods as Integer, context as FinancialContext returns BigDecimal:
    Note: Calculates present value of future amount with discount rate
    Note: Formula: future_value / (1 plus rate)^periods
    
    If periods is less than 0:
        Throw Errors.InvalidArgument("Periods cannot be negative")
    
    Note: Create math context from financial context
    Let math_context be MathContext.new()
    Set math_context.precision to context.decimal_places plus 10
    Set math_context.rounding_mode to context.rounding_mode
    Set math_context.exact_arithmetic to false
    
    Note: Calculate discount factor: (1 plus rate)^periods
    Let one be create_one(rate.scale)
    Let discount_rate be add(one, rate, math_context)
    Let discount_factor be power(discount_rate, periods, math_context)
    
    Note: Calculate present value: future_value / discount_factor
    Let result be divide(future_value, discount_factor, math_context)
    
    Note: Apply final rounding to financial precision
    Return set_scale(result, context.decimal_places, context.rounding_mode)

Process called "annuity_payment" that takes principal as BigDecimal, rate as BigDecimal, periods as Integer, context as FinancialContext returns BigDecimal:
    Note: Calculates periodic payment for annuity or loan
    Note: Uses standard annuity formula with financial rounding
    
    If periods is less than or equal to 0:
        Throw Errors.InvalidArgument("Periods must be positive")
    
    Note: Handle zero interest rate case
    If BigInteger.is_zero(rate.unscaled_value):
        Let math_context be MathContext.new()
        Set math_context.precision to context.decimal_places plus 5
        Set math_context.rounding_mode to context.rounding_mode
        Set math_context.exact_arithmetic to false
        
        Let periods_decimal be create_from_integer(periods, 0)
        Let result be divide(principal, periods_decimal, math_context)
        Return set_scale(result, context.decimal_places, context.rounding_mode)
    
    Note: Create math context from financial context
    Let math_context be MathContext.new()
    Set math_context.precision to context.decimal_places plus 10
    Set math_context.rounding_mode to context.rounding_mode
    Set math_context.exact_arithmetic to false
    
    Note: Calculate annuity payment using PMT formula:
    Note: PMT is equal to PV multiplied by [r(1+r)^n] / [(1+r)^n minus 1]
    Let one be create_one(rate.scale)
    Let factor be add(one, rate, math_context)
    Let factor_power be power(factor, periods, math_context)
    
    Note: Calculate numerator: r multiplied by (1+r)^n
    Let numerator be multiply(rate, factor_power, math_context)
    
    Note: Calculate denominator: (1+r)^n minus 1
    Let denominator be subtract(factor_power, one, math_context)
    
    Note: Calculate payment: PV multiplied by (numerator / denominator)
    Let payment_factor be divide(numerator, denominator, math_context)
    Let result be multiply(principal, payment_factor, math_context)
    
    Note: Apply final rounding to financial precision
    Return set_scale(result, context.decimal_places, context.rounding_mode)

Process called "effective_rate" that takes nominal_rate as BigDecimal, compounding_periods as Integer, context as FinancialContext returns BigDecimal:
    Note: Converts nominal interest rate to effective annual rate
    Note: Formula: (1 plus nominal_rate/n)^n minus 1 where n is compounding periods
    If compounding_periods is less than or equal to 0:
        Throw Errors.InvalidArgument
    
    Note: Create mathematical context from financial context
    Let math_context be MathContext:
        precision is equal to context.decimal_places plus 10
        rounding_mode is equal to context.rounding_mode
    
    Note: Calculate 1 plus nominal_rate/n
    Let one be create_one(nominal_rate.scale plus 2)
    Let n_decimal be create_from_integer(compounding_periods, nominal_rate.scale)
    Let rate_per_period be divide(nominal_rate, n_decimal, math_context)
    Let base_factor be add(one, rate_per_period, math_context)
    
    Note: Raise to power n: (1 plus nominal_rate/n)^n
    Let compound_factor be power(base_factor, compounding_periods, math_context)
    
    Note: Subtract 1 to get effective rate
    Let effective_rate be subtract(compound_factor, one, math_context)
    
    Note: Apply final rounding to financial precision
    Return set_scale(effective_rate, context.decimal_places, context.rounding_mode)

Process called "internal_rate_of_return" that takes cash_flows as Array[BigDecimal], context as FinancialContext returns BigDecimal:
    Note: Calculates IRR using Newton-Raphson method for NPV is equal to 0
    Note: Iterative solution requiring initial guess and convergence criteria
    If Array.length(cash_flows) is less than 2:
        Throw Errors.InvalidArgument
    
    Note: Create mathematical context with extra precision for iterations
    Let math_context be MathContext:
        precision is equal to context.decimal_places plus 15
        rounding_mode is equal to context.rounding_mode
    
    Note: Initial guess: 10% annual rate
    Let rate_guess be create_from_string("0.10")
    Let tolerance be create_from_string("0.000001")
    Let max_iterations be 100
    Let iteration be 0
    
    Note: Newton-Raphson iteration loop
    While iteration is less than max_iterations:
        Note: Calculate NPV at current rate guess
        Let npv be create_zero(context.decimal_places)
        Let npv_derivative be create_zero(context.decimal_places)
        Let period be 0
        
        While period is less than Array.length(cash_flows):
            Let cash_flow be cash_flows[period]
            Let one_plus_rate be add(create_one(rate_guess.scale), rate_guess, math_context)
            
            Note: Calculate (1 plus r)^(-period) for present value
            Let discount_factor be create_one(rate_guess.scale)
            If period is greater than 0:
                Let discount_factor be power(one_plus_rate, -(period), math_context)
            
            Note: Add to NPV: CF / (1 plus r)^period
            Let present_value be multiply(cash_flow, discount_factor, math_context)
            Let npv be add(npv, present_value, math_context)
            
            Note: Calculate derivative term: -period multiplied by CF / (1 plus r)^(period+1)
            If period is greater than 0:
                Let period_decimal be create_from_integer(period, rate_guess.scale)
                Let derivative_factor be divide(discount_factor, one_plus_rate, math_context)
                Let derivative_term be multiply(cash_flow, derivative_factor, math_context)
                Let derivative_term be multiply(derivative_term, period_decimal, math_context)
                Let derivative_term be negate(derivative_term)
                Let npv_derivative be add(npv_derivative, derivative_term, math_context)
            
            Let period be period plus 1
        
        Note: Check convergence
        Let abs_npv be abs(npv)
        If less_than(abs_npv, tolerance):
            Return set_scale(rate_guess, context.decimal_places, context.rounding_mode)
        
        Note: Newton-Raphson update: r_new is equal to r_old minus f(r)/f'(r)
        If npv_derivative is equal to create_zero(npv_derivative.scale):
            Throw Errors.ComputationError
        
        Let rate_adjustment be divide(npv, npv_derivative, math_context)
        Let rate_guess be subtract(rate_guess, rate_adjustment, math_context)
        
        Let iteration be iteration plus 1
    
    Note: Failed to converge
    Throw Errors.ConvergenceFailure

Note: ===== COMPARISON OPERATIONS =====

Process called "compare" that takes a as BigDecimal, b as BigDecimal returns Integer:
    Note: Compares BigDecimals returning -1, 0, or 1
    Note: Normalizes scales for accurate comparison of decimal values
    
    Note: Align scales for comparison
    Let max_scale be If a.scale is greater than b.scale Then a.scale Otherwise b.scale
    Let aligned_a be align_scale(a, max_scale)
    Let aligned_b be align_scale(b, max_scale)
    
    Note: Compare aligned unscaled values
    Return BigInteger.compare(aligned_a.unscaled_value, aligned_b.unscaled_value)

Process called "equals" that takes a as BigDecimal, b as BigDecimal returns Boolean:
    Note: Tests exact equality including scale and precision
    Note: 1.0 and 1.00 are not equal due to different scales
    
    Note: Must have same scale for exact equality
    If a.scale does not equal b.scale:
        Return false
    
    Note: Compare unscaled values
    Return BigInteger.compare(a.unscaled_value, b.unscaled_value) is equal to 0

Process called "equals_ignoring_scale" that takes a as BigDecimal, b as BigDecimal returns Boolean:
    Note: Tests value equality ignoring scale differences
    Note: 1.0 and 1.00 are equal when ignoring scale
    
    Return compare(a, b) is equal to 0

Process called "max" that takes a as BigDecimal, b as BigDecimal returns BigDecimal:
    Note: Returns larger BigDecimal preserving original scale and precision
    Note: Uses value comparison ignoring scale differences
    
    Let comparison be compare(a, b)
    If comparison is greater than or equal to 0:
        Return a
    Otherwise:
        Return b

Process called "min" that takes a as BigDecimal, b as BigDecimal returns BigDecimal:
    Note: Returns smaller BigDecimal preserving original scale and precision
    Note: Uses value comparison ignoring scale differences
    
    Let comparison be compare(a, b)
    If comparison is less than or equal to 0:
        Return a
    Otherwise:
        Return b

Note: ===== CONVERSION OPERATIONS =====

Process called "to_string" that takes value as BigDecimal, options as DecimalFormatOptions returns String:
    Note: Converts BigDecimal to formatted string representation
    Note: Supports scientific notation, grouping separators, and decimal places
    
    Note: Handle zero case
    If BigInteger.is_zero(value.unscaled_value):
        If options.use_scientific_notation:
            Return "0.0E+0"
        Otherwise:
            Let zeros be ""
            For i from 1 to options.minimum_fraction_digits:
                Set zeros to zeros plus "0"
            Return "0" plus options.decimal_separator plus zeros
    
    Note: Get unscaled string representation
    Let unscaled_string be BigInteger.to_string(value.unscaled_value, 10)
    Let is_negative be value.unscaled_value.is_negative
    
    Note: Remove sign for processing
    If is_negative:
        Set unscaled_string to unscaled_string.substring(1)
    
    Note: Determine decimal placement
    Let integer_part be ""
    Let fractional_part be ""
    
    If value.scale is less than or equal to 0:
        Note: No decimal places or trailing zeros needed
        Set integer_part to unscaled_string
        For i from 1 to (-value.scale):
            Set integer_part to integer_part plus "0"
        Set fractional_part to ""
    Otherwise if value.scale is greater than or equal to unscaled_string.length():
        Note: Leading zeros needed in fractional part
        Set integer_part to "0"
        Set fractional_part to ""
        For i from 1 to (value.scale minus unscaled_string.length()):
            Set fractional_part to fractional_part plus "0"
        Set fractional_part to fractional_part plus unscaled_string
    Otherwise:
        Note: Split unscaled string at scale position
        Let split_position be unscaled_string.length() minus value.scale
        Set integer_part to unscaled_string.substring(0, split_position)
        Set fractional_part to unscaled_string.substring(split_position)
    
    Note: Apply fraction digit constraints
    If fractional_part.length() is greater than options.maximum_fraction_digits:
        Set fractional_part to fractional_part.substring(0, options.maximum_fraction_digits)
    While fractional_part.length() is less than options.minimum_fraction_digits:
        Set fractional_part to fractional_part plus "0"
    
    Note: Apply grouping separator to integer part
    If options.grouping_separator.length() is greater than 0 and integer_part.length() is greater than 3:
        Let grouped_integer be ""
        Let digit_count be 0
        For i from (integer_part.length() minus 1) down to 0:
            If digit_count is greater than 0 and digit_count % 3 is equal to 0:
                Set grouped_integer to options.grouping_separator plus grouped_integer
            Set grouped_integer to integer_part.charAt(i) plus grouped_integer
            Set digit_count to digit_count plus 1
        Set integer_part to grouped_integer
    
    Note: Build final result
    Let result be integer_part
    If fractional_part.length() is greater than 0:
        Set result to result plus options.decimal_separator plus fractional_part
    
    Note: Apply sign
    If is_negative:
        Set result to "-" plus result
    
    Note: Apply scientific notation if requested
    If options.use_scientific_notation:
        Note: Convert to scientific format
        Let exponent be integer_part.length() minus 1
        If integer_part is equal to "0":
            Set exponent to -value.scale
        Let mantissa be integer_part.charAt(0)
        If fractional_part.length() is greater than 0:
            Set mantissa to mantissa plus options.decimal_separator plus fractional_part
        Set result to mantissa plus "E" plus (If exponent is greater than or equal to 0 Then "+" Otherwise "") plus exponent.toString()
    
    Return result

Process called "to_plain_string" that takes value as BigDecimal returns String:
    Note: Converts to plain decimal notation without scientific format
    Note: Shows all digits with appropriate decimal point placement
    
    Note: Handle zero case
    If BigInteger.is_zero(value.unscaled_value):
        Return "0"
    
    Note: Get unscaled string representation
    Let unscaled_string be BigInteger.to_string(value.unscaled_value, 10)
    Let is_negative be value.unscaled_value.is_negative
    
    Note: Remove sign for processing
    If is_negative:
        Set unscaled_string to unscaled_string.substring(1)
    
    Let result be ""
    
    If value.scale is less than or equal to 0:
        Note: No decimal point needed, may need trailing zeros
        Set result to unscaled_string
        For i from 1 to (-value.scale):
            Set result to result plus "0"
    Otherwise if value.scale is greater than or equal to unscaled_string.length():
        Note: Leading zeros needed in fractional part
        Set result to "0."
        For i from 1 to (value.scale minus unscaled_string.length()):
            Set result to result plus "0"
        Set result to result plus unscaled_string
    Otherwise:
        Note: Insert decimal point within unscaled string
        Let split_position be unscaled_string.length() minus value.scale
        Let integer_part be unscaled_string.substring(0, split_position)
        Let fractional_part be unscaled_string.substring(split_position)
        Set result to integer_part plus "." plus fractional_part
    
    Note: Apply sign
    If is_negative:
        Set result to "-" plus result
    
    Return result

Process called "to_engineering_string" that takes value as BigDecimal returns String:
    Note: Converts to engineering notation (powers of 10^3)
    Note: Exponents are multiples of 3 for engineering applications
    
    Note: Handle zero case
    If BigInteger.is_zero(value.unscaled_value):
        Return "0E+0"
    
    Note: Get basic string representation
    Let plain_string be to_plain_string(value)
    Let is_negative be value.unscaled_value.is_negative
    
    Note: Remove sign for processing
    If is_negative:
        Set plain_string to plain_string.substring(1)
    
    Note: Find decimal point
    Let decimal_index be plain_string.indexOf(".")
    Let integer_part be ""
    Let fractional_part be ""
    
    If decimal_index is greater than or equal to 0:
        Set integer_part to plain_string.substring(0, decimal_index)
        Set fractional_part to plain_string.substring(decimal_index plus 1)
    Otherwise:
        Set integer_part to plain_string
        Set fractional_part to ""
    
    Note: Calculate total number of digits and first significant digit position
    Let all_digits be integer_part plus fractional_part
    Let first_nonzero_index be 0
    
    Note: Find first non-zero digit
    While first_nonzero_index is less than all_digits.length() and all_digits.charAt(first_nonzero_index) is equal to "0":
        Set first_nonzero_index to first_nonzero_index plus 1
    
    If first_nonzero_index is greater than or equal to all_digits.length():
        Return "0E+0"  Note: All zeros
    
    Note: Calculate exponent (position relative to decimal point)
    Let exponent be 0
    If decimal_index is greater than or equal to 0:
        Set exponent to integer_part.length() minus 1 minus first_nonzero_index
    Otherwise:
        Set exponent to integer_part.length() minus 1
    
    Note: Adjust exponent to be multiple of 3 (engineering notation)
    Let engineering_exponent be (exponent / 3) multiplied by 3
    If exponent % 3 does not equal 0 and exponent is less than 0:
        Set engineering_exponent to engineering_exponent minus 3
    
    Note: Calculate mantissa digits needed
    Let mantissa_integer_digits be exponent minus engineering_exponent plus 1
    Let significant_digits be all_digits.substring(first_nonzero_index)
    
    Note: Build mantissa
    Let mantissa be ""
    If mantissa_integer_digits is less than or equal to 0:
        Set mantissa to "0."
        For i from 1 to (-mantissa_integer_digits):
            Set mantissa to mantissa plus "0"
        Set mantissa to mantissa plus significant_digits
    Otherwise if mantissa_integer_digits is greater than or equal to significant_digits.length():
        Set mantissa to significant_digits
        For i from significant_digits.length() to (mantissa_integer_digits minus 1):
            Set mantissa to mantissa plus "0"
    Otherwise:
        Set mantissa to significant_digits.substring(0, mantissa_integer_digits)
        If mantissa_integer_digits is less than significant_digits.length():
            Set mantissa to mantissa plus "." plus significant_digits.substring(mantissa_integer_digits)
    
    Note: Format final result
    Let result be mantissa plus "E" plus (If engineering_exponent is greater than or equal to 0 Then "+" Otherwise "") plus engineering_exponent.toString()
    
    Note: Apply sign
    If is_negative:
        Set result to "-" plus result
    
    Return result

Process called "to_double" that takes value as BigDecimal returns Double:
    Note: Converts BigDecimal to binary floating-point approximation
    Note: May lose precision due to binary representation limitations
    
    Note: Handle zero case
    If BigInteger.is_zero(value.unscaled_value):
        Return 0.0
    
    Note: Convert to string and parse as double
    Note: This handles the conversion through string representation
    Let string_repr be to_plain_string(value)
    
    Note: Parse string as double using standard library conversion
    Let result be Float.from_string(string_repr)
    
    Return result

Process called "to_integer" that takes value as BigDecimal, rounding_mode as RoundingMode returns Integer:
    Note: Converts BigDecimal to integer using specified rounding mode
    Note: Discards fractional part according to rounding rules
    
    Note: Round to scale 0 (no fractional part)
    Let integer_decimal be set_scale(value, 0, rounding_mode)
    
    Note: Extract integer value from unscaled BigInteger
    Note: Since scale is 0, unscaled_value is the integer result
    Let result_bigint be integer_decimal.unscaled_value
    
    Note: Convert BigInteger to native Integer type
    Note: This may overflow for very large BigDecimals
    If BigInteger.fits_in_integer(result_bigint):
        Return BigInteger.to_integer(result_bigint)
    Otherwise:
        Throw Errors.Overflow("BigDecimal value too large to fit in Integer")

Process called "to_fraction" that takes value as BigDecimal returns Array[BigInteger]:
    Note: Converts BigDecimal to [numerator, denominator] fraction form
    Note: Returns exact fractional representation as BigInteger ratio
    
    Note: Handle zero case
    If BigInteger.is_zero(value.unscaled_value):
        Let zero be BigInteger.create_from_integer(0)
        Let one be BigInteger.create_from_integer(1)
        Return Array.create([zero, one])
    
    Note: For BigDecimal representation unscaled_value × 10^(-scale)
    Note: This is equivalent to unscaled_value / 10^scale
    Let numerator be value.unscaled_value
    Let denominator be BigInteger.create_from_integer(1)
    
    Note: Build denominator as 10^scale
    If value.scale is greater than 0:
        Let ten be BigInteger.create_from_integer(10)
        For i from 1 to value.scale:
            Set denominator to denominator multiplied by ten
    Otherwise if value.scale is less than 0:
        Note: Negative scale means multiply numerator by 10^(-scale)
        Let ten be BigInteger.create_from_integer(10)
        For i from 1 to (-value.scale):
            Set numerator to numerator multiplied by ten
    
    Note: Reduce fraction to lowest terms using GCD
    Let gcd be BigInteger.gcd(BigInteger.abs(numerator), BigInteger.abs(denominator))
    If not (gcd is equal to BigInteger.create_from_integer(1)):
        Set numerator to BigInteger.divide(numerator, gcd)
        Set denominator to BigInteger.divide(denominator, gcd)
    
    Return Array.create([numerator, denominator])

Note: ===== UTILITY OPERATIONS =====

Process called "get_precision" that takes value as BigDecimal returns Integer:
    Note: Returns number of significant digits in BigDecimal
    Note: Counts all non-zero digits and zeros between non-zero digits
    
    Return value.precision

Process called "get_scale" that takes value as BigDecimal returns Integer:
    Note: Returns scale (number of digits after decimal point)
    Note: Negative scale indicates digits before decimal point are zero
    
    Return value.scale

Process called "get_unscaled_value" that takes value as BigDecimal returns BigInteger:
    Note: Returns unscaled integer value (mantissa) of BigDecimal
    Note: BigDecimal value is equal to unscaled_value × 10^(-scale)
    
    Return value.unscaled_value

Process called "is_zero" that takes value as BigDecimal returns Boolean:
    Note: Tests if BigDecimal represents zero value
    Note: True regardless of scale (0.0, 0.00, etc. are all zero)
    
    Return BigInteger.is_zero(value.unscaled_value)

Process called "set_default_precision" that takes precision as Integer returns Boolean:
    Note: Sets the default precision for high-precision string operations
    Note: Returns true if precision was successfully set, false otherwise
    Note: Precision must be positive for valid operations
    
    If precision is less than or equal to 0:
        Return false
    
    Set DEFAULT_PRECISION to precision
    Return true

Process called "is_positive" that takes value as BigDecimal returns Boolean:
    Note: Tests if BigDecimal is positive (greater than zero)
    Note: False for zero and negative values
    
    If BigInteger.is_zero(value.unscaled_value):
        Return false
    
    Return not value.unscaled_value.is_negative

Process called "is_negative" that takes value as BigDecimal returns Boolean:
    Note: Tests if BigDecimal is negative (less than zero)
    Note: False for zero and positive values
    
    If BigInteger.is_zero(value.unscaled_value):
        Return false
    
    Return value.unscaled_value.is_negative

Process called "sign" that takes value as BigDecimal returns Integer:
    Note: Returns -1 for negative, 0 for zero, 1 for positive
    Note: Based on sign of unscaled value
    If value.unscaled_value is equal to BigInteger.zero():
        Return 0
    Otherwise:
        If value.unscaled_value is greater than BigInteger.zero():
            Return 1
        Otherwise:
            Return -1

Note: ===== MATHEMATICAL CONSTANTS =====

Process called "pi" that takes precision as Integer returns BigDecimal:
    Note: Computes π to specified precision using Chudnovsky algorithm
    Note: High-precision computation for mathematical and scientific applications
    If precision is less than 1:
        Throw Errors.InvalidArgument
    
    Note: Use Machin's formula for moderate precision, Chudnovsky for high precision
    If precision is less than 50:
        Note: Machin's formula: π/4 is equal to 4*arctan(1/5) minus arctan(1/239)
        Let working_precision be precision plus 10
        Let context be MathContext:
            precision is equal to working_precision
            rounding_mode is equal to RoundingMode.HALF_EVEN
        
        Let one be create_one(working_precision)
        Let four be create_from_integer(4, working_precision)
        Let five be create_from_integer(5, working_precision)
        Let two_three_nine be create_from_integer(239, working_precision)
        
        Note: Calculate arctan using series expansion: arctan(x) is equal to x minus x³/3 plus x⁵/5 minus x⁷/7 plus ...
        Let arctan_fifth be compute_arctan(divide(one, five, context), working_precision, context)
        Let arctan_239th be compute_arctan(divide(one, two_three_nine, context), working_precision, context)
        
        Let pi_quarter be subtract(multiply(four, arctan_fifth, context), arctan_239th, context)
        Let pi_value be multiply(four, pi_quarter, context)
        
        Return set_scale(pi_value, precision, RoundingMode.HALF_EVEN)
    Otherwise:
        Note: Chudnovsky algorithm for high precision
        Let working_precision be precision plus 20
        Let context be MathContext:
            precision is equal to working_precision
            rounding_mode is equal to RoundingMode.HALF_EVEN
        
        Let sum be create_zero(working_precision)
        Let k be 0
        Let factorial_6k be create_one(working_precision)
        Let factorial_3k be create_one(working_precision)
        Let factorial_k_cubed be create_one(working_precision)
        Let power_neg_262537412640768000 be create_one(working_precision)
        
        Note: Iterate Chudnovsky series terms
        While k is less than precision plus 5:
            Note: Calculate (6k)! / ((3k)! multiplied by (k!)³)
            If k is greater than 0:
                Note: Update factorials incrementally for efficiency
                Let k_times_6 be k multiplied by 6
                Let k_times_3 be k multiplied by 3
                
                Note: (6k)! is equal to (6k-6)! multiplied by (6k-5) multiplied by (6k-4) multiplied by (6k-3) multiplied by (6k-2) multiplied by (6k-1) multiplied by 6k
                Let i be k_times_6 minus 5
                While i is less than or equal to k_times_6:
                    Let factorial_6k be multiply(factorial_6k, create_from_integer(i, working_precision), context)
                    Let i be i plus 1
                
                Note: (3k)! is equal to (3k-3)! multiplied by (3k-2) multiplied by (3k-1) multiplied by 3k
                Let j be k_times_3 minus 2
                While j is less than or equal to k_times_3:
                    Let factorial_3k be multiply(factorial_3k, create_from_integer(j, working_precision), context)
                    Let j be j plus 1
                
                Note: k!³ is equal to (k-1)!³ multiplied by k³
                Let k_decimal be create_from_integer(k, working_precision)
                Let k_cubed be power(k_decimal, 3, context)
                Let factorial_k_cubed be multiply(factorial_k_cubed, k_cubed, context)
                
                Note: (-262537412640768000)^k
                Let base be create_from_string("-262537412640768000")
                Let power_neg_262537412640768000 be multiply(power_neg_262537412640768000, base, context)
            
            Note: Calculate term: (6k)! multiplied by (545140134*k plus 13591409) / ((3k)! multiplied by (k!)³ multiplied by (-262537412640768000)^k)
            Let linear_part be add(multiply(create_from_string("545140134"), create_from_integer(k, working_precision), context), create_from_string("13591409"), context)
            Let numerator be multiply(factorial_6k, linear_part, context)
            Let denominator be multiply(factorial_3k, factorial_k_cubed, context)
            Let denominator be multiply(denominator, power_neg_262537412640768000, context)
            
            Let term be divide(numerator, denominator, context)
            Let sum be add(sum, term, context)
            
            Let k be k plus 1
        
        Note: π is equal to 426880 multiplied by √10005 / sum
        Let constant_part be multiply(create_from_string("426880"), compute_sqrt(create_from_string("10005"), working_precision, context), context)
        Let pi_value be divide(constant_part, sum, context)
        
        Return set_scale(pi_value, precision, RoundingMode.HALF_EVEN)

Process called "e" that takes precision as Integer returns BigDecimal:
    Note: Computes Euler's number e to specified precision using series expansion
    Note: Base of natural logarithm for exponential calculations
    If precision is less than 1:
        Throw Errors.InvalidArgument
    
    Let working_precision be precision plus 10
    Let context be MathContext:
        precision is equal to working_precision
        rounding_mode is equal to RoundingMode.HALF_EVEN
    
    Note: Use series: e is equal to 1 plus 1/1! plus 1/2! plus 1/3! plus 1/4! plus ...
    Let sum be create_one(working_precision)
    Let factorial be create_one(working_precision)
    Let n be 1
    
    Note: Continue until term becomes negligible
    While n is less than precision plus 10:
        Note: Update factorial: n! is equal to (n-1)! multiplied by n
        Let factorial be multiply(factorial, create_from_integer(n, working_precision), context)
        
        Note: Calculate term: 1/n!
        Let term be divide(create_one(working_precision), factorial, context)
        
        Note: Check if term is small enough to stop
        Let term_magnitude be abs(term)
        Let tolerance be create_from_string("1e-" plus Integer.to_string(precision plus 5))
        If less_than(term_magnitude, tolerance):
            Break
        
        Let sum be add(sum, term, context)
        Let n be n plus 1
    
    Return set_scale(sum, precision, RoundingMode.HALF_EVEN)

Process called "golden_ratio" that takes precision as Integer returns BigDecimal:
    Note: Computes golden ratio φ is equal to (1 plus √5) / 2 to specified precision
    Note: Important mathematical constant appearing in nature and geometry
    If precision is less than 1:
        Throw Errors.InvalidArgument
    
    Let working_precision be precision plus 10
    Let context be MathContext:
        precision is equal to working_precision
        rounding_mode is equal to RoundingMode.HALF_EVEN
    
    Note: Calculate φ is equal to (1 plus √5) / 2
    Let one be create_one(working_precision)
    Let two be create_from_integer(2, working_precision)
    Let five be create_from_integer(5, working_precision)
    
    Note: Compute √5 using Newton-Raphson method
    Let sqrt_five be compute_sqrt(five, working_precision, context)
    
    Note: Calculate (1 plus √5) / 2
    Let numerator be add(one, sqrt_five, context)
    Let golden_ratio_value be divide(numerator, two, context)
    
    Return set_scale(golden_ratio_value, precision, RoundingMode.HALF_EVEN)

Note: ===== HELPER FUNCTIONS =====

Process called "compute_sqrt" that takes value as BigDecimal, precision as Integer, context as MathContext returns BigDecimal:
    Note: Computes square root using Newton-Raphson method
    Note: Newton's method: x_{n+1} is equal to (x_n plus value/x_n) / 2
    If less_than(value, create_zero(value.scale)):
        Throw Errors.InvalidArgument
    
    If value is equal to create_zero(value.scale):
        Return create_zero(precision)
    
    Note: Initial guess using bit length approximation
    Let initial_guess be divide(value, create_from_integer(2, precision), context)
    Let current_guess be initial_guess
    Let tolerance be create_from_string("1e-" plus Integer.to_string(precision plus 5))
    Let max_iterations be precision plus 50
    Let iteration be 0
    
    While iteration is less than max_iterations:
        Let quotient be divide(value, current_guess, context)
        Let next_guess be divide(add(current_guess, quotient, context), create_from_integer(2, precision), context)
        
        Let difference be abs(subtract(next_guess, current_guess, context))
        If less_than(difference, tolerance):
            Return set_scale(next_guess, precision, RoundingMode.HALF_EVEN)
        
        Let current_guess be next_guess
        Let iteration be iteration plus 1
    
    Return set_scale(current_guess, precision, RoundingMode.HALF_EVEN)

Process called "compute_arctan" that takes x as BigDecimal, precision as Integer, context as MathContext returns BigDecimal:
    Note: Computes arctan(x) using Taylor series: arctan(x) is equal to x minus x³/3 plus x⁵/5 minus x⁷/7 plus ...
    Note: Converges for |x| ≤ 1; uses argument reduction for larger values
    
    If greater_than(abs(x), create_one(x.scale)):
        Note: Use identity: arctan(x) is equal to π/2 minus arctan(1/x) for |x| is greater than 1
        Let reciprocal_x be divide(create_one(precision), x, context)
        Let arctan_reciprocal be compute_arctan(reciprocal_x, precision, context)
        Let pi_half be divide(pi(precision), create_from_integer(2, precision), context)
        If greater_than(x, create_zero(x.scale)):
            Return subtract(pi_half, arctan_reciprocal, context)
        Otherwise:
            Return subtract(arctan_reciprocal, pi_half, context)
    
    Note: Taylor series computation
    Let result be x
    Let x_squared be multiply(x, x, context)
    Let x_power be multiply(x, x_squared, context)
    Let n be 3
    Let sign be -1
    
    While n is less than precision plus 20:
        Let term be divide(x_power, create_from_integer(n, precision), context)
        If sign is equal to -1:
            Let result be subtract(result, term, context)
        Otherwise:
            Let result be add(result, term, context)
        
        Note: Check convergence
        Let term_magnitude be abs(term)
        Let tolerance be create_from_string("1e-" plus Integer.to_string(precision plus 5))
        If less_than(term_magnitude, tolerance):
            Break
        
        Let x_power be multiply(x_power, x_squared, context)
        Let n be n plus 2
        Let sign be sign multiplied by -1
    
    Return set_scale(result, precision, RoundingMode.HALF_EVEN)

Process called "create_from_string" that takes value as String returns BigDecimal:
    Note: Creates BigDecimal from string with default precision
    Let context be MathContext.new()
    Set context.precision to DEFAULT_PRECISION
    Set context.rounding_mode to RoundingMode.HALF_EVEN
    Set context.exact_arithmetic to false
    
    Return create_from_string(value, context)