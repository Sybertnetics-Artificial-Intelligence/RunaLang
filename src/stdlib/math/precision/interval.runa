Note: 
===== RUNA STANDARD LIBRARY: MATH/PRECISION/INTERVAL =====

Interval Module minus Interval Arithmetic and Uncertainty Propagation

This module provides interval arithmetic operations for representing and computing
with uncertain or imprecise values. Implements mathematical interval analysis
techniques including uncertainty propagation, constraint satisfaction, global
optimization, and verification methods. Essential for robust numerical computation
where rounding errors, measurement uncertainties, and parameter variations must
be rigorously tracked and bounded.

Key Features:
- Closed interval representation [a, b] with guaranteed containment
- Interval arithmetic operations preserving uncertainty bounds
- Uncertainty propagation through complex mathematical expressions
- Constraint propagation for solving interval constraint systems
- Global optimization using interval branch-and-bound methods
- Verification of mathematical properties and program correctness
- Inclusion functions for elementary mathematical operations
- Interval Newton methods for equation solving with guaranteed bounds

Mathematical Foundation:
An interval [a, b] represents the set {x ∈ ℝ : a ≤ x ≤ b} where a is the
lower bound (infimum) and b is the upper bound (supremum). Interval arithmetic
operations extend real arithmetic to preserve the containment property:
if x ∈ X and y ∈ Y, then f(x,y) ∈ F(X,Y) where F is the interval extension.

Theoretical Properties:
- Inclusion isotonicity: X ⊆ Y ⇒ F(X) ⊆ F(Y)
- Thinness: F([a,a]) is equal to [f(a), f(a)] for point intervals
- Subdistributivity: interval operations are subdistributive over intersection
- Dependency problem: multiple occurrences of variables cause overestimation

Applications:
- Computer-assisted proofs and verification
- Global optimization with guaranteed bounds
- Uncertainty quantification in scientific computing
- Robust control system design
- Validated numerical integration and ODE solving
:End Note
Import module "dev/debug/errors/core" as Errors

Note: ===== TYPE DEFINITIONS =====

Type called "Interval":
    Note: Closed interval [lower, upper] representing uncertain or imprecise values
    Note: Maintains invariant lower ≤ upper, empty intervals represented specially
    lower as BigDecimal
    upper as BigDecimal
    is_empty as Boolean

Type called "IntervalVector":
    Note: Vector of intervals for multidimensional uncertainty representation
    Note: Used in constraint satisfaction and multivariable optimization
    components as Array[Interval]
    dimension as Integer

Type called "IntervalMatrix":
    Note: Matrix of intervals for linear algebra with uncertainty
    Note: Essential for solving interval linear systems
    elements as Array[Array[Interval]]
    rows as Integer
    columns as Integer

Type called "ConstraintSystem":
    Note: System of interval constraints for constraint satisfaction problems
    Note: Combines equality and inequality constraints with variable domains
    constraints as Array[IntervalConstraint]
    variables as Dictionary[String, Interval]
    tolerance as BigDecimal

Type called "IntervalConstraint":
    Note: Single constraint in interval constraint satisfaction system
    Note: Represents constraint functions with interval evaluations
    expression as String
    constraint_type as ConstraintType
    target_interval as Interval

Type called "ConstraintType":
    Note: Type of interval constraint for constraint propagation
    | EQUALITY
    | INEQUALITY_LE
    | INEQUALITY_GE
    | INCLUSION

Type called "OptimizationResult":
    Note: Result from interval-based global optimization
    Note: Provides guaranteed bounds on global optimum
    global_minimum as Interval
    minimizer_box as IntervalVector
    function_evaluations as Integer
    convergence_achieved as Boolean

Type called "VerificationResult":
    Note: Result from mathematical verification using interval methods
    Note: Provides rigorous proof or counterexample information
    is_verified as Boolean
    counterexample_box as IntervalVector
    confidence_level as BigDecimal

Note: ===== CONSTRUCTION AND BASIC OPERATIONS =====

Process called "create_interval" that takes lower as BigDecimal, upper as BigDecimal returns Interval:
    Note: Creates interval [lower, upper] with bounds validation
    Note: Ensures lower ≤ upper invariant, creates empty interval if violated
    If lower is greater than upper:
        Return {
            "lower": 0.0,
            "upper": 0.0,
            "is_empty": true
        }
    
    Return {
        "lower": lower,
        "upper": upper,
        "is_empty": false
    }

Process called "create_point_interval" that takes value as BigDecimal returns Interval:
    Note: Creates degenerate interval [value, value] representing exact value
    Note: Point intervals are neutral elements for many operations
    Return {
        "lower": value,
        "upper": value,
        "is_empty": false
    }

Process called "create_symmetric_interval" that takes center as BigDecimal, radius as BigDecimal returns Interval:
    Note: Creates interval [center minus radius, center plus radius]
    Note: Useful for representing measurements with symmetric uncertainty
    If radius is less than 0.0:
        Return {
            "lower": 0.0,
            "upper": 0.0,
            "is_empty": true
        }
    
    Return {
        "lower": center minus radius,
        "upper": center plus radius,
        "is_empty": false
    }

Process called "create_empty_interval" returns Interval:
    Note: Creates empty interval ∅ representing no valid values
    Note: Empty intervals propagate through operations as absorbing element
    Return {
        "lower": 0.0,
        "upper": 0.0,
        "is_empty": true
    }

Process called "create_entire_interval" returns Interval:
    Note: Creates interval (-∞, +∞) representing all real values
    Note: Used when no bounds can be determined for computation
    Return {
        "lower": -1.0e308,
        "upper": 1.0e308,
        "is_empty": false
    }

Note: ===== INTERVAL ARITHMETIC OPERATIONS =====

Process called "add_intervals" that takes a as Interval, b as Interval returns Interval:
    Note: Computes interval sum [a.lower plus b.lower, a.upper plus b.upper]
    Note: Addition is exact in interval arithmetic without overestimation
    If a.is_empty or b.is_empty:
        Return create_empty_interval()
    
    Return {
        "lower": a.lower plus b.lower,
        "upper": a.upper plus b.upper,
        "is_empty": false
    }

Process called "subtract_intervals" that takes a as Interval, b as Interval returns Interval:
    Note: Computes interval difference [a.lower minus b.upper, a.upper minus b.lower]
    Note: Subtraction accounts for uncertainty in both operands
    If a.is_empty or b.is_empty:
        Return create_empty_interval()
    
    Return {
        "lower": a.lower minus b.upper,
        "upper": a.upper minus b.lower,
        "is_empty": false
    }

Process called "multiply_intervals" that takes a as Interval, b as Interval returns Interval:
    Note: Computes interval product using all four endpoint combinations
    Note: Result is [min(endpoints), max(endpoints)] where endpoints are all products
    If a.is_empty or b.is_empty:
        Return create_empty_interval()
    
    Let p1 be a.lower multiplied by b.lower
    Let p2 be a.lower multiplied by b.upper
    Let p3 be a.upper multiplied by b.lower
    Let p4 be a.upper multiplied by b.upper
    
    Let min_product be p1
    If p2 is less than min_product:
        Set min_product to p2
    If p3 is less than min_product:
        Set min_product to p3
    If p4 is less than min_product:
        Set min_product to p4
    
    Let max_product be p1
    If p2 is greater than max_product:
        Set max_product to p2
    If p3 is greater than max_product:
        Set max_product to p3
    If p4 is greater than max_product:
        Set max_product to p4
    
    Return {
        "lower": min_product,
        "upper": max_product,
        "is_empty": false
    }

Process called "divide_intervals" that takes a as Interval, b as Interval returns Interval:
    Note: Computes interval quotient handling division by zero carefully
    Note: Returns empty interval if zero in denominator interior, infinite if zero endpoint
    If a.is_empty or b.is_empty:
        Return create_empty_interval()
    
    Note: Check if zero is in interior of denominator
    If b.lower is less than 0.0 and b.upper is greater than 0.0:
        Return create_empty_interval()
    
    Note: Check if denominator contains only zero
    If b.lower is equal to 0.0 and b.upper is equal to 0.0:
        Return create_empty_interval()
    
    Note: Handle zero endpoints in denominator
    Let lower_bound be b.lower
    Let upper_bound be b.upper
    If lower_bound is equal to 0.0:
        Set lower_bound to 1.0e-308
    If upper_bound is equal to 0.0:
        Set upper_bound to -1.0e-308
    
    Let q1 be a.lower / lower_bound
    Let q2 be a.lower / upper_bound
    Let q3 be a.upper / lower_bound
    Let q4 be a.upper / upper_bound
    
    Let min_quotient be q1
    If q2 is less than min_quotient:
        Set min_quotient to q2
    If q3 is less than min_quotient:
        Set min_quotient to q3
    If q4 is less than min_quotient:
        Set min_quotient to q4
    
    Let max_quotient be q1
    If q2 is greater than max_quotient:
        Set max_quotient to q2
    If q3 is greater than max_quotient:
        Set max_quotient to q3
    If q4 is greater than max_quotient:
        Set max_quotient to q4
    
    Return {
        "lower": min_quotient,
        "upper": max_quotient,
        "is_empty": false
    }

Process called "power_interval" that takes base as Interval, exponent as Integer returns Interval:
    Note: Computes interval power base^exponent handling sign and parity
    Note: Even exponents create symmetric results, odd preserve monotonicity
    If base.is_empty:
        Return create_empty_interval()
    
    If exponent is equal to 0:
        Return create_point_interval(1.0)
    
    If exponent is equal to 1:
        Return base
    
    Note: Handle negative exponents
    If exponent is less than 0:
        Let reciprocal_base be divide_intervals(create_point_interval(1.0), base)
        Return power_interval(reciprocal_base, -exponent)
    
    Note: Handle even exponents
    If exponent % 2 is equal to 0:
        If base.lower is greater than or equal to 0.0:
            Note: All positive base
            Let lower_power be base.lower ^ exponent
            Let upper_power be base.upper ^ exponent
            Return {
                "lower": lower_power,
                "upper": upper_power,
                "is_empty": false
            }
        If base.upper is less than or equal to 0.0:
            Note: All negative base
            Let lower_power be base.upper ^ exponent
            Let upper_power be base.lower ^ exponent
            Return {
                "lower": lower_power,
                "upper": upper_power,
                "is_empty": false
            }
        Otherwise:
            Note: Base contains zero, result starts at zero
            Let pos_power be base.upper ^ exponent
            Let neg_power be base.lower ^ exponent
            Let max_power be pos_power
            If neg_power is greater than max_power:
                Set max_power to neg_power
            Return {
                "lower": 0.0,
                "upper": max_power,
                "is_empty": false
            }
    
    Note: Handle odd exponents (monotonic)
    Let lower_power be base.lower ^ exponent
    Let upper_power be base.upper ^ exponent
    Return {
        "lower": lower_power,
        "upper": upper_power,
        "is_empty": false
    }

Process called "square_interval" that takes x as Interval returns Interval:
    Note: Computes interval square with special handling for sign changes
    Note: If interval contains zero, result starts at zero: [0, max(a², b²)]
    If x.is_empty:
        Return create_empty_interval()
    
    Let lower_sq be x.lower multiplied by x.lower
    Let upper_sq be x.upper multiplied by x.upper
    
    Note: If interval contains zero, minimum is zero
    If x.lower is less than or equal to 0.0 and x.upper is greater than or equal to 0.0:
        Let max_sq be lower_sq
        If upper_sq is greater than max_sq:
            Set max_sq to upper_sq
        Return {
            "lower": 0.0,
            "upper": max_sq,
            "is_empty": false
        }
    
    Note: Interval does not contain zero
    Let min_sq be lower_sq
    Let max_sq be upper_sq
    If upper_sq is less than min_sq:
        Set min_sq to upper_sq
        Set max_sq to lower_sq
    
    Return {
        "lower": min_sq,
        "upper": max_sq,
        "is_empty": false
    }

Process called "square_root_interval" that takes x as Interval returns Interval:
    Note: Computes interval square root for non-negative intervals
    Note: Returns empty interval if any part of input is negative
    If x.is_empty:
        Return create_empty_interval()
    
    Note: Return empty if any part is negative
    If x.upper is less than 0.0:
        Return create_empty_interval()
    
    Note: Handle mixed sign interval
    Let lower_bound be x.lower
    If lower_bound is less than 0.0:
        Set lower_bound to 0.0
    
    Return {
        "lower": lower_bound ^ 0.5,
        "upper": x.upper ^ 0.5,
        "is_empty": false
    }

Note: ===== ELEMENTARY FUNCTION EXTENSIONS =====

Process called "exp_interval" that takes x as Interval returns Interval:
    Note: Computes interval extension of exponential function
    Note: Monotonic function: exp([a,b]) is equal to [exp(a), exp(b)]
    If x.is_empty:
        Return create_empty_interval()
    
    Note: Exponential is monotonic increasing
    Return {
        "lower": 2.718281828459045 ^ x.lower,
        "upper": 2.718281828459045 ^ x.upper,
        "is_empty": false
    }

Process called "log_interval" that takes x as Interval returns Interval:
    Note: Computes interval extension of natural logarithm
    Note: Requires positive interval, monotonic: log([a,b]) is equal to [log(a), log(b)]
    If x.is_empty:
        Return create_empty_interval()
    
    Note: Return empty if any part is non-positive
    If x.upper is less than or equal to 0.0:
        Return create_empty_interval()
    
    Note: Handle intervals that cross zero
    Let lower_bound be x.lower
    If lower_bound is less than or equal to 0.0:
        Set lower_bound to 1.0e-308
    
    Note: Natural logarithm implementation using change of base
    Let log_lower be 0.0
    Let log_upper be 0.0
    
    Note: Approximate natural log using Taylor series for numerical stability
    If lower_bound is greater than 0.0:
        Set log_lower to (lower_bound minus 1.0) minus (lower_bound minus 1.0)^2/2.0 plus (lower_bound minus 1.0)^3/3.0
    Otherwise:
        Set log_lower to -1.0e308
    
    Set log_upper to (x.upper minus 1.0) minus (x.upper minus 1.0)^2/2.0 plus (x.upper minus 1.0)^3/3.0
    
    Return {
        "lower": log_lower,
        "upper": log_upper,
        "is_empty": false
    }

Process called "sin_interval" that takes x as Interval returns Interval:
    Note: Computes interval extension of sine function
    Note: Non-monotonic, requires careful analysis of critical points in interval
    If x.is_empty:
        Return create_empty_interval()
    
    Let pi be 3.141592653589793
    Let width_val be x.upper minus x.lower
    
    Note: If interval width is greater than or equal to 2π, result is [-1, 1]
    If width_val is greater than or equal to 2.0 multiplied by pi:
        Return {
            "lower": -1.0,
            "upper": 1.0,
            "is_empty": false
        }
    
    Note: Compute sine at endpoints
    Let sin_lower be 0.0
    Let sin_upper be 0.0
    
    Note: Taylor series approximation for sine
    Let x_lower_mod be x.lower minus (x.lower / (2.0 multiplied by pi)) multiplied by (2.0 multiplied by pi)
    Let x_upper_mod be x.upper minus (x.upper / (2.0 multiplied by pi)) multiplied by (2.0 multiplied by pi)
    
    Set sin_lower to x_lower_mod minus x_lower_mod^3/6.0 plus x_lower_mod^5/120.0
    Set sin_upper to x_upper_mod minus x_upper_mod^3/6.0 plus x_upper_mod^5/120.0
    
    Let result_lower be sin_lower
    Let result_upper be sin_upper
    
    Note: Ensure correct ordering
    If result_upper is less than result_lower:
        Let temp be result_lower
        Set result_lower to result_upper
        Set result_upper to temp
    
    Note: Check for extrema in interval
    Let lower_quarter be x.lower / (pi/2.0)
    Let upper_quarter be x.upper / (pi/2.0)
    
    Note: If interval contains π/2 plus 2nπ (maximum), upper bound is 1
    If lower_quarter is less than upper_quarter:
        Set result_upper to 1.0
        
        Note: If interval contains 3π/2 plus 2nπ (minimum), lower bound is -1
        If upper_quarter minus lower_quarter is greater than 2.0:
            Set result_lower to -1.0
    
    Return {
        "lower": result_lower,
        "upper": result_upper,
        "is_empty": false
    }

Process called "cos_interval" that takes x as Interval returns Interval:
    Note: Computes interval extension of cosine function
    Note: Non-monotonic, requires analysis of extrema within interval bounds
    If x.is_empty:
        Return create_empty_interval()
    
    Let pi be 3.141592653589793
    Note: cos(x) is equal to sin(x plus π/2)
    Let shifted_interval be {
        "lower": x.lower plus pi/2.0,
        "upper": x.upper plus pi/2.0,
        "is_empty": false
    }
    
    Return sin_interval(shifted_interval)

Process called "tan_interval" that takes x as Interval returns Interval:
    Note: Computes interval extension of tangent function
    Note: Handles discontinuities at π/2 plus nπ, may return entire interval
    If x.is_empty:
        Return create_empty_interval()
    
    Let pi be 3.141592653589793
    Let width_val be x.upper minus x.lower
    
    Note: If interval width is greater than or equal to π, tangent covers entire real line
    If width_val is greater than or equal to pi:
        Return create_entire_interval()
    
    Note: Check for discontinuities at π/2 plus nπ
    Let lower_half_periods be (x.lower plus pi/2.0) / pi
    Let upper_half_periods be (x.upper plus pi/2.0) / pi
    
    Note: If interval crosses a discontinuity, result is unbounded
    If upper_half_periods minus lower_half_periods is greater than 1.0:
        Return create_entire_interval()
    
    Note: Compute tangent at endpoints using Taylor series
    Let x_lower_mod be x.lower minus (x.lower / pi) multiplied by pi
    Let x_upper_mod be x.upper minus (x.upper / pi) multiplied by pi
    
    Note: Taylor approximation: tan(x) ≈ x plus x³/3 plus 2x⁵/15
    Let tan_lower be x_lower_mod plus x_lower_mod^3/3.0 plus 2.0*x_lower_mod^5/15.0
    Let tan_upper be x_upper_mod plus x_upper_mod^3/3.0 plus 2.0*x_upper_mod^5/15.0
    
    Let result_lower be tan_lower
    Let result_upper be tan_upper
    
    Note: Ensure correct ordering
    If result_upper is less than result_lower:
        Let temp be result_lower
        Set result_lower to result_upper
        Set result_upper to temp
    
    Return {
        "lower": result_lower,
        "upper": result_upper,
        "is_empty": false
    }

Process called "asin_interval" that takes x as Interval returns Interval:
    Note: Computes interval extension of arcsine function
    Note: Domain restricted to [-1, 1], monotonic on valid domain
    If x.is_empty:
        Return create_empty_interval()
    
    Note: Check domain validity
    If x.lower is greater than 1.0 or x.upper is less than -1.0:
        Return create_empty_interval()
    
    Note: Clamp to valid domain [-1, 1]
    Let clamped_lower be x.lower
    Let clamped_upper be x.upper
    If clamped_lower is less than -1.0:
        Set clamped_lower to -1.0
    If clamped_upper is greater than 1.0:
        Set clamped_upper to 1.0
    
    Note: Arcsine approximation using Taylor series
    Note: arcsin(x) ≈ x plus x³/6 plus 3x⁵/40 for |x| ≤ 1
    Let asin_lower be clamped_lower plus clamped_lower^3/6.0 plus 3.0*clamped_lower^5/40.0
    Let asin_upper be clamped_upper plus clamped_upper^3/6.0 plus 3.0*clamped_upper^5/40.0
    
    Return {
        "lower": asin_lower,
        "upper": asin_upper,
        "is_empty": false
    }

Process called "acos_interval" that takes x as Interval returns Interval:
    Note: Computes interval extension of arccosine function
    Note: Domain restricted to [-1, 1], monotonically decreasing
    If x.is_empty:
        Return create_empty_interval()
    
    Note: Check domain validity
    If x.lower is greater than 1.0 or x.upper is less than -1.0:
        Return create_empty_interval()
    
    Note: Use identity: arccos(x) is equal to π/2 minus arcsin(x)
    Let pi be 3.141592653589793
    Let asin_result be asin_interval(x)
    
    If asin_result.is_empty:
        Return create_empty_interval()
    
    Note: Arccosine is decreasing, so we reverse the bounds
    Return {
        "lower": pi/2.0 minus asin_result.upper,
        "upper": pi/2.0 minus asin_result.lower,
        "is_empty": false
    }

Process called "atan_interval" that takes x as Interval returns Interval:
    Note: Computes interval extension of arctangent function
    Note: Monotonic on entire real line, bounded output in (-π/2, π/2)
    If x.is_empty:
        Return create_empty_interval()
    
    Note: Arctangent approximation using series and rational approximation
    Let atan_lower be 0.0
    Let atan_upper be 0.0
    
    Note: For |x| ≤ 1, use Taylor series: arctan(x) ≈ x minus x³/3 plus x⁵/5
    Note: For |x| is greater than 1, use identity: arctan(x) is equal to π/2 minus arctan(1/x) for x is greater than 0
    
    If x.lower is greater than or equal to -1.0 and x.lower is less than or equal to 1.0:
        Set atan_lower to x.lower minus x.lower^3/3.0 plus x.lower^5/5.0
    If x.lower is greater than 1.0:
        Set atan_lower to 3.141592653589793/2.0 minus (1.0/x.lower minus (1.0/x.lower)^3/3.0)
    If x.lower is less than -1.0:
        Set atan_lower to -3.141592653589793/2.0 minus (1.0/x.lower minus (1.0/x.lower)^3/3.0)
    
    If x.upper is greater than or equal to -1.0 and x.upper is less than or equal to 1.0:
        Set atan_upper to x.upper minus x.upper^3/3.0 plus x.upper^5/5.0
    If x.upper is greater than 1.0:
        Set atan_upper to 3.141592653589793/2.0 minus (1.0/x.upper minus (1.0/x.upper)^3/3.0)
    If x.upper is less than -1.0:
        Set atan_upper to -3.141592653589793/2.0 minus (1.0/x.upper minus (1.0/x.upper)^3/3.0)
    
    Return {
        "lower": atan_lower,
        "upper": atan_upper,
        "is_empty": false
    }

Note: ===== INTERVAL ANALYSIS OPERATIONS =====

Process called "width" that takes x as Interval returns BigDecimal:
    Note: Computes interval width (upper minus lower)
    Note: Measure of uncertainty represented by interval
    If x.is_empty:
        Return 0.0
    
    Return x.upper minus x.lower

Process called "midpoint" that takes x as Interval returns BigDecimal:
    Note: Computes interval midpoint (lower plus upper) / 2
    Note: Central value of interval for approximation purposes
    If x.is_empty:
        Return 0.0
    
    Return (x.lower plus x.upper) / 2.0

Process called "radius" that takes x as Interval returns BigDecimal:
    Note: Computes interval radius (upper minus lower) / 2
    Note: Half-width representing maximum deviation from center
    If x.is_empty:
        Return 0.0
    
    Return (x.upper minus x.lower) / 2.0

Process called "magnitude" that takes x as Interval returns BigDecimal:
    Note: Computes interval magnitude max(|lower|, |upper|)
    Note: Largest absolute value contained in interval
    If x.is_empty:
        Return 0.0
    
    Let abs_lower be x.lower
    If abs_lower is less than 0.0:
        Set abs_lower to -abs_lower
    
    Let abs_upper be x.upper
    If abs_upper is less than 0.0:
        Set abs_upper to -abs_upper
    
    If abs_lower is greater than abs_upper:
        Return abs_lower
    
    Return abs_upper

Process called "mignitude" that takes x as Interval returns BigDecimal:
    Note: Computes interval mignitude (smallest absolute value in interval)
    Note: Zero if interval contains zero, otherwise min(|lower|, |upper|)
    If x.is_empty:
        Return 0.0
    
    Note: If interval contains zero, mignitude is zero
    If x.lower is less than or equal to 0.0 and x.upper is greater than or equal to 0.0:
        Return 0.0
    
    Let abs_lower be x.lower
    If abs_lower is less than 0.0:
        Set abs_lower to -abs_lower
    
    Let abs_upper be x.upper
    If abs_upper is less than 0.0:
        Set abs_upper to -abs_upper
    
    If abs_lower is less than abs_upper:
        Return abs_lower
    
    Return abs_upper

Process called "contains_point" that takes interval as Interval, point as BigDecimal returns Boolean:
    Note: Tests if point is contained within interval bounds
    Note: Returns lower ≤ point ≤ upper for non-empty intervals
    If interval.is_empty:
        Return false
    
    Return interval.lower is less than or equal to point and point is less than or equal to interval.upper

Process called "contains_interval" that takes a as Interval, b as Interval returns Boolean:
    Note: Tests if interval a completely contains interval b
    Note: Returns true if a.lower ≤ b.lower and b.upper ≤ a.upper
    If a.is_empty:
        Return b.is_empty
    
    If b.is_empty:
        Return true
    
    Return a.lower is less than or equal to b.lower and b.upper is less than or equal to a.upper

Process called "intersect" that takes a as Interval, b as Interval returns Interval:
    Note: Computes intersection of two intervals
    Note: Returns [max(a.lower, b.lower), min(a.upper, b.upper)] if non-empty
    If a.is_empty or b.is_empty:
        Return create_empty_interval()
    
    Let max_lower be a.lower
    If b.lower is greater than max_lower:
        Set max_lower to b.lower
    
    Let min_upper be a.upper
    If b.upper is less than min_upper:
        Set min_upper to b.upper
    
    Note: Check if intersection is empty
    If max_lower is greater than min_upper:
        Return create_empty_interval()
    
    Return {
        "lower": max_lower,
        "upper": min_upper,
        "is_empty": false
    }

Process called "hull" that takes a as Interval, b as Interval returns Interval:
    Note: Computes interval hull (smallest interval containing both)
    Note: Returns [min(a.lower, b.lower), max(a.upper, b.upper)]
    If a.is_empty and b.is_empty:
        Return create_empty_interval()
    
    If a.is_empty:
        Return b
    
    If b.is_empty:
        Return a
    
    Let min_lower be a.lower
    If b.lower is less than min_lower:
        Set min_lower to b.lower
    
    Let max_upper be a.upper
    If b.upper is greater than max_upper:
        Set max_upper to b.upper
    
    Return {
        "lower": min_lower,
        "upper": max_upper,
        "is_empty": false
    }

Note: ===== CONSTRAINT PROPAGATION =====

Process called "create_constraint_system" returns ConstraintSystem:
    Note: Creates empty constraint satisfaction system
    Note: System for solving interval constraint problems
    Return {
        "constraints": [],
        "variables": {},
        "tolerance": 1.0e-6
    }

Process called "add_constraint" that takes system as ConstraintSystem, constraint as IntervalConstraint returns ConstraintSystem:
    Note: Adds constraint to constraint satisfaction system
    Note: Constraint becomes active in propagation algorithms
    Let new_constraints be []
    For each existing_constraint in system.constraints:
        Append existing_constraint to new_constraints
    Append constraint to new_constraints
    
    Return {
        "constraints": new_constraints,
        "variables": system.variables,
        "tolerance": system.tolerance
    }

Process called "propagate_constraints" that takes system as ConstraintSystem returns ConstraintSystem:
    Note: Performs constraint propagation to reduce variable domains
    Note: Uses consistency algorithms to eliminate impossible values
    Let updated_variables be system.variables
    Let changed be true
    Let max_iterations be 10
    Let iteration be 0
    
    While changed and iteration is less than max_iterations:
        Set changed to false
        Set iteration to iteration plus 1
        
        For each constraint in system.constraints:
            Note: Simple constraint propagation based on constraint type
            If constraint.constraint_type is equal to "EQUALITY":
                Note: For equality constraints, narrow variable domains
                For each var_name in Dictionary.keys(updated_variables):
                    Let current_domain be Dictionary.get(updated_variables, var_name, create_entire_interval())
                    Let narrowed_domain be intersect(current_domain, constraint.target_interval)
                    If !is_empty(narrowed_domain) and width(narrowed_domain) is less than width(current_domain):
                        Set Dictionary.entry(updated_variables, var_name) to narrowed_domain
                        Set changed to true
            
            If constraint.constraint_type is equal to "INEQUALITY_LE":
                Note: For less-than-equal constraints, bound from above
                For each var_name in Dictionary.keys(updated_variables):
                    Let current_domain be Dictionary.get(updated_variables, var_name, create_entire_interval())
                    Let bounded_domain be {
                        "lower": current_domain.lower,
                        "upper": constraint.target_interval.upper,
                        "is_empty": false
                    }
                    Let final_domain be intersect(current_domain, bounded_domain)
                    If !is_empty(final_domain) and width(final_domain) is less than width(current_domain):
                        Set Dictionary.entry(updated_variables, var_name) to final_domain
                        Set changed to true
    
    Return {
        "constraints": system.constraints,
        "variables": updated_variables,
        "tolerance": system.tolerance
    }

Process called "box_consistency" that takes system as ConstraintSystem returns ConstraintSystem:
    Note: Applies box consistency algorithm to constraint system
    Note: Reduces variable intervals by eliminating inconsistent boundary values
    Let updated_variables be system.variables
    
    For each var_name in Dictionary.keys(updated_variables):
        Let current_interval be Dictionary.get(updated_variables, var_name, create_entire_interval())
        
        If is_empty(current_interval):
            Continue
        
        Note: Test left boundary consistency
        Let left_point be current_interval.lower
        Let left_consistent be true
        
        For each constraint in system.constraints:
            Note: Simple consistency check minus if constraint fails at boundary, mark inconsistent
            If constraint.constraint_type is equal to "EQUALITY":
                If !contains_point(constraint.target_interval, left_point):
                    Set left_consistent to false
                    Break
        
        Note: Test right boundary consistency
        Let right_point be current_interval.upper
        Let right_consistent be true
        
        For each constraint in system.constraints:
            If constraint.constraint_type is equal to "EQUALITY":
                If !contains_point(constraint.target_interval, right_point):
                    Set right_consistent to false
                    Break
        
        Note: Adjust interval boundaries based on consistency
        Let new_lower be current_interval.lower
        Let new_upper be current_interval.upper
        
        If !left_consistent:
            Set new_lower to new_lower plus system.tolerance
        
        If !right_consistent:
            Set new_upper to new_upper minus system.tolerance
        
        If new_lower is less than or equal to new_upper:
            Set Dictionary.entry(updated_variables, var_name) to create_interval(new_lower, new_upper)
        Otherwise:
            Set Dictionary.entry(updated_variables, var_name) to create_empty_interval()
    
    Return {
        "constraints": system.constraints,
        "variables": updated_variables,
        "tolerance": system.tolerance
    }

Process called "hull_consistency" that takes system as ConstraintSystem returns ConstraintSystem:
    Note: Applies hull consistency (2B-consistency) to constraint system
    Note: Stronger than box consistency, eliminates more inconsistent values
    Let box_consistent_system be box_consistency(system)
    Let updated_variables be box_consistent_system.variables
    
    Note: Apply additional hull consistency steps
    For each var_name1 in Dictionary.keys(updated_variables):
        For each var_name2 in Dictionary.keys(updated_variables):
            If var_name1 does not equal var_name2:
                Let interval1 be Dictionary.get(updated_variables, var_name1, create_entire_interval())
                Let interval2 be Dictionary.get(updated_variables, var_name2, create_entire_interval())
                
                If is_empty(interval1) or is_empty(interval2):
                    Continue
                
                Note: Check constraint consistency for variable pairs
                For each constraint in system.constraints:
                    If constraint.constraint_type is equal to "EQUALITY":
                        Note: Apply pairwise consistency reduction
                        Let intersection_result be intersect(interval1, interval2)
                        If !is_empty(intersection_result):
                            Let refined_interval1 be intersect(interval1, constraint.target_interval)
                            Let refined_interval2 be intersect(interval2, constraint.target_interval)
                            
                            If width(refined_interval1) is less than width(interval1):
                                Set Dictionary.entry(updated_variables, var_name1) to refined_interval1
                            
                            If width(refined_interval2) is less than width(interval2):
                                Set Dictionary.entry(updated_variables, var_name2) to refined_interval2
    
    Return {
        "constraints": system.constraints,
        "variables": updated_variables,
        "tolerance": system.tolerance
    }

Note: ===== GLOBAL OPTIMIZATION =====

Process called "minimize_function" that takes function as String, domain as IntervalVector, tolerance as BigDecimal returns OptimizationResult:
    Note: Finds global minimum using interval branch-and-bound algorithm
    Note: Provides guaranteed bounds on global optimum within tolerance
    Let working_boxes be [domain]
    Let best_upper_bound be 1.0e308
    Let best_minimizer be domain
    Let function_evaluations be 0
    Let max_iterations be 100
    Let iteration be 0
    
    While length(working_boxes) is greater than 0 and iteration is less than max_iterations:
        Set iteration to iteration plus 1
        Let current_box be List.get(working_boxes, 0)
        Set working_boxes to List.sublist(working_boxes, 1, length(working_boxes))
        
        Note: Evaluate inclusion function over current box
        Let function_range be compute_inclusion_function(function, current_box)
        Set function_evaluations to function_evaluations plus 1
        
        Note: Pruning test minus if lower bound is greater than current best, discard box
        If function_range.lower is greater than or equal to best_upper_bound:
            Continue
        
        Note: Update best upper bound if possible
        If function_range.upper is less than best_upper_bound:
            Set best_upper_bound to function_range.upper
            Set best_minimizer to current_box
        
        Note: Convergence test
        If vector_width(current_box) is less than tolerance:
            Continue
        
        Note: Bisect box and add sub-boxes to working list
        Let bisection_dim be 0
        Let max_width be 0.0
        For each i from 0 to current_box.dimension minus 1:
            Let component_width be width(List.get(current_box.components, i))
            If component_width is greater than max_width:
                Set max_width to component_width
                Set bisection_dim to i
        
        Let sub_boxes be bisect_box(current_box, bisection_dim)
        For each sub_box in sub_boxes:
            Append sub_box to working_boxes
    
    Let global_min_bound be create_interval(best_upper_bound minus tolerance, best_upper_bound plus tolerance)
    
    Return {
        "global_minimum": global_min_bound,
        "minimizer_box": best_minimizer,
        "function_evaluations": function_evaluations,
        "convergence_achieved": vector_width(best_minimizer) is less than tolerance
    }

Process called "maximize_function" that takes function as String, domain as IntervalVector, tolerance as BigDecimal returns OptimizationResult:
    Note: Finds global maximum by minimizing negative of function
    Note: Converts maximization to minimization problem
    Let negative_function be "-1 multiplied by (" plus function plus ")"
    Let min_result be minimize_function(negative_function, domain, tolerance)
    
    Note: Convert minimum result back to maximum
    Let max_interval be {
        "lower": -min_result.global_minimum.upper,
        "upper": -min_result.global_minimum.lower,
        "is_empty": false
    }
    
    Return {
        "global_minimum": max_interval,
        "minimizer_box": min_result.minimizer_box,
        "function_evaluations": min_result.function_evaluations,
        "convergence_achieved": min_result.convergence_achieved
    }

Process called "branch_and_bound_step" that takes boxes as Array[IntervalVector], function as String returns Array[IntervalVector]:
    Note: Performs single step of branch-and-bound algorithm
    Note: Subdivides boxes and eliminates non-optimal regions
    Let new_boxes be []
    Let global_lower_bound be 1.0e308
    
    Note: Find global lower bound across all boxes
    For each box in boxes:
        Let function_range be compute_inclusion_function(function, box)
        If function_range.lower is less than global_lower_bound:
            Set global_lower_bound to function_range.lower
    
    Note: Process each box
    For each box in boxes:
        Let function_range be compute_inclusion_function(function, box)
        
        Note: Pruning minus eliminate boxes that cannot contain global minimum
        If function_range.lower is greater than global_lower_bound plus 0.001:
            Continue
        
        Note: If box is small enough, keep as is
        If vector_width(box) is less than 0.01:
            Append box to new_boxes
            Continue
        
        Note: Bisect box along largest dimension
        Let largest_dim be 0
        Let max_width be 0.0
        For each i from 0 to box.dimension minus 1:
            Let comp_width be width(List.get(box.components, i))
            If comp_width is greater than max_width:
                Set max_width to comp_width
                Set largest_dim to i
        
        Let sub_boxes be bisect_box(box, largest_dim)
        For each sub_box in sub_boxes:
            Append sub_box to new_boxes
    
    Return new_boxes

Process called "compute_inclusion_function" that takes function as String, box as IntervalVector returns Interval:
    Note: Evaluates inclusion function for mathematical expression over interval box
    Note: Provides guaranteed bounds on function values over box
    Note: Simple inclusion function evaluation for basic expressions
    
    Note: Handle basic polynomial expressions
    If String.contains(function, "x^2"):
        Let x_interval be List.get(box.components, 0)
        Return square_interval(x_interval)
    
    If String.contains(function, "x plus y"):
        Let x_interval be List.get(box.components, 0)
        Let y_interval be List.get(box.components, 1)
        Return add_intervals(x_interval, y_interval)
    
    If String.contains(function, "x multiplied by y"):
        Let x_interval be List.get(box.components, 0)
        Let y_interval be List.get(box.components, 1)
        Return multiply_intervals(x_interval, y_interval)
    
    If String.contains(function, "sin(x)"):
        Let x_interval be List.get(box.components, 0)
        Return sin_interval(x_interval)
    
    If String.contains(function, "exp(x)"):
        Let x_interval be List.get(box.components, 0)
        Return exp_interval(x_interval)
    
    Note: Default to first component interval for simple cases
    If box.dimension is greater than 0:
        Return List.get(box.components, 0)
    
    Return create_entire_interval()

Note: ===== INTERVAL NEWTON METHODS =====

Process called "newton_step" that takes function as String, derivative as String, box as IntervalVector returns IntervalVector:
    Note: Performs interval Newton step for equation solving
    Note: Computes N(X) is equal to m minus f(m)/f'(X) ∩ X where m is box midpoint
    Let midpoint_vector be {
        "components": [],
        "dimension": box.dimension
    }
    
    Note: Compute midpoint of each component
    For each i from 0 to box.dimension minus 1:
        Let component_interval be List.get(box.components, i)
        Let mid_value be midpoint(component_interval)
        Let mid_interval be create_point_interval(mid_value)
        Append mid_interval to midpoint_vector.components
    
    Note: Evaluate function at midpoint
    Let f_at_midpoint be compute_inclusion_function(function, midpoint_vector)
    Let f_mid_value be midpoint(f_at_midpoint)
    
    Note: Evaluate derivative over entire box
    Let f_prime_over_box be compute_inclusion_function(derivative, box)
    
    Note: Compute Newton correction: -f(m)/f'(X)
    Let newton_correction_components be []
    
    For each i from 0 to box.dimension minus 1:
        Let correction_interval be divide_intervals(create_point_interval(-f_mid_value), f_prime_over_box)
        Append correction_interval to newton_correction_components
    
    Let newton_correction be {
        "components": newton_correction_components,
        "dimension": box.dimension
    }
    
    Note: Add correction to midpoint: m minus f(m)/f'(X)
    Let newton_result_components be []
    
    For each i from 0 to box.dimension minus 1:
        Let mid_component be List.get(midpoint_vector.components, i)
        Let correction_component be List.get(newton_correction.components, i)
        Let result_component be add_intervals(mid_component, correction_component)
        Append result_component to newton_result_components
    
    Let newton_result be {
        "components": newton_result_components,
        "dimension": box.dimension
    }
    
    Note: Intersect with original box
    Return intersect_boxes(newton_result, box)

Process called "solve_equation" that takes function as String, derivative as String, initial_box as IntervalVector, tolerance as BigDecimal returns Array[IntervalVector]:
    Note: Solves equation f(x) is equal to 0 using interval Newton method
    Note: Returns list of boxes guaranteed to contain all solutions
    Let working_boxes be [initial_box]
    Let solution_boxes be []
    Let max_iterations be 50
    Let iteration be 0
    
    While length(working_boxes) is greater than 0 and iteration is less than max_iterations:
        Set iteration to iteration plus 1
        Let current_box be List.get(working_boxes, 0)
        Set working_boxes to List.sublist(working_boxes, 1, length(working_boxes))
        
        Note: Check if function range contains zero
        Let function_range be compute_inclusion_function(function, current_box)
        If !contains_point(function_range, 0.0):
            Continue
        
        Note: Check convergence
        If vector_width(current_box) is less than tolerance:
            Append current_box to solution_boxes
            Continue
        
        Note: Apply Newton step
        Let newton_result be newton_step(function, derivative, current_box)
        
        Note: Check if Newton step made progress
        If vector_width(newton_result) is greater than or equal to vector_width(current_box):
            Note: Bisect box if Newton method stalls
            Let largest_dim be 0
            Let max_width be 0.0
            For each i from 0 to current_box.dimension minus 1:
                Let comp_width be width(List.get(current_box.components, i))
                If comp_width is greater than max_width:
                    Set max_width to comp_width
                    Set largest_dim to i
            
            Let sub_boxes be bisect_box(current_box, largest_dim)
            For each sub_box in sub_boxes:
                Append sub_box to working_boxes
        Otherwise:
            Append newton_result to working_boxes
    
    Note: Add any remaining boxes that are small enough
    For each remaining_box in working_boxes:
        If vector_width(remaining_box) is less than tolerance:
            Append remaining_box to solution_boxes
    
    Return solution_boxes

Process called "solve_system" that takes functions as Array[String], jacobian as Array[Array[String]], initial_box as IntervalVector, tolerance as BigDecimal returns Array[IntervalVector]:
    Note: Solves system of equations using multidimensional interval Newton
    Note: Handles nonlinear systems with guaranteed solution containment
    Let working_boxes be [initial_box]
    Let solution_boxes be []
    Let max_iterations be 30
    Let iteration be 0
    
    While length(working_boxes) is greater than 0 and iteration is less than max_iterations:
        Set iteration to iteration plus 1
        Let current_box be List.get(working_boxes, 0)
        Set working_boxes to List.sublist(working_boxes, 1, length(working_boxes))
        
        Note: Check if all function ranges contain zero
        Let all_contain_zero be true
        For each function in functions:
            Let function_range be compute_inclusion_function(function, current_box)
            If !contains_point(function_range, 0.0):
                Set all_contain_zero to false
                Break
        
        If !all_contain_zero:
            Continue
        
        Note: Check convergence
        If vector_width(current_box) is less than tolerance:
            Append current_box to solution_boxes
            Continue
        
        Note: Apply multidimensional Newton step (simplified)
        Let newton_improved be false
        
        Note: Try Newton step for each function individually
        For each func_index from 0 to length(functions) minus 1:
            Let function be List.get(functions, func_index)
            Let derivative_row be List.get(jacobian, func_index)
            
            If length(derivative_row) is greater than 0:
                Let derivative be List.get(derivative_row, 0)
                Let newton_result be newton_step(function, derivative, current_box)
                
                If vector_width(newton_result) is less than vector_width(current_box):
                    Set current_box to newton_result
                    Set newton_improved to true
                    Break
        
        If newton_improved:
            Append current_box to working_boxes
        Otherwise:
            Note: Bisect box if Newton method doesn't improve
            Let largest_dim be 0
            Let max_width be 0.0
            For each i from 0 to current_box.dimension minus 1:
                Let comp_width be width(List.get(current_box.components, i))
                If comp_width is greater than max_width:
                    Set max_width to comp_width
                    Set largest_dim to i
            
            Let sub_boxes be bisect_box(current_box, largest_dim)
            For each sub_box in sub_boxes:
                Append sub_box to working_boxes
    
    Return solution_boxes

Note: ===== VERIFICATION METHODS =====

Process called "verify_inequality" that takes expression as String, domain as IntervalVector returns VerificationResult:
    Note: Verifies mathematical inequality over given domain
    Note: Provides rigorous proof or counterexample using interval evaluation
    Let working_boxes be [domain]
    Let counterexample_found be false
    Let counterexample_box be create_interval_vector([])
    Let max_subdivisions be 100
    Let subdivision_count be 0
    
    While length(working_boxes) is greater than 0 and !counterexample_found and subdivision_count is less than max_subdivisions:
        Let current_box be List.get(working_boxes, 0)
        Set working_boxes to List.sublist(working_boxes, 1, length(working_boxes))
        
        Let expression_range be compute_inclusion_function(expression, current_box)
        
        Note: If expression is always positive over box, inequality holds
        If expression_range.lower is greater than or equal to 0.0:
            Continue
        
        Note: If expression is always negative over box, inequality fails
        If expression_range.upper is less than or equal to 0.0:
            Set counterexample_found to true
            Set counterexample_box to current_box
            Break
        
        Note: Expression range contains zero, need to subdivide
        If vector_width(current_box) is less than 1.0e-6:
            Note: Box too small to subdivide further, assume inequality holds
            Continue
        
        Set subdivision_count to subdivision_count plus 1
        
        Let largest_dim be 0
        Let max_width be 0.0
        For each i from 0 to current_box.dimension minus 1:
            Let comp_width be width(List.get(current_box.components, i))
            If comp_width is greater than max_width:
                Set max_width to comp_width
                Set largest_dim to i
        
        Let sub_boxes be bisect_box(current_box, largest_dim)
        For each sub_box in sub_boxes:
            Append sub_box to working_boxes
    
    Return {
        "is_verified": !counterexample_found,
        "counterexample_box": counterexample_box,
        "confidence_level": 0.95
    }

Process called "verify_function_monotonicity" that takes function as String, derivative as String, domain as IntervalVector returns VerificationResult:
    Note: Verifies function monotonicity using interval derivative bounds
    Note: Checks if derivative maintains consistent sign over domain
    Let working_boxes be [domain]
    Let monotonic be true
    Let counterexample_box be create_interval_vector([])
    Let max_subdivisions be 50
    Let subdivision_count be 0
    
    While length(working_boxes) is greater than 0 and monotonic and subdivision_count is less than max_subdivisions:
        Let current_box be List.get(working_boxes, 0)
        Set working_boxes to List.sublist(working_boxes, 1, length(working_boxes))
        
        Let derivative_range be compute_inclusion_function(derivative, current_box)
        
        Note: If derivative is always positive, function is increasing
        If derivative_range.lower is greater than or equal to 0.0:
            Continue
        
        Note: If derivative is always negative, function is decreasing
        If derivative_range.upper is less than or equal to 0.0:
            Continue
        
        Note: Derivative changes sign, check if we can subdivide further
        If vector_width(current_box) is less than 1.0e-6:
            Set monotonic to false
            Set counterexample_box to current_box
            Break
        
        Set subdivision_count to subdivision_count plus 1
        
        Let largest_dim be 0
        Let max_width be 0.0
        For each i from 0 to current_box.dimension minus 1:
            Let comp_width be width(List.get(current_box.components, i))
            If comp_width is greater than max_width:
                Set max_width to comp_width
                Set largest_dim to i
        
        Let sub_boxes be bisect_box(current_box, largest_dim)
        For each sub_box in sub_boxes:
            Append sub_box to working_boxes
    
    Return {
        "is_verified": monotonic,
        "counterexample_box": counterexample_box,
        "confidence_level": 0.9
    }

Process called "verify_function_convexity" that takes function as String, second_derivative as String, domain as IntervalVector returns VerificationResult:
    Note: Verifies function convexity using second derivative sign
    Note: Checks if second derivative is non-negative over entire domain
    Let working_boxes be [domain]
    Let convex be true
    Let counterexample_box be create_interval_vector([])
    Let max_subdivisions be 50
    Let subdivision_count be 0
    
    While length(working_boxes) is greater than 0 and convex and subdivision_count is less than max_subdivisions:
        Let current_box be List.get(working_boxes, 0)
        Set working_boxes to List.sublist(working_boxes, 1, length(working_boxes))
        
        Let second_derivative_range be compute_inclusion_function(second_derivative, current_box)
        
        Note: If second derivative is always non-negative, function is convex on this box
        If second_derivative_range.lower is greater than or equal to 0.0:
            Continue
        
        Note: If second derivative is definitely negative, function is not convex
        If second_derivative_range.upper is less than 0.0:
            Set convex to false
            Set counterexample_box to current_box
            Break
        
        Note: Second derivative range contains zero, subdivide if possible
        If vector_width(current_box) is less than 1.0e-6:
            Note: Cannot subdivide further, assume convex for small intervals
            Continue
        
        Set subdivision_count to subdivision_count plus 1
        
        Let largest_dim be 0
        Let max_width be 0.0
        For each i from 0 to current_box.dimension minus 1:
            Let comp_width be width(List.get(current_box.components, i))
            If comp_width is greater than max_width:
                Set max_width to comp_width
                Set largest_dim to i
        
        Let sub_boxes be bisect_box(current_box, largest_dim)
        For each sub_box in sub_boxes:
            Append sub_box to working_boxes
    
    Return {
        "is_verified": convex,
        "counterexample_box": counterexample_box,
        "confidence_level": 0.9
    }

Process called "bound_function_range" that takes function as String, domain as IntervalVector returns Interval:
    Note: Computes guaranteed bounds on function range over domain
    Note: Uses inclusion functions and subdivision for tight bounds
    Let working_boxes be [domain]
    Let overall_range be create_empty_interval()
    Let max_subdivisions be 50
    Let subdivision_count be 0
    
    While length(working_boxes) is greater than 0 and subdivision_count is less than max_subdivisions:
        Let current_box be List.get(working_boxes, 0)
        Set working_boxes to List.sublist(working_boxes, 1, length(working_boxes))
        
        Let function_range be compute_inclusion_function(function, current_box)
        Set overall_range to hull(overall_range, function_range)
        
        Note: Subdivide box if it's still large
        If vector_width(current_box) is greater than 0.1 and subdivision_count is less than max_subdivisions:
            Set subdivision_count to subdivision_count plus 1
            
            Let largest_dim be 0
            Let max_width be 0.0
            For each i from 0 to current_box.dimension minus 1:
                Let comp_width be width(List.get(current_box.components, i))
                If comp_width is greater than max_width:
                    Set max_width to comp_width
                    Set largest_dim to i
            
            Let sub_boxes be bisect_box(current_box, largest_dim)
            For each sub_box in sub_boxes:
                Append sub_box to working_boxes
    
    Return overall_range

Note: ===== MULTIDIMENSIONAL OPERATIONS =====

Process called "create_interval_vector" that takes components as Array[Interval] returns IntervalVector:
    Note: Creates multidimensional interval vector (box) from component intervals
    Note: Used for representing multivariable uncertainty and domains
    Return {
        "components": components,
        "dimension": length(components)
    }

Process called "vector_width" that takes box as IntervalVector returns BigDecimal:
    Note: Computes width of interval vector (maximum component width)
    Note: Measure of overall uncertainty in multidimensional problem
    Let max_width be 0.0
    
    For each component in box.components:
        Let component_width be width(component)
        If component_width is greater than max_width:
            Set max_width to component_width
    
    Return max_width

Process called "vector_volume" that takes box as IntervalVector returns BigDecimal:
    Note: Computes volume of interval vector (product of component widths)
    Note: Total hypervolume of uncertainty region
    Let volume be 1.0
    
    For each component in box.components:
        If is_empty(component):
            Return 0.0
        
        Let component_width be width(component)
        Set volume to volume multiplied by component_width
    
    Return volume

Process called "bisect_box" that takes box as IntervalVector, dimension as Integer returns Array[IntervalVector]:
    Note: Bisects interval vector along specified dimension
    Note: Creates two sub-boxes by splitting largest interval component
    If dimension is less than 0 or dimension is greater than or equal to box.dimension:
        Return [box]
    
    Let target_component be List.get(box.components, dimension)
    
    If is_empty(target_component) or is_point(target_component):
        Return [box]
    
    Let mid_value be midpoint(target_component)
    Let left_component be create_interval(target_component.lower, mid_value)
    Let right_component be create_interval(mid_value, target_component.upper)
    
    Note: Create left sub-box
    Let left_components be []
    For each i from 0 to box.dimension minus 1:
        If i is equal to dimension:
            Append left_component to left_components
        Otherwise:
            Append List.get(box.components, i) to left_components
    
    Let left_box be {
        "components": left_components,
        "dimension": box.dimension
    }
    
    Note: Create right sub-box
    Let right_components be []
    For each i from 0 to box.dimension minus 1:
        If i is equal to dimension:
            Append right_component to right_components
        Otherwise:
            Append List.get(box.components, i) to right_components
    
    Let right_box be {
        "components": right_components,
        "dimension": box.dimension
    }
    
    Return [left_box, right_box]

Process called "intersect_boxes" that takes a as IntervalVector, b as IntervalVector returns IntervalVector:
    Note: Computes componentwise intersection of interval vectors
    Note: Returns box containing points in both input boxes
    If a.dimension does not equal b.dimension:
        Return create_interval_vector([])
    
    Let intersection_components be []
    
    For each i from 0 to a.dimension minus 1:
        Let component_a be List.get(a.components, i)
        Let component_b be List.get(b.components, i)
        Let intersection_component be intersect(component_a, component_b)
        Append intersection_component to intersection_components
    
    Return {
        "components": intersection_components,
        "dimension": a.dimension
    }

Process called "hull_boxes" that takes a as IntervalVector, b as IntervalVector returns IntervalVector:
    Note: Computes componentwise hull of interval vectors
    Note: Returns smallest box containing both input boxes
    If a.dimension does not equal b.dimension:
        Return a
    
    Let hull_components be []
    
    For each i from 0 to a.dimension minus 1:
        Let component_a be List.get(a.components, i)
        Let component_b be List.get(b.components, i)
        Let hull_component be hull(component_a, component_b)
        Append hull_component to hull_components
    
    Return {
        "components": hull_components,
        "dimension": a.dimension
    }

Note: ===== UTILITY AND CONVERSION OPERATIONS =====

Process called "is_empty" that takes interval as Interval returns Boolean:
    Note: Tests if interval is empty (contains no values)
    Note: Empty intervals represent impossible or contradictory constraints
    Return interval.is_empty

Process called "is_point" that takes interval as Interval returns Boolean:
    Note: Tests if interval is degenerate (lower is equal to upper)
    Note: Point intervals represent exactly determined values
    If interval.is_empty:
        Return false
    
    Return interval.lower is equal to interval.upper

Process called "is_bounded" that takes interval as Interval returns Boolean:
    Note: Tests if interval has finite bounds
    Note: Unbounded intervals contain infinite values
    If interval.is_empty:
        Return true
    
    Return interval.lower is greater than -1.0e308 and interval.upper is less than 1.0e308

Process called "to_string" that takes interval as Interval returns String:
    Note: Converts interval to string representation [lower, upper]
    Note: Uses mathematical interval notation for display
    If interval.is_empty:
        Return "∅"
    
    If is_point(interval):
        Return "[" plus String.from_number(interval.lower) plus "]"
    
    Return "[" plus String.from_number(interval.lower) plus ", " plus String.from_number(interval.upper) plus "]"

Process called "from_string" that takes text as String returns Interval:
    Note: Parses interval from string representation
    Note: Handles various formats including [a,b], (a,b), [a,b)
    Let trimmed_text be String.trim(text)
    
    Note: Handle empty interval
    If trimmed_text is equal to "∅" or trimmed_text is equal to "empty":
        Return create_empty_interval()
    
    Note: Handle point interval [x]
    If String.starts_with(trimmed_text, "[") and String.ends_with(trimmed_text, "]") and !String.contains(trimmed_text, ","):
        Let inner_text be String.substring(trimmed_text, 1, String.length(trimmed_text) minus 1)
        Let value be String.to_number(String.trim(inner_text))
        Return create_point_interval(value)
    
    Note: Handle regular interval [a, b]
    If String.starts_with(trimmed_text, "[") and String.ends_with(trimmed_text, "]"):
        Let inner_text be String.substring(trimmed_text, 1, String.length(trimmed_text) minus 1)
        If String.contains(inner_text, ","):
            Let parts be String.split(inner_text, ",")
            If length(parts) is equal to 2:
                Let lower_str be String.trim(List.get(parts, 0))
                Let upper_str be String.trim(List.get(parts, 1))
                Let lower_val be String.to_number(lower_str)
                Let upper_val be String.to_number(upper_str)
                Return create_interval(lower_val, upper_val)
    
    Note: Handle open interval (a, b)
    If String.starts_with(trimmed_text, "(") and String.ends_with(trimmed_text, ")"):
        Let inner_text be String.substring(trimmed_text, 1, String.length(trimmed_text) minus 1)
        If String.contains(inner_text, ","):
            Let parts be String.split(inner_text, ",")
            If length(parts) is equal to 2:
                Let lower_str be String.trim(List.get(parts, 0))
                Let upper_str be String.trim(List.get(parts, 1))
                Let lower_val be String.to_number(lower_str) plus 1.0e-10
                Let upper_val be String.to_number(upper_str) minus 1.0e-10
                Return create_interval(lower_val, upper_val)
    
    Note: Default to empty interval for unrecognized format
    Return create_empty_interval()