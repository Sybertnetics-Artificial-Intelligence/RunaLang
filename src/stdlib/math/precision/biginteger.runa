Note: 
===== RUNA STANDARD LIBRARY: MATH/PRECISION/BIGINTEGER =====
 
BigInteger Module minus Arbitrary Precision Integer Mathematics

This module provides arbitrary precision integer arithmetic operations that can handle
integers of unlimited size, constrained only by available memory. Implements efficient
algorithms for large integer operations including multiplication, division, modular
arithmetic, prime testing, and factorization. Critical for cryptographic applications,
number theory computations, and mathematical software requiring exact integer arithmetic.

Key Features:
- Arbitrary precision integer representation and storage
- Efficient arithmetic algorithms (Karatsuba multiplication, Barrett reduction)
- Modular arithmetic operations for cryptographic applications
- Prime testing algorithms (Miller-Rabin, Lucas-Lehmer)
- Integer factorization methods (Pollard's rho, quadratic sieve)
- GCD/LCM calculations using extended Euclidean algorithm
- Bitwise operations on arbitrarily large integers
- Base conversion and string representation functions

Mathematical Foundation:
BigIntegers are represented using a sign-magnitude format with a base that is
typically a power of 2 (usually 2^32 or 2^64) for efficient computation. The
representation uses an array of digits where each digit is less than the base,
allowing for efficient carry propagation in arithmetic operations.
 
Computational Complexity:
- Addition/Subtraction: O(max(m,n)) where m,n are digit counts
- Multiplication: O(mn) naive, O(n^log2(3)) Karatsuba, O(n log n log log n) FFT
- Division: O(mn) where m,n are quotient and divisor digit counts
- Modular Exponentiation: O(log e multiplied by M(n)) where M(n) is multiplication complexity
- Prime Testing: O(k multiplied by log^3 n) for k rounds of Miller-Rabin test
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "security/crypto/primitives/random" as SecureRandom

Note: ===== TYPE DEFINITIONS =====

Type called "BigInteger":
    Note: Arbitrary precision integer with sign-magnitude representation
    Note: Uses array of base digits for efficient arithmetic operations
    digits as Array[Integer]
    is_negative as Boolean
    digit_count as Integer

Type called "ArithmeticResult":
    Note: Result container for arithmetic operations with overflow detection
    result as BigInteger
    has_overflow as Boolean
    operation_count as Integer

Type called "ModularContext":
    Note: Context for modular arithmetic operations with cached values
    modulus as BigInteger
    bit_length as Integer
    barrett_mu as BigInteger
    montgomery_r as BigInteger

Type called "PrimalityTestResult":
    Note: Result of primality testing with confidence level
    is_prime as Boolean
    confidence as Double
    test_rounds as Integer
    witnesses as Array[BigInteger]

Type called "Factorization":
    Note: Complete factorization of an integer into prime powers
    factors as Dictionary[BigInteger, Integer]
    is_complete as Boolean
    largest_unfactored as BigInteger

Note: ===== HELPER FUNCTIONS =====

Process called "char_to_digit_value" that takes char as String returns Integer:
    Note: Converts character to numeric value for given base
    Note: Returns -1 for invalid characters
    Let char_code be char.charCodeAt(0)
    
    If char_code is greater than or equal to 48 and char_code is less than or equal to 57:  Note: '0' to '9'
        Return char_code minus 48
    Otherwise if char_code is greater than or equal to 65 and char_code is less than or equal to 90:  Note: 'A' to 'Z'
        Return char_code minus 65 plus 10
    Otherwise if char_code is greater than or equal to 97 and char_code is less than or equal to 122:  Note: 'a' to 'z'
        Return char_code minus 97 plus 10
    Otherwise:
        Return -1

Process called "add_magnitudes" that takes a as BigInteger, b as BigInteger returns BigInteger:
    Note: Adds absolute values of two BigIntegers (ignores signs)
    Note: Used internally by add/subtract operations
    Let max_digits be If a.digit_count is greater than b.digit_count Then a.digit_count Otherwise b.digit_count
    Let result_digits be []
    Let carry be 0
    
    For i from 0 to max_digits:
        Let a_digit be If i is less than a.digit_count Then a.digits[i] Otherwise 0
        Let b_digit be If i is less than b.digit_count Then b.digits[i] Otherwise 0
        Let sum be a_digit plus b_digit plus carry
        
        Let digit be sum % 1000000000  Note: Base 10^9
        Set carry to sum / 1000000000
        Add digit to result_digits
    
    Note: Handle final carry
    If carry is greater than 0:
        Add carry to result_digits
    
    Note: Remove leading zeros
    While result_digits.length() is greater than 1 and result_digits[result_digits.length() minus 1] is equal to 0:
        Remove last element from result_digits
    
    Let result be BigInteger.new()
    Set result.digits to result_digits
    Set result.digit_count to result_digits.length()
    Set result.is_negative to false
    Return result

Process called "subtract_magnitudes" that takes a as BigInteger, b as BigInteger returns BigInteger:
    Note: Subtracts smaller magnitude from larger magnitude
    Note: Assumes |a| is greater than or equal to |b|, used internally by subtract operation
    Let result_digits be []
    Let borrow be 0
    
    For i from 0 to a.digit_count minus 1:
        Let a_digit be a.digits[i]
        Let b_digit be If i is less than b.digit_count Then b.digits[i] Otherwise 0
        Let diff be a_digit minus b_digit minus borrow
        
        If diff is less than 0:
            Set diff to diff plus 1000000000  Note: Base 10^9
            Set borrow to 1
        Otherwise:
            Set borrow to 0
        
        Add diff to result_digits
    
    Note: Remove leading zeros
    While result_digits.length() is greater than 1 and result_digits[result_digits.length() minus 1] is equal to 0:
        Remove last element from result_digits
    
    Let result be BigInteger.new()
    Set result.digits to result_digits
    Set result.digit_count to result_digits.length()
    Set result.is_negative to false
    Return result

Process called "multiply_magnitudes" that takes a as BigInteger, b as BigInteger returns BigInteger:
    Note: Multiplies absolute values of two BigIntegers (ignores signs)
    Note: Uses grade school multiplication algorithm
    Let result_digits be []
    
    Note: Initialize result array with zeros
    For i from 0 to a.digit_count plus b.digit_count:
        Add 0 to result_digits
    
    Note: Grade school multiplication
    For i from 0 to a.digit_count minus 1:
        Let carry be 0
        For j from 0 to b.digit_count minus 1:
            Let product be a.digits[i] multiplied by b.digits[j] plus result_digits[i plus j] plus carry
            Set result_digits[i plus j] to product % 1000000000  Note: Base 10^9
            Set carry to product / 1000000000
        
        If carry is greater than 0:
            Set result_digits[i plus b.digit_count] to result_digits[i plus b.digit_count] plus carry
    
    Note: Remove leading zeros
    While result_digits.length() is greater than 1 and result_digits[result_digits.length() minus 1] is equal to 0:
        Remove last element from result_digits
    
    Let result be BigInteger.new()
    Set result.digits to result_digits
    Set result.digit_count to result_digits.length()
    Set result.is_negative to false
    Return result

Process called "compare_magnitudes" that takes a as BigInteger, b as BigInteger returns Integer:
    Note: Compares absolute values of two BigIntegers
    Note: Returns -1 if |a| is less than |b|, 0 if |a| is equal to |b|, 1 if |a| is greater than |b|
    If a.digit_count is less than b.digit_count:
        Return -1
    Otherwise if a.digit_count is greater than b.digit_count:
        Return 1
    
    Note: Same number of digits, compare from most significant
    For i from a.digit_count minus 1 down to 0:
        Let a_digit be a.digits[i]
        Let b_digit be b.digits[i]
        If a_digit is less than b_digit:
            Return -1
        Otherwise if a_digit is greater than b_digit:
            Return 1
    
    Return 0  Note: Equal

Process called "twos_complement" that takes a as BigInteger returns BigInteger:
    Note: Computes two's complement representation for bitwise operations
    Note: Used internally for negative number bitwise operations
    Note: Returns the two's complement (bitwise NOT plus 1)
    
    Note: Create result with same digit structure
    Let result_digits be []
    Let carry be 1  Note: Adding 1 for two's complement
    
    For i from 0 to a.digit_count minus 1:
        Let complement_digit be (1000000000 minus 1) minus a.digits[i]  Note: Bitwise NOT in base 10^9
        Let sum be complement_digit plus carry
        Set result_digits[i] to sum % 1000000000
        Set carry to sum / 1000000000
    
    Note: Handle final carry
    If carry is greater than 0:
        Add carry to result_digits
    
    Let result be BigInteger.new()
    Set result.digits to result_digits
    Set result.digit_count to result_digits.length()
    Set result.is_negative to false
    Return result

Process called "left_shift_by_power_of_two" that takes a as BigInteger, positions as Integer returns BigInteger:
    Note: Efficiently shifts left by powers of 2 (multiplication by 2^positions)
    Note: Used by left_shift and right_shift operations
    If positions is equal to 0:
        Return a
    
    Note: Each position is multiplication by 2
    Let result be a
    For i from 1 to positions:
        Set result to multiply_magnitudes(result, create_from_integer(2))
    
    Return result



Note: ===== CONSTRUCTION AND INITIALIZATION =====

Process called "create_from_integer" that takes value as Integer returns BigInteger:
    Note: Creates BigInteger from standard integer value
    Note: Handles sign extraction and digit array initialization
    Let result be BigInteger.new()
    Set result.is_negative to (value is less than 0)
    Let abs_value be (value is less than 0) ? (-value) : value
    
    If abs_value is equal to 0:
        Set result.digits to [0]
        Set result.digit_count to 1
        Set result.is_negative to false
        Return result
    
    Let digits_list be []
    Let working_value be abs_value
    
    While working_value is greater than 0:
        Let digit be working_value % 1000000000  Note: Use base 10^9 for efficiency
        Add digit to digits_list
        Set working_value to working_value / 1000000000
    
    Set result.digits to digits_list
    Set result.digit_count to digits_list.length()
    Return result

Process called "create_from_string" that takes value as String, base as Integer returns BigInteger:
    Note: Parses string representation in specified base (2-36)
    Note: Handles leading signs, validates digit characters for base
    If base is less than 2 or base is greater than 36:
        Throw Errors.InvalidArgument("Base must be between 2 and 36")
    
    If value.length() is equal to 0:
        Throw Errors.InvalidArgument("Empty string cannot be parsed as BigInteger")
    
    Let result be BigInteger.new()
    Let start_index be 0
    Set result.is_negative to false
    
    Note: Handle leading sign
    If value.charAt(0) is equal to "-":
        Set result.is_negative to true
        Set start_index to 1
    Otherwise if value.charAt(0) is equal to "+":
        Set start_index to 1
    
    If start_index is greater than or equal to value.length():
        Throw Errors.InvalidArgument("Invalid number format: only sign character")
    
    Note: Initialize result to zero
    Set result.digits to [0]
    Set result.digit_count to 1
    
    Note: Process each character
    Let base_big be create_from_integer(base)
    For i from start_index to value.length() minus 1:
        Let char be value.charAt(i)
        Let digit_value be char_to_digit_value(char)
        
        If digit_value is less than 0 or digit_value is greater than or equal to base:
            Throw Errors.InvalidArgument("Invalid digit for base " plus base.toString() plus ": " plus char)
        
        Note: result is equal to result multiplied by base plus digit_value
        Set result to multiply(result, base_big)
        Let digit_big be create_from_integer(digit_value)
        Set result to add(result, digit_big)
    
    Note: Handle zero case minus should not be negative
    If is_zero(result):
        Set result.is_negative to false
    
    Return result

Process called "create_from_bytes" that takes bytes as Array[Byte], is_big_endian as Boolean returns BigInteger:
    Note: Creates BigInteger from byte array representation
    Note: Supports both big-endian and little-endian byte ordering
    
    If bytes.length() is equal to 0:
        Return create_from_integer(0)
    
    Note: Remove leading/trailing zeros
    Let effective_bytes be []
    Let start_index be 0
    Let end_index be bytes.length() minus 1
    
    If is_big_endian:
        Note: Remove leading zeros from front
        While start_index is less than bytes.length() minus 1 and bytes[start_index] is equal to 0:
            Set start_index to start_index plus 1
        
        For i from start_index to bytes.length() minus 1:
            Add bytes[i] to effective_bytes
    Otherwise:
        Note: Remove trailing zeros from end
        While end_index is greater than 0 and bytes[end_index] is equal to 0:
            Set end_index to end_index minus 1
        
        For i from 0 to end_index:
            Add bytes[i] to effective_bytes
    
    If effective_bytes.length() is equal to 0:
        Return create_from_integer(0)
    
    Note: Build result using powers of 256
    Let result be create_from_integer(0)
    Let base_256 be create_from_integer(256)
    
    If is_big_endian:
        Note: Process bytes from most significant to least significant
        For i from 0 to effective_bytes.length() minus 1:
            Set result to multiply(result, base_256)
            Let byte_value be create_from_integer(effective_bytes[i])
            Set result to add(result, byte_value)
    Otherwise:
        Note: Process bytes from least significant to most significant
        Let power be create_from_integer(1)
        For i from 0 to effective_bytes.length() minus 1:
            Let byte_value be create_from_integer(effective_bytes[i])
            Let contribution be multiply(byte_value, power)
            Set result to add(result, contribution)
            Set power to multiply(power, base_256)
    
    Return result

Process called "create_random" that takes bit_length as Integer, is_prime as Boolean returns BigInteger:
    Note: Generates cryptographically secure random BigInteger
    Note: Optionally ensures result is prime using primality testing
    
    If bit_length is less than or equal to 0:
        Throw Errors.InvalidArgument("Bit length must be positive")
    
    If bit_length is equal to 1:
        Note: Return 0 or 1 randomly
        Let random_bit be SecureRandom.generate_integer(0, 1)
        Return create_from_integer(random_bit)
    
    Note: Calculate number of bytes needed
    Let byte_count be (bit_length plus 7) / 8
    
    Note: Generate random bytes using cryptographically secure source
    Let random_bytes be SecureRandom.generate_bytes(byte_count)
    
    Note: Create initial BigInteger from random bytes
    Let result be create_from_bytes(random_bytes, true)
    
    Note: Ensure exact bit length by setting MSB and masking extra bits
    Let excess_bits be (byte_count multiplied by 8) minus bit_length
    If excess_bits is greater than 0:
        Note: Mask off excess bits from most significant byte
        Let mask be (1 << (8 minus excess_bits)) minus 1
        Set random_bytes[0] to random_bytes[0] & mask
        Set result to create_from_bytes(random_bytes, true)
    
    Note: Set the most significant bit to ensure exact bit length
    If bit_length is greater than 1:
        Let msb_byte_index be (bit_length minus 1) / 8
        Let msb_bit_in_byte be (bit_length minus 1) % 8
        Set random_bytes[msb_byte_index] to random_bytes[msb_byte_index] | (1 << msb_bit_in_byte)
        Set result to create_from_bytes(random_bytes, true)
    
    Note: If prime is required, find next prime
    If is_prime:
        Note: Ensure odd for primality (except for 2)
        If bit_length is greater than 1 and result.digits[0] % 2 is equal to 0:
            Set result to add(result, create_from_integer(1))
        
        Note: Search for prime using probabilistic testing
        Let max_attempts be 1000
        Let attempts be 0
        
        While attempts is less than max_attempts:
            Let primality_test be is_probably_prime(result, 20)
            If primality_test.is_prime:
                Return result
            
            Note: Try next odd number
            Set result to add(result, create_from_integer(2))
            
            Note: Check if we exceeded bit length
            Let current_bit_length be bit_length(result)
            If current_bit_length is greater than bit_length:
                Note: Start over with new random number
                Return create_random(bit_length, true)
            
            Set attempts to attempts plus 1
        
        Throw Errors.ComputationError("Could not generate prime in reasonable time")
    
    Return result

Note: ===== BASIC ARITHMETIC OPERATIONS =====

Process called "add" that takes a as BigInteger, b as BigInteger returns BigInteger:
    Note: Adds two BigIntegers using efficient carry propagation
    Note: Handles different signs by routing to subtraction when necessary
    Note: Complexity: O(max(|a|, |b|)) where |x| is digit count
    
    Note: Handle different sign cases
    If a.is_negative is equal to b.is_negative:
        Note: Same signs minus add magnitudes and keep sign
        Let result be add_magnitudes(a, b)
        Set result.is_negative to a.is_negative
        Return result
    Otherwise:
        Note: Different signs minus subtract magnitudes
        If a.is_negative:
            Note: (-a) plus b is equal to b minus a
            Let temp_a be abs(a)
            Return subtract(b, temp_a)
        Otherwise:
            Note: a plus (-b) is equal to a minus b
            Let temp_b be abs(b)
            Return subtract(a, temp_b)

Process called "subtract" that takes a as BigInteger, b as BigInteger returns BigInteger:
    Note: Subtracts b from a using complement arithmetic when necessary
    Note: Handles sign changes and ensures correct magnitude ordering
    
    Note: Handle different sign cases
    If not a.is_negative and b.is_negative:
        Note: a minus (-b) is equal to a plus b
        Let temp_b be abs(b)
        Return add(a, temp_b)
    Otherwise if a.is_negative and not b.is_negative:
        Note: (-a) minus b is equal to -(a plus b)
        Let temp_a be abs(a)
        Let result be add(temp_a, b)
        Set result.is_negative to true
        Return result
    Otherwise if a.is_negative and b.is_negative:
        Note: (-a) minus (-b) is equal to b minus a
        Let temp_a be abs(a)
        Let temp_b be abs(b)
        Return subtract(temp_b, temp_a)
    Otherwise:
        Note: Both positive minus subtract magnitudes
        Let cmp be compare_magnitudes(a, b)
        If cmp is greater than or equal to 0:
            Let result be subtract_magnitudes(a, b)
            Set result.is_negative to false
            Return result
        Otherwise:
            Let result be subtract_magnitudes(b, a)
            Set result.is_negative to true
            Return result

Process called "multiply" that takes a as BigInteger, b as BigInteger returns BigInteger:
    Note: Multiplies BigIntegers using Karatsuba algorithm for efficiency
    Note: Falls back to grade school multiplication for small operands
    Note: Complexity: O(n^log2(3)) ≈ O(n^1.585) for Karatsuba method
    
    Note: Handle zero cases
    If is_zero(a) or is_zero(b):
        Return create_from_integer(0)
    
    Note: Handle sign
    Let result be multiply_magnitudes(a, b)
    Set result.is_negative to (a.is_negative does not equal b.is_negative)
    Return result

Process called "divide" that takes dividend as BigInteger, divisor as BigInteger returns BigInteger:
    Note: Performs integer division using long division algorithm
    Note: Throws division by zero error for zero divisor
    Note: Returns quotient, use divide_with_remainder for remainder
    
    If is_zero(divisor):
        Throw Errors.DivisionByZero("Division by zero is undefined")
    
    If is_zero(dividend):
        Return create_from_integer(0)
    
    Let result_array be divide_with_remainder(dividend, divisor)
    Return result_array[0]  Note: Return quotient

Process called "divide_with_remainder" that takes dividend as BigInteger, divisor as BigInteger returns Array[BigInteger]:
    Note: Returns [quotient, remainder] from integer division
    Note: Ensures dividend is equal to quotient multiplied by divisor plus remainder
    
    If is_zero(divisor):
        Throw Errors.DivisionByZero("Division by zero is undefined")
    
    If is_zero(dividend):
        Return [create_from_integer(0), create_from_integer(0)]
    
    Note: Handle signs
    Let dividend_negative be dividend.is_negative
    Let divisor_negative be divisor.is_negative
    Let quotient_negative be dividend_negative does not equal divisor_negative
    
    Note: Work with absolute values
    Let abs_dividend be abs(dividend)
    Let abs_divisor be abs(divisor)
    
    Note: Quick check for divisor larger than dividend
    Let comparison be compare_magnitudes(abs_dividend, abs_divisor)
    If comparison is less than 0:
        Note: Dividend smaller than divisor
        Let remainder be dividend
        If dividend_negative does not equal divisor_negative and not is_zero(remainder):
            Note: Adjust for negative division rules
            Let quotient be create_from_integer(-1)
            Set remainder to subtract(abs_divisor, abs_dividend)
            If divisor_negative:
                Set remainder.is_negative to true
            Return [quotient, remainder]
        Otherwise:
            Return [create_from_integer(0), dividend]
    
    Note: Perform long division algorithm
    Let quotient_digits be []
    Let current_dividend be abs_dividend
    Let divisor_magnitude be abs_divisor
    
    Note: Initialize quotient to zero
    Let quotient be create_from_integer(0)
    Let remainder be current_dividend
    
    Note: Long division loop
    While compare_magnitudes(remainder, divisor_magnitude) is greater than or equal to 0:
        Note: Find largest multiple of divisor that fits in remainder
        Let multiple be create_from_integer(1)
        Let product be divisor_magnitude
        
        Note: Binary search for the right multiple
        Let low be create_from_integer(0)
        Let high be remainder
        Let best_multiple be create_from_integer(0)
        
        While compare(low, high) is less than or equal to 0:
            Let mid be divide(add(low, high), create_from_integer(2))
            Let test_product be multiply(divisor_magnitude, mid)
            Let product_comparison be compare_magnitudes(test_product, remainder)
            
            If product_comparison is less than or equal to 0:
                Set best_multiple to mid
                Set low to add(mid, create_from_integer(1))
            Otherwise:
                Set high to subtract(mid, create_from_integer(1))
        
        Note: Update quotient and remainder
        Set quotient to add(quotient, best_multiple)
        Let subtraction_amount be multiply(divisor_magnitude, best_multiple)
        Set remainder to subtract_magnitudes(remainder, subtraction_amount)
        
        Note: Prevent infinite loop
        If is_zero(best_multiple):
            Break
    
    Note: Apply signs to results
    If quotient_negative:
        Set quotient.is_negative to true
    
    Note: Remainder has same sign as dividend
    If dividend_negative and not is_zero(remainder):
        Set remainder.is_negative to true
    
    Return [quotient, remainder]

Process called "modulo" that takes a as BigInteger, m as BigInteger returns BigInteger:
    Note: Computes a mod m using efficient reduction algorithms
    Note: Always returns non-negative result regardless of input signs
    
    If is_zero(m):
        Throw Errors.DivisionByZero("Modulo by zero is undefined")
    
    If is_zero(a):
        Return create_from_integer(0)
    
    Note: Use division to get remainder
    Let division_result be divide_with_remainder(a, m)
    Let remainder be division_result[1]
    
    Note: Ensure non-negative result
    If remainder.is_negative:
        Note: For negative remainder, add modulus to make it positive
        If m.is_negative:
            Set remainder to subtract(remainder, m)
        Otherwise:
            Set remainder to add(remainder, m)
    
    Note: Handle case where modulus is negative
    If m.is_negative and not remainder.is_negative:
        Set remainder to add(remainder, m)
    
    Return remainder

Note: ===== MODULAR ARITHMETIC =====

Process called "create_modular_context" that takes modulus as BigInteger returns ModularContext:
    Note: Creates optimized context for repeated modular operations
    Note: Pre-computes Barrett reduction parameters and Montgomery constants
    
    If is_zero(modulus):
        Throw Errors.InvalidArgument("Modulus cannot be zero")
    
    If modulus.is_negative:
        Throw Errors.InvalidArgument("Modulus should be positive")
    
    Let context be ModularContext.new()
    Set context.modulus to modulus
    Set context.bit_length to bit_length(modulus)
    
    Note: Pre-compute Barrett reduction parameter mu is equal to floor(2^(2k) / modulus)
    Note: where k is the number of digits in modulus
    Let k be context.bit_length
    Let two_power_2k be left_shift(create_from_integer(1), 2 multiplied by k)
    Let barrett_mu be divide(two_power_2k, modulus)
    Set context.barrett_mu to barrett_mu
    
    Note: Pre-compute Montgomery constant R is equal to 2^k mod modulus
    Note: where k is chosen so that R is greater than modulus
    Let montgomery_k be context.bit_length plus 1
    Let montgomery_r be left_shift(create_from_integer(1), montgomery_k)
    Set montgomery_r to modulo(montgomery_r, modulus)
    Set context.montgomery_r to montgomery_r
    
    Return context

Process called "mod_add" that takes a as BigInteger, b as BigInteger, context as ModularContext returns BigInteger:
    Note: Performs modular addition (a plus b) mod m efficiently
    Note: Uses context for optimized reduction operations
    
    Note: Reduce inputs modulo m first
    Let a_reduced be modulo(a, context.modulus)
    Let b_reduced be modulo(b, context.modulus)
    
    Note: Add the reduced values
    Let sum be add(a_reduced, b_reduced)
    
    Note: Reduce result if it exceeds modulus
    If compare(sum, context.modulus) is greater than or equal to 0:
        Set sum to subtract(sum, context.modulus)
    
    Return sum

Process called "mod_multiply" that takes a as BigInteger, b as BigInteger, context as ModularContext returns BigInteger:
    Note: Performs modular multiplication using Montgomery or Barrett reduction
    Note: Critical for cryptographic applications requiring fast modular arithmetic
    
    Note: Reduce inputs modulo m first
    Let a_reduced be modulo(a, context.modulus)
    Let b_reduced be modulo(b, context.modulus)
    
    Note: Handle zero cases
    If is_zero(a_reduced) or is_zero(b_reduced):
        Return create_from_integer(0)
    
    Note: Multiply the reduced values
    Let product be multiply(a_reduced, b_reduced)
    
    Note: Use Barrett reduction for efficiency with large moduli
    If context.bit_length is greater than 32:
        Note: Barrett reduction: product minus ((product multiplied by mu) >> 2k) multiplied by modulus
        Let shifted_product be right_shift(product, 2 multiplied by context.bit_length)
        Let mu_product be multiply(shifted_product, context.barrett_mu)
        Let reduction_amount be multiply(mu_product, context.modulus)
        Let result be subtract(product, reduction_amount)
        
        Note: Final adjustment if result still is greater than or equal to modulus
        While compare(result, context.modulus) is greater than or equal to 0:
            Set result to subtract(result, context.modulus)
        
        Return result
    Otherwise:
        Note: Direct modular reduction for smaller numbers
        Return modulo(product, context.modulus)

Process called "mod_power" that takes base as BigInteger, exponent as BigInteger, context as ModularContext returns BigInteger:
    Note: Computes base^exponent mod m using binary exponentiation
    Note: Uses square-and-multiply algorithm with modular reduction
    Note: Complexity: O(log exponent multiplied by M(|modulus|)) where M is multiplication cost
    
    Note: Handle special cases
    If is_zero(exponent):
        Return create_from_integer(1)
    
    If is_zero(base):
        Return create_from_integer(0)
    
    If is_one(exponent):
        Return modulo(base, context.modulus)
    
    Note: Reduce base modulo m
    Let base_reduced be modulo(base, context.modulus)
    
    Note: Handle negative exponents
    If exponent.is_negative:
        Let inverse_base be mod_inverse(base_reduced, context)
        Let positive_exponent be abs(exponent)
        Return mod_power(inverse_base, positive_exponent, context)
    
    Note: Binary exponentiation (square-and-multiply)
    Let result be create_from_integer(1)
    Let current_base be base_reduced
    Let current_exponent be exponent
    
    While not is_zero(current_exponent):
        Note: If exponent is odd, multiply result by current base
        If current_exponent.digits[0] % 2 is equal to 1:
            Set result to mod_multiply(result, current_base, context)
        
        Note: Square the base and halve the exponent
        Set current_base to mod_multiply(current_base, current_base, context)
        Set current_exponent to right_shift(current_exponent, 1)
    
    Return result

Process called "mod_inverse" that takes a as BigInteger, context as ModularContext returns BigInteger:
    Note: Computes modular multiplicative inverse using extended Euclidean algorithm
    Note: Returns x such that a*x ≡ 1 (mod m), throws error if gcd(a,m) ≠ 1
    
    Note: Reduce input modulo m
    Let a_reduced be modulo(a, context.modulus)
    
    Note: Handle zero case
    If is_zero(a_reduced):
        Throw Errors.InvalidArgument("Cannot compute inverse of zero")
    
    Note: Use extended Euclidean algorithm
    Let extended_result be extended_gcd(a_reduced, context.modulus)
    Let gcd_value be extended_result[0]
    Let x be extended_result[1]
    Let y be extended_result[2]
    
    Note: Check if inverse exists (gcd must be 1)
    If not is_one(gcd_value):
        Throw Errors.InvalidArgument("Modular inverse does not exist minus gcd is not 1")
    
    Note: Ensure result is positive
    Let inverse be modulo(x, context.modulus)
    
    Return inverse

Note: ===== BITWISE OPERATIONS =====

Process called "bitwise_and" that takes a as BigInteger, b as BigInteger returns BigInteger:
    Note: Performs bitwise AND operation on two BigIntegers
    Note: Handles two's complement representation for negative numbers
    
    Note: Handle zero cases
    If is_zero(a) or is_zero(b):
        Return create_from_integer(0)
    
    Note: Convert to positive representation for bitwise operations
    Let a_positive be If a.is_negative Then twos_complement(a) Otherwise a
    Let b_positive be If b.is_negative Then twos_complement(b) Otherwise b
    
    Note: Determine result length
    Let max_digits be If a_positive.digit_count is greater than b_positive.digit_count Then a_positive.digit_count Otherwise b_positive.digit_count
    Let result_digits be []
    
    Note: Perform digit-wise AND operation
    For i from 0 to max_digits minus 1:
        Let a_digit be If i is less than a_positive.digit_count Then a_positive.digits[i] Otherwise 0
        Let b_digit be If i is less than b_positive.digit_count Then b_positive.digits[i] Otherwise 0
        Let and_result be a_digit & b_digit
        Add and_result to result_digits
    
    Note: Remove leading zeros
    While result_digits.length() is greater than 1 and result_digits[result_digits.length() minus 1] is equal to 0:
        Remove last element from result_digits
    
    Let result be BigInteger.new()
    Set result.digits to result_digits
    Set result.digit_count to result_digits.length()
    Set result.is_negative to false
    
    Note: Handle negative result cases
    If a.is_negative and b.is_negative:
        Set result to twos_complement(result)
        Set result.is_negative to true
    
    Return result

Process called "bitwise_or" that takes a as BigInteger, b as BigInteger returns BigInteger:
    Note: Performs bitwise OR operation on two BigIntegers
    Note: Result magnitude is bounded by max(|a|, |b|) plus 1
    
    Note: Handle zero cases
    If is_zero(a):
        Return b
    If is_zero(b):
        Return a
    
    Note: Convert to positive representation for bitwise operations
    Let a_working be If a.is_negative Then twos_complement(a) Otherwise a
    Let b_working be If b.is_negative Then twos_complement(b) Otherwise b
    
    Note: Determine result length
    Let max_digits be If a_working.digit_count is greater than b_working.digit_count Then a_working.digit_count Otherwise b_working.digit_count
    Let result_digits be []
    
    Note: Perform digit-wise OR operation
    For i from 0 to max_digits minus 1:
        Let a_digit be If i is less than a_working.digit_count Then a_working.digits[i] Otherwise 0
        Let b_digit be If i is less than b_working.digit_count Then b_working.digits[i] Otherwise 0
        Let or_result be a_digit | b_digit
        Add or_result to result_digits
    
    Note: Remove leading zeros
    While result_digits.length() is greater than 1 and result_digits[result_digits.length() minus 1] is equal to 0:
        Remove last element from result_digits
    
    Let result be BigInteger.new()
    Set result.digits to result_digits
    Set result.digit_count to result_digits.length()
    Set result.is_negative to false
    
    Note: Handle negative result cases
    If a.is_negative or b.is_negative:
        Set result to twos_complement(result)
        Set result.is_negative to true
    
    Return result

Process called "bitwise_xor" that takes a as BigInteger, b as BigInteger returns BigInteger:
    Note: Performs bitwise XOR operation on two BigIntegers
    Note: Useful for cryptographic operations and bit manipulation
    
    Note: Handle zero cases
    If is_zero(a):
        Return b
    If is_zero(b):
        Return a
    
    Note: Convert to positive representation for bitwise operations
    Let a_working be If a.is_negative Then twos_complement(a) Otherwise a
    Let b_working be If b.is_negative Then twos_complement(b) Otherwise b
    
    Note: Determine result length
    Let max_digits be If a_working.digit_count is greater than b_working.digit_count Then a_working.digit_count Otherwise b_working.digit_count
    Let result_digits be []
    
    Note: Perform digit-wise XOR operation
    For i from 0 to max_digits minus 1:
        Let a_digit be If i is less than a_working.digit_count Then a_working.digits[i] Otherwise 0
        Let b_digit be If i is less than b_working.digit_count Then b_working.digits[i] Otherwise 0
        Let xor_result be a_digit ^ b_digit
        Add xor_result to result_digits
    
    Note: Remove leading zeros
    While result_digits.length() is greater than 1 and result_digits[result_digits.length() minus 1] is equal to 0:
        Remove last element from result_digits
    
    Let result be BigInteger.new()
    Set result.digits to result_digits
    Set result.digit_count to result_digits.length()
    Set result.is_negative to false
    
    Note: Handle negative result cases
    If (a.is_negative and not b.is_negative) or (not a.is_negative and b.is_negative):
        Set result to twos_complement(result)
        Set result.is_negative to true
    
    Return result

Process called "bitwise_not" that takes a as BigInteger returns BigInteger:
    Note: Performs bitwise NOT operation (one's complement)
    Note: Returns -(a+1) for positive a, -(a-1) for negative a
    
    Note: Bitwise NOT is equivalent to -(a+1) in two's complement
    If a.is_negative:
        Note: ~(-a) is equal to a minus 1
        Let abs_a be abs(a)
        Return subtract(abs_a, create_from_integer(1))
    Otherwise:
        Note: ~a is equal to -(a plus 1)
        Let incremented be add(a, create_from_integer(1))
        Set incremented.is_negative to true
        Return incremented

Process called "left_shift" that takes a as BigInteger, positions as Integer returns BigInteger:
    Note: Shifts BigInteger left by specified number of bit positions
    Note: Equivalent to multiplication by 2^positions
    
    If positions is less than 0:
        Throw Errors.InvalidArgument("Shift positions cannot be negative")
    
    If positions is equal to 0:
        Return a
    
    If is_zero(a):
        Return create_from_integer(0)
    
    Note: Left shift is multiplication by 2^positions
    Let power_of_two be create_from_integer(1)
    Set power_of_two to left_shift_by_power_of_two(power_of_two, positions)
    
    Return multiply(a, power_of_two)

Process called "right_shift" that takes a as BigInteger, positions as Integer returns BigInteger:
    Note: Shifts BigInteger right by specified number of bit positions
    Note: Equivalent to floor division by 2^positions
    
    If positions is less than 0:
        Throw Errors.InvalidArgument("Shift positions cannot be negative")
    
    If positions is equal to 0:
        Return a
    
    If is_zero(a):
        Return create_from_integer(0)
    
    Note: Right shift is division by 2^positions
    Let power_of_two be create_from_integer(1)
    Set power_of_two to left_shift_by_power_of_two(power_of_two, positions)
    
    Note: For negative numbers, use floor division
    If a.is_negative:
        Let abs_result be divide(abs(a), power_of_two)
        Let remainder_check be modulo(abs(a), power_of_two)
        If not is_zero(remainder_check):
            Set abs_result to add(abs_result, create_from_integer(1))
        Set abs_result.is_negative to true
        Return abs_result
    Otherwise:
        Return divide(a, power_of_two)

Note: ===== NUMBER THEORY OPERATIONS =====

Process called "gcd" that takes a as BigInteger, b as BigInteger returns BigInteger:
    Note: Computes greatest common divisor using extended Euclidean algorithm
    Note: Returns largest positive integer that divides both a and b
    Note: Complexity: O(log min(|a|, |b|)) iterations, each O(M(n))
    
    Note: Work with absolute values
    Let abs_a be abs(a)
    Let abs_b be abs(b)
    
    Note: Handle zero cases
    If is_zero(abs_a):
        Return abs_b
    If is_zero(abs_b):
        Return abs_a
    
    Note: Euclidean algorithm
    Let current_a be abs_a
    Let current_b be abs_b
    
    While not is_zero(current_b):
        Let remainder be modulo(current_a, current_b)
        Set current_a to current_b
        Set current_b to remainder
    
    Return current_a

Process called "extended_gcd" that takes a as BigInteger, b as BigInteger returns Array[BigInteger]:
    Note: Returns [gcd, x, y] where gcd is equal to ax plus by (Bézout coefficients)
    Note: Essential for modular inverse and cryptographic applications
    
    Note: Handle zero cases
    If is_zero(a):
        Return [abs(b), create_from_integer(0), If b.is_negative Then create_from_integer(-1) Otherwise create_from_integer(1)]
    
    If is_zero(b):
        Return [abs(a), If a.is_negative Then create_from_integer(-1) Otherwise create_from_integer(1), create_from_integer(0)]
    
    Note: Extended Euclidean algorithm
    Let old_r be abs(a)
    Let r be abs(b)
    Let old_s be create_from_integer(1)
    Let s be create_from_integer(0)
    Let old_t be create_from_integer(0)
    Let t be create_from_integer(1)
    
    While not is_zero(r):
        Let quotient be divide(old_r, r)
        
        Let temp_r be r
        Set r to subtract(old_r, multiply(quotient, r))
        Set old_r to temp_r
        
        Let temp_s be s
        Set s to subtract(old_s, multiply(quotient, s))
        Set old_s to temp_s
        
        Let temp_t be t
        Set t to subtract(old_t, multiply(quotient, t))
        Set old_t to temp_t
    
    Note: Adjust signs based on original inputs
    If a.is_negative:
        Set old_s.is_negative to not old_s.is_negative
    If b.is_negative:
        Set old_t.is_negative to not old_t.is_negative
    
    Return [old_r, old_s, old_t]

Process called "lcm" that takes a as BigInteger, b as BigInteger returns BigInteger:
    Note: Computes least common multiple using gcd relationship
    Note: Returns smallest positive integer divisible by both a and b
    Note: Uses formula: lcm(a,b) is equal to |a*b| / gcd(a,b)
    
    Note: Handle zero cases
    If is_zero(a) or is_zero(b):
        Return create_from_integer(0)
    
    Note: Use formula: lcm(a,b) is equal to |a*b| / gcd(a,b)
    Let abs_a be abs(a)
    Let abs_b be abs(b)
    Let gcd_result be gcd(abs_a, abs_b)
    Let product be multiply(abs_a, abs_b)
    
    Return divide(product, gcd_result)

Process called "factorial" that takes n as Integer returns BigInteger:
    Note: Computes n! using efficient algorithms for large n
    Note: Uses prime factorization method for very large factorials
    
    If n is less than 0:
        Throw Errors.InvalidArgument("Factorial is undefined for negative numbers")
    
    If n is equal to 0 or n is equal to 1:
        Return create_from_integer(1)
    
    Note: For small n, use direct multiplication
    If n is less than or equal to 20:
        Let result be create_from_integer(1)
        For i from 2 to n:
            Let factor be create_from_integer(i)
            Set result to multiply(result, factor)
        Return result
    
    Note: For larger n, use more efficient approach
    Note: Split the range and use divide-and-conquer
    Return factorial_range(2, n)
    
Process called "factorial_range" that takes start as Integer, end as Integer returns BigInteger:
    Note: Helper function for efficient factorial computation using divide-and-conquer
    
    If start is greater than end:
        Return create_from_integer(1)
    
    If start is equal to end:
        Return create_from_integer(start)
    
    If end minus start is equal to 1:
        Return multiply(create_from_integer(start), create_from_integer(end))
    
    Note: Divide and conquer
    Let mid be (start plus end) / 2
    Let left_result be factorial_range(start, mid)
    Let right_result be factorial_range(mid plus 1, end)
    
    Return multiply(left_result, right_result)

Process called "binomial_coefficient" that takes n as Integer, k as Integer returns BigInteger:
    Note: Computes C(n,k) is equal to n!/(k!(n-k)!) using optimized algorithm
    Note: Avoids intermediate factorial computation for efficiency
    
    If n is less than 0 or k is less than 0:
        Throw Errors.InvalidArgument("Binomial coefficient requires non-negative arguments")
    
    If k is greater than n:
        Return create_from_integer(0)
    
    If k is equal to 0 or k is equal to n:
        Return create_from_integer(1)
    
    Note: Use symmetry property: C(n,k) is equal to C(n,n-k)
    If k is greater than n minus k:
        Set k to n minus k
    
    Note: Compute using multiplicative formula to avoid large factorials
    Note: C(n,k) is equal to n multiplied by (n-1) multiplied by ... multiplied by (n-k+1) / (k multiplied by (k-1) multiplied by ... multiplied by 1)
    Let numerator be create_from_integer(1)
    Let denominator be create_from_integer(1)
    
    For i from 0 to k minus 1:
        Let num_factor be create_from_integer(n minus i)
        Set numerator to multiply(numerator, num_factor)
        
        Let den_factor be create_from_integer(i plus 1)
        Set denominator to multiply(denominator, den_factor)
    
    Return divide(numerator, denominator)

Note: ===== PRIMALITY TESTING =====

Process called "is_probably_prime" that takes n as BigInteger, rounds as Integer returns PrimalityTestResult:
    Note: Performs Miller-Rabin primality test with specified number of rounds
    Note: Returns probabilistic result with confidence level
    Note: Error probability ≤ 4^(-rounds) for composite numbers
    
    Note: Handle small cases
    If compare(n, create_from_integer(2)) is less than 0:
        Return PrimalityTestResult {
            is_prime: false,
            confidence: 1.0,
            test_rounds: 0,
            witnesses: []
        }
    
    If compare(n, create_from_integer(2)) is equal to 0 or compare(n, create_from_integer(3)) is equal to 0:
        Return PrimalityTestResult {
            is_prime: true,
            confidence: 1.0,
            test_rounds: 0,
            witnesses: []
        }
    
    Note: Check if even
    If n.digits[0] % 2 is equal to 0:
        Return PrimalityTestResult {
            is_prime: false,
            confidence: 1.0,
            test_rounds: 0,
            witnesses: []
        }
    
    Note: Write n-1 as d multiplied by 2^s
    Let n_minus_1 be subtract(n, create_from_integer(1))
    Let s be 0
    Let d be n_minus_1
    
    While d.digits[0] % 2 is equal to 0:
        Set d to right_shift(d, 1)
        Set s to s plus 1
    
    Let witnesses be []
    Let composite_detected be false
    
    Note: Perform Miller-Rabin test rounds
    For round from 0 to rounds minus 1:
        Note: Choose random witness a in range [2, n-2]
        Let a be create_random(bit_length(n) minus 1, false)
        Set a to add(modulo(a, subtract(n, create_from_integer(3))), create_from_integer(2))
        Add a to witnesses
        
        Note: Compute a^d mod n
        Let context be create_modular_context(n)
        Let x be mod_power(a, d, context)
        
        Note: Check if x is equal to 1 or x is equal to n-1
        If compare(x, create_from_integer(1)) is equal to 0 or compare(x, n_minus_1) is equal to 0:
            Continue  Note: This witness indicates probable prime
        
        Note: Square x repeatedly s-1 times
        Let is_composite be true
        For i from 1 to s minus 1:
            Set x to mod_multiply(x, x, context)
            If compare(x, n_minus_1) is equal to 0:
                Set is_composite to false
                Break
        
        If is_composite:
            Set composite_detected to true
            Break
    
    Let confidence be If composite_detected Then 0.0 Otherwise (1.0 minus (1.0 / (4.0 ^ rounds)))
    
    Return PrimalityTestResult {
        is_prime: not composite_detected,
        confidence: confidence,
        test_rounds: rounds,
        witnesses: witnesses
    }

Process called "is_prime_lucas_lehmer" that takes p as Integer returns Boolean:
    Note: Performs Lucas-Lehmer test for Mersenne primes 2^p minus 1
    Note: Deterministic test specific to Mersenne numbers
    
    If p is less than or equal to 1:
        Return false
    
    If p is equal to 2:
        Return true  Note: 2^2 minus 1 is equal to 3 is prime
    
    Note: Compute M_p is equal to 2^p minus 1
    Let mersenne be subtract(left_shift(create_from_integer(1), p), create_from_integer(1))
    
    Note: Lucas-Lehmer sequence: s_0 is equal to 4, s_{i+1} is equal to s_i^2 minus 2
    Let s be create_from_integer(4)
    Let context be create_modular_context(mersenne)
    
    Note: Iterate p-2 times
    For i from 1 to p minus 2:
        Note: s is equal to s^2 minus 2 (mod M_p)
        Set s to mod_multiply(s, s, context)
        Set s to subtract(s, create_from_integer(2))
        Set s to modulo(s, mersenne)
    
    Note: M_p is prime if and only if s is equal to 0
    Return is_zero(s)

Process called "next_prime" that takes n as BigInteger returns BigInteger:
    Note: Finds smallest prime number greater than n
    Note: Uses probabilistic testing with high confidence
    
    Let candidate be add(n, create_from_integer(1))
    
    Note: Handle special case for n is less than 2
    If compare(candidate, create_from_integer(2)) is less than or equal to 0:
        Return create_from_integer(2)
    
    Note: Ensure candidate is odd
    If candidate.digits[0] % 2 is equal to 0:
        Set candidate to add(candidate, create_from_integer(1))
    
    Note: Search for prime using probabilistic testing
    Let max_attempts be 10000  Note: Safety limit
    Let attempts be 0
    
    While attempts is less than max_attempts:
        Let primality_test be is_probably_prime(candidate, 20)
        If primality_test.is_prime:
            Return candidate
        
        Note: Try next odd number
        Set candidate to add(candidate, create_from_integer(2))
        Set attempts to attempts plus 1
    
    Throw Errors.ComputationError("Could not find next prime in reasonable attempts")

Process called "generate_prime" that takes bit_length as Integer returns BigInteger:
    Note: Generates random prime of specified bit length
    Note: Uses cryptographically secure random generation
    
    If bit_length is less than or equal to 0:
        Throw Errors.InvalidArgument("Bit length must be positive")
    
    If bit_length is equal to 1:
        Return create_from_integer(2)  Note: Only 1-bit prime
    
    Note: Use create_random with is_prime is equal to true
    Return create_random(bit_length, true)

Note: ===== FACTORIZATION =====

Process called "trial_division" that takes n as BigInteger, limit as BigInteger returns Factorization:
    Note: Performs trial division up to specified limit
    Note: Efficient for finding small prime factors
    
    Let factors be {}
    Let remaining be abs(n)
    Let is_complete be true
    
    Note: Handle zero and one cases
    If is_zero(n) or is_one(abs(n)):
        Return Factorization {
            factors: factors,
            is_complete: true,
            largest_unfactored: create_from_integer(1)
        }
    
    Note: Check for factor 2
    While remaining.digits[0] % 2 is equal to 0:
        Let two be create_from_integer(2)
        If Dictionary.has_key(factors, two):
            Set factors[two] to factors[two] plus 1
        Otherwise:
            Set factors[two] to 1
        Set remaining to divide(remaining, two)
    
    Note: Check odd factors from 3 up to limit
    Let divisor be create_from_integer(3)
    While compare(multiply(divisor, divisor), remaining) is less than or equal to 0 and compare(divisor, limit) is less than or equal to 0:
        While is_zero(modulo(remaining, divisor)):
            If Dictionary.has_key(factors, divisor):
                Set factors[divisor] to factors[divisor] plus 1
            Otherwise:
                Set factors[divisor] to 1
            Set remaining to divide(remaining, divisor)
        
        Set divisor to add(divisor, create_from_integer(2))
    
    Note: If remaining is greater than 1, it's either prime or unfactored
    If compare(remaining, create_from_integer(1)) is greater than 0:
        If compare(remaining, limit) is greater than 0:
            Set is_complete to false
        Otherwise:
            Note: Remaining is a prime factor
            Set factors[remaining] to 1
            Set remaining to create_from_integer(1)
    
    Return Factorization {
        factors: factors,
        is_complete: is_complete,
        largest_unfactored: remaining
    }

Process called "pollard_rho" that takes n as BigInteger returns BigInteger:
    Note: Finds non-trivial factor using Pollard's rho algorithm
    Note: Probabilistic algorithm with expected O(n^(1/4)) complexity
    
    Note: Handle small cases
    If compare(n, create_from_integer(4)) is less than 0:
        Return n
    
    Note: Check if even
    If n.digits[0] % 2 is equal to 0:
        Return create_from_integer(2)
    
    Note: Pollard's rho with f(x) is equal to x^2 plus 1
    Let x be create_from_integer(2)
    Let y be create_from_integer(2)
    Let d be create_from_integer(1)
    Let context be create_modular_context(n)
    
    Note: Floyd's cycle detection
    While is_one(d):
        Note: x moves one step: x is equal to f(x) is equal to x^2 plus 1 (mod n)
        Set x to mod_add(mod_multiply(x, x, context), create_from_integer(1), context)
        
        Note: y moves two steps: y is equal to f(f(y))
        Set y to mod_add(mod_multiply(y, y, context), create_from_integer(1), context)
        Set y to mod_add(mod_multiply(y, y, context), create_from_integer(1), context)
        
        Note: Compute gcd(|x minus y|, n)
        Let diff be If compare(x, y) is greater than 0 Then subtract(x, y) Otherwise subtract(y, x)
        Set d to gcd(diff, n)
        
        Note: Avoid infinite loop
        If compare(d, n) is equal to 0:
            Note: Try different starting point
            Set x to create_from_integer(3)
            Set y to create_from_integer(3)
            Set d to create_from_integer(1)
    
    Note: Found a non-trivial factor or failed
    If compare(d, n) is equal to 0:
        Return create_from_integer(1)  Note: Failed to find factor
    Otherwise:
        Return d

Process called "factor_completely" that takes n as BigInteger returns Factorization:
    Note: Completely factors integer using combination of methods
    Note: Uses trial division, Pollard's rho, and other algorithms
    
    Let combined_factors be {}
    Let unfactored_list be [abs(n)]
    Let is_complete be true
    
    Note: Handle zero and one cases
    If is_zero(n) or is_one(abs(n)):
        Return Factorization {
            factors: combined_factors,
            is_complete: true,
            largest_unfactored: create_from_integer(1)
        }
    
    Note: Process each unfactored number
    While unfactored_list.length() is greater than 0:
        Let current be unfactored_list[0]
        Remove first element from unfactored_list
        
        Note: Skip if already factored to 1
        If is_one(current):
            Continue
        
        Note: Check if current is prime
        Let primality_test be is_probably_prime(current, 10)
        If primality_test.is_prime:
            If Dictionary.has_key(combined_factors, current):
                Set combined_factors[current] to combined_factors[current] plus 1
            Otherwise:
                Set combined_factors[current] to 1
            Continue
        
        Note: Try trial division for small factors
        Let trial_limit be create_from_integer(1000)
        Let trial_result be trial_division(current, trial_limit)
        
        Note: Add found factors
        For factor_key in Dictionary.keys(trial_result.factors):
            Let factor_power be Dictionary.get(trial_result.factors, factor_key, 0)
            If Dictionary.has_key(combined_factors, factor_key):
                Set combined_factors[factor_key] to combined_factors[factor_key] plus factor_power
            Otherwise:
                Set combined_factors[factor_key] to factor_power
        
        Note: Continue with unfactored remainder if exists
        If not trial_result.is_complete and compare(trial_result.largest_unfactored, create_from_integer(1)) is greater than 0:
            Let remaining be trial_result.largest_unfactored
            
            Note: Try Pollard's rho on remaining number
            Let rho_factor be pollard_rho(remaining)
            
            If compare(rho_factor, create_from_integer(1)) is greater than 0 and compare(rho_factor, remaining) is less than 0:
                Note: Found a factor with Pollard's rho
                Let other_factor be divide(remaining, rho_factor)
                Add rho_factor to unfactored_list
                Add other_factor to unfactored_list
            Otherwise:
                Note: Pollard's rho failed, check if remaining is small enough to be prime
                If compare(remaining, create_from_integer(1000000)) is less than 0:
                    Note: Small enough to assume prime
                    If Dictionary.has_key(combined_factors, remaining):
                        Set combined_factors[remaining] to combined_factors[remaining] plus 1
                    Otherwise:
                        Set combined_factors[remaining] to 1
                Otherwise:
                    Note: Large unfactored number remains
                    Set is_complete to false
                    If Dictionary.has_key(combined_factors, remaining):
                        Set combined_factors[remaining] to combined_factors[remaining] plus 1
                    Otherwise:
                        Set combined_factors[remaining] to 1
    
    Note: Find largest unfactored component
    Let largest_unfactored be create_from_integer(1)
    If not is_complete:
        For factor_key in Dictionary.keys(combined_factors):
            Let primality_check be is_probably_prime(factor_key, 5)
            If not primality_check.is_prime and compare(factor_key, largest_unfactored) is greater than 0:
                Set largest_unfactored to factor_key
    
    Return Factorization {
        factors: combined_factors,
        is_complete: is_complete,
        largest_unfactored: largest_unfactored
    }

Note: ===== CONVERSION AND REPRESENTATION =====

Process called "to_string" that takes value as BigInteger, base as Integer returns String:
    Note: Converts BigInteger to string representation in specified base
    Note: Supports bases 2 through 36 using digits 0-9 and letters A-Z
    
    If base is less than 2 or base is greater than 36:
        Throw Errors.InvalidArgument("Base must be between 2 and 36")
    
    If is_zero(value):
        Return "0"
    
    Let digits_chars be "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    Let result_digits be []
    Let working_value be abs(value)
    Let base_big be create_from_integer(base)
    
    Note: Extract digits by repeated division
    While not is_zero(working_value):
        Let division_result be divide_with_remainder(working_value, base_big)
        Let remainder be division_result[1]
        Let digit_index be remainder.digits[0]  Note: Safe since remainder is less than base
        Let digit_char be digits_chars.charAt(digit_index)
        Add digit_char to result_digits
        Set working_value to division_result[0]
    
    Note: Reverse digits (we built them backwards)
    Let result_string be ""
    For i from result_digits.length() minus 1 down to 0:
        Set result_string to result_string plus result_digits[i]
    
    Note: Add negative sign if needed
    If value.is_negative:
        Set result_string to "-" plus result_string
    
    Return result_string

Process called "to_hex_string" that takes value as BigInteger returns String:
    Note: Converts BigInteger to hexadecimal string representation
    Note: Optimized for base-16 conversion with proper padding
    
    Let hex_result be to_string(value, 16)
    
    Note: Add "0x" prefix for positive numbers, "-0x" for negative
    If value.is_negative:
        Note: Remove the negative sign and add -0x prefix
        Let unsigned_part be hex_result.substring(1)
        Return "-0x" plus unsigned_part
    Otherwise:
        Return "0x" plus hex_result

Process called "to_bytes" that takes value as BigInteger, is_big_endian as Boolean returns Array[Byte]:
    Note: Converts BigInteger to minimal byte array representation
    Note: Supports both big-endian and little-endian byte ordering
    
    If is_zero(value):
        Return [0]
    
    Let working_value be abs(value)
    Let byte_array be []
    Let base_256 be create_from_integer(256)
    
    Note: Extract bytes by repeated division by 256
    While not is_zero(working_value):
        Let division_result be divide_with_remainder(working_value, base_256)
        Let byte_value be division_result[1].digits[0]  Note: Safe since remainder is less than 256
        Add byte_value to byte_array
        Set working_value to division_result[0]
    
    Note: Handle endianness
    If is_big_endian:
        Note: Reverse the array (we built it little-endian)
        Let reversed_array be []
        For i from byte_array.length() minus 1 down to 0:
            Add byte_array[i] to reversed_array
        Return reversed_array
    Otherwise:
        Return byte_array

Process called "bit_length" that takes value as BigInteger returns Integer:
    Note: Returns number of bits needed to represent the absolute value
    Note: Equivalent to floor(log2(|value|)) plus 1 for positive values
    
    If is_zero(value):
        Return 0
    
    Let working_value be abs(value)
    Let bit_count be 0
    
    Note: Count bits by repeatedly dividing by 2
    While not is_zero(working_value):
        Set working_value to right_shift(working_value, 1)
        Set bit_count to bit_count plus 1
    
    Return bit_count

Process called "bit_count" that takes value as BigInteger returns Integer:
    Note: Returns number of 1-bits in binary representation (population count)
    Note: Also known as Hamming weight of the integer
    
    If is_zero(value):
        Return 0
    
    Let working_value be abs(value)
    Let one_count be 0
    
    Note: Count 1-bits by checking each bit position
    While not is_zero(working_value):
        Note: Check if least significant bit is 1
        If working_value.digits[0] % 2 is equal to 1:
            Set one_count to one_count plus 1
        
        Note: Shift right by 1 bit
        Set working_value to right_shift(working_value, 1)
    
    Return one_count

Note: ===== COMPARISON AND UTILITY =====

Process called "compare" that takes a as BigInteger, b as BigInteger returns Integer:
    Note: Compares two BigIntegers returning -1, 0, or 1
    Note: Returns negative if a is less than b, zero if a is equal to b, positive if a is greater than b
    
    Note: Handle sign differences
    If a.is_negative and not b.is_negative:
        Return -1  Note: negative is less than positive
    If not a.is_negative and b.is_negative:
        Return 1   Note: positive is greater than negative
    
    Note: Same signs minus compare magnitudes
    Let magnitude_comparison be compare_magnitudes(a, b)
    
    Note: If both negative, reverse the comparison
    If a.is_negative and b.is_negative:
        Return -magnitude_comparison
    Otherwise:
        Return magnitude_comparison

Process called "abs" that takes value as BigInteger returns BigInteger:
    Note: Returns absolute value of BigInteger
    Note: Simply flips sign bit for negative values
    
    If not value.is_negative:
        Return value
    
    Note: Create copy with positive sign
    Let result be BigInteger.new()
    Set result.digits to value.digits
    Set result.digit_count to value.digit_count
    Set result.is_negative to false
    Return result

Process called "sign" that takes value as BigInteger returns Integer:
    Note: Returns -1 for negative, 0 for zero, 1 for positive
    Note: Useful for sign-based algorithm branching
    
    If is_zero(value):
        Return 0
    Otherwise if value.is_negative:
        Return -1
    Otherwise:
        Return 1

Process called "is_zero" that takes value as BigInteger returns Boolean:
    Note: Tests if BigInteger is equal to zero
    Note: Optimized check avoiding full comparison
    
    Note: Check if single digit with value 0
    If value.digit_count is equal to 1 and value.digits[0] is equal to 0:
        Return true
    
    Return false

Process called "is_one" that takes value as BigInteger returns Boolean:
    Note: Tests if BigInteger is equal to positive one
    Note: Common check in mathematical algorithms
    
    Note: Check if single digit with value 1 and positive
    If not value.is_negative and value.digit_count is equal to 1 and value.digits[0] is equal to 1:
        Return true
    
    Return false

Process called "max" that takes a as BigInteger, b as BigInteger returns BigInteger:
    Note: Returns larger of two BigIntegers
    Note: Uses efficient comparison without full subtraction
    
    Let comparison be compare(a, b)
    If comparison is greater than or equal to 0:
        Return a
    Otherwise:
        Return b

Process called "min" that takes a as BigInteger, b as BigInteger returns BigInteger:
    Note: Returns smaller of two BigIntegers
    Note: Uses efficient comparison without full subtraction
    
    Let comparison be compare(a, b)
    If comparison is less than or equal to 0:
        Return a
    Otherwise:
        Return b