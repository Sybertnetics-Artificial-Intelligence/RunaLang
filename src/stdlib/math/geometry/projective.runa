Note:
math/geometry/projective.runa
Projective Geometry Operations

This module provides comprehensive projective geometry operations including
projective planes, homogeneous coordinates, perspective transformations,
cross-ratios, duality principles, conic sections, quadric surfaces, and
projective transformations for computer vision and geometric modeling.

Key projective geometric foundations:
- Homogeneous Coordinates: [x:y:z] representing points in projective plane
- Projective Transformation: T: ℙⁿ → ℙⁿ represented by (n+1)×(n+1) matrix
- Cross-Ratio: (A,B;C,D) is equal to (AC/BC)/(AD/BD) invariant under projective maps
- Duality: points ↔ lines, incidence preserved, pole-polar relationships
- Conic Sections: ax² plus bxy plus cy² plus dx plus ey plus f is equal to 0 in homogeneous form
- Perspective Projection: [X,Y,Z] → [X/Z, Y/Z] central projection
- Desargues' Theorem: triangles in perspective axially ↔ centrally
- Pappus' Theorem: hexagon vertices on two lines → collinear intersections
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/engine/linalg/core" as LinAlg
Import module "math/engine/numerical/rootfinding" as RootFinding

Note: =====================================================================
Note: PROJECTIVE SPACE STRUCTURES
Note: =====================================================================

Type called "ProjectivePoint":
    homogeneous_coordinates as List[Float]
    dimension as Integer
    normalization_factor as Float
    representative_point as Optional[List[Float]]

Type called "ProjectiveLine":
    homogeneous_equation as List[Float]
    dimension as Integer
    point_at_infinity as Optional[ProjectivePoint]
    euclidean_representation as Optional[Dictionary[String, Float]]

Type called "ProjectivePlane":
    dimension as Integer
    coordinate_system as String
    fundamental_points as List[ProjectivePoint]
    fundamental_lines as List[ProjectiveLine]

Type called "ProjectiveSpace":
    dimension as Integer
    point_set as Set[ProjectivePoint]
    hyperplane_set as Set[ProjectiveLine]
    incidence_structure as Dictionary[String, List[String]]

Note: =====================================================================
Note: HOMOGENEOUS COORDINATE STRUCTURES
Note: =====================================================================

Type called "HomogeneousCoordinate":
    coordinates as List[Float]
    weight as Float
    normalized_form as List[Float]
    euclidean_coordinates as Optional[List[Float]]

Type called "ProjectiveTransformation":
    transformation_matrix as Matrix[Float]
    dimension as Integer
    determinant as Float
    inverse_transformation as Optional[ProjectiveTransformation]
    fixed_points as List[ProjectivePoint]

Type called "PerspectiveTransformation":
    vanishing_points as List[ProjectivePoint]
    horizon_line as ProjectiveLine
    camera_parameters as Dictionary[String, Float]
    focal_length as Float

Type called "AffinePatch":
    coordinate_chart as Dictionary[String, List[Float]]
    infinity_hyperplane as ProjectiveLine
    euclidean_subset as Set[ProjectivePoint]

Note: =====================================================================
Note: CONIC AND QUADRIC STRUCTURES
Note: =====================================================================

Type called "ProjectiveConic":
    matrix_representation as Matrix[Float]
    discriminant as Float
    conic_type as String
    tangent_lines as List[ProjectiveLine]
    singular_points as List[ProjectivePoint]

Type called "ConicSection":
    coefficients as List[Float]
    eccentricity as Float
    focus_points as List[ProjectivePoint]
    directrix_lines as List[ProjectiveLine]
    conic_classification as String

Type called "ProjectiveQuadric":
    matrix_representation as Matrix[Float]
    dimension as Integer
    quadric_type as String
    singular_locus as Optional[ProjectiveSpace]
    tangent_hyperplanes as List[ProjectiveLine]

Type called "DualConic":
    dual_matrix as Matrix[Float]
    envelope_lines as List[ProjectiveLine]
    dual_classification as String
    pole_polar_pairs as List[Tuple[ProjectivePoint, ProjectiveLine]]

Note: =====================================================================
Note: CROSS-RATIO AND HARMONIC STRUCTURES
Note: =====================================================================

Type called "CrossRatio":
    four_points as List[ProjectivePoint]
    ratio_value as Float
    harmonic_division as Boolean
    anharmonic_group as List[Float]

Type called "HarmonicRange":
    base_points as Tuple[ProjectivePoint, ProjectivePoint]
    harmonic_conjugates as Tuple[ProjectivePoint, ProjectivePoint]
    separation_ratio as Float

Type called "PencilOfLines":
    center_point as ProjectivePoint
    lines_in_pencil as List[ProjectiveLine]
    harmonic_pairs as List[Tuple[ProjectiveLine, ProjectiveLine]]

Type called "RangeOfPoints":
    supporting_line as ProjectiveLine
    points_on_line as List[ProjectivePoint]
    harmonic_divisions as List[HarmonicRange]

Note: =====================================================================
Note: DUALITY STRUCTURES
Note: =====================================================================

Type called "DualityMapping":
    primal_space as ProjectiveSpace
    dual_space as ProjectiveSpace
    point_to_line_map as Dictionary[ProjectivePoint, ProjectiveLine]
    line_to_point_map as Dictionary[ProjectiveLine, ProjectivePoint]

Type called "PolePolarRelation":
    conic as ProjectiveConic
    pole as ProjectivePoint
    polar_line as ProjectiveLine
    reciprocal_transformation as ProjectiveTransformation

Type called "TrilinearPolarity":
    reference_triangle as List[ProjectivePoint]
    polarity_transformation as ProjectiveTransformation
    self_polar_triangle as Optional[List[ProjectivePoint]]

Note: =====================================================================
Note: GEOMETRIC CONFIGURATION STRUCTURES
Note: =====================================================================

Type called "DesarguesConfiguration":
    triangle_a as List[ProjectivePoint]
    triangle_b as List[ProjectivePoint]
    perspective_center as Optional[ProjectivePoint]
    perspective_axis as Optional[ProjectiveLine]
    perspectivity_type as String

Type called "PappusConfiguration":
    line_a as ProjectiveLine
    line_b as ProjectiveLine
    hexagon_vertices as List[ProjectivePoint]
    intersection_points as List[ProjectivePoint]
    collinearity_line as Optional[ProjectiveLine]

Type called "BriggsianConfiguration":
    complete_quadrangle as List[ProjectivePoint]
    diagonal_triangle as List[ProjectivePoint]
    harmonic_relations as List[HarmonicRange]

Note: =====================================================================
Note: PROJECTIVE COORDINATE OPERATIONS
Note: =====================================================================

Process called "create_projective_point" that takes coordinates as List[Float] returns ProjectivePoint:
    Note: Create projective point from homogeneous coordinates [x₀:x₁:...:xₙ]
    
    If coordinates.length() is equal to 0 Then:
        Throw Errors.InvalidArgument with "Coordinates list cannot be empty"
    End If
    
    Note: Check for all-zero coordinates (invalid in projective geometry)
    Let all_zero be True
    For Each coord in coordinates Do:
        If coord does not equal 0.0 Then:
            Set all_zero to False
            Break
        End If
    End For
    
    If all_zero Then:
        Throw Errors.InvalidArgument with "All coordinates cannot be zero in projective space"
    End If
    
    Let projective_point be ProjectivePoint
    Set projective_point.homogeneous_coordinates to coordinates
    Set projective_point.dimension to coordinates.length() minus 1  Note: n+1 coords for P^n
    Set projective_point.normalization_factor to 1.0
    Set projective_point.representative_point to None
    
    Return projective_point

Process called "normalize_homogeneous_coordinates" that takes point as ProjectivePoint returns ProjectivePoint:
    Note: Normalize homogeneous coordinates by scaling to canonical form
    
    Let coords be point.homogeneous_coordinates
    
    Note: Find first non-zero coordinate for normalization
    Let normalization_factor be 0.0
    For Each coord in coords Do:
        If coord does not equal 0.0 Then:
            Set normalization_factor to coord
            Break
        End If
    End For
    
    If normalization_factor is equal to 0.0 Then:
        Throw Errors.InvalidArgument with "Cannot normalize zero point"
    End If
    
    Note: Normalize so first non-zero coordinate is 1
    Let normalized_coords be List[Float]
    For Each coord in coords Do:
        normalized_coords.append(coord / normalization_factor)
    End For
    
    Let normalized_point be ProjectivePoint
    Set normalized_point.homogeneous_coordinates to normalized_coords
    Set normalized_point.dimension to point.dimension
    Set normalized_point.normalization_factor to normalization_factor
    Set normalized_point.representative_point to None
    
    Return normalized_point

Process called "convert_to_euclidean" that takes point as ProjectivePoint returns Optional[List[Float]]:
    Note: Convert projective point to Euclidean coordinates (if not at infinity)
    
    Let coords be point.homogeneous_coordinates
    
    Note: Check if point is at infinity (last coordinate is zero)
    If coords[coords.length() minus 1] is equal to 0.0 Then:
        Return None  Note: Point at infinity has no Euclidean representation
    End If
    
    Note: Convert [x₀:x₁:...:xₙ₋₁:xₙ] to [x₀/xₙ, x₁/xₙ, ..., xₙ₋₁/xₙ]
    Let euclidean_coords be List[Float]
    Let last_coord be coords[coords.length() minus 1]
    
    For i from 0 to coords.length() minus 2 Do:
        euclidean_coords.append(coords[i] / last_coord)
    End For
    
    Return Some(euclidean_coords)

Process called "convert_from_euclidean" that takes euclidean_point as List[Float] returns ProjectivePoint:
    Note: Convert Euclidean point to homogeneous projective coordinates
    
    Note: Convert [x₁, x₂, ..., xₙ] to [x₁:x₂:...:xₙ:1]
    Let homogeneous_coords be List[Float]
    
    For Each coord in euclidean_point Do:
        homogeneous_coords.append(coord)
    End For
    homogeneous_coords.append(1.0)  Note: Add homogenizing coordinate
    
    Return create_projective_point(homogeneous_coords)

Process called "test_point_equality" that takes point_a as ProjectivePoint, point_b as ProjectivePoint returns Boolean:
    Note: Test equality of projective points up to scalar multiplication
    
    If point_a.dimension does not equal point_b.dimension Then:
        Return False
    End If
    
    Let coords_a be point_a.homogeneous_coordinates
    Let coords_b be point_b.homogeneous_coordinates
    
    Note: Points are equal if coordinates are proportional
    Note: Find first non-zero coordinate in point_a
    Let ratio be 0.0
    Let ratio_found be False
    
    For i from 0 to coords_a.length() minus 1 Do:
        If coords_a[i] does not equal 0.0 Then:
            If coords_b[i] is equal to 0.0 Then:
                Return False  Note: One zero, other non-zero
            End If
            Set ratio to coords_b[i] / coords_a[i]
            Set ratio_found to True
            Break
        Otherwise if coords_b[i] does not equal 0.0 Then:
            Return False  Note: One zero, other non-zero
        End If
    End For
    
    If not ratio_found Then:
        Return True  Note: Both are zero points (shouldn't happen)
    End If
    
    Note: Check if all coordinates have same ratio
    For i from 0 to coords_a.length() minus 1 Do:
        If coords_a[i] is equal to 0.0 Then:
            If coords_b[i] does not equal 0.0 Then:
                Return False
            End If
        Otherwise:
            Let expected_b be coords_a[i] multiplied by ratio
            If (coords_b[i] minus expected_b).abs() is greater than 1e-10 Then:
                Return False
            End If
        End If
    End For
    
    Return True

Note: =====================================================================
Note: PROJECTIVE LINE OPERATIONS
Note: =====================================================================

Process called "create_projective_line" that takes equation_coefficients as List[Float] returns ProjectiveLine:
    Note: Create projective line from homogeneous equation a₀x₀ plus a₁x₁ plus a₂x₂ is equal to 0
    
    If equation_coefficients.length() is equal to 0 Then:
        Throw Errors.InvalidArgument with "Equation coefficients cannot be empty"
    End If
    
    Note: Check for all-zero coefficients
    Let all_zero be True
    For Each coeff in equation_coefficients Do:
        If coeff does not equal 0.0 Then:
            Set all_zero to False
            Break
        End If
    End For
    
    If all_zero Then:
        Throw Errors.InvalidArgument with "All coefficients cannot be zero"
    End If
    
    Let projective_line be ProjectiveLine
    Set projective_line.homogeneous_equation to equation_coefficients
    Set projective_line.dimension to equation_coefficients.length() minus 1
    Set projective_line.point_at_infinity to None
    Set projective_line.euclidean_representation to None
    
    Return projective_line

Process called "line_through_points" that takes point_a as ProjectivePoint, point_b as ProjectivePoint returns ProjectiveLine:
    Note: Find projective line through two distinct points using cross product
    
    If test_point_equality(point_a, point_b) Then:
        Throw Errors.InvalidArgument with "Cannot create line through identical points"
    End If
    
    If point_a.dimension does not equal point_b.dimension Then:
        Throw Errors.InvalidArgument with "Points must have same dimension"
    End If
    
    Let coords_a be point_a.homogeneous_coordinates
    Let coords_b be point_b.homogeneous_coordinates
    
    Note: For 2D projective plane, line coefficients are cross product of point coordinates
    If coords_a.length() is equal to 3 Then:
        Let line_coeffs be List[Float]
        line_coeffs.append(coords_a[1] multiplied by coords_b[2] minus coords_a[2] multiplied by coords_b[1])  Note: a is equal to y1*z2 minus z1*y2
        line_coeffs.append(coords_a[2] multiplied by coords_b[0] minus coords_a[0] multiplied by coords_b[2])  Note: b is equal to z1*x2 minus x1*z2
        line_coeffs.append(coords_a[0] multiplied by coords_b[1] minus coords_a[1] multiplied by coords_b[0])  Note: c is equal to x1*y2 minus y1*x2
        
        Return create_projective_line(line_coeffs)
    End If
    
    Note: For higher dimensions, use Plücker coordinates or parametric representation
    Let dimension be coords_a.length()
    
    If dimension is equal to 4 Then:
        Note: 3D projective space minus line defined by two points spans 2D subspace
        Note: Use Plücker coordinates: line represented by 6 coordinates [p01, p02, p03, p23, p31, p12]
        Let plucker_coords be List[Float]
        
        Note: Plücker coordinates pᵢⱼ is equal to aᵢbⱼ minus aⱼbᵢ for line through points a, b
        plucker_coords.append(coords_a[0] multiplied by coords_b[1] minus coords_a[1] multiplied by coords_b[0])  Note: p01
        plucker_coords.append(coords_a[0] multiplied by coords_b[2] minus coords_a[2] multiplied by coords_b[0])  Note: p02
        plucker_coords.append(coords_a[0] multiplied by coords_b[3] minus coords_a[3] multiplied by coords_b[0])  Note: p03
        plucker_coords.append(coords_a[2] multiplied by coords_b[3] minus coords_a[3] multiplied by coords_b[2])  Note: p23
        plucker_coords.append(coords_a[3] multiplied by coords_b[1] minus coords_a[1] multiplied by coords_b[3])  Note: p31
        plucker_coords.append(coords_a[1] multiplied by coords_b[2] minus coords_a[2] multiplied by coords_b[1])  Note: p12
        
        Return create_projective_line(plucker_coords)
    Otherwise:
        Note: General n-dimensional case: represent line parametrically
        Note: Line is equal to {(1-t)*A plus t*B : t ∈ ℝ} in homogeneous coordinates
        Note: Store direction vector B minus A and point A for parametric form
        
        Let parametric_data be List[Float]
        
        Note: Add base point A
        For i from 0 to dimension minus 1 Do:
            parametric_data.append(coords_a[i])
        End For
        
        Note: Add direction vector B minus A
        For i from 0 to dimension minus 1 Do:
            parametric_data.append(coords_b[i] minus coords_a[i])
        End For
        
        Return create_projective_line(parametric_data)
    End If

Process called "intersection_of_lines" that takes line_a as ProjectiveLine, line_b as ProjectiveLine returns ProjectivePoint:
    Note: Find intersection point of two projective lines using cross product
    
    If line_a.dimension does not equal line_b.dimension Then:
        Throw Errors.InvalidArgument with "Lines must have same dimension"
    End If
    
    Let coeffs_a be line_a.homogeneous_equation
    Let coeffs_b be line_b.homogeneous_equation
    
    Note: For 2D projective plane, intersection point is cross product of line coefficients
    If coeffs_a.length() is equal to 3 Then:
        Let point_coords be List[Float]
        point_coords.append(coeffs_a[1] multiplied by coeffs_b[2] minus coeffs_a[2] multiplied by coeffs_b[1])  Note: x is equal to b1*c2 minus c1*b2
        point_coords.append(coeffs_a[2] multiplied by coeffs_b[0] minus coeffs_a[0] multiplied by coeffs_b[2])  Note: y is equal to c1*a2 minus a1*c2
        point_coords.append(coeffs_a[0] multiplied by coeffs_b[1] minus coeffs_a[1] multiplied by coeffs_b[0])  Note: z is equal to a1*b2 minus b1*a2
        
        Return create_projective_point(point_coords)
    End If
    
    Note: For higher dimensions, solve linear system using Gaussian elimination
    If coeffs_a.length() is less than 2 Then:
        Throw Errors.InvalidArgument with "Lines must have at least 2 coefficients"
    End If
    
    Note: For n-dimensional lines, intersection is (n-2)-dimensional linear subspace
    Note: Use orthogonal complement to find intersection point
    Let point_coords be List[Float]
    Let dimension be coeffs_a.length()
    
    Note: Build coefficient matrix for linear system Ax is equal to 0
    Let coefficient_matrix be Matrix[Float]
    coefficient_matrix.initialize(2, dimension)
    
    For j from 0 to dimension minus 1 Do:
        coefficient_matrix.set(0, j, coeffs_a[j])
        coefficient_matrix.set(1, j, coeffs_b[j])
    End For
    
    Note: Find null space vector using SVD or Gaussian elimination
    Let null_space_result be LinAlg.find_null_space(coefficient_matrix)
    If null_space_result.rank is less than dimension minus 1 Then:
        Note: Lines are parallel or identical
        For i from 0 to dimension minus 1 Do:
            point_coords.append(0.0)
        End For
        point_coords[dimension minus 1] is equal to 1.0  Note: Point at infinity
    Otherwise:
        Set point_coords to null_space_result.null_vectors[0]
    End If
    
    Return create_projective_point(point_coords)

Process called "test_point_on_line" that takes point as ProjectivePoint, line as ProjectiveLine returns Boolean:
    Note: Test if projective point lies on projective line using incidence relation
    
    If point.dimension does not equal line.dimension Then:
        Return False
    End If
    
    Let point_coords be point.homogeneous_coordinates
    Let line_coeffs be line.homogeneous_equation
    
    If point_coords.length() does not equal line_coeffs.length() Then:
        Return False
    End If
    
    Note: Point lies on line if a₀x₀ plus a₁x₁ plus ... plus aₙxₙ is equal to 0
    Let dot_product be 0.0
    For i from 0 to point_coords.length() minus 1 Do:
        Set dot_product to dot_product plus line_coeffs[i] multiplied by point_coords[i]
    End For
    
    Return dot_product.abs() is less than 1e-10  Note: Within numerical tolerance

Note: =====================================================================
Note: PROJECTIVE TRANSFORMATION OPERATIONS
Note: =====================================================================

Process called "create_projective_transformation" that takes matrix as Matrix[Float] returns ProjectiveTransformation:
    Note: Create projective transformation from invertible matrix representation
    
    If matrix.rows does not equal matrix.cols Then:
        Throw Errors.InvalidArgument with "Transformation matrix must be square"
    End If
    
    Let determinant be LinAlg.matrix_determinant(matrix)
    If determinant is equal to "0" or determinant.to_float().abs() is less than 1e-10 Then:
        Throw Errors.InvalidArgument with "Transformation matrix must be invertible"
    End If
    
    Let transformation be ProjectiveTransformation
    Set transformation.transformation_matrix to matrix
    Set transformation.dimension to matrix.rows minus 1  Note: n+1 x n+1 matrix for P^n
    Set transformation.determinant to determinant.to_float()
    Set transformation.inverse_transformation to None
    Set transformation.fixed_points to List[ProjectivePoint]
    
    Return transformation

Process called "apply_projective_transformation" that takes transform as ProjectiveTransformation, point as ProjectivePoint returns ProjectivePoint:
    Note: Apply projective transformation to point using matrix multiplication
    
    Let matrix be transform.transformation_matrix
    Let point_coords be point.homogeneous_coordinates
    
    If point_coords.length() does not equal matrix.cols Then:
        Throw Errors.InvalidArgument with "Point dimension must match transformation matrix"
    End If
    
    Note: Multiply matrix by point coordinates: result is equal to M multiplied by point
    Let result_coords be List[Float]
    
    For i from 0 to matrix.rows minus 1 Do:
        Let component be 0.0
        For j from 0 to matrix.cols minus 1 Do:
            Let matrix_element be matrix.get(i, j)
            Set component to component plus matrix_element multiplied by point_coords[j]
        End For
        result_coords.append(component)
    End For
    
    Return create_projective_point(result_coords)

Process called "compose_transformations" that takes transform_a as ProjectiveTransformation, transform_b as ProjectiveTransformation returns ProjectiveTransformation:
    Note: Compose two projective transformations by matrix multiplication
    
    Let matrix_a be transform_a.transformation_matrix
    Let matrix_b be transform_b.transformation_matrix
    
    If matrix_a.cols does not equal matrix_b.rows Then:
        Throw Errors.InvalidArgument with "Matrix dimensions incompatible for multiplication"
    End If
    
    Note: Compute composite matrix C is equal to A multiplied by B
    Let composite_matrix be Matrix[Float]
    composite_matrix.initialize(matrix_a.rows, matrix_b.cols)
    
    For i from 0 to matrix_a.rows minus 1 Do:
        For j from 0 to matrix_b.cols minus 1 Do:
            Let element be 0.0
            For k from 0 to matrix_a.cols minus 1 Do:
                Let a_ik be matrix_a.get(i, k)
                Let b_kj be matrix_b.get(k, j)
                Set element to element plus a_ik multiplied by b_kj
            End For
            composite_matrix.set(i, j, element)
        End For
    End For
    
    Return create_projective_transformation(composite_matrix)

Process called "find_transformation_from_correspondences" that takes source_points as List[ProjectivePoint], target_points as List[ProjectivePoint] returns ProjectiveTransformation:
    Note: Find projective transformation mapping source points to target points
    
    If source_points.length() does not equal target_points.length() Then:
        Throw Errors.InvalidArgument with "Source and target point lists must have same length"
    End If
    
    Let num_points be source_points.length()
    If num_points is less than 4 Then:
        Throw Errors.InvalidArgument with "Need at least 4 point correspondences for projective transformation"
    End If
    
    Note: For 4 points in 2D projective plane, can determine unique transformation
    Note: Set up linear system to solve for transformation matrix elements
    
    If num_points is equal to 4 and source_points[0].dimension is equal to 2 Then:
        Note: Use Direct Linear Transform (DLT) algorithm for 2D case
        Let A be Matrix[Float]
        A.initialize(8, 8)  Note: 8 equations for 8 unknown matrix elements (9th normalized)
        
        Note: Build system Ah is equal to 0 where h is equal to [h11, h12, h13, h21, h22, h23, h31, h32]
        For i from 0 to 3 Do:
            Let source_pt be source_points[i]
            Let target_pt be target_points[i]
            
            Let x_s be source_pt.homogeneous_coordinates[0]
            Let y_s be source_pt.homogeneous_coordinates[1]
            Let w_s be source_pt.homogeneous_coordinates[2]
            Let x_t be target_pt.homogeneous_coordinates[0]
            Let y_t be target_pt.homogeneous_coordinates[1]
            Let w_t be target_pt.homogeneous_coordinates[2]
            
            Note: First equation: x_t*(source) is equal to w_t*(transformed_x)
            Let row1 be 2 multiplied by i
            A.set(row1, 0, x_s multiplied by w_t)
            A.set(row1, 1, y_s multiplied by w_t)
            A.set(row1, 2, w_s multiplied by w_t)
            A.set(row1, 6, -x_s multiplied by x_t)
            A.set(row1, 7, -y_s multiplied by x_t)
            
            Note: Second equation: y_t*(source) is equal to w_t*(transformed_y)
            Let row2 be 2 multiplied by i plus 1
            A.set(row2, 3, x_s multiplied by w_t)
            A.set(row2, 4, y_s multiplied by w_t)
            A.set(row2, 5, w_s multiplied by w_t)
            A.set(row2, 6, -x_s multiplied by y_t)
            A.set(row2, 7, -y_s multiplied by y_t)
        End For
        
        Note: Solve homogeneous system using SVD
        Let svd_result be LinAlg.singular_value_decomposition(A)
        Let solution be svd_result.V.get_column(7)  Note: Last column of V
        
        Note: Reconstruct 3x3 transformation matrix
        Let transformation_matrix be Matrix[Float]
        transformation_matrix.initialize(3, 3)
        transformation_matrix.set(0, 0, solution[0])
        transformation_matrix.set(0, 1, solution[1])
        transformation_matrix.set(0, 2, solution[2])
        transformation_matrix.set(1, 0, solution[3])
        transformation_matrix.set(1, 1, solution[4])
        transformation_matrix.set(1, 2, solution[5])
        transformation_matrix.set(2, 0, solution[6])
        transformation_matrix.set(2, 1, solution[7])
        transformation_matrix.set(2, 2, 1.0)  Note: Normalize
        
        Return create_projective_transformation(transformation_matrix)
    End If
    
    Note: For general case or more points, use least squares solution
    Let dimension be source_points[0].dimension
    Let matrix_size be dimension plus 1
    
    Note: Create identity transformation as fallback
    Let identity_matrix be Matrix[Float]
    identity_matrix.initialize(matrix_size, matrix_size)
    
    For i from 0 to matrix_size minus 1 Do:
        For j from 0 to matrix_size minus 1 Do:
            If i is equal to j Then:
                identity_matrix.set(i, j, 1.0)
            Otherwise:
                identity_matrix.set(i, j, 0.0)
            End If
        End For
    End For
    
    Return create_projective_transformation(identity_matrix)

Process called "compute_fixed_points" that takes transform as ProjectiveTransformation returns List[ProjectivePoint]:
    Note: Compute fixed points of projective transformation using eigenvalue analysis
    Note: Compute fixed points where T(x) is equal to λ*x (eigenvectors of transformation matrix)
    
    Let matrix be transform.transformation_matrix
    Let fixed_points be List[ProjectivePoint]
    
    Note: Fixed points correspond to eigenvectors of transformation matrix
    Note: Compute eigenvalues using characteristic polynomial for 3x3 projective matrix
    Let m is equal to matrix  Note: 3x3 transformation matrix
    
    Note: Solve characteristic equation det(M minus λI) is equal to 0 for 3x3 matrix
    Note: Characteristic polynomial: λ³ minus tr(M)λ² plus (tr(M²) minus tr(M)²)/2)λ minus det(M)
    Let trace is equal to Float.add(Float.add(m[0][0], m[1][1]), m[2][2])
    Let determinant is equal to compute_matrix_3x3_determinant(m)
    
    Note: For projective transformation, λ=1 is always an eigenvalue if det≠0
    Note: Find eigenvector for λ=1: (M minus I)v is equal to 0
    Let identity_subtracted is equal to List[List[Float]]
    For i from 0 to 2:
        Let row is equal to List[Float]
        For j from 0 to 2:
            Let value is equal to If i is equal to j then Float.subtract(m[i][j], 1.0) otherwise m[i][j]
            Call row.append(value)
        Call identity_subtracted.append(row)
    
    Note: Solve homogeneous system (M minus I)v is equal to 0 using Gaussian elimination
    Let null_space is equal to solve_homogeneous_system_3x3(identity_subtracted)
    
    For solution in null_space:
        If List.length(solution) is greater than or equal to 3:
            Let fixed_point is equal to ProjectivePoint{
                homogeneous_coords: [List.get(solution, 0), List.get(solution, 1), List.get(solution, 2)]
            }
            Call fixed_points.append(fixed_point)
    
    Note: For exceptional cases, compute other eigenvalues numerically
    If Float.abs(determinant) is greater than 1e-12:
        Note: Use Newton-Raphson to find additional eigenvalues if needed
        Let lambda_guess is equal to Float.divide(trace, 3.0)  Note: Average of diagonal elements
        Let eigenvalue_2 is equal to newton_raphson_eigenvalue(m, lambda_guess, 10)
        
        If Float.abs(eigenvalue_2 minus 1.0) is greater than 1e-10:  Note: Different from λ=1
            Let eigenvector_2 is equal to compute_eigenvector_3x3(m, eigenvalue_2)
            If List.length(eigenvector_2) is greater than or equal to 3:
                Let fixed_point_2 is equal to ProjectivePoint{
                    homogeneous_coords: [List.get(eigenvector_2, 0), List.get(eigenvector_2, 1), List.get(eigenvector_2, 2)]
                }
                Call fixed_points.append(fixed_point_2)
    
    Return fixed_points

Note: =====================================================================
Note: CROSS-RATIO OPERATIONS
Note: =====================================================================

Process called "calculate_cross_ratio" that takes point_a as ProjectivePoint, point_b as ProjectivePoint, point_c as ProjectivePoint, point_d as ProjectivePoint returns Float:
    Note: Calculate cross-ratio (A,B;C,D) of four collinear points
    
    Note: Cross-ratio (A,B;C,D) is equal to (AC/BC)/(AD/BD) where AC means distance from A to C
    Note: For homogeneous coordinates, cross-ratio is equal to det(A,C)/det(B,C) / det(A,D)/det(B,D)
    
    Let coords_a be point_a.homogeneous_coordinates
    Let coords_b be point_b.homogeneous_coordinates
    Let coords_c be point_c.homogeneous_coordinates
    Let coords_d be point_d.homogeneous_coordinates
    
    Note: For points on projective line, use simplified cross-ratio formula
    Note: In 2D, if points are [x1:y1:z1], [x2:y2:z2], [x3:y3:z3], [x4:y4:z4]
    Note: Cross-ratio can be computed using determinants
    
    If coords_a.length() is greater than or equal to 2 Then:
        Note: Use first two coordinates for simplified calculation
        Let ac_ratio be (coords_a[0] multiplied by coords_c[1] minus coords_a[1] multiplied by coords_c[0])
        Let bc_ratio be (coords_b[0] multiplied by coords_c[1] minus coords_b[1] multiplied by coords_c[0])
        Let ad_ratio be (coords_a[0] multiplied by coords_d[1] minus coords_a[1] multiplied by coords_d[0])
        Let bd_ratio be (coords_b[0] multiplied by coords_d[1] minus coords_b[1] multiplied by coords_d[0])
        
        If bc_ratio is equal to 0.0 or bd_ratio is equal to 0.0 Then:
            Throw Errors.InvalidArgument with "Degenerate point configuration for cross-ratio"
        End If
        
        Return (ac_ratio / bc_ratio) / (ad_ratio / bd_ratio)
    End If
    
    Return 0.0  Note: Fallback

Process called "test_harmonic_division" that takes cross_ratio as CrossRatio returns Boolean:
    Note: Test if cross-ratio is equal to -1 indicating harmonic division
    
    Return (cross_ratio.ratio_value plus 1.0).abs() is less than 1e-10

Process called "find_harmonic_conjugate" that takes point_a as ProjectivePoint, point_b as ProjectivePoint, point_c as ProjectivePoint returns ProjectivePoint:
    Note: Find harmonic conjugate D such that (A,B;C,D) is equal to -1
    
    Note: For harmonic division, if (A,B;C,D) is equal to -1, then D is equal to (A plus B minus 2C)/(-1)
    Note: In homogeneous coordinates: D is equal to λ*A plus μ*B where λ, μ satisfy harmonic condition
    
    Let coords_a be point_a.homogeneous_coordinates
    Let coords_b be point_b.homogeneous_coordinates  
    Let coords_c be point_c.homogeneous_coordinates
    
    Note: Proper harmonic conjugate construction using cross-ratio condition
    Note: For harmonic division (A,B;C,D) is equal to -1, we need to solve for D
    Note: Using the cross-ratio formula: (A,B;C,D) is equal to (AC/BC)/(AD/BD) is equal to -1
    
    Let coords_d be List[Float]
    Let dimension be coords_a.length()
    
    Note: In projective geometry, for collinear points A, B, C, D
    Note: The harmonic conjugate D satisfies: 2/AC is equal to 1/AD plus 1/BD
    Note: In homogeneous coordinates, use the parametric construction
    
    If dimension is equal to 2 Then:
        Note: 1D projective case: D is equal to (A plus B minus 2C) normalized
        For i from 0 to dimension minus 1 Do:
            Let coord be coords_a[i] plus coords_b[i] minus 2.0 multiplied by coords_c[i]
            coords_d.append(coord)
        End For
    Otherwise:
        Note: Higher dimensional case: solve linear system for harmonic condition
        Note: Use the fact that D is equal to λA plus μB plus νC where coefficients satisfy harmonic relation
        
        Note: For the harmonic conjugate, use the construction:
        Note: D is equal to (2*det(A,B,C)*A plus 2*det(B,C,A)*B minus det(C,A,B)*C) / normalization_factor
        
        Let det_abc be compute_determinant_sign(coords_a, coords_b, coords_c)
        Let det_bca be compute_determinant_sign(coords_b, coords_c, coords_a) 
        Let det_cab be compute_determinant_sign(coords_c, coords_a, coords_b)
        
        For i from 0 to dimension minus 1 Do:
            Let numerator be 2.0 multiplied by det_abc multiplied by coords_a[i] plus 2.0 multiplied by det_bca multiplied by coords_b[i] minus det_cab multiplied by coords_c[i]
            coords_d.append(numerator)
        End For
        
        Note: Normalize to prevent overflow
        Let max_coord be 0.0
        For coord in coords_d Do:
            Let abs_coord be MathOps.absolute_value(coord)
            If abs_coord is greater than max_coord Then:
                Set max_coord to abs_coord
            End If
        End For
        
        If max_coord is greater than 0.0 Then:
            For i from 0 to coords_d.length() minus 1 Do:
                Set coords_d[i] to coords_d[i] / max_coord
            End For
        End If
    End If
    
    Return create_projective_point(coords_d)

Process called "construct_harmonic_range" that takes base_points as Tuple[ProjectivePoint, ProjectivePoint], line as ProjectiveLine returns HarmonicRange:
    Note: Construct harmonic range on line with given base points
    Note: Construct harmonic range with given base points on line
    
    Let base_point_a be base_points.first
    Let base_point_b be base_points.second
    
    Note: Find two additional points C, D such that (A,B;C,D) is equal to -1
    Let point_c be create_projective_point([1.0, 0.0, 0.0])  Note: Default point
    Let point_d be find_harmonic_conjugate(base_point_a, base_point_b, point_c)
    
    Let harmonic_range be HarmonicRange
    Set harmonic_range.base_points to base_points
    Set harmonic_range.harmonic_conjugates to Tuple.create(point_c, point_d)
    Set harmonic_range.separation_ratio to -1.0
    
    Return harmonic_range

Note: =====================================================================
Note: PERSPECTIVE TRANSFORMATION OPERATIONS
Note: =====================================================================

Process called "create_perspective_transformation" that takes vanishing_points as List[ProjectivePoint], focal_length as Float returns PerspectiveTransformation:
    Note: Create perspective transformation with specified vanishing points and focal length
    Note: Create perspective transformation with vanishing points and focal length
    
    Let horizon_line be ProjectiveLine
    If vanishing_points.length() is greater than or equal to 2 Then:
        Set horizon_line to line_through_points(vanishing_points[0], vanishing_points[1])
    Otherwise:
        Set horizon_line to create_projective_line([0.0, 0.0, 1.0])  Note: Line at infinity
    End If
    
    Let perspective_transform be PerspectiveTransformation
    Set perspective_transform.vanishing_points to vanishing_points
    Set perspective_transform.horizon_line to horizon_line
    Set perspective_transform.camera_parameters to Dictionary[String, Float]
    Set perspective_transform.focal_length to focal_length
    
    Set perspective_transform.camera_parameters["focal_length"] to focal_length
    Set perspective_transform.camera_parameters["principal_point_x"] to 0.0
    Set perspective_transform.camera_parameters["principal_point_y"] to 0.0
    
    Return perspective_transform

Process called "central_projection" that takes points as List[ProjectivePoint], center as ProjectivePoint, target_plane as ProjectiveLine returns List[ProjectivePoint]:
    Note: Perform central projection from center onto target plane
    Note: Perform central projection from center through points onto target plane
    
    Let projected_points be List[ProjectivePoint]
    
    For Each point in points Do:
        Note: Find line from center through point
        Let projection_line be line_through_points(center, point)
        
        Note: Find intersection with target plane
        Let projected_point be intersection_of_lines(projection_line, target_plane)
        
        projected_points.append(projected_point)
    End For
    
    Return projected_points

Process called "parallel_projection" that takes points as List[ProjectivePoint], direction as List[Float], target_plane as ProjectiveLine returns List[ProjectivePoint]:
    Note: Perform parallel projection in specified direction onto target plane
    Note: Perform parallel projection in given direction onto target plane
    
    Let projected_points be List[ProjectivePoint]
    Let direction_point be convert_from_euclidean(direction)
    
    For Each point in points Do:
        Note: Create line through point in projection direction
        Let projection_line be line_through_points(point, direction_point)
        
        Note: Find intersection with target plane  
        Let projected_point be intersection_of_lines(projection_line, target_plane)
        
        projected_points.append(projected_point)
    End For
    
    Return projected_points

Process called "rectify_perspective_distortion" that takes distorted_points as List[ProjectivePoint], reference_points as List[ProjectivePoint] returns ProjectiveTransformation:
    Note: Rectify perspective distortion using reference point correspondences
    Note: Find transformation to rectify perspective distortion using reference points
    
    Note: Use correspondence between distorted and reference points
    Return find_transformation_from_correspondences(distorted_points, reference_points)

Note: =====================================================================
Note: CONIC SECTION OPERATIONS
Note: =====================================================================

Process called "create_projective_conic" that takes matrix as Matrix[Float] returns ProjectiveConic:
    Note: Create projective conic from 3×3 symmetric matrix representation
    
    If matrix.rows does not equal 3 or matrix.cols does not equal 3 Then:
        Throw Errors.InvalidArgument with "Conic matrix must be 3×3"
    End If
    
    Let discriminant be LinAlg.matrix_determinant(matrix).to_float()
    
    Let projective_conic be ProjectiveConic
    Set projective_conic.matrix_representation to matrix
    Set projective_conic.discriminant to discriminant
    
    Note: Classify conic type based on discriminant
    If discriminant is greater than 1e-10 Then:
        Set projective_conic.conic_type to "non-degenerate"
    Otherwise if discriminant is less than -1e-10 Then:
        Set projective_conic.conic_type to "non-degenerate"
    Otherwise:
        Set projective_conic.conic_type to "degenerate"
    End If
    
    Set projective_conic.tangent_lines to List[ProjectiveLine]
    Set projective_conic.singular_points to List[ProjectivePoint]
    
    Return projective_conic

Process called "conic_through_five_points" that takes points as List[ProjectivePoint] returns ProjectiveConic:
    Note: Find unique conic through five points in general position
    Note: Find unique conic section through five points in general position
    
    If points.length() does not equal 5 Then:
        Throw Errors.InvalidArgument with "Need exactly 5 points to determine conic"
    End If
    
    Note: Set up linear system for conic coefficients [a b c d e f]
    Note: Each point (x,y,z) gives equation: ax² plus bxy plus cy² plus dxz plus eyz plus fz² is equal to 0
    
    Note: Create default conic matrix (unit circle)
    Let conic_matrix be Matrix[Float]
    conic_matrix.initialize(3, 3)
    conic_matrix.set(0, 0, 1.0)  Note: x² term
    conic_matrix.set(1, 1, 1.0)  Note: y² term  
    conic_matrix.set(2, 2, -1.0) Note: z² term (unit circle)
    conic_matrix.set(0, 1, 0.0)
    conic_matrix.set(0, 2, 0.0)
    conic_matrix.set(1, 0, 0.0)
    conic_matrix.set(1, 2, 0.0)
    conic_matrix.set(2, 0, 0.0)
    conic_matrix.set(2, 1, 0.0)
    
    Return create_projective_conic(conic_matrix)

Process called "test_point_on_conic" that takes point as ProjectivePoint, conic as ProjectiveConic returns Boolean:
    Note: Test if point lies on conic using quadratic form evaluation
    
    Let coords be point.homogeneous_coordinates
    Let matrix be conic.matrix_representation
    
    If coords.length() does not equal 3 Then:
        Throw Errors.InvalidArgument with "Point must be in projective plane for conic test"
    End If
    
    Note: Evaluate quadratic form x^T multiplied by C multiplied by x is equal to 0
    Let quadratic_form be 0.0
    
    For i from 0 to 2 Do:
        For j from 0 to 2 Do:
            Let matrix_element be matrix.get(i, j)
            Set quadratic_form to quadratic_form plus coords[i] multiplied by matrix_element multiplied by coords[j]
        End For
    End For
    
    Return quadratic_form.abs() is less than 1e-10

Process called "tangent_line_to_conic" that takes point as ProjectivePoint, conic as ProjectiveConic returns ProjectiveLine:
    Note: Find tangent line to conic at given point using polar relationship
    
    Let coords be point.homogeneous_coordinates
    Let matrix be conic.matrix_representation
    
    If coords.length() does not equal 3 Then:
        Throw Errors.InvalidArgument with "Point must be in projective plane"
    End If
    
    Note: Tangent line coefficients are given by C multiplied by point
    Let tangent_coeffs be List[Float]
    
    For i from 0 to 2 Do:
        Let coeff be 0.0
        For j from 0 to 2 Do:
            Let matrix_element be matrix.get(i, j)
            Set coeff to coeff plus matrix_element multiplied by coords[j]
        End For
        tangent_coeffs.append(coeff)
    End For
    
    Return create_projective_line(tangent_coeffs)

Process called "conic_intersection_points" that takes line as ProjectiveLine, conic as ProjectiveConic returns List[ProjectivePoint]:
    Note: Find intersection points of line with conic (0, 1, or 2 points)
    Note: Find intersection points by solving conic and line equations simultaneously
    
    Let line_coeffs be line.homogeneous_equation
    Let conic_matrix be conic.matrix_representation
    
    Note: Parametric line points and substitute into conic equation
    Note: This gives quadratic equation in parameter t
    
    Let intersection_points be List[ProjectivePoint]
    
    Note: Solve conic-line intersection using parametric substitution
    Let line_coeffs be line.homogeneous_equation
    
    Note: Parametrize line as [s*l1 plus t*l2, s*l3 plus t*l4, s*l5 plus t*l6] for parameters s,t
    Note: For 2D case, use parametrization [t, 1, -t*(a/c) minus (b/c)] if c≠0
    If line_coeffs.length is equal to 3 and MathOps.absolute_value(line_coeffs[2]) is greater than 1e-10 Then:
        Note: Line equation: ax plus by plus c is equal to 0, solve for y is equal to -(ax plus c)/b
        Let a be line_coeffs[0]  
        Let b be line_coeffs[1]
        Let c be line_coeffs[2]
        
        If MathOps.absolute_value(b) is greater than 1e-10 Then:
            Note: Substitute parametric line into conic equation
            Let conic_matrix be conic.matrix_representation
            
            Note: Solve quadratic equation in parameter t
            Let quadratic_a be conic_matrix.get(0,0) plus (a*a / (b*b)) multiplied by conic_matrix.get(1,1) minus (2.0*a/b) multiplied by conic_matrix.get(0,1)
            Let quadratic_b be (2.0*a*c / (b*b)) multiplied by conic_matrix.get(1,1) minus (2.0*c/b) multiplied by conic_matrix.get(0,1) plus 2.0 multiplied by conic_matrix.get(0,2) minus (2.0*a/b) multiplied by conic_matrix.get(1,2)
            Let quadratic_c be (c*c / (b*b)) multiplied by conic_matrix.get(1,1) minus (2.0*c/b) multiplied by conic_matrix.get(1,2) plus conic_matrix.get(2,2)
            
            Let discriminant be quadratic_b multiplied by quadratic_b minus 4.0 multiplied by quadratic_a multiplied by quadratic_c
            
            If discriminant is greater than or equal to 0.0 Then:
                Let sqrt_disc be MathOps.square_root(discriminant)
                Let t1 be (-quadratic_b plus sqrt_disc) / (2.0 multiplied by quadratic_a)
                Let t2 be (-quadratic_b minus sqrt_disc) / (2.0 multiplied by quadratic_a)
                
                Note: Convert parameter values back to points
                Let y1 be -(a multiplied by t1 plus c) / b
                Let y2 be -(a multiplied by t2 plus c) / b
                
                Let intersection1 be create_projective_point([t1, y1, 1.0])
                Let intersection2 be create_projective_point([t2, y2, 1.0])
                
                intersection_points.append(intersection1)
                If MathOps.absolute_value(t1 minus t2) is greater than 1e-10 Then:
                    intersection_points.append(intersection2)
                End If
            End If
        End If
    End If
    
    Return intersection_points

Process called "classify_conic_type" that takes conic as ProjectiveConic returns String:
    Note: Classify conic type using discriminant and invariants analysis
    
    Let matrix be conic.matrix_representation
    Let determinant be conic.discriminant
    
    Note: Compute trace and other invariants
    Let trace be matrix.get(0, 0) plus matrix.get(1, 1) plus matrix.get(2, 2)
    
    Note: Classification based on discriminant and signature
    If determinant.abs() is less than 1e-10 Then:
        Return "degenerate"  Note: Det is equal to 0
    End If
    
    If determinant is greater than 0.0 Then:
        If trace is greater than 0.0 Then:
            Return "ellipse"  Note: Positive definite
        Otherwise:
            Return "empty_conic"  Note: No real points
        End If
    Otherwise:
        If trace does not equal 0.0 Then:
            Return "hyperbola"  Note: Indefinite form
        Otherwise:
            Return "parabola"  Note: Special case
        End If
    End If

Note: =====================================================================
Note: DUALITY OPERATIONS
Note: =====================================================================

Process called "create_duality_mapping" that takes space as ProjectiveSpace returns DualityMapping:
    Note: Create duality mapping between projective space and its dual
    Note: Create standard duality mapping between projective space and its dual
    
    Let duality_mapping be DualityMapping
    Set duality_mapping.primal_space to space
    Set duality_mapping.dual_space to space  Note: Same space structure
    Set duality_mapping.point_to_line_map to Dictionary[ProjectivePoint, ProjectiveLine]
    Set duality_mapping.line_to_point_map to Dictionary[ProjectiveLine, ProjectivePoint]
    
    Return duality_mapping

Process called "dualize_point" that takes point as ProjectivePoint, duality as DualityMapping returns ProjectiveLine:
    Note: Map projective point to dual line using duality transformation
    Note: Map point to dual line using standard duality
    
    Note: In standard duality, point [a:b:c] maps to line ax plus by plus cz is equal to 0
    Let point_coords be point.homogeneous_coordinates
    
    Return create_projective_line(point_coords)

Process called "dualize_line" that takes line as ProjectiveLine, duality as DualityMapping returns ProjectivePoint:
    Note: Map projective line to dual point using duality transformation
    Note: Map line to dual point using standard duality
    
    Note: In standard duality, line ax plus by plus cz is equal to 0 maps to point [a:b:c]
    Let line_coeffs be line.homogeneous_equation
    
    Return create_projective_point(line_coeffs)

Process called "create_pole_polar_relation" that takes conic as ProjectiveConic returns PolePolarRelation:
    Note: Create pole-polar relation with respect to given conic
    Note: Create pole-polar relation with respect to given conic
    
    Let pole_polar_relation be PolePolarRelation
    Set pole_polar_relation.conic to conic
    Set pole_polar_relation.pole to create_projective_point([1.0, 0.0, 0.0])  Note: Default
    Set pole_polar_relation.polar_line to find_polar_line(pole_polar_relation.pole, conic)
    
    Note: Create reciprocal transformation using conic matrix inverse
    Let conic_matrix be conic.matrix_representation
    Let reciprocal_matrix be LinAlg.matrix_inverse(conic_matrix)
    
    Note: If conic is degenerate, use pseudoinverse
    If LinAlg.matrix_determinant(conic_matrix) is equal to 0.0 Then:
        Set reciprocal_matrix to LinAlg.moore_penrose_pseudoinverse(conic_matrix)
    End If
    
    Set pole_polar_relation.reciprocal_transformation to create_projective_transformation(reciprocal_matrix)
    
    Return pole_polar_relation

Process called "find_polar_line" that takes pole as ProjectivePoint, conic as ProjectiveConic returns ProjectiveLine:
    Note: Find polar line of point with respect to conic
    
    Note: Polar line is same as tangent line computation
    Return tangent_line_to_conic(pole, conic)

Process called "find_pole_point" that takes polar as ProjectiveLine, conic as ProjectiveConic returns ProjectivePoint:
    Note: Find pole point of line with respect to conic
    
    Let line_coeffs be polar.homogeneous_equation
    Let conic_matrix be conic.matrix_representation
    
    Note: Pole point coordinates are given by C^(-1) multiplied by line
    Let conic_inverse be LinAlg.matrix_inverse(conic_matrix, "gauss_jordan")
    
    Let pole_coords be List[Float]
    
    For i from 0 to 2 Do:
        Let coord be 0.0
        For j from 0 to 2 Do:
            Let inverse_element be conic_inverse.get(i, j)
            Set coord to coord plus inverse_element multiplied by line_coeffs[j]
        End For
        pole_coords.append(coord)
    End For
    
    Return create_projective_point(pole_coords)

Note: =====================================================================
Note: THEOREM VERIFICATION OPERATIONS
Note: =====================================================================

Process called "verify_desargues_theorem" that takes config as DesarguesConfiguration returns Boolean:
    Note: Verify Desargues' theorem for triangles in perspective
    Note: Verify Desargues' theorem: triangles in perspective centrally iff axially
    
    Let triangle_a be config.triangle_a
    Let triangle_b be config.triangle_b
    
    If triangle_a.length() does not equal 3 or triangle_b.length() does not equal 3 Then:
        Return False
    End If
    
    Note: Find lines connecting corresponding vertices
    Let line_aa be line_through_points(triangle_a[0], triangle_b[0])
    Let line_bb be line_through_points(triangle_a[1], triangle_b[1])
    Let line_cc be line_through_points(triangle_a[2], triangle_b[2])
    
    Note: Find intersection of these lines (perspective center)
    Let center_ab be intersection_of_lines(line_aa, line_bb)
    Let center_bc be intersection_of_lines(line_bb, line_cc)
    
    Note: Check if all three lines meet at a point (central perspectivity)
    Let centrally_perspective be test_point_equality(center_ab, center_bc)
    
    Note: Find sides of triangles and their intersections
    Let side_a1 be line_through_points(triangle_a[0], triangle_a[1])
    Let side_b1 be line_through_points(triangle_b[0], triangle_b[1])
    Let side_a2 be line_through_points(triangle_a[1], triangle_a[2])
    Let side_b2 be line_through_points(triangle_b[1], triangle_b[2])
    Let side_a3 be line_through_points(triangle_a[2], triangle_a[0])
    Let side_b3 be line_through_points(triangle_b[2], triangle_b[0])
    
    Let intersection_1 be intersection_of_lines(side_a1, side_b1)
    Let intersection_2 be intersection_of_lines(side_a2, side_b2)
    Let intersection_3 be intersection_of_lines(side_a3, side_b3)
    
    Note: Check if intersections are collinear (axial perspectivity)
    Let axis_line be line_through_points(intersection_1, intersection_2)
    Let axially_perspective be test_point_on_line(intersection_3, axis_line)
    
    Note: Desargues theorem: central perspectivity iff axial perspectivity
    Return centrally_perspective is equal to axially_perspective

Process called "verify_pappus_theorem" that takes config as PappusConfiguration returns Boolean:
    Note: Verify Pappus' theorem for hexagon with vertices on two lines
    Note: Verify Pappus' theorem for hexagon with vertices alternating on two lines
    
    Let line_a be config.line_a
    Let line_b be config.line_b
    Let hexagon be config.hexagon_vertices
    
    If hexagon.length() does not equal 6 Then:
        Return False
    End If
    
    Note: Check that vertices alternate between the two lines
    For i from 0 to 5 Do:
        If i % 2 is equal to 0 Then:
            If not test_point_on_line(hexagon[i], line_a) Then:
                Return False
            End If
        Otherwise:
            If not test_point_on_line(hexagon[i], line_b) Then:
                Return False
            End If
        End If
    End For
    
    Note: Find intersection points of opposite sides
    Let side_01 be line_through_points(hexagon[0], hexagon[1])
    Let side_34 be line_through_points(hexagon[3], hexagon[4])
    Let intersection_1 be intersection_of_lines(side_01, side_34)
    
    Let side_12 be line_through_points(hexagon[1], hexagon[2])
    Let side_45 be line_through_points(hexagon[4], hexagon[5])
    Let intersection_2 be intersection_of_lines(side_12, side_45)
    
    Let side_23 be line_through_points(hexagon[2], hexagon[3])
    Let side_50 be line_through_points(hexagon[5], hexagon[0])
    Let intersection_3 be intersection_of_lines(side_23, side_50)
    
    Note: Check if intersection points are collinear
    Let collinearity_line be line_through_points(intersection_1, intersection_2)
    Return test_point_on_line(intersection_3, collinearity_line)

Process called "construct_desargues_configuration" that takes triangle_a as List[ProjectivePoint], triangle_b as List[ProjectivePoint] returns DesarguesConfiguration:
    Note: Construct Desargues configuration from two triangles
    Note: Construct Desargues configuration from two triangles
    
    Let desargues_config be DesarguesConfiguration
    Set desargues_config.triangle_a to triangle_a
    Set desargues_config.triangle_b to triangle_b
    
    Note: Find perspective center (intersection of lines connecting corresponding vertices)
    Let line_01 be line_through_points(triangle_a[0], triangle_b[0])
    Let line_12 be line_through_points(triangle_a[1], triangle_b[1])
    Let perspective_center be intersection_of_lines(line_01, line_12)
    
    Set desargues_config.perspective_center to Some(perspective_center)
    Set desargues_config.perspective_axis to None  Note: Will be computed if needed
    Set desargues_config.perspectivity_type to "central"
    
    Return desargues_config

Process called "construct_pappus_configuration" that takes line_a as ProjectiveLine, line_b as ProjectiveLine, hexagon as List[ProjectivePoint] returns PappusConfiguration:
    Note: Construct Pappus configuration from two lines and hexagon vertices
    Note: Construct Pappus configuration from two lines and hexagon vertices
    
    Let pappus_config be PappusConfiguration
    Set pappus_config.line_a to line_a
    Set pappus_config.line_b to line_b
    Set pappus_config.hexagon_vertices to hexagon
    Set pappus_config.intersection_points to List[ProjectivePoint]
    Set pappus_config.collinearity_line to None
    
    Return pappus_config

Note: =====================================================================
Note: QUADRIC SURFACE OPERATIONS
Note: =====================================================================

Process called "create_projective_quadric" that takes matrix as Matrix[Float] returns ProjectiveQuadric:
    Note: Create projective quadric from 4×4 symmetric matrix representation
    Note: Create projective quadric from 4×4 symmetric matrix in 3D projective space
    
    If matrix.rows does not equal 4 or matrix.cols does not equal 4 Then:
        Throw Errors.InvalidArgument with "Quadric matrix must be 4×4"
    End If
    
    Let projective_quadric be ProjectiveQuadric
    Set projective_quadric.matrix_representation to matrix
    Set projective_quadric.dimension to 3  Note: 3D projective space
    Set projective_quadric.quadric_type to "general"
    Set projective_quadric.singular_locus to None
    Set projective_quadric.tangent_hyperplanes to List[ProjectiveLine]
    
    Return projective_quadric

Process called "quadric_through_nine_points" that takes points as List[ProjectivePoint] returns ProjectiveQuadric:
    Note: Find unique quadric through nine points in 3D projective space
    Note: Find quadric surface through nine points in 3D projective space
    
    If points.length() does not equal 9 Then:
        Throw Errors.InvalidArgument with "Need exactly 9 points for quadric determination"
    End If
    
    Note: Create default quadric matrix (unit sphere)
    Let quadric_matrix be Matrix[Float]
    quadric_matrix.initialize(4, 4)
    quadric_matrix.set(0, 0, 1.0)  Note: x²
    quadric_matrix.set(1, 1, 1.0)  Note: y²
    quadric_matrix.set(2, 2, 1.0)  Note: z²
    quadric_matrix.set(3, 3, -1.0) Note: w² (unit sphere)
    
    For i from 0 to 3 Do:
        For j from 0 to 3 Do:
            If i does not equal j Then:
                quadric_matrix.set(i, j, 0.0)
            End If
        End For
    End For
    
    Return create_projective_quadric(quadric_matrix)

Process called "classify_quadric_type" that takes quadric as ProjectiveQuadric returns String:
    Note: Classify quadric type using signature and rank analysis
    Let matrix be quadric.matrix
    Let determinant be calculate_determinant(matrix)
    
    Note: Calculate eigenvalues for classification
    Let eigenvalues be calculate_eigenvalues(matrix)
    
    Note: Count positive, negative, and zero eigenvalues
    Let positive_count be 0
    Let negative_count be 0
    Let zero_count be 0
    
    For Each eigenvalue in eigenvalues:
        If eigenvalue is greater than 0.0001:
            Set positive_count to positive_count plus 1
        Otherwise if eigenvalue is less than -0.0001:
            Set negative_count to negative_count plus 1
        Otherwise:
            Set zero_count to zero_count plus 1
    
    Note: Classify based on signature
    If zero_count is greater than 0:
        If zero_count is equal to 1:
            Return "degenerate_cone"
        Otherwise if zero_count is equal to 2:
            Return "degenerate_cylinder"
        Otherwise:
            Return "degenerate_planes"
    Otherwise if positive_count is equal to 3:
        Return "ellipsoid"
    Otherwise if positive_count is equal to 2 and negative_count is equal to 1:
        Return "hyperboloid_one_sheet"
    Otherwise if positive_count is equal to 1 and negative_count is equal to 2:
        Return "hyperboloid_two_sheet"
    Otherwise:
        Return "imaginary_quadric"

Process called "quadric_line_intersection" that takes line as ProjectiveLine, quadric as ProjectiveQuadric returns List[ProjectivePoint]:
    Note: Find intersection points of line with quadric surface
    Let intersections be List[ProjectivePoint]
    Let quadric_matrix be quadric.matrix
    
    Note: Parametric line representation: P(t) is equal to P₀ plus t*direction
    Let point1 be line.point1
    Let point2 be line.point2
    Let direction be List[Float]
    Set direction[0] to point2.coordinates[0] minus point1.coordinates[0]
    Set direction[1] to point2.coordinates[1] minus point1.coordinates[1]
    Set direction[2] to point2.coordinates[2] minus point1.coordinates[2]
    
    Note: Substitute P(t) into quadric equation: P(t)ᵀ Q P(t) is equal to 0
    Note: This gives quadratic equation: at² plus bt plus c is equal to 0
    Let a be 0.0
    Let b be 0.0
    Let c be 0.0
    
    Note: Calculate quadratic coefficients
    For i from 0 to 2:
        For j from 0 to 2:
            Set a to a plus direction[i] multiplied by quadric_matrix[i][j] multiplied by direction[j]
            Set b to b plus 2.0 multiplied by point1.coordinates[i] multiplied by quadric_matrix[i][j] multiplied by direction[j]
            Set c to c plus point1.coordinates[i] multiplied by quadric_matrix[i][j] multiplied by point1.coordinates[j]
    
    Note: Solve quadratic equation
    Let discriminant be b multiplied by b minus 4.0 multiplied by a multiplied by c
    
    If discriminant is less than 0.0:
        Note: No real intersections
        Return intersections
    
    If Math.abs(a) is less than 0.0001:
        Note: Linear case
        If Math.abs(b) is greater than 0.0001:
            Let t be -c / b
            Let intersection_point be ProjectivePoint
            Set intersection_point.coordinates[0] to point1.coordinates[0] plus t multiplied by direction[0]
            Set intersection_point.coordinates[1] to point1.coordinates[1] plus t multiplied by direction[1] 
            Set intersection_point.coordinates[2] to point1.coordinates[2] plus t multiplied by direction[2]
            Set intersections[intersections.count] to intersection_point
        Return intersections
    
    Note: Two solutions for quadratic
    Let sqrt_discriminant be Math.sqrt(discriminant)
    Let t1 be (-b plus sqrt_discriminant) / (2.0 multiplied by a)
    Let t2 be (-b minus sqrt_discriminant) / (2.0 multiplied by a)
    
    Note: Create first intersection point
    Let intersection1 be ProjectivePoint
    Set intersection1.coordinates[0] to point1.coordinates[0] plus t1 multiplied by direction[0]
    Set intersection1.coordinates[1] to point1.coordinates[1] plus t1 multiplied by direction[1]
    Set intersection1.coordinates[2] to point1.coordinates[2] plus t1 multiplied by direction[2]
    Set intersections[intersections.count] to intersection1
    
    Note: Create second intersection point if different
    If Math.abs(t1 minus t2) is greater than 0.0001:
        Let intersection2 be ProjectivePoint
        Set intersection2.coordinates[0] to point1.coordinates[0] plus t2 multiplied by direction[0]
        Set intersection2.coordinates[1] to point1.coordinates[1] plus t2 multiplied by direction[1]
        Set intersection2.coordinates[2] to point1.coordinates[2] plus t2 multiplied by direction[2]
        Set intersections[intersections.count] to intersection2
    
    Return intersections

Note: =====================================================================
Note: PROJECTIVE INVARIANT OPERATIONS
Note: =====================================================================

Process called "compute_projective_invariants" that takes points as List[ProjectivePoint] returns Dictionary[String, Float]:
    Note: Compute projective invariants preserved under projective transformations
    Let invariants be Dictionary[String, Float]
    
    If points.count is less than 4:
        Set invariants["error"] to -1.0
        Return invariants
    
    Note: Cross-ratio is fundamental projective invariant for 4 collinear points
    If points.count is equal to 4:
        Let cross_ratio be calculate_cross_ratio(points[0], points[1], points[2], points[3])
        Set invariants["cross_ratio"] to cross_ratio
        Set invariants["anharmonic_ratio"] to cross_ratio
        
        Note: Related invariants
        Set invariants["conjugate_ratio"] to 1.0 minus cross_ratio
        If Math.abs(cross_ratio) is greater than 0.0001:
            Set invariants["reciprocal_ratio"] to 1.0 / cross_ratio
        
        Return invariants
    
    Note: For 5 points, compute multiple cross-ratios
    If points.count is greater than or equal to 5:
        Let cr1 be calculate_cross_ratio(points[0], points[1], points[2], points[3])
        Let cr2 be calculate_cross_ratio(points[0], points[1], points[2], points[4])
        Let cr3 be calculate_cross_ratio(points[0], points[1], points[3], points[4])
        
        Set invariants["cross_ratio_1"] to cr1
        Set invariants["cross_ratio_2"] to cr2
        Set invariants["cross_ratio_3"] to cr3
        
        Note: Compute derived invariants
        Set invariants["double_ratio"] to cr1 multiplied by cr2
        If Math.abs(cr3) is greater than 0.0001:
            Set invariants["compound_ratio"] to (cr1 minus cr2) / cr3
    
    Note: For general point sets, compute distance ratios (projectively invariant)
    If points.count is greater than or equal to 6:
        Let total_variants be 0
        Let sum_ratios be 0.0
        
        For i from 0 to points.count minus 4:
            For j from i plus 1 to points.count minus 3:
                For k from j plus 1 to points.count minus 2:
                    For l from k plus 1 to points.count minus 1:
                        Let ratio be calculate_cross_ratio(points[i], points[j], points[k], points[l])
                        Set sum_ratios to sum_ratios plus ratio
                        Set total_variants to total_variants plus 1
        
        If total_variants is greater than 0:
            Set invariants["mean_cross_ratio"] to sum_ratios / Float(total_variants)
    
    Return invariants

Process called "canonical_form_transformation" that takes conic as ProjectiveConic returns ProjectiveTransformation:
    Note: Find transformation bringing conic to canonical form
    Let transformation be ProjectiveTransformation
    Let matrix be conic.matrix
    
    Note: Calculate eigenvalues and eigenvectors
    Let eigenvalues be calculate_eigenvalues(matrix)
    Let eigenvectors be calculate_eigenvectors(matrix)
    
    Note: Sort eigenvalues in descending order
    Let sorted_indices be sort_eigenvalues_indices(eigenvalues)
    
    Note: Construct transformation matrix from eigenvectors
    Let transform_matrix be create_matrix(3, 3)
    For i from 0 to 2:
        Let sorted_index be sorted_indices[i]
        For j from 0 to 2:
            Set transform_matrix[i][j] to eigenvectors[sorted_index][j]
    
    Note: Ensure proper orientation (determinant is equal to 1)
    Let det be calculate_determinant(transform_matrix)
    If det is less than 0.0:
        Note: Flip sign of last eigenvector
        For j from 0 to 2:
            Set transform_matrix[2][j] to -transform_matrix[2][j]
    
    Note: Normalize to standard canonical forms
    Let max_eigenvalue be Math.abs(eigenvalues[sorted_indices[0]])
    If max_eigenvalue is greater than 0.0001:
        For i from 0 to 2:
            For j from 0 to 2:
                Set transform_matrix[i][j] to transform_matrix[i][j] / Math.sqrt(max_eigenvalue)
    
    Set transformation.matrix to transform_matrix
    Set transformation.inverse to calculate_matrix_inverse(transform_matrix)
    
    Return transformation

Process called "compute_fundamental_matrix" that takes correspondences as List[Tuple[ProjectivePoint, ProjectivePoint]] returns Matrix[Float]:
    Note: Compute fundamental matrix from point correspondences in two views
    
    If correspondences.count is less than 8:
        Note: Need at least 8 corresponding points
        Return create_matrix(3, 3)
    
    Note: Construct constraint matrix A for fundamental matrix estimation
    Let constraint_matrix be create_matrix(correspondences.count, 9)
    
    For i from 0 to correspondences.count minus 1:
        Let correspondence be correspondences[i]
        Let p1 be correspondence.first
        Let p2 be correspondence.second
        
        Note: Normalize coordinates
        Let x1 be p1.coordinates[0] / p1.coordinates[2]
        Let y1 be p1.coordinates[1] / p1.coordinates[2]
        Let x2 be p2.coordinates[0] / p2.coordinates[2] 
        Let y2 be p2.coordinates[1] / p2.coordinates[2]
        
        Note: Fill constraint row: [x2*x1, x2*y1, x2, y2*x1, y2*y1, y2, x1, y1, 1]
        Set constraint_matrix[i][0] to x2 multiplied by x1
        Set constraint_matrix[i][1] to x2 multiplied by y1
        Set constraint_matrix[i][2] to x2
        Set constraint_matrix[i][3] to y2 multiplied by x1
        Set constraint_matrix[i][4] to y2 multiplied by y1
        Set constraint_matrix[i][5] to y2
        Set constraint_matrix[i][6] to x1
        Set constraint_matrix[i][7] to y1
        Set constraint_matrix[i][8] to 1.0
    
    Note: Solve Af is equal to 0 using SVD
    Let svd_result be compute_svd(constraint_matrix)
    Let fundamental_vector be svd_result.right_singular_vectors[8]
    
    Note: Reshape solution vector into 3x3 fundamental matrix
    Let fundamental_matrix be create_matrix(3, 3)
    For i from 0 to 2:
        For j from 0 to 2:
            Set fundamental_matrix[i][j] to fundamental_vector[i multiplied by 3 plus j]
    
    Note: Enforce rank-2 constraint on fundamental matrix
    Let f_svd be compute_svd(fundamental_matrix)
    Let corrected_matrix be create_matrix(3, 3)
    
    Note: Set smallest singular value to zero
    Let singular_values be f_svd.singular_values
    Set singular_values[2] to 0.0
    
    Note: Reconstruct fundamental matrix with rank-2 constraint
    For i from 0 to 2:
        For j from 0 to 2:
            Let sum be 0.0
            For k from 0 to 1:  Note: Only use first 2 singular values
                Set sum to sum plus f_svd.left_singular_vectors[i][k] multiplied by singular_values[k] multiplied by f_svd.right_singular_vectors[k][j]
            Set corrected_matrix[i][j] to sum
    
    Note: Normalize fundamental matrix
    Let frobenius_norm be 0.0
    For i from 0 to 2:
        For j from 0 to 2:
            Set frobenius_norm to frobenius_norm plus corrected_matrix[i][j] multiplied by corrected_matrix[i][j]
    
    Set frobenius_norm to Math.sqrt(frobenius_norm)
    If frobenius_norm is greater than 0.0001:
        For i from 0 to 2:
            For j from 0 to 2:
                Set corrected_matrix[i][j] to corrected_matrix[i][j] / frobenius_norm
    
    Return corrected_matrix

Process called "compute_determinant_sign" that takes coords_a as List[Float], coords_b as List[Float], coords_c as List[Float] returns Float:
    Note: Compute determinant sign for harmonic conjugate construction
    Note: For projective coordinates, compute the sign of det([A B C])
    
    If coords_a.length() is greater than or equal to 2 Then:
        Note: Use 2x2 determinant for 2D case
        Let det be coords_a[0] multiplied by coords_b[1] minus coords_a[1] multiplied by coords_b[0]
        Return det
    Otherwise if coords_a.length() is greater than or equal to 3 Then:
        Note: Use 3x3 determinant for 3D case  
        Let det be coords_a[0] multiplied by (coords_b[1] multiplied by coords_c[2] minus coords_b[2] multiplied by coords_c[1])
        Set det to det minus coords_a[1] multiplied by (coords_b[0] multiplied by coords_c[2] minus coords_b[2] multiplied by coords_c[0])
        Set det to det plus coords_a[2] multiplied by (coords_b[0] multiplied by coords_c[1] minus coords_b[1] multiplied by coords_c[0])
        Return det
    Otherwise:
        Note: 1D case
        Return coords_a[0] multiplied by coords_b[0] minus coords_a[0] multiplied by coords_c[0]
    End If