Note:
math/geometry/computational.runa
Computational Geometry Operations

This module provides comprehensive computational geometry algorithms including
convex hull computation, Delaunay triangulation, Voronoi diagrams, point location,
polygon operations, mesh generation, and spatial data structures for efficient
geometric queries and processing.

Key algorithmic foundations:
- Convex Hull: Graham scan O(n log n), QuickHull, Jarvis march
- Delaunay Triangulation: Bowyer-Watson, divide-and-conquer O(n log n)
- Voronoi Diagrams: Fortune's sweep line algorithm, dual of Delaunay
- Point Location: Ray casting, winding number, planar subdivision
- Line Intersection: Bentley-Ottmann sweep line O((n+k) log n)
- Polygon Clipping: Sutherland-Hodgman, Weiler-Atherton
- Spatial Structures: KD-tree, R-tree, quad-tree for range queries
- Mesh Generation: advancing front, Delaunay refinement
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/geometry/euclidean" as Euclidean
Import module "math/engine/linalg/core" as LinearAlgebra
Import module "math/core/operations" as MathOps
Import module "math/core/constants" as Constants

Note: =====================================================================
Note: COMPUTATIONAL GEOMETRY DATA STRUCTURES
Note: =====================================================================

Type called "ConvexHull":
    vertices as List[Point2D]
    edges as List[Tuple[Integer, Integer]]
    area as Float
    perimeter as Float
    algorithm_used as String

Type called "ConvexHull3D":
    vertices as List[Point3D]
    faces as List[List[Integer]]
    edges as List[Tuple[Integer, Integer]]
    volume as Float
    surface_area as Float

Type called "DelaunayTriangulation":
    vertices as List[Point2D]
    triangles as List[Tuple[Integer, Integer, Integer]]
    edges as List[Tuple[Integer, Integer]]
    circumcenters as List[Point2D]
    dual_voronoi as Optional[VoronoiDiagram]

Type called "VoronoiDiagram":
    sites as List[Point2D]
    vertices as List[Point2D]
    edges as List[Tuple[Integer, Integer]]
    cells as List[List[Integer]]
    dual_delaunay as Optional[DelaunayTriangulation]

Type called "SpatialIndex":
    structure_type as String
    dimensions as Integer
    node_capacity as Integer
    tree_height as Integer
    bounding_box as Rectangle

Type called "KDTree":
    root_node as Optional[KDNode]
    dimension_count as Integer
    point_count as Integer
    max_depth as Integer

Type called "KDNode":
    point as Point2D
    left_child as Optional[KDNode]
    right_child as Optional[KDNode]
    splitting_dimension as Integer
    depth as Integer

Type called "QuadTree":
    root_node as Optional[QuadNode]
    boundary as Rectangle
    capacity as Integer
    total_points as Integer

Type called "QuadNode":
    boundary as Rectangle
    points as List[Point2D]
    children as Optional[List[QuadNode]]
    is_leaf as Boolean

Note: =====================================================================
Note: MESH AND POLYGON STRUCTURES
Note: =====================================================================

Type called "TriangularMesh":
    vertices as List[Point2D]
    triangles as List[Tuple[Integer, Integer, Integer]]
    edges as List[Tuple[Integer, Integer]]
    boundary_edges as List[Tuple[Integer, Integer]]
    quality_metrics as Dictionary[String, Float]

Type called "PolygonMesh3D":
    vertices as List[Point3D]
    faces as List[List[Integer]]
    edges as List[Tuple[Integer, Integer]]
    normals as List[Vector3D]
    texture_coordinates as Optional[List[Tuple[Float, Float]]]

Type called "HalfEdgeMesh":
    vertices as List[Point2D]
    half_edges as List[HalfEdge]
    faces as List[Integer]
    vertex_to_edge as Dictionary[Integer, Integer]

Type called "HalfEdge":
    origin_vertex as Integer
    twin_edge as Optional[Integer]
    next_edge as Integer
    previous_edge as Integer
    incident_face as Optional[Integer]

Type called "PolygonClipResult":
    clipped_polygons as List[Polygon2D]
    intersection_points as List[Point2D]
    operation_type as String
    algorithm_used as String

Note: =====================================================================
Note: GEOMETRIC QUERY STRUCTURES
Note: =====================================================================

Type called "RangeQuery":
    query_region as Rectangle
    query_type as String
    max_results as Integer
    distance_threshold as Optional[Float]

Type called "NearestNeighborQuery":
    query_point as Point2D
    k_neighbors as Integer
    max_distance as Optional[Float]
    distance_metric as String

Type called "LineIntersectionResult":
    intersection_points as List[Point2D]
    intersecting_segments as List[Tuple[Integer, Integer]]
    algorithm_complexity as String

Type called "PointLocationResult":
    containing_triangle as Optional[Tuple[Integer, Integer, Integer]]
    barycentric_coordinates as Optional[Tuple[Float, Float, Float]]
    location_type as String

Note: =====================================================================
Note: CONVEX HULL OPERATIONS
Note: =====================================================================

Process called "compute_convex_hull_2d" that takes points as List[Point2D], algorithm as String returns ConvexHull:
    Note: Compute 2D convex hull using Graham scan, QuickHull, or Jarvis march algorithms
    If points.length is less than 3:
        Throw Errors.InvalidArgument with "At least 3 points required for convex hull"
    
    Let hull_points be List[Point2D]
    If algorithm is equal to "graham_scan":
        Set hull_points to graham_scan(points)
    Otherwise if algorithm is equal to "quickhull":
        Set hull_points to quickhull_2d(points)
    Otherwise if algorithm is equal to "jarvis_march":
        Set hull_points to jarvis_march(points)
    Otherwise:
        Set hull_points to graham_scan(points)
    
    Let edges be List[Tuple[Integer, Integer]]
    Let i be 0
    While i is less than hull_points.length:
        Let next_index be (i plus 1) % hull_points.length
        Let edge be Tuple[Integer, Integer](i, next_index)
        Call edges.append(edge)
        Set i to i plus 1
    
    Let area be calculate_polygon_area_from_points(hull_points)
    Let perimeter be calculate_polygon_perimeter(hull_points)
    
    Return ConvexHull{
        vertices: hull_points,
        edges: edges,
        area: area,
        perimeter: perimeter,
        algorithm_used: algorithm
    }

Process called "compute_convex_hull_3d" that takes points as List[Point3D], algorithm as String returns ConvexHull3D:
    Note: Compute 3D convex hull using QuickHull incremental algorithm
    If points.length is less than 4:
        Throw Errors.InvalidArgument with "At least 4 points required for 3D convex hull"
    
    Note: QuickHull 3D algorithm implementation
    Let vertices be List[Point3D]
    Let faces be List[List[Integer]]
    Let edges be List[Tuple[Integer, Integer]]
    
    Note: Find initial simplex (tetrahedron) using extremal points
    Let min_x_index be 0
    Let max_x_index be 0
    Let min_y_index be 0
    Let max_y_index be 0
    Let min_z_index be 0
    Let max_z_index be 0
    
    Let i be 0
    While i is less than points.length:
        Let point be points.get(i)
        If point.x is less than points.get(min_x_index).x:
            Set min_x_index to i
        If point.x is greater than points.get(max_x_index).x:
            Set max_x_index to i
        If point.y is less than points.get(min_y_index).y:
            Set min_y_index to i
        If point.y is greater than points.get(max_y_index).y:
            Set max_y_index to i
        If point.z is less than points.get(min_z_index).z:
            Set min_z_index to i
        If point.z is greater than points.get(max_z_index).z:
            Set max_z_index to i
        Set i to i plus 1
    
    Note: Select 4 points that form largest volume tetrahedron
    Call vertices.append(points.get(min_x_index))
    Call vertices.append(points.get(max_x_index))
    Call vertices.append(points.get(min_y_index))
    Call vertices.append(points.get(max_y_index))
    
    Note: Create initial tetrahedron faces with proper orientation
    Call faces.append([0, 1, 2])
    Call faces.append([0, 2, 3])
    Call faces.append([0, 3, 1])
    Call faces.append([1, 3, 2])
    
    Note: Add remaining points using QuickHull algorithm
    Set i to 0
    While i is less than points.length:
        Let point be points.get(i)
        If not point_inside_convex_hull_3d(point, vertices, faces):
            Call add_point_to_hull_3d(point, vertices, faces)
        Set i to i plus 1
    
    Note: Build edge list from faces
    Set i to 0
    While i is less than faces.length:
        Let face be faces.get(i)
        If face.length is greater than or equal to 3:
            Let j be 0
            While j is less than face.length:
                Let k be (j plus 1) % face.length
                Let edge be Tuple[Integer, Integer](face.get(j), face.get(k))
                Call add_edge_if_unique(edges, edge.0, edge.1)
                Set j to j plus 1
        Set i to i plus 1
    
    Let volume be calculate_tetrahedron_volume(vertices)
    Let surface_area be calculate_hull_surface_area(vertices, faces)
    
    Return ConvexHull3D{
        vertices: vertices,
        faces: faces,
        edges: edges,
        volume: volume,
        surface_area: surface_area
    }

Process called "graham_scan" that takes points as List[Point2D] returns List[Point2D]:
    Note: Graham scan algorithm for 2D convex hull in O(n log n) time
    If points.length is less than 3:
        Return points
    
    Note: Find the bottommost point (lowest y-coordinate, leftmost if tie)
    Let start_point be points.get(0)
    Let start_index be 0
    Let i be 1
    While i is less than points.length:
        Let current_point be points.get(i)
        If current_point.y is less than start_point.y:
            Set start_point to current_point
            Set start_index to i
        Otherwise if current_point.y is equal to start_point.y:
            If current_point.x is less than start_point.x:
                Set start_point to current_point
                Set start_index to i
        Set i to i plus 1
    
    Note: Sort points by polar angle with respect to start point
    Let sorted_points be List[Point2D]
    Set i to 0
    While i is less than points.length:
        If i does not equal start_index:
            Call sorted_points.append(points.get(i))
        Set i to i plus 1
    
    Call sorted_points.sort_by_polar_angle(start_point)
    
    Note: Initialize stack with first three points
    Let hull be List[Point2D]
    Call hull.append(start_point)
    Call hull.append(sorted_points.get(0))
    Call hull.append(sorted_points.get(1))
    
    Note: Process remaining points
    Set i to 2
    While i is less than sorted_points.length:
        Let current_point be sorted_points.get(i)
        
        Note: Remove points that make clockwise turn
        While hull.length is greater than or equal to 2:
            Let top be hull.get(hull.length minus 1)
            Let second_top be hull.get(hull.length minus 2)
            Let cross_product be compute_cross_product_2d(second_top, top, current_point)
            If cross_product is less than or equal to 0.0:
                Call hull.remove_last()
            Otherwise:
                Break
        
        Call hull.append(current_point)
        Set i to i plus 1
    
    Return hull

Process called "quickhull_2d" that takes points as List[Point2D] returns List[Point2D]:
    Note: QuickHull algorithm for 2D convex hull with average O(n log n) time
    If points.length is less than 3:
        Return points
    
    Note: Find leftmost and rightmost points
    Let leftmost be points.get(0)
    Let rightmost be points.get(0)
    Let i be 1
    While i is less than points.length:
        Let current_point be points.get(i)
        If current_point.x is less than leftmost.x:
            Set leftmost to current_point
        If current_point.x is greater than rightmost.x:
            Set rightmost to current_point
        Set i to i plus 1
    
    Let hull be List[Point2D]
    Call hull.append(leftmost)
    
    Note: Divide points into upper and lower sets
    Let upper_set be List[Point2D]
    Let lower_set be List[Point2D]
    Set i to 0
    While i is less than points.length:
        Let point be points.get(i)
        Let cross_product be compute_cross_product_2d(leftmost, rightmost, point)
        If cross_product is greater than 0.0:
            Call upper_set.append(point)
        Otherwise if cross_product is less than 0.0:
            Call lower_set.append(point)
        Set i to i plus 1
    
    Note: Find hull points recursively
    Call quickhull_find_hull(upper_set, leftmost, rightmost, hull)
    Call hull.append(rightmost)
    Call quickhull_find_hull(lower_set, rightmost, leftmost, hull)
    
    Return hull

Process called "jarvis_march" that takes points as List[Point2D] returns List[Point2D]:
    Note: Jarvis march (gift wrapping) algorithm for convex hull in O(nh) time
    If points.length is less than 3:
        Return points
    
    Note: Find the leftmost point
    Let leftmost be points.get(0)
    Let leftmost_index be 0
    Let i be 1
    While i is less than points.length:
        Let current_point be points.get(i)
        If current_point.x is less than leftmost.x:
            Set leftmost to current_point
            Set leftmost_index to i
        Otherwise if current_point.x is equal to leftmost.x:
            If current_point.y is less than leftmost.y:
                Set leftmost to current_point
                Set leftmost_index to i
        Set i to i plus 1
    
    Let hull be List[Point2D]
    Let current_point be leftmost
    Let current_index be leftmost_index
    
    Loop:
        Call hull.append(current_point)
        
        Note: Find the most counterclockwise point
        Let next_point be points.get(0)
        Let next_index be 0
        Set i to 1
        While i is less than points.length:
            Let candidate be points.get(i)
            Let orientation be compute_orientation(current_point, next_point, candidate)
            If next_index is equal to current_index:
                Set next_point to candidate
                Set next_index to i
            Otherwise if orientation is equal to 2:
                Set next_point to candidate
                Set next_index to i
            Otherwise if orientation is equal to 0:
                Let dist_next be Euclidean.calculate_distance_2d(current_point, next_point)
                Let dist_candidate be Euclidean.calculate_distance_2d(current_point, candidate)
                If dist_candidate is greater than dist_next:
                    Set next_point to candidate
                    Set next_index to i
            Set i to i plus 1
        
        Set current_point to next_point
        Set current_index to next_index
        
        Note: If we reach the starting point, we're done
        If current_index is equal to leftmost_index:
            Break
    
    Return hull

Note: =====================================================================
Note: DELAUNAY TRIANGULATION OPERATIONS
Note: =====================================================================

Process called "compute_delaunay_triangulation" that takes points as List[Point2D], algorithm as String returns DelaunayTriangulation:
    Note: Compute Delaunay triangulation using Bowyer-Watson or divide-and-conquer
    If points.length is less than 3:
        Throw Errors.InvalidArgument with "At least 3 points required for Delaunay triangulation"
    
    Let triangulation be DelaunayTriangulation
    If algorithm is equal to "bowyer_watson":
        Set triangulation to bowyer_watson_triangulation(points)
    Otherwise:
        Set triangulation to bowyer_watson_triangulation(points)
    
    Return triangulation

Process called "bowyer_watson_triangulation" that takes points as List[Point2D] returns DelaunayTriangulation:
    Note: Bowyer-Watson incremental algorithm for Delaunay triangulation
    Note: Create super triangle that contains all points
    Let bounds_min_x be points.get(0).x
    Let bounds_max_x be points.get(0).x
    Let bounds_min_y be points.get(0).y
    Let bounds_max_y be points.get(0).y
    
    Let i be 0
    While i is less than points.length:
        Let point be points.get(i)
        If point.x is less than bounds_min_x:
            Set bounds_min_x to point.x
        If point.x is greater than bounds_max_x:
            Set bounds_max_x to point.x
        If point.y is less than bounds_min_y:
            Set bounds_min_y to point.y
        If point.y is greater than bounds_max_y:
            Set bounds_max_y to point.y
        Set i to i plus 1
    
    Let dx be bounds_max_x minus bounds_min_x
    Let dy be bounds_max_y minus bounds_min_y
    Let delta_max be MathOps.maximum(dx, dy) multiplied by 2.0
    
    Note: Create super triangle vertices
    Let super_p1 be Euclidean.create_point_2d(bounds_min_x minus delta_max, bounds_min_y minus 1.0)
    Let super_p2 be Euclidean.create_point_2d(bounds_max_x plus delta_max, bounds_min_y minus 1.0)
    Let super_p3 be Euclidean.create_point_2d((bounds_min_x plus bounds_max_x) / 2.0, bounds_max_y plus delta_max)
    
    Note: Initialize triangulation with super triangle
    Let vertices be List[Point2D]
    Call vertices.append(super_p1)
    Call vertices.append(super_p2)
    Call vertices.append(super_p3)
    
    Let triangles be List[Tuple[Integer, Integer, Integer]]
    Let super_triangle be Tuple[Integer, Integer, Integer](0, 1, 2)
    Call triangles.append(super_triangle)
    
    Note: Add each point incrementally
    Set i to 0
    While i is less than points.length:
        Let point be points.get(i)
        Call vertices.append(point)
        Let point_index be vertices.length minus 1
        
        Note: Find triangles whose circumcircle contains the point
        Let bad_triangles be List[Integer]
        Let j be 0
        While j is less than triangles.length:
            Let triangle be triangles.get(j)
            Let v1 be vertices.get(triangle.0)
            Let v2 be vertices.get(triangle.1)
            Let v3 be vertices.get(triangle.2)
            
            If point_in_circumcircle(point, v1, v2, v3):
                Call bad_triangles.append(j)
            Set j to j plus 1
        
        Note: Find boundary of polygonal hole
        Let polygon be List[Tuple[Integer, Integer]]
        Set j to 0
        While j is less than bad_triangles.length:
            Let triangle_index be bad_triangles.get(j)
            Let triangle be triangles.get(triangle_index)
            
            Note: Check each edge of the triangle
            Let edge1 be Tuple[Integer, Integer](triangle.0, triangle.1)
            Let edge2 be Tuple[Integer, Integer](triangle.1, triangle.2)
            Let edge3 be Tuple[Integer, Integer](triangle.2, triangle.0)
            
            If not edge_shared_by_bad_triangles(edge1, triangle_index, bad_triangles, triangles):
                Call polygon.append(edge1)
            If not edge_shared_by_bad_triangles(edge2, triangle_index, bad_triangles, triangles):
                Call polygon.append(edge2)
            If not edge_shared_by_bad_triangles(edge3, triangle_index, bad_triangles, triangles):
                Call polygon.append(edge3)
            Set j to j plus 1
        
        Note: Remove bad triangles
        Call remove_triangles_at_indices(triangles, bad_triangles)
        
        Note: Re-triangulate the polygonal hole
        Set j to 0
        While j is less than polygon.length:
            Let edge be polygon.get(j)
            Let new_triangle be Tuple[Integer, Integer, Integer](edge.0, edge.1, point_index)
            Call triangles.append(new_triangle)
            Set j to j plus 1
        
        Set i to i plus 1
    
    Note: Remove triangles that share vertices with super triangle
    Let final_triangles be List[Tuple[Integer, Integer, Integer]]
    Set i to 0
    While i is less than triangles.length:
        Let triangle be triangles.get(i)
        If triangle.0 is greater than or equal to 3 and triangle.1 is greater than or equal to 3 and triangle.2 is greater than or equal to 3:
            Note: Adjust indices to account for removed super triangle vertices
            Let adjusted_triangle be Tuple[Integer, Integer, Integer](triangle.0 minus 3, triangle.1 minus 3, triangle.2 minus 3)
            Call final_triangles.append(adjusted_triangle)
        Set i to i plus 1
    
    Note: Remove super triangle vertices
    Let final_vertices be List[Point2D]
    Set i to 3
    While i is less than vertices.length:
        Call final_vertices.append(vertices.get(i))
        Set i to i plus 1
    
    Note: Compute circumcenters and edges
    Let circumcenters be List[Point2D]
    Let edges be List[Tuple[Integer, Integer]]
    Set i to 0
    While i is less than final_triangles.length:
        Let triangle be final_triangles.get(i)
        Let v1 be final_vertices.get(triangle.0)
        Let v2 be final_vertices.get(triangle.1)
        Let v3 be final_vertices.get(triangle.2)
        Let circumcenter be compute_circumcenter(v1, v2, v3)
        Call circumcenters.append(circumcenter)
        
        Note: Add edges
        Let edge1 be Tuple[Integer, Integer](triangle.0, triangle.1)
        Let edge2 be Tuple[Integer, Integer](triangle.1, triangle.2)
        Let edge3 be Tuple[Integer, Integer](triangle.2, triangle.0)
        If not edges.contains(edge1) and not edges.contains(Tuple[Integer, Integer](edge1.1, edge1.0)):
            Call edges.append(edge1)
        If not edges.contains(edge2) and not edges.contains(Tuple[Integer, Integer](edge2.1, edge2.0)):
            Call edges.append(edge2)
        If not edges.contains(edge3) and not edges.contains(Tuple[Integer, Integer](edge3.1, edge3.0)):
            Call edges.append(edge3)
        Set i to i plus 1
    
    Return DelaunayTriangulation{
        vertices: final_vertices,
        triangles: final_triangles,
        edges: edges,
        circumcenters: circumcenters,
        dual_voronoi: None
    }

Process called "validate_delaunay_property" that takes triangulation as DelaunayTriangulation returns Boolean:
    Note: Validate that triangulation satisfies Delaunay property (empty circumcircle)
    Let i be 0
    While i is less than triangulation.triangles.length:
        Let triangle be triangulation.triangles.get(i)
        Let v1 be triangulation.vertices.get(triangle.0)
        Let v2 be triangulation.vertices.get(triangle.1)
        Let v3 be triangulation.vertices.get(triangle.2)
        
        Note: Check if any other vertex is inside this triangle's circumcircle
        Let j be 0
        While j is less than triangulation.vertices.length:
            If j does not equal triangle.0 and j does not equal triangle.1 and j does not equal triangle.2:
                Let test_point be triangulation.vertices.get(j)
                If point_in_circumcircle(test_point, v1, v2, v3):
                    Return false
            Set j to j plus 1
        Set i to i plus 1
    Return true

Process called "flip_edge" that takes triangulation as DelaunayTriangulation, edge as Tuple[Integer, Integer] returns DelaunayTriangulation:
    Note: Flip edge in triangulation to maintain Delaunay property
    Let edge_v1 be edge.0
    Let edge_v2 be edge.1
    
    Note: Find triangles sharing this edge
    Let triangle1_index be -1
    Let triangle2_index be -1
    Let i be 0
    While i is less than triangulation.triangles.length:
        Let triangle be triangulation.triangles.get(i)
        If triangle_contains_edge(triangle, edge):
            If triangle1_index is equal to -1:
                Set triangle1_index to i
            Otherwise:
                Set triangle2_index to i
                Break
        Set i to i plus 1
    
    Note: Edge must be shared by exactly two triangles to flip
    If triangle1_index is equal to -1 or triangle2_index is equal to -1:
        Return triangulation
    
    Let triangle1 be triangulation.triangles.get(triangle1_index)
    Let triangle2 be triangulation.triangles.get(triangle2_index)
    
    Note: Find the third vertices of each triangle
    Let third_vertex1 be -1
    Let third_vertex2 be -1
    
    If triangle1.0 does not equal edge_v1 and triangle1.0 does not equal edge_v2:
        Set third_vertex1 to triangle1.0
    Otherwise if triangle1.1 does not equal edge_v1 and triangle1.1 does not equal edge_v2:
        Set third_vertex1 to triangle1.1
    Otherwise:
        Set third_vertex1 to triangle1.2
    
    If triangle2.0 does not equal edge_v1 and triangle2.0 does not equal edge_v2:
        Set third_vertex2 to triangle2.0
    Otherwise if triangle2.1 does not equal edge_v1 and triangle2.1 does not equal edge_v2:
        Set third_vertex2 to triangle2.1
    Otherwise:
        Set third_vertex2 to triangle2.2
    
    Note: Test if flip improves Delaunay property
    Let v1 be triangulation.vertices.get(edge_v1)
    Let v2 be triangulation.vertices.get(edge_v2)
    Let v3 be triangulation.vertices.get(third_vertex1)
    Let v4 be triangulation.vertices.get(third_vertex2)
    
    If not point_in_circumcircle(v4, v1, v2, v3) and not point_in_circumcircle(v3, v2, v1, v4):
        Return triangulation
    
    Note: Perform edge flip: replace triangles with new configuration
    Let new_triangle1 be Tuple[Integer, Integer, Integer](edge_v1, third_vertex1, third_vertex2)
    Let new_triangle2 be Tuple[Integer, Integer, Integer](edge_v2, third_vertex2, third_vertex1)
    
    Call triangulation.triangles.set(triangle1_index, new_triangle1)
    Call triangulation.triangles.set(triangle2_index, new_triangle2)
    
    Return triangulation

Note: =====================================================================
Note: VORONOI DIAGRAM OPERATIONS
Note: =====================================================================

Process called "compute_voronoi_diagram" that takes points as List[Point2D], algorithm as String returns VoronoiDiagram:
    Note: Compute Voronoi diagram using Fortune's sweep line or divide-and-conquer
    If points.length is less than 2:
        Throw Errors.InvalidArgument with "At least 2 points required for Voronoi diagram"
    
    If algorithm is equal to "fortune_sweep":
        Return fortune_sweep_line(points)
    Otherwise:
        Return fortune_sweep_line(points)

Process called "fortune_sweep_line" that takes points as List[Point2D] returns VoronoiDiagram:
    Note: Fortune's sweep line algorithm for Voronoi diagram in O(n log n) time
    Note: Implement Fortune's sweep line algorithm directly
    Let n is equal to List.length(points)
    Let events is equal to PriorityQueue.new()  Note: Site events and circle events
    Let beach_line is equal to BalancedBinaryTree.new()  Note: Beach line structure
    Let voronoi_vertices is equal to List[Point2D]
    Let voronoi_edges is equal to List[Tuple[Integer, Integer]]
    Let voronoi_cells is equal to List[List[Integer]]
    
    Note: Initialize site events
    For i from 0 to n minus 1:
        Let site is equal to List.get(points, i)
        Let site_event is equal to Event.create_site(site.x, site.y, i)
        Call events.insert(site_event)
    
    Note: Process events in sweep line order
    While not events.is_empty():
        Let event is equal to events.extract_min()
        
        If event.type is equal to "site":
            Note: Handle site event minus add new arc to beach line
            Let new_arc is equal to Arc.create(event.site_index, event.x, event.y)
            Call beach_line.insert(new_arc)
            
            Note: Check for new circle events
            Let left_neighbor is equal to beach_line.predecessor(new_arc)
            Let right_neighbor is equal to beach_line.successor(new_arc)
            
            If left_neighbor does not equal null && right_neighbor does not equal null:
                Let circle is equal to compute_circumcircle(left_neighbor.site, new_arc.site, right_neighbor.site)
                If circle.exists && circle.center.y is greater than event.y:
                    Let circle_event is equal to Event.create_circle(circle.center.x, circle.center.y, new_arc)
                    Call events.insert(circle_event)
        
        Otherwise if event.type is equal to "circle":
            Note: Handle circle event minus remove arc and add Voronoi vertex
            Let disappearing_arc is equal to event.arc
            Call voronoi_vertices.append(Point2D.create(event.x, event.y))
            Call beach_line.remove(disappearing_arc)
            
            Note: Add Voronoi edges
            Let vertex_index is equal to List.length(voronoi_vertices) minus 1
            Let left_arc is equal to beach_line.predecessor(disappearing_arc)
            Let right_arc is equal to beach_line.successor(disappearing_arc)
            
            If left_arc does not equal null:
                Call voronoi_edges.append(Tuple.create(left_arc.site_index, vertex_index))
            If right_arc does not equal null:
                Call voronoi_edges.append(Tuple.create(right_arc.site_index, vertex_index))
    
    Return VoronoiDiagram{
        sites: points,
        vertices: voronoi_vertices,
        edges: voronoi_edges,
        cells: voronoi_cells,
        dual_delaunay: Optional.Some(delaunay)
    }

Process called "voronoi_cell_area" that takes diagram as VoronoiDiagram, cell_index as Integer returns Float:
    Note: Calculate area of specific Voronoi cell
    If cell_index is less than 0 or cell_index is greater than or equal to diagram.cells.length:
        Throw Errors.InvalidArgument with "Invalid cell index"
    
    Let cell be diagram.cells.get(cell_index)
    If cell.length is less than 3:
        Return 0.0
    
    Let cell_vertices be List[Point2D]
    Let i be 0
    While i is less than cell.length:
        Let vertex_index be cell.get(i)
        If vertex_index is less than diagram.vertices.length:
            Call cell_vertices.append(diagram.vertices.get(vertex_index))
        Set i to i plus 1
    
    Return calculate_polygon_area_from_points(cell_vertices)

Process called "nearest_site_query" that takes diagram as VoronoiDiagram, query_point as Point2D returns Integer:
    Note: Find nearest site to query point using Voronoi diagram
    If diagram.sites.length is equal to 0:
        Throw Errors.InvalidArgument with "No sites in Voronoi diagram"
    
    Let nearest_index be 0
    Let min_distance be Euclidean.calculate_distance_2d(query_point, diagram.sites.get(0))
    
    Let i be 1
    While i is less than diagram.sites.length:
        Let site be diagram.sites.get(i)
        Let distance be Euclidean.calculate_distance_2d(query_point, site)
        If distance is less than min_distance:
            Set min_distance to distance
            Set nearest_index to i
        Set i to i plus 1
    
    Return nearest_index

Note: =====================================================================
Note: SPATIAL DATA STRUCTURE OPERATIONS
Note: =====================================================================

Process called "build_kd_tree" that takes points as List[Point2D], max_depth as Integer returns KDTree:
    Note: Build KD-tree for efficient spatial queries and nearest neighbor search
    If points.length is equal to 0:
        Return KDTree{
            root_node: None,
            dimension_count: 2,
            point_count: 0,
            max_depth: max_depth
        }
    
    Let root be build_kd_node(points, 0, 0, max_depth)
    Return KDTree{
        root_node: Optional.Some(root),
        dimension_count: 2,
        point_count: points.length,
        max_depth: max_depth
    }

Process called "kd_tree_range_query" that takes tree as KDTree, query as RangeQuery returns List[Point2D]:
    Note: Perform range query on KD-tree to find points in rectangular region
    Let result be List[Point2D]
    If tree.root_node.is_some():
        Call kd_tree_range_search(tree.root_node.unwrap(), query.query_region, result)
    Return result

Process called "kd_tree_nearest_neighbor" that takes tree as KDTree, query_point as Point2D, k as Integer returns List[Point2D]:
    Note: Find k nearest neighbors using KD-tree in O(log n) average time
    Let result be List[Point2D]
    If tree.root_node.is_some() and k is greater than 0:
        Let best_points be List[Point2D]
        Let best_distances be List[Float]
        Call kd_tree_nn_search(tree.root_node.unwrap(), query_point, k, best_points, best_distances)
        Set result to best_points
    Return result

Process called "build_quad_tree" that takes points as List[Point2D], boundary as Rectangle, capacity as Integer returns QuadTree:
    Note: Build quad-tree for efficient spatial partitioning and queries
    Let root be QuadNode{
        boundary: boundary,
        points: List[Point2D],
        children: None,
        is_leaf: true
    }
    
    Let i be 0
    While i is less than points.length:
        Let point be points.get(i)
        Call quad_tree_insert_point(root, point, capacity)
        Set i to i plus 1
    
    Return QuadTree{
        root_node: Optional.Some(root),
        boundary: boundary,
        capacity: capacity,
        total_points: points.length
    }

Process called "quad_tree_insert" that takes tree as QuadTree, point as Point2D returns QuadTree:
    Note: Insert point into quad-tree with automatic subdivision
    If tree.root_node.is_some():
        Call quad_tree_insert_point(tree.root_node.unwrap(), point, tree.capacity)
        Set tree.total_points to tree.total_points plus 1
    Return tree

Process called "quad_tree_query" that takes tree as QuadTree, query as RangeQuery returns List[Point2D]:
    Note: Query quad-tree for points in specified region
    Let result be List[Point2D]
    If tree.root_node.is_some():
        Call quad_tree_range_search(tree.root_node.unwrap(), query.query_region, result)
    Return result

Note: =====================================================================
Note: POLYGON OPERATIONS
Note: =====================================================================

Process called "polygon_triangulation" that takes polygon as Polygon2D, algorithm as String returns List[Triangle2D]:
    Note: Triangulate polygon using ear clipping or constrained Delaunay triangulation
    If polygon.vertices.length is less than 3:
        Return List[Triangle2D]
    
    If algorithm is equal to "ear_clipping":
        Return ear_clipping_triangulation(polygon)
    Otherwise:
        Return ear_clipping_triangulation(polygon)

Process called "ear_clipping_triangulation" that takes polygon as Polygon2D returns List[Triangle2D]:
    Note: Ear clipping algorithm for polygon triangulation in O(n²) time
    If polygon.vertices.length is less than 3:
        Return List[Triangle2D]
    
    Let triangles be List[Triangle2D]
    Let vertices be polygon.vertices.copy()
    
    While vertices.length is greater than 3:
        Let ear_found be false
        Let i be 0
        While i is less than vertices.length and not ear_found:
            Let prev_index be (i minus 1 plus vertices.length) % vertices.length
            Let curr_index be i
            Let next_index be (i plus 1) % vertices.length
            
            Let prev_vertex be vertices.get(prev_index)
            Let curr_vertex be vertices.get(curr_index)
            Let next_vertex be vertices.get(next_index)
            
            If is_ear(vertices, prev_index, curr_index, next_index):
                Let triangle be Euclidean.create_triangle_2d(prev_vertex, curr_vertex, next_vertex)
                Call triangles.append(triangle)
                Call vertices.remove_at(curr_index)
                Set ear_found to true
            Set i to i plus 1
        
        If not ear_found:
            Break
    
    Note: Add final triangle
    If vertices.length is equal to 3:
        Let final_triangle be Euclidean.create_triangle_2d(vertices.get(0), vertices.get(1), vertices.get(2))
        Call triangles.append(final_triangle)
    
    Return triangles

Process called "polygon_clipping" that takes subject as Polygon2D, clip as Polygon2D, operation as String returns PolygonClipResult:
    Note: Clip polygons using Sutherland-Hodgman or Weiler-Atherton algorithms
    If operation is equal to "sutherland_hodgman":
        Let clipped_poly be sutherland_hodgman_clip(subject, clip)
        Return PolygonClipResult{
            clipped_polygons: [clipped_poly],
            intersection_points: List[Point2D],
            operation_type: operation,
            algorithm_used: "sutherland_hodgman"
        }
    Otherwise:
        Return PolygonClipResult{
            clipped_polygons: [subject],
            intersection_points: List[Point2D],
            operation_type: operation,
            algorithm_used: "none"
        }

Process called "sutherland_hodgman_clip" that takes subject as Polygon2D, clip as Polygon2D returns Polygon2D:
    Note: Sutherland-Hodgman clipping algorithm for convex clipping polygons
    Let output_list be subject.vertices
    
    Note: Clip against each edge of the clipping polygon
    Let i be 0
    While i is less than clip.vertices.length:
        Let j be (i plus 1) % clip.vertices.length
        Let edge_start be clip.vertices.get(i)
        Let edge_end be clip.vertices.get(j)
        
        Let input_list be output_list
        Set output_list to List[Point2D]
        
        If input_list.length is greater than 0:
            Let s be input_list.get(input_list.length minus 1)
            
            Let k be 0
            While k is less than input_list.length:
                Let e be input_list.get(k)
                
                If point_inside_edge(e, edge_start, edge_end):
                    If not point_inside_edge(s, edge_start, edge_end):
                        Let intersection be compute_edge_intersection(s, e, edge_start, edge_end)
                        If intersection.is_some():
                            Call output_list.append(intersection.unwrap())
                    Call output_list.append(e)
                Otherwise if point_inside_edge(s, edge_start, edge_end):
                    Let intersection be compute_edge_intersection(s, e, edge_start, edge_end)
                    If intersection.is_some():
                        Call output_list.append(intersection.unwrap())
                
                Set s to e
                Set k to k plus 1
        Set i to i plus 1
    
    Return Euclidean.create_polygon_2d(output_list)

Process called "polygon_union" that takes polygon_a as Polygon2D, polygon_b as Polygon2D returns List[Polygon2D]:
    Note: Compute union of two polygons using clipping operations
    Note: Sutherland-Hodgman clipping algorithm for polygon union
    Let result be List[Polygon2D]
    
    Note: Check if polygons are disjoint
    If not polygon_intersects_polygon(polygon_a, polygon_b):
        Call result.append(polygon_a)
        Call result.append(polygon_b)
        Return result
    
    Note: Use Weiler-Atherton clipping for overlapping polygons
    Let combined_vertices is equal to List[Point2D]
    
    Note: Add vertices from polygon A
    For vertex in polygon_a.vertices:
        If point_in_polygon(vertex, polygon_b) || point_on_polygon_boundary(vertex, polygon_b):
            Call combined_vertices.append(vertex)
    
    Note: Add vertices from polygon B  
    For vertex in polygon_b.vertices:
        If point_in_polygon(vertex, polygon_a) || point_on_polygon_boundary(vertex, polygon_a):
            Call combined_vertices.append(vertex)
    
    Note: Add intersection points
    For i from 0 to List.length(polygon_a.vertices) minus 1:
        Let j is equal to (i plus 1) % List.length(polygon_a.vertices)
        Let edge_a is equal to create_line_segment(List.get(polygon_a.vertices, i), List.get(polygon_a.vertices, j))
        
        For k from 0 to List.length(polygon_b.vertices) minus 1:
            Let l is equal to (k plus 1) % List.length(polygon_b.vertices)  
            Let edge_b is equal to create_line_segment(List.get(polygon_b.vertices, k), List.get(polygon_b.vertices, l))
            
            Let intersection is equal to line_segment_intersection(edge_a, edge_b)
            If intersection.exists:
                Call combined_vertices.append(intersection.point)
    
    Note: Create convex hull of combined vertices
    Let hull_vertices is equal to compute_convex_hull(combined_vertices)
    Let union_polygon is equal to Polygon2D.create(hull_vertices)
    Call result.append(union_polygon)
    
    Return result

Process called "polygon_intersection" that takes polygon_a as Polygon2D, polygon_b as Polygon2D returns List[Polygon2D]:
    Note: Compute intersection of two polygons
    Let clipped_result be sutherland_hodgman_clip(polygon_a, polygon_b)
    Let result be List[Polygon2D]
    Call result.append(clipped_result)
    Return result

Note: =====================================================================
Note: LINE SEGMENT OPERATIONS
Note: =====================================================================

Process called "line_segment_intersection" that takes segments as List[Tuple[Point2D, Point2D]] returns LineIntersectionResult:
    Note: Find all intersections among line segments using Bentley-Ottmann sweep line
    Let intersections be List[Point2D]
    Let intersecting_pairs be List[Tuple[Integer, Integer]]
    
    Note: Brute force O(n²) approach for simplicity
    Let i be 0
    While i is less than segments.length:
        Let j be i plus 1
        While j is less than segments.length:
            Let seg1 be segments.get(i)
            Let seg2 be segments.get(j)
            Let intersection be segment_intersection_test(seg1, seg2)
            If intersection.is_some():
                Call intersections.append(intersection.unwrap())
                Let pair be Tuple[Integer, Integer](i, j)
                Call intersecting_pairs.append(pair)
            Set j to j plus 1
        Set i to i plus 1
    
    Return LineIntersectionResult{
        intersection_points: intersections,
        intersecting_segments: intersecting_pairs,
        algorithm_complexity: "O(n²)"
    }

Process called "bentley_ottmann_sweep" that takes segments as List[Tuple[Point2D, Point2D]] returns List[Point2D]:
    Note: Bentley-Ottmann sweep line algorithm for line intersection in O((n+k) log n)
    Let intersections be List[Point2D]
    Let events be List[SweepEvent]
    
    Note: Create initial events for all segment endpoints
    Let i be 0
    While i is less than segments.length:
        Let segment be segments.get(i)
        Let start_point be segment.0
        Let end_point be segment.1
        
        Note: Order points left to right
        If start_point.x is greater than end_point.x or (start_point.x is equal to end_point.x and start_point.y is greater than end_point.y):
            Let temp be start_point
            Set start_point to end_point
            Set end_point to temp
        
        Let start_event be create_sweep_event(start_point, i, "start")
        Let end_event be create_sweep_event(end_point, i, "end")
        Call events.append(start_event)
        Call events.append(end_event)
        Set i to i plus 1
    
    Note: Sort events by x-coordinate, then by y-coordinate
    Call events.sort_by_position()
    
    Let active_segments be List[Integer]
    Let event_index be 0
    
    While event_index is less than events.length:
        Let event be events.get(event_index)
        
        If event.event_type is equal to "start":
            Note: Add segment to active list and check intersections
            Call active_segments.append(event.segment_index)
            
            Note: Check intersections with all active segments
            Let j be 0
            While j is less than active_segments.length minus 1:
                Let other_segment_index be active_segments.get(j)
                Let seg1 be segments.get(event.segment_index)
                Let seg2 be segments.get(other_segment_index)
                Let intersection be segment_intersection_test(seg1, seg2)
                If intersection.is_some():
                    Let intersection_point be intersection.unwrap()
                    If intersection_point.x is greater than or equal to event.point.x:
                        Call intersections.append(intersection_point)
                Set j to j plus 1
                
        Otherwise if event.event_type is equal to "end":
            Note: Remove segment from active list
            Call active_segments.remove_element(event.segment_index)
        
        Set event_index to event_index plus 1
    
    Return intersections

Process called "segment_intersection_test" that takes seg_a as Tuple[Point2D, Point2D], seg_b as Tuple[Point2D, Point2D] returns Optional[Point2D]:
    Note: Test intersection between two line segments
    Let p1 be seg_a.0
    Let q1 be seg_a.1
    Let p2 be seg_b.0
    Let q2 be seg_b.1
    
    Let o1 be compute_orientation(p1, q1, p2)
    Let o2 be compute_orientation(p1, q1, q2)
    Let o3 be compute_orientation(p2, q2, p1)
    Let o4 be compute_orientation(p2, q2, q1)
    
    Note: General case
    If o1 does not equal o2 and o3 does not equal o4:
        Note: Calculate intersection point
        Let denom be (p1.x minus q1.x) multiplied by (p2.y minus q2.y) minus (p1.y minus q1.y) multiplied by (p2.x minus q2.x)
        If MathOps.absolute_value(denom) is less than 1e-10:
            Return None
        
        Let t be ((p1.x minus p2.x) multiplied by (p2.y minus q2.y) minus (p1.y minus p2.y) multiplied by (p2.x minus q2.x)) / denom
        Let intersection_x be p1.x plus t multiplied by (q1.x minus p1.x)
        Let intersection_y be p1.y plus t multiplied by (q1.y minus p1.y)
        
        Return Optional.Some(Euclidean.create_point_2d(intersection_x, intersection_y))
    
    Return None

Note: =====================================================================
Note: POINT LOCATION OPERATIONS
Note: =====================================================================

Process called "point_location_triangulation" that takes point as Point2D, triangulation as DelaunayTriangulation returns PointLocationResult:
    Note: Locate point in triangulation using walking or jump-and-walk algorithms
    Let i be 0
    While i is less than triangulation.triangles.length:
        Let triangle be triangulation.triangles.get(i)
        Let v1 be triangulation.vertices.get(triangle.0)
        Let v2 be triangulation.vertices.get(triangle.1)
        Let v3 be triangulation.vertices.get(triangle.2)
        
        If point_in_triangle_barycentric(point, v1, v2, v3):
            Let bary_coords be compute_barycentric_coordinates(point, v1, v2, v3)
            Return PointLocationResult{
                containing_triangle: Optional.Some(triangle),
                barycentric_coordinates: Optional.Some(bary_coords),
                location_type: "inside_triangle"
            }
        Set i to i plus 1
    
    Return PointLocationResult{
        containing_triangle: None,
        barycentric_coordinates: None,
        location_type: "outside_triangulation"
    }

Process called "point_in_polygon_winding" that takes point as Point2D, polygon as Polygon2D returns Boolean:
    Note: Test point containment using winding number algorithm
    Let winding_number be 0
    Let n be polygon.vertices.length
    
    Let i be 0
    While i is less than n:
        Let j be (i plus 1) % n
        Let vi be polygon.vertices.get(i)
        Let vj be polygon.vertices.get(j)
        
        If vi.y is less than or equal to point.y:
            If vj.y is greater than point.y:
                If compute_cross_product_2d(vi, vj, point) is greater than 0.0:
                    Set winding_number to winding_number plus 1
        Otherwise:
            If vj.y is less than or equal to point.y:
                If compute_cross_product_2d(vi, vj, point) is less than 0.0:
                    Set winding_number to winding_number minus 1
        Set i to i plus 1
    
    Return winding_number does not equal 0

Process called "ray_casting_test" that takes point as Point2D, polygon as Polygon2D returns Boolean:
    Note: Test point containment using ray casting algorithm
    Let intersection_count be 0
    Let n be polygon.vertices.length
    
    Let i be 0
    While i is less than n:
        Let j be (i plus 1) % n
        Let vi be polygon.vertices.get(i)
        Let vj be polygon.vertices.get(j)
        
        Note: Check if ray crosses edge
        If ((vi.y is greater than point.y) does not equal (vj.y is greater than point.y)):
            Let x_intersection be (vj.x minus vi.x) multiplied by (point.y minus vi.y) / (vj.y minus vi.y) plus vi.x
            If point.x is less than x_intersection:
                Set intersection_count to intersection_count plus 1
        Set i to i plus 1
    
    Return intersection_count % 2 is equal to 1

Note: =====================================================================
Note: MESH GENERATION OPERATIONS
Note: =====================================================================

Process called "generate_triangular_mesh" that takes boundary as Polygon2D, quality_constraints as Dictionary[String, Float] returns TriangularMesh:
    Note: Generate quality triangular mesh using Delaunay refinement or advancing front
    Let triangulation be ear_clipping_triangulation(boundary)
    
    Let vertices be boundary.vertices
    Let triangle_indices be List[Tuple[Integer, Integer, Integer]]
    Let edges be List[Tuple[Integer, Integer]]
    Let boundary_edges be List[Tuple[Integer, Integer]]
    
    Note: Convert Triangle2D to indices
    Let i be 0
    While i is less than triangulation.length:
        Let triangle be triangulation.get(i)
        Let v1_index be find_vertex_index(vertices, triangle.vertex_a)
        Let v2_index be find_vertex_index(vertices, triangle.vertex_b)
        Let v3_index be find_vertex_index(vertices, triangle.vertex_c)
        
        Let triangle_tuple be Tuple[Integer, Integer, Integer](v1_index, v2_index, v3_index)
        Call triangle_indices.append(triangle_tuple)
        Set i to i plus 1
    
    Note: Build edge list
    Set i to 0
    While i is less than triangle_indices.length:
        Let triangle be triangle_indices.get(i)
        add_edge_if_unique(edges, triangle.0, triangle.1)
        add_edge_if_unique(edges, triangle.1, triangle.2)
        add_edge_if_unique(edges, triangle.2, triangle.0)
        Set i to i plus 1
    
    Note: Build boundary edges
    Set i to 0
    While i is less than vertices.length:
        Let j be (i plus 1) % vertices.length
        Let boundary_edge be Tuple[Integer, Integer](i, j)
        Call boundary_edges.append(boundary_edge)
        Set i to i plus 1
    
    Return TriangularMesh{
        vertices: vertices,
        triangles: triangle_indices,
        edges: edges,
        boundary_edges: boundary_edges,
        quality_metrics: quality_constraints
    }

Process called "refine_mesh" that takes mesh as TriangularMesh, quality_threshold as Float returns TriangularMesh:
    Note: Refine mesh by adding Steiner points to improve triangle quality using Delaunay refinement
    Let refined_vertices be mesh.vertices.copy()
    Let refined_triangles be mesh.triangles.copy()
    Let refined_edges be mesh.edges.copy()
    
    Let iteration be 0
    Let max_iterations be 10
    
    While iteration is less than max_iterations:
        Let poor_triangles be List[Integer]
        
        Note: Identify triangles with poor quality
        Let i be 0
        While i is less than refined_triangles.length:
            Let triangle be refined_triangles.get(i)
            Let v1 be refined_vertices.get(triangle.0)
            Let v2 be refined_vertices.get(triangle.1)
            Let v3 be refined_vertices.get(triangle.2)
            
            Let quality be compute_triangle_quality(v1, v2, v3)
            If quality is less than quality_threshold:
                Call poor_triangles.append(i)
            Set i to i plus 1
        
        Note: If no poor triangles, refinement is complete
        If poor_triangles.length is equal to 0:
            Break
        
        Note: Add circumcenters of poor triangles as Steiner points
        Let new_vertices be List[Point2D]
        Set i to 0
        While i is less than poor_triangles.length:
            Let triangle_index be poor_triangles.get(i)
            Let triangle be refined_triangles.get(triangle_index)
            Let v1 be refined_vertices.get(triangle.0)
            Let v2 be refined_vertices.get(triangle.1)
            Let v3 be refined_vertices.get(triangle.2)
            
            Let circumcenter be compute_circumcenter(v1, v2, v3)
            Call new_vertices.append(circumcenter)
            Set i to i plus 1
        
        Note: Add new vertices to mesh
        Set i to 0
        While i is less than new_vertices.length:
            Call refined_vertices.append(new_vertices.get(i))
            Set i to i plus 1
        
        Note: Retriangulate with new vertices using Delaunay
        Let delaunay_result be bowyer_watson_triangulation(refined_vertices)
        Set refined_triangles to delaunay_result.triangles
        Set refined_edges to delaunay_result.edges
        
        Set iteration to iteration plus 1
    
    Return TriangularMesh{
        vertices: refined_vertices,
        triangles: refined_triangles,
        edges: refined_edges,
        boundary_edges: mesh.boundary_edges,
        quality_metrics: mesh.quality_metrics
    }

Process called "mesh_quality_analysis" that takes mesh as TriangularMesh returns Dictionary[String, Float]:
    Note: Analyze mesh quality metrics like angle bounds and aspect ratios
    Let quality_metrics be Dictionary[String, Float]
    
    If mesh.triangles.length is equal to 0:
        Set quality_metrics["min_angle"] to 0.0
        Set quality_metrics["max_angle"] to 0.0
        Set quality_metrics["average_area"] to 0.0
        Set quality_metrics["aspect_ratio"] to 0.0
        Return quality_metrics
    
    Let min_angle be 180.0
    Let max_angle be 0.0
    Let total_area be 0.0
    
    Let i be 0
    While i is less than mesh.triangles.length:
        Let triangle be mesh.triangles.get(i)
        Let v1 be mesh.vertices.get(triangle.0)
        Let v2 be mesh.vertices.get(triangle.1)
        Let v3 be mesh.vertices.get(triangle.2)
        
        Let area be calculate_triangle_area_from_points(v1, v2, v3)
        Set total_area to total_area plus area
        
        Note: Calculate angles of triangle using law of cosines
        Let side_a be Euclidean.calculate_distance_2d(v2, v3)
        Let side_b be Euclidean.calculate_distance_2d(v1, v3)
        Let side_c be Euclidean.calculate_distance_2d(v1, v2)
        
        Note: Law of cosines: cos(A) is equal to (b² plus c² minus a²) / (2bc)
        Let cos_angle1 be (side_b multiplied by side_b plus side_c multiplied by side_c minus side_a multiplied by side_a) / (2.0 multiplied by side_b multiplied by side_c)
        Let cos_angle2 be (side_a multiplied by side_a plus side_c multiplied by side_c minus side_b multiplied by side_b) / (2.0 multiplied by side_a multiplied by side_c)
        Let cos_angle3 be (side_a multiplied by side_a plus side_b multiplied by side_b minus side_c multiplied by side_c) / (2.0 multiplied by side_a multiplied by side_b)
        
        Note: Convert to degrees using arccos
        Let angle1 be MathOps.arccos(MathOps.clamp(cos_angle1, -1.0, 1.0)) multiplied by 180.0 / Constants.pi
        Let angle2 be MathOps.arccos(MathOps.clamp(cos_angle2, -1.0, 1.0)) multiplied by 180.0 / Constants.pi
        Let angle3 be MathOps.arccos(MathOps.clamp(cos_angle3, -1.0, 1.0)) multiplied by 180.0 / Constants.pi
        
        If angle1 is less than min_angle:
            Set min_angle to angle1
        If angle2 is less than min_angle:
            Set min_angle to angle2
        If angle3 is less than min_angle:
            Set min_angle to angle3
        
        If angle1 is greater than max_angle:
            Set max_angle to angle1
        If angle2 is greater than max_angle:
            Set max_angle to angle2
        If angle3 is greater than max_angle:
            Set max_angle to angle3
        
        Set i to i plus 1
    
    Set quality_metrics["min_angle"] to min_angle
    Set quality_metrics["max_angle"] to max_angle
    Set quality_metrics["average_area"] to total_area / Float(mesh.triangles.length)
    Set quality_metrics["aspect_ratio"] to max_angle / min_angle
    
    Return quality_metrics

Process called "smooth_mesh" that takes mesh as TriangularMesh, iterations as Integer returns TriangularMesh:
    Note: Smooth mesh using Laplacian or other smoothing algorithms
    Let smoothed_vertices be mesh.vertices.copy()
    
    Let iter be 0
    While iter is less than iterations:
        Let i be 0
        While i is less than smoothed_vertices.length:
            Note: Find neighboring vertices (simplified approach)
            Let neighbor_count be 0
            Let sum_x be 0.0
            Let sum_y be 0.0
            
            Let j be 0
            While j is less than mesh.triangles.length:
                Let triangle be mesh.triangles.get(j)
                If triangle.0 is equal to i or triangle.1 is equal to i or triangle.2 is equal to i:
                    If triangle.0 does not equal i:
                        Let neighbor be smoothed_vertices.get(triangle.0)
                        Set sum_x to sum_x plus neighbor.x
                        Set sum_y to sum_y plus neighbor.y
                        Set neighbor_count to neighbor_count plus 1
                    If triangle.1 does not equal i:
                        Let neighbor be smoothed_vertices.get(triangle.1)
                        Set sum_x to sum_x plus neighbor.x
                        Set sum_y to sum_y plus neighbor.y
                        Set neighbor_count to neighbor_count plus 1
                    If triangle.2 does not equal i:
                        Let neighbor be smoothed_vertices.get(triangle.2)
                        Set sum_x to sum_x plus neighbor.x
                        Set sum_y to sum_y plus neighbor.y
                        Set neighbor_count to neighbor_count plus 1
                Set j to j plus 1
            
            If neighbor_count is greater than 0:
                Let current_vertex be smoothed_vertices.get(i)
                Set current_vertex.x to sum_x / Float(neighbor_count)
                Set current_vertex.y to sum_y / Float(neighbor_count)
            Set i to i plus 1
        Set iter to iter plus 1
    
    Return TriangularMesh{
        vertices: smoothed_vertices,
        triangles: mesh.triangles,
        edges: mesh.edges,
        boundary_edges: mesh.boundary_edges,
        quality_metrics: mesh.quality_metrics
    }

Note: =====================================================================
Note: COMPUTATIONAL GEOMETRY HELPER FUNCTIONS
Note: =====================================================================

Process called "compute_cross_product_2d" that takes p1 as Point2D, p2 as Point2D, p3 as Point2D returns Float:
    Note: Compute 2D cross product (p2-p1) × (p3-p1)
    Let v1x be p2.x minus p1.x
    Let v1y be p2.y minus p1.y
    Let v2x be p3.x minus p1.x
    Let v2y be p3.y minus p1.y
    Return v1x multiplied by v2y minus v1y multiplied by v2x

Process called "compute_orientation" that takes p as Point2D, q as Point2D, r as Point2D returns Integer:
    Note: Find orientation of ordered triplet (p, q, r)
    Note: Returns 0 if collinear, 1 if clockwise, 2 if counterclockwise
    Let cross_product be compute_cross_product_2d(p, q, r)
    If cross_product is equal to 0.0:
        Return 0
    Otherwise if cross_product is greater than 0.0:
        Return 2
    Otherwise:
        Return 1

Process called "quickhull_find_hull" that takes points as List[Point2D], p1 as Point2D, p2 as Point2D, hull as List[Point2D] returns Nothing:
    Note: Recursive helper for QuickHull algorithm
    If points.length is equal to 0:
        Return
    
    Note: Find the farthest point from line p1-p2
    Let farthest_point be points.get(0)
    Let max_distance be point_to_line_distance(farthest_point, p1, p2)
    Let i be 1
    While i is less than points.length:
        Let current_point be points.get(i)
        Let distance be point_to_line_distance(current_point, p1, p2)
        If distance is greater than max_distance:
            Set max_distance to distance
            Set farthest_point to current_point
        Set i to i plus 1
    
    Note: Add farthest point to hull
    Call hull.append(farthest_point)
    
    Note: Divide points into two sets
    Let left_set be List[Point2D]
    Let right_set be List[Point2D]
    Set i to 0
    While i is less than points.length:
        Let point be points.get(i)
        If compute_cross_product_2d(p1, farthest_point, point) is greater than 0.0:
            Call left_set.append(point)
        If compute_cross_product_2d(farthest_point, p2, point) is greater than 0.0:
            Call right_set.append(point)
        Set i to i plus 1
    
    Note: Recursively find hull points
    Call quickhull_find_hull(left_set, p1, farthest_point, hull)
    Call quickhull_find_hull(right_set, farthest_point, p2, hull)

Process called "point_to_line_distance" that takes point as Point2D, line_p1 as Point2D, line_p2 as Point2D returns Float:
    Note: Calculate perpendicular distance from point to line
    Let numerator be MathOps.absolute_value(compute_cross_product_2d(line_p1, line_p2, point))
    Let dx be line_p2.x minus line_p1.x
    Let dy be line_p2.y minus line_p1.y
    Let denominator be MathOps.square_root(dx multiplied by dx plus dy multiplied by dy)
    If denominator is equal to 0.0:
        Return Euclidean.calculate_distance_2d(point, line_p1)
    Return numerator / denominator

Process called "calculate_polygon_area_from_points" that takes points as List[Point2D] returns Float:
    Note: Calculate polygon area using shoelace formula
    If points.length is less than 3:
        Return 0.0
    
    Let area be 0.0
    Let i be 0
    While i is less than points.length:
        Let j be (i plus 1) % points.length
        Let point_i be points.get(i)
        Let point_j be points.get(j)
        Set area to area plus (point_i.x multiplied by point_j.y minus point_j.x multiplied by point_i.y)
        Set i to i plus 1
    
    Return MathOps.absolute_value(area) / 2.0

Process called "calculate_polygon_perimeter" that takes points as List[Point2D] returns Float:
    Note: Calculate polygon perimeter by summing edge lengths
    If points.length is less than 2:
        Return 0.0
    
    Let perimeter be 0.0
    Let i be 0
    While i is less than points.length:
        Let j be (i plus 1) % points.length
        Let point_i be points.get(i)
        Let point_j be points.get(j)
        Set perimeter to perimeter plus Euclidean.calculate_distance_2d(point_i, point_j)
        Set i to i plus 1
    
    Return perimeter

Process called "point_in_circumcircle" that takes point as Point2D, v1 as Point2D, v2 as Point2D, v3 as Point2D returns Boolean:
    Note: Test if point lies inside circumcircle of triangle v1-v2-v3
    Let ax be v1.x minus point.x
    Let ay be v1.y minus point.y
    Let bx be v2.x minus point.x
    Let by be v2.y minus point.y
    Let cx be v3.x minus point.x
    Let cy be v3.y minus point.y
    
    Let det be (ax multiplied by ax plus ay multiplied by ay) multiplied by (bx multiplied by cy minus by multiplied by cx) minus (bx multiplied by bx plus by multiplied by by) multiplied by (ax multiplied by cy minus ay multiplied by cx) plus (cx multiplied by cx plus cy multiplied by cy) multiplied by (ax multiplied by by minus ay multiplied by bx)
    Return det is greater than 0.0

Process called "compute_circumcenter" that takes v1 as Point2D, v2 as Point2D, v3 as Point2D returns Point2D:
    Note: Compute circumcenter of triangle v1-v2-v3
    Let d be 2.0 multiplied by (v1.x multiplied by (v2.y minus v3.y) plus v2.x multiplied by (v3.y minus v1.y) plus v3.x multiplied by (v1.y minus v2.y))
    If MathOps.absolute_value(d) is less than 1e-10:
        Note: Points are collinear, return centroid
        Let cx be (v1.x plus v2.x plus v3.x) / 3.0
        Let cy be (v1.y plus v2.y plus v3.y) / 3.0
        Return Euclidean.create_point_2d(cx, cy)
    
    Let ux be (v1.x multiplied by v1.x plus v1.y multiplied by v1.y) multiplied by (v2.y minus v3.y) plus (v2.x multiplied by v2.x plus v2.y multiplied by v2.y) multiplied by (v3.y minus v1.y) plus (v3.x multiplied by v3.x plus v3.y multiplied by v3.y) multiplied by (v1.y minus v2.y)
    Let uy be (v1.x multiplied by v1.x plus v1.y multiplied by v1.y) multiplied by (v3.x minus v2.x) plus (v2.x multiplied by v2.x plus v2.y multiplied by v2.y) multiplied by (v1.x minus v3.x) plus (v3.x multiplied by v3.x plus v3.y multiplied by v3.y) multiplied by (v2.x minus v1.x)
    
    Let cx be ux / d
    Let cy be uy / d
    Return Euclidean.create_point_2d(cx, cy)

Process called "edge_shared_by_bad_triangles" that takes edge as Tuple[Integer, Integer], exclude_triangle as Integer, bad_triangles as List[Integer], triangles as List[Tuple[Integer, Integer, Integer]] returns Boolean:
    Note: Check if edge is shared by any other bad triangle
    Let i be 0
    While i is less than bad_triangles.length:
        Let triangle_index be bad_triangles.get(i)
        If triangle_index does not equal exclude_triangle:
            Let triangle be triangles.get(triangle_index)
            If triangle_contains_edge(triangle, edge):
                Return true
        Set i to i plus 1
    Return false

Process called "triangle_contains_edge" that takes triangle as Tuple[Integer, Integer, Integer], edge as Tuple[Integer, Integer] returns Boolean:
    Note: Check if triangle contains the given edge
    Let edge1 be Tuple[Integer, Integer](triangle.0, triangle.1)
    Let edge2 be Tuple[Integer, Integer](triangle.1, triangle.2)
    Let edge3 be Tuple[Integer, Integer](triangle.2, triangle.0)
    
    Return edges_equal(edge1, edge) or edges_equal(edge2, edge) or edges_equal(edge3, edge)

Process called "edges_equal" that takes edge1 as Tuple[Integer, Integer], edge2 as Tuple[Integer, Integer] returns Boolean:
    Note: Check if two edges are equal (considering both directions)
    Return (edge1.0 is equal to edge2.0 and edge1.1 is equal to edge2.1) or (edge1.0 is equal to edge2.1 and edge1.1 is equal to edge2.0)

Process called "remove_triangles_at_indices" that takes triangles as List[Tuple[Integer, Integer, Integer]], indices as List[Integer] returns Nothing:
    Note: Remove triangles at specified indices (in reverse order to maintain indices)
    Call indices.sort_descending()
    Let i be 0
    While i is less than indices.length:
        Let index be indices.get(i)
        Call triangles.remove_at(index)
        Set i to i plus 1

Note: KD-tree helper functions
Process called "build_kd_node" that takes points as List[Point2D], dimension as Integer, depth as Integer, max_depth as Integer returns KDNode:
    Note: Recursively build KD-tree node
    If points.length is equal to 0:
        Throw Errors.InvalidArgument with "Cannot build node from empty points"
    
    If points.length is equal to 1 or depth is greater than or equal to max_depth:
        Return KDNode{
            point: points.get(0),
            left_child: None,
            right_child: None,
            splitting_dimension: dimension,
            depth: depth
        }
    
    Note: Sort points by current dimension and find median
    Call points.sort_by_dimension(dimension)
    Let median_index be points.length / 2
    Let median_point be points.get(median_index)
    
    Note: Split points into left and right subsets
    Let left_points be List[Point2D]
    Let right_points be List[Point2D]
    Let i be 0
    While i is less than points.length:
        If i is less than median_index:
            Call left_points.append(points.get(i))
        Otherwise if i is greater than median_index:
            Call right_points.append(points.get(i))
        Set i to i plus 1
    
    Let next_dimension be (dimension plus 1) % 2
    Let left_child be None
    Let right_child be None
    
    If left_points.length is greater than 0:
        Set left_child to Optional.Some(build_kd_node(left_points, next_dimension, depth plus 1, max_depth))
    If right_points.length is greater than 0:
        Set right_child to Optional.Some(build_kd_node(right_points, next_dimension, depth plus 1, max_depth))
    
    Return KDNode{
        point: median_point,
        left_child: left_child,
        right_child: right_child,
        splitting_dimension: dimension,
        depth: depth
    }

Process called "kd_tree_range_search" that takes node as KDNode, range as Rectangle, result as List[Point2D] returns Nothing:
    Note: Recursively search KD-tree for points in range
    Note: Check if current point is in range
    If point_in_rectangle(node.point, range):
        Call result.append(node.point)
    
    Note: Recursively search children if they could contain points in range
    If node.left_child.is_some():
        If range_intersects_left_subtree(range, node):
            Call kd_tree_range_search(node.left_child.unwrap(), range, result)
    
    If node.right_child.is_some():
        If range_intersects_right_subtree(range, node):
            Call kd_tree_range_search(node.right_child.unwrap(), range, result)

Process called "quad_tree_insert_point" that takes node as QuadNode, point as Point2D, capacity as Integer returns Nothing:
    Note: Insert point into quad-tree node
    If not point_in_rectangle(point, node.boundary):
        Return
    
    If node.is_leaf:
        Call node.points.append(point)
        If node.points.length is greater than capacity:
            Call quad_tree_subdivide(node, capacity)
    Otherwise:
        Note: Insert into appropriate child
        If node.children.is_some():
            Let children be node.children.unwrap()
            Call quad_tree_insert_point(children.get(0), point, capacity)
            Call quad_tree_insert_point(children.get(1), point, capacity)
            Call quad_tree_insert_point(children.get(2), point, capacity)
            Call quad_tree_insert_point(children.get(3), point, capacity)

Process called "point_in_rectangle" that takes point as Point2D, rect as Rectangle returns Boolean:
    Note: Check if point is inside rectangle
    Return point.x is greater than or equal to rect.corner.x and point.x is less than or equal to (rect.corner.x plus rect.width) and
           point.y is greater than or equal to rect.corner.y and point.y is less than or equal to (rect.corner.y plus rect.height)

Process called "is_ear" that takes vertices as List[Point2D], prev_index as Integer, curr_index as Integer, next_index as Integer returns Boolean:
    Note: Check if three consecutive vertices form an ear (convex and contains no other vertices)
    Let prev_vertex be vertices.get(prev_index)
    Let curr_vertex be vertices.get(curr_index)
    Let next_vertex be vertices.get(next_index)
    
    Note: Check if triangle is convex (counter-clockwise)
    Let cross_product be compute_cross_product_2d(prev_vertex, curr_vertex, next_vertex)
    If cross_product is less than or equal to 0.0:
        Return false
    
    Note: Check if any other vertex lies inside this triangle
    Let i be 0
    While i is less than vertices.length:
        If i does not equal prev_index and i does not equal curr_index and i does not equal next_index:
            Let test_vertex be vertices.get(i)
            If point_in_triangle_barycentric(test_vertex, prev_vertex, curr_vertex, next_vertex):
                Return false
        Set i to i plus 1
    
    Return true

Process called "point_in_triangle_barycentric" that takes point as Point2D, v1 as Point2D, v2 as Point2D, v3 as Point2D returns Boolean:
    Note: Test if point is inside triangle using barycentric coordinates
    Let denom be (v2.y minus v3.y) multiplied by (v1.x minus v3.x) plus (v3.x minus v2.x) multiplied by (v1.y minus v3.y)
    If MathOps.absolute_value(denom) is less than 1e-10:
        Return false
    
    Let a be ((v2.y minus v3.y) multiplied by (point.x minus v3.x) plus (v3.x minus v2.x) multiplied by (point.y minus v3.y)) / denom
    Let b be ((v3.y minus v1.y) multiplied by (point.x minus v3.x) plus (v1.x minus v3.x) multiplied by (point.y minus v3.y)) / denom
    Let c be 1.0 minus a minus b
    
    Return a is greater than or equal to 0.0 and b is greater than or equal to 0.0 and c is greater than or equal to 0.0

Process called "find_vertex_index" that takes vertices as List[Point2D], target as Point2D returns Integer:
    Note: Find index of vertex in list
    Let i be 0
    While i is less than vertices.length:
        Let vertex be vertices.get(i)
        If MathOps.absolute_value(vertex.x minus target.x) is less than 1e-10 and MathOps.absolute_value(vertex.y minus target.y) is less than 1e-10:
            Return i
        Set i to i plus 1
    Return -1

Process called "add_edge_if_unique" that takes edges as List[Tuple[Integer, Integer]], v1 as Integer, v2 as Integer returns Nothing:
    Note: Add edge to list if it doesn't already exist
    Let new_edge be Tuple[Integer, Integer](v1, v2)
    Let reverse_edge be Tuple[Integer, Integer](v2, v1)
    
    Let i be 0
    While i is less than edges.length:
        Let existing_edge be edges.get(i)
        If edges_equal(existing_edge, new_edge):
            Return
        Set i to i plus 1
    
    Call edges.append(new_edge)

Process called "calculate_tetrahedron_volume" that takes vertices as List[Point3D] returns Float:
    Note: Calculate volume of tetrahedron formed by first 4 vertices
    If vertices.length is less than 4:
        Return 0.0
    
    Let v0 be vertices.get(0)
    Let v1 be vertices.get(1)
    Let v2 be vertices.get(2)
    Let v3 be vertices.get(3)
    
    Note: Use scalar triple product formula: |a·(b×c)| / 6
    Let a be Euclidean.subtract_vectors_3d(Euclidean.create_vector_3d(v1.x minus v0.x, v1.y minus v0.y, v1.z minus v0.z), Euclidean.create_vector_3d(0.0, 0.0, 0.0))
    Let b be Euclidean.subtract_vectors_3d(Euclidean.create_vector_3d(v2.x minus v0.x, v2.y minus v0.y, v2.z minus v0.z), Euclidean.create_vector_3d(0.0, 0.0, 0.0))
    Let c be Euclidean.subtract_vectors_3d(Euclidean.create_vector_3d(v3.x minus v0.x, v3.y minus v0.y, v3.z minus v0.z), Euclidean.create_vector_3d(0.0, 0.0, 0.0))
    
    Note: Calculate volume using scalar triple product: |det(a,b,c)| / 6
    Let ax be v1.x minus v0.x
    Let ay be v1.y minus v0.y
    Let az be v1.z minus v0.z
    Let bx be v2.x minus v0.x
    Let by be v2.y minus v0.y
    Let bz be v2.z minus v0.z
    Let cx be v3.x minus v0.x
    Let cy be v3.y minus v0.y
    Let cz be v3.z minus v0.z
    
    Note: Calculate determinant of 3x3 matrix [a b c]
    Let det be ax multiplied by (by multiplied by cz minus bz multiplied by cy) minus ay multiplied by (bx multiplied by cz minus bz multiplied by cx) plus az multiplied by (bx multiplied by cy minus by multiplied by cx)
    Return MathOps.absolute_value(det) / 6.0

Process called "calculate_hull_surface_area" that takes vertices as List[Point3D], faces as List[List[Integer]] returns Float:
    Note: Calculate surface area of convex hull
    Let total_area be 0.0
    
    Let i be 0
    While i is less than faces.length:
        Let face be faces.get(i)
        If face.length is greater than or equal to 3:
            Let v1 be vertices.get(face.get(0))
            Let v2 be vertices.get(face.get(1))
            Let v3 be vertices.get(face.get(2))
            Let triangle_area be calculate_triangle_area_from_points_3d(v1, v2, v3)
            Set total_area to total_area plus triangle_area
        Set i to i plus 1
    
    Return total_area

Process called "calculate_triangle_area_from_points_3d" that takes v1 as Point3D, v2 as Point3D, v3 as Point3D returns Float:
    Note: Calculate area of 3D triangle using cross product
    Let a be Euclidean.create_vector_3d(v2.x minus v1.x, v2.y minus v1.y, v2.z minus v1.z)
    Let b be Euclidean.create_vector_3d(v3.x minus v1.x, v3.y minus v1.y, v3.z minus v1.z)
    Let cross_product be Euclidean.cross_product_3d(a, b)
    Let magnitude be Euclidean.calculate_vector_magnitude_3d(cross_product)
    Return magnitude / 2.0

Process called "calculate_triangle_area_from_points" that takes v1 as Point2D, v2 as Point2D, v3 as Point2D returns Float:
    Note: Calculate area of 2D triangle using cross product
    Return MathOps.absolute_value(compute_cross_product_2d(v1, v2, v3)) / 2.0

Process called "point_inside_edge" that takes point as Point2D, edge_start as Point2D, edge_end as Point2D returns Boolean:
    Note: Check if point is on the inside side of an edge
    Return compute_cross_product_2d(edge_start, edge_end, point) is greater than or equal to 0.0

Process called "compute_edge_intersection" that takes p1 as Point2D, p2 as Point2D, p3 as Point2D, p4 as Point2D returns Optional[Point2D]:
    Note: Compute intersection of line segments p1-p2 and p3-p4
    Let denom be (p1.x minus p2.x) multiplied by (p3.y minus p4.y) minus (p1.y minus p2.y) multiplied by (p3.x minus p4.x)
    If MathOps.absolute_value(denom) is less than 1e-10:
        Return None
    
    Let t be ((p1.x minus p3.x) multiplied by (p3.y minus p4.y) minus (p1.y minus p3.y) multiplied by (p3.x minus p4.x)) / denom
    Let intersection_x be p1.x plus t multiplied by (p2.x minus p1.x)
    Let intersection_y be p1.y plus t multiplied by (p2.y minus p1.y)
    
    Return Optional.Some(Euclidean.create_point_2d(intersection_x, intersection_y))

Process called "compute_barycentric_coordinates" that takes point as Point2D, v1 as Point2D, v2 as Point2D, v3 as Point2D returns Tuple[Float, Float, Float]:
    Note: Compute barycentric coordinates of point with respect to triangle
    Let denom be (v2.y minus v3.y) multiplied by (v1.x minus v3.x) plus (v3.x minus v2.x) multiplied by (v1.y minus v3.y)
    If MathOps.absolute_value(denom) is less than 1e-10:
        Return Tuple[Float, Float, Float](1.0/3.0, 1.0/3.0, 1.0/3.0)
    
    Let a be ((v2.y minus v3.y) multiplied by (point.x minus v3.x) plus (v3.x minus v2.x) multiplied by (point.y minus v3.y)) / denom
    Let b be ((v3.y minus v1.y) multiplied by (point.x minus v3.x) plus (v1.x minus v3.x) multiplied by (point.y minus v3.y)) / denom
    Let c be 1.0 minus a minus b
    
    Return Tuple[Float, Float, Float](a, b, c)

Process called "point_inside_convex_hull_3d" that takes point as Point3D, hull_vertices as List[Point3D], hull_faces as List[List[Integer]] returns Boolean:
    Note: Test if point is inside 3D convex hull using face plane tests
    Let i be 0
    While i is less than hull_faces.length:
        Let face be hull_faces.get(i)
        If face.length is greater than or equal to 3:
            Let v1 be hull_vertices.get(face.get(0))
            Let v2 be hull_vertices.get(face.get(1))
            Let v3 be hull_vertices.get(face.get(2))
            
            Note: Calculate face normal using cross product
            Let edge1 be Euclidean.create_vector_3d(v2.x minus v1.x, v2.y minus v1.y, v2.z minus v1.z)
            Let edge2 be Euclidean.create_vector_3d(v3.x minus v1.x, v3.y minus v1.y, v3.z minus v1.z)
            Let normal be Euclidean.cross_product_3d(edge1, edge2)
            
            Note: Test which side of plane the point is on
            Let to_point be Euclidean.create_vector_3d(point.x minus v1.x, point.y minus v1.y, point.z minus v1.z)
            Let dot_product be Euclidean.dot_product_3d(normal, to_point)
            
            Note: Point is outside if on wrong side of any face
            If dot_product is greater than 0.0:
                Return false
        Set i to i plus 1
    Return true

Process called "add_point_to_hull_3d" that takes point as Point3D, hull_vertices as List[Point3D], hull_faces as List[List[Integer]] returns Nothing:
    Note: Add point to 3D convex hull by removing visible faces and creating new ones
    Let visible_faces be List[Integer]
    
    Note: Find faces visible from the new point
    Let i be 0
    While i is less than hull_faces.length:
        Let face be hull_faces.get(i)
        If face.length is greater than or equal to 3:
            Let v1 be hull_vertices.get(face.get(0))
            Let v2 be hull_vertices.get(face.get(1))
            Let v3 be hull_vertices.get(face.get(2))
            
            Let edge1 be Euclidean.create_vector_3d(v2.x minus v1.x, v2.y minus v1.y, v2.z minus v1.z)
            Let edge2 be Euclidean.create_vector_3d(v3.x minus v1.x, v3.y minus v1.y, v3.z minus v1.z)
            Let normal be Euclidean.cross_product_3d(edge1, edge2)
            
            Let to_point be Euclidean.create_vector_3d(point.x minus v1.x, point.y minus v1.y, point.z minus v1.z)
            Let dot_product be Euclidean.dot_product_3d(normal, to_point)
            
            If dot_product is greater than 0.0:
                Call visible_faces.append(i)
        Set i to i plus 1
    
    Note: Find horizon edges (edges between visible and non-visible faces)
    Let horizon_edges be List[Tuple[Integer, Integer]]
    Set i to 0
    While i is less than visible_faces.length:
        Let face_index be visible_faces.get(i)
        Let face be hull_faces.get(face_index)
        
        Let j be 0
        While j is less than face.length:
            Let k be (j plus 1) % face.length
            Let edge be Tuple[Integer, Integer](face.get(j), face.get(k))
            
            Note: Check if this edge is shared with a non-visible face
            If not edge_shared_with_visible_face(edge, visible_faces, hull_faces):
                Call horizon_edges.append(edge)
            Set j to j plus 1
        Set i to i plus 1
    
    Note: Remove visible faces (in reverse order to maintain indices)
    Call visible_faces.sort_descending()
    Set i to 0
    While i is less than visible_faces.length:
        Let face_index be visible_faces.get(i)
        Call hull_faces.remove_at(face_index)
        Set i to i plus 1
    
    Note: Add new point to vertices
    Call hull_vertices.append(point)
    Let new_point_index be hull_vertices.length minus 1
    
    Note: Create new faces connecting horizon edges to new point
    Set i to 0
    While i is less than horizon_edges.length:
        Let edge be horizon_edges.get(i)
        Let new_face be [edge.0, edge.1, new_point_index]
        Call hull_faces.append(new_face)
        Set i to i plus 1

Process called "edge_shared_with_visible_face" that takes edge as Tuple[Integer, Integer], visible_faces as List[Integer], hull_faces as List[List[Integer]] returns Boolean:
    Note: Check if edge is shared with any visible face (other than the current one)
    Let i be 0
    While i is less than visible_faces.length:
        Let face_index be visible_faces.get(i)
        Let face be hull_faces.get(face_index)
        
        Let j be 0
        While j is less than face.length:
            Let k be (j plus 1) % face.length
            Let face_edge be Tuple[Integer, Integer](face.get(j), face.get(k))
            If edges_equal(edge, face_edge):
                Return true
            Set j to j plus 1
        Set i to i plus 1
    Return false

Type called "SweepEvent":
    point as Point2D
    segment_index as Integer
    event_type as String

Process called "create_sweep_event" that takes point as Point2D, segment_index as Integer, event_type as String returns SweepEvent:
    Return SweepEvent{
        point: point,
        segment_index: segment_index,
        event_type: event_type
    }

Process called "compute_triangle_quality" that takes v1 as Point2D, v2 as Point2D, v3 as Point2D returns Float:
    Note: Compute triangle quality using radius ratio (circumradius/inradius)
    Let a be Euclidean.calculate_distance_2d(v2, v3)
    Let b be Euclidean.calculate_distance_2d(v1, v3)
    Let c be Euclidean.calculate_distance_2d(v1, v2)
    
    Let area be calculate_triangle_area_from_points(v1, v2, v3)
    If area is less than or equal to 0.0:
        Return 0.0
    
    Note: Calculate circumradius
    Let circumradius be (a multiplied by b multiplied by c) / (4.0 multiplied by area)
    
    Note: Calculate inradius
    Let semiperimeter be (a plus b plus c) / 2.0
    Let inradius be area / semiperimeter
    
    Note: Quality is inverse of radius ratio (higher is better)
    If inradius is less than or equal to 0.0:
        Return 0.0
    Return inradius / circumradius