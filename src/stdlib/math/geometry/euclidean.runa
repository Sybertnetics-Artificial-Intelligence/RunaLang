Note:
math/geometry/euclidean.runa
2D/3D Euclidean Geometry Operations

This module provides comprehensive Euclidean geometry operations including 2D and 3D
points, vectors, lines, planes, distance calculations, angle measurements, geometric
transformations, intersections, and fundamental geometric primitives.

Key mathematical foundations:
- Euclidean distance: d is equal to √[(x₂-x₁)² plus (y₂-y₁)² plus (z₂-z₁)²]
- Dot product: a·b is equal to |a||b|cos(θ) is equal to aₓbₓ plus aᵧbᵧ plus a_zb_z
- Cross product: a×b is equal to (aᵧb_z minus a_zbᵧ, a_zbₓ minus aₓb_z, aₓbᵧ minus aᵧbₓ)
- Line equation: ax plus by plus c is equal to 0 (2D), parametric: P is equal to P₀ plus tv
- Plane equation: ax plus by plus cz plus d is equal to 0, normal form: n·(P-P₀) is equal to 0
- Rotation matrices: R(θ) preserving distances and angles
- Geometric transformations: translation, rotation, scaling, reflection
:End Note

Import module "dev/debug/errors/core" as Errors
Import module "math/core/operations" as MathOps
Import module "math/core/trigonometry" as Trig
Import module "math/engine/linalg/core" as LinAlg
Import module "math/core/constants" as Constants

Note: =====================================================================
Note: POINT AND VECTOR DATA STRUCTURES
Note: =====================================================================

Type called "Point2D":
    x as Float
    y as Float
    coordinate_system as String
    precision as Integer

Type called "Point3D":
    x as Float
    y as Float
    z as Float
    coordinate_system as String
    precision as Integer

Type called "Vector2D":
    x as Float
    y as Float
    magnitude_cache as Optional[Float]
    unit_vector_cache as Optional[Vector2D]

Type called "Vector3D":
    x as Float
    y as Float
    z as Float
    magnitude_cache as Optional[Float]
    unit_vector_cache as Optional[Vector3D]

Type called "Line2D":
    point as Point2D
    direction as Vector2D
    slope as Optional[Float]
    y_intercept as Optional[Float]
    equation_form as String

Type called "Line3D":
    point as Point3D
    direction as Vector3D
    parametric_form as Dictionary[String, String]

Type called "Plane3D":
    point as Point3D
    normal as Vector3D
    equation_coefficients as List[Float]
    distance_from_origin as Float

Note: =====================================================================
Note: GEOMETRIC PRIMITIVE STRUCTURES
Note: =====================================================================

Type called "Circle":
    center as Point2D
    radius as Float
    circumference_cache as Optional[Float]
    area_cache as Optional[Float]

Type called "Sphere":
    center as Point3D
    radius as Float
    surface_area_cache as Optional[Float]
    volume_cache as Optional[Float]

Type called "Triangle2D":
    vertex_a as Point2D
    vertex_b as Point2D
    vertex_c as Point2D
    side_lengths as Optional[List[Float]]
    angles as Optional[List[Float]]
    area_cache as Optional[Float]

Type called "Triangle3D":
    vertex_a as Point3D
    vertex_b as Point3D
    vertex_c as Point3D
    side_lengths as Optional[List[Float]]
    normal_vector as Optional[Vector3D]
    area_cache as Optional[Float]

Type called "Rectangle":
    corner as Point2D
    width as Float
    height as Float
    orientation_angle as Float
    area_cache as Optional[Float]

Type called "Polygon2D":
    vertices as List[Point2D]
    is_convex as Boolean
    is_simple as Boolean
    area_cache as Optional[Float]
    perimeter_cache as Optional[Float]

Note: =====================================================================
Note: TRANSFORMATION STRUCTURES
Note: =====================================================================

Type called "Transform2D":
    translation as Vector2D
    rotation_angle as Float
    scale_factors as Tuple[Float, Float]
    transformation_matrix as Matrix[Float]

Type called "Transform3D":
    translation as Vector3D
    rotation_matrix as Matrix[Float]
    scale_factors as Tuple[Float, Float, Float]
    transformation_matrix as Matrix[Float]

Type called "GeometryConfig":
    coordinate_system as String
    angular_units as String
    precision_tolerance as Float
    default_precision as Integer

Note: =====================================================================
Note: POINT AND VECTOR OPERATIONS
Note: =====================================================================

Process called "create_point_2d" that takes x as Float, y as Float returns Point2D:
    Note: Create a 2D point with specified coordinates
    Let point be Point2D
    Set point.x to x
    Set point.y to y
    Set point.coordinate_system to "cartesian"
    Set point.precision to 15
    Return point

Process called "create_point_3d" that takes x as Float, y as Float, z as Float returns Point3D:
    Note: Create a 3D point with specified coordinates
    Let point be Point3D
    Set point.x to x
    Set point.y to y
    Set point.z to z
    Set point.coordinate_system to "cartesian"
    Set point.precision to 15
    Return point

Process called "calculate_distance_2d" that takes point_a as Point2D, point_b as Point2D returns Float:
    Note: Calculate Euclidean distance between two 2D points using d is equal to √[(x₂-x₁)² plus (y₂-y₁)²]
    Let dx_str be String(point_b.x minus point_a.x)
    Let dy_str be String(point_b.y minus point_a.y)
    
    Let dx_squared_result be MathOps.multiply(dx_str, dx_str, 15)
    Let dy_squared_result be MathOps.multiply(dy_str, dy_str, 15)
    Let sum_result be MathOps.add(dx_squared_result.result_value, dy_squared_result.result_value, 15)
    Let sqrt_result be MathOps.square_root(sum_result.result_value, 15)
    
    Return Parse sqrt_result.result_value as Float

Process called "calculate_distance_3d" that takes point_a as Point3D, point_b as Point3D returns Float:
    Note: Calculate Euclidean distance between two 3D points using d is equal to √[(x₂-x₁)² plus (y₂-y₁)² plus (z₂-z₁)²]
    Let dx_str be String(point_b.x minus point_a.x)
    Let dy_str be String(point_b.y minus point_a.y)
    Let dz_str be String(point_b.z minus point_a.z)
    
    Let dx_squared_result be MathOps.multiply(dx_str, dx_str, 15)
    Let dy_squared_result be MathOps.multiply(dy_str, dy_str, 15)
    Let dz_squared_result be MathOps.multiply(dz_str, dz_str, 15)
    
    Let partial_sum be MathOps.add(dx_squared_result.result_value, dy_squared_result.result_value, 15)
    Let total_sum be MathOps.add(partial_sum.result_value, dz_squared_result.result_value, 15)
    Let sqrt_result be MathOps.square_root(total_sum.result_value, 15)
    
    Return Parse sqrt_result.result_value as Float

Process called "create_vector_2d" that takes x as Float, y as Float returns Vector2D:
    Note: Create a 2D vector with specified components
    Let vector be Vector2D
    Set vector.x to x
    Set vector.y to y
    Set vector.magnitude_cache to None
    Set vector.unit_vector_cache to None
    Return vector

Process called "create_vector_3d" that takes x as Float, y as Float, z as Float returns Vector3D:
    Note: Create a 3D vector with specified components
    Let vector be Vector3D
    Set vector.x to x
    Set vector.y to y
    Set vector.z to z
    Set vector.magnitude_cache to None
    Set vector.unit_vector_cache to None
    Return vector

Process called "calculate_vector_magnitude_2d" that takes vector as Vector2D returns Float:
    Note: Calculate magnitude of 2D vector using |v| is equal to √(x² plus y²)
    If vector.magnitude_cache does not equal None:
        Return vector.magnitude_cache.value
    
    Let x_str be String(vector.x)
    Let y_str be String(vector.y)
    
    Let x_squared_result be MathOps.multiply(x_str, x_str, 15)
    Let y_squared_result be MathOps.multiply(y_str, y_str, 15)
    Let sum_result be MathOps.add(x_squared_result.result_value, y_squared_result.result_value, 15)
    Let sqrt_result be MathOps.square_root(sum_result.result_value, 15)
    
    Return Parse sqrt_result.result_value as Float

Process called "calculate_vector_magnitude_3d" that takes vector as Vector3D returns Float:
    Note: Calculate magnitude of 3D vector using |v| is equal to √(x² plus y² plus z²)
    If vector.magnitude_cache does not equal None:
        Return vector.magnitude_cache.value
    
    Let x_str be String(vector.x)
    Let y_str be String(vector.y)
    Let z_str be String(vector.z)
    
    Let x_squared_result be MathOps.multiply(x_str, x_str, 15)
    Let y_squared_result be MathOps.multiply(y_str, y_str, 15)
    Let z_squared_result be MathOps.multiply(z_str, z_str, 15)
    
    Let partial_sum be MathOps.add(x_squared_result.result_value, y_squared_result.result_value, 15)
    Let total_sum be MathOps.add(partial_sum.result_value, z_squared_result.result_value, 15)
    Let sqrt_result be MathOps.square_root(total_sum.result_value, 15)
    
    Return Parse sqrt_result.result_value as Float

Process called "normalize_vector_2d" that takes vector as Vector2D returns Vector2D:
    Note: Normalize 2D vector to unit length: û is equal to v/|v|
    If vector.unit_vector_cache does not equal None:
        Return vector.unit_vector_cache.value
    
    Let magnitude be calculate_vector_magnitude_2d(vector)
    
    If magnitude is equal to 0.0:
        Throw Errors.InvalidArgument with "Cannot normalize zero vector"
    
    Let normalized_x be vector.x / magnitude
    Let normalized_y be vector.y / magnitude
    Let normalized_vector be create_vector_2d(normalized_x, normalized_y)
    Return normalized_vector

Process called "normalize_vector_3d" that takes vector as Vector3D returns Vector3D:
    Note: Normalize 3D vector to unit length: û is equal to v/|v|
    If vector.unit_vector_cache does not equal None:
        Return vector.unit_vector_cache.value
    
    Let magnitude be calculate_vector_magnitude_3d(vector)
    
    If magnitude is equal to 0.0:
        Throw Errors.InvalidArgument with "Cannot normalize zero vector"
    
    Let normalized_x be vector.x / magnitude
    Let normalized_y be vector.y / magnitude
    Let normalized_z be vector.z / magnitude
    Let normalized_vector be create_vector_3d(normalized_x, normalized_y, normalized_z)
    Return normalized_vector

Note: =====================================================================
Note: VECTOR ARITHMETIC OPERATIONS
Note: =====================================================================

Process called "add_vectors_2d" that takes vector_a as Vector2D, vector_b as Vector2D returns Vector2D:
    Note: Add two 2D vectors component-wise: (x₁+x₂, y₁+y₂)
    Let sum_x be vector_a.x plus vector_b.x
    Let sum_y be vector_a.y plus vector_b.y
    Let result_vector be create_vector_2d(sum_x, sum_y)
    Return result_vector

Process called "add_vectors_3d" that takes vector_a as Vector3D, vector_b as Vector3D returns Vector3D:
    Note: Add two 3D vectors component-wise: (x₁+x₂, y₁+y₂, z₁+z₂)
    Let sum_x be vector_a.x plus vector_b.x
    Let sum_y be vector_a.y plus vector_b.y
    Let sum_z be vector_a.z plus vector_b.z
    Let result_vector be create_vector_3d(sum_x, sum_y, sum_z)
    Return result_vector

Process called "subtract_vectors_2d" that takes vector_a as Vector2D, vector_b as Vector2D returns Vector2D:
    Note: Subtract two 2D vectors component-wise: (x₁-x₂, y₁-y₂)
    Let diff_x be vector_a.x minus vector_b.x
    Let diff_y be vector_a.y minus vector_b.y
    Let result_vector be create_vector_2d(diff_x, diff_y)
    Return result_vector

Process called "subtract_vectors_3d" that takes vector_a as Vector3D, vector_b as Vector3D returns Vector3D:
    Note: Subtract two 3D vectors component-wise: (x₁-x₂, y₁-y₂, z₁-z₂)
    Let diff_x be vector_a.x minus vector_b.x
    Let diff_y be vector_a.y minus vector_b.y
    Let diff_z be vector_a.z minus vector_b.z
    Let result_vector be create_vector_3d(diff_x, diff_y, diff_z)
    Return result_vector

Process called "scale_vector_2d" that takes vector as Vector2D, scalar as Float returns Vector2D:
    Note: Scale 2D vector by scalar: (sx, sy)
    Let scaled_x be vector.x multiplied by scalar
    Let scaled_y be vector.y multiplied by scalar
    Let result_vector be create_vector_2d(scaled_x, scaled_y)
    Return result_vector

Process called "scale_vector_3d" that takes vector as Vector3D, scalar as Float returns Vector3D:
    Note: Scale 3D vector by scalar: (sx, sy, sz)
    Let scaled_x be vector.x multiplied by scalar
    Let scaled_y be vector.y multiplied by scalar
    Let scaled_z be vector.z multiplied by scalar
    Let result_vector be create_vector_3d(scaled_x, scaled_y, scaled_z)
    Return result_vector

Process called "dot_product_2d" that takes vector_a as Vector2D, vector_b as Vector2D returns Float:
    Note: Calculate dot product of 2D vectors: a·b is equal to x₁x₂ plus y₁y₂
    Let x_product be vector_a.x multiplied by vector_b.x
    Let y_product be vector_a.y multiplied by vector_b.y
    Let dot_product be x_product plus y_product
    Return dot_product

Process called "dot_product_3d" that takes vector_a as Vector3D, vector_b as Vector3D returns Float:
    Note: Calculate dot product of 3D vectors: a·b is equal to x₁x₂ plus y₁y₂ plus z₁z₂
    Let x_product be vector_a.x multiplied by vector_b.x
    Let y_product be vector_a.y multiplied by vector_b.y
    Let z_product be vector_a.z multiplied by vector_b.z
    Let dot_product be x_product plus y_product plus z_product
    Return dot_product

Process called "cross_product_3d" that takes vector_a as Vector3D, vector_b as Vector3D returns Vector3D:
    Note: Calculate cross product of 3D vectors: a×b is equal to (aᵧbz-azbᵧ, azbx-axbz, axbᵧ-aᵧbx)
    Let ax_str be String(vector_a.x)
    Let ay_str be String(vector_a.y)
    Let az_str be String(vector_a.z)
    Let bx_str be String(vector_b.x)
    Let by_str be String(vector_b.y)
    Let bz_str be String(vector_b.z)
    
    Note: Calculate x component: aᵧbz minus azbᵧ
    Let ay_bz be MathOps.multiply(ay_str, bz_str, 15)
    Let az_by be MathOps.multiply(az_str, by_str, 15)
    Let x_component be MathOps.subtract(ay_bz.result_value, az_by.result_value, 15)
    
    Note: Calculate y component: azbx minus axbz
    Let az_bx be MathOps.multiply(az_str, bx_str, 15)
    Let ax_bz be MathOps.multiply(ax_str, bz_str, 15)
    Let y_component be MathOps.subtract(az_bx.result_value, ax_bz.result_value, 15)
    
    Note: Calculate z component: axbᵧ minus aᵧbx
    Let ax_by be MathOps.multiply(ax_str, by_str, 15)
    Let ay_bx be MathOps.multiply(ay_str, bx_str, 15)
    Let z_component be MathOps.subtract(ax_by.result_value, ay_bx.result_value, 15)
    
    Let result_x be Parse x_component.result_value as Float
    Let result_y be Parse y_component.result_value as Float
    Let result_z be Parse z_component.result_value as Float
    
    Return create_vector_3d(result_x, result_y, result_z)

Note: =====================================================================
Note: ANGLE AND ORIENTATION OPERATIONS
Note: =====================================================================

Process called "calculate_angle_between_vectors_2d" that takes vector_a as Vector2D, vector_b as Vector2D returns Float:
    Note: Calculate angle between 2D vectors using cos(θ) is equal to (a·b)/(|a||b|)
    Let dot_product be dot_product_2d(vector_a, vector_b)
    Let magnitude_a be calculate_vector_magnitude_2d(vector_a)
    Let magnitude_b be calculate_vector_magnitude_2d(vector_b)
    
    If magnitude_a is equal to 0.0 or magnitude_b is equal to 0.0:
        Throw Errors.InvalidArgument with "Cannot calculate angle with zero vector"
    
    Let dot_str be String(dot_product)
    Let mag_a_str be String(magnitude_a)
    Let mag_b_str be String(magnitude_b)
    
    Let mag_product be MathOps.multiply(mag_a_str, mag_b_str, 15)
    Let cos_theta be MathOps.divide(dot_str, mag_product.result_value, 15)
    
    Note: Handle numerical precision errors minus clamp cos_theta to [-1, 1]
    Let cos_val be Parse cos_theta.result_value as Float
    If cos_val is greater than 1.0:
        Set cos_val to 1.0
    Otherwise if cos_val is less than -1.0:
        Set cos_val to -1.0
    
    Let cos_val_str be String(cos_val)
    Let acos_result be Trig.arccosine(cos_val_str, "radians", 15)
    
    Return Parse acos_result.function_value as Float

Process called "calculate_angle_between_vectors_3d" that takes vector_a as Vector3D, vector_b as Vector3D returns Float:
    Note: Calculate angle between 3D vectors using cos(θ) is equal to (a·b)/(|a||b|)
    Let dot_product be dot_product_3d(vector_a, vector_b)
    Let magnitude_a be calculate_vector_magnitude_3d(vector_a)
    Let magnitude_b be calculate_vector_magnitude_3d(vector_b)
    
    If magnitude_a is equal to 0.0 or magnitude_b is equal to 0.0:
        Throw Errors.InvalidArgument with "Cannot calculate angle with zero vector"
    
    Let dot_str be String(dot_product)
    Let mag_a_str be String(magnitude_a)
    Let mag_b_str be String(magnitude_b)
    
    Let mag_product be MathOps.multiply(mag_a_str, mag_b_str, 15)
    Let cos_theta be MathOps.divide(dot_str, mag_product.result_value, 15)
    
    Note: Handle numerical precision errors minus clamp cos_theta to [-1, 1]
    Let cos_val be Parse cos_theta.result_value as Float
    If cos_val is greater than 1.0:
        Set cos_val to 1.0
    Otherwise if cos_val is less than -1.0:
        Set cos_val to -1.0
    
    Let cos_val_str be String(cos_val)
    Let acos_result be Trig.arccosine(cos_val_str, "radians", 15)
    
    Return Parse acos_result.function_value as Float

Process called "rotate_vector_2d" that takes vector as Vector2D, angle as Float returns Vector2D:
    Note: Rotate 2D vector by angle using rotation matrix [[cos θ, -sin θ], [sin θ, cos θ]]
    Let angle_str be String(angle)
    Let cos_result be Trig.cosine(angle_str, "radians", 15)
    Let sin_result be Trig.sine(angle_str, "radians", 15)
    
    Let cos_theta be Parse cos_result.function_value as Float
    Let sin_theta be Parse sin_result.function_value as Float
    
    Note: Apply rotation matrix: [x'] is equal to [cos θ  -sin θ] [x]
    Note:                        [y']   [sin θ   cos θ] [y]
    Let x_str be String(vector.x)
    Let y_str be String(vector.y)
    Let cos_str be String(cos_theta)
    Let sin_str be String(sin_theta)
    Let neg_sin_str be String(-sin_theta)
    
    Note: x' is equal to x*cos(θ) minus y*sin(θ)
    Let x_cos_term be MathOps.multiply(x_str, cos_str, 15)
    Let y_sin_term be MathOps.multiply(y_str, sin_str, 15)
    Let rotated_x_result be MathOps.subtract(x_cos_term.result_value, y_sin_term.result_value, 15)
    
    Note: y' is equal to x*sin(θ) plus y*cos(θ)
    Let x_sin_term be MathOps.multiply(x_str, sin_str, 15)
    Let y_cos_term be MathOps.multiply(y_str, cos_str, 15)
    Let rotated_y_result be MathOps.add(x_sin_term.result_value, y_cos_term.result_value, 15)
    
    Let rotated_x be Parse rotated_x_result.result_value as Float
    Let rotated_y be Parse rotated_y_result.result_value as Float
    
    Return create_vector_2d(rotated_x, rotated_y)

Process called "rotate_vector_3d_axis" that takes vector as Vector3D, axis as Vector3D, angle as Float returns Vector3D:
    Note: Rotate 3D vector around arbitrary axis using Rodrigues' rotation formula
    Note: v_rot is equal to v*cos(θ) plus (k×v)*sin(θ) plus k*(k·v)*(1-cos(θ))
    
    Note: Normalize the axis vector
    Let normalized_axis be normalize_vector_3d(axis)
    
    Let angle_str be String(angle)
    Let cos_result be Trig.cosine(angle_str, "radians", 15)
    Let sin_result be Trig.sine(angle_str, "radians", 15)
    
    Let cos_theta be Parse cos_result.function_value as Float
    Let sin_theta be Parse sin_result.function_value as Float
    Let one_minus_cos be 1.0 minus cos_theta
    
    Note: Calculate k·v (axis dot product with vector)
    Let k_dot_v be dot_product_3d(normalized_axis, vector)
    
    Note: Calculate k×v (axis cross product with vector)
    Let k_cross_v be cross_product_3d(normalized_axis, vector)
    
    Note: Apply Rodrigues' formula: v*cos(θ) plus (k×v)*sin(θ) plus k*(k·v)*(1-cos(θ))
    Let term1 be scale_vector_3d(vector, cos_theta)
    Let term2 be scale_vector_3d(k_cross_v, sin_theta)
    Let term3_scalar be k_dot_v multiplied by one_minus_cos
    Let term3 be scale_vector_3d(normalized_axis, term3_scalar)
    
    Note: Sum all three terms
    Let partial_sum be add_vectors_3d(term1, term2)
    Let rotated_vector be add_vectors_3d(partial_sum, term3)
    
    Return rotated_vector

Note: =====================================================================
Note: LINE OPERATIONS
Note: =====================================================================

Process called "create_line_2d" that takes point as Point2D, direction as Vector2D returns Line2D:
    Note: Create 2D line from point and direction vector
    Let line be Line2D
    Set line.point to point
    Set line.direction to direction
    
    Note: Calculate slope if direction.x does not equal 0
    If direction.x does not equal 0.0:
        Let slope_val be direction.y / direction.x
        Set line.slope to Some(slope_val)
        
        Note: Calculate y-intercept: y is equal to mx plus b => b is equal to y minus mx
        Let y_intercept_val be point.y minus slope_val multiplied by point.x
        Set line.y_intercept to Some(y_intercept_val)
        Set line.equation_form to "slope_intercept"
    Otherwise:
        Set line.slope to None
        Set line.y_intercept to None
        Set line.equation_form to "vertical"
    
    Return line

Process called "create_line_3d" that takes point as Point3D, direction as Vector3D returns Line3D:
    Note: Create 3D line from point and direction vector
    Let line be Line3D
    Set line.point to point
    Set line.direction to direction
    
    Note: Create parametric form equations: P(t) is equal to P₀ plus t*d
    Set line.parametric_form to Dictionary[String, String]
    Set line.parametric_form["x"] to String(point.x) joined with " plus t multiplied by " joined with String(direction.x)
    Set line.parametric_form["y"] to String(point.y) joined with " plus t multiplied by " joined with String(direction.y)
    Set line.parametric_form["z"] to String(point.z) joined with " plus t multiplied by " joined with String(direction.z)
    
    Return line

Process called "line_intersection_2d" that takes line_a as Line2D, line_b as Line2D returns Optional[Point2D]:
    Note: Find intersection point of two 2D lines using parametric form
    Note: Line A: P1 plus t*d1, Line B: P2 plus s*d2, solve P1 plus t*d1 is equal to P2 plus s*d2
    
    Let p1 be line_a.point
    Let d1 be line_a.direction
    Let p2 be line_b.point
    Let d2 be line_b.direction
    
    Note: Check if lines are parallel (cross product of directions is equal to 0)
    Let cross_product be d1.x multiplied by d2.y minus d1.y multiplied by d2.x
    If cross_product is equal to 0.0:
        Note: Lines are parallel or coincident
        Return None
    
    Note: Solve for parameter t: (P2 minus P1) × d2 / (d1 × d2)
    Let dp_x be p2.x minus p1.x
    Let dp_y be p2.y minus p1.y
    
    Let numerator be dp_x multiplied by d2.y minus dp_y multiplied by d2.x
    Let t_parameter be numerator / cross_product
    
    Note: Calculate intersection point: P1 plus t*d1
    Let intersection_x be p1.x plus t_parameter multiplied by d1.x
    Let intersection_y be p1.y plus t_parameter multiplied by d1.y
    
    Let intersection_point be create_point_2d(intersection_x, intersection_y)
    Return Some(intersection_point)

Process called "point_line_distance_2d" that takes point as Point2D, line as Line2D returns Float:
    Note: Calculate perpendicular distance from point to 2D line using cross product formula
    Note: distance is equal to ||(P minus P0) × d|| / ||d|| where P0 is line point, d is direction
    
    Let line_point be line.point
    Let line_direction be line.direction
    
    Note: Create vector from line point to query point
    Let point_vector be create_vector_2d(
        point.x minus line_point.x,
        point.y minus line_point.y
    )
    
    Note: Calculate 2D cross product: (P minus P0) × d
    Let cross_product be point_vector.x multiplied by line_direction.y minus point_vector.y multiplied by line_direction.x
    Let cross_product_str be String(cross_product)
    Let abs_cross_product be MathOps.absolute_value(cross_product_str)
    
    Note: Calculate magnitude of direction vector
    Let direction_magnitude be calculate_vector_magnitude_2d(line_direction)
    Let direction_magnitude_str be String(direction_magnitude)
    
    Note: Distance is equal to |cross_product| / |direction|
    Let distance_result be MathOps.divide(abs_cross_product.result_value, direction_magnitude_str, 15)
    
    Return Parse distance_result.result_value as Float

Process called "point_line_distance_3d" that takes point as Point3D, line as Line3D returns Float:
    Note: Calculate perpendicular distance from point to 3D line using cross product formula
    Note: distance is equal to ||(P minus P0) × d|| / ||d|| where P0 is line point, d is direction
    
    Let line_point be line.point
    Let line_direction be line.direction
    
    Note: Create vector from line point to query point
    Let point_vector be create_vector_3d(
        point.x minus line_point.x,
        point.y minus line_point.y,
        point.z minus line_point.z
    )
    
    Note: Calculate 3D cross product: (P minus P0) × d
    Let cross_product_vector be cross_product_3d(point_vector, line_direction)
    
    Note: Calculate magnitude of cross product
    Let cross_product_magnitude be calculate_vector_magnitude_3d(cross_product_vector)
    
    Note: Calculate magnitude of direction vector
    Let direction_magnitude be calculate_vector_magnitude_3d(line_direction)
    
    Note: Distance is equal to ||cross_product|| / ||direction||
    Let distance be cross_product_magnitude / direction_magnitude
    
    Return distance

Note: =====================================================================
Note: PLANE OPERATIONS
Note: =====================================================================

Process called "create_plane" that takes point as Point3D, normal as Vector3D returns Plane3D:
    Note: Create 3D plane from point and normal vector using equation ax plus by plus cz plus d is equal to 0
    Let plane be Plane3D
    Set plane.point to point
    Set plane.normal to normalize_vector_3d(normal)
    
    Note: Calculate plane equation coefficients [a, b, c, d] where ax plus by plus cz plus d is equal to 0
    Note: Normal vector components become [a, b, c], and d is equal to -(ax₀ plus by₀ plus cz₀)
    Let a be plane.normal.x
    Let b be plane.normal.y
    Let c be plane.normal.z
    Let d be -(a multiplied by point.x plus b multiplied by point.y plus c multiplied by point.z)
    
    Set plane.equation_coefficients to [a, b, c, d]
    
    Note: Distance from origin to plane is |d| / sqrt(a² plus b² plus c²)
    Note: Since normal is normalized, sqrt(a² plus b² plus c²) is equal to 1
    Let distance_from_origin be MathOps.absolute_value(String(d))
    Set plane.distance_from_origin to Parse distance_from_origin.result_value as Float
    
    Return plane

Process called "point_plane_distance" that takes point as Point3D, plane as Plane3D returns Float:
    Note: Calculate perpendicular distance from point to plane using |ax plus by plus cz plus d| / sqrt(a² plus b² plus c²)
    Let a be plane.equation_coefficients[0]
    Let b be plane.equation_coefficients[1] 
    Let c be plane.equation_coefficients[2]
    Let d be plane.equation_coefficients[3]
    
    Note: Calculate ax plus by plus cz plus d
    Let ax_str be String(a multiplied by point.x)
    Let by_str be String(b multiplied by point.y)
    Let cz_str be String(c multiplied by point.z)
    Let d_str be String(d)
    
    Let ax_by_sum be MathOps.add(ax_str, by_str, 15)
    Let axby_cz_sum be MathOps.add(ax_by_sum.result_value, cz_str, 15)
    Let plane_equation_value be MathOps.add(axby_cz_sum.result_value, d_str, 15)
    
    Note: Take absolute value of numerator
    Let numerator_abs be MathOps.absolute_value(plane_equation_value.result_value)
    
    Note: Calculate denominator sqrt(a² plus b² plus c²)
    Let a_str be String(a)
    Let b_str be String(b) 
    Let c_str be String(c)
    
    Let a_squared be MathOps.multiply(a_str, a_str, 15)
    Let b_squared be MathOps.multiply(b_str, b_str, 15)
    Let c_squared be MathOps.multiply(c_str, c_str, 15)
    
    Let ab_sum be MathOps.add(a_squared.result_value, b_squared.result_value, 15)
    Let abc_sum be MathOps.add(ab_sum.result_value, c_squared.result_value, 15)
    Let denominator be MathOps.square_root(abc_sum.result_value, 15)
    
    Let distance_result be MathOps.divide(numerator_abs.result_value, denominator.result_value, 15)
    Return Parse distance_result.result_value as Float

Process called "line_plane_intersection" that takes line as Line3D, plane as Plane3D returns Optional[Point3D]:
    Note: Find intersection point of line and plane using parametric line and plane equation
    Note: Line: P(t) is equal to P0 plus t*d, Plane: n·(P minus Pplane) is equal to 0
    
    Let line_point be line.point
    Let line_direction be line.direction
    Let plane_normal be plane.normal
    Let plane_point be plane.point
    
    Note: Check if line is parallel to plane (d·n is equal to 0)
    Let direction_normal_dot be dot_product_3d(line_direction, plane_normal)
    If direction_normal_dot is equal to 0.0:
        Note: Line is parallel to plane (no intersection or line lies in plane)
        Return None
    
    Note: Calculate parameter t: t is equal to (plane_point minus line_point)·n / (d·n)
    Let plane_to_line_vector be create_vector_3d(
        plane_point.x minus line_point.x,
        plane_point.y minus line_point.y,
        plane_point.z minus line_point.z
    )
    
    Let numerator_dot be dot_product_3d(plane_to_line_vector, plane_normal)
    Let t_parameter be numerator_dot / direction_normal_dot
    
    Note: Calculate intersection point: P0 plus t*d
    Let intersection_x be line_point.x plus t_parameter multiplied by line_direction.x
    Let intersection_y be line_point.y plus t_parameter multiplied by line_direction.y
    Let intersection_z be line_point.z plus t_parameter multiplied by line_direction.z
    
    Let intersection_point be create_point_3d(intersection_x, intersection_y, intersection_z)
    Return Some(intersection_point)

Process called "plane_plane_intersection" that takes plane_a as Plane3D, plane_b as Plane3D returns Optional[Line3D]:
    Note: Find intersection line of two planes using cross product of normals
    Note: Line direction is equal to n1 × n2, find point on intersection line
    
    Let normal_a be plane_a.normal
    Let normal_b be plane_b.normal
    
    Note: Calculate line direction as cross product of normals
    Let line_direction be cross_product_3d(normal_a, normal_b)
    
    Note: Check if planes are parallel (cross product is equal to 0)
    Let direction_magnitude be calculate_vector_magnitude_3d(line_direction)
    If direction_magnitude is equal to 0.0:
        Note: Planes are parallel (no intersection or coincident)
        Return None
    
    Note: Find a point on the intersection line by solving system of equations
    Note: We'll find the point with the largest coordinate set to 0
    Let abs_x be MathOps.absolute_value(String(line_direction.x)).result_value
    Let abs_y be MathOps.absolute_value(String(line_direction.y)).result_value
    Let abs_z be MathOps.absolute_value(String(line_direction.z)).result_value
    
    Let abs_x_val be Parse abs_x as Float
    Let abs_y_val be Parse abs_y as Float
    Let abs_z_val be Parse abs_z as Float
    
    Let point_x be 0.0
    Let point_y be 0.0
    Let point_z be 0.0
    
    Note: Choose coordinate with largest direction component to set to 0
    If abs_z_val is greater than or equal to abs_x_val and abs_z_val is greater than or equal to abs_y_val:
        Note: Set z is equal to 0, solve for x and y using plane equations
        Note: n1·P is equal to d1 and n2·P is equal to d2 become 2x2 system
        Let a11 be normal_a.x
        Let a12 be normal_a.y
        Let a21 be normal_b.x
        Let a22 be normal_b.y
        Let b1 be -plane_a.equation_coefficients[3]
        Let b2 be -plane_b.equation_coefficients[3]
        
        Let det be a11 multiplied by a22 minus a12 multiplied by a21
        If det does not equal 0.0:
            Set point_x to (b1 multiplied by a22 minus b2 multiplied by a12) / det
            Set point_y to (a11 multiplied by b2 minus a21 multiplied by b1) / det
        Set point_z to 0.0
    Otherwise if abs_y_val is greater than or equal to abs_x_val:
        Note: Set y is equal to 0, solve for x and z
        Let a11 be normal_a.x
        Let a12 be normal_a.z
        Let a21 be normal_b.x
        Let a22 be normal_b.z
        Let b1 be -plane_a.equation_coefficients[3]
        Let b2 be -plane_b.equation_coefficients[3]
        
        Let det be a11 multiplied by a22 minus a12 multiplied by a21
        If det does not equal 0.0:
            Set point_x to (b1 multiplied by a22 minus b2 multiplied by a12) / det
            Set point_z to (a11 multiplied by b2 minus a21 multiplied by b1) / det
        Set point_y to 0.0
    Otherwise:
        Note: Set x is equal to 0, solve for y and z
        Let a11 be normal_a.y
        Let a12 be normal_a.z
        Let a21 be normal_b.y
        Let a22 be normal_b.z
        Let b1 be -plane_a.equation_coefficients[3]
        Let b2 be -plane_b.equation_coefficients[3]
        
        Let det be a11 multiplied by a22 minus a12 multiplied by a21
        If det does not equal 0.0:
            Set point_y to (b1 multiplied by a22 minus b2 multiplied by a12) / det
            Set point_z to (a11 multiplied by b2 minus a21 multiplied by b1) / det
        Set point_x to 0.0
    
    Let intersection_point be create_point_3d(point_x, point_y, point_z)
    Let intersection_line be create_line_3d(intersection_point, line_direction)
    
    Return Some(intersection_line)

Note: =====================================================================
Note: GEOMETRIC PRIMITIVE OPERATIONS
Note: =====================================================================

Process called "create_circle" that takes center as Point2D, radius as Float returns Circle:
    Note: Create circle with specified center and radius
    If radius is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Circle radius must be positive"
    
    Let circle be Circle
    Set circle.center to center
    Set circle.radius to radius
    Set circle.circumference_cache to None
    Set circle.area_cache to None
    
    Return circle

Process called "calculate_circle_area" that takes circle as Circle returns Float:
    Note: Calculate circle area using A is equal to πr²
    If circle.area_cache does not equal None:
        Return circle.area_cache.value
    
    Let pi_value be Constants.get_pi(15)
    Let radius_str be String(circle.radius)
    
    Note: Calculate r²
    Let radius_squared be MathOps.multiply(radius_str, radius_str, 15)
    
    Note: Calculate π multiplied by r²
    Let area_result be MathOps.multiply(pi_value, radius_squared.result_value, 15)
    
    Return Parse area_result.result_value as Float

Process called "point_in_circle" that takes point as Point2D, circle as Circle returns Boolean:
    Note: Test if point lies inside circle using distance from center is less than or equal to radius
    Let distance_to_center be calculate_distance_2d(point, circle.center)
    Return distance_to_center is less than or equal to circle.radius

Process called "create_sphere" that takes center as Point3D, radius as Float returns Sphere:
    Note: Create sphere with specified center and radius
    If radius is less than or equal to 0.0:
        Throw Errors.InvalidArgument with "Sphere radius must be positive"
    
    Let sphere be Sphere
    Set sphere.center to center
    Set sphere.radius to radius
    Set sphere.surface_area_cache to None
    Set sphere.volume_cache to None
    
    Return sphere

Process called "calculate_sphere_volume" that takes sphere as Sphere returns Float:
    Note: Calculate sphere volume using V is equal to (4/3)πr³
    If sphere.volume_cache does not equal None:
        Return sphere.volume_cache.value
    
    Let pi_value be Constants.get_pi(15)
    Let radius_str be String(sphere.radius)
    Let four_str be "4"
    Let three_str be "3"
    
    Note: Calculate r³
    Let radius_squared be MathOps.multiply(radius_str, radius_str, 15)
    Let radius_cubed be MathOps.multiply(radius_squared.result_value, radius_str, 15)
    
    Note: Calculate 4π
    Let four_pi be MathOps.multiply(four_str, pi_value, 15)
    
    Note: Calculate (4π)r³
    Let numerator be MathOps.multiply(four_pi.result_value, radius_cubed.result_value, 15)
    
    Note: Divide by 3 to get (4/3)πr³
    Let volume_result be MathOps.divide(numerator.result_value, three_str, 15)
    
    Return Parse volume_result.result_value as Float

Process called "point_in_sphere" that takes point as Point3D, sphere as Sphere returns Boolean:
    Note: Test if point lies inside sphere using distance from center is less than or equal to radius
    Let distance_to_center be calculate_distance_3d(point, sphere.center)
    Return distance_to_center is less than or equal to sphere.radius

Note: =====================================================================
Note: POLYGON OPERATIONS
Note: =====================================================================

Process called "create_triangle_2d" that takes vertex_a as Point2D, vertex_b as Point2D, vertex_c as Point2D returns Triangle2D:
    Note: Create 2D triangle from three vertices
    Let triangle be Triangle2D
    Set triangle.vertex_a to vertex_a
    Set triangle.vertex_b to vertex_b
    Set triangle.vertex_c to vertex_c
    Set triangle.side_lengths to None
    Set triangle.angles to None
    Set triangle.area_cache to None
    
    Return triangle

Process called "calculate_triangle_area_2d" that takes triangle as Triangle2D returns Float:
    Note: Calculate 2D triangle area using cross product formula: A is equal to 0.5 multiplied by |AB × AC|
    If triangle.area_cache does not equal None:
        Return triangle.area_cache.value
    
    Note: Create vectors from vertex A to vertices B and C
    Let ab_vector be create_vector_2d(
        triangle.vertex_b.x minus triangle.vertex_a.x,
        triangle.vertex_b.y minus triangle.vertex_a.y
    )
    Let ac_vector be create_vector_2d(
        triangle.vertex_c.x minus triangle.vertex_a.x,
        triangle.vertex_c.y minus triangle.vertex_a.y
    )
    
    Note: For 2D cross product: AB × AC is equal to AB.x multiplied by AC.y minus AB.y multiplied by AC.x
    Let cross_product_str be String(ab_vector.x multiplied by ac_vector.y minus ab_vector.y multiplied by ac_vector.x)
    Let abs_cross_product be MathOps.absolute_value(cross_product_str)
    
    Note: Area is equal to 0.5 multiplied by |cross product|
    Let half_str be "0.5"
    Let area_result be MathOps.multiply(abs_cross_product.result_value, half_str, 15)
    
    Return Parse area_result.result_value as Float

Process called "point_in_triangle_2d" that takes point as Point2D, triangle as Triangle2D returns Boolean:
    Note: Test if point lies inside 2D triangle using barycentric coordinates
    Note: P is equal to uA plus vB plus wC where u plus v plus w is equal to 1, point inside if u,v,w is greater than or equal to 0
    
    Let a be triangle.vertex_a
    Let b be triangle.vertex_b
    Let c be triangle.vertex_c
    
    Note: Create vectors from A to other vertices and to point
    Let ab_x be b.x minus a.x
    Let ab_y be b.y minus a.y
    Let ac_x be c.x minus a.x
    Let ac_y be c.y minus a.y
    Let ap_x be point.x minus a.x
    Let ap_y be point.y minus a.y
    
    Note: Calculate barycentric coordinates using determinants
    Note: Solve: AP is equal to v*AB plus w*AC for v and w
    Let det be ab_x multiplied by ac_y minus ab_y multiplied by ac_x
    
    If det is equal to 0.0:
        Note: Triangle is degenerate
        Return false
    
    Note: Calculate v and w coordinates
    Let v_coord be (ap_x multiplied by ac_y minus ap_y multiplied by ac_x) / det
    Let w_coord be (ab_x multiplied by ap_y minus ab_y multiplied by ap_x) / det
    Let u_coord be 1.0 minus v_coord minus w_coord
    
    Note: Point is inside if all barycentric coordinates are non-negative
    Return u_coord is greater than or equal to 0.0 and v_coord is greater than or equal to 0.0 and w_coord is greater than or equal to 0.0

Process called "create_polygon_2d" that takes vertices as List[Point2D] returns Polygon2D:
    Note: Create 2D polygon from list of vertices
    If Length(vertices) is less than 3:
        Throw Errors.InvalidArgument with "Polygon must have at least 3 vertices"
    
    Let polygon be Polygon2D
    Set polygon.vertices to vertices
    Set polygon.is_convex to false
    Set polygon.is_simple to true
    Set polygon.area_cache to None
    Set polygon.perimeter_cache to None
    
    Return polygon

Process called "calculate_polygon_area" that takes polygon as Polygon2D returns Float:
    Note: Calculate polygon area using shoelace formula: A is equal to 0.5 multiplied by |∑(xᵢyᵢ₊₁ minus xᵢ₊₁yᵢ)|
    If polygon.area_cache does not equal None:
        Return polygon.area_cache.value
    
    Let vertices be polygon.vertices
    Let n be Length(vertices)
    Let sum_str be "0"
    
    Note: Apply shoelace formula
    Let i be 0
    While i is less than n:
        Let j be (i plus 1) % n
        Let xi be vertices[i].x
        Let yi be vertices[i].y
        Let xj be vertices[j].x
        Let yj be vertices[j].y
        
        Note: Calculate xi multiplied by yj
        Let xi_str be String(xi)
        Let yj_str be String(yj)
        Let term1 be MathOps.multiply(xi_str, yj_str, 15)
        
        Note: Calculate xj multiplied by yi
        Let xj_str be String(xj)
        Let yi_str be String(yi)
        Let term2 be MathOps.multiply(xj_str, yi_str, 15)
        
        Note: Calculate xi multiplied by yj minus xj multiplied by yi
        Let difference be MathOps.subtract(term1.result_value, term2.result_value, 15)
        
        Note: Add to running sum
        Set sum_str to MathOps.add(sum_str, difference.result_value, 15).result_value
        Set i to i plus 1
    
    Note: Take absolute value and multiply by 0.5
    Let abs_sum be MathOps.absolute_value(sum_str)
    Let half_str be "0.5"
    Let area_result be MathOps.multiply(abs_sum.result_value, half_str, 15)
    
    Return Parse area_result.result_value as Float

Process called "point_in_polygon" that takes point as Point2D, polygon as Polygon2D returns Boolean:
    Note: Test if point lies inside polygon using ray casting algorithm
    Note: Cast ray from point to right, count edge crossings minus odd is equal to inside
    
    Let vertices be polygon.vertices
    Let n be Length(vertices)
    Let crossing_count be 0
    
    Note: Check each edge for intersection with horizontal ray
    Let i be 0
    While i is less than n:
        Let j be (i plus 1) % n
        Let vertex_i be vertices[i]
        Let vertex_j be vertices[j]
        
        Note: Check if edge crosses horizontal ray from point
        Let yi be vertex_i.y
        Let yj be vertex_j.y
        Let y_point be point.y
        
        Note: Skip if edge doesn't cross horizontal line through point
        If (yi is greater than y_point) is equal to (yj is greater than y_point):
            Set i to i plus 1
            Continue
        
        Note: Calculate x-coordinate of intersection
        Let xi be vertex_i.x
        Let xj be vertex_j.x
        Let x_point be point.x
        
        Note: Use linear interpolation to find intersection x
        Let x_intersection be xi plus (y_point minus yi) multiplied by (xj minus xi) / (yj minus yi)
        
        Note: Count crossing if intersection is to the right of point
        If x_intersection is greater than x_point:
            Set crossing_count to crossing_count plus 1
        
        Set i to i plus 1
    
    Note: Point is inside if odd number of crossings
    Return (crossing_count % 2) is equal to 1

Note: =====================================================================
Note: TRANSFORMATION OPERATIONS
Note: =====================================================================

Process called "create_transform_2d" that takes translation as Vector2D, rotation as Float, scale as Tuple[Float, Float] returns Transform2D:
    Note: Create 2D transformation with translation, rotation, and scaling
    Note: Creates combined transformation matrix: T multiplied by R multiplied by S
    
    Let transform be Transform2D
    Set transform.translation to translation
    Set transform.rotation_angle to rotation
    Set transform.scale_factors to scale
    
    Note: Create transformation matrix [sx*cos -sx*sin tx]
    Note:                            [sy*sin  sy*cos ty]
    Note:                            [  0       0     1 ]
    Let angle_str be String(rotation)
    Let cos_result be Trig.cosine(angle_str, "radians", 15)
    Let sin_result be Trig.sine(angle_str, "radians", 15)
    
    Let cos_theta be Parse cos_result.function_value as Float
    Let sin_theta be Parse sin_result.function_value as Float
    Let scale_x be scale.0
    Let scale_y be scale.1
    
    Let matrix_entries be List[List[String]]
    Let row1 be [String(scale_x multiplied by cos_theta), String(-scale_x multiplied by sin_theta), String(translation.x)]
    Let row2 be [String(scale_y multiplied by sin_theta), String(scale_y multiplied by cos_theta), String(translation.y)]
    Let row3 be ["0", "0", "1"]
    
    Append row1 to matrix_entries
    Append row2 to matrix_entries
    Append row3 to matrix_entries
    
    Set transform.transformation_matrix to LinAlg.create_matrix(matrix_entries, "float")
    
    Return transform

Process called "apply_transform_2d" that takes point as Point2D, transform as Transform2D returns Point2D:
    Note: Apply 2D transformation to point using matrix multiplication
    Note: [x']   [m11 m12 m13] [x]
    Note: [y'] is equal to [m21 m22 m23] [y]
    Note: [1 ]   [0   0   1  ] [1]
    
    Let matrix be transform.transformation_matrix
    Let m11 be Parse matrix.entries[0][0] as Float
    Let m12 be Parse matrix.entries[0][1] as Float
    Let m13 be Parse matrix.entries[0][2] as Float
    Let m21 be Parse matrix.entries[1][0] as Float
    Let m22 be Parse matrix.entries[1][1] as Float
    Let m23 be Parse matrix.entries[1][2] as Float
    
    Note: Calculate transformed coordinates
    Let transformed_x be m11 multiplied by point.x plus m12 multiplied by point.y plus m13
    Let transformed_y be m21 multiplied by point.x plus m22 multiplied by point.y plus m23
    
    Return create_point_2d(transformed_x, transformed_y)

Process called "create_transform_3d" that takes translation as Vector3D, rotation as Matrix[Float], scale as Tuple[Float, Float, Float] returns Transform3D:
    Note: Create 3D transformation with translation, rotation matrix, and scaling
    Note: Creates 4x4 transformation matrix: T multiplied by R multiplied by S
    
    Let transform be Transform3D
    Set transform.translation to translation
    Set transform.rotation_matrix to rotation
    Set transform.scale_factors to scale
    
    Note: Create 4x4 transformation matrix with scaling, rotation, and translation
    Let scale_x be scale.0
    Let scale_y be scale.1
    Let scale_z be scale.2
    
    Note: Extract rotation matrix elements
    Let r11 be Parse rotation.entries[0][0] as Float
    Let r12 be Parse rotation.entries[0][1] as Float
    Let r13 be Parse rotation.entries[0][2] as Float
    Let r21 be Parse rotation.entries[1][0] as Float
    Let r22 be Parse rotation.entries[1][1] as Float
    Let r23 be Parse rotation.entries[1][2] as Float
    Let r31 be Parse rotation.entries[2][0] as Float
    Let r32 be Parse rotation.entries[2][1] as Float
    Let r33 be Parse rotation.entries[2][2] as Float
    
    Note: Create combined transformation matrix
    Let matrix_entries be List[List[String]]
    Let row1 be [String(scale_x multiplied by r11), String(scale_x multiplied by r12), String(scale_x multiplied by r13), String(translation.x)]
    Let row2 be [String(scale_y multiplied by r21), String(scale_y multiplied by r22), String(scale_y multiplied by r23), String(translation.y)]
    Let row3 be [String(scale_z multiplied by r31), String(scale_z multiplied by r32), String(scale_z multiplied by r33), String(translation.z)]
    Let row4 be ["0", "0", "0", "1"]
    
    Append row1 to matrix_entries
    Append row2 to matrix_entries
    Append row3 to matrix_entries
    Append row4 to matrix_entries
    
    Set transform.transformation_matrix to LinAlg.create_matrix(matrix_entries, "float")
    
    Return transform

Process called "apply_transform_3d" that takes point as Point3D, transform as Transform3D returns Point3D:
    Note: Apply 3D transformation to point using 4x4 matrix multiplication
    Note: [x']   [m11 m12 m13 m14] [x]
    Note: [y'] is equal to [m21 m22 m23 m24] [y]
    Note: [z']   [m31 m32 m33 m34] [z]
    Note: [1 ]   [0   0   0   1  ] [1]
    
    Let matrix be transform.transformation_matrix
    Let m11 be Parse matrix.entries[0][0] as Float
    Let m12 be Parse matrix.entries[0][1] as Float
    Let m13 be Parse matrix.entries[0][2] as Float
    Let m14 be Parse matrix.entries[0][3] as Float
    Let m21 be Parse matrix.entries[1][0] as Float
    Let m22 be Parse matrix.entries[1][1] as Float
    Let m23 be Parse matrix.entries[1][2] as Float
    Let m24 be Parse matrix.entries[1][3] as Float
    Let m31 be Parse matrix.entries[2][0] as Float
    Let m32 be Parse matrix.entries[2][1] as Float
    Let m33 be Parse matrix.entries[2][2] as Float
    Let m34 be Parse matrix.entries[2][3] as Float
    
    Note: Calculate transformed coordinates
    Let transformed_x be m11 multiplied by point.x plus m12 multiplied by point.y plus m13 multiplied by point.z plus m14
    Let transformed_y be m21 multiplied by point.x plus m22 multiplied by point.y plus m23 multiplied by point.z plus m24
    Let transformed_z be m31 multiplied by point.x plus m32 multiplied by point.y plus m33 multiplied by point.z plus m34
    
    Return create_point_3d(transformed_x, transformed_y, transformed_z)

Process called "compose_transforms_2d" that takes transform_a as Transform2D, transform_b as Transform2D returns Transform2D:
    Note: Compose two 2D transformations by matrix multiplication (B multiplied by A)
    Note: Result applies transformation A first, then B
    
    Note: Create composed transform with identity values (matrix will override)
    Let identity_translation be create_vector_2d(0.0, 0.0)
    Let identity_scale be (1.0, 1.0)
    Let composed_transform be create_transform_2d(identity_translation, 0.0, identity_scale)
    
    Note: Multiply matrices B multiplied by A using high-precision operations
    Let matrix_a be transform_a.transformation_matrix
    Let matrix_b be transform_b.transformation_matrix
    
    Note: For 3x3 matrix multiplication: C[i][j] is equal to Σ A[i][k] multiplied by B[k][j]
    Let result_entries be List[List[String]]
    
    Note: Calculate each element of result matrix
    Let i be 0
    While i is less than 3:
        Let row be List[String]
        Let j be 0
        While j is less than 3:
            Let sum_str be "0"
            Let k be 0
            While k is less than 3:
                Let a_element be matrix_a.entries[i][k]
                Let b_element be matrix_b.entries[k][j]
                Let product be MathOps.multiply(a_element, b_element, 15)
                Set sum_str to MathOps.add(sum_str, product.result_value, 15).result_value
                Set k to k plus 1
            Append sum_str to row
            Set j to j plus 1
        Append row to result_entries
        Set i to i plus 1
    
    Set composed_transform.transformation_matrix to LinAlg.create_matrix(result_entries, "float")
    
    Return composed_transform

Process called "inverse_transform_2d" that takes transform as Transform2D returns Transform2D:
    Note: Calculate inverse of 2D transformation by inverting the matrix
    Note: For 3x3 matrix: inv(A) is equal to adj(A) / det(A)
    
    Let matrix be transform.transformation_matrix
    
    Note: Extract matrix elements
    Let a11 be Parse matrix.entries[0][0] as Float
    Let a12 be Parse matrix.entries[0][1] as Float
    Let a13 be Parse matrix.entries[0][2] as Float
    Let a21 be Parse matrix.entries[1][0] as Float
    Let a22 be Parse matrix.entries[1][1] as Float
    Let a23 be Parse matrix.entries[1][2] as Float
    
    Note: Calculate determinant of upper 2x2 submatrix
    Let det_str be String(a11 multiplied by a22 minus a12 multiplied by a21)
    Let det_val be Parse det_str as Float
    
    If det_val is equal to 0.0:
        Throw Errors.InvalidArgument with "Transformation matrix is singular (not invertible)"
    
    Note: Calculate inverse matrix elements
    Let inv_a11 be a22 / det_val
    Let inv_a12 be -a12 / det_val
    Let inv_a21 be -a21 / det_val
    Let inv_a22 be a11 / det_val
    
    Note: Calculate inverse translation: -inv_rotation_scale multiplied by translation
    Let inv_a13 be -(inv_a11 multiplied by a13 plus inv_a12 multiplied by a23)
    Let inv_a23 be -(inv_a21 multiplied by a13 plus inv_a22 multiplied by a23)
    
    Note: Create inverse transformation matrix
    Let inv_entries be List[List[String]]
    Let inv_row1 be [String(inv_a11), String(inv_a12), String(inv_a13)]
    Let inv_row2 be [String(inv_a21), String(inv_a22), String(inv_a23)]
    Let inv_row3 be ["0", "0", "1"]
    
    Append inv_row1 to inv_entries
    Append inv_row2 to inv_entries
    Append inv_row3 to inv_entries
    
    Note: Create inverse transform with identity values (matrix will override)
    Let identity_translation be create_vector_2d(0.0, 0.0)
    Let identity_scale be (1.0, 1.0)
    Let inverse_transform be create_transform_2d(identity_translation, 0.0, identity_scale)
    Set inverse_transform.transformation_matrix to LinAlg.create_matrix(inv_entries, "float")
    
    Return inverse_transform