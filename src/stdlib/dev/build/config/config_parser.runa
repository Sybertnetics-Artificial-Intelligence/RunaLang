Note:
dev/build/config/config_parser.runa
Configuration Format Parser System

This module provides comprehensive parsing capabilities for multiple configuration file formats.

Key features and capabilities:
- Multi-format parsing support (JSON, YAML, TOML, INI, Runa native)
- Strict and lenient parsing modes for different use cases
- Schema validation and type checking capabilities
- Comment preservation and extraction for documentation
- Format conversion between different configuration types
- Error recovery and detailed error reporting
- Custom parser registration for extensibility
- Data normalization and standardization
- Line number tracking for precise error locations
- Performance optimized parsing algorithms
:End Note

Import "collections" as Collections
Import "errors" as Errors
Import "strings" as Strings

Note: =====================================================================
Note: DATA STRUCTURES/TYPES
Note: =====================================================================

Type called "ParserConfig":
    format as String                    Note: Target format: json, yaml, toml, ini, runa
    strict_mode as Boolean              Note: Whether to enforce strict parsing rules
    allow_comments as Boolean           Note: Whether to allow comments in the format
    preserve_order as Boolean           Note: Whether to preserve key ordering
    custom_delimiters as Dictionary[String, String] Note: Custom delimiter overrides
    max_nesting_depth as Integer        Note: Maximum allowed nesting depth
    max_array_size as Integer           Note: Maximum allowed array size
    encoding as String                  Note: Expected text encoding

Type called "ParseResult":
    success as Boolean                  Note: Whether parsing completed successfully
    data as Dictionary[String, Any]     Note: Parsed configuration data
    errors as List[String]              Note: Critical errors that prevented parsing
    warnings as List[String]            Note: Non-critical warnings and issues
    line_numbers as Dictionary[String, Integer] Note: Key to line number mapping
    metadata as Dictionary[String, String] Note: Additional parsing metadata

Type called "ConfigSchema":
    required_keys as List[String]       Note: Keys that must be present
    optional_keys as List[String]       Note: Keys that may be present
    key_types as Dictionary[String, String] Note: Expected type for each key
    nested_schemas as Dictionary[String, ConfigSchema] Note: Schemas for nested objects
    validation_rules as Dictionary[String, String] Note: Custom validation rules

Type called "ConfigParser":
    parsers as Dictionary[String, Function] Note: Format-specific parser functions
    default_config as ParserConfig      Note: Default parsing configuration
    schema_validator as Function        Note: Schema validation function
    custom_validators as Dictionary[String, Function] Note: Custom validation functions
    supported_formats as List[String]   Note: List of supported configuration formats

Note: =====================================================================
Note: CORE OPERATIONS
Note: =====================================================================

Process called "create_config_parser" that takes nothing returns ConfigParser:
    Note: Creates a new configuration parser with all supported formats
    Note: Initializes default parsing configuration and validators
    Note: Time complexity: O(1), Space complexity: O(1)
    
    Let parser be ConfigParser
    Set parser.parsers to Collections.create_dictionary()
    Set parser.custom_validators to Collections.create_dictionary()
    Set parser.supported_formats to ["json", "yaml", "toml", "ini", "runa"]
    
    Note: Create default parser configuration
    Let default_config be ParserConfig
    Set default_config.format to "auto"
    Set default_config.strict_mode to False
    Set default_config.allow_comments to True
    Set default_config.preserve_order to True
    Set default_config.custom_delimiters to Collections.create_dictionary()
    Set default_config.max_nesting_depth to 10
    Set default_config.max_array_size to 1000
    Set default_config.encoding to "utf-8"
    
    Set parser.default_config to default_config
    
    Note: Register built-in parsers
    Collections.set_dictionary_value(parser.parsers, "json", parse_json_format)
    Collections.set_dictionary_value(parser.parsers, "yaml", parse_yaml_format)
    Collections.set_dictionary_value(parser.parsers, "toml", parse_toml_format)
    Collections.set_dictionary_value(parser.parsers, "ini", parse_ini_format)
    Collections.set_dictionary_value(parser.parsers, "runa", parse_runa_format)
    
    Return parser

Process called "parse_config_string" that takes parser as ConfigParser, content as String, format as String returns ParseResult:
    Note: Parses configuration content using the appropriate format parser
    Note: Handles format auto-detection and delegation to specific parsers
    Note: Returns comprehensive parsing result with errors and warnings
    
    Let result be ParseResult
    Set result.success to False
    Set result.data to Collections.create_dictionary()
    Set result.errors to Collections.create_list()
    Set result.warnings to Collections.create_list()
    Set result.line_numbers to Collections.create_dictionary()
    Set result.metadata to Collections.create_dictionary()
    
    Note: Validate input parameters
    If Strings.is_empty(content):
        Collections.add_to_list(result.errors, "Configuration content is empty")
        Return result
    
    Note: Auto-detect format if not specified
    Let target_format be format
    If target_format = "auto":
        Set target_format to detect_format_from_content(content)
        Collections.set_dictionary_value(result.metadata, "detected_format", target_format)
    
    Note: Check if format is supported
    If Not Collections.list_contains(parser.supported_formats, target_format):
        Collections.add_to_list(result.errors, "Unsupported configuration format: " + target_format)
        Return result
    
    Note: Get the appropriate parser function
    If Collections.dictionary_has_key(parser.parsers, target_format):
        Let parser_function be Collections.get_dictionary_value(parser.parsers, target_format)
        Set result to parser_function(content, parser.default_config)
    Otherwise:
        Collections.add_to_list(result.errors, "No parser registered for format: " + target_format)
    
    Return result

Process called "parse_json_config" that takes content as String, config as ParserConfig returns ParseResult:
    Note: Parses JSON configuration with comprehensive error handling
    Note: Supports both strict and lenient JSON parsing modes
    Note: Handles comments if allowed in configuration
    
    Let result be create_empty_parse_result()
    
    Note: Pre-process content to handle comments if allowed
    Let processed_content be content
    If config.allow_comments:
        Set processed_content to strip_json_comments(content)
    
    Note: Attempt to parse JSON content
    Try:
        Let json_data be parse_json_native(processed_content)
        Set result.data to json_data
        Set result.success to True
        
        Note: Validate nesting depth
        Let max_depth be calculate_nesting_depth(json_data)
        If max_depth > config.max_nesting_depth:
            Collections.add_to_list(result.warnings, "JSON nesting depth exceeds recommended maximum: " + max_depth)
        
    Catch json_error:
        Collections.add_to_list(result.errors, "JSON parsing failed: " + json_error.message)
        
        Note: Try to provide helpful error location information
        Let error_location be extract_json_error_location(json_error.message)
        If error_location > 0:
            Collections.set_dictionary_value(result.line_numbers, "error_line", error_location)
    
    Return result

Process called "parse_yaml_config" that takes content as String, config as ParserConfig returns ParseResult:
    Note: Parses YAML configuration with support for multiple documents
    Note: Handles YAML-specific features like anchors and references
    Note: Provides detailed error reporting for YAML syntax issues
    
    Let result be create_empty_parse_result()
    
    Note: YAML allows comments by default, so no preprocessing needed
    Try:
        Let yaml_data be parse_yaml_native(content)
        Set result.data to yaml_data
        Set result.success to True
        
        Note: Check for potentially unsafe YAML constructs
        If config.strict_mode:
            Let safety_warnings be check_yaml_safety(content)
            For Each warning in safety_warnings:
                Collections.add_to_list(result.warnings, warning)
        
    Catch yaml_error:
        Collections.add_to_list(result.errors, "YAML parsing failed: " + yaml_error.message)
        
        Note: YAML errors often include line information
        Let error_line be extract_yaml_error_line(yaml_error.message)
        If error_line > 0:
            Collections.set_dictionary_value(result.line_numbers, "error_line", error_line)
    
    Return result

Process called "parse_toml_config" that takes content as String, config as ParserConfig returns ParseResult:
    Note: Parses TOML configuration with table and array support
    Note: Handles TOML-specific datetime and multiline string features
    Note: Validates TOML structure and provides helpful error messages
    
    Let result be create_empty_parse_result()
    
    Try:
        Let toml_data be parse_toml_native(content)
        Set result.data to toml_data
        Set result.success to True
        
        Note: TOML has specific rules about table redefinition
        If config.strict_mode:
            Let structure_errors be validate_toml_structure(content)
            For Each error in structure_errors:
                Collections.add_to_list(result.warnings, "TOML structure warning: " + error)
        
    Catch toml_error:
        Collections.add_to_list(result.errors, "TOML parsing failed: " + toml_error.message)
        
        Note: Extract line information from TOML error
        Let error_info be extract_toml_error_info(toml_error.message)
        Collections.set_dictionary_value(result.line_numbers, "error_line", error_info.line)
    
    Return result

Process called "parse_ini_config" that takes content as String, config as ParserConfig returns ParseResult:
    Note: Parses INI configuration with section and key-value support
    Note: Handles different INI dialects and delimiter customization
    Note: Supports both flat and nested INI structures
    
    Let result be create_empty_parse_result()
    Let parsed_data be Collections.create_dictionary()
    
    Note: Split content into lines for processing
    Let lines be Strings.split_lines(content)
    Let current_section be ""
    Let line_number be 0
    
    For Each line in lines:
        Set line_number to line_number + 1
        Let trimmed_line be Strings.trim(line)
        
        Note: Skip empty lines and comments
        If Strings.is_empty(trimmed_line) Or Strings.starts_with(trimmed_line, "#") Or Strings.starts_with(trimmed_line, ";"):
            Continue
        
        Note: Check for section headers
        If Strings.starts_with(trimmed_line, "[") And Strings.ends_with(trimmed_line, "]"):
            Set current_section to Strings.substring(trimmed_line, 1, Strings.length(trimmed_line) - 2)
            Collections.set_dictionary_value(parsed_data, current_section, Collections.create_dictionary())
            Continue
        
        Note: Parse key-value pairs
        Let delimiter be "="
        If Collections.dictionary_has_key(config.custom_delimiters, "ini_delimiter"):
            Set delimiter to Collections.get_dictionary_value(config.custom_delimiters, "ini_delimiter")
        
        If Strings.contains(trimmed_line, delimiter):
            Let key_value be Strings.split_first(trimmed_line, delimiter)
            Let key be Strings.trim(key_value.first)
            Let value be Strings.trim(key_value.second)
            
            Note: Store the key-value pair in appropriate section
            If Strings.is_empty(current_section):
                Collections.set_dictionary_value(parsed_data, key, value)
                Collections.set_dictionary_value(result.line_numbers, key, line_number)
            Otherwise:
                Let section_data be Collections.get_dictionary_value(parsed_data, current_section)
                Collections.set_dictionary_value(section_data, key, value)
                Collections.set_dictionary_value(result.line_numbers, current_section + "." + key, line_number)
        Otherwise:
            Collections.add_to_list(result.warnings, "Invalid INI line at " + line_number + ": " + trimmed_line)
    
    Set result.data to parsed_data
    Set result.success to True
    Return result

Process called "parse_runa_config" that takes content as String, config as ParserConfig returns ParseResult:
    Note: Parses native Runa configuration format
    Note: Supports Runa-specific syntax and type annotations
    Note: Provides integration with Runa's type system
    
    Let result be create_empty_parse_result()
    
    Note: Runa config format is structured similar to Runa code
    Try:
        Let runa_data be parse_runa_native_format(content)
        Set result.data to runa_data
        Set result.success to True
        
        Note: Validate Runa-specific constructs
        Let validation_result be validate_runa_config_syntax(content)
        If Not validation_result.valid:
            For Each error in validation_result.errors:
                Collections.add_to_list(result.errors, error)
            Set result.success to False
        
    Catch runa_error:
        Collections.add_to_list(result.errors, "Runa config parsing failed: " + runa_error.message)
        Set result.success to False
    
    Return result

Note: =====================================================================
Note: SPECIALIZED OPERATIONS
Note: =====================================================================

Process called "validate_against_schema" that takes data as Dictionary[String, Any], schema as ConfigSchema returns List[String]:
    Note: Validates parsed configuration data against a defined schema
    Note: Checks for required keys, types, and nested structure compliance
    Note: Returns list of validation errors, empty if valid
    
    Let validation_errors be Collections.create_list()
    
    Note: Check for required keys
    For Each required_key in schema.required_keys:
        If Not Collections.dictionary_has_key(data, required_key):
            Collections.add_to_list(validation_errors, "Required configuration key missing: " + required_key)
    
    Note: Validate key types
    For Each key in Collections.get_dictionary_keys(data):
        If Collections.dictionary_has_key(schema.key_types, key):
            Let expected_type be Collections.get_dictionary_value(schema.key_types, key)
            Let actual_value be Collections.get_dictionary_value(data, key)
            Let actual_type be get_value_type(actual_value)
            
            If actual_type != expected_type:
                Collections.add_to_list(validation_errors, "Type mismatch for key '" + key + "': expected " + expected_type + ", got " + actual_type)
    
    Note: Validate nested schemas
    For Each nested_key in Collections.get_dictionary_keys(schema.nested_schemas):
        If Collections.dictionary_has_key(data, nested_key):
            Let nested_data be Collections.get_dictionary_value(data, nested_key)
            Let nested_schema be Collections.get_dictionary_value(schema.nested_schemas, nested_key)
            Let nested_errors be validate_against_schema(nested_data, nested_schema)
            
            For Each nested_error in nested_errors:
                Collections.add_to_list(validation_errors, nested_key + "." + nested_error)
    
    Return validation_errors

Process called "convert_config_format" that takes data as Dictionary[String, Any], from_format as String, to_format as String returns String:
    Note: Converts configuration data from one format to another
    Note: Preserves structure and values while adapting to target format
    Note: Handles format-specific features and limitations
    
    Note: First normalize the data to a common structure
    Let normalized_data be normalize_config_data(data)
    
    Note: Generate output in target format
    If to_format = "json":
        Return serialize_to_json(normalized_data)
    Otherwise If to_format = "yaml":
        Return serialize_to_yaml(normalized_data)
    Otherwise If to_format = "toml":
        Return serialize_to_toml(normalized_data)
    Otherwise If to_format = "ini":
        Return serialize_to_ini(normalized_data)
    Otherwise If to_format = "runa":
        Return serialize_to_runa(normalized_data)
    Otherwise:
        Throw Errors.InvalidFormat with "Unsupported target format: " + to_format

Process called "register_custom_parser" that takes parser as ConfigParser, format as String, parser_function as Function returns Boolean:
    Note: Registers a custom parser function for a specific format
    Note: Allows extension of parser capabilities for custom formats
    Note: Returns success status of registration
    
    If Strings.is_empty(format):
        Return False
    
    Note: Add format to supported formats if not already present
    If Not Collections.list_contains(parser.supported_formats, format):
        Collections.add_to_list(parser.supported_formats, format)
    
    Note: Register the parser function
    Collections.set_dictionary_value(parser.parsers, format, parser_function)
    
    Return True

Note: =====================================================================
Note: VALIDATION/UTILITY OPERATIONS
Note: =====================================================================

Process called "normalize_config_data" that takes data as Dictionary[String, Any] returns Dictionary[String, Any]:
    Note: Normalizes configuration data to a standard internal format
    Note: Handles type coercion and value standardization
    Note: Ensures consistent data structure across different input formats
    
    Let normalized_data be Collections.create_dictionary()
    
    For Each key in Collections.get_dictionary_keys(data):
        Let value be Collections.get_dictionary_value(data, key)
        Let normalized_value be normalize_config_value(value)
        Collections.set_dictionary_value(normalized_data, key, normalized_value)
    
    Return normalized_data

Process called "extract_comments" that takes content as String, format as String returns Dictionary[String, String]:
    Note: Extracts comments from configuration content
    Note: Associates comments with their corresponding configuration keys
    Note: Preserves comment content for documentation generation
    
    Let comments be Collections.create_dictionary()
    Let lines be Strings.split_lines(content)
    Let line_number be 0
    
    For Each line in lines:
        Set line_number to line_number + 1
        Let trimmed_line be Strings.trim(line)
        
        Note: Identify comment patterns based on format
        Let comment_prefix be get_comment_prefix(format)
        
        If Strings.starts_with(trimmed_line, comment_prefix):
            Let comment_content be Strings.substring(trimmed_line, Strings.length(comment_prefix))
            Let comment_key be "line_" + line_number
            Collections.set_dictionary_value(comments, comment_key, Strings.trim(comment_content))
    
    Return comments

Process called "detect_format_from_content" that takes content as String returns String:
    Note: Auto-detects configuration format from content structure
    Note: Analyzes syntax patterns and markers to identify format
    Note: Returns best guess format or "unknown"
    
    Let trimmed_content be Strings.trim(content)
    
    Note: Check for JSON indicators
    If Strings.starts_with(trimmed_content, "{") And Strings.ends_with(trimmed_content, "}"):
        Return "json"
    
    Note: Check for YAML indicators
    If Strings.contains(content, "---") Or Strings.contains(content, ":"):
        Let colon_count be Strings.count_occurrences(content, ":")
        Let bracket_count be Strings.count_occurrences(content, "{")
        If colon_count > bracket_count:
            Return "yaml"
    
    Note: Check for TOML indicators
    If Strings.contains(content, "[[") Or Strings.contains(content, "]]"):
        Return "toml"
    
    Note: Check for INI indicators
    If Strings.contains(content, "[") And Strings.contains(content, "="):
        Return "ini"
    
    Note: Check for Runa indicators
    If Strings.contains(content, "Type called") Or Strings.contains(content, "Process called"):
        Return "runa"
    
    Note: Default fallback
    Return "unknown"

Note: =====================================================================
Note: ADVANCED/OPTIMIZATION OPERATIONS
Note: =====================================================================

Process called "create_empty_parse_result" that takes nothing returns ParseResult:
    Note: Creates an initialized empty parse result structure
    Note: Used for consistent initialization across all parsers
    Note: Provides default values for all result fields
    
    Let result be ParseResult
    Set result.success to False
    Set result.data to Collections.create_dictionary()
    Set result.errors to Collections.create_list()
    Set result.warnings to Collections.create_list()
    Set result.line_numbers to Collections.create_dictionary()
    Set result.metadata to Collections.create_dictionary()
    
    Return result

Process called "get_value_type" that takes value as Any returns String:
    Note: Determines the runtime type of a configuration value
    Note: Used for type validation and schema checking
    Note: Returns standardized type names
    
    If Collections.is_string(value):
        Return "string"
    Otherwise If Collections.is_integer(value):
        Return "integer"
    Otherwise If Collections.is_float(value):
        Return "float"
    Otherwise If Collections.is_boolean(value):
        Return "boolean"
    Otherwise If Collections.is_list(value):
        Return "array"
    Otherwise If Collections.is_dictionary(value):
        Return "object"
    Otherwise:
        Return "unknown"

Process called "normalize_config_value" that takes value as Any returns Any:
    Note: Normalizes individual configuration values to standard types
    Note: Handles string to number conversion and boolean normalization
    Note: Recursively processes nested structures
    
    If Collections.is_dictionary(value):
        Return normalize_config_data(value)
    Otherwise If Collections.is_list(value):
        Let normalized_list be Collections.create_list()
        For Each item in value:
            Let normalized_item be normalize_config_value(item)
            Collections.add_to_list(normalized_list, normalized_item)
        Return normalized_list
    Otherwise If Collections.is_string(value):
        Note: Try to convert string to appropriate type
        Return normalize_string_value(value)
    Otherwise:
        Return value

Note: =====================================================================
Note: INTEGRATION/EXPORT OPERATIONS
Note: =====================================================================

Process called "get_comment_prefix" that takes format as String returns String:
    Note: Returns the comment prefix character(s) for a given format
    Note: Used for comment extraction and processing
    Note: Supports all major configuration format comment styles
    
    If format = "json":
        Return "//"  Note: Non-standard but commonly supported
    Otherwise If format = "yaml":
        Return "#"
    Otherwise If format = "toml":
        Return "#"
    Otherwise If format = "ini":
        Return "#"  Note: Also supports ";" but "#" is more common
    Otherwise If format = "runa":
        Return "Note:"
    Otherwise:
        Return "#"  Note: Default fallback