Note:
dev/build/config/config_validator.runa
Configuration Validation System

This module provides comprehensive configuration validation capabilities for the Runa build system.

Key features and capabilities:
- Schema-based validation with multiple rule types (required, type, range, pattern, custom)
- Nested configuration validation with recursive schema support
- Configurable severity levels (error, warning, info) for different validation rules
- Custom validation rule registration and execution framework
- Automatic error fixing and suggestion generation for common issues
- Comprehensive validation reporting with detailed error messages
- Pattern-based validation using regular expressions
- Range validation for numeric and string length constraints
- Type validation with support for all configuration data types
- Strict and lenient validation modes for different use cases
:End Note

Import "collections" as Collections
Import "errors" as Errors
Import "strings" as Strings

Note: =====================================================================
Note: DATA STRUCTURES/TYPES
Note: =====================================================================

Type called "ValidationRule":
    rule_name as String                 Note: Unique name for the validation rule
    rule_type as String                 Note: Type: required, type, range, pattern, custom
    parameters as Dictionary[String, Any] Note: Rule-specific parameters and constraints
    error_message as String             Note: Custom error message for rule violations
    severity as String                  Note: Severity level: error, warning, info
    applies_to as List[String]          Note: List of property paths this rule applies to
    condition as String                 Note: Optional condition for conditional validation

Type called "ValidationError":
    path as String                      Note: Configuration path where error occurred
    rule_name as String                 Note: Name of the validation rule that failed
    message as String                   Note: Detailed error message
    severity as String                  Note: Error severity level
    suggested_fix as String             Note: Suggestion for fixing the error
    current_value as String             Note: Current value that failed validation
    expected_value as String            Note: Expected value or format

Type called "ValidationResult":
    is_valid as Boolean                 Note: Overall validation status
    errors as List[ValidationError]     Note: Critical errors that prevent usage
    warnings as List[ValidationError]   Note: Non-critical warnings
    suggestions as List[String]         Note: General improvement suggestions
    validated_paths as List[String]     Note: List of all validated configuration paths
    statistics as Dictionary[String, Integer] Note: Validation statistics

Type called "ConfigValidationSchema":
    schema_version as String            Note: Version of the validation schema format
    properties as Dictionary[String, List[ValidationRule]] Note: Property validation rules
    nested_schemas as Dictionary[String, ConfigValidationSchema] Note: Nested object schemas
    custom_validators as Dictionary[String, Function] Note: Custom validation functions
    global_rules as List[ValidationRule] Note: Rules applied to entire configuration
    metadata as Dictionary[String, String] Note: Schema metadata and documentation

Type called "ConfigValidator":
    schema as ConfigValidationSchema    Note: Validation schema to apply
    strict_mode as Boolean              Note: Whether to enforce strict validation
    allow_unknown_properties as Boolean Note: Whether to allow properties not in schema
    custom_error_messages as Dictionary[String, String] Note: Custom error message templates
    validation_context as Dictionary[String, Any] Note: Context data for validation
    cache_enabled as Boolean            Note: Whether to cache validation results

Note: =====================================================================
Note: CORE OPERATIONS
Note: =====================================================================

Process called "create_config_validator" that takes schema as ConfigValidationSchema returns ConfigValidator:
    Note: Creates a new configuration validator with specified schema
    Note: Initializes validation context and default settings
    Note: Time complexity: O(1), Space complexity: O(1)
    
    Let validator be ConfigValidator
    Set validator.schema to schema
    Set validator.strict_mode to False
    Set validator.allow_unknown_properties to True
    Set validator.custom_error_messages to Collections.create_dictionary()
    Set validator.validation_context to Collections.create_dictionary()
    Set validator.cache_enabled to True
    
    Note: Set up default error message templates
    Collections.set_dictionary_value(validator.custom_error_messages, "required", 
        "Required property '{path}' is missing")
    Collections.set_dictionary_value(validator.custom_error_messages, "type", 
        "Property '{path}' has invalid type. Expected {expected}, got {actual}")
    Collections.set_dictionary_value(validator.custom_error_messages, "range", 
        "Property '{path}' value {value} is outside allowed range {min} to {max}")
    Collections.set_dictionary_value(validator.custom_error_messages, "pattern", 
        "Property '{path}' value does not match required pattern")
    
    Return validator

Process called "validate_config" that takes validator as ConfigValidator, config_data as Dictionary[String, Any] returns ValidationResult:
    Note: Performs comprehensive validation of configuration data
    Note: Applies all validation rules and collects errors, warnings, and suggestions
    Note: Returns detailed validation result with statistics
    
    Let result be create_empty_validation_result()
    
    Note: Start validation process
    Collections.set_dictionary_value(result.statistics, "total_properties", 
        count_total_properties(config_data))
    Collections.set_dictionary_value(result.statistics, "validated_properties", 0)
    
    Note: Validate global rules first
    Let global_errors be validate_global_rules(validator, config_data)
    For Each error in global_errors:
        add_error_to_result(result, error)
    
    Note: Validate each property according to schema
    For Each property_path in Collections.get_dictionary_keys(validator.schema.properties):
        Let property_rules be Collections.get_dictionary_value(validator.schema.properties, property_path)
        Let property_errors be validate_property_with_rules(config_data, property_path, property_rules)
        
        For Each error in property_errors:
            add_error_to_result(result, error)
        
        Collections.add_to_list(result.validated_paths, property_path)
        increment_statistic(result.statistics, "validated_properties")
    
    Note: Validate nested configurations
    Let nested_errors be validate_nested_configs(validator, config_data)
    For Each error in nested_errors:
        add_error_to_result(result, error)
    
    Note: Execute custom validations
    Let custom_errors be execute_custom_validations(validator, config_data)
    For Each error in custom_errors:
        add_error_to_result(result, error)
    
    Note: Check for unknown properties if strict mode is enabled
    If validator.strict_mode And Not validator.allow_unknown_properties:
        Let unknown_errors be validate_unknown_properties(validator, config_data)
        For Each error in unknown_errors:
            add_error_to_result(result, error)
    
    Note: Determine overall validation status
    Set result.is_valid to Collections.get_list_size(result.errors) = 0
    
    Note: Generate improvement suggestions
    Set result.suggestions to generate_improvement_suggestions(result)
    
    Return result

Process called "validate_required_properties" that takes config_data as Dictionary[String, Any], required_keys as List[String] returns List[ValidationError]:
    Note: Validates that all required properties are present in configuration
    Note: Returns list of validation errors for missing required properties
    Note: Supports nested property paths using dot notation
    
    Let errors be Collections.create_list()
    
    For Each required_key in required_keys:
        If Not has_nested_property(config_data, required_key):
            Let error be create_validation_error(required_key, "required", 
                "Required property '" + required_key + "' is missing", "error")
            Set error.suggested_fix to "Add the required property '" + required_key + "' to your configuration"
            Collections.add_to_list(errors, error)
    
    Return errors

Process called "validate_property_types" that takes config_data as Dictionary[String, Any], type_rules as Dictionary[String, String] returns List[ValidationError]:
    Note: Validates that properties have the correct data types
    Note: Returns list of validation errors for type mismatches
    Note: Supports all common configuration data types
    
    Let errors be Collections.create_list()
    
    For Each property_path in Collections.get_dictionary_keys(type_rules):
        Let expected_type be Collections.get_dictionary_value(type_rules, property_path)
        
        If has_nested_property(config_data, property_path):
            Let actual_value be get_nested_property(config_data, property_path)
            Let actual_type be get_value_type_name(actual_value)
            
            If actual_type != expected_type:
                Let error_message be "Property '" + property_path + "' has invalid type. Expected " + 
                                   expected_type + ", got " + actual_type
                Let error be create_validation_error(property_path, "type", error_message, "error")
                Set error.current_value to Strings.convert_to_string(actual_value)
                Set error.expected_value to expected_type
                Set error.suggested_fix to "Change the value type to " + expected_type
                Collections.add_to_list(errors, error)
    
    Return errors

Process called "validate_value_ranges" that takes config_data as Dictionary[String, Any], range_rules as Dictionary[String, Dictionary[String, Any]] returns List[ValidationError]:
    Note: Validates that numeric values fall within specified ranges
    Note: Also validates string length ranges and array size ranges
    Note: Returns list of validation errors for out-of-range values
    
    Let errors be Collections.create_list()
    
    For Each property_path in Collections.get_dictionary_keys(range_rules):
        Let range_spec be Collections.get_dictionary_value(range_rules, property_path)
        
        If has_nested_property(config_data, property_path):
            Let actual_value be get_nested_property(config_data, property_path)
            Let range_error be validate_single_range(property_path, actual_value, range_spec)
            
            If range_error != null:
                Collections.add_to_list(errors, range_error)
    
    Return errors

Process called "validate_patterns" that takes config_data as Dictionary[String, Any], pattern_rules as Dictionary[String, String] returns List[ValidationError]:
    Note: Validates string properties against regular expression patterns
    Note: Returns list of validation errors for pattern mismatches
    Note: Supports complex regex patterns and provides helpful error messages
    
    Let errors be Collections.create_list()
    
    For Each property_path in Collections.get_dictionary_keys(pattern_rules):
        Let pattern be Collections.get_dictionary_value(pattern_rules, property_path)
        
        If has_nested_property(config_data, property_path):
            Let actual_value be get_nested_property(config_data, property_path)
            
            If Collections.is_string(actual_value):
                If Not Strings.matches_pattern(actual_value, pattern):
                    Let error_message be "Property '" + property_path + "' value does not match required pattern"
                    Let error be create_validation_error(property_path, "pattern", error_message, "error")
                    Set error.current_value to actual_value
                    Set error.expected_value to "Pattern: " + pattern
                    Set error.suggested_fix to "Ensure the value matches the required pattern: " + pattern
                    Collections.add_to_list(errors, error)
            Otherwise:
                Let error_message be "Property '" + property_path + "' must be a string for pattern validation"
                Let error be create_validation_error(property_path, "type", error_message, "error")
                Collections.add_to_list(errors, error)
    
    Return errors

Note: =====================================================================
Note: SPECIALIZED OPERATIONS
Note: =====================================================================

Process called "execute_custom_validations" that takes validator as ConfigValidator, config_data as Dictionary[String, Any] returns List[ValidationError]:
    Note: Executes custom validation functions registered with the validator
    Note: Returns list of validation errors from custom validators
    Note: Provides context and error handling for custom validation functions
    
    Let errors be Collections.create_list()
    
    For Each validator_name in Collections.get_dictionary_keys(validator.schema.custom_validators):
        Let validator_function be Collections.get_dictionary_value(validator.schema.custom_validators, validator_name)
        
        Try:
            Note: Execute custom validator with configuration data and context
            Let custom_errors be validator_function(config_data, validator.validation_context)
            
            For Each custom_error in custom_errors:
                Note: Ensure custom error has proper structure
                If validate_error_structure(custom_error):
                    Collections.add_to_list(errors, custom_error)
        Catch validation_error:
            Note: Handle errors in custom validation functions
            Let error_message be "Custom validator '" + validator_name + "' failed: " + validation_error.message
            Let error be create_validation_error("", "custom", error_message, "warning")
            Collections.add_to_list(errors, error)
    
    Return errors

Process called "validate_nested_configs" that takes validator as ConfigValidator, config_data as Dictionary[String, Any] returns List[ValidationError]:
    Note: Validates nested configuration objects using their specific schemas
    Note: Recursively applies validation rules to nested structures
    Note: Returns list of validation errors with proper path prefixing
    
    Let errors be Collections.create_list()
    
    For Each nested_path in Collections.get_dictionary_keys(validator.schema.nested_schemas):
        If has_nested_property(config_data, nested_path):
            Let nested_data be get_nested_property(config_data, nested_path)
            Let nested_schema be Collections.get_dictionary_value(validator.schema.nested_schemas, nested_path)
            
            Note: Create validator for nested schema
            Let nested_validator be create_config_validator(nested_schema)
            Set nested_validator.strict_mode to validator.strict_mode
            Set nested_validator.allow_unknown_properties to validator.allow_unknown_properties
            
            Note: Validate nested configuration
            Let nested_result be validate_config(nested_validator, nested_data)
            
            Note: Prefix error paths with nested path
            For Each nested_error in nested_result.errors:
                Set nested_error.path to nested_path + "." + nested_error.path
                Collections.add_to_list(errors, nested_error)
            
            For Each nested_warning in nested_result.warnings:
                Set nested_warning.path to nested_path + "." + nested_warning.path
                Collections.add_to_list(errors, nested_warning)
    
    Return errors

Process called "generate_validation_report" that takes result as ValidationResult returns String:
    Note: Generates a comprehensive human-readable validation report
    Note: Includes statistics, errors, warnings, and suggestions
    Note: Formats report in markdown for easy reading and documentation
    
    Let report_builder be Strings.create_string_builder()
    
    Strings.append_line(report_builder, "# Configuration Validation Report")
    Strings.append_line(report_builder, "")
    
    Note: Overall status
    Let status_text be "âœ… VALID"
    If Not result.is_valid:
        Set status_text to "âŒ INVALID"
    
    Strings.append_line(report_builder, "**Status:** " + status_text)
    Strings.append_line(report_builder, "")
    
    Note: Statistics section
    Strings.append_line(report_builder, "## Validation Statistics")
    Strings.append_line(report_builder, "")
    For Each stat_name in Collections.get_dictionary_keys(result.statistics):
        Let stat_value be Collections.get_dictionary_value(result.statistics, stat_name)
        Strings.append_line(report_builder, "- **" + format_stat_name(stat_name) + ":** " + stat_value)
    Strings.append_line(report_builder, "")
    
    Note: Errors section
    If Collections.get_list_size(result.errors) > 0:
        Strings.append_line(report_builder, "## âŒ Errors")
        Strings.append_line(report_builder, "")
        For Each error in result.errors:
            Strings.append_line(report_builder, format_error_for_report(error))
        Strings.append_line(report_builder, "")
    
    Note: Warnings section
    If Collections.get_list_size(result.warnings) > 0:
        Strings.append_line(report_builder, "## âš ï¸ Warnings")
        Strings.append_line(report_builder, "")
        For Each warning in result.warnings:
            Strings.append_line(report_builder, format_error_for_report(warning))
        Strings.append_line(report_builder, "")
    
    Note: Suggestions section
    If Collections.get_list_size(result.suggestions) > 0:
        Strings.append_line(report_builder, "## ðŸ’¡ Suggestions")
        Strings.append_line(report_builder, "")
        For Each suggestion in result.suggestions:
            Strings.append_line(report_builder, "- " + suggestion)
        Strings.append_line(report_builder, "")
    
    Return Strings.build_string(report_builder)

Process called "auto_fix_errors" that takes config_data as Dictionary[String, Any], errors as List[ValidationError] returns Dictionary[String, Any]:
    Note: Attempts to automatically fix common validation errors
    Note: Only fixes errors that can be safely corrected without losing data
    Note: Returns modified configuration with fixes applied
    
    Let fixed_config be Collections.deep_copy_dictionary(config_data)
    
    For Each error in errors:
        Note: Only attempt to fix errors with clear fix strategies
        If error.rule_name = "type" And can_safely_convert_type(error):
            apply_type_fix(fixed_config, error)
        Otherwise If error.rule_name = "range" And can_safely_clamp_value(error):
            apply_range_fix(fixed_config, error)
        Otherwise If error.rule_name = "required" And has_default_value(error):
            apply_default_value_fix(fixed_config, error)
    
    Return fixed_config

Note: =====================================================================
Note: VALIDATION/UTILITY OPERATIONS
Note: =====================================================================

Process called "load_validation_schema" that takes schema_file_path as String returns ConfigValidationSchema:
    Note: Loads validation schema from a configuration file
    Note: Supports multiple schema file formats (JSON, YAML, etc.)
    Note: Returns parsed and validated schema structure
    
    Note: This would integrate with the config_loader module
    Let loader be create_basic_config_loader()
    Let loaded_config be load_config_file(loader, schema_file_path)
    
    If Collections.get_list_size(loaded_config.errors) > 0:
        Throw Errors.InvalidConfiguration with "Failed to load validation schema: " + 
            Collections.get_list_item(loaded_config.errors, 0)
    
    Return parse_validation_schema_from_config(loaded_config.data)

Process called "register_custom_validator" that takes validator as ConfigValidator, name as String, validator_function as Function returns Boolean:
    Note: Registers a custom validation function with the validator
    Note: Custom validator should return list of ValidationError objects
    Note: Returns success status of registration
    
    If Strings.is_empty(name):
        Return False
    
    Collections.set_dictionary_value(validator.schema.custom_validators, name, validator_function)
    Return True

Process called "create_validation_error" that takes path as String, rule_name as String, message as String, severity as String returns ValidationError:
    Note: Creates a properly structured validation error object
    Note: Used by all validation functions for consistent error format
    Note: Initializes all required fields with appropriate defaults
    
    Let error be ValidationError
    Set error.path to path
    Set error.rule_name to rule_name
    Set error.message to message
    Set error.severity to severity
    Set error.suggested_fix to ""
    Set error.current_value to ""
    Set error.expected_value to ""
    
    Return error

Process called "has_nested_property" that takes config_data as Dictionary[String, Any], property_path as String returns Boolean:
    Note: Checks if a nested property exists using dot notation path
    Note: Supports deep property access like "database.connection.host"
    Note: Returns false if any part of the path doesn't exist
    
    Let path_parts be Strings.split(property_path, ".")
    Let current_data be config_data
    
    For Each part in path_parts:
        If Not Collections.is_dictionary(current_data):
            Return False
        
        If Not Collections.dictionary_has_key(current_data, part):
            Return False
        
        Set current_data to Collections.get_dictionary_value(current_data, part)
    
    Return True

Process called "get_nested_property" that takes config_data as Dictionary[String, Any], property_path as String returns Any:
    Note: Retrieves a nested property value using dot notation path
    Note: Returns the value at the specified path or null if not found
    Note: Should be used after has_nested_property check
    
    Let path_parts be Strings.split(property_path, ".")
    Let current_data be config_data
    
    For Each part in path_parts:
        If Collections.is_dictionary(current_data) And Collections.dictionary_has_key(current_data, part):
            Set current_data to Collections.get_dictionary_value(current_data, part)
        Otherwise:
            Return null
    
    Return current_data

Note: =====================================================================
Note: ADVANCED/OPTIMIZATION OPERATIONS
Note: =====================================================================

Process called "create_empty_validation_result" that takes nothing returns ValidationResult:
    Note: Creates an initialized empty validation result structure
    Note: Used for consistent initialization across validation operations
    Note: Provides default values for all result fields
    
    Let result be ValidationResult
    Set result.is_valid to True
    Set result.errors to Collections.create_list()
    Set result.warnings to Collections.create_list()
    Set result.suggestions to Collections.create_list()
    Set result.validated_paths to Collections.create_list()
    Set result.statistics to Collections.create_dictionary()
    
    Note: Initialize statistics
    Collections.set_dictionary_value(result.statistics, "total_properties", 0)
    Collections.set_dictionary_value(result.statistics, "validated_properties", 0)
    Collections.set_dictionary_value(result.statistics, "error_count", 0)
    Collections.set_dictionary_value(result.statistics, "warning_count", 0)
    
    Return result

Process called "get_value_type_name" that takes value as Any returns String:
    Note: Returns the type name of a configuration value
    Note: Used for type validation and error reporting
    Note: Returns standardized type names consistent with schema definitions
    
    If Collections.is_string(value):
        Return "string"
    Otherwise If Collections.is_integer(value):
        Return "integer"
    Otherwise If Collections.is_float(value):
        Return "float"
    Otherwise If Collections.is_boolean(value):
        Return "boolean"
    Otherwise If Collections.is_list(value):
        Return "array"
    Otherwise If Collections.is_dictionary(value):
        Return "object"
    Otherwise If value = null:
        Return "null"
    Otherwise:
        Return "unknown"

Process called "add_error_to_result" that takes result as ValidationResult, error as ValidationError returns Boolean:
    Note: Adds validation error to result and updates statistics
    Note: Categorizes errors vs warnings based on severity
    Note: Updates error and warning counts in statistics
    
    If error.severity = "error":
        Collections.add_to_list(result.errors, error)
        increment_statistic(result.statistics, "error_count")
    Otherwise:
        Collections.add_to_list(result.warnings, error)
        increment_statistic(result.statistics, "warning_count")
    
    Return True

Process called "increment_statistic" that takes statistics as Dictionary[String, Integer], stat_name as String returns Boolean:
    Note: Increments a statistic counter in the statistics dictionary
    Note: Creates the statistic if it doesn't exist
    Note: Used for tracking validation metrics
    
    Let current_value be 0
    If Collections.dictionary_has_key(statistics, stat_name):
        Set current_value to Collections.get_dictionary_value(statistics, stat_name)
    
    Collections.set_dictionary_value(statistics, stat_name, current_value + 1)
    Return True

Note: =====================================================================
Note: INTEGRATION/EXPORT OPERATIONS
Note: =====================================================================

Process called "validate_property_with_rules" that takes config_data as Dictionary[String, Any], property_path as String, rules as List[ValidationRule] returns List[ValidationError]:
    Note: Validates a single property against all its validation rules
    Note: Returns list of validation errors for the property
    Note: Applies rules in order and collects all violations
    
    Let errors be Collections.create_list()
    
    For Each rule in rules:
        Let rule_errors be apply_validation_rule(config_data, property_path, rule)
        For Each rule_error in rule_errors:
            Collections.add_to_list(errors, rule_error)
    
    Return errors

Process called "apply_validation_rule" that takes config_data as Dictionary[String, Any], property_path as String, rule as ValidationRule returns List[ValidationError]:
    Note: Applies a single validation rule to a property
    Note: Delegates to appropriate validation function based on rule type
    Note: Returns list of validation errors (empty if valid)
    
    Let errors be Collections.create_list()
    
    If rule.rule_type = "required":
        If Not has_nested_property(config_data, property_path):
            Let error be create_validation_error(property_path, rule.rule_name, rule.error_message, rule.severity)
            Collections.add_to_list(errors, error)
    
    Otherwise If rule.rule_type = "type":
        If has_nested_property(config_data, property_path):
            Let expected_type be Collections.get_dictionary_value(rule.parameters, "type")
            Let actual_value be get_nested_property(config_data, property_path)
            Let actual_type be get_value_type_name(actual_value)
            
            If actual_type != expected_type:
                Let error be create_validation_error(property_path, rule.rule_name, rule.error_message, rule.severity)
                Set error.current_value to Strings.convert_to_string(actual_value)
                Set error.expected_value to expected_type
                Collections.add_to_list(errors, error)
    
    Otherwise If rule.rule_type = "range":
        If has_nested_property(config_data, property_path):
            Let actual_value be get_nested_property(config_data, property_path)
            Let range_error be validate_single_range(property_path, actual_value, rule.parameters)
            If range_error != null:
                Set range_error.rule_name to rule.rule_name
                Set range_error.severity to rule.severity
                Collections.add_to_list(errors, range_error)
    
    Otherwise If rule.rule_type = "pattern":
        If has_nested_property(config_data, property_path):
            Let actual_value be get_nested_property(config_data, property_path)
            Let pattern be Collections.get_dictionary_value(rule.parameters, "pattern")
            
            If Collections.is_string(actual_value):
                If Not Strings.matches_pattern(actual_value, pattern):
                    Let error be create_validation_error(property_path, rule.rule_name, rule.error_message, rule.severity)
                    Collections.add_to_list(errors, error)
    
    Return errors

Process called "validate_single_range" that takes property_path as String, value as Any, range_spec as Dictionary[String, Any] returns ValidationError:
    Note: Validates a single value against range constraints
    Note: Supports numeric ranges, string length ranges, and array size ranges
    Note: Returns validation error if out of range, null if valid
    
    Let min_value be Collections.get_dictionary_value(range_spec, "min")
    Let max_value be Collections.get_dictionary_value(range_spec, "max")
    
    If Collections.is_integer(value) Or Collections.is_float(value):
        If value < min_value Or value > max_value:
            Let error_message be "Value " + Strings.convert_to_string(value) + 
                               " is outside allowed range " + Strings.convert_to_string(min_value) + 
                               " to " + Strings.convert_to_string(max_value)
            Return create_validation_error(property_path, "range", error_message, "error")
    
    Otherwise If Collections.is_string(value):
        Let string_length be Strings.length(value)
        If string_length < min_value Or string_length > max_value:
            Let error_message be "String length " + Strings.convert_to_string(string_length) + 
                               " is outside allowed range " + Strings.convert_to_string(min_value) + 
                               " to " + Strings.convert_to_string(max_value)
            Return create_validation_error(property_path, "range", error_message, "error")
    
    Otherwise If Collections.is_list(value):
        Let array_size be Collections.get_list_size(value)
        If array_size < min_value Or array_size > max_value:
            Let error_message be "Array size " + Strings.convert_to_string(array_size) + 
                               " is outside allowed range " + Strings.convert_to_string(min_value) + 
                               " to " + Strings.convert_to_string(max_value)
            Return create_validation_error(property_path, "range", error_message, "error")
    
    Return null