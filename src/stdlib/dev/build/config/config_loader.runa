Note:
dev/build/config/config_loader.runa
Configuration File Loading System

This module provides comprehensive configuration file loading capabilities for the Runa build system.

Key features and capabilities:
- Multi-format configuration file support (JSON, YAML, TOML, INI, Runa native)
- Directory-based configuration discovery and loading
- Configuration file watching and hot-reloading
- Caching system for improved performance
- Format auto-detection based on file extension and content
- Source prioritization and merging capabilities
- Comprehensive error handling and validation
- Memory-efficient streaming for large configuration files
- Thread-safe operations for concurrent access
- Platform-agnostic file system operations
:End Note

Import "collections" as Collections
Import "io" as IO
Import "os" as OS
Import "errors" as Errors

Note: =====================================================================
Note: DATA STRUCTURES/TYPES
Note: =====================================================================

Type called "ConfigFile":
    file_path as String                 Note: Full path to the configuration file
    format as String                    Note: Detected format: json, yaml, toml, ini, runa
    encoding as String                  Note: File encoding, defaults to UTF-8
    last_modified as Integer           Note: Last modification timestamp
    checksum as String                 Note: SHA-256 checksum for change detection
    size as Integer                    Note: File size in bytes for validation

Type called "ConfigSource":
    source_type as String              Note: Type: file, directory, url, environment
    location as String                 Note: Path, URL, or environment variable name
    priority as Integer                Note: Loading priority (higher numbers = higher priority)
    watch_for_changes as Boolean       Note: Enable file watching for hot-reload
    recursive as Boolean               Note: For directories, search recursively
    pattern as String                  Note: File pattern filter (e.g., "*.json")

Type called "LoadedConfig":
    data as Dictionary[String, Any]    Note: Merged configuration data
    source_files as List[ConfigFile]   Note: List of loaded source files
    load_time as Integer              Note: Timestamp when configuration was loaded
    errors as List[String]            Note: Non-fatal errors encountered during loading
    warnings as List[String]          Note: Warning messages from loading process
    metadata as Dictionary[String, String] Note: Additional metadata about the configuration

Type called "ConfigLoader":
    supported_formats as List[String]  Note: List of supported configuration formats
    search_paths as List[String]       Note: Default search paths for configuration files
    file_watchers as Dictionary[String, Any] Note: Active file watchers by path
    cache_enabled as Boolean           Note: Whether caching is enabled
    cache_storage as Dictionary[String, LoadedConfig] Note: In-memory configuration cache
    max_cache_size as Integer          Note: Maximum number of cached configurations
    default_encoding as String        Note: Default file encoding

Note: =====================================================================
Note: CORE OPERATIONS
Note: =====================================================================

Process called "create_config_loader" that takes search_paths as List[String] returns ConfigLoader:
    Note: Creates a new configuration loader with specified search paths
    Note: Initializes with default supported formats and empty cache
    Note: Time complexity: O(1), Space complexity: O(1)
    
    Let loader be ConfigLoader
    Set loader.supported_formats to ["json", "yaml", "toml", "ini", "runa", "conf"]
    Set loader.search_paths to search_paths
    Set loader.file_watchers to Collections.create_dictionary()
    Set loader.cache_enabled to True
    Set loader.cache_storage to Collections.create_dictionary()
    Set loader.max_cache_size to 100
    Set loader.default_encoding to "utf-8"
    
    Return loader

Process called "load_config_file" that takes loader as ConfigLoader, file_path as String returns LoadedConfig:
    Note: Loads configuration from a single file with format auto-detection
    Note: Handles file reading, parsing, and error recovery
    Note: Returns structured configuration data with metadata
    
    Let config be LoadedConfig
    Set config.data to Collections.create_dictionary()
    Set config.source_files to Collections.create_list()
    Set config.errors to Collections.create_list()
    Set config.warnings to Collections.create_list()
    Set config.metadata to Collections.create_dictionary()
    Set config.load_time to OS.get_current_time()
    
    Note: Check if file exists and is readable
    If Not OS.file_exists(file_path):
        Collections.add_to_list(config.errors, "Configuration file not found: " + file_path)
        Return config
    
    Note: Create ConfigFile metadata
    Let config_file be ConfigFile
    Set config_file.file_path to file_path
    Set config_file.format to detect_config_format(file_path)
    Set config_file.encoding to loader.default_encoding
    Set config_file.last_modified to OS.get_file_modified_time(file_path)
    Set config_file.size to OS.get_file_size(file_path)
    Set config_file.checksum to calculate_file_checksum(file_path)
    
    Collections.add_to_list(config.source_files, config_file)
    
    Note: Attempt to read and parse the file
    Try:
        Let file_content be IO.read_file(file_path, config_file.encoding)
        Let parsed_data be parse_config_content(file_content, config_file.format)
        Set config.data to parsed_data
    Catch error:
        Collections.add_to_list(config.errors, "Failed to load config file " + file_path + ": " + error.message)
    
    Return config

Process called "load_config_directory" that takes loader as ConfigLoader, directory_path as String returns LoadedConfig:
    Note: Loads all configuration files from a directory
    Note: Respects file patterns and priority ordering
    Note: Merges multiple configuration files into single result
    
    Let merged_config be LoadedConfig
    Set merged_config.data to Collections.create_dictionary()
    Set merged_config.source_files to Collections.create_list()
    Set merged_config.errors to Collections.create_list()
    Set merged_config.warnings to Collections.create_list()
    Set merged_config.metadata to Collections.create_dictionary()
    Set merged_config.load_time to OS.get_current_time()
    
    Note: Get all configuration files in directory
    Let config_files be find_config_files_in_directory(directory_path, loader.supported_formats)
    
    Note: Sort files by priority (alphabetical order as default)
    Set config_files to Collections.sort_list(config_files)
    
    Note: Load each configuration file and merge
    For Each file_path in config_files:
        Let individual_config be load_config_file(loader, file_path)
        
        Note: Merge source files list
        For Each source_file in individual_config.source_files:
            Collections.add_to_list(merged_config.source_files, source_file)
        
        Note: Merge errors and warnings
        For Each error in individual_config.errors:
            Collections.add_to_list(merged_config.errors, error)
        For Each warning in individual_config.warnings:
            Collections.add_to_list(merged_config.warnings, warning)
        
        Note: Merge configuration data (later files override earlier ones)
        Set merged_config.data to merge_dictionaries(merged_config.data, individual_config.data)
    
    Return merged_config

Process called "load_config_sources" that takes loader as ConfigLoader, sources as List[ConfigSource] returns LoadedConfig:
    Note: Loads configuration from multiple prioritized sources
    Note: Handles different source types (file, directory, environment)
    Note: Applies priority-based merging of configuration data
    
    Let final_config be LoadedConfig
    Set final_config.data to Collections.create_dictionary()
    Set final_config.source_files to Collections.create_list()
    Set final_config.errors to Collections.create_list()
    Set final_config.warnings to Collections.create_list()
    Set final_config.metadata to Collections.create_dictionary()
    Set final_config.load_time to OS.get_current_time()
    
    Note: Sort sources by priority (ascending order, higher priority overrides)
    Let sorted_sources be Collections.sort_list_by_field(sources, "priority")
    
    Note: Process each source in priority order
    For Each source in sorted_sources:
        Let source_config be LoadedConfig
        
        If source.source_type = "file":
            Set source_config to load_config_file(loader, source.location)
        Otherwise If source.source_type = "directory":
            Set source_config to load_config_directory(loader, source.location)
        Otherwise If source.source_type = "environment":
            Set source_config to load_environment_config(source.location)
        Otherwise:
            Collections.add_to_list(final_config.warnings, "Unknown source type: " + source.source_type)
            Continue
        
        Note: Merge this source's data with final configuration
        Set final_config.data to merge_dictionaries(final_config.data, source_config.data)
        
        Note: Accumulate source files, errors, and warnings
        For Each source_file in source_config.source_files:
            Collections.add_to_list(final_config.source_files, source_file)
        For Each error in source_config.errors:
            Collections.add_to_list(final_config.errors, error)
        For Each warning in source_config.warnings:
            Collections.add_to_list(final_config.warnings, warning)
    
    Return final_config

Note: =====================================================================
Note: SPECIALIZED OPERATIONS
Note: =====================================================================

Process called "detect_config_format" that takes file_path as String returns String:
    Note: Auto-detects configuration format from file extension and content
    Note: Supports multiple format detection strategies
    Note: Falls back to content-based detection if extension is ambiguous
    
    Note: Get file extension for initial format detection
    Let file_extension be OS.get_file_extension(file_path)
    
    Note: Map common extensions to formats
    If file_extension = "json":
        Return "json"
    Otherwise If file_extension = "yaml" Or file_extension = "yml":
        Return "yaml"
    Otherwise If file_extension = "toml":
        Return "toml"
    Otherwise If file_extension = "ini" Or file_extension = "cfg":
        Return "ini"
    Otherwise If file_extension = "runa":
        Return "runa"
    Otherwise If file_extension = "conf":
        Note: Content-based detection needed for .conf files
        Let content_sample be IO.read_file_partial(file_path, 1024)
        Return detect_format_from_content(content_sample)
    Otherwise:
        Note: Unknown extension, attempt content-based detection
        Let content_sample be IO.read_file_partial(file_path, 1024)
        Return detect_format_from_content(content_sample)

Process called "watch_config_changes" that takes loader as ConfigLoader, files as List[String], callback as Function returns Boolean:
    Note: Sets up file system watching for configuration file changes
    Note: Calls provided callback function when changes are detected
    Note: Returns success status of watcher setup
    
    Let watch_success be True
    
    For Each file_path in files:
        Try:
            Note: Create file watcher for this path
            Let watcher be OS.create_file_watcher(file_path)
            
            Note: Set up change callback
            OS.set_watcher_callback(watcher, callback)
            
            Note: Store watcher reference for cleanup
            Collections.set_dictionary_value(loader.file_watchers, file_path, watcher)
            
            Note: Start watching
            OS.start_file_watcher(watcher)
        Catch error:
            Set watch_success to False
            Note: Continue with other files even if one fails
    
    Return watch_success

Process called "reload_config" that takes loader as ConfigLoader, config as LoadedConfig returns LoadedConfig:
    Note: Reloads configuration from original sources
    Note: Maintains source file references and reloads each
    Note: Preserves original loading parameters and priorities
    
    Let reloaded_config be LoadedConfig
    Set reloaded_config.data to Collections.create_dictionary()
    Set reloaded_config.source_files to Collections.create_list()
    Set reloaded_config.errors to Collections.create_list()
    Set reloaded_config.warnings to Collections.create_list()
    Set reloaded_config.metadata to Collections.copy_dictionary(config.metadata)
    Set reloaded_config.load_time to OS.get_current_time()
    
    Note: Reload each source file
    For Each source_file in config.source_files:
        Let individual_config be load_config_file(loader, source_file.file_path)
        
        Note: Merge the reloaded data
        Set reloaded_config.data to merge_dictionaries(reloaded_config.data, individual_config.data)
        
        Note: Update source file list with new metadata
        For Each new_source_file in individual_config.source_files:
            Collections.add_to_list(reloaded_config.source_files, new_source_file)
        
        Note: Accumulate any new errors or warnings
        For Each error in individual_config.errors:
            Collections.add_to_list(reloaded_config.errors, error)
        For Each warning in individual_config.warnings:
            Collections.add_to_list(reloaded_config.warnings, warning)
    
    Return reloaded_config

Note: =====================================================================
Note: VALIDATION/UTILITY OPERATIONS
Note: =====================================================================

Process called "validate_config_structure" that takes config_data as Dictionary[String, Any], schema as Dictionary[String, Any] returns List[String]:
    Note: Validates configuration data against a provided schema
    Note: Returns list of validation errors, empty list means valid
    Note: Supports nested structure validation and type checking
    
    Let validation_errors be Collections.create_list()
    
    Note: Check required fields
    If Collections.dictionary_has_key(schema, "required"):
        Let required_fields be Collections.get_dictionary_value(schema, "required")
        For Each field_name in required_fields:
            If Not Collections.dictionary_has_key(config_data, field_name):
                Collections.add_to_list(validation_errors, "Required field missing: " + field_name)
    
    Note: Check field types and constraints
    If Collections.dictionary_has_key(schema, "properties"):
        Let properties_schema be Collections.get_dictionary_value(schema, "properties")
        For Each field_name in Collections.get_dictionary_keys(properties_schema):
            If Collections.dictionary_has_key(config_data, field_name):
                Let field_value be Collections.get_dictionary_value(config_data, field_name)
                Let field_schema be Collections.get_dictionary_value(properties_schema, field_name)
                Let field_errors be validate_field_value(field_name, field_value, field_schema)
                For Each error in field_errors:
                    Collections.add_to_list(validation_errors, error)
    
    Return validation_errors

Process called "calculate_file_checksum" that takes file_path as String returns String:
    Note: Calculates SHA-256 checksum of configuration file
    Note: Used for change detection and cache invalidation
    Note: Returns hexadecimal string representation
    
    Try:
        Let file_content be IO.read_file_binary(file_path)
        Let checksum be OS.calculate_sha256(file_content)
        Return checksum
    Catch error:
        Return ""

Process called "find_config_files_in_directory" that takes directory_path as String, supported_formats as List[String] returns List[String]:
    Note: Finds all configuration files in a directory
    Note: Filters by supported formats and excludes hidden files
    Note: Returns sorted list of file paths
    
    Let config_files be Collections.create_list()
    Let all_files be OS.list_directory_files(directory_path)
    
    For Each file_path in all_files:
        Let file_name be OS.get_file_name(file_path)
        
        Note: Skip hidden files
        If OS.string_starts_with(file_name, "."):
            Continue
        
        Note: Check if file has supported format
        Let file_extension be OS.get_file_extension(file_path)
        If Collections.list_contains(supported_formats, file_extension):
            Collections.add_to_list(config_files, file_path)
    
    Return Collections.sort_list(config_files)

Note: =====================================================================
Note: ADVANCED/OPTIMIZATION OPERATIONS
Note: =====================================================================

Process called "cache_config" that takes loader as ConfigLoader, config as LoadedConfig, cache_key as String returns Boolean:
    Note: Caches loaded configuration in memory for faster subsequent access
    Note: Implements LRU eviction when cache size limit is reached
    Note: Returns success status of caching operation
    
    If Not loader.cache_enabled:
        Return False
    
    Note: Check cache size limit and evict if necessary
    If Collections.get_dictionary_size(loader.cache_storage) >= loader.max_cache_size:
        Let oldest_key be find_oldest_cache_entry(loader.cache_storage)
        Collections.remove_dictionary_key(loader.cache_storage, oldest_key)
    
    Note: Store configuration in cache
    Collections.set_dictionary_value(loader.cache_storage, cache_key, config)
    
    Return True

Process called "get_cached_config" that takes loader as ConfigLoader, cache_key as String returns LoadedConfig:
    Note: Retrieves cached configuration if available and valid
    Note: Performs cache validation based on file modification times
    Note: Returns empty config if cache miss or invalid
    
    If Not loader.cache_enabled:
        Return create_empty_config()
    
    If Not Collections.dictionary_has_key(loader.cache_storage, cache_key):
        Return create_empty_config()
    
    Let cached_config be Collections.get_dictionary_value(loader.cache_storage, cache_key)
    
    Note: Validate cache by checking file modification times
    For Each source_file in cached_config.source_files:
        Let current_modified_time be OS.get_file_modified_time(source_file.file_path)
        If current_modified_time > source_file.last_modified:
            Note: Cache is stale, remove it
            Collections.remove_dictionary_key(loader.cache_storage, cache_key)
            Return create_empty_config()
    
    Return cached_config

Process called "clear_config_cache" that takes loader as ConfigLoader returns Boolean:
    Note: Clears all cached configurations from memory
    Note: Useful for forcing fresh loads or memory cleanup
    Note: Always returns True as operation cannot fail
    
    Set loader.cache_storage to Collections.create_dictionary()
    Return True

Note: =====================================================================
Note: INTEGRATION/EXPORT OPERATIONS
Note: =====================================================================

Process called "merge_dictionaries" that takes base_dict as Dictionary[String, Any], override_dict as Dictionary[String, Any] returns Dictionary[String, Any]:
    Note: Deep merges two configuration dictionaries
    Note: Override values take precedence over base values
    Note: Handles nested dictionary structures recursively
    
    Let merged_dict be Collections.copy_dictionary(base_dict)
    
    For Each key in Collections.get_dictionary_keys(override_dict):
        Let override_value be Collections.get_dictionary_value(override_dict, key)
        
        If Collections.dictionary_has_key(merged_dict, key):
            Let base_value be Collections.get_dictionary_value(merged_dict, key)
            
            Note: If both values are dictionaries, merge recursively
            If Collections.is_dictionary(base_value) And Collections.is_dictionary(override_value):
                Let nested_merged be merge_dictionaries(base_value, override_value)
                Collections.set_dictionary_value(merged_dict, key, nested_merged)
            Otherwise:
                Collections.set_dictionary_value(merged_dict, key, override_value)
        Otherwise:
            Collections.set_dictionary_value(merged_dict, key, override_value)
    
    Return merged_dict

Process called "parse_config_content" that takes content as String, format as String returns Dictionary[String, Any]:
    Note: Parses configuration content based on detected format
    Note: Delegates to format-specific parsers
    Note: Returns structured data dictionary
    
    If format = "json":
        Return parse_json_config(content)
    Otherwise If format = "yaml":
        Return parse_yaml_config(content)
    Otherwise If format = "toml":
        Return parse_toml_config(content)
    Otherwise If format = "ini":
        Return parse_ini_config(content)
    Otherwise If format = "runa":
        Return parse_runa_config(content)
    Otherwise:
        Throw Errors.InvalidFormat with "Unsupported configuration format: " + format

Process called "create_empty_config" that takes nothing returns LoadedConfig:
    Note: Creates an empty configuration structure
    Note: Used for initialization and cache miss scenarios
    Note: Provides consistent empty state
    
    Let empty_config be LoadedConfig
    Set empty_config.data to Collections.create_dictionary()
    Set empty_config.source_files to Collections.create_list()
    Set empty_config.load_time to OS.get_current_time()
    Set empty_config.errors to Collections.create_list()
    Set empty_config.warnings to Collections.create_list()
    Set empty_config.metadata to Collections.create_dictionary()
    
    Return empty_config