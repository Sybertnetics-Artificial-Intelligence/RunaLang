Note:
dev/build/config/config_merger.runa
Configuration Merging System

This module provides comprehensive configuration merging capabilities for the Runa build system.

Key features and capabilities:
- Multiple merge strategies (override, merge, append, prepend, custom)
- Intelligent conflict detection and resolution mechanisms
- Deep merging support for nested configuration structures
- Array merging with various strategies (replace, append, unique append)
- Priority-based configuration source ordering and processing
- Comprehensive conflict reporting and resolution tracking
- Custom conflict handler registration for complex scenarios
- Merge history tracking and audit trail capabilities
- Validation of merge results for data integrity
- Performance-optimized merging algorithms for large configurations
:End Note

Import "collections" as Collections
Import "errors" as Errors
Import "strings" as Strings

Note: =====================================================================
Note: DATA STRUCTURES/TYPES
Note: =====================================================================

Type called "MergeStrategy":
    strategy_name as String             Note: Type: override, merge, append, prepend, custom
    conflict_resolution as String       Note: Resolution method: first_wins, last_wins, prompt, error
    deep_merge as Boolean               Note: Whether to perform deep merging of nested objects
    array_merge_strategy as String      Note: Array handling: replace, append, unique_append, merge
    preserve_types as Boolean           Note: Whether to preserve original data types
    case_sensitive_keys as Boolean      Note: Whether key comparison is case-sensitive
    merge_null_values as Boolean        Note: Whether null values should override existing values

Type called "MergeConflict":
    config_path as String               Note: Dot-separated path where conflict occurred
    source_values as Dictionary[String, Any] Note: Values from each source by source ID
    resolution as String                Note: How the conflict was resolved
    resolved_value as Any               Note: Final value chosen for this path
    conflict_type as String             Note: Type of conflict: type_mismatch, value_conflict, etc.
    timestamp as Integer                Note: When the conflict was detected
    auto_resolved as Boolean            Note: Whether conflict was auto-resolved

Type called "MergeResult":
    merged_config as Dictionary[String, Any] Note: Final merged configuration
    conflicts as List[MergeConflict]    Note: List of conflicts encountered during merge
    merge_order as List[String]         Note: Order in which sources were processed
    warnings as List[String]            Note: Non-critical warnings during merge
    statistics as Dictionary[String, Integer] Note: Merge operation statistics
    metadata as Dictionary[String, String] Note: Additional merge metadata

Type called "ConfigSource":
    source_id as String                 Note: Unique identifier for this configuration source
    priority as Integer                 Note: Merge priority (higher numbers = higher priority)
    config_data as Dictionary[String, Any] Note: Actual configuration data
    merge_strategy as MergeStrategy     Note: Strategy to use for this source
    source_metadata as Dictionary[String, String] Note: Metadata about this source
    enabled as Boolean                  Note: Whether this source should be included in merge
    last_modified as Integer            Note: Last modification timestamp

Type called "ConfigMerger":
    default_strategy as MergeStrategy   Note: Default strategy when not specified per source
    conflict_handlers as Dictionary[String, Function] Note: Custom conflict resolution handlers
    merge_history as List[String]       Note: History of merge operations performed
    validation_rules as List[Function]  Note: Rules to validate merge results
    cache_enabled as Boolean            Note: Whether to cache merge results
    debug_mode as Boolean               Note: Whether to collect detailed debug information

Note: =====================================================================
Note: CORE OPERATIONS
Note: =====================================================================

Process called "create_config_merger" that takes default_strategy as MergeStrategy returns ConfigMerger:
    Note: Creates a new configuration merger with specified default strategy
    Note: Initializes conflict handlers and validation rules
    Note: Time complexity: O(1), Space complexity: O(1)
    
    Let merger be ConfigMerger
    Set merger.default_strategy to default_strategy
    Set merger.conflict_handlers to Collections.create_dictionary()
    Set merger.merge_history to Collections.create_list()
    Set merger.validation_rules to Collections.create_list()
    Set merger.cache_enabled to True
    Set merger.debug_mode to False
    
    Note: Register built-in conflict handlers
    Collections.set_dictionary_value(merger.conflict_handlers, "type_mismatch", handle_type_mismatch_conflict)
    Collections.set_dictionary_value(merger.conflict_handlers, "value_conflict", handle_value_conflict)
    Collections.set_dictionary_value(merger.conflict_handlers, "array_conflict", handle_array_conflict)
    
    Return merger

Process called "merge_configs" that takes merger as ConfigMerger, sources as List[ConfigSource] returns MergeResult:
    Note: Merges multiple configuration sources according to priority and strategies
    Note: Handles conflicts and generates comprehensive merge result
    Note: Returns detailed merge result with conflicts and statistics
    
    Let result be create_empty_merge_result()
    
    Note: Sort sources by priority (ascending order, higher priority overrides)
    Let sorted_sources be Collections.sort_list_by_field(sources, "priority")
    
    Note: Filter enabled sources
    Let active_sources be Collections.create_list()
    For Each source in sorted_sources:
        If source.enabled:
            Collections.add_to_list(active_sources, source)
            Collections.add_to_list(result.merge_order, source.source_id)
    
    Note: Initialize with first source's configuration
    If Collections.get_list_size(active_sources) > 0:
        Let first_source be Collections.get_list_item(active_sources, 0)
        Set result.merged_config to Collections.deep_copy_dictionary(first_source.config_data)
        Collections.set_dictionary_value(result.statistics, "sources_processed", 1)
    Otherwise:
        Collections.add_to_list(result.warnings, "No active configuration sources to merge")
        Return result
    
    Note: Merge remaining sources
    For i from 1 to Collections.get_list_size(active_sources) - 1:
        Let current_source be Collections.get_list_item(active_sources, i)
        Let merge_strategy be current_source.merge_strategy
        
        Note: Use default strategy if source doesn't specify one
        If merge_strategy = null:
            Set merge_strategy to merger.default_strategy
        
        Note: Perform two-config merge
        Let two_config_result be merge_two_configs(result.merged_config, current_source.config_data, merge_strategy)
        
        Note: Update result with merged data and conflicts
        Set result.merged_config to two_config_result.merged_config
        For Each conflict in two_config_result.conflicts:
            Collections.add_to_list(result.conflicts, conflict)
        For Each warning in two_config_result.warnings:
            Collections.add_to_list(result.warnings, warning)
        
        increment_statistic(result.statistics, "sources_processed")
    
    Note: Resolve any remaining conflicts
    Let resolved_conflicts be resolve_conflicts(merger, result.conflicts)
    Set result.conflicts to resolved_conflicts
    
    Note: Record merge operation in history
    Let merge_summary be "Merged " + Collections.get_list_size(active_sources) + " sources"
    Collections.add_to_list(merger.merge_history, merge_summary)
    
    Return result

Process called "merge_two_configs" that takes base_config as Dictionary[String, Any], override_config as Dictionary[String, Any], strategy as MergeStrategy returns MergeResult:
    Note: Merges two configuration dictionaries using specified strategy
    Note: Handles conflicts and applies appropriate merge logic
    Note: Returns merge result with conflicts and resolved configuration
    
    Let result be create_empty_merge_result()
    Set result.merged_config to Collections.deep_copy_dictionary(base_config)
    
    Note: Process each key in the override configuration
    For Each override_key in Collections.get_dictionary_keys(override_config):
        Let override_value be Collections.get_dictionary_value(override_config, override_key)
        
        If Collections.dictionary_has_key(result.merged_config, override_key):
            Let base_value be Collections.get_dictionary_value(result.merged_config, override_key)
            
            Note: Check for conflicts and resolve
            Let merge_conflict be detect_key_conflict(override_key, base_value, override_value, strategy)
            
            If merge_conflict != null:
                Collections.add_to_list(result.conflicts, merge_conflict)
                Collections.set_dictionary_value(result.merged_config, override_key, merge_conflict.resolved_value)
            Otherwise:
                Note: No conflict, apply merge logic
                Let merged_value be apply_merge_logic(override_key, base_value, override_value, strategy)
                Collections.set_dictionary_value(result.merged_config, override_key, merged_value)
        Otherwise:
            Note: New key, add it directly
            Collections.set_dictionary_value(result.merged_config, override_key, override_value)
    
    Return result

Process called "deep_merge_configs" that takes base_config as Dictionary[String, Any], override_config as Dictionary[String, Any] returns Dictionary[String, Any]:
    Note: Performs deep merge of two configuration objects
    Note: Recursively merges nested dictionaries and handles arrays
    Note: Returns merged configuration with all nested structures combined
    
    Let merged_config be Collections.deep_copy_dictionary(base_config)
    
    For Each override_key in Collections.get_dictionary_keys(override_config):
        Let override_value be Collections.get_dictionary_value(override_config, override_key)
        
        If Collections.dictionary_has_key(merged_config, override_key):
            Let base_value be Collections.get_dictionary_value(merged_config, override_key)
            
            Note: Recursively merge nested dictionaries
            If Collections.is_dictionary(base_value) And Collections.is_dictionary(override_value):
                Let nested_merged be deep_merge_configs(base_value, override_value)
                Collections.set_dictionary_value(merged_config, override_key, nested_merged)
            Otherwise If Collections.is_list(base_value) And Collections.is_list(override_value):
                Let merged_array be merge_arrays(base_value, override_value, "unique_append")
                Collections.set_dictionary_value(merged_config, override_key, merged_array)
            Otherwise:
                Note: Override with new value
                Collections.set_dictionary_value(merged_config, override_key, override_value)
        Otherwise:
            Collections.set_dictionary_value(merged_config, override_key, override_value)
    
    Return merged_config

Process called "resolve_conflicts" that takes merger as ConfigMerger, conflicts as List[MergeConflict] returns List[MergeConflict]:
    Note: Resolves merge conflicts using registered conflict handlers
    Note: Applies conflict resolution strategies and updates conflict records
    Note: Returns list of resolved conflicts with resolution details
    
    Let resolved_conflicts be Collections.create_list()
    
    For Each conflict in conflicts:
        Let resolved_conflict be conflict
        
        Note: Try to resolve using registered handlers
        If Collections.dictionary_has_key(merger.conflict_handlers, conflict.conflict_type):
            Let handler_function be Collections.get_dictionary_value(merger.conflict_handlers, conflict.conflict_type)
            
            Try:
                Set resolved_conflict to handler_function(conflict)
                Set resolved_conflict.auto_resolved to True
            Catch handler_error:
                Collections.add_to_list(resolved_conflicts, conflict)
                Continue
        
        Note: Apply default resolution strategy
        If resolved_conflict.resolution = "":
            Set resolved_conflict to apply_default_resolution(resolved_conflict)
        
        Collections.add_to_list(resolved_conflicts, resolved_conflict)
    
    Return resolved_conflicts

Note: =====================================================================
Note: SPECIALIZED OPERATIONS
Note: =====================================================================

Process called "merge_arrays" that takes base_array as List[Any], override_array as List[Any], strategy as String returns List[Any]:
    Note: Merges two arrays according to specified strategy
    Note: Supports replace, append, unique append, and merge strategies
    Note: Returns combined array based on merge strategy
    
    If strategy = "replace":
        Return override_array
    
    Otherwise If strategy = "append":
        Let merged_array be Collections.copy_list(base_array)
        For Each item in override_array:
            Collections.add_to_list(merged_array, item)
        Return merged_array
    
    Otherwise If strategy = "unique_append":
        Let merged_array be Collections.copy_list(base_array)
        For Each item in override_array:
            If Not Collections.list_contains(merged_array, item):
                Collections.add_to_list(merged_array, item)
        Return merged_array
    
    Otherwise If strategy = "prepend":
        Let merged_array be Collections.copy_list(override_array)
        For Each item in base_array:
            Collections.add_to_list(merged_array, item)
        Return merged_array
    
    Otherwise:
        Note: Default to append strategy
        Return merge_arrays(base_array, override_array, "append")

Process called "detect_conflicts" that takes config_path as String, values as Dictionary[String, Any] returns MergeConflict:
    Note: Detects conflicts between multiple configuration values
    Note: Analyzes type compatibility and value differences
    Note: Returns conflict object if conflict exists, null otherwise
    
    Let unique_values be Collections.create_list()
    Let unique_types be Collections.create_list()
    
    Note: Collect unique values and types
    For Each source_id in Collections.get_dictionary_keys(values):
        Let value be Collections.get_dictionary_value(values, source_id)
        Let value_type be get_value_type_name(value)
        
        If Not Collections.list_contains(unique_values, value):
            Collections.add_to_list(unique_values, value)
        
        If Not Collections.list_contains(unique_types, value_type):
            Collections.add_to_list(unique_types, value_type)
    
    Note: Check for conflicts
    If Collections.get_list_size(unique_values) > 1:
        Let conflict be MergeConflict
        Set conflict.config_path to config_path
        Set conflict.source_values to values
        Set conflict.timestamp to get_current_timestamp()
        Set conflict.auto_resolved to False
        
        Note: Determine conflict type
        If Collections.get_list_size(unique_types) > 1:
            Set conflict.conflict_type to "type_mismatch"
        Otherwise:
            Set conflict.conflict_type to "value_conflict"
        
        Return conflict
    
    Return null

Process called "apply_merge_strategy" that takes strategy as MergeStrategy, config_path as String, values as Dictionary[String, Any] returns Any:
    Note: Applies merge strategy to resolve conflicting values
    Note: Uses strategy configuration to determine resolution method
    Note: Returns resolved value based on strategy rules
    
    If strategy.conflict_resolution = "first_wins":
        Note: Return value from first source (lowest priority)
        Let first_source be get_first_dictionary_key(values)
        Return Collections.get_dictionary_value(values, first_source)
    
    Otherwise If strategy.conflict_resolution = "last_wins":
        Note: Return value from last source (highest priority)
        Let last_source be get_last_dictionary_key(values)
        Return Collections.get_dictionary_value(values, last_source)
    
    Otherwise If strategy.conflict_resolution = "error":
        Throw Errors.ConfigurationConflict with "Unresolved conflict at path: " + config_path
    
    Otherwise:
        Note: Default to last wins
        Let last_source be get_last_dictionary_key(values)
        Return Collections.get_dictionary_value(values, last_source)

Process called "validate_merge_result" that takes result as MergeResult returns List[String]:
    Note: Validates the integrity and consistency of merge result
    Note: Checks for common issues and inconsistencies
    Note: Returns list of validation errors found
    
    Let validation_errors be Collections.create_list()
    
    Note: Check for unresolved conflicts
    For Each conflict in result.conflicts:
        If conflict.resolution = "" Or conflict.resolved_value = null:
            Collections.add_to_list(validation_errors, 
                "Unresolved conflict at path: " + conflict.config_path)
    
    Note: Check for circular references in merged config
    Let circular_refs be detect_circular_references(result.merged_config)
    For Each circular_ref in circular_refs:
        Collections.add_to_list(validation_errors, 
            "Circular reference detected at path: " + circular_ref)
    
    Note: Validate required configuration keys
    Let missing_required be find_missing_required_keys(result.merged_config)
    For Each missing_key in missing_required:
        Collections.add_to_list(validation_errors, 
            "Required configuration key missing: " + missing_key)
    
    Return validation_errors

Process called "generate_merge_report" that takes result as MergeResult returns String:
    Note: Generates comprehensive human-readable merge report
    Note: Includes statistics, conflicts, and warnings in formatted output
    Note: Returns markdown-formatted report for documentation
    
    Let report_builder be Strings.create_string_builder()
    
    Strings.append_line(report_builder, "# Configuration Merge Report")
    Strings.append_line(report_builder, "")
    
    Note: Merge statistics
    Strings.append_line(report_builder, "## Merge Statistics")
    Strings.append_line(report_builder, "")
    For Each stat_name in Collections.get_dictionary_keys(result.statistics):
        Let stat_value be Collections.get_dictionary_value(result.statistics, stat_name)
        Strings.append_line(report_builder, "- **" + format_stat_name(stat_name) + ":** " + stat_value)
    Strings.append_line(report_builder, "")
    
    Note: Merge order
    Strings.append_line(report_builder, "## Source Processing Order")
    Strings.append_line(report_builder, "")
    For i from 0 to Collections.get_list_size(result.merge_order) - 1:
        Let source_id be Collections.get_list_item(result.merge_order, i)
        Strings.append_line(report_builder, (i + 1) + ". " + source_id)
    Strings.append_line(report_builder, "")
    
    Note: Conflicts section
    If Collections.get_list_size(result.conflicts) > 0:
        Strings.append_line(report_builder, "## ⚠️ Merge Conflicts")
        Strings.append_line(report_builder, "")
        For Each conflict in result.conflicts:
            Strings.append_line(report_builder, format_conflict_for_report(conflict))
        Strings.append_line(report_builder, "")
    
    Note: Warnings section
    If Collections.get_list_size(result.warnings) > 0:
        Strings.append_line(report_builder, "## ⚠️ Warnings")
        Strings.append_line(report_builder, "")
        For Each warning in result.warnings:
            Strings.append_line(report_builder, "- " + warning)
        Strings.append_line(report_builder, "")
    
    Return Strings.build_string(report_builder)

Note: =====================================================================
Note: VALIDATION/UTILITY OPERATIONS
Note: =====================================================================

Process called "register_conflict_handler" that takes merger as ConfigMerger, conflict_type as String, handler_function as Function returns Boolean:
    Note: Registers custom conflict resolution handler for specific conflict type
    Note: Handler function should accept MergeConflict and return resolved MergeConflict
    Note: Returns success status of registration
    
    If Strings.is_empty(conflict_type):
        Return False
    
    Collections.set_dictionary_value(merger.conflict_handlers, conflict_type, handler_function)
    Return True

Process called "create_merge_strategy" that takes strategy_config as Dictionary[String, Any] returns MergeStrategy:
    Note: Creates merge strategy from configuration dictionary
    Note: Supports all strategy options with sensible defaults
    Note: Returns configured merge strategy object
    
    Let strategy be MergeStrategy
    
    Note: Set strategy name with default
    If Collections.dictionary_has_key(strategy_config, "strategy_name"):
        Set strategy.strategy_name to Collections.get_dictionary_value(strategy_config, "strategy_name")
    Otherwise:
        Set strategy.strategy_name to "merge"
    
    Note: Set conflict resolution with default
    If Collections.dictionary_has_key(strategy_config, "conflict_resolution"):
        Set strategy.conflict_resolution to Collections.get_dictionary_value(strategy_config, "conflict_resolution")
    Otherwise:
        Set strategy.conflict_resolution to "last_wins"
    
    Note: Set deep merge option with default
    If Collections.dictionary_has_key(strategy_config, "deep_merge"):
        Set strategy.deep_merge to Collections.get_dictionary_value(strategy_config, "deep_merge")
    Otherwise:
        Set strategy.deep_merge to True
    
    Note: Set array merge strategy with default
    If Collections.dictionary_has_key(strategy_config, "array_merge_strategy"):
        Set strategy.array_merge_strategy to Collections.get_dictionary_value(strategy_config, "array_merge_strategy")
    Otherwise:
        Set strategy.array_merge_strategy to "unique_append"
    
    Note: Set additional options with defaults
    Set strategy.preserve_types to True
    Set strategy.case_sensitive_keys to True
    Set strategy.merge_null_values to False
    
    Return strategy

Process called "detect_key_conflict" that takes key as String, base_value as Any, override_value as Any, strategy as MergeStrategy returns MergeConflict:
    Note: Detects conflict between two values for a specific key
    Note: Considers strategy settings when determining if conflict exists
    Note: Returns conflict object or null if no conflict
    
    Note: Check if values are identical
    If values_are_equal(base_value, override_value):
        Return null
    
    Note: Check type compatibility if preserve_types is enabled
    If strategy.preserve_types:
        Let base_type be get_value_type_name(base_value)
        Let override_type be get_value_type_name(override_value)
        
        If base_type != override_type:
            Let conflict be MergeConflict
            Set conflict.config_path to key
            Set conflict.conflict_type to "type_mismatch"
            Set conflict.timestamp to get_current_timestamp()
            
            Note: Create source values dictionary
            Let source_values be Collections.create_dictionary()
            Collections.set_dictionary_value(source_values, "base", base_value)
            Collections.set_dictionary_value(source_values, "override", override_value)
            Set conflict.source_values to source_values
            
            Note: Apply resolution strategy
            Set conflict.resolved_value to apply_merge_strategy(strategy, key, source_values)
            Set conflict.resolution to strategy.conflict_resolution
            
            Return conflict
    
    Note: Handle null values based on strategy
    If override_value = null And Not strategy.merge_null_values:
        Return null
    
    Note: Create value conflict
    Let conflict be MergeConflict
    Set conflict.config_path to key
    Set conflict.conflict_type to "value_conflict"
    Set conflict.timestamp to get_current_timestamp()
    
    Let source_values be Collections.create_dictionary()
    Collections.set_dictionary_value(source_values, "base", base_value)
    Collections.set_dictionary_value(source_values, "override", override_value)
    Set conflict.source_values to source_values
    Set conflict.resolved_value to apply_merge_strategy(strategy, key, source_values)
    Set conflict.resolution to strategy.conflict_resolution
    
    Return conflict

Note: =====================================================================
Note: ADVANCED/OPTIMIZATION OPERATIONS
Note: =====================================================================

Process called "create_empty_merge_result" that takes nothing returns MergeResult:
    Note: Creates an initialized empty merge result structure
    Note: Used for consistent initialization across merge operations
    Note: Provides default values for all result fields
    
    Let result be MergeResult
    Set result.merged_config to Collections.create_dictionary()
    Set result.conflicts to Collections.create_list()
    Set result.merge_order to Collections.create_list()
    Set result.warnings to Collections.create_list()
    Set result.statistics to Collections.create_dictionary()
    Set result.metadata to Collections.create_dictionary()
    
    Note: Initialize statistics
    Collections.set_dictionary_value(result.statistics, "sources_processed", 0)
    Collections.set_dictionary_value(result.statistics, "conflicts_detected", 0)
    Collections.set_dictionary_value(result.statistics, "conflicts_resolved", 0)
    
    Return result

Process called "apply_merge_logic" that takes key as String, base_value as Any, override_value as Any, strategy as MergeStrategy returns Any:
    Note: Applies merge logic based on strategy without conflict detection
    Note: Handles deep merging and array merging according to strategy
    Note: Returns merged value for the specific key
    
    Note: Handle deep merge for nested objects
    If strategy.deep_merge And Collections.is_dictionary(base_value) And Collections.is_dictionary(override_value):
        Return deep_merge_configs(base_value, override_value)
    
    Note: Handle array merging
    If Collections.is_list(base_value) And Collections.is_list(override_value):
        Return merge_arrays(base_value, override_value, strategy.array_merge_strategy)
    
    Note: Handle null values
    If override_value = null And Not strategy.merge_null_values:
        Return base_value
    
    Note: Default to override value
    Return override_value

Process called "increment_statistic" that takes statistics as Dictionary[String, Integer], stat_name as String returns Boolean:
    Note: Increments a statistic counter in the statistics dictionary
    Note: Creates the statistic if it doesn't exist
    Note: Used for tracking merge operation metrics
    
    Let current_value be 0
    If Collections.dictionary_has_key(statistics, stat_name):
        Set current_value to Collections.get_dictionary_value(statistics, stat_name)
    
    Collections.set_dictionary_value(statistics, stat_name, current_value + 1)
    Return True

Process called "values_are_equal" that takes value1 as Any, value2 as Any returns Boolean:
    Note: Performs deep equality comparison between two values
    Note: Handles all configuration data types including nested structures
    Note: Returns true if values are logically equal
    
    Note: Handle null comparisons
    If value1 = null And value2 = null:
        Return True
    If value1 = null Or value2 = null:
        Return False
    
    Note: Handle type mismatches
    Let type1 be get_value_type_name(value1)
    Let type2 be get_value_type_name(value2)
    If type1 != type2:
        Return False
    
    Note: Handle primitive types
    If Collections.is_string(value1) Or Collections.is_integer(value1) Or 
       Collections.is_float(value1) Or Collections.is_boolean(value1):
        Return value1 = value2
    
    Note: Handle arrays
    If Collections.is_list(value1):
        If Collections.get_list_size(value1) != Collections.get_list_size(value2):
            Return False
        
        For i from 0 to Collections.get_list_size(value1) - 1:
            Let item1 be Collections.get_list_item(value1, i)
            Let item2 be Collections.get_list_item(value2, i)
            If Not values_are_equal(item1, item2):
                Return False
        
        Return True
    
    Note: Handle dictionaries
    If Collections.is_dictionary(value1):
        Let keys1 be Collections.get_dictionary_keys(value1)
        Let keys2 be Collections.get_dictionary_keys(value2)
        
        If Collections.get_list_size(keys1) != Collections.get_list_size(keys2):
            Return False
        
        For Each key in keys1:
            If Not Collections.dictionary_has_key(value2, key):
                Return False
            
            Let sub_value1 be Collections.get_dictionary_value(value1, key)
            Let sub_value2 be Collections.get_dictionary_value(value2, key)
            If Not values_are_equal(sub_value1, sub_value2):
                Return False
        
        Return True
    
    Return False

Note: =====================================================================
Note: INTEGRATION/EXPORT OPERATIONS
Note: =====================================================================

Process called "get_value_type_name" that takes value as Any returns String:
    Note: Returns the type name of a configuration value
    Note: Used for type checking and conflict detection
    Note: Returns standardized type names
    
    If Collections.is_string(value):
        Return "string"
    Otherwise If Collections.is_integer(value):
        Return "integer"
    Otherwise If Collections.is_float(value):
        Return "float"
    Otherwise If Collections.is_boolean(value):
        Return "boolean"
    Otherwise If Collections.is_list(value):
        Return "array"
    Otherwise If Collections.is_dictionary(value):
        Return "object"
    Otherwise If value = null:
        Return "null"
    Otherwise:
        Return "unknown"

Process called "get_current_timestamp" that takes nothing returns Integer:
    Note: Returns current timestamp for conflict tracking
    Note: Used for audit trail and conflict resolution history
    Note: Returns Unix timestamp in seconds
    
    Return OS.get_current_time()

Process called "format_conflict_for_report" that takes conflict as MergeConflict returns String:
    Note: Formats merge conflict for inclusion in reports
    Note: Creates human-readable description of the conflict
    Note: Returns formatted conflict description
    
    Let conflict_desc be "**Path:** `" + conflict.config_path + "`\n"
    Set conflict_desc to conflict_desc + "**Type:** " + conflict.conflict_type + "\n"
    Set conflict_desc to conflict_desc + "**Resolution:** " + conflict.resolution + "\n"
    
    If Collections.get_dictionary_size(conflict.source_values) > 0:
        Set conflict_desc to conflict_desc + "**Source Values:**\n"
        For Each source_id in Collections.get_dictionary_keys(conflict.source_values):
            Let source_value be Collections.get_dictionary_value(conflict.source_values, source_id)
            Set conflict_desc to conflict_desc + "  - " + source_id + ": `" + Strings.convert_to_string(source_value) + "`\n"
    
    Set conflict_desc to conflict_desc + "**Resolved Value:** `" + Strings.convert_to_string(conflict.resolved_value) + "`\n"
    
    Return conflict_desc

Process called "format_stat_name" that takes stat_name as String returns String:
    Note: Formats statistic name for human-readable display
    Note: Converts snake_case to Title Case format
    Note: Returns formatted statistic name
    
    Let formatted_name be Strings.replace_all(stat_name, "_", " ")
    Return Strings.to_title_case(formatted_name)