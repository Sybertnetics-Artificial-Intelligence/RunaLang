Note:
app/graphics/platforms/metal/devices.runa
Metal Device Management

This module provides Metal device creation and management including:
- Device enumeration and selection
- Command queue creation
- Device capabilities and features
- GPU family support detection
- Memory management and limits
- Performance statistics
- Multi-GPU support
- Shared events and fences
- Device notifications
- Power management
:End Note

Import "dev/debug/errors/core" as Errors

Note: =====================================================================
Note: METAL DEVICE DATA STRUCTURES
Note: =====================================================================

Type called "MTLDevice":
    handle as Integer
    name as String
    registry_id as Integer
    location as String
    location_number as Integer
    max_threads_per_threadgroup as Integer
    max_threadgroup_memory as Integer
    is_headless as Boolean
    is_low_power as Boolean
    is_removable as Boolean
    recommended_max_working_set_size as Integer
    has_unified_memory as Boolean
    supports_family as Dictionary[String, Boolean]
    supports_feature_set as Dictionary[String, Boolean]

Type called "MTLCommandQueue":
    handle as Integer
    device as MTLDevice
    label as String
    max_command_buffer_count as Integer

Type called "MTLGPUFamily":
    apple as List[Integer]
    mac as List[Integer]
    common as List[Integer]
    metal3 as Boolean

Type called "MTLFeatureSet":
    ios_gpu_family as List[Integer]
    macos_gpu_family as List[Integer]
    tvos as List[Integer]

Type called "MTLDeviceCapabilities":
    max_texture_dimension_1d as Integer
    max_texture_dimension_2d as Integer
    max_texture_dimension_3d as Integer
    max_texture_dimension_cube as Integer
    max_texture_array_layers as Integer
    max_buffer_length as Integer
    max_argument_buffer_samplers as Integer
    max_threads_per_threadgroup as Integer
    max_threadgroups_per_grid as List[Integer]
    sparse_texture_alignment as Integer
    min_buffer_offset_alignment as Integer
    min_texture_buffer_offset_alignment as Integer

Type called "MTLResourceOptions":
    storage_mode as String
    cache_mode as String
    hazard_tracking_mode as String

Type called "MTLHeap":
    handle as Integer
    size as Integer
    used_size as Integer
    storage_mode as String
    cpu_cache_mode as String
    hazard_tracking_mode as String
    type as String
    label as String

Type called "MTLCounterSet":
    handle as Integer
    name as String
    counters as List[MTLCounter]

Type called "MTLCounter":
    name as String
    handle as Integer

Note: =====================================================================
Note: DEVICE ENUMERATION
Note: =====================================================================

Process called "create_system_default_device" that takes nothing returns MTLDevice:
    Note: Gets default system GPU
    Placeholder

Process called "copy_all_devices" that takes nothing returns List[MTLDevice]:
    Note: Gets all available devices
    Placeholder

Process called "copy_all_devices_with_observer" that takes observer as Function returns Tuple[List[MTLDevice], Integer]:
    Note: Gets devices with observer
    Placeholder

Process called "remove_device_observer" that takes observer_id as Integer returns Nothing:
    Note: Removes device observer
    Placeholder

Process called "preferred_system_device" that takes nothing returns MTLDevice:
    Note: Gets preferred system device
    Placeholder

Note: =====================================================================
Note: DEVICE PROPERTIES
Note: =====================================================================

Process called "get_device_name" that takes device as MTLDevice returns String:
    Note: Gets device name
    Placeholder

Process called "get_registry_id" that takes device as MTLDevice returns Integer:
    Note: Gets registry ID
    Placeholder

Process called "get_location" that takes device as MTLDevice returns String:
    Note: Gets device location
    Placeholder

Process called "is_headless" that takes device as MTLDevice returns Boolean:
    Note: Checks if device is headless
    Placeholder

Process called "is_low_power" that takes device as MTLDevice returns Boolean:
    Note: Checks if device is low power
    Placeholder

Process called "is_removable" that takes device as MTLDevice returns Boolean:
    Note: Checks if device is removable
    Placeholder

Process called "has_unified_memory" that takes device as MTLDevice returns Boolean:
    Note: Checks unified memory support
    Placeholder

Note: =====================================================================
Note: FEATURE SUPPORT
Note: =====================================================================

Process called "supports_family" that takes device as MTLDevice, family as String returns Boolean:
    Note: Checks GPU family support
    Placeholder

Process called "supports_feature_set" that takes device as MTLDevice, feature_set as String returns Boolean:
    Note: Checks feature set support
    Placeholder

Process called "supports_texture_sample_count" that takes device as MTLDevice, sample_count as Integer returns Boolean:
    Note: Checks sample count support
    Placeholder

Process called "supports_vertex_amplification_count" that takes device as MTLDevice, count as Integer returns Boolean:
    Note: Checks amplification support
    Placeholder

Process called "supports_raytracing" that takes device as MTLDevice returns Boolean:
    Note: Checks ray tracing support
    Placeholder

Process called "supports_shader_barycentric_coordinates" that takes device as MTLDevice returns Boolean:
    Note: Checks barycentric support
    Placeholder

Process called "supports_function_pointers" that takes device as MTLDevice returns Boolean:
    Note: Checks function pointer support
    Placeholder

Note: =====================================================================
Note: COMMAND QUEUE MANAGEMENT
Note: =====================================================================

Process called "new_command_queue" that takes device as MTLDevice returns MTLCommandQueue:
    Note: Creates command queue
    Placeholder

Process called "new_command_queue_with_max_command_buffer_count" that takes device as MTLDevice, max_count as Integer returns MTLCommandQueue:
    Note: Creates queue with buffer limit
    Placeholder

Process called "set_command_queue_label" that takes queue as MTLCommandQueue, label as String returns Nothing:
    Note: Sets queue debug label
    Placeholder

Process called "get_command_queue_device" that takes queue as MTLCommandQueue returns MTLDevice:
    Note: Gets queue's device
    Placeholder

Note: =====================================================================
Note: MEMORY LIMITS
Note: =====================================================================

Process called "get_max_buffer_length" that takes device as MTLDevice returns Integer:
    Note: Gets max buffer size
    Placeholder

Process called "get_max_threadgroup_memory_length" that takes device as MTLDevice returns Integer:
    Note: Gets max threadgroup memory
    Placeholder

Process called "get_max_threads_per_threadgroup" that takes device as MTLDevice returns Integer:
    Note: Gets max threads per group
    Placeholder

Process called "get_recommended_max_working_set_size" that takes device as MTLDevice returns Integer:
    Note: Gets recommended working set
    Placeholder

Process called "get_current_allocated_size" that takes device as MTLDevice returns Integer:
    Note: Gets current allocation size
    Placeholder

Note: =====================================================================
Note: HEAP MANAGEMENT
Note: =====================================================================

Process called "new_heap" that takes device as MTLDevice, descriptor as Dictionary[String, Any] returns MTLHeap:
    Note: Creates memory heap
    Placeholder

Process called "heap_size_and_align" that takes device as MTLDevice, descriptor as Dictionary[String, Any] returns Tuple[Integer, Integer]:
    Note: Gets heap size requirements
    Placeholder

Process called "heap_texture_size_and_align" that takes device as MTLDevice, descriptor as Dictionary[String, Any] returns Tuple[Integer, Integer]:
    Note: Gets texture heap requirements
    Placeholder

Process called "heap_buffer_size_and_align" that takes device as MTLDevice, length as Integer, options as MTLResourceOptions returns Tuple[Integer, Integer]:
    Note: Gets buffer heap requirements
    Placeholder

Note: =====================================================================
Note: SHARED EVENTS
Note: =====================================================================

Process called "new_shared_event" that takes device as MTLDevice returns Integer:
    Note: Creates shared event
    Placeholder

Process called "new_shared_event_with_handle" that takes device as MTLDevice, handle as Integer returns Integer:
    Note: Creates event from handle
    Placeholder

Process called "supports_shared_events" that takes device as MTLDevice returns Boolean:
    Note: Checks shared event support
    Placeholder

Note: =====================================================================
Note: FENCE SUPPORT
Note: =====================================================================

Process called "new_fence" that takes device as MTLDevice returns Integer:
    Note: Creates fence object
    Placeholder

Process called "supports_fences" that takes device as MTLDevice returns Boolean:
    Note: Checks fence support
    Placeholder

Note: =====================================================================
Note: ARGUMENT BUFFERS
Note: =====================================================================

Process called "get_max_argument_buffer_samplers" that takes device as MTLDevice returns Integer:
    Note: Gets max argument samplers
    Placeholder

Process called "supports_argument_buffers" that takes device as MTLDevice returns Boolean:
    Note: Checks argument buffer support
    Placeholder

Process called "new_argument_encoder" that takes device as MTLDevice, arguments as List[Dictionary[String, Any]] returns Integer:
    Note: Creates argument encoder
    Placeholder

Note: =====================================================================
Note: COUNTER SAMPLING
Note: =====================================================================

Process called "get_counter_sets" that takes device as MTLDevice returns List[MTLCounterSet]:
    Note: Gets available counter sets
    Placeholder

Process called "new_counter_sample_buffer" that takes device as MTLDevice, descriptor as Dictionary[String, Any] returns Integer:
    Note: Creates counter sample buffer
    Placeholder

Process called "supports_counter_sampling" that takes device as MTLDevice, stage as String returns Boolean:
    Note: Checks counter sampling support
    Placeholder

Note: =====================================================================
Note: PERFORMANCE HINTS
Note: =====================================================================

Process called "get_sparse_tile_size" that takes device as MTLDevice, texture_type as String, pixel_format as String, sample_count as Integer returns Dictionary[String, Integer]:
    Note: Gets sparse tile dimensions
    Placeholder

Process called "minimum_linear_texture_alignment" that takes device as MTLDevice, pixel_format as String returns Integer:
    Note: Gets texture alignment
    Placeholder

Process called "minimum_texture_buffer_alignment" that takes device as MTLDevice, pixel_format as String returns Integer:
    Note: Gets buffer alignment
    Placeholder

Note: =====================================================================
Note: DEVICE NOTIFICATIONS
Note: =====================================================================

Process called "register_device_notification" that takes device as MTLDevice, callback as Function returns Integer:
    Note: Registers for notifications
    Placeholder

Process called "unregister_device_notification" that takes notification_id as Integer returns Nothing:
    Note: Unregisters notification
    Placeholder

Process called "was_device_removed" that takes device as MTLDevice returns Boolean:
    Note: Checks if device was removed
    Placeholder

Note: =====================================================================
Note: UTILITIES
Note: =====================================================================

Process called "copy_default_library" that takes device as MTLDevice returns Integer:
    Note: Gets default shader library
    Placeholder

Process called "new_library_with_source" that takes device as MTLDevice, source as String, options as Dictionary[String, Any] returns Integer:
    Note: Creates library from source
    Placeholder

Process called "new_library_with_data" that takes device as MTLDevice, data as List[Integer] returns Integer:
    Note: Creates library from data
    Placeholder

Process called "supports_dynamic_libraries" that takes device as MTLDevice returns Boolean:
    Note: Checks dynamic library support
    Placeholder