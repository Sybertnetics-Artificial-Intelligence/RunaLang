Note: sys/os/platform/linux.runa
Note: Linux-Specific Operations - Pure Linux platform functionality
Note: 
Note: This module provides ONLY operations that are unique to Linux and cannot
Note: be implemented cross-platform. All generic operations are delegated to
Note: appropriate domain modules.

Import "dev/debug/errors/core" as Errors
Import "sys/os/platform/detection" as PlatformDetect
Import "sys/os/core/process" as Process
Import "data/collections/core/map" as MapOps
Import "data/collections/core/list" as ListOps
Import "text/string/core" as StringCore

Note: =====================================================================
Note: PROC FILESYSTEM OPERATIONS (/proc - Linux virtual filesystem)
Note: =====================================================================

Process called "read_proc_file" that takes proc_path as String returns String:
    Note: Read content from /proc filesystem using Linux system calls
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Proc filesystem operations only available on Linux"
    
    If proc_path is null or proc_path equals "":
        Throw Errors.InvalidArgumentError with "Invalid proc path"
    
    External "linux_read_proc_file" that takes path as String returns String
    Return linux_read_proc_file(proc_path)

Process called "get_process_proc_info" that takes pid as Integer returns Dictionary[String, String]:
    Note: Get process information from /proc/[pid]/ directory
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Process proc info operations only available on Linux"
    
    If pid <= 0:
        Throw Errors.InvalidArgumentError with "Invalid process ID"
    
    External "linux_get_proc_process_info" that takes process_id as Integer returns Dictionary[String, String]
    Return linux_get_proc_process_info(pid)

Process called "get_proc_meminfo" that takes nothing returns Dictionary[String, Integer]:
    Note: Get system memory information from /proc/meminfo
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Proc meminfo operations only available on Linux"
    
    External "linux_read_proc_meminfo" that takes nothing returns Dictionary[String, Integer]
    Return linux_read_proc_meminfo()

Process called "get_proc_cpuinfo" that takes nothing returns List[Dictionary[String, String]]:
    Note: Get CPU information from /proc/cpuinfo
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Proc cpuinfo operations only available on Linux"
    
    External "linux_read_proc_cpuinfo" that takes nothing returns List[Dictionary[String, String]]
    Return linux_read_proc_cpuinfo()

Process called "get_proc_loadavg" that takes nothing returns Dictionary[String, Float]:
    Note: Get system load average from /proc/loadavg
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Proc loadavg operations only available on Linux"
    
    External "linux_read_proc_loadavg" that takes nothing returns Dictionary[String, Float]
    Return linux_read_proc_loadavg()

Process called "get_proc_version" that takes nothing returns String:
    Note: Get kernel version from /proc/version
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Proc version operations only available on Linux"
    
    External "linux_read_proc_version" that takes nothing returns String
    Return linux_read_proc_version()

Process called "get_process_memory_maps" that takes pid as Integer returns List[Dictionary[String, String]]:
    Note: Get process memory maps from /proc/[pid]/maps
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Process memory map operations only available on Linux"
    
    If pid <= 0:
        Throw Errors.InvalidArgumentError with "Invalid process ID"
    
    External "linux_read_proc_maps" that takes process_id as Integer returns List[Dictionary[String, String]]
    Return linux_read_proc_maps(pid)

Note: =====================================================================
Note: SYSTEMD OPERATIONS (Linux init system)
Note: =====================================================================

Type called "SystemdService":
    name as String
    load_state as String
    active_state as String
    sub_state as String
    description as String
    main_pid as Integer

Process called "systemctl_status" that takes service_name as String returns SystemdService:
    Note: Get systemd service status using systemctl
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Systemd operations only available on Linux"
    
    If service_name is null or service_name equals "":
        Throw Errors.InvalidArgumentError with "Invalid service name"
    
    External "linux_systemctl_status" that takes svc_name as String returns SystemdService
    Return linux_systemctl_status(service_name)

Process called "systemctl_start" that takes service_name as String returns Nothing:
    Note: Start systemd service using systemctl
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Systemd operations only available on Linux"
    
    If service_name is null or service_name equals "":
        Throw Errors.InvalidArgumentError with "Invalid service name"
    
    External "linux_systemctl_start" that takes svc_name as String returns Boolean
    Let success be linux_systemctl_start(service_name)
    
    If not success:
        Throw Errors.OperationError with "Failed to start systemd service"

Process called "systemctl_stop" that takes service_name as String returns Nothing:
    Note: Stop systemd service using systemctl
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Systemd operations only available on Linux"
    
    If service_name is null or service_name equals "":
        Throw Errors.InvalidArgumentError with "Invalid service name"
    
    External "linux_systemctl_stop" that takes svc_name as String returns Boolean
    Let success be linux_systemctl_stop(service_name)
    
    If not success:
        Throw Errors.OperationError with "Failed to stop systemd service"

Process called "systemctl_enable" that takes service_name as String returns Nothing:
    Note: Enable systemd service for automatic startup
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Systemd operations only available on Linux"
    
    If service_name is null or service_name equals "":
        Throw Errors.InvalidArgumentError with "Invalid service name"
    
    External "linux_systemctl_enable" that takes svc_name as String returns Boolean
    Let success be linux_systemctl_enable(service_name)
    
    If not success:
        Throw Errors.OperationError with "Failed to enable systemd service"

Process called "systemctl_disable" that takes service_name as String returns Nothing:
    Note: Disable systemd service from automatic startup
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Systemd operations only available on Linux"
    
    If service_name is null or service_name equals "":
        Throw Errors.InvalidArgumentError with "Invalid service name"
    
    External "linux_systemctl_disable" that takes svc_name as String returns Boolean
    Let success be linux_systemctl_disable(service_name)
    
    If not success:
        Throw Errors.OperationError with "Failed to disable systemd service"

Process called "systemctl_restart" that takes service_name as String returns Nothing:
    Note: Restart systemd service using systemctl
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Systemd operations only available on Linux"
    
    If service_name is null or service_name equals "":
        Throw Errors.InvalidArgumentError with "Invalid service name"
    
    External "linux_systemctl_restart" that takes svc_name as String returns Boolean
    Let success be linux_systemctl_restart(service_name)
    
    If not success:
        Throw Errors.OperationError with "Failed to restart systemd service"

Process called "systemctl_reload" that takes service_name as String returns Nothing:
    Note: Reload systemd service configuration
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Systemd operations only available on Linux"
    
    If service_name is null or service_name equals "":
        Throw Errors.InvalidArgumentError with "Invalid service name"
    
    External "linux_systemctl_reload" that takes svc_name as String returns Boolean
    Let success be linux_systemctl_reload(service_name)
    
    If not success:
        Throw Errors.OperationError with "Failed to reload systemd service"

Process called "list_systemd_services" that takes nothing returns List[SystemdService]:
    Note: List all systemd services using systemctl
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Systemd operations only available on Linux"
    
    External "linux_systemctl_list_units" that takes nothing returns List[SystemdService]
    Return linux_systemctl_list_units()

Note: =====================================================================
Note: LINUX SIGNAL HANDLING (Linux process signals)
Note: =====================================================================

Process called "send_signal" that takes pid as Integer, signal as Integer returns Nothing:
    Note: Send signal to Linux process using kill() system call
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Signal operations only available on Linux"
    
    If pid <= 0:
        Throw Errors.InvalidArgumentError with "Invalid process ID"
    
    If signal < 1 or signal > 64:
        Throw Errors.InvalidArgumentError with "Invalid signal number"
    
    External "linux_kill_process" that takes process_id as Integer, sig as Integer returns Boolean
    Let success be linux_kill_process(pid, signal)
    
    If not success:
        Throw Errors.OperationError with "Failed to send signal to process"

Process called "send_signal_by_name" that takes pid as Integer, signal_name as String returns Nothing:
    Note: Send signal to Linux process by signal name (e.g., "SIGTERM", "SIGKILL")
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Signal operations only available on Linux"
    
    If pid <= 0:
        Throw Errors.InvalidArgumentError with "Invalid process ID"
    
    If signal_name is null or signal_name equals "":
        Throw Errors.InvalidArgumentError with "Invalid signal name"
    
    External "linux_kill_process_by_name" that takes process_id as Integer, sig_name as String returns Boolean
    Let success be linux_kill_process_by_name(pid, signal_name)
    
    If not success:
        Throw Errors.OperationError with "Failed to send signal to process"

Note: =====================================================================
Note: LINUX KERNEL MODULE OPERATIONS
Note: =====================================================================

Type called "LinuxKernelModule":
    name as String
    size as Integer
    used_count as Integer
    status as String
    depends_on as List[String]

Process called "list_kernel_modules" that takes nothing returns List[LinuxKernelModule]:
    Note: List loaded kernel modules from /proc/modules
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Kernel module operations only available on Linux"
    
    External "linux_list_kernel_modules" that takes nothing returns List[LinuxKernelModule]
    Return linux_list_kernel_modules()

Process called "load_kernel_module" that takes module_name as String, parameters as String returns Nothing:
    Note: Load kernel module using insmod or modprobe
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Kernel module operations only available on Linux"
    
    If module_name is null or module_name equals "":
        Throw Errors.InvalidArgumentError with "Invalid module name"
    
    If parameters is null:
        Let parameters be ""
    
    External "linux_load_kernel_module" that takes name as String, params as String returns Boolean
    Let success be linux_load_kernel_module(module_name, parameters)
    
    If not success:
        Throw Errors.OperationError with "Failed to load kernel module"

Process called "unload_kernel_module" that takes module_name as String returns Nothing:
    Note: Unload kernel module using rmmod or modprobe -r
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Kernel module operations only available on Linux"
    
    If module_name is null or module_name equals "":
        Throw Errors.InvalidArgumentError with "Invalid module name"
    
    External "linux_unload_kernel_module" that takes name as String returns Boolean
    Let success be linux_unload_kernel_module(module_name)
    
    If not success:
        Throw Errors.OperationError with "Failed to unload kernel module"

Process called "get_module_info" that takes module_name as String returns Dictionary[String, String]:
    Note: Get information about specific kernel module using modinfo
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Kernel module operations only available on Linux"
    
    If module_name is null or module_name equals "":
        Throw Errors.InvalidArgumentError with "Invalid module name"
    
    External "linux_get_module_info" that takes name as String returns Dictionary[String, String]
    Return linux_get_module_info(module_name)

Note: =====================================================================
Note: LINUX MOUNT OPERATIONS (/proc/mounts and mount system)
Note: =====================================================================

Type called "LinuxMountPoint":
    device as String
    mount_point as String
    filesystem_type as String
    mount_options as List[String]
    dump_frequency as Integer
    fsck_pass as Integer

Process called "get_mount_points" that takes nothing returns List[LinuxMountPoint]:
    Note: Get filesystem mount points from /proc/mounts
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Mount operations only available on Linux"
    
    External "linux_read_proc_mounts" that takes nothing returns List[LinuxMountPoint]
    Return linux_read_proc_mounts()

Process called "mount_filesystem" that takes device as String, mount_point as String, fs_type as String, options as String returns Nothing:
    Note: Mount filesystem using mount() system call
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Mount operations only available on Linux"
    
    If device is null or device equals "" or mount_point is null or mount_point equals "":
        Throw Errors.InvalidArgumentError with "Invalid mount parameters"
    
    If fs_type is null:
        Let fs_type be "auto"
    
    If options is null:
        Let options be ""
    
    External "linux_mount_filesystem" that takes dev as String, point as String, type as String, opts as String returns Boolean
    Let success be linux_mount_filesystem(device, mount_point, fs_type, options)
    
    If not success:
        Throw Errors.OperationError with "Failed to mount filesystem"

Process called "unmount_filesystem" that takes mount_point as String returns Nothing:
    Note: Unmount filesystem using umount() system call
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Mount operations only available on Linux"
    
    If mount_point is null or mount_point equals "":
        Throw Errors.InvalidArgumentError with "Invalid mount point"
    
    External "linux_unmount_filesystem" that takes point as String returns Boolean
    Let success be linux_unmount_filesystem(mount_point)
    
    If not success:
        Throw Errors.OperationError with "Failed to unmount filesystem"

Note: =====================================================================
Note: LINUX SYSFS OPERATIONS (/sys filesystem)
Note: =====================================================================

Process called "read_sysfs_file" that takes sysfs_path as String returns String:
    Note: Read content from /sys filesystem
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Sysfs operations only available on Linux"
    
    If sysfs_path is null or sysfs_path equals "":
        Throw Errors.InvalidArgumentError with "Invalid sysfs path"
    
    External "linux_read_sysfs_file" that takes path as String returns String
    Return linux_read_sysfs_file(sysfs_path)

Process called "write_sysfs_file" that takes sysfs_path as String, value as String returns Nothing:
    Note: Write content to /sys filesystem
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Sysfs operations only available on Linux"
    
    If sysfs_path is null or sysfs_path equals "" or value is null:
        Throw Errors.InvalidArgumentError with "Invalid sysfs parameters"
    
    External "linux_write_sysfs_file" that takes path as String, val as String returns Boolean
    Let success be linux_write_sysfs_file(sysfs_path, value)
    
    If not success:
        Throw Errors.OperationError with "Failed to write to sysfs"

Note: =====================================================================
Note: LINUX CGROUPS OPERATIONS (Control Groups)
Note: =====================================================================

Type called "LinuxCgroup":
    name as String
    controller as String
    path as String
    processes as List[Integer]

Process called "get_process_cgroups" that takes pid as Integer returns List[String]:
    Note: Get cgroups for process from /proc/[pid]/cgroup
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Cgroups operations only available on Linux"
    
    If pid <= 0:
        Throw Errors.InvalidArgumentError with "Invalid process ID"
    
    External "linux_get_process_cgroups" that takes process_id as Integer returns List[String]
    Return linux_get_process_cgroups(pid)

Process called "set_cgroup_limit" that takes cgroup_path as String, resource as String, limit as String returns Nothing:
    Note: Set resource limit for cgroup
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Cgroups operations only available on Linux"
    
    If cgroup_path is null or cgroup_path equals "" or resource is null or resource equals "":
        Throw Errors.InvalidArgumentError with "Invalid cgroup parameters"
    
    If limit is null:
        Let limit be "max"
    
    External "linux_set_cgroup_limit" that takes path as String, res as String, lmt as String returns Boolean
    Let success be linux_set_cgroup_limit(cgroup_path, resource, limit)
    
    If not success:
        Throw Errors.OperationError with "Failed to set cgroup limit"

Note: =====================================================================
Note: LINUX NAMESPACE OPERATIONS
Note: =====================================================================

Process called "get_process_namespaces" that takes pid as Integer returns Dictionary[String, String]:
    Note: Get namespaces for process from /proc/[pid]/ns/
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Namespace operations only available on Linux"
    
    If pid <= 0:
        Throw Errors.InvalidArgumentError with "Invalid process ID"
    
    External "linux_get_process_namespaces" that takes process_id as Integer returns Dictionary[String, String]
    Return linux_get_process_namespaces(pid)

Process called "unshare_namespace" that takes namespace_type as String returns Nothing:
    Note: Unshare namespace using unshare() system call
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Namespace operations only available on Linux"
    
    If namespace_type is null or namespace_type equals "":
        Throw Errors.InvalidArgumentError with "Invalid namespace type"
    
    External "linux_unshare_namespace" that takes ns_type as String returns Boolean
    Let success be linux_unshare_namespace(namespace_type)
    
    If not success:
        Throw Errors.OperationError with "Failed to unshare namespace"

Note: =====================================================================
Note: LINUX NETWORK NAMESPACE OPERATIONS
Note: =====================================================================

Process called "get_network_interfaces_proc" that takes nothing returns List[Dictionary[String, String]]:
    Note: Get network interfaces from /proc/net/dev
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Network interface operations only available on Linux"
    
    External "linux_read_proc_net_dev" that takes nothing returns List[Dictionary[String, String]]
    Return linux_read_proc_net_dev()

Process called "get_network_connections_proc" that takes protocol as String returns List[Dictionary[String, String]]:
    Note: Get network connections from /proc/net/tcp, /proc/net/udp, etc.
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Network connection operations only available on Linux"
    
    If protocol is null or protocol equals "":
        Let protocol be "tcp"
    
    External "linux_read_proc_net_connections" that takes proto as String returns List[Dictionary[String, String]]
    Return linux_read_proc_net_connections(protocol)

Note: =====================================================================
Note: LINUX INOTIFY OPERATIONS (File system event monitoring)
Note: =====================================================================

Type called "InotifyWatch":
    watch_descriptor as Integer
    path as String
    mask as Integer

Process called "inotify_add_watch" that takes path as String, mask as Integer returns InotifyWatch:
    Note: Add inotify watch using inotify_add_watch() system call
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Inotify operations only available on Linux"
    
    If path is null or path equals "":
        Throw Errors.InvalidArgumentError with "Invalid watch path"
    
    If mask <= 0:
        Throw Errors.InvalidArgumentError with "Invalid watch mask"
    
    External "linux_inotify_add_watch" that takes watch_path as String, event_mask as Integer returns InotifyWatch
    Return linux_inotify_add_watch(path, mask)

Process called "inotify_remove_watch" that takes watch as InotifyWatch returns Nothing:
    Note: Remove inotify watch using inotify_rm_watch() system call
    
    If not PlatformDetect.is_linux():
        Throw Errors.PlatformError with "Inotify operations only available on Linux"
    
    External "linux_inotify_remove_watch" that takes iwatch as InotifyWatch returns Boolean
    Let success be linux_inotify_remove_watch(watch)
    
    If not success:
        Throw Errors.OperationError with "Failed to remove inotify watch"

Note: =====================================================================
Note: INITIALIZATION
Note: =====================================================================

Process called "initialize_linux_platform" that takes nothing returns Nothing:
    Note: Initialize Linux platform operations
    
    If not PlatformDetect.is_linux():
        Note: Linux operations not available on this platform
        Return
    
    Note: Test basic Linux functionality
    Let kernel_version be get_proc_version()
    
    If kernel_version is null or kernel_version equals "":
        Throw Errors.SystemError with "Could not access Linux proc filesystem"
    
    Note: Linux platform operations initialized successfully