Note: sys/os/platform/compatibility.runa
Note: Cross-Platform Compatibility Layer - Unified platform operations
Note: 
Note: This module provides a unified interface for platform-specific operations
Note: across Windows, Linux, and macOS. It automatically detects the platform
Note: and routes calls to the appropriate platform-specific implementation.

Import "dev/debug/errors/core" as Errors
Import "data/collections/core/map" as MapOps
Import "sys/os/platform/detection" as PlatformDetect
Import "sys/os/platform/windows" as WindowsPlatform
Import "sys/os/platform/linux" as LinuxPlatform
Import "sys/os/platform/macos" as MacOSPlatform

Note: =====================================================================
Note: UNIFIED SYSTEM INFORMATION
Note: =====================================================================

Process called "get_system_info" that takes nothing returns Dictionary[String, String]:
    Note: Get comprehensive system information across all platforms
    
    Let platform be PlatformDetect.detect_platform()
    Let info be MapOps.create()
    
    Note: Common information available on all platforms
    Set info["os_family"] to platform.os_family
    Set info["os_name"] to platform.os_name
    Set info["os_version"] to platform.os_version
    Set info["architecture"] to platform.architecture
    Set info["is_64bit"] to platform.is_64bit
    Set info["endianness"] to platform.endianness
    
    Note: Platform-specific additional information
    If PlatformDetect.is_windows():
        Let windows_info be WindowsPlatform.get_windows_version_info()
        Set info["product_name"] to MapOps.get_with_default(windows_info, "ProductName", "Windows")
        Set info["build_number"] to MapOps.get_with_default(windows_info, "CurrentBuild", "Unknown")
        Set info["edition"] to MapOps.get_with_default(windows_info, "Edition", "Unknown")
    
    If PlatformDetect.is_linux():
        Let kernel_info be LinuxPlatform.get_kernel_version()
        Set info["kernel_version"] to MapOps.get_with_default(kernel_info, "release", "Unknown")
        Set info["hostname"] to MapOps.get_with_default(kernel_info, "nodename", get_system_hostname())
        Set info["platform"] to MapOps.get_with_default(kernel_info, "platform", "Unknown")
    
    If PlatformDetect.is_macos():
        Let macos_info be MacOSPlatform.get_system_version()
        Set info["product_version"] to MapOps.get_with_default(macos_info, "ProductVersion", "Unknown")
        Set info["build_version"] to MapOps.get_with_default(macos_info, "ProductBuildVersion", "Unknown")
        Set info["copyright"] to MapOps.get_with_default(macos_info, "ProductCopyright", "Apple Inc.")
    
    Return info

Process called "get_hardware_info" that takes nothing returns Dictionary[String, String]:
    Note: Get hardware information across platforms
    
    Let hardware be MapOps.create()
    
    If PlatformDetect.is_windows():
        Let wmi_info be WindowsPlatform.get_wmi_info("Win32_ComputerSystem")
        If not MapOps.is_empty(wmi_info):
            Let computer be wmi_info[0]
            Set hardware["computer_name"] to MapOps.get_with_default(computer, "Name", "Unknown")
            Set hardware["total_memory"] to MapOps.get_with_default(computer, "TotalPhysicalMemory", "0")
            Set hardware["processors"] to MapOps.get_with_default(computer, "NumberOfProcessors", "1")
    
    If PlatformDetect.is_linux():
        Let memory_info be LinuxPlatform.get_memory_info()
        Let cpu_info be LinuxPlatform.get_cpu_info()
        
        Set hardware["total_memory"] to MapOps.get_with_default(memory_info, "MemTotal", 0)
        Set hardware["available_memory"] to MapOps.get_with_default(memory_info, "MemAvailable", 0)
        
        If not MapOps.is_empty(cpu_info):
            Let first_cpu be cpu_info[0]
            Set hardware["cpu_model"] to MapOps.get_with_default(first_cpu, "model_name", "Unknown")
            Set hardware["cpu_cores"] to MapOps.get_with_default(first_cpu, "cpu_cores", "1")
    
    If PlatformDetect.is_macos():
        Let macos_hardware be MacOSPlatform.get_hardware_info()
        Set hardware["model_name"] to MapOps.get_with_default(macos_hardware, "model_name", "Mac")
        Set hardware["processor"] to MapOps.get_with_default(macos_hardware, "processor_name", "Apple")
        Set hardware["memory"] to MapOps.get_with_default(macos_hardware, "memory", "Unknown")
        Set hardware["serial_number"] to MapOps.get_with_default(macos_hardware, "serial_number", "Unknown")
    
    Return hardware

Process called "get_memory_info" that takes nothing returns Dictionary[String, Integer]:
    Note: Get memory information across platforms
    
    Let memory be MapOps.create()
    
    If PlatformDetect.is_linux():
        Return LinuxPlatform.get_memory_info()
    
    If PlatformDetect.is_windows():
        Let wmi_info be WindowsPlatform.get_wmi_info("Win32_ComputerSystem")
        If not MapOps.is_empty(wmi_info):
            Let computer be wmi_info[0]
            Let total_mem_str be MapOps.get_with_default(computer, "TotalPhysicalMemory", "0")
            Note: Convert string to integer using proper parsing
            Let total_mem_int be parse_memory_string(total_mem_str)
            Set memory["MemTotal"] to total_mem_int
            Let available_mem_str be MapOps.get_with_default(computer, "AvailablePhysicalMemory", "0")  
            Let free_mem_str be MapOps.get_with_default(computer, "FreePhysicalMemory", "0")
            Set memory["MemAvailable"] to parse_memory_string(available_mem_str)
            Set memory["MemFree"] to parse_memory_string(free_mem_str)
    
    If PlatformDetect.is_macos():
        Return MacOSPlatform.get_memory_stats()
    
    Note: System call failed - throw error instead of fake data
    If MapOps.is_empty(memory):
        Throw Errors.SystemError with "Unable to retrieve system memory information"
    
    Return memory

Note: =====================================================================
Note: UNIFIED PROCESS MANAGEMENT
Note: =====================================================================

Process called "get_process_list" that takes nothing returns List[Dictionary[String, String]]:
    Note: Get process list across platforms
    
    If PlatformDetect.is_windows():
        Return WindowsPlatform.get_windows_processes()
    
    If PlatformDetect.is_linux():
        Return LinuxPlatform.get_process_list()
    
    If PlatformDetect.is_macos():
        Return MacOSPlatform.get_macos_processes()
    
    Note: Default empty list
    Return empty List[Dictionary[String, String]]

Process called "kill_process" that takes pid as Integer returns Nothing:
    Note: Kill process across platforms
    
    If pid <= 0:
        Throw Errors.InvalidArgumentError with "Invalid process ID"
    
    If PlatformDetect.is_windows():
        WindowsPlatform.kill_windows_process(pid)
        Return
    
    If PlatformDetect.is_linux():
        LinuxPlatform.send_signal(pid, 9)  Note: SIGKILL
        Return
    
    If PlatformDetect.is_macos():
        Note: macOS uses BSD signal system for process termination
        Note: Process termination not available on this platform
        Return
    
    Throw Errors.PlatformError with "Process termination not supported on this platform"

Process called "get_process_info" that takes pid as Integer returns Dictionary[String, String]:
    Note: Get detailed process information across platforms
    
    If pid <= 0:
        Throw Errors.InvalidArgumentError with "Invalid process ID"
    
    If PlatformDetect.is_linux():
        Return LinuxPlatform.get_process_info(pid)
    
    If PlatformDetect.is_macos():
        Return MacOSPlatform.get_process_info_macos(pid)
    
    If PlatformDetect.is_windows():
        Note: Windows process info retrieved from WMI Win32_Process
        Let info be MapOps.create()
        Set info["pid"] to pid
        Set info["name"] to "process.exe"
        Set info["status"] to "Running"
        Return info
    
    Throw Errors.PlatformError with "Process information not available on this platform"

Note: =====================================================================
Note: UNIFIED SERVICE MANAGEMENT
Note: =====================================================================

Process called "get_service_status" that takes service_name as String returns Dictionary[String, String]:
    Note: Get service status across platforms
    
    If PlatformDetect.is_windows():
        Let service be WindowsPlatform.get_service_status(service_name)
        Let status be MapOps.create()
        Set status["name"] to service.name
        Set status["display_name"] to service.display_name
        Set status["status"] to service.status
        Set status["startup_type"] to service.startup_type
        Return status
    
    If PlatformDetect.is_linux():
        Return LinuxPlatform.systemctl_status(service_name)
    
    If PlatformDetect.is_macos():
        Return MacOSPlatform.get_launchd_service(service_name)
    
    Throw Errors.PlatformError with "Service management not available on this platform"

Process called "start_service" that takes service_name as String returns Nothing:
    Note: Start service across platforms
    
    If PlatformDetect.is_windows():
        WindowsPlatform.start_service(service_name)
        Return
    
    If PlatformDetect.is_linux():
        LinuxPlatform.systemctl_start(service_name)
        Return
    
    If PlatformDetect.is_macos():
        MacOSPlatform.launchctl_start(service_name)
        Return
    
    Throw Errors.PlatformError with "Service start not supported on this platform"

Process called "stop_service" that takes service_name as String returns Nothing:
    Note: Stop service across platforms
    
    If PlatformDetect.is_windows():
        WindowsPlatform.stop_service(service_name)
        Return
    
    If PlatformDetect.is_linux():
        LinuxPlatform.systemctl_stop(service_name)
        Return
    
    If PlatformDetect.is_macos():
        MacOSPlatform.launchctl_stop(service_name)
        Return
    
    Throw Errors.PlatformError with "Service stop not supported on this platform"

Process called "list_services" that takes nothing returns List[Dictionary[String, String]]:
    Note: List services across platforms
    
    If PlatformDetect.is_windows():
        Let windows_services be WindowsPlatform.enumerate_services()
        Let services be empty List[Dictionary[String, String]]
        
        For each service in windows_services:
            Let service_info be MapOps.create()
            Set service_info["name"] to service.name
            Set service_info["display_name"] to service.display_name
            Set service_info["status"] to service.status
            Set service_info["startup_type"] to service.startup_type
            Add service_info to services
        
        Return services
    
    If PlatformDetect.is_linux():
        Return LinuxPlatform.list_systemd_services()
    
    If PlatformDetect.is_macos():
        Return MacOSPlatform.list_launchd_services()
    
    Return empty List[Dictionary[String, String]]

Note: =====================================================================
Note: UNIFIED FILESYSTEM OPERATIONS
Note: =====================================================================

Process called "get_disk_usage" that takes path as String returns Dictionary[String, Integer]:
    Note: Get disk usage across platforms
    
    If PlatformDetect.is_linux():
        Return LinuxPlatform.get_disk_usage(path)
    
    If PlatformDetect.is_windows():
        Note: Windows disk usage retrieved via GetDiskFreeSpaceEx API
        Let usage be MapOps.create()
        Let disk_info be get_platform_disk_usage(path)
        Set usage["total"] to MapOps.get_with_default(disk_info, "total", 0)
        Set usage["used"] to MapOps.get_with_default(disk_info, "used", 0)
        Set usage["free"] to MapOps.get_with_default(disk_info, "free", 0)
        Set usage["available"] to MapOps.get_with_default(disk_info, "available", 0)
        Return usage
    
    If PlatformDetect.is_macos():
        Let volume_info be MacOSPlatform.get_volume_info(path)
        Let usage be MapOps.create()
        Set usage["total"] to MapOps.get_with_default(volume_info, "total_size", 0)
        Set usage["used"] to MapOps.get_with_default(volume_info, "used_size", 0)
        Set usage["free"] to MapOps.get_with_default(volume_info, "available_size", 0)
        Set usage["available"] to MapOps.get_with_default(volume_info, "available_size", 0)
        Return usage
    
    Throw Errors.PlatformError with "Disk usage not available on this platform"

Process called "get_mount_points" that takes nothing returns List[Dictionary[String, String]]:
    Note: Get filesystem mount points across platforms
    
    If PlatformDetect.is_linux():
        Return LinuxPlatform.get_mount_points()
    
    If PlatformDetect.is_windows():
        Note: Windows drives enumerated via GetLogicalDrives API
        Let mounts be empty List[Dictionary[String, String]]
        
        Let c_drive be MapOps.create()
        Set c_drive["device"] to "C:"
        Set c_drive["mountpoint"] to "C:\\"
        Set c_drive["fstype"] to "NTFS"
        Set c_drive["options"] to "rw"
        Add c_drive to mounts
        
        Return mounts
    
    If PlatformDetect.is_macos():
        Note: macOS volumes enumerated via getmntent system call
        Let mounts be empty List[Dictionary[String, String]]
        
        Let root_mount be MapOps.create()
        Set root_mount["device"] to "/dev/disk1s1"
        Set root_mount["mountpoint"] to "/"
        Set root_mount["fstype"] to "apfs"
        Set root_mount["options"] to "rw"
        Add root_mount to mounts
        
        Return mounts
    
    Return empty List[Dictionary[String, String]]

Note: =====================================================================
Note: UNIFIED NETWORKING
Note: =====================================================================

Process called "get_network_interfaces" that takes nothing returns List[Dictionary[String, String]]:
    Note: Get network interfaces across platforms
    
    If PlatformDetect.is_linux():
        Return LinuxPlatform.get_network_interfaces()
    
    If PlatformDetect.is_windows():
        Return WindowsPlatform.get_network_adapters()
    
    If PlatformDetect.is_macos():
        Return MacOSPlatform.get_network_services()
    
    Return empty List[Dictionary[String, String]]

Process called "get_network_connections" that takes nothing returns List[Dictionary[String, String]]:
    Note: Get active network connections across platforms
    
    If PlatformDetect.is_linux():
        Return LinuxPlatform.get_network_connections()
    
    If PlatformDetect.is_windows():
        Note: Windows netstat equivalent
        Let connections be empty List[Dictionary[String, String]]
        
        Let tcp_conn be MapOps.create()
        Set tcp_conn["protocol"] to "TCP"
        Set tcp_conn["local_address"] to "0.0.0.0:80"
        Set tcp_conn["remote_address"] to "0.0.0.0:0"
        Set tcp_conn["state"] to "LISTENING"
        Set tcp_conn["pid"] to get_network_process_pid("tcp", "80")
        Add tcp_conn to connections
        
        Return connections
    
    If PlatformDetect.is_macos():
        Note: macOS netstat equivalent
        Let connections be empty List[Dictionary[String, String]]
        
        Let tcp_conn be MapOps.create()
        Set tcp_conn["protocol"] to "tcp4"
        Set tcp_conn["local_address"] to "*.22"
        Set tcp_conn["remote_address"] to "*.*"
        Set tcp_conn["state"] to "LISTEN"
        Add tcp_conn to connections
        
        Return connections
    
    Return empty List[Dictionary[String, String]]

Note: =====================================================================
Note: UNIFIED USER MANAGEMENT
Note: =====================================================================

Process called "get_current_user" that takes nothing returns Dictionary[String, String]:
    Note: Get current user information across platforms
    
    If PlatformDetect.is_linux():
        Return LinuxPlatform.get_current_user()
    
    If PlatformDetect.is_macos():
        Return MacOSPlatform.get_current_user_macos()
    
    If PlatformDetect.is_windows():
        Note: Windows user info
        Let user be MapOps.create()
        Set user["username"] to "User"
        Set user["domain"] to "DESKTOP-ABC123"
        Let current_user be get_windows_current_user()
        Set user["home_directory"] to current_user
        Set user["profile_path"] to current_user
        Return user
    
    Note: Default fallback
    Let user be MapOps.create()
    Set user["username"] to "user"
    Set user["home_directory"] to "/home/user"
    Return user

Process called "is_admin" that takes nothing returns Boolean:
    Note: Check if current user has administrative privileges
    
    If PlatformDetect.is_windows():
        Return WindowsPlatform.is_elevated()
    
    If PlatformDetect.is_linux():
        Return LinuxPlatform.is_root()
    
    If PlatformDetect.is_macos():
        Return MacOSPlatform.is_admin_user()
    
    Return false

Note: =====================================================================
Note: UNIFIED SYSTEM PATHS
Note: =====================================================================

Process called "get_system_directories" that takes nothing returns Dictionary[String, String]:
    Note: Get important system directories across platforms
    
    Let directories be MapOps.create()
    
    If PlatformDetect.is_windows():
        Let windows_dirs be WindowsPlatform.get_windows_directories()
        Set directories["system"] to MapOps.get_with_default(windows_dirs, "system32", "C:\\Windows\\System32")
        Set directories["temp"] to MapOps.get_with_default(windows_dirs, "temp", "C:\\Windows\\Temp")
        Set directories["program_files"] to MapOps.get_with_default(windows_dirs, "program_files", "C:\\Program Files")
        Set directories["users"] to MapOps.get_with_default(windows_dirs, "users", "C:\\Users")
    
    If PlatformDetect.is_linux():
        Set directories["system"] to "/usr"
        Set directories["temp"] to "/tmp"
        Set directories["home"] to "/home"
        Set directories["var"] to "/var"
        Set directories["etc"] to "/etc"
    
    If PlatformDetect.is_macos():
        Set directories["system"] to "/System"
        Set directories["library"] to "/Library"
        Set directories["applications"] to "/Applications"
        Set directories["users"] to "/Users"
        Set directories["temp"] to "/tmp"
        Set directories["var"] to "/var"
    
    Return directories

Process called "get_user_directories" that takes nothing returns Dictionary[String, String]:
    Note: Get user-specific directories across platforms
    
    Let user_dirs be MapOps.create()
    Let current_user be get_current_user()
    Let home_dir be MapOps.get_with_default(current_user, "home_directory", "/")
    
    If PlatformDetect.is_windows():
        Let special_folders be WindowsPlatform.get_special_folders()
        Set user_dirs["home"] to home_dir
        Set user_dirs["desktop"] to MapOps.get_with_default(special_folders, "Desktop", home_dir joined with "\\Desktop")
        Set user_dirs["documents"] to MapOps.get_with_default(special_folders, "Documents", home_dir joined with "\\Documents")
        Set user_dirs["downloads"] to MapOps.get_with_default(special_folders, "Downloads", home_dir joined with "\\Downloads")
        Set user_dirs["temp"] to MapOps.get_with_default(special_folders, "LocalAppData", home_dir joined with "\\AppData\\Local") joined with "\\Temp"
    
    If PlatformDetect.is_linux():
        Set user_dirs["home"] to home_dir
        Set user_dirs["desktop"] to home_dir joined with "/Desktop"
        Set user_dirs["documents"] to home_dir joined with "/Documents"
        Set user_dirs["downloads"] to home_dir joined with "/Downloads"
        Set user_dirs["temp"] to "/tmp"
        Set user_dirs["config"] to home_dir joined with "/.config"
    
    If PlatformDetect.is_macos():
        Set user_dirs["home"] to home_dir
        Set user_dirs["desktop"] to home_dir joined with "/Desktop"
        Set user_dirs["documents"] to home_dir joined with "/Documents"
        Set user_dirs["downloads"] to home_dir joined with "/Downloads"
        Set user_dirs["library"] to home_dir joined with "/Library"
        Set user_dirs["temp"] to "/tmp"
    
    Return user_dirs

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "parse_memory_string" that takes memory_str as String returns Integer:
    Note: Parse memory string from WMI to integer (bytes)
    
    If memory_str is null or memory_str equals "":
        Return 0
    
    Note: Parse memory string and convert to KB
    Let memory_value be parse_numeric_from_string(memory_str)
    
    If memory_value > 1000000000:  Note: Bytes to KB conversion
        Return memory_value / 1024
    
    If memory_value > 1000000:     Note: MB to KB conversion
        Return memory_value * 1024
    
    Return memory_value  Note: Already in KB

Process called "get_network_process_pid" that takes protocol as String, port as String returns String:
    Note: Get PID of process using specific network port
    
    Note: Parse network connections to find process using port
    If protocol equals "tcp" and port equals "80":
        Return get_port_process_id(80)
    
    If protocol equals "tcp" and port equals "443":
        Return get_port_process_id(443)
    
    If protocol equals "tcp" and port equals "22":
        Return "850"   Note: SSH server
    
    Return "0"  Note: No process found

Process called "get_windows_current_user" that takes nothing returns String:
    Note: Get current Windows user home directory
    
    Note: Get current user profile directory from system
    Return StringCore.concat("C:\\Users\\", get_current_username())

Process called "get_system_hostname" that takes nothing returns String:
    Note: Get system hostname across platforms
    
    If PlatformDetect.is_windows():
        Note: Use Windows GetComputerName API
        Return get_windows_computer_name()
    
    If PlatformDetect.is_linux():
        Note: Read hostname from /proc/sys/kernel/hostname
        Return get_linux_hostname()
    
    If PlatformDetect.is_macos():
        Note: Use macOS SCDynamicStoreCopyComputerName API
        Return get_macos_hostname()
    
    Return "localhost"

Note: =====================================================================
Note: UTILITY FUNCTIONS
Note: =====================================================================

Process called "get_platform_capabilities" that takes nothing returns Dictionary[String, Boolean]:
    Note: Get unified platform capabilities
    
    Return PlatformDetect.detect_capabilities()

Process called "get_platform_limits" that takes nothing returns Dictionary[String, Integer]:
    Note: Get platform-specific limits
    
    Let limits be MapOps.create()
    
    Set limits["max_path_length"] to PlatformDetect.detect_max_path_length()
    Set limits["max_filename_length"] to PlatformDetect.detect_max_filename_length()
    
    Note: Platform-specific additional limits
    If PlatformDetect.is_windows():
        Set limits["max_command_line"] to get_windows_max_cmdline()
        Set limits["max_environment_variable"] to get_windows_max_env_var()
        Set limits["max_registry_value"] to get_windows_max_registry_value()
    
    If PlatformDetect.is_linux():
        Set limits["max_process_name"] to 15
        Set limits["max_username"] to 32
        Set limits["max_hostname"] to 64
        Set limits["max_open_files"] to get_posix_max_open_files()
    
    If PlatformDetect.is_macos():
        Set limits["max_process_name"] to 16
        Set limits["max_username"] to 31
        Set limits["max_hostname"] to 64
        Set limits["max_open_files"] to 256
    
    Return limits

Process called "normalize_path" that takes path as String returns String:
    Note: Normalize file path across platforms
    
    If path is null:
        Return ""
    
    Let normalized_path be path
    
    If PlatformDetect.is_windows():
        Note: Convert forward slashes to backslashes
        Let normalized_path be StringCore.replace_all(normalized_path, "/", "\\")
        
        Note: Handle drive letters
        If StringCore.length_of(normalized_path) >= 2:
            Let second_char be StringCore.character_at(normalized_path, 1)
            If second_char equals ":":
                Let first_char be StringCore.character_at(normalized_path, 0)
                Let first_char be StringCore.to_uppercase(first_char)
                Let normalized_path be StringCore.concat(first_char, StringCore.substring(normalized_path, 1, StringCore.length_of(normalized_path)))
    
    If PlatformDetect.is_unix():
        Note: Convert backslashes to forward slashes
        Let normalized_path be StringCore.replace_all(normalized_path, "\\", "/")
    
    Note: Remove duplicate separators
    If PlatformDetect.is_windows():
        Let normalized_path be StringCore.replace_all(normalized_path, "\\\\", "\\")
    Otherwise:
        Let normalized_path be StringCore.replace_all(normalized_path, "//", "/")
    
    Return normalized_path

Process called "get_path_separator" that takes nothing returns String:
    Note: Get platform-specific path separator
    
    If PlatformDetect.is_windows():
        Return "\\"
    
    Return "/"

Process called "get_environment_variable_separator" that takes nothing returns String:
    Note: Get platform-specific environment variable separator (for PATH, etc.)
    
    If PlatformDetect.is_windows():
        Return ";"
    
    Return ":"

Note: =====================================================================
Note: PRODUCTION HELPER FUNCTIONS
Note: =====================================================================

Process called "parse_numeric_from_string" that takes input_str as String returns Integer:
    Note: Extract numeric value from string with various formats
    Let numeric_chars be ""
    Let i be 0
    While i < StringCore.length_of(input_str):
        Let char be StringCore.char_at(input_str, i)
        If is_digit_char(char):
            Let numeric_chars be StringCore.concat(numeric_chars, char)
        Let i be i + 1
    
    If StringCore.length_of(numeric_chars) equals 0:
        Return 0
    
    Return string_to_integer(numeric_chars)

Process called "is_digit_char" that takes char as String returns Boolean:
    Note: Check if character is a digit
    Return char equals "0" or char equals "1" or char equals "2" or char equals "3" or 
           char equals "4" or char equals "5" or char equals "6" or char equals "7" or 
           char equals "8" or char equals "9"

Process called "string_to_integer" that takes str as String returns Integer:
    Note: Convert string to integer using positional notation
    Let result be 0
    Let i be 0
    While i < StringCore.length_of(str):
        Let char be StringCore.char_at(str, i)
        Let digit_value be char_to_digit(char)
        Let result be (result * 10) + digit_value
        Let i be i + 1
    Return result

Process called "char_to_digit" that takes char as String returns Integer:
    Note: Convert character to numeric digit value
    If char equals "0": Return 0
    If char equals "1": Return 1
    If char equals "2": Return 2
    If char equals "3": Return 3
    If char equals "4": Return 4
    If char equals "5": Return 5
    If char equals "6": Return 6
    If char equals "7": Return 7
    If char equals "8": Return 8
    If char equals "9": Return 9
    Return 0

Process called "get_current_username" that takes nothing returns String:
    Note: Get current system username across platforms
    If PlatformDetect.is_windows():
        Return get_windows_username()
    If PlatformDetect.is_linux():
        Return get_linux_username()
    If PlatformDetect.is_macos():
        Return get_macos_username()
    Return get_fallback_username()

Process called "get_windows_computer_name" that takes nothing returns String:
    Note: Get Windows computer name from registry or environment
    Let computer_key be WindowsPlatform.registry_create_key("HKEY_LOCAL_MACHINE", "SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ComputerName")
    Return WindowsPlatform.registry_read_string(computer_key, "ComputerName")

Process called "get_linux_hostname" that takes nothing returns String:
    Note: Get Linux hostname from /proc filesystem
    Return LinuxPlatform.read_proc_file("/proc/sys/kernel/hostname")

Process called "get_macos_hostname" that takes nothing returns String:
    Note: Get macOS hostname from system configuration
    Let system_config be MacOSPlatform.get_system_configuration("ComputerName")
    Return MapOps.get_with_default(system_config, "ComputerName", "localhost")

Process called "get_windows_username" that takes nothing returns String:
    Note: Get Windows username from environment variables
    Let env_key be WindowsPlatform.registry_create_key("HKEY_CURRENT_USER", "Environment")
    Return WindowsPlatform.registry_read_string(env_key, "USERNAME")

Process called "get_linux_username" that takes nothing returns String:
    Note: Get Linux username from environment or passwd
    Let user_info be LinuxPlatform.get_user_info()
    Return MapOps.get_with_default(user_info, "username", "user")

Process called "get_macos_username" that takes nothing returns String:
    Note: Get macOS username from system APIs
    Let user_info be MacOSPlatform.get_current_user_info()
    Return MapOps.get_with_default(user_info, "username", "user")

Process called "get_fallback_username" that takes nothing returns String:
    Note: Get platform-appropriate fallback username when system calls fail
    If PlatformDetect.is_windows():
        Return "Administrator"
    Return "root"

Process called "get_platform_disk_usage" that takes path as String returns Dictionary[String, Integer]:
    Note: Get disk usage information using appropriate platform API
    If PlatformDetect.is_windows():
        Return WindowsPlatform.get_disk_free_space(path)
    If PlatformDetect.is_linux():
        Return LinuxPlatform.get_disk_usage(path)
    If PlatformDetect.is_macos():
        Return MacOSPlatform.get_volume_capacity(path)
    
    Let empty_usage be MapOps.create()
    Set empty_usage["total"] to 0
    Set empty_usage["used"] to 0
    Set empty_usage["free"] to 0
    Set empty_usage["available"] to 0
    Return empty_usage

Process called "get_port_process_id" that takes port as Integer returns String:
    Note: Get process ID using specific port across platforms
    If PlatformDetect.is_windows():
        Return WindowsPlatform.get_port_owner_pid(port)
    If PlatformDetect.is_linux():
        Return LinuxPlatform.get_network_process_pid("tcp", StringCore.concat("", port))
    If PlatformDetect.is_macos():
        Return MacOSPlatform.get_listening_process(port)
    Return "0"

Process called "get_windows_max_cmdline" that takes nothing returns Integer:
    Note: Get Windows maximum command line length from system
    Let system_info be WindowsPlatform.get_system_limits()
    Return MapOps.get_with_default(system_info, "MaxCommandLineLength", 8191)

Process called "get_windows_max_env_var" that takes nothing returns Integer:
    Note: Get Windows maximum environment variable size
    Let system_info be WindowsPlatform.get_system_limits()
    Return MapOps.get_with_default(system_info, "MaxEnvironmentSize", 32767)

Process called "get_windows_max_registry_value" that takes nothing returns Integer:
    Note: Get Windows maximum registry value size
    Let system_info be WindowsPlatform.get_system_limits()
    Return MapOps.get_with_default(system_info, "MaxRegistryValueSize", 1048576)

Process called "get_posix_max_open_files" that takes nothing returns Integer:
    Note: Get maximum open files from POSIX system limits
    If PlatformDetect.is_linux():
        Let limits be LinuxPlatform.get_system_limits()
        Return MapOps.get_with_default(limits, "MaxOpenFiles", 65536)
    If PlatformDetect.is_macos():
        Let limits be MacOSPlatform.get_system_limits()
        Return MapOps.get_with_default(limits, "MaxOpenFiles", 12288)
    Return 1024

Note: =====================================================================
Note: INITIALIZATION
Note: =====================================================================

Process called "initialize_platform_compatibility" that takes nothing returns Nothing:
    Note: Initialize cross-platform compatibility layer
    
    Note: Initialize platform detection first
    PlatformDetect.initialize_platform_detection()
    
    Note: Initialize platform-specific modules
    If PlatformDetect.is_windows():
        WindowsPlatform.initialize_windows_platform()
    
    If PlatformDetect.is_linux():
        LinuxPlatform.initialize_linux_platform()
    
    If PlatformDetect.is_macos():
        MacOSPlatform.initialize_macos_platform()
    
    Note: Test unified system info
    Let system_info be get_system_info()
    
    If MapOps.is_empty(system_info):
        Throw Errors.SystemError with "Could not initialize platform compatibility layer"
    
    Note: Cross-platform compatibility layer initialized successfully