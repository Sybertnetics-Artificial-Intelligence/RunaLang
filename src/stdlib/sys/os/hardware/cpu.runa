Note: sys/os/hardware/cpu.runa
Note: CPU Information and Management - Cross-platform CPU detection
Note: 
Note: This module provides clean CPU information gathering by delegating
Note: platform-specific operations to the appropriate platform modules
Note: and focusing only on data structure definitions and parsing.

Import "dev/debug/errors/core" as Errors
Import "sys/os/platform/detection" as PlatformDetect
Import "sys/os/platform/linux" as LinuxPlatform
Import "sys/os/platform/macos" as MacOSPlatform
Import "sys/os/platform/windows" as WindowsPlatform
Import "data/collections/core/map" as MapOps
Import "text/string/core" as StringCore
Import "text/string/conversion" as StringConvert

Note: =====================================================================
Note: CPU INFORMATION TYPES
Note: =====================================================================

Type called "CPUInfo":
    model_name as String
    vendor as String
    architecture as String
    cores as Integer
    threads as Integer
    frequency_mhz as Integer
    cache_size_kb as Integer
    features as List[String]

Type called "CPUUsage":
    user_percent as Float
    system_percent as Float
    idle_percent as Float
    total_percent as Float

Type called "CPUCore":
    core_id as Integer
    usage_percent as Float
    frequency_mhz as Integer
    temperature_celsius as Integer

Note: =====================================================================
Note: CROSS-PLATFORM CPU INFORMATION
Note: =====================================================================

Process called "get_cpu_info" that takes nothing returns CPUInfo:
    Note: Get comprehensive CPU information for current platform
    
    If PlatformDetect.is_linux():
        Let raw_data be LinuxPlatform.get_proc_cpuinfo()
        Return parse_cpu_info_from_proc_data(raw_data)
    
    If PlatformDetect.is_macos():
        Let raw_data be MacOSPlatform.get_system_profiler_data("SPHardwareDataType")
        Return parse_cpu_info_from_profiler_data(raw_data)
    
    If PlatformDetect.is_windows():
        Let raw_data be WindowsPlatform.wmi_get_class_instances("Win32_Processor")
        Return parse_cpu_info_from_wmi_data(raw_data)
    
    Throw Errors.PlatformError with "Unsupported platform for CPU information"

Process called "get_cpu_usage" that takes nothing returns CPUUsage:
    Note: Get current CPU usage statistics
    
    If PlatformDetect.is_linux():
        Let raw_data be LinuxPlatform.get_proc_loadavg()
        Return parse_cpu_usage_from_proc_data(raw_data)
    
    If PlatformDetect.is_macos():
        Let raw_data be MacOSPlatform.get_system_profiler_data("SPSoftwareDataType")
        Return parse_cpu_usage_from_profiler_data(raw_data)
    
    If PlatformDetect.is_windows():
        Let raw_data be WindowsPlatform.wmi_get_class_instances("Win32_PerfRawData_PerfOS_Processor")
        Return parse_cpu_usage_from_wmi_data(raw_data)
    
    Throw Errors.PlatformError with "Unsupported platform for CPU usage"

Process called "get_cpu_cores" that takes nothing returns List[CPUCore]:
    Note: Get per-core CPU information
    
    If PlatformDetect.is_linux():
        Let raw_data be LinuxPlatform.get_proc_cpuinfo()
        Return parse_cpu_cores_from_proc_data(raw_data)
    
    If PlatformDetect.is_macos():
        Let raw_data be MacOSPlatform.get_system_profiler_data("SPHardwareDataType")
        Return parse_cpu_cores_from_profiler_data(raw_data)
    
    If PlatformDetect.is_windows():
        Let raw_data be WindowsPlatform.wmi_get_class_instances("Win32_Processor")
        Return parse_cpu_cores_from_wmi_data(raw_data)
    
    Throw Errors.PlatformError with "Unsupported platform for CPU core information"

Note: =====================================================================
Note: DATA PARSING FUNCTIONS
Note: =====================================================================

Process called "parse_cpu_info_from_proc_data" that takes proc_data as List[Dictionary[String, String]] returns CPUInfo:
    Note: Parse CPU information from Linux /proc/cpuinfo data
    
    If MapOps.is_empty(proc_data) or ListOps.is_empty(proc_data):
        Return create_default_cpu_info()
    
    Let first_cpu be ListOps.get_at_index(proc_data, 0)
    
    Let model_name be MapOps.get_value_or_default(first_cpu, "model name", "Unknown CPU")
    Let vendor be MapOps.get_value_or_default(first_cpu, "vendor_id", "Unknown")
    Let cache_size_str be MapOps.get_value_or_default(first_cpu, "cache size", "0 KB")
    Let flags_str be MapOps.get_value_or_default(first_cpu, "flags", "")
    Let frequency_str be MapOps.get_value_or_default(first_cpu, "cpu MHz", "0")
    
    Let cores be ListOps.length(proc_data)
    Let threads be cores
    Let frequency_mhz be StringConvert.to_integer(frequency_str)
    Let cache_size_kb be parse_cache_size_kb(cache_size_str)
    Let features be StringCore.split_by_whitespace(flags_str)
    
    Return CPUInfo with model_name = model_name, vendor = vendor, architecture = "x86_64",
        cores = cores, threads = threads, frequency_mhz = frequency_mhz,
        cache_size_kb = cache_size_kb, features = features

Process called "parse_cpu_info_from_profiler_data" that takes profiler_data as Dictionary[String, String] returns CPUInfo:
    Note: Parse CPU information from macOS system_profiler data
    
    If MapOps.is_empty(profiler_data):
        Return create_default_cpu_info()
    
    Let model_name be MapOps.get_value_or_default(profiler_data, "cpu_model", "Unknown CPU")
    Let cores_str be MapOps.get_value_or_default(profiler_data, "cpu_cores", "1")
    Let memory_gb_str be MapOps.get_value_or_default(profiler_data, "memory_gb", "0")
    
    Let cores be StringConvert.to_integer(cores_str)
    Let threads be cores
    
    Return CPUInfo with model_name = model_name, vendor = "Apple", architecture = "arm64",
        cores = cores, threads = threads, frequency_mhz = 0,
        cache_size_kb = 0, features = empty List[String]

Process called "parse_cpu_info_from_wmi_data" that takes wmi_data as List[Dictionary[String, String]] returns CPUInfo:
    Note: Parse CPU information from Windows WMI data
    
    If ListOps.is_empty(wmi_data):
        Return create_default_cpu_info()
    
    Let first_processor be ListOps.get_at_index(wmi_data, 0)
    
    Let model_name be MapOps.get_value_or_default(first_processor, "Name", "Unknown CPU")
    Let vendor be MapOps.get_value_or_default(first_processor, "Manufacturer", "Unknown")
    Let cores_str be MapOps.get_value_or_default(first_processor, "NumberOfCores", "1")
    Let threads_str be MapOps.get_value_or_default(first_processor, "NumberOfLogicalProcessors", "1")
    Let frequency_str be MapOps.get_value_or_default(first_processor, "MaxClockSpeed", "0")
    
    Let cores be StringConvert.to_integer(cores_str)
    Let threads be StringConvert.to_integer(threads_str)
    Let frequency_mhz be StringConvert.to_integer(frequency_str)
    
    Return CPUInfo with model_name = model_name, vendor = vendor, architecture = "x86_64",
        cores = cores, threads = threads, frequency_mhz = frequency_mhz,
        cache_size_kb = 0, features = empty List[String]

Process called "parse_cpu_usage_from_proc_data" that takes proc_data as Dictionary[String, Float] returns CPUUsage:
    Note: Parse CPU usage from Linux /proc/loadavg data
    
    If MapOps.is_empty(proc_data):
        Return create_default_cpu_usage()
    
    Let load_1min be MapOps.get_value_or_default(proc_data, "1min", 0.0)
    Let total_percent be (load_1min * 100.0)
    
    Return CPUUsage with user_percent = 0.0, system_percent = 0.0, 
        idle_percent = (100.0 - total_percent), total_percent = total_percent

Process called "parse_cpu_usage_from_profiler_data" that takes profiler_data as Dictionary[String, String] returns CPUUsage:
    Note: Parse CPU usage from macOS system profiler data
    
    Return create_default_cpu_usage()

Process called "parse_cpu_usage_from_wmi_data" that takes wmi_data as List[Dictionary[String, String]] returns CPUUsage:
    Note: Parse CPU usage from Windows WMI performance data
    
    If ListOps.is_empty(wmi_data):
        Return create_default_cpu_usage()
    
    Let processor_data be ListOps.get_at_index(wmi_data, 0)
    Let processor_time_str be MapOps.get_value_or_default(processor_data, "PercentProcessorTime", "0")
    Let total_percent be StringConvert.to_float(processor_time_str)
    
    Return CPUUsage with user_percent = 0.0, system_percent = 0.0, 
        idle_percent = (100.0 - total_percent), total_percent = total_percent

Process called "parse_cpu_cores_from_proc_data" that takes proc_data as List[Dictionary[String, String]] returns List[CPUCore]:
    Note: Parse per-core information from Linux /proc/cpuinfo data
    
    If ListOps.is_empty(proc_data):
        Return empty List[CPUCore]
    
    Let cores be empty List[CPUCore]
    Let core_count be ListOps.length(proc_data)
    Let i be 0
    
    While i < core_count:
        Let core_data be ListOps.get_at_index(proc_data, i)
        Let frequency_str be MapOps.get_value_or_default(core_data, "cpu MHz", "0")
        Let frequency_mhz be StringConvert.to_integer(frequency_str)
        
        Let core be CPUCore with core_id = i, usage_percent = 0.0, 
            frequency_mhz = frequency_mhz, temperature_celsius = 0
        
        ListOps.add(cores, core)
        Let i be i + 1
    
    Return cores

Process called "parse_cpu_cores_from_profiler_data" that takes profiler_data as Dictionary[String, String] returns List[CPUCore]:
    Note: Parse per-core information from macOS system profiler data
    
    Let cores_str be MapOps.get_value_or_default(profiler_data, "cpu_cores", "1")
    Let core_count be StringConvert.to_integer(cores_str)
    
    Let cores be empty List[CPUCore]
    Let i be 0
    
    While i < core_count:
        Let core be CPUCore with core_id = i, usage_percent = 0.0, 
            frequency_mhz = 0, temperature_celsius = 0
        
        ListOps.add(cores, core)
        Let i be i + 1
    
    Return cores

Process called "parse_cpu_cores_from_wmi_data" that takes wmi_data as List[Dictionary[String, String]] returns List[CPUCore]:
    Note: Parse per-core information from Windows WMI data
    
    If ListOps.is_empty(wmi_data):
        Return empty List[CPUCore]
    
    Let processor_data be ListOps.get_at_index(wmi_data, 0)
    Let cores_str be MapOps.get_value_or_default(processor_data, "NumberOfCores", "1")
    Let core_count be StringConvert.to_integer(cores_str)
    Let frequency_str be MapOps.get_value_or_default(processor_data, "MaxClockSpeed", "0")
    Let frequency_mhz be StringConvert.to_integer(frequency_str)
    
    Let cores be empty List[CPUCore]
    Let i be 0
    
    While i < core_count:
        Let core be CPUCore with core_id = i, usage_percent = 0.0, 
            frequency_mhz = frequency_mhz, temperature_celsius = 0
        
        ListOps.add(cores, core)
        Let i be i + 1
    
    Return cores

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "create_default_cpu_info" that takes nothing returns CPUInfo:
    Note: Create default CPU info when data is unavailable
    
    Return CPUInfo with model_name = "Unknown CPU", vendor = "Unknown", architecture = "unknown",
        cores = 1, threads = 1, frequency_mhz = 0, cache_size_kb = 0, features = empty List[String]

Process called "create_default_cpu_usage" that takes nothing returns CPUUsage:
    Note: Create default CPU usage when data is unavailable
    
    Return CPUUsage with user_percent = 0.0, system_percent = 0.0, 
        idle_percent = 100.0, total_percent = 0.0

Process called "parse_cache_size_kb" that takes cache_str as String returns Integer:
    Note: Parse cache size string (e.g., "256 KB", "8192 KB") to integer KB
    
    If cache_str is null or cache_str equals "":
        Return 0
    
    Let parts be StringCore.split_by_whitespace(cache_str)
    If ListOps.is_empty(parts):
        Return 0
    
    Let size_str be ListOps.get_at_index(parts, 0)
    Return StringConvert.to_integer(size_str)