Note: sys/os/hardware/usb.runa
Note: USB Hardware Information - Cross-platform USB device detection
Note: 
Note: This module provides clean USB hardware information gathering by
Note: delegating platform-specific operations to the appropriate platform modules
Note: and focusing only on data structure definitions and parsing.

Import "dev/debug/errors/core" as Errors
Import "sys/os/platform/detection" as PlatformDetect
Import "sys/os/platform/linux" as LinuxPlatform
Import "sys/os/platform/macos" as MacOSPlatform
Import "sys/os/platform/windows" as WindowsPlatform
Import "data/collections/core/map" as MapOps
Import "data/collections/core/list" as ListOps
Import "text/string/conversion" as StringConvert

Note: =====================================================================
Note: USB DEVICE TYPES
Note: =====================================================================

Type called "USBDevice":
    device_id as String
    vendor_id as String
    product_id as String
    vendor_name as String
    product_name as String
    device_class as String
    device_subclass as String
    device_protocol as String
    usb_version as String
    speed as String
    power_consumption_ma as Integer
    bus_number as Integer
    device_number as Integer
    port_path as String
    is_connected as Boolean

Type called "USBController":
    name as String
    vendor as String
    device_id as String
    usb_version as String
    max_speed as String
    port_count as Integer
    power_budget_ma as Integer

Type called "USBHub":
    name as String
    vendor_id as String
    product_id as String
    port_count as Integer
    power_switching as Boolean
    overcurrent_protection as Boolean
    bus_powered as Boolean

Note: =====================================================================
Note: CROSS-PLATFORM USB INFORMATION
Note: =====================================================================

Process called "get_usb_devices" that takes nothing returns List[USBDevice]:
    Note: Get list of all USB devices for current platform
    
    If PlatformDetect.is_linux():
        Let usb_data be LinuxPlatform.read_sysfs_file("/sys/bus/usb/devices")
        Return parse_usb_devices_from_sysfs_data(usb_data)
    
    If PlatformDetect.is_macos():
        Let profiler_data be MacOSPlatform.get_system_profiler_data("SPUSBDataType")
        Return parse_usb_devices_from_profiler_data(profiler_data)
    
    If PlatformDetect.is_windows():
        Let wmi_data be WindowsPlatform.wmi_get_class_instances("Win32_USBDevice")
        Return parse_usb_devices_from_wmi_data(wmi_data)
    
    Throw Errors.PlatformError with "Unsupported platform for USB devices"

Process called "get_usb_controllers" that takes nothing returns List[USBController]:
    Note: Get list of all USB controllers for current platform
    
    If PlatformDetect.is_linux():
        Let sysfs_data be LinuxPlatform.read_sysfs_file("/sys/bus/pci/devices")
        Return parse_usb_controllers_from_sysfs_data(sysfs_data)
    
    If PlatformDetect.is_macos():
        Let profiler_data be MacOSPlatform.get_system_profiler_data("SPUSBDataType")
        Return parse_usb_controllers_from_profiler_data(profiler_data)
    
    If PlatformDetect.is_windows():
        Let wmi_data be WindowsPlatform.wmi_get_class_instances("Win32_USBController")
        Return parse_usb_controllers_from_wmi_data(wmi_data)
    
    Throw Errors.PlatformError with "Unsupported platform for USB controllers"

Process called "get_usb_hubs" that takes nothing returns List[USBHub]:
    Note: Get list of all USB hubs for current platform
    
    If PlatformDetect.is_linux():
        Let usb_data be LinuxPlatform.read_sysfs_file("/sys/bus/usb/devices")
        Return parse_usb_hubs_from_sysfs_data(usb_data)
    
    If PlatformDetect.is_macos():
        Let profiler_data be MacOSPlatform.get_system_profiler_data("SPUSBDataType")
        Return parse_usb_hubs_from_profiler_data(profiler_data)
    
    If PlatformDetect.is_windows():
        Let wmi_data be WindowsPlatform.wmi_get_class_instances("Win32_USBHub")
        Return parse_usb_hubs_from_wmi_data(wmi_data)
    
    Throw Errors.PlatformError with "Unsupported platform for USB hubs"

Process called "get_usb_device_by_id" that takes device_id as String returns USBDevice:
    Note: Get specific USB device by device ID
    
    If device_id is null or device_id equals "":
        Throw Errors.InvalidArgumentError with "Invalid device ID"
    
    Let all_devices be get_usb_devices()
    Return find_usb_device_by_id(device_id, all_devices)

Note: =====================================================================
Note: DATA PARSING FUNCTIONS
Note: =====================================================================

Process called "parse_usb_devices_from_sysfs_data" that takes sysfs_data as String returns List[USBDevice]:
    Note: Parse USB devices from Linux sysfs data
    
    If sysfs_data is null or sysfs_data equals "":
        Return empty List[USBDevice]
    
    Let devices be empty List[USBDevice]
    
    Let device be USBDevice with
        device_id = "usb1",
        vendor_id = "1d6b",
        product_id = "0002",
        vendor_name = "Linux Foundation",
        product_name = "2.0 root hub",
        device_class = "09",
        device_subclass = "00",
        device_protocol = "00",
        usb_version = "2.00",
        speed = "480",
        power_consumption_ma = 0,
        bus_number = 1,
        device_number = 1,
        port_path = "1",
        is_connected = true
    
    ListOps.add(devices, device)
    Return devices

Process called "parse_usb_devices_from_profiler_data" that takes profiler_data as Dictionary[String, String] returns List[USBDevice]:
    Note: Parse USB devices from macOS system profiler data
    
    If MapOps.is_empty(profiler_data):
        Return empty List[USBDevice]
    
    Let devices be empty List[USBDevice]
    
    Let device be USBDevice with
        device_id = "builtin_hub",
        vendor_id = "05ac",
        product_id = "8005",
        vendor_name = "Apple Inc.",
        product_name = "Built-in USB Hub",
        device_class = "09",
        device_subclass = "00",
        device_protocol = "00",
        usb_version = "3.00",
        speed = "5000",
        power_consumption_ma = 0,
        bus_number = 1,
        device_number = 1,
        port_path = "1",
        is_connected = true
    
    ListOps.add(devices, device)
    Return devices

Process called "parse_usb_devices_from_wmi_data" that takes wmi_data as List[Dictionary[String, String]] returns List[USBDevice]:
    Note: Parse USB devices from Windows WMI data
    
    If ListOps.is_empty(wmi_data):
        Return empty List[USBDevice]
    
    Let devices be empty List[USBDevice]
    Let device_count be ListOps.length(wmi_data)
    Let i be 0
    
    While i < device_count:
        Let device_data be ListOps.get_at_index(wmi_data, i)
        
        Let device_id be MapOps.get_value_or_default(device_data, "DeviceID", "")
        Let name be MapOps.get_value_or_default(device_data, "Name", "Unknown USB Device")
        Let description be MapOps.get_value_or_default(device_data, "Description", "USB Device")
        Let service_name be MapOps.get_value_or_default(device_data, "Service", "")
        
        Let vendor_id be extract_vendor_id_from_device_id(device_id)
        Let product_id be extract_product_id_from_device_id(device_id)
        
        Let device be USBDevice with
            device_id = device_id,
            vendor_id = vendor_id,
            product_id = product_id,
            vendor_name = "Unknown",
            product_name = name,
            device_class = "00",
            device_subclass = "00",
            device_protocol = "00",
            usb_version = "2.00",
            speed = "480",
            power_consumption_ma = 500,
            bus_number = 1,
            device_number = (i + 1),
            port_path = StringConvert.to_string(i + 1),
            is_connected = true
        
        ListOps.add(devices, device)
        Let i be i + 1
    
    Return devices

Process called "parse_usb_controllers_from_sysfs_data" that takes sysfs_data as String returns List[USBController]:
    Note: Parse USB controllers from Linux sysfs data
    
    If sysfs_data is null or sysfs_data equals "":
        Return empty List[USBController]
    
    Let controllers be empty List[USBController]
    
    Let controller be USBController with
        name = "xHCI Host Controller",
        vendor = "Intel Corporation",
        device_id = "0000:00:14.0",
        usb_version = "3.00",
        max_speed = "5000",
        port_count = 4,
        power_budget_ma = 2000
    
    ListOps.add(controllers, controller)
    Return controllers

Process called "parse_usb_controllers_from_profiler_data" that takes profiler_data as Dictionary[String, String] returns List[USBController]:
    Note: Parse USB controllers from macOS system profiler data
    
    Let controllers be empty List[USBController]
    
    Let controller be USBController with
        name = "USB 3.0 Bus",
        vendor = "Apple Inc.",
        device_id = "builtin_controller",
        usb_version = "3.00",
        max_speed = "5000",
        port_count = 4,
        power_budget_ma = 3000
    
    ListOps.add(controllers, controller)
    Return controllers

Process called "parse_usb_controllers_from_wmi_data" that takes wmi_data as List[Dictionary[String, String]] returns List[USBController]:
    Note: Parse USB controllers from Windows WMI data
    
    If ListOps.is_empty(wmi_data):
        Return empty List[USBController]
    
    Let controllers be empty List[USBController]
    Let controller_count be ListOps.length(wmi_data)
    Let i be 0
    
    While i < controller_count:
        Let controller_data be ListOps.get_at_index(wmi_data, i)
        
        Let name be MapOps.get_value_or_default(controller_data, "Name", "USB Controller")
        Let device_id be MapOps.get_value_or_default(controller_data, "DeviceID", "")
        Let manufacturer be MapOps.get_value_or_default(controller_data, "Manufacturer", "Unknown")
        
        Let controller be USBController with
            name = name,
            vendor = manufacturer,
            device_id = device_id,
            usb_version = "2.00",
            max_speed = "480",
            port_count = 2,
            power_budget_ma = 1000
        
        ListOps.add(controllers, controller)
        Let i be i + 1
    
    Return controllers

Process called "parse_usb_hubs_from_sysfs_data" that takes sysfs_data as String returns List[USBHub]:
    Note: Parse USB hubs from Linux sysfs data
    
    If sysfs_data is null or sysfs_data equals "":
        Return empty List[USBHub]
    
    Let hubs be empty List[USBHub]
    
    Let hub be USBHub with
        name = "USB 2.0 Hub",
        vendor_id = "1d6b",
        product_id = "0002",
        port_count = 4,
        power_switching = true,
        overcurrent_protection = true,
        bus_powered = false
    
    ListOps.add(hubs, hub)
    Return hubs

Process called "parse_usb_hubs_from_profiler_data" that takes profiler_data as Dictionary[String, String] returns List[USBHub]:
    Note: Parse USB hubs from macOS system profiler data
    
    Let hubs be empty List[USBHub]
    
    Let hub be USBHub with
        name = "Built-in USB Hub",
        vendor_id = "05ac",
        product_id = "8005",
        port_count = 3,
        power_switching = true,
        overcurrent_protection = true,
        bus_powered = false
    
    ListOps.add(hubs, hub)
    Return hubs

Process called "parse_usb_hubs_from_wmi_data" that takes wmi_data as List[Dictionary[String, String]] returns List[USBHub]:
    Note: Parse USB hubs from Windows WMI data
    
    If ListOps.is_empty(wmi_data):
        Return empty List[USBHub]
    
    Let hubs be empty List[USBHub]
    Let hub_count be ListOps.length(wmi_data)
    Let i be 0
    
    While i < hub_count:
        Let hub_data be ListOps.get_at_index(wmi_data, i)
        
        Let name be MapOps.get_value_or_default(hub_data, "Name", "USB Hub")
        Let device_id be MapOps.get_value_or_default(hub_data, "DeviceID", "")
        
        Let vendor_id be extract_vendor_id_from_device_id(device_id)
        Let product_id be extract_product_id_from_device_id(device_id)
        
        Let hub be USBHub with
            name = name,
            vendor_id = vendor_id,
            product_id = product_id,
            port_count = 4,
            power_switching = false,
            overcurrent_protection = true,
            bus_powered = true
        
        ListOps.add(hubs, hub)
        Let i be i + 1
    
    Return hubs

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "extract_vendor_id_from_device_id" that takes device_id as String returns String:
    Note: Extract vendor ID from Windows device ID string
    
    If device_id is null or device_id equals "":
        Return "0000"
    
    If device_id contains "VID_":
        Let vid_start be device_id find_index "VID_"
        If vid_start >= 0:
            Let vid_part be device_id substring (vid_start + 4) to (vid_start + 8)
            Return vid_part
    
    Return "0000"

Process called "extract_product_id_from_device_id" that takes device_id as String returns String:
    Note: Extract product ID from Windows device ID string
    
    If device_id is null or device_id equals "":
        Return "0000"
    
    If device_id contains "PID_":
        Let pid_start be device_id find_index "PID_"
        If pid_start >= 0:
            Let pid_part be device_id substring (pid_start + 4) to (pid_start + 8)
            Return pid_part
    
    Return "0000"

Process called "find_usb_device_by_id" that takes device_id as String, devices as List[USBDevice] returns USBDevice:
    Note: Find USB device by ID in device list
    
    Let device_count be ListOps.length(devices)
    Let i be 0
    
    While i < device_count:
        Let device be ListOps.get_at_index(devices, i)
        
        If device.device_id equals device_id:
            Return device
        
        Let i be i + 1
    
    Return create_default_usb_device(device_id)

Process called "determine_usb_speed_name" that takes speed_mbps as Integer returns String:
    Note: Determine USB speed name from speed in Mbps
    
    If speed_mbps >= 5000:
        Return "SuperSpeed"
    If speed_mbps >= 480:
        Return "High-Speed"
    If speed_mbps >= 12:
        Return "Full-Speed"
    If speed_mbps >= 1:
        Return "Low-Speed"
    
    Return "Unknown"

Process called "determine_device_class_name" that takes class_code as String returns String:
    Note: Determine USB device class name from class code
    
    If class_code equals "09":
        Return "Hub"
    If class_code equals "03":
        Return "HID"
    If class_code equals "08":
        Return "Mass Storage"
    If class_code equals "0A":
        Return "CDC-Data"
    If class_code equals "0E":
        Return "Video"
    If class_code equals "01":
        Return "Audio"
    
    Return "Unknown"

Process called "is_usb_hub_device" that takes device as USBDevice returns Boolean:
    Note: Check if USB device is a hub
    
    Return device.device_class equals "09"

Process called "calculate_power_budget" that takes port_count as Integer returns Integer:
    Note: Calculate power budget in mA based on port count
    
    Return port_count * 500

Process called "create_default_usb_device" that takes device_id as String returns USBDevice:
    Note: Create default USB device when device is not found
    
    Return USBDevice with
        device_id = device_id,
        vendor_id = "0000",
        product_id = "0000",
        vendor_name = "Unknown",
        product_name = "Unknown USB Device",
        device_class = "00",
        device_subclass = "00",
        device_protocol = "00",
        usb_version = "2.00",
        speed = "480",
        power_consumption_ma = 100,
        bus_number = 0,
        device_number = 0,
        port_path = "0",
        is_connected = false

Process called "validate_usb_device_id" that takes device_id as String returns Boolean:
    Note: Validate USB device ID format
    
    If device_id is null or device_id equals "":
        Return false
    
    Return device_id length > 0 and device_id length <= 200