Note: sys/os/hardware/storage.runa
Note: Storage Device Information and Management - Cross-platform storage detection
Note: 
Note: This module provides clean storage information gathering by delegating
Note: platform-specific operations to the appropriate platform modules
Note: and focusing only on data structure definitions and parsing.

Import "dev/debug/errors/core" as Errors
Import "sys/os/platform/detection" as PlatformDetect
Import "sys/os/platform/linux" as LinuxPlatform
Import "sys/os/platform/macos" as MacOSPlatform
Import "sys/os/platform/windows" as WindowsPlatform
Import "data/collections/core/map" as MapOps
Import "data/collections/core/list" as ListOps
Import "text/string/conversion" as StringConvert

Note: =====================================================================
Note: STORAGE INFORMATION TYPES
Note: =====================================================================

Type called "StorageDevice":
    name as String
    device_path as String
    filesystem as String
    size_gb as Integer
    free_gb as Integer
    used_gb as Integer
    mount_point as String
    is_removable as Boolean
    device_type as String

Type called "DiskUsage":
    path as String
    total_gb as Integer
    used_gb as Integer
    free_gb as Integer
    usage_percent as Float

Note: =====================================================================
Note: CROSS-PLATFORM STORAGE INFORMATION
Note: =====================================================================

Process called "get_storage_devices" that takes nothing returns List[StorageDevice]:
    Note: Get list of all storage devices for current platform
    
    If PlatformDetect.is_linux():
        Let mount_data be LinuxPlatform.get_mount_points()
        Return parse_storage_devices_from_mount_data(mount_data)
    
    If PlatformDetect.is_macos():
        Let volume_data be MacOSPlatform.get_apfs_volume_info("/")
        Return parse_storage_devices_from_apfs_data(volume_data)
    
    If PlatformDetect.is_windows():
        Let wmi_data be WindowsPlatform.wmi_get_class_instances("Win32_LogicalDisk")
        Return parse_storage_devices_from_wmi_data(wmi_data)
    
    Throw Errors.PlatformError with "Unsupported platform for storage information"

Process called "get_disk_usage" that takes path as String returns DiskUsage:
    Note: Get disk usage information for specific path
    
    If path is null or path equals "":
        Throw Errors.InvalidArgumentError with "Invalid path"
    
    If PlatformDetect.is_linux():
        Let mount_data be LinuxPlatform.get_mount_points()
        Return parse_disk_usage_from_mount_data(path, mount_data)
    
    If PlatformDetect.is_macos():
        Let volume_data be MacOSPlatform.get_apfs_volume_info(path)
        Return parse_disk_usage_from_apfs_data(path, volume_data)
    
    If PlatformDetect.is_windows():
        Let wmi_data be WindowsPlatform.wmi_get_class_instances("Win32_LogicalDisk")
        Return parse_disk_usage_from_wmi_data(path, wmi_data)
    
    Throw Errors.PlatformError with "Unsupported platform for disk usage"

Process called "get_filesystem_info" that takes mount_point as String returns StorageDevice:
    Note: Get filesystem information for mount point
    
    If mount_point is null or mount_point equals "":
        Throw Errors.InvalidArgumentError with "Invalid mount point"
    
    If PlatformDetect.is_linux():
        Let mount_data be LinuxPlatform.get_mount_points()
        Return find_filesystem_in_mount_data(mount_point, mount_data)
    
    If PlatformDetect.is_macos():
        Let volume_data be MacOSPlatform.get_apfs_volume_info(mount_point)
        Return parse_single_storage_device_from_apfs_data(volume_data)
    
    If PlatformDetect.is_windows():
        Let wmi_data be WindowsPlatform.wmi_get_class_instances("Win32_LogicalDisk")
        Return find_filesystem_in_wmi_data(mount_point, wmi_data)
    
    Throw Errors.PlatformError with "Unsupported platform for filesystem information"

Note: =====================================================================
Note: DATA PARSING FUNCTIONS
Note: =====================================================================

Process called "parse_storage_devices_from_mount_data" that takes mount_data as List[LinuxMountPoint] returns List[StorageDevice]:
    Note: Parse storage devices from Linux mount point data
    
    If ListOps.is_empty(mount_data):
        Return empty List[StorageDevice]
    
    Let devices be empty List[StorageDevice]
    Let mount_count be ListOps.length(mount_data)
    Let i be 0
    
    While i < mount_count:
        Let mount be ListOps.get_at_index(mount_data, i)
        
        If not is_virtual_filesystem(mount.filesystem_type):
            Let device be StorageDevice with 
                name = mount.device,
                device_path = mount.device,
                filesystem = mount.filesystem_type,
                size_gb = 0,
                free_gb = 0,
                used_gb = 0,
                mount_point = mount.mount_point,
                is_removable = is_removable_device(mount.device),
                device_type = determine_device_type(mount.device)
            
            ListOps.add(devices, device)
        
        Let i be i + 1
    
    Return devices

Process called "parse_storage_devices_from_apfs_data" that takes apfs_data as Dictionary[String, String] returns List[StorageDevice]:
    Note: Parse storage devices from macOS APFS data
    
    If MapOps.is_empty(apfs_data):
        Return empty List[StorageDevice]
    
    Let devices be empty List[StorageDevice]
    
    Let device be StorageDevice with
        name = "APFS Volume",
        device_path = "/",
        filesystem = "APFS",
        size_gb = 0,
        free_gb = 0,
        used_gb = 0,
        mount_point = "/",
        is_removable = false,
        device_type = "SSD"
    
    ListOps.add(devices, device)
    Return devices

Process called "parse_storage_devices_from_wmi_data" that takes wmi_data as List[Dictionary[String, String]] returns List[StorageDevice]:
    Note: Parse storage devices from Windows WMI data
    
    If ListOps.is_empty(wmi_data):
        Return empty List[StorageDevice]
    
    Let devices be empty List[StorageDevice]
    Let disk_count be ListOps.length(wmi_data)
    Let i be 0
    
    While i < disk_count:
        Let disk_data be ListOps.get_at_index(wmi_data, i)
        
        Let device_id be MapOps.get_value_or_default(disk_data, "DeviceID", "")
        Let size_str be MapOps.get_value_or_default(disk_data, "Size", "0")
        Let free_str be MapOps.get_value_or_default(disk_data, "FreeSpace", "0")
        Let filesystem be MapOps.get_value_or_default(disk_data, "FileSystem", "NTFS")
        
        Let size_bytes be StringConvert.to_integer(size_str)
        Let free_bytes be StringConvert.to_integer(free_str)
        Let size_gb be (size_bytes / 1073741824)
        Let free_gb be (free_bytes / 1073741824)
        Let used_gb be (size_gb - free_gb)
        
        Let device be StorageDevice with
            name = device_id,
            device_path = device_id,
            filesystem = filesystem,
            size_gb = size_gb,
            free_gb = free_gb,
            used_gb = used_gb,
            mount_point = device_id,
            is_removable = false,
            device_type = "HDD"
        
        ListOps.add(devices, device)
        Let i be i + 1
    
    Return devices

Process called "parse_disk_usage_from_mount_data" that takes path as String, mount_data as List[LinuxMountPoint] returns DiskUsage:
    Note: Parse disk usage for path from Linux mount data
    
    Let best_match be find_best_mount_match(path, mount_data)
    
    If best_match is null:
        Return create_default_disk_usage(path)
    
    Return DiskUsage with path = path, total_gb = 0, used_gb = 0, 
        free_gb = 0, usage_percent = 0.0

Process called "parse_disk_usage_from_apfs_data" that takes path as String, apfs_data as Dictionary[String, String] returns DiskUsage:
    Note: Parse disk usage for path from macOS APFS data
    
    Return DiskUsage with path = path, total_gb = 0, used_gb = 0, 
        free_gb = 0, usage_percent = 0.0

Process called "parse_disk_usage_from_wmi_data" that takes path as String, wmi_data as List[Dictionary[String, String]] returns DiskUsage:
    Note: Parse disk usage for path from Windows WMI data
    
    If ListOps.is_empty(wmi_data):
        Return create_default_disk_usage(path)
    
    Let drive_letter be extract_drive_letter(path)
    Let disk_data be find_disk_by_drive_letter(drive_letter, wmi_data)
    
    If disk_data is null:
        Return create_default_disk_usage(path)
    
    Let size_str be MapOps.get_value_or_default(disk_data, "Size", "0")
    Let free_str be MapOps.get_value_or_default(disk_data, "FreeSpace", "0")
    
    Let size_bytes be StringConvert.to_integer(size_str)
    Let free_bytes be StringConvert.to_integer(free_str)
    Let total_gb be (size_bytes / 1073741824)
    Let free_gb be (free_bytes / 1073741824)
    Let used_gb be (total_gb - free_gb)
    Let usage_percent be ((used_gb * 100.0) / total_gb)
    
    Return DiskUsage with path = path, total_gb = total_gb, used_gb = used_gb,
        free_gb = free_gb, usage_percent = usage_percent

Process called "find_filesystem_in_mount_data" that takes mount_point as String, mount_data as List[LinuxMountPoint] returns StorageDevice:
    Note: Find filesystem by mount point in Linux mount data
    
    Let best_match be find_best_mount_match(mount_point, mount_data)
    
    If best_match is null:
        Return create_default_storage_device(mount_point)
    
    Return StorageDevice with 
        name = best_match.device,
        device_path = best_match.device,
        filesystem = best_match.filesystem_type,
        size_gb = 0,
        free_gb = 0,
        used_gb = 0,
        mount_point = best_match.mount_point,
        is_removable = is_removable_device(best_match.device),
        device_type = determine_device_type(best_match.device)

Process called "parse_single_storage_device_from_apfs_data" that takes apfs_data as Dictionary[String, String] returns StorageDevice:
    Note: Parse single storage device from macOS APFS data
    
    Return StorageDevice with
        name = "APFS Volume",
        device_path = "/",
        filesystem = "APFS",
        size_gb = 0,
        free_gb = 0,
        used_gb = 0,
        mount_point = "/",
        is_removable = false,
        device_type = "SSD"

Process called "find_filesystem_in_wmi_data" that takes mount_point as String, wmi_data as List[Dictionary[String, String]] returns StorageDevice:
    Note: Find filesystem by mount point in Windows WMI data
    
    Let drive_letter be extract_drive_letter(mount_point)
    Let disk_data be find_disk_by_drive_letter(drive_letter, wmi_data)
    
    If disk_data is null:
        Return create_default_storage_device(mount_point)
    
    Let device_id be MapOps.get_value_or_default(disk_data, "DeviceID", "")
    Let filesystem be MapOps.get_value_or_default(disk_data, "FileSystem", "NTFS")
    
    Return StorageDevice with
        name = device_id,
        device_path = device_id,
        filesystem = filesystem,
        size_gb = 0,
        free_gb = 0,
        used_gb = 0,
        mount_point = device_id,
        is_removable = false,
        device_type = "HDD"

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "is_virtual_filesystem" that takes fs_type as String returns Boolean:
    Note: Check if filesystem type is virtual (proc, sysfs, etc.)
    
    Return fs_type equals "proc" or fs_type equals "sysfs" or fs_type equals "devtmpfs" or
           fs_type equals "tmpfs" or fs_type equals "devpts" or fs_type equals "cgroup"

Process called "is_removable_device" that takes device_path as String returns Boolean:
    Note: Check if device is removable based on path
    
    Return device_path contains "/usb" or device_path contains "/mmc"

Process called "determine_device_type" that takes device_path as String returns String:
    Note: Determine device type based on path
    
    If device_path contains "/nvme":
        Return "NVMe"
    If device_path contains "/ssd":
        Return "SSD"
    If device_path contains "/usb":
        Return "USB"
    If device_path contains "/mmc":
        Return "SD"
    
    Return "HDD"

Process called "extract_drive_letter" that takes path as String returns String:
    Note: Extract Windows drive letter from path (e.g., "C:" from "C:\\Windows")
    
    If path is null or path equals "":
        Return "C:"
    
    If path length >= 2 and path substring 1 equals ":":
        Return path substring 0 to 2
    
    Return "C:"

Process called "find_disk_by_drive_letter" that takes drive_letter as String, wmi_data as List[Dictionary[String, String]] returns Dictionary[String, String]:
    Note: Find disk data by Windows drive letter
    
    Let disk_count be ListOps.length(wmi_data)
    Let i be 0
    
    While i < disk_count:
        Let disk_data be ListOps.get_at_index(wmi_data, i)
        Let device_id be MapOps.get_value_or_default(disk_data, "DeviceID", "")
        
        If device_id equals drive_letter:
            Return disk_data
        
        Let i be i + 1
    
    Return null

Process called "find_best_mount_match" that takes path as String, mount_data as List[LinuxMountPoint] returns LinuxMountPoint:
    Note: Find best matching mount point for given path
    
    Let best_match be null
    Let best_match_length be 0
    Let mount_count be ListOps.length(mount_data)
    Let i be 0
    
    While i < mount_count:
        Let mount be ListOps.get_at_index(mount_data, i)
        Let mount_path_length be string_length(mount.mount_point)
        
        If path starts_with mount.mount_point and mount_path_length > best_match_length:
            Let best_match be mount
            Let best_match_length be mount_path_length
        
        Let i be i + 1
    
    Return best_match

Process called "create_default_storage_device" that takes path as String returns StorageDevice:
    Note: Create default storage device when data is unavailable
    
    Return StorageDevice with
        name = "Unknown",
        device_path = path,
        filesystem = "Unknown",
        size_gb = 0,
        free_gb = 0,
        used_gb = 0,
        mount_point = path,
        is_removable = false,
        device_type = "Unknown"

Process called "create_default_disk_usage" that takes path as String returns DiskUsage:
    Note: Create default disk usage when data is unavailable
    
    Return DiskUsage with path = path, total_gb = 0, used_gb = 0, 
        free_gb = 0, usage_percent = 0.0