Note: v0.2 Parser Implementation
Note: Per specification Section 2.3

Import "lexer" as Lexer

Note: Mirror of lexer's TokenType enum
Type TokenType is:
    | Keyword
    | Identifier
    | Integer
    | String
    | Symbol
    | Operator
End Type

Note: Type alias for Lexer's Token type
Type called "Token":
    token_type as TokenType
    value as String
    line as Integer
    column as Integer
End Type

Type called "ASTNode":
    node_type as NodeType
    children as List[ASTNode]
    value as String
    data_type as String
End Type

Type NodeType is:
    | Program
    | Function
    | Parameter
    | Statement
    | Expression
    | BinaryOp
    | UnaryOp
    | Literal
    | Identifier
    | FunctionCall
    | IfNode
    | WhileNode
    | ForEachNode
    | MatchNode
    | ReturnNode
    | LetNode
    | SetNode
    | TypeDef
    | ImportNode
    | EnumVariant
    | FieldNode
End Type

Type called "Parser":
    tokens as List[Token]
    current as Integer
End Type

Process called "parse" that takes tokens as List[Token] returns ASTNode:
    Let parser be a value of Type Parser with
        tokens as tokens,
        current as 0

    Return parse_program(parser)
End Process

Process called "parse_program" that takes parser as Parser returns ASTNode:
    Let program be a value of Type ASTNode with
        node_type as Program,
        children as list_create(),
        value as "",
        data_type as ""

    While parser.current is less than length of parser.tokens:
        Let token be current_token(parser)
        If token.value is equal to "":
            advance(parser)
            Continue
        End If

        Let node be parse_top_level(parser)
        Add node to end of program.children
    End While

    Return program
End Process

Process called "parse_top_level" that takes parser as Parser returns ASTNode:
    Let token be current_token(parser)

    If token.value is equal to "Process":
        Return parse_function(parser)
    Otherwise If token.value is equal to "Type":
        Return parse_type_definition(parser)
    Otherwise If token.value is equal to "Import":
        Return parse_import(parser)
    Otherwise If token.value is equal to "Note":
        advance(parser)  Note: Skip comments
        Return parse_top_level(parser)
    Otherwise:
        Error("Unexpected top-level token: " plus token.value)
    End If
End Process

Process called "parse_function" that takes parser as Parser returns ASTNode:
    consume(parser, "Process")
    consume(parser, "called")

    Let name be consume_identifier(parser)

    Let parameters be list_create()
    If current_token(parser).value is equal to "that":
        consume(parser, "that")
        consume(parser, "takes")
        Set parameters to parse_parameters(parser)
    End If

    Let return_type be ""
    If current_token(parser).value is equal to "returns":
        consume(parser, "returns")
        Set return_type to consume_identifier(parser)
    End If

    consume(parser, ":")

    Let body be parse_block(parser, "End Process")

    Let function be a value of Type ASTNode with
        node_type as Function,
        children as body,
        value as name,
        data_type as return_type

    Return function
End Process

Process called "parse_parameters" that takes parser as Parser returns List[ASTNode]:
    Let parameters be list_create()

    Let param_name be consume_identifier(parser)
    consume(parser, "as")
    Let param_type be consume_identifier(parser)

    Let param be a value of Type ASTNode with
        node_type as Parameter,
        children as list_create(),
        value as param_name,
        data_type as param_type

    Add param to end of parameters

    Return parameters
End Process

Process called "parse_block" that takes parser as Parser, terminator as String returns List[ASTNode]:
    Let statements be list_create()

    While not check_token(parser, terminator):
        Let token be current_token(parser)
        If token.value is equal to "Note":
            advance(parser)  Note: Skip comments
            Continue
        End If

        Let stmt be parse_statement(parser)
        Add stmt to end of statements
    End While

    consume(parser, terminator)
    Return statements
End Process

Process called "parse_statement" that takes parser as Parser returns ASTNode:
    Let token be current_token(parser)

    If token.value is equal to "Let":
        Return parse_let_statement(parser)
    Otherwise If token.value is equal to "Set":
        Return parse_set_statement(parser)
    Otherwise If token.value is equal to "Return":
        Return parse_return_statement(parser)
    Otherwise If token.value is equal to "If":
        Return parse_if_statement(parser)
    Otherwise If token.value is equal to "While":
        Return parse_while_statement(parser)
    Otherwise If token.value is equal to "For":
        Return parse_for_each_statement(parser)
    Otherwise If token.value is equal to "Match":
        Return parse_match_statement(parser)
    Otherwise:
        Return parse_expression_statement(parser)
    End If
End Process

Process called "parse_let_statement" that takes parser as Parser returns ASTNode:
    consume(parser, "Let")
    Let var_name be consume_identifier(parser)
    consume(parser, "be")
    Let expr be parse_expression(parser)

    Let let_stmt be a value of Type ASTNode with
        node_type as LetNode,
        children as a list containing expr,
        value as var_name,
        data_type as ""

    Return let_stmt
End Process

Process called "parse_set_statement" that takes parser as Parser returns ASTNode:
    consume(parser, "Set")
    Let var_name be consume_identifier(parser)
    consume(parser, "to")
    Let expr be parse_expression(parser)

    Let set_stmt be a value of Type ASTNode with
        node_type as SetNode,
        children as a list containing expr,
        value as var_name,
        data_type as ""

    Return set_stmt
End Process

Process called "parse_return_statement" that takes parser as Parser returns ASTNode:
    consume(parser, "Return")
    Let expr be parse_expression(parser)

    Let return_stmt be a value of Type ASTNode with
        node_type as ReturnNode,
        children as a list containing expr,
        value as "",
        data_type as ""

    Return return_stmt
End Process

Process called "parse_if_statement" that takes parser as Parser returns ASTNode:
    consume(parser, "If")
    Let condition be parse_expression(parser)
    consume(parser, ":")

    Let then_block be parse_block(parser, "End If")

    Let if_stmt be a value of Type ASTNode with
        node_type as IfNode,
        children as a list containing condition,
        value as "",
        data_type as ""

    Add then_block to end of if_stmt.children

    Return if_stmt
End Process

Process called "parse_expression" that takes parser as Parser returns ASTNode:
    Let left be parse_primary(parser)

    While is_binary_operator(current_token(parser)):
        Let op_token be current_token(parser)
        advance(parser)
        Let right be parse_primary(parser)

        Let binary_op be a value of Type ASTNode with
            node_type as BinaryOp,
            children as a list containing left, right,
            value as op_token.value,
            data_type as ""

        Set left to binary_op
    End While

    Return left
End Process

Process called "parse_primary" that takes parser as Parser returns ASTNode:
    Let token be current_token(parser)

    If token.token_type is equal to Integer:
        advance(parser)
        Return a value of Type ASTNode with
            node_type as Literal,
            children as list_create(),
            value as token.value,
            data_type as "Integer"

    Otherwise If token.token_type is equal to String:
        advance(parser)
        Return a value of Type ASTNode with
            node_type as Literal,
            children as list_create(),
            value as token.value,
            data_type as "String"

    Otherwise If token.token_type is equal to Identifier:
        Let name be token.value
        advance(parser)

        If current_token(parser).value is equal to "(":
            Return parse_function_call(parser, name)
        Otherwise:
            Return a value of Type ASTNode with
                node_type as Identifier,
                children as list_create(),
                value as name,
                data_type as ""
        End If

    Otherwise:
        Error("Unexpected token in expression: " plus token.value)
    End If
End Process

Process called "parse_function_call" that takes parser as Parser, name as String returns ASTNode:
    consume(parser, "(")
    Let args be list_create()

    While not check_token(parser, ")"):
        Let arg be parse_expression(parser)
        Add arg to end of args

        If check_token(parser, ","):
            advance(parser)
        End If
    End While

    consume(parser, ")")

    Return a value of Type ASTNode with
        node_type as FunctionCall,
        children as args,
        value as name,
        data_type as ""
End Process

Process called "current_token" that takes parser as Parser returns Token:
    If parser.current is less than length of parser.tokens:
        Return parser.tokens at index parser.current
    Otherwise:
        Return create_eof_token()
    End If
End Process

Process called "advance" that takes parser as Parser returns Nothing:
    Set parser.current to parser.current plus 1
End Process

Process called "consume" that takes parser as Parser, expected as String returns Nothing:
    Let token be current_token(parser)
    If token.value is equal to expected:
        advance(parser)
    Otherwise:
        Error("Expected '" plus expected plus "' but got '" plus token.value plus "'")
    End If
End Process

Process called "consume_identifier" that takes parser as Parser returns String:
    Let token be current_token(parser)
    If token.token_type is equal to Identifier:
        advance(parser)
        Return token.value
    Otherwise:
        Error("Expected identifier but got '" plus token.value plus "'")
    End If
End Process

Process called "check_token" that takes parser as Parser, expected as String returns Boolean:
    Let token be current_token(parser)
    Return token.value is equal to expected
End Process

Process called "is_binary_operator" that takes token as Token returns Boolean:
    If token.value is equal to "plus": Return true
    Otherwise If token.value is equal to "minus": Return true
    Otherwise If token.value is equal to "multiplied": Return true
    Otherwise If token.value is equal to "divided": Return true
    Otherwise If token.value is equal to "is": Return true
    Otherwise: Return false
    End If
End Process

Process called "create_eof_token" returns Token:
    Return a value of Type Token with
        token_type as Symbol,
        value as "",
        line as 0,
        column as 0
End Process

Process called "parse_type_definition" that takes parser as Parser returns ASTNode:
    consume(parser, "Type")

    Let type_name be consume_identifier(parser)

    Let type_node be a value of Type ASTNode with
        node_type as TypeDef,
        children as list_create(),
        value as type_name,
        data_type as ""

    If check_token(parser, "is"):
        consume(parser, "is")
        consume(parser, ":")

        Note: Parse enum variants
        While check_token(parser, "|"):
            consume(parser, "|")
            Let variant_name be consume_identifier(parser)

            Let variant_node be a value of Type ASTNode with
                node_type as EnumVariant,
                children as list_create(),
                value as variant_name,
                data_type as ""

            Add variant_node to end of type_node.children

            If check_token(parser, "as"):
                consume(parser, "as")
                Let variant_type be consume_identifier(parser)
                Set variant_node.data_type to variant_type
            End If
        End While
    Otherwise If check_token(parser, "called"):
        consume(parser, "called")
        consume(parser, "\"" plus type_name plus "\"")
        consume(parser, ":")

        Note: Parse struct fields
        While not check_token(parser, "End"):
            Let field_name be consume_identifier(parser)
            consume(parser, "as")
            Let field_type be consume_identifier(parser)

            Let field_node be a value of Type ASTNode with
                node_type as FieldNode,
                children as list_create(),
                value as field_name,
                data_type as field_type

            Add field_node to end of type_node.children
        End While
    End If

    consume(parser, "End")
    consume(parser, "Type")

    Return type_node
End Process

Process called "parse_import" that takes parser as Parser returns ASTNode:
    consume(parser, "Import")
    consume(parser, "\"")

    Let module_name be consume_identifier(parser)

    consume(parser, "\"")
    consume(parser, "as")

    Let alias_name be consume_identifier(parser)

    Let import_node be a value of Type ASTNode with
        node_type as ImportNode,
        children as list_create(),
        value as module_name,
        data_type as alias_name

    Return import_node
End Process

Process called "parse_while_statement" that takes parser as Parser returns ASTNode:
    consume(parser, "While")
    Let condition be parse_expression(parser)
    consume(parser, ":")

    Let body be parse_block(parser, "End While")

    Let while_stmt be a value of Type ASTNode with
        node_type as WhileNode,
        children as a list containing condition,
        value as "",
        data_type as ""

    Add body to end of while_stmt.children
    Return while_stmt
End Process

Process called "parse_for_each_statement" that takes parser as Parser returns ASTNode:
    consume(parser, "For")
    consume(parser, "Each")
    Let var_name be consume_identifier(parser)
    consume(parser, "in")
    Let collection be parse_expression(parser)
    consume(parser, ":")

    Let body be parse_block(parser, "End For")

    Let for_each_stmt be a value of Type ASTNode with
        node_type as ForEachNode,
        children as a list containing collection,
        value as var_name,
        data_type as ""

    Add body to end of for_each_stmt.children
    Return for_each_stmt
End Process

Process called "parse_match_statement" that takes parser as Parser returns ASTNode:
    consume(parser, "Match")
    Let expr be parse_expression(parser)
    consume(parser, ":")

    Let cases be list_create()
    While check_token(parser, "When"):
        consume(parser, "When")
        Let pattern be parse_expression(parser)
        consume(parser, ":")

        Let case_body be parse_block(parser, "When")
        Let case_node be a value of Type ASTNode with
            node_type as Statement,
            children as case_body,
            value as pattern.value,
            data_type as ""

        Add case_node to end of cases
    End While

    consume(parser, "End")
    consume(parser, "Match")

    Let match_stmt be a value of Type ASTNode with
        node_type as MatchNode,
        children as a list containing expr,
        value as "",
        data_type as ""

    Add cases to end of match_stmt.children
    Return match_stmt
End Process

Process called "parse_expression_statement" that takes parser as Parser returns ASTNode:
    Let expr be parse_expression(parser)
    Return expr
End Process

Process called "create_empty_node" returns ASTNode:
    Return a value of Type ASTNode with
        node_type as Statement,
        children as list_create(),
        value as "",
        data_type as ""
End Process

Process called "Error" that takes message as String returns Nothing:
    WriteFile message to "/dev/stderr"
    Return
End Process

Note: Wrapper function for v0.1 compatibility
Process called "Parser_parse" that takes tokens as List[Token] returns ASTNode:
    Return parse(tokens)
End Process