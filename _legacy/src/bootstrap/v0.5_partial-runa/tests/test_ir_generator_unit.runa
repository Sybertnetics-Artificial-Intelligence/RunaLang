Note: Unit tests for ir_generator.runa
Note: Tests each individual function in the IR builder module
Note: Validates that the FFI bridge to Rust backend works correctly

Import module "../ir_generator" as IR

External Process called "rust_print_string" that takes text as String

Note: Mock external functions for testing
External Process called "mock_create_ast_node" that takes node_type as String returns Integer
External Process called "mock_create_symbol_table" returns Integer
External Process called "mock_verify_ir_module" that takes ir_module as Integer returns Boolean
External Process called "mock_get_block_instruction_count" that takes block as Integer returns Integer
External Process called "mock_get_temp_var_count" that takes func as Integer returns Integer

Process called "test_create_ir_module" returns Boolean:
    Note: Test basic IR module creation
    
    rust_print_string("TEST: create_ir_module\n")
    
    Let module_name be "test_module"
    Let ir_module be IR.create_ir_module(module_name)
    
    If ir_module is equal to 0:
        rust_print_string("  FAIL: Module creation returned null\n")
        Return false
    End If
    
    rust_print_string("  PASS: IR module created successfully\n")
    Return true
End Process

Process called "test_create_basic_blocks" returns Boolean:
    Note: Test basic block creation
    
    rust_print_string("TEST: create_basic_block\n")
    
    Let block1 be IR.create_basic_block(1)
    Let block2 be IR.create_basic_block(2)
    Let block3 be IR.create_basic_block(3)
    
    If block1 is equal to 0:
        rust_print_string("  FAIL: Block 1 creation failed\n")
        Return false
    End If
    
    If block2 is equal to 0:
        rust_print_string("  FAIL: Block 2 creation failed\n")
        Return false
    End If
    
    If block3 is equal to 0:
        rust_print_string("  FAIL: Block 3 creation failed\n")
        Return false
    End If
    
    rust_print_string("  PASS: All basic blocks created\n")
    Return true
End Process

Process called "test_entry_exit_blocks" returns Boolean:
    Note: Test entry and exit block creation
    
    rust_print_string("TEST: create_entry_block and create_exit_block\n")
    
    Let entry_block be IR.create_entry_block()
    Let exit_block be IR.create_exit_block()
    
    If entry_block is equal to 0:
        rust_print_string("  FAIL: Entry block creation failed\n")
        Return false
    End If
    
    If exit_block is equal to 0:
        rust_print_string("  FAIL: Exit block creation failed\n")
        Return false
    End If
    
    rust_print_string("  PASS: Entry and exit blocks created\n")
    Return true
End Process

Process called "test_generate_temp_var" returns Boolean:
    Note: Test temporary variable generation
    
    rust_print_string("TEST: generate_temp_var\n")
    
    Note: Create a mock function context
    Let func_context be 12345
    
    Let temp1 be IR.generate_temp_var(func_context, "Integer")
    Let temp2 be IR.generate_temp_var(func_context, "Float")
    Let temp3 be IR.generate_temp_var(func_context, "String")
    
    Note: Verify temps are non-empty strings
    If temp1 is equal to "":
        rust_print_string("  FAIL: Temp var 1 is empty\n")
        Return false
    End If
    
    If temp2 is equal to "":
        rust_print_string("  FAIL: Temp var 2 is empty\n")
        Return false
    End If
    
    If temp3 is equal to "":
        rust_print_string("  FAIL: Temp var 3 is empty\n")
        Return false
    End If
    
    rust_print_string("  PASS: Temporary variables generated\n")
    Return true
End Process

Process called "test_emit_assignment" returns Boolean:
    Note: Test assignment instruction emission
    
    rust_print_string("TEST: emit_assignment\n")
    
    Let block be IR.create_basic_block(100)
    Let target be "x"
    Let value be "42"
    Let var_type be "Integer"
    
    Let result be IR.emit_assignment(block, target, value, var_type)
    
    If result is equal to 0:
        rust_print_string("  FAIL: Assignment emission failed\n")
        Return false
    End If
    
    rust_print_string("  PASS: Assignment instruction emitted\n")
    Return true
End Process

Process called "test_emit_binary_op" returns Boolean:
    Note: Test binary operation emission
    
    rust_print_string("TEST: emit_binary_op\n")
    
    Let block be IR.create_basic_block(200)
    
    Note: Test addition
    Let add_result be IR.emit_binary_op(block, "+", "x", "y", "Integer")
    If add_result is equal to "":
        rust_print_string("  FAIL: Addition emission failed\n")
        Return false
    End If
    
    Note: Test multiplication
    Let mul_result be IR.emit_binary_op(block, "*", "a", "b", "Float")
    If mul_result is equal to "":
        rust_print_string("  FAIL: Multiplication emission failed\n")
        Return false
    End If
    
    Note: Test comparison
    Let cmp_result be IR.emit_binary_op(block, "<", "i", "j", "Boolean")
    If cmp_result is equal to "":
        rust_print_string("  FAIL: Comparison emission failed\n")
        Return false
    End If
    
    rust_print_string("  PASS: Binary operations emitted\n")
    Return true
End Process

Process called "test_emit_branch" returns Boolean:
    Note: Test branch instruction emission
    
    rust_print_string("TEST: emit_branch\n")
    
    Let block be IR.create_basic_block(300)
    Let true_block be IR.create_basic_block(301)
    Let false_block be IR.create_basic_block(302)
    
    Note: Test conditional branch
    Let cond_branch be IR.emit_branch(block, "cond", true_block, false_block)
    If cond_branch is equal to 0:
        rust_print_string("  FAIL: Conditional branch emission failed\n")
        Return false
    End If
    
    Note: Test unconditional branch (pass 0 for false_block)
    Let uncond_branch be IR.emit_branch(block, "", true_block, 0)
    If uncond_branch is equal to 0:
        rust_print_string("  FAIL: Unconditional branch emission failed\n")
        Return false
    End If
    
    rust_print_string("  PASS: Branch instructions emitted\n")
    Return true
End Process

Process called "test_emit_return" returns Boolean:
    Note: Test return instruction emission
    
    rust_print_string("TEST: emit_return\n")
    
    Let block be IR.create_basic_block(400)
    
    Note: Test return with value
    Let return_with_value be IR.emit_return(block, "result", "Integer")
    If return_with_value is equal to 0:
        rust_print_string("  FAIL: Return with value emission failed\n")
        Return false
    End If
    
    Note: Test void return
    Let void_return be IR.emit_return(block, "", "Void")
    If void_return is equal to 0:
        rust_print_string("  FAIL: Void return emission failed\n")
        Return false
    End If
    
    rust_print_string("  PASS: Return instructions emitted\n")
    Return true
End Process

Process called "test_emit_function_call" returns Boolean:
    Note: Test function call emission
    
    rust_print_string("TEST: emit_function_call\n")
    
    Let block be IR.create_basic_block(500)
    Let args_handle be 999  Note: Mock arguments handle
    
    Note: Test function call with return value
    Let call_result be IR.emit_function_call(block, "add", args_handle, "Integer")
    If call_result is equal to "":
        rust_print_string("  FAIL: Function call emission failed\n")
        Return false
    End If
    
    Note: Test void function call
    Let void_call be IR.emit_function_call(block, "print", args_handle, "Void")
    If void_call is equal to "":
        rust_print_string("  FAIL: Void function call emission failed\n")
        Return false
    End If
    
    rust_print_string("  PASS: Function calls emitted\n")
    Return true
End Process

Process called "test_ssa_conversion" returns Boolean:
    Note: Test SSA form conversion
    
    rust_print_string("TEST: convert_to_ssa\n")
    
    Let func_handle be 777  Note: Mock function handle
    
    Let ssa_result be IR.convert_to_ssa(func_handle)
    If ssa_result is equal to 0:
        rust_print_string("  FAIL: SSA conversion failed\n")
        Return false
    End If
    
    rust_print_string("  PASS: SSA conversion completed\n")
    Return true
End Process

Process called "test_optimizations" returns Boolean:
    Note: Test optimization passes
    
    rust_print_string("TEST: Optimization passes\n")
    
    Let block be IR.create_basic_block(600)
    Let func be 888
    
    Note: Test constant folding
    Let fold_result be IR.fold_constants(block)
    If fold_result is less than 0:
        rust_print_string("  FAIL: Constant folding failed\n")
        Return false
    End If
    
    Note: Test dead code elimination
    Let dce_result be IR.eliminate_dead_code(func)
    If dce_result is less than 0:
        rust_print_string("  FAIL: Dead code elimination failed\n")
        Return false
    End If
    
    rust_print_string("  PASS: Optimizations completed\n")
    Return true
End Process

Process called "test_build_ir_module" returns Boolean:
    Note: Test complete IR module building
    
    rust_print_string("TEST: build_ir_module\n")
    
    Let ast be mock_create_ast_node("program")
    Let symbol_table be mock_create_symbol_table()
    
    Let ir_module be IR.build_ir_module(ast, symbol_table)
    
    If ir_module is equal to 0:
        rust_print_string("  FAIL: IR module building failed\n")
        Return false
    End If
    
    Let is_valid be mock_verify_ir_module(ir_module)
    If is_valid is equal to false:
        rust_print_string("  FAIL: Generated IR module is invalid\n")
        Return false
    End If
    
    rust_print_string("  PASS: Complete IR module built successfully\n")
    Return true
End Process

Process called "run_all_tests" returns Boolean:
    Note: Run all unit tests
    
    rust_print_string("\n=== IR BUILDER UNIT TESTS ===\n\n")
    
    Let all_passed be true
    
    If test_create_ir_module() is equal to false:
        Set all_passed to false
    End If
    
    If test_create_basic_blocks() is equal to false:
        Set all_passed to false
    End If
    
    If test_entry_exit_blocks() is equal to false:
        Set all_passed to false
    End If
    
    If test_generate_temp_var() is equal to false:
        Set all_passed to false
    End If
    
    If test_emit_assignment() is equal to false:
        Set all_passed to false
    End If
    
    If test_emit_binary_op() is equal to false:
        Set all_passed to false
    End If
    
    If test_emit_branch() is equal to false:
        Set all_passed to false
    End If
    
    If test_emit_return() is equal to false:
        Set all_passed to false
    End If
    
    If test_emit_function_call() is equal to false:
        Set all_passed to false
    End If
    
    If test_ssa_conversion() is equal to false:
        Set all_passed to false
    End If
    
    If test_optimizations() is equal to false:
        Set all_passed to false
    End If
    
    If test_build_ir_module() is equal to false:
        Set all_passed to false
    End If
    
    rust_print_string("\n=== TEST SUMMARY ===\n")
    
    If all_passed is equal to true:
        rust_print_string("✓ ALL TESTS PASSED\n")
    Otherwise:
        rust_print_string("✗ SOME TESTS FAILED\n")
    End If
    
    Return all_passed
End Process

Note: Main entry point for testing
Process called "main" returns Nothing:
    run_all_tests()
End Process