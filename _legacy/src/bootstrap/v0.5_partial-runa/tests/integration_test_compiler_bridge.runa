Note: Integration test for compiler_bridge functionality
Note: Tests that we can generate code through the Rust/LLVM backend

Import module "../parser_frontend" as Parser
Import module "../semantic_analyzer" as Semantic
Import module "../type_system" as Types
Import module "../compiler_bridge" as Bridge
Import module "../core_libs" as Core

External Process called "rust_print_string" that takes text as String

Process called "test_basic_code_generation" returns Boolean:
    Note: Test basic code generation through the bridge
    
    rust_print_string("[TEST] Basic Code Generation\n")
    
    Let test_program be "Process called \"main\" returns Nothing:\n    rust_print_string(\"Hello from generated code!\")\nEnd Process"
    
    Note: Parse the program
    Let parse_result be Parser.parse_program(test_program)
    If parse_result.success is equal to false:
        rust_print_string("  ✗ Parse failed (prerequisite)\n")
        Return false
    End If
    
    Note: Run semantic analysis
    Let symbol_table be Semantic.create_symbol_table()
    Let semantic_result be Semantic.analyze_program(parse_result.ast, symbol_table)
    If semantic_result.success is equal to false:
        rust_print_string("  ✗ Semantic analysis failed (prerequisite)\n")
        Return false
    End If
    
    Note: Run type checking
    Let type_result be Types.check_program(parse_result.ast, symbol_table)
    If type_result.success is equal to false:
        rust_print_string("  ✗ Type checking failed (prerequisite)\n")
        Return false
    End If
    
    Note: Test code generation
    Let codegen_result be Bridge.generate_code(parse_result.ast, symbol_table, "test_basic")
    If codegen_result.success is equal to false:
        rust_print_string("  ✗ Code generation failed\n")
        For Each error in codegen_result.errors:
            rust_print_string("    Error: ")
            rust_print_string(error)
            rust_print_string("\n")
        End For
        Return false
    End If
    
    rust_print_string("  ✓ Basic code generation passed\n")
    Return true
End Process

Process called "test_function_with_parameters" returns Boolean:
    Note: Test code generation for functions with parameters
    
    rust_print_string("[TEST] Function with Parameters\n")
    
    Let test_program be "Process called \"add\" that takes a as Integer, b as Integer returns Integer:\n    Return a plus b\nEnd Process"
    
    Let parse_result be Parser.parse_program(test_program)
    If parse_result.success is equal to false:
        rust_print_string("  ✗ Parse failed\n")
        Return false
    End If
    
    Let symbol_table be Semantic.create_symbol_table()
    Let semantic_result be Semantic.analyze_program(parse_result.ast, symbol_table)
    If semantic_result.success is equal to false:
        rust_print_string("  ✗ Semantic analysis failed\n")
        Return false
    End If
    
    Let type_result be Types.check_program(parse_result.ast, symbol_table)
    If type_result.success is equal to false:
        rust_print_string("  ✗ Type checking failed\n")
        Return false
    End If
    
    Let codegen_result be Bridge.generate_code(parse_result.ast, symbol_table, "test_params")
    If codegen_result.success is equal to false:
        rust_print_string("  ✗ Code generation with parameters failed\n")
        Return false
    End If
    
    rust_print_string("  ✓ Function with parameters passed\n")
    Return true
End Process

Process called "test_variable_operations" returns Boolean:
    Note: Test code generation for variable operations
    
    rust_print_string("[TEST] Variable Operations\n")
    
    Let test_program be "Process called \"test\" returns Integer:\n    Let x be 10\n    Let y be 20\n    Let sum be x plus y\n    Return sum\nEnd Process"
    
    Let parse_result be Parser.parse_program(test_program)
    If parse_result.success is equal to false:
        rust_print_string("  ✗ Parse failed\n")
        Return false
    End If
    
    Let symbol_table be Semantic.create_symbol_table()
    Let semantic_result be Semantic.analyze_program(parse_result.ast, symbol_table)
    If semantic_result.success is equal to false:
        rust_print_string("  ✗ Semantic analysis failed\n")
        Return false
    End If
    
    Let type_result be Types.check_program(parse_result.ast, symbol_table)
    If type_result.success is equal to false:
        rust_print_string("  ✗ Type checking failed\n")
        Return false
    End If
    
    Let codegen_result be Bridge.generate_code(parse_result.ast, symbol_table, "test_vars")
    If codegen_result.success is equal to false:
        rust_print_string("  ✗ Variable operations code generation failed\n")
        Return false
    End If
    
    rust_print_string("  ✓ Variable operations passed\n")
    Return true
End Process

Process called "test_control_flow_generation" returns Boolean:
    Note: Test code generation for control flow structures
    
    rust_print_string("[TEST] Control Flow Generation\n")
    
    Let test_program be "Process called \"test\" returns Nothing:\n    If true:\n        rust_print_string(\"True branch\")\n    Otherwise:\n        rust_print_string(\"False branch\")\n    End If\nEnd Process"
    
    Let parse_result be Parser.parse_program(test_program)
    If parse_result.success is equal to false:
        rust_print_string("  ✗ Parse failed\n")
        Return false
    End If
    
    Let symbol_table be Semantic.create_symbol_table()
    Let semantic_result be Semantic.analyze_program(parse_result.ast, symbol_table)
    If semantic_result.success is equal to false:
        rust_print_string("  ✗ Semantic analysis failed\n")
        Return false
    End If
    
    Let type_result be Types.check_program(parse_result.ast, symbol_table)
    If type_result.success is equal to false:
        rust_print_string("  ✗ Type checking failed\n")
        Return false
    End If
    
    Let codegen_result be Bridge.generate_code(parse_result.ast, symbol_table, "test_control")
    If codegen_result.success is equal to false:
        rust_print_string("  ✗ Control flow code generation failed\n")
        Return false
    End If
    
    rust_print_string("  ✓ Control flow generation passed\n")
    Return true
End Process

Process called "test_external_function_calls" returns Boolean:
    Note: Test code generation for external function calls
    
    rust_print_string("[TEST] External Function Calls\n")
    
    Let test_program be "External Process called \"rust_print_string\" that takes text as String\n\nProcess called \"test\" returns Nothing:\n    rust_print_string(\"External call test\")\nEnd Process"
    
    Let parse_result be Parser.parse_program(test_program)
    If parse_result.success is equal to false:
        rust_print_string("  ✗ Parse failed\n")
        Return false
    End If
    
    Let symbol_table be Semantic.create_symbol_table()
    Let semantic_result be Semantic.analyze_program(parse_result.ast, symbol_table)
    If semantic_result.success is equal to false:
        rust_print_string("  ✗ Semantic analysis failed\n")
        Return false
    End If
    
    Let type_result be Types.check_program(parse_result.ast, symbol_table)
    If type_result.success is equal to false:
        rust_print_string("  ✗ Type checking failed\n")
        Return false
    End If
    
    Let codegen_result be Bridge.generate_code(parse_result.ast, symbol_table, "test_external")
    If codegen_result.success is equal to false:
        rust_print_string("  ✗ External function calls code generation failed\n")
        Return false
    End If
    
    rust_print_string("  ✓ External function calls passed\n")
    Return true
End Process

Process called "test_type_definition_codegen" returns Boolean:
    Note: Test code generation for custom types
    
    rust_print_string("[TEST] Type Definition Code Generation\n")
    
    Let test_program be "Type called \"Point\":\n    x as Integer\n    y as Integer\nEnd Type\n\nProcess called \"create_point\" returns Point:\n    Return Point with x = 10, y = 20\nEnd Process"
    
    Let parse_result be Parser.parse_program(test_program)
    If parse_result.success is equal to false:
        rust_print_string("  ✗ Parse failed\n")
        Return false
    End If
    
    Let symbol_table be Semantic.create_symbol_table()
    Let semantic_result be Semantic.analyze_program(parse_result.ast, symbol_table)
    If semantic_result.success is equal to false:
        rust_print_string("  ✗ Semantic analysis failed\n")
        Return false
    End If
    
    Let type_result be Types.check_program(parse_result.ast, symbol_table)
    If type_result.success is equal to false:
        rust_print_string("  ✗ Type checking failed\n")
        Return false
    End If
    
    Let codegen_result be Bridge.generate_code(parse_result.ast, symbol_table, "test_types")
    If codegen_result.success is equal to false:
        rust_print_string("  ✗ Type definition code generation failed\n")
        Return false
    End If
    
    rust_print_string("  ✓ Type definition code generation passed\n")
    Return true
End Process

Process called "test_optimization_passes" returns Boolean:
    Note: Test that optimization passes are applied
    
    rust_print_string("[TEST] Optimization Passes\n")
    
    Let test_program be "Process called \"test\" returns Integer:\n    Let x be 5 plus 10\n    Let y be x times 2\n    Return y\nEnd Process"
    
    Let parse_result be Parser.parse_program(test_program)
    If parse_result.success is equal to false:
        rust_print_string("  ✗ Parse failed\n")
        Return false
    End If
    
    Let symbol_table be Semantic.create_symbol_table()
    Let semantic_result be Semantic.analyze_program(parse_result.ast, symbol_table)
    If semantic_result.success is equal to false:
        rust_print_string("  ✗ Semantic analysis failed\n")
        Return false
    End If
    
    Let type_result be Types.check_program(parse_result.ast, symbol_table)
    If type_result.success is equal to false:
        rust_print_string("  ✗ Type checking failed\n")
        Return false
    End If
    
    Note: Test with optimization enabled
    Let codegen_result be Bridge.generate_optimized_code(parse_result.ast, symbol_table, "test_opt")
    If codegen_result.success is equal to false:
        rust_print_string("  ✗ Optimization passes failed\n")
        Return false
    End If
    
    rust_print_string("  ✓ Optimization passes passed\n")
    Return true
End Process

Process called "test_error_handling_in_codegen" returns Boolean:
    Note: Test that codegen errors are properly handled
    
    rust_print_string("[TEST] Code Generation Error Handling\n")
    
    Let test_program be "Process called \"test\" returns Nothing:\n    invalid_function_call()\nEnd Process"  Note: This should fail in semantic analysis
    
    Let parse_result be Parser.parse_program(test_program)
    If parse_result.success is equal to false:
        rust_print_string("  ✓ Parse correctly failed for invalid code\n")
        Return true
    End If
    
    Let symbol_table be Semantic.create_symbol_table()
    Let semantic_result be Semantic.analyze_program(parse_result.ast, symbol_table)
    If semantic_result.success is equal to false:
        rust_print_string("  ✓ Semantic analysis correctly failed for invalid code\n")
        Return true
    End If
    
    Note: If we get here, the invalid code somehow passed - test codegen error handling
    Let codegen_result be Bridge.generate_code(parse_result.ast, symbol_table, "test_error")
    If codegen_result.success is equal to true:
        rust_print_string("  ✗ Invalid code should have failed in code generation\n")
        Return false
    End If
    
    rust_print_string("  ✓ Code generation error handling passed\n")
    Return true
End Process

Process called "run_all_compiler_bridge_tests" returns Boolean:
    Note: Run all compiler bridge integration tests
    
    Let tests_passed be 0
    Let tests_failed be 0
    
    If test_basic_code_generation():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_function_with_parameters():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_variable_operations():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_control_flow_generation():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_external_function_calls():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_type_definition_codegen():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_optimization_passes():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_error_handling_in_codegen():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    rust_print_string("\n=== COMPILER BRIDGE INTEGRATION TEST RESULTS ===\n")
    rust_print_string("Passed: ")
    rust_print_string(Core.integer_to_string(tests_passed))
    rust_print_string("\nFailed: ")
    rust_print_string(Core.integer_to_string(tests_failed))
    rust_print_string("\n")
    
    If tests_failed is equal to 0:
        rust_print_string("✓ ALL COMPILER BRIDGE TESTS PASSED\n")
        Return true
    Otherwise:
        rust_print_string("✗ SOME COMPILER BRIDGE TESTS FAILED\n")
        Return false
    End If
End Process

Process called "main":
    rust_print_string("=== COMPILER BRIDGE INTEGRATION TEST ===\n\n")
    run_all_compiler_bridge_tests()
End Process