Note: Test runner for IR builder module
Note: Executes all IR builder tests and reports results
Note: Can be compiled and run with the bootstrap compiler

Import module "../ir_generator" as IR
Import module "../core_libs" as Core

External Process called "rust_print_string" that takes text as String

Note: Test suite metadata
Process called "print_test_header" returns Nothing:
    rust_print_string("=====================================\n")
    rust_print_string("   IR BUILDER TEST SUITE\n")
    rust_print_string("   Testing partial-runa/ir_generator.runa\n")
    rust_print_string("=====================================\n\n")
End Process

Process called "test_basic_ir_creation" returns Boolean:
    Note: Test basic IR module and function creation
    
    rust_print_string("[TEST] Basic IR Creation\n")
    
    Note: Create a new IR module
    Let module_name be "test_module"
    Let ir_module be IR.create_ir_module(module_name)
    
    If ir_module is equal to 0:
        rust_print_string("  ✗ Failed to create IR module\n")
        Return false
    End If
    
    rust_print_string("  ✓ IR module created\n")
    
    Note: Create basic blocks
    Let entry be IR.create_entry_block()
    Let body be IR.create_basic_block(2)
    Let exit be IR.create_exit_block()
    
    If entry is equal to 0 or body is equal to 0 or exit is equal to 0:
        rust_print_string("  ✗ Failed to create basic blocks\n")
        Return false
    End If
    
    rust_print_string("  ✓ Basic blocks created\n")
    Return true
End Process

Process called "test_instruction_emission" returns Boolean:
    Note: Test IR instruction emission
    
    rust_print_string("[TEST] Instruction Emission\n")
    
    Let block be IR.create_basic_block(100)
    
    Note: Test assignment
    Let assign_result be IR.emit_assignment(block, "x", "10", "Integer")
    If assign_result is equal to 0:
        rust_print_string("  ✗ Assignment emission failed\n")
        Return false
    End If
    rust_print_string("  ✓ Assignment emitted\n")
    
    Note: Test binary operation
    Let temp be IR.emit_binary_op(block, "+", "x", "5", "Integer")
    If temp is equal to "":
        rust_print_string("  ✗ Binary op emission failed\n")
        Return false
    End If
    rust_print_string("  ✓ Binary operation emitted\n")
    
    Note: Test return
    Let ret_result be IR.emit_return(block, temp, "Integer")
    If ret_result is equal to 0:
        rust_print_string("  ✗ Return emission failed\n")
        Return false
    End If
    rust_print_string("  ✓ Return emitted\n")
    
    Return true
End Process

Process called "test_control_flow" returns Boolean:
    Note: Test control flow IR generation
    
    rust_print_string("[TEST] Control Flow\n")
    
    Let entry_block be IR.create_entry_block()
    Let then_block be IR.create_basic_block(10)
    Let else_block be IR.create_basic_block(20)
    Let merge_block be IR.create_basic_block(30)
    
    Note: Emit conditional branch
    Let branch_result be IR.emit_branch(entry_block, "condition", then_block, else_block)
    If branch_result is equal to 0:
        rust_print_string("  ✗ Conditional branch failed\n")
        Return false
    End If
    rust_print_string("  ✓ Conditional branch emitted\n")
    
    Note: Emit unconditional branches from then/else to merge
    Let then_jump be IR.emit_branch(then_block, "", merge_block, 0)
    Let else_jump be IR.emit_branch(else_block, "", merge_block, 0)
    
    If then_jump is equal to 0 or else_jump is equal to 0:
        rust_print_string("  ✗ Unconditional branch failed\n")
        Return false
    End If
    rust_print_string("  ✓ Control flow structure created\n")
    
    Return true
End Process

Process called "test_function_calls" returns Boolean:
    Note: Test function call IR generation
    
    rust_print_string("[TEST] Function Calls\n")
    
    Let block be IR.create_basic_block(200)
    Let args be 1234  Note: Mock argument list handle
    
    Note: Test function with return value
    Let result be IR.emit_function_call(block, "calculate", args, "Integer")
    If result is equal to "":
        rust_print_string("  ✗ Function call with return failed\n")
        Return false
    End If
    rust_print_string("  ✓ Function call with return emitted\n")
    
    Note: Test void function
    Let void_result be IR.emit_function_call(block, "print_value", args, "Void")
    If void_result is equal to "":
        rust_print_string("  ✗ Void function call failed\n")
        Return false
    End If
    rust_print_string("  ✓ Void function call emitted\n")
    
    Return true
End Process

Process called "test_ssa_and_optimizations" returns Boolean:
    Note: Test SSA conversion and optimizations
    
    rust_print_string("[TEST] SSA and Optimizations\n")
    
    Let func_handle be 5678  Note: Mock function handle
    Let block_handle be IR.create_basic_block(300)
    
    Note: Test SSA conversion
    Let ssa_result be IR.convert_to_ssa(func_handle)
    If ssa_result is equal to 0:
        rust_print_string("  ✗ SSA conversion failed\n")
        Return false
    End If
    rust_print_string("  ✓ SSA conversion completed\n")
    
    Note: Test constant folding
    Let fold_count be IR.fold_constants(block_handle)
    If fold_count is less than 0:
        rust_print_string("  ✗ Constant folding failed\n")
        Return false
    End If
    rust_print_string("  ✓ Constant folding completed\n")
    
    Note: Test dead code elimination
    Let dce_count be IR.eliminate_dead_code(func_handle)
    If dce_count is less than 0:
        rust_print_string("  ✗ Dead code elimination failed\n")
        Return false
    End If
    rust_print_string("  ✓ Dead code elimination completed\n")
    
    Return true
End Process

Process called "test_complete_pipeline" returns Boolean:
    Note: Test complete IR building pipeline
    
    rust_print_string("[TEST] Complete Pipeline\n")
    
    Note: Mock AST and symbol table (these would come from parser/semantic analyzer)
    Let ast_handle be 9999
    Let symbol_table be 8888
    
    Note: Build complete IR module
    Let ir_module be IR.build_ir_module(ast_handle, symbol_table)
    If ir_module is equal to 0:
        rust_print_string("  ✗ Complete IR module build failed\n")
        Return false
    End If
    rust_print_string("  ✓ Complete IR module built\n")
    
    Note: Build IR for a function
    Let func_ast be 7777
    Let ir_function be IR.build_ir_function(func_ast, symbol_table)
    If ir_function is equal to 0:
        rust_print_string("  ✗ Function IR build failed\n")
        Return false
    End If
    rust_print_string("  ✓ Function IR built\n")
    
    Note: Add function to module
    Let add_result be IR.add_function_to_module(ir_module, ir_function)
    If add_result is equal to false:
        rust_print_string("  ✗ Failed to add function to module\n")
        Return false
    End If
    rust_print_string("  ✓ Function added to module\n")
    
    Return true
End Process

Process called "print_test_summary" that takes passed as Integer, failed as Integer returns Nothing:
    rust_print_string("\n=====================================\n")
    rust_print_string("TEST RESULTS:\n")
    rust_print_string("  Passed: ")
    rust_print_string(Core.integer_to_string(passed))
    rust_print_string("\n  Failed: ")
    rust_print_string(Core.integer_to_string(failed))
    rust_print_string("\n")
    
    If failed is equal to 0:
        rust_print_string("\n✓✓✓ ALL TESTS PASSED ✓✓✓\n")
    Otherwise:
        rust_print_string("\n✗✗✗ SOME TESTS FAILED ✗✗✗\n")
    End If
    rust_print_string("=====================================\n")
End Process

Process called "main" returns Nothing:
    Note: Main test runner
    
    print_test_header()
    
    Let tests_passed be 0
    Let tests_failed be 0
    
    Note: Run each test and track results
    If test_basic_ir_creation() is equal to true:
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_instruction_emission() is equal to true:
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_control_flow() is equal to true:
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_function_calls() is equal to true:
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_ssa_and_optimizations() is equal to true:
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_complete_pipeline() is equal to true:
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    print_test_summary(tests_passed, tests_failed)
End Process