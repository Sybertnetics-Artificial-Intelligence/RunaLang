Note:
bootstrap/partial-runa/core_libs.runa
Core Libraries in Runa - Stage 0.2 Bootstrap

This module provides fundamental data structures and utilities for the partial self-hosting phase.

Key features and capabilities:
- String manipulation and creation
- Dynamic array management  
- Memory allocation primitives
- Basic I/O operations
- Error handling utilities
- Type conversion functions
- Mathematical operations
- Platform-agnostic interfaces
- Bootstrap-specific optimizations
- Error handling approach
- Memory management considerations
- Concurrency/threading considerations if applicable
:End Note

Note: Error types defined locally for bootstrap phase

Note: =====================================================================
Note: ERROR TYPES
Note: =====================================================================

Type called "IndexError":
    message as String
    index as Integer
End Type

Type called "ValueError":
    message as String
    value as Any
End Type

Type called "TypeError":
    message as String
    expected_type as String
    actual_type as String
End Type

Note: =====================================================================
Note: CORE DATA STRUCTURES
Note: =====================================================================

Type called "String":
    data as Array[Byte]                  Note: UTF-8 encoded byte array
    length as Integer                     Note: Number of bytes
    capacity as Integer                   Note: Allocated capacity
End Type

Type called "Array":
    elements as Pointer                  Note: Pointer to element storage
    capacity as Integer                   Note: Total allocated slots
    length as Integer                     Note: Current number of elements
    element_size as Integer               Note: Size of each element in bytes
End Type

Type called "Result":
    success as Boolean                    Note: Operation success indicator
    value as Any                         Note: Result value if successful
    error_message as Optional[String]    Note: Error details if failed
End Type

Type called "Dictionary":
    keys as Array                        Note: Array of key values
    values as Array                      Note: Array of corresponding values
    size as Integer                      Note: Number of key-value pairs
    capacity as Integer                  Note: Allocated capacity
End Type

Type called "ByteArray":
    data as Pointer                      Note: Raw byte data pointer
    length as Integer                    Note: Number of bytes
    capacity as Integer                  Note: Allocated capacity
End Type

Type called "Stream":
    handle as Integer                    Note: File descriptor or handle
    mode as String                       Note: read, write, append
    buffer as ByteArray                  Note: Internal buffer
    position as Integer                  Note: Current position in stream
End Type

Type called "Pointer":
    address as Integer                   Note: Memory address
    size as Integer                      Note: Size of pointed-to data
End Type

Note: =====================================================================
Note: STRING OPERATIONS
Note: =====================================================================

External Process called "rust_string_copy" that takes text as String returns String

Process called "string_new" that takes text as String returns String:
    Note: Create new string from text
    Note: Allocates memory and copies content
    Note: Time complexity: O(n), Space complexity: O(n)
    
    Let new_string be rust_string_copy(text)
    Return new_string
End Process

External Process called "rust_string_concat" that takes left as String, right as String returns String

Process called "string_concat" that takes left as String, right as String returns String:
    Note: Concatenate two strings
    Note: Creates new string with combined content
    Note: Time complexity: O(n+m), Space complexity: O(n+m)
    
    Note: Use Rust backend for actual concatenation
    Let result be rust_string_concat(left, right)
    Return result
End Process

Note: =====================================================================
Note: ARRAY OPERATIONS
Note: =====================================================================

External Process called "rust_array_new" that takes element_size as Integer, capacity as Integer returns Pointer

Process called "array_new" that takes element_type_size as Integer, initial_capacity as Integer returns Array:
    Note: Create new array with specified element size and capacity
    Note: Allocates contiguous memory block
    Note: Time complexity: O(1), Space complexity: O(capacity)
    
    Let min_capacity be initial_capacity
    If min_capacity is less than 4:
        Set min_capacity to 4
    End If
    
    Let memory_ptr be rust_array_new(element_type_size, min_capacity)
    
    Let new_array be Array with elements as memory_ptr, capacity as min_capacity, length as 0, element_size as element_type_size
    
    Return new_array
End Process

External Process called "rust_array_grow" that takes arr_ptr as Pointer, old_capacity as Integer, new_capacity as Integer, element_size as Integer returns Pointer
External Process called "rust_array_set" that takes arr_ptr as Pointer, index as Integer, value_ptr as Pointer, element_size as Integer returns Nothing

Process called "array_push" that takes arr as Array, item as Any returns Nothing:
    Note: Add item to end of array
    Note: Grows array if needed (doubles capacity)
    Note: Amortized time complexity: O(1)
    
    Note: Check if growth is needed
    If arr.length is greater than or equal to arr.capacity:
        Let new_capacity be arr.capacity multiplied by 2
        Let new_ptr be rust_array_grow(arr.elements, arr.capacity, new_capacity, arr.element_size)
        Set arr.elements to new_ptr
        Set arr.capacity to new_capacity
    End If
    
    Note: Add item at the end
    rust_array_set(arr.elements, arr.length, item as Pointer, arr.element_size)
    Set arr.length to arr.length plus 1
End Process

External Process called "rust_array_get" that takes arr_ptr as Pointer, index as Integer, element_size as Integer returns Any

Process called "array_get" that takes arr as Array, index as Integer returns Any:
    Note: Get item at specified index
    Note: Bounds checking included
    Note: Time complexity: O(1)
    
    If index is less than 0:
        Let error be IndexError with message as "Array index cannot be negative", index as index
        Throw error
    End If
    
    If index is greater than or equal to arr.length:
        Let error be IndexError with message as "Array index out of bounds", index as index
        Throw error
    End If
    
    Let value be rust_array_get(arr.elements, index, arr.element_size)
    Return value
End Process

Note: =====================================================================
Note: MEMORY MANAGEMENT
Note: =====================================================================

External Process called "rust_malloc" that takes size as Integer returns Integer

Process called "memory_allocate" that takes size as Integer returns Pointer:
    Note: Allocate memory block of specified size
    Note: Returns null on allocation failure
    Note: Interfaces with system allocator
    
    If size is less than or equal to 0:
        Let null_ptr be Pointer with address as 0, size as 0
        Return null_ptr
    End If
    
    Note: Round up to alignment boundary (8 bytes)
    Let aligned_size be size
    Let alignment be 8
    Let remainder be size modulo alignment
    If remainder is greater than 0:
        Set aligned_size to size plus alignment minus remainder
    End If
    
    Let raw_address be rust_malloc(aligned_size)
    
    Let ptr be Pointer with address as raw_address, size as aligned_size
    
    Return ptr
End Process

External Process called "rust_free" that takes address as Integer returns Nothing

Process called "memory_free" that takes ptr as Pointer returns Nothing:
    Note: Free previously allocated memory
    Note: No-op if ptr is null
    Note: Must match allocation size
    
    If ptr.address is equal to 0:
        Return
    End If
    
    rust_free(ptr.address)
    
    Note: Clear pointer to prevent use-after-free
    Set ptr.address to 0
    Set ptr.size to 0
End Process

Note: =====================================================================
Note: I/O OPERATIONS
Note: =====================================================================

External Process called "rust_print_string" that takes text as String returns Nothing

Process called "print_string" that takes text as String returns Nothing:
    Note: Output string to stdout
    Note: Handles UTF-8 encoding
    Note: Flushes output buffer
    
    rust_print_string(text)
End Process

External Process called "rust_read_line" returns String

Process called "read_line" returns String:
    Note: Read line from stdin
    Note: Strips newline character
    Note: Handles UTF-8 input
    
    Let input be rust_read_line()
    Return input
End Process

Note: =====================================================================
Note: TYPE CONVERSION OPERATIONS
Note: =====================================================================

External Process called "rust_integer_to_string" that takes value as Integer returns String

Process called "integer_to_string" that takes value as Integer returns String:
    Note: Convert integer to string representation
    Let result be rust_integer_to_string(value)
    Return result
End Process

External Process called "rust_string_to_integer" that takes text as String returns Integer

Process called "string_to_integer" that takes text as String returns Integer:
    Note: Convert string to integer
    Note: Throws ValueError if conversion fails
    Let result be rust_string_to_integer(text)
    Return result
End Process

External Process called "rust_float_to_string" that takes value as Float returns String

Process called "float_to_string" that takes value as Float returns String:
    Note: Convert float to string representation
    Let result be rust_float_to_string(value)
    Return result
End Process

Note: =====================================================================
Note: MATH OPERATIONS
Note: =====================================================================

Process called "min" that takes a as Integer, b as Integer returns Integer:
    Note: Return minimum of two integers
    Let result be a
    If b is less than a:
        Set result to b
    End If
    Return result
End Process

Process called "max" that takes a as Integer, b as Integer returns Integer:
    Note: Return maximum of two integers
    Let result be a
    If b is greater than a:
        Set result to b
    End If
    Return result
End Process

Process called "abs" that takes value as Integer returns Integer:
    Note: Return absolute value of integer
    Let result be value
    If value is less than 0:
        Set result to 0 minus value
    End If
    Return result
End Process

Note: =====================================================================
Note: STRING OPERATIONS
Note: =====================================================================

External Process called "rust_string_length" that takes text as String returns Integer

Process called "string_length" that takes text as String returns Integer:
    Note: Get length of string in characters
    Let length be rust_string_length(text)
    Return length
End Process

External Process called "rust_string_substring" that takes text as String, start as Integer, end as Integer returns String

Process called "string_substring" that takes text as String, start as Integer, end as Integer returns String:
    Note: Extract substring from start to end position
    Note: Validates bounds
    Let length be string_length(text)
    
    If start is less than 0:
        Let error be IndexError with message as "Substring start index cannot be negative", index as start
        Throw error
    End If
    
    If end is greater than length:
        Let error be IndexError with message as "Substring end index out of bounds", index as end
        Throw error
    End If
    
    If start is greater than end:
        Let error be ValueError with message as "Start index must be less than or equal to end index", value as start
        Throw error
    End If
    
    Let result be rust_string_substring(text, start, end)
    Return result
End Process

External Process called "rust_string_index_of" that takes text as String, search as String returns Integer

Process called "string_index_of" that takes text as String, search as String returns Integer:
    Note: Find index of first occurrence of search string
    Note: Returns -1 if not found
    Let index be rust_string_index_of(text, search)
    Return index
End Process

Note: =====================================================================
Note: ARRAY OPERATIONS
Note: =====================================================================

Process called "array_length" that takes arr as Array returns Integer:
    Note: Get current number of elements in array
    Return arr.length
End Process

External Process called "rust_array_set" that takes arr_ptr as Pointer, index as Integer, value_ptr as Pointer, element_size as Integer

Process called "array_set" that takes arr as Array, index as Integer, value as Any:
    Note: Set item at specified index
    Note: Bounds checking included
    
    If index is less than 0:
        Let error be IndexError with message as "Array index cannot be negative", index as index
        Throw error
    End If
    
    If index is greater than or equal to arr.length:
        Let error be IndexError with message as "Array index out of bounds", index as index
        Throw error
    End If
    
    rust_array_set(arr.elements, index, value as Pointer, arr.element_size)
End Process

Process called "array_clear" that takes arr as Array:
    Note: Remove all elements from array
    Set arr.length to 0
End Process

Note: =====================================================================
Note: UTILITY OPERATIONS
Note: =====================================================================

Process called "empty_list" returns Array:
    Note: Create an empty list/array
    Note: Used for initializing collections
    
    Let list be array_new(8, 16)  Note: 8 bytes per element, initial capacity 16
    Return list
End Process

Process called "create_dictionary" returns Dictionary:
    Note: Create an empty dictionary
    Note: Used for key-value storage
    
    Let dict be Dictionary with keys as array_new(8, 16), values as array_new(8, 16), size as 0, capacity as 16
    Return dict
End Process

Process called "create_byte_array" that takes size as Integer returns ByteArray:
    Note: Create a byte array with specified size
    Note: Used for binary data operations
    
    Let capacity be size
    If capacity is less than 16:
        Set capacity to 16
    End If
    
    Let ptr be memory_allocate(capacity)
    Let byte_arr be ByteArray with data as ptr, length as 0, capacity as capacity
    Return byte_arr
End Process

Process called "create_stream" that takes handle as Integer, mode as String returns Stream:
    Note: Create a stream for I/O operations
    Note: Used for file and network operations
    
    Let buffer be create_byte_array(4096)
    Let stream be Stream with handle as handle, mode as mode, buffer as buffer, position as 0
    Return stream
End Process