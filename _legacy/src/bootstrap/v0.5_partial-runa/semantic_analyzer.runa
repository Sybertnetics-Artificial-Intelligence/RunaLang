Note:
bootstrap/partial-runa/semantic_analyzer.runa
Semantic Analysis for Runa Partial Self-Hosting

This module performs semantic analysis on the parsed AST, handling symbol resolution,
scope management, and name binding for the partial Runa compiler.

Key features and capabilities:
- Symbol table construction and management
- Scope tracking and nested scope resolution
- Variable and type name binding
- Function signature validation
- Import resolution and module management
- Forward reference handling
- Semantic error detection and reporting
- Type annotation processing
- Generic parameter tracking
- Error handling approach
- Memory management considerations
- Integration with parser frontend and type system
:End Note

Import module "core_libs" as Core
Import module "parser_frontend" as Parser

Note: =====================================================================
Note: SYMBOL TABLE DATA STRUCTURES
Note: =====================================================================

Type called "Symbol":
    name as String                       Note: Symbol identifier
    symbol_type as String                Note: variable, function, type, module
    data_type as String                  Note: The type of the symbol
    scope_id as Integer                  Note: Scope where symbol is defined
    line as Integer                      Note: Definition line number
    is_mutable as Boolean                Note: For variables - mutability flag
    metadata as Core.Dictionary          Note: Additional symbol information
End Type

Type called "Scope":
    scope_id as Integer                  Note: Unique scope identifier
    parent_scope_id as Integer           Note: Parent scope ID for nesting (-1 for global)
    symbols as Core.Dictionary           Note: Symbols defined in this scope (name -> Symbol)
    scope_type as String                 Note: function, block, module, class
    start_line as Integer                Note: Where scope begins
    end_line as Integer                  Note: Where scope ends
End Type

Type called "SymbolTable":
    scopes as Core.Array                 Note: Array of Scope objects
    current_scope_id as Integer          Note: Currently active scope
    next_scope_id as Integer             Note: Counter for scope IDs
    global_scope_id as Integer           Note: ID of global scope (always 0)
    unresolved as Core.Array             Note: Forward references to resolve
    errors as Core.Array                 Note: Semantic errors found
End Type

Type called "SemanticResult":
    success as Boolean                   Note: Analysis success indicator
    symbol_table as SymbolTable         Note: Constructed symbol table
    annotated_ast as Parser.ASTNode     Note: AST with semantic annotations
    errors as Core.Array                 Note: Semantic errors found
    warnings as Core.Array               Note: Semantic warnings
End Type

Note: =====================================================================
Note: SYMBOL TABLE OPERATIONS
Note: =====================================================================

Process called "create_symbol_table" returns SymbolTable:
    Note: Initialize a new symbol table with global scope
    Note: Sets up the root scope for global definitions
    
    Let global_scope be Scope with scope_id as 0, parent_scope_id as -1, 
        symbols as Core.dictionary_new(), scope_type as "module",
        start_line as 0, end_line as 0
    
    Let scopes be Core.array_new(8, 16)  Note: Initial capacity for 16 scopes
    Core.array_push(scopes, global_scope)
    
    Let table be SymbolTable with scopes as scopes, current_scope_id as 0,
        next_scope_id as 1, global_scope_id as 0,
        unresolved as Core.array_new(8, 32),
        errors as Core.array_new(8, 32)
    
    Return table
End Process

Process called "enter_scope" that takes table as SymbolTable, scope_type as String, start_line as Integer returns Integer:
    Note: Create and enter a new nested scope
    Note: Returns the new scope ID for tracking
    Note: Maintains parent-child scope relationships
    
    Let new_scope_id be table.next_scope_id
    Set table.next_scope_id to table.next_scope_id plus 1
    
    Let new_scope be Scope with scope_id as new_scope_id,
        parent_scope_id as table.current_scope_id,
        symbols as Core.dictionary_new(),
        scope_type as scope_type,
        start_line as start_line,
        end_line as 0
    
    Core.array_push(table.scopes, new_scope)
    Set table.current_scope_id to new_scope_id
    
    Return new_scope_id
End Process

Process called "exit_scope" that takes table as SymbolTable, end_line as Integer returns Boolean:
    Note: Exit current scope and return to parent
    Note: Validates no unresolved symbols in exiting scope
    
    If table.current_scope_id is equal to 0:
        Note: Cannot exit global scope
        Core.array_push(table.errors, "Cannot exit global scope")
        Return false
    End If
    
    Let current_scope be Core.array_get(table.scopes, table.current_scope_id)
    Set current_scope.end_line to end_line
    
    Note: Check for unresolved symbols in this scope
    Let scope_symbols be Core.dictionary_values(current_scope.symbols)
    Let i be 0
    While i is less than Core.array_length(scope_symbols):
        Let symbol be Core.array_get(scope_symbols, i)
        Note: Check if symbol is used but not defined
        Note: This would be expanded in full implementation
        Set i to i plus 1
    End While
    
    Set table.current_scope_id to current_scope.parent_scope_id
    Return true
End Process

Process called "define_symbol" that takes table as SymbolTable, name as String, symbol_type as String, data_type as String, line as Integer, is_mutable as Boolean returns Boolean:
    Note: Add a new symbol to current scope
    Note: Checks for duplicate definitions
    Note: Handles shadowing rules for nested scopes
    
    Let current_scope be Core.array_get(table.scopes, table.current_scope_id)
    
    Note: Check if symbol already exists in current scope
    If Core.dictionary_has_key(current_scope.symbols, name) is equal to true:
        Let error_msg be Core.string_concat("Duplicate definition of symbol: ", name)
        Core.array_push(table.errors, error_msg)
        Return false
    End If
    
    Let new_symbol be Symbol with name as name, symbol_type as symbol_type,
        data_type as data_type, scope_id as table.current_scope_id,
        line as line, is_mutable as is_mutable,
        metadata as Core.dictionary_new()
    
    Core.dictionary_set(current_scope.symbols, name, new_symbol)
    Return true
End Process

Process called "resolve_symbol" that takes table as SymbolTable, name as String, line as Integer returns Symbol:
    Note: Look up symbol in current and parent scopes
    Note: Implements lexical scoping rules
    Note: Returns null-like symbol if not found
    
    Let scope_id be table.current_scope_id
    
    While scope_id is greater than or equal to 0:
        Let scope be Core.array_get(table.scopes, scope_id)
        
        If Core.dictionary_has_key(scope.symbols, name) is equal to true:
            Let symbol be Core.dictionary_get(scope.symbols, name)
            Return symbol
        End If
        
        Set scope_id to scope.parent_scope_id
    End While
    
    Note: Symbol not found - create unresolved reference
    Let unresolved_ref be Core.string_concat(name, " at line ")
    Set unresolved_ref to Core.string_concat(unresolved_ref, Core.integer_to_string(line))
    Core.array_push(table.unresolved, unresolved_ref)
    
    Note: Return a null symbol indicator
    Let null_symbol be Symbol with name as "", symbol_type as "undefined",
        data_type as "undefined", scope_id as -1, line as -1,
        is_mutable as false, metadata as Core.dictionary_new()
    
    Return null_symbol
End Process

Note: =====================================================================
Note: SEMANTIC ANALYSIS OPERATIONS
Note: =====================================================================

Process called "analyze_program" that takes ast as Parser.ASTNode returns SemanticResult:
    Note: Main entry point for semantic analysis
    Note: Performs complete semantic analysis on AST
    Note: Builds symbol table and annotates AST
    
    Let table be create_symbol_table()
    Let errors be Core.array_new(8, 32)
    Let warnings be Core.array_new(8, 32)
    
    Note: First pass - collect all type definitions and function signatures
    collect_declarations(ast, table)
    
    Note: Second pass - analyze function bodies and expressions
    analyze_node(ast, table)
    
    Note: Third pass - resolve forward references
    resolve_forward_references(table)
    
    Note: Check for unresolved symbols
    If Core.array_length(table.unresolved) is greater than 0:
        Let i be 0
        While i is less than Core.array_length(table.unresolved):
            Let unresolved be Core.array_get(table.unresolved, i)
            Let error_msg be Core.string_concat("Unresolved symbol: ", unresolved)
            Core.array_push(errors, error_msg)
            Set i to i plus 1
        End While
    End If
    
    Let success be Core.array_length(errors) is equal to 0
    
    Let result be SemanticResult with success as success,
        symbol_table as table, annotated_ast as ast,
        errors as errors, warnings as warnings
    
    Return result
End Process

Process called "collect_declarations" that takes node as Parser.ASTNode, table as SymbolTable returns Nothing:
    Note: First pass to collect all declarations
    Note: Allows forward references to work
    
    If node.node_type is equal to "function_def":
        Let func_name be Core.dictionary_get(node.attributes, "name")
        Let return_type be Core.dictionary_get(node.attributes, "return_type")
        define_symbol(table, func_name, "function", return_type, node.line, false)
    Otherwise If node.node_type is equal to "type_def":
        Let type_name be Core.dictionary_get(node.attributes, "name")
        define_symbol(table, type_name, "type", "Type", node.line, false)
    Otherwise If node.node_type is equal to "import":
        Let module_name be Core.dictionary_get(node.attributes, "module")
        define_symbol(table, module_name, "module", "Module", node.line, false)
    End If
    
    Note: Recursively collect from children
    Let i be 0
    While i is less than Core.array_length(node.children):
        Let child be Core.array_get(node.children, i)
        collect_declarations(child, table)
        Set i to i plus 1
    End While
End Process

Process called "analyze_node" that takes node as Parser.ASTNode, table as SymbolTable returns String:
    Note: Analyze a single AST node and its children
    Note: Returns the type of the expression/statement
    
    If node.node_type is equal to "function_def":
        Return analyze_function(node, table)
    Otherwise If node.node_type is equal to "type_def":
        Return analyze_type_definition(node, table)
    Otherwise If node.node_type is equal to "variable_def":
        Return analyze_variable_definition(node, table)
    Otherwise If node.node_type is equal to "identifier":
        Return analyze_identifier(node, table)
    Otherwise If node.node_type is equal to "binary_op":
        Return analyze_binary_operation(node, table)
    Otherwise If node.node_type is equal to "function_call":
        Return analyze_function_call(node, table)
    Otherwise If node.node_type is equal to "if_statement":
        Return analyze_if_statement(node, table)
    Otherwise If node.node_type is equal to "while_loop":
        Return analyze_while_loop(node, table)
    Otherwise If node.node_type is equal to "block":
        Return analyze_block(node, table)
    Otherwise If node.node_type is equal to "literal":
        Return Core.dictionary_get(node.attributes, "type")
    Otherwise:
        Note: Recursively analyze children for unknown node types
        Let i be 0
        While i is less than Core.array_length(node.children):
            Let child be Core.array_get(node.children, i)
            analyze_node(child, table)
            Set i to i plus 1
        End While
        Return "void"
    End If
End Process

Process called "analyze_function" that takes func_node as Parser.ASTNode, table as SymbolTable returns String:
    Note: Analyze function definition
    Note: Creates function scope and processes parameters
    Note: Validates return statements match signature
    
    Let func_name be Core.dictionary_get(func_node.attributes, "name")
    Let return_type be Core.dictionary_get(func_node.attributes, "return_type")
    
    Note: Enter function scope
    Let func_scope_id be enter_scope(table, "function", func_node.line)
    
    Note: Add parameters to function scope
    Let params be Core.dictionary_get(func_node.attributes, "parameters")
    If params is not equal to null:
        Let i be 0
        While i is less than Core.array_length(params):
            Let param be Core.array_get(params, i)
            Let param_name be Core.dictionary_get(param, "name")
            Let param_type be Core.dictionary_get(param, "type")
            define_symbol(table, param_name, "parameter", param_type, func_node.line, false)
            Set i to i plus 1
        End While
    End If
    
    Note: Analyze function body
    Let body be Core.dictionary_get(func_node.attributes, "body")
    If body is not equal to null:
        analyze_node(body, table)
    End If
    
    Note: Exit function scope
    exit_scope(table, func_node.line)
    
    Return return_type
End Process

Process called "analyze_type_definition" that takes type_node as Parser.ASTNode, table as SymbolTable returns String:
    Note: Analyze type definition
    Note: Registers fields and validates types
    
    Let type_name be Core.dictionary_get(type_node.attributes, "name")
    
    Note: Process fields if struct type
    Let fields be Core.dictionary_get(type_node.attributes, "fields")
    If fields is not equal to null:
        Let i be 0
        While i is less than Core.array_length(fields):
            Let field be Core.array_get(fields, i)
            Let field_type be Core.dictionary_get(field, "type")
            Note: Validate field type exists
            resolve_symbol(table, field_type, type_node.line)
            Set i to i plus 1
        End While
    End If
    
    Return "Type"
End Process

Process called "analyze_variable_definition" that takes var_node as Parser.ASTNode, table as SymbolTable returns String:
    Note: Analyze variable definition
    Note: Adds variable to current scope
    
    Let var_name be Core.dictionary_get(var_node.attributes, "name")
    Let var_type be Core.dictionary_get(var_node.attributes, "type")
    Let is_mutable be Core.dictionary_get(var_node.attributes, "mutable")
    
    If is_mutable is equal to null:
        Set is_mutable to false
    End If
    
    define_symbol(table, var_name, "variable", var_type, var_node.line, is_mutable)
    
    Note: Analyze initialization expression if present
    Let init_expr be Core.dictionary_get(var_node.attributes, "initializer")
    If init_expr is not equal to null:
        Let expr_type be analyze_node(init_expr, table)
        Note: Type checking would happen here
    End If
    
    Return var_type
End Process

Process called "analyze_identifier" that takes id_node as Parser.ASTNode, table as SymbolTable returns String:
    Note: Resolve identifier and return its type
    
    Let name be Core.dictionary_get(id_node.attributes, "name")
    Let symbol be resolve_symbol(table, name, id_node.line)
    
    If symbol.name is equal to "":
        Let error_msg be Core.string_concat("Undefined identifier: ", name)
        Core.array_push(table.errors, error_msg)
        Return "undefined"
    End If
    
    Return symbol.data_type
End Process

Process called "analyze_binary_operation" that takes op_node as Parser.ASTNode, table as SymbolTable returns String:
    Note: Analyze binary operation and determine result type
    
    Let left be Core.array_get(op_node.children, 0)
    Let right be Core.array_get(op_node.children, 1)
    Let operator be Core.dictionary_get(op_node.attributes, "operator")
    
    Let left_type be analyze_node(left, table)
    Let right_type be analyze_node(right, table)
    
    Note: Type inference for binary operations
    If operator is equal to "+" or operator is equal to "-" or operator is equal to "*" or operator is equal to "/":
        If left_type is equal to "Integer" and right_type is equal to "Integer":
            Return "Integer"
        Otherwise If left_type is equal to "Float" or right_type is equal to "Float":
            Return "Float"
        Otherwise If operator is equal to "+" and left_type is equal to "String" and right_type is equal to "String":
            Return "String"
        End If
    Otherwise If operator is equal to "==" or operator is equal to "!=" or operator is equal to "<" or operator is equal to ">":
        Return "Boolean"
    Otherwise If operator is equal to "and" or operator is equal to "or":
        Return "Boolean"
    End If
    
    Return "undefined"
End Process

Process called "analyze_function_call" that takes call_node as Parser.ASTNode, table as SymbolTable returns String:
    Note: Analyze function call and return result type
    
    Let func_name be Core.dictionary_get(call_node.attributes, "function")
    Let symbol be resolve_symbol(table, func_name, call_node.line)
    
    If symbol.name is equal to "":
        Let error_msg be Core.string_concat("Undefined function: ", func_name)
        Core.array_push(table.errors, error_msg)
        Return "undefined"
    End If
    
    Note: Analyze arguments
    Let args be Core.dictionary_get(call_node.attributes, "arguments")
    If args is not equal to null:
        Let i be 0
        While i is less than Core.array_length(args):
            Let arg be Core.array_get(args, i)
            analyze_node(arg, table)
            Set i to i plus 1
        End While
    End If
    
    Return symbol.data_type
End Process

Process called "analyze_if_statement" that takes if_node as Parser.ASTNode, table as SymbolTable returns String:
    Note: Analyze if statement with condition and branches
    
    Let condition be Core.dictionary_get(if_node.attributes, "condition")
    Let cond_type be analyze_node(condition, table)
    
    If cond_type is not equal to "Boolean":
        Core.array_push(table.errors, "If condition must be Boolean")
    End If
    
    Note: Enter scope for then branch
    enter_scope(table, "block", if_node.line)
    Let then_branch be Core.dictionary_get(if_node.attributes, "then_branch")
    analyze_node(then_branch, table)
    exit_scope(table, if_node.line)
    
    Note: Analyze else branch if present
    Let else_branch be Core.dictionary_get(if_node.attributes, "else_branch")
    If else_branch is not equal to null:
        enter_scope(table, "block", if_node.line)
        analyze_node(else_branch, table)
        exit_scope(table, if_node.line)
    End If
    
    Return "void"
End Process

Process called "analyze_while_loop" that takes while_node as Parser.ASTNode, table as SymbolTable returns String:
    Note: Analyze while loop
    
    Let condition be Core.dictionary_get(while_node.attributes, "condition")
    Let cond_type be analyze_node(condition, table)
    
    If cond_type is not equal to "Boolean":
        Core.array_push(table.errors, "While condition must be Boolean")
    End If
    
    Note: Enter scope for loop body
    enter_scope(table, "block", while_node.line)
    Let body be Core.dictionary_get(while_node.attributes, "body")
    analyze_node(body, table)
    exit_scope(table, while_node.line)
    
    Return "void"
End Process

Process called "analyze_block" that takes block_node as Parser.ASTNode, table as SymbolTable returns String:
    Note: Analyze block of statements
    
    enter_scope(table, "block", block_node.line)
    
    Let i be 0
    While i is less than Core.array_length(block_node.children):
        Let stmt be Core.array_get(block_node.children, i)
        analyze_node(stmt, table)
        Set i to i plus 1
    End While
    
    exit_scope(table, block_node.line)
    
    Return "void"
End Process

Process called "resolve_forward_references" that takes table as SymbolTable returns Nothing:
    Note: Resolve any forward references collected during analysis
    
    Let i be 0
    While i is less than Core.array_length(table.unresolved):
        Let ref be Core.array_get(table.unresolved, i)
        Note: Try to resolve again in global scope
        Note: This would be expanded to handle forward references properly
        Set i to i plus 1
    End While
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "report_semantic_error" that takes table as SymbolTable, error_type as String, location as Integer, details as String returns Nothing:
    Note: Format and add semantic error to table
    
    Let error_msg be Core.string_concat(error_type, " at line ")
    Set error_msg to Core.string_concat(error_msg, Core.integer_to_string(location))
    Set error_msg to Core.string_concat(error_msg, ": ")
    Set error_msg to Core.string_concat(error_msg, details)
    
    Core.array_push(table.errors, error_msg)
End Process