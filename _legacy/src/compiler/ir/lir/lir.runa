Note: Runa Compiler: Low-Level IR (LIR)
Note: Machine-like representation with virtual registers and explicit memory operations

Import "../types/types.runa"
Import "../ir_context.runa"

Note: Low-Level IR (LIR) - Machine-Like Representation
Type LIRNode is Dictionary with:
    node_type as String
    location as SourceLocation
    basic_block as String
    metadata as Dictionary[String, Any]

Type LIRInstruction is:
    | LIRLoad with destination as VirtualRegister and source as MemoryAddress and type as IRType
    | LIRStore with destination as MemoryAddress and source as VirtualRegister and type as IRType
    | LIRMove with destination as VirtualRegister and source as VirtualRegister or Immediate
    | LIRBinaryOp with destination as VirtualRegister and left as VirtualRegister and operator as String and right as VirtualRegister or Immediate and type as IRType
    | LIRUnaryOp with destination as VirtualRegister and operator as String and operand as VirtualRegister and type as IRType
    | LIRCall with destination as Optional[VirtualRegister] and function as String and arguments as List[VirtualRegister] and return_type as IRType
    | LIRReturn with value as Optional[VirtualRegister]
    | LIRJump with target as String
    | LIRBranch with condition as VirtualRegister and true_target as String and false_target as String
    | LIRPhi with destination as VirtualRegister and operands as List[PhiOperand] and type as IRType
    | LIRAlloca with destination as VirtualRegister and type as IRType and size as Integer
    | LIRGetElementPtr with destination as VirtualRegister and base as VirtualRegister and indices as List[VirtualRegister] and type as IRType
    | LIRBitcast with destination as VirtualRegister and source as VirtualRegister and from_type as IRType and to_type as IRType
    | LIRSelect with destination as VirtualRegister and condition as VirtualRegister and true_value as VirtualRegister and false_value as VirtualRegister and type as IRType
    | LIRIntrinsic with destination as Optional[VirtualRegister] and intrinsic_name as String and arguments as List[VirtualRegister] and return_type as IRType

Type VirtualRegister is Dictionary with:
    name as String
    type as IRType
    is_spilled as Boolean
    physical_register as Optional[String]
    metadata as Dictionary[String, Any]

Type MemoryAddress is:
    | LIRDirectAddress with offset as Integer and base as Optional[VirtualRegister]
    | LIRIndirectAddress with base as VirtualRegister and offset as Integer
    | LIRIndexedAddress with base as VirtualRegister and index as VirtualRegister and scale as Integer

Type Immediate is:
    | LIRIntegerImmediate with value as Integer and type as IRType
    | LIRFloatImmediate with value as Float and type as IRType
    | LIRStringImmediate with value as String and type as IRType
    | LIRBooleanImmediate with value as Boolean and type as IRType

Type LIRTerminator is:
    | LIRJumpTerminator with target as String
    | LIRBranchTerminator with condition as VirtualRegister and true_target as String and false_target as String
    | LIRReturnTerminator with value as Optional[VirtualRegister]
    | LIRUnreachableTerminator

Type LIRBasicBlock is Dictionary with:
    name as String
    instructions as List[LIRInstruction]
    terminator as LIRTerminator
    predecessors as List[String]
    successors as List[String]
    live_in as List[VirtualRegister]
    live_out as List[VirtualRegister]
    metadata as Dictionary[String, Any]

Type LIRFunction is Dictionary with:
    name as String
    parameters as List[LIRParameter]
    return_type as IRType
    basic_blocks as List[LIRBasicBlock]
    entry_block as String
    exit_blocks as List[String]
    virtual_registers as Dictionary[String, VirtualRegister]
    stack_frame_size as Integer
    metadata as Dictionary[String, Any]

Type LIRParameter is Dictionary with:
    name as String
    type as IRType
    virtual_register as VirtualRegister
    is_mutable as Boolean

Type LIRModule is Dictionary with:
    name as String
    functions as List[LIRFunction]
    global_variables as Dictionary[String, LIRGlobalVariable]
    constants as Dictionary[String, Immediate]
    metadata as Dictionary[String, Any]

Type LIRGlobalVariable is Dictionary with:
    name as String
    type as IRType
    initial_value as Optional[Immediate]
    is_constant as Boolean
    alignment as Integer

Process called "create_lir_module" that takes name as String returns LIRModule:
    Note: Create a new LIR module
    Return LIRModule with:
        name as name
        functions as list containing
        global_variables as dictionary containing
        constants as dictionary containing
        metadata as dictionary containing

Process called "create_lir_function" that takes name as String and parameters as List[LIRParameter] and return_type as IRType returns LIRFunction:
    Note: Create a new LIR function
    Let entry_block be "entry"
    Let exit_blocks be list containing
    
    Let basic_blocks be list containing
    Let entry_bb be create_lir_basic_block with name as entry_block
    Add entry_bb to basic_blocks
    
    Return LIRFunction with:
        name as name
        parameters as parameters
        return_type as return_type
        basic_blocks as basic_blocks
        entry_block as entry_block
        exit_blocks as exit_blocks
        virtual_registers as dictionary containing
        stack_frame_size as 0
        metadata as dictionary containing

Process called "create_lir_basic_block" that takes name as String returns LIRBasicBlock:
    Note: Create a new LIR basic block
    Return LIRBasicBlock with:
        name as name
        instructions as list containing
        terminator as LIRUnreachableTerminator
        predecessors as list containing
        successors as list containing
        live_in as list containing
        live_out as list containing
        metadata as dictionary containing

Process called "create_virtual_register" that takes name as String and type as IRType returns VirtualRegister:
    Note: Create a new virtual register
    Return VirtualRegister with:
        name as name
        type as type
        is_spilled as false
        physical_register as None
        metadata as dictionary containing

Process called "create_integer_immediate" that takes value as Integer and type as IRType returns Immediate:
    Note: Create an integer immediate
    Return LIRIntegerImmediate with value as value and type as type

Process called "create_float_immediate" that takes value as Float and type as IRType returns Immediate:
    Note: Create a float immediate
    Return LIRFloatImmediate with value as value and type as type

Process called "create_string_immediate" that takes value as String and type as IRType returns Immediate:
    Note: Create a string immediate
    Return LIRStringImmediate with value as value and type as type

Process called "create_boolean_immediate" that takes value as Boolean and type as IRType returns Immediate:
    Note: Create a boolean immediate
    Return LIRBooleanImmediate with value as value and type as type

Note: LIR Instruction Creation Utilities
Process called "create_lir_load" that takes destination as VirtualRegister and source as MemoryAddress and type as IRType returns LIRInstruction:
    Note: Create a LIR load instruction
    Return LIRLoad with destination as destination and source as source and type as type

Process called "create_lir_store" that takes destination as MemoryAddress and source as VirtualRegister and type as IRType returns LIRInstruction:
    Note: Create a LIR store instruction
    Return LIRStore with destination as destination and source as source and type as type

Process called "create_lir_move" that takes destination as VirtualRegister and source as VirtualRegister or Immediate returns LIRInstruction:
    Note: Create a LIR move instruction
    Return LIRMove with destination as destination and source as source

Process called "create_lir_binary_op" that takes destination as VirtualRegister and left as VirtualRegister and operator as String and right as VirtualRegister or Immediate and type as IRType returns LIRInstruction:
    Note: Create a LIR binary operation instruction
    Return LIRBinaryOp with destination as destination and left as left and operator as operator and right as right and type as type

Process called "create_lir_call" that takes destination as Optional[VirtualRegister] and function as String and arguments as List[VirtualRegister] and return_type as IRType returns LIRInstruction:
    Note: Create a LIR function call instruction
    Return LIRCall with destination as destination and function as function and arguments as arguments and return_type as return_type

Process called "create_lir_return" that takes value as Optional[VirtualRegister] returns LIRInstruction:
    Note: Create a LIR return instruction
    Return LIRReturn with value as value

Process called "create_lir_jump" that takes target as String returns LIRInstruction:
    Note: Create a LIR jump instruction
    Return LIRJump with target as target

Process called "create_lir_branch" that takes condition as VirtualRegister and true_target as String and false_target as String returns LIRInstruction:
    Note: Create a LIR conditional branch instruction
    Return LIRBranch with condition as condition and true_target as true_target and false_target as false_target

Process called "create_lir_phi" that takes destination as VirtualRegister and operands as List[PhiOperand] and type as IRType returns LIRInstruction:
    Note: Create a LIR phi instruction for SSA form
    Return LIRPhi with destination as destination and operands as operands and type as type

Process called "create_lir_alloca" that takes destination as VirtualRegister and type as IRType and size as Integer returns LIRInstruction:
    Note: Create a LIR alloca instruction for stack allocation
    Return LIRAlloca with destination as destination and type as type and size as size

Process called "create_lir_intrinsic" that takes destination as Optional[VirtualRegister] and intrinsic_name as String and arguments as List[VirtualRegister] and return_type as IRType returns LIRInstruction:
    Note: Create a LIR intrinsic instruction
    Return LIRIntrinsic with destination as destination and intrinsic_name as intrinsic_name and arguments as arguments and return_type as return_type

Note: LIR Terminator Creation Utilities
Process called "create_lir_jump_terminator" that takes target as String returns LIRTerminator:
    Note: Create a LIR jump terminator
    Return LIRJumpTerminator with target as target

Process called "create_lir_branch_terminator" that takes condition as VirtualRegister and true_target as String and false_target as String returns LIRTerminator:
    Note: Create a LIR branch terminator
    Return LIRBranchTerminator with condition as condition and true_target as true_target and false_target as false_target

Process called "create_lir_return_terminator" that takes value as Optional[VirtualRegister] returns LIRTerminator:
    Note: Create a LIR return terminator
    Return LIRReturnTerminator with value as value

Process called "create_lir_unreachable_terminator" returns LIRTerminator:
    Note: Create a LIR unreachable terminator
    Return LIRUnreachableTerminator

Note: LIR Analysis Utilities
Process called "get_lir_instruction_type" that takes instruction as LIRInstruction returns String:
    Note: Get the type of a LIR instruction
    Match instruction:
        When LIRLoad with destination as destination and source as source and type as type:
            Return "load"
        When LIRStore with destination as destination and source as source and type as type:
            Return "store"
        When LIRMove with destination as destination and source as source:
            Return "move"
        When LIRBinaryOp with destination as destination and left as left and operator as operator and right as right and type as type:
            Return "binary_op"
        When LIRUnaryOp with destination as destination and operator as operator and operand as operand and type as type:
            Return "unary_op"
        When LIRCall with destination as destination and function as function and arguments as arguments and return_type as return_type:
            Return "call"
        When LIRReturn with value as value:
            Return "return"
        When LIRJump with target as target:
            Return "jump"
        When LIRBranch with condition as condition and true_target as true_target and false_target as false_target:
            Return "branch"
        When LIRPhi with destination as destination and operands as operands and type as type:
            Return "phi"
        When LIRAlloca with destination as destination and type as type and size as size:
            Return "alloca"
        When LIRGetElementPtr with destination as destination and base as base and indices as indices and type as type:
            Return "getelementptr"
        When LIRBitcast with destination as destination and source as source and from_type as from_type and to_type as to_type:
            Return "bitcast"
        When LIRSelect with destination as destination and condition as condition and true_value as true_value and false_value as false_value and type as type:
            Return "select"
        When LIRIntrinsic with destination as destination and intrinsic_name as intrinsic_name and arguments as arguments and return_type as return_type:
            Return "intrinsic"

Process called "is_lir_terminator" that takes instruction as LIRInstruction returns Boolean:
    Note: Check if a LIR instruction is a terminator
    Let instruction_type be get_lir_instruction_type with instruction as instruction
    Return instruction_type is equal to "return" or instruction_type is equal to "jump" or instruction_type is equal to "branch"

Process called "get_lir_instruction_destination" that takes instruction as LIRInstruction returns Optional[VirtualRegister]:
    Note: Get the destination of a LIR instruction
    Match instruction:
        When LIRLoad with destination as destination and source as source and type as type:
            Return destination
        When LIRStore with destination as destination and source as source and type as type:
            Return None
        When LIRMove with destination as destination and source as source:
            Return destination
        When LIRBinaryOp with destination as destination and left as left and operator as operator and right as right and type as type:
            Return destination
        When LIRUnaryOp with destination as destination and operator as operator and operand as operand and type as type:
            Return destination
        When LIRCall with destination as destination and function as function and arguments as arguments and return_type as return_type:
            Return destination
        When LIRPhi with destination as destination and operands as operands and type as type:
            Return destination
        When LIRAlloca with destination as destination and type as type and size as size:
            Return destination
        When LIRGetElementPtr with destination as destination and base as base and indices as indices and type as type:
            Return destination
        When LIRBitcast with destination as destination and source as source and from_type as from_type and to_type as to_type:
            Return destination
        When LIRSelect with destination as destination and condition as condition and true_value as true_value and false_value as false_value and type as type:
            Return destination
        When LIRIntrinsic with destination as destination and intrinsic_name as intrinsic_name and arguments as arguments and return_type as return_type:
            Return destination
        Otherwise:
            Return None

Process called "get_lir_instruction_sources" that takes instruction as LIRInstruction returns List[VirtualRegister]:
    Note: Get the source operands of a LIR instruction
    Let sources be list containing
    
    Match instruction:
        When LIRLoad with destination as destination and source as source and type as type:
            Note: Extract virtual registers from memory address
            Match source:
                When LIRDirectAddress with offset as offset and base as base:
                    If base is not None:
                        Add base to sources
                When LIRIndirectAddress with base as base and offset as offset:
                    Add base to sources
                When LIRIndexedAddress with base as base and index as index and scale as scale:
                    Add base to sources
                    Add index to sources
        When LIRStore with destination as destination and source as source and type as type:
            Add source to sources
            Note: Extract virtual registers from memory address
            Match destination:
                When LIRDirectAddress with offset as offset and base as base:
                    If base is not None:
                        Add base to sources
                When LIRIndirectAddress with base as base and offset as offset:
                    Add base to sources
                When LIRIndexedAddress with base as base and index as index and scale as scale:
                    Add base to sources
                    Add index to sources
        When LIRMove with destination as destination and source as source:
            Match source:
                When VirtualRegister:
                    Add source to sources
                Otherwise:
                    Note: Immediate values don't count as sources
                    Return sources
        When LIRBinaryOp with destination as destination and left as left and operator as operator and right as right and type as type:
            Add left to sources
            Match right:
                When VirtualRegister:
                    Add right to sources
                Otherwise:
                    Note: Immediate values don't count as sources
                    Return sources
        When LIRUnaryOp with destination as destination and operator as operator and operand as operand and type as type:
            Add operand to sources
        When LIRCall with destination as destination and function as function and arguments as arguments and return_type as return_type:
            Add all arguments to sources
        When LIRBranch with condition as condition and true_target as true_target and false_target as false_target:
            Add condition to sources
        When LIRPhi with destination as destination and operands as operands and type as type:
            For each operand in operands:
                Add operand.value to sources
        When LIRGetElementPtr with destination as destination and base as base and indices as indices and type as type:
            Add base to sources
            Add all indices to sources
        When LIRBitcast with destination as destination and source as source and from_type as from_type and to_type as to_type:
            Add source to sources
        When LIRSelect with destination as destination and condition as condition and true_value as true_value and false_value as false_value and type as type:
            Add condition to sources
            Add true_value to sources
            Add false_value to sources
        When LIRIntrinsic with destination as destination and intrinsic_name as intrinsic_name and arguments as arguments and return_type as return_type:
            Add all arguments to sources
        Otherwise:
            Note: No sources for other instruction types
            Return sources
    
    Return sources

Note: LIR Control Flow Analysis
Process called "compute_lir_cfg_predecessors" that takes lir_function as LIRFunction:
    Note: Compute predecessor relationships for all basic blocks
    For each basic_block in lir_function.basic_blocks:
        Set basic_block.predecessors to list containing
    
    For each basic_block in lir_function.basic_blocks:
        Match basic_block.terminator:
            When LIRJumpTerminator with target as target:
                Let target_bb be find_lir_basic_block_by_name with lir_function as lir_function and name as target
                If target_bb is not None:
                    Add basic_block.name to target_bb.predecessors
            When LIRBranchTerminator with condition as condition and true_target as true_target and false_target as false_target:
                Let true_bb be find_lir_basic_block_by_name with lir_function as lir_function and name as true_target
                If true_bb is not None:
                    Add basic_block.name to true_bb.predecessors
                Let false_bb be find_lir_basic_block_by_name with lir_function as lir_function and name as false_target
                If false_bb is not None:
                    Add basic_block.name to false_bb.predecessors
            Otherwise:
                Note: Return and unreachable terminators have no successors
                Return

Process called "compute_lir_cfg_successors" that takes lir_function as LIRFunction:
    Note: Compute successor relationships for all basic blocks
    For each basic_block in lir_function.basic_blocks:
        Set basic_block.successors to list containing
    
    For each basic_block in lir_function.basic_blocks:
        Match basic_block.terminator:
            When LIRJumpTerminator with target as target:
                Add target to basic_block.successors
            When LIRBranchTerminator with condition as condition and true_target as true_target and false_target as false_target:
                Add true_target to basic_block.successors
                Add false_target to basic_block.successors
            Otherwise:
                Note: Return and unreachable terminators have no successors
                Return

Process called "find_lir_basic_block_by_name" that takes lir_function as LIRFunction and name as String returns Optional[LIRBasicBlock]:
    Note: Find a basic block by name
    For each basic_block in lir_function.basic_blocks:
        If basic_block.name is equal to name:
            Return basic_block
    Return None

Note: LIR Validation
Process called "validate_lir_function" that takes lir_function as LIRFunction returns Dictionary[String, Any]:
    Note: Validate a LIR function
    Let errors be list containing
    Let warnings be list containing
    
    Note: Check that all basic blocks have terminators
    For each basic_block in lir_function.basic_blocks:
        If basic_block.terminator is LIRUnreachableTerminator:
            Add "Basic block " plus basic_block.name plus " has no terminator" to errors
    
    Note: Check that all jump/branch targets exist
    For each basic_block in lir_function.basic_blocks:
        Match basic_block.terminator:
            When LIRJumpTerminator with target as target:
                If find_lir_basic_block_by_name with lir_function as lir_function and name as target is None:
                    Add "Jump target " plus target plus " does not exist" to errors
            When LIRBranchTerminator with condition as condition and true_target as true_target and false_target as false_target:
                If find_lir_basic_block_by_name with lir_function as lir_function and name as true_target is None:
                    Add "Branch true target " plus true_target plus " does not exist" to errors
                If find_lir_basic_block_by_name with lir_function as lir_function and name as false_target is None:
                    Add "Branch false target " plus false_target plus " does not exist" to errors
            Otherwise:
                Note: Return and unreachable terminators are valid
                Return
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Note: LIR Statistics
Process called "get_lir_statistics" that takes lir_module as LIRModule returns Dictionary[String, Any]:
    Note: Get statistics about a LIR module
    Let function_count be length of lir_module.functions
    Let basic_block_count be 0
    Let instruction_count be 0
    Let virtual_register_count be 0
    Let global_variable_count be length of lir_module.global_variables
    
    For each function in lir_module.functions:
        Set basic_block_count to basic_block_count plus length of function.basic_blocks
        Set virtual_register_count to virtual_register_count plus length of function.virtual_registers
        For each basic_block in function.basic_blocks:
            Set instruction_count to instruction_count plus length of basic_block.instructions
    
    Return dictionary containing:
        "function_count" as function_count
        "basic_block_count" as basic_block_count
        "instruction_count" as instruction_count
        "virtual_register_count" as virtual_register_count
        "global_variable_count" as global_variable_count
        "average_instructions_per_block" as (instruction_count divided by basic_block_count if basic_block_count is greater than 0 else 0)
        "average_virtual_registers_per_function" as (virtual_register_count divided by function_count if function_count is greater than 0 else 0) 