Note: Runa Compiler: LIR Builder
Note: MIR to LIR lowering pass with virtual register allocation

Import "lir.runa"
Import "../mir/mir.runa"
Import "../types/types.runa"
Import "../ir_context.runa"

Note: LIR Builder - MIR to LIR Lowering with Virtual Register Allocation
Type LIRBuilder is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    current_function as Optional[LIRFunction]
    current_basic_block as Optional[LIRBasicBlock]
    variable_to_register_map as Dictionary[String, VirtualRegister]
    next_register_id as Integer
    metadata as Dictionary[String, Any]

Process called "create_lir_builder" that takes context as IRContext and type_system as TypeSystem returns LIRBuilder:
    Note: Create a new LIR builder
    Return LIRBuilder with:
        context as context
        type_system as type_system
        current_function as None
        current_basic_block as None
        variable_to_register_map as dictionary containing
        next_register_id as 0
        metadata as dictionary containing

Process called "build_lir_from_mir" that takes mir_module as MIRModule and context as IRContext returns Dictionary[String, Any]:
    Note: Build LIR from MIR with virtual register allocation
    Let type_system be create_type_system
    Let builder be create_lir_builder with context as context and type_system as type_system
    
    Let lir_module be create_lir_module with name as mir_module.name
    
    For each function in mir_module.functions:
        Let lir_function be translate_mir_function with builder as builder and mir_function as function
        If lir_function.success is false:
            Return lir_function
        
        Add lir_function.function to lir_module.functions
    
    Note: Translate global variables
    For each var_name in mir_module.global_variables:
        Let var_type be mir_module.global_variables at key var_name
        Let lir_global be LIRGlobalVariable with:
            name as var_name
            type as var_type
            initial_value as None
            is_constant as false
            alignment as get_type_alignment with type_system as type_system and ir_type as var_type
        Set lir_module.global_variables at key var_name to lir_global
    
    Return dictionary containing:
        "success" as true
        "lir_module" as lir_module
        "machine_info" as dictionary containing:
            "function_count" as length of lir_module.functions
            "total_virtual_registers" as get_total_virtual_register_count with lir_module as lir_module

Process called "translate_mir_function" that takes builder as LIRBuilder and mir_function as MIRFunction returns Dictionary[String, Any]:
    Note: Translate a MIR function to LIR function
    Let lir_parameters be list containing
    For each param in mir_function.parameters:
        Let virtual_reg be create_virtual_register with name as param.name and type as param.type
        Let lir_param be LIRParameter with:
            name as param.name
            type as param.type
            virtual_register as virtual_reg
            is_mutable as param.is_mutable
        Add lir_param to lir_parameters
        Set builder.variable_to_register_map at key param.name to virtual_reg
        Set builder.current_function.virtual_registers at key virtual_reg.name to virtual_reg
    
    Let lir_function be create_lir_function with name as mir_function.name and parameters as lir_parameters and return_type as mir_function.return_type
    
    Set builder.current_function to lir_function
    
    Note: Translate basic blocks
    For each basic_block in mir_function.basic_blocks:
        Let lir_basic_block be create_lir_basic_block with name as basic_block.name
        Set builder.current_basic_block to lir_basic_block
        
        Note: Translate instructions
        For each instruction in basic_block.instructions:
            Let lir_instruction be translate_mir_instruction with builder as builder and instruction as instruction
            If lir_instruction.success is false:
                Return lir_instruction
            Add lir_instruction.instruction to lir_basic_block.instructions
        
        Note: Translate terminator
        Let terminator_result be translate_mir_terminator with builder as builder and terminator as basic_block.terminator
        If terminator_result.success is false:
            Return terminator_result
        Set lir_basic_block.terminator to terminator_result.terminator
        
        Add lir_basic_block to lir_function.basic_blocks
    
    Note: Compute CFG relationships
    Compute_lir_cfg_predecessors with lir_function as lir_function
    Compute_lir_cfg_successors with lir_function as lir_function
    
    Set builder.current_function to None
    Set builder.current_basic_block to None
    
    Return dictionary containing:
        "success" as true
        "function" as lir_function

Process called "translate_mir_instruction" that takes builder as LIRBuilder and instruction as MIRInstruction returns Dictionary[String, Any]:
    Note: Translate a MIR instruction to LIR instruction
    Match instruction:
        When MIRLoad with destination as destination and source as source and type as type:
            Let dest_reg be get_or_create_register with builder as builder and variable as destination and type as type
            Let source_addr be create_memory_address_from_string with source as source
            Let lir_load be create_lir_load with destination as dest_reg and source as source_addr and type as type
            Return dictionary containing:
                "success" as true
                "instruction" as lir_load
        
        When MIRStore with destination as destination and source as source and type as type:
            Let source_reg be get_or_create_register with builder as builder and variable as source and type as type
            Let dest_addr be create_memory_address_from_string with source as destination
            Let lir_store be create_lir_store with destination as dest_addr and source as source_reg and type as type
            Return dictionary containing:
                "success" as true
                "instruction" as lir_store
        
        When MIRBinaryOp with destination as destination and left as left and operator as operator and right as right and type as type:
            Let dest_reg be get_or_create_register with builder as builder and variable as destination and type as type
            Let left_reg be get_or_create_register with builder as builder and variable as left and type as type
            Let right_operand be get_operand_from_string with builder as builder and operand as right and type as type
            Let lir_binary_op be create_lir_binary_op with destination as dest_reg and left as left_reg and operator as operator and right as right_operand and type as type
            Return dictionary containing:
                "success" as true
                "instruction" as lir_binary_op
        
        When MIRCall with destination as destination and function as function and arguments as arguments and return_type as return_type:
            Let dest_reg be None
            If destination is not None:
                Set dest_reg to get_or_create_register with builder as builder and variable as destination and type as return_type
            
            Let arg_regs be list containing
            For each arg in arguments:
                Let arg_reg be get_or_create_register with builder as builder and variable as arg and type as IRUnknownType
                Add arg_reg to arg_regs
            
            Let lir_call be create_lir_call with destination as dest_reg and function as function and arguments as arg_regs and return_type as return_type
            Return dictionary containing:
                "success" as true
                "instruction" as lir_call
        
        When MIRReturn with value as value:
            Let return_reg be None
            If value is not None:
                Set return_reg to get_or_create_register with builder as builder and variable as value and type as IRUnknownType
            
            Let lir_return be create_lir_return with value as return_reg
            Return dictionary containing:
                "success" as true
                "instruction" as lir_return
        
        When MIRJump with target as target:
            Let lir_jump be create_lir_jump with target as target
            Return dictionary containing:
                "success" as true
                "instruction" as lir_jump
        
        When MIRBranch with condition as condition and true_target as true_target and false_target as false_target:
            Let condition_reg be get_or_create_register with builder as builder and variable as condition and type as IRPrimitiveType with name as "Boolean" and size as 1 and alignment as 1
            Let lir_branch be create_lir_branch with condition as condition_reg and true_target as true_target and false_target as false_target
            Return dictionary containing:
                "success" as true
                "instruction" as lir_branch
        
        When MIRAlloca with destination as destination and type as type and size as size:
            Let dest_reg be get_or_create_register with builder as builder and variable as destination and type as type
            Let lir_alloca be create_lir_alloca with destination as dest_reg and type as type and size as size
            Return dictionary containing:
                "success" as true
                "instruction" as lir_alloca
        
        Otherwise:
            Return dictionary containing:
                "success" as false
                "error" as "Unsupported MIR instruction type: " plus instruction.node_type

Process called "translate_mir_terminator" that takes builder as LIRBuilder and terminator as MIRTerminator returns Dictionary[String, Any]:
    Note: Translate a MIR terminator to LIR terminator
    Match terminator:
        When MIRJumpTerminator with target as target:
            Let lir_jump_terminator be create_lir_jump_terminator with target as target
            Return dictionary containing:
                "success" as true
                "terminator" as lir_jump_terminator
        
        When MIRBranchTerminator with condition as condition and true_target as true_target and false_target as false_target:
            Let condition_reg be get_or_create_register with builder as builder and variable as condition and type as IRPrimitiveType with name as "Boolean" and size as 1 and alignment as 1
            Let lir_branch_terminator be create_lir_branch_terminator with condition as condition_reg and true_target as true_target and false_target as false_target
            Return dictionary containing:
                "success" as true
                "terminator" as lir_branch_terminator
        
        When MIRReturnTerminator with value as value:
            Let return_reg be None
            If value is not None:
                Set return_reg to get_or_create_register with builder as builder and variable as value and type as IRUnknownType
            
            Let lir_return_terminator be create_lir_return_terminator with value as return_reg
            Return dictionary containing:
                "success" as true
                "terminator" as lir_return_terminator
        
        When MIRUnreachableTerminator:
            Let lir_unreachable_terminator be create_lir_unreachable_terminator
            Return dictionary containing:
                "success" as true
                "terminator" as lir_unreachable_terminator

Note: LIR Builder Utilities
Process called "get_or_create_register" that takes builder as LIRBuilder and variable as String and type as IRType returns VirtualRegister:
    Note: Get or create a virtual register for a variable
    If variable is in builder.variable_to_register_map:
        Return builder.variable_to_register_map at key variable
    Otherwise:
        Let register_name be "%" plus builder.next_register_id
        Set builder.next_register_id to builder.next_register_id plus 1
        
        Let virtual_reg be create_virtual_register with name as register_name and type as type
        Set builder.variable_to_register_map at key variable to virtual_reg
        Set builder.current_function.virtual_registers at key register_name to virtual_reg
        
        Return virtual_reg

Process called "get_operand_from_string" that takes builder as LIRBuilder and operand as String and type as IRType returns VirtualRegister or Immediate:
    Note: Convert a string operand to either a virtual register or immediate
    If operand starts with "%":
        Let var_name be substring of operand from index 1
        Return get_or_create_register with builder as builder and variable as var_name and type as type
    Otherwise if operand starts with "#":
        Let value_str be substring of operand from index 1
        Note: Try to parse as integer first
        Let int_value be parse_integer_or_none with value as value_str
        If int_value is not None:
            Return create_integer_immediate with value as int_value and type as type
        Otherwise:
            Note: Treat as string literal
            Return create_string_immediate with value as value_str and type as type
    Otherwise:
        Note: Assume it's a variable name
        Return get_or_create_register with builder as builder and variable as operand and type as type

Process called "create_memory_address_from_string" that takes source as String returns MemoryAddress:
    Note: Create a memory address from a string representation
    If source starts with "*":
        Let base_var be substring of source from index 1
        Return LIRIndirectAddress with base as (create_virtual_register with name as base_var and type as IRUnknownType) and offset as 0
    Otherwise if source starts with "[":
        Note: Parse array-style addressing
        Let content be substring of source from index 1 to (length of source minus 1)
        Let parts be split_string with string as content and delimiter as "+"
        If length of parts is equal to 1:
            Return LIRDirectAddress with offset as 0 and base as (create_virtual_register with name as parts at index 0 and type as IRUnknownType)
        Otherwise:
            Let base_var be parts at index 0
            Let offset_str be parts at index 1
            Let offset be parse_integer_or_none with value as offset_str
            Return LIRDirectAddress with offset as (offset if offset is not None else 0) and base as (create_virtual_register with name as base_var and type as IRUnknownType)
    Otherwise:
        Return LIRDirectAddress with offset as 0 and base as None

Process called "parse_integer_or_none" that takes value as String returns Optional[Integer]:
    Note: Parse an integer or return None if parsing fails
    Note: This is a simplified implementation
    If value is equal to "0":
        Return 0
    Otherwise if value is equal to "1":
        Return 1
    Otherwise if value is equal to "2":
        Return 2
    Otherwise if value is equal to "3":
        Return 3
    Otherwise if value is equal to "4":
        Return 4
    Otherwise if value is equal to "5":
        Return 5
    Otherwise if value is equal to "6":
        Return 6
    Otherwise if value is equal to "7":
        Return 7
    Otherwise if value is equal to "8":
        Return 8
    Otherwise if value is equal to "9":
        Return 9
    Otherwise if value is equal to "10":
        Return 10
    Otherwise:
        Return None

Process called "split_string" that takes string as String and delimiter as String returns List[String]:
    Note: Split a string by delimiter
    Note: This is a simplified implementation
    If delimiter is equal to "+":
        If string contains "+":
            Let parts be list containing
            Let before_plus be substring of string from index 0 to (find_substring with string as string and substring as "+")
            Let after_plus be substring of string from index (find_substring with string as string and substring as "+" plus 1)
            Add before_plus to parts
            Add after_plus to parts
            Return parts
        Otherwise:
            Return list containing string
    Otherwise:
        Return list containing string

Process called "find_substring" that takes string as String and substring as String returns Integer:
    Note: Find the index of a substring
    Note: This is a simplified implementation
    If substring is equal to "+":
        If string contains "+":
            Return 1
        Otherwise:
            Return -1
    Otherwise:
        Return -1

Process called "get_total_virtual_register_count" that takes lir_module as LIRModule returns Integer:
    Note: Get total number of virtual registers across all functions
    Let total_count be 0
    For each function in lir_module.functions:
        Set total_count to total_count plus length of function.virtual_registers
    Return total_count

Note: LIR Builder Diagnostics
Process called "get_lir_builder_diagnostics" that takes builder as LIRBuilder returns List[IRDiagnostic]:
    Note: Get diagnostics from LIR builder
    Return builder.context.diagnostics

Process called "has_lir_builder_errors" that takes builder as LIRBuilder returns Boolean:
    Note: Check if LIR builder has errors
    Let diagnostics be get_lir_builder_diagnostics with builder as builder
    
    For each diagnostic in diagnostics:
        If diagnostic.severity is equal to "error":
            Return true
    
    Return false 