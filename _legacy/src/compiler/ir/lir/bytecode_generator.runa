Note: Runa Bytecode Generator
Note: Pure Runa implementation of LIR to bytecode translation
Note: This enables self-hosting by eliminating dependency on Rust FFI

Type BytecodeGenerator is Dictionary with:
    chunk as BytecodeChunk
    constants as List[Any]
    functions as Dictionary[String, Function]
    current_function as String
    current_line as Integer
    labels as Dictionary[String, Integer]
    pending_jumps as List[Tuple[Integer, String]]
    register_slots as Dictionary[String, Integer]

Type BytecodeChunk is Dictionary with:
    code as List[Integer]
    constants as List[Any]
    lines as List[Integer]
    source_locations as List[SourceLocation]

Type Function is Dictionary with:
    name as String
    arity as Integer
    chunk as BytecodeChunk
    upvalues as List[Upvalue]

Type Upvalue is Dictionary with:
    index as Integer
    is_local as Boolean

Type SourceLocation is Dictionary with:
    file as String
    line as Integer
    column as Integer

Type OpCode is:
    | Constant
    | GetLocal
    | SetLocal
    | Add
    | Subtract
    | Multiply
    | Divide
    | Call
    | Return
    | Jump
    | JumpIfFalse
    | JumpIfTrue
    | Equal
    | NotEqual
    | Greater
    | Less
    | And
    | Or
    | Not
    | Negate
    | Pop
    | Null

Type CompilationResult is:
    | Success with bytecode as BytecodeChunk and statistics as Dictionary[String, Any]
    | Failure with error as String

Type TranslationResult is:
    | Success
    | Failure with error as String

Process called "create_bytecode_generator" returns BytecodeGenerator:
    Return BytecodeGenerator with:
        chunk as create_bytecode_chunk
        constants as list containing
        functions as dictionary containing
        current_function as ""
        current_line as 0
        labels as dictionary containing
        pending_jumps as list containing
        register_slots as dictionary containing

Process called "create_bytecode_chunk" returns BytecodeChunk:
    Return BytecodeChunk with:
        code as list containing
        constants as list containing
        lines as list containing
        source_locations as list containing

Process called "translate_lir_to_bytecode" that takes lir_module as LIRModule returns CompilationResult:
    Note: Main entry point for LIR to bytecode translation
    Let generator be create_bytecode_generator
    Let result be translate_lir_module with generator as generator and lir_module as lir_module
    
    Match result:
        When Success with bytecode as bytecode and statistics as statistics:
            Return Success with bytecode as bytecode and statistics as statistics
        When Failure with error as error:
            Return Failure with error as error

Process called "translate_lir_module" that takes generator as BytecodeGenerator and lir_module as LIRModule returns CompilationResult:
    Note: Translate complete LIR module to bytecode
    Let generator be reset_generator with generator as generator
    
    Set generator.chunk.source_locations to list containing create_source_location with:
        file as lir_module.name
        line as 0
        column as 0
    
    For each function in lir_module.functions:
        Let result be translate_lir_function with generator as generator and lir_function as function
        Match result:
            When Failure with error as error:
                Return Failure with error as error
            Otherwise:
                Continue
    
    Let result be resolve_jumps with generator as generator
    Match result:
        When Failure with error as error:
            Return Failure with error as error
        Otherwise:
            Continue
    
    Return Success with bytecode as generator.chunk and statistics as create_compilation_statistics with:
        functions_compiled as length of lir_module.functions
        total_instructions as length of generator.chunk.code
        total_constants as length of generator.constants

Process called "reset_generator" that takes generator as BytecodeGenerator returns BytecodeGenerator:
    Set generator.chunk to create_bytecode_chunk
    Set generator.constants to list containing
    Set generator.functions to dictionary containing
    Set generator.current_function to ""
    Set generator.current_line to 0
    Set generator.labels to dictionary containing
    Set generator.pending_jumps to list containing
    Set generator.register_slots to dictionary containing
    Return generator

Process called "translate_lir_function" that takes generator as BytecodeGenerator and lir_function as LIRFunction returns TranslationResult:
    Note: Translate single LIR function to bytecode
    Set generator.current_function to lir_function.name
    
    Let function_chunk be create_bytecode_chunk
    Let function be Function with:
        name as lir_function.name
        arity as length of lir_function.parameters
        chunk as function_chunk
        upvalues as translate_upvalues with upvalues as lir_function.upvalues
    
    Set generator.functions at key lir_function.name to function
    
    For each basic_block in lir_function.basic_blocks:
        Let result be translate_basic_block with generator as generator and basic_block as basic_block
        Match result:
            When Failure with error as error:
                Return Failure with error as error
            Otherwise:
                Continue
    
    Return Success

Process called "translate_basic_block" that takes generator as BytecodeGenerator and basic_block as LIRBasicBlock returns TranslationResult:
    Note: Translate basic block to bytecode
    Let label_name be basic_block.name
    Set generator.labels at key label_name to length of generator.chunk.code
    
    For each instruction in basic_block.instructions:
        Let result be translate_instruction with generator as generator and instruction as instruction
        Match result:
            When Failure with error as error:
                Return Failure with error as error
            Otherwise:
                Continue
    
    Return Success

Process called "translate_instruction" that takes generator as BytecodeGenerator and instruction as LIRInstruction returns TranslationResult:
    Note: Translate individual LIR instruction to bytecode
    Match instruction:
        When LIRMove with destination as destination and source as source:
            Return translate_move_instruction with generator as generator and destination as destination and source as source
            
        When LIRBinaryOp with destination as destination and left as left and operator as operator and right as right:
            Return translate_binary_op_instruction with generator as generator and destination as destination and left as left and operator as operator and right as right
            
        When LIRUnaryOp with destination as destination and operator as operator and operand as operand:
            Return translate_unary_op_instruction with generator as generator and destination as destination and operator as operator and operand as operand
            
        When LIRCall with destination as destination and function as function and arguments as arguments:
            Return translate_call_instruction with generator as generator and destination as destination and function as function and arguments as arguments
            
        When LIRReturn with value as value:
            Return translate_return_instruction with generator as generator and value as value
            
        When LIRJump with target as target:
            Return translate_jump_instruction with generator as generator and target as target
            
        When LIRBranch with condition as condition and true_target as true_target and false_target as false_target:
            Return translate_branch_instruction with generator as generator and condition as condition and true_target as true_target and false_target as false_target
            
        When LIRLoadConstant with destination as destination and value as value:
            Return translate_load_constant_instruction with generator as generator and destination as destination and value as value
            
        Otherwise:
            Return Failure with error as "Unsupported instruction type"

Process called "translate_move_instruction" that takes generator as BytecodeGenerator and destination as VirtualRegister and source as VirtualRegister returns TranslationResult:
    Note: Translate register-to-register move
    Let source_slot be get_or_allocate_register_slot with generator as generator and register as source
    Let dest_slot be get_or_allocate_register_slot with generator as generator and register as destination
    
    Add (GetLocal as Integer) to generator.chunk.code
    Add source_slot to generator.chunk.code
    Add (SetLocal as Integer) to generator.chunk.code
    Add dest_slot to generator.chunk.code
    
    Return Success

Process called "translate_binary_op_instruction" that takes generator as BytecodeGenerator and destination as VirtualRegister and left as VirtualRegister and operator as String and right as VirtualRegister returns TranslationResult:
    Note: Translate binary operations
    Let left_slot be get_or_allocate_register_slot with generator as generator and register as left
    Let right_slot be get_or_allocate_register_slot with generator as generator and register as right
    Let dest_slot be get_or_allocate_register_slot with generator as generator and register as destination
    
    Add (GetLocal as Integer) to generator.chunk.code
    Add left_slot to generator.chunk.code
    Add (GetLocal as Integer) to generator.chunk.code
    Add right_slot to generator.chunk.code
    
    Let opcode be map_operator_to_opcode with operator as operator
    Add (opcode as Integer) to generator.chunk.code
    
    Add (SetLocal as Integer) to generator.chunk.code
    Add dest_slot to generator.chunk.code
    
    Return Success

Process called "translate_unary_op_instruction" that takes generator as BytecodeGenerator and destination as VirtualRegister and operator as String and operand as VirtualRegister returns TranslationResult:
    Note: Translate unary operations
    Let operand_slot be get_or_allocate_register_slot with generator as generator and register as operand
    Let dest_slot be get_or_allocate_register_slot with generator as generator and register as destination
    
    Add (GetLocal as Integer) to generator.chunk.code
    Add operand_slot to generator.chunk.code
    
    Let opcode be map_unary_operator_to_opcode with operator as operator
    Add (opcode as Integer) to generator.chunk.code
    
    Add (SetLocal as Integer) to generator.chunk.code
    Add dest_slot to generator.chunk.code
    
    Return Success

Process called "translate_call_instruction" that takes generator as BytecodeGenerator and destination as Option[VirtualRegister] and function as String and arguments as List[VirtualRegister] returns TranslationResult:
    Note: Translate function calls
    For each argument in arguments:
        Let slot be get_or_allocate_register_slot with generator as generator and register as argument
        Add (GetLocal as Integer) to generator.chunk.code
        Add slot to generator.chunk.code
    
    Let constant_index be add_constant with generator as generator and value as function
    Add (Constant as Integer) to generator.chunk.code
    Add constant_index to generator.chunk.code
    
    Add (Call as Integer) to generator.chunk.code
    Add length of arguments to generator.chunk.code
    
    If destination is not None:
        Let dest_slot be get_or_allocate_register_slot with generator as generator and register as destination
        Add (SetLocal as Integer) to generator.chunk.code
        Add dest_slot to generator.chunk.code
    Otherwise:
        Add (Pop as Integer) to generator.chunk.code
    
    Return Success

Process called "translate_return_instruction" that takes generator as BytecodeGenerator and value as Option[VirtualRegister] returns TranslationResult:
    Note: Translate return instructions
    If value is not None:
        Let slot be get_or_allocate_register_slot with generator as generator and register as value
        Add (GetLocal as Integer) to generator.chunk.code
        Add slot to generator.chunk.code
    
    Add (Return as Integer) to generator.chunk.code
    
    Return Success

Process called "translate_jump_instruction" that takes generator as BytecodeGenerator and target as String returns TranslationResult:
    Note: Translate unconditional jumps
    Add (Jump as Integer) to generator.chunk.code
    Let jump_address be length of generator.chunk.code
    Add 0 to generator.chunk.code
    Add tuple containing jump_address and target to generator.pending_jumps
    
    Return Success

Process called "translate_branch_instruction" that takes generator as BytecodeGenerator and condition as VirtualRegister and true_target as String and false_target as String returns TranslationResult:
    Note: Translate conditional branches
    Let condition_slot be get_or_allocate_register_slot with generator as generator and register as condition
    Add (GetLocal as Integer) to generator.chunk.code
    Add condition_slot to generator.chunk.code
    
    Add (JumpIfFalse as Integer) to generator.chunk.code
    Let false_jump_address be length of generator.chunk.code
    Add 0 to generator.chunk.code
    Add tuple containing false_jump_address and false_target to generator.pending_jumps
    
    Add (Jump as Integer) to generator.chunk.code
    Let true_jump_address be length of generator.chunk.code
    Add 0 to generator.chunk.code
    Add tuple containing true_jump_address and true_target to generator.pending_jumps
    
    Return Success

Process called "translate_load_constant_instruction" that takes generator as BytecodeGenerator and destination as VirtualRegister and value as String returns TranslationResult:
    Note: Translate constant loading
    Let constant_index be add_constant with generator as generator and value as value
    Let dest_slot be get_or_allocate_register_slot with generator as generator and register as destination
    
    Add (Constant as Integer) to generator.chunk.code
    Add constant_index to generator.chunk.code
    Add (SetLocal as Integer) to generator.chunk.code
    Add dest_slot to generator.chunk.code
    
    Return Success

Process called "resolve_jumps" that takes generator as BytecodeGenerator returns TranslationResult:
    Note: Resolve all pending jumps
    For each pending_jump in generator.pending_jumps:
        Let jump_address be pending_jump at index 0
        Let target_label be pending_jump at index 1
        
        If target_label is in generator.labels:
            Let target_address be generator.labels at key target_label
            Set generator.chunk.code at index (jump_address plus 1) to target_address
        Otherwise:
            Return Failure with error as "Undefined label: " plus target_label
    
    Return Success

Process called "add_constant" that takes generator as BytecodeGenerator and value as Any returns Integer:
    Note: Add constant to constant pool
    For each constant in generator.constants:
        If constant equals value:
            Return index of constant in generator.constants
    
    Add value to generator.constants
    Return length of generator.constants minus 1

Process called "get_or_allocate_register_slot" that takes generator as BytecodeGenerator and register as VirtualRegister returns Integer:
    Note: Get or allocate register slot with overflow protection
    Let register_name be register.name
    
    If register_name is in generator.register_slots:
        Return generator.register_slots at key register_name
    
    Let slot be length of generator.register_slots
    If slot is greater than 255:
        Throw "Too many local variables in function: " plus generator.current_function
    
    Set generator.register_slots at key register_name to slot
    Return slot

Process called "map_operator_to_opcode" that takes operator as String returns OpCode:
    Note: Map operator strings to opcodes
    Match operator:
        When "add":
            Return Add
        When "subtract":
            Return Subtract
        When "multiply":
            Return Multiply
        When "divide":
            Return Divide
        When "equal":
            Return Equal
        When "not_equal":
            Return NotEqual
        When "greater":
            Return Greater
        When "less":
            Return Less
        When "and":
            Return And
        When "or":
            Return Or
        Otherwise:
            Return Add

Process called "map_unary_operator_to_opcode" that takes operator as String returns OpCode:
    Note: Map unary operator strings to opcodes
    Match operator:
        When "not":
            Return Not
        When "negate":
            Return Negate
        Otherwise:
            Return Not

Process called "translate_upvalues" that takes upvalues as List[LIRUpvalue] returns List[Upvalue]:
    Note: Translate LIR upvalues to bytecode upvalues
    Let result be list containing
    
    For each upvalue in upvalues:
        Add Upvalue with:
            index as upvalue.index
            is_local as upvalue.is_local
        to result
    
    Return result

Process called "create_source_location" that takes file as String and line as Integer and column as Integer returns SourceLocation:
    Return SourceLocation with:
        file as file
        line as line
        column as column

Process called "create_compilation_statistics" that takes functions_compiled as Integer and total_instructions as Integer and total_constants as Integer returns Dictionary[String, Any]:
    Return dictionary containing:
        "functions_compiled" as functions_compiled
        "total_instructions" as total_instructions
        "total_constants" as total_constants
        "compilation_time_ms" as 0 