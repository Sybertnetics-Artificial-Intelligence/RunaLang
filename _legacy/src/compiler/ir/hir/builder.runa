Note: Runa Compiler: HIR Builder
Note: AST to HIR translator with semantic analysis and type inference

Import "hir.runa"
Import "../types/types.runa"
Import "../ir_context.runa"
Import "../../parser/ast.runa"

Note: HIR Builder - AST to HIR Translation with Semantic Analysis
Type HIRBuilder is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    current_scope as String
    symbol_resolver as SymbolResolver
    type_inferrer as TypeInferrer
    metadata as Dictionary[String, Any]

Type SymbolResolver is Dictionary with:
    context as IRContext
    current_scope as String

Type TypeInferrer is Dictionary with:
    type_system as TypeSystem
    context as IRContext

Process called "create_hir_builder" that takes context as IRContext and type_system as TypeSystem returns HIRBuilder:
    Note: Create a new HIR builder
    Let symbol_resolver be SymbolResolver with:
        context as context
        current_scope as "global"
    
    Let type_inferrer be TypeInferrer with:
        type_system as type_system
        context as context
    
    Return HIRBuilder with:
        context as context
        type_system as type_system
        current_scope as "global"
        symbol_resolver as symbol_resolver
        type_inferrer as type_inferrer
        metadata as dictionary containing

Process called "build_hir_from_ast" that takes ast as ASTNode and context as IRContext returns Dictionary[String, Any]:
    Note: Build HIR from AST with semantic analysis
    Let type_system be create_type_system
    Let builder be create_hir_builder with context as context and type_system as type_system
    
    Let hir_module be create_hir_module with name as "main"
    
    Let result be translate_ast_node with builder as builder and node as ast and target_module as hir_module
    
    If result.success is false:
        Return result
    
    Set hir_module.scope_tree to context.scope_stack
    Set hir_module.symbol_table to context.symbol_table
    Set hir_module.type_table to context.type_table
    
    Return dictionary containing:
        "success" as true
        "hir_module" as hir_module
        "semantic_info" as dictionary containing:
            "symbol_count" as get_context_statistics with context as context
            "type_count" as get_type_system_statistics with type_system as type_system
            "diagnostics" as context.diagnostics

Process called "translate_ast_node" that takes builder as HIRBuilder and node as ASTNode and target_module as HIRModule returns Dictionary[String, Any]:
    Note: Translate an AST node to HIR
    Match node:
        When Expression with expression_type as expression_type:
            Let hir_expr be translate_expression with builder as builder and expression as node
            If hir_expr.success is false:
                Return hir_expr
            
            Add HIRExpressionStatement with expression as hir_expr.expression to target_module.statements
            
            Return dictionary containing:
                "success" as true
                "hir_node" as hir_expr.expression
        
        When Statement with statement_type as statement_type:
            Let hir_stmt be translate_statement with builder as builder and statement as node
            If hir_stmt.success is false:
                Return hir_stmt
            
            Add hir_stmt.statement to target_module.statements
            
            Return dictionary containing:
                "success" as true
                "hir_node" as hir_stmt.statement
        
        When Declaration with declaration_type as declaration_type:
            Let hir_decl be translate_declaration with builder as builder and declaration as node
            If hir_decl.success is false:
                Return hir_decl
            
            Add hir_decl.declaration to target_module.declarations
            
            Return dictionary containing:
                "success" as true
                "hir_node" as hir_decl.declaration
        
        Otherwise:
            Return dictionary containing:
                "success" as false
                "error" as "Unknown AST node type: " plus node.node_type

Process called "translate_expression" that takes builder as HIRBuilder and expression as Expression returns Dictionary[String, Any]:
    Note: Translate an AST expression to HIR expression
    Match expression:
        When Literal with value as value and literal_type as literal_type and location as location:
            Let ir_type be infer_literal_type with type_system as builder.type_system and value as value and literal_type as literal_type
            Let hir_literal be create_hir_literal with value as value and literal_type as literal_type and inferred_type as ir_type and location as location
            Return dictionary containing:
                "success" as true
                "expression" as hir_literal
        
        When Identifier with name as name and location as location:
            Let resolved_symbol be resolve_symbol with builder as builder and name as name
            Let ir_type be infer_identifier_type with builder as builder and name as name
            Let hir_identifier be create_hir_identifier with name as name and resolved_symbol as resolved_symbol and inferred_type as ir_type and location as location
            Return dictionary containing:
                "success" as true
                "expression" as hir_identifier
        
        When BinaryOperation with left as left and operator as operator and right as right and location as location:
            Let left_result be translate_expression with builder as builder and expression as left
            If left_result.success is false:
                Return left_result
            
            Let right_result be translate_expression with builder as builder and expression as right
            If right_result.success is false:
                Return right_result
            
            Let ir_type be infer_binary_operation_type with builder as builder and left_type as get_hir_inferred_type with node as left_result.expression and operator as operator and right_type as get_hir_inferred_type with node as right_result.expression
            Let hir_binary_op be create_hir_binary_operation with left as left_result.expression and operator as operator and right as right_result.expression and inferred_type as ir_type and location as location
            Return dictionary containing:
                "success" as true
                "expression" as hir_binary_op
        
        When FunctionCall with function as function and arguments as arguments and location as location:
            Let function_result be translate_expression with builder as builder and expression as function
            If function_result.success is false:
                Return function_result
            
            Let translated_args be list containing
            For each arg in arguments:
                Let arg_result be translate_expression with builder as builder and expression as arg
                If arg_result.success is false:
                    Return arg_result
                Add arg_result.expression to translated_args
            
            Let ir_type be infer_function_call_type with builder as builder and function_type as get_hir_inferred_type with node as function_result.expression and arguments as translated_args
            Let hir_function_call be create_hir_function_call with function as function_result.expression and arguments as translated_args and inferred_type as ir_type and location as location
            Return dictionary containing:
                "success" as true
                "expression" as hir_function_call
        
        Otherwise:
            Return dictionary containing:
                "success" as false
                "error" as "Unsupported expression type: " plus expression.node_type

Process called "translate_statement" that takes builder as HIRBuilder and statement as Statement returns Dictionary[String, Any]:
    Note: Translate an AST statement to HIR statement
    Match statement:
        When VariableDeclaration with name as name and type_annotation as type_annotation and initializer as initializer and is_mutable as is_mutable and location as location:
            Let ir_type_annotation be None
            If type_annotation is not None:
                Let type_result be translate_type_expression with builder as builder and type_expr as type_annotation
                If type_result.success is false:
                    Return type_result
                Set ir_type_annotation to type_result.ir_type
            
            Let hir_initializer be None
            If initializer is not None:
                Let init_result be translate_expression with builder as builder and expression as initializer
                If init_result.success is false:
                    Return init_result
                Set hir_initializer to init_result.expression
            
            Let hir_var_decl be create_hir_variable_declaration with name as name and type_annotation as ir_type_annotation and initializer as hir_initializer and is_mutable as is_mutable and location as location
            
            Note: Add to symbol table
            Let symbol be Symbol with:
                name as name
                type as (ir_type_annotation if ir_type_annotation is not None else IRUnknownType)
                kind as Variable
                location as location
                is_mutable as is_mutable
                is_exported as false
                metadata as dictionary containing
            
            Let add_result be add_symbol with context as builder.context and symbol as symbol
            If add_result is false:
                Add_error with context as builder.context and message as "Symbol already defined: " plus name and location as location
            
            Return dictionary containing:
                "success" as true
                "statement" as hir_var_decl
        
        When IfStatement with condition as condition and then_block as then_block and else_block as else_block and location as location:
            Let condition_result be translate_expression with builder as builder and expression as condition
            If condition_result.success is false:
                Return condition_result
            
            Let then_statements be list containing
            For each stmt in then_block:
                Let stmt_result be translate_statement with builder as builder and statement as stmt
                If stmt_result.success is false:
                    Return stmt_result
                Add stmt_result.statement to then_statements
            
            Let else_statements be None
            If else_block is not None:
                Set else_statements to list containing
                For each stmt in else_block:
                    Let stmt_result be translate_statement with builder as builder and statement as stmt
                    If stmt_result.success is false:
                        Return stmt_result
                    Add stmt_result.statement to else_statements
            
            Let hir_if_stmt be HIRIfStatement with condition as condition_result.expression and then_block as then_statements and else_block as else_statements
            Return dictionary containing:
                "success" as true
                "statement" as hir_if_stmt
        
        Otherwise:
            Return dictionary containing:
                "success" as false
                "error" as "Unsupported statement type: " plus statement.node_type

Process called "translate_declaration" that takes builder as HIRBuilder and declaration as Declaration returns Dictionary[String, Any]:
    Note: Translate an AST declaration to HIR declaration
    Match declaration:
        When ProcessDeclaration with name as name and parameters as parameters and return_type as return_type and body as body and is_function as is_function and location as location:
            Note: Enter function scope
            Enter_scope with context as builder.context and name as name and kind as Function and location as location
            Set builder.current_scope to name
            
            Let hir_parameters be list containing
            For each param in parameters:
                Let ir_param_type be None
                If param.type_annotation is not None:
                    Let type_result be translate_type_expression with builder as builder and type_expr as param.type_annotation
                    If type_result.success is false:
                        Return type_result
                    Set ir_param_type to type_result.ir_type
                
                Let hir_param be HIRParameter with:
                    name as param.name
                    type_annotation as ir_param_type
                    default_value as None
                    is_mutable as param.is_mutable
                
                Add hir_param to hir_parameters
                
                Note: Add parameter to symbol table
                Let param_symbol be Symbol with:
                    name as param.name
                    type as (ir_param_type if ir_param_type is not None else IRUnknownType)
                    kind as Parameter
                    location as param.location
                    is_mutable as param.is_mutable
                    is_exported as false
                    metadata as dictionary containing
                
                Add_symbol with context as builder.context and symbol as param_symbol
            
            Let ir_return_type be None
            If return_type is not None:
                Let return_type_result be translate_type_expression with builder as builder and type_expr as return_type
                If return_type_result.success is false:
                    Return return_type_result
                Set ir_return_type to return_type_result.ir_type
            
            Let hir_body be list containing
            For each stmt in body:
                Let stmt_result be translate_statement with builder as builder and statement as stmt
                If stmt_result.success is false:
                    Return stmt_result
                Add stmt_result.statement to hir_body
            
            Note: Exit function scope
            Exit_scope with context as builder.context
            Set builder.current_scope to "global"
            
            Let hir_process_decl be create_hir_process_declaration with name as name and parameters as hir_parameters and return_type as ir_return_type and body as hir_body and is_function as is_function and location as location
            
            Note: Add function to symbol table
            Let function_symbol be Symbol with:
                name as name
                type as IRFunctionType with parameters as (map parameter types from hir_parameters) and return_type as (ir_return_type if ir_return_type is not None else IRUnknownType) and is_variadic as false
                kind as Function
                location as location
                is_mutable as false
                is_exported as false
                metadata as dictionary containing
            
            Add_symbol with context as builder.context and symbol as function_symbol
            
            Return dictionary containing:
                "success" as true
                "declaration" as hir_process_decl
        
        Otherwise:
            Return dictionary containing:
                "success" as false
                "error" as "Unsupported declaration type: " plus declaration.node_type

Note: Symbol Resolution
Process called "resolve_symbol" that takes builder as HIRBuilder and name as String returns Optional[String]:
    Note: Resolve a symbol name to its canonical identifier
    Let symbol be lookup_symbol with context as builder.context and name as name
    If symbol is not None:
        Return symbol.name
    Otherwise:
        Return None

Note: Type Inference
Process called "infer_literal_type" that takes type_system as TypeSystem and value as Any and literal_type as String returns IRType:
    Note: Infer type from literal value
    Match literal_type:
        When "integer":
            Return IRPrimitiveType with name as "Integer" and size as 8 and alignment as 8
        When "float":
            Return IRPrimitiveType with name as "Float" and size as 8 and alignment as 8
        When "string":
            Return IRPrimitiveType with name as "String" and size as 16 and alignment as 8
        When "boolean":
            Return IRPrimitiveType with name as "Boolean" and size as 1 and alignment as 1
        Otherwise:
            Return IRUnknownType

Process called "infer_identifier_type" that takes builder as HIRBuilder and name as String returns IRType:
    Note: Infer type from identifier
    Let symbol be lookup_symbol with context as builder.context and name as name
    If symbol is not None:
        Return symbol.type
    Otherwise:
        Return IRUnknownType

Process called "infer_binary_operation_type" that takes builder as HIRBuilder and left_type as IRType and operator as String and right_type as IRType returns IRType:
    Note: Infer type from binary operation
    Match operator:
        When "plus", "minus", "multiplied by", "divided by":
            If left_type is IRPrimitiveType with name as "Integer" and right_type is IRPrimitiveType with name as "Integer":
                Return IRPrimitiveType with name as "Integer" and size as 8 and alignment as 8
            Otherwise if left_type is IRPrimitiveType with name as "Float" or right_type is IRPrimitiveType with name as "Float":
                Return IRPrimitiveType with name as "Float" and size as 8 and alignment as 8
            Otherwise if left_type is IRPrimitiveType with name as "String" and right_type is IRPrimitiveType with name as "String":
                Return IRPrimitiveType with name as "String" and size as 16 and alignment as 8
            Otherwise:
                Return IRUnknownType
        When "is equal to", "is not equal to", "is greater than", "is less than":
            Return IRPrimitiveType with name as "Boolean" and size as 1 and alignment as 1
        Otherwise:
            Return IRUnknownType

Process called "infer_function_call_type" that takes builder as HIRBuilder and function_type as IRType and arguments as List[HIRExpression] returns IRType:
    Note: Infer type from function call
    Match function_type:
        When IRFunctionType with parameters as parameters and return_type as return_type and is_variadic as is_variadic:
            Return return_type
        Otherwise:
            Return IRUnknownType

Note: Type Translation
Process called "translate_type_expression" that takes builder as HIRBuilder and type_expr as TypeExpression returns Dictionary[String, Any]:
    Note: Translate AST type expression to IR type
    Match type_expr:
        When SimpleType with name as name:
            Let ir_type be lookup_type with type_system as builder.type_system and name as name
            If ir_type is not None:
                Return dictionary containing:
                    "success" as true
                    "ir_type" as ir_type
            Otherwise:
                Return dictionary containing:
                    "success" as false
                    "error" as "Unknown type: " plus name
        Otherwise:
            Return dictionary containing:
                "success" as false
                "error" as "Unsupported type expression: " plus type_expr.node_type

Note: HIR Builder Diagnostics
Process called "get_hir_builder_diagnostics" that takes builder as HIRBuilder returns List[IRDiagnostic]:
    Note: Get diagnostics from HIR builder
    Return builder.context.diagnostics

Process called "has_hir_builder_errors" that takes builder as HIRBuilder returns Boolean:
    Note: Check if HIR builder has errors
    Let diagnostics be get_hir_builder_diagnostics with builder as builder
    
    For each diagnostic in diagnostics:
        If diagnostic.severity is equal to "error":
            Return true
    
    Return false 