Note: Runa Compiler: IR Context Management
Note: Central context object that holds all IR for a compilation unit

Import "../parser/ast.runa"
Import "types/types.runa"

Note: IR Context - Central Compilation State
Type IRContext is Dictionary with:
    compilation_unit as String
    source_file as String
    type_system as TypeSystem
    symbol_table as SymbolTable
    type_table as TypeTable
    scope_stack as List[Scope]
    current_function as Optional[String]
    current_module as Optional[String]
    diagnostics as List[IRDiagnostic]
    optimization_level as Integer
    debug_info as Boolean
    target_platform as String
    metadata as Dictionary[String, Any]

Note: Symbol Table Management
Type SymbolTable is Dictionary with:
    symbols as Dictionary[String, Symbol]
    parent as Optional[SymbolTable]
    scope_level as Integer

Type Symbol is Dictionary with:
    name as String
    type as IRType
    kind as SymbolKind
    location as SourceLocation
    is_mutable as Boolean
    is_exported as Boolean
    metadata as Dictionary[String, Any]

Type SymbolKind is:
    | Variable
    | Function
    | Type
    | Module
    | Parameter
    | Constant

Note: Type Table Management
Type TypeTable is Dictionary with:
    types as Dictionary[String, IRType]
    parent as Optional[TypeTable]
    scope_level as Integer

Note: Scope Management
Type Scope is Dictionary with:
    name as String
    kind as ScopeKind
    symbol_table as SymbolTable
    type_table as TypeTable
    parent as Optional[Scope]
    children as List[Scope]
    location as SourceLocation

Type ScopeKind is:
    | Global
    | Module
    | Function
    | Block
    | Loop
    | Match

Process called "create_ir_context" that takes compilation_unit as String and source_file as String returns IRContext:
    Note: Create a new IR context for compilation
    Let type_system be create_type_system
    Let global_symbol_table be create_symbol_table with parent as None and scope_level as 0
    Let global_type_table be create_type_table with parent as None and scope_level as 0
    Let global_scope be create_scope with name as "global" and kind as Global and symbol_table as global_symbol_table and type_table as global_type_table and parent as None and location as SourceLocation with line as 0 and column as 0 and file as source_file and length as 0
    
    Let scope_stack be list containing global_scope
    
    Return IRContext with:
        compilation_unit as compilation_unit
        source_file as source_file
        type_system as type_system
        symbol_table as global_symbol_table
        type_table as global_type_table
        scope_stack as scope_stack
        current_function as None
        current_module as None
        diagnostics as list containing
        optimization_level as 1
        debug_info as false
        target_platform as "generic"
        metadata as dictionary containing

Process called "create_ir_context_with_type_system" that takes compilation_unit as String and source_file as String and type_system as TypeSystem returns IRContext:
    Note: Create a new IR context with a specific type system
    Let global_symbol_table be create_symbol_table with parent as None and scope_level as 0
    Let global_type_table be create_type_table with parent as None and scope_level as 0
    Let global_scope be create_scope with name as "global" and kind as Global and symbol_table as global_symbol_table and type_table as global_type_table and parent as None and location as SourceLocation with line as 0 and column as 0 and file as source_file and length as 0
    
    Let scope_stack be list containing global_scope
    
    Return IRContext with:
        compilation_unit as compilation_unit
        source_file as source_file
        type_system as type_system
        symbol_table as global_symbol_table
        type_table as global_type_table
        scope_stack as scope_stack
        current_function as None
        current_module as None
        diagnostics as list containing
        optimization_level as 1
        debug_info as false
        target_platform as "generic"
        metadata as dictionary containing

Process called "create_symbol_table" that takes parent as Optional[SymbolTable] and scope_level as Integer returns SymbolTable:
    Note: Create a new symbol table
    Return SymbolTable with:
        symbols as dictionary containing
        parent as parent
        scope_level as scope_level

Process called "create_type_table" that takes parent as Optional[TypeTable] and scope_level as Integer returns TypeTable:
    Note: Create a new type table
    Return TypeTable with:
        types as dictionary containing
        parent as parent
        scope_level as scope_level

Process called "create_scope" that takes name as String and kind as ScopeKind and symbol_table as SymbolTable and type_table as TypeTable and parent as Optional[Scope] and location as SourceLocation returns Scope:
    Note: Create a new scope
    Return Scope with:
        name as name
        kind as kind
        symbol_table as symbol_table
        type_table as type_table
        parent as parent
        children as list containing
        location as location

Note: Symbol Table Operations
Process called "add_symbol" that takes context as IRContext and symbol as Symbol returns Boolean:
    Note: Add a symbol to the current symbol table
    Let current_table be context.symbol_table
    
    If symbol.name is in current_table.symbols:
        Return false
    
    Set current_table.symbols at key symbol.name to symbol
    Return true

Process called "lookup_symbol" that takes context as IRContext and name as String returns Optional[Symbol]:
    Note: Look up a symbol in the symbol table hierarchy
    Let current_table be context.symbol_table
    
    While current_table is not None:
        If name is in current_table.symbols:
            Return current_table.symbols at key name
        
        Set current_table to current_table.parent
    
    Return None

Process called "lookup_symbol_in_scope" that takes context as IRContext and name as String and scope_name as String returns Optional[Symbol]:
    Note: Look up a symbol in a specific scope
    Let target_scope be find_scope_by_name with context as context and name as scope_name
    
    If target_scope is None:
        Return None
    
    If name is in target_scope.symbol_table.symbols:
        Return target_scope.symbol_table.symbols at key name
    
    Return None

Process called "remove_symbol" that takes context as IRContext and name as String returns Boolean:
    Note: Remove a symbol from the current symbol table
    Let current_table be context.symbol_table
    
    If name is not in current_table.symbols:
        Return false
    
    Remove name from current_table.symbols
    Return true

Note: Type Table Operations
Process called "add_type" that takes context as IRContext and type_name as String and ir_type as IRType returns Boolean:
    Note: Add a type to the current type table
    Let current_table be context.type_table
    
    If type_name is in current_table.types:
        Return false
    
    Set current_table.types at key type_name to ir_type
    Return true

Process called "lookup_type" that takes context as IRContext and type_name as String returns Optional[IRType]:
    Note: Look up a type in the type table hierarchy
    Let current_table be context.type_table
    
    While current_table is not None:
        If type_name is in current_table.types:
            Return current_table.types at key type_name
        
        Set current_table to current_table.parent
    
    Return None

Process called "remove_type" that takes context as IRContext and type_name as String returns Boolean:
    Note: Remove a type from the current type table
    Let current_table be context.type_table
    
    If type_name is not in current_table.types:
        Return false
    
    Remove type_name from current_table.types
    Return true

Note: Scope Management Operations
Process called "enter_scope" that takes context as IRContext and name as String and kind as ScopeKind and location as SourceLocation:
    Note: Enter a new scope
    Let current_scope be (context.scope_stack at index (length of context.scope_stack minus 1))
    
    Let new_symbol_table be create_symbol_table with parent as current_scope.symbol_table and scope_level as (current_scope.symbol_table.scope_level plus 1)
    Let new_type_table be create_type_table with parent as current_scope.type_table and scope_level as (current_scope.type_table.scope_level plus 1)
    
    Let new_scope be create_scope with name as name and kind as kind and symbol_table as new_symbol_table and type_table as new_type_table and parent as current_scope and location as location
    
    Add new_scope to current_scope.children
    Add new_scope to context.scope_stack
    
    Set context.symbol_table to new_symbol_table
    Set context.type_table to new_type_table

Process called "exit_scope" that takes context as IRContext:
    Note: Exit the current scope
    If length of context.scope_stack is less than or equal to 1:
        Return
    
    Remove the last element from context.scope_stack
    
    Let new_current_scope be (context.scope_stack at index (length of context.scope_stack minus 1))
    Set context.symbol_table to new_current_scope.symbol_table
    Set context.type_table to new_current_scope.type_table

Process called "get_current_scope" that takes context as IRContext returns Scope:
    Note: Get the current scope
    Return context.scope_stack at index (length of context.scope_stack minus 1)

Process called "find_scope_by_name" that takes context as IRContext and name as String returns Optional[Scope]:
    Note: Find a scope by name in the scope hierarchy
    Let current_scope be get_current_scope with context as context
    
    While current_scope is not None:
        If current_scope.name is equal to name:
            Return current_scope
        
        Set current_scope to current_scope.parent
    
    Return None

Process called "get_scope_chain" that takes context as IRContext returns List[Scope]:
    Note: Get the current scope chain from global to current
    Let chain be list containing
    Let current_scope be get_current_scope with context as context
    
    While current_scope is not None:
        Add current_scope to chain at index 0
        Set current_scope to current_scope.parent
    
    Return chain

Note: Context Diagnostics
Process called "add_diagnostic" that takes context as IRContext and diagnostic as IRDiagnostic:
    Note: Add a diagnostic to the context
    Add diagnostic to context.diagnostics

Process called "add_error" that takes context as IRContext and message as String and location as Optional[SourceLocation]:
    Note: Add an error diagnostic
    Let error be IRDiagnostic with:
        level as "error"
        message as message
        location as location
        ir_level as HIR
        severity as "error"
        suggestions as list containing
    
    Add error to context.diagnostics

Process called "add_warning" that takes context as IRContext and message as String and location as Optional[SourceLocation]:
    Note: Add a warning diagnostic
    Let warning be IRDiagnostic with:
        level as "warning"
        message as message
        location as location
        ir_level as HIR
        severity as "warning"
        suggestions as list containing
    
    Add warning to context.diagnostics

Process called "add_info" that takes context as IRContext and message as String and location as Optional[SourceLocation]:
    Note: Add an info diagnostic
    Let info be IRDiagnostic with:
        level as "info"
        message as message
        location as location
        ir_level as HIR
        severity as "info"
        suggestions as list containing
    
    Add info to context.diagnostics

Note: Context Metadata
Process called "set_metadata" that takes context as IRContext and key as String and value as Any:
    Note: Set metadata in the context
    Set context.metadata at key key to value

Process called "get_metadata" that takes context as IRContext and key as String returns Optional[Any]:
    Note: Get metadata from the context
    If key is in context.metadata:
        Return context.metadata at key key
    Otherwise:
        Return None

Process called "has_metadata" that takes context as IRContext and key as String returns Boolean:
    Note: Check if metadata exists in the context
    Return key is in context.metadata

Note: Context Statistics
Process called "get_context_statistics" that takes context as IRContext returns Dictionary[String, Any]:
    Note: Get statistics about the context
    Let symbol_count be 0
    Let type_count be 0
    Let scope_count be length of context.scope_stack
    Let error_count be 0
    Let warning_count be 0
    
    Let current_table be context.symbol_table
    While current_table is not None:
        Set symbol_count to symbol_count plus length of current_table.symbols
        Set current_table to current_table.parent
    
    Let current_type_table be context.type_table
    While current_type_table is not None:
        Set type_count to type_count plus length of current_type_table.types
        Set current_type_table to current_type_table.parent
    
    For each diagnostic in context.diagnostics:
        If diagnostic.severity is equal to "error":
            Set error_count to error_count plus 1
        Otherwise if diagnostic.severity is equal to "warning":
            Set warning_count to warning_count plus 1
    
    Return dictionary containing:
        "symbol_count" as symbol_count
        "type_count" as type_count
        "scope_count" as scope_count
        "error_count" as error_count
        "warning_count" as warning_count
        "diagnostic_count" as length of context.diagnostics 