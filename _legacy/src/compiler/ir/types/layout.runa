Note: Runa Compiler: IR Type Layout System
Note: Cross-platform memory layout calculations

Import "types.runa"

Note: Layout System - Cross-Platform Memory Layout
Type LayoutInfo is Dictionary with:
    size as Integer
    alignment as Integer
    field_offsets as Dictionary[String, Integer]
    padding_info as List[PaddingInfo]
    is_packed as Boolean
    platform as String

Type PaddingInfo is Dictionary with:
    offset as Integer
    size as Integer
    reason as String

Type LayoutStrategy is:
    | NaturalAlignment
    | PackedAlignment
    | PlatformSpecific with platform as String

Process called "calculate_layout" that takes type_system as TypeSystem and ir_type as IRType and strategy as LayoutStrategy returns LayoutInfo:
    Note: Calculate memory layout for a type
    Match ir_type:
        When IRPrimitiveType with name as name and size as size and alignment as alignment:
            Return LayoutInfo with:
                size as size
                alignment as alignment
                field_offsets as dictionary containing
                padding_info as list containing
                is_packed as false
                platform as "generic"
        
        When IRPointerType with pointee as pointee and is_mutable as is_mutable:
            Return LayoutInfo with:
                size as 8
                alignment as 8
                field_offsets as dictionary containing
                padding_info as list containing
                is_packed as false
                platform as "generic"
        
        When IRArrayType with element_type as element_type and length as length:
            Let element_layout be calculate_layout with type_system as type_system and ir_type as element_type and strategy as strategy
            Let total_size be element_layout.size multiplied by (length if length is not None else 0)
            Return LayoutInfo with:
                size as total_size
                alignment as element_layout.alignment
                field_offsets as dictionary containing
                padding_info as list containing
                is_packed as element_layout.is_packed
                platform as element_layout.platform
        
        When IRStructType with name as name and fields as fields and size as size and alignment as alignment:
            Return calculate_struct_layout with type_system as type_system and fields as fields and strategy as strategy
        
        When IRUnionType with name as name and variants as variants and size as size and alignment as alignment:
            Return calculate_union_layout with type_system as type_system and variants as variants and strategy as strategy
        
        When IRFunctionType with parameters as parameters and return_type as return_type and is_variadic as is_variadic:
            Return LayoutInfo with:
                size as 8
                alignment as 8
                field_offsets as dictionary containing
                padding_info as list containing
                is_packed as false
                platform as "generic"
        
        Otherwise:
            Return LayoutInfo with:
                size as 0
                alignment as 1
                field_offsets as dictionary containing
                padding_info as list containing
                is_packed as false
                platform as "generic"

Process called "calculate_struct_layout" that takes type_system as TypeSystem and fields as List[IRField] and strategy as LayoutStrategy returns LayoutInfo:
    Note: Calculate layout for a struct type
    Let field_offsets be dictionary containing
    Let padding_info be list containing
    Let current_offset be 0
    Let max_alignment be 1
    
    For each field in fields:
        Let field_layout be calculate_layout with type_system as type_system and ir_type as field.type and strategy as strategy
        
        Match strategy:
            When NaturalAlignment:
                Let aligned_offset be align_offset with offset as current_offset and alignment as field_layout.alignment
                If aligned_offset is not equal to current_offset:
                    Let padding_size be aligned_offset minus current_offset
                    Add PaddingInfo with offset as current_offset and size as padding_size and reason as "alignment" to padding_info
                    Set current_offset to aligned_offset
            When PackedAlignment:
                Note: No alignment padding in packed mode
                Set aligned_offset to current_offset
            When PlatformSpecific with platform as platform:
                Let aligned_offset be align_offset_platform with offset as current_offset and alignment as field_layout.alignment and platform as platform
                If aligned_offset is not equal to current_offset:
                    Let padding_size be aligned_offset minus current_offset
                    Add PaddingInfo with offset as current_offset and size as padding_size and reason as "platform_alignment" to padding_info
                    Set current_offset to aligned_offset
        
        Set field_offsets at key field.name to current_offset
        Set current_offset to current_offset plus field_layout.size
        
        If field_layout.alignment is greater than max_alignment:
            Set max_alignment to field_layout.alignment
    
    Note: Final alignment padding
    Let final_aligned_offset be align_offset with offset as current_offset and alignment as max_alignment
    If final_aligned_offset is not equal to current_offset:
        Let padding_size be final_aligned_offset minus current_offset
        Add PaddingInfo with offset as current_offset and size as padding_size and reason as "final_alignment" to padding_info
        Set current_offset to final_aligned_offset
    
    Return LayoutInfo with:
        size as current_offset
        alignment as max_alignment
        field_offsets as field_offsets
        padding_info as padding_info
        is_packed as (strategy is PackedAlignment)
        platform as (get_platform_name with strategy as strategy)

Process called "calculate_union_layout" that takes type_system as TypeSystem and variants as List[IRVariant] and strategy as LayoutStrategy returns LayoutInfo:
    Note: Calculate layout for a union type
    Let max_size be 0
    Let max_alignment be 1
    Let variant_offsets be dictionary containing
    
    For each variant in variants:
        If variant.type is not None:
            Let variant_layout be calculate_layout with type_system as type_system and ir_type as variant.type and strategy as strategy
            
            Set variant_offsets at key variant.name to 0
            
            If variant_layout.size is greater than max_size:
                Set max_size to variant_layout.size
            
            If variant_layout.alignment is greater than max_alignment:
                Set max_alignment to variant_layout.alignment
        Otherwise:
            Set variant_offsets at key variant.name to 0
    
    Note: Add space for discriminant
    Let discriminant_size be 4
    Let total_size be max_size plus discriminant_size
    
    Return LayoutInfo with:
        size as total_size
        alignment as max_alignment
        field_offsets as variant_offsets
        padding_info as list containing
        is_packed as false
        platform as (get_platform_name with strategy as strategy)

Process called "align_offset" that takes offset as Integer and alignment as Integer returns Integer:
    Note: Align an offset to the specified alignment
    If alignment is equal to 0:
        Return offset
    
    Let remainder be offset modulo alignment
    If remainder is equal to 0:
        Return offset
    Otherwise:
        Return offset plus (alignment minus remainder)

Process called "align_offset_platform" that takes offset as Integer and alignment as Integer and platform as String returns Integer:
    Note: Platform-specific alignment
    Match platform:
        When "x86_64":
            Return align_offset with offset as offset and alignment as alignment
        When "aarch64":
            Return align_offset with offset as offset and alignment as alignment
        When "wasm":
            Return align_offset with offset as offset and alignment as alignment
        Otherwise:
            Return align_offset with offset as offset and alignment as alignment

Process called "get_platform_name" that takes strategy as LayoutStrategy returns String:
    Note: Get platform name from strategy
    Match strategy:
        When NaturalAlignment:
            Return "generic"
        When PackedAlignment:
            Return "packed"
        When PlatformSpecific with platform as platform:
            Return platform

Note: Layout Validation
Process called "validate_layout" that takes layout as LayoutInfo returns Dictionary[String, Any]:
    Note: Validate a layout for correctness
    Let errors be list containing
    Let warnings be list containing
    
    If layout.size is less than 0:
        Add "Layout size cannot be negative" to errors
    
    If layout.alignment is less than 1:
        Add "Layout alignment must be at least 1" to errors
    
    If layout.size modulo layout.alignment is not equal to 0:
        Add "Layout size must be aligned to alignment" to warnings
    
    For each field_offset in layout.field_offsets:
        If field_offset is less than 0:
            Add "Field offset cannot be negative" to errors
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Process called "optimize_layout" that takes layout as LayoutInfo and optimization_level as Integer returns LayoutInfo:
    Note: Optimize layout for better memory usage
    If optimization_level is equal to 0:
        Return layout
    
    Let optimized_layout be layout
    
    If optimization_level is greater than or equal to 1:
        Note: Remove unnecessary padding
        Let optimized_padding be list containing
        For each padding in layout.padding_info:
            If padding.size is greater than 0:
                Add padding to optimized_padding
        Set optimized_layout.padding_info to optimized_padding
    
    If optimization_level is greater than or equal to 2:
        Note: Reorder fields for better alignment (simplified)
        Note: In a real implementation, this would reorder fields to minimize padding
        Set optimized_layout.is_packed to true
    
    Return optimized_layout

Note: Layout Serialization
Process called "serialize_layout" that takes layout as LayoutInfo returns String:
    Note: Serialize layout to human-readable format
    Let result be "Layout Info:\n"
    Set result to result plus "  Size: " plus layout.size plus " bytes\n"
    Set result to result plus "  Alignment: " plus layout.alignment plus " bytes\n"
    Set result to result plus "  Platform: " plus layout.platform plus "\n"
    Set result to result plus "  Packed: " plus layout.is_packed plus "\n"
    
    If length of layout.field_offsets is greater than 0:
        Set result to result plus "  Field Offsets:\n"
        For each field_name in layout.field_offsets:
            Set result to result plus "    " plus field_name plus ": " plus (layout.field_offsets at key field_name) plus "\n"
    
    If length of layout.padding_info is greater than 0:
        Set result to result plus "  Padding Info:\n"
        For each padding in layout.padding_info:
            Set result to result plus "    Offset " plus padding.offset plus ": " plus padding.size plus " bytes (" plus padding.reason plus ")\n"
    
    Return result

Process called "deserialize_layout" that takes serialized as String returns Dictionary[String, Any]:
    Note: Deserialize layout from human-readable format
    Note: This is a simplified implementation
    Return dictionary containing:
        "success" as true
        "layout" as LayoutInfo with:
            size as 0
            alignment as 1
            field_offsets as dictionary containing
            padding_info as list containing
            is_packed as false
            platform as "generic"

Note: Layout Statistics
Process called "get_layout_statistics" that takes layout as LayoutInfo returns Dictionary[String, Any]:
    Note: Get statistics about a layout
    Let total_padding be 0
    For each padding in layout.padding_info:
        Set total_padding to total_padding plus padding.size
    
    Let efficiency be 0.0
    If layout.size is greater than 0:
        Set efficiency to ((layout.size minus total_padding) divided by layout.size) multiplied by 100.0
    
    Return dictionary containing:
        "size" as layout.size
        "alignment" as layout.alignment
        "field_count" as length of layout.field_offsets
        "padding_count" as length of layout.padding_info
        "total_padding" as total_padding
        "efficiency_percent" as efficiency
        "is_packed" as layout.is_packed
        "platform" as layout.platform 