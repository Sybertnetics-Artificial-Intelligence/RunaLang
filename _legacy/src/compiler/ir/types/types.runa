Note: Runa Compiler: Unified IR Type System
Note: Canonical type representation used across all IR levels

Import "../../parser/ast.runa"

Note: IR Type System - Canonical Type Representation
Type IRType is:
    | IRPrimitiveType with name as String and size as Integer and alignment as Integer
    | IRPointerType with pointee as IRType and is_mutable as Boolean
    | IRArrayType with element_type as IRType and length as Optional[Integer]
    | IRStructType with name as String and fields as List[IRField] and size as Integer and alignment as Integer
    | IRUnionType with name as String and variants as List[IRVariant] and size as Integer and alignment as Integer
    | IRFunctionType with parameters as List[IRType] and return_type as IRType and is_variadic as Boolean
    | IRGenericType with name as String and type_parameters as List[String] and constraints as List[IRTypeConstraint]
    | IRTypeParameter with name as String and constraint as Optional[IRType]
    | IRInferredType with placeholder as String
    | IRUnknownType

Note: IR Type Components
Type IRField is Dictionary with:
    name as String
    type as IRType
    offset as Integer
    is_mutable as Boolean
    metadata as Dictionary[String, Any]

Type IRVariant is Dictionary with:
    name as String
    type as Optional[IRType]
    discriminant as Integer
    metadata as Dictionary[String, Any]

Type IRTypeConstraint is Dictionary with:
    constraint_type as String
    constraint_value as Any
    metadata as Dictionary[String, Any]

Note: Type System Management
Type TypeSystem is Dictionary with:
    primitive_types as Dictionary[String, IRType]
    builtin_types as Dictionary[String, IRType]
    user_types as Dictionary[String, IRType]
    type_aliases as Dictionary[String, IRType]
    generic_types as Dictionary[String, IRType]
    metadata as Dictionary[String, Any]

Process called "create_type_system" returns TypeSystem:
    Note: Create a new type system with built-in types
    Let primitive_types be dictionary containing
    Let builtin_types be dictionary containing
    Let user_types be dictionary containing
    Let type_aliases be dictionary containing
    Let generic_types be dictionary containing
    
    Note: Initialize primitive types
    Let int_type be IRPrimitiveType with name as "Integer" and size as 8 and alignment as 8
    Let float_type be IRPrimitiveType with name as "Float" and size as 8 and alignment as 8
    Let string_type be IRPrimitiveType with name as "String" and size as 16 and alignment as 8
    Let bool_type be IRPrimitiveType with name as "Boolean" and size as 1 and alignment as 1
    Let char_type be IRPrimitiveType with name as "Character" and size as 4 and alignment as 4
    
    Set primitive_types at key "Integer" to int_type
    Set primitive_types at key "Float" to float_type
    Set primitive_types at key "String" to string_type
    Set primitive_types at key "Boolean" to bool_type
    Set primitive_types at key "Character" to char_type
    
    Note: Initialize built-in types
    Let list_type be IRGenericType with name as "List" and type_parameters as list containing "T" and constraints as list containing
    Let dict_type be IRGenericType with name as "Dictionary" and type_parameters as list containing "K", "V" and constraints as list containing
    Let option_type be IRGenericType with name as "Optional" and type_parameters as list containing "T" and constraints as list containing
    
    Set builtin_types at key "List" to list_type
    Set builtin_types at key "Dictionary" to dict_type
    Set builtin_types at key "Optional" to option_type
    
    Return TypeSystem with:
        primitive_types as primitive_types
        builtin_types as builtin_types
        user_types as user_types
        type_aliases as type_aliases
        generic_types as generic_types
        metadata as dictionary containing

Note: Type System Operations
Process called "register_primitive_type" that takes type_system as TypeSystem and name as String and size as Integer and alignment as Integer returns Boolean:
    Note: Register a primitive type
    If name is in type_system.primitive_types:
        Return false
    
    Let primitive_type be IRPrimitiveType with name as name and size as size and alignment as alignment
    Set type_system.primitive_types at key name to primitive_type
    Return true

Process called "register_builtin_type" that takes type_system as TypeSystem and name as String and ir_type as IRType returns Boolean:
    Note: Register a built-in type
    If name is in type_system.builtin_types:
        Return false
    
    Set type_system.builtin_types at key name to ir_type
    Return true

Process called "register_user_type" that takes type_system as TypeSystem and name as String and ir_type as IRType returns Boolean:
    Note: Register a user-defined type
    If name is in type_system.user_types:
        Return false
    
    Set type_system.user_types at key name to ir_type
    Return true

Process called "register_type_alias" that takes type_system as TypeSystem and alias as String and target_type as IRType returns Boolean:
    Note: Register a type alias
    If alias is in type_system.type_aliases:
        Return false
    
    Set type_system.type_aliases at key alias to target_type
    Return true

Process called "register_generic_type" that takes type_system as TypeSystem and name as String and ir_type as IRType returns Boolean:
    Note: Register a generic type
    If name is in type_system.generic_types:
        Return false
    
    Set type_system.generic_types at key name to ir_type
    Return true

Process called "lookup_type" that takes type_system as TypeSystem and name as String returns Optional[IRType]:
    Note: Look up a type by name
    If name is in type_system.primitive_types:
        Return type_system.primitive_types at key name
    Otherwise if name is in type_system.builtin_types:
        Return type_system.builtin_types at key name
    Otherwise if name is in type_system.user_types:
        Return type_system.user_types at key name
    Otherwise if name is in type_system.type_aliases:
        Return type_system.type_aliases at key name
    Otherwise if name is in type_system.generic_types:
        Return type_system.generic_types at key name
    Otherwise:
        Return None

Process called "resolve_type" that takes type_system as TypeSystem and ir_type as IRType returns IRType:
    Note: Resolve type aliases and return the concrete type
    Match ir_type:
        When IRPrimitiveType with name as name and size as size and alignment as alignment:
            Return ir_type
        When IRPointerType with pointee as pointee and is_mutable as is_mutable:
            Let resolved_pointee be resolve_type with type_system as type_system and ir_type as pointee
            Return IRPointerType with pointee as resolved_pointee and is_mutable as is_mutable
        When IRArrayType with element_type as element_type and length as length:
            Let resolved_element be resolve_type with type_system as type_system and ir_type as element_type
            Return IRArrayType with element_type as resolved_element and length as length
        When IRStructType with name as name and fields as fields and size as size and alignment as alignment:
            Let resolved_fields be list containing
            For each field in fields:
                Let resolved_field be IRField with:
                    name as field.name
                    type as resolve_type with type_system as type_system and ir_type as field.type
                    offset as field.offset
                    is_mutable as field.is_mutable
                    metadata as field.metadata
                Add resolved_field to resolved_fields
            Return IRStructType with name as name and fields as resolved_fields and size as size and alignment as alignment
        When IRUnionType with name as name and variants as variants and size as size and alignment as alignment:
            Let resolved_variants be list containing
            For each variant in variants:
                Let resolved_variant be IRVariant with:
                    name as variant.name
                    type as (resolve_type with type_system as type_system and ir_type as variant.type if variant.type is not None else None)
                    discriminant as variant.discriminant
                    metadata as variant.metadata
                Add resolved_variant to resolved_variants
            Return IRUnionType with name as name and variants as resolved_variants and size as size and alignment as alignment
        When IRFunctionType with parameters as parameters and return_type as return_type and is_variadic as is_variadic:
            Let resolved_parameters be list containing
            For each param in parameters:
                Add resolve_type with type_system as type_system and ir_type as param to resolved_parameters
            Let resolved_return be resolve_type with type_system as type_system and ir_type as return_type
            Return IRFunctionType with parameters as resolved_parameters and return_type as resolved_return and is_variadic as is_variadic
        When IRGenericType with name as name and type_parameters as type_parameters and constraints as constraints:
            Return ir_type
        When IRTypeParameter with name as name and constraint as constraint:
            Let resolved_constraint be (resolve_type with type_system as type_system and ir_type as constraint if constraint is not None else None)
            Return IRTypeParameter with name as name and constraint as resolved_constraint
        When IRInferredType with placeholder as placeholder:
            Return ir_type
        When IRUnknownType:
            Return ir_type

Note: Type Compatibility and Conversion
Process called "is_type_compatible" that takes type_system as TypeSystem and source_type as IRType and target_type as IRType returns Boolean:
    Note: Check if source type is compatible with target type
    Let resolved_source be resolve_type with type_system as type_system and ir_type as source_type
    Let resolved_target be resolve_type with type_system as type_system and ir_type as target_type
    
    If resolved_source is equal to resolved_target:
        Return true
    
    Match resolved_source:
        When IRPrimitiveType with name as source_name:
            Match resolved_target:
                When IRPrimitiveType with name as target_name:
                    Return is_primitive_compatible with source as source_name and target as target_name
                Otherwise:
                    Return false
        When IRPointerType with pointee as source_pointee and is_mutable as source_mutable:
            Match resolved_target:
                When IRPointerType with pointee as target_pointee and is_mutable as target_mutable:
                    If source_mutable is equal to target_mutable:
                        Return is_type_compatible with type_system as type_system and source_type as source_pointee and target_type as target_pointee
                    Otherwise:
                        Return false
                Otherwise:
                    Return false
        When IRArrayType with element_type as source_element and length as source_length:
            Match resolved_target:
                When IRArrayType with element_type as target_element and length as target_length:
                    If source_length is equal to target_length:
                        Return is_type_compatible with type_system as type_system and source_type as source_element and target_type as target_element
                    Otherwise:
                        Return false
                Otherwise:
                    Return false
        Otherwise:
            Return false

Process called "is_primitive_compatible" that takes source as String and target as String returns Boolean:
    Note: Check primitive type compatibility
    If source is equal to target:
        Return true
    
    Note: Integer promotions
    If source is equal to "Integer" and target is equal to "Float":
        Return true
    
    Note: Character to string conversion
    If source is equal to "Character" and target is equal to "String":
        Return true
    
    Return false

Process called "get_type_size" that takes type_system as TypeSystem and ir_type as IRType returns Integer:
    Note: Get the size of a type in bytes
    Let resolved_type be resolve_type with type_system as type_system and ir_type as ir_type
    
    Match resolved_type:
        When IRPrimitiveType with size as size:
            Return size
        When IRPointerType:
            Return 8
        When IRArrayType with element_type as element_type and length as length:
            Let element_size be get_type_size with type_system as type_system and ir_type as element_type
            If length is not None:
                Return element_size multiplied by length
            Otherwise:
                Return 0
        When IRStructType with size as size:
            Return size
        When IRUnionType with size as size:
            Return size
        When IRFunctionType:
            Return 8
        When IRGenericType:
            Return 0
        When IRTypeParameter:
            Return 0
        When IRInferredType:
            Return 0
        When IRUnknownType:
            Return 0

Process called "get_type_alignment" that takes type_system as TypeSystem and ir_type as IRType returns Integer:
    Note: Get the alignment requirement of a type
    Let resolved_type be resolve_type with type_system as type_system and ir_type as ir_type
    
    Match resolved_type:
        When IRPrimitiveType with alignment as alignment:
            Return alignment
        When IRPointerType:
            Return 8
        When IRArrayType with element_type as element_type:
            Return get_type_alignment with type_system as type_system and ir_type as element_type
        When IRStructType with alignment as alignment:
            Return alignment
        When IRUnionType with alignment as alignment:
            Return alignment
        When IRFunctionType:
            Return 8
        When IRGenericType:
            Return 1
        When IRTypeParameter:
            Return 1
        When IRInferredType:
            Return 1
        When IRUnknownType:
            Return 1

Note: Type System Statistics
Process called "get_type_system_statistics" that takes type_system as TypeSystem returns Dictionary[String, Any]:
    Note: Get statistics about the type system
    Return dictionary containing:
        "primitive_types" as length of type_system.primitive_types
        "builtin_types" as length of type_system.builtin_types
        "user_types" as length of type_system.user_types
        "type_aliases" as length of type_system.type_aliases
        "generic_types" as length of type_system.generic_types
        "total_types" as (length of type_system.primitive_types plus length of type_system.builtin_types plus length of type_system.user_types plus length of type_system.type_aliases plus length of type_system.generic_types) 