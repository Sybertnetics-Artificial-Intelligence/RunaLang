Note: Runa Compiler: Intermediate Representation (IR) System
Note: Multi-level IR with type-safe, idiomatic Runa APIs

Import "ir_context.runa"
Import "types/types.runa"
Import "hir/hir.runa"
Import "mir/mir.runa"
Import "lir/lir.runa"

Note: IR System Result Types - Idiomatic Runa ADTs
Type IRBuildResult is Success with module as IRModule | Failure with diagnostics as List[IRDiagnostic]

Type HIRBuildResult is Success with module as HIRModule | Failure with diagnostics as List[IRDiagnostic]

Type MIRBuildResult is Success with module as MIRModule | Failure with diagnostics as List[IRDiagnostic]

Type LIRBuildResult is Success with module as LIRModule | Failure with diagnostics as List[IRDiagnostic]

Type IROptimizationResult is Success with module as IRModule and statistics as Dictionary[String, Any] | Failure with diagnostics as List[IRDiagnostic]

Type IRValidationResult is Success with valid as Boolean and warnings as List[String] | Failure with diagnostics as List[IRDiagnostic]

Note: IR Module Types
Type IRLevel is:
    | HIR
    | MIR
    | LIR

Type IRModule is Dictionary with:
    hir as HIRModule
    mir as MIRModule
    lir as LIRModule
    types as TypeSystem
    context as IRContext

Note: IR Module Creation and Management
Process called "create_ir_module" returns IRModule:
    Note: Create a new IR module with all levels initialized
    Let type_system be create_type_system
    Let context be create_ir_context with compilation_unit as "unknown" and source_file as "unknown" and type_system as type_system
    
    Return IRModule with:
        hir as create_hir_module with name as "unknown"
        mir as create_mir_module with name as "unknown"
        lir as create_lir_module with name as "unknown"
        types as type_system
        context as context

Process called "create_ir_module_with_context" that takes context as IRContext returns IRModule:
    Note: Create a new IR module with a specific context
    Return IRModule with:
        hir as create_hir_module with name as context.compilation_unit
        mir as create_mir_module with name as context.compilation_unit
        lir as create_lir_module with name as context.compilation_unit
        types as context.type_system
        context as context

Note: IR Translation Pipeline - Type-Safe Results
Process called "translate_ast_to_hir" that takes ast as ASTNode and context as IRContext returns HIRBuildResult:
    Note: Translate AST to HIR with type-safe result
    Let hir_builder be create_hir_builder with context as context
    Let build_result be build_hir_from_ast with hir_builder as hir_builder and ast as ast
    
    If build_result.success:
        Return Success with module as build_result.hir_module
    Otherwise:
        Return Failure with diagnostics as get_hir_builder_diagnostics with hir_builder as hir_builder

Process called "translate_hir_to_mir" that takes hir_module as HIRModule and context as IRContext returns MIRBuildResult:
    Note: Translate HIR to MIR with type-safe result
    Let mir_builder be create_mir_builder with context as context
    Let build_result be build_mir_from_hir with mir_builder as mir_builder and hir_module as hir_module
    
    If build_result.success:
        Return Success with module as build_result.mir_module
    Otherwise:
        Return Failure with diagnostics as get_mir_builder_diagnostics with mir_builder as mir_builder

Process called "translate_mir_to_lir" that takes mir_module as MIRModule and context as IRContext returns LIRBuildResult:
    Note: Translate MIR to LIR with type-safe result
    Let lir_builder be create_lir_builder with context as context
    Let build_result be build_lir_from_mir with lir_builder as lir_builder and mir_module as mir_module
    
    If build_result.success:
        Return Success with module as build_result.lir_module
    Otherwise:
        Return Failure with diagnostics as get_lir_builder_diagnostics with lir_builder as lir_builder

Note: IR Validation - Type-Safe Results
Process called "validate_ir" that takes ir_module as IRModule returns IRValidationResult:
    Note: Validate IR module with type-safe result
    Let context be ir_module.context
    Let errors be list containing
    Let warnings be list containing
    
    Note: Validate HIR
    Let hir_validation be validate_hir_module with hir_module as ir_module.hir
    If hir_validation.valid is false:
        Add all hir_validation.errors to errors
    Add all hir_validation.warnings to warnings
    
    Note: Validate MIR
    Let mir_validation be validate_mir with mir_module as ir_module.mir
    If mir_validation.valid is false:
        Add all mir_validation.errors to errors
    Add all mir_validation.warnings to warnings
    
    Note: Validate LIR
    Let lir_validation be validate_lir_module with lir_module as ir_module.lir
    If lir_validation.valid is false:
        Add all lir_validation.errors to errors
    Add all lir_validation.warnings to warnings
    
    If length of errors is equal to 0:
        Return Success with valid as true and warnings as warnings
    Otherwise:
        Return Failure with diagnostics as create_diagnostics_from_errors with errors as errors and context as context

Process called "validate_hir_module" that takes hir_module as HIRModule returns Dictionary[String, Any]:
    Note: Validate HIR module
    Let errors be list containing
    Let warnings be list containing
    
    For each declaration in hir_module.declarations:
        Let validation be validate_hir_declaration with declaration as declaration
        If validation.valid is false:
            Add all validation.errors to errors
        Add all validation.warnings to warnings
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Process called "validate_hir_declaration" that takes declaration as HIRDeclaration returns Dictionary[String, Any]:
    Note: Validate HIR declaration
    Let errors be list containing
    Let warnings be list containing
    
    Match declaration:
        When HIRProcessDeclaration with name as name and parameters as parameters and return_type as return_type and body as body and is_function as is_function:
            If name is equal to "":
                Add "Process declaration has empty name" to errors
            If length of body is equal to 0:
                Add "Process " plus name plus " has empty body" to warnings
        Otherwise:
            Note: Other declaration types
            Return dictionary containing:
                "valid" as true
                "errors" as errors
                "warnings" as warnings
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Process called "validate_lir_module" that takes lir_module as LIRModule returns Dictionary[String, Any]:
    Note: Validate LIR module
    Let errors be list containing
    Let warnings be list containing
    
    For each function in lir_module.functions:
        Let validation be validate_lir_function with function as function
        If validation.valid is false:
            Add all validation.errors to errors
        Add all validation.warnings to warnings
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Process called "validate_lir_function" that takes function as LIRFunction returns Dictionary[String, Any]:
    Note: Validate LIR function
    Let errors be list containing
    Let warnings as list containing
    
    If function.name is equal to "":
        Add "LIR function has empty name" to errors
    
    If length of function.basic_blocks is equal to 0:
        Add "LIR function " plus function.name plus " has no basic blocks" to errors
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Process called "create_diagnostics_from_errors" that takes errors as List[String] and context as IRContext returns List[IRDiagnostic]:
    Note: Create diagnostics from error messages
    Let diagnostics be list containing
    
    For each error in errors:
        Let diagnostic be IRDiagnostic with:
            severity as "error"
            message as error
            location as SourceLocation with line as 0 and column as 0 and file as context.source_file
            code as "IR_VALIDATION_ERROR"
        Add diagnostic to diagnostics
    
    Return diagnostics

Note: IR Statistics and Analysis
Process called "get_ir_statistics" that takes ir_module as IRModule returns Dictionary[String, Any]:
    Note: Get comprehensive statistics for IR module
    Return dictionary containing:
        "hir" as dictionary containing:
            "declarations" as length of ir_module.hir.declarations
            "statements" as length of ir_module.hir.statements
        "mir" as dictionary containing:
            "functions" as length of ir_module.mir.functions
            "basic_blocks" as get_total_basic_block_count with mir_module as ir_module.mir
        "lir" as dictionary containing:
            "functions" as length of ir_module.lir.functions
            "virtual_registers" as get_total_virtual_register_count with lir_module as ir_module.lir
        "types" as get_type_system_statistics with type_system as ir_module.types

Process called "serialize_ir" that takes ir_module as IRModule returns String:
    Note: Serialize IR module to string representation
    Let stats be get_ir_statistics with ir_module as ir_module
    Let output be "IR Module: " plus ir_module.context.compilation_unit plus "\n"
    Set output to output plus "HIR: " plus stats.hir.declarations plus " declarations, " plus stats.hir.statements plus " statements\n"
    Set output to output plus "MIR: " plus stats.mir.functions plus " functions, " plus stats.mir.basic_blocks plus " basic blocks\n"
    Set output to output plus "LIR: " plus stats.lir.functions plus " functions, " plus stats.lir.virtual_registers plus " virtual registers\n"
    Return output

Process called "deserialize_ir" that takes serialized as String returns IRModule:
    Note: Deserialize IR module from string representation
    Note: This is a simplified implementation
    Return create_ir_module

Note: IR Configuration
Process called "configure_ir_module" that takes ir_module as IRModule and options as Dictionary[String, Any] returns IRModule:
    Note: Configure IR module with compilation options
    Let context be ir_module.context
    
    If "optimization_level" is in options:
        Set context.optimization_level to options at key "optimization_level"
    
    If "debug_info" is in options:
        Set context.debug_info to options at key "debug_info"
    
    If "target_platform" is in options:
        Set context.target_platform to options at key "target_platform"
    
    Return ir_module

Note: IR Diagnostics
Process called "get_ir_diagnostics" that takes ir_module as IRModule returns List[IRDiagnostic]:
    Note: Get all diagnostics from IR module
    Return ir_module.context.diagnostics

Process called "has_ir_errors" that takes ir_module as IRModule returns Boolean:
    Note: Check if IR module has errors
    Let diagnostics be get_ir_diagnostics with ir_module as ir_module
    
    For each diagnostic in diagnostics:
        If diagnostic.severity is equal to "error":
            Return true
    
    Return false

Process called "get_ir_warnings" that takes ir_module as IRModule returns List[IRDiagnostic]:
    Note: Get all warnings from IR module
    Let warnings be list containing
    Let diagnostics be get_ir_diagnostics with ir_module as ir_module
    
    For each diagnostic in diagnostics:
        If diagnostic.severity is equal to "warning":
            Add diagnostic to warnings
    
    Return warnings 