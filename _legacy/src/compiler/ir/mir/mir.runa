Note: Runa Compiler: Mid-Level IR (MIR)
Note: Control Flow Graph representation for optimization

Import "../types/types.runa"
Import "../ir_context.runa"

Note: Mid-Level IR (MIR) - Control Flow Graph Representation
Type MIRNode is Dictionary with:
    node_type as String
    location as SourceLocation
    basic_block as String
    metadata as Dictionary[String, Any]

Type MIRInstruction is:
    | MIRLoad with destination as String and source as String and type as IRType
    | MIRStore with destination as String and source as String and type as IRType
    | MIRBinaryOp with destination as String and left as String and operator as String and right as String and type as IRType
    | MIRUnaryOp with destination as String and operator as String and operand as String and type as IRType
    | MIRCall with destination as String and function as String and arguments as List[String] and return_type as IRType
    | MIRReturn with value as Optional[String]
    | MIRJump with target as String
    | MIRBranch with condition as String and true_target as String and false_target as String
    | MIRPhi with destination as String and operands as List[PhiOperand] and type as IRType
    | MIRAlloca with destination as String and type as IRType and size as Integer
    | MIRGetElementPtr with destination as String and base as String and indices as List[String] and type as IRType
    | MIRBitcast with destination as String and source as String and from_type as IRType and to_type as IRType
    | MIRSelect with destination as String and condition as String and true_value as String and false_value as String and type as IRType

Type PhiOperand is Dictionary with:
    value as String
    basic_block as String

Type MIRTerminator is:
    | MIRJumpTerminator with target as String
    | MIRBranchTerminator with condition as String and true_target as String and false_target as String
    | MIRReturnTerminator with value as Optional[String]
    | MIRUnreachableTerminator

Type MIRBasicBlock is Dictionary with:
    name as String
    instructions as List[MIRInstruction]
    terminator as MIRTerminator
    predecessors as List[String]
    successors as List[String]
    dominance_frontier as List[String]
    metadata as Dictionary[String, Any]

Type MIRFunction is Dictionary with:
    name as String
    parameters as List[MIRParameter]
    return_type as IRType
    basic_blocks as List[MIRBasicBlock]
    entry_block as String
    exit_blocks as List[String]
    local_variables as Dictionary[String, IRType]
    metadata as Dictionary[String, Any]

Type MIRParameter is Dictionary with:
    name as String
    type as IRType
    is_mutable as Boolean

Type MIRModule is Dictionary with:
    name as String
    functions as List[MIRFunction]
    global_variables as Dictionary[String, IRType]
    metadata as Dictionary[String, Any]

Process called "create_mir_module" that takes name as String returns MIRModule:
    Note: Create a new MIR module
    Return MIRModule with:
        name as name
        functions as list containing
        global_variables as dictionary containing
        metadata as dictionary containing

Process called "create_mir_function" that takes name as String and parameters as List[MIRParameter] and return_type as IRType returns MIRFunction:
    Note: Create a new MIR function
    Let entry_block be "entry"
    Let exit_blocks be list containing
    
    Let basic_blocks be list containing
    Let entry_bb be create_mir_basic_block with name as entry_block
    Add entry_bb to basic_blocks
    
    Return MIRFunction with:
        name as name
        parameters as parameters
        return_type as return_type
        basic_blocks as basic_blocks
        entry_block as entry_block
        exit_blocks as exit_blocks
        local_variables as dictionary containing
        metadata as dictionary containing

Process called "create_mir_basic_block" that takes name as String returns MIRBasicBlock:
    Note: Create a new MIR basic block
    Return MIRBasicBlock with:
        name as name
        instructions as list containing
        terminator as MIRUnreachableTerminator
        predecessors as list containing
        successors as list containing
        dominance_frontier as list containing
        metadata as dictionary containing

Note: MIR Instruction Creation Utilities
Process called "create_mir_load" that takes destination as String and source as String and type as IRType returns MIRInstruction:
    Note: Create a MIR load instruction
    Return MIRLoad with destination as destination and source as source and type as type

Process called "create_mir_store" that takes destination as String and source as String and type as IRType returns MIRInstruction:
    Note: Create a MIR store instruction
    Return MIRStore with destination as destination and source as source and type as type

Process called "create_mir_binary_op" that takes destination as String and left as String and operator as String and right as String and type as IRType returns MIRInstruction:
    Note: Create a MIR binary operation instruction
    Return MIRBinaryOp with destination as destination and left as left and operator as operator and right as right and type as type

Process called "create_mir_call" that takes destination as String and function as String and arguments as List[String] and return_type as IRType returns MIRInstruction:
    Note: Create a MIR function call instruction
    Return MIRCall with destination as destination and function as function and arguments as arguments and return_type as return_type

Process called "create_mir_return" that takes value as Optional[String] returns MIRInstruction:
    Note: Create a MIR return instruction
    Return MIRReturn with value as value

Process called "create_mir_jump" that takes target as String returns MIRInstruction:
    Note: Create a MIR jump instruction
    Return MIRJump with target as target

Process called "create_mir_branch" that takes condition as String and true_target as String and false_target as String returns MIRInstruction:
    Note: Create a MIR conditional branch instruction
    Return MIRBranch with condition as condition and true_target as true_target and false_target as false_target

Process called "create_mir_phi" that takes destination as String and operands as List[PhiOperand] and type as IRType returns MIRInstruction:
    Note: Create a MIR phi instruction for SSA form
    Return MIRPhi with destination as destination and operands as operands and type as type

Process called "create_mir_alloca" that takes destination as String and type as IRType and size as Integer returns MIRInstruction:
    Note: Create a MIR alloca instruction for stack allocation
    Return MIRAlloca with destination as destination and type as type and size as size

Note: MIR Terminator Creation Utilities
Process called "create_mir_jump_terminator" that takes target as String returns MIRTerminator:
    Note: Create a MIR jump terminator
    Return MIRJumpTerminator with target as target

Process called "create_mir_branch_terminator" that takes condition as String and true_target as String and false_target as String returns MIRTerminator:
    Note: Create a MIR branch terminator
    Return MIRBranchTerminator with condition as condition and true_target as true_target and false_target as false_target

Process called "create_mir_return_terminator" that takes value as Optional[String] returns MIRTerminator:
    Note: Create a MIR return terminator
    Return MIRReturnTerminator with value as value

Process called "create_mir_unreachable_terminator" returns MIRTerminator:
    Note: Create a MIR unreachable terminator
    Return MIRUnreachableTerminator

Note: MIR Analysis Utilities
Process called "get_mir_instruction_type" that takes instruction as MIRInstruction returns String:
    Note: Get the type of a MIR instruction
    Match instruction:
        When MIRLoad with destination as destination and source as source and type as type:
            Return "load"
        When MIRStore with destination as destination and source as source and type as type:
            Return "store"
        When MIRBinaryOp with destination as destination and left as left and operator as operator and right as right and type as type:
            Return "binary_op"
        When MIRUnaryOp with destination as destination and operator as operator and operand as operand and type as type:
            Return "unary_op"
        When MIRCall with destination as destination and function as function and arguments as arguments and return_type as return_type:
            Return "call"
        When MIRReturn with value as value:
            Return "return"
        When MIRJump with target as target:
            Return "jump"
        When MIRBranch with condition as condition and true_target as true_target and false_target as false_target:
            Return "branch"
        When MIRPhi with destination as destination and operands as operands and type as type:
            Return "phi"
        When MIRAlloca with destination as destination and type as type and size as size:
            Return "alloca"
        When MIRGetElementPtr with destination as destination and base as base and indices as indices and type as type:
            Return "getelementptr"
        When MIRBitcast with destination as destination and source as source and from_type as from_type and to_type as to_type:
            Return "bitcast"
        When MIRSelect with destination as destination and condition as condition and true_value as true_value and false_value as false_value and type as type:
            Return "select"

Process called "is_mir_terminator" that takes instruction as MIRInstruction returns Boolean:
    Note: Check if a MIR instruction is a terminator
    Let instruction_type be get_mir_instruction_type with instruction as instruction
    Return instruction_type is equal to "return" or instruction_type is equal to "jump" or instruction_type is equal to "branch"

Process called "get_mir_instruction_destination" that takes instruction as MIRInstruction returns Optional[String]:
    Note: Get the destination of a MIR instruction
    Match instruction:
        When MIRLoad with destination as destination and source as source and type as type:
            Return destination
        When MIRStore with destination as destination and source as source and type as type:
            Return destination
        When MIRBinaryOp with destination as destination and left as left and operator as operator and right as right and type as type:
            Return destination
        When MIRUnaryOp with destination as destination and operator as operator and operand as operand and type as type:
            Return destination
        When MIRCall with destination as destination and function as function and arguments as arguments and return_type as return_type:
            Return destination
        When MIRPhi with destination as destination and operands as operands and type as type:
            Return destination
        When MIRAlloca with destination as destination and type as type and size as size:
            Return destination
        When MIRGetElementPtr with destination as destination and base as base and indices as indices and type as type:
            Return destination
        When MIRBitcast with destination as destination and source as source and from_type as from_type and to_type as to_type:
            Return destination
        When MIRSelect with destination as destination and condition as condition and true_value as true_value and false_value as false_value and type as type:
            Return destination
        Otherwise:
            Return None

Process called "get_mir_instruction_sources" that takes instruction as MIRInstruction returns List[String]:
    Note: Get the source operands of a MIR instruction
    Let sources be list containing
    
    Match instruction:
        When MIRLoad with destination as destination and source as source and type as type:
            Add source to sources
        When MIRStore with destination as destination and source as source and type as type:
            Add destination to sources
            Add source to sources
        When MIRBinaryOp with destination as destination and left as left and operator as operator and right as right and type as type:
            Add left to sources
            Add right to sources
        When MIRUnaryOp with destination as destination and operator as operator and operand as operand and type as type:
            Add operand to sources
        When MIRCall with destination as destination and function as function and arguments as arguments and return_type as return_type:
            Add function to sources
            Add all arguments to sources
        When MIRBranch with condition as condition and true_target as true_target and false_target as false_target:
            Add condition to sources
        When MIRPhi with destination as destination and operands as operands and type as type:
            For each operand in operands:
                Add operand.value to sources
        When MIRGetElementPtr with destination as destination and base as base and indices as indices and type as type:
            Add base to sources
            Add all indices to sources
        When MIRBitcast with destination as destination and source as source and from_type as from_type and to_type as to_type:
            Add source to sources
        When MIRSelect with destination as destination and condition as condition and true_value as true_value and false_value as false_value and type as type:
            Add condition to sources
            Add true_value to sources
            Add false_value to sources
        Otherwise:
            Note: No sources for other instruction types
            Return sources
    
    Return sources

Note: MIR Control Flow Analysis
Process called "compute_cfg_predecessors" that takes mir_function as MIRFunction:
    Note: Compute predecessor relationships for all basic blocks
    For each basic_block in mir_function.basic_blocks:
        Set basic_block.predecessors to list containing
    
    For each basic_block in mir_function.basic_blocks:
        Match basic_block.terminator:
            When MIRJumpTerminator with target as target:
                Let target_bb be find_basic_block_by_name with mir_function as mir_function and name as target
                If target_bb is not None:
                    Add basic_block.name to target_bb.predecessors
            When MIRBranchTerminator with condition as condition and true_target as true_target and false_target as false_target:
                Let true_bb be find_basic_block_by_name with mir_function as mir_function and name as true_target
                If true_bb is not None:
                    Add basic_block.name to true_bb.predecessors
                Let false_bb be find_basic_block_by_name with mir_function as mir_function and name as false_target
                If false_bb is not None:
                    Add basic_block.name to false_bb.predecessors
            Otherwise:
                Note: Return and unreachable terminators have no successors
                Return

Process called "compute_cfg_successors" that takes mir_function as MIRFunction:
    Note: Compute successor relationships for all basic blocks
    For each basic_block in mir_function.basic_blocks:
        Set basic_block.successors to list containing
    
    For each basic_block in mir_function.basic_blocks:
        Match basic_block.terminator:
            When MIRJumpTerminator with target as target:
                Add target to basic_block.successors
            When MIRBranchTerminator with condition as condition and true_target as true_target and false_target as false_target:
                Add true_target to basic_block.successors
                Add false_target to basic_block.successors
            Otherwise:
                Note: Return and unreachable terminators have no successors
                Return

Process called "find_basic_block_by_name" that takes mir_function as MIRFunction and name as String returns Optional[MIRBasicBlock]:
    Note: Find a basic block by name
    For each basic_block in mir_function.basic_blocks:
        If basic_block.name is equal to name:
            Return basic_block
    Return None

Note: MIR Validation
Process called "validate_mir_function" that takes mir_function as MIRFunction returns Dictionary[String, Any]:
    Note: Validate a MIR function
    Let errors be list containing
    Let warnings be list containing
    
    Note: Check that all basic blocks have terminators
    For each basic_block in mir_function.basic_blocks:
        If basic_block.terminator is MIRUnreachableTerminator:
            Add "Basic block " plus basic_block.name plus " has no terminator" to errors
    
    Note: Check that all jump/branch targets exist
    For each basic_block in mir_function.basic_blocks:
        Match basic_block.terminator:
            When MIRJumpTerminator with target as target:
                If find_basic_block_by_name with mir_function as mir_function and name as target is None:
                    Add "Jump target " plus target plus " does not exist" to errors
            When MIRBranchTerminator with condition as condition and true_target as true_target and false_target as false_target:
                If find_basic_block_by_name with mir_function as mir_function and name as true_target is None:
                    Add "Branch true target " plus true_target plus " does not exist" to errors
                If find_basic_block_by_name with mir_function as mir_function and name as false_target is None:
                    Add "Branch false target " plus false_target plus " does not exist" to errors
            Otherwise:
                Note: Return and unreachable terminators are valid
                Return
    
    Note: Check for unreachable basic blocks
    Let reachable_blocks be set containing mir_function.entry_block
    Let worklist be list containing mir_function.entry_block
    
    While length of worklist is greater than 0:
        Let current be (worklist at index 0)
        Remove current from worklist at index 0
        
        Let current_bb be find_basic_block_by_name with mir_function as mir_function and name as current
        If current_bb is not None:
            For each successor in current_bb.successors:
                If successor is not in reachable_blocks:
                    Add successor to reachable_blocks
                    Add successor to worklist
    
    For each basic_block in mir_function.basic_blocks:
        If basic_block.name is not in reachable_blocks:
            Add "Basic block " plus basic_block.name plus " is unreachable" to warnings
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Note: MIR Statistics
Process called "get_mir_statistics" that takes mir_module as MIRModule returns Dictionary[String, Any]:
    Note: Get statistics about a MIR module
    Let function_count be length of mir_module.functions
    Let basic_block_count be 0
    Let instruction_count be 0
    Let global_variable_count be length of mir_module.global_variables
    
    For each function in mir_module.functions:
        Set basic_block_count to basic_block_count plus length of function.basic_blocks
        For each basic_block in function.basic_blocks:
            Set instruction_count to instruction_count plus length of basic_block.instructions
    
    Return dictionary containing:
        "function_count" as function_count
        "basic_block_count" as basic_block_count
        "instruction_count" as instruction_count
        "global_variable_count" as global_variable_count
        "average_instructions_per_block" as (instruction_count divided by basic_block_count if basic_block_count is greater than 0 else 0) 