Note: Runa Compiler: MIR Builder
Note: HIR to MIR lowering pass with Control Flow Graph construction

Import "mir.runa"
Import "../hir/hir.runa"
Import "../types/types.runa"
Import "../ir_context.runa"

Note: MIR Builder - HIR to MIR Lowering with CFG Construction
Type MIRBuilder is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    current_function as Optional[MIRFunction]
    current_basic_block as Optional[MIRBasicBlock]
    variable_map as Dictionary[String, String]
    block_map as Dictionary[String, MIRBasicBlock]
    next_temp_id as Integer
    metadata as Dictionary[String, Any]

Process called "create_mir_builder" that takes context as IRContext and type_system as TypeSystem returns MIRBuilder:
    Note: Create a new MIR builder
    Return MIRBuilder with:
        context as context
        type_system as type_system
        current_function as None
        current_basic_block as None
        variable_map as dictionary containing
        block_map as dictionary containing
        next_temp_id as 0
        metadata as dictionary containing

Process called "build_mir_from_hir" that takes hir_module as HIRModule and context as IRContext returns Dictionary[String, Any]:
    Note: Build MIR from HIR with CFG construction
    Let type_system be create_type_system
    Let builder be create_mir_builder with context as context and type_system as type_system
    
    Let mir_module be create_mir_module with name as hir_module.name
    
    For each declaration in hir_module.declarations:
        Match declaration:
            When HIRProcessDeclaration with name as name and parameters as parameters and return_type as return_type and body as body and is_function as is_function:
                Let mir_function be translate_hir_function with builder as builder and declaration as declaration
                If mir_function.success is false:
                    Return mir_function
                
                Add mir_function.function to mir_module.functions
            Otherwise:
                Note: Skip other declaration types for now
                Return
    
    Return dictionary containing:
        "success" as true
        "mir_module" as mir_module
        "cfg_info" as dictionary containing:
            "function_count" as length of mir_module.functions
            "total_basic_blocks" as get_total_basic_block_count with mir_module as mir_module

Process called "translate_hir_function" that takes builder as MIRBuilder and declaration as HIRProcessDeclaration returns Dictionary[String, Any]:
    Note: Translate a HIR function to MIR function
    Let mir_parameters be list containing
    For each param in declaration.parameters:
        Let mir_param be MIRParameter with:
            name as param.name
            type as (param.type_annotation if param.type_annotation is not None else IRUnknownType)
            is_mutable as param.is_mutable
        Add mir_param to mir_parameters
    
    Let return_type be (declaration.return_type if declaration.return_type is not None else IRUnknownType)
    Let mir_function be create_mir_function with name as declaration.name and parameters as mir_parameters and return_type as return_type
    
    Set builder.current_function to mir_function
    Set builder.current_basic_block to (mir_function.basic_blocks at index 0)
    
    Note: Add parameters to variable map
    For each param in mir_parameters:
        Set builder.variable_map at key param.name to param.name
    
    Note: Translate function body
    Let body_result be translate_hir_statements with builder as builder and statements as declaration.body
    If body_result.success is false:
        Return body_result
    
    Note: Add implicit return if needed
    If builder.current_basic_block.terminator is MIRUnreachableTerminator:
        Let return_inst be create_mir_return_terminator with value as None
        Set builder.current_basic_block.terminator to return_inst
    
    Note: Compute CFG relationships
    Compute_cfg_predecessors with mir_function as mir_function
    Compute_cfg_successors with mir_function as mir_function
    
    Set builder.current_function to None
    Set builder.current_basic_block to None
    
    Return dictionary containing:
        "success" as true
        "function" as mir_function

Process called "translate_hir_statements" that takes builder as MIRBuilder and statements as List[HIRStatement] returns Dictionary[String, Any]:
    Note: Translate HIR statements to MIR instructions
    For each statement in statements:
        Let result be translate_hir_statement with builder as builder and statement as statement
        If result.success is false:
            Return result
    
    Return dictionary containing:
        "success" as true

Process called "translate_hir_statement" that takes builder as MIRBuilder and statement as HIRStatement returns Dictionary[String, Any]:
    Note: Translate a HIR statement to MIR instructions
    Match statement:
        When HIRExpressionStatement with expression as expression:
            Let result be translate_hir_expression with builder as builder and expression as expression
            If result.success is false:
                Return result
            Return dictionary containing:
                "success" as true
        
        When HIRVariableDeclaration with name as name and type_annotation as type_annotation and initializer as initializer and is_mutable as is_mutable:
            Let var_type be (type_annotation if type_annotation is not None else IRUnknownType)
            Let temp_var be generate_temp_variable with builder as builder
            
            Note: Allocate space for variable
            Let alloca_inst be create_mir_alloca with destination as temp_var and type as var_type and size as get_type_size with type_system as builder.type_system and ir_type as var_type
            Add alloca_inst to builder.current_basic_block.instructions
            
            Set builder.variable_map at key name to temp_var
            Set builder.current_function.local_variables at key temp_var to var_type
            
            If initializer is not None:
                Let init_result be translate_hir_expression with builder as builder and expression as initializer
                If init_result.success is false:
                    Return init_result
                
                Let store_inst be create_mir_store with destination as temp_var and source as init_result.result and type as var_type
                Add store_inst to builder.current_basic_block.instructions
            
            Return dictionary containing:
                "success" as true
        
        When HIRAssignment with target as target and value as value:
            Let target_result be translate_hir_expression with builder as builder and expression as target
            If target_result.success is false:
                Return target_result
            
            Let value_result be translate_hir_expression with builder as builder and expression as value
            If value_result.success is false:
                Return value_result
            
            Let store_inst be create_mir_store with destination as target_result.result and source as value_result.result and type as get_hir_inferred_type with node as value
            Add store_inst to builder.current_basic_block.instructions
            
            Return dictionary containing:
                "success" as true
        
        When HIRIfStatement with condition as condition and then_block as then_block and else_block as else_block:
            Let condition_result be translate_hir_expression with builder as builder and expression as condition
            If condition_result.success is false:
                Return condition_result
            
            Let then_block_name be generate_block_name with builder as builder and prefix as "then"
            Let else_block_name be generate_block_name with builder as builder and prefix as "else"
            Let merge_block_name be generate_block_name with builder as builder and prefix as "merge"
            
            Let then_block be create_mir_basic_block with name as then_block_name
            Let else_block be create_mir_basic_block with name as else_block_name
            Let merge_block be create_mir_basic_block with name as merge_block_name
            
            Set builder.block_map at key then_block_name to then_block
            Set builder.block_map at key else_block_name to else_block
            Set builder.block_map at key merge_block_name to merge_block
            
            Add then_block to builder.current_function.basic_blocks
            Add else_block to builder.current_function.basic_blocks
            Add merge_block to builder.current_function.basic_blocks
            
            Note: Create branch instruction
            Let branch_terminator be create_mir_branch_terminator with condition as condition_result.result and true_target as then_block_name and false_target as else_block_name
            Set builder.current_basic_block.terminator to branch_terminator
            
            Note: Translate then block
            Set builder.current_basic_block to then_block
            Let then_result be translate_hir_statements with builder as builder and statements as then_block
            If then_result.success is false:
                Return then_result
            
            If then_block.terminator is MIRUnreachableTerminator:
                Let jump_terminator be create_mir_jump_terminator with target as merge_block_name
                Set then_block.terminator to jump_terminator
            
            Note: Translate else block
            Set builder.current_basic_block to else_block
            If else_block is not None:
                Let else_result be translate_hir_statements with builder as builder and statements as else_block
                If else_result.success is false:
                    Return else_result
                
                If else_block.terminator is MIRUnreachableTerminator:
                    Let jump_terminator be create_mir_jump_terminator with target as merge_block_name
                    Set else_block.terminator to jump_terminator
            
            Note: Continue with merge block
            Set builder.current_basic_block to merge_block
            
            Return dictionary containing:
                "success" as true
        
        When HIRReturnStatement with value as value:
            Let return_value be None
            If value is not None:
                Let value_result be translate_hir_expression with builder as builder and expression as value
                If value_result.success is false:
                    Return value_result
                Set return_value to value_result.result
            
            Let return_terminator be create_mir_return_terminator with value as return_value
            Set builder.current_basic_block.terminator to return_terminator
            
            Return dictionary containing:
                "success" as true
        
        Otherwise:
            Return dictionary containing:
                "success" as false
                "error" as "Unsupported statement type: " plus statement.node_type

Process called "translate_hir_expression" that takes builder as MIRBuilder and expression as HIRExpression returns Dictionary[String, Any]:
    Note: Translate a HIR expression to MIR instructions
    Match expression:
        When HIRLiteral with value as value and literal_type as literal_type and inferred_type as inferred_type:
            Let temp_var be generate_temp_variable with builder as builder
            Let load_inst be create_mir_load with destination as temp_var and source as (string representation of value) and type as inferred_type
            Add load_inst to builder.current_basic_block.instructions
            
            Return dictionary containing:
                "success" as true
                "result" as temp_var
        
        When HIRIdentifier with name as name and resolved_symbol as resolved_symbol and inferred_type as inferred_type:
            Let var_name be lookup_variable with builder as builder and name as name
            If var_name is None:
                Return dictionary containing:
                    "success" as false
                    "error" as "Undefined variable: " plus name
            
            Return dictionary containing:
                "success" as true
                "result" as var_name
        
        When HIRBinaryOperation with left as left and operator as operator and right as right and inferred_type as inferred_type:
            Let left_result be translate_hir_expression with builder as builder and expression as left
            If left_result.success is false:
                Return left_result
            
            Let right_result be translate_hir_expression with builder as builder and expression as right
            If right_result.success is false:
                Return right_result
            
            Let temp_var be generate_temp_variable with builder as builder
            Let binary_inst be create_mir_binary_op with destination as temp_var and left as left_result.result and operator as operator and right as right_result.result and type as inferred_type
            Add binary_inst to builder.current_basic_block.instructions
            
            Return dictionary containing:
                "success" as true
                "result" as temp_var
        
        When HIRFunctionCall with function as function and arguments as arguments and inferred_type as inferred_type:
            Let function_result be translate_hir_expression with builder as builder and expression as function
            If function_result.success is false:
                Return function_result
            
            Let translated_args be list containing
            For each arg in arguments:
                Let arg_result be translate_hir_expression with builder as builder and expression as arg
                If arg_result.success is false:
                    Return arg_result
                Add arg_result.result to translated_args
            
            Let temp_var be generate_temp_variable with builder as builder
            Let call_inst be create_mir_call with destination as temp_var and function as function_result.result and arguments as translated_args and return_type as inferred_type
            Add call_inst to builder.current_basic_block.instructions
            
            Return dictionary containing:
                "success" as true
                "result" as temp_var
        
        Otherwise:
            Return dictionary containing:
                "success" as false
                "error" as "Unsupported expression type: " plus expression.node_type

Note: MIR Builder Utilities
Process called "generate_temp_variable" that takes builder as MIRBuilder returns String:
    Note: Generate a temporary variable name
    Let temp_name be "%temp_" plus builder.next_temp_id
    Set builder.next_temp_id to builder.next_temp_id plus 1
    Return temp_name

Process called "generate_block_name" that takes builder as MIRBuilder and prefix as String returns String:
    Note: Generate a basic block name
    Let block_name be prefix plus "_" plus builder.next_temp_id
    Set builder.next_temp_id to builder.next_temp_id plus 1
    Return block_name

Process called "lookup_variable" that takes builder as MIRBuilder and name as String returns Optional[String]:
    Note: Look up a variable in the current scope
    If name is in builder.variable_map:
        Return builder.variable_map at key name
    Otherwise:
        Return None

Process called "get_total_basic_block_count" that takes mir_module as MIRModule returns Integer:
    Note: Get total number of basic blocks across all functions
    Let total_count be 0
    For each function in mir_module.functions:
        Set total_count to total_count plus length of function.basic_blocks
    Return total_count

Note: MIR Builder Diagnostics
Process called "get_mir_builder_diagnostics" that takes builder as MIRBuilder returns List[IRDiagnostic]:
    Note: Get diagnostics from MIR builder
    Return builder.context.diagnostics

Process called "has_mir_builder_errors" that takes builder as MIRBuilder returns Boolean:
    Note: Check if MIR builder has errors
    Let diagnostics be get_mir_builder_diagnostics with builder as builder
    
    For each diagnostic in diagnostics:
        If diagnostic.severity is equal to "error":
            Return true
    
    Return false 