Note: Runa Compiler: MIR Verifier
Note: Validates MIR for correctness and SSA form

Import "mir.runa"
Import "../types/types.runa"
Import "../ir_context.runa"

Note: MIR Verifier - Validation and SSA Form Checking
Type MIRVerifier is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    diagnostics as List[IRDiagnostic]
    metadata as Dictionary[String, Any]

Process called "create_mir_verifier" that takes context as IRContext and type_system as TypeSystem returns MIRVerifier:
    Note: Create a new MIR verifier
    Return MIRVerifier with:
        context as context
        type_system as type_system
        diagnostics as list containing
        metadata as dictionary containing

Process called "validate_mir" that takes mir_module as MIRModule returns Dictionary[String, Any]:
    Note: Validate a MIR module
    Let type_system be create_type_system
    Let verifier be create_mir_verifier with context as create_ir_context with compilation_unit as "verifier" and source_file as "unknown" and type_system as type_system
    
    Let errors be list containing
    Let warnings be list containing
    
    For each function in mir_module.functions:
        Let function_result be validate_mir_function_detailed with verifier as verifier and mir_function as function
        Add all function_result.errors to errors
        Add all function_result.warnings to warnings
    
    Note: Validate global variables
    For each var_name in mir_module.global_variables:
        Let var_type be mir_module.global_variables at key var_name
        Let type_result be validate_ir_type with verifier as verifier and ir_type as var_type
        If type_result.valid is false:
            Add "Invalid type for global variable " plus var_name to errors
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings
        "diagnostics" as verifier.diagnostics

Process called "validate_mir_function_detailed" that takes verifier as MIRVerifier and mir_function as MIRFunction returns Dictionary[String, Any]:
    Note: Validate a MIR function in detail
    Let errors be list containing
    Let warnings be list containing
    
    Note: Basic CFG validation
    Let cfg_result be validate_mir_function with mir_function as mir_function
    Add all cfg_result.errors to errors
    Add all cfg_result.warnings to warnings
    
    Note: Validate each basic block
    For each basic_block in mir_function.basic_blocks:
        Let block_result be validate_mir_basic_block with verifier as verifier and basic_block as basic_block and function as mir_function
        Add all block_result.errors to errors
        Add all block_result.warnings to warnings
    
    Note: Validate SSA form
    Let ssa_result be validate_ssa_form with verifier as verifier and mir_function as mir_function
    Add all ssa_result.errors to errors
    Add all ssa_result.warnings to warnings
    
    Note: Validate type consistency
    Let type_result be validate_type_consistency with verifier as verifier and mir_function as mir_function
    Add all type_result.errors to errors
    Add all type_result.warnings to warnings
    
    Note: Validate variable definitions
    Let var_result be validate_variable_definitions with verifier as verifier and mir_function as mir_function
    Add all var_result.errors to errors
    Add all var_result.warnings to warnings
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Process called "validate_mir_basic_block" that takes verifier as MIRVerifier and basic_block as MIRBasicBlock and function as MIRFunction returns Dictionary[String, Any]:
    Note: Validate a MIR basic block
    Let errors be list containing
    Let warnings be list containing
    
    Note: Check that block has a terminator
    If basic_block.terminator is MIRUnreachableTerminator:
        Add "Basic block " plus basic_block.name plus " has no terminator" to errors
    
    Note: Validate each instruction
    For each instruction in basic_block.instructions:
        Let inst_result be validate_mir_instruction with verifier as verifier and instruction as instruction and function as function
        Add all inst_result.errors to errors
        Add all inst_result.warnings to warnings
    
    Note: Validate terminator
    Let terminator_result be validate_mir_terminator with verifier as verifier and terminator as basic_block.terminator and function as function
    Add all terminator_result.errors to errors
    Add all terminator_result.warnings to warnings
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Process called "validate_mir_instruction" that takes verifier as MIRVerifier and instruction as MIRInstruction and function as MIRFunction returns Dictionary[String, Any]:
    Note: Validate a MIR instruction
    Let errors be list containing
    Let warnings be list containing
    
    Note: Check that instruction has a destination if it should
    Let destination be get_mir_instruction_destination with instruction as instruction
    If destination is not None:
        If destination is not in function.local_variables:
            Add "Instruction destination " plus destination plus " is not defined" to errors
    
    Note: Check that all sources are defined
    Let sources be get_mir_instruction_sources with instruction as instruction
    For each source in sources:
        If source is not in function.local_variables and source is not in function.parameters:
            Add "Instruction source " plus source plus " is not defined" to errors
    
    Note: Validate instruction-specific constraints
    Match instruction:
        When MIRBinaryOp with destination as destination and left as left and operator as operator and right as right and type as type:
            Let left_type be function.local_variables at key left
            Let right_type be function.local_variables at key right
            If left_type is not equal to right_type:
                Add "Binary operation type mismatch: " plus left plus " (" plus left_type plus ") vs " plus right plus " (" plus right_type plus ")" to warnings
        When MIRCall with destination as destination and function as function_name and arguments as arguments and return_type as return_type:
            If length of arguments is greater than 10:
                Add "Function call with many arguments: " plus function_name to warnings
        Otherwise:
            Note: Other instruction types are generally valid
            Return dictionary containing "valid" as true and "errors" as errors and "warnings" as warnings
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Process called "validate_mir_terminator" that takes verifier as MIRVerifier and terminator as MIRTerminator and function as MIRFunction returns Dictionary[String, Any]:
    Note: Validate a MIR terminator
    Let errors be list containing
    Let warnings be list containing
    
    Match terminator:
        When MIRJumpTerminator with target as target:
            If find_basic_block_by_name with mir_function as function and name as target is None:
                Add "Jump target " plus target plus " does not exist" to errors
        When MIRBranchTerminator with condition as condition and true_target as true_target and false_target as false_target:
            If condition is not in function.local_variables:
                Add "Branch condition " plus condition plus " is not defined" to errors
            If find_basic_block_by_name with mir_function as function and name as true_target is None:
                Add "Branch true target " plus true_target plus " does not exist" to errors
            If find_basic_block_by_name with mir_function as function and name as false_target is None:
                Add "Branch false target " plus false_target plus " does not exist" to errors
        When MIRReturnTerminator with value as value:
            If value is not None:
                If value is not in function.local_variables:
                    Add "Return value " plus value plus " is not defined" to errors
        Otherwise:
            Note: Unreachable terminator is valid
            Return dictionary containing "valid" as true and "errors" as errors and "warnings" as warnings
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Process called "validate_ssa_form" that takes verifier as MIRVerifier and mir_function as MIRFunction returns Dictionary[String, Any]:
    Note: Validate Static Single Assignment (SSA) form
    Let errors be list containing
    Let warnings be list containing
    
    Let variable_definitions be dictionary containing
    Let variable_uses be dictionary containing
    
    For each basic_block in mir_function.basic_blocks:
        For each instruction in basic_block.instructions:
            Let destination be get_mir_instruction_destination with instruction as instruction
            If destination is not None:
                If destination is in variable_definitions:
                    Add "Variable " plus destination plus " is defined multiple times (violates SSA)" to errors
                Otherwise:
                    Set variable_definitions at key destination to basic_block.name
            
            Let sources be get_mir_instruction_sources with instruction as instruction
            For each source in sources:
                If source is not in variable_uses:
                    Set variable_uses at key source to list containing
                Add basic_block.name to variable_uses at key source
    
    Note: Check that all used variables are defined
    For each var_name in variable_uses:
        If var_name is not in variable_definitions and var_name is not in mir_function.parameters:
            Add "Variable " plus var_name plus " is used but not defined" to errors
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Process called "validate_type_consistency" that takes verifier as MIRVerifier and mir_function as MIRFunction returns Dictionary[String, Any]:
    Note: Validate type consistency across the function
    Let errors be list containing
    Let warnings be list containing
    
    For each basic_block in mir_function.basic_blocks:
        For each instruction in basic_block.instructions:
            Let inst_type be get_mir_instruction_type with instruction as instruction
            Let destination be get_mir_instruction_destination with instruction as instruction
            
            If destination is not None:
                Let expected_type be function.local_variables at key destination
                Match instruction:
                    When MIRBinaryOp with destination as dest and left as left and operator as operator and right as right and type as type:
                        Let left_type be function.local_variables at key left
                        Let right_type be function.local_variables at key right
                        If type is not equal to expected_type:
                            Add "Binary operation result type mismatch for " plus destination to warnings
                    When MIRCall with destination as dest and function as func and arguments as args and return_type as return_type:
                        If return_type is not equal to expected_type:
                            Add "Function call return type mismatch for " plus destination to warnings
                    Otherwise:
                        Note: Other instruction types are generally type-consistent
                        Return dictionary containing "valid" as true and "errors" as errors and "warnings" as warnings
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Process called "validate_variable_definitions" that takes verifier as MIRVerifier and mir_function as MIRFunction returns Dictionary[String, Any]:
    Note: Validate variable definitions and usage
    Let errors be list containing
    Let warnings be list containing
    
    Let defined_vars be set containing
    Let used_vars be set containing
    
    For each basic_block in mir_function.basic_blocks:
        For each instruction in basic_block.instructions:
            Let destination be get_mir_instruction_destination with instruction as instruction
            If destination is not None:
                Add destination to defined_vars
            
            Let sources be get_mir_instruction_sources with instruction as instruction
            For each source in sources:
                Add source to used_vars
    
    Note: Check for unused variables
    For each var_name in defined_vars:
        If var_name is not in used_vars:
            Add "Variable " plus var_name plus " is defined but never used" to warnings
    
    Note: Check for undefined variables
    For each var_name in used_vars:
        If var_name is not in defined_vars and var_name is not in mir_function.parameters:
            Add "Variable " plus var_name plus " is used but not defined" to errors
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Process called "validate_ir_type" that takes verifier as MIRVerifier and ir_type as IRType returns Dictionary[String, Any]:
    Note: Validate an IR type
    Let errors be list containing
    Let warnings be list containing
    
    Match ir_type:
        When IRPrimitiveType with name as name and size as size and alignment as alignment:
            If size is less than or equal to 0:
                Add "Invalid size for primitive type " plus name to errors
            If alignment is less than 1:
                Add "Invalid alignment for primitive type " plus name to errors
        When IRPointerType with pointee as pointee and is_mutable as is_mutable:
            Let pointee_result be validate_ir_type with verifier as verifier and ir_type as pointee
            Add all pointee_result.errors to errors
            Add all pointee_result.warnings to warnings
        When IRArrayType with element_type as element_type and length as length:
            Let element_result be validate_ir_type with verifier as verifier and ir_type as element_type
            Add all element_result.errors to errors
            Add all element_result.warnings to warnings
            If length is not None and length is less than 0:
                Add "Invalid array length" to errors
        Otherwise:
            Note: Other type types are generally valid
            Return dictionary containing "valid" as true and "errors" as errors and "warnings" as warnings
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Note: MIR Verifier Diagnostics
Process called "get_mir_verifier_diagnostics" that takes verifier as MIRVerifier returns List[IRDiagnostic]:
    Note: Get diagnostics from MIR verifier
    Return verifier.diagnostics

Process called "has_mir_verifier_errors" that takes verifier as MIRVerifier returns Boolean:
    Note: Check if MIR verifier has errors
    Let diagnostics be get_mir_verifier_diagnostics with verifier as verifier
    
    For each diagnostic in diagnostics:
        If diagnostic.severity is equal to "error":
            Return true
    
    Return false

Note: MIR Verifier Statistics
Process called "get_mir_verification_statistics" that takes mir_module as MIRModule returns Dictionary[String, Any]:
    Note: Get verification statistics for a MIR module
    Let type_system be create_type_system
    Let verifier be create_mir_verifier with context as create_ir_context with compilation_unit as "stats" and source_file as "unknown" and type_system as type_system
    
    Let validation_result be validate_mir with mir_module as mir_module
    Let diagnostics be get_mir_verifier_diagnostics with verifier as verifier
    
    Let error_count be 0
    Let warning_count be 0
    
    For each diagnostic in diagnostics:
        If diagnostic.severity is equal to "error":
            Set error_count to error_count plus 1
        Otherwise if diagnostic.severity is equal to "warning":
            Set warning_count to warning_count plus 1
    
    Return dictionary containing:
        "valid" as validation_result.valid
        "error_count" as error_count
        "warning_count" as warning_count
        "total_diagnostics" as length of diagnostics
        "function_count" as length of mir_module.functions
        "basic_block_count" as get_total_basic_block_count with mir_module as mir_module 