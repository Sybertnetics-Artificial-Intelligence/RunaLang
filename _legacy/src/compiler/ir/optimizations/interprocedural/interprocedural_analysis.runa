Note: Runa Compiler: Interprocedural Analysis Framework
Note: Provides interprocedural analysis and optimization capabilities

Import "../../hir/hir.runa"
Import "../../mir/mir.runa"
Import "../../types/types.runa"
Import "../../ir_context.runa"
Import "../analysis/control_flow_analysis.runa"

Note: Interprocedural Analysis Types
Type InterproceduralAnalysisPass is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    call_graph as CallGraph
    interprocedural_info as InterproceduralInfo
    optimization_decisions as List[InterproceduralDecision]
    metadata as Dictionary[String, Any]

Type CallGraph is Dictionary with:
    nodes as Dictionary[String, CallGraphNode]
    edges as List[CallGraphEdge]
    strongly_connected_components as List[List[String]]
    metadata as Dictionary[String, Any]

Type CallGraphNode is Dictionary with:
    function_name as String
    function_type as String
    call_sites as List[String]
    callees as List[String]
    callers as List[String]
    metadata as Dictionary[String, Any]

Type CallGraphEdge is Dictionary with:
    from_function as String
    to_function as String
    call_site as String
    call_type as String
    metadata as Dictionary[String, Any]

Type InterproceduralInfo is Dictionary with:
    function_summaries as Dictionary[String, FunctionSummary]
    side_effects as Dictionary[String, SideEffectInfo]
    data_flow as Dictionary[String, DataFlowInfo]
    metadata as Dictionary[String, Any]

Type FunctionSummary is Dictionary with:
    function_name as String
    parameters as List[ParameterSummary]
    return_value as ReturnSummary
    side_effects as List[String]
    metadata as Dictionary[String, Any]

Type ParameterSummary is Dictionary with:
    parameter_name as String
    parameter_type as String
    may_be_modified as Boolean
    may_be_read as Boolean
    metadata as Dictionary[String, Any]

Type ReturnSummary is Dictionary with:
    return_type as String
    always_returns as Boolean
    may_return_null as Boolean
    metadata as Dictionary[String, Any]

Type SideEffectInfo is Dictionary with:
    function_name as String
    global_variables_read as List[String]
    global_variables_written as List[String]
    file_operations as List[String]
    network_operations as List[String]
    metadata as Dictionary[String, Any]

Type DataFlowInfo is Dictionary with:
    function_name as String
    input_parameters as List[String]
    output_parameters as List[String]
    global_variables as List[String]
    metadata as Dictionary[String, Any]

Type InterproceduralDecision is Dictionary with:
    optimization_type as String
    target_function as String
    confidence as Float
    expected_benefit as Float
    reason as String
    metadata as Dictionary[String, Any]

Process called "create_interprocedural_analysis_pass" that takes context as IRContext and type_system as TypeSystem returns InterproceduralAnalysisPass:
    Note: Create a new interprocedural analysis pass
    Return InterproceduralAnalysisPass with:
        context as context
        type_system as type_system
        call_graph as CallGraph with:
            nodes as dictionary containing
            edges as list containing
            strongly_connected_components as list containing
            metadata as dictionary containing
        interprocedural_info as InterproceduralInfo with:
            function_summaries as dictionary containing
            side_effects as dictionary containing
            data_flow as dictionary containing
            metadata as dictionary containing
        optimization_decisions as list containing
        metadata as dictionary containing

Process called "analyze_interprocedural" that takes ir_module as IRModule and context as IRContext returns Dictionary[String, Any]:
    Note: Perform interprocedural analysis on IR module
    Let type_system be create_type_system
    Let analyzer be create_interprocedural_analysis_pass with context as context and type_system as type_system
    
    Let optimized_module be copy_ir_module with module as ir_module
    Let total_optimizations be 0
    
    Note: Build call graph
    Let call_graph_result be build_call_graph with analyzer as analyzer and module as optimized_module
    Set analyzer.call_graph to call_graph_result.call_graph
    
    Note: Analyze function summaries
    Let summary_result be analyze_function_summaries with analyzer as analyzer and module as optimized_module
    Set analyzer.interprocedural_info.function_summaries to summary_result.summaries
    
    Note: Analyze side effects
    Let side_effect_result be analyze_side_effects with analyzer as analyzer and module as optimized_module
    Set analyzer.interprocedural_info.side_effects to side_effect_result.side_effects
    
    Note: Analyze data flow
    Let data_flow_result be analyze_interprocedural_data_flow with analyzer as analyzer and module as optimized_module
    Set analyzer.interprocedural_info.data_flow to data_flow_result.data_flow
    
    Note: Make optimization decisions
    Let decisions be make_interprocedural_optimization_decisions with analyzer as analyzer
    
    Note: Apply optimizations
    For each decision in decisions:
        Let result be apply_interprocedural_optimization with analyzer as analyzer and decision as decision and module as optimized_module
        If result.success:
            Set optimized_module to result.module
            Set total_optimizations to total_optimizations plus 1
    
    Return dictionary containing:
        "success" as true
        "optimized_module" as optimized_module
        "statistics" as dictionary containing:
            "optimizations_applied" as total_optimizations
            "decisions_made" as length of decisions
            "call_graph_size" as length of analyzer.call_graph.nodes
            "function_summaries" as length of analyzer.interprocedural_info.function_summaries

Process called "build_call_graph" that takes analyzer as InterproceduralAnalysisPass and module as IRModule returns Dictionary[String, Any]:
    Note: Build call graph from IR module
    Let call_graph be CallGraph with:
        nodes as dictionary containing
        edges as list containing
        strongly_connected_components as list containing
        metadata as dictionary containing
    
    Note: Add nodes for all functions
    For each declaration in module.declarations:
        If declaration is HIRProcessDeclaration:
            Let node be CallGraphNode with:
                function_name as declaration.name
                function_type as "function"
                call_sites as list containing
                callees as list containing
                callers as list containing
                metadata as dictionary containing
            
            Set call_graph.nodes at key declaration.name to node
    
    Note: Add edges for function calls
    For each declaration in module.declarations:
        If declaration is HIRProcessDeclaration:
            Let calls be find_function_calls with function as declaration
            For each call in calls:
                Let edge be CallGraphEdge with:
                    from_function as declaration.name
                    to_function as call.callee
                    call_site as call.site
                    call_type as "direct"
                    metadata as dictionary containing
                
                Add edge to call_graph.edges
                
                Note: Update node information
                Let from_node be call_graph.nodes at key declaration.name
                Add call.site to from_node.call_sites
                Add call.callee to from_node.callees
                
                If call.callee is in call_graph.nodes:
                    Let to_node be call_graph.nodes at key call.callee
                    Add declaration.name to to_node.callers
    
    Note: Find strongly connected components
    Let sccs be find_strongly_connected_components with call_graph as call_graph
    Set call_graph.strongly_connected_components to sccs
    
    Return dictionary containing:
        "call_graph" as call_graph
        "statistics" as dictionary containing:
            "nodes" as length of call_graph.nodes
            "edges" as length of call_graph.edges
            "sccs" as length of sccs

Process called "find_function_calls" that takes function as HIRProcessDeclaration returns List[Dictionary[String, Any]]:
    Note: Find all function calls in a function
    Let calls be list containing
    
    For each statement in function.body:
        Let function_calls be find_calls_in_statement with statement as statement
        For each call in function_calls:
            Add call to calls
    
    Return calls

Process called "find_calls_in_statement" that takes statement as HIRNode returns List[Dictionary[String, Any]]:
    Note: Find function calls in a statement
    Let calls be list containing
    
    Match statement:
        When HIRFunctionCall:
            Add dictionary containing:
                "callee" as statement.function_name
                "site" as "direct_call"
            to calls
        When HIRAssignment:
            Let value_calls be find_calls_in_expression with expression as statement.value
            For each call in value_calls:
                Add call to calls
        Otherwise:
            Note: Recursively check nested statements
            Let nested be get_nested_statements with statement as statement
            For each nested_stmt in nested:
                Let nested_calls be find_calls_in_statement with statement as nested_stmt
                For each call in nested_calls:
                    Add call to calls
    
    Return calls

Process called "find_calls_in_expression" that takes expression as HIRNode returns List[Dictionary[String, Any]]:
    Note: Find function calls in an expression
    Let calls be list containing
    
    Match expression:
        When HIRFunctionCall:
            Add dictionary containing:
                "callee" as expression.function_name
                "site" as "expression_call"
            to calls
        When HIRBinaryOperation:
            Let left_calls be find_calls_in_expression with expression as expression.left
            Let right_calls be find_calls_in_expression with expression as expression.right
            For each call in left_calls:
                Add call to calls
            For each call in right_calls:
                Add call to calls
        Otherwise:
            Return calls
    
    Return calls

Process called "find_strongly_connected_components" that takes call_graph as CallGraph returns List[List[String]]:
    Note: Find strongly connected components in call graph using Tarjan's algorithm
    Let sccs be list containing
    Let visited be dictionary containing
    Let low_link be dictionary containing
    Let stack be list containing
    Let index be 0
    
    For each function_name in call_graph.nodes:
        If function_name is not in visited:
            Let component be tarjan_dfs with call_graph as call_graph and node as function_name and visited as visited and low_link as low_link and stack as stack and index as index
            If length of component is greater than 0:
                Add component to sccs
    
    Return sccs

Process called "tarjan_dfs" that takes call_graph as CallGraph and node as String and visited as Dictionary[String, Integer] and low_link as Dictionary[String, Integer] and stack as List[String] and index as Integer returns List[String]:
    Note: Tarjan's DFS for finding strongly connected components
    Note: This is a simplified implementation
    Let component be list containing
    Add node to component
    Return component

Process called "analyze_function_summaries" that takes analyzer as InterproceduralAnalysisPass and module as IRModule returns Dictionary[String, Any]:
    Note: Analyze function summaries for interprocedural optimization
    Let summaries be dictionary containing
    
    For each declaration in module.declarations:
        If declaration is HIRProcessDeclaration:
            Let summary be create_function_summary with function as declaration
            Set summaries at key declaration.name to summary
    
    Return dictionary containing:
        "summaries" as summaries
        "statistics" as dictionary containing:
            "functions_analyzed" as length of summaries

Process called "create_function_summary" that takes function as HIRProcessDeclaration returns FunctionSummary:
    Note: Create a function summary for interprocedural analysis
    Let parameters be list containing
    
    For each param in function.parameters:
        Let param_summary be ParameterSummary with:
            parameter_name as param.name
            parameter_type as param.type_name
            may_be_modified as true
            may_be_read as true
            metadata as dictionary containing
        
        Add param_summary to parameters
    
    Let return_summary be ReturnSummary with:
        return_type as function.return_type
        always_returns as true
        may_return_null as false
        metadata as dictionary containing
    
    Let side_effects be list containing
    
    Return FunctionSummary with:
        function_name as function.name
        parameters as parameters
        return_value as return_summary
        side_effects as side_effects
        metadata as dictionary containing

Process called "analyze_side_effects" that takes analyzer as InterproceduralAnalysisPass and module as IRModule returns Dictionary[String, Any]:
    Note: Analyze side effects for interprocedural optimization
    Let side_effects be dictionary containing
    
    For each declaration in module.declarations:
        If declaration is HIRProcessDeclaration:
            Let side_effect_info be analyze_function_side_effects with function as declaration
            Set side_effects at key declaration.name to side_effect_info
    
    Return dictionary containing:
        "side_effects" as side_effects
        "statistics" as dictionary containing:
            "functions_analyzed" as length of side_effects

Process called "analyze_function_side_effects" that takes function as HIRProcessDeclaration returns SideEffectInfo:
    Note: Analyze side effects of a function
    Let global_reads be list containing
    Let global_writes be list containing
    Let file_ops be list containing
    Let network_ops be list containing
    
    For each statement in function.body:
        Let effects be analyze_statement_side_effects with statement as statement
        For each read in effects.global_reads:
            Add read to global_reads
        For each write in effects.global_writes:
            Add write to global_writes
        For each file_op in effects.file_operations:
            Add file_op to file_ops
        For each net_op in effects.network_operations:
            Add net_op to network_ops
    
    Return SideEffectInfo with:
        function_name as function.name
        global_variables_read as global_reads
        global_variables_written as global_writes
        file_operations as file_ops
        network_operations as network_ops
        metadata as dictionary containing

Process called "analyze_statement_side_effects" that takes statement as HIRNode returns Dictionary[String, Any]:
    Note: Analyze side effects of a statement
    Let global_reads be list containing
    Let global_writes be list containing
    Let file_ops be list containing
    Let network_ops be list containing
    
    Match statement:
        When HIRAssignment:
            If is_global_variable with target as statement.target:
                Add statement.target to global_writes
        When HIRFunctionCall:
            If statement.function_name is in ["read_file", "write_file"]:
                Add statement.function_name to file_ops
            If statement.function_name is in ["http_get", "http_post"]:
                Add statement.function_name to network_ops
        Otherwise:
            Note: Recursively check nested statements
            Let nested be get_nested_statements with statement as statement
            For each nested_stmt in nested:
                Let effects be analyze_statement_side_effects with statement as nested_stmt
                For each read in effects.global_reads:
                    Add read to global_reads
                For each write in effects.global_writes:
                    Add write to global_writes
                For each file_op in effects.file_operations:
                    Add file_op to file_ops
                For each net_op in effects.network_operations:
                    Add net_op to network_ops
    
    Return dictionary containing:
        "global_reads" as global_reads
        "global_writes" as global_writes
        "file_operations" as file_ops
        "network_operations" as network_ops

Process called "is_global_variable" that takes target as String returns Boolean:
    Note: Check if a variable is global
    Note: This is a simplified check - real implementation would be more sophisticated
    Return target starts with "global_"

Process called "analyze_interprocedural_data_flow" that takes analyzer as InterproceduralAnalysisPass and module as IRModule returns Dictionary[String, Any]:
    Note: Analyze interprocedural data flow
    Let data_flow be dictionary containing
    
    For each declaration in module.declarations:
        If declaration is HIRProcessDeclaration:
            Let flow_info be analyze_function_data_flow with function as declaration
            Set data_flow at key declaration.name to flow_info
    
    Return dictionary containing:
        "data_flow" as data_flow
        "statistics" as dictionary containing:
            "functions_analyzed" as length of data_flow

Process called "analyze_function_data_flow" that takes function as HIRProcessDeclaration returns DataFlowInfo:
    Note: Analyze data flow of a function
    Let input_params be list containing
    Let output_params be list containing
    Let global_vars be list containing
    
    For each param in function.parameters:
        Add param.name to input_params
        Add param.name to output_params
    
    For each statement in function.body:
        Let flow be analyze_statement_data_flow with statement as statement
        For each global_var in flow.global_variables:
            Add global_var to global_vars
    
    Return DataFlowInfo with:
        function_name as function.name
        input_parameters as input_params
        output_parameters as output_params
        global_variables as global_vars
        metadata as dictionary containing

Process called "analyze_statement_data_flow" that takes statement as HIRNode returns Dictionary[String, Any]:
    Note: Analyze data flow of a statement
    Let global_vars be list containing
    
    Match statement:
        When HIRAssignment:
            If is_global_variable with target as statement.target:
                Add statement.target to global_vars
        Otherwise:
            Note: Recursively check nested statements
            Let nested be get_nested_statements with statement as statement
            For each nested_stmt in nested:
                Let flow be analyze_statement_data_flow with statement as nested_stmt
                For each global_var in flow.global_variables:
                    Add global_var to global_vars
    
    Return dictionary containing:
        "global_variables" as global_vars

Process called "make_interprocedural_optimization_decisions" that takes analyzer as InterproceduralAnalysisPass returns List[InterproceduralDecision]:
    Note: Make interprocedural optimization decisions
    Let decisions be list containing
    
    Note: Inline small functions
    For each function_name in analyzer.call_graph.nodes:
        Let node be analyzer.call_graph.nodes at key function_name
        If length of node.callees is 0 and length of node.callers is 1:
            Let decision be InterproceduralDecision with:
                optimization_type as "function_inlining"
                target_function as function_name
                confidence as 0.8
                expected_benefit as 0.1
                reason as "Small function with single caller"
                metadata as dictionary containing
            
            Add decision to decisions
    
    Note: Optimize functions with no side effects
    For each function_name in analyzer.interprocedural_info.side_effects:
        Let side_effects be analyzer.interprocedural_info.side_effects at key function_name
        If length of side_effects.global_variables_written is 0 and length of side_effects.file_operations is 0:
            Let decision be InterproceduralDecision with:
                optimization_type as "pure_function_optimization"
                target_function as function_name
                confidence as 0.9
                expected_benefit as 0.15
                reason as "Pure function - no side effects"
                metadata as dictionary containing
            
            Add decision to decisions
    
    Return decisions

Process called "apply_interprocedural_optimization" that takes analyzer as InterproceduralAnalysisPass and decision as InterproceduralDecision and module as IRModule returns Dictionary[String, Any]:
    Note: Apply an interprocedural optimization decision
    Match decision.optimization_type:
        When "function_inlining":
            Return apply_interprocedural_inlining with analyzer as analyzer and target as decision.target_function and module as module
        When "pure_function_optimization":
            Return apply_pure_function_optimization with analyzer as analyzer and target as decision.target_function and module as module
        Otherwise:
            Return dictionary containing:
                "success" as false
                "error" as "Unknown optimization type"

Process called "apply_interprocedural_inlining" that takes analyzer as InterproceduralAnalysisPass and target as String and module as IRModule returns Dictionary[String, Any]:
    Note: Apply interprocedural function inlining
    Let optimized_module be copy_ir_module with module as module
    
    Note: Find and inline the target function
    For each declaration in optimized_module.declarations:
        If declaration is HIRProcessDeclaration and declaration.name is equal to target:
            Let inlined_result be inline_function_interprocedural with analyzer as analyzer and function as declaration and module as optimized_module
            If inlined_result.success:
                Set optimized_module to inlined_result.module
    
    Return dictionary containing:
        "success" as true
        "module" as optimized_module

Process called "inline_function_interprocedural" that takes analyzer as InterproceduralAnalysisPass and function as HIRProcessDeclaration and module as IRModule returns Dictionary[String, Any]:
    Note: Inline a function using interprocedural information
    Let optimized_module be copy_ir_module with module as module
    
    Note: Replace function calls with inlined body
    For each declaration in optimized_module.declarations:
        If declaration is HIRProcessDeclaration:
            Let inlined_body be inline_calls_interprocedural with analyzer as analyzer and function as declaration and target_function as function
            Let optimized_function be HIRProcessDeclaration with:
                name as declaration.name
                parameters as declaration.parameters
                return_type as declaration.return_type
                body as inlined_body
                is_function as declaration.is_function
            
            Set declaration to optimized_function
    
    Return dictionary containing:
        "success" as true
        "module" as optimized_module

Process called "inline_calls_interprocedural" that takes analyzer as InterproceduralAnalysisPass and function as HIRProcessDeclaration and target_function as HIRProcessDeclaration returns List[HIRNode]:
    Note: Inline calls to target function using interprocedural information
    Let optimized_body be list containing
    
    For each statement in function.body:
        Let inlined_stmt be inline_calls_interprocedural_statement with analyzer as analyzer and statement as statement and target_function as target_function
        Add inlined_stmt to optimized_body
    
    Return optimized_body

Process called "inline_calls_interprocedural_statement" that takes analyzer as InterproceduralAnalysisPass and statement as HIRNode and target_function as HIRProcessDeclaration returns HIRNode:
    Note: Inline calls to target function in a statement using interprocedural information
    Match statement:
        When HIRFunctionCall:
            If statement.function_name is equal to target_function.name:
                Return create_interprocedural_inlined_call with analyzer as analyzer and call as statement and target_function as target_function
            Otherwise:
                Return statement
        Otherwise:
            Return statement

Process called "create_interprocedural_inlined_call" that takes analyzer as InterproceduralAnalysisPass and call as HIRFunctionCall and target_function as HIRProcessDeclaration returns HIRNode:
    Note: Create an interprocedural inlined function call
    Let inlined_body be list containing
    
    Note: Create parameter assignments
    For i from 0 to length of call.arguments:
        Let param be target_function.parameters at index i
        Let arg be call.arguments at index i
        Let assignment be HIRAssignment with:
            target as param.name
            value as arg
        
        Add assignment to inlined_body
    
    Note: Add function body
    For each stmt in target_function.body:
        Add stmt to inlined_body
    
    Return HIRBlockStatement with:
        statements as inlined_body

Process called "apply_pure_function_optimization" that takes analyzer as InterproceduralAnalysisPass and target as String and module as IRModule returns Dictionary[String, Any]:
    Note: Apply pure function optimization
    Let optimized_module be copy_ir_module with module as module
    
    Note: Find and optimize the pure function
    For each declaration in optimized_module.declarations:
        If declaration is HIRProcessDeclaration and declaration.name is equal to target:
            Let optimized_function be optimize_pure_function with analyzer as analyzer and function as declaration
            Set declaration to optimized_function
    
    Return dictionary containing:
        "success" as true
        "module" as optimized_module

Process called "optimize_pure_function" that takes analyzer as InterproceduralAnalysisPass and function as HIRProcessDeclaration returns HIRProcessDeclaration:
    Note: Optimize a pure function
    Let optimized_body be list containing
    
    For each statement in function.body:
        Let optimized_stmt be optimize_pure_statement with analyzer as analyzer and statement as statement
        Add optimized_stmt to optimized_body
    
    Return HIRProcessDeclaration with:
        name as function.name
        parameters as function.parameters
        return_type as function.return_type
        body as optimized_body
        is_function as function.is_function

Process called "optimize_pure_statement" that takes analyzer as InterproceduralAnalysisPass and statement as HIRNode returns HIRNode:
    Note: Optimize a statement in a pure function
    Note: This is a simplified optimization - real implementation would be more sophisticated
    Return statement

Process called "get_nested_statements" that takes statement as HIRNode returns List[HIRNode]:
    Note: Get nested statements from a compound statement
    Match statement:
        When HIRBlockStatement:
            Return statement.statements
        When HIRIfStatement:
            Let nested be list containing
            Add statement.then_branch to nested
            If statement.else_branch is not None:
                Add statement.else_branch to nested
            Return nested
        Otherwise:
            Return list containing

Process called "copy_ir_module" that takes module as IRModule returns IRModule:
    Note: Create a copy of IR module
    Return IRModule with:
        name as module.name
        declarations as module.declarations
        imports as module.imports
        metadata as module.metadata 