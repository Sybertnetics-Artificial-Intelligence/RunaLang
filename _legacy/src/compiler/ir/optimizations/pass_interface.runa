Note: Runa Compiler: Optimization Pass Interface
Note: Functional optimization pass protocol and utilities

Import "../types/types.runa"
Import "../ir_context.runa"

Note: Optimization Pass Protocol - Functional Design
Note: A pass is anything that transforms an IR module and returns a new one
Type OptimizationPassResult[T] is Success with module as T and statistics as Dictionary[String, Any] | Failure with diagnostics as List[IRDiagnostic]

Note: Pass Interface - All passes must implement this
Type Pass[T] is Dictionary with:
    name as String
    description as String
    level as Integer
    enabled as Boolean
    metadata as Dictionary[String, Any]

Process called "create_pass" that takes name as String and description as String and level as Integer returns Pass[Any]:
    Note: Create a base pass configuration
    Return Pass[Any] with:
        name as name
        description as description
        level as level
        enabled as true
        metadata as dictionary containing

Note: Pass Execution Interface
Process called "run_pass" that takes pass as Pass[T] and module as T and context as IRContext returns OptimizationPassResult[T]:
    Note: Execute a pass on a module
    Note: This is a placeholder - actual passes will override this
    Return Failure with diagnostics as list containing

Note: Pass Composition - Chain multiple passes
Process called "chain_passes" that takes passes as List[Pass[T]] and module as T and context as IRContext returns OptimizationPassResult[T]:
    Note: Execute multiple passes in sequence
    Let current_module be module
    Let total_statistics be dictionary containing
    Let total_diagnostics be list containing
    
    For each pass in passes:
        If pass.enabled:
            Let result be run_pass with pass as pass and module as current_module and context as context
            
            Match result:
                When Success with module as new_module and statistics as statistics:
                    Set current_module to new_module
                    Set total_statistics at key pass.name to statistics
                When Failure with diagnostics as diagnostics:
                    Add all diagnostics to total_diagnostics
                    Return Failure with diagnostics as total_diagnostics
    
    Return Success with module as current_module and statistics as total_statistics

Note: Pass Filtering and Selection
Process called "filter_passes_by_level" that takes passes as List[Pass[T]] and level as Integer returns List[Pass[T]]:
    Note: Filter passes by optimization level
    Let filtered_passes be list containing
    
    For each pass in passes:
        If pass.level is less than or equal to level and pass.enabled:
            Add pass to filtered_passes
    
    Return filtered_passes

Process called "filter_passes_by_name" that takes passes as List[Pass[T]] and names as List[String] returns List[Pass[T]]:
    Note: Filter passes by name
    Let filtered_passes be list containing
    
    For each pass in passes:
        If pass.name is in names and pass.enabled:
            Add pass to filtered_passes
    
    Return filtered_passes

Note: Pass Statistics and Analysis
Process called "get_pass_statistics" that takes passes as List[Pass[T]] returns Dictionary[String, Any]:
    Note: Get statistics about a list of passes
    Let enabled_count be 0
    Let total_count be length of passes
    
    For each pass in passes:
        If pass.enabled:
            Set enabled_count to enabled_count plus 1
    
    Return dictionary containing:
        "total_passes" as total_count
        "enabled_passes" as enabled_count
        "disabled_passes" as (total_count minus enabled_count)
        "passes" as passes

Process called "validate_pass_configuration" that takes passes as List[Pass[T]] returns Dictionary[String, Any]:
    Note: Validate pass configuration
    Let errors be list containing
    Let warnings be list containing
    
    For each pass in passes:
        If pass.name is equal to "":
            Add "Pass has empty name" to errors
        
        If pass.level is less than 0:
            Add "Pass " plus pass.name plus " has negative level" to errors
        
        If pass.level is greater than 3:
            Add "Pass " plus pass.name plus " has level greater than 3" to warnings
    
    Return dictionary containing:
        "valid" as (length of errors is equal to 0)
        "errors" as errors
        "warnings" as warnings

Note: Pass Registry - Central pass management
Type PassRegistry[T] is Dictionary with:
    passes as Dictionary[String, Pass[T]]
    metadata as Dictionary[String, Any]

Process called "create_pass_registry" returns PassRegistry[Any]:
    Note: Create a new pass registry
    Return PassRegistry[Any] with:
        passes as dictionary containing
        metadata as dictionary containing

Process called "register_pass" that takes registry as PassRegistry[T] and pass as Pass[T]:
    Note: Register a pass in the registry
    Set registry.passes at key pass.name to pass

Process called "unregister_pass" that takes registry as PassRegistry[T] and name as String returns Boolean:
    Note: Unregister a pass from the registry
    If name is in registry.passes:
        Remove registry.passes at key name
        Return true
    Otherwise:
        Return false

Process called "get_pass" that takes registry as PassRegistry[T] and name as String returns Optional[Pass[T]]:
    Note: Get a pass by name
    If name is in registry.passes:
        Return registry.passes at key name
    Otherwise:
        Return None

Process called "get_all_passes" that takes registry as PassRegistry[T] returns List[Pass[T]]:
    Note: Get all registered passes
    Let all_passes be list containing
    
    For each pass_name in registry.passes:
        Add registry.passes at key pass_name to all_passes
    
    Return all_passes

Process called "get_enabled_passes" that takes registry as PassRegistry[T] returns List[Pass[T]]:
    Note: Get all enabled passes
    Let enabled_passes be list containing
    
    For each pass_name in registry.passes:
        Let pass be registry.passes at key pass_name
        If pass.enabled:
            Add pass to enabled_passes
    
    Return enabled_passes

Note: Pass Execution Context
Type PassExecutionContext[T] is Dictionary with:
    module as T
    context as IRContext
    pass_name as String
    pass_level as Integer
    metadata as Dictionary[String, Any]

Process called "create_pass_execution_context" that takes module as T and context as IRContext and pass_name as String and pass_level as Integer returns PassExecutionContext[T]:
    Note: Create a pass execution context
    Return PassExecutionContext[T] with:
        module as module
        context as context
        pass_name as pass_name
        pass_level as pass_level
        metadata as dictionary containing

Note: Pass Utilities
Process called "copy_module_for_pass" that takes module as T returns T:
    Note: Create a copy of a module for pass execution
    Note: This is a placeholder - actual implementation depends on module type
    Return module

Process called "merge_pass_statistics" that takes base_stats as Dictionary[String, Any] and new_stats as Dictionary[String, Any] returns Dictionary[String, Any]:
    Note: Merge pass statistics
    Let merged_stats be copy base_stats
    
    For each key in new_stats:
        Set merged_stats at key key to new_stats at key key
    
    Return merged_stats

Process called "create_pass_diagnostic" that takes pass_name as String and message as String and severity as String and context as IRContext returns IRDiagnostic:
    Note: Create a diagnostic for a pass
    Return IRDiagnostic with:
        severity as severity
        message as "[" plus pass_name plus "] " plus message
        location as SourceLocation with line as 0 and column as 0 and file as context.source_file
        code as "PASS_" plus pass_name plus "_ERROR" 