Note: Runa Compiler: IR Optimization Pipeline
Note: Orchestrates all optimization passes across IR levels

Import "../ir.runa"
Import "../ir_context.runa"
Import "pass_interface.runa"
Import "hir_passes/inlining.runa"
Import "hir_passes/loop_optimization.runa"
Import "hir_passes/loop_vectorization.runa"
Import "hir_passes/advanced_loop_optimizations.runa"
Import "mir_passes/constant_folding.runa"
Import "mir_passes/dead_code_elimination.runa"
Import "mir_passes/ssa.runa"
Import "lir_passes/register_allocation.runa"
Import "profile_guided/profile_guided_optimization.runa"
Import "interprocedural/interprocedural_analysis.runa"
Import "target_specific/target_specific_optimizations.runa"

Note: IR Optimization Pipeline
Type OptimizationPipeline is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    optimization_level as Integer
    pass_registry as PassRegistry[Any]
    pass_statistics as Dictionary[String, Dictionary[String, Any]]
    metadata as Dictionary[String, Any]

Process called "create_optimization_pipeline" that takes context as IRContext and type_system as TypeSystem returns OptimizationPipeline:
    Note: Create a new optimization pipeline
    Let registry be create_pass_registry
    
    Return OptimizationPipeline with:
        context as context
        type_system as type_system
        optimization_level as 1
        pass_registry as registry
        pass_statistics as dictionary containing
        metadata as dictionary containing

Process called "optimize_ir_module" that takes ir_module as IRModule and context as IRContext and optimization_level as Integer returns Dictionary[String, Any]:
    Note: Apply optimizations to an IR module
    Let type_system be create_type_system
    Let pipeline be create_optimization_pipeline with context as context and type_system as type_system
    Set pipeline.optimization_level to optimization_level
    
    Let optimized_module be copy_ir_module with module as ir_module
    Let total_optimizations be 0
    
    Note: Configure optimization level
    Let enabled_passes be get_enabled_passes_for_level with level as optimization_level
    Set pipeline.enabled_passes to enabled_passes
    
    Note: Apply HIR optimizations
    If "hir_inlining" is in enabled_passes:
        Let hir_result be optimize_hir_with_inlining with hir_module as optimized_module.hir and context as context
        If hir_result.success:
            Set optimized_module.hir to hir_result.optimized_module
            Set pipeline.pass_statistics at key "hir_inlining" to hir_result.statistics
            Set total_optimizations to total_optimizations plus 1
    
    If "hir_loop_optimization" is in enabled_passes:
        Let loop_result be optimize_hir_with_loop_optimization with hir_module as optimized_module.hir and context as context
        If loop_result.success:
            Set optimized_module.hir to loop_result.optimized_module
            Set pipeline.pass_statistics at key "hir_loop_optimization" to loop_result.statistics
            Set total_optimizations to total_optimizations plus 1
    
    Note: Apply MIR optimizations
    If "mir_constant_folding" is in enabled_passes:
        Let mir_result be optimize_mir_with_constant_folding with mir_module as optimized_module.mir and context as context
        If mir_result.success:
            Set optimized_module.mir to mir_result.optimized_module
            Set pipeline.pass_statistics at key "mir_constant_folding" to mir_result.statistics
            Set total_optimizations to total_optimizations plus 1
    
    If "mir_dead_code_elimination" is in enabled_passes:
        Let dce_result be optimize_mir_with_dead_code_elimination with mir_module as optimized_module.mir and context as context
        If dce_result.success:
            Set optimized_module.mir to dce_result.optimized_module
            Set pipeline.pass_statistics at key "mir_dead_code_elimination" to dce_result.statistics
            Set total_optimizations to total_optimizations plus 1
    
    If "mir_ssa_construction" is in enabled_passes:
        Let ssa_result be optimize_mir_with_ssa with mir_module as optimized_module.mir and context as context
        If ssa_result.success:
            Set optimized_module.mir to ssa_result.optimized_module
            Set pipeline.pass_statistics at key "mir_ssa_construction" to ssa_result.statistics
            Set total_optimizations to total_optimizations plus 1
    
    Note: Apply LIR optimizations
    If "lir_register_allocation" is in enabled_passes:
        Let lir_result be allocate_registers with lir_module as optimized_module.lir and context as context
        If lir_result.success:
            Set optimized_module.lir to lir_result.optimized_module
            Set pipeline.pass_statistics at key "lir_register_allocation" to lir_result.statistics
            Set total_optimizations to total_optimizations plus 1
    
    Return dictionary containing:
        "success" as true
        "optimized_module" as optimized_module
        "statistics" as dictionary containing:
            "total_optimizations" as total_optimizations
            "pass_statistics" as pipeline.pass_statistics
            "optimization_level" as optimization_level

Process called "get_enabled_passes_for_level" that takes level as Integer returns List[String]:
    Note: Get enabled optimization passes for a given level
    Let enabled_passes be list containing
    
    If level is greater than or equal to 1:
        Add "hir_inlining" to enabled_passes
        Add "mir_constant_folding" to enabled_passes
    
    If level is greater than or equal to 2:
        Add "hir_loop_optimization" to enabled_passes
        Add "hir_loop_vectorization" to enabled_passes
        Add "hir_advanced_loop_optimizations" to enabled_passes
        Add "mir_dead_code_elimination" to enabled_passes
        Add "lir_register_allocation" to enabled_passes
    
    If level is greater than or equal to 3:
        Add "mir_ssa_construction" to enabled_passes
        Add "profile_guided_optimization" to enabled_passes
        Add "interprocedural_analysis" to enabled_passes
        Add "target_specific_optimizations" to enabled_passes
    
    Return enabled_passes

Process called "optimize_hir_level" that takes hir_module as HIRModule and context as IRContext and level as Integer returns Dictionary[String, Any]:
    Note: Apply HIR-level optimizations
    Let type_system be create_type_system
    Let pipeline be create_optimization_pipeline with context as context and type_system as type_system
    
    Let optimized_module be copy_hir_module with module as hir_module
    Let applied_passes be list containing
    
    If level is greater than or equal to 1:
        Let inlining_result be optimize_hir_with_inlining with hir_module as optimized_module and context as context
        If inlining_result.success:
            Set optimized_module to inlining_result.optimized_module
            Add "inlining" to applied_passes
    
    If level is greater than or equal to 2:
        Let loop_opt_result be optimize_hir_with_loop_optimization with hir_module as optimized_module and context as context
        If loop_opt_result.success:
            Set optimized_module to loop_opt_result.optimized_module
            Add "loop_optimization" to applied_passes
        
        Let vectorization_result be optimize_hir_with_loop_vectorization with hir_module as optimized_module and context as context
        If vectorization_result.success:
            Set optimized_module to vectorization_result.optimized_module
            Add "loop_vectorization" to applied_passes
        
        Let advanced_loop_result be optimize_hir_with_advanced_loop_optimizations with hir_module as optimized_module and context as context
        If advanced_loop_result.success:
            Set optimized_module to advanced_loop_result.optimized_module
            Add "advanced_loop_optimizations" to applied_passes
    
    Return dictionary containing:
        "success" as true
        "optimized_module" as optimized_module
        "applied_passes" as applied_passes

Process called "optimize_mir_level" that takes mir_module as MIRModule and context as IRContext and level as Integer returns Dictionary[String, Any]:
    Note: Apply MIR-level optimizations
    Let type_system be create_type_system
    Let pipeline be create_optimization_pipeline with context as context and type_system as type_system
    
    Let optimized_module be copy_mir_module with module as mir_module
    Let applied_passes be list containing
    
    If level is greater than or equal to 1:
        Let constant_folding_result be optimize_mir_with_constant_folding with mir_module as optimized_module and context as context
        If constant_folding_result.success:
            Set optimized_module to constant_folding_result.optimized_module
            Add "constant_folding" to applied_passes
    
    If level is greater than or equal to 2:
        Let dce_result be optimize_mir_with_dead_code_elimination with mir_module as optimized_module and context as context
        If dce_result.success:
            Set optimized_module to dce_result.optimized_module
            Add "dead_code_elimination" to applied_passes
    
    If level is greater than or equal to 3:
        Let ssa_result be optimize_mir_with_ssa with mir_module as optimized_module and context as context
        If ssa_result.success:
            Set optimized_module to ssa_result.optimized_module
            Add "ssa_construction" to applied_passes
        
        Let profile_result be optimize_with_profile_guidance with ir_module as optimized_module and profile_data as None and context as context
        If profile_result.success:
            Set optimized_module to profile_result.optimized_module
            Add "profile_guided_optimization" to applied_passes
        
        Let interprocedural_result be analyze_interprocedural with ir_module as optimized_module and context as context
        If interprocedural_result.success:
            Set optimized_module to interprocedural_result.optimized_module
            Add "interprocedural_analysis" to applied_passes
        
        Let target_platform be TargetPlatform with:
            architecture as "x86_64"
            cpu_model as "generic"
            cache_size as 32768
            cache_line_size as 64
            vector_width as 8
            instruction_set as list containing "sse", "avx2"
            metadata as dictionary containing
        
        Let target_result be optimize_for_target with ir_module as optimized_module and target_platform as target_platform and context as context
        If target_result.success:
            Set optimized_module to target_result.optimized_module
            Add "target_specific_optimizations" to applied_passes
    
    Return dictionary containing:
        "success" as true
        "optimized_module" as optimized_module
        "applied_passes" as applied_passes

Process called "optimize_lir_level" that takes lir_module as LIRModule and context as IRContext and level as Integer returns Dictionary[String, Any]:
    Note: Apply LIR-level optimizations
    Let type_system be create_type_system
    Let pipeline be create_optimization_pipeline with context as context and type_system as type_system
    
    Let optimized_module be copy_lir_module with module as lir_module
    Let applied_passes be list containing
    
    If level is greater than or equal to 2:
        Let register_allocation_result be allocate_registers with lir_module as optimized_module and context as context
        If register_allocation_result.success:
            Set optimized_module to register_allocation_result.optimized_module
            Add "register_allocation" to applied_passes
    
    Return dictionary containing:
        "success" as true
        "optimized_module" as optimized_module
        "applied_passes" as applied_passes

Process called "copy_ir_module" that takes module as IRModule returns IRModule:
    Note: Create a copy of an IR module
    Return IRModule with:
        hir as module.hir
        mir as module.mir
        lir as module.lir
        types as module.types
        context as module.context

Process called "copy_hir_module" that takes module as HIRModule returns HIRModule:
    Note: Create a copy of a HIR module
    Return HIRModule with:
        name as module.name
        declarations as module.declarations
        statements as module.statements
        metadata as module.metadata

Process called "copy_mir_module" that takes module as MIRModule returns MIRModule:
    Note: Create a copy of a MIR module
    Let copied_functions be list containing
    For each function in module.functions:
        Let copied_function be copy_mir_function with function as function
        Add copied_function to copied_functions
    
    Return MIRModule with:
        name as module.name
        functions as copied_functions
        global_variables as module.global_variables

Process called "copy_mir_function" that takes function as MIRFunction returns MIRFunction:
    Note: Create a copy of a MIR function
    Let copied_basic_blocks be list containing
    For each basic_block in function.basic_blocks:
        Let copied_block be copy_mir_basic_block with basic_block as basic_block
        Add copied_block to copied_basic_blocks
    
    Return MIRFunction with:
        name as function.name
        parameters as function.parameters
        return_type as function.return_type
        basic_blocks as copied_basic_blocks
        entry_block as function.entry_block
        exit_blocks as function.exit_blocks
        local_variables as function.local_variables
        stack_frame_size as function.stack_frame_size
        metadata as function.metadata

Process called "copy_mir_basic_block" that takes basic_block as MIRBasicBlock returns MIRBasicBlock:
    Note: Create a copy of a MIR basic block
    Return MIRBasicBlock with:
        name as basic_block.name
        instructions as basic_block.instructions
        terminator as basic_block.terminator
        predecessors as basic_block.predecessors
        successors as basic_block.successors
        live_in as basic_block.live_in
        live_out as basic_block.live_out
        metadata as basic_block.metadata

Process called "copy_lir_module" that takes module as LIRModule returns LIRModule:
    Note: Create a copy of a LIR module
    Let copied_functions be list containing
    For each function in module.functions:
        Let copied_function be copy_lir_function with function as function
        Add copied_function to copied_functions
    
    Return LIRModule with:
        name as module.name
        functions as copied_functions
        global_variables as module.global_variables
        constants as module.constants

Process called "copy_lir_function" that takes function as LIRFunction returns LIRFunction:
    Note: Create a copy of a LIR function
    Let copied_basic_blocks be list containing
    For each basic_block in function.basic_blocks:
        Let copied_block be copy_lir_basic_block with basic_block as basic_block
        Add copied_block to copied_basic_blocks
    
    Return LIRFunction with:
        name as function.name
        parameters as function.parameters
        return_type as function.return_type
        basic_blocks as copied_basic_blocks
        entry_block as function.entry_block
        exit_blocks as function.exit_blocks
        virtual_registers as function.virtual_registers
        stack_frame_size as function.stack_frame_size
        metadata as function.metadata

Process called "copy_lir_basic_block" that takes basic_block as LIRBasicBlock returns LIRBasicBlock:
    Note: Create a copy of a LIR basic block
    Return LIRBasicBlock with:
        name as basic_block.name
        instructions as basic_block.instructions
        terminator as basic_block.terminator
        predecessors as basic_block.predecessors
        successors as basic_block.successors
        live_in as basic_block.live_in
        live_out as basic_block.live_out
        metadata as basic_block.metadata

Note: Optimization Pipeline Diagnostics
Process called "get_optimization_pipeline_diagnostics" that takes pipeline as OptimizationPipeline returns List[IRDiagnostic]:
    Note: Get diagnostics from optimization pipeline
    Return pipeline.context.diagnostics

Process called "has_optimization_pipeline_errors" that takes pipeline as OptimizationPipeline returns Boolean:
    Note: Check if optimization pipeline has errors
    Let diagnostics be get_optimization_pipeline_diagnostics with pipeline as pipeline
    
    For each diagnostic in diagnostics:
        If diagnostic.severity is equal to "error":
            Return true
    
    Return false

Note: Optimization Pipeline Statistics
Process called "get_optimization_pipeline_statistics" that takes ir_module as IRModule and optimization_level as Integer returns Dictionary[String, Any]:
    Note: Get optimization pipeline statistics
    Let type_system be create_type_system
    Let pipeline be create_optimization_pipeline with context as create_ir_context with compilation_unit as "stats" and source_file as "unknown" and type_system as type_system
    
    Let optimization_result be optimize_ir_module with ir_module as ir_module and context as pipeline.context and optimization_level as optimization_level
    Let statistics be optimization_result.statistics
    
    Return dictionary containing:
        "total_optimizations" as statistics.total_optimizations
        "pass_statistics" as statistics.pass_statistics
        "optimization_level" as statistics.optimization_level
        "hir_function_count" as length of ir_module.hir.declarations
        "mir_function_count" as length of ir_module.mir.functions
        "lir_function_count" as length of ir_module.lir.functions

Note: Optimization Level Descriptions
Process called "get_optimization_level_description" that takes level as Integer returns String:
    Note: Get description of optimization level
    Match level:
        When 0:
            Return "No optimizations"
        When 1:
            Return "Basic optimizations (inlining, constant folding)"
        When 2:
            Return "Standard optimizations (includes register allocation)"
        When 3:
            Return "Aggressive optimizations (includes advanced passes)"
        Otherwise:
            Return "Unknown optimization level"

Note: Optimization Pass Descriptions
Process called "get_optimization_pass_description" that takes pass_name as String returns String:
    Note: Get description of an optimization pass
    Match pass_name:
        When "hir_inlining":
            Return "Function inlining at HIR level"
        When "mir_constant_folding":
            Return "Constant folding at MIR level"
        When "mir_dead_code_elimination":
            Return "Dead code elimination at MIR level"
        When "mir_ssa_construction":
            Return "SSA form construction at MIR level"
        When "lir_register_allocation":
            Return "Register allocation at LIR level"
        When "hir_loop_optimization":
            Return "Loop optimizations at HIR level"
        When "hir_loop_vectorization":
            Return "Loop vectorization at HIR level"
        When "hir_advanced_loop_optimizations":
            Return "Advanced loop optimizations at HIR level"
        When "profile_guided_optimization":
            Return "Profile-guided optimization"
        When "interprocedural_analysis":
            Return "Interprocedural analysis and optimization"
        When "target_specific_optimizations":
            Return "Target-specific optimizations"
        Otherwise:
            Return "Unknown optimization pass" 