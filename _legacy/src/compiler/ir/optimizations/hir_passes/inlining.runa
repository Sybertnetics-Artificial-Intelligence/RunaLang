Note: Runa Compiler: HIR Function Inlining Optimization
Note: Inlines small functions to reduce call overhead

Import "../../hir/hir.runa"
Import "../../types/types.runa"
Import "../../ir_context.runa"

Note: HIR Function Inlining Optimization
Type InliningPass is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    max_inline_size as Integer
    max_inline_depth as Integer
    inlined_functions as Set[String]
    current_depth as Integer
    metadata as Dictionary[String, Any]

Process called "create_inlining_pass" that takes context as IRContext and type_system as TypeSystem returns InliningPass:
    Note: Create a new inlining pass
    Return InliningPass with:
        context as context
        type_system as type_system
        max_inline_size as 50
        max_inline_depth as 3
        inlined_functions as set containing
        current_depth as 0
        metadata as dictionary containing

Process called "optimize_hir_with_inlining" that takes hir_module as HIRModule and context as IRContext returns Dictionary[String, Any]:
    Note: Apply function inlining optimization to HIR module
    Let type_system be create_type_system
    Let inliner be create_inlining_pass with context as context and type_system as type_system
    
    Let optimized_module be copy_hir_module with module as hir_module
    Let inlined_count be 0
    Let total_calls be 0
    
    Note: First pass: collect function sizes and call sites
    Let function_sizes be dictionary containing
    Let call_sites be list containing
    
    For each declaration in optimized_module.declarations:
        Match declaration:
            When HIRProcessDeclaration with name as name and parameters as parameters and return_type as return_type and body as body and is_function as is_function:
                If is_function:
                    Let size be calculate_function_size with body as body
                    Set function_sizes at key name to size
                    
                    Note: Find call sites for this function
                    Let sites be find_function_call_sites with module as optimized_module and function_name as name
                    Add all sites to call_sites
                    Set total_calls to total_calls plus length of sites
            Otherwise:
                Note: Skip other declaration types
                Return
    
    Note: Second pass: perform inlining
    For each call_site in call_sites:
        Let inlining_result be try_inline_function_call with inliner as inliner and call_site as call_site and function_sizes as function_sizes and optimized_module as optimized_module
        If inlining_result.success:
            Set inlined_count to inlined_count plus 1
    
    Note: Clean up unused functions
    Let cleanup_result be cleanup_unused_functions with module as optimized_module and inlined_functions as inliner.inlined_functions
    Let removed_count be cleanup_result.removed_count
    
    Return dictionary containing:
        "success" as true
        "optimized_module" as optimized_module
        "statistics" as dictionary containing:
            "inlined_calls" as inlined_count
            "total_calls" as total_calls
            "removed_functions" as removed_count
            "inlining_ratio" as ((inlined_count divided by total_calls) multiplied by 100.0 if total_calls is greater than 0 else 0.0)

Process called "try_inline_function_call" that takes inliner as InliningPass and call_site as Dictionary[String, Any] and function_sizes as Dictionary[String, Integer] and module as HIRModule returns Dictionary[String, Any]:
    Note: Try to inline a specific function call
    Let function_name be call_site.function_name
    Let call_location be call_site.location
    Let arguments be call_site.arguments
    
    Note: Check if function exists and is inlineable
    Let target_function be find_function_declaration with module as module and name as function_name
    If target_function is None:
        Return dictionary containing:
            "success" as false
            "reason" as "Function not found"
    
    Let function_size be function_sizes at key function_name
    If function_size is greater than inliner.max_inline_size:
        Return dictionary containing:
            "success" as false
            "reason" as "Function too large"
    
    If inliner.current_depth is greater than or equal to inliner.max_inline_depth:
        Return dictionary containing:
            "success" as false
            "reason" as "Maximum inlining depth reached"
    
    If function_name is in inliner.inlined_functions:
        Return dictionary containing:
            "success" as false
            "reason" as "Function already inlined"
    
    Note: Check for recursive calls
    If is_recursive_call with function_name as function_name and call_location as call_location:
        Return dictionary containing:
            "success" as false
            "reason" as "Recursive call detected"
    
    Note: Perform the inlining
    Let inlining_result be perform_function_inlining with inliner as inliner and target_function as target_function and arguments as arguments and call_location as call_location
    If inlining_result.success:
        Add function_name to inliner.inlined_functions
        Return dictionary containing:
            "success" as true
            "inlined_body" as inlining_result.inlined_body
    Otherwise:
        Return dictionary containing:
            "success" as false
            "reason" as inlining_result.reason

Process called "perform_function_inlining" that takes inliner as InliningPass and target_function as HIRProcessDeclaration and arguments as List[HIRExpression] and call_location as SourceLocation returns Dictionary[String, Any]:
    Note: Perform the actual function inlining
    Set inliner.current_depth to inliner.current_depth plus 1
    
    Let parameter_map be dictionary containing
    For i from 0 to (length of target_function.parameters minus 1):
        Let param be target_function.parameters at index i
        Let arg be arguments at index i
        Set parameter_map at key param.name to arg
    
    Note: Clone and substitute the function body
    Let inlined_body be list containing
    For each statement in target_function.body:
        Let substituted_statement be substitute_parameters_in_statement with statement as statement and parameter_map as parameter_map
        Add substituted_statement to inlined_body
    
    Set inliner.current_depth to inliner.current_depth minus 1
    
    Return dictionary containing:
        "success" as true
        "inlined_body" as inlined_body

Process called "substitute_parameters_in_statement" that takes statement as HIRStatement and parameter_map as Dictionary[String, HIRExpression] returns HIRStatement:
    Note: Substitute parameter references with argument expressions
    Match statement:
        When HIRExpressionStatement with expression as expression:
            Let substituted_expr be substitute_parameters_in_expression with expression as expression and parameter_map as parameter_map
            Return HIRExpressionStatement with expression as substituted_expr
        When HIRVariableDeclaration with name as name and type_annotation as type_annotation and initializer as initializer and is_mutable as is_mutable:
            Let substituted_init be None
            If initializer is not None:
                Set substituted_init to substitute_parameters_in_expression with expression as initializer and parameter_map as parameter_map
            Return HIRVariableDeclaration with name as name and type_annotation as type_annotation and initializer as substituted_init and is_mutable as is_mutable
        When HIRAssignment with target as target and value as value:
            Let substituted_target be substitute_parameters_in_expression with expression as target and parameter_map as parameter_map
            Let substituted_value be substitute_parameters_in_expression with expression as value and parameter_map as parameter_map
            Return HIRAssignment with target as substituted_target and value as substituted_value
        When HIRReturnStatement with value as value:
            Let substituted_value be None
            If value is not None:
                Set substituted_value to substitute_parameters_in_expression with expression as value and parameter_map as parameter_map
            Return HIRReturnStatement with value as substituted_value
        Otherwise:
            Return statement

Process called "substitute_parameters_in_expression" that takes expression as HIRExpression and parameter_map as Dictionary[String, HIRExpression] returns HIRExpression:
    Note: Substitute parameter references in expressions
    Match expression:
        When HIRIdentifier with name as name and resolved_symbol as resolved_symbol and inferred_type as inferred_type and location as location:
            If name is in parameter_map:
                Return parameter_map at key name
            Otherwise:
                Return expression
        When HIRBinaryOperation with left as left and operator as operator and right as right and inferred_type as inferred_type and location as location:
            Let substituted_left be substitute_parameters_in_expression with expression as left and parameter_map as parameter_map
            Let substituted_right be substitute_parameters_in_expression with expression as right and parameter_map as parameter_map
            Return HIRBinaryOperation with left as substituted_left and operator as operator and right as substituted_right and inferred_type as inferred_type and location as location
        When HIRFunctionCall with function as function and arguments as arguments and inferred_type as inferred_type and location as location:
            Let substituted_function be substitute_parameters_in_expression with expression as function and parameter_map as parameter_map
            Let substituted_args be list containing
            For each arg in arguments:
                Let substituted_arg be substitute_parameters_in_expression with expression as arg and parameter_map as parameter_map
                Add substituted_arg to substituted_args
            Return HIRFunctionCall with function as substituted_function and arguments as substituted_args and inferred_type as inferred_type and location as location
        Otherwise:
            Return expression

Process called "calculate_function_size" that takes body as List[HIRStatement] returns Integer:
    Note: Calculate the size of a function for inlining decisions
    Let size be 0
    For each statement in body:
        Set size to size plus calculate_statement_size with statement as statement
    Return size

Process called "calculate_statement_size" that takes statement as HIRStatement returns Integer:
    Note: Calculate the size of a statement
    Match statement:
        When HIRExpressionStatement with expression as expression:
            Return calculate_expression_size with expression as expression
        When HIRVariableDeclaration with name as name and type_annotation as type_annotation and initializer as initializer and is_mutable as is_mutable:
            Let size be 1
            If initializer is not None:
                Set size to size plus calculate_expression_size with expression as initializer
            Return size
        When HIRAssignment with target as target and value as value:
            Return calculate_expression_size with expression as target plus calculate_expression_size with expression as value
        When HIRReturnStatement with value as value:
            If value is not None:
                Return calculate_expression_size with expression as value
            Otherwise:
                Return 1
        Otherwise:
            Return 1

Process called "calculate_expression_size" that takes expression as HIRExpression returns Integer:
    Note: Calculate the size of an expression
    Match expression:
        When HIRLiteral with value as value and literal_type as literal_type and inferred_type as inferred_type and location as location:
            Return 1
        When HIRIdentifier with name as name and resolved_symbol as resolved_symbol and inferred_type as inferred_type and location as location:
            Return 1
        When HIRBinaryOperation with left as left and operator as operator and right as right and inferred_type as inferred_type and location as location:
            Return calculate_expression_size with expression as left plus calculate_expression_size with expression as right plus 1
        When HIRFunctionCall with function as function and arguments as arguments and inferred_type as inferred_type and location as location:
            Let size be calculate_expression_size with expression as function
            For each arg in arguments:
                Set size to size plus calculate_expression_size with expression as arg
            Return size plus 1
        Otherwise:
            Return 1

Process called "find_function_call_sites" that takes module as HIRModule and function_name as String returns List[Dictionary[String, Any]]:
    Note: Find all call sites for a specific function
    Let call_sites be list containing
    
    For each declaration in module.declarations:
        Match declaration:
            When HIRProcessDeclaration with name as name and parameters as parameters and return_type as return_type and body as body and is_function as is_function:
                Let sites be find_call_sites_in_statements with statements as body and function_name as function_name
                Add all sites to call_sites
            Otherwise:
                Note: Skip other declaration types
                Return
    
    Return call_sites

Process called "find_call_sites_in_statements" that takes statements as List[HIRStatement] and function_name as String returns List[Dictionary[String, Any]]:
    Note: Find call sites in a list of statements
    Let call_sites be list containing
    
    For each statement in statements:
        Let sites be find_call_sites_in_statement with statement as statement and function_name as function_name
        Add all sites to call_sites
    
    Return call_sites

Process called "find_call_sites_in_statement" that takes statement as HIRStatement and function_name as String returns List[Dictionary[String, Any]]:
    Note: Find call sites in a single statement
    Let call_sites be list containing
    
    Match statement:
        When HIRExpressionStatement with expression as expression:
            Let sites be find_call_sites_in_expression with expression as expression and function_name as function_name
            Add all sites to call_sites
        When HIRVariableDeclaration with name as name and type_annotation as type_annotation and initializer as initializer and is_mutable as is_mutable:
            If initializer is not None:
                Let sites be find_call_sites_in_expression with expression as initializer and function_name as function_name
                Add all sites to call_sites
        When HIRAssignment with target as target and value as value:
            Let target_sites be find_call_sites_in_expression with expression as target and function_name as function_name
            Let value_sites be find_call_sites_in_expression with expression as value and function_name as function_name
            Add all target_sites to call_sites
            Add all value_sites to call_sites
        When HIRReturnStatement with value as value:
            If value is not None:
                Let sites be find_call_sites_in_expression with expression as value and function_name as function_name
                Add all sites to call_sites
        Otherwise:
            Note: No call sites in other statement types
            Return call_sites
    
    Return call_sites

Process called "find_call_sites_in_expression" that takes expression as HIRExpression and function_name as String returns List[Dictionary[String, Any]]:
    Note: Find call sites in an expression
    Let call_sites be list containing
    
    Match expression:
        When HIRFunctionCall with function as function and arguments as arguments and inferred_type as inferred_type and location as location:
            Let function_name_expr be get_function_name_from_expression with expression as function
            If function_name_expr is equal to function_name:
                Add dictionary containing:
                    "function_name" as function_name
                    "arguments" as arguments
                    "location" as location
                to call_sites
        When HIRBinaryOperation with left as left and operator as operator and right as right and inferred_type as inferred_type and location as location:
            Let left_sites be find_call_sites_in_expression with expression as left and function_name as function_name
            Let right_sites be find_call_sites_in_expression with expression as right and function_name as function_name
            Add all left_sites to call_sites
            Add all right_sites to call_sites
        Otherwise:
            Note: No call sites in other expression types
            Return call_sites
    
    Return call_sites

Process called "get_function_name_from_expression" that takes expression as HIRExpression returns String:
    Note: Extract function name from a function call expression
    Match expression:
        When HIRIdentifier with name as name and resolved_symbol as resolved_symbol and inferred_type as inferred_type and location as location:
            Return name
        Otherwise:
            Return "unknown"

Process called "find_function_declaration" that takes module as HIRModule and name as String returns Optional[HIRProcessDeclaration]:
    Note: Find a function declaration by name
    For each declaration in module.declarations:
        Match declaration:
            When HIRProcessDeclaration with name as decl_name and parameters as parameters and return_type as return_type and body as body and is_function as is_function:
                If decl_name is equal to name and is_function:
                    Return declaration
            Otherwise:
                Note: Skip other declaration types
                Return
    Return None

Process called "is_recursive_call" that takes function_name as String and call_location as SourceLocation returns Boolean:
    Note: Check if a function call is recursive
    Note: This is a simplified implementation
    Return false

Process called "copy_hir_module" that takes module as HIRModule returns HIRModule:
    Note: Create a copy of a HIR module
    Return HIRModule with:
        name as module.name
        declarations as module.declarations
        statements as module.statements
        metadata as module.metadata

Process called "cleanup_unused_functions" that takes module as HIRModule and inlined_functions as Set[String] returns Dictionary[String, Any]:
    Note: Remove functions that are no longer used after inlining
    Let removed_count be 0
    Let remaining_declarations be list containing
    
    For each declaration in module.declarations:
        Match declaration:
            When HIRProcessDeclaration with name as name and parameters as parameters and return_type as return_type and body as body and is_function as is_function:
                If is_function and name is in inlined_functions:
                    Set removed_count to removed_count plus 1
                Otherwise:
                    Add declaration to remaining_declarations
            Otherwise:
                Add declaration to remaining_declarations
    
    Set module.declarations to remaining_declarations
    
    Return dictionary containing:
        "removed_count" as removed_count

Note: Inlining Pass Diagnostics
Process called "get_inlining_diagnostics" that takes inliner as InliningPass returns List[IRDiagnostic]:
    Note: Get diagnostics from inlining pass
    Return inliner.context.diagnostics

Process called "has_inlining_errors" that takes inliner as InliningPass returns Boolean:
    Note: Check if inlining pass has errors
    Let diagnostics be get_inlining_diagnostics with inliner as inliner
    
    For each diagnostic in diagnostics:
        If diagnostic.severity is equal to "error":
            Return true
    
    Return false 