Note: Runa Compiler: HIR Loop Optimization
Note: Performs loop optimizations at the HIR level

Import "../../hir/hir.runa"
Import "../../types/types.runa"
Import "../../ir_context.runa"
Import "../analysis/control_flow_analysis.runa"

Note: HIR Loop Optimization Types
Type LoopOptimizationPass is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    loops_optimized as Integer
    metadata as Dictionary[String, Any]

Type LoopInfo is Dictionary with:
    header as HIRNode
    body as List[HIRNode]
    exit_conditions as List[HIRNode]
    induction_variables as List[String]
    loop_invariants as List[HIRNode]
    metadata as Dictionary[String, Any]

Process called "create_loop_optimization_pass" that takes context as IRContext and type_system as TypeSystem returns LoopOptimizationPass:
    Note: Create a new loop optimization pass
    Return LoopOptimizationPass with:
        context as context
        type_system as type_system
        loops_optimized as 0
        metadata as dictionary containing

Process called "optimize_hir_with_loop_optimization" that takes hir_module as HIRModule and context as IRContext returns Dictionary[String, Any]:
    Note: Apply loop optimization to HIR module
    Let type_system be create_type_system
    Let optimizer be create_loop_optimization_pass with context as context and type_system as type_system
    
    Let optimized_module be copy_hir_module with module as hir_module
    Let total_optimizations be 0
    
    For each declaration in optimized_module.declarations:
        If declaration is HIRProcessDeclaration:
            Let function_result be optimize_function_loops with optimizer as optimizer and function as declaration
            Set total_optimizations to total_optimizations plus function_result.optimizations
    
    Return dictionary containing:
        "success" as true
        "optimized_module" as optimized_module
        "statistics" as dictionary containing:
            "loops_optimized" as total_optimizations
            "optimization_types" as optimizer.metadata

Process called "optimize_function_loops" that takes optimizer as LoopOptimizationPass and function as HIRProcessDeclaration returns Dictionary[String, Any]:
    Note: Optimize loops in a function
    Let optimizations be 0
    Let optimized_body be list containing
    
    For each statement in function.body:
        Let optimization_result be optimize_statement_loops with optimizer as optimizer and statement as statement
        If optimization_result.optimized:
            Set optimizations to optimizations plus optimization_result.optimizations
            Add optimization_result.optimized_statement to optimized_body
        Otherwise:
            Add statement to optimized_body
    
    Set function.body to optimized_body
    
    Return dictionary containing:
        "optimizations" as optimizations

Process called "optimize_statement_loops" that takes optimizer as LoopOptimizationPass and statement as HIRNode returns Dictionary[String, Any]:
    Note: Optimize loops in a statement
    Match statement:
        When HIRForStatement with variable as variable and range as range and body as body:
            Let loop_info be analyze_loop with optimizer as optimizer and variable as variable and range as range and body as body
            Let optimized_loop be apply_loop_optimizations with optimizer as optimizer and loop_info as loop_info
            Return dictionary containing:
                "optimized" as true
                "optimized_statement" as optimized_loop
                "optimizations" as 1
        
        When HIRWhileStatement with condition as condition and body as body:
            Let loop_info be analyze_while_loop with optimizer as optimizer and condition as condition and body as body
            Let optimized_loop be apply_loop_optimizations with optimizer as optimizer and loop_info as loop_info
            Return dictionary containing:
                "optimized" as true
                "optimized_statement" as optimized_loop
                "optimizations" as 1
        
        Otherwise:
            Return dictionary containing:
                "optimized" as false
                "optimized_statement" as statement
                "optimizations" as 0

Process called "analyze_loop" that takes optimizer as LoopOptimizationPass and variable as String and range as HIRNode and body as List[HIRNode] returns LoopInfo:
    Note: Analyze a for loop for optimization opportunities
    Let induction_vars be list containing variable
    Let invariants be find_loop_invariants with optimizer as optimizer and body as body and induction_vars as induction_vars
    Let exit_conditions be find_exit_conditions with optimizer as optimizer and body as body
    
    Return LoopInfo with:
        header as create_hir_for_statement with variable as variable and range as range and body as body
        body as body
        exit_conditions as exit_conditions
        induction_variables as induction_vars
        loop_invariants as invariants
        metadata as dictionary containing:
            "loop_type" as "for"
            "range_expression" as range

Process called "analyze_while_loop" that takes optimizer as LoopOptimizationPass and condition as HIRNode and body as List[HIRNode] returns LoopInfo:
    Note: Analyze a while loop for optimization opportunities
    Let induction_vars be find_induction_variables with optimizer as optimizer and body as body
    Let invariants be find_loop_invariants with optimizer as optimizer and body as body and induction_vars as induction_vars
    Let exit_conditions be list containing condition
    
    Return LoopInfo with:
        header as create_hir_while_statement with condition as condition and body as body
        body as body
        exit_conditions as exit_conditions
        induction_variables as induction_vars
        loop_invariants as invariants
        metadata as dictionary containing:
            "loop_type" as "while"
            "condition" as condition

Process called "apply_loop_optimizations" that takes optimizer as LoopOptimizationPass and loop_info as LoopInfo returns HIRNode:
    Note: Apply various loop optimizations
    Let optimized_loop be loop_info.header
    
    Note: Apply loop invariant code motion
    If length of loop_info.loop_invariants is greater than 0:
        Let optimized_loop be apply_loop_invariant_motion with optimizer as optimizer and loop_info as loop_info
    
    Note: Apply loop unrolling for small loops
    If should_unroll_loop with loop_info as loop_info:
        Let optimized_loop be apply_loop_unrolling with optimizer as optimizer and loop_info as loop_info
    
    Note: Apply strength reduction
    If length of loop_info.induction_variables is greater than 0:
        Let optimized_loop be apply_strength_reduction with optimizer as optimizer and loop_info as loop_info
    
    Set optimizer.loops_optimized to optimizer.loops_optimized plus 1
    
    Return optimized_loop

Process called "find_loop_invariants" that takes optimizer as LoopOptimizationPass and body as List[HIRNode] and induction_vars as List[String] returns List[HIRNode]:
    Note: Find loop invariant expressions
    Let invariants be list containing
    
    For each statement in body:
        If is_loop_invariant with optimizer as optimizer and statement as statement and induction_vars as induction_vars:
            Add statement to invariants
    
    Return invariants

Process called "find_exit_conditions" that takes optimizer as LoopOptimizationPass and body as List[HIRNode] returns List[HIRNode]:
    Note: Find loop exit conditions
    Let exit_conditions be list containing
    
    For each statement in body:
        If is_exit_condition with optimizer as optimizer and statement as statement:
            Add statement to exit_conditions
    
    Return exit_conditions

Process called "find_induction_variables" that takes optimizer as LoopOptimizationPass and body as List[HIRNode] returns List[String]:
    Note: Find induction variables in the loop
    Let induction_vars be list containing
    
    For each statement in body:
        If statement is HIRBinaryOperation:
            Let var_name be get_induction_variable with optimizer as optimizer and statement as statement
            If var_name is not None:
                Add var_name to induction_vars
    
    Return induction_vars

Process called "is_loop_invariant" that takes optimizer as LoopOptimizationPass and statement as HIRNode and induction_vars as List[String] returns Boolean:
    Note: Check if a statement is loop invariant
    Match statement:
        When HIRBinaryOperation with left as left and right as right:
            Let left_vars be get_variables_in_expression with optimizer as optimizer and expression as left
            Let right_vars be get_variables_in_expression with optimizer as optimizer and expression as right
            
            For each var in left_vars:
                If var is in induction_vars:
                    Return false
            
            For each var in right_vars:
                If var is in induction_vars:
                    Return false
            
            Return true
        
        Otherwise:
            Return true

Process called "is_exit_condition" that takes optimizer as LoopOptimizationPass and statement as HIRNode returns Boolean:
    Note: Check if a statement is an exit condition
    Match statement:
        When HIRIfStatement:
            Return true
        When HIRReturnStatement:
            Return true
        Otherwise:
            Return false

Process called "get_induction_variable" that takes optimizer as LoopOptimizationPass and statement as HIRNode returns Optional[String]:
    Note: Get induction variable from a statement
    Match statement:
        When HIRBinaryOperation with destination as destination and operator as operator and left as left and right as right:
            If operator is "add" or operator is "subtract":
                If left is HIRIdentifier with name as name and name is equal to destination:
                    If right is HIRLiteral:
                        Return destination
                If right is HIRIdentifier with name as name and name is equal to destination:
                    If left is HIRLiteral:
                        Return destination
        
        Otherwise:
            Return None

Process called "get_variables_in_expression" that takes optimizer as LoopOptimizationPass and expression as HIRNode returns List[String]:
    Note: Get all variables used in an expression
    Let variables be list containing
    
    Match expression:
        When HIRIdentifier with name as name:
            Add name to variables
        When HIRBinaryOperation with left as left and right as right:
            Add all get_variables_in_expression with optimizer as optimizer and expression as left to variables
            Add all get_variables_in_expression with optimizer as optimizer and expression as right to variables
        When HIRFunctionCall with arguments as arguments:
            For each arg in arguments:
                Add all get_variables_in_expression with optimizer as optimizer and expression as arg to variables
        Otherwise:
            Note: No variables in literals
    
    Return variables

Process called "apply_loop_invariant_motion" that takes optimizer as LoopOptimizationPass and loop_info as LoopInfo returns HIRNode:
    Note: Apply loop invariant code motion
    Let hoisted_statements be list containing
    Let optimized_body be list containing
    
    Note: Hoist invariant statements
    For each invariant in loop_info.loop_invariants:
        Add invariant to hoisted_statements
    
    Note: Keep non-invariant statements in loop
    For each statement in loop_info.body:
        If statement is not in loop_info.loop_invariants:
            Add statement to optimized_body
    
    Note: Create new loop with hoisted statements
    Let new_loop be create_hir_for_statement with variable as loop_info.induction_variables at index 0 and range as loop_info.metadata at key "range_expression" and body as optimized_body
    
    Return create_hir_block_statement with statements as (hoisted_statements concatenated with list containing new_loop)

Process called "should_unroll_loop" that takes loop_info as LoopInfo returns Boolean:
    Note: Determine if a loop should be unrolled
    Let body_size be length of loop_info.body
    
    Note: Unroll small loops (body size < 5 statements)
    If body_size is less than 5:
        Return true
    
    Note: Unroll loops with simple induction variables
    If length of loop_info.induction_variables is equal to 1:
        Return true
    
    Return false

Process called "apply_loop_unrolling" that takes optimizer as LoopOptimizationPass and loop_info as LoopInfo returns HIRNode:
    Note: Apply loop unrolling optimization
    Let unrolled_statements be list containing
    Let unroll_factor be 4  Note: Unroll by factor of 4
    
    For each i from 0 to unroll_factor minus 1:
        For each statement in loop_info.body:
            Let unrolled_statement be unroll_statement with optimizer as optimizer and statement as statement and iteration as i
            Add unrolled_statement to unrolled_statements
    
    Return create_hir_block_statement with statements as unrolled_statements

Process called "apply_strength_reduction" that takes optimizer as LoopOptimizationPass and loop_info as LoopInfo returns HIRNode:
    Note: Apply strength reduction optimization
    Let optimized_body be list containing
    
    For each statement in loop_info.body:
        Let reduced_statement be reduce_strength with optimizer as optimizer and statement as statement and induction_vars as loop_info.induction_variables
        Add reduced_statement to optimized_body
    
    Return create_hir_for_statement with variable as loop_info.induction_variables at index 0 and range as loop_info.metadata at key "range_expression" and body as optimized_body

Process called "unroll_statement" that takes optimizer as LoopOptimizationPass and statement as HIRNode and iteration as Integer returns HIRNode:
    Note: Unroll a statement for a specific iteration
    Match statement:
        When HIRBinaryOperation with destination as destination and operator as operator and left as left and right as right:
            Let new_destination be destination concatenated with "_" concatenated with string_from_integer with iteration
            Return create_hir_binary_operation with destination as new_destination and operator as operator and left as left and right as right
        
        Otherwise:
            Return statement

Process called "reduce_strength" that takes optimizer as LoopOptimizationPass and statement as HIRNode and induction_vars as List[String] returns HIRNode:
    Note: Reduce strength of operations in a statement
    Match statement:
        When HIRBinaryOperation with destination as destination and operator as operator and left as left and right as right:
            If operator is "multiply" and left is HIRIdentifier with name as name and name is in induction_vars:
                If right is HIRLiteral with value as value and value is equal to 2:
                    Return create_hir_binary_operation with destination as destination and operator as "add" and left as left and right as left
                If right is HIRLiteral with value as value and value is equal to 4:
                    Return create_hir_binary_operation with destination as destination and operator as "add" and left as (create_hir_binary_operation with destination as "temp" and operator as "add" and left as left and right as left) and right as (create_hir_binary_operation with destination as "temp2" and operator as "add" and left as left and right as left)
            
            Return statement
        
        Otherwise:
            Return statement

Note: Helper functions for creating HIR nodes
Process called "create_hir_for_statement" that takes variable as String and range as HIRNode and body as List[HIRNode] returns HIRNode:
    Note: Create a HIR for statement
    Return HIRForStatement with:
        variable as variable
        range as range
        body as body

Process called "create_hir_while_statement" that takes condition as HIRNode and body as List[HIRNode] returns HIRNode:
    Note: Create a HIR while statement
    Return HIRWhileStatement with:
        condition as condition
        body as body

Process called "create_hir_block_statement" that takes statements as List[HIRNode] returns HIRNode:
    Note: Create a HIR block statement
    Return HIRBlockStatement with:
        statements as statements

Process called "create_hir_binary_operation" that takes destination as String and operator as String and left as HIRNode and right as HIRNode returns HIRNode:
    Note: Create a HIR binary operation
    Return HIRBinaryOperation with:
        destination as destination
        operator as operator
        left as left
        right as right 