Note: Runa Compiler: Dependency Tracking Framework
Note: Provides dependency tracking for optimization passes

Import "../../mir/mir.runa"
Import "../../types/types.runa"
Import "../../ir_context.runa"

Note: Dependency Tracking Types
Type DependencyNode is Dictionary with:
    id as String
    type as String
    dependencies as Set[String]
    dependents as Set[String]
    metadata as Dictionary[String, Any]

Type DependencyGraph is Dictionary with:
    nodes as Dictionary[String, DependencyNode]
    edges as List[DependencyEdge]
    metadata as Dictionary[String, Any]

Type DependencyEdge is Dictionary with:
    from_node as String
    to_node as String
    edge_type as String
    metadata as Dictionary[String, Any]

Type DependencyTracker is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    graph as DependencyGraph
    analysis_type as String
    metadata as Dictionary[String, Any]

Note: Dependency Types
Type DependencyType is:
    | DataDependency
    | ControlDependency
    | AntiDependency
    | OutputDependency
    | InputDependency

Process called "create_dependency_tracker" that takes context as IRContext and type_system as TypeSystem returns DependencyTracker:
    Note: Create a new dependency tracker
    Return DependencyTracker with:
        context as context
        type_system as type_system
        graph as DependencyGraph with:
            nodes as dictionary containing
            edges as list containing
            metadata as dictionary containing
        analysis_type as "complete"
        metadata as dictionary containing

Process called "track_dependencies" that takes tracker as DependencyTracker and mir_function as MIRFunction returns Dictionary[String, Any]:
    Note: Track dependencies in a MIR function
    Let cfg be mir_function.basic_blocks
    Let analysis_result be dictionary containing
    
    Note: Build dependency graph
    Let graph_result be build_dependency_graph with tracker as tracker and cfg as cfg
    Let data_deps be analyze_data_dependencies with tracker as tracker and cfg as cfg
    Let control_deps be analyze_control_dependencies with tracker as tracker and cfg as cfg
    
    Set analysis_result to dictionary containing:
        "success" as true
        "dependency_graph" as graph_result
        "data_dependencies" as data_deps
        "control_dependencies" as control_deps
        "statistics" as dictionary containing:
            "nodes" as length of tracker.graph.nodes
            "edges" as length of tracker.graph.edges
            "data_deps" as length of data_deps
            "control_deps" as length of control_deps
    
    Return analysis_result

Process called "build_dependency_graph" that takes tracker as DependencyTracker and cfg as List[MIRBasicBlock] returns Dictionary[String, Any]:
    Note: Build the dependency graph from CFG
    Let nodes be dictionary containing
    Let edges be list containing
    
    Note: Create nodes for each instruction
    For each block in cfg:
        For each instruction in block.instructions:
            Let node_id be generate_instruction_id with block as block and instruction as instruction
            Let node be DependencyNode with:
                id as node_id
                type as "instruction"
                dependencies as set containing
                dependents as set containing
                metadata as dictionary containing:
                    "block" as block.name
                    "instruction_index" as index of instruction in block.instructions
                    "instruction_type" as get_instruction_type with instruction as instruction
            
            Set nodes at key node_id to node
    
    Note: Create nodes for each block
    For each block in cfg:
        Let block_id be "block_" concatenated with block.name
        Let block_node be DependencyNode with:
            id as block_id
            type as "block"
            dependencies as set containing
            dependents as set containing
            metadata as dictionary containing:
                "block_name" as block.name
                "instruction_count" as length of block.instructions
        
        Set nodes at key block_id to block_node
    
    Set tracker.graph.nodes to nodes
    Set tracker.graph.edges to edges
    
    Return dictionary containing:
        "success" as true
        "nodes" as nodes
        "edges" as edges

Process called "analyze_data_dependencies" that takes tracker as DependencyTracker and cfg as List[MIRBasicBlock] returns List[DependencyEdge]:
    Note: Analyze data dependencies between instructions
    Let data_deps be list containing
    
    For each block in cfg:
        For each instruction in block.instructions:
            Let instruction_id be generate_instruction_id with block as block and instruction as instruction
            Let sources be get_instruction_sources with instruction as instruction
            Let destination be get_instruction_destination with instruction as instruction
            
            Note: Find dependencies on sources
            For each source in sources:
                Let source_deps be find_source_dependencies with tracker as tracker and source as source and current_instruction as instruction_id
                Add all source_deps to data_deps
            
            Note: Add this instruction to dependency graph
            If destination is not None:
                Let dep_node be DependencyNode with:
                    id as destination
                    type as "variable"
                    dependencies as set containing
                    dependents as set containing instruction_id
                    metadata as dictionary containing:
                        "variable_name" as destination
                        "defining_instruction" as instruction_id
                
                Set tracker.graph.nodes at key destination to dep_node
    
    Return data_deps

Process called "analyze_control_dependencies" that takes tracker as DependencyTracker and cfg as List[MIRBasicBlock] returns List[DependencyEdge]:
    Note: Analyze control dependencies between blocks
    Let control_deps be list containing
    
    For each block in cfg:
        Match block.terminator:
            When MIRBranch with condition as condition and true_target as true_target and false_target as false_target:
                Note: Add control dependencies for conditional branches
                Let true_block be find_block_by_name with cfg as cfg and name as true_target
                Let false_block be find_block_by_name with cfg as cfg and name as false_target
                
                If true_block is not None:
                    Add DependencyEdge with:
                        from_node as block.name
                        to_node as true_target
                        edge_type as "control_true"
                        metadata as dictionary containing:
                            "condition" as condition
                    to control_deps
                
                If false_block is not None:
                    Add DependencyEdge with:
                        from_node as block.name
                        to_node as false_target
                        edge_type as "control_false"
                        metadata as dictionary containing:
                            "condition" as condition
                    to control_deps
            
            When MIRJump with target as target:
                Note: Add control dependency for unconditional jumps
                Add DependencyEdge with:
                    from_node as block.name
                    to_node as target
                    edge_type as "control_jump"
                    metadata as dictionary containing
                to control_deps
    
    Return control_deps

Process called "find_circular_dependencies" that takes tracker as DependencyTracker returns List[List[String]]:
    Note: Find circular dependencies in the graph
    Let cycles be list containing
    Let visited be set containing
    let recursion_stack be set containing
    
    For each node_id in tracker.graph.nodes:
        If node_id is not in visited:
            Let cycle be detect_cycle_with_dfs with tracker as tracker and node_id as node_id and visited as visited and recursion_stack as recursion_stack
            If cycle is not None:
                Add cycle to cycles
    
    Return cycles

Process called "get_dependency_chain" that takes tracker as DependencyTracker and node_id as String returns List[String]:
    Note: Get the dependency chain for a node
    Let chain be list containing
    Let visited be set containing
    
    Let result be build_dependency_chain with tracker as tracker and node_id as node_id and chain as chain and visited as visited
    
    Return chain

Note: Helper functions for dependency tracking
Process called "generate_instruction_id" that takes block as MIRBasicBlock and instruction as MIRInstruction returns String:
    Note: Generate unique ID for an instruction
    Return block.name concatenated with "_" concatenated with string_from_integer with index of instruction in block.instructions

Process called "get_instruction_type" that takes instruction as MIRInstruction returns String:
    Note: Get the type of an instruction
    Match instruction:
        When MIRLoad:
            Return "load"
        When MIRStore:
            Return "store"
        When MIRBinaryOp:
            Return "binary_op"
        When MIRCall:
            Return "call"
        When MIRReturn:
            Return "return"
        When MIRPhi:
            Return "phi"
        When MIRAlloca:
            Return "alloca"
        Otherwise:
            Return "unknown"

Process called "get_instruction_sources" that takes instruction as MIRInstruction returns List[String]:
    Note: Get source operands of an instruction
    Match instruction:
        When MIRLoad with source as source:
            Return list containing source
        When MIRBinaryOp with left as left and right as right:
            Return list containing left, right
        When MIRCall with arguments as arguments:
            Return arguments
        When MIRPhi with operands as operands:
            Let sources be list containing
            For each operand in operands:
                Add operand.value to sources
            Return sources
        Otherwise:
            Return list containing

Process called "get_instruction_destination" that takes instruction as MIRInstruction returns Optional[String]:
    Note: Get destination operand of an instruction
    Match instruction:
        When MIRStore with destination as destination:
            Return destination
        When MIRBinaryOp with destination as destination:
            Return destination
        When MIRCall with destination as destination:
            Return destination
        When MIRPhi with destination as destination:
            Return destination
        When MIRAlloca with destination as destination:
            Return destination
        Otherwise:
            Return None

Process called "find_source_dependencies" that takes tracker as DependencyTracker and source as String and current_instruction as String returns List[DependencyEdge]:
    Note: Find dependencies on a source variable
    Let deps be list containing
    
    If source is in tracker.graph.nodes:
        Let source_node be tracker.graph.nodes at key source
        Add DependencyEdge with:
            from_node as source
            to_node as current_instruction
            edge_type as "data_dependency"
            metadata as dictionary containing:
                "source_variable" as source
        to deps
    
    Return deps

Process called "detect_cycle_with_dfs" that takes tracker as DependencyTracker and node_id as String and visited as Set[String] and recursion_stack as Set[String] returns Optional[List[String]]:
    Note: Detect cycles using depth-first search
    If node_id is in recursion_stack:
        Return list containing node_id
    
    If node_id is in visited:
        Return None
    
    Add node_id to visited
    Add node_id to recursion_stack
    
    If node_id is in tracker.graph.nodes:
        Let node be tracker.graph.nodes at key node_id
        
        For each dependent in node.dependents:
            Let cycle be detect_cycle_with_dfs with tracker as tracker and node_id as dependent and visited as visited and recursion_stack as recursion_stack
            If cycle is not None:
                If node_id is equal to (cycle at index 0):
                    Return cycle
                Otherwise:
                    Add node_id to cycle
                    Return cycle
    
    Remove node_id from recursion_stack
    Return None

Process called "build_dependency_chain" that takes tracker as DependencyTracker and node_id as String and chain as List[String] and visited as Set[String] returns Boolean:
    Note: Build dependency chain recursively
    If node_id is in visited:
        Return false
    
    Add node_id to visited
    Add node_id to chain
    
    If node_id is in tracker.graph.nodes:
        Let node be tracker.graph.nodes at key node_id
        
        For each dependency in node.dependencies:
            Let result be build_dependency_chain with tracker as tracker and node_id as dependency and chain as chain and visited as visited
            If result:
                Return true
    
    Return false

Process called "find_block_by_name" that takes cfg as List[MIRBasicBlock] and name as String returns Optional[MIRBasicBlock]:
    Note: Find a block by name
    For each block in cfg:
        If block.name is equal to name:
            Return block
    
    Return None 