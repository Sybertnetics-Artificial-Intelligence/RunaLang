Note: Runa Compiler: Data Flow Analysis Framework
Note: Provides data flow analysis for optimization passes

Import "../../mir/mir.runa"
Import "../../types/types.runa"
Import "../../ir_context.runa"

Note: Data Flow Analysis Types
Type DataFlowFact is Dictionary with:
    reaching_definitions as Set[String]
    live_variables as Set[String]
    available_expressions as Set[String]
    very_busy_expressions as Set[String]

Type DataFlowAnalysis is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    facts as Dictionary[String, DataFlowFact]
    analysis_type as String
    metadata as Dictionary[String, Any]

Note: Analysis Types
Type AnalysisType is:
    | ReachingDefinitions
    | LiveVariables
    | AvailableExpressions
    | VeryBusyExpressions

Process called "create_data_flow_analysis" that takes context as IRContext and type_system as TypeSystem and analysis_type as AnalysisType returns DataFlowAnalysis:
    Note: Create a new data flow analysis
    Return DataFlowAnalysis with:
        context as context
        type_system as type_system
        facts as dictionary containing
        analysis_type as analysis_type
        metadata as dictionary containing

Process called "analyze_data_flow" that takes analysis as DataFlowAnalysis and mir_function as MIRFunction returns Dictionary[String, Any]:
    Note: Perform data flow analysis on a MIR function
    Let cfg be mir_function.basic_blocks
    Let analysis_result be dictionary containing
    
    Match analysis.analysis_type:
        When ReachingDefinitions:
            Let result be analyze_reaching_definitions with analysis as analysis and cfg as cfg
            Set analysis_result to result
        When LiveVariables:
            Let result be analyze_live_variables with analysis as analysis and cfg as cfg
            Set analysis_result to result
        When AvailableExpressions:
            Let result be analyze_available_expressions with analysis as analysis and cfg as cfg
            Set analysis_result to result
        When VeryBusyExpressions:
            Let result be analyze_very_busy_expressions with analysis as analysis and cfg as cfg
            Set analysis_result to result
    
    Return analysis_result

Process called "analyze_reaching_definitions" that takes analysis as DataFlowAnalysis and cfg as List[MIRBasicBlock] returns Dictionary[String, Any]:
    Note: Analyze reaching definitions
    Let reaching_defs be dictionary containing
    Let worklist be list containing
    
    Note: Initialize worklist with all blocks
    For each block in cfg:
        Add block to worklist
        Set reaching_defs at key block.name to DataFlowFact with:
            reaching_definitions as set containing
            live_variables as set containing
            available_expressions as set containing
            very_busy_expressions as set containing
    
    Note: Iterative data flow analysis
    While worklist is not empty:
        Let current_block be remove first element from worklist
        Let old_fact be reaching_defs at key current_block.name
        Let new_fact be compute_reaching_definitions with analysis as analysis and block as current_block and predecessors as get_predecessors with cfg as cfg and block as current_block
        
        If new_fact is not equal to old_fact:
            Set reaching_defs at key current_block.name to new_fact
            Add all successors of current_block to worklist
    
    Return dictionary containing:
        "success" as true
        "reaching_definitions" as reaching_defs
        "statistics" as dictionary containing:
            "blocks_analyzed" as length of cfg
            "iterations" as 0  Note: Would track actual iterations

Process called "analyze_live_variables" that takes analysis as DataFlowAnalysis and cfg as List[MIRBasicBlock] returns Dictionary[String, Any]:
    Note: Analyze live variables
    Let live_vars be dictionary containing
    Let worklist be list containing
    
    Note: Initialize worklist with all blocks
    For each block in cfg:
        Add block to worklist
        Set live_vars at key block.name to DataFlowFact with:
            reaching_definitions as set containing
            live_variables as set containing
            available_expressions as set containing
            very_busy_expressions as set containing
    
    Note: Iterative data flow analysis (backward)
    While worklist is not empty:
        Let current_block be remove first element from worklist
        Let old_fact be live_vars at key current_block.name
        Let new_fact be compute_live_variables with analysis as analysis and block as current_block and successors as get_successors with cfg as cfg and block as current_block
        
        If new_fact is not equal to old_fact:
            Set live_vars at key current_block.name to new_fact
            Add all predecessors of current_block to worklist
    
    Return dictionary containing:
        "success" as true
        "live_variables" as live_vars
        "statistics" as dictionary containing:
            "blocks_analyzed" as length of cfg
            "iterations" as 0  Note: Would track actual iterations

Process called "analyze_available_expressions" that takes analysis as DataFlowAnalysis and cfg as List[MIRBasicBlock] returns Dictionary[String, Any]:
    Note: Analyze available expressions
    Let available_exprs be dictionary containing
    Let worklist be list containing
    
    Note: Initialize worklist with all blocks
    For each block in cfg:
        Add block to worklist
        Set available_exprs at key block.name to DataFlowFact with:
            reaching_definitions as set containing
            live_variables as set containing
            available_expressions as set containing
            very_busy_expressions as set containing
    
    Note: Iterative data flow analysis
    While worklist is not empty:
        Let current_block be remove first element from worklist
        Let old_fact be available_exprs at key current_block.name
        Let new_fact be compute_available_expressions with analysis as analysis and block as current_block and predecessors as get_predecessors with cfg as cfg and block as current_block
        
        If new_fact is not equal to old_fact:
            Set available_exprs at key current_block.name to new_fact
            Add all successors of current_block to worklist
    
    Return dictionary containing:
        "success" as true
        "available_expressions" as available_exprs
        "statistics" as dictionary containing:
            "blocks_analyzed" as length of cfg
            "iterations" as 0  Note: Would track actual iterations

Process called "analyze_very_busy_expressions" that takes analysis as DataFlowAnalysis and cfg as List[MIRBasicBlock] returns Dictionary[String, Any]:
    Note: Analyze very busy expressions
    Let very_busy_exprs be dictionary containing
    Let worklist be list containing
    
    Note: Initialize worklist with all blocks
    For each block in cfg:
        Add block to worklist
        Set very_busy_exprs at key block.name to DataFlowFact with:
            reaching_definitions as set containing
            live_variables as set containing
            available_expressions as set containing
            very_busy_expressions as set containing
    
    Note: Iterative data flow analysis (backward)
    While worklist is not empty:
        Let current_block be remove first element from worklist
        Let old_fact be very_busy_exprs at key current_block.name
        Let new_fact be compute_very_busy_expressions with analysis as analysis and block as current_block and successors as get_successors with cfg as cfg and block as current_block
        
        If new_fact is not equal to old_fact:
            Set very_busy_exprs at key current_block.name to new_fact
            Add all predecessors of current_block to worklist
    
    Return dictionary containing:
        "success" as true
        "very_busy_expressions" as very_busy_exprs
        "statistics" as dictionary containing:
            "blocks_analyzed" as length of cfg
            "iterations" as 0  Note: Would track actual iterations

Note: Helper functions for data flow analysis
Process called "compute_reaching_definitions" that takes analysis as DataFlowAnalysis and block as MIRBasicBlock and predecessors as List[MIRBasicBlock] returns DataFlowFact:
    Note: Compute reaching definitions for a block
    Let reaching_defs be set containing
    
    Note: Union of reaching definitions from predecessors
    For each pred in predecessors:
        Let pred_fact be analysis.facts at key pred.name
        Add all pred_fact.reaching_definitions to reaching_defs
    
    Note: Add definitions from this block
    For each instruction in block.instructions:
        If instruction is MIRStore:
            Add instruction.destination to reaching_defs
    
    Return DataFlowFact with:
        reaching_definitions as reaching_defs
        live_variables as set containing
        available_expressions as set containing
        very_busy_expressions as set containing

Process called "compute_live_variables" that takes analysis as DataFlowAnalysis and block as MIRBasicBlock and successors as List[MIRBasicBlock] returns DataFlowFact:
    Note: Compute live variables for a block
    Let live_vars be set containing
    
    Note: Union of live variables from successors
    For each succ in successors:
        Let succ_fact be analysis.facts at key succ.name
        Add all succ_fact.live_variables to live_vars
    
    Note: Add variables used in this block
    For each instruction in block.instructions:
        If instruction is MIRLoad:
            Add instruction.source to live_vars
        If instruction is MIRBinaryOp:
            Add instruction.left to live_vars
            Add instruction.right to live_vars
    
    Return DataFlowFact with:
        reaching_definitions as set containing
        live_variables as live_vars
        available_expressions as set containing
        very_busy_expressions as set containing

Process called "compute_available_expressions" that takes analysis as DataFlowAnalysis and block as MIRBasicBlock and predecessors as List[MIRBasicBlock] returns DataFlowFact:
    Note: Compute available expressions for a block
    Let available_exprs be set containing
    
    Note: Intersection of available expressions from predecessors
    If predecessors is not empty:
        Let first_pred_fact be analysis.facts at key (predecessors at index 0).name
        Set available_exprs to first_pred_fact.available_expressions
        
        For each pred in predecessors starting from index 1:
            Let pred_fact be analysis.facts at key pred.name
            Set available_exprs to intersection of available_exprs and pred_fact.available_expressions
    
    Note: Add expressions generated in this block
    For each instruction in block.instructions:
        If instruction is MIRBinaryOp:
            Let expr be instruction.left concatenated with " " concatenated with instruction.operator concatenated with " " concatenated with instruction.right
            Add expr to available_exprs
    
    Return DataFlowFact with:
        reaching_definitions as set containing
        live_variables as set containing
        available_expressions as available_exprs
        very_busy_expressions as set containing

Process called "compute_very_busy_expressions" that takes analysis as DataFlowAnalysis and block as MIRBasicBlock and successors as List[MIRBasicBlock] returns DataFlowFact:
    Note: Compute very busy expressions for a block
    Let very_busy_exprs be set containing
    
    Note: Intersection of very busy expressions from successors
    If successors is not empty:
        Let first_succ_fact be analysis.facts at key (successors at index 0).name
        Set very_busy_exprs to first_succ_fact.very_busy_expressions
        
        For each succ in successors starting from index 1:
            Let succ_fact be analysis.facts at key succ.name
            Set very_busy_exprs to intersection of very_busy_exprs and succ_fact.very_busy_expressions
    
    Note: Add expressions used in this block
    For each instruction in block.instructions:
        If instruction is MIRBinaryOp:
            Let expr be instruction.left concatenated with " " concatenated with instruction.operator concatenated with " " concatenated with instruction.right
            Add expr to very_busy_exprs
    
    Return DataFlowFact with:
        reaching_definitions as set containing
        live_variables as set containing
        available_expressions as set containing
        very_busy_expressions as very_busy_exprs

Note: CFG helper functions
Process called "get_predecessors" that takes cfg as List[MIRBasicBlock] and block as MIRBasicBlock returns List[MIRBasicBlock]:
    Note: Get predecessors of a block in the CFG
    Let predecessors be list containing
    
    For each cfg_block in cfg:
        If cfg_block.terminator is MIRJump with target as target and target is equal to block.name:
            Add cfg_block to predecessors
        If cfg_block.terminator is MIRBranch with true_target as true_target and false_target as false_target:
            If true_target is equal to block.name or false_target is equal to block.name:
                Add cfg_block to predecessors
    
    Return predecessors

Process called "get_successors" that takes cfg as List[MIRBasicBlock] and block as MIRBasicBlock returns List[MIRBasicBlock]:
    Note: Get successors of a block in the CFG
    Let successors be list containing
    
    Match block.terminator:
        When MIRJump with target as target:
            For each cfg_block in cfg:
                If cfg_block.name is equal to target:
                    Add cfg_block to successors
        When MIRBranch with true_target as true_target and false_target as false_target:
            For each cfg_block in cfg:
                If cfg_block.name is equal to true_target or cfg_block.name is equal to false_target:
                    Add cfg_block to successors
        Otherwise:
            Note: No successors for return/unreachable
    
    Return successors 