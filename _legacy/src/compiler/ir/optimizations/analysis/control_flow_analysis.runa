Note: Runa Compiler: Control Flow Analysis Framework
Note: Provides control flow analysis for optimization passes

Import "../../mir/mir.runa"
Import "../../types/types.runa"
Import "../../ir_context.runa"

Note: Control Flow Analysis Types
Type ControlFlowInfo is Dictionary with:
    dominators as Dictionary[String, Set[String]]
    post_dominators as Dictionary[String, Set[String]]
    dominance_frontiers as Dictionary[String, Set[String]]
    loops as List[LoopInfo]
    critical_edges as List[EdgeInfo]

Type LoopInfo is Dictionary with:
    header as String
    body as Set[String]
    back_edges as List[EdgeInfo]
    exit_edges as List[EdgeInfo]
    depth as Integer
    metadata as Dictionary[String, Any]

Type EdgeInfo is Dictionary with:
    from_block as String
    to_block as String
    edge_type as String
    metadata as Dictionary[String, Any]

Type ControlFlowAnalysis is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    cfg_info as ControlFlowInfo
    analysis_type as String
    metadata as Dictionary[String, Any]

Note: Analysis Types
Type CFAAnalysisType is:
    | DominanceAnalysis
    | LoopAnalysis
    | CriticalEdgeAnalysis
    | CompleteAnalysis

Process called "create_control_flow_analysis" that takes context as IRContext and type_system as TypeSystem and analysis_type as CFAAnalysisType returns ControlFlowAnalysis:
    Note: Create a new control flow analysis
    Return ControlFlowAnalysis with:
        context as context
        type_system as type_system
        cfg_info as ControlFlowInfo with:
            dominators as dictionary containing
            post_dominators as dictionary containing
            dominance_frontiers as dictionary containing
            loops as list containing
            critical_edges as list containing
        analysis_type as analysis_type
        metadata as dictionary containing

Process called "analyze_control_flow" that takes analysis as ControlFlowAnalysis and mir_function as MIRFunction returns Dictionary[String, Any]:
    Note: Perform control flow analysis on a MIR function
    Let cfg be mir_function.basic_blocks
    Let analysis_result be dictionary containing
    
    Match analysis.analysis_type:
        When DominanceAnalysis:
            Let result be analyze_dominance with analysis as analysis and cfg as cfg
            Set analysis_result to result
        When LoopAnalysis:
            Let result be analyze_loops with analysis as analysis and cfg as cfg
            Set analysis_result to result
        When CriticalEdgeAnalysis:
            Let result be analyze_critical_edges with analysis as analysis and cfg as cfg
            Set analysis_result to result
        When CompleteAnalysis:
            Let dominance_result be analyze_dominance with analysis as analysis and cfg as cfg
            Let loop_result be analyze_loops with analysis as analysis and cfg as cfg
            Let edge_result be analyze_critical_edges with analysis as analysis and cfg as cfg
            
            Set analysis_result to dictionary containing:
                "success" as true
                "dominance" as dominance_result
                "loops" as loop_result
                "critical_edges" as edge_result
                "statistics" as dictionary containing:
                    "blocks_analyzed" as length of cfg
                    "loops_found" as length of analysis.cfg_info.loops
                    "critical_edges" as length of analysis.cfg_info.critical_edges
    
    Return analysis_result

Process called "analyze_dominance" that takes analysis as ControlFlowAnalysis and cfg as List[MIRBasicBlock] returns Dictionary[String, Any]:
    Note: Analyze dominance relationships
    Let dominators be dictionary containing
    Let post_dominators be dictionary containing
    Let dominance_frontiers be dictionary containing
    
    Note: Initialize dominators
    For each block in cfg:
        Set dominators at key block.name to set containing
        Set post_dominators at key block.name to set containing
        Set dominance_frontiers at key block.name to set containing
    
    Note: Entry block dominates all
    If cfg is not empty:
        Let entry_block be cfg at index 0
        Set dominators at key entry_block.name to set containing entry_block.name
    
    Note: Iterative dominance computation
    Let changed be true
    While changed:
        Set changed to false
        
        For each block in cfg starting from index 1:
            Let old_doms be dominators at key block.name
            Let new_doms be compute_dominators with cfg as cfg and block as block and dominators as dominators
            
            If new_doms is not equal to old_doms:
                Set dominators at key block.name to new_doms
                Set changed to true
    
    Note: Compute dominance frontiers
    For each block in cfg:
        Let frontiers be compute_dominance_frontier with cfg as cfg and block as block and dominators as dominators
        Set dominance_frontiers at key block.name to frontiers
    
    Set analysis.cfg_info.dominators to dominators
    Set analysis.cfg_info.dominance_frontiers to dominance_frontiers
    
    Return dictionary containing:
        "success" as true
        "dominators" as dominators
        "dominance_frontiers" as dominance_frontiers
        "statistics" as dictionary containing:
            "blocks_analyzed" as length of cfg

Process called "analyze_loops" that takes analysis as ControlFlowAnalysis and cfg as List[MIRBasicBlock] returns Dictionary[String, Any]:
    Note: Analyze loops in the control flow graph
    Let loops be list containing
    Let back_edges be find_back_edges with cfg as cfg and dominators as analysis.cfg_info.dominators
    
    For each back_edge in back_edges:
        Let loop be identify_loop with cfg as cfg and back_edge as back_edge and dominators as analysis.cfg_info.dominators
        Add loop to loops
    
    Note: Compute loop nesting
    For each loop in loops:
        Set loop.depth to compute_loop_depth with loop as loop and loops as loops
    
    Set analysis.cfg_info.loops to loops
    
    Return dictionary containing:
        "success" as true
        "loops" as loops
        "statistics" as dictionary containing:
            "loops_found" as length of loops
            "back_edges" as length of back_edges

Process called "analyze_critical_edges" that takes analysis as ControlFlowAnalysis and cfg as List[MIRBasicBlock] returns Dictionary[String, Any]:
    Note: Analyze critical edges in the control flow graph
    Let critical_edges be list containing
    
    For each block in cfg:
        If length of get_successors with cfg as cfg and block as block is greater than 1:
            For each succ in get_successors with cfg as cfg and block as block:
                If length of get_predecessors with cfg as cfg and block as succ is greater than 1:
                    Add EdgeInfo with:
                        from_block as block.name
                        to_block as succ.name
                        edge_type as "critical"
                        metadata as dictionary containing
                    to critical_edges
    
    Set analysis.cfg_info.critical_edges to critical_edges
    
    Return dictionary containing:
        "success" as true
        "critical_edges" as critical_edges
        "statistics" as dictionary containing:
            "critical_edges_found" as length of critical_edges

Note: Helper functions for control flow analysis
Process called "compute_dominators" that takes cfg as List[MIRBasicBlock] and block as MIRBasicBlock and dominators as Dictionary[String, Set[String]] returns Set[String]:
    Note: Compute dominators for a block
    Let predecessors be get_predecessors with cfg as cfg and block as block
    
    If predecessors is empty:
        Return set containing block.name
    
    Let intersection be dominators at key (predecessors at index 0).name
    
    For each pred in predecessors starting from index 1:
        Let pred_doms be dominators at key pred.name
        Set intersection to intersection of intersection and pred_doms
    
    Add block.name to intersection
    Return intersection

Process called "compute_dominance_frontier" that takes cfg as List[MIRBasicBlock] and block as MIRBasicBlock and dominators as Dictionary[String, Set[String]] returns Set[String]:
    Note: Compute dominance frontier for a block
    Let frontier be set containing
    
    For each cfg_block in cfg:
        If cfg_block.name is not equal to block.name:
            Let preds be get_predecessors with cfg as cfg and block as cfg_block
            Let dominated_by_block be false
            Let has_pred_not_dominated_by_block be false
            
            For each pred in preds:
                If block.name is in (dominators at key pred.name):
                    Set dominated_by_block to true
                Otherwise:
                    Set has_pred_not_dominated_by_block to true
            
            If dominated_by_block and has_pred_not_dominated_by_block:
                Add cfg_block.name to frontier
    
    Return frontier

Process called "find_back_edges" that takes cfg as List[MIRBasicBlock] and dominators as Dictionary[String, Set[String]] returns List[EdgeInfo]:
    Note: Find back edges in the control flow graph
    Let back_edges be list containing
    
    For each block in cfg:
        Let successors be get_successors with cfg as cfg and block as block
        
        For each succ in successors:
            If succ.name is in (dominators at key block.name):
                Add EdgeInfo with:
                    from_block as block.name
                    to_block as succ.name
                    edge_type as "back_edge"
                    metadata as dictionary containing
                to back_edges
    
    Return back_edges

Process called "identify_loop" that takes cfg as List[MIRBasicBlock] and back_edge as EdgeInfo and dominators as Dictionary[String, Set[String]] returns LoopInfo:
    Note: Identify loop from a back edge
    Let header be back_edge.to_block
    Let body be set containing
    
    Note: Find all blocks in the loop body
    For each block in cfg:
        If header is in (dominators at key block.name) and block.name is in (dominators at key back_edge.from_block):
            Add block.name to body
    
    Note: Find exit edges
    Let exit_edges be list containing
    For each block_name in body:
        Let block be find_block_by_name with cfg as cfg and name as block_name
        Let successors be get_successors with cfg as cfg and block as block
        
        For each succ in successors:
            If succ.name is not in body:
                Add EdgeInfo with:
                    from_block as block.name
                    to_block as succ.name
                    edge_type as "exit_edge"
                    metadata as dictionary containing
                to exit_edges
    
    Return LoopInfo with:
        header as header
        body as body
        back_edges as list containing back_edge
        exit_edges as exit_edges
        depth as 0  Note: Will be computed later
        metadata as dictionary containing

Process called "compute_loop_depth" that takes loop as LoopInfo and loops as List[LoopInfo] returns Integer:
    Note: Compute nesting depth of a loop
    Let depth be 1
    
    For each other_loop in loops:
        If other_loop is not equal to loop:
            If loop.header is in other_loop.body:
                Set depth to depth plus 1
    
    Return depth

Process called "find_block_by_name" that takes cfg as List[MIRBasicBlock] and name as String returns MIRBasicBlock:
    Note: Find a block by name
    For each block in cfg:
        If block.name is equal to name:
            Return block
    
    Return None  Note: Should not happen in valid CFG

Note: CFG helper functions (reused from data flow analysis)
Process called "get_predecessors" that takes cfg as List[MIRBasicBlock] and block as MIRBasicBlock returns List[MIRBasicBlock]:
    Note: Get predecessors of a block in the CFG
    Let predecessors be list containing
    
    For each cfg_block in cfg:
        If cfg_block.terminator is MIRJump with target as target and target is equal to block.name:
            Add cfg_block to predecessors
        If cfg_block.terminator is MIRBranch with true_target as true_target and false_target as false_target:
            If true_target is equal to block.name or false_target is equal to block.name:
                Add cfg_block to predecessors
    
    Return predecessors

Process called "get_successors" that takes cfg as List[MIRBasicBlock] and block as MIRBasicBlock returns List[MIRBasicBlock]:
    Note: Get successors of a block in the CFG
    Let successors be list containing
    
    Match block.terminator:
        When MIRJump with target as target:
            For each cfg_block in cfg:
                If cfg_block.name is equal to target:
                    Add cfg_block to successors
        When MIRBranch with true_target as true_target and false_target as false_target:
            For each cfg_block in cfg:
                If cfg_block.name is equal to true_target or cfg_block.name is equal to false_target:
                    Add cfg_block to successors
        Otherwise:
            Note: No successors for return/unreachable
    
    Return successors 