Note: Runa Compiler: MIR Dead Code Elimination Optimization
Note: Removes unreachable code and unused variables

Import "../../mir/mir.runa"
Import "../../types/types.runa"
Import "../../ir_context.runa"

Note: MIR Dead Code Elimination Optimization
Type DeadCodeEliminationPass is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    live_variables as Set[String]
    reachable_blocks as Set[String]
    removed_instructions as Integer
    removed_blocks as Integer
    metadata as Dictionary[String, Any]

Process called "create_dead_code_elimination_pass" that takes context as IRContext and type_system as TypeSystem returns DeadCodeEliminationPass:
    Note: Create a new dead code elimination pass
    Return DeadCodeEliminationPass with:
        context as context
        type_system as type_system
        live_variables as set containing
        reachable_blocks as set containing
        removed_instructions as 0
        removed_blocks as 0
        metadata as dictionary containing

Process called "optimize_mir_with_dead_code_elimination" that takes mir_module as MIRModule and context as IRContext returns Dictionary[String, Any]:
    Note: Apply dead code elimination to MIR module
    Let type_system be create_type_system
    Let eliminator be create_dead_code_elimination_pass with context as context and type_system as type_system
    
    Let optimized_module be copy_mir_module with module as mir_module
    Let total_removed_instructions be 0
    Let total_removed_blocks be 0
    
    For each function in optimized_module.functions:
        Let function_result be eliminate_dead_code_in_function with eliminator as eliminator and mir_function as function
        Set total_removed_instructions to total_removed_instructions plus function_result.removed_instructions
        Set total_removed_blocks to total_removed_blocks plus function_result.removed_blocks
    
    Return dictionary containing:
        "success" as true
        "optimized_module" as optimized_module
        "statistics" as dictionary containing:
            "removed_instructions" as total_removed_instructions
            "removed_blocks" as total_removed_blocks
            "elimination_ratio" as ((total_removed_instructions divided by get_total_instruction_count with mir_module as optimized_module) multiplied by 100.0 if get_total_instruction_count with mir_module as optimized_module is greater than 0 else 0.0)

Process called "eliminate_dead_code_in_function" that takes eliminator as DeadCodeEliminationPass and mir_function as MIRFunction returns Dictionary[String, Any]:
    Note: Apply dead code elimination to a single function
    Let removed_instructions be 0
    Let removed_blocks be 0
    
    Note: Find reachable basic blocks
    Let reachable_blocks be find_reachable_blocks with mir_function as mir_function
    Set eliminator.reachable_blocks to reachable_blocks
    
    Note: Find live variables
    Let live_vars be find_live_variables with mir_function as mir_function and reachable_blocks as reachable_blocks
    Set eliminator.live_variables to live_vars
    
    Note: Remove unreachable blocks
    Let remaining_blocks be list containing
    For each basic_block in mir_function.basic_blocks:
        If basic_block.name is in reachable_blocks:
            Add basic_block to remaining_blocks
        Otherwise:
            Set removed_blocks to removed_blocks plus 1
    
    Set mir_function.basic_blocks to remaining_blocks
    
    Note: Remove dead instructions from remaining blocks
    For each basic_block in mir_function.basic_blocks:
        Let block_result be eliminate_dead_instructions_in_block with eliminator as eliminator and basic_block as basic_block
        Set removed_instructions to removed_instructions plus block_result.removed_instructions
    
    Return dictionary containing:
        "removed_instructions" as removed_instructions
        "removed_blocks" as removed_blocks

Process called "find_reachable_blocks" that takes mir_function as MIRFunction returns Set[String]:
    Note: Find all reachable basic blocks using BFS
    Let reachable_blocks be set containing
    Let worklist be list containing mir_function.entry_block
    Add mir_function.entry_block to reachable_blocks
    
    While length of worklist is greater than 0:
        Let current_block_name be worklist at index 0
        Remove worklist at index 0
        
        Let current_block be find_basic_block_by_name with mir_function as mir_function and name as current_block_name
        If current_block is not None:
            For each successor in current_block.successors:
                If successor is not in reachable_blocks:
                    Add successor to reachable_blocks
                    Add successor to worklist
    
    Return reachable_blocks

Process called "find_live_variables" that takes mir_function as MIRFunction and reachable_blocks as Set[String] returns Set[String]:
    Note: Find all live variables in reachable blocks
    Let live_variables be set containing
    
    For each basic_block in mir_function.basic_blocks:
        If basic_block.name is in reachable_blocks:
            For each instruction in basic_block.instructions:
                Let sources be get_mir_instruction_sources with instruction as instruction
                For each source in sources:
                    Add source to live_variables
    
    Return live_variables

Process called "eliminate_dead_instructions_in_block" that takes eliminator as DeadCodeEliminationPass and basic_block as MIRBasicBlock returns Dictionary[String, Any]:
    Note: Remove dead instructions from a basic block
    Let removed_instructions be 0
    Let optimized_instructions be list containing
    
    For each instruction in basic_block.instructions:
        Let destination be get_mir_instruction_destination with instruction as instruction
        
        If destination is not None:
            If destination is in eliminator.live_variables:
                Add instruction to optimized_instructions
            Else:
                Set removed_instructions to removed_instructions plus 1
        Else:
            Note: Instructions without destinations (like calls with no return value) are kept
            Add instruction to optimized_instructions
    
    Set basic_block.instructions to optimized_instructions
    
    Return dictionary containing:
        "removed_instructions" as removed_instructions

Process called "get_total_instruction_count" that takes mir_module as MIRModule returns Integer:
    Note: Get total instruction count in MIR module
    Let total_count be 0
    
    For each function in mir_module.functions:
        For each basic_block in function.basic_blocks:
            Set total_count to total_count plus length of basic_block.instructions
    
    Return total_count

Process called "copy_mir_module" that takes module as MIRModule returns MIRModule:
    Note: Create a copy of a MIR module
    Let copied_functions be list containing
    For each function in module.functions:
        Let copied_function be copy_mir_function with function as function
        Add copied_function to copied_functions
    
    Return MIRModule with:
        name as module.name
        functions as copied_functions
        global_variables as module.global_variables

Process called "copy_mir_function" that takes function as MIRFunction returns MIRFunction:
    Note: Create a copy of a MIR function
    Let copied_basic_blocks be list containing
    For each basic_block in function.basic_blocks:
        Let copied_block be copy_mir_basic_block with basic_block as basic_block
        Add copied_block to copied_basic_blocks
    
    Return MIRFunction with:
        name as function.name
        parameters as function.parameters
        return_type as function.return_type
        basic_blocks as copied_basic_blocks
        entry_block as function.entry_block
        exit_blocks as function.exit_blocks
        local_variables as function.local_variables
        stack_frame_size as function.stack_frame_size
        metadata as function.metadata

Process called "copy_mir_basic_block" that takes basic_block as MIRBasicBlock returns MIRBasicBlock:
    Note: Create a copy of a MIR basic block
    Return MIRBasicBlock with:
        name as basic_block.name
        instructions as basic_block.instructions
        terminator as basic_block.terminator
        predecessors as basic_block.predecessors
        successors as basic_block.successors
        live_in as basic_block.live_in
        live_out as basic_block.live_out
        metadata as basic_block.metadata

Note: Dead Code Elimination Pass Diagnostics
Process called "get_dead_code_elimination_diagnostics" that takes eliminator as DeadCodeEliminationPass returns List[IRDiagnostic]:
    Note: Get diagnostics from dead code elimination pass
    Return eliminator.context.diagnostics

Process called "has_dead_code_elimination_errors" that takes eliminator as DeadCodeEliminationPass returns Boolean:
    Note: Check if dead code elimination pass has errors
    Let diagnostics be get_dead_code_elimination_diagnostics with eliminator as eliminator
    
    For each diagnostic in diagnostics:
        If diagnostic.severity is equal to "error":
            Return true
    
    Return false

Note: Dead Code Elimination Statistics
Process called "get_dead_code_elimination_statistics" that takes mir_module as MIRModule returns Dictionary[String, Any]:
    Note: Get dead code elimination statistics for a MIR module
    Let type_system be create_type_system
    Let eliminator be create_dead_code_elimination_pass with context as create_ir_context with compilation_unit as "stats" and source_file as "unknown" and type_system as type_system
    
    Let optimization_result be optimize_mir_with_dead_code_elimination with mir_module as mir_module and context as eliminator.context
    Let statistics be optimization_result.statistics
    
    Return dictionary containing:
        "removed_instructions" as statistics.removed_instructions
        "removed_blocks" as statistics.removed_blocks
        "elimination_ratio" as statistics.elimination_ratio
        "function_count" as length of mir_module.functions
        "basic_block_count" as get_total_basic_block_count with mir_module as mir_module 