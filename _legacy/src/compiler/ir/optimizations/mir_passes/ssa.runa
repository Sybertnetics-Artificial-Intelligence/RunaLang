Note: Runa Compiler: MIR SSA Construction Optimization
Note: Converts MIR to Static Single Assignment form

Import "../../mir/mir.runa"
Import "../../types/types.runa"
Import "../../ir_context.runa"

Note: MIR SSA Construction Optimization
Type SSAPass is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    variable_versions as Dictionary[String, Integer]
    phi_insertions as List[Dictionary[String, Any]]
    dominance_frontier as Dictionary[String, Set[String]]
    metadata as Dictionary[String, Any]

Process called "create_ssa_pass" that takes context as IRContext and type_system as TypeSystem returns SSAPass:
    Note: Create a new SSA construction pass
    Return SSAPass with:
        context as context
        type_system as type_system
        variable_versions as dictionary containing
        phi_insertions as list containing
        dominance_frontier as dictionary containing
        metadata as dictionary containing

Process called "optimize_mir_with_ssa" that takes mir_module as MIRModule and context as IRContext returns Dictionary[String, Any]:
    Note: Convert MIR module to SSA form
    Let type_system be create_type_system
    Let ssa_pass be create_ssa_pass with context as context and type_system as type_system
    
    Let optimized_module be copy_mir_module with module as mir_module
    Let total_phi_insertions be 0
    Let total_variable_versions be 0
    
    For each function in optimized_module.functions:
        Let function_result be convert_function_to_ssa with ssa_pass as ssa_pass and mir_function as function
        Set total_phi_insertions to total_phi_insertions plus function_result.phi_insertions
        Set total_variable_versions to total_variable_versions plus function_result.variable_versions
    
    Return dictionary containing:
        "success" as true
        "optimized_module" as optimized_module
        "statistics" as dictionary containing:
            "phi_insertions" as total_phi_insertions
            "variable_versions" as total_variable_versions
            "ssa_conversion_ratio" as ((total_phi_insertions divided by get_total_basic_block_count with mir_module as optimized_module) multiplied by 100.0 if get_total_basic_block_count with mir_module as optimized_module is greater than 0 else 0.0)

Process called "convert_function_to_ssa" that takes ssa_pass as SSAPass and mir_function as MIRFunction returns Dictionary[String, Any]:
    Note: Convert a single function to SSA form
    Let phi_insertions be 0
    Let variable_versions be 0
    
    Note: Compute dominance frontier
    Let dominance_frontier be compute_dominance_frontier with mir_function as mir_function
    Set ssa_pass.dominance_frontier to dominance_frontier
    
    Note: Find all variables that need SSA conversion
    Let variables be find_all_variables with mir_function as mir_function
    
    For each variable in variables:
        Let variable_result be convert_variable_to_ssa with ssa_pass as ssa_pass and mir_function as mir_function and variable as variable
        Set phi_insertions to phi_insertions plus variable_result.phi_insertions
        Set variable_versions to variable_versions plus variable_result.versions
    
    Return dictionary containing:
        "phi_insertions" as phi_insertions
        "variable_versions" as variable_versions

Process called "compute_dominance_frontier" that takes mir_function as MIRFunction returns Dictionary[String, Set[String]]:
    Note: Compute dominance frontier for all basic blocks
    Let dominance_frontier be dictionary containing
    
    For each basic_block in mir_function.basic_blocks:
        Set dominance_frontier at key basic_block.name to set containing
    
    Note: Compute dominance frontier using iterative algorithm
    For each basic_block in mir_function.basic_blocks:
        If length of basic_block.predecessors is greater than 1:
            For each pred_name in basic_block.predecessors:
                Let pred_block be find_basic_block_by_name with mir_function as mir_function and name as pred_name
                If pred_block is not None:
                    Let frontier be compute_block_dominance_frontier with mir_function as mir_function and block as pred_block
                    For each frontier_block in frontier:
                        Add frontier_block to dominance_frontier at key basic_block.name
    
    Return dominance_frontier

Process called "compute_block_dominance_frontier" that takes mir_function as MIRFunction and block as MIRBasicBlock returns Set[String]:
    Note: Compute dominance frontier for a single block
    Let frontier be set containing
    
    For each successor in block.successors:
        Let succ_block be find_basic_block_by_name with mir_function as mir_function and name as successor
        If succ_block is not None:
            If not dominates_block with mir_function as mir_function and dominator as block and dominated as succ_block:
                Add successor to frontier
    
    Return frontier

Process called "dominates_block" that takes mir_function as MIRFunction and dominator as MIRBasicBlock and dominated as MIRBasicBlock returns Boolean:
    Note: Check if dominator block dominates dominated block
    Note: Simplified dominance check - in practice, this would use a proper dominance tree
    If dominator.name is equal to dominated.name:
        Return true
    
    Note: Check if dominator is the entry block
    If dominator.name is equal to mir_function.entry_block:
        Return true
    
    Note: Check if dominated is reachable from dominator
    Let reachable_blocks be find_reachable_blocks_from with mir_function as mir_function and start_block as dominator
    Return dominated.name is in reachable_blocks

Process called "find_reachable_blocks_from" that takes mir_function as MIRFunction and start_block as MIRBasicBlock returns Set[String]:
    Note: Find all blocks reachable from start_block
    Let reachable_blocks be set containing
    Let worklist be list containing start_block.name
    Add start_block.name to reachable_blocks
    
    While length of worklist is greater than 0:
        Let current_block_name be worklist at index 0
        Remove worklist at index 0
        
        Let current_block be find_basic_block_by_name with mir_function as mir_function and name as current_block_name
        If current_block is not None:
            For each successor in current_block.successors:
                If successor is not in reachable_blocks:
                    Add successor to reachable_blocks
                    Add successor to worklist
    
    Return reachable_blocks

Process called "find_all_variables" that takes mir_function as MIRFunction returns Set[String]:
    Note: Find all variables used in the function
    Let variables be set containing
    
    For each basic_block in mir_function.basic_blocks:
        For each instruction in basic_block.instructions:
            Let destination be get_mir_instruction_destination with instruction as instruction
            If destination is not None:
                Add destination to variables
            
            Let sources be get_mir_instruction_sources with instruction as instruction
            For each source in sources:
                Add source to variables
    
    Return variables

Process called "convert_variable_to_ssa" that takes ssa_pass as SSAPass and mir_function as MIRFunction and variable as String returns Dictionary[String, Any]:
    Note: Convert a single variable to SSA form
    Let phi_insertions be 0
    Let versions be 0
    
    Note: Find all definitions of the variable
    Let definitions be find_variable_definitions with mir_function as mir_function and variable as variable
    
    If length of definitions is greater than 1:
        Note: Multiple definitions - need SSA conversion
        Let phi_result be insert_phi_functions with ssa_pass as ssa_pass and mir_function as mir_function and variable as variable and definitions as definitions
        Set phi_insertions to phi_insertions plus phi_result.insertions
        Set versions to versions plus phi_result.versions
    
    Return dictionary containing:
        "phi_insertions" as phi_insertions
        "versions" as versions

Process called "find_variable_definitions" that takes mir_function as MIRFunction and variable as String returns List[String]:
    Note: Find all basic blocks where the variable is defined
    Let definitions be list containing
    
    For each basic_block in mir_function.basic_blocks:
        For each instruction in basic_block.instructions:
            Let destination be get_mir_instruction_destination with instruction as instruction
            If destination is equal to variable:
                Add basic_block.name to definitions
    
    Return definitions

Process called "insert_phi_functions" that takes ssa_pass as SSAPass and mir_function as MIRFunction and variable as String and definitions as List[String] returns Dictionary[String, Any]:
    Note: Insert phi functions for variable SSA conversion
    Let insertions be 0
    Let versions be 0
    
    Note: Find blocks that need phi functions
    Let phi_blocks be find_phi_insertion_blocks with ssa_pass as ssa_pass and variable as variable and definitions as definitions
    
    For each block_name in phi_blocks:
        Let phi_result be insert_phi_in_block with ssa_pass as ssa_pass and mir_function as mir_function and variable as variable and block_name as block_name
        Set insertions to insertions plus phi_result.insertions
        Set versions to versions plus phi_result.versions
    
    Return dictionary containing:
        "insertions" as insertions
        "versions" as versions

Process called "find_phi_insertion_blocks" that takes ssa_pass as SSAPass and variable as String and definitions as List[String] returns Set[String]:
    Note: Find blocks where phi functions need to be inserted
    Let phi_blocks be set containing
    
    For each def_block in definitions:
        If def_block is in ssa_pass.dominance_frontier:
            Let frontier_blocks be ssa_pass.dominance_frontier at key def_block
            For each frontier_block in frontier_blocks:
                Add frontier_block to phi_blocks
    
    Return phi_blocks

Process called "insert_phi_in_block" that takes ssa_pass as SSAPass and mir_function as MIRFunction and variable as String and block_name as String returns Dictionary[String, Any]:
    Note: Insert a phi function in a specific block
    Let insertions be 0
    Let versions be 0
    
    Let block be find_basic_block_by_name with mir_function as mir_function and name as block_name
    If block is not None:
        Note: Create phi operands from predecessors
        Let phi_operands be list containing
        For each pred_name in block.predecessors:
            Let operand be PhiOperand with block as pred_name and value as variable
            Add operand to phi_operands
        
        Note: Create new variable version
        Let current_version be get_variable_version with ssa_pass as ssa_pass and variable as variable
        Let new_version be current_version plus 1
        Set ssa_pass.variable_versions at key variable to new_version
        Set versions to versions plus 1
        
        Let new_variable be variable plus "_" plus new_version
        Let phi_instruction be create_mir_phi with destination as new_variable and operands as phi_operands and type as IRUnknownType
        
        Note: Insert phi at beginning of block
        Add phi_instruction to block.instructions at index 0
        Set insertions to insertions plus 1
    
    Return dictionary containing:
        "insertions" as insertions
        "versions" as versions

Process called "get_variable_version" that takes ssa_pass as SSAPass and variable as String returns Integer:
    Note: Get current version number for a variable
    If variable is in ssa_pass.variable_versions:
        Return ssa_pass.variable_versions at key variable
    Otherwise:
        Return 0

Process called "copy_mir_module" that takes module as MIRModule returns MIRModule:
    Note: Create a copy of a MIR module
    Let copied_functions be list containing
    For each function in module.functions:
        Let copied_function be copy_mir_function with function as function
        Add copied_function to copied_functions
    
    Return MIRModule with:
        name as module.name
        functions as copied_functions
        global_variables as module.global_variables

Process called "copy_mir_function" that takes function as MIRFunction returns MIRFunction:
    Note: Create a copy of a MIR function
    Let copied_basic_blocks be list containing
    For each basic_block in function.basic_blocks:
        Let copied_block be copy_mir_basic_block with basic_block as basic_block
        Add copied_block to copied_basic_blocks
    
    Return MIRFunction with:
        name as function.name
        parameters as function.parameters
        return_type as function.return_type
        basic_blocks as copied_basic_blocks
        entry_block as function.entry_block
        exit_blocks as function.exit_blocks
        local_variables as function.local_variables
        stack_frame_size as function.stack_frame_size
        metadata as function.metadata

Process called "copy_mir_basic_block" that takes basic_block as MIRBasicBlock returns MIRBasicBlock:
    Note: Create a copy of a MIR basic block
    Return MIRBasicBlock with:
        name as basic_block.name
        instructions as basic_block.instructions
        terminator as basic_block.terminator
        predecessors as basic_block.predecessors
        successors as basic_block.successors
        live_in as basic_block.live_in
        live_out as basic_block.live_out
        metadata as basic_block.metadata

Note: SSA Pass Diagnostics
Process called "get_ssa_diagnostics" that takes ssa_pass as SSAPass returns List[IRDiagnostic]:
    Note: Get diagnostics from SSA pass
    Return ssa_pass.context.diagnostics

Process called "has_ssa_errors" that takes ssa_pass as SSAPass returns Boolean:
    Note: Check if SSA pass has errors
    Let diagnostics be get_ssa_diagnostics with ssa_pass as ssa_pass
    
    For each diagnostic in diagnostics:
        If diagnostic.severity is equal to "error":
            Return true
    
    Return false

Note: SSA Statistics
Process called "get_ssa_statistics" that takes mir_module as MIRModule returns Dictionary[String, Any]:
    Note: Get SSA statistics for a MIR module
    Let type_system be create_type_system
    Let ssa_pass be create_ssa_pass with context as create_ir_context with compilation_unit as "stats" and source_file as "unknown" and type_system as type_system
    
    Let optimization_result be optimize_mir_with_ssa with mir_module as mir_module and context as ssa_pass.context
    Let statistics be optimization_result.statistics
    
    Return dictionary containing:
        "phi_insertions" as statistics.phi_insertions
        "variable_versions" as statistics.variable_versions
        "ssa_conversion_ratio" as statistics.ssa_conversion_ratio
        "function_count" as length of mir_module.functions
        "basic_block_count" as get_total_basic_block_count with mir_module as mir_module 