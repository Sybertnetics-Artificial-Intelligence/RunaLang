Note: Runa Compiler: MIR Constant Folding Optimization
Note: Evaluates constant expressions at compile time

Import "../../mir/mir.runa"
Import "../../types/types.runa"
Import "../../ir_context.runa"

Note: MIR Constant Folding Optimization
Type ConstantFoldingPass is Dictionary with:
    context as IRContext
    type_system as TypeSystem
    constant_values as Dictionary[String, Any]
    folded_instructions as Integer
    metadata as Dictionary[String, Any]

Process called "create_constant_folding_pass" that takes context as IRContext and type_system as TypeSystem returns ConstantFoldingPass:
    Note: Create a new constant folding pass
    Return ConstantFoldingPass with:
        context as context
        type_system as type_system
        constant_values as dictionary containing
        folded_instructions as 0
        metadata as dictionary containing

Process called "optimize_mir_with_constant_folding" that takes mir_module as MIRModule and context as IRContext returns Dictionary[String, Any]:
    Note: Apply constant folding optimization to MIR module
    Let type_system be create_type_system
    Let folder be create_constant_folding_pass with context as context and type_system as type_system
    
    Let optimized_module be copy_mir_module with module as mir_module
    Let total_folded be 0
    
    For each function in optimized_module.functions:
        Let function_result be fold_constants_in_function with folder as folder and mir_function as function
        Set total_folded to total_folded plus function_result.folded_count
    
    Return dictionary containing:
        "success" as true
        "optimized_module" as optimized_module
        "statistics" as dictionary containing:
            "folded_instructions" as total_folded
            "constant_values" as length of folder.constant_values

Process called "fold_constants_in_function" that takes folder as ConstantFoldingPass and mir_function as MIRFunction returns Dictionary[String, Any]:
    Note: Apply constant folding to a single function
    Let folded_count be 0
    
    For each basic_block in mir_function.basic_blocks:
        Let block_result be fold_constants_in_basic_block with folder as folder and basic_block as basic_block
        Set folded_count to folded_count plus block_result.folded_count
    
    Return dictionary containing:
        "folded_count" as folded_count

Process called "fold_constants_in_basic_block" that takes folder as ConstantFoldingPass and basic_block as MIRBasicBlock returns Dictionary[String, Any]:
    Note: Apply constant folding to a basic block
    Let folded_count be 0
    Let optimized_instructions be list containing
    
    For each instruction in basic_block.instructions:
        Let folding_result be try_fold_instruction with folder as folder and instruction as instruction
        If folding_result.folded:
            Set folded_count to folded_count plus 1
            If folding_result.replacement is not None:
                Add folding_result.replacement to optimized_instructions
        Otherwise:
            Add instruction to optimized_instructions
    
    Set basic_block.instructions to optimized_instructions
    
    Return dictionary containing:
        "folded_count" as folded_count

Process called "try_fold_instruction" that takes folder as ConstantFoldingPass and instruction as MIRInstruction returns Dictionary[String, Any]:
    Note: Try to fold a single instruction
    Match instruction:
        When MIRBinaryOp with destination as destination and left as left and operator as operator and right as right and type as type:
            Let folding_result be fold_binary_operation with folder as folder and left as left and operator as operator and right as right and type as type
            If folding_result.can_fold:
                Set folder.constant_values at key destination to folding_result.value
                Set folder.folded_instructions to folder.folded_instructions plus 1
                Return dictionary containing:
                    "folded" as true
                    "replacement" as None
            Otherwise:
                Return dictionary containing:
                    "folded" as false
                    "replacement" as None
        
        When MIRLoad with destination as destination and source as source and type as type:
            Let folding_result be fold_load_instruction with folder as folder and source as source and type as type
            If folding_result.can_fold:
                Set folder.constant_values at key destination to folding_result.value
                Set folder.folded_instructions to folder.folded_instructions plus 1
                Return dictionary containing:
                    "folded" as true
                    "replacement" as None
            Otherwise:
                Return dictionary containing:
                    "folded" as false
                    "replacement" as None
        
        Otherwise:
            Return dictionary containing:
                "folded" as false
                "replacement" as None

Process called "fold_binary_operation" that takes folder as ConstantFoldingPass and left as String and operator as String and right as String and type as IRType returns Dictionary[String, Any]:
    Note: Fold a binary operation if both operands are constants
    Let left_value be get_constant_value with folder as folder and variable as left
    Let right_value be get_constant_value with folder as folder and variable as right
    
    If left_value is None or right_value is None:
        Return dictionary containing:
            "can_fold" as false
            "value" as None
    
    Note: Perform the operation based on type
    Match type:
        When IRPrimitiveType with name as name and size as size and alignment as alignment:
            If name is equal to "Integer":
                Let result be evaluate_integer_binary_op with left as left_value and operator as operator and right as right_value
                Return dictionary containing:
                    "can_fold" as true
                    "value" as result
            Otherwise if name is equal to "Float":
                Let result be evaluate_float_binary_op with left as left_value and operator as operator and right as right_value
                Return dictionary containing:
                    "can_fold" as true
                    "value" as result
            Otherwise if name is equal to "String":
                Let result be evaluate_string_binary_op with left as left_value and operator as operator and right as right_value
                Return dictionary containing:
                    "can_fold" as true
                    "value" as result
            Otherwise:
                Return dictionary containing:
                    "can_fold" as false
                    "value" as None
        Otherwise:
            Return dictionary containing:
                "can_fold" as false
                "value" as None

Process called "fold_load_instruction" that takes folder as ConstantFoldingPass and source as String and type as IRType returns Dictionary[String, Any]:
    Note: Fold a load instruction if the source is a constant
    Let source_value be get_constant_value with folder as folder and variable as source
    
    If source_value is not None:
        Return dictionary containing:
            "can_fold" as true
            "value" as source_value
    Otherwise:
        Return dictionary containing:
            "can_fold" as false
            "value" as None

Process called "get_constant_value" that takes folder as ConstantFoldingPass and variable as String returns Optional[Any]:
    Note: Get the constant value for a variable
    If variable is in folder.constant_values:
        Return folder.constant_values at key variable
    Otherwise:
        Return None

Process called "evaluate_integer_binary_op" that takes left as Any and operator as String and right as Any returns Optional[Integer]:
    Note: Evaluate an integer binary operation
    If left is not Integer or right is not Integer:
        Return None
    
    Match operator:
        When "plus":
            Return left plus right
        When "minus":
            Return left minus right
        When "multiply":
            Return left multiplied by right
        When "divide":
            If right is equal to 0:
                Return None
            Otherwise:
                Return left divided by right
        When "modulo":
            If right is equal to 0:
                Return None
            Otherwise:
                Return left modulo right
        When "power":
            If right is less than 0:
                Return None
            Otherwise:
                Return left to the power of right
        When "bitwise_and":
            Return left bitwise and right
        When "bitwise_or":
            Return left bitwise or right
        When "bitwise_xor":
            Return left bitwise xor right
        When "left_shift":
            If right is less than 0:
                Return None
            Otherwise:
                Return left left shifted by right
        When "right_shift":
            If right is less than 0:
                Return None
            Otherwise:
                Return left right shifted by right
        When "equal":
            Return (left is equal to right) as Integer
        When "not_equal":
            Return (left is not equal to right) as Integer
        When "less_than":
            Return (left is less than right) as Integer
        When "less_equal":
            Return (left is less than or equal to right) as Integer
        When "greater_than":
            Return (left is greater than right) as Integer
        When "greater_equal":
            Return (left is greater than or equal to right) as Integer
        Otherwise:
            Return None

Process called "evaluate_float_binary_op" that takes left as Any and operator as String and right as Any returns Optional[Float]:
    Note: Evaluate a float binary operation
    If left is not Float or right is not Float:
        Return None
    
    Match operator:
        When "plus":
            Return left plus right
        When "minus":
            Return left minus right
        When "multiply":
            Return left multiplied by right
        When "divide":
            If right is equal to 0.0:
                Return None
            Otherwise:
                Return left divided by right
        When "power":
            Return left to the power of right
        When "equal":
            Return (left is equal to right) as Float
        When "not_equal":
            Return (left is not equal to right) as Float
        When "less_than":
            Return (left is less than right) as Float
        When "less_equal":
            Return (left is less than or equal to right) as Float
        When "greater_than":
            Return (left is greater than right) as Float
        When "greater_equal":
            Return (left is greater than or equal to right) as Float
        Otherwise:
            Return None

Process called "evaluate_string_binary_op" that takes left as Any and operator as String and right as Any returns Optional[String]:
    Note: Evaluate a string binary operation
    If left is not String or right is not String:
        Return None
    
    Match operator:
        When "plus":
            Return left plus right
        When "equal":
            Return (left is equal to right) as String
        When "not_equal":
            Return (left is not equal to right) as String
        When "less_than":
            Return (left is less than right) as String
        When "less_equal":
            Return (left is less than or equal to right) as String
        When "greater_than":
            Return (left is greater than right) as String
        When "greater_equal":
            Return (left is greater than or equal to right) as String
        Otherwise:
            Return None

Process called "copy_mir_module" that takes module as MIRModule returns MIRModule:
    Note: Create a copy of a MIR module
    Let copied_functions be list containing
    For each function in module.functions:
        Let copied_function be copy_mir_function with function as function
        Add copied_function to copied_functions
    
    Return MIRModule with:
        name as module.name
        functions as copied_functions
        global_variables as module.global_variables

Process called "copy_mir_function" that takes function as MIRFunction returns MIRFunction:
    Note: Create a copy of a MIR function
    Let copied_basic_blocks be list containing
    For each basic_block in function.basic_blocks:
        Let copied_block be copy_mir_basic_block with basic_block as basic_block
        Add copied_block to copied_basic_blocks
    
    Return MIRFunction with:
        name as function.name
        parameters as function.parameters
        return_type as function.return_type
        basic_blocks as copied_basic_blocks
        entry_block as function.entry_block
        exit_blocks as function.exit_blocks
        local_variables as function.local_variables
        stack_frame_size as function.stack_frame_size
        metadata as function.metadata

Process called "copy_mir_basic_block" that takes basic_block as MIRBasicBlock returns MIRBasicBlock:
    Note: Create a copy of a MIR basic block
    Return MIRBasicBlock with:
        name as basic_block.name
        instructions as basic_block.instructions
        terminator as basic_block.terminator
        predecessors as basic_block.predecessors
        successors as basic_block.successors
        live_in as basic_block.live_in
        live_out as basic_block.live_out
        metadata as basic_block.metadata

Note: Constant Folding Pass Diagnostics
Process called "get_constant_folding_diagnostics" that takes folder as ConstantFoldingPass returns List[IRDiagnostic]:
    Note: Get diagnostics from constant folding pass
    Return folder.context.diagnostics

Process called "has_constant_folding_errors" that takes folder as ConstantFoldingPass returns Boolean:
    Note: Check if constant folding pass has errors
    Let diagnostics be get_constant_folding_diagnostics with folder as folder
    
    For each diagnostic in diagnostics:
        If diagnostic.severity is equal to "error":
            Return true
    
    Return false

Note: Constant Folding Statistics
Process called "get_constant_folding_statistics" that takes mir_module as MIRModule returns Dictionary[String, Any]:
    Note: Get constant folding statistics for a MIR module
    Let type_system be create_type_system
    Let folder be create_constant_folding_pass with context as create_ir_context with compilation_unit as "stats" and source_file as "unknown" and type_system as type_system
    
    Let optimization_result be optimize_mir_with_constant_folding with mir_module as mir_module and context as folder.context
    Let statistics be optimization_result.statistics
    
    Return dictionary containing:
        "folded_instructions" as statistics.folded_instructions
        "constant_values" as statistics.constant_values
        "function_count" as length of mir_module.functions
        "basic_block_count" as get_total_basic_block_count with mir_module as mir_module 