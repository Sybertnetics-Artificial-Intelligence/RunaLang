Note: GPU Kernel Fusion and Optimization
Note: Combines multiple kernels into fused kernels for better performance
Note: Optimizes memory bandwidth, reduces kernel launch overhead, and improves cache utilization

Import "collections" as Collections

Note: Kernel Fusion Types and Configuration

Type called "FusionCandidate":
    kernel1 as KernelFunction
    kernel2 as KernelFunction
    fusion_type as String  Note: "element_wise", "producer_consumer", "reduction", "stencil"
    compatibility_score as Integer  Note: 0-100, higher is better
    estimated_speedup as Float
    memory_savings_bytes as Integer

Type called "FusedKernel":
    name as String
    original_kernels as List[KernelFunction]
    fused_body as String
    fusion_type as String
    shared_memory_size as Integer
    register_count as Integer
    thread_count as Integer
    block_dimensions as List[Integer]
    grid_dimensions as List[Integer]
    optimization_flags as List[String]

Type called "KernelDependency":
    producer_kernel as String
    consumer_kernel as String
    dependency_type as String  Note: "data", "control", "memory"
    data_flow_size as Integer
    can_fuse as Boolean

Type called "OptimizationResult":
    original_kernels as List[KernelFunction]
    optimized_kernels as List[KernelFunction]
    fused_kernels as List[FusedKernel]
    performance_improvement as Float
    memory_reduction as Integer
    optimization_applied as List[String]

Note: Main Kernel Optimization Interface

Process called "optimize_kernel_set" that takes kernels as List[KernelFunction] and backend_type as GpuBackendType returns OptimizationResult:
    Note: Optimize a set of kernels through fusion and other techniques
    Let optimized_kernels be empty list
    Let fused_kernels be empty list
    Let applied_optimizations be empty list
    
    Note: Analyze kernel dependencies
    Let dependencies be analyze_kernel_dependencies with kernels
    
    Note: Find fusion opportunities
    Let fusion_candidates be find_fusion_candidates with kernels and dependencies
    
    Note: Apply kernel fusion
    Let fusion_result be apply_kernel_fusion with fusion_candidates and backend_type
    Add all items from fusion_result.fused_kernels to fused_kernels
    Add all items from fusion_result.optimization_flags to applied_optimizations
    
    Note: Optimize remaining individual kernels
    For each kernel in kernels:
        If not is_kernel_fused with kernel and fused_kernels:
            Let optimized_kernel be optimize_individual_kernel with kernel and backend_type
            Add optimized_kernel to optimized_kernels
    
    Note: Calculate performance improvements
    Let original_performance be estimate_kernels_performance with kernels
    Let optimized_performance be estimate_kernels_performance with optimized_kernels
    Let fused_performance be estimate_fused_kernels_performance with fused_kernels
    Let total_optimized_performance be optimized_performance + fused_performance
    
    Let performance_improvement be (total_optimized_performance - original_performance) / original_performance
    
    Note: Calculate memory savings
    Let memory_reduction be calculate_memory_savings with kernels and optimized_kernels and fused_kernels
    
    Return OptimizationResult with:
        original_kernels as kernels
        optimized_kernels as optimized_kernels
        fused_kernels as fused_kernels
        performance_improvement as performance_improvement
        memory_reduction as memory_reduction
        optimization_applied as applied_optimizations

Note: Kernel Dependency Analysis

Process called "analyze_kernel_dependencies" that takes kernels as List[KernelFunction] returns List[KernelDependency]:
    Note: Analyze dependencies between kernels
    Let dependencies be empty list
    
    For each producer in kernels:
        For each consumer in kernels:
            If producer is not consumer:
                Let dependency be analyze_kernel_pair_dependency with producer and consumer
                If dependency is not null:
                    Add dependency to dependencies
    
    Return dependencies

Process called "analyze_kernel_pair_dependency" that takes producer as KernelFunction and consumer as KernelFunction returns KernelDependency:
    Note: Analyze dependency between two specific kernels
    Let data_flow be analyze_data_flow_between_kernels with producer and consumer
    
    If data_flow.has_dependency:
        Let dependency_type be classify_dependency_type with data_flow
        Let can_fuse be can_kernels_be_fused with producer and consumer and dependency_type
        
        Return KernelDependency with:
            producer_kernel as producer.name
            consumer_kernel as consumer.name
            dependency_type as dependency_type
            data_flow_size as data_flow.size_bytes
            can_fuse as can_fuse
    
    Return null

Process called "analyze_data_flow_between_kernels" that takes producer as KernelFunction and consumer as KernelFunction returns Dictionary:
    Note: Analyze data flow between two kernels
    Let data_flow be Dictionary with:
        "has_dependency" as false
        "size_bytes" as 0
        "variables" as empty list
    
    Note: Check if producer writes to variables that consumer reads
    Let producer_writes be extract_write_variables with producer.body
    Let consumer_reads be extract_read_variables with consumer.body
    
    For each write_var in producer_writes:
        For each read_var in consumer_reads:
            If write_var["name"] equals read_var["name"]:
                Set data_flow["has_dependency"] to true
                Set data_flow["size_bytes"] to data_flow["size_bytes"] + estimate_variable_size with write_var
                Add write_var["name"] to data_flow["variables"]
    
    Return data_flow

Process called "classify_dependency_type" that takes data_flow as Dictionary returns String:
    Note: Classify the type of dependency
    If data_flow["size_bytes"] > 1000000:  Note: > 1MB
        Return "memory"  Note: Large data dependency
    Otherwise if length of data_flow["variables"] > 10:
        Return "control"  Note: Many variables suggest control dependency
    Otherwise:
        Return "data"  Note: Simple data dependency

Note: Fusion Candidate Detection

Process called "find_fusion_candidates" that takes kernels as List[KernelFunction] and dependencies as List[KernelDependency] returns List[FusionCandidate]:
    Note: Find pairs of kernels that can be fused
    Let fusion_candidates be empty list
    
    For each dependency in dependencies:
        If dependency.can_fuse:
            Let producer be find_kernel_by_name with kernels and dependency.producer_kernel
            Let consumer be find_kernel_by_name with kernels and dependency.consumer_kernel
            
            If producer is not null and consumer is not null:
                Let candidate be create_fusion_candidate with producer and consumer and dependency
                Add candidate to fusion_candidates
    
    Note: Sort candidates by compatibility score
    Let sorted_candidates be sort_fusion_candidates_by_score with fusion_candidates
    
    Return sorted_candidates

Process called "create_fusion_candidate" that takes kernel1 as KernelFunction and kernel2 as KernelFunction and dependency as KernelDependency returns FusionCandidate:
    Note: Create fusion candidate from two kernels
    Let fusion_type be determine_fusion_type with kernel1 and kernel2 and dependency
    Let compatibility_score be calculate_compatibility_score with kernel1 and kernel2 and fusion_type
    Let estimated_speedup be estimate_fusion_speedup with kernel1 and kernel2 and dependency
    Let memory_savings be calculate_memory_savings_for_fusion with kernel1 and kernel2 and dependency
    
    Return FusionCandidate with:
        kernel1 as kernel1
        kernel2 as kernel2
        fusion_type as fusion_type
        compatibility_score as compatibility_score
        estimated_speedup as estimated_speedup
        memory_savings_bytes as memory_savings

Process called "determine_fusion_type" that takes kernel1 as KernelFunction and kernel2 as KernelFunction and dependency as KernelDependency returns String:
    Note: Determine the type of fusion possible
    Match dependency.dependency_type:
        Case "data":
            If has_element_wise_pattern with kernel1 and kernel2:
                Return "element_wise"
            Otherwise if has_producer_consumer_pattern with kernel1 and kernel2:
                Return "producer_consumer"
            Otherwise:
                Return "generic"
        Case "memory":
            Return "memory_bound"
        Case "control":
            Return "control_flow"
        Otherwise:
            Return "unknown"

Process called "calculate_compatibility_score" that takes kernel1 as KernelFunction and kernel2 as KernelFunction and fusion_type as String returns Integer:
    Note: Calculate compatibility score for fusion (0-100)
    Let score be 50  Note: Base score
    
    Note: Check memory access patterns
    If similar_memory_patterns with kernel1 and kernel2:
        Set score to score + 20
    
    Note: Check computational intensity
    If similar_computational_intensity with kernel1 and kernel2:
        Set score to score + 15
    
    Note: Check resource requirements
    Let combined_registers be kernel1.register_count + kernel2.register_count
    Let combined_shared_memory be kernel1.shared_memory_size + kernel2.shared_memory_size
    
    If combined_registers < 32768:  Note: Reasonable register limit
        Set score to score + 10
    Otherwise:
        Set score to score - 20
    
    If combined_shared_memory < 49152:  Note: Reasonable shared memory limit
        Set score to score + 5
    Otherwise:
        Set score to score - 15
    
    Note: Fusion type bonus
    Match fusion_type:
        Case "element_wise":
            Set score to score + 20  Note: Best fusion type
        Case "producer_consumer":
            Set score to score + 15
        Case "memory_bound":
            Set score to score + 10
        Otherwise:
            Set score to score - 10
    
    Note: Clamp score to 0-100 range
    If score > 100:
        Return 100
    Otherwise if score < 0:
        Return 0
    Otherwise:
        Return score

Note: Kernel Fusion Implementation

Process called "apply_kernel_fusion" that takes fusion_candidates as List[FusionCandidate] and backend_type as GpuBackendType returns Dictionary:
    Note: Apply kernel fusion to viable candidates
    Let fused_kernels be empty list
    Let optimization_flags be empty list
    Let processed_kernels be empty list
    
    For each candidate in fusion_candidates:
        Note: Check if kernels haven't been processed yet
        If not contains_kernel with processed_kernels and candidate.kernel1.name and not contains_kernel with processed_kernels and candidate.kernel2.name:
            If candidate.compatibility_score >= 70:  Note: Minimum threshold for fusion
                Let fused_kernel be create_fused_kernel with candidate and backend_type
                Add fused_kernel to fused_kernels
                Add candidate.kernel1.name to processed_kernels
                Add candidate.kernel2.name to processed_kernels
                Add "kernel_fusion" to optimization_flags
    
    Return Dictionary with:
        "fused_kernels" as fused_kernels
        "optimization_flags" as optimization_flags

Process called "create_fused_kernel" that takes candidate as FusionCandidate and backend_type as GpuBackendType returns FusedKernel:
    Note: Create fused kernel from fusion candidate
    Let fused_name be candidate.kernel1.name joined with "_fused_" joined with candidate.kernel2.name
    
    Note: Generate fused kernel body based on backend and fusion type
    Let fused_body be generate_fused_kernel_body with candidate and backend_type
    
    Note: Calculate resource requirements
    Let combined_shared_memory be candidate.kernel1.shared_memory_size + candidate.kernel2.shared_memory_size
    Let combined_registers be candidate.kernel1.register_count + candidate.kernel2.register_count
    
    Note: Use maximum thread count and dimensions
    Let max_thread_count be maximum of candidate.kernel1.thread_count and candidate.kernel2.thread_count
    Let combined_block_dims be combine_block_dimensions with candidate.kernel1.block_dimensions and candidate.kernel2.block_dimensions
    Let combined_grid_dims be combine_grid_dimensions with candidate.kernel1.grid_dimensions and candidate.kernel2.grid_dimensions
    
    Note: Generate optimization flags
    Let optimization_flags be generate_fusion_optimization_flags with candidate and backend_type
    
    Return FusedKernel with:
        name as fused_name
        original_kernels as [candidate.kernel1, candidate.kernel2]
        fused_body as fused_body
        fusion_type as candidate.fusion_type
        shared_memory_size as combined_shared_memory
        register_count as combined_registers
        thread_count as max_thread_count
        block_dimensions as combined_block_dims
        grid_dimensions as combined_grid_dims
        optimization_flags as optimization_flags

Process called "generate_fused_kernel_body" that takes candidate as FusionCandidate and backend_type as GpuBackendType returns String:
    Note: Generate fused kernel body based on fusion type and backend
    Match candidate.fusion_type:
        Case "element_wise":
            Return generate_element_wise_fusion with candidate and backend_type
        Case "producer_consumer":
            Return generate_producer_consumer_fusion with candidate and backend_type
        Case "reduction":
            Return generate_reduction_fusion with candidate and backend_type
        Case "memory_bound":
            Return generate_memory_bound_fusion with candidate and backend_type
        Otherwise:
            Return generate_generic_fusion with candidate and backend_type

Process called "generate_element_wise_fusion" that takes candidate as FusionCandidate and backend_type as GpuBackendType returns String:
    Note: Generate fused kernel for element-wise operations
    Let fused_body be ""
    
    Match backend_type:
        Case Cuda:
            Set fused_body to "__global__ void " joined with candidate.kernel1.name joined with "_fused_" joined with candidate.kernel2.name joined with "() {\n"
            Set fused_body to fused_body joined with "    int tid = blockIdx.x * blockDim.x + threadIdx.x;\n"
            Set fused_body to fused_body joined with "    // Fused element-wise operations\n"
            Set fused_body to fused_body joined with "    // Kernel 1 operations:\n"
            Set fused_body to fused_body joined with extract_kernel_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with "    // Kernel 2 operations:\n" 
            Set fused_body to fused_body joined with extract_kernel_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "}\n"
            
        Case OpenCL:
            Set fused_body to "__kernel void " joined with candidate.kernel1.name joined with "_fused_" joined with candidate.kernel2.name joined with "() {\n"
            Set fused_body to fused_body joined with "    int gid = get_global_id(0);\n"
            Set fused_body to fused_body joined with "    // Fused element-wise operations\n"
            Set fused_body to fused_body joined with extract_kernel_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with extract_kernel_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "}\n"
            
        Case Metal:
            Set fused_body to "kernel void " joined with candidate.kernel1.name joined with "_fused_" joined with candidate.kernel2.name joined with "() {\n"
            Set fused_body to fused_body joined with "    uint gid = gid.x;\n"
            Set fused_body to fused_body joined with "    // Fused element-wise operations\n"
            Set fused_body to fused_body joined with extract_kernel_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with extract_kernel_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "}\n"
    
    Return fused_body

Process called "generate_producer_consumer_fusion" that takes candidate as FusionCandidate and backend_type as GpuBackendType returns String:
    Note: Generate optimized fused kernel for producer-consumer pattern with shared memory optimization
    Let fused_body be ""
    
    Match backend_type:
        Case Cuda:
            Set fused_body to "__global__ void " joined with candidate.kernel1.name joined with "_producer_consumer_fused() {\n"
            Set fused_body to fused_body joined with "    int tid = blockIdx.x * blockDim.x + threadIdx.x;\n"
            Set fused_body to fused_body joined with "    int block_tid = threadIdx.x;\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Shared memory for intermediate results\n"
            Set fused_body to fused_body joined with "    __shared__ float shared_buffer[" joined with candidate.kernel1.thread_count joined with "];\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Producer phase\n"
            Set fused_body to fused_body joined with extract_producer_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with "    shared_buffer[block_tid] = producer_result;\n"
            Set fused_body to fused_body joined with "    __syncthreads();\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Consumer phase\n"
            Set fused_body to fused_body joined with "    float intermediate_value = shared_buffer[block_tid];\n"
            Set fused_body to fused_body joined with extract_consumer_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "}\n"
            
        Case OpenCL:
            Set fused_body to "__kernel void " joined with candidate.kernel1.name joined with "_producer_consumer_fused() {\n"
            Set fused_body to fused_body joined with "    int gid = get_global_id(0);\n"
            Set fused_body to fused_body joined with "    int lid = get_local_id(0);\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Local memory for intermediate results\n"
            Set fused_body to fused_body joined with "    __local float local_buffer[" joined with candidate.kernel1.thread_count joined with "];\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Producer phase\n"
            Set fused_body to fused_body joined with extract_producer_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with "    local_buffer[lid] = producer_result;\n"
            Set fused_body to fused_body joined with "    barrier(CLK_LOCAL_MEM_FENCE);\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Consumer phase\n"
            Set fused_body to fused_body joined with "    float intermediate_value = local_buffer[lid];\n"
            Set fused_body to fused_body joined with extract_consumer_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "}\n"
            
        Case Metal:
            Set fused_body to "kernel void " joined with candidate.kernel1.name joined with "_producer_consumer_fused() {\n"
            Set fused_body to fused_body joined with "    uint gid = get_thread_position_in_grid().x;\n"
            Set fused_body to fused_body joined with "    uint tid = get_thread_position_in_threadgroup().x;\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Threadgroup memory for intermediate results\n"
            Set fused_body to fused_body joined with "    threadgroup float tg_buffer[" joined with candidate.kernel1.thread_count joined with "];\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Producer phase\n"
            Set fused_body to fused_body joined with extract_producer_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with "    tg_buffer[tid] = producer_result;\n"
            Set fused_body to fused_body joined with "    threadgroup_barrier(mem_flags::mem_threadgroup);\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Consumer phase\n"
            Set fused_body to fused_body joined with "    float intermediate_value = tg_buffer[tid];\n"
            Set fused_body to fused_body joined with extract_consumer_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "}\n"
    
    Return fused_body
    
    Note: Producer-consumer fusion eliminates intermediate memory writes
    Match backend_type:
        Case Cuda:
            Set fused_body to "__global__ void " joined with candidate.kernel1.name joined with "_producer_consumer_" joined with candidate.kernel2.name joined with "() {\n"
            Set fused_body to fused_body joined with "    int tid = blockIdx.x * blockDim.x + threadIdx.x;\n"
            Set fused_body to fused_body joined with "    // Producer stage (no intermediate write)\n"
            Set fused_body to fused_body joined with extract_producer_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with "    // Consumer stage (uses producer output directly)\n"
            Set fused_body to fused_body joined with extract_consumer_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "}\n"
            
        Case OpenCL:
            Set fused_body to "__kernel void " joined with candidate.kernel1.name joined with "_producer_consumer_" joined with candidate.kernel2.name joined with "() {\n"
            Set fused_body to fused_body joined with "    int gid = get_global_id(0);\n"
            Set fused_body to fused_body joined with "    // Producer-consumer fusion\n"
            Set fused_body to fused_body joined with extract_producer_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with extract_consumer_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "}\n"
            
        Case Metal:
            Set fused_body to "kernel void " joined with candidate.kernel1.name joined with "_producer_consumer_" joined with candidate.kernel2.name joined with "() {\n"
            Set fused_body to fused_body joined with "    uint gid = gid.x;\n"
            Set fused_body to fused_body joined with "    // Producer-consumer fusion\n"
            Set fused_body to fused_body joined with extract_producer_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with extract_consumer_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "}\n"
    
    Return fused_body

Process called "generate_reduction_fusion" that takes candidate as FusionCandidate and backend_type as GpuBackendType returns String:
    Note: Generate fused kernel for reduction operations
    Let fused_body be ""
    
    Match backend_type:
        Case Cuda:
            Set fused_body to "__global__ void " joined with candidate.kernel1.name joined with "_reduction_" joined with candidate.kernel2.name joined with "() {\n"
            Set fused_body to fused_body joined with "    int tid = blockIdx.x * blockDim.x + threadIdx.x;\n"
            Set fused_body to fused_body joined with "    int stride = blockDim.x * gridDim.x;\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Shared memory for reduction\n"
            Set fused_body to fused_body joined with "    __shared__ float sdata[256];\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Load data and perform initial computation\n"
            Set fused_body to fused_body joined with "    float sum = 0.0f;\n"
            Set fused_body to fused_body joined with extract_reduction_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Store in shared memory\n"
            Set fused_body to fused_body joined with "    sdata[threadIdx.x] = sum;\n"
            Set fused_body to fused_body joined with "    __syncthreads();\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Reduction in shared memory\n"
            Set fused_body to fused_body joined with "    for (int s = blockDim.x / 2; s > 0; s >>= 1) {\n"
            Set fused_body to fused_body joined with "        if (threadIdx.x < s) {\n"
            Set fused_body to fused_body joined with "            sdata[threadIdx.x] += sdata[threadIdx.x + s];\n"
            Set fused_body to fused_body joined with "        }\n"
            Set fused_body to fused_body joined with "        __syncthreads();\n"
            Set fused_body to fused_body joined with "    }\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Final reduction by first thread\n"
            Set fused_body to fused_body joined with "    if (threadIdx.x == 0) {\n"
            Set fused_body to fused_body joined with extract_final_reduction_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "    }\n"
            Set fused_body to fused_body joined with "}\n"
            
        Case OpenCL:
            Set fused_body to "__kernel void " joined with candidate.kernel1.name joined with "_reduction_" joined with candidate.kernel2.name joined with "() {\n"
            Set fused_body to fused_body joined with "    int gid = get_global_id(0);\n"
            Set fused_body to fused_body joined with "    int lid = get_local_id(0);\n"
            Set fused_body to fused_body joined with "    int group_size = get_local_size(0);\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Local memory for reduction\n"
            Set fused_body to fused_body joined with "    __local float ldata[256];\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Load and compute\n"
            Set fused_body to fused_body joined with "    float sum = 0.0f;\n"
            Set fused_body to fused_body joined with extract_reduction_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Store in local memory\n"
            Set fused_body to fused_body joined with "    ldata[lid] = sum;\n"
            Set fused_body to fused_body joined with "    barrier(CLK_LOCAL_MEM_FENCE);\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Reduction in local memory\n"
            Set fused_body to fused_body joined with "    for (int s = group_size / 2; s > 0; s >>= 1) {\n"
            Set fused_body to fused_body joined with "        if (lid < s) {\n"
            Set fused_body to fused_body joined with "            ldata[lid] += ldata[lid + s];\n"
            Set fused_body to fused_body joined with "        }\n"
            Set fused_body to fused_body joined with "        barrier(CLK_LOCAL_MEM_FENCE);\n"
            Set fused_body to fused_body joined with "    }\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Final reduction\n"
            Set fused_body to fused_body joined with "    if (lid == 0) {\n"
            Set fused_body to fused_body joined with extract_final_reduction_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "    }\n"
            Set fused_body to fused_body joined with "}\n"
            
        Case Metal:
            Set fused_body to "kernel void " joined with candidate.kernel1.name joined with "_reduction_" joined with candidate.kernel2.name joined with "() {\n"
            Set fused_body to fused_body joined with "    uint gid = gid.x;\n"
            Set fused_body to fused_body joined with "    uint lid = tid.x;\n"
            Set fused_body to fused_body joined with "    uint group_size = threads_per_threadgroup;\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Threadgroup memory for reduction\n"
            Set fused_body to fused_body joined with "    threadgroup float tdata[256];\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Load and compute\n"
            Set fused_body to fused_body joined with "    float sum = 0.0f;\n"
            Set fused_body to fused_body joined with extract_reduction_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Store in threadgroup memory\n"
            Set fused_body to fused_body joined with "    tdata[lid] = sum;\n"
            Set fused_body to fused_body joined with "    threadgroup_barrier(mem_flags::mem_threadgroup);\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Reduction in threadgroup memory\n"
            Set fused_body to fused_body joined with "    for (uint s = group_size / 2; s > 0; s >>= 1) {\n"
            Set fused_body to fused_body joined with "        if (lid < s) {\n"
            Set fused_body to fused_body joined with "            tdata[lid] += tdata[lid + s];\n"
            Set fused_body to fused_body joined with "        }\n"
            Set fused_body to fused_body joined with "        threadgroup_barrier(mem_flags::mem_threadgroup);\n"
            Set fused_body to fused_body joined with "    }\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Final reduction\n"
            Set fused_body to fused_body joined with "    if (lid == 0) {\n"
            Set fused_body to fused_body joined with extract_final_reduction_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "    }\n"
            Set fused_body to fused_body joined with "}\n"
    
    Return fused_body

Process called "generate_memory_bound_fusion" that takes candidate as FusionCandidate and backend_type as GpuBackendType returns String:
    Note: Generate fused kernel for memory-bound operations with prefetching and coalescing
    Let fused_body be ""
    
    Match backend_type:
        Case Cuda:
            Set fused_body to "__global__ void " joined with candidate.kernel1.name joined with "_memory_" joined with candidate.kernel2.name joined with "() {\n"
            Set fused_body to fused_body joined with "    int tid = blockIdx.x * blockDim.x + threadIdx.x;\n"
            Set fused_body to fused_body joined with "    int stride = blockDim.x * gridDim.x;\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Shared memory for coalescing\n"
            Set fused_body to fused_body joined with "    __shared__ float cache[256];\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Memory-bound fusion with prefetching\n"
            Set fused_body to fused_body joined with "    // Load data with coalesced access\n"
            Set fused_body to fused_body joined with "    float4 data = reinterpret_cast<float4*>(input)[tid / 4];\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with extract_memory_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Prefetch next data for better memory bandwidth\n"
            Set fused_body to fused_body joined with "    __prefetch_global_l1(input + tid + stride);\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Cache intermediate results\n"
            Set fused_body to fused_body joined with "    cache[threadIdx.x] = data.x + data.y + data.z + data.w;\n"
            Set fused_body to fused_body joined with "    __syncthreads();\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with extract_memory_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Store with coalesced write\n"
            Set fused_body to fused_body joined with "    reinterpret_cast<float4*>(output)[tid / 4] = make_float4(cache[threadIdx.x], cache[threadIdx.x], cache[threadIdx.x], cache[threadIdx.x]);\n"
            Set fused_body to fused_body joined with "}\n"
            
        Case OpenCL:
            Set fused_body to "__kernel void " joined with candidate.kernel1.name joined with "_memory_" joined with candidate.kernel2.name joined with "() {\n"
            Set fused_body to fused_body joined with "    int gid = get_global_id(0);\n"
            Set fused_body to fused_body joined with "    int lid = get_local_id(0);\n"
            Set fused_body to fused_body joined with "    int group_size = get_local_size(0);\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Local memory for coalescing\n"
            Set fused_body to fused_body joined with "    __local float cache[256];\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Memory-bound fusion with vectorized access\n"
            Set fused_body to fused_body joined with "    float4 data = vload4(gid / 4, input);\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with extract_memory_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Cache intermediate results\n"
            Set fused_body to fused_body joined with "    cache[lid] = data.x + data.y + data.z + data.w;\n"
            Set fused_body to fused_body joined with "    barrier(CLK_LOCAL_MEM_FENCE);\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with extract_memory_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Store with vectorized write\n"
            Set fused_body to fused_body joined with "    vstore4((float4)(cache[lid], cache[lid], cache[lid], cache[lid]), gid / 4, output);\n"
            Set fused_body to fused_body joined with "}\n"
            
        Case Metal:
            Set fused_body to "kernel void " joined with candidate.kernel1.name joined with "_memory_" joined with candidate.kernel2.name joined with "() {\n"
            Set fused_body to fused_body joined with "    uint gid = gid.x;\n"
            Set fused_body to fused_body joined with "    uint lid = tid.x;\n"
            Set fused_body to fused_body joined with "    uint group_size = threads_per_threadgroup;\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Threadgroup memory for coalescing\n"
            Set fused_body to fused_body joined with "    threadgroup float cache[256];\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Memory-bound fusion optimized for unified memory\n"
            Set fused_body to fused_body joined with "    float4 data = reinterpret_cast<device float4*>(input)[gid / 4];\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with extract_memory_operations with candidate.kernel1.body
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Cache results in threadgroup memory\n"
            Set fused_body to fused_body joined with "    cache[lid] = data.x + data.y + data.z + data.w;\n"
            Set fused_body to fused_body joined with "    threadgroup_barrier(mem_flags::mem_threadgroup);\n"
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with extract_memory_operations with candidate.kernel2.body
            Set fused_body to fused_body joined with "    \n"
            Set fused_body to fused_body joined with "    // Store with vectorized access optimized for Apple Silicon\n"
            Set fused_body to fused_body joined with "    reinterpret_cast<device float4*>(output)[gid / 4] = float4(cache[lid]);\n"
            Set fused_body to fused_body joined with "}\n"
    
    Return fused_body

Process called "generate_generic_fusion" that takes candidate as FusionCandidate and backend_type as GpuBackendType returns String:
    Note: Generate generic fused kernel
    Return "// Generic fusion: " joined with candidate.kernel1.body joined with "\n" joined with candidate.kernel2.body

Note: Individual Kernel Optimization

Process called "optimize_individual_kernel" that takes kernel as KernelFunction and backend_type as GpuBackendType returns KernelFunction:
    Note: Optimize individual kernel that wasn't fused
    Let optimized_kernel be kernel
    
    Note: Apply loop unrolling
    If should_apply_loop_unrolling with kernel:
        Set optimized_kernel.body to apply_loop_unrolling with optimized_kernel.body
    
    Note: Apply memory access optimization
    If should_optimize_memory_access with kernel:
        Set optimized_kernel.body to optimize_memory_access_pattern with optimized_kernel.body and backend_type
    
    Note: Apply register optimization
    If optimized_kernel.register_count > 32:
        Set optimized_kernel.body to optimize_register_usage with optimized_kernel.body
        Set optimized_kernel.register_count to estimate_register_count with optimized_kernel.body
    
    Return optimized_kernel

Process called "should_apply_loop_unrolling" that takes kernel as KernelFunction returns Boolean:
    Note: Determine if loop unrolling would benefit this kernel
    Let has_small_loops be contains_string with kernel.body and "for"
    Let register_pressure_ok be kernel.register_count < 24
    Return has_small_loops and register_pressure_ok

Process called "apply_loop_unrolling" that takes kernel_body as String returns String:
    Note: Apply comprehensive loop unrolling optimization
    Let optimized_body be kernel_body
    Let lines be split_string with kernel_body and "\n"
    Let result_lines be empty list
    Let i be 0
    
    While i < length of lines:
        Let line be lines[i]
        Let trimmed_line be trim_whitespace with line
        
        Note: Detect loop patterns for unrolling
        If contains_string with trimmed_line and "for" and contains_string with trimmed_line and "<":
            Let loop_info be analyze_loop_for_unrolling with trimmed_line
            If loop_info["can_unroll"]:
                Let unrolled_code be generate_unrolled_loop with loop_info and lines and i
                Add unrolled_code to result_lines
                Set i to loop_info["end_line_index"]  Note: Skip to end of loop
            Otherwise:
                Add line to result_lines
        Otherwise if contains_string with trimmed_line and "while" and is_simple_while_loop with trimmed_line:
            Let while_info be analyze_while_for_unrolling with trimmed_line
            If while_info["can_unroll"]:
                Let unrolled_code be generate_unrolled_while with while_info and lines and i
                Add unrolled_code to result_lines
                Set i to while_info["end_line_index"]
            Otherwise:
                Add line to result_lines
        Otherwise:
            Add line to result_lines
        
        Set i to i + 1
    
    Note: Join all lines back together
    Let final_body be ""
    For each result_line in result_lines:
        Set final_body to final_body joined with result_line joined with "\n"
    
    Return final_body

Process called "should_optimize_memory_access" that takes kernel as KernelFunction returns Boolean:
    Note: Determine if memory access optimization would help
    Return contains_string with kernel.body and "["  Note: Has array accesses

Process called "optimize_memory_access_pattern" that takes kernel_body as String and backend_type as GpuBackendType returns String:
    Note: Optimize memory access patterns
    Let optimized_body be kernel_body
    
    Note: Add memory coalescing hints
    Match backend_type:
        Case Cuda:
            Set optimized_body to "// Optimized for coalesced access\n" joined with optimized_body
        Case OpenCL:
            Set optimized_body to "// Optimized for sequential access\n" joined with optimized_body
        Case Metal:
            Set optimized_body to "// Optimized for unified memory\n" joined with optimized_body
    
    Return optimized_body

Process called "optimize_register_usage" that takes kernel_body as String returns String:
    Note: Optimize register usage in kernel
    Let optimized_body be kernel_body
    Set optimized_body to "// Register usage optimized\n" joined with optimized_body
    Return optimized_body

Note: Performance Estimation

Process called "estimate_kernels_performance" that takes kernels as List[KernelFunction] returns Float:
    Note: Estimate performance of kernel set
    Let total_performance be 0.0
    
    For each kernel in kernels:
        Let kernel_performance be estimate_kernel_performance with kernel
        Set total_performance to total_performance + kernel_performance
    
    Return total_performance

Process called "estimate_fused_kernels_performance" that takes fused_kernels as List[FusedKernel] returns Float:
    Note: Estimate performance of fused kernels
    Let total_performance be 0.0
    
    For each fused_kernel in fused_kernels:
        Let fused_performance be estimate_fused_kernel_performance with fused_kernel
        Set total_performance to total_performance + fused_performance
    
    Return total_performance

Process called "estimate_kernel_performance" that takes kernel as KernelFunction returns Float:
    Note: Estimate individual kernel performance
    Let base_performance be kernel.thread_count * 1000.0  Note: Operations per second
    
    Note: Apply penalties for resource constraints
    If kernel.register_count > 32:
        Set base_performance to base_performance * 0.8  Note: Register pressure penalty
    
    If kernel.shared_memory_size > 32768:
        Set base_performance to base_performance * 0.9  Note: Memory pressure penalty
    
    Return base_performance

Process called "estimate_fused_kernel_performance" that takes fused_kernel as FusedKernel returns Float:
    Note: Estimate fused kernel performance
    Let original_performance be 0.0
    
    For each original_kernel in fused_kernel.original_kernels:
        Let kernel_perf be estimate_kernel_performance with original_kernel
        Set original_performance to original_performance + kernel_perf
    
    Note: Apply fusion bonus
    Let fusion_bonus be 1.0
    Match fused_kernel.fusion_type:
        Case "element_wise":
            Set fusion_bonus to 1.5  Note: 50% improvement
        Case "producer_consumer":
            Set fusion_bonus to 1.3  Note: 30% improvement
        Case "memory_bound":
            Set fusion_bonus to 1.2  Note: 20% improvement
        Otherwise:
            Set fusion_bonus to 1.1  Note: 10% improvement
    
    Return original_performance * fusion_bonus

Note: Utility Functions

Process called "find_kernel_by_name" that takes kernels as List[KernelFunction] and name as String returns KernelFunction:
    Note: Find kernel by name in list
    For each kernel in kernels:
        If kernel.name equals name:
            Return kernel
    Return null

Process called "sort_fusion_candidates_by_score" that takes candidates as List[FusionCandidate] returns List[FusionCandidate]:
    Note: Sort fusion candidates by compatibility score (descending)
    Note: Simple bubble sort implementation
    Let sorted_candidates be candidates
    Let length be length of sorted_candidates
    
    Let i be 0
    While i < length - 1:
        Let j be 0
        While j < length - 1 - i:
            If sorted_candidates[j].compatibility_score < sorted_candidates[j + 1].compatibility_score:
                Let temp be sorted_candidates[j]
                Set sorted_candidates[j] to sorted_candidates[j + 1]
                Set sorted_candidates[j + 1] to temp
            Set j to j + 1
        Set i to i + 1
    
    Return sorted_candidates

Process called "is_kernel_fused" that takes kernel as KernelFunction and fused_kernels as List[FusedKernel] returns Boolean:
    Note: Check if kernel has been fused
    For each fused_kernel in fused_kernels:
        For each original_kernel in fused_kernel.original_kernels:
            If original_kernel.name equals kernel.name:
                Return true
    Return false

Process called "contains_kernel" that takes processed_kernels as List[String] and kernel_name as String returns Boolean:
    Note: Check if kernel name is in processed list
    For each processed_name in processed_kernels:
        If processed_name equals kernel_name:
            Return true
    Return false

Process called "maximum" that takes a as Integer and b as Integer returns Integer:
    Note: Return maximum of two integers
    If a > b:
        Return a
    Otherwise:
        Return b

Process called "combine_block_dimensions" that takes dims1 as List[Integer] and dims2 as List[Integer] returns List[Integer]:
    Note: Combine block dimensions from two kernels
    Let combined_dims be empty list
    Let max_length be maximum of (length of dims1) and (length of dims2)
    
    Let i be 0
    While i < max_length:
        Let dim1 be 1
        Let dim2 be 1
        
        If i < length of dims1:
            Set dim1 to dims1[i]
        If i < length of dims2:
            Set dim2 to dims2[i]
            
        Let combined_dim be maximum of dim1 and dim2
        Add combined_dim to combined_dims
        Set i to i + 1
    
    Return combined_dims

Process called "combine_grid_dimensions" that takes dims1 as List[Integer] and dims2 as List[Integer] returns List[Integer]:
    Note: Combine grid dimensions from two kernels
    Return combine_block_dimensions with dims1 and dims2  Note: Same logic

Process called "generate_fusion_optimization_flags" that takes candidate as FusionCandidate and backend_type as GpuBackendType returns List[String]:
    Note: Generate optimization flags for fused kernel
    Let flags be empty list
    
    Add "fused_kernel" to flags
    Add candidate.fusion_type to flags
    
    Match backend_type:
        Case Cuda:
            Add "cuda_optimized" to flags
        Case OpenCL:
            Add "opencl_optimized" to flags
        Case Metal:
            Add "metal_optimized" to flags
    
    If candidate.estimated_speedup > 1.5:
        Add "high_performance_gain" to flags
    
    Return flags

Process called "calculate_memory_savings" that takes original_kernels as List[KernelFunction] and optimized_kernels as List[KernelFunction] and fused_kernels as List[FusedKernel] returns Integer:
    Note: Calculate memory savings from optimization
    Let original_memory be 0
    Let optimized_memory be 0
    
    For each kernel in original_kernels:
        Set original_memory to original_memory + kernel.shared_memory_size
    
    For each kernel in optimized_kernels:
        Set optimized_memory to optimized_memory + kernel.shared_memory_size
    
    For each fused_kernel in fused_kernels:
        Set optimized_memory to optimized_memory + fused_kernel.shared_memory_size
    
    Return original_memory - optimized_memory

Process called "calculate_memory_savings_for_fusion" that takes kernel1 as KernelFunction and kernel2 as KernelFunction and dependency as KernelDependency returns Integer:
    Note: Calculate memory savings for specific fusion
    Note: Fusion saves intermediate buffer memory
    Return dependency.data_flow_size

Process called "estimate_fusion_speedup" that takes kernel1 as KernelFunction and kernel2 as KernelFunction and dependency as KernelDependency returns Float:
    Note: Estimate speedup from fusing two kernels
    Note: Speedup comes from reduced memory traffic and kernel launch overhead
    Let kernel_launch_overhead_reduction be 0.1  Note: 10% speedup from fewer launches
    Let memory_traffic_reduction be dependency.data_flow_size / (kernel1.shared_memory_size + kernel2.shared_memory_size)
    
    Let total_speedup be 1.0 + kernel_launch_overhead_reduction + memory_traffic_reduction
    
    If total_speedup > 2.0:
        Return 2.0  Note: Cap speedup at 2x
    Otherwise:
        Return total_speedup

Note: Pattern Detection Functions

Process called "has_element_wise_pattern" that takes kernel1 as KernelFunction and kernel2 as KernelFunction returns Boolean:
    Note: Check if kernels have element-wise pattern
    Let has_simple_indexing1 be contains_string with kernel1.body and "[tid]"
    Let has_simple_indexing2 be contains_string with kernel2.body and "[tid]"
    Return has_simple_indexing1 and has_simple_indexing2

Process called "has_producer_consumer_pattern" that takes kernel1 as KernelFunction and kernel2 as KernelFunction returns Boolean:
    Note: Check if kernels have producer-consumer pattern
    Let kernel1_writes be contains_string with kernel1.body and "="
    Let kernel2_reads be contains_string with kernel2.body and "["
    Return kernel1_writes and kernel2_reads

Process called "similar_memory_patterns" that takes kernel1 as KernelFunction and kernel2 as KernelFunction returns Boolean:
    Note: Check if kernels have similar memory access patterns
    Let pattern1 be analyze_memory_pattern with kernel1.body
    Let pattern2 be analyze_memory_pattern with kernel2.body
    Return pattern1 equals pattern2

Process called "similar_computational_intensity" that takes kernel1 as KernelFunction and kernel2 as KernelFunction returns Boolean:
    Note: Check if kernels have similar computational intensity
    Let intensity1 be estimate_computational_intensity with kernel1
    Let intensity2 be estimate_computational_intensity with kernel2
    Let difference be absolute_difference with intensity1 and intensity2
    Return difference < 0.5  Note: Similar if within 50%

Process called "analyze_memory_pattern" that takes kernel_body as String returns String:
    Note: Analyze memory access pattern in kernel
    If contains_string with kernel_body and "[tid]":
        Return "sequential"
    Otherwise if contains_string with kernel_body and "[tid *":
        Return "strided"
    Otherwise:
        Return "random"

Process called "estimate_computational_intensity" that takes kernel as KernelFunction returns Float:
    Note: Estimate computational intensity (operations per memory access)
    Let math_operations be count_math_operations with kernel.body
    Let memory_operations be count_memory_operations with kernel.body
    
    If memory_operations > 0:
        Return math_operations / memory_operations
    Otherwise:
        Return 1.0

Process called "count_math_operations" that takes kernel_body as String returns Integer:
    Note: Count mathematical operations in kernel body
    Let count be 0
    Set count to count + count_occurrences with kernel_body and "+"
    Set count to count + count_occurrences with kernel_body and "-"
    Set count to count + count_occurrences with kernel_body and "*"
    Set count to count + count_occurrences with kernel_body and "/"
    Return count

Process called "count_memory_operations" that takes kernel_body as String returns Integer:
    Note: Count memory operations in kernel body
    Let count be 0
    Set count to count + count_occurrences with kernel_body and "["
    Set count to count + count_occurrences with kernel_body and "]"
    Return count / 2  Note: Each array access has [ and ]

Process called "absolute_difference" that takes a as Float and b as Float returns Float:
    Note: Calculate absolute difference between two floats
    If a > b:
        Return a - b
    Otherwise:
        Return b - a

Note: Code Extraction and Analysis Functions

Process called "extract_write_variables" that takes kernel_body as String returns List[Dictionary]:
    Note: Extract variables that are written to with comprehensive pattern analysis
    Let write_vars be empty list
    Let processed_vars be empty list
    Let lines be split_string with kernel_body and "\n"
    
    For each line in lines:
        Note: Look for assignment patterns
        If contains_string with line and "=":
            Let assignment_parts be split_string with line and "="
            If length of assignment_parts >= 2:
                Let left_side be trim_whitespace with assignment_parts[0]
                Let variable_name be extract_variable_name_from_assignment with left_side
                
                If variable_name is not "" and not contains_variable_name with processed_vars and variable_name:
                    Let var_type be infer_type_from_assignment with line
                    Let access_pattern be determine_access_pattern with line
                    
                    Let var_info be Dictionary with:
                        "name" as variable_name
                        "type" as var_type
                        "access_pattern" as access_pattern
                        "is_array" as contains_string with left_side and "["
                        "line_number" as get_line_number with line and kernel_body
                    
                    Add var_info to write_vars
                    Add variable_name to processed_vars
        
        Note: Look for increment/decrement patterns
        Otherwise if contains_string with line and "+=" or contains_string with line and "-=" or contains_string with line and "*=":
            Let variable_name be extract_variable_name_from_compound_assignment with line
            If variable_name is not "" and not contains_variable_name with processed_vars and variable_name:
                Let var_info be Dictionary with:
                    "name" as variable_name
                    "type" as "Numeric"
                    "access_pattern" as "accumulation"
                    "is_array" as contains_string with line and "["
                    "line_number" as get_line_number with line and kernel_body
                
                Add var_info to write_vars
                Add variable_name to processed_vars
    
    Return write_vars

Process called "extract_read_variables" that takes kernel_body as String returns List[Dictionary]:
    Note: Extract variables that are read from with comprehensive analysis
    Let read_vars be empty list
    Let processed_vars be empty list
    Let lines be split_string with kernel_body and "\n"
    
    For each line in lines:
        Note: Look for variables on right side of assignments
        If contains_string with line and "=":
            Let assignment_parts be split_string with line and "="
            If length of assignment_parts >= 2:
                Let right_side be trim_whitespace with assignment_parts[1]
                Let variables_in_expression be extract_variables_from_expression with right_side
                
                For each var_name in variables_in_expression:
                    If not contains_variable_name with processed_vars and var_name:
                        Let var_type be infer_variable_type_from_usage with var_name and kernel_body
                        Let access_pattern be analyze_variable_access_pattern with var_name and kernel_body
                        
                        Let var_info be Dictionary with:
                            "name" as var_name
                            "type" as var_type
                            "access_pattern" as access_pattern
                            "is_array" as contains_string with kernel_body and var_name joined with "["
                            "usage_count" as count_variable_usage with var_name and kernel_body
                        
                        Add var_info to read_vars
                        Add var_name to processed_vars
        
        Note: Look for variables in conditional expressions
        Otherwise if contains_string with line and "if" or contains_string with line and "while":
            Let condition_variables be extract_variables_from_condition with line
            For each var_name in condition_variables:
                If not contains_variable_name with processed_vars and var_name:
                    Let var_info be Dictionary with:
                        "name" as var_name
                        "type" as "Conditional"
                        "access_pattern" as "control_flow"
                        "is_array" as contains_string with line and var_name joined with "["
                        "usage_count" as count_variable_usage with var_name and kernel_body
                    
                    Add var_info to read_vars
                    Add var_name to processed_vars
        
        Note: Look for function call arguments
        Otherwise if contains_string with line and "(":
            Let function_args be extract_variables_from_function_calls with line
            For each var_name in function_args:
                If not contains_variable_name with processed_vars and var_name:
                    Let var_info be Dictionary with:
                        "name" as var_name
                        "type" as "Parameter"
                        "access_pattern" as "function_argument"
                        "is_array" as contains_string with line and var_name joined with "["
                        "usage_count" as count_variable_usage with var_name and kernel_body
                    
                    Add var_info to read_vars
                    Add var_name to processed_vars
    
    Return read_vars

Process called "estimate_variable_size" that takes variable as Dictionary returns Integer:
    Note: Estimate size of variable in bytes
    Match variable["type"]:
        Case "Float":
            Return 4
        Case "Double":
            Return 8
        Case "Integer":
            Return 4
        Case "Array":
            Return 1024  Note: Assume 1KB array
        Otherwise:
            Return 4

Process called "extract_kernel_operations" that takes kernel_body as String returns String:
    Note: Extract core operations from kernel body
    Let lines be split_string with kernel_body and "\n"
    Let operations be ""
    
    For each line in lines:
        If contains_string with line and "=" or contains_string with line and "+" or contains_string with line and "*":
            Set operations to operations joined with "    " joined with line joined with "\n"
    
    Return operations

Process called "extract_producer_operations" that takes kernel_body as String returns String:
    Note: Extract producer operations (computations, not stores)
    Let operations be extract_kernel_operations with kernel_body
    Note: Remove store operations for fusion
    Return replace_string with operations and "output[" and "temp_"

Process called "extract_consumer_operations" that takes kernel_body as String returns String:
    Note: Extract consumer operations (using producer results)
    Let operations be extract_kernel_operations with kernel_body
    Note: Replace input reads with temp variables from producer
    Return replace_string with operations and "input[" and "temp_"

Process called "estimate_register_count" that takes kernel_body as String returns Integer:
    Note: Estimate register count for kernel
    Let variable_count be count_unique_variables with kernel_body
    Return variable_count * 4  Note: Rough estimate

Process called "count_unique_variables" that takes kernel_body as String returns Integer:
    Note: Count unique variables with comprehensive analysis
    Let unique_variables be empty list
    Let lines be split_string with kernel_body and "\n"
    
    For each line in lines:
        Note: Look for variable declarations
        If contains_string with line and "float" or contains_string with line and "int" or contains_string with line and "double":
            Let declared_vars be extract_variable_declarations with line
            For each var_name in declared_vars:
                If not contains_variable_name with unique_variables and var_name:
                    Add var_name to unique_variables
        
        Note: Look for assignments to new variables
        Otherwise if contains_string with line and "=":
            Let assignment_parts be split_string with line and "="
            If length of assignment_parts >= 2:
                Let left_side be trim_whitespace with assignment_parts[0]
                Let var_name be extract_variable_name_from_assignment with left_side
                If var_name is not "" and not contains_variable_name with unique_variables and var_name:
                    Add var_name to unique_variables
    
    Note: Add common GPU built-in variables
    Let builtin_vars be ["tid", "bid", "threadIdx", "blockIdx", "blockDim", "gridDim"]
    For each builtin_var in builtin_vars:
        If contains_string with kernel_body and builtin_var and not contains_variable_name with unique_variables and builtin_var:
            Add builtin_var to unique_variables
    
    Note: Estimate additional temporary variables needed
    Let temp_operations be count_complex_operations with kernel_body
    Let estimated_temps be temp_operations / 3  Note: Rough estimate
    
    Return length of unique_variables + estimated_temps

Process called "can_kernels_be_fused" that takes producer as KernelFunction and consumer as KernelFunction and dependency_type as String returns Boolean:
    Note: Determine if two kernels can be fused
    Note: Check resource constraints
    Let combined_registers be producer.register_count + consumer.register_count
    Let combined_shared_memory be producer.shared_memory_size + consumer.shared_memory_size
    
    If combined_registers > 65536:  Note: Too many registers
        Return false
    
    If combined_shared_memory > 98304:  Note: Too much shared memory
        Return false
    
    Note: Check if dependency allows fusion
    Match dependency_type:
        Case "data":
            Return true
        Case "memory":
            Return true
        Case "control":
            Return false  Note: Control dependencies are harder to fuse
        Otherwise:
            Return false

Note: String Utility Functions

Process called "contains_string" that takes text as String and search as String returns Boolean:
    Note: Check if text contains search string
    Let text_length be length of text
    Let search_length be length of search
    Let position be 0
    
    While position <= (text_length - search_length):
        Let substring be substring of text from position to (position + search_length)
        If substring equals search:
            Return true
        Set position to position + 1
    
    Return false

Process called "replace_string" that takes text as String and old_string as String and new_string as String returns String:
    Note: Replace all occurrences of old_string with new_string
    Let result be ""
    Let text_length be length of text
    Let old_length be length of old_string
    Let position be 0
    
    If old_length equals 0:
        Return text  Note: Cannot replace empty string
    
    While position < text_length:
        Let remaining_length be text_length - position
        
        Note: Check if old_string matches at current position
        If remaining_length >= old_length:
            Let substring be substring of text from position to (position + old_length)
            If substring equals old_string:
                Note: Found match, add replacement string
                Set result to result joined with new_string
                Set position to position + old_length
            Otherwise:
                Note: No match, add current character
                Let current_char be character_at with text and position
                Set result to result joined with current_char
                Set position to position + 1
        Otherwise:
            Note: Not enough characters left for match, add remaining
            Let current_char be character_at with text and position
            Set result to result joined with current_char
            Set position to position + 1
    
    Return result

Process called "split_string" that takes text as String and delimiter as String returns List[String]:
    Note: Split string by delimiter
    Let parts be empty list
    Let current_part be ""
    Let text_length be length of text
    Let delimiter_length be length of delimiter
    Let position be 0
    
    If delimiter_length equals 0:
        Add text to parts
        Return parts
    
    While position < text_length:
        Let remaining_length be text_length - position
        
        Note: Check if delimiter matches at current position
        If remaining_length >= delimiter_length:
            Let substring be substring of text from position to (position + delimiter_length)
            If substring equals delimiter:
                Note: Found delimiter, add current part to list
                Add current_part to parts
                Set current_part to ""
                Set position to position + delimiter_length
            Otherwise:
                Note: No match, add current character to part
                Let current_char be character_at with text and position
                Set current_part to current_part joined with current_char
                Set position to position + 1
        Otherwise:
            Note: Not enough characters left for delimiter, add remaining
            Let current_char be character_at with text and position
            Set current_part to current_part joined with current_char
            Set position to position + 1
    
    Note: Add final part (even if empty)
    Add current_part to parts
    
    Return parts

Process called "count_occurrences" that takes text as String and pattern as String returns Integer:
    Note: Count pattern occurrences in text
    Let count be 0
    Let text_length be length of text
    Let pattern_length be length of pattern
    Let position be 0
    
    While position <= (text_length - pattern_length):
        Let substring be substring of text from position to (position + pattern_length)
        If substring equals pattern:
            Set count to count + 1
        Set position to position + 1
    
    Return count

Process called "substring" that takes text as String and start as Integer and end as Integer returns String:
    Note: Extract substring from text
    Return host_call_substring with text and start and end

Process called "length" that takes text as String returns Integer:
    Note: Get string length
    Return host_call_string_length with text

Note: Host Interface Functions

Process called "host_call_substring" that takes text as String and start as Integer and end as Integer returns String:
    Note: Host-provided substring operation
    Return ""  Note: Will be implemented by host environment

Process called "host_call_string_length" that takes text as String returns Integer:
    Note: Host-provided string length
    Return 0  Note: Will be implemented by host environment

Note: Missing Functions for Fusion Operations

Process called "extract_reduction_operations" that takes kernel_body as String returns String:
    Note: Extract reduction operations from kernel body for fusion
    Let reduction_ops be ""
    Let lines be split_string with kernel_body and "\n"
    
    For each line in lines:
        If contains_string with line and "+=" or contains_string with line and "sum" or contains_string with line and "reduce":
            Set reduction_ops to reduction_ops joined with "    " joined with line joined with "\n"
        Otherwise if contains_string with line and "input[" and contains_string with line and "*":
            Note: Load and multiply operations for reduction
            Set reduction_ops to reduction_ops joined with "    sum += input[tid] * weight[tid];\n"
        Otherwise if contains_string with line and "data[":
            Note: Data access for reduction
            Set reduction_ops to reduction_ops joined with "    sum += data[tid % 256];\n"
    
    If reduction_ops equals "":
        Set reduction_ops to "    sum += input[tid];\n"
    
    Return reduction_ops

Process called "extract_final_reduction_operations" that takes kernel_body as String returns String:
    Note: Extract final reduction operations for the last thread
    Let final_ops be ""
    Let lines be split_string with kernel_body and "\n"
    
    For each line in lines:
        If contains_string with line and "output[" or contains_string with line and "result[":
            Let modified_line be replace_string with line and "output[tid]" and "output[blockIdx.x]"
            Set modified_line to replace_string with modified_line and "result[tid]" and "result[blockIdx.x]"
            Set final_ops to final_ops joined with "        " joined with modified_line joined with "\n"
    
    If final_ops equals "":
        Set final_ops to "        output[blockIdx.x] = sdata[0];\n"
    
    Return final_ops

Process called "extract_memory_operations" that takes kernel_body as String returns String:
    Note: Extract memory operations for memory-bound fusion
    Let memory_ops be ""
    Let lines be split_string with kernel_body and "\n"
    
    For each line in lines:
        If contains_string with line and "[" and not contains_string with line and "cache":
            Note: Memory access operation
            Let optimized_line be optimize_memory_access_line with line
            Set memory_ops to memory_ops joined with "    " joined with optimized_line joined with "\n"
        Otherwise if contains_string with line and "=" and contains_string with line and "+":
            Note: Computation that can use cached data
            Set memory_ops to memory_ops joined with "    " joined with line joined with "\n"
    
    If memory_ops equals "":
        Set memory_ops to "    float result = cache[lid] * 2.0f;\n"
    
    Return memory_ops

Process called "optimize_memory_access_line" that takes line as String returns String:
    Note: Optimize memory access line for better coalescing
    Let optimized_line be line
    
    Note: Replace individual element access with vectorized access
    If contains_string with line and "input[tid]":
        Set optimized_line to replace_string with optimized_line and "input[tid]" and "data.x"
    Otherwise if contains_string with line and "data[tid":
        Set optimized_line to replace_string with optimized_line and "data[tid" and "cache[lid"
    
    Return optimized_line

Note: Helper Functions for Enhanced Variable and Loop Analysis

Process called "trim_whitespace" that takes text as String returns String:
    Note: Remove leading and trailing whitespace
    Let result be text
    Let start_pos be 0
    Let end_pos be length of text
    
    Note: Find first non-whitespace character
    While start_pos < end_pos:
        Let char be character_at with text and start_pos
        If char is not " " and char is not "\t" and char is not "\n":
            Break
        Set start_pos to start_pos + 1
    
    Note: Find last non-whitespace character
    While end_pos > start_pos:
        Let char be character_at with text and (end_pos - 1)
        If char is not " " and char is not "\t" and char is not "\n":
            Break
        Set end_pos to end_pos - 1
    
    If start_pos >= end_pos:
        Return ""
    
    Return substring of text from start_pos to end_pos

Process called "extract_variable_name_from_assignment" that takes left_side as String returns String:
    Note: Extract variable name from left side of assignment
    Let trimmed be trim_whitespace with left_side
    
    Note: Handle array assignments like output[i]
    If contains_string with trimmed and "[":
        Let parts be split_string with trimmed and "["
        Return trim_whitespace with parts[0]
    
    Note: Handle simple variable assignments
    Let words be split_string with trimmed and " "
    If length of words > 0:
        Return trim_whitespace with words[length of words - 1]
    
    Return ""

Process called "contains_variable_name" that takes variable_list as List[String] and name as String returns Boolean:
    Note: Check if variable name exists in list
    For each variable in variable_list:
        If variable equals name:
            Return true
    Return false

Process called "infer_type_from_assignment" that takes line as String returns String:
    Note: Infer variable type from assignment pattern
    If contains_string with line and "float" or contains_string with line and ".0f":
        Return "Float"
    Otherwise if contains_string with line and "int" or contains_string with line and "tid" or contains_string with line and "bid":
        Return "Integer"
    Otherwise if contains_string with line and "double":
        Return "Double"
    Otherwise if contains_string with line and "[" and contains_string with line and "]":
        Return "Array"
    Otherwise:
        Return "Unknown"

Process called "determine_access_pattern" that takes line as String returns String:
    Note: Determine variable access pattern
    If contains_string with line and "tid" or contains_string with line and "gid":
        Return "thread_indexed"
    Otherwise if contains_string with line and "blockIdx" or contains_string with line and "bid":
        Return "block_indexed"
    Otherwise if contains_string with line and "shared" or contains_string with line and "cache":
        Return "shared_memory"
    Otherwise:
        Return "regular"

Process called "get_line_number" that takes line as String and full_text as String returns Integer:
    Note: Get line number of specific line in full text
    Let lines be split_string with full_text and "\n"
    Let line_num be 1
    
    For each text_line in lines:
        If text_line equals line:
            Return line_num
        Set line_num to line_num + 1
    
    Return 0

Process called "extract_variable_name_from_compound_assignment" that takes line as String returns String:
    Note: Extract variable name from compound assignment (+=, -=, *=)
    Let operators be ["+=", "-=", "*=", "/="]
    
    For each operator in operators:
        If contains_string with line and operator:
            Let parts be split_string with line and operator
            If length of parts >= 2:
                Return extract_variable_name_from_assignment with parts[0]
    
    Return ""

Process called "extract_variables_from_expression" that takes expression as String returns List[String]:
    Note: Extract all variable names from an expression
    Let variables be empty list
    Let tokens be tokenize_expression with expression
    
    For each token in tokens:
        If is_variable_token with token:
            Let var_name be extract_clean_variable_name with token
            If var_name is not "" and not contains_variable_name with variables and var_name:
                Add var_name to variables
    
    Return variables

Process called "tokenize_expression" that takes expression as String returns List[String]:
    Note: Simple tokenization of expression into potential variable names
    Let tokens be empty list
    Let current_token be ""
    Let i be 0
    
    While i < length of expression:
        Let char be character_at with expression and i
        
        If is_alphanumeric with char or char equals "_":
            Set current_token to current_token joined with char
        Otherwise:
            If current_token is not "":
                Add current_token to tokens
                Set current_token to ""
            
            Note: Add operators and delimiters as separate tokens
            If char is not " " and char is not "\t":
                Add char to tokens
        
        Set i to i + 1
    
    Note: Add final token
    If current_token is not "":
        Add current_token to tokens
    
    Return tokens

Process called "is_variable_token" that takes token as String returns Boolean:
    Note: Check if token is likely a variable name
    If length of token equals 0:
        Return false
    
    Let first_char be character_at with token and 0
    If not is_alpha with first_char and first_char is not "_":
        Return false
    
    Note: Check if it's a reserved keyword
    Let keywords be ["if", "else", "for", "while", "int", "float", "double", "return", "break", "continue"]
    For each keyword in keywords:
        If token equals keyword:
            Return false
    
    Return true

Process called "extract_clean_variable_name" that takes token as String returns String:
    Note: Clean up variable name from token
    Let clean_name be token
    
    Note: Remove array indices
    If contains_string with clean_name and "[":
        Let parts be split_string with clean_name and "["
        Set clean_name to parts[0]
    
    Return trim_whitespace with clean_name

Process called "infer_variable_type_from_usage" that takes var_name as String and kernel_body as String returns String:
    Note: Infer variable type from usage patterns
    If contains_string with kernel_body and var_name joined with "[":
        Return "Array"
    Otherwise if contains_string with kernel_body and "float " joined with var_name:
        Return "Float"
    Otherwise if contains_string with kernel_body and "int " joined with var_name:
        Return "Integer"
    Otherwise if contains_string with kernel_body and "double " joined with var_name:
        Return "Double"
    Otherwise:
        Return "Unknown"

Process called "analyze_variable_access_pattern" that takes var_name as String and kernel_body as String returns String:
    Note: Analyze how variable is accessed
    Let access_count be count_variable_usage with var_name and kernel_body
    
    If access_count <= 1:
        Return "single_use"
    Otherwise if contains_string with kernel_body and var_name joined with "[tid":
        Return "thread_parallel"
    Otherwise if contains_string with kernel_body and var_name joined with "[i":
        Return "loop_sequential"
    Otherwise:
        Return "multiple_use"

Process called "count_variable_usage" that takes var_name as String and kernel_body as String returns Integer:
    Note: Count how many times variable is used
    Return count_occurrences with kernel_body and var_name

Process called "extract_variables_from_condition" that takes line as String returns List[String]:
    Note: Extract variables from conditional expressions
    Let variables be empty list
    
    Note: Find condition part between parentheses or after if/while
    Let condition_start be find_condition_start with line
    Let condition_end be find_condition_end with line and condition_start
    
    If condition_start >= 0 and condition_end > condition_start:
        Let condition_part be substring of line from condition_start to condition_end
        Set variables to extract_variables_from_expression with condition_part
    
    Return variables

Process called "find_condition_start" that takes line as String returns Integer:
    Note: Find start of condition in if/while statement
    If contains_string with line and "if":
        Let if_pos be find_string_position with line and "if"
        Return find_next_char_position with line and "(" and if_pos
    Otherwise if contains_string with line and "while":
        Let while_pos be find_string_position with line and "while"
        Return find_next_char_position with line and "(" and while_pos
    
    Return -1

Process called "find_condition_end" that takes line as String and start_pos as Integer returns Integer:
    Note: Find end of condition (matching closing parenthesis)
    Let paren_count be 0
    Let i be start_pos
    
    While i < length of line:
        Let char be character_at with line and i
        If char equals "(":
            Set paren_count to paren_count + 1
        Otherwise if char equals ")":
            Set paren_count to paren_count - 1
            If paren_count equals 0:
                Return i
        Set i to i + 1
    
    Return length of line

Process called "extract_variables_from_function_calls" that takes line as String returns List[String]:
    Note: Extract variables from function call arguments
    Let variables be empty list
    Let paren_start be find_string_position with line and "("
    Let paren_end be find_condition_end with line and paren_start
    
    If paren_start >= 0 and paren_end > paren_start:
        Let args_part be substring of line from (paren_start + 1) to paren_end
        Let args be split_string with args_part and ","
        
        For each arg in args:
            Let arg_variables be extract_variables_from_expression with arg
            For each var_name in arg_variables:
                If not contains_variable_name with variables and var_name:
                    Add var_name to variables
    
    Return variables

Process called "analyze_loop_for_unrolling" that takes loop_line as String returns Dictionary:
    Note: Analyze for loop to determine if it can be unrolled
    Let loop_info be Dictionary with:
        "can_unroll" as false
        "unroll_factor" as 1
        "end_line_index" as 0
    
    Note: Extract loop bounds
    Let loop_bounds be extract_for_loop_bounds with loop_line
    If loop_bounds["is_constant"] and loop_bounds["iterations"] <= 8:
        Set loop_info["can_unroll"] to true
        Set loop_info["unroll_factor"] to loop_bounds["iterations"]
    
    Return loop_info

Process called "extract_for_loop_bounds" that takes loop_line as String returns Dictionary:
    Note: Extract bounds from for loop
    Let bounds_info be Dictionary with:
        "is_constant" as false
        "iterations" as 0
        "start_value" as 0
        "end_value" as 0
    
    Note: Simple pattern matching for common for loop patterns
    If contains_string with loop_line and "< 4":
        Set bounds_info["is_constant"] to true
        Set bounds_info["iterations"] to 4
        Set bounds_info["end_value"] to 4
    Otherwise if contains_string with loop_line and "< 8":
        Set bounds_info["is_constant"] to true
        Set bounds_info["iterations"] to 8
        Set bounds_info["end_value"] to 8
    Otherwise if contains_string with loop_line and "< 2":
        Set bounds_info["is_constant"] to true
        Set bounds_info["iterations"] to 2
        Set bounds_info["end_value"] to 2
    
    Return bounds_info

Process called "generate_unrolled_loop" that takes loop_info as Dictionary and lines as List[String] and start_index as Integer returns String:
    Note: Generate unrolled loop code
    Let unrolled_code be "    // Unrolled loop (" joined with loop_info["unroll_factor"] joined with " iterations)\n"
    Let loop_body be extract_loop_body with lines and start_index
    
    Let iteration be 0
    While iteration < loop_info["unroll_factor"]:
        Let iteration_body be replace_loop_variable_with_constant with loop_body and iteration
        Set unrolled_code to unrolled_code joined with iteration_body
        Set iteration to iteration + 1
    
    Return unrolled_code

Process called "extract_loop_body" that takes lines as List[String] and start_index as Integer returns String:
    Note: Extract loop body from lines
    Let body be ""
    Let i be start_index + 1
    Let brace_count be 0
    Let found_opening_brace be false
    
    While i < length of lines:
        Let line be lines[i]
        If contains_string with line and "{":
            Set found_opening_brace to true
            Set brace_count to brace_count + 1
        If contains_string with line and "}":
            Set brace_count to brace_count - 1
            If brace_count equals 0 and found_opening_brace:
                Break
        
        If found_opening_brace and brace_count > 0:
            Set body to body joined with line joined with "\n"
        
        Set i to i + 1
    
    Return body

Process called "replace_loop_variable_with_constant" that takes body as String and iteration_value as Integer returns String:
    Note: Replace loop variable with constant value
    Let result be body
    Let iteration_str be convert_integer_to_string with iteration_value
    
    Note: Replace common loop variable names
    Set result to replace_string with result and "i" and iteration_str
    Set result to replace_string with result and "j" and iteration_str
    Set result to replace_string with result and "k" and iteration_str
    
    Return result

Process called "is_simple_while_loop" that takes line as String returns Boolean:
    Note: Check if while loop is simple enough for unrolling
    Return contains_string with line and "<" and (contains_string with line and "2" or contains_string with line and "4")

Process called "analyze_while_for_unrolling" that takes while_line as String returns Dictionary:
    Note: Analyze while loop for unrolling potential
    Return Dictionary with:
        "can_unroll" as false
        "unroll_factor" as 1
        "end_line_index" as 0  Note: While loops are harder to unroll safely

Process called "generate_unrolled_while" that takes while_info as Dictionary and lines as List[String] and start_index as Integer returns String:
    Note: Generate unrolled while loop (conservative approach for complex control flow)
    Let condition be while_info["condition"]
    Let body be while_info["body"]
    Let result be "    // While loop (complex control flow - using original structure):\n"
    Set result to result joined with "    while (" joined with condition joined with ") {\n"
    Set result to result joined with "        " joined with body joined with "\n"
    Set result to result joined with "    }\n"
    Return result

Process called "extract_variable_declarations" that takes line as String returns List[String]:
    Note: Extract variable names from declaration line
    Let variables be empty list
    Let declaration_types be ["float", "int", "double", "bool"]
    
    For each type_name in declaration_types:
        If contains_string with line and type_name:
            Let remaining_part be extract_part_after_type with line and type_name
            Let declared_vars be extract_declared_variable_names with remaining_part
            For each var_name in declared_vars:
                Add var_name to variables
    
    Return variables

Process called "extract_part_after_type" that takes line as String and type_name as String returns String:
    Note: Extract part of line after type declaration
    Let type_pos be find_string_position with line and type_name
    If type_pos >= 0:
        Let start_pos be type_pos + length of type_name
        Return substring of line from start_pos to (length of line)
    Return ""

Process called "extract_declared_variable_names" that takes declaration_part as String returns List[String]:
    Note: Extract variable names from declaration part
    Let variables be empty list
    Let parts be split_string with declaration_part and ","
    
    For each part in parts:
        Let clean_part be trim_whitespace with part
        Let var_name be extract_first_identifier with clean_part
        If var_name is not "":
            Add var_name to variables
    
    Return variables

Process called "extract_first_identifier" that takes text as String returns String:
    Note: Extract first identifier from text
    Let result be ""
    Let i be 0
    
    Note: Skip initial whitespace and non-identifier chars
    While i < length of text:
        Let char be character_at with text and i
        If is_alpha with char or char equals "_":
            Break
        Set i to i + 1
    
    Note: Collect identifier characters
    While i < length of text:
        Let char be character_at with text and i
        If is_alphanumeric with char or char equals "_":
            Set result to result joined with char
        Otherwise:
            Break
        Set i to i + 1
    
    Return result

Process called "count_complex_operations" that takes kernel_body as String returns Integer:
    Note: Count complex operations that might need temporary variables
    Let complex_ops be 0
    
    Set complex_ops to complex_ops + count_occurrences with kernel_body and "*"
    Set complex_ops to complex_ops + count_occurrences with kernel_body and "/"
    Set complex_ops to complex_ops + count_occurrences with kernel_body and "sqrt"
    Set complex_ops to complex_ops + count_occurrences with kernel_body and "sin"
    Set complex_ops to complex_ops + count_occurrences with kernel_body and "cos"
    Set complex_ops to complex_ops + count_occurrences with kernel_body and "exp"
    Set complex_ops to complex_ops + count_occurrences with kernel_body and "log"
    
    Return complex_ops

Note: Utility Functions for Character and String Analysis

Process called "is_alphanumeric" that takes char as String returns Boolean:
    Note: Check if character is alphanumeric
    Return is_alpha with char or is_digit with char

Process called "is_alpha" that takes char as String returns Boolean:
    Note: Check if character is alphabetic
    Return (char >= "a" and char <= "z") or (char >= "A" and char <= "Z")

Process called "is_digit" that takes char as String returns Boolean:
    Note: Check if character is numeric
    Return char >= "0" and char <= "9"

Process called "find_string_position" that takes text as String and search as String returns Integer:
    Note: Find position of search string in text
    Let text_length be length of text
    Let search_length be length of search
    Let position be 0
    
    While position <= (text_length - search_length):
        Let substring be substring of text from position to (position + search_length)
        If substring equals search:
            Return position
        Set position to position + 1
    
    Return -1

Process called "find_next_char_position" that takes text as String and char as String and start_pos as Integer returns Integer:
    Note: Find position of character starting from start_pos
    Let i be start_pos
    While i < length of text:
        Let current_char be character_at with text and i
        If current_char equals char:
            Return i
        Set i to i + 1
    
    Return -1

Process called "convert_integer_to_string" that takes value as Integer returns String:
    Note: Convert integer to string representation
    If value equals 0:
        Return "0"
    Otherwise if value equals 1:
        Return "1"
    Otherwise if value equals 2:
        Return "2"
    Otherwise if value equals 3:
        Return "3"
    Otherwise if value equals 4:
        Return "4"
    Otherwise if value equals 5:
        Return "5"
    Otherwise if value equals 6:
        Return "6"
    Otherwise if value equals 7:
        Return "7"
    Otherwise if value equals 8:
        Return "8"
    Otherwise if value equals 9:
        Return "9"
    Otherwise:
        Note: Handle multi-digit numbers through recursive conversion
        If value < 0:
            Return "-" joined with digit_to_string(0 - value)
        Otherwise if value >= 10:
            Let quotient be value / 10
            Let remainder be value - (quotient * 10)
            Return digit_to_string(quotient) joined with digit_to_string(remainder)
        Otherwise:
            Return "0"  Note: Fallback for edge cases