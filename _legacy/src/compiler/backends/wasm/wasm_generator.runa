Note: Runa WebAssembly Code Generator
Note: Compiles Runa LIR (Low-level IR) to WebAssembly bytecode
Note: Supports both browser and server-side (WASI) deployment targets

Import "../../ir/lir/lir.runa"
Import "../../ir/types/types.runa"

Note: WebAssembly Module Structure
Type WasmModule is Dictionary with:
    magic as List[Integer]
    version as List[Integer]
    sections as List[WasmSection]
    imports as List[WasmImport]
    exports as List[WasmExport]
    functions as List[WasmFunction]
    memory as WasmMemory
    table as WasmTable

Type WasmSection is Dictionary with:
    section_id as Integer
    size as Integer
    payload as List[Integer]

Type WasmImport is Dictionary with:
    module_name as String
    field_name as String
    import_type as WasmImportType

Type WasmImportType is:
    | Function with signature as WasmFunctionSignature
    | Memory with limits as WasmLimits
    | Table with element_type as WasmValueType and limits as WasmLimits
    | Global with value_type as WasmValueType and mutability as Boolean

Type WasmExport is Dictionary with:
    name as String
    export_type as WasmExportType
    index as Integer

Type WasmExportType is:
    | Function
    | Memory
    | Table
    | Global

Type WasmFunction is Dictionary with:
    signature as WasmFunctionSignature
    locals as List[WasmValueType]
    body as List[WasmInstruction]

Type WasmFunctionSignature is Dictionary with:
    parameters as List[WasmValueType]
    results as List[WasmValueType]

Type WasmValueType is:
    | I32
    | I64
    | F32
    | F64
    | V128

Type WasmLimits is Dictionary with:
    min as Integer
    max as Integer

Type WasmMemory is Dictionary with:
    limits as WasmLimits

Type WasmTable is Dictionary with:
    element_type as WasmValueType
    limits as WasmLimits

Note: WebAssembly Instructions
Type WasmInstruction is:
    | Unreachable
    | Nop
    | Block with result_type as WasmValueType
    | Loop with result_type as WasmValueType
    | If with result_type as WasmValueType
    | Else
    | End
    | Br with label_index as Integer
    | BrIf with label_index as Integer
    | BrTable with label_indices as List[Integer] and default_label as Integer
    | Return
    | Call with function_index as Integer
    | CallIndirect with signature_index as Integer
    | Drop
    | Select
    | LocalGet with local_index as Integer
    | LocalSet with local_index as Integer
    | LocalTee with local_index as Integer
    | GlobalGet with global_index as Integer
    | GlobalSet with global_index as Integer
    | I32Load with offset as Integer and align as Integer
    | I64Load with offset as Integer and align as Integer
    | F32Load with offset as Integer and align as Integer
    | F64Load with offset as Integer and align as Integer
    | I32Store with offset as Integer and align as Integer
    | I64Store with offset as Integer and align as Integer
    | F32Store with offset as Integer and align as Integer
    | F64Store with offset as Integer and align as Integer
    | MemorySize
    | MemoryGrow
    | I32Const with value as Integer
    | I64Const with value as Integer
    | F32Const with value as Float
    | F64Const with value as Float
    | I32Eqz
    | I32Eq
    | I32Ne
    | I32LtS
    | I32LtU
    | I32GtS
    | I32GtU
    | I32LeS
    | I32LeU
    | I32GeS
    | I32GeU
    | I64Eqz
    | I64Eq
    | I64Ne
    | I64LtS
    | I64LtU
    | I64GtS
    | I64GtU
    | I64LeS
    | I64LeU
    | I64GeS
    | I64GeU
    | F32Eq
    | F32Ne
    | F32Lt
    | F32Gt
    | F32Le
    | F32Ge
    | F64Eq
    | F64Ne
    | F64Lt
    | F64Gt
    | F64Le
    | F64Ge
    | I32Clz
    | I32Ctz
    | I32Popcnt
    | I32Add
    | I32Sub
    | I32Mul
    | I32DivS
    | I32DivU
    | I32RemS
    | I32RemU
    | I32And
    | I32Or
    | I32Xor
    | I32Shl
    | I32ShrS
    | I32ShrU
    | I32Rotl
    | I32Rotr
    | I64Clz
    | I64Ctz
    | I64Popcnt
    | I64Add
    | I64Sub
    | I64Mul
    | I64DivS
    | I64DivU
    | I64RemS
    | I64RemU
    | I64And
    | I64Or
    | I64Xor
    | I64Shl
    | I64ShrS
    | I64ShrU
    | I64Rotl
    | I64Rotr
    | F32Abs
    | F32Neg
    | F32Ceil
    | F32Floor
    | F32Trunc
    | F32Nearest
    | F32Sqrt
    | F32Add
    | F32Sub
    | F32Mul
    | F32Div
    | F32Min
    | F32Max
    | F32Copysign
    | F64Abs
    | F64Neg
    | F64Ceil
    | F64Floor
    | F64Trunc
    | F64Nearest
    | F64Sqrt
    | F64Add
    | F64Sub
    | F64Mul
    | F64Div
    | F64Min
    | F64Max
    | F64Copysign

Note: WebAssembly Generator
Type WasmGenerator is Dictionary with:
    module as WasmModule
    current_function as Integer
    local_counter as Integer
    label_stack as List[String]
    function_signatures as Dictionary[String, WasmFunctionSignature]
    import_map as Dictionary[String, Integer]
    export_map as Dictionary[String, Integer]
    function_name_map as Dictionary[String, Integer]
    memory_size as Integer
    enable_wasi as Boolean

Note: WebAssembly Constants
Let WASM_MAGIC_NUMBER be [0x00, 0x61, 0x73, 0x6D]
Let WASM_VERSION be [0x01, 0x00, 0x00, 0x00]
Let DEFAULT_MEMORY_MIN_PAGES be 1
Let DEFAULT_MEMORY_MAX_PAGES be 16
Let DEFAULT_TABLE_MIN_SIZE be 0
Let DEFAULT_TABLE_MAX_SIZE be 100
Let DEFAULT_MEMORY_SIZE be 65536

Note: WebAssembly Section IDs
Let SECTION_ID_CUSTOM be 0
Let SECTION_ID_TYPE be 1
Let SECTION_ID_IMPORT be 2
Let SECTION_ID_FUNCTION be 3
Let SECTION_ID_TABLE be 4
Let SECTION_ID_MEMORY be 5
Let SECTION_ID_GLOBAL be 6
Let SECTION_ID_EXPORT be 7
Let SECTION_ID_START be 8
Let SECTION_ID_ELEMENT be 9
Let SECTION_ID_CODE be 10
Let SECTION_ID_DATA be 11

Note: WebAssembly Value Type Encodings
Let WASM_TYPE_I32 be 0x7F
Let WASM_TYPE_I64 be 0x7E
Let WASM_TYPE_F32 be 0x7D
Let WASM_TYPE_F64 be 0x7C
Let WASM_TYPE_V128 be 0x7B

Note: WebAssembly Import/Export Type Encodings
Let IMPORT_TYPE_FUNCTION be 0x00
Let IMPORT_TYPE_TABLE be 0x01
Let IMPORT_TYPE_MEMORY be 0x02
Let IMPORT_TYPE_GLOBAL be 0x03

Note: WebAssembly Function Type Encoding
Let FUNCTION_TYPE_INDICATOR be 0x60

Note: WebAssembly Limits Encodings
Let LIMITS_NO_MAX be 0x00
Let LIMITS_WITH_MAX be 0x01

Process called "create_wasm_generator" that takes enable_wasi as Boolean returns WasmGenerator:
    Note: Create a new WebAssembly generator
    Let module be WasmModule with:
        magic as WASM_MAGIC_NUMBER
        version as WASM_VERSION
        sections as empty list
        imports as empty list
        exports as empty list
        functions as empty list
        memory as WasmMemory with limits as WasmLimits with min as DEFAULT_MEMORY_MIN_PAGES and max as DEFAULT_MEMORY_MAX_PAGES
        table as WasmTable with element_type as I32 and limits as WasmLimits with min as DEFAULT_TABLE_MIN_SIZE and max as DEFAULT_TABLE_MAX_SIZE
    
    Return WasmGenerator with:
        module as module
        current_function as 0
        local_counter as 0
        label_stack as empty list
        function_signatures as empty dictionary
        import_map as empty dictionary
        export_map as empty dictionary
        function_name_map as empty dictionary
        memory_size as DEFAULT_MEMORY_SIZE
        enable_wasi as enable_wasi

Process called "generate_wasm_from_lir" that takes generator as WasmGenerator and lir_module as LIRModule returns WasmModule:
    Note: Convert LIR module to WebAssembly module
    Let updated_generator be generator
    
    Note: Add WASI imports if enabled
    If updated_generator.enable_wasi is true:
        Set updated_generator to add_wasi_imports with generator as updated_generator
    
    Note: Process all functions in the LIR module
    For each function in lir_module.functions:
        Set updated_generator to generate_wasm_function with generator as updated_generator and lir_function as function
    
    Note: Add main export if exists
    If lir_module.entry_point is not null:
        Set updated_generator to add_main_export with generator as updated_generator and entry_point as lir_module.entry_point
    
    Note: Finalize module sections
    Set updated_generator to finalize_wasm_sections with generator as updated_generator
    
    Return updated_generator.module

Process called "generate_wasm_function" that takes generator as WasmGenerator and lir_function as LIRFunction returns WasmGenerator:
    Note: Convert a single LIR function to WebAssembly
    Let function_signature be convert_lir_signature_to_wasm with signature as lir_function.signature
    Let function_index be generator.current_function
    
    Note: Create function locals from LIR registers
    Let locals be convert_lir_registers_to_locals with registers as lir_function.registers
    
    Note: Generate function body from LIR instructions
    Let wasm_instructions be generate_wasm_instructions with generator as generator and lir_instructions as lir_function.instructions
    
    Let wasm_function be WasmFunction with:
        signature as function_signature
        locals as locals
        body as wasm_instructions
    
    Note: Add function to module and update maps
    Add wasm_function to generator.module.functions
    Set generator.function_signatures[lir_function.name] to function_signature
    Set generator.function_name_map[lir_function.name] to function_index
    Set generator.current_function to generator.current_function + 1
    
    Return generator

Process called "convert_lir_signature_to_wasm" that takes signature as LIRFunctionSignature returns WasmFunctionSignature:
    Note: Convert LIR function signature to WebAssembly signature
    Let wasm_parameters be empty list
    For each param in signature.parameters:
        Let wasm_type be convert_lir_type_to_wasm with lir_type as param.type
        Add wasm_type to wasm_parameters
    
    Let wasm_results be empty list
    If signature.return_type is not Void:
        Let wasm_return_type be convert_lir_type_to_wasm with lir_type as signature.return_type
        Add wasm_return_type to wasm_results
    
    Return WasmFunctionSignature with:
        parameters as wasm_parameters
        results as wasm_results

Process called "convert_lir_type_to_wasm" that takes lir_type as LIRType returns WasmValueType:
    Note: Map LIR types to WebAssembly value types
    Match lir_type with:
        | I8: I32
        | I16: I32
        | I32: I32
        | I64: I64
        | F32: F32
        | F64: F64
        | Bool: I32
        | Pointer: I32
        | Reference: I32
        | _: I32

Process called "convert_lir_registers_to_locals" that takes registers as List[LIRRegister] returns List[WasmValueType]:
    Note: Convert LIR virtual registers to WebAssembly locals
    Let locals be empty list
    For each register in registers:
        Let wasm_type be convert_lir_type_to_wasm with lir_type as register.type
        Add wasm_type to locals
    Return locals

Process called "generate_wasm_instructions" that takes generator as WasmGenerator and lir_instructions as List[LIRInstruction] returns List[WasmInstruction]:
    Note: Convert LIR instructions to WebAssembly instructions
    Let wasm_instructions be empty list
    
    For each lir_instruction in lir_instructions:
        Let converted_instructions be convert_lir_instruction_to_wasm with generator as generator and instruction as lir_instruction
        Add all converted_instructions to wasm_instructions
    
    Note: Always end function with explicit return
    Add Return to wasm_instructions
    
    Return wasm_instructions

Process called "convert_lir_instruction_to_wasm" that takes generator as WasmGenerator and instruction as LIRInstruction returns List[WasmInstruction]:
    Note: Convert individual LIR instruction to WebAssembly instruction sequence
    Match instruction with:
        | Load with dest as dest and source as source:
            Return [
                LocalGet with local_index as source.register_id,
                LocalSet with local_index as dest.register_id
            ]
        
        | Store with address as addr and value as value:
            Return [
                LocalGet with local_index as addr.register_id,
                LocalGet with local_index as value.register_id,
                I32Store with offset as 0 and align as 4
            ]
        
        | Add with dest as dest and left as left and right as right:
            Let arithmetic_instruction be get_arithmetic_instruction with operation as "add" and operand_type as left.type
            Return [
                LocalGet with local_index as left.register_id,
                LocalGet with local_index as right.register_id,
                arithmetic_instruction,
                LocalSet with local_index as dest.register_id
            ]
        
        | Sub with dest as dest and left as left and right as right:
            Let arithmetic_instruction be get_arithmetic_instruction with operation as "sub" and operand_type as left.type
            Return [
                LocalGet with local_index as left.register_id,
                LocalGet with local_index as right.register_id,
                arithmetic_instruction,
                LocalSet with local_index as dest.register_id
            ]
        
        | Mul with dest as dest and left as left and right as right:
            Let arithmetic_instruction be get_arithmetic_instruction with operation as "mul" and operand_type as left.type
            Return [
                LocalGet with local_index as left.register_id,
                LocalGet with local_index as right.register_id,
                arithmetic_instruction,
                LocalSet with local_index as dest.register_id
            ]
        
        | Div with dest as dest and left as left and right as right:
            Let arithmetic_instruction be get_arithmetic_instruction with operation as "div" and operand_type as left.type
            Return [
                LocalGet with local_index as left.register_id,
                LocalGet with local_index as right.register_id,
                arithmetic_instruction,
                LocalSet with local_index as dest.register_id
            ]
        
        | Call with dest as dest and function_name as func_name and arguments as args:
            Let call_instructions be empty list
            
            Note: Push arguments onto stack
            For each arg in args:
                Add LocalGet with local_index as arg.register_id to call_instructions
            
            Note: Call the function
            Let function_index be get_function_index with generator as generator and function_name as func_name
            Add Call with function_index as function_index to call_instructions
            
            Note: Store result if function returns a value
            If dest is not null:
                Add LocalSet with local_index as dest.register_id to call_instructions
            
            Return call_instructions
        
        | Jump with label as label:
            Let label_index be get_label_index with generator as generator and label as label
            Return [Br with label_index as label_index]
        
        | ConditionalJump with condition as cond and true_label as true_label and false_label as false_label:
            Let true_index be get_label_index with generator as generator and label as true_label
            Let false_index be get_label_index with generator as generator and label as false_label
            Return [
                LocalGet with local_index as cond.register_id,
                BrIf with label_index as true_index,
                Br with label_index as false_index
            ]
        
        | Return with value as value:
            If value is not null:
                Return [
                    LocalGet with local_index as value.register_id,
                    Return
                ]
            Else:
                Return [Return]
        
        | Constant with dest as dest and value as value:
            Let const_instruction be get_constant_instruction with value as value and target_type as dest.type
            Return [
                const_instruction,
                LocalSet with local_index as dest.register_id
            ]
        
        | _:
            Note: Default case for unsupported instructions
            Return [Nop]

Process called "get_arithmetic_instruction" that takes operation as String and operand_type as LIRType returns WasmInstruction:
    Note: Get the appropriate WebAssembly arithmetic instruction
    Match operand_type with:
        | I32:
            Match operation with:
                | "add": I32Add
                | "sub": I32Sub
                | "mul": I32Mul
                | "div": I32DivS
                | _: I32Add
        | I64:
            Match operation with:
                | "add": I64Add
                | "sub": I64Sub
                | "mul": I64Mul
                | "div": I64DivS
                | _: I64Add
        | F32:
            Match operation with:
                | "add": F32Add
                | "sub": F32Sub
                | "mul": F32Mul
                | "div": F32Div
                | _: F32Add
        | F64:
            Match operation with:
                | "add": F64Add
                | "sub": F64Sub
                | "mul": F64Mul
                | "div": F64Div
                | _: F64Add
        | _: I32Add

Process called "get_constant_instruction" that takes value as Any and target_type as LIRType returns WasmInstruction:
    Note: Generate appropriate constant instruction based on type and value
    Match target_type with:
        | I32: I32Const with value as value as Integer
        | I64: I64Const with value as value as Integer
        | F32: F32Const with value as value as Float
        | F64: F64Const with value as value as Float
        | Bool: I32Const with value as (if value then 1 else 0)
        | _: I32Const with value as 0

Process called "get_function_index" that takes generator as WasmGenerator and function_name as String returns Integer:
    Note: Get the index of a function in the module - optimized O(1) lookup
    Note: Check imports first (they have lower indices)
    If generator.import_map contains function_name:
        Return generator.import_map[function_name]
    
    Note: Check local functions using optimized hash map
    If generator.function_name_map contains function_name:
        Let local_index be generator.function_name_map[function_name]
        Let base_index be generator.import_map.size
        Return base_index + local_index
    
    Note: Function not found, return invalid index with error logging
    Call log_function_resolution_error with function_name as function_name and available_functions as get_available_function_names with generator as generator
    Return -1

Process called "log_function_resolution_error" that takes function_name as String and available_functions as List[String]:
    Note: Log detailed error information for function resolution failures
    Let error_message be "Function '" + function_name + "' not found. Available functions: "
    For each i in range from 0 to available_functions.length:
        Set error_message to error_message + available_functions[i]
        If i < available_functions.length - 1:
            Set error_message to error_message + ", "
    
    Note: Output error to debug stream
    Call output_debug_message with message as error_message
    Call increment_error_count

Process called "get_available_function_names" that takes generator as WasmGenerator returns List[String]:
    Note: Get list of all available function names for error reporting
    Let available be empty list
    
    Note: Add imported function names
    For each import_name in generator.import_map.keys:
        Add import_name to available
    
    Note: Add local function names
    For each local_name in generator.function_name_map.keys:
        Add local_name to available
    
    Return available

Process called "output_debug_message" that takes message as String:
    Note: Output debug message to error stream
    Let debug_prefix be "[WASM_GEN_ERROR] "
    Let full_message be debug_prefix + message
    Call write_to_error_stream with text as full_message

Process called "increment_error_count":
    Note: Increment global error counter for compilation statistics
    Set global_compilation_error_count to global_compilation_error_count + 1

Process called "write_to_error_stream" that takes text as String:
    Note: Write text to standard error stream
    For each character in text:
        Call write_char_to_stderr with char as character
    Call write_char_to_stderr with char as "\n"

Process called "write_char_to_stderr" that takes char as String:
    Note: Write single character to stderr
    Note: This interfaces with the host environment's stderr
    Call host_stderr_write with byte as get_char_code with character as char

Process called "get_char_code" that takes character as String returns Integer:
    Note: Get ASCII/Unicode code point for character
    If character.length == 1:
        Return character.code_point
    Else:
        Return 63  Note: '?' for invalid characters

Process called "host_stderr_write" that takes byte as Integer:
    Note: Host interface for stderr writing
    Note: Implementation depends on runtime environment

Let global_compilation_error_count be 0

Process called "get_label_index" that takes generator as WasmGenerator and label as String returns Integer:
    Note: Get the index of a label for branching
    Note: In WebAssembly, labels are relative to the current block depth
    Let label_depth be 0
    For each block_label in generator.label_stack:
        If block_label == label:
            Return label_depth
        Set label_depth to label_depth + 1
    
    Note: Label not found in current scope
    Return 0

Process called "add_wasi_imports" that takes generator as WasmGenerator returns WasmGenerator:
    Note: Add WASI (WebAssembly System Interface) imports for server-side capabilities
    Let wasi_imports be [
        WasmImport with:
            module_name as "wasi_snapshot_preview1"
            field_name as "fd_write"
            import_type as Function with signature as WasmFunctionSignature with:
                parameters as [I32, I32, I32, I32]
                results as [I32],
        WasmImport with:
            module_name as "wasi_snapshot_preview1"
            field_name as "fd_read"
            import_type as Function with signature as WasmFunctionSignature with:
                parameters as [I32, I32, I32, I32]
                results as [I32],
        WasmImport with:
            module_name as "wasi_snapshot_preview1"
            field_name as "proc_exit"
            import_type as Function with signature as WasmFunctionSignature with:
                parameters as [I32]
                results as empty list
    ]
    
    Add all wasi_imports to generator.module.imports
    
    Note: Update import map for function resolution
    Set generator.import_map["fd_write"] to 0
    Set generator.import_map["fd_read"] to 1
    Set generator.import_map["proc_exit"] to 2
    
    Return generator

Process called "add_main_export" that takes generator as WasmGenerator and entry_point as String returns WasmGenerator:
    Note: Add main function export for executable modules
    Let main_export be WasmExport with:
        name as "_start"
        export_type as Function
        index as get_function_index with generator as generator and function_name as entry_point
    
    Add main_export to generator.module.exports
    Set generator.export_map["_start"] to main_export.index
    
    Return generator

Process called "finalize_wasm_sections" that takes generator as WasmGenerator returns WasmGenerator:
    Note: Build the final WebAssembly module sections
    Let module be generator.module
    
    Note: Type section - function signatures
    Let type_section be create_type_section with signatures as get_all_function_signatures with generator as generator
    Add type_section to module.sections
    
    Note: Import section
    If module.imports is not empty:
        Let import_section be create_import_section with imports as module.imports
        Add import_section to module.sections
    
    Note: Function section - function type indices
    Let function_section be create_function_section with functions as module.functions
    Add function_section to module.sections
    
    Note: Memory section
    Let memory_section be create_memory_section with memory as module.memory
    Add memory_section to module.sections
    
    Note: Export section
    If module.exports is not empty:
        Let export_section be create_export_section with exports as module.exports
        Add export_section to module.sections
    
    Note: Code section - function bodies
    Let code_section be create_code_section with functions as module.functions
    Add code_section to module.sections
    
    Return generator

Process called "get_all_function_signatures" that takes generator as WasmGenerator returns List[WasmFunctionSignature]:
    Note: Get all unique function signatures for the type section
    Let signatures be empty list
    For each signature in generator.function_signatures.values:
        If signature is not in signatures:
            Add signature to signatures
    Return signatures

Process called "create_type_section" that takes signatures as List[WasmFunctionSignature] returns WasmSection:
    Note: Create WebAssembly type section
    Let payload be empty list
    
    Note: Section contains count of types followed by type definitions
    Add signatures.length to payload
    
    For each signature in signatures:
        Add FUNCTION_TYPE_INDICATOR to payload  Note: Function type indicator
        Add signature.parameters.length to payload
        For each param_type in signature.parameters:
            Add encode_value_type with value_type as param_type to payload
        Add signature.results.length to payload
        For each result_type in signature.results:
            Add encode_value_type with value_type as result_type to payload
    
    Return WasmSection with:
        section_id as SECTION_ID_TYPE
        size as payload.length
        payload as payload

Process called "create_import_section" that takes imports as List[WasmImport] returns WasmSection:
    Note: Create WebAssembly import section
    Let payload be empty list
    
    Add imports.length to payload
    
    For each import in imports:
        Note: Module name
        Let module_name_bytes be encode_string with text as import.module_name
        Add all module_name_bytes to payload
        
        Note: Field name
        Let field_name_bytes be encode_string with text as import.field_name
        Add all field_name_bytes to payload
        
        Note: Import type
        Match import.import_type with:
            | Function with signature as sig:
                Add IMPORT_TYPE_FUNCTION to payload  Note: Function import
                Let type_index be find_type_index with signatures as get_all_function_signatures with generator as generator and signature as sig
                Add type_index to payload
            | Memory with limits as limits:
                Add IMPORT_TYPE_MEMORY to payload  Note: Memory import
                Add all encode_limits with limits as limits to payload
            | Table with element_type as elem_type and limits as limits:
                Add IMPORT_TYPE_TABLE to payload  Note: Table import
                Add encode_value_type with value_type as elem_type to payload
                Add all encode_limits with limits as limits to payload
            | Global with value_type as val_type and mutability as mut:
                Add IMPORT_TYPE_GLOBAL to payload  Note: Global import
                Add encode_value_type with value_type as val_type to payload
                Add (if mut then 1 else 0) to payload
    
    Return WasmSection with:
        section_id as SECTION_ID_IMPORT
        size as payload.length
        payload as payload

Process called "create_function_section" that takes functions as List[WasmFunction] returns WasmSection:
    Note: Create WebAssembly function section (type indices)
    Let payload be empty list
    
    Add functions.length to payload
    
    Let all_signatures be get_all_unique_signatures with functions as functions
    
    For each function in functions:
        Let type_index be find_signature_index with signatures as all_signatures and signature as function.signature
        Add type_index to payload
    
    Return WasmSection with:
        section_id as SECTION_ID_FUNCTION
        size as payload.length
        payload as payload

Process called "create_memory_section" that takes memory as WasmMemory returns WasmSection:
    Note: Create WebAssembly memory section
    Let payload be empty list
    
    Add 1 to payload  Note: One memory
    Add encode_limits with limits as memory.limits to payload
    
    Return WasmSection with:
        section_id as SECTION_ID_MEMORY
        size as payload.length
        payload as payload

Process called "create_export_section" that takes exports as List[WasmExport] returns WasmSection:
    Note: Create WebAssembly export section
    Let payload be empty list
    
    Add exports.length to payload
    
    For each export in exports:
        Note: Export name
        Let name_bytes be encode_string with text as export.name
        Add all name_bytes to payload
        
        Note: Export type
        Match export.export_type with:
            | Function: Add IMPORT_TYPE_FUNCTION to payload
            | Memory: Add IMPORT_TYPE_MEMORY to payload
            | _: Add IMPORT_TYPE_FUNCTION to payload
        
        Note: Export index
        Add export.index to payload
    
    Return WasmSection with:
        section_id as SECTION_ID_EXPORT
        size as payload.length
        payload as payload

Process called "create_code_section" that takes functions as List[WasmFunction] returns WasmSection:
    Note: Create WebAssembly code section (function bodies)
    Let payload be empty list
    
    Add functions.length to payload
    
    For each function in functions:
        Let function_body be encode_function_body with function as function
        Add function_body.length to payload
        Add all function_body to payload
    
    Return WasmSection with:
        section_id as SECTION_ID_CODE
        size as payload.length
        payload as payload

Process called "encode_function_body" that takes function as WasmFunction returns List[Integer]:
    Note: Encode a single function body
    Let body be empty list
    
    Note: Local declarations
    Add function.locals.length to body
    For each local_type in function.locals:
        Add 1 to body  Note: Count of this local type
        Add encode_value_type with value_type as local_type to body
    
    Note: Function instructions
    For each instruction in function.body:
        Let encoded_instruction be encode_instruction with instruction as instruction
        Add all encoded_instruction to body
    
    Return body

Process called "encode_instruction" that takes instruction as WasmInstruction returns List[Integer]:
    Note: Encode WebAssembly instruction to bytecode
    Match instruction with:
        | Unreachable: [0x00]
        | Nop: [0x01]
        | Block with result_type as rt: [0x02, encode_value_type with value_type as rt]
        | Loop with result_type as rt: [0x03, encode_value_type with value_type as rt]
        | If with result_type as rt: [0x04, encode_value_type with value_type as rt]
        | Else: [0x05]
        | End: [0x0B]
        | Br with label_index as idx: [0x0C, idx]
        | BrIf with label_index as idx: [0x0D, idx]
        | Return: [0x0F]
        | Call with function_index as idx: [0x10, idx]
        | Drop: [0x1A]
        | Select: [0x1B]
        | LocalGet with local_index as idx: [0x20, idx]
        | LocalSet with local_index as idx: [0x21, idx]
        | LocalTee with local_index as idx: [0x22, idx]
        | GlobalGet with global_index as idx: [0x23, idx]
        | GlobalSet with global_index as idx: [0x24, idx]
        | I32Load with offset as off and align as align: [0x28, align, off]
        | I32Store with offset as off and align as align: [0x36, align, off]
        | MemorySize: [0x3F, 0x00]
        | MemoryGrow: [0x40, 0x00]
        | I32Const with value as val: [0x41] + encode_i32 with value as val
        | I64Const with value as val: [0x42] + encode_i64 with value as val
        | F32Const with value as val: [0x43] + encode_f32 with value as val
        | F64Const with value as val: [0x44] + encode_f64 with value as val
        | I32Eqz: [0x45]
        | I32Eq: [0x46]
        | I32Ne: [0x47]
        | I32Add: [0x6A]
        | I32Sub: [0x6B]
        | I32Mul: [0x6C]
        | I32DivS: [0x6D]
        | I64Add: [0x7C]
        | I64Sub: [0x7D]
        | I64Mul: [0x7E]
        | I64DivS: [0x7F]
        | F32Add: [0x92]
        | F32Sub: [0x93]
        | F32Mul: [0x94]
        | F32Div: [0x95]
        | F64Add: [0xA0]
        | F64Sub: [0xA1]
        | F64Mul: [0xA2]
        | F64Div: [0xA3]
        | _: [0x01]  Note: Default to NOP for unsupported instructions

Process called "encode_value_type" that takes value_type as WasmValueType returns Integer:
    Note: Encode WebAssembly value type
    Match value_type with:
        | I32: WASM_TYPE_I32
        | I64: WASM_TYPE_I64
        | F32: WASM_TYPE_F32
        | F64: WASM_TYPE_F64
        | V128: WASM_TYPE_V128

Process called "encode_string" that takes text as String returns List[Integer]:
    Note: Encode string with length prefix
    Let bytes be convert_string_to_bytes with text as text
    Return [bytes.length] + bytes

Process called "encode_limits" that takes limits as WasmLimits returns List[Integer]:
    Note: Encode WebAssembly limits
    If limits.max is null:
        Return [LIMITS_NO_MAX, limits.min]  Note: No maximum
    Else:
        Return [LIMITS_WITH_MAX, limits.min, limits.max]  Note: With maximum

Process called "encode_i32" that takes value as Integer returns List[Integer]:
    Note: Encode 32-bit integer as LEB128
    Return encode_leb128 with value as value

Process called "encode_i64" that takes value as Integer returns List[Integer]:
    Note: Encode 64-bit integer as LEB128
    Return encode_leb128 with value as value

Process called "encode_f32" that takes value as Float returns List[Integer]:
    Note: Encode 32-bit float as IEEE 754
    Return encode_ieee754_32 with value as value

Process called "encode_f64" that takes value as Float returns List[Integer]:
    Note: Encode 64-bit float as IEEE 754
    Return encode_ieee754_64 with value as value

Process called "encode_leb128" that takes value as Integer returns List[Integer]:
    Note: Encode integer using LEB128 variable-length encoding
    Let result be empty list
    Let remaining be value
    
    While remaining is not 0:
        Let byte be remaining & 0x7F
        Set remaining to remaining >> 7
        
        If remaining is not 0:
            Set byte to byte | 0x80
        
        Add byte to result
    
    If result is empty:
        Return [0]
    
    Return result

Process called "encode_ieee754_32" that takes value as Float returns List[Integer]:
    Note: Encode 32-bit float as IEEE 754
    If value == 0.0:
        Return [0, 0, 0, 0]
    
    Let sign_bit be if value < 0.0 then 1 else 0
    Let abs_value be if value < 0.0 then -value else value
    
    Note: Handle special cases
    If abs_value == Float.INFINITY:
        Return [0, 0, 0x80, 0x7F] if sign_bit == 0 else [0, 0, 0x80, 0xFF]
    
    If abs_value != abs_value:  Note: NaN check
        Return [0, 0, 0xC0, 0x7F]
    
    Note: Normalize the value
    Let exponent be 0
    Let mantissa be abs_value
    
    While mantissa >= 2.0:
        Set mantissa to mantissa / 2.0
        Set exponent to exponent + 1
    
    While mantissa < 1.0 and mantissa != 0.0:
        Set mantissa to mantissa * 2.0
        Set exponent to exponent - 1
    
    Note: Adjust for IEEE 754 bias
    Set exponent to exponent + 127
    
    Note: Extract mantissa bits (23 bits)
    Set mantissa to mantissa - 1.0  Note: Remove implicit 1
    Let mantissa_bits be mantissa * (2^23)
    Let mantissa_int be mantissa_bits as Integer
    
    Note: Construct IEEE 754 representation
    Let ieee_bits be (sign_bit << 31) | (exponent << 23) | mantissa_int
    
    Return [
        ieee_bits & 0xFF,
        (ieee_bits >> 8) & 0xFF,
        (ieee_bits >> 16) & 0xFF,
        (ieee_bits >> 24) & 0xFF
    ]

Process called "encode_ieee754_64" that takes value as Float returns List[Integer]:
    Note: Encode 64-bit float as IEEE 754
    If value == 0.0:
        Return [0, 0, 0, 0, 0, 0, 0, 0]
    
    Let sign_bit be if value < 0.0 then 1 else 0
    Let abs_value be if value < 0.0 then -value else value
    
    Note: Handle special cases
    If abs_value == Float.INFINITY:
        Return [0, 0, 0, 0, 0, 0, 0xF0, 0x7F] if sign_bit == 0 else [0, 0, 0, 0, 0, 0, 0xF0, 0xFF]
    
    If abs_value != abs_value:  Note: NaN check
        Return [0, 0, 0, 0, 0, 0, 0xF8, 0x7F]
    
    Note: Normalize the value
    Let exponent be 0
    Let mantissa be abs_value
    
    While mantissa >= 2.0:
        Set mantissa to mantissa / 2.0
        Set exponent to exponent + 1
    
    While mantissa < 1.0 and mantissa != 0.0:
        Set mantissa to mantissa * 2.0
        Set exponent to exponent - 1
    
    Note: Adjust for IEEE 754 bias (1023 for double)
    Set exponent to exponent + 1023
    
    Note: Extract mantissa bits (52 bits)
    Set mantissa to mantissa - 1.0  Note: Remove implicit 1
    Let mantissa_high be (mantissa * (2^20)) as Integer
    Let mantissa_low be ((mantissa * (2^52)) - (mantissa_high * (2^32))) as Integer
    
    Note: Construct IEEE 754 representation
    Let high_word be (sign_bit << 31) | (exponent << 20) | mantissa_high
    Let low_word be mantissa_low
    
    Return [
        low_word & 0xFF,
        (low_word >> 8) & 0xFF,
        (low_word >> 16) & 0xFF,
        (low_word >> 24) & 0xFF,
        high_word & 0xFF,
        (high_word >> 8) & 0xFF,
        (high_word >> 16) & 0xFF,
        (high_word >> 24) & 0xFF
    ]

Process called "convert_string_to_bytes" that takes text as String returns List[Integer]:
    Note: Convert string to UTF-8 byte array
    Let bytes be empty list
    
    For each character in text:
        Let code_point be character.code
        
        Note: UTF-8 encoding based on Unicode code point
        If code_point <= 0x7F:
            Note: ASCII range (0-127)
            Add code_point to bytes
        
        Else If code_point <= 0x7FF:
            Note: 2-byte sequence (128-2047)
            Add (0xC0 | (code_point >> 6)) to bytes
            Add (0x80 | (code_point & 0x3F)) to bytes
        
        Else If code_point <= 0xFFFF:
            Note: 3-byte sequence (2048-65535)
            Add (0xE0 | (code_point >> 12)) to bytes
            Add (0x80 | ((code_point >> 6) & 0x3F)) to bytes
            Add (0x80 | (code_point & 0x3F)) to bytes
        
        Else:
            Note: 4-byte sequence (65536 and above)
            Add (0xF0 | (code_point >> 18)) to bytes
            Add (0x80 | ((code_point >> 12) & 0x3F)) to bytes
            Add (0x80 | ((code_point >> 6) & 0x3F)) to bytes
            Add (0x80 | (code_point & 0x3F)) to bytes
    
    Return bytes

Process called "serialize_wasm_module" that takes module as WasmModule returns List[Integer]:
    Note: Serialize complete WebAssembly module to binary format
    Let binary be empty list
    
    Note: Magic number and version
    Add all module.magic to binary
    Add all module.version to binary
    
    Note: All sections in order
    For each section in module.sections:
        Add section.section_id to binary
        Add section.size to binary
        Add all section.payload to binary
    
    Return binary

Process called "find_type_index" that takes signatures as List[WasmFunctionSignature] and signature as WasmFunctionSignature returns Integer:
    Note: Find the index of a function signature in the type list
    For each index in range from 0 to signatures.length:
        If signatures_match with sig1 as signatures[index] and sig2 as signature:
            Return index
    
    Note: Signature not found
    Return 0

Process called "signatures_match" that takes sig1 as WasmFunctionSignature and sig2 as WasmFunctionSignature returns Boolean:
    Note: Check if two function signatures match
    If sig1.parameters.length != sig2.parameters.length:
        Return false
    
    If sig1.results.length != sig2.results.length:
        Return false
    
    For each i in range from 0 to sig1.parameters.length:
        If sig1.parameters[i] != sig2.parameters[i]:
            Return false
    
    For each i in range from 0 to sig1.results.length:
        If sig1.results[i] != sig2.results[i]:
            Return false
    
    Return true

Process called "get_all_unique_signatures" that takes functions as List[WasmFunction] returns List[WasmFunctionSignature]:
    Note: Get all unique function signatures
    Let signatures be empty list
    
    For each function in functions:
        Let found be false
        For each existing_sig in signatures:
            If signatures_match with sig1 as existing_sig and sig2 as function.signature:
                Set found to true
                Break
        
        If not found:
            Add function.signature to signatures
    
    Return signatures

Process called "find_signature_index" that takes signatures as List[WasmFunctionSignature] and signature as WasmFunctionSignature returns Integer:
    Note: Find the index of a signature in the list
    For each index in range from 0 to signatures.length:
        If signatures_match with sig1 as signatures[index] and sig2 as signature:
            Return index
    
    Return 0