Note:
Runa Semantic Validator: Language Rule Enforcement

This module implements comprehensive semantic validation for Runa with:
- Variable usage before declaration checking
- Function call argument validation
- Import resolution validation
- Circular dependency detection
- Scope rule validation
- Semantic error reporting with suggestions
:End Note

Note: Import dependencies
Import "ast.runa"
Import "symbol_table.runa"
Import "type_checker.runa"
Import "diagnostics.runa"

Note: Semantic Validator Core Type
Type SemanticValidator is Dictionary with:
    Private symbol_table as SymbolTable
    Private type_checker as TypeChecker
    Private validation_rules as List[ValidationRule]
    Private error_collector as ErrorCollector
    Private warning_collector as WarningCollector
    Private performance_metrics as Dictionary[String, Any]
    
    analyzer as SemanticAnalyzer

Type ValidationRule is Dictionary with:
    name as String
    description as String
    severity as String  Note: "error", "warning", "info"
    validator as String  Note: Function name to call
    enabled as Boolean

Type ErrorCollector is Dictionary with:
    errors as List[SemanticError]
    max_errors as Integer
    error_count as Integer

Type WarningCollector is Dictionary with:
    warnings as List[SemanticWarning]
    max_warnings as Integer
    warning_count as Integer

Type SemanticError is Dictionary with:
    message as String
    location as SourceLocation
    code as String
    suggestions as List[String]
    severity as String

Type SemanticWarning is Dictionary with:
    message as String
    location as SourceLocation
    code as String
    suggestions as List[String]
    severity as String

Note: Semantic Validator Creation
Process called "create_semantic_validator" that takes symbol_table as SymbolTable returns SemanticValidator:
    Note: Create a new semantic validator with all validation rules
    Let type_checker be None  Note: Will be set by semantic analyzer
    Let validation_rules be create_validation_rules
    Let error_collector be create_error_collector
    Let warning_collector be create_warning_collector
    
    Let performance_metrics be dictionary containing:
        "validations" as 0
        "rule_checks" as 0
        "error_collections" as 0
        "warning_collections" as 0
    
    Return SemanticValidator with:
        symbol_table as symbol_table
        type_checker as type_checker
        validation_rules as validation_rules
        error_collector as error_collector
        warning_collector as warning_collector
        performance_metrics as performance_metrics
        analyzer as None  Note: Will be set by semantic analyzer

Note: Validation Rules Creation
Process called "create_validation_rules" returns List[ValidationRule]:
    Note: Create all semantic validation rules
    Return list containing:
        ValidationRule with:
            name as "Variable Usage Before Declaration"
            description as "Check that variables are declared before use"
            severity as "error"
            validator as "validate_variable_usage"
            enabled as true
        ValidationRule with:
            name as "Function Call Argument Validation"
            description as "Validate function call arguments match signature"
            severity as "error"
            validator as "validate_function_calls"
            enabled as true
        ValidationRule with:
            name as "Import Resolution"
            description as "Validate that imported symbols exist"
            severity as "error"
            validator as "validate_imports"
            enabled as true
        ValidationRule with:
            name as "Circular Dependency Detection"
            description as "Detect circular dependencies between modules"
            severity as "error"
            validator as "detect_circular_dependencies"
            enabled as true
        ValidationRule with:
            name as "Scope Rule Validation"
            description as "Validate scope rules and variable shadowing"
            severity as "warning"
            validator as "validate_scope_rules"
            enabled as true
        ValidationRule with:
            name as "Unused Variable Detection"
            description as "Detect unused variables and parameters"
            severity as "warning"
            validator as "detect_unused_variables"
            enabled as true
        ValidationRule with:
            name as "Return Statement Validation"
            description as "Validate return statements in functions"
            severity as "error"
            validator as "validate_return_statements"
            enabled as true
        ValidationRule with:
            name as "Type Annotation Consistency"
            description as "Check type annotation consistency"
            severity as "warning"
            validator as "validate_type_annotations"
            enabled as true

Note: Error Collector Creation
Process called "create_error_collector" returns ErrorCollector:
    Note: Create error collector
    Return ErrorCollector with:
        errors as list containing
        max_errors as 100
        error_count as 0

Note: Warning Collector Creation
Process called "create_warning_collector" returns WarningCollector:
    Note: Create warning collector
    Return WarningCollector with:
        warnings as list containing
        max_warnings as 200
        warning_count as 0

Note: Main Validation API
Process called "validate_semantics" that takes validator as SemanticValidator and ast as ASTNode returns Dictionary[String, Any]:
    Note: Perform comprehensive semantic validation
    Let start_time be get_current_time_ms
    
    Note: Clear previous results
    Set validator.error_collector.errors to list containing
    Set validator.warning_collector.warnings to list containing
    Set validator.error_collector.error_count to 0
    Set validator.warning_collector.warning_count to 0
    
    Note: Run all enabled validation rules
    For each rule in validator.validation_rules:
        If rule.enabled:
            Set validator.performance_metrics.rule_checks to validator.performance_metrics.rule_checks plus 1
            Call validation_rule with validator as validator and rule as rule and ast as ast
    
    Set validator.performance_metrics.validations to validator.performance_metrics.validations plus 1
    
    Return dictionary containing:
        "success" as validator.error_collector.error_count is equal to 0
        "errors" as validator.error_collector.errors
        "warnings" as validator.warning_collector.warnings
        "error_count" as validator.error_collector.error_count
        "warning_count" as validator.warning_collector.warning_count

Note: Validation Rule Execution
Process called "validation_rule" that takes validator as SemanticValidator and rule as ValidationRule and ast as ASTNode:
    Note: Execute a specific validation rule
    Match rule.validator:
        When "validate_variable_usage":
            Call validate_variable_usage with validator as validator and ast as ast
        When "validate_function_calls":
            Call validate_function_calls with validator as validator and ast as ast
        When "validate_imports":
            Call validate_imports with validator as validator and ast as ast
        When "detect_circular_dependencies":
            Call detect_circular_dependencies with validator as validator and ast as ast
        When "validate_scope_rules":
            Call validate_scope_rules with validator as validator and ast as ast
        When "detect_unused_variables":
            Call detect_unused_variables with validator as validator and ast as ast
        When "validate_return_statements":
            Call validate_return_statements with validator as validator and ast as ast
        When "validate_type_annotations":
            Call validate_type_annotations with validator as validator and ast as ast
        Otherwise:
            Note: Unknown validation rule

Note: Variable Usage Validation
Process called "validate_variable_usage" that takes validator as SemanticValidator and ast as ASTNode:
    Note: Check that variables are declared before use
    Let visitor be create_variable_usage_visitor with validator as validator
    Call visit_ast with visitor as visitor and node as ast

Note: Variable Usage Visitor Creation
Process called "create_variable_usage_visitor" that takes validator as SemanticValidator returns ASTVisitor:
    Note: Create visitor for variable usage validation
    Return ASTVisitor with:
        visit_identifier as process that takes node as ASTNode:
            Let symbol be resolve_symbol with table as validator.symbol_table and name as node.value
            If symbol is None:
                Let error be SemanticError with:
                    message as "Undefined variable: " plus node.value
                    location as node.location
                    code as "UNDEFINED_VARIABLE"
                    suggestions as list containing "Declare the variable before use" and "Check for typos in variable name"
                    severity as "error"
                Call add_semantic_error with validator as validator and error as error
            Otherwise:
                Call add_symbol_usage with table as validator.symbol_table and symbol as symbol and location as node.location

Note: Function Call Validation
Process called "validate_function_calls" that takes validator as SemanticValidator and ast as ASTNode:
    Note: Validate function call arguments
    Let visitor be create_function_call_visitor with validator as validator
    Call visit_ast with visitor as visitor and node as ast

Note: Function Call Visitor Creation
Process called "create_function_call_visitor" that takes validator as SemanticValidator returns ASTVisitor:
    Note: Create visitor for function call validation
    Return ASTVisitor with:
        visit_function_call as process that takes node as ASTNode:
            Let function_symbol be resolve_symbol with table as validator.symbol_table and name as node.function.value
            If function_symbol is None:
                Let error be SemanticError with:
                    message as "Undefined function: " plus node.function.value
                    location as node.location
                    code as "UNDEFINED_FUNCTION"
                    suggestions as list containing "Define the function before calling it" and "Check for typos in function name"
                    severity as "error"
                Call add_semantic_error with validator as validator and error as error
            Otherwise:
                Note: Validate argument count and types
                Let validation_result be validate_function_arguments with validator as validator and function_symbol as function_symbol and arguments as node.arguments
                If not validation_result.success:
                    Call add_semantic_error with validator as validator and error as validation_result.error

Note: Function Argument Validation
Process called "validate_function_arguments" that takes validator as SemanticValidator and function_symbol as Symbol and arguments as List[ASTNode] returns Dictionary[String, Any]:
    Note: Validate function call arguments
    If function_symbol.kind is not equal to "function":
        Return dictionary containing "success" as false and "error" as SemanticError with:
            message as "Cannot call non-function: " plus function_symbol.name
            location as SourceLocation with file_path as "" and line as 1 and column as 1
            code as "NOT_A_FUNCTION"
            suggestions as list containing "Use a function name instead"
            severity as "error"
    
    Note: Get function signature from symbol metadata
    Let signature be function_symbol.metadata at key "signature"
    If signature is None:
        Return dictionary containing "success" as true  Note: Built-in function
    
    Let expected_params be signature.parameters
    Let actual_args be length of arguments
    
    If actual_args is not equal to length of expected_params:
        Return dictionary containing "success" as false and "error" as SemanticError with:
            message as "Function " plus function_symbol.name plus " expects " plus length of expected_params plus " arguments but got " plus actual_args
            location as SourceLocation with file_path as "" and line as 1 and column as 1
            code as "ARGUMENT_COUNT_MISMATCH"
            suggestions as list containing "Check the function signature" and "Add or remove arguments as needed"
            severity as "error"
    
    Note: Validate argument types
    For i from 0 to length of arguments minus 1:
        Let arg be arguments at index i
        Let expected_type be expected_params at index i
        Let arg_type_result be check_type with checker as validator.type_checker and expression as arg
        If arg_type_result.success:
            Let compatibility_result be check_type_compatibility with checker as validator.type_checker and expected as expected_type and actual as arg_type_result.type
            If not compatibility_result.success:
                Return dictionary containing "success" as false and "error" as SemanticError with:
                    message as "Argument " plus (i plus 1) plus " type mismatch: expected " plus expected_type.name plus " but got " plus arg_type_result.type.name
                    location as arg.location
                    code as "ARGUMENT_TYPE_MISMATCH"
                    suggestions as list containing "Check argument types" and "Convert argument to expected type"
                    severity as "error"
    
    Return dictionary containing "success" as true

Note: Import Validation
Process called "validate_imports" that takes validator as SemanticValidator and ast as ASTNode:
    Note: Validate import statements
    Let visitor be create_import_visitor with validator as validator
    Call visit_ast with visitor as visitor and node as ast

Note: Import Visitor Creation
Process called "create_import_visitor" that takes validator as SemanticValidator returns ASTVisitor:
    Note: Create visitor for import validation
    Return ASTVisitor with:
        visit_import_statement as process that takes node as ASTNode:
            Let module_name be node.module_name
            Let imported_symbols be node.imported_symbols
            
            Note: Check if module exists
            If module_name is not in validator.symbol_table.imported_modules:
                Let error be SemanticError with:
                    message as "Module not found: " plus module_name
                    location as node.location
                    code as "MODULE_NOT_FOUND"
                    suggestions as list containing "Check module path" and "Ensure module exists"
                    severity as "error"
                Call add_semantic_error with validator as validator and error as error
            Otherwise:
                Note: Check if imported symbols exist in module
                Let module_info be validator.symbol_table.imported_modules at key module_name
                For each symbol_name in imported_symbols:
                    If symbol_name is not in module_info.symbols:
                        Let error be SemanticError with:
                            message as "Symbol " plus symbol_name plus " not found in module " plus module_name
                            location as node.location
                            code as "SYMBOL_NOT_FOUND"
                            suggestions as list containing "Check symbol name" and "Check if symbol is exported"
                            severity as "error"
                        Call add_semantic_error with validator as validator and error as error

Note: Circular Dependency Detection
Process called "detect_circular_dependencies" that takes validator as SemanticValidator and ast as ASTNode:
    Note: Detect circular dependencies between modules
    Let dependency_graph be build_dependency_graph with validator as validator
    Let cycles be find_cycles with graph as dependency_graph
    
    For each cycle in cycles:
        Let error be SemanticError with:
            message as "Circular dependency detected: " plus join_cycle_path with cycle as cycle
            location as SourceLocation with file_path as "" and line as 1 and column as 1
            code as "CIRCULAR_DEPENDENCY"
            suggestions as list containing "Restructure code to remove circular dependency" and "Use forward declarations"
            severity as "error"
        Call add_semantic_error with validator as validator and error as error

Note: Scope Rule Validation
Process called "validate_scope_rules" that takes validator as SemanticValidator and ast as ASTNode:
    Note: Validate scope rules and variable shadowing
    Let visitor be create_scope_visitor with validator as validator
    Call visit_ast with visitor as visitor and node as ast

Note: Unused Variable Detection
Process called "detect_unused_variables" that takes validator as SemanticValidator and ast as ASTNode:
    Note: Detect unused variables and parameters
    Let all_symbols be get_all_symbols with table as validator.symbol_table
    
    For each symbol in all_symbols:
        If symbol.kind is equal to "variable" and length of symbol.usage_locations is equal to 0:
            Let warning be SemanticWarning with:
                message as "Unused variable: " plus symbol.name
                location as symbol.declaration_location
                code as "UNUSED_VARIABLE"
                suggestions as list containing "Remove unused variable" and "Use the variable or prefix with underscore"
                severity as "warning"
            Call add_semantic_warning with validator as validator and warning as warning

Note: Return Statement Validation
Process called "validate_return_statements" that takes validator as SemanticValidator and ast as ASTNode:
    Note: Validate return statements in functions
    Let visitor be create_return_visitor with validator as validator
    Call visit_ast with visitor as visitor and node as ast

Note: Type Annotation Validation
Process called "validate_type_annotations" that takes validator as SemanticValidator and ast as ASTNode:
    Note: Check type annotation consistency
    Let visitor be create_type_annotation_visitor with validator as validator
    Call visit_ast with visitor as visitor and node as ast

Note: Error and Warning Collection
Process called "add_semantic_error" that takes validator as SemanticValidator and error as SemanticError:
    Note: Add semantic error to collector
    If validator.error_collector.error_count is less than validator.error_collector.max_errors:
        Add error to validator.error_collector.errors
        Set validator.error_collector.error_count to validator.error_collector.error_count plus 1
        Set validator.performance_metrics.error_collections to validator.performance_metrics.error_collections plus 1

Process called "add_semantic_warning" that takes validator as SemanticValidator and warning as SemanticWarning:
    Note: Add semantic warning to collector
    If validator.warning_collector.warning_count is less than validator.warning_collector.max_warnings:
        Add warning to validator.warning_collector.warnings
        Set validator.warning_collector.warning_count to validator.warning_collector.warning_count plus 1
        Set validator.performance_metrics.warning_collections to validator.performance_metrics.warning_collections plus 1

Note: Utility Functions
Process called "build_dependency_graph" that takes validator as SemanticValidator returns Dictionary[String, List[String]]:
    Note: Build dependency graph from imported modules
    Let graph be dictionary containing
    
    For each module_name in validator.symbol_table.imported_modules:
        Let module_info be validator.symbol_table.imported_modules at key module_name
        Set graph at key module_name to module_info.dependencies
    
    Return graph

Process called "find_cycles" that takes graph as Dictionary[String, List[String]] returns List[List[String]]:
    Note: Find cycles in dependency graph using DFS
    Let cycles be list containing
    Let visited be set containing
    Let recursion_stack be set containing
    
    Let dfs be process that takes node as String and path as List[String]:
        If node is in recursion_stack:
            Let cycle_start be index_of with list as path and item as node
            Let cycle be path from index cycle_start to end
            Add cycle to cycles
            Return
        
        If node is in visited:
            Return
        
        Add node to visited
        Add node to recursion_stack
        Add node to path
        
        If node is in graph:
            For each neighbor in graph at key node:
                Call dfs with node as neighbor and path as path
        
        Remove node from recursion_stack
        Remove last item from path
    
    For each node in graph:
        If node is not in visited:
            Call dfs with node as node and path as list containing
    
    Return cycles

Process called "join_cycle_path" that takes cycle as List[String] returns String:
    Note: Join cycle path for error message
    Let result be ""
    For i from 0 to length of cycle minus 1:
        If i is greater than 0:
            Set result to result plus " -> "
        Set result to result plus (cycle at index i)
    Return result

Process called "get_all_symbols" that takes table as SymbolTable returns List[Symbol]:
    Note: Get all symbols from symbol table
    Let symbols be list containing
    Let all_scopes be get_all_scopes with table as table
    
    For each scope in all_scopes:
        For each symbol_name in scope.symbols:
            Add scope.symbols at key symbol_name to symbols
    
    Return symbols

Process called "get_semantic_validator_performance_metrics" that takes validator as SemanticValidator returns Dictionary[String, Any]:
    Note: Get performance metrics from semantic validator
    Return validator.performance_metrics 