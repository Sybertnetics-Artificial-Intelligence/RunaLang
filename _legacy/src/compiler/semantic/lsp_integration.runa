Note:
Runa LSP Integration: Real-time IDE Support

This module provides comprehensive LSP integration for Runa with:
- Autocompletion with context-aware suggestions
- Hover information with type details
- Go to definition and find all references
- Document symbols for outline view
- Real-time diagnostics and error reporting
- Incremental analysis support
:End Note

Note: Import dependencies
Import "ast.runa"
Import "symbol_table.runa"
Import "type_checker.runa"
Import "validation.runa"
Import "diagnostics.runa"

Note: LSP Integration Core Types
Type LSPIntegration is Dictionary with:
    Private analyzer as SemanticAnalyzer
    Private completion_cache as Dictionary[String, List[CompletionItem]]
    Private hover_cache as Dictionary[String, HoverInfo]
    Private symbol_cache as Dictionary[String, List[Symbol]]
    Private performance_metrics as Dictionary[String, Any]
    Private incremental_mode as Boolean
    Private changed_ranges as List[Range]

Type CompletionItem is Dictionary with:
    label as String
    kind as String  Note: "variable", "function", "keyword", "type", "module"
    detail as String  Note: Type information or description
    documentation as String  Note: Detailed documentation
    insert_text as String  Note: Text to insert
    sort_text as String  Note: For sorting suggestions
    filter_text as String  Note: For filtering
    commit_characters as List[String]  Note: Characters that commit the completion
    command as Optional[Command]  Note: Command to execute after insertion

Type HoverInfo is Dictionary with:
    contents as String  Note: Markdown formatted content
    range as Optional[Range]  Note: Range this hover applies to

Type Range is Dictionary with:
    start as Position
    end as Position

Type Position is Dictionary with:
    line as Integer
    character as Integer

Type Command is Dictionary with:
    title as String
    command as String
    arguments as List[Any]

Type SymbolInformation is Dictionary with:
    name as String
    kind as String
    location as Location
    container_name as Optional[String]

Type Location is Dictionary with:
    uri as String
    range as Range

Note: LSP Integration Creation
Process called "create_lsp_integration" that takes analyzer as SemanticAnalyzer returns LSPIntegration:
    Note: Create new LSP integration instance
    Let completion_cache be dictionary containing
    Let hover_cache be dictionary containing
    Let symbol_cache be dictionary containing
    
    Let performance_metrics be dictionary containing:
        "completion_requests" as 0
        "hover_requests" as 0
        "definition_requests" as 0
        "reference_requests" as 0
        "symbol_requests" as 0
        "cache_hits" as 0
        "cache_misses" as 0
    
    Return LSPIntegration with:
        analyzer as analyzer
        completion_cache as completion_cache
        hover_cache as hover_cache
        symbol_cache as symbol_cache
        performance_metrics as performance_metrics
        incremental_mode as false
        changed_ranges as list containing

Note: Autocompletion API
Process called "get_completion_items" that takes integration as LSPIntegration and position as SourceLocation returns List[CompletionItem]:
    Note: Get autocompletion items for a position
    Set integration.performance_metrics.completion_requests to integration.performance_metrics.completion_requests plus 1
    
    Let cache_key be create_completion_cache_key with position as position
    If cache_key is in integration.completion_cache:
        Set integration.performance_metrics.cache_hits to integration.performance_metrics.cache_hits plus 1
        Return integration.completion_cache at key cache_key
    
    Set integration.performance_metrics.cache_misses to integration.performance_metrics.cache_misses plus 1
    
    Note: Get completion items based on context
    Let completion_items be get_context_completion_items with integration as integration and position as position
    
    Note: Cache results
    Set integration.completion_cache at key cache_key to completion_items
    
    Return completion_items

Note: Context-Aware Completion
Process called "get_context_completion_items" that takes integration as LSPIntegration and position as SourceLocation returns List[CompletionItem]:
    Note: Get completion items based on context at position
    Let items be list containing
    
    Note: Get current scope and context
    Let current_scope be integration.analyzer.current_scope
    Let context be analyze_completion_context with integration as integration and position as position
    
    Note: Add symbols from current scope and parent scopes
    Let scope_symbols be get_scope_completion_symbols with integration as integration and scope as current_scope
    Add all items from scope_symbols to items
    
    Note: Add built-in keywords and functions
    Let built_in_items be get_built_in_completion_items with integration as integration and context as context
    Add all items from built_in_items to items
    
    Note: Add imported symbols
    Let imported_items be get_imported_completion_items with integration as integration and context as context
    Add all items from imported_items to items
    
    Note: Filter and sort based on context
    Let filtered_items be filter_completion_items with items as items and context as context
    
    Return filtered_items

Note: Completion Context Analysis
Process called "analyze_completion_context" that takes integration as LSPIntegration and position as SourceLocation returns Dictionary[String, Any]:
    Note: Analyze the context around the completion position
    Let context be dictionary containing:
        "trigger_character" as ""
        "line_prefix" as ""
        "line_suffix" as ""
        "word_prefix" as ""
        "scope_kind" as "global"
        "expected_type" as None
    
    Note: Get source code around position
    Let source_code be integration.analyzer.ast.source_code
    Let line_content be get_line_content with source_code as source_code and line as position.line
    
    If line_content is not None:
        Set context.line_prefix to line_content from index 0 to position.column
        Set context.line_suffix to line_content from index position.column to end
        Set context.word_prefix to extract_word_prefix with line_prefix as context.line_prefix
    
    Note: Determine scope kind
    Let current_scope be integration.analyzer.current_scope
    Set context.scope_kind to current_scope.kind
    
    Note: Determine expected type from context
    Let expected_type be infer_expected_type with integration as integration and context as context
    Set context.expected_type to expected_type
    
    Return context

Note: Scope Completion Symbols
Process called "get_scope_completion_symbols" that takes integration as LSPIntegration and scope as Scope returns List[CompletionItem]:
    Note: Get completion items from a scope
    Let items be list containing
    
    For each symbol_name in scope.symbols:
        Let symbol be scope.symbols at key symbol_name
        Let item be create_completion_item_from_symbol with symbol as symbol
        Add item to items
    
    Return items

Note: Built-in Completion Items
Process called "get_built_in_completion_items" that takes integration as LSPIntegration and context as Dictionary[String, Any] returns List[CompletionItem]:
    Note: Get built-in completion items
    Let items be list containing
    
    Note: Add keywords based on context
    Let keywords be get_context_keywords with context as context
    For each keyword in keywords:
        Let item be CompletionItem with:
            label as keyword
            kind as "keyword"
            detail as "Keyword"
            documentation as "Runa language keyword"
            insert_text as keyword
            sort_text as "0_" plus keyword
            filter_text as keyword
            commit_characters as list containing " " and "\t" and "\n"
            command as None
        Add item to items
    
    Note: Add built-in functions
    Let built_in_functions be list containing "Display", "Return", "Let", "Process", "If", "Otherwise"
    For each func_name in built_in_functions:
        Let item be CompletionItem with:
            label as func_name
            kind as "function"
            detail as "Built-in function"
            documentation as "Built-in Runa function"
            insert_text as func_name
            sort_text as "1_" plus func_name
            filter_text as func_name
            commit_characters as list containing "(" and " "
            command as None
        Add item to items
    
    Return items

Note: Imported Completion Items
Process called "get_imported_completion_items" that takes integration as LSPIntegration and context as Dictionary[String, Any] returns List[CompletionItem]:
    Note: Get completion items from imported modules
    Let items be list containing
    
    For each module_name in integration.analyzer.symbol_table.imported_modules:
        Let module_info be integration.analyzer.symbol_table.imported_modules at key module_name
        For each symbol_name in module_info.symbols:
            Let symbol be module_info.symbols at key symbol_name
            If symbol.is_exported:
                Let item be create_completion_item_from_symbol with symbol as symbol
                Set item.detail to item.detail plus " (from " plus module_name plus ")"
                Add item to items
    
    Return items

Note: Completion Item Creation from Symbol
Process called "create_completion_item_from_symbol" that takes symbol as Symbol returns CompletionItem:
    Note: Create completion item from symbol
    Let kind be get_completion_kind with symbol as symbol
    Let detail be get_symbol_detail with symbol as symbol
    Let documentation be get_symbol_documentation with symbol as symbol
    
    Return CompletionItem with:
        label as symbol.name
        kind as kind
        detail as detail
        documentation as documentation
        insert_text as symbol.name
        sort_text as "2_" plus symbol.name
        filter_text as symbol.name
        commit_characters as get_commit_characters with symbol as symbol
        command as None

Note: Hover Information API
Process called "get_hover_info" that takes integration as LSPIntegration and position as SourceLocation returns Optional[HoverInfo]:
    Note: Get hover information for a position
    Set integration.performance_metrics.hover_requests to integration.performance_metrics.hover_requests plus 1
    
    Let cache_key be create_hover_cache_key with position as position
    If cache_key is in integration.hover_cache:
        Set integration.performance_metrics.cache_hits to integration.performance_metrics.cache_hits plus 1
        Return integration.hover_cache at key cache_key
    
    Set integration.performance_metrics.cache_misses to integration.performance_metrics.cache_misses plus 1
    
    Note: Get symbol at position
    Let symbol be get_symbol_at_position with integration as integration and position as position
    If symbol is None:
        Return None
    
    Note: Create hover info
    Let hover_info be create_hover_info_from_symbol with symbol as symbol and position as position
    
    Note: Cache result
    Set integration.hover_cache at key cache_key to hover_info
    
    Return hover_info

Note: Symbol at Position
Process called "get_symbol_at_position" that takes integration as LSPIntegration and position as SourceLocation returns Optional[Symbol]:
    Note: Get symbol at specific position
    Let word be get_word_at_position with integration as integration and position as position
    If word is None:
        Return None
    
    Let symbol be resolve_symbol with table as integration.analyzer.symbol_table and name as word
    Return symbol

Note: Hover Info Creation
Process called "create_hover_info_from_symbol" that takes symbol as Symbol and position as SourceLocation returns HoverInfo:
    Note: Create hover information from symbol
    Let contents be ""
    
    Note: Add symbol name and kind
    Set contents to contents plus "**" plus symbol.name plus "** (" plus get_symbol_kind_display_name with symbol as symbol plus ")\n\n"
    
    Note: Add type information
    If symbol.type is not None:
        Set contents to contents plus "**Type:** " plus symbol.type.name plus "\n\n"
    
    Note: Add documentation
    If symbol.metadata contains "documentation":
        Set contents to contents plus symbol.metadata at key "documentation" plus "\n\n"
    
    Note: Add usage information
    If length of symbol.usage_locations is greater than 0:
        Set contents to contents plus "**Used " plus length of symbol.usage_locations plus " times**\n"
    
    Note: Add scope information
    Set contents to contents plus "**Scope:** " plus symbol.scope.name
    
    Return HoverInfo with:
        contents as contents
        range as None  Note: Could be calculated from symbol location

Note: Go to Definition API
Process called "get_definition_location" that takes integration as LSPIntegration and position as SourceLocation returns Optional[SourceLocation]:
    Note: Get definition location for symbol at position
    Set integration.performance_metrics.definition_requests to integration.performance_metrics.definition_requests plus 1
    
    Let symbol be get_symbol_at_position with integration as integration and position as position
    If symbol is None:
        Return None
    
    Return symbol.declaration_location

Note: Find All References API
Process called "get_references" that takes integration as LSPIntegration and position as SourceLocation returns List[SourceLocation]:
    Note: Get all references for symbol at position
    Set integration.performance_metrics.reference_requests to integration.performance_metrics.reference_requests plus 1
    
    Let symbol be get_symbol_at_position with integration as integration and position as position
    If symbol is None:
        Return list containing
    
    Return symbol.usage_locations

Note: Document Symbols API
Process called "get_document_symbols" that takes integration as LSPIntegration and file_path as String returns List[Symbol]:
    Note: Get document symbols for outline view
    Set integration.performance_metrics.symbol_requests to integration.performance_metrics.symbol_requests plus 1
    
    Let cache_key be "symbols_" plus file_path
    If cache_key is in integration.symbol_cache:
        Set integration.performance_metrics.cache_hits to integration.performance_metrics.cache_hits plus 1
        Return integration.symbol_cache at key cache_key
    
    Set integration.performance_metrics.cache_misses to integration.performance_metrics.cache_misses plus 1
    
    Let symbols be get_document_symbols with table as integration.analyzer.symbol_table and file_path as file_path
    
    Note: Cache results
    Set integration.symbol_cache at key cache_key to symbols
    
    Return symbols

Note: Incremental Analysis Support
Process called "update_incremental_analysis" that takes integration as LSPIntegration and changed_ranges as List[Range]:
    Note: Update analysis for incremental changes
    Set integration.incremental_mode to true
    Set integration.changed_ranges to changed_ranges
    
    Note: Clear affected caches
    Call clear_affected_caches with integration as integration and ranges as changed_ranges
    
    Note: Perform incremental analysis
    Let analysis_result be analyze_incrementally with analyzer as integration.analyzer and changed_nodes as extract_changed_nodes with ranges as changed_ranges
    
    Set integration.incremental_mode to false
    Return analysis_result

Note: Cache Management
Process called "clear_affected_caches" that takes integration as LSPIntegration and ranges as List[Range]:
    Note: Clear caches affected by changes
    For each range in ranges:
        Let affected_keys be get_affected_cache_keys with integration as integration and range as range
        For each key in affected_keys:
            Remove key from integration.completion_cache
            Remove key from integration.hover_cache
    
    Note: Clear symbol cache for affected files
    For each range in ranges:
        Let file_path be range.file_path
        Let symbol_key be "symbols_" plus file_path
        Remove symbol_key from integration.symbol_cache

Note: Utility Functions
Process called "create_completion_cache_key" that takes position as SourceLocation returns String:
    Note: Create cache key for completion
    Return "completion_" plus position.line plus "_" plus position.column

Process called "create_hover_cache_key" that takes position as SourceLocation returns String:
    Note: Create cache key for hover
    Return "hover_" plus position.line plus "_" plus position.column

Process called "get_completion_kind" that takes symbol as Symbol returns String:
    Note: Get completion kind from symbol
    Match symbol.kind:
        When "variable":
            Return "variable"
        When "function":
            Return "function"
        When "type":
            Return "type"
        When "module":
            Return "module"
        When "parameter":
            Return "variable"
        When "keyword":
            Return "keyword"
        Otherwise:
            Return "variable"

Process called "get_symbol_detail" that takes symbol as Symbol returns String:
    Note: Get symbol detail for completion
    If symbol.type is not None:
        Return symbol.type.name
    Otherwise:
        Return get_symbol_kind_display_name with symbol as symbol

Process called "get_symbol_documentation" that takes symbol as Symbol returns String:
    Note: Get symbol documentation
    If symbol.metadata contains "documentation":
        Return symbol.metadata at key "documentation"
    Otherwise:
        Return "No documentation available"

Process called "get_commit_characters" that takes symbol as Symbol returns List[String]:
    Note: Get commit characters for symbol
    Match symbol.kind:
        When "function":
            Return list containing "(" and " "
        When "variable":
            Return list containing " " and "\t" and "\n"
        When "type":
            Return list containing " " and "<"
        When "keyword":
            Return list containing " " and "\n"
        Otherwise:
            Return list containing " " and "\t" and "\n"

Process called "get_context_keywords" that takes context as Dictionary[String, Any] returns List[String]:
    Note: Get relevant keywords for context
    Let keywords be list containing
    
    Note: Add basic keywords
    Add "Let" to keywords
    Add "Process" to keywords
    Add "If" to keywords
    Add "Otherwise" to keywords
    Add "Return" to keywords
    
    Note: Add context-specific keywords
    If context.scope_kind is equal to "function":
        Add "Return" to keywords
    
    If context.word_prefix starts with "I":
        Add "If" to keywords
        Add "Import" to keywords
    
    Return keywords

Process called "get_word_at_position" that takes integration as LSPIntegration and position as SourceLocation returns Optional[String]:
    Note: Get word at position
    Let source_code be integration.analyzer.ast.source_code
    Let line_content be get_line_content with source_code as source_code and line as position.line
    
    If line_content is None:
        Return None
    
    Let word_start be find_word_start with line_content as line_content and position as position.column
    Let word_end be find_word_end with line_content as line_content and position as position.column
    
    If word_start is equal to word_end:
        Return None
    
    Return line_content from index word_start to word_end

Process called "get_line_content" that takes source_code as String and line as Integer returns Optional[String]:
    Note: Get content of specific line
    Let lines be split with text as source_code and delimiter as "\n"
    If line is greater than 0 and line is less than or equal to length of lines:
        Return lines at index (line minus 1)
    Return None

Process called "find_word_start" that takes line_content as String and position as Integer returns Integer:
    Note: Find start of word at position
    Let start be position
    While start is greater than 0 and is_identifier_char with char as (line_content at index (start minus 1)):
        Set start to start minus 1
    Return start

Process called "find_word_end" that takes line_content as String and position as Integer returns Integer:
    Note: Find end of word at position
    Let end be position
    While end is less than length of line_content and is_identifier_char with char as (line_content at index end):
        Set end to end plus 1
    Return end

Process called "is_identifier_char" that takes char as String returns Boolean:
    Note: Check if character is valid for identifier
    Return (char is greater than or equal to "a" and char is less than or equal to "z") or
           (char is greater than or equal to "A" and char is less than or equal to "Z") or
           (char is greater than or equal to "0" and char is less than or equal to "9") or
           char is equal to "_"

Process called "extract_word_prefix" that takes line_prefix as String returns String:
    Note: Extract word prefix from line prefix
    Let prefix be ""
    For i from (length of line_prefix minus 1) down to 0:
        Let char be line_prefix at index i
        If is_identifier_char with char as char:
            Set prefix to char plus prefix
        Otherwise:
            Break
    Return prefix

Process called "infer_expected_type" that takes integration as LSPIntegration and context as Dictionary[String, Any] returns Optional[RunaType]:
    Note: Infer expected type from context
    Return None  Note: Could be implemented with more sophisticated type inference

Process called "filter_completion_items" that takes items as List[CompletionItem] and context as Dictionary[String, Any] returns List[CompletionItem]:
    Note: Filter completion items based on context
    Let filtered_items be list containing
    Let word_prefix be context.word_prefix
    
    For each item in items:
        If length of word_prefix is equal to 0 or item.label starts with word_prefix:
            Add item to filtered_items
    
    Return filtered_items

Process called "get_lsp_performance_metrics" that takes integration as LSPIntegration returns Dictionary[String, Any]:
    Note: Get performance metrics from LSP integration
    Return integration.performance_metrics

Process called "clear_lsp_cache" that takes integration as LSPIntegration:
    Note: Clear all LSP caches
    Set integration.completion_cache to dictionary containing
    Set integration.hover_cache to dictionary containing
    Set integration.symbol_cache to dictionary containing 