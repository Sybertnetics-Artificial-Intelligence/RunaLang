Note:
Runa Semantic Analysis Diagnostics: Centralized Error Management

This module implements a centralized diagnostic engine for semantic analysis,
serving as the single source of truth for all errors, warnings, and information
messages. This addresses the critical architectural need for unified error reporting.

Key Features:
- Single diagnostic engine per compilation job
- Hierarchical error categorization
- Performance metrics and error recovery
- LSP integration for real-time feedback
- Comprehensive error context preservation
:End Note

Note: Import dependencies
Import "../lexer/diagnostics.runa"

Note: Semantic Analysis Diagnostic Types
Type SemanticError is Dictionary with:
    code as String
    message as String
    severity as String  Note: "error", "warning", "info"
    location as SourceLocation
    context as Dictionary[String, Any]
    suggestions as List[String]
    related_locations as List[SourceLocation]

Type SemanticWarning is Dictionary with:
    code as String
    message as String
    severity as String  Note: Always "warning"
    location as SourceLocation
    context as Dictionary[String, Any]
    suggestions as List[String]

Type SemanticInfo is Dictionary with:
    code as String
    message as String
    severity as String  Note: Always "info"
    location as SourceLocation
    context as Dictionary[String, Any]

Type SemanticDiagnosticEngine is Dictionary with:
    Note: Centralized state management
    errors as List[SemanticError]
    warnings as List[SemanticWarning]
    info_messages as List[SemanticInfo]
    
    Note: Performance and configuration
    max_errors as Integer
    max_warnings as Integer
    error_count as Integer
    warning_count as Integer
    info_count as Integer
    
    Note: Error recovery and context
    error_recovery_mode as Boolean
    current_scope as String
    current_function as String
    context_stack as List[Dictionary[String, Any]]
    
    Note: Performance metrics
    performance_metrics as Dictionary[String, Any]
    
    Note: LSP integration
    lsp_mode as Boolean
    incremental_updates as Boolean
    changed_ranges as List[Range]

Note: Diagnostic Engine Creation
Process called "create_semantic_diagnostic_engine" that takes max_errors as Integer and max_warnings as Integer returns SemanticDiagnosticEngine:
    Note: Create a new centralized diagnostic engine for semantic analysis
    Return SemanticDiagnosticEngine with:
        errors as list containing
        warnings as list containing
        info_messages as list containing
        max_errors as max_errors
        max_warnings as max_warnings
        error_count as 0
        warning_count as 0
        info_count as 0
        error_recovery_mode as false
        current_scope as "global"
        current_function as ""
        context_stack as list containing
        performance_metrics as dictionary containing:
            "errors_reported" as 0
            "warnings_reported" as 0
            "info_reported" as 0
            "recovery_attempts" as 0
            "processing_time_ms" as 0
        lsp_mode as false
        incremental_updates as false
        changed_ranges as list containing

Note: Core Error Reporting Functions
Process called "report_semantic_error" that takes engine as SemanticDiagnosticEngine and error as SemanticError:
    Note: Report a semantic error with centralized management
    If engine.error_count is greater than or equal to engine.max_errors:
        Return  Note: Error limit reached
    
    Add error to engine.errors
    Set engine.error_count to engine.error_count plus 1
    Set engine.performance_metrics.errors_reported to engine.performance_metrics.errors_reported plus 1
    
    Note: Add context information
    Set error.context to dictionary containing:
        "current_scope" as engine.current_scope
        "current_function" as engine.current_function
        "context_stack_depth" as length of engine.context_stack

Process called "report_semantic_warning" that takes engine as SemanticDiagnosticEngine and warning as SemanticWarning:
    Note: Report a semantic warning with centralized management
    If engine.warning_count is greater than or equal to engine.max_warnings:
        Return  Note: Warning limit reached
    
    Add warning to engine.warnings
    Set engine.warning_count to engine.warning_count plus 1
    Set engine.performance_metrics.warnings_reported to engine.performance_metrics.warnings_reported plus 1
    
    Note: Add context information
    Set warning.context to dictionary containing:
        "current_scope" as engine.current_scope
        "current_function" as engine.current_function
        "context_stack_depth" as length of engine.context_stack

Process called "report_semantic_info" that takes engine as SemanticDiagnosticEngine and info as SemanticInfo:
    Note: Report a semantic information message
    Add info to engine.info_messages
    Set engine.info_count to engine.info_count plus 1
    Set engine.performance_metrics.info_reported to engine.performance_metrics.info_reported plus 1

Note: Predefined Error Types
Process called "create_undefined_variable_error" that takes variable_name as String and location as SourceLocation returns SemanticError:
    Note: Create error for undefined variable
    Return SemanticError with:
        code as "E001"
        message as "Undefined variable '" plus variable_name plus "'"
        severity as "error"
        location as location
        context as dictionary containing "variable_name" as variable_name
        suggestions as list containing:
            "Check if the variable is declared before use"
            "Verify the variable name spelling"
            "Ensure the variable is in scope"
        related_locations as list containing

Process called "create_type_mismatch_error" that takes expected_type as String and actual_type as String and location as SourceLocation returns SemanticError:
    Note: Create error for type mismatch
    Return SemanticError with:
        code as "E002"
        message as "Type mismatch: expected '" plus expected_type plus "', got '" plus actual_type plus "'"
        severity as "error"
        location as location
        context as dictionary containing:
            "expected_type" as expected_type
            "actual_type" as actual_type
        suggestions as list containing:
            "Check the variable declaration type"
            "Verify the expression type"
            "Consider explicit type conversion"
        related_locations as list containing

Process called "create_function_call_error" that takes function_name as String and expected_args as Integer and actual_args as Integer and location as SourceLocation returns SemanticError:
    Note: Create error for function call argument mismatch
    Return SemanticError with:
        code as "E003"
        message as "Function '" plus function_name plus "' expects " plus expected_args plus " arguments, got " plus actual_args
        severity as "error"
        location as location
        context as dictionary containing:
            "function_name" as function_name
            "expected_arguments" as expected_args
            "actual_arguments" as actual_args
        suggestions as list containing:
            "Check the function signature"
            "Add missing arguments"
            "Remove extra arguments"
        related_locations as list containing

Process called "create_circular_dependency_error" that takes dependency_chain as List[String] and location as SourceLocation returns SemanticError:
    Note: Create error for circular dependency
    Return SemanticError with:
        code as "E004"
        message as "Circular dependency detected: " plus join_dependency_chain with chain as dependency_chain
        severity as "error"
        location as location
        context as dictionary containing "dependency_chain" as dependency_chain
        suggestions as list containing:
            "Break the circular dependency"
            "Use forward declarations"
            "Restructure the code"
        related_locations as list containing

Process called "create_import_error" that takes module_name as String and reason as String and location as SourceLocation returns SemanticError:
    Note: Create error for import issues
    Return SemanticError with:
        code as "E005"
        message as "Import error for module '" plus module_name plus "': " plus reason
        severity as "error"
        location as location
        context as dictionary containing:
            "module_name" as module_name
            "reason" as reason
        suggestions as list containing:
            "Check if the module exists"
            "Verify the import path"
            "Ensure the module is accessible"
        related_locations as list containing

Note: Predefined Warning Types
Process called "create_unused_variable_warning" that takes variable_name as String and location as SourceLocation returns SemanticWarning:
    Note: Create warning for unused variable
    Return SemanticWarning with:
        code as "W001"
        message as "Unused variable '" plus variable_name plus "'"
        severity as "warning"
        location as location
        context as dictionary containing "variable_name" as variable_name
        suggestions as list containing:
            "Remove the unused variable"
            "Use the variable in your code"
            "Prefix with underscore to suppress warning"

Process called "create_unused_import_warning" that takes import_name as String and location as SourceLocation returns SemanticWarning:
    Note: Create warning for unused import
    Return SemanticWarning with:
        code as "W002"
        message as "Unused import '" plus import_name plus "'"
        severity as "warning"
        location as location
        context as dictionary containing "import_name" as import_name
        suggestions as list containing:
            "Remove the unused import"
            "Use the imported symbol"
            "Check if import is needed"

Process called "create_deprecated_feature_warning" that takes feature_name as String and alternative as String and location as SourceLocation returns SemanticWarning:
    Note: Create warning for deprecated feature usage
    Return SemanticWarning with:
        code as "W003"
        message as "Deprecated feature '" plus feature_name plus "' used"
        severity as "warning"
        location as location
        context as dictionary containing:
            "feature_name" as feature_name
            "alternative" as alternative
        suggestions as list containing:
            "Use '" plus alternative plus "' instead"
            "Update to the new API"
            "Check the migration guide"

Note: Context Management
Process called "push_context" that takes engine as SemanticDiagnosticEngine and context as Dictionary[String, Any]:
    Note: Push context onto the diagnostic engine stack
    Add context to engine.context_stack

Process called "pop_context" that takes engine as SemanticDiagnosticEngine returns Dictionary[String, Any]:
    Note: Pop context from the diagnostic engine stack
    If length of engine.context_stack is greater than 0:
        Let context be engine.context_stack at index (length of engine.context_stack minus 1)
        Remove last item from engine.context_stack
        Return context
    Otherwise:
        Return dictionary containing

Process called "set_current_scope" that takes engine as SemanticDiagnosticEngine and scope as String:
    Note: Set the current scope for error context
    Set engine.current_scope to scope

Process called "set_current_function" that takes engine as SemanticDiagnosticEngine and function_name as String:
    Note: Set the current function for error context
    Set engine.current_function to function_name

Note: Error Recovery and Performance
Process called "enable_error_recovery" that takes engine as SemanticDiagnosticEngine:
    Note: Enable error recovery mode
    Set engine.error_recovery_mode to true

Process called "disable_error_recovery" that takes engine as SemanticDiagnosticEngine:
    Note: Disable error recovery mode
    Set engine.error_recovery_mode to false

Process called "get_diagnostic_summary" that takes engine as SemanticDiagnosticEngine returns Dictionary[String, Any]:
    Note: Get a summary of all diagnostics
    Return dictionary containing:
        "total_errors" as engine.error_count
        "total_warnings" as engine.warning_count
        "total_info" as engine.info_count
        "errors" as engine.errors
        "warnings" as engine.warnings
        "info_messages" as engine.info_messages
        "performance_metrics" as engine.performance_metrics

Process called "clear_diagnostics" that takes engine as SemanticDiagnosticEngine:
    Note: Clear all diagnostics and reset counters
    Set engine.errors to list containing
    Set engine.warnings to list containing
    Set engine.info_messages to list containing
    Set engine.error_count to 0
    Set engine.warning_count to 0
    Set engine.info_count to 0
    Set engine.context_stack to list containing
    Set engine.performance_metrics to dictionary containing:
        "errors_reported" as 0
        "warnings_reported" as 0
        "info_reported" as 0
        "recovery_attempts" as 0
        "processing_time_ms" as 0

Note: LSP Integration
Process called "enable_lsp_mode" that takes engine as SemanticDiagnosticEngine:
    Note: Enable LSP mode for real-time diagnostics
    Set engine.lsp_mode to true
    Set engine.incremental_updates to true

Process called "disable_lsp_mode" that takes engine as SemanticDiagnosticEngine:
    Note: Disable LSP mode
    Set engine.lsp_mode to false
    Set engine.incremental_updates to false

Process called "get_lsp_diagnostics" that takes engine as SemanticDiagnosticEngine returns List[Dictionary[String, Any]]:
    Note: Get diagnostics in LSP format
    Let lsp_diagnostics be list containing
    
    Note: Convert errors to LSP format
    For each error in engine.errors:
        Add dictionary containing:
            "range" as create_lsp_range with location as error.location
            "severity" as 1  Note: Error
            "code" as error.code
            "source" as "runa-semantic"
            "message" as error.message
            "relatedInformation" as create_lsp_related_info with locations as error.related_locations
        to lsp_diagnostics
    
    Note: Convert warnings to LSP format
    For each warning in engine.warnings:
        Add dictionary containing:
            "range" as create_lsp_range with location as warning.location
            "severity" as 2  Note: Warning
            "code" as warning.code
            "source" as "runa-semantic"
            "message" as warning.message
            "relatedInformation" as list containing
        to lsp_diagnostics
    
    Return lsp_diagnostics

Note: Utility Functions
Process called "join_dependency_chain" that takes chain as List[String] returns String:
    Note: Join dependency chain into readable string
    Let result be ""
    For i from 0 to length of chain minus 1:
        If i is greater than 0:
            Set result to result plus " -> "
        Set result to result plus (chain at index i)
    Return result

Process called "create_lsp_range" that takes location as SourceLocation returns Dictionary[String, Any]:
    Note: Create LSP range from source location
    Return dictionary containing:
        "start" as dictionary containing:
            "line" as location.line minus 1  Note: LSP uses 0-based indexing
            "character" as location.column minus 1
        "end" as dictionary containing:
            "line" as location.line minus 1
            "character" as location.column

Process called "create_lsp_related_info" that takes locations as List[SourceLocation] returns List[Dictionary[String, Any]]:
    Note: Create LSP related information from locations
    Let related_info be list containing
    For each location in locations:
        Add dictionary containing:
            "location" as dictionary containing:
                "uri" as "file://" plus location.file_path
                "range" as create_lsp_range with location as location
            "message" as "Related location"
        to related_info
    Return related_info

Process called "get_diagnostic_engine_performance" that takes engine as SemanticDiagnosticEngine returns Dictionary[String, Any]:
    Note: Get performance metrics from diagnostic engine
    Return engine.performance_metrics 