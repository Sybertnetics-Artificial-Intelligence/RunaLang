Note:
Runa Dependency Analyzer: Circular Dependency Detection

This module implements circular dependency detection using DFS algorithms,
addressing the critical need for robust dependency analysis in semantic validation.

Key Features:
- DFS-based cycle detection
- Import dependency tracking
- Function call dependency analysis
- Type dependency resolution
- Performance optimization with caching
- Comprehensive error reporting
:End Note

Note: Import dependencies
Import "diagnostics.runa"
Import "visitor.runa"

Note: Dependency Analysis Core Types
Type DependencyNode is Dictionary with:
    name as String
    kind as String  Note: "module", "function", "type", "variable"
    location as SourceLocation
    dependencies as List[String]
    dependents as List[String]
    visited as Boolean
    in_stack as Boolean
    depth as Integer

Type DependencyGraph is Dictionary with:
    nodes as Dictionary[String, DependencyNode]
    edges as List[Dictionary[String, String]]  Note: from -> to
    cycles as List[List[String]]
    performance_metrics as Dictionary[String, Any]
    diagnostic_engine as SemanticDiagnosticEngine

Type CycleDetectionResult is Dictionary with:
    success as Boolean
    cycles as List[List[String]]
    errors as List[String]
    warnings as List[String]
    dependency_order as List[String]

Note: Dependency Graph Creation
Process called "create_dependency_graph" that takes diagnostic_engine as SemanticDiagnosticEngine returns DependencyGraph:
    Note: Create a new dependency graph for analysis
    Return DependencyGraph with:
        nodes as dictionary containing
        edges as list containing
        cycles as list containing
        performance_metrics as dictionary containing:
            "nodes_created" as 0
            "edges_created" as 0
            "cycles_found" as 0
            "dfs_runs" as 0
            "processing_time_ms" as 0
        diagnostic_engine as diagnostic_engine

Note: Core Cycle Detection Algorithm
Process called "find_cycles" that takes graph as DependencyGraph returns CycleDetectionResult:
    Note: Main cycle detection using DFS algorithm
    Let start_time be get_current_time_ms
    Set graph.performance_metrics.dfs_runs to graph.performance_metrics.dfs_runs plus 1
    
    Let cycles be list containing
    Let errors be list containing
    Let warnings be list containing
    Let dependency_order be list containing
    
    Note: Reset node states
    For each node_name and node in graph.nodes:
        Set node.visited to false
        Set node.in_stack to false
        Set node.depth to 0
    
    Note: Run DFS from each unvisited node
    For each node_name and node in graph.nodes:
        If not node.visited:
            Let cycle_result be dfs_cycle_detection with graph as graph and node_name as node_name and path as list containing node_name
            If cycle_result.found_cycle:
                Add cycle_result.cycle to cycles
                Set graph.performance_metrics.cycles_found to graph.performance_metrics.cycles_found plus 1
            Add all items from cycle_result.path to dependency_order
    
    Let end_time be get_current_time_ms
    Set graph.performance_metrics.processing_time_ms to end_time minus start_time
    
    Set graph.cycles to cycles
    
    Return CycleDetectionResult with:
        success as length of cycles is equal to 0
        cycles as cycles
        errors as errors
        warnings as warnings
        dependency_order as dependency_order

Note: DFS Cycle Detection
Process called "dfs_cycle_detection" that takes graph as DependencyGraph and node_name as String and path as List[String] returns Dictionary[String, Any]:
    Note: DFS-based cycle detection algorithm
    Let node be graph.nodes at key node_name
    Set node.visited to true
    Set node.in_stack to true
    Set node.depth to length of path
    
    Let result be dictionary containing:
        "found_cycle" as false
        "cycle" as list containing
        "path" as path
    
    Note: Check all dependencies
    For each dep_name in node.dependencies:
        If dep_name is in graph.nodes:
            Let dep_node be graph.nodes at key dep_name
            
            If dep_node.in_stack:
                Note: Found a cycle!
                Let cycle_start be index_of with list as path and item as dep_name
                Let cycle be path from index cycle_start to end
                Add dep_name to cycle
                Set result.found_cycle to true
                Set result.cycle to cycle
                Break
            Otherwise if not dep_node.visited:
                Let dep_result be dfs_cycle_detection with graph as graph and node_name as dep_name and path as path plus dep_name
                If dep_result.found_cycle:
                    Set result.found_cycle to true
                    Set result.cycle to dep_result.cycle
                    Break
                Add all items from dep_result.path to result.path
        Otherwise:
            Note: Dependency not found - report warning
            Let warning be create_missing_dependency_warning with dependency_name as dep_name and location as node.location
            Report with engine as graph.diagnostic_engine and warning as warning
    
    Set node.in_stack to false
    Return result

Note: Dependency Graph Building
Process called "add_dependency_node" that takes graph as DependencyGraph and name as String and kind as String and location as SourceLocation returns DependencyNode:
    Note: Add a new node to the dependency graph
    Let node be DependencyNode with:
        name as name
        kind as kind
        location as location
        dependencies as list containing
        dependents as list containing
        visited as false
        in_stack as false
        depth as 0
    
    Set graph.nodes at key name to node
    Set graph.performance_metrics.nodes_created to graph.performance_metrics.nodes_created plus 1
    
    Return node

Process called "add_dependency_edge" that takes graph as DependencyGraph and from_name as String and to_name as String:
    Note: Add a dependency edge between two nodes
    If from_name is in graph.nodes and to_name is in graph.nodes:
        Let from_node be graph.nodes at key from_name
        Let to_node be graph.nodes at key to_name
        
        If to_name is not in from_node.dependencies:
            Add to_name to from_node.dependencies
        If from_name is not in to_node.dependents:
            Add from_name to to_node.dependents
        
        Add dictionary containing "from" as from_name and "to" as to_name to graph.edges
        Set graph.performance_metrics.edges_created to graph.performance_metrics.edges_created plus 1

Process called "remove_dependency_edge" that takes graph as DependencyGraph and from_name as String and to_name as String:
    Note: Remove a dependency edge
    If from_name is in graph.nodes and to_name is in graph.nodes:
        Let from_node be graph.nodes at key from_name
        Let to_node be graph.nodes at key to_name
        
        Remove to_name from from_node.dependencies
        Remove from_name from to_node.dependents
        
        Note: Remove edge from edges list
        Let edge_index be find_edge_index with graph as graph and from_name as from_name and to_name as to_name
        If edge_index is not equal to -1:
            Remove graph.edges at index edge_index

Note: Import Dependency Analysis
Process called "analyze_import_dependencies" that takes graph as DependencyGraph and ast as ASTNode returns List[String]:
    Note: Analyze import dependencies from AST
    Let import_visitor be create_import_dependency_visitor with graph as graph
    Let visit_result be visit_ast with visitor as import_visitor and node as ast and context as dictionary containing
    
    Return visit_result.result

Process called "create_import_dependency_visitor" that takes graph as DependencyGraph returns ASTVisitor:
    Note: Create visitor for import dependency analysis
    Let visitor be create_ast_visitor
    Set visitor.visit_import_statement to collect_import_dependencies with graph as graph
    Return visitor

Process called "collect_import_dependencies" that takes visitor as ASTVisitor and node as ASTNode and context as Dictionary[String, Any] returns VisitResult:
    Note: Collect import dependencies from import statements
    Let graph be context at key "graph"
    Let current_module be context at key "current_module"
    
    If current_module is not None:
        Let module_name be node.module_name
        Let imported_symbols be node.imported_symbols
        
        Note: Add dependency edge
        Call add_dependency_edge with graph as graph and from_name as current_module and to_name as module_name
        
        Note: Add imported symbols as dependencies
        For each symbol in imported_symbols:
            Let symbol_name be current_module plus "." plus symbol
            Let dep_name be module_name plus "." plus symbol
            Call add_dependency_edge with graph as graph and from_name as symbol_name and to_name as dep_name
    
    Return VisitResult with:
        success as true
        result as list containing node.module_name
        errors as list containing
        warnings as list containing
        context_updates as dictionary containing

Note: Function Call Dependency Analysis
Process called "analyze_function_dependencies" that takes graph as DependencyGraph and ast as ASTNode returns List[String]:
    Note: Analyze function call dependencies from AST
    Let function_visitor be create_function_dependency_visitor with graph as graph
    Let visit_result be visit_ast with visitor as function_visitor and node as ast and context as dictionary containing
    
    Return visit_result.result

Process called "create_function_dependency_visitor" that takes graph as DependencyGraph returns ASTVisitor:
    Note: Create visitor for function dependency analysis
    Let visitor be create_ast_visitor
    Set visitor.visit_function_call to collect_function_dependencies with graph as graph
    Return visitor

Process called "collect_function_dependencies" that takes visitor as ASTVisitor and node as ASTNode and context as Dictionary[String, Any] returns VisitResult:
    Note: Collect function call dependencies
    Let graph be context at key "graph"
    Let current_function be context at key "current_function"
    
    If current_function is not None:
        Let function_name be node.function.value
        Let qualified_name be resolve_function_name with function_name as function_name and context as context
        
        If qualified_name is not None:
            Call add_dependency_edge with graph as graph and from_name as current_function and to_name as qualified_name
    
    Return VisitResult with:
        success as true
        result as list containing
        errors as list containing
        warnings as list containing
        context_updates as dictionary containing

Note: Type Dependency Analysis
Process called "analyze_type_dependencies" that takes graph as DependencyGraph and ast as ASTNode returns List[String]:
    Note: Analyze type dependencies from AST
    Let type_visitor be create_type_dependency_visitor with graph as graph
    Let visit_result be visit_ast with visitor as type_visitor and node as ast and context as dictionary containing
    
    Return visit_result.result

Process called "create_type_dependency_visitor" that takes graph as DependencyGraph returns ASTVisitor:
    Note: Create visitor for type dependency analysis
    Let visitor be create_ast_visitor
    Set visitor.visit_variable_declaration to collect_type_dependencies with graph as graph
    Set visitor.visit_process_declaration to collect_type_dependencies with graph as graph
    Return visitor

Process called "collect_type_dependencies" that takes visitor as ASTVisitor and node as ASTNode and context as Dictionary[String, Any] returns VisitResult:
    Note: Collect type dependencies from declarations
    Let graph be context at key "graph"
    Let current_scope be context at key "current_scope"
    
    If current_scope is not None and node.type_annotation is not None:
        Let type_name be node.type_annotation
        Let qualified_type_name be resolve_type_name with type_name as type_name and context as context
        
        If qualified_type_name is not None:
            Let declaration_name be current_scope plus "." plus node.name
            Call add_dependency_edge with graph as graph and from_name as declaration_name and to_name as qualified_type_name
    
    Return VisitResult with:
        success as true
        result as list containing
        errors as list containing
        warnings as list containing
        context_updates as dictionary containing

Note: Dependency Resolution Helpers
Process called "resolve_function_name" that takes function_name as String and context as Dictionary[String, Any] returns Optional[String]:
    Note: Resolve a function name to its fully qualified name
    If function_name contains ".":
        Return function_name  Note: Already qualified
    Otherwise:
        Let current_module be context at key "current_module"
        If current_module is not None:
            Return current_module plus "." plus function_name
        Otherwise:
            Return function_name

Process called "resolve_type_name" that takes type_name as String and context as Dictionary[String, Any] returns Optional[String]:
    Note: Resolve a type name to its fully qualified name
    If type_name contains ".":
        Return type_name  Note: Already qualified
    Otherwise:
        Let current_module be context at key "current_module"
        If current_module is not None:
            Return current_module plus "." plus type_name
        Otherwise:
            Return type_name

Note: Graph Analysis Utilities
Process called "get_dependency_path" that takes graph as DependencyGraph and from_name as String and to_name as String returns List[String]:
    Note: Find dependency path between two nodes using BFS
    If from_name is not in graph.nodes or to_name is not in graph.nodes:
        Return list containing
    
    Let visited be set containing
    Let queue be list containing dictionary containing "node" as from_name and "path" as list containing from_name
    
    While length of queue is greater than 0:
        Let current be queue at index 0
        Remove queue at index 0
        
        Let current_node be current at key "node"
        Let current_path be current at key "path"
        
        If current_node is equal to to_name:
            Return current_path
        
        If current_node is not in visited:
            Add current_node to visited
            
            Let node be graph.nodes at key current_node
            For each dep in node.dependencies:
                If dep is not in visited:
                    Add dictionary containing "node" as dep and "path" as current_path plus dep to queue
    
    Return list containing

Process called "get_reverse_dependencies" that takes graph as DependencyGraph and node_name as String returns List[String]:
    Note: Get all nodes that depend on the given node
    If node_name is not in graph.nodes:
        Return list containing
    
    Let dependents be list containing
    Let node be graph.nodes at key node_name
    
    For each dep_name in node.dependents:
        Add dep_name to dependents
        Add all items from get_reverse_dependencies with graph as graph and node_name as dep_name to dependents
    
    Return dependents

Process called "get_dependency_tree" that takes graph as DependencyGraph and root_name as String returns Dictionary[String, Any]:
    Note: Get dependency tree rooted at the given node
    If root_name is not in graph.nodes:
        Return dictionary containing "node" as root_name and "children" as list containing
    
    Let node be graph.nodes at key root_name
    Let children be list containing
    
    For each dep_name in node.dependencies:
        Let child_tree be get_dependency_tree with graph as graph and root_name as dep_name
        Add child_tree to children
    
    Return dictionary containing:
        "node" as root_name
        "kind" as node.kind
        "location" as node.location
        "children" as children

Note: Performance and Utility Functions
Process called "find_edge_index" that takes graph as DependencyGraph and from_name as String and to_name as String returns Integer:
    Note: Find index of edge in edges list
    For i from 0 to length of graph.edges minus 1:
        Let edge be graph.edges at index i
        If edge at key "from" is equal to from_name and edge at key "to" is equal to to_name:
            Return i
    Return -1

Process called "index_of" that takes list as List[String] and item as String returns Integer:
    Note: Find index of item in list
    For i from 0 to length of list minus 1:
        If list at index i is equal to item:
            Return i
    Return -1

Process called "create_missing_dependency_warning" that takes dependency_name as String and location as SourceLocation returns SemanticWarning:
    Note: Create warning for missing dependency
    Return SemanticWarning with:
        code as "W004"
        message as "Missing dependency: '" plus dependency_name plus "'"
        severity as "warning"
        location as location
        context as dictionary containing "dependency_name" as dependency_name
        suggestions as list containing:
            "Check if the dependency is properly imported"
            "Verify the dependency exists"
            "Ensure the dependency is accessible"

Process called "get_dependency_graph_performance" that takes graph as DependencyGraph returns Dictionary[String, Any]:
    Note: Get performance metrics from dependency graph
    Return graph.performance_metrics

Process called "clear_dependency_graph" that takes graph as DependencyGraph:
    Note: Clear dependency graph and reset state
    Set graph.nodes to dictionary containing
    Set graph.edges to list containing
    Set graph.cycles to list containing
    Set graph.performance_metrics to dictionary containing:
        "nodes_created" as 0
        "edges_created" as 0
        "cycles_found" as 0
        "dfs_runs" as 0
        "processing_time_ms" as 0 