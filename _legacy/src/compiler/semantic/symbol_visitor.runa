Note:
Runa Symbol Table Visitor: Concrete Symbol Resolution

This module implements a concrete visitor for symbol table population and scope management.
It traverses the AST and builds up the complete symbol table with proper scope resolution.

Key Features:
- Scope creation and management
- Symbol declaration and resolution
- Import/export handling
- Variable and function scope tracking
- Error reporting for duplicate declarations
:End Note

Note: Import dependencies
Import "visitor.runa"
Import "symbol_table.runa"
Import "diagnostics.runa"

Note: Symbol Visitor Type
Type SymbolVisitor is ASTVisitor with:
    symbol_table as SymbolTable
    current_scope as Scope
    scope_stack as List[Scope]
    diagnostic_engine as SemanticDiagnosticEngine
    performance_metrics as Dictionary[String, Any]

Note: Symbol Visitor Creation
Process called "create_symbol_visitor" that takes symbol_table as SymbolTable and diagnostic_engine as SemanticDiagnosticEngine returns SymbolVisitor:
    Note: Create a symbol table visitor with all methods implemented
    Let visitor be create_ast_visitor
    
    Note: Set up symbol-specific visitor methods
    Set visitor.visit_program to visit_program_symbols with symbol_table as symbol_table and diagnostic_engine as diagnostic_engine
    Set visitor.visit_variable_declaration to visit_variable_declaration_symbols with symbol_table as symbol_table and diagnostic_engine as diagnostic_engine
    Set visitor.visit_process_declaration to visit_process_declaration_symbols with symbol_table as symbol_table and diagnostic_engine as diagnostic_engine
    Set visitor.visit_import_statement to visit_import_statement_symbols with symbol_table as symbol_table and diagnostic_engine as diagnostic_engine
    Set visitor.visit_export_statement to visit_export_statement_symbols with symbol_table as symbol_table and diagnostic_engine as diagnostic_engine
    Set visitor.visit_identifier to visit_identifier_symbols with symbol_table as symbol_table and diagnostic_engine as diagnostic_engine
    
    Return visitor

Note: Program-Level Symbol Resolution
Process called "visit_program_symbols" that takes visitor as ASTVisitor and node as ASTNode and context as Dictionary[String, Any] returns VisitResult:
    Note: Visit program and set up global scope
    Let symbol_table be context at key "symbol_table"
    Let diagnostic_engine be context at key "diagnostic_engine"
    
    Note: Set current scope to global scope
    Let current_scope be symbol_table.global_scope
    Let scope_stack be list containing current_scope
    
    Note: Create program context
    Let program_context be dictionary containing:
        "symbol_table" as symbol_table
        "diagnostic_engine" as diagnostic_engine
        "current_scope" as current_scope
        "scope_stack" as scope_stack
    
    Note: Visit all statements in the program
    Let errors be list containing
    Let warnings be list containing
    Let context_updates be dictionary containing
    
    If node.statements is not None:
        For each statement in node.statements:
            Let statement_result be visit_ast with visitor as visitor and node as statement and context as program_context
            Match statement_result:
                When Success with result as result and context_updates as updates:
                    Add all items from updates to context_updates
                When Failure with diagnostics as diagnostics and warnings as stmt_warnings:
                    Add all items from diagnostics to errors
                    Add all items from stmt_warnings to warnings
    
    If length of errors is equal to 0:
        Return Success with result as None and context_updates as context_updates
    Otherwise:
        Return Failure with diagnostics as errors and warnings as warnings

Note: Variable Declaration Symbol Resolution
Process called "visit_variable_declaration_symbols" that takes visitor as ASTVisitor and node as ASTNode and context as Dictionary[String, Any] returns VisitResult:
    Note: Process variable declaration and add to symbol table
    Let symbol_table be context at key "symbol_table"
    Let diagnostic_engine be context at key "diagnostic_engine"
    Let current_scope be context at key "current_scope"
    
    Let variable_name be node.name
    Let variable_type be node.type_annotation
    
    Note: Check for duplicate declaration in current scope
    Let existing_symbol be resolve_symbol_in_scope with scope as current_scope and name as variable_name
    If existing_symbol is not None:
        Let error be create_duplicate_declaration_error with name as variable_name and location as node.location and existing_location as existing_symbol.declaration_location
        Report with engine as diagnostic_engine and error as error
        Return Failure with diagnostics as list containing error and warnings as list containing
    
    Note: Create variable symbol
    Let variable_symbol be Symbol with:
        name as variable_name
        kind as "variable"
        type as variable_type
        scope as current_scope
        declaration_location as node.location
        usage_locations as list containing
        is_exported as false
        is_imported as false
        metadata as dictionary containing
    
    Note: Add symbol to current scope
    Set current_scope.symbols at key variable_name to variable_symbol
    
    Note: Visit initial value if present
    If node.initial_value is not None:
        Let value_result be visit_ast with visitor as visitor and node as node.initial_value and context as context
        Match value_result:
            When Success with result as result and context_updates as updates:
                Return Success with result as variable_symbol and context_updates as updates
            When Failure with diagnostics as diagnostics and warnings as warnings:
                Return Failure with diagnostics as diagnostics and warnings as warnings
    
    Return Success with result as variable_symbol and context_updates as dictionary containing

Note: Process Declaration Symbol Resolution
Process called "visit_process_declaration_symbols" that takes visitor as ASTVisitor and node as ASTNode and context as Dictionary[String, Any] returns VisitResult:
    Note: Process function/process declaration and add to symbol table
    Let symbol_table be context at key "symbol_table"
    Let diagnostic_engine be context at key "diagnostic_engine"
    Let current_scope be context at key "current_scope"
    Let scope_stack be context at key "scope_stack"
    
    Let process_name be node.name
    Let return_type be node.return_type
    
    Note: Check for duplicate declaration
    Let existing_symbol be resolve_symbol_in_scope with scope as current_scope and name as process_name
    If existing_symbol is not None:
        Let error be create_duplicate_declaration_error with name as process_name and location as node.location and existing_location as existing_symbol.declaration_location
        Report with engine as diagnostic_engine and error as error
        Return Failure with diagnostics as list containing error and warnings as list containing
    
    Note: Create function scope
    Let function_scope be create_scope with name as process_name and parent as current_scope
    Add function_scope to scope_stack
    Add function_scope to symbol_table.scopes
    
    Note: Process parameters
    Let parameter_symbols be list containing
    If node.parameters is not None:
        For each parameter in node.parameters:
            Let param_symbol be Symbol with:
                name as parameter.name
                kind as "parameter"
                type as parameter.type_annotation
                scope as function_scope
                declaration_location as parameter.location
                usage_locations as list containing
                is_exported as false
                is_imported as false
                metadata as dictionary containing
            
            Set function_scope.symbols at key parameter.name to param_symbol
            Add param_symbol to parameter_symbols
    
    Note: Create process symbol
    Let process_symbol be Symbol with:
        name as process_name
        kind as "function"
        type as create_function_type with parameter_types as parameter_symbols and return_type as return_type
        scope as current_scope
        declaration_location as node.location
        usage_locations as list containing
        is_exported as false
        is_imported as false
        metadata as dictionary containing:
            "parameters" as parameter_symbols
            "function_scope" as function_scope
    
    Note: Add process symbol to current scope
    Set current_scope.symbols at key process_name to process_symbol
    
    Note: Visit function body with function scope
    Let function_context be dictionary containing:
        "symbol_table" as symbol_table
        "diagnostic_engine" as diagnostic_engine
        "current_scope" as function_scope
        "scope_stack" as scope_stack
    
    If node.body is not None:
        Let body_result be visit_ast with visitor as visitor and node as node.body and context as function_context
        Match body_result:
            When Success with result as result and context_updates as updates:
                Remove last item from scope_stack  Note: Pop function scope
                Return Success with result as process_symbol and context_updates as updates
            When Failure with diagnostics as diagnostics and warnings as warnings:
                Remove last item from scope_stack  Note: Pop function scope
                Return Failure with diagnostics as diagnostics and warnings as warnings
    
    Remove last item from scope_stack  Note: Pop function scope
    Return Success with result as process_symbol and context_updates as dictionary containing

Note: Import Statement Symbol Resolution
Process called "visit_import_statement_symbols" that takes visitor as ASTVisitor and node as ASTNode and context as Dictionary[String, Any] returns VisitResult:
    Note: Process import statement and add imported symbols to symbol table
    Let symbol_table be context at key "symbol_table"
    Let diagnostic_engine be context at key "diagnostic_engine"
    Let current_scope be context at key "current_scope"
    
    Let module_name be node.module_name
    Let imported_symbols be node.imported_symbols
    
    Note: Add imported symbols to current scope
    For each symbol_name in imported_symbols:
        Let imported_symbol be Symbol with:
            name as symbol_name
            kind as "imported"
            type as None  Note: Will be resolved during type checking
            scope as current_scope
            declaration_location as node.location
            usage_locations as list containing
            is_exported as false
            is_imported as true
            metadata as dictionary containing:
                "module_name" as module_name
                "original_name" as symbol_name
        
        Set current_scope.symbols at key symbol_name to imported_symbol
    
    Return Success with result as None and context_updates as dictionary containing

Note: Export Statement Symbol Resolution
Process called "visit_export_statement_symbols" that takes visitor as ASTVisitor and node as ASTNode and context as Dictionary[String, Any] returns VisitResult:
    Note: Process export statement and mark symbols as exported
    Let symbol_table be context at key "symbol_table"
    Let diagnostic_engine be context at key "diagnostic_engine"
    Let current_scope be context at key "current_scope"
    
    Let exported_symbols be node.exported_symbols
    
    Note: Mark symbols as exported
    For each symbol_name in exported_symbols:
        Let symbol be resolve_symbol_in_scope with scope as current_scope and name as symbol_name
        If symbol is not None:
            Set symbol.is_exported to true
        Otherwise:
            Let error be create_undefined_symbol_error with name as symbol_name and location as node.location
            Report with engine as diagnostic_engine and error as error
    
    Return Success with result as None and context_updates as dictionary containing

Note: Identifier Symbol Resolution
Process called "visit_identifier_symbols" that takes visitor as ASTVisitor and node as ASTNode and context as Dictionary[String, Any] returns VisitResult:
    Note: Process identifier usage and track symbol references
    Let symbol_table be context at key "symbol_table"
    Let diagnostic_engine be context at key "diagnostic_engine"
    Let current_scope be context at key "current_scope"
    
    Let identifier_name be node.value
    
    Note: Resolve symbol in current scope hierarchy
    Let symbol be resolve_symbol with table as symbol_table and name as identifier_name
    
    If symbol is not None:
        Note: Add usage location to symbol
        Add node.location to symbol.usage_locations
        Return Success with result as symbol and context_updates as dictionary containing
    Otherwise:
        Note: Undefined symbol - will be reported during type checking
        Return Success with result as None and context_updates as dictionary containing

Note: Utility Functions
Process called "resolve_symbol_in_scope" that takes scope as Scope and name as String returns Optional[Symbol]:
    Note: Resolve symbol in a specific scope
    If name is in scope.symbols:
        Return scope.symbols at key name
    Otherwise:
        Return None

Process called "create_duplicate_declaration_error" that takes name as String and location as SourceLocation and existing_location as SourceLocation returns SemanticError:
    Note: Create error for duplicate symbol declaration
    Return SemanticError with:
        code as "E006"
        message as "Duplicate declaration of '" plus name plus "'"
        severity as "error"
        location as location
        context as dictionary containing:
            "symbol_name" as name
            "existing_location" as existing_location
        suggestions as list containing:
            "Remove the duplicate declaration"
            "Rename one of the declarations"
            "Check if you meant to use a different name"
        related_locations as list containing existing_location

Process called "create_undefined_symbol_error" that takes name as String and location as SourceLocation returns SemanticError:
    Note: Create error for undefined symbol
    Return SemanticError with:
        code as "E007"
        message as "Undefined symbol '" plus name plus "'"
        severity as "error"
        location as location
        context as dictionary containing "symbol_name" as name
        suggestions as list containing:
            "Check if the symbol is declared"
            "Verify the symbol name spelling"
            "Ensure the symbol is imported if from another module"
        related_locations as list containing

Process called "create_function_type" that takes parameter_types as List[Symbol] and return_type as RunaType returns RunaType:
    Note: Create function type from parameters and return type
    Let param_types be list containing
    For each param in parameter_types:
        Add param.type to param_types
    
    Return RunaType with:
        kind as "function"
        name as "Function"
        parameters as param_types
        return_type as return_type
        constraints as list containing
        metadata as dictionary containing 