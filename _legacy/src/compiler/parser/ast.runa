Note:
Runa Parser: Abstract Syntax Tree Node Types

This module defines the complete AST node hierarchy for the Runa language,
supporting natural language syntax, AI-first design, and comprehensive
language features.

Key Features:
- Complete AST node hierarchy for all Runa constructs
- Natural language syntax support (multi-word operators, identifiers)
- AI-first design with forgiving parsing
- Comprehensive type system integration
- Source location tracking for error reporting
:End Note

Note: Import dependencies
Import "../lexer/token.runa"
Import "../lexer/internal/utilities.runa"

Note: Base AST Node with Common Properties
Type ASTNode is Dictionary with:
    node_type as String
    location as SourceLocation
    metadata as Dictionary[String, Any]

Note: Expression AST Nodes (Values and Operations)
Type Expression is:
    | Literal with value as Any and literal_type as String
    | Identifier with name as String and is_qualified as Boolean
    | BinaryOperation with left as Expression and operator as String and right as Expression
    | UnaryOperation with operator as String and operand as Expression
    | FunctionCall with function as Expression and arguments as List[Expression]
    | MethodCall with object as Expression and method as String and arguments as List[Expression]
    | IndexAccess with array as Expression and index as Expression
    | FieldAccess with object as Expression and field as String
    | ParenthesizedExpression with expression as Expression
    | ListLiteral with elements as List[Expression]
    | DictionaryLiteral with keys as List[Expression] and values as List[Expression]
    | TupleLiteral with elements as List[Expression]
    | ConditionalExpression with condition as Expression and then_expr as Expression and else_expr as Expression
    | LambdaExpression with parameters as List[Parameter] and body as Expression
    | TypeCast with expression as Expression and target_type as TypeExpression

Note: Statement AST Nodes (Actions and Control Flow)
Type Statement is:
    | ExpressionStatement with expression as Expression
    | VariableDeclaration with name as String and value as Expression and type_annotation as Optional[TypeExpression]
    | Assignment with target as Expression and value as Expression
    | IfStatement with condition as Expression and then_body as List[Statement] and else_body as List[Statement]
    | MatchStatement with expression as Expression and cases as List[MatchCase]
    | ForLoop with variable as String and iterable as Expression and body as List[Statement]
    | WhileLoop with condition as Expression and body as List[Statement]
    | BreakStatement
    | ContinueStatement
    | ReturnStatement with value as Optional[Expression]
    | TryStatement with try_body as List[Statement] and catch_blocks as List[CatchBlock] and finally_body as Optional[List[Statement]]
    | ThrowStatement with expression as Expression
    | ImportStatement with module as String and alias as Optional[String]
    | ExportStatement with items as List[ExportItem]
    | CommentStatement with content as String and is_multiline as Boolean
    | PassStatement

Note: Declaration AST Nodes (Type and Function Definitions)
Type Declaration is:
    | ProcessDeclaration with name as String and parameters as List[Parameter] and return_type as Optional[TypeExpression] and body as List[Statement] and is_function as Boolean
    | TypeDeclaration with name as String and fields as List[TypeField] and methods as List[ProcessDeclaration]
    | ModuleDeclaration with name as String and body as List[Statement]

Note: Type System AST Nodes
Type TypeExpression is:
    | SimpleType with name as String
    | GenericType with base_type as String and type_arguments as List[TypeExpression]
    | UnionType with types as List[TypeExpression]
    | OptionalType with inner_type as TypeExpression
    | FunctionType with parameter_types as List[TypeExpression] and return_type as TypeExpression
    | TupleType with element_types as List[TypeExpression]
    | ListType with element_type as TypeExpression
    | DictionaryType with key_type as TypeExpression and value_type as TypeExpression

Note: Supporting Types for AST Nodes
Type Parameter is Dictionary with:
    name as String
    type_annotation as Optional[TypeExpression]
    default_value as Optional[Expression]
    is_variadic as Boolean

Type TypeField is Dictionary with:
    name as String
    field_type as TypeExpression
    default_value as Optional[Expression]

Type MatchCase is Dictionary with:
    pattern as Pattern
    guard as Optional[Expression]
    body as List[Statement]

Type Pattern is:
    | LiteralPattern with value as Any
    | IdentifierPattern with name as String
    | TuplePattern with elements as List[Pattern]
    | ListPattern with elements as List[Pattern] and rest as Optional[String]
    | WildcardPattern

Type CatchBlock is Dictionary with:
    exception_type as Optional[TypeExpression]
    exception_name as Optional[String]
    body as List[Statement]

Type ExportItem is Dictionary with:
    name as String
    alias as Optional[String]

Note: AST Node Creation Utilities
Process called "create_literal_node" that takes value as Any and literal_type as String and location as SourceLocation returns Expression:
    Note: Create a literal expression node
    Return Literal with value as value and literal_type as literal_type

Process called "create_identifier_node" that takes name as String and location as SourceLocation returns Expression:
    Note: Create an identifier expression node
    Let is_qualified be name contains " "
    Return Identifier with name as name and is_qualified as is_qualified

Process called "create_binary_operation_node" that takes left as Expression and operator as String and right as Expression and location as SourceLocation returns Expression:
    Note: Create a binary operation expression node
    Return BinaryOperation with left as left and operator as operator and right as right

Process called "create_function_call_node" that takes function as Expression and arguments as List[Expression] and location as SourceLocation returns Expression:
    Note: Create a function call expression node
    Return FunctionCall with function as function and arguments as arguments

Process called "create_method_call_node" that takes object as Expression and method as String and arguments as List[Expression] and location as SourceLocation returns Expression:
    Note: Create a method call expression node
    Return MethodCall with object as object and method as method and arguments as arguments

Process called "create_variable_declaration_node" that takes name as String and value as Expression and type_annotation as Optional[TypeExpression] and location as SourceLocation returns Statement:
    Note: Create a variable declaration statement node
    Return VariableDeclaration with name as name and value as value and type_annotation as type_annotation

Process called "create_if_statement_node" that takes condition as Expression and then_body as List[Statement] and else_body as List[Statement] and location as SourceLocation returns Statement:
    Note: Create an if statement node
    Return IfStatement with condition as condition and then_body as then_body and else_body as else_body

Process called "create_function_declaration_node" that takes name as String and parameters as List[Parameter] and return_type as Optional[TypeExpression] and body as List[Statement] and location as SourceLocation returns Declaration:
    Note: Create a function declaration node
    Return ProcessDeclaration with name as name and parameters as parameters and return_type as return_type and body as body and is_function as true

Process called "create_process_declaration_node" that takes name as String and parameters as List[Parameter] and return_type as Optional[TypeExpression] and body as List[Statement] and location as SourceLocation returns Declaration:
    Note: Create a process declaration node (Runa's main function type)
    Return ProcessDeclaration with name as name and parameters as parameters and return_type as return_type and body as body and is_function as false

Process called "create_member_access_node" that takes object as Expression and member as String and location as SourceLocation returns Expression:
    Note: Create a member access node (object.member)
    Return FieldAccess with object as object and field as member

Note: AST Node Analysis Utilities
Process called "get_node_type" that takes node as Expression returns String:
    Note: Get the type of an expression node
    Match node:
        When Literal with value as value and literal_type as literal_type:
            Return literal_type
        When Identifier with name as name and is_qualified as is_qualified:
            Return "identifier"
        When BinaryOperation with left as left and operator as operator and right as right:
            Return "binary_operation"
        When UnaryOperation with operator as operator and operand as operand:
            Return "unary_operation"
        When FunctionCall with function as function and arguments as arguments:
            Return "function_call"
        When MethodCall with object as object and method as method and arguments as arguments:
            Return "method_call"
        When IndexAccess with array as array and index as index:
            Return "index_access"
        When FieldAccess with object as object and field as field:
            Return "field_access"
        When ParenthesizedExpression with expression as expression:
            Return "parenthesized_expression"
        When ListLiteral with elements as elements:
            Return "list_literal"
        When DictionaryLiteral with keys as keys and values as values:
            Return "dictionary_literal"
        When TupleLiteral with elements as elements:
            Return "tuple_literal"
        When ConditionalExpression with condition as condition and then_expr as then_expr and else_expr as else_expr:
            Return "conditional_expression"
        When LambdaExpression with parameters as parameters and body as body:
            Return "lambda_expression"
        When TypeCast with expression as expression and target_type as target_type:
            Return "type_cast"

Process called "is_literal_node" that takes node as Expression returns Boolean:
    Note: Check if node is a literal
    Match node:
        When Literal with value as value and literal_type as literal_type:
            Return true
        Otherwise:
            Return false

Process called "is_identifier_node" that takes node as Expression returns Boolean:
    Note: Check if node is an identifier
    Match node:
        When Identifier with name as name and is_qualified as is_qualified:
            Return true
        Otherwise:
            Return false

Process called "is_binary_operation_node" that takes node as Expression returns Boolean:
    Note: Check if node is a binary operation
    Match node:
        When BinaryOperation with left as left and operator as operator and right as right:
            Return true
        Otherwise:
            Return false

Process called "is_function_call_node" that takes node as Expression returns Boolean:
    Note: Check if node is a function call
    Match node:
        When FunctionCall with function as function and arguments as arguments:
            Return true
        Otherwise:
            Return false

Note: AST Node Traversal Utilities
Process called "get_all_identifiers" that takes node as Expression returns List[String]:
    Note: Extract all identifiers from an expression tree
    Let identifiers be list containing
    
    Match node:
        When Identifier with name as name and is_qualified as is_qualified:
            Add name to identifiers
        When BinaryOperation with left as left and operator as operator and right as right:
            Let left_ids be get_all_identifiers with node as left
            Let right_ids be get_all_identifiers with node as right
            For each id in left_ids:
                Add id to identifiers
            For each id in right_ids:
                Add id to identifiers
        When FunctionCall with function as function and arguments as arguments:
            Let func_ids be get_all_identifiers with node as function
            For each id in func_ids:
                Add id to identifiers
            For each arg in arguments:
                Let arg_ids be get_all_identifiers with node as arg
                For each id in arg_ids:
                    Add id to identifiers
        Otherwise:
            Note: For other node types, return empty list for now
            Return identifiers
    
    Return identifiers

Process called "get_all_literals" that takes node as Expression returns List[Any]:
    Note: Extract all literal values from an expression tree
    Let literals be list containing
    
    Match node:
        When Literal with value as value and literal_type as literal_type:
            Add value to literals
        When BinaryOperation with left as left and operator as operator and right as right:
            Let left_lits be get_all_literals with node as left
            Let right_lits be get_all_literals with node as right
            For each lit in left_lits:
                Add lit to literals
            For each lit in right_lits:
                Add lit to literals
        Otherwise:
            Return literals
    
    Return literals

Note: AST Node Validation Utilities
Process called "validate_expression" that takes node as Expression returns Dictionary[String, Any]:
    Note: Validate an expression node for correctness
    Let errors be list containing
    Let warnings be list containing
    
    Match node:
        When BinaryOperation with left as left and operator as operator and right as right:
            Let left_validation be validate_expression with node as left
            Let right_validation be validate_expression with node as right
            
            For each error in left_validation.errors:
                Add error to errors
            For each error in right_validation.errors:
                Add error to errors
            
            Note: Check for common operator issues
            If operator is equal to "is greater than" or operator is equal to "is less than":
                Let left_type be get_node_type with node as left
                Let right_type be get_node_type with node as right
                If left_type is not equal to "number" or right_type is not equal to "number":
                    Add "Comparison operators expect numeric operands" to warnings
        
        When FunctionCall with function as function and arguments as arguments:
            Let func_validation be validate_expression with node as function
            For each error in func_validation.errors:
                Add error to errors
            
            For each arg in arguments:
                Let arg_validation be validate_expression with node as arg
                For each error in arg_validation.errors:
                    Add error to errors
        
        Otherwise:
            Note: Other node types are generally valid
            Return dictionary containing "errors" as errors and "warnings" as warnings
    
    Return dictionary containing "errors" as errors and "warnings" as warnings

Note: AST Node Serialization Utilities
Process called "serialize_node" that takes node as Expression returns String:
    Note: Serialize an AST node to a string representation
    Match node:
        When Literal with value as value and literal_type as literal_type:
            Return "Literal(" plus value plus ")"
        When Identifier with name as name and is_qualified as is_qualified:
            Return "Identifier(" plus name plus ")"
        When BinaryOperation with left as left and operator as operator and right as right:
            Let left_str be serialize_node with node as left
            Let right_str be serialize_node with node as right
            Return "BinaryOp(" plus left_str plus " " plus operator plus " " plus right_str plus ")"
        When FunctionCall with function as function and arguments as arguments:
            Let func_str be serialize_node with node as function
            Let args_str be ""
            For i from 0 to length of arguments minus 1:
                If i is greater than 0:
                    Set args_str to args_str plus ", "
                Set args_str to args_str plus serialize_node with node as (arguments at index i)
            Return "Call(" plus func_str plus ", [" plus args_str plus "])"
        Otherwise:
            Return "UnknownNode"

Process called "get_node_complexity" that takes node as Expression returns Integer:
    Note: Calculate the complexity of an expression node
    Match node:
        When Literal with value as value and literal_type as literal_type:
            Return 1
        When Identifier with name as name and is_qualified as is_qualified:
            Return 1
        When BinaryOperation with left as left and operator as operator and right as right:
            Let left_complexity be get_node_complexity with node as left
            Let right_complexity be get_node_complexity with node as right
            Return left_complexity plus right_complexity plus 1
        When FunctionCall with function as function and arguments as arguments:
            Let func_complexity be get_node_complexity with node as function
            Let args_complexity be 0
            For each arg in arguments:
                Set args_complexity to args_complexity plus get_node_complexity with node as arg
            Return func_complexity plus args_complexity plus 1
        Otherwise:
            Return 1 