Note:
Runa Advanced Mathematics Symbol Support

Implements lexical replacement for mathematical symbols in Runa source code.
This module provides direct language support for mathematical notation,
enabling researchers and scientists to write code that closely matches
mathematical formulas and papers.

Features:
- Greek letters (α, β, γ, δ, θ, λ, π, σ, φ, ψ, ω)
- Mathematical operators (∑, ∏, ∫, ∂, ∇, ∞)
- Set theory symbols (∈, ∉, ⊂, ⊆, ∪, ∩, ∅)
- Logic symbols (∀, ∃, ¬, ∧, ∨, ⊕)
- Comparison symbols (≤, ≥, ≠, ≈, ≡)
- Special functions (√, ∛, ⌊, ⌈, |)
- Lexical replacement (\alpha → α, \sum → ∑, etc.)
:End Note

Note: Mathematical symbol mapping for lexical replacement
Type called "MathSymbolMap":
    symbol_mappings as Dictionary[String, String]
    operator_mappings as Dictionary[String, String]
    function_mappings as Dictionary[String, String]
    metadata as Dictionary[String, Any]

Type called "SymbolReplacement":
    original_sequence as String
    unicode_symbol as String
    category as String
    description as String
    precedence as Integer

Note: Initialize mathematical symbol mappings
Process called "create_math_symbol_map" returns MathSymbolMap:
    Note: Create comprehensive mapping of escape sequences to Unicode symbols
    Let symbol_map be dictionary containing
    Let operator_map be dictionary containing
    Let function_map be dictionary containing
    
    Note: Greek letters (variables and constants)
    Set symbol_map["\\alpha"] to "α"
    Set symbol_map["\\beta"] to "β"
    Set symbol_map["\\gamma"] to "γ"
    Set symbol_map["\\delta"] to "δ"
    Set symbol_map["\\epsilon"] to "ε"
    Set symbol_map["\\zeta"] to "ζ"
    Set symbol_map["\\eta"] to "η"
    Set symbol_map["\\theta"] to "θ"
    Set symbol_map["\\iota"] to "ι"
    Set symbol_map["\\kappa"] to "κ"
    Set symbol_map["\\lambda"] to "λ"
    Set symbol_map["\\mu"] to "μ"
    Set symbol_map["\\nu"] to "ν"
    Set symbol_map["\\xi"] to "ξ"
    Set symbol_map["\\omicron"] to "ο"
    Set symbol_map["\\pi"] to "π"
    Set symbol_map["\\rho"] to "ρ"
    Set symbol_map["\\sigma"] to "σ"
    Set symbol_map["\\tau"] to "τ"
    Set symbol_map["\\upsilon"] to "υ"
    Set symbol_map["\\phi"] to "φ"
    Set symbol_map["\\chi"] to "χ"
    Set symbol_map["\\psi"] to "ψ"
    Set symbol_map["\\omega"] to "ω"
    
    Note: Capital Greek letters
    Set symbol_map["\\Alpha"] to "Α"
    Set symbol_map["\\Beta"] to "Β"
    Set symbol_map["\\Gamma"] to "Γ"
    Set symbol_map["\\Delta"] to "Δ"
    Set symbol_map["\\Epsilon"] to "Ε"
    Set symbol_map["\\Zeta"] to "Ζ"
    Set symbol_map["\\Eta"] to "Η"
    Set symbol_map["\\Theta"] to "Θ"
    Set symbol_map["\\Iota"] to "Ι"
    Set symbol_map["\\Kappa"] to "Κ"
    Set symbol_map["\\Lambda"] to "Λ"
    Set symbol_map["\\Mu"] to "Μ"
    Set symbol_map["\\Nu"] to "Ν"
    Set symbol_map["\\Xi"] to "Ξ"
    Set symbol_map["\\Omicron"] to "Ο"
    Set symbol_map["\\Pi"] to "Π"
    Set symbol_map["\\Rho"] to "Ρ"
    Set symbol_map["\\Sigma"] to "Σ"
    Set symbol_map["\\Tau"] to "Τ"
    Set symbol_map["\\Upsilon"] to "Υ"
    Set symbol_map["\\Phi"] to "Φ"
    Set symbol_map["\\Chi"] to "Χ"
    Set symbol_map["\\Psi"] to "Ψ"
    Set symbol_map["\\Omega"] to "Ω"
    
    Note: Mathematical operators
    Set operator_map["\\sum"] to "∑"
    Set operator_map["\\prod"] to "∏"
    Set operator_map["\\int"] to "∫"
    Set operator_map["\\oint"] to "∮"
    Set operator_map["\\partial"] to "∂"
    Set operator_map["\\nabla"] to "∇"
    Set operator_map["\\laplacian"] to "∆"
    Set operator_map["\\infinity"] to "∞"
    Set operator_map["\\infty"] to "∞"
    
    Note: Set theory symbols
    Set operator_map["\\in"] to "∈"
    Set operator_map["\\notin"] to "∉"
    Set operator_map["\\subset"] to "⊂"
    Set operator_map["\\subseteq"] to "⊆"
    Set operator_map["\\supset"] to "⊃"
    Set operator_map["\\supseteq"] to "⊇"
    Set operator_map["\\union"] to "∪"
    Set operator_map["\\cap"] to "∩"
    Set operator_map["\\emptyset"] to "∅"
    Set operator_map["\\setminus"] to "∖"
    
    Note: Logic symbols
    Set operator_map["\\forall"] to "∀"
    Set operator_map["\\exists"] to "∃"
    Set operator_map["\\nexists"] to "∄"
    Set operator_map["\\neg"] to "¬"
    Set operator_map["\\land"] to "∧"
    Set operator_map["\\lor"] to "∨"
    Set operator_map["\\oplus"] to "⊕"
    Set operator_map["\\implies"] to "⇒"
    Set operator_map["\\iff"] to "⇔"
    
    Note: Comparison and relation symbols
    Set operator_map["\\leq"] to "≤"
    Set operator_map["\\geq"] to "≥"
    Set operator_map["\\neq"] to "≠"
    Set operator_map["\\approx"] to "≈"
    Set operator_map["\\equiv"] to "≡"
    Set operator_map["\\sim"] to "∼"
    Set operator_map["\\propto"] to "∝"
    Set operator_map["\\parallel"] to "∥"
    Set operator_map["\\perp"] to "⊥"
    
    Note: Mathematical functions and special symbols
    Set function_map["\\sqrt"] to "√"
    Set function_map["\\cbrt"] to "∛"
    Set function_map["\\floor"] to "⌊"
    Set function_map["\\ceil"] to "⌈"
    Set function_map["\\abs"] to "|"
    Set function_map["\\norm"] to "‖"
    Set function_map["\\angle"] to "∠"
    Set function_map["\\degree"] to "°"
    Set function_map["\\prime"] to "′"
    Set function_map["\\dprime"] to "″"
    
    Note: Arrows and miscellaneous
    Set operator_map["\\rightarrow"] to "→"
    Set operator_map["\\leftarrow"] to "←"
    Set operator_map["\\uparrow"] to "↑"
    Set operator_map["\\downarrow"] to "↓"
    Set operator_map["\\leftrightarrow"] to "↔"
    Set operator_map["\\mapsto"] to "↦"
    
    Return MathSymbolMap with:
        symbol_mappings as symbol_map
        operator_mappings as operator_map
        function_mappings as function_map
        metadata as dictionary containing

Note: Main lexical replacement process
Process called "apply_math_symbol_replacement" that takes source_code as String returns String:
    Note: Apply mathematical symbol replacement to source code
    Try:
        Let symbol_map be create_math_symbol_map()
        Let processed_code be source_code
        
        Note: Apply symbol replacements (variables)
        For each sequence, symbol in symbol_map.symbol_mappings:
            Set processed_code to replace_escape_sequence with code as processed_code and sequence as sequence and symbol as symbol
        
        Note: Apply operator replacements
        For each sequence, symbol in symbol_map.operator_mappings:
            Set processed_code to replace_escape_sequence with code as processed_code and sequence as sequence and symbol as symbol
        
        Note: Apply function replacements
        For each sequence, symbol in symbol_map.function_mappings:
            Set processed_code to replace_escape_sequence with code as processed_code and sequence as sequence and symbol as symbol
        
        Return processed_code
        
    Catch error:
        Note: Return original code if replacement fails
        Return source_code

Process called "replace_escape_sequence" that takes code as String and sequence as String and symbol as String returns String:
    Note: Replace all occurrences of escape sequence with Unicode symbol
    Let result_code be code
    Let search_index be find_sequence_position with text as result_code and sequence as sequence
    
    While search_index is not equal to -1:
        Note: Check if this is a valid replacement (not inside string literals or comments)
        If is_valid_replacement_position with code as result_code and position as search_index:
            Let before be substring with text as result_code and start as 0 and end as search_index
            Let after be substring with text as result_code and start as search_index plus length of sequence
            Set result_code to before plus symbol plus after
            
            Note: Adjust search position for the replaced symbol
            Set search_index to find_sequence_position with text as result_code and sequence as sequence and start_pos as search_index plus length of symbol
        Otherwise:
            Note: Skip this occurrence and continue searching
            Set search_index to find_sequence_position with text as result_code and sequence as sequence and start_pos as search_index plus 1
    
    Return result_code

Process called "is_valid_replacement_position" that takes code as String and position as Integer returns Boolean:
    Note: Check if position is valid for symbol replacement (not in strings/comments)
    Try:
        Note: Check if we're inside a string literal
        If is_inside_string_literal with code as code and position as position:
            Return false
        
        Note: Check if we're inside a comment
        If is_inside_comment with code as code and position as position:
            Return false
        
        Note: Check if this is part of a larger identifier
        If is_part_of_identifier with code as code and position as position:
            Return false
        
        Return true
        
    Catch error:
        Note: Conservative approach - don't replace if unsure
        Return false

Process called "is_inside_string_literal" that takes code as String and position as Integer returns Boolean:
    Note: Check if position is inside a string literal
    Let quote_count be 0
    Let i be 0
    
    While i is less than position:
        Let char be character_at with text as code and position as i
        If char is equal to "\"":
            Note: Check if quote is escaped
            If i is greater than 0 and character_at with text as code and position as i minus 1 is not equal to "\\":
                Set quote_count to quote_count plus 1
        Set i to i plus 1
    
    Note: If quote count is odd, we're inside a string
    Return quote_count modulo 2 is equal to 1

Process called "is_inside_comment" that takes code as String and position as Integer returns Boolean:
    Note: Check if position is inside a Runa comment (Note: ... :End Note)
    Let line_start be find_line_start with code as code and position as position
    Let line_text be extract_line with code as code and start as line_start
    
    Note: Check for single-line note
    If line_text contains "Note:" and position is greater than line_start plus find_substring with text as line_text and search as "Note:":
        If not line_text contains ":End Note":
            Return true
    
    Note: Check for multi-line note block
    Return is_inside_multiline_note with code as code and position as position

Process called "is_inside_multiline_note" that takes code as String and position as Integer returns Boolean:
    Note: Check if position is inside a multi-line Note block
    Let i be position
    Let note_depth be 0
    
    Note: Scan backwards to find note boundaries
    While i is greater than 0:
        Set i to i minus 1
        Let char_sequence be substring with text as code and start as i and end as i plus 10
        
        If char_sequence starts with ":End Note":
            Set note_depth to note_depth plus 1
        Else if char_sequence starts with "Note:":
            Set note_depth to note_depth minus 1
            If note_depth is less than 0:
                Return true
    
    Return false

Process called "is_part_of_identifier" that takes code as String and position as Integer returns Boolean:
    Note: Check if the escape sequence is part of a larger identifier
    Note: Look at character before the backslash
    If position is greater than 0:
        Let prev_char be character_at with text as code and position as position minus 1
        If is_alphanumeric_or_underscore with char as prev_char:
            Return true
    
    Note: This would require parsing the full sequence, but for now use simple heuristic
    Return false

Process called "find_sequence_position" that takes text as String and sequence as String and start_pos as Optional[Integer] returns Integer:
    Note: Find position of escape sequence in text
    Let actual_start be if start_pos is not None then start_pos else 0
    Let text_length be length of text
    Let sequence_length be length of sequence
    
    For i from actual_start to text_length minus sequence_length:
        Let matches be true
        For j from 0 to sequence_length minus 1:
            If character_at with text as text and position as i plus j is not equal to character_at with text as sequence and position as j:
                Set matches to false
                Break
        If matches:
            Return i
    
    Return -1

Process called "find_line_start" that takes code as String and position as Integer returns Integer:
    Note: Find the start of the line containing position
    Let i be position
    While i is greater than 0:
        Set i to i minus 1
        If character_at with text as code and position as i is equal to "\n":
            Return i plus 1
    Return 0

Process called "extract_line" that takes code as String and start as Integer returns String:
    Note: Extract line of text starting from position
    Let line_text be ""
    Let i be start
    
    While i is less than length of code:
        Let char be character_at with text as code and position as i
        If char is equal to "\n":
            Break
        Set line_text to line_text plus char
        Set i to i plus 1
    
    Return line_text

Process called "substring" that takes text as String and start as Integer and end as Optional[Integer] returns String:
    Note: Extract substring from text
    Let actual_end be if end is not None then end else length of text
    If start is less than 0:
        Set start to 0
    If actual_end is greater than length of text:
        Set actual_end to length of text
    
    Let result be ""
    For i from start to actual_end minus 1:
        Set result to result plus character_at with text as text and position as i
    
    Return result

Process called "character_at" that takes text as String and position as Integer returns String:
    Note: Get character at position in string
    If position is less than 0 or position is greater than or equal to length of text:
        Return ""
    
    Note: Convert to character array and access by index
    Let chars be text as List[String]
    Return chars at position

Process called "is_alphanumeric_or_underscore" that takes char as String returns Boolean:
    Note: Check if character is alphanumeric or underscore
    If length of char is not equal to 1:
        Return false
    
    Let char_code be char as Integer
    
    Note: Check for uppercase letters (A-Z)
    If char_code is greater than or equal to 65 and char_code is less than or equal to 90:
        Return true
    
    Note: Check for lowercase letters (a-z)
    If char_code is greater than or equal to 97 and char_code is less than or equal to 122:
        Return true
    
    Note: Check for digits (0-9)
    If char_code is greater than or equal to 48 and char_code is less than or equal to 57:
        Return true
    
    Note: Check for underscore
    If char_code is equal to 95:
        Return true
    
    Return false

Note: Symbol validation and metadata
Process called "validate_math_symbols" that takes source_code as String returns List[SymbolValidation]:
    Note: Validate mathematical symbols in source code
    Let validations be list containing
    Let symbol_map be create_math_symbol_map()
    
    Note: Check for unrecognized escape sequences
    Let escape_positions be find_all_escape_sequences with code as source_code
    
    For each position in escape_positions:
        Let sequence be extract_escape_sequence with code as source_code and position as position
        Let is_recognized be is_recognized_sequence with sequence as sequence and symbol_map as symbol_map
        
        If not is_recognized:
            Let validation be SymbolValidation with:
                position as position
                sequence as sequence
                is_valid as false
                message as "Unrecognized escape sequence: " plus sequence
                suggestion as suggest_similar_sequence with sequence as sequence and symbol_map as symbol_map
            Add validation to validations
    
    Return validations

Process called "find_all_escape_sequences" that takes code as String returns List[Integer]:
    Note: Find all backslash escape sequences in code
    Let positions be list containing
    Let i be 0
    
    While i is less than length of code:
        If character_at with text as code and position as i is equal to "\\":
            If is_valid_replacement_position with code as code and position as i:
                Add i to positions
        Set i to i plus 1
    
    Return positions

Process called "extract_escape_sequence" that takes code as String and position as Integer returns String:
    Note: Extract complete escape sequence starting at position
    Let sequence be "\\"
    Let i be position plus 1
    
    While i is less than length of code:
        Let char be character_at with text as code and position as i
        If is_alphanumeric_or_underscore with char as char:
            Set sequence to sequence plus char
            Set i to i plus 1
        Otherwise:
            Break
    
    Return sequence

Process called "is_recognized_sequence" that takes sequence as String and symbol_map as MathSymbolMap returns Boolean:
    Note: Check if escape sequence is recognized
    If symbol_map.symbol_mappings contains sequence:
        Return true
    If symbol_map.operator_mappings contains sequence:
        Return true
    If symbol_map.function_mappings contains sequence:
        Return true
    Return false

Process called "suggest_similar_sequence" that takes sequence as String and symbol_map as MathSymbolMap returns String:
    Note: Suggest similar recognized sequence for typos
    Let all_sequences be list containing
    
    For each seq, symbol in symbol_map.symbol_mappings:
        Add seq to all_sequences
    For each seq, symbol in symbol_map.operator_mappings:
        Add seq to all_sequences
    For each seq, symbol in symbol_map.function_mappings:
        Add seq to all_sequences
    
    Let best_match be ""
    Let best_similarity be 0
    
    For each known_seq in all_sequences:
        Let similarity be calculate_string_similarity with str1 as sequence and str2 as known_seq
        If similarity is greater than best_similarity:
            Set best_similarity to similarity
            Set best_match to known_seq
    
    If best_similarity is greater than 0.5:
        Return "Did you mean: " plus best_match plus "?"
    Otherwise:
        Return "No similar sequence found"

Process called "calculate_string_similarity" that takes str1 as String and str2 as String returns Float:
    Note: Calculate similarity between two strings (simple Levenshtein-based)
    Let len1 be length of str1
    Let len2 be length of str2
    
    If len1 is equal to 0:
        Return if len2 is equal to 0 then 1.0 else 0.0
    If len2 is equal to 0:
        Return 0.0
    
    Let max_len be max with a as len1 and b as len2
    Let distance be calculate_edit_distance with str1 as str1 and str2 as str2
    
    Return 1.0 minus (distance as Float divided by max_len as Float)

Process called "calculate_edit_distance" that takes str1 as String and str2 as String returns Integer:
    Note: Calculate Levenshtein edit distance
    Let len1 be length of str1
    Let len2 be length of str2
    
    Note: Create distance matrix (simplified for Runa)
    If len1 is equal to 0:
        Return len2
    If len2 is equal to 0:
        Return len1
    
    Note: Simple character-by-character comparison
    Let differences be 0
    Let min_len be min with a as len1 and b as len2
    
    For i from 0 to min_len minus 1:
        If character_at with text as str1 and position as i is not equal to character_at with text as str2 and position as i:
            Set differences to differences plus 1
    
    Set differences to differences plus abs with value as len1 minus len2
    Return differences

Process called "max" that takes a as Integer and b as Integer returns Integer:
    If a is greater than b:
        Return a
    Return b

Process called "min" that takes a as Integer and b as Integer returns Integer:
    If a is less than b:
        Return a
    Return b

Process called "abs" that takes value as Integer returns Integer:
    If value is less than 0:
        Return 0 minus value
    Return value

Note: Supporting types
Type called "SymbolValidation":
    position as Integer
    sequence as String
    is_valid as Boolean
    message as String
    suggestion as String

Note: Integration with lexer
Process called "preprocess_math_symbols" that takes source_code as String returns String:
    Note: Main entry point for mathematical symbol preprocessing
    Note: This function is called by the lexer before tokenization
    Try:
        Let processed_code be apply_math_symbol_replacement with source_code as source_code
        Return processed_code
    Catch error:
        Note: If symbol replacement fails, return original code
        Return source_code

Note: Symbol information and documentation
Process called "get_symbol_info" that takes symbol as String returns Optional[SymbolInfo]:
    Note: Get information about a mathematical symbol
    Let symbol_map be create_math_symbol_map()
    
    Note: Search in symbol mappings
    For each sequence, unicode_symbol in symbol_map.symbol_mappings:
        If unicode_symbol is equal to symbol:
            Return Some(SymbolInfo with:
                unicode_symbol as symbol
                escape_sequence as sequence
                category as "variable"
                description as get_symbol_description with symbol as symbol
                usage_example as get_symbol_usage with symbol as symbol)
    
    Note: Search in operator mappings
    For each sequence, unicode_symbol in symbol_map.operator_mappings:
        If unicode_symbol is equal to symbol:
            Return Some(SymbolInfo with:
                unicode_symbol as symbol
                escape_sequence as sequence
                category as "operator"
                description as get_symbol_description with symbol as symbol
                usage_example as get_symbol_usage with symbol as symbol)
    
    Note: Search in function mappings
    For each sequence, unicode_symbol in symbol_map.function_mappings:
        If unicode_symbol is equal to symbol:
            Return Some(SymbolInfo with:
                unicode_symbol as symbol
                escape_sequence as sequence
                category as "function"
                description as get_symbol_description with symbol as symbol
                usage_example as get_symbol_usage with symbol as symbol)
    
    Return None

Process called "get_symbol_description" that takes symbol as String returns String:
    Note: Get description for mathematical symbol
    Match symbol:
        When "α":
            Return "Greek letter alpha, commonly used for angles or coefficients"
        When "β":
            Return "Greek letter beta, often used for angles or parameters"
        When "γ":
            Return "Greek letter gamma, used for ratios or angles"
        When "δ":
            Return "Greek letter delta, represents change or small quantity"
        When "θ":
            Return "Greek letter theta, commonly used for angles"
        When "λ":
            Return "Greek letter lambda, used for wavelength or eigenvalues"
        When "π":
            Return "Greek letter pi, mathematical constant (≈3.14159)"
        When "σ":
            Return "Greek letter sigma, used for standard deviation or summation"
        When "φ":
            Return "Greek letter phi, golden ratio or angle"
        When "ω":
            Return "Greek letter omega, angular frequency"
        When "∑":
            Return "Summation operator, sums over a range of values"
        When "∏":
            Return "Product operator, multiplies over a range of values"
        When "∫":
            Return "Integral operator, calculates area under curve"
        When "∂":
            Return "Partial derivative operator"
        When "∇":
            Return "Nabla operator, gradient or divergence"
        When "∞":
            Return "Infinity symbol"
        When "∈":
            Return "Element of, set membership"
        When "∉":
            Return "Not an element of, not in set"
        When "⊂":
            Return "Subset of, proper subset"
        When "⊆":
            Return "Subset or equal, subset or equal to"
        When "∪":
            Return "Union, set union operation"
        When "∩":
            Return "Intersection, set intersection operation"
        When "∅":
            Return "Empty set, set with no elements"
        When "∀":
            Return "Universal quantifier, for all"
        When "∃":
            Return "Existential quantifier, there exists"
        When "¬":
            Return "Logical negation, not operator"
        When "∧":
            Return "Logical AND, conjunction"
        When "∨":
            Return "Logical OR, disjunction"
        When "≤":
            Return "Less than or equal to"
        When "≥":
            Return "Greater than or equal to"
        When "≠":
            Return "Not equal to"
        When "≈":
            Return "Approximately equal to"
        When "≡":
            Return "Equivalent to, congruent"
        When "√":
            Return "Square root function"
        When "∛":
            Return "Cube root function"
        Otherwise:
            Return "Mathematical symbol"

Process called "get_symbol_usage" that takes symbol as String returns String:
    Note: Get usage example for mathematical symbol
    Match symbol:
        When "α":
            Return "Let α be 0.05  Note: significance level"
        When "π":
            Return "Let circumference be 2 * π * radius"
        When "σ":
            Return "Let std_dev be σ(data)"
        When "∑":
            Return "Let total be ∑(i=1 to n, x[i])"
        When "∏":
            Return "Let factorial be ∏(i=1 to n, i)"
        When "∫":
            Return "Let area be ∫(0 to 1, f(x) dx)"
        When "∈":
            Return "If x ∈ S then process(x)"
        When "∀":
            Return "∀x ∈ S: property(x)"
        When "∃":
            Return "∃x ∈ S: condition(x)"
        When "√":
            Return "Let result be √(x² + y²)"
        Otherwise:
            Return "Let variable be " plus symbol plus "value"

Type called "SymbolInfo":
    unicode_symbol as String
    escape_sequence as String
    category as String
    description as String
    usage_example as String

Note: CLI integration for symbol information
Process called "list_available_symbols" returns None:
    Note: Display all available mathematical symbols
    Let symbol_map be create_math_symbol_map()
    
    Display "Available Mathematical Symbols in Runa:"
    Display ""
    Display "Greek Letters (Variables):"
    For each sequence, symbol in symbol_map.symbol_mappings:
        Let info be get_symbol_description with symbol as symbol
        Display "  " plus sequence plus " → " plus symbol plus "  " plus info
    
    Display ""
    Display "Mathematical Operators:"
    For each sequence, symbol in symbol_map.operator_mappings:
        Let info be get_symbol_description with symbol as symbol
        Display "  " plus sequence plus " → " plus symbol plus "  " plus info
    
    Display ""
    Display "Mathematical Functions:"
    For each sequence, symbol in symbol_map.function_mappings:
        Let info be get_symbol_description with symbol as symbol
        Display "  " plus sequence plus " → " plus symbol plus "  " plus info