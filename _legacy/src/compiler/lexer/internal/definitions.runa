Note:
Runa Lexer: Internal Definitions - Single Source of Truth

This module contains the unified definitions for all multi-word constructs,
keywords, and operators that the lexer must recognize.

Key Features:
- Single source of truth for all multi-word constructs
- Unified approach to keyword and operator recognition
- Clean separation of lexer recognition from parser interpretation
:End Note

Note: Mathematical Symbols (RESTRICTED TO MATH ONLY)
Let mathematical_symbols be list containing:
    "+", "-", "*", "/", "%", "<", ">", "<=", ">=", "!="

Note: Other Single-Character Operators (Non-Mathematical)
Let single_char_operators be list containing:
    "!", "&", "|", "^", "~", "(", ")", "[", "]", "{", "}", ",", ";", ":", "."

Note: Unified Multi-Word Constructs (Single Source of Truth)
Let multi_word_constructs be list containing:
    Note: Comparison operators
    "is greater than", "is less than", "is equal to", "equals", "does not equal", "is not equal to",
    "is greater than or equal to", "is less than or equal to",
    
    Note: Arithmetic operators
    "multiplied by", "divided by", "plus", "minus", "modulo",
    "power of", "shifted left by", "shifted right by",
    
    Note: String operators
    "joined with",
    
    Note: Bitwise operators
    "bitwise and", "bitwise or", "bitwise xor", "bitwise not",
    
    Note: Logical operators
    "logical and", "logical or", "logical not",
    
    Note: Function declaration keywords
    "process called", "that takes", "returns",
    
    Note: Variable declaration keywords
    "let", "be", "define", "set",
    
    Note: Control flow keywords
    "if", "otherwise", "match", "when", "for", "each", "in", "while", "break", "continue",
    
    Note: Exception handling keywords
    "try", "catch", "error", "throw", "return",
    
    Note: Import/export keywords
    "import", "export", "type",
    
    Note: Method call keywords
    "with", "as", "and", "or", "not",
    
    Note: Natural language module access
    "get", "from",
    
    Note: Boolean literals
    "true", "false",
    
    Note: Special values
    "some", "none", "optional", "null", "undefined", "infinity", "nan",
    
    Note: Type keywords
    "string", "integer", "float", "boolean", "any", "void", "list", "dictionary"

Note: Keyword Categories for Parser (Not Lexer)
Let keyword_categories be dictionary containing:
    "control_flow" as list containing "if", "otherwise", "match", "when", "for", "each", "in", "while", "break", "continue",
    "declaration" as list containing "let", "define", "set", "process", "called", "type", "import", "export",
    "function" as list containing "that", "takes", "returns", "with", "as",
    "exception" as list containing "try", "catch", "error", "throw", "return",
    "boolean" as list containing "true", "false", "and", "or", "not",
    "type" as list containing "string", "integer", "float", "boolean", "any", "void", "list", "dictionary", "optional",
    "special" as list containing "some", "none", "null", "undefined", "infinity", "nan"

Note: Operator Precedence for Parser (Not Lexer)
Let operator_precedence be dictionary containing:
    "power of" as 8,
    "multiplied by" as 7, "divided by" as 7, "modulo" as 7,
    "plus" as 6, "minus" as 6, "joined with" as 6,
    "shifted left by" as 5, "shifted right by" as 5,
    "is greater than" as 4, "is less than" as 4, "is equal to" as 4, "equals" as 4, "does not equal" as 4, "is not equal to" as 4,
    "is greater than or equal to" as 4, "is less than or equal to" as 4,
    "bitwise and" as 3,
    "bitwise xor" as 2,
    "bitwise or" as 1,
    "logical and" as 0,
    "logical or" as 0

Note: Operator Associativity for Parser (Not Lexer)
Let operator_associativity be dictionary containing:
    "power of" as "right",
    "multiplied by" as "left", "divided by" as "left", "modulo" as "left",
    "plus" as "left", "minus" as "left", "joined with" as "left",
    "shifted left by" as "left", "shifted right by" as "left",
    "is greater than" as "left", "is less than" as "left", "is equal to" as "left", "equals" as "left", "does not equal" as "left", "is not equal to" as "left",
    "is greater than or equal to" as "left", "is less than or equal to" as "left",
    "bitwise and" as "left",
    "bitwise xor" as "left",
    "bitwise or" as "left",
    "logical and" as "left",
    "logical or" as "left"

Note: Operator Type Classifications with Mathematical Symbol Enforcement
Let operator_types be dictionary containing:
    "plus" as "mathematical",
    "minus" as "mathematical",
    "multiplied by" as "mathematical",
    "divided by" as "mathematical",
    "modulo" as "mathematical",
    "power of" as "mathematical",
    "is greater than" as "mathematical_comparison",
    "is less than" as "mathematical_comparison",
    "is equal to" as "mathematical_comparison",
    "equals" as "comparison",
    "does not equal" as "mathematical_comparison",
    "is not equal to" as "mathematical_comparison",
    "is greater than or equal to" as "mathematical_comparison",
    "is less than or equal to" as "mathematical_comparison",
    "bitwise and" as "bitwise",
    "bitwise or" as "bitwise",
    "bitwise xor" as "bitwise",
    "bitwise not" as "bitwise",
    "shifted left by" as "bitwise",
    "shifted right by" as "bitwise",
    "logical and" as "logical",
    "logical or" as "logical",
    "logical not" as "logical"

Note: Mathematical Symbol Restriction Mapping
Let mathematical_symbol_restrictions be dictionary containing:
    "+" as "mathematical_only",
    "-" as "mathematical_only",
    "*" as "mathematical_only",
    "/" as "mathematical_only",
    "%" as "mathematical_only",
    "<" as "mathematical_only",
    ">" as "mathematical_only",
    "<=" as "mathematical_only",
    ">=" as "mathematical_only",
    "!=" as "mathematical_only"

Note: Unified Definitions Loading Function
Process called "load_definitions" returns Dictionary[String, Any]:
    Note: Load all definitions into a clean structure for the lexer
    Let multi_word_set be set containing
    
    For each construct in multi_word_constructs:
        Add normalize_identifier with text as construct to multi_word_set
    
    Let single_char_set be set containing
    
    For each operator in single_char_operators:
        Add operator to single_char_set
    
    Let mathematical_symbols_set be set containing
    For each symbol in mathematical_symbols:
        Add symbol to mathematical_symbols_set
    
    Return dictionary containing:
        "multi_word_constructs" as multi_word_set
        "single_char_operators" as single_char_set
        "mathematical_symbols" as mathematical_symbols_set
        "mathematical_symbol_restrictions" as mathematical_symbol_restrictions
        "keyword_categories" as keyword_categories
        "operator_precedence" as operator_precedence
        "operator_associativity" as operator_associativity
        "operator_types" as operator_types

Note: Utility Functions
Process called "normalize_identifier" that takes text as String returns String:
    Note: Normalize identifiers for case-insensitive comparison
    Note: Preserve separators (spaces, underscores) but lowercase everything
    Return to_lowercase with text as text 