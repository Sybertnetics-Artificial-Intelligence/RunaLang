Note:
Runa Extended Operators Support

Adds support for missing operators that are commonly used in technical syntax
but were not originally included in Runa's natural language design.

Added Operators:
- = (equality comparison - MATHEMATICAL CONTEXTS ONLY)
- && (logical AND - MATHEMATICAL CONTEXTS ONLY)
- || (logical OR - MATHEMATICAL CONTEXTS ONLY)

Note: <=, >=, and != are already handled by the main lexer

IMPORTANT: These symbols are ONLY for mathematical operations and expressions.
For non-mathematical comparisons, use natural language: "is equal to", "and", "or".
:End Note

Note: Extended operator token definitions
Type called "ExtendedOperator":
    symbol as String
    token_type as String
    precedence as Integer
    associativity as String
    description as String

Type called "OperatorDefinition":
    operators as List[ExtendedOperator]
    precedence_map as Dictionary[String, Integer]
    metadata as Dictionary[String, Any]

Note: Initialize extended operator definitions
Process called "create_extended_operators" returns OperatorDefinition:
    Note: Define all extended operators with precedence and associativity
    Let operators be list containing
    
    Note: Equality operators (precedence 7) - MATHEMATICAL CONTEXTS ONLY
    Add ExtendedOperator with:
        symbol as "="
        token_type as "MATH_EQUALS"
        precedence as 7
        associativity as "left"
        description as "Mathematical equality comparison"
    to operators
    
    Note: != is already handled by main lexer
    Note: Relational operators are already supported in natural language:
    Note: "is less than or equal to" and "is greater than or equal to"
    
    Note: Logical operators (precedence 3-4) - MATHEMATICAL CONTEXTS ONLY
    Add ExtendedOperator with:
        symbol as "&&"
        token_type as "MATH_LOGICAL_AND"
        precedence as 4
        associativity as "left"
        description as "Mathematical logical AND"
    to operators
    
    Add ExtendedOperator with:
        symbol as "||"
        token_type as "MATH_LOGICAL_OR"
        precedence as 3
        associativity as "left"
        description as "Mathematical logical OR"
    to operators
    
    Note: Create precedence map for quick lookup
    Let precedence_map be dictionary containing
    For each operator in operators:
        Set precedence_map[operator.symbol] to operator.precedence
    
    Return OperatorDefinition with:
        operators as operators
        precedence_map as precedence_map
        metadata as dictionary containing

Note: Token recognition for extended operators
Process called "recognize_extended_operator" that takes text as String and position as Integer returns Optional[Token]:
    Note: Recognize extended operators in source text
    Let operators be create_extended_operators()
    
    For each operator in operators.operators:
        If matches_operator_at_position with text as text and position as position and operator as operator:
            Return Some(Token with:
                type as operator.token_type
                value as operator.symbol
                position as position
                length as length of operator.symbol
                metadata as dictionary with "operator_info" as operator)
    
    Return None

Process called "matches_operator_at_position" that takes text as String and position as Integer and operator as ExtendedOperator returns Boolean:
    Note: Check if operator symbol matches at given position
    Let symbol_length be length of operator.symbol
    
    Note: Check if we have enough characters remaining
    If position plus symbol_length is greater than length of text:
        Return false
    
    Note: Check character by character match
    For i from 0 to symbol_length minus 1:
        If character_at with text as text and position as position plus i is not equal to character_at with text as operator.symbol and position as i:
            Return false
    
    Note: Ensure we don't match partial identifiers (like "==" in "===")
    If position plus symbol_length is less than length of text:
        Let next_char be character_at with text as text and position as position plus symbol_length
        If is_operator_continuation_char with char as next_char:
            Return false
    
    Return true

Process called "is_operator_continuation_char" that takes char as String returns Boolean:
    Note: Check if character could continue an operator sequence
    Match char:
        When "=":
            Return true
        When "&":
            Return true
        When "|":
            Return true
        When "!":
            Return true
        When "<":
            Return true
        When ">":
            Return true
        Otherwise:
            Return false

Process called "character_at" that takes text as String and position as Integer returns String:
    Note: Get character at position in string
    If position is less than 0 or position is greater than or equal to length of text:
        Return ""
    
    Note: Convert to character array and access by index
    Let chars be text as List[String]
    Return chars at position

Note: Integration with existing lexer
Process called "extend_lexer_with_operators" that takes lexer as Lexer returns Lexer:
    Note: Extend existing lexer to recognize additional operators
    Let operators be create_extended_operators()
    
    Note: Add operator recognition to lexer's token patterns
    For each operator in operators.operators:
        Call add_operator_pattern with lexer as lexer and operator as operator
    
    Return lexer

Process called "add_operator_pattern" that takes lexer as Lexer and operator as ExtendedOperator returns None:
    Note: Add operator pattern to lexer
    Let pattern be TokenPattern with:
        pattern as escape_operator_for_regex with symbol as operator.symbol
        token_type as operator.token_type
        priority as 100  Note: High priority for operators
        metadata as dictionary with "operator" as operator
    
    Call lexer.add_pattern with pattern as pattern

Process called "escape_operator_for_regex" that takes symbol as String returns String:
    Note: Escape operator symbols for regex pattern matching
    Let escaped be ""
    For each char in symbol:
        Match char:
            When "&":
                Set escaped to escaped plus "\\&"
            When "|":
                Set escaped to escaped plus "\\|"
            When "=":
                Set escaped to escaped plus "\\="
            When "!":
                Set escaped to escaped plus "\\!"
            When "<":
                Set escaped to escaped plus "\\<"
            When ">":
                Set escaped to escaped plus "\\>"
            Otherwise:
                Set escaped to escaped plus char
    Return escaped

Note: Operator precedence and parsing support
Process called "get_operator_precedence" that takes operator as String returns Integer:
    Note: Get precedence for operator during parsing
    Let operators be create_extended_operators()
    
    If operators.precedence_map contains operator:
        Return operators.precedence_map[operator]
    
    Note: Default precedences for existing Runa operators
    Match operator:
        When "plus":
            Return 10
        When "minus":
            Return 10
        When "multiplied by":
            Return 11
        When "divided by":
            Return 11
        When "is greater than":
            Return 8
        When "is less than":
            Return 8
        When "is equal to":
            Return 7
        When "and":
            Return 4
        When "or":
            Return 3
        Otherwise:
            Return 5

Process called "get_operator_associativity" that takes operator as String returns String:
    Note: Get associativity for operator during parsing
    Let operators be create_extended_operators()
    
    For each op in operators.operators:
        If op.symbol is equal to operator:
            Return op.associativity
    
    Note: Default to left associativity
    Return "left"

Process called "is_extended_operator" that takes symbol as String returns Boolean:
    Note: Check if symbol is one of our extended operators
    Let operators be create_extended_operators()
    
    For each operator in operators.operators:
        If operator.symbol is equal to symbol:
            Return true
    
    Return false

Note: Semantic analysis support for extended operators
Process called "analyze_extended_operator" that takes operator as String and left_operand as ASTNode and right_operand as ASTNode returns OperatorAnalysis:
    Note: Analyze extended operator usage for type checking
    Let analysis be OperatorAnalysis with:
        operator as operator
        is_valid as true
        result_type as "Boolean"
        error_message as None
        warnings as list containing
    
    Match operator:
        When "=":
            Return analyze_math_equality_operator with left as left_operand and right as right_operand
        Note: !=, <=, and >= are handled by natural language operators
        When "&&":
            Return analyze_math_logical_and with left as left_operand and right as right_operand
        When "||":
            Return analyze_math_logical_or with left as left_operand and right as right_operand
        Otherwise:
            Set analysis.is_valid to false
            Set analysis.error_message to Some("Unknown extended operator: " plus operator)
            Return analysis

Process called "analyze_math_equality_operator" that takes left as ASTNode and right as ASTNode returns OperatorAnalysis:
    Note: Analyze = operator for type compatibility - MATHEMATICAL CONTEXTS ONLY
    Let left_type be infer_expression_type with node as left
    Let right_type be infer_expression_type with node as right
    
    Let analysis be OperatorAnalysis with:
        operator as "="
        is_valid as true
        result_type as "Boolean"
        error_message as None
        warnings as list containing
    
    Note: Verify this is in a mathematical context
    If not is_mathematical_context with left as left and right as right:
        Set analysis.is_valid to false
        Set analysis.error_message to Some("Symbol '=' can only be used in mathematical expressions. Use 'is equal to' for general comparisons.")
        Return analysis
    
    Note: Check type compatibility for mathematical equality
    If not are_math_types_comparable with type1 as left_type and type2 as right_type:
        Set analysis.is_valid to false
        Set analysis.error_message to Some("Cannot mathematically compare " plus left_type plus " with " plus right_type)
    
    Return analysis

Note: analyze_inequality_operator removed - != handled by main lexer

Note: analyze_comparison_operator removed - <=, >= handled by main lexer

Process called "analyze_math_logical_and" that takes left as ASTNode and right as ASTNode returns OperatorAnalysis:
    Note: Analyze && operator for boolean operands - MATHEMATICAL CONTEXTS ONLY
    Let left_type be infer_expression_type with node as left
    Let right_type be infer_expression_type with node as right
    
    Let analysis be OperatorAnalysis with:
        operator as "&&"
        is_valid as true
        result_type as "Boolean"
        error_message as None
        warnings as list containing
    
    Note: Verify this is in a mathematical context
    If not is_mathematical_context with left as left and right as right:
        Set analysis.is_valid to false
        Set analysis.error_message to Some("Symbol '&&' can only be used in mathematical expressions. Use 'and' for general logic.")
        Return analysis
    
    Note: Check that both operands are boolean-compatible in mathematical context
    If not is_math_boolean_type with type as left_type:
        Set analysis.is_valid to false
        Set analysis.error_message to Some("Left operand of mathematical && must be boolean, got " plus left_type)
    
    If not is_math_boolean_type with type as right_type:
        Set analysis.is_valid to false
        Set analysis.error_message to Some("Right operand of mathematical && must be boolean, got " plus right_type)
    
    Return analysis

Process called "analyze_math_logical_or" that takes left as ASTNode and right as ASTNode returns OperatorAnalysis:
    Note: Analyze || operator for boolean operands - MATHEMATICAL CONTEXTS ONLY
    Let left_type be infer_expression_type with node as left
    Let right_type be infer_expression_type with node as right
    
    Let analysis be OperatorAnalysis with:
        operator as "||"
        is_valid as true
        result_type as "Boolean"
        error_message as None
        warnings as list containing
    
    Note: Verify this is in a mathematical context
    If not is_mathematical_context with left as left and right as right:
        Set analysis.is_valid to false
        Set analysis.error_message to Some("Symbol '||' can only be used in mathematical expressions. Use 'or' for general logic.")
        Return analysis
    
    Note: Check that both operands are boolean-compatible in mathematical context
    If not is_math_boolean_type with type as left_type:
        Set analysis.is_valid to false
        Set analysis.error_message to Some("Left operand of mathematical || must be boolean, got " plus left_type)
    
    If not is_math_boolean_type with type as right_type:
        Set analysis.is_valid to false
        Set analysis.error_message to Some("Right operand of mathematical || must be boolean, got " plus right_type)
    
    Return analysis

Note: Mathematical context detection
Process called "is_mathematical_context" that takes left as ASTNode and right as ASTNode returns Boolean:
    Note: Check if both operands are in a mathematical context
    Let left_is_math be is_mathematical_expression with node as left
    Let right_is_math be is_mathematical_expression with node as right
    Return left_is_math and right_is_math

Process called "is_mathematical_expression" that takes node as ASTNode returns Boolean:
    Note: Check if expression contains mathematical elements
    Match node.node_type:
        When "Literal":
            Return is_numeric_literal with value as node.value
        When "Identifier":
            Return is_mathematical_identifier with name as node.value as String
        When "BinaryOperation":
            Return contains_mathematical_operator with node as node
        When "FunctionCall":
            Return is_mathematical_function with node as node
        Otherwise:
            Return false

Process called "is_mathematical_identifier" that takes name as String returns Boolean:
    Note: Check if identifier is mathematical (variables like x, y, α, β)
    If length of name is equal to 1:
        Let char_code be name as Integer
        Note: Single letter variables are typically mathematical
        If char_code is greater than or equal to 97 and char_code is less than or equal to 122:  Note: a-z
            Return true
        If char_code is greater than or equal to 65 and char_code is less than or equal to 90:   Note: A-Z
            Return true
    
    Note: Greek letters and mathematical symbols
    Match name:
        When "α", "β", "γ", "δ", "θ", "λ", "π", "σ", "φ", "ω":
            Return true
        When "sin", "cos", "tan", "log", "exp", "sqrt":
            Return true
        Otherwise:
            Return false

Process called "contains_mathematical_operator" that takes node as ASTNode returns Boolean:
    Note: Check if binary operation uses mathematical operators
    If length of node.children is less than 3:
        Return false
    
    Let operator be get_node_text with node as node.children[1]
    Match operator:
        When "+", "-", "*", "/", "^", "=", "≤", "≥", "≠":
            Return true
        When "&&", "||":
            Note: Only mathematical if operands are mathematical
            Return is_mathematical_expression with node as node.children[0] and is_mathematical_expression with node as node.children[2]
        Otherwise:
            Return false

Process called "is_mathematical_function" that takes node as ASTNode returns Boolean:
    Note: Check if function call is mathematical
    If length of node.children is equal to 0:
        Return false
    
    Let function_name be get_node_text with node as node.children[0]
    Match function_name:
        When "sin", "cos", "tan", "asin", "acos", "atan":
            Return true
        When "log", "ln", "exp", "pow", "sqrt", "abs":
            Return true
        When "∑", "∏", "∫":  Note: Mathematical symbols
            Return true
        Otherwise:
            Return false

Process called "is_numeric_literal" that takes value as Any returns Boolean:
    Note: Check if literal value is numeric
    Try:
        If value is Integer or value is Float:
            Return true
        Return false
    Catch error:
        Return false

Note: Mathematical type checking utilities
Process called "are_math_types_comparable" that takes type1 as String and type2 as String returns Boolean:
    Note: Check if two types can be compared for mathematical equality
    If type1 is equal to type2:
        Return true
    
    Note: All numeric types are mathematically comparable
    If is_numeric_type with type as type1 and is_numeric_type with type as type2:
        Return true
    
    Note: Mathematical vectors/matrices are comparable
    If is_mathematical_type with type as type1 and is_mathematical_type with type as type2:
        Return true
    
    Return false

Process called "is_math_boolean_type" that takes type as String returns Boolean:
    Note: Check if type can be used in mathematical boolean operations
    Match type:
        When "Boolean":
            Return true
        When "MathematicalPredicate":
            Return true
        When "LogicalExpression":
            Return true
        Otherwise:
            Return false

Process called "is_mathematical_type" that takes type as String returns Boolean:
    Note: Check if type is mathematical
    Match type:
        When "Integer", "Float", "Number", "Complex":
            Return true
        When "Vector", "Matrix", "Tensor":
            Return true
        When "MathematicalExpression", "Equation":
            Return true
        Otherwise:
            Return false

Note: Legacy type checking utilities (kept for compatibility)
Process called "are_types_comparable" that takes type1 as String and type2 as String returns Boolean:
    Note: Check if two types can be compared for equality (general)
    If type1 is equal to type2:
        Return true
    
    Note: Numeric types are comparable
    If is_numeric_type with type as type1 and is_numeric_type with type as type2:
        Return true
    
    Note: String and character types are comparable
    If is_string_type with type as type1 and is_string_type with type as type2:
        Return true
    
    Return false

Process called "are_types_orderable" that takes type1 as String and type2 as String returns Boolean:
    Note: Check if two types can be ordered (< > <= >=)
    Note: Numeric types are orderable
    If is_numeric_type with type as type1 and is_numeric_type with type as type2:
        Return true
    
    Note: String types are orderable (lexicographic)
    If is_string_type with type as type1 and is_string_type with type as type2:
        Return true
    
    Return false

Process called "is_boolean_convertible" that takes type as String returns Boolean:
    Note: Check if type can be converted to boolean
    Match type:
        When "Integer":
            Return true  Note: 0 is false, non-zero is true
        When "String":
            Return true  Note: Empty string is false, non-empty is true
        When "Optional":
            Return true  Note: None is false, Some is true
        Otherwise:
            Return false

Process called "is_numeric_type" that takes type as String returns Boolean:
    Note: Check if type is numeric
    Match type:
        When "Integer":
            Return true
        When "Float":
            Return true
        When "Number":
            Return true
        Otherwise:
            Return false

Process called "is_string_type" that takes type as String returns Boolean:
    Note: Check if type is string-like
    Match type:
        When "String":
            Return true
        When "Character":
            Return true
        Otherwise:
            Return false

Process called "infer_expression_type" that takes node as ASTNode returns String:
    Note: Infer the type of an expression node
    Match node.node_type:
        When "Literal":
            Return infer_literal_type with value as node.value
        When "Identifier":
            Return "Unknown"  Note: Would need symbol table lookup
        When "BinaryOperation":
            Return infer_binary_operation_type with node as node
        Otherwise:
            Return "Unknown"

Process called "infer_literal_type" that takes value as Any returns String:
    Note: Infer type from literal value
    Try:
        If value is Integer:
            Return "Integer"
        If value is Float:
            Return "Float"
        If value is String:
            Return "String"
        If value is Boolean:
            Return "Boolean"
        Return "Unknown"
    Catch error:
        Return "Unknown"

Process called "infer_binary_operation_type" that takes node as ASTNode returns String:
    Note: Infer result type of binary operation
    If length of node.children is less than 3:
        Return "Unknown"
    
    Let operator be get_node_text with node as node.children[1]
    
    Match operator:
        When "==":
            Return "Boolean"
        When "!=":
            Return "Boolean"
        When "<=":
            Return "Boolean"
        When ">=":
            Return "Boolean"
        When "&&":
            Return "Boolean"
        When "||":
            Return "Boolean"
        When "+":
            Return infer_arithmetic_result_type with left as node.children[0] and right as node.children[2]
        When "-":
            Return infer_arithmetic_result_type with left as node.children[0] and right as node.children[2]
        When "*":
            Return infer_arithmetic_result_type with left as node.children[0] and right as node.children[2]
        When "/":
            Return "Float"  Note: Division always returns float
        Otherwise:
            Return "Unknown"

Process called "infer_arithmetic_result_type" that takes left as ASTNode and right as ASTNode returns String:
    Note: Infer result type of arithmetic operation
    Let left_type be infer_expression_type with node as left
    Let right_type be infer_expression_type with node as right
    
    Note: If either operand is float, result is float
    If left_type is equal to "Float" or right_type is equal to "Float":
        Return "Float"
    
    Note: If both are integers, result is integer
    If left_type is equal to "Integer" and right_type is equal to "Integer":
        Return "Integer"
    
    Return "Number"

Process called "get_node_text" that takes node as ASTNode returns String:
    Note: Extract text representation of AST node
    Match node.node_type:
        When "Identifier":
            Return node.value as String
        When "Literal":
            Return node.value as String
        When "Operator":
            Return node.value as String
        Otherwise:
            Return ""

Note: Supporting types
Type called "Token":
    type as String
    value as String
    position as Integer
    length as Integer
    metadata as Dictionary[String, Any]

Type called "TokenPattern":
    pattern as String
    token_type as String
    priority as Integer
    metadata as Dictionary[String, Any]

Type called "OperatorAnalysis":
    operator as String
    is_valid as Boolean
    result_type as String
    error_message as Optional[String]
    warnings as List[String]

Note: Main integration function
Process called "initialize_extended_operators" that takes compiler as Compiler returns Compiler:
    Note: Initialize extended operator support in compiler
    Note: This should be called during compiler initialization
    
    Note: Extend lexer with new operators
    Set compiler.lexer to extend_lexer_with_operators with lexer as compiler.lexer
    
    Note: Register operators with parser
    Call register_extended_operators_with_parser with parser as compiler.parser
    
    Note: Add operator analysis to semantic analyzer
    Call register_extended_operators_with_analyzer with analyzer as compiler.semantic_analyzer
    
    Return compiler