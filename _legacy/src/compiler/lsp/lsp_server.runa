Note:
Runa Language Server Protocol (LSP) Server: Core Implementation

This module implements the Language Server Protocol server for Runa, providing
first-class IDE support including autocompletion, hover information, go-to-definition,
find all references, and real-time error reporting.

Key Features:
- JSON-RPC communication with IDEs
- Real-time semantic analysis
- Incremental parsing and analysis
- Comprehensive code intelligence
- Performance optimization with caching
- Error recovery and diagnostics
:End Note

Note: Import dependencies
Import "../semantic/semantic_analyzer.runa"
Import "../semantic/diagnostics.runa"
Import "../lexer/lexer.runa"
Import "../parser/parser.runa"
Import "lsp_types.runa"
Import "lsp_handlers.runa"

Note: LSP Server Core Type
Type LSPServer is Dictionary with:
    Private state as LSPState
    Private semantic_analyzer as SemanticAnalyzer
    Private diagnostic_engine as SemanticDiagnosticEngine
    Private analysis_cache as Dictionary[String, AnalysisResult]
    Private document_cache as Dictionary[String, DocumentState]
    Private performance_metrics as Dictionary[String, Any]
    Private configuration as LSPServerConfig

Note: LSP Server State
Type LSPState is Dictionary with:
    initialized as Boolean
    shutdown_requested as Boolean
    exit_requested as Boolean
    client_capabilities as ClientCapabilities
    server_capabilities as ServerCapabilities
    workspace_folders as List[WorkspaceFolder]
    root_path as String
    root_uri as String

Note: LSP Server Configuration
Type LSPServerConfig is Dictionary with:
    max_errors as Integer
    max_warnings as Integer
    enable_incremental_analysis as Boolean
    cache_size as Integer
    performance_tracking as Boolean
    debug_mode as Boolean

Note: Document State
Type DocumentState is Dictionary with:
    uri as String
    version as Integer
    content as String
    ast as ASTNode
    semantic_result as Dictionary[String, Any]
    last_analysis_time as Integer
    diagnostics as List[Diagnostic]

Note: Analysis Result
Type AnalysisResult is Dictionary with:
    success as Boolean
    ast as ASTNode
    symbol_table as SymbolTable
    type_environment as Dictionary[String, RunaType]
    diagnostics as List[Diagnostic]
    performance_metrics as Dictionary[String, Any]

Note: LSP Server Creation
Process called "create_lsp_server" that takes config as LSPServerConfig returns LSPServer:
    Note: Create a new LSP server instance
    Let diagnostic_engine be create_semantic_diagnostic_engine with max_errors as config.max_errors and max_warnings as config.max_warnings
    
    Let performance_metrics be dictionary containing:
        "requests_processed" as 0
        "analysis_time_ms" as 0
        "cache_hits" as 0
        "cache_misses" as 0
        "documents_analyzed" as 0
        "errors_reported" as 0
        "warnings_reported" as 0
    
    Let server_state be LSPState with:
        initialized as false
        shutdown_requested as false
        exit_requested as false
        client_capabilities as create_default_client_capabilities
        server_capabilities as create_default_server_capabilities
        workspace_folders as list containing
        root_path as ""
        root_uri as ""
    
    Return LSPServer with:
        state as server_state
        semantic_analyzer as None  Note: Will be created per document
        diagnostic_engine as diagnostic_engine
        analysis_cache as dictionary containing
        document_cache as dictionary containing
        performance_metrics as performance_metrics
        configuration as config

Note: Main LSP Server Loop
Process called "run_lsp_server" that takes server as LSPServer:
    Note: Main server loop for handling LSP requests
    Print "ðŸš€ Runa LSP Server starting..."
    
    While not server.state.exit_requested:
        Let request be read_lsp_request
        
        If request is None:
            Continue
        
        Let response be handle_lsp_request with server as server and request as request
        
        If response is not None:
            send_lsp_response with response as response
        
        Set server.performance_metrics.requests_processed to server.performance_metrics.requests_processed plus 1
    
    Print "ðŸ›‘ Runa LSP Server shutting down..."

Note: LSP Request Handler
Process called "handle_lsp_request" that takes server as LSPServer and request as LSPRequest returns Optional[LSPResponse]:
    Note: Route LSP requests to appropriate handlers
    Let start_time be get_current_time_ms
    
    Try:
        Match request.method:
            When "initialize":
                Return handle_initialize with server as server and params as request.params
            
            When "initialized":
                Return handle_initialized with server as server and params as request.params
            
            When "shutdown":
                Return handle_shutdown with server as server and params as request.params
            
            When "exit":
                Return handle_exit with server as server and params as request.params
            
            When "textDocument/didOpen":
                Return handle_document_did_open with server as server and params as request.params
            
            When "textDocument/didChange":
                Return handle_document_did_change with server as server and params as request.params
            
            When "textDocument/didClose":
                Return handle_document_did_close with server as server and params as request.params
            
            When "textDocument/completion":
                Return handle_completion with server as server and params as request.params
            
            When "textDocument/hover":
                Return handle_hover with server as server and params as request.params
            
            When "textDocument/definition":
                Return handle_definition with server as server and params as request.params
            
            When "textDocument/references":
                Return handle_references with server as server and params as request.params
            
            When "textDocument/documentSymbol":
                Return handle_document_symbols with server as server and params as request.params
            
            When "textDocument/semanticTokens/full":
                Return handle_semantic_tokens with server as server and params as request.params
            
            When "workspace/didChangeConfiguration":
                Return handle_workspace_configuration_change with server as server and params as request.params
            
            Otherwise:
                Return create_error_response with request_id as request.id and error_code as -32601 and message as "Method not found: " plus request.method
    
    Catch error:
        Return create_error_response with request_id as request.id and error_code as -32603 and message as "Internal error: " plus error.message

Note: Document Analysis
Process called "analyze_document" that takes server as LSPServer and uri as String and content as String returns AnalysisResult:
    Note: Perform comprehensive analysis of a document
    Let start_time be get_current_time_ms
    
    Note: Check cache first
    If uri is in server.analysis_cache:
        Let cached_result be server.analysis_cache at key uri
        If cached_result.content is equal to content:
            Set server.performance_metrics.cache_hits to server.performance_metrics.cache_hits plus 1
            Return cached_result
    
    Set server.performance_metrics.cache_misses to server.performance_metrics.cache_misses plus 1
    
    Note: Lexical analysis
    Let tokens be tokenize with source_code as content and file_path as uri
    
    Note: Syntactic analysis
    Let parsing_result be parse_program with tokens as tokens and file_path as uri
    
    If not parsing_result.success:
        Return AnalysisResult with:
            success as false
            ast as None
            symbol_table as None
            type_environment as dictionary containing
            diagnostics as parsing_result.errors
            performance_metrics as dictionary containing
    
    Note: Semantic analysis
    Let semantic_result be analyze_semantics with ast as parsing_result.ast and file_path as uri and diagnostic_engine as server.diagnostic_engine
    
    Let end_time be get_current_time_ms
    Let analysis_time be end_time minus start_time
    Set server.performance_metrics.analysis_time_ms to server.performance_metrics.analysis_time_ms plus analysis_time
    Set server.performance_metrics.documents_analyzed to server.performance_metrics.documents_analyzed plus 1
    
    Let result be AnalysisResult with:
        success as semantic_result.success
        ast as parsing_result.ast
        symbol_table as semantic_result.symbol_table
        type_environment as semantic_result.type_environment
        diagnostics as semantic_result.errors
        performance_metrics as dictionary containing:
            "analysis_time_ms" as analysis_time
            "tokens_count" as length of tokens
            "ast_nodes" as count_ast_nodes with ast as parsing_result.ast
    
    Note: Cache the result
    Set server.analysis_cache at key uri to result
    
    Return result

Note: Incremental Analysis
Process called "analyze_document_incrementally" that takes server as LSPServer and uri as String and changes as List[TextDocumentContentChangeEvent] returns AnalysisResult:
    Note: Perform incremental analysis for better performance
    If not server.configuration.enable_incremental_analysis:
        Return analyze_document with server as server and uri as uri and content as get_document_content with server as server and uri as uri
    
    Note: Apply changes to document content
    Let current_content be get_document_content with server as server and uri as uri
    Let new_content be apply_text_changes with content as current_content and changes as changes
    
    Note: Perform full analysis (simplified for now)
    Return analyze_document with server as server and uri as uri and content as new_content

Note: Utility Functions
Process called "get_document_content" that takes server as LSPServer and uri as String returns String:
    Note: Get document content from cache
    If uri is in server.document_cache:
        Return server.document_cache at key uri.content
    Otherwise:
        Return ""

Process called "update_document_content" that takes server as LSPServer and uri as String and content as String and version as Integer:
    Note: Update document content in cache
    If uri is in server.document_cache:
        Let doc_state be server.document_cache at key uri
        Set doc_state.content to content
        Set doc_state.version to version
    Otherwise:
        Let doc_state be DocumentState with:
            uri as uri
            version as version
            content as content
            ast as None
            semantic_result as dictionary containing
            last_analysis_time as 0
            diagnostics as list containing
        Set server.document_cache at key uri to doc_state

Process called "count_ast_nodes" that takes ast as ASTNode returns Integer:
    Note: Count nodes in AST for performance metrics
    If ast is None:
        Return 0
    
    Let count be 1  Note: Count current node
    
    If ast.statements is not None:
        For each statement in ast.statements:
            Set count to count plus count_ast_nodes with ast as statement
    
    If ast.left is not None:
        Set count to count plus count_ast_nodes with ast as ast.left
    
    If ast.right is not None:
        Set count to count plus count_ast_nodes with ast as ast.right
    
    If ast.arguments is not None:
        For each arg in ast.arguments:
            Set count to count plus count_ast_nodes with ast as arg
    
    Return count

Process called "apply_text_changes" that takes content as String and changes as List[TextDocumentContentChangeEvent] returns String:
    Note: Apply text changes to document content
    Let result be content
    
    For each change in changes:
        If change.range is not None:
            Let start_pos be position_to_offset with text as result and position as change.range.start
            Let end_pos be position_to_offset with text as result and position as change.range.end
            Let before_text be result from index 0 to start_pos
            Let after_text be result from index end_pos to length of result
            Set result to before_text plus change.text plus after_text
        Otherwise:
            Set result to change.text
    
    Return result

Process called "position_to_offset" that takes text as String and position as Position returns Integer:
    Note: Convert LSP position to character offset
    Let offset be 0
    Let line be 0
    Let column be 0
    
    For i from 0 to length of text minus 1:
        If line is equal to position.line and column is equal to position.character:
            Return offset
        
        If text at index i is equal to "\n":
            Set line to line plus 1
            Set column to 0
        Otherwise:
            Set column to column plus 1
        
        Set offset to offset plus 1
    
    Return offset

Process called "offset_to_position" that takes text as String and offset as Integer returns Position:
    Note: Convert character offset to LSP position
    Let line be 0
    Let column be 0
    
    For i from 0 to offset minus 1:
        If i is greater than or equal to length of text:
            Break
        
        If text at index i is equal to "\n":
            Set line to line plus 1
            Set column to 0
        Otherwise:
            Set column to column plus 1
    
    Return Position with line as line and character as column

Process called "get_server_performance_metrics" that takes server as LSPServer returns Dictionary[String, Any]:
    Note: Get performance metrics from server
    Return server.performance_metrics

Process called "clear_server_cache" that takes server as LSPServer:
    Note: Clear server cache
    Set server.analysis_cache to dictionary containing
    Set server.document_cache to dictionary containing
    Set server.performance_metrics to dictionary containing:
        "requests_processed" as 0
        "analysis_time_ms" as 0
        "cache_hits" as 0
        "cache_misses" as 0
        "documents_analyzed" as 0
        "errors_reported" as 0
        "warnings_reported" as 0 