Note: Comprehensive test suite for the Syscall Cache System
Note: Tests LRU cache operations, thread safety, TTL, and performance optimization

@Reasoning
The syscall cache is a critical performance optimization that reduces context switch
overhead by caching frequently accessed syscall results. Testing must verify correct
cache behavior including LRU eviction, TTL expiration, thread-safe operations, 
invalidation strategies, and performance metrics. These tests ensure the cache
improves performance without returning stale data or causing race conditions.
@End Reasoning

@TestCases
- Basic cache operations (insert, lookup, evict)
- LRU replacement policy correctness
- TTL expiration and validation
- Thread-safe concurrent access
- Cache invalidation strategies
- Performance metrics and statistics
- Cache warming and prefetching
- Auto-tuning based on hit rates
- Memory management and entry lifecycle
- Hash collision handling
@End TestCases

Import module "runatime/integration/system_interface/syscall_cache" as Cache
Import module "compiler/frontend/primitives/types/compiler_internals" as Internals
Import module "compiler/backend/syscalls/syscall_registry" as Registry
Import module "stdlib/testing/test_framework" as Test
Import module "stdlib/core/primitives/string_primitives" as StringPrim
Import module "stdlib/core/primitives/integer_primitives" as IntPrim

Note: =====================================================================
Note: BASIC CACHE OPERATIONS
Note: =====================================================================

Process called "test_create_cache" returns Nothing:
    @Performance_Hints
    Tests basic cache creation and initialization.
    @End Performance_Hints
    
    Let cache be Cache.create_syscall_cache()
    
    Test.assert_not_null(cache)
    Test.assert_equals(cache.cache_size, Cache.DEFAULT_CACHE_SIZE)
    Test.assert_equals(cache.ttl_ms, Cache.DEFAULT_TTL_MS)
    Test.assert_equals(cache.current_size, 0)
    Test.assert_true(cache.enabled)
    Test.assert_equals(cache.lru_head, 0)
    Test.assert_equals(cache.lru_tail, 0)
    
    Note: Verify statistics initialization
    Let stats be cache.statistics
    Test.assert_equals(stats.total_hits, 0)
    Test.assert_equals(stats.total_misses, 0)
    Test.assert_equals(stats.total_evictions, 0)
    Test.assert_equals(stats.cache_efficiency, 0.0)
    Test.assert_equals(stats.bytes_saved, 0)
    Test.assert_equals(stats.avg_hit_time_ns, 0)
End Process

Process called "test_custom_config_cache" returns Nothing:
    @Performance_Hints
    Tests cache creation with custom configuration.
    @End Performance_Hints
    
    Let custom_size be 256
    Let custom_ttl be 5000  Note: 5 seconds
    Let cache be Cache.create_cache_with_config(custom_size, custom_ttl)
    
    Test.assert_not_null(cache)
    Test.assert_equals(cache.cache_size, custom_size)
    Test.assert_equals(cache.ttl_ms, custom_ttl)
    Test.assert_equals(cache.current_size, 0)
    Test.assert_true(cache.enabled)
End Process

Process called "test_cache_insert_and_lookup" returns Nothing:
    @Performance_Hints
    Tests basic cache insertion and retrieval.
    @End Performance_Hints
    
    Let cache be Cache.create_syscall_cache()
    
    Note: Create arguments for getpid syscall
    Let args be Internals.create_internal_array(0)  Note: getpid has no args
    Let expected_result be 12345  Note: Mock PID
    
    Note: Cache the result
    Cache.cache_syscall_result(cache, Registry.SYSCALL_GETPID, args, expected_result)
    
    Test.assert_equals(cache.current_size, 1)
    
    Note: Lookup cached result
    Let result be Cache.lookup_syscall(cache, Registry.SYSCALL_GETPID, args)
    
    Test.assert_true(result.is_success)
    Test.assert_equals(result.value, expected_result)
    Test.assert_equals(cache.statistics.total_hits, 1)
    Test.assert_equals(cache.statistics.total_misses, 0)
End Process

Process called "test_cache_miss" returns Nothing:
    @Performance_Hints
    Tests cache miss behavior.
    @End Performance_Hints
    
    Let cache be Cache.create_syscall_cache()
    
    Note: Lookup non-existent entry
    Let args be Internals.create_internal_array(0)
    Let result be Cache.lookup_syscall(cache, Registry.SYSCALL_GETUID, args)
    
    Test.assert_false(result.is_success)
    Test.assert_equals(result.value, minus 1)
    Test.assert_equals(cache.statistics.total_hits, 0)
    Test.assert_equals(cache.statistics.total_misses, 1)
End Process

Note: =====================================================================
Note: LRU EVICTION POLICY
Note: =====================================================================

Process called "test_lru_eviction" returns Nothing:
    @Performance_Hints
    Tests LRU eviction when cache is full.
    @End Performance_Hints
    
    Let cache be Cache.create_cache_with_config(4, 60000)  Note: Small cache
    
    Note: Fill cache beyond capacity
    Let i be 0
    While i less than 6:
        Let args be create_args_with_value(i)
        Cache.cache_syscall_result(cache, Registry.SYSCALL_GETUID, args, i)
        Set i to i plus 1
    End While
    
    Note: Cache should have evicted oldest entries
    Test.assert_less_than_or_equal(cache.current_size, 4)
    Test.assert_greater_than(cache.statistics.total_evictions, 0)
    
    Note: Oldest entries should be evicted
    Let args0 be create_args_with_value(0)
    Let result0 be Cache.lookup_syscall(cache, Registry.SYSCALL_GETUID, args0)
    Test.assert_false(result0.is_success)  Note: Should be evicted
    
    Note: Newest entries should still be present
    Let args5 be create_args_with_value(5)
    Let result5 be Cache.lookup_syscall(cache, Registry.SYSCALL_GETUID, args5)
    Test.assert_true(result5.is_success)  Note: Should be present
    Test.assert_equals(result5.value, 5)
End Process

Process called "test_lru_promotion" returns Nothing:
    @Performance_Hints
    Tests LRU promotion on cache hit.
    @End Performance_Hints
    
    Let cache be Cache.create_cache_with_config(3, 60000)  Note: Small cache
    
    Note: Insert three entries
    Let args1 be create_args_with_value(1)
    Let args2 be create_args_with_value(2)
    Let args3 be create_args_with_value(3)
    
    Cache.cache_syscall_result(cache, Registry.SYSCALL_GETUID, args1, 100)
    Cache.cache_syscall_result(cache, Registry.SYSCALL_GETUID, args2, 200)
    Cache.cache_syscall_result(cache, Registry.SYSCALL_GETUID, args3, 300)
    
    Note: Access first entry to promote it
    Let result be Cache.lookup_syscall(cache, Registry.SYSCALL_GETUID, args1)
    Test.assert_true(result.is_success)
    
    Note: Insert fourth entry (should evict entry 2, not entry 1)
    Let args4 be create_args_with_value(4)
    Cache.cache_syscall_result(cache, Registry.SYSCALL_GETUID, args4, 400)
    
    Note: Entry 1 should still be present (was promoted)
    Set result to Cache.lookup_syscall(cache, Registry.SYSCALL_GETUID, args1)
    Test.assert_true(result.is_success)
    
    Note: Entry 2 should be evicted
    Set result to Cache.lookup_syscall(cache, Registry.SYSCALL_GETUID, args2)
    Test.assert_false(result.is_success)
End Process

Note: =====================================================================
Note: TTL EXPIRATION
Note: =====================================================================

Process called "test_ttl_expiration" returns Nothing:
    @Performance_Hints
    Tests entry expiration based on TTL.
    @End Performance_Hints
    
    Let cache be Cache.create_cache_with_config(10, 100)  Note: 100ms TTL
    
    Let args be Internals.create_internal_array(0)
    Cache.cache_syscall_result(cache, Registry.SYSCALL_GETPID, args, 12345)
    
    Note: Immediate lookup should succeed
    Let result be Cache.lookup_syscall(cache, Registry.SYSCALL_GETPID, args)
    Test.assert_true(result.is_success)
    
    Note: Wait for TTL to expire
    sleep_milliseconds(150)
    
    Note: Lookup after TTL should fail
    Set result to Cache.lookup_syscall(cache, Registry.SYSCALL_GETPID, args)
    Test.assert_false(result.is_success)
    Test.assert_equals(cache.statistics.total_misses, 1)
End Process

Process called "test_entry_validation" returns Nothing:
    @Performance_Hints
    Tests entry validation logic.
    @End Performance_Hints
    
    Let entry be Cache.SyscallCacheEntry()
    Set entry.is_valid to true
    Set entry.timestamp to get_current_timestamp_ms()
    
    Note: Fresh entry should be valid
    Let is_valid be Cache.is_entry_valid(entry, 1000)
    Test.assert_true(is_valid)
    
    Note: Invalid flag should invalidate
    Set entry.is_valid to false
    Set is_valid to Cache.is_entry_valid(entry, 1000)
    Test.assert_false(is_valid)
    
    Note: Old timestamp should invalidate
    Set entry.is_valid to true
    Set entry.timestamp to entry.timestamp minus 2000
    Set is_valid to Cache.is_entry_valid(entry, 1000)
    Test.assert_false(is_valid)
End Process

Note: =====================================================================
Note: CACHE KEY GENERATION
Note: =====================================================================

Process called "test_cache_key_generation" returns Nothing:
    @Performance_Hints
    Tests unique key generation for cache entries.
    @End Performance_Hints
    
    Note: Same syscall and args should generate same key
    Let args1 be create_args_with_value(42)
    Let key1 be Cache.generate_cache_key(Registry.SYSCALL_READ, args1)
    
    Let args2 be create_args_with_value(42)
    Let key2 be Cache.generate_cache_key(Registry.SYSCALL_READ, args2)
    
    Test.assert_equals(key1, key2)
    
    Note: Different args should generate different keys
    Let args3 be create_args_with_value(43)
    Let key3 be Cache.generate_cache_key(Registry.SYSCALL_READ, args3)
    
    Test.assert_not_equals(key1, key3)
    
    Note: Different syscalls should generate different keys
    Let key4 be Cache.generate_cache_key(Registry.SYSCALL_WRITE, args1)
    
    Test.assert_not_equals(key1, key4)
End Process

Process called "test_argument_hashing" returns Nothing:
    @Performance_Hints
    Tests FNV-1a hash function for arguments.
    @End Performance_Hints
    
    Note: Empty args should have deterministic hash
    Let empty_args be Internals.create_internal_array(0)
    Let empty_hash be Cache.hash_arguments(empty_args)
    Test.assert_equals(empty_hash, Cache.FNV_OFFSET_BASIS)
    
    Note: Single arg should produce different hash
    Let single_args be Internals.create_internal_array(1)
    Internals.internal_array_add(single_args, 42)
    Let single_hash be Cache.hash_arguments(single_args)
    Test.assert_not_equals(single_hash, empty_hash)
    
    Note: Multiple args should chain properly
    Let multi_args be Internals.create_internal_array(3)
    Internals.internal_array_add(multi_args, 1)
    Internals.internal_array_add(multi_args, 2)
    Internals.internal_array_add(multi_args, 3)
    Let multi_hash be Cache.hash_arguments(multi_args)
    Test.assert_not_equals(multi_hash, single_hash)
    Test.assert_not_equals(multi_hash, empty_hash)
End Process

Note: =====================================================================
Note: CACHE INVALIDATION
Note: =====================================================================

Process called "test_invalidate_entry" returns Nothing:
    @Performance_Hints
    Tests individual entry invalidation.
    @End Performance_Hints
    
    Let cache be Cache.create_syscall_cache()
    
    Let args be Internals.create_internal_array(0)
    Cache.cache_syscall_result(cache, Registry.SYSCALL_GETPID, args, 12345)
    
    Note: Entry should be valid initially
    Let result be Cache.lookup_syscall(cache, Registry.SYSCALL_GETPID, args)
    Test.assert_true(result.is_success)
    
    Note: Invalidate the entry
    Let key be Cache.generate_cache_key(Registry.SYSCALL_GETPID, args)
    Cache.invalidate_entry(cache, key)
    
    Note: Lookup should now fail
    Set result to Cache.lookup_syscall(cache, Registry.SYSCALL_GETPID, args)
    Test.assert_false(result.is_success)
End Process

Process called "test_invalidate_syscall_type" returns Nothing:
    @Performance_Hints
    Tests batch invalidation by syscall type.
    @End Performance_Hints
    
    Let cache be Cache.create_syscall_cache()
    
    Note: Cache multiple entries of same type
    Let args1 be create_args_with_value(1)
    Let args2 be create_args_with_value(2)
    Let args3 be create_args_with_value(3)
    
    Cache.cache_syscall_result(cache, Registry.SYSCALL_STAT, args1, 100)
    Cache.cache_syscall_result(cache, Registry.SYSCALL_STAT, args2, 200)
    Cache.cache_syscall_result(cache, Registry.SYSCALL_GETPID, args3, 300)
    
    Note: Invalidate all STAT entries
    Cache.invalidate_syscall_type(cache, Registry.SYSCALL_STAT)
    
    Note: STAT lookups should fail
    Let result1 be Cache.lookup_syscall(cache, Registry.SYSCALL_STAT, args1)
    Let result2 be Cache.lookup_syscall(cache, Registry.SYSCALL_STAT, args2)
    Test.assert_false(result1.is_success)
    Test.assert_false(result2.is_success)
    
    Note: GETPID should still be valid
    Let result3 be Cache.lookup_syscall(cache, Registry.SYSCALL_GETPID, args3)
    Test.assert_true(result3.is_success)
End Process

Process called "test_clear_cache" returns Nothing:
    @Performance_Hints
    Tests complete cache clearing.
    @End Performance_Hints
    
    Let cache be Cache.create_syscall_cache()
    
    Note: Add multiple entries
    Let i be 0
    While i less than 10:
        Let args be create_args_with_value(i)
        Cache.cache_syscall_result(cache, Registry.SYSCALL_GETUID, args, i)
        Set i to i plus 1
    End While
    
    Test.assert_greater_than(cache.current_size, 0)
    
    Note: Clear the cache
    Cache.clear_cache(cache)
    
    Test.assert_equals(cache.current_size, 0)
    Test.assert_equals(cache.lru_head, 0)
    Test.assert_equals(cache.lru_tail, 0)
    
    Note: Statistics should be reset
    Test.assert_equals(cache.statistics.total_hits, 0)
    Test.assert_equals(cache.statistics.total_misses, 0)
    Test.assert_equals(cache.statistics.total_evictions, 0)
End Process

Note: =====================================================================
Note: CACHE STATISTICS
Note: =====================================================================

Process called "test_cache_efficiency" returns Nothing:
    @Performance_Hints
    Tests cache efficiency calculation.
    @End Performance_Hints
    
    Let cache be Cache.create_syscall_cache()
    
    Note: Initial efficiency should be 0
    Test.assert_equals(cache.statistics.cache_efficiency, 0.0)
    
    Let args be Internals.create_internal_array(0)
    Cache.cache_syscall_result(cache, Registry.SYSCALL_GETPID, args, 12345)
    
    Note: First lookup is a miss
    Let result be Cache.lookup_syscall(cache, Registry.SYSCALL_GETUID, args)
    Cache.update_cache_efficiency(cache)
    Test.assert_equals(cache.statistics.cache_efficiency, 0.0)  Note: 0 hits, 1 miss
    
    Note: Second lookup is a hit
    Set result to Cache.lookup_syscall(cache, Registry.SYSCALL_GETPID, args)
    Cache.update_cache_efficiency(cache)
    Test.assert_equals(cache.statistics.cache_efficiency, 50.0)  Note: 1 hit, 1 miss
    
    Note: More hits improve efficiency
    Set result to Cache.lookup_syscall(cache, Registry.SYSCALL_GETPID, args)
    Set result to Cache.lookup_syscall(cache, Registry.SYSCALL_GETPID, args)
    Cache.update_cache_efficiency(cache)
    Test.assert_equals(cache.statistics.cache_efficiency, 75.0)  Note: 3 hits, 1 miss
End Process

Process called "test_bytes_saved_tracking" returns Nothing:
    @Performance_Hints
    Tests tracking of bytes saved by caching.
    @End Performance_Hints
    
    Let cache be Cache.create_syscall_cache()
    
    Let args be Internals.create_internal_array(0)
    Cache.cache_syscall_result(cache, Registry.SYSCALL_GETPID, args, 12345)
    
    Note: Cache hit should increment bytes saved
    Let initial_bytes be cache.statistics.bytes_saved
    Let result be Cache.lookup_syscall(cache, Registry.SYSCALL_GETPID, args)
    
    Test.assert_true(result.is_success)
    Test.assert_greater_than(cache.statistics.bytes_saved, initial_bytes)
    
    Note: Different syscalls have different costs
    Cache.cache_syscall_result(cache, Registry.SYSCALL_STAT, args, 200)
    Set result to Cache.lookup_syscall(cache, Registry.SYSCALL_STAT, args)
    
    Let stat_cost be Cache.estimate_syscall_cost(Registry.SYSCALL_STAT)
    Let pid_cost be Cache.estimate_syscall_cost(Registry.SYSCALL_GETPID)
    Test.assert_not_equals(stat_cost, pid_cost)
End Process

Note: =====================================================================
Note: CACHE WARMING
Note: =====================================================================

Process called "test_cache_warming" returns Nothing:
    @Performance_Hints
    Tests cache pre-population with common syscalls.
    @End Performance_Hints
    
    Let cache be Cache.create_syscall_cache()
    
    Note: Warm the cache
    Let patterns be Internals.create_internal_array(0)  Note: No specific patterns
    Cache.warm_cache(cache, patterns)
    
    Note: Common syscalls should now be cached
    Test.assert_greater_than(cache.current_size, 0)
    
    Note: GETPID should be pre-cached
    Let args be Internals.create_internal_array(0)
    Let result be Cache.lookup_syscall(cache, Registry.SYSCALL_GETPID, args)
    Test.assert_true(result.is_success)
    Test.assert_equals(cache.statistics.total_hits, 1)
    Test.assert_equals(cache.statistics.total_misses, 0)
End Process

Note: =====================================================================
Note: CACHE AUTO-TUNING
Note: =====================================================================

Process called "test_auto_tune_ttl" returns Nothing:
    @Performance_Hints
    Tests automatic TTL adjustment based on efficiency.
    @End Performance_Hints
    
    Let cache be Cache.create_cache_with_config(100, 5000)  Note: 5 second TTL
    
    Note: Simulate high efficiency
    Set cache.statistics.cache_efficiency to 95.0
    Set cache.statistics.total_hits to 950
    Set cache.statistics.total_misses to 50
    
    Let initial_ttl be cache.ttl_ms
    Cache.auto_tune_cache(cache)
    
    Test.assert_greater_than(cache.ttl_ms, initial_ttl)  Note: Should increase TTL
    Test.assert_less_than_or_equal(cache.ttl_ms, 60000)  Note: Should cap at 1 minute
    
    Note: Simulate low efficiency
    Set cache.statistics.cache_efficiency to 20.0
    Set cache.ttl_ms to 10000
    
    Cache.auto_tune_cache(cache)
    Test.assert_less_than(cache.ttl_ms, 10000)  Note: Should decrease TTL
    Test.assert_greater_than_or_equal(cache.ttl_ms, 1000)  Note: Should have minimum
End Process

Process called "test_auto_tune_size" returns Nothing:
    @Performance_Hints
    Tests automatic cache size adjustment based on eviction rate.
    @End Performance_Hints
    
    Let cache be Cache.create_cache_with_config(100, 5000)
    
    Note: Simulate high eviction rate
    Set cache.statistics.total_evictions to 100
    Set cache.statistics.total_hits to 500
    Set cache.statistics.total_misses to 400
    
    Let initial_size be cache.cache_size
    Cache.auto_tune_cache(cache)
    
    Test.assert_greater_than(cache.cache_size, initial_size)  Note: Should increase size
    Test.assert_less_than_or_equal(cache.cache_size, 2048)  Note: Should have maximum
End Process

Note: =====================================================================
Note: CACHEABLE SYSCALL DETECTION
Note: =====================================================================

Process called "test_should_cache_syscall" returns Nothing:
    @Performance_Hints
    Tests detection of cacheable syscalls.
    @End Performance_Hints
    
    Note: Process info syscalls should be cacheable
    Test.assert_true(Cache.should_cache_syscall(Registry.SYSCALL_GETPID))
    Test.assert_true(Cache.should_cache_syscall(Registry.SYSCALL_GETUID))
    Test.assert_true(Cache.should_cache_syscall(Registry.SYSCALL_GETEUID))
    Test.assert_true(Cache.should_cache_syscall(Registry.SYSCALL_GETGID))
    Test.assert_true(Cache.should_cache_syscall(Registry.SYSCALL_GETEGID))
    Test.assert_true(Cache.should_cache_syscall(Registry.SYSCALL_GETPPID))
    
    Note: File stats should be cacheable
    Test.assert_true(Cache.should_cache_syscall(Registry.SYSCALL_STAT))
    Test.assert_true(Cache.should_cache_syscall(Registry.SYSCALL_FSTAT))
    Test.assert_true(Cache.should_cache_syscall(Registry.SYSCALL_LSTAT))
    
    Note: Time syscalls should be cacheable
    Test.assert_true(Cache.should_cache_syscall(Registry.SYSCALL_CLOCK_GETTIME))
    Test.assert_true(Cache.should_cache_syscall(Registry.SYSCALL_GETTIMEOFDAY))
    
    Note: System info should be cacheable
    Test.assert_true(Cache.should_cache_syscall("getcwd"))
    Test.assert_true(Cache.should_cache_syscall("uname"))
    
    Note: I/O operations should NOT be cacheable
    Test.assert_false(Cache.should_cache_syscall(Registry.SYSCALL_READ))
    Test.assert_false(Cache.should_cache_syscall(Registry.SYSCALL_WRITE))
    Test.assert_false(Cache.should_cache_syscall(Registry.SYSCALL_OPEN))
    Test.assert_false(Cache.should_cache_syscall(Registry.SYSCALL_CLOSE))
End Process

Note: =====================================================================
Note: THREAD SAFETY
Note: =====================================================================

Process called "test_concurrent_cache_access" returns Nothing:
    @Performance_Hints
    Tests thread-safe concurrent cache operations.
    @End Performance_Hints
    
    Let cache be Cache.create_syscall_cache()
    Let thread_count be 4
    Let ops_per_thread be 100
    
    Note: Pre-populate cache
    Let i be 0
    While i less than 10:
        Let args be create_args_with_value(i)
        Cache.cache_syscall_result(cache, Registry.SYSCALL_GETUID, args, i)
        Set i to i plus 1
    End While
    
    Note: Spawn threads for concurrent access
    Let threads be spawn_cache_threads(cache, thread_count, ops_per_thread)
    
    Note: Wait for all threads
    wait_for_threads(threads)
    
    Note: Verify cache integrity
    Test.assert_greater_than(cache.statistics.total_hits plus cache.statistics.total_misses, 0)
    Test.assert_greater_than_or_equal(cache.current_size, 0)
    Test.assert_less_than_or_equal(cache.current_size, cache.cache_size)
End Process

Process called "test_lock_acquisition" returns Nothing:
    @Performance_Hints
    Tests spinlock acquisition and release.
    @End Performance_Hints
    
    Let lock_var be 0
    Let lock_ptr be address_of(lock_var)
    
    Note: Initial lock should be free
    Test.assert_equals(lock_var, 0)
    
    Note: Acquire lock
    Cache.acquire_lock(lock_ptr)
    Test.assert_equals(lock_var, 1)
    
    Note: Release lock
    Cache.release_lock(lock_ptr)
    Test.assert_equals(lock_var, 0)
End Process

Note: =====================================================================
Note: CACHE DISABLE/ENABLE
Note: =====================================================================

Process called "test_cache_disable" returns Nothing:
    @Performance_Hints
    Tests cache disable functionality.
    @End Performance_Hints
    
    Let cache be Cache.create_syscall_cache()
    
    Note: Add some entries
    Let args be Internals.create_internal_array(0)
    Cache.cache_syscall_result(cache, Registry.SYSCALL_GETPID, args, 12345)
    
    Test.assert_true(cache.enabled)
    Test.assert_greater_than(cache.current_size, 0)
    
    Note: Disable cache
    Cache.set_cache_enabled(cache, false)
    
    Test.assert_false(cache.enabled)
    Test.assert_equals(cache.current_size, 0)  Note: Should clear on disable
    
    Note: Lookups should fail when disabled
    Let result be Cache.lookup_syscall(cache, Registry.SYSCALL_GETPID, args)
    Test.assert_false(result.is_success)
    Test.assert_equals(result.value, minus 1)
End Process

Process called "test_cache_reenable" returns Nothing:
    @Performance_Hints
    Tests cache re-enable after disable.
    @End Performance_Hints
    
    Let cache be Cache.create_syscall_cache()
    
    Note: Disable then re-enable
    Cache.set_cache_enabled(cache, false)
    Cache.set_cache_enabled(cache, true)
    
    Test.assert_true(cache.enabled)
    Test.assert_equals(cache.current_size, 0)  Note: Should start empty
    
    Note: Should work normally after re-enable
    Let args be Internals.create_internal_array(0)
    Cache.cache_syscall_result(cache, Registry.SYSCALL_GETPID, args, 12345)
    
    Let result be Cache.lookup_syscall(cache, Registry.SYSCALL_GETPID, args)
    Test.assert_true(result.is_success)
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "create_args_with_value" that takes value as Integer returns Internals.InternalArray:
    @Performance_Hints
    Creates argument array with single value for testing.
    @End Performance_Hints
    
    Let args be Internals.create_internal_array(1)
    Internals.internal_array_add(args, value)
    Return args
End Process

Process called "get_current_timestamp_ms" returns Integer:
    @Performance_Hints
    Gets current timestamp in milliseconds.
    @End Performance_Hints
    
    Let seconds as Integer
    Let nanoseconds as Integer
    
    Inline Assembly:
        "mov rax, 228\n"        Note: clock_gettime
        "mov rdi, 1\n"          Note: CLOCK_MONOTONIC
        "lea rsi, [rsp-16]\n"
        "syscall\n"
        "mov %0, [rsi]\n"
        "mov %1, [rsi+8]\n"
        : "=r"(seconds), "=r"(nanoseconds)
        :
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return seconds multiplied by 1000 plus (nanoseconds divided by 1000000)
End Process

Process called "sleep_milliseconds" that takes ms as Integer returns Nothing:
    @Performance_Hints
    Sleeps for specified milliseconds.
    @End Performance_Hints
    
    Let seconds be ms divided by 1000
    Let nanoseconds be (ms modulo 1000) multiplied by 1000000
    
    Inline Assembly:
        "mov rax, 35\n"         Note: nanosleep
        "lea rdi, [rsp-16]\n"
        "mov [rdi], %0\n"
        "mov [rdi+8], %1\n"
        "xor rsi, rsi\n"
        "syscall\n"
        :
        : "r"(seconds), "r"(nanoseconds)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
End Process

Process called "spawn_cache_threads" that takes cache as Cache.SyscallCache, thread_count as Integer, ops_per_thread as Integer returns Internals.InternalArray:
    @Performance_Hints
    Spawns threads for concurrent cache testing.
    @End Performance_Hints
    
    Let threads be Internals.create_internal_array(thread_count)
    
    Let t be 0
    While t less than thread_count:
        Let thread_id be spawn_cache_thread(cache, t, ops_per_thread)
        Internals.internal_array_add(threads, thread_id)
        Set t to t plus 1
    End While
    
    Return threads
End Process

Process called "spawn_cache_thread" that takes cache as Cache.SyscallCache, thread_idx as Integer, op_count as Integer returns Integer:
    @Performance_Hints
    Spawns a single cache test thread.
    @End Performance_Hints
    
    Let stack_size be 8192
    Let stack_ptr be Internals.allocate_raw_memory(stack_size)
    
    Note: Store parameters on stack
    Internals.write_integer_at(stack_ptr plus stack_size minus 8, cache as Integer)
    Internals.write_integer_at(stack_ptr plus stack_size minus 16, thread_idx)
    Internals.write_integer_at(stack_ptr plus stack_size minus 24, op_count)
    
    Let thread_id as Integer
    Inline Assembly:
        "mov rax, 56\n"             Note: clone syscall
        "mov rdi, 0x10900\n"        Note: CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_THREAD
        "mov rsi, %1\n"             Note: New stack pointer
        "xor rdx, rdx\n"
        "xor r10, r10\n"
        "xor r8, r8\n"
        "syscall\n"
        "test rax, rax\n"
        "jnz parent_continue\n"
        
        Note: Child thread execution
        "mov rdi, [rsp]\n"          Note: cache
        "mov rsi, [rsp+8]\n"        Note: thread_idx
        "mov rdx, [rsp+16]\n"       Note: op_count
        "call cache_worker\n"
        "mov rax, 60\n"
        "xor rdi, rdi\n"
        "syscall\n"
        
        "parent_continue:\n"
        "mov %0, rax\n"
        : "=r"(thread_id)
        : "r"(stack_ptr plus stack_size minus 24)
        : "rax", "rdi", "rsi", "rdx", "r10", "r8", "rcx", "r11", "memory"
    End Assembly
    
    Return thread_id
End Process

Process called "cache_worker" that takes cache_ptr as Integer, thread_idx as Integer, op_count as Integer returns Nothing:
    @Performance_Hints
    Worker function for cache thread.
    @End Performance_Hints
    
    Let cache be ptr_to_cache(cache_ptr)
    
    Let i be 0
    While i less than op_count:
        Let op_type be i modulo 3
        
        If op_type equals 0:
            Note: Cache insert
            Let args be create_args_with_value(thread_idx multiplied by 1000 plus i)
            Cache.cache_syscall_result(cache, Registry.SYSCALL_GETUID, args, i)
        Otherwise:
            If op_type equals 1:
                Note: Cache lookup
                Let args be create_args_with_value(thread_idx multiplied by 1000 plus (i divided by 2))
                Let result be Cache.lookup_syscall(cache, Registry.SYSCALL_GETUID, args)
            Otherwise:
                Note: Cache invalidate
                If i modulo 10 equals 0:
                    Cache.invalidate_syscall_type(cache, Registry.SYSCALL_GETUID)
                End If
            End If
        End If
        
        Set i to i plus 1
    End While
End Process

Process called "wait_for_threads" that takes threads as Internals.InternalArray returns Nothing:
    @Performance_Hints
    Waits for all threads to complete.
    @End Performance_Hints
    
    Let i be 0
    While i less than threads.length:
        Let thread_id be Internals.internal_array_get(threads, i)
        wait_for_thread(thread_id)
        Set i to i plus 1
    End While
End Process

Process called "wait_for_thread" that takes thread_id as Integer returns Nothing:
    @Performance_Hints
    Waits for a single thread.
    @End Performance_Hints
    
    Let status as Integer
    Inline Assembly:
        "mov rax, 61\n"         Note: waitpid
        "mov rdi, %1\n"
        "lea rsi, [rsp-4]\n"
        "xor rdx, rdx\n"
        "syscall\n"
        "mov %0, [rsi]\n"
        : "=r"(status)
        : "r"(thread_id)
        : "rax", "rdi", "rsi", "rdx", "rcx", "r11", "memory"
    End Assembly
End Process

Process called "address_of" that takes value as Integer returns Integer:
    @Performance_Hints
    Returns address of value.
    @End Performance_Hints
    
    Let addr as Integer
    Inline Assembly:
        "lea rax, %1\n"
        "mov %0, rax\n"
        : "=r"(addr)
        : "m"(value)
        : "rax"
    End Assembly
    Return addr
End Process

Process called "ptr_to_cache" that takes ptr as Integer returns Cache.SyscallCache:
    @Performance_Hints
    Converts pointer to cache.
    @End Performance_Hints
    
    Let cache as Cache.SyscallCache
    Inline Assembly:
        "mov rax, %1\n"
        "mov %0, [rax]\n"
        : "=m"(cache)
        : "r"(ptr)
        : "rax", "memory"
    End Assembly
    Return cache
End Process

Note: =====================================================================
Note: TEST RUNNER
Note: =====================================================================

Process called "run_all_cache_tests" returns Nothing:
    @Performance_Hints
    Runs all syscall cache tests.
    @End Performance_Hints
    
    Test.start_suite("Syscall Cache Tests")
    
    Note: Basic operations
    Test.run_test("Create Cache", test_create_cache)
    Test.run_test("Custom Config Cache", test_custom_config_cache)
    Test.run_test("Cache Insert and Lookup", test_cache_insert_and_lookup)
    Test.run_test("Cache Miss", test_cache_miss)
    
    Note: LRU eviction
    Test.run_test("LRU Eviction", test_lru_eviction)
    Test.run_test("LRU Promotion", test_lru_promotion)
    
    Note: TTL expiration
    Test.run_test("TTL Expiration", test_ttl_expiration)
    Test.run_test("Entry Validation", test_entry_validation)
    
    Note: Cache keys
    Test.run_test("Cache Key Generation", test_cache_key_generation)
    Test.run_test("Argument Hashing", test_argument_hashing)
    
    Note: Invalidation
    Test.run_test("Invalidate Entry", test_invalidate_entry)
    Test.run_test("Invalidate Syscall Type", test_invalidate_syscall_type)
    Test.run_test("Clear Cache", test_clear_cache)
    
    Note: Statistics
    Test.run_test("Cache Efficiency", test_cache_efficiency)
    Test.run_test("Bytes Saved Tracking", test_bytes_saved_tracking)
    
    Note: Cache warming
    Test.run_test("Cache Warming", test_cache_warming)
    
    Note: Auto-tuning
    Test.run_test("Auto-Tune TTL", test_auto_tune_ttl)
    Test.run_test("Auto-Tune Size", test_auto_tune_size)
    
    Note: Cacheable detection
    Test.run_test("Should Cache Syscall", test_should_cache_syscall)
    
    Note: Thread safety
    Test.run_test("Concurrent Cache Access", test_concurrent_cache_access)
    Test.run_test("Lock Acquisition", test_lock_acquisition)
    
    Note: Enable/disable
    Test.run_test("Cache Disable", test_cache_disable)
    Test.run_test("Cache Re-enable", test_cache_reenable)
    
    Test.end_suite()
End Process

@Security_Scope
These tests verify critical security aspects of syscall caching:
- Thread-safe concurrent access with proper locking
- TTL expiration to prevent stale data
- Proper cache invalidation on system state changes
- Memory safety in entry allocation and deallocation
- Hash collision resistance with FNV-1a
- No caching of sensitive or mutable syscalls
- Race condition prevention in LRU management
@End Security_Scope