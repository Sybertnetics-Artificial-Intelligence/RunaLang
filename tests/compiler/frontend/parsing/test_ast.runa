Note: Comprehensive test suite for the Abstract Syntax Tree (AST) module
Note: Tests AST node creation, manipulation, traversal, and transformation

@Reasoning
The AST is the core data structure that represents parsed Runa code in memory.
Testing must verify correct node creation, tree structure integrity, traversal
algorithms, transformation operations, and memory management. These tests ensure
the AST correctly represents all language constructs and supports both natural
and technical syntax representations for the dual-mode viewer.
@End Reasoning

@TestCases
- AST node creation and initialization
- Tree structure manipulation and validation
- Node traversal and visitor patterns
- AST transformation between syntax modes
- Serialization and deserialization
- Memory management and cleanup
- Performance optimization for large trees
- Node lookup and path operations
- Metadata preservation and context tracking
- Integration with parser and semantic analyzer
@End TestCases

Import module "compiler/frontend/parsing/ast" as AST
Import module "compiler/frontend/parsing/ast_builder" as ASTBuilder
Import module "compiler/frontend/lexical/operators" as Operators
Import module "stdlib/testing/test_framework" as Test
Import module "stdlib/core/primitives/string_primitives" as StringPrim
Import module "compiler/frontend/primitives/types/compiler_internals" as Internals

Note: =====================================================================
Note: AST NODE CREATION TESTS
Note: =====================================================================

Process called "test_create_ast_node" returns Nothing:
    @Performance_Hints
    Tests basic AST node creation and initialization.
    @End Performance_Hints
    
    Let position be create_position_info(1, 5)
    Let attributes be create_attributes_map()
    Internals.internal_map_set(attributes, "value", "42")
    
    Let node be AST.create_ast_node(
        "LiteralExpression",
        "node_001",
        position,
        null,
        attributes
    )
    
    Test.assert_not_null(node)
    Test.assert_equals(node.node_type, "LiteralExpression")
    Test.assert_equals(node.node_id, "node_001")
    Test.assert_equals(node.children.length, 0)
    Test.assert_equals(Internals.internal_map_get(node.attributes, "value"), "42")
End Process

Process called "test_create_expression_node" returns Nothing:
    @Performance_Hints
    Tests creation of expression nodes with operators.
    @End Performance_Hints
    
    Let binary_expr be AST.create_expression_node(
        "BinaryExpression",
        "expr_001",
        "plus",
        create_operand_list("x", "y"),
        5,  Note: Precedence
        "left"
    )
    
    Test.assert_not_null(binary_expr)
    Test.assert_equals(binary_expr.base_node.node_type, "BinaryExpression")
    Test.assert_equals(binary_expr.operator, "plus")
    Test.assert_equals(binary_expr.operands.length, 2)
    Test.assert_equals(binary_expr.precedence, 5)
    Test.assert_equals(binary_expr.associativity, "left")
End Process

Process called "test_create_statement_node" returns Nothing:
    @Performance_Hints
    Tests creation of statement nodes.
    @End Performance_Hints
    
    Let if_stmt be AST.create_statement_node(
        "IfStatement",
        "stmt_001",
        create_keyword_list("If", "End If"),
        "condition_expr",
        "body_block"
    )
    
    Test.assert_not_null(if_stmt)
    Test.assert_equals(if_stmt.base_node.node_type, "IfStatement")
    Test.assert_equals(if_stmt.keywords.length, 2)
    Test.assert_equals(if_stmt.condition, "condition_expr")
    Test.assert_equals(if_stmt.body, "body_block")
    Test.assert_true(if_stmt.is_block_statement)
End Process

Process called "test_create_declaration_node" returns Nothing:
    @Performance_Hints
    Tests creation of declaration nodes.
    @End Performance_Hints
    
    Let var_decl be AST.create_declaration_node(
        "VariableDeclaration",
        "decl_001",
        "myVariable",
        "Integer",
        "literal_42",
        create_modifier_list("const")
    )
    
    Test.assert_not_null(var_decl)
    Test.assert_equals(var_decl.base_node.node_type, "VariableDeclaration")
    Test.assert_equals(var_decl.identifier, "myVariable")
    Test.assert_equals(var_decl.type_annotation, "Integer")
    Test.assert_equals(var_decl.initializer, "literal_42")
    Test.assert_equals(var_decl.modifiers.length, 1)
End Process

Note: =====================================================================
Note: AST TREE MANIPULATION TESTS
Note: =====================================================================

Process called "test_add_child_node" returns Nothing:
    @Performance_Hints
    Tests adding child nodes to parent nodes.
    @End Performance_Hints
    
    Let parent be AST.create_ast_node("BlockStatement", "block_001", null, null, null)
    Let child1 be AST.create_ast_node("ExpressionStatement", "expr_001", null, null, null)
    Let child2 be AST.create_ast_node("VariableDeclaration", "var_001", null, null, null)
    
    AST.add_child(parent, child1)
    AST.add_child(parent, child2)
    
    Test.assert_equals(parent.children.length, 2)
    Test.assert_equals(parent.children[0], child1.node_id)
    Test.assert_equals(parent.children[1], child2.node_id)
    
    Note: Verify parent-child relationships
    Test.assert_equals(child1.parent, parent.node_id)
    Test.assert_equals(child2.parent, parent.node_id)
End Process

Process called "test_remove_child_node" returns Nothing:
    @Performance_Hints
    Tests removing child nodes from parent nodes.
    @End Performance_Hints
    
    Let parent be AST.create_ast_node("BlockStatement", "block_001", null, null, null)
    Let child1 be AST.create_ast_node("ExpressionStatement", "expr_001", null, null, null)
    Let child2 be AST.create_ast_node("VariableDeclaration", "var_001", null, null, null)
    
    AST.add_child(parent, child1)
    AST.add_child(parent, child2)
    
    Test.assert_equals(parent.children.length, 2)
    
    AST.remove_child(parent, child1)
    
    Test.assert_equals(parent.children.length, 1)
    Test.assert_equals(parent.children[0], child2.node_id)
    Test.assert_equals(child1.parent, null)
End Process

Process called "test_replace_child_node" returns Nothing:
    @Performance_Hints
    Tests replacing child nodes.
    @End Performance_Hints
    
    Let parent be AST.create_ast_node("BinaryExpression", "expr_001", null, null, null)
    Let old_child be AST.create_ast_node("Literal", "lit_001", null, null, null)
    Let new_child be AST.create_ast_node("Identifier", "id_001", null, null, null)
    
    AST.add_child(parent, old_child)
    Test.assert_equals(parent.children.length, 1)
    
    AST.replace_child(parent, old_child, new_child)
    
    Test.assert_equals(parent.children.length, 1)
    Test.assert_equals(parent.children[0], new_child.node_id)
    Test.assert_equals(new_child.parent, parent.node_id)
    Test.assert_equals(old_child.parent, null)
End Process

Note: =====================================================================
Note: AST TRAVERSAL TESTS
Note: =====================================================================

Process called "test_depth_first_traversal" returns Nothing:
    @Performance_Hints
    Tests depth-first tree traversal.
    @End Performance_Hints
    
    Let tree be create_sample_ast_tree()
    Let visited_nodes be Internals.create_internal_array(10)
    
    Let visitor be AST.DepthFirstVisitor with
        visit_callback as collect_node_id
    End AST.DepthFirstVisitor
    
    AST.traverse_depth_first(tree, visitor, visited_nodes)
    
    Test.assert_equals(visited_nodes.length, 5)  Note: Expected number of nodes
    
    Note: Verify traversal order (root first in pre-order)
    Let first_node be Internals.internal_array_get(visited_nodes, 0)
    Test.assert_equals(first_node, tree.node_id)
End Process

Process called "test_breadth_first_traversal" returns Nothing:
    @Performance_Hints
    Tests breadth-first tree traversal.
    @End Performance_Hints
    
    Let tree be create_sample_ast_tree()
    Let visited_nodes be Internals.create_internal_array(10)
    
    Let visitor be AST.BreadthFirstVisitor with
        visit_callback as collect_node_id
    End AST.BreadthFirstVisitor
    
    AST.traverse_breadth_first(tree, visitor, visited_nodes)
    
    Test.assert_equals(visited_nodes.length, 5)
    
    Note: In BFS, root should be first, then level 1, then level 2, etc.
    Let root_node be Internals.internal_array_get(visited_nodes, 0)
    Test.assert_equals(root_node, tree.node_id)
End Process

Process called "test_find_node_by_id" returns Nothing:
    @Performance_Hints
    Tests finding nodes by their ID.
    @End Performance_Hints
    
    Let tree be create_sample_ast_tree()
    
    Let found_node be AST.find_node_by_id(tree, "target_node")
    Test.assert_not_null(found_node)
    Test.assert_equals(found_node.node_id, "target_node")
    
    Let not_found be AST.find_node_by_id(tree, "nonexistent")
    Test.assert_null(not_found)
End Process

Process called "test_find_nodes_by_type" returns Nothing:
    @Performance_Hints
    Tests finding all nodes of a specific type.
    @End Performance_Hints
    
    Let tree be create_sample_ast_tree()
    
    Let literals be AST.find_nodes_by_type(tree, "LiteralExpression")
    Test.assert_greater_than(literals.length, 0)
    
    Note: Verify all found nodes are of correct type
    Let i be 0
    While i less than literals.length:
        Let node be Internals.internal_array_get(literals, i)
        Test.assert_equals(node.node_type, "LiteralExpression")
        Set i to i plus 1
    End While
End Process

Note: =====================================================================
Note: AST TRANSFORMATION TESTS
Note: =====================================================================

Process called "test_transform_natural_to_technical" returns Nothing:
    @Performance_Hints
    Tests transformation from natural to technical syntax.
    @End Performance_Hints
    
    Note: Create natural language AST
    Let natural_ast be create_natural_syntax_ast()
    
    Note: Transform to technical syntax
    Let technical_ast be AST.transform_to_technical_syntax(natural_ast)
    
    Test.assert_not_null(technical_ast)
    Test.assert_equals(technical_ast.syntax_mode, "technical")
    
    Note: Verify operator transformations
    Let binary_expr be AST.find_first_by_type(technical_ast, "BinaryExpression")
    Test.assert_not_null(binary_expr)
    
    Note: "plus" should become "+"
    Test.assert_equals(AST.get_operator(binary_expr), "+")
    
    Note: Original operators should be preserved for reverse transformation
    Test.assert_equals(Internals.internal_map_get(binary_expr.original_operators, "+"), "plus")
End Process

Process called "test_transform_technical_to_natural" returns Nothing:
    @Performance_Hints
    Tests transformation from technical to natural syntax.
    @End Performance_Hints
    
    Note: Create technical syntax AST
    Let technical_ast be create_technical_syntax_ast()
    
    Note: Transform to natural syntax
    Let natural_ast be AST.transform_to_natural_syntax(technical_ast)
    
    Test.assert_not_null(natural_ast)
    Test.assert_equals(natural_ast.syntax_mode, "natural")
    
    Note: Verify operator transformations
    Let binary_expr be AST.find_first_by_type(natural_ast, "BinaryExpression")
    Test.assert_not_null(binary_expr)
    
    Note: "+" should become "plus"
    Test.assert_equals(AST.get_operator(binary_expr), "plus")
End Process

Process called "test_preserve_transformation_metadata" returns Nothing:
    @Performance_Hints
    Tests preservation of metadata during transformations.
    @End Performance_Hints
    
    Let original_ast be create_natural_syntax_ast()
    AST.set_preserve_metadata(original_ast, true)
    
    Let transformed_ast be AST.transform_to_technical_syntax(original_ast)
    
    Note: Original position information should be preserved
    Let original_pos be original_ast.position
    Let transformed_pos be transformed_ast.position
    Test.assert_equals(original_pos["line"], transformed_pos["line"])
    Test.assert_equals(original_pos["column"], transformed_pos["column"])
    
    Note: Source context should be preserved
    Test.assert_not_null(transformed_ast.source_context)
End Process

Note: =====================================================================
Note: AST SERIALIZATION TESTS
Note: =====================================================================

Process called "test_serialize_ast" returns Nothing:
    @Performance_Hints
    Tests AST serialization to JSON format.
    @End Performance_Hints
    
    Let ast be create_sample_ast_tree()
    
    Let json_string be AST.serialize_to_json(ast)
    
    Test.assert_not_null(json_string)
    Test.assert_greater_than(StringPrim.length(json_string), 0)
    
    Note: Verify JSON contains expected structure
    Test.assert_contains(json_string, "node_type")
    Test.assert_contains(json_string, "node_id")
    Test.assert_contains(json_string, "children")
End Process

Process called "test_deserialize_ast" returns Nothing:
    @Performance_Hints
    Tests AST deserialization from JSON format.
    @End Performance_Hints
    
    Let original_ast be create_sample_ast_tree()
    Let json_string be AST.serialize_to_json(original_ast)
    
    Let deserialized_ast be AST.deserialize_from_json(json_string)
    
    Test.assert_not_null(deserialized_ast)
    Test.assert_equals(deserialized_ast.node_type, original_ast.node_type)
    Test.assert_equals(deserialized_ast.node_id, original_ast.node_id)
    Test.assert_equals(deserialized_ast.children.length, original_ast.children.length)
End Process

Process called "test_round_trip_serialization" returns Nothing:
    @Performance_Hints
    Tests serialization round-trip integrity.
    @End Performance_Hints
    
    Let original_ast be create_complex_ast_tree()
    
    Let json_string be AST.serialize_to_json(original_ast)
    Let restored_ast be AST.deserialize_from_json(json_string)
    
    Note: Compare tree structure
    Test.assert_true(AST.trees_are_equal(original_ast, restored_ast))
    
    Note: Verify all attributes are preserved
    Let original_attrs be count_all_attributes(original_ast)
    Let restored_attrs be count_all_attributes(restored_ast)
    Test.assert_equals(original_attrs, restored_attrs)
End Process

Note: =====================================================================
Note: AST VALIDATION TESTS
Note: =====================================================================

Process called "test_validate_ast_structure" returns Nothing:
    @Performance_Hints
    Tests AST structure validation.
    @End Performance_Hints
    
    Let valid_ast be create_sample_ast_tree()
    
    Let validation_result be AST.validate_structure(valid_ast)
    Test.assert_true(validation_result.is_valid)
    Test.assert_equals(validation_result.errors.length, 0)
    
    Note: Test invalid AST with circular reference
    Let invalid_ast be create_circular_ast()
    Let invalid_result be AST.validate_structure(invalid_ast)
    Test.assert_false(invalid_result.is_valid)
    Test.assert_greater_than(invalid_result.errors.length, 0)
    Test.assert_contains(invalid_result.errors[0], "circular reference")
End Process

Process called "test_validate_node_relationships" returns Nothing:
    @Performance_Hints
    Tests validation of parent-child relationships.
    @End Performance_Hints
    
    Let ast be create_sample_ast_tree()
    
    Note: Verify all children reference correct parent
    Let validation_errors be AST.validate_parent_child_consistency(ast)
    Test.assert_equals(validation_errors.length, 0)
    
    Note: Break parent-child relationship
    Let child_node be AST.find_first_child(ast)
    Set child_node.parent to "invalid_parent_id"
    
    Set validation_errors to AST.validate_parent_child_consistency(ast)
    Test.assert_greater_than(validation_errors.length, 0)
End Process

Note: =====================================================================
Note: PERFORMANCE TESTS
Note: =====================================================================

Process called "test_large_tree_operations" returns Nothing:
    @Performance_Hints
    Tests performance with large AST trees.
    @End Performance_Hints
    
    Note: Create large AST with 10,000 nodes
    Let large_ast be create_large_ast_tree(10000)
    
    Note: Test traversal performance
    Let start_time be get_timestamp_ms()
    Let node_count be AST.count_nodes(large_ast)
    Let end_time be get_timestamp_ms()
    
    Test.assert_equals(node_count, 10000)
    Test.assert_less_than(end_time minus start_time, 100)  Note: Should complete in <100ms
    
    Note: Test search performance
    Set start_time to get_timestamp_ms()
    Let found_nodes be AST.find_nodes_by_type(large_ast, "Identifier")
    Set end_time to get_timestamp_ms()
    
    Test.assert_greater_than(found_nodes.length, 0)
    Test.assert_less_than(end_time minus start_time, 50)  Note: Should complete in <50ms
End Process

Process called "test_memory_usage" returns Nothing:
    @Performance_Hints
    Tests memory usage of AST operations.
    @End Performance_Hints
    
    Let initial_memory be get_memory_usage()
    
    Note: Create and destroy many AST nodes
    Let i be 0
    While i less than 1000:
        Let temp_ast be create_sample_ast_tree()
        AST.destroy_ast(temp_ast)
        Set i to i plus 1
    End While
    
    Let final_memory be get_memory_usage()
    
    Note: Memory usage should not have grown significantly
    Let memory_growth be final_memory minus initial_memory
    Test.assert_less_than(memory_growth, 1048576)  Note: Less than 1MB growth
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "create_position_info" that takes line as Integer, column as Integer returns Internals.InternalMap:
    @Performance_Hints
    Creates position information map for AST nodes.
    @End Performance_Hints
    
    Let position be Internals.create_internal_map(4)
    Internals.internal_map_set(position, "line", integer_to_string(line))
    Internals.internal_map_set(position, "column", integer_to_string(column))
    Internals.internal_map_set(position, "offset", "0")
    Internals.internal_map_set(position, "length", "0")
    Return position
End Process

Process called "create_attributes_map" returns Internals.InternalMap:
    @Performance_Hints
    Creates empty attributes map.
    @End Performance_Hints
    
    Return Internals.create_internal_map(8)
End Process

Process called "create_operand_list" that takes left as String, right as String returns Internals.InternalArray:
    @Performance_Hints
    Creates operand list for binary expressions.
    @End Performance_Hints
    
    Let operands be Internals.create_internal_array(2)
    Internals.internal_array_add(operands, left)
    Internals.internal_array_add(operands, right)
    Return operands
End Process

Process called "create_keyword_list" that takes keyword1 as String, keyword2 as String returns Internals.InternalArray:
    @Performance_Hints
    Creates keyword list for statements.
    @End Performance_Hints
    
    Let keywords be Internals.create_internal_array(2)
    Internals.internal_array_add(keywords, keyword1)
    Internals.internal_array_add(keywords, keyword2)
    Return keywords
End Process

Process called "create_modifier_list" that takes modifier as String returns Internals.InternalArray:
    @Performance_Hints
    Creates modifier list for declarations.
    @End Performance_Hints
    
    Let modifiers be Internals.create_internal_array(1)
    Internals.internal_array_add(modifiers, modifier)
    Return modifiers
End Process

Process called "create_sample_ast_tree" returns AST.ASTNode:
    @Performance_Hints
    Creates a sample AST tree for testing.
    @End Performance_Hints
    
    Note: Create root node (Program)
    Let root be AST.create_ast_node(
        "Program",
        "root_node",
        create_position_info(1, 1),
        null,
        create_attributes_map()
    )
    
    Note: Create Let statement node
    Let let_stmt be AST.create_ast_node(
        "LetStatement",
        "let_stmt_001",
        create_position_info(2, 1),
        root.node_id,
        create_attributes_map()
    )
    
    Note: Create identifier node
    Let identifier be AST.create_ast_node(
        "Identifier",
        "id_x",
        create_position_info(2, 5),
        let_stmt.node_id,
        create_attributes_map()
    )
    
    Note: Create literal node
    Let literal be AST.create_ast_node(
        "LiteralExpression",
        "target_node",  Note: For search tests
        create_position_info(2, 10),
        let_stmt.node_id,
        create_attributes_map()
    )
    
    Note: Create binary expression
    Let binary_expr be AST.create_ast_node(
        "BinaryExpression",
        "binary_001",
        create_position_info(3, 1),
        root.node_id,
        create_attributes_map()
    )
    
    Note: Build tree structure
    AST.add_child(root, let_stmt)
    AST.add_child(root, binary_expr)
    AST.add_child(let_stmt, identifier)
    AST.add_child(let_stmt, literal)
    
    Return root
End Process

Process called "create_natural_syntax_ast" returns AST.ASTNode:
    @Performance_Hints
    Creates AST representing natural language syntax.
    @End Performance_Hints
    
    Let root be AST.create_ast_node("Program", "nat_root", null, null, null)
    Set root.syntax_mode to "natural"
    
    Note: Create "x plus y" expression
    Let plus_expr be AST.create_expression_node(
        "BinaryExpression",
        "plus_expr",
        "plus",
        create_operand_list("x", "y"),
        5,
        "left"
    )
    Set plus_expr.base_node.syntax_mode to "natural"
    
    AST.add_child(root, plus_expr.base_node)
    
    Return root
End Process

Process called "create_technical_syntax_ast" returns AST.ASTNode:
    @Performance_Hints
    Creates AST representing technical syntax.
    @End Performance_Hints
    
    Let root be AST.create_ast_node("Program", "tech_root", null, null, null)
    Set root.syntax_mode to "technical"
    
    Note: Create "x + y" expression
    Let plus_expr be AST.create_expression_node(
        "BinaryExpression",
        "plus_expr",
        "+",
        create_operand_list("x", "y"),
        5,
        "left"
    )
    Set plus_expr.base_node.syntax_mode to "technical"
    
    AST.add_child(root, plus_expr.base_node)
    
    Return root
End Process

Process called "create_complex_ast_tree" returns AST.ASTNode:
    @Performance_Hints
    Creates a complex AST tree for serialization testing.
    @End Performance_Hints
    
    Let root be create_sample_ast_tree()
    
    Note: Add more complex structures
    Let function_decl be AST.create_declaration_node(
        "FunctionDeclaration",
        "func_001",
        "calculate",
        "Integer -> Integer",
        null,
        create_modifier_list("public")
    )
    
    AST.add_child(root, function_decl.base_node)
    
    Note: Add nested expressions
    Let i be 0
    While i less than 5:
        Let nested_expr be AST.create_ast_node(
            "CallExpression",
            "call_" + integer_to_string(i),
            create_position_info(i, i),
            function_decl.base_node.node_id,
            create_attributes_map()
        )
        AST.add_child(function_decl.base_node, nested_expr)
        Set i to i plus 1
    End While
    
    Return root
End Process

Process called "create_circular_ast" returns AST.ASTNode:
    @Performance_Hints
    Creates invalid AST with circular reference for testing.
    @End Performance_Hints
    
    Let node1 be AST.create_ast_node("Node1", "node1", null, null, null)
    Let node2 be AST.create_ast_node("Node2", "node2", null, null, null)
    
    Note: Create circular reference
    AST.add_child(node1, node2)
    AST.add_child(node2, node1)  Note: This creates a cycle
    
    Return node1
End Process

Process called "create_large_ast_tree" that takes node_count as Integer returns AST.ASTNode:
    @Performance_Hints
    Creates large AST tree for performance testing.
    @End Performance_Hints
    
    Let root be AST.create_ast_node("Program", "large_root", null, null, null)
    
    Let nodes_created be 1  Note: Count root
    Let current_parent be root
    
    While nodes_created less than node_count:
        Let node_type be "Identifier"  Note: Simple node type
        If nodes_created modulo 10 equals 0:
            Set node_type to "LiteralExpression"
        End If
        
        Let new_node be AST.create_ast_node(
            node_type,
            "node_" + integer_to_string(nodes_created),
            null,
            current_parent.node_id,
            null
        )
        
        AST.add_child(current_parent, new_node)
        
        Note: Occasionally change parent to create broader tree
        If nodes_created modulo 100 equals 0:
            Set current_parent to new_node
        End If
        
        Set nodes_created to nodes_created plus 1
    End While
    
    Return root
End Process

Process called "collect_node_id" that takes node as AST.ASTNode, context as Internals.InternalArray returns Nothing:
    @Performance_Hints
    Callback function for collecting node IDs during traversal.
    @End Performance_Hints
    
    Internals.internal_array_add(context, node.node_id)
End Process

Process called "count_all_attributes" that takes node as AST.ASTNode returns Integer:
    @Performance_Hints
    Recursively counts all attributes in AST tree.
    @End Performance_Hints
    
    Let count be node.attributes.size
    
    Let i be 0
    While i less than node.children.length:
        Let child_id be node.children[i]
        Let child_node be AST.find_node_by_id(node, child_id)
        If child_node not equals null:
            Set count to count plus count_all_attributes(child_node)
        End If
        Set i to i plus 1
    End While
    
    Return count
End Process

Process called "get_timestamp_ms" returns Integer:
    @Performance_Hints
    Gets current timestamp in milliseconds.
    @End Performance_Hints
    
    Let seconds as Integer
    Let nanoseconds as Integer
    
    Inline Assembly:
        "mov rax, 228\n"
        "mov rdi, 1\n"
        "lea rsi, [rsp-16]\n"
        "syscall\n"
        "mov %0, [rsi]\n"
        "mov %1, [rsi+8]\n"
        : "=r"(seconds), "=r"(nanoseconds)
        :
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return seconds multiplied by 1000 plus (nanoseconds divided by 1000000)
End Process

Process called "get_memory_usage" returns Integer:
    @Performance_Hints
    Gets current memory usage in bytes.
    @End Performance_Hints
    
    Let rusage_struct be Internals.allocate_raw_memory(144)  Note: Size of rusage struct
    
    Inline Assembly:
        "mov rax, 98\n"         Note: getrusage syscall
        "mov rdi, 0\n"          Note: RUSAGE_SELF
        "mov rsi, %0\n"         Note: rusage struct pointer
        "syscall\n"
        :
        : "r"(rusage_struct)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Note: Read ru_maxrss field (peak memory usage in KB)
    Let memory_kb be Internals.read_integer_at(rusage_struct, 32)
    
    Internals.free_raw_memory(rusage_struct, 144)
    
    Return memory_kb multiplied by 1024  Note: Convert to bytes
End Process

Process called "integer_to_string" that takes value as Integer returns String:
    @Performance_Hints
    Converts integer to string.
    @End Performance_Hints
    
    If value equals 0:
        Return "0"
    End If
    
    Let is_negative be value less than 0
    Let num be value
    If is_negative:
        Set num to 0 minus value
    End If
    
    Let sb be Internals.create_string_builder()
    Let digits be Internals.create_internal_array(20)
    Let digit_count be 0
    
    While num greater than 0:
        Let digit be num modulo 10
        Internals.internal_array_add(digits, digit)
        Set digit_count to digit_count plus 1
        Set num to num divided by 10
    End While
    
    If is_negative:
        Internals.string_builder_append(sb, "-")
    End If
    
    Let i be digit_count minus 1
    While i greater than or equal to 0:
        Let digit be Internals.internal_array_get(digits, i)
        Let digit_char be character_from_code(digit plus 48)
        Internals.string_builder_append(sb, digit_char)
        Set i to i minus 1
    End While
    
    Return Internals.string_builder_to_string(sb)
End Process

Process called "character_from_code" that takes code as Integer returns String:
    @Performance_Hints
    Creates single-character string from ASCII code.
    @End Performance_Hints
    
    Let buffer be Internals.allocate_raw_memory(2)
    Internals.write_byte_at(buffer, 0, code)
    Internals.write_byte_at(buffer, 1, 0)
    
    Let str be Internals.ptr_to_string(buffer)
    Internals.free_raw_memory(buffer, 2)
    Return str
End Process

Note: =====================================================================
Note: TEST RUNNER
Note: =====================================================================

Process called "run_all_ast_tests" returns Nothing:
    @Performance_Hints
    Runs all AST tests.
    @End Performance_Hints
    
    Test.start_suite("AST Tests")
    
    Note: Node creation tests
    Test.run_test("Create AST Node", test_create_ast_node)
    Test.run_test("Create Expression Node", test_create_expression_node)
    Test.run_test("Create Statement Node", test_create_statement_node)
    Test.run_test("Create Declaration Node", test_create_declaration_node)
    
    Note: Tree manipulation tests
    Test.run_test("Add Child Node", test_add_child_node)
    Test.run_test("Remove Child Node", test_remove_child_node)
    Test.run_test("Replace Child Node", test_replace_child_node)
    
    Note: Traversal tests
    Test.run_test("Depth-First Traversal", test_depth_first_traversal)
    Test.run_test("Breadth-First Traversal", test_breadth_first_traversal)
    Test.run_test("Find Node by ID", test_find_node_by_id)
    Test.run_test("Find Nodes by Type", test_find_nodes_by_type)
    
    Note: Transformation tests
    Test.run_test("Transform Natural to Technical", test_transform_natural_to_technical)
    Test.run_test("Transform Technical to Natural", test_transform_technical_to_natural)
    Test.run_test("Preserve Transformation Metadata", test_preserve_transformation_metadata)
    
    Note: Serialization tests
    Test.run_test("Serialize AST", test_serialize_ast)
    Test.run_test("Deserialize AST", test_deserialize_ast)
    Test.run_test("Round-Trip Serialization", test_round_trip_serialization)
    
    Note: Validation tests
    Test.run_test("Validate AST Structure", test_validate_ast_structure)
    Test.run_test("Validate Node Relationships", test_validate_node_relationships)
    
    Note: Performance tests
    Test.run_test("Large Tree Operations", test_large_tree_operations)
    Test.run_test("Memory Usage", test_memory_usage)
    
    Test.end_suite()
End Process

@Security_Scope
These tests verify critical security aspects of AST operations:
- Input validation to prevent malformed tree structures
- Circular reference detection to prevent infinite loops
- Memory bounds checking in tree operations
- Safe serialization/deserialization without code injection
- Stack overflow prevention in deep tree traversals
- Memory leak detection in node creation/destruction
@End Security_Scope