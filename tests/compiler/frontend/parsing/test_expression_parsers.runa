Note: Comprehensive test suite for Expression Parsers
Note: Tests parsing of all expression types with proper precedence and associativity

@Reasoning
Expression parsing is critical for correctly interpreting mathematical and logical
expressions in both natural and technical syntax modes. Testing must verify proper
operator precedence, associativity rules, function calls, member access, and
complex nested expressions. These tests ensure expressions are parsed into the
correct AST structure for semantic analysis.
@End Reasoning

@TestCases
- Binary expression parsing with precedence
- Unary expression parsing
- Function call expressions
- Member access and property chains
- Mathematical symbol expressions
- Parenthesized expressions
- Array and object literals
- Conditional (ternary) expressions
- Type casting expressions
- Lambda expressions
@End TestCases

Import module "compiler/frontend/parsing/expression_parsers" as ExprParsers
Import module "compiler/frontend/parsing/ast" as AST
Import module "compiler/frontend/parsing/precedence" as Precedence
Import module "compiler/frontend/lexical/lexer" as Lexer
Import module "compiler/frontend/lexical/token_stream" as TokenStream
Import module "stdlib/testing/test_framework" as Test
Import module "stdlib/core/primitives/string_primitives" as StringPrim
Import module "compiler/frontend/primitives/types/compiler_internals" as Internals

Note: =====================================================================
Note: BINARY EXPRESSION PARSING TESTS
Note: =====================================================================

Process called "test_parse_arithmetic_expressions" returns Nothing:
    @Performance_Hints
    Tests parsing of basic arithmetic expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test addition
    Let add_tokens be tokenize_expression("5 plus 3")
    Let add_result be ExprParsers.parse_expression(parser, add_tokens)
    
    Test.assert_true(add_result.success)
    Let add_ast be AST.get_node(add_result.ast_node)
    Test.assert_equals(add_ast.node_type, "BinaryExpression")
    Test.assert_equals(AST.get_operator(add_ast), "plus")
    Test.assert_equals(AST.get_left_operand_value(add_ast), "5")
    Test.assert_equals(AST.get_right_operand_value(add_ast), "3")
    
    Note: Test multiplication with precedence
    Let mult_tokens be tokenize_expression("2 plus 3 multiplied by 4")
    Let mult_result be ExprParsers.parse_expression(parser, mult_tokens)
    
    Test.assert_true(mult_result.success)
    Let mult_ast be AST.get_node(mult_result.ast_node)
    Test.assert_equals(AST.get_operator(mult_ast), "plus")
    
    Note: Right operand should be "3 * 4" due to precedence
    Let right_operand be AST.get_right_operand(mult_ast)
    Test.assert_equals(AST.get_operator(right_operand), "multiplied_by")
End Process

Process called "test_parse_comparison_expressions" returns Nothing:
    @Performance_Hints
    Tests parsing of comparison expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test equality
    Let eq_tokens be tokenize_expression("x equals 42")
    Let eq_result be ExprParsers.parse_expression(parser, eq_tokens)
    
    Test.assert_true(eq_result.success)
    Let eq_ast be AST.get_node(eq_result.ast_node)
    Test.assert_equals(AST.get_operator(eq_ast), "equals")
    
    Note: Test greater than
    Let gt_tokens be tokenize_expression("age greater than 18")
    Let gt_result be ExprParsers.parse_expression(parser, gt_tokens)
    
    Test.assert_true(gt_result.success)
    Let gt_ast be AST.get_node(gt_result.ast_node)
    Test.assert_equals(AST.get_operator(gt_ast), "greater_than")
    
    Note: Test chained comparisons
    Let chain_tokens be tokenize_expression("0 less than x less than 100")
    Let chain_result be ExprParsers.parse_expression(parser, chain_tokens)
    
    Test.assert_true(chain_result.success)
    Let chain_ast be AST.get_node(chain_result.ast_node)
    Test.assert_equals(chain_ast.node_type, "ChainedComparison")
End Process

Process called "test_parse_logical_expressions" returns Nothing:
    @Performance_Hints
    Tests parsing of logical expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test logical AND
    Let and_tokens be tokenize_expression("x greater than 0 And y less than 10")
    Let and_result be ExprParsers.parse_expression(parser, and_tokens)
    
    Test.assert_true(and_result.success)
    Let and_ast be AST.get_node(and_result.ast_node)
    Test.assert_equals(AST.get_operator(and_ast), "And")
    
    Note: Test logical OR
    Let or_tokens be tokenize_expression("status equals \"active\" Or status equals \"pending\"")
    Let or_result be ExprParsers.parse_expression(parser, or_tokens)
    
    Test.assert_true(or_result.success)
    Let or_ast be AST.get_node(or_result.ast_node)
    Test.assert_equals(AST.get_operator(or_ast), "Or")
    
    Note: Test precedence: AND has higher precedence than OR
    Let mixed_tokens be tokenize_expression("a Or b And c")
    Let mixed_result be ExprParsers.parse_expression(parser, mixed_tokens)
    
    Test.assert_true(mixed_result.success)
    Let mixed_ast be AST.get_node(mixed_result.ast_node)
    Test.assert_equals(AST.get_operator(mixed_ast), "Or")
    
    Let right_side be AST.get_right_operand(mixed_ast)
    Test.assert_equals(AST.get_operator(right_side), "And")
End Process

Note: =====================================================================
Note: UNARY EXPRESSION PARSING TESTS
Note: =====================================================================

Process called "test_parse_unary_expressions" returns Nothing:
    @Performance_Hints
    Tests parsing of unary expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test negation
    Let neg_tokens be tokenize_expression("negative x")
    Let neg_result be ExprParsers.parse_expression(parser, neg_tokens)
    
    Test.assert_true(neg_result.success)
    Let neg_ast be AST.get_node(neg_result.ast_node)
    Test.assert_equals(neg_ast.node_type, "UnaryExpression")
    Test.assert_equals(AST.get_unary_operator(neg_ast), "negative")
    Test.assert_equals(AST.get_operand_value(neg_ast), "x")
    
    Note: Test logical NOT
    Let not_tokens be tokenize_expression("Not condition")
    Let not_result be ExprParsers.parse_expression(parser, not_tokens)
    
    Test.assert_true(not_result.success)
    Let not_ast be AST.get_node(not_result.ast_node)
    Test.assert_equals(AST.get_unary_operator(not_ast), "Not")
    
    Note: Test prefix increment (technical syntax)
    Let inc_tokens be tokenize_expression("++counter")
    Let inc_result be ExprParsers.parse_expression(parser, inc_tokens)
    
    Test.assert_true(inc_result.success)
    Let inc_ast be AST.get_node(inc_result.ast_node)
    Test.assert_equals(AST.get_unary_operator(inc_ast), "prefix_increment")
End Process

Process called "test_parse_postfix_expressions" returns Nothing:
    @Performance_Hints
    Tests parsing of postfix expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test postfix increment
    Let post_inc_tokens be tokenize_expression("counter++")
    Let post_inc_result be ExprParsers.parse_expression(parser, post_inc_tokens)
    
    Test.assert_true(post_inc_result.success)
    Let post_inc_ast be AST.get_node(post_inc_result.ast_node)
    Test.assert_equals(post_inc_ast.node_type, "PostfixExpression")
    Test.assert_equals(AST.get_postfix_operator(post_inc_ast), "++")
    
    Note: Test factorial (mathematical)
    Let fact_tokens be tokenize_expression("n!")
    Let fact_result be ExprParsers.parse_expression(parser, fact_tokens)
    
    Test.assert_true(fact_result.success)
    Let fact_ast be AST.get_node(fact_result.ast_node)
    Test.assert_equals(AST.get_postfix_operator(fact_ast), "!")
End Process

Note: =====================================================================
Note: FUNCTION CALL PARSING TESTS
Note: =====================================================================

Process called "test_parse_function_calls" returns Nothing:
    @Performance_Hints
    Tests parsing of function call expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test simple function call
    Let simple_tokens be tokenize_expression("calculate(x, y)")
    Let simple_result be ExprParsers.parse_expression(parser, simple_tokens)
    
    Test.assert_true(simple_result.success)
    Let simple_ast be AST.get_node(simple_result.ast_node)
    Test.assert_equals(simple_ast.node_type, "FunctionCall")
    Test.assert_equals(AST.get_function_name(simple_ast), "calculate")
    Test.assert_equals(AST.get_argument_count(simple_ast), 2)
    
    Note: Test nested function calls
    Let nested_tokens be tokenize_expression("outer(inner(a, b), c)")
    Let nested_result be ExprParsers.parse_expression(parser, nested_tokens)
    
    Test.assert_true(nested_result.success)
    Let nested_ast be AST.get_node(nested_result.ast_node)
    Test.assert_equals(AST.get_function_name(nested_ast), "outer")
    
    Let first_arg be AST.get_argument(nested_ast, 0)
    Test.assert_equals(first_arg.node_type, "FunctionCall")
    Test.assert_equals(AST.get_function_name(first_arg), "inner")
    
    Note: Test method chaining
    Let chain_tokens be tokenize_expression("object.method1().method2(arg)")
    Let chain_result be ExprParsers.parse_expression(parser, chain_tokens)
    
    Test.assert_true(chain_result.success)
    Let chain_ast be AST.get_node(chain_result.ast_node)
    Test.assert_equals(chain_ast.node_type, "MethodChain")
End Process

Process called "test_parse_named_arguments" returns Nothing:
    @Performance_Hints
    Tests parsing of function calls with named arguments.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test named arguments
    Let named_tokens be tokenize_expression("create_rectangle(width as 10, height as 20)")
    Let named_result be ExprParsers.parse_expression(parser, named_tokens)
    
    Test.assert_true(named_result.success)
    Let named_ast be AST.get_node(named_result.ast_node)
    Test.assert_equals(AST.get_function_name(named_ast), "create_rectangle")
    
    Let args be AST.get_arguments(named_ast)
    Test.assert_equals(args.length, 2)
    Test.assert_equals(AST.get_argument_name(args[0]), "width")
    Test.assert_equals(AST.get_argument_value(args[0]), "10")
End Process

Note: =====================================================================
Note: MEMBER ACCESS PARSING TESTS
Note: =====================================================================

Process called "test_parse_member_access" returns Nothing:
    @Performance_Hints
    Tests parsing of member access expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test simple property access
    Let prop_tokens be tokenize_expression("object.property")
    Let prop_result be ExprParsers.parse_expression(parser, prop_tokens)
    
    Test.assert_true(prop_result.success)
    Let prop_ast be AST.get_node(prop_result.ast_node)
    Test.assert_equals(prop_ast.node_type, "MemberAccess")
    Test.assert_equals(AST.get_object_name(prop_ast), "object")
    Test.assert_equals(AST.get_member_name(prop_ast), "property")
    
    Note: Test nested property access
    Let nested_tokens be tokenize_expression("user.profile.settings.theme")
    Let nested_result be ExprParsers.parse_expression(parser, nested_tokens)
    
    Test.assert_true(nested_result.success)
    Let nested_ast be AST.get_node(nested_result.ast_node)
    Test.assert_equals(nested_ast.node_type, "MemberAccess")
    
    Let access_chain be AST.get_access_chain(nested_ast)
    Test.assert_equals(access_chain.length, 4)
    Test.assert_equals(access_chain[0], "user")
    Test.assert_equals(access_chain[3], "theme")
End Process

Process called "test_parse_array_access" returns Nothing:
    @Performance_Hints
    Tests parsing of array access expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test simple array access
    Let array_tokens be tokenize_expression("items[0]")
    Let array_result be ExprParsers.parse_expression(parser, array_tokens)
    
    Test.assert_true(array_result.success)
    Let array_ast be AST.get_node(array_result.ast_node)
    Test.assert_equals(array_ast.node_type, "ArrayAccess")
    Test.assert_equals(AST.get_array_name(array_ast), "items")
    Test.assert_equals(AST.get_index_value(array_ast), "0")
    
    Note: Test multi-dimensional array access
    Let multi_tokens be tokenize_expression("matrix[i][j]")
    Let multi_result be ExprParsers.parse_expression(parser, multi_tokens)
    
    Test.assert_true(multi_result.success)
    Let multi_ast be AST.get_node(multi_result.ast_node)
    Test.assert_equals(multi_ast.node_type, "ArrayAccess")
    
    Note: Should be nested ArrayAccess nodes
    Let inner_access be AST.get_array_expression(multi_ast)
    Test.assert_equals(inner_access.node_type, "ArrayAccess")
End Process

Note: =====================================================================
Note: MATHEMATICAL EXPRESSION TESTS
Note: =====================================================================

Process called "test_parse_mathematical_symbols" returns Nothing:
    @Performance_Hints
    Tests parsing of mathematical symbols and operators.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test Greek letters
    Let greek_tokens be tokenize_expression("α + β × γ")
    Let greek_result be ExprParsers.parse_expression(parser, greek_tokens)
    
    Test.assert_true(greek_result.success)
    Let greek_ast be AST.get_node(greek_result.ast_node)
    Test.assert_equals(AST.get_operator(greek_ast), "+")
    
    Note: Test mathematical operators
    Let math_tokens be tokenize_expression("x ≠ y ∧ z ∈ ℕ")
    Let math_result be ExprParsers.parse_expression(parser, math_tokens)
    
    Test.assert_true(math_result.success)
    Let math_ast be AST.get_node(math_result.ast_node)
    Test.assert_equals(AST.get_operator(math_ast), "∧")  Note: logical AND
    
    Note: Test set operations
    Let set_tokens be tokenize_expression("A ∩ B ∪ C")
    Let set_result be ExprParsers.parse_expression(parser, set_tokens)
    
    Test.assert_true(set_result.success)
    Let set_ast be AST.get_node(set_result.ast_node)
    Test.assert_equals(AST.get_operator(set_ast), "∪")  Note: Union has lower precedence
End Process

Process called "test_parse_exponentiation" returns Nothing:
    @Performance_Hints
    Tests parsing of exponentiation expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test power operator
    Let power_tokens be tokenize_expression("x to the power of 2")
    Let power_result be ExprParsers.parse_expression(parser, power_tokens)
    
    Test.assert_true(power_result.success)
    Let power_ast be AST.get_node(power_result.ast_node)
    Test.assert_equals(AST.get_operator(power_ast), "to_the_power_of")
    
    Note: Test right associativity of exponentiation
    Let assoc_tokens be tokenize_expression("2^3^4")
    Let assoc_result be ExprParsers.parse_expression(parser, assoc_tokens)
    
    Test.assert_true(assoc_result.success)
    Let assoc_ast be AST.get_node(assoc_result.ast_node)
    
    Note: Should be 2^(3^4), not (2^3)^4
    Test.assert_equals(AST.get_left_operand_value(assoc_ast), "2")
    Let right_exp be AST.get_right_operand(assoc_ast)
    Test.assert_equals(AST.get_operator(right_exp), "^")
End Process

Note: =====================================================================
Note: PARENTHESIZED EXPRESSION TESTS
Note: =====================================================================

Process called "test_parse_parenthesized_expressions" returns Nothing:
    @Performance_Hints
    Tests parsing of parenthesized expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test simple parentheses
    Let paren_tokens be tokenize_expression("(x plus y)")
    Let paren_result be ExprParsers.parse_expression(parser, paren_tokens)
    
    Test.assert_true(paren_result.success)
    Let paren_ast be AST.get_node(paren_result.ast_node)
    Test.assert_equals(paren_ast.node_type, "ParenthesizedExpression")
    
    Let inner_expr be AST.get_inner_expression(paren_ast)
    Test.assert_equals(AST.get_operator(inner_expr), "plus")
    
    Note: Test precedence override
    Let override_tokens be tokenize_expression("(2 plus 3) multiplied by 4")
    Let override_result be ExprParsers.parse_expression(parser, override_tokens)
    
    Test.assert_true(override_result.success)
    Let override_ast be AST.get_node(override_result.ast_node)
    Test.assert_equals(AST.get_operator(override_ast), "multiplied_by")
    
    Let left_operand be AST.get_left_operand(override_ast)
    Test.assert_equals(left_operand.node_type, "ParenthesizedExpression")
End Process

Process called "test_parse_nested_parentheses" returns Nothing:
    @Performance_Hints
    Tests parsing of deeply nested parentheses.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test deeply nested parentheses
    Let nested_tokens be tokenize_expression("((((x))))")
    Let nested_result be ExprParsers.parse_expression(parser, nested_tokens)
    
    Test.assert_true(nested_result.success)
    Let nested_ast be AST.get_node(nested_result.ast_node)
    
    Note: Should handle nesting without issues
    Let depth be AST.get_parentheses_depth(nested_ast)
    Test.assert_equals(depth, 4)
    
    Let innermost be AST.get_innermost_expression(nested_ast)
    Test.assert_equals(AST.get_identifier_name(innermost), "x")
End Process

Note: =====================================================================
Note: LITERAL PARSING TESTS
Note: =====================================================================

Process called "test_parse_numeric_literals" returns Nothing:
    @Performance_Hints
    Tests parsing of numeric literal expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test integer literals
    Let int_tokens be tokenize_expression("42")
    Let int_result be ExprParsers.parse_expression(parser, int_tokens)
    
    Test.assert_true(int_result.success)
    Let int_ast be AST.get_node(int_result.ast_node)
    Test.assert_equals(int_ast.node_type, "LiteralExpression")
    Test.assert_equals(AST.get_literal_type(int_ast), "Integer")
    Test.assert_equals(AST.get_literal_value(int_ast), "42")
    
    Note: Test float literals
    Let float_tokens be tokenize_expression("3.14159")
    Let float_result be ExprParsers.parse_expression(parser, float_tokens)
    
    Test.assert_true(float_result.success)
    Let float_ast be AST.get_node(float_result.ast_node)
    Test.assert_equals(AST.get_literal_type(float_ast), "Float")
    
    Note: Test scientific notation
    Let sci_tokens be tokenize_expression("1.23e-4")
    Let sci_result be ExprParsers.parse_expression(parser, sci_tokens)
    
    Test.assert_true(sci_result.success)
    Let sci_ast be AST.get_node(sci_result.ast_node)
    Test.assert_equals(AST.get_literal_type(sci_ast), "Float")
End Process

Process called "test_parse_string_literals" returns Nothing:
    @Performance_Hints
    Tests parsing of string literal expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test simple string
    Let str_tokens be tokenize_expression("\"Hello, World!\"")
    Let str_result be ExprParsers.parse_expression(parser, str_tokens)
    
    Test.assert_true(str_result.success)
    Let str_ast be AST.get_node(str_result.ast_node)
    Test.assert_equals(AST.get_literal_type(str_ast), "String")
    Test.assert_equals(AST.get_literal_value(str_ast), "Hello, World!")
    
    Note: Test string with escape sequences
    Let escape_tokens be tokenize_expression("\"Line 1\\nLine 2\\t\"Quoted\"\"")
    Let escape_result be ExprParsers.parse_expression(parser, escape_tokens)
    
    Test.assert_true(escape_result.success)
    Let escape_ast be AST.get_node(escape_result.ast_node)
    Test.assert_contains(AST.get_literal_value(escape_ast), "\n")
End Process

Process called "test_parse_boolean_literals" returns Nothing:
    @Performance_Hints
    Tests parsing of boolean literal expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test true literal
    Let true_tokens be tokenize_expression("true")
    Let true_result be ExprParsers.parse_expression(parser, true_tokens)
    
    Test.assert_true(true_result.success)
    Let true_ast be AST.get_node(true_result.ast_node)
    Test.assert_equals(AST.get_literal_type(true_ast), "Boolean")
    Test.assert_equals(AST.get_literal_value(true_ast), "true")
    
    Note: Test false literal
    Let false_tokens be tokenize_expression("false")
    Let false_result be ExprParsers.parse_expression(parser, false_tokens)
    
    Test.assert_true(false_result.success)
    Let false_ast be AST.get_node(false_result.ast_node)
    Test.assert_equals(AST.get_literal_value(false_ast), "false")
End Process

Note: =====================================================================
Note: ARRAY AND OBJECT LITERAL TESTS
Note: =====================================================================

Process called "test_parse_array_literals" returns Nothing:
    @Performance_Hints
    Tests parsing of array literal expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test empty array
    Let empty_tokens be tokenize_expression("[]")
    Let empty_result be ExprParsers.parse_expression(parser, empty_tokens)
    
    Test.assert_true(empty_result.success)
    Let empty_ast be AST.get_node(empty_result.ast_node)
    Test.assert_equals(empty_ast.node_type, "ArrayLiteral")
    Test.assert_equals(AST.get_array_element_count(empty_ast), 0)
    
    Note: Test array with elements
    Let filled_tokens be tokenize_expression("[1, 2, 3, 4]")
    Let filled_result be ExprParsers.parse_expression(parser, filled_tokens)
    
    Test.assert_true(filled_result.success)
    Let filled_ast be AST.get_node(filled_result.ast_node)
    Test.assert_equals(AST.get_array_element_count(filled_ast), 4)
    
    Let first_element be AST.get_array_element(filled_ast, 0)
    Test.assert_equals(AST.get_literal_value(first_element), "1")
    
    Note: Test nested arrays
    Let nested_tokens be tokenize_expression("[[1, 2], [3, 4]]")
    Let nested_result be ExprParsers.parse_expression(parser, nested_tokens)
    
    Test.assert_true(nested_result.success)
    Let nested_ast be AST.get_node(nested_result.ast_node)
    Test.assert_equals(AST.get_array_element_count(nested_ast), 2)
    
    Let nested_element be AST.get_array_element(nested_ast, 0)
    Test.assert_equals(nested_element.node_type, "ArrayLiteral")
End Process

Process called "test_parse_object_literals" returns Nothing:
    @Performance_Hints
    Tests parsing of object literal expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test empty object
    Let empty_tokens be tokenize_expression("{}")
    Let empty_result be ExprParsers.parse_expression(parser, empty_tokens)
    
    Test.assert_true(empty_result.success)
    Let empty_ast be AST.get_node(empty_result.ast_node)
    Test.assert_equals(empty_ast.node_type, "ObjectLiteral")
    Test.assert_equals(AST.get_object_property_count(empty_ast), 0)
    
    Note: Test object with properties
    Let obj_tokens be tokenize_expression("{name: \"John\", age: 30}")
    Let obj_result be ExprParsers.parse_expression(parser, obj_tokens)
    
    Test.assert_true(obj_result.success)
    Let obj_ast be AST.get_node(obj_result.ast_node)
    Test.assert_equals(AST.get_object_property_count(obj_ast), 2)
    
    Let name_prop be AST.get_object_property(obj_ast, "name")
    Test.assert_equals(AST.get_literal_value(name_prop), "John")
End Process

Note: =====================================================================
Note: CONDITIONAL EXPRESSION TESTS
Note: =====================================================================

Process called "test_parse_ternary_expressions" returns Nothing:
    @Performance_Hints
    Tests parsing of ternary conditional expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test ternary operator
    Let ternary_tokens be tokenize_expression("x greater than 0 ? x : negative x")
    Let ternary_result be ExprParsers.parse_expression(parser, ternary_tokens)
    
    Test.assert_true(ternary_result.success)
    Let ternary_ast be AST.get_node(ternary_result.ast_node)
    Test.assert_equals(ternary_ast.node_type, "ConditionalExpression")
    
    Let condition be AST.get_condition(ternary_ast)
    Test.assert_equals(AST.get_operator(condition), "greater_than")
    
    Let true_branch be AST.get_true_expression(ternary_ast)
    Test.assert_equals(AST.get_identifier_name(true_branch), "x")
    
    Let false_branch be AST.get_false_expression(ternary_ast)
    Test.assert_equals(AST.get_unary_operator(false_branch), "negative")
End Process

Process called "test_parse_if_expressions" returns Nothing:
    @Performance_Hints
    Tests parsing of if expressions (natural language ternary).
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test if expression
    Let if_tokens be tokenize_expression("If condition Then value1 Otherwise value2")
    Let if_result be ExprParsers.parse_expression(parser, if_tokens)
    
    Test.assert_true(if_result.success)
    Let if_ast be AST.get_node(if_result.ast_node)
    Test.assert_equals(if_ast.node_type, "ConditionalExpression")
    
    Let condition be AST.get_condition(if_ast)
    Test.assert_equals(AST.get_identifier_name(condition), "condition")
End Process

Note: =====================================================================
Note: TYPE CASTING TESTS
Note: =====================================================================

Process called "test_parse_type_casting" returns Nothing:
    @Performance_Hints
    Tests parsing of type casting expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test explicit cast
    Let cast_tokens be tokenize_expression("value as Integer")
    Let cast_result be ExprParsers.parse_expression(parser, cast_tokens)
    
    Test.assert_true(cast_result.success)
    Let cast_ast be AST.get_node(cast_result.ast_node)
    Test.assert_equals(cast_ast.node_type, "TypeCast")
    Test.assert_equals(AST.get_cast_source(cast_ast), "value")
    Test.assert_equals(AST.get_cast_target_type(cast_ast), "Integer")
    
    Note: Test function-style cast
    Let func_cast_tokens be tokenize_expression("Integer(value)")
    Let func_cast_result be ExprParsers.parse_expression(parser, func_cast_tokens)
    
    Test.assert_true(func_cast_result.success)
    Let func_cast_ast be AST.get_node(func_cast_result.ast_node)
    Test.assert_equals(func_cast_ast.node_type, "TypeCast")
End Process

Note: =====================================================================
Note: LAMBDA EXPRESSION TESTS
Note: =====================================================================

Process called "test_parse_lambda_expressions" returns Nothing:
    @Performance_Hints
    Tests parsing of lambda expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test simple lambda
    Let lambda_tokens be tokenize_expression("x -> x multiplied by 2")
    Let lambda_result be ExprParsers.parse_expression(parser, lambda_tokens)
    
    Test.assert_true(lambda_result.success)
    Let lambda_ast be AST.get_node(lambda_result.ast_node)
    Test.assert_equals(lambda_ast.node_type, "LambdaExpression")
    
    Let params be AST.get_lambda_parameters(lambda_ast)
    Test.assert_equals(params.length, 1)
    Test.assert_equals(params[0], "x")
    
    Let body be AST.get_lambda_body(lambda_ast)
    Test.assert_equals(AST.get_operator(body), "multiplied_by")
    
    Note: Test lambda with multiple parameters
    Let multi_lambda_tokens be tokenize_expression("(x, y) -> x plus y")
    Let multi_lambda_result be ExprParsers.parse_expression(parser, multi_lambda_tokens)
    
    Test.assert_true(multi_lambda_result.success)
    Let multi_lambda_ast be AST.get_node(multi_lambda_result.ast_node)
    
    Let multi_params be AST.get_lambda_parameters(multi_lambda_ast)
    Test.assert_equals(multi_params.length, 2)
End Process

Note: =====================================================================
Note: ERROR HANDLING TESTS
Note: =====================================================================

Process called "test_parse_malformed_expressions" returns Nothing:
    @Performance_Hints
    Tests error handling for malformed expressions.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test missing operand
    Let missing_tokens be tokenize_expression("5 +")
    Let missing_result be ExprParsers.parse_expression(parser, missing_tokens)
    
    Test.assert_false(missing_result.success)
    Test.assert_greater_than(missing_result.errors.length, 0)
    Test.assert_contains(missing_result.errors[0], "Expected operand")
    
    Note: Test unmatched parentheses
    Let unmatched_tokens be tokenize_expression("(5 + 3")
    Let unmatched_result be ExprParsers.parse_expression(parser, unmatched_tokens)
    
    Test.assert_false(unmatched_result.success)
    Test.assert_contains(missing_result.errors[0], "Unmatched")
    
    Note: Test invalid operator sequence
    Let invalid_tokens be tokenize_expression("5 + * 3")
    Let invalid_result be ExprParsers.parse_expression(parser, invalid_tokens)
    
    Test.assert_false(invalid_result.success)
    Test.assert_contains(invalid_result.errors[0], "Unexpected operator")
End Process

Process called "test_parse_operator_precedence_edge_cases" returns Nothing:
    @Performance_Hints
    Tests edge cases in operator precedence.
    @End Performance_Hints
    
    Let parser be create_expression_parser()
    
    Note: Test mixed precedence levels
    Let mixed_tokens be tokenize_expression("a + b * c / d - e")
    Let mixed_result be ExprParsers.parse_expression(parser, mixed_tokens)
    
    Test.assert_true(mixed_result.success)
    Let mixed_ast be AST.get_node(mixed_result.ast_node)
    
    Note: Should be ((a + ((b * c) / d)) - e)
    Test.assert_equals(AST.get_operator(mixed_ast), "-")
    
    Note: Test right-associative operators
    Let right_assoc_tokens be tokenize_expression("a ^ b ^ c")
    Let right_assoc_result be ExprParsers.parse_expression(parser, right_assoc_tokens)
    
    Test.assert_true(right_assoc_result.success)
    Let right_assoc_ast be AST.get_node(right_assoc_result.ast_node)
    
    Note: Should be (a ^ (b ^ c))
    Test.assert_equals(AST.get_left_operand_value(right_assoc_ast), "a")
    Let right_side be AST.get_right_operand(right_assoc_ast)
    Test.assert_equals(AST.get_operator(right_side), "^")
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "create_expression_parser" returns ExprParsers.ExpressionParser:
    @Performance_Hints
    Creates expression parser for testing.
    @End Performance_Hints
    
    Let parser_config be ExprParsers.ParserConfig with
        allow_mathematical_symbols as true,
        enable_precedence_handling as true,
        support_lambda_expressions as true,
        strict_parentheses_matching as true,
        error_recovery_enabled as true
    End ExprParsers.ParserConfig
    
    Return ExprParsers.create_expression_parser("test_expr_parser", parser_config)
End Process

Process called "tokenize_expression" that takes expression as String returns Internals.InternalArray:
    @Performance_Hints
    Tokenizes expression string for testing.
    @End Performance_Hints
    
    Let lexer be Lexer.create_lexer("expr_test_lexer")
    Let token_stream be Lexer.tokenize(lexer, expression)
    Return TokenStream.get_all_tokens(token_stream)
End Process

Note: =====================================================================
Note: TEST RUNNER
Note: =====================================================================

Process called "run_all_expression_parser_tests" returns Nothing:
    @Performance_Hints
    Runs all expression parser tests.
    @End Performance_Hints
    
    Test.start_suite("Expression Parser Tests")
    
    Note: Binary expression tests
    Test.run_test("Parse Arithmetic Expressions", test_parse_arithmetic_expressions)
    Test.run_test("Parse Comparison Expressions", test_parse_comparison_expressions)
    Test.run_test("Parse Logical Expressions", test_parse_logical_expressions)
    
    Note: Unary expression tests
    Test.run_test("Parse Unary Expressions", test_parse_unary_expressions)
    Test.run_test("Parse Postfix Expressions", test_parse_postfix_expressions)
    
    Note: Function call tests
    Test.run_test("Parse Function Calls", test_parse_function_calls)
    Test.run_test("Parse Named Arguments", test_parse_named_arguments)
    
    Note: Member access tests
    Test.run_test("Parse Member Access", test_parse_member_access)
    Test.run_test("Parse Array Access", test_parse_array_access)
    
    Note: Mathematical expression tests
    Test.run_test("Parse Mathematical Symbols", test_parse_mathematical_symbols)
    Test.run_test("Parse Exponentiation", test_parse_exponentiation)
    
    Note: Parenthesized expression tests
    Test.run_test("Parse Parenthesized Expressions", test_parse_parenthesized_expressions)
    Test.run_test("Parse Nested Parentheses", test_parse_nested_parentheses)
    
    Note: Literal tests
    Test.run_test("Parse Numeric Literals", test_parse_numeric_literals)
    Test.run_test("Parse String Literals", test_parse_string_literals)
    Test.run_test("Parse Boolean Literals", test_parse_boolean_literals)
    
    Note: Array and object literal tests
    Test.run_test("Parse Array Literals", test_parse_array_literals)
    Test.run_test("Parse Object Literals", test_parse_object_literals)
    
    Note: Conditional expression tests
    Test.run_test("Parse Ternary Expressions", test_parse_ternary_expressions)
    Test.run_test("Parse If Expressions", test_parse_if_expressions)
    
    Note: Type casting tests
    Test.run_test("Parse Type Casting", test_parse_type_casting)
    
    Note: Lambda expression tests
    Test.run_test("Parse Lambda Expressions", test_parse_lambda_expressions)
    
    Note: Error handling tests
    Test.run_test("Parse Malformed Expressions", test_parse_malformed_expressions)
    Test.run_test("Parse Operator Precedence Edge Cases", test_parse_operator_precedence_edge_cases)
    
    Test.end_suite()
End Process

@Security_Scope
These tests verify critical security aspects of expression parsing:
- Input validation to prevent injection attacks through expressions
- Stack overflow prevention in deeply nested expressions
- Bounds checking for array and object access
- Safe evaluation of mathematical expressions
- Proper handling of malformed input without crashes
- Memory safety in AST node creation for expressions
@End Security_Scope