Note: Comprehensive test suite for the Runa Parser
Note: Tests recursive descent parsing, dual syntax support, and AST generation

@Reasoning
The parser is the core component that transforms tokenized input into an Abstract
Syntax Tree (AST). Testing must verify correct parsing of both natural and technical
syntax, proper error recovery, AST structure integrity, and performance characteristics.
These tests ensure the parser correctly handles all Runa language constructs and
maintains consistency between the two syntax modes.
@End Reasoning

@TestCases
- Natural language statement parsing
- Technical syntax parsing for developer mode
- Expression parsing with precedence
- Mathematical symbol support
- Error recovery and reporting
- Dual syntax mode switching
- AST generation and validation
- Incremental parsing support
- Performance benchmarks
- Edge cases and malformed input
@End TestCases

Import module "compiler/frontend/parsing/parser" as Parser
Import module "compiler/frontend/parsing/ast" as AST
Import module "compiler/frontend/parsing/precedence" as Precedence
Import module "compiler/frontend/lexical/lexer" as Lexer
Import module "compiler/frontend/lexical/token_stream" as TokenStream
Import module "stdlib/testing/test_framework" as Test
Import module "stdlib/core/primitives/string_primitives" as StringPrim
Import module "compiler/frontend/primitives/types/compiler_internals" as Internals

Note: =====================================================================
Note: PARSER INITIALIZATION TESTS
Note: =====================================================================

Process called "test_create_parser" returns Nothing:
    @Performance_Hints
    Tests basic parser creation and initialization.
    @End Performance_Hints
    
    Let mode be Parser.ParserMode with
        syntax_mode as "natural",
        strict_natural_language as true,
        allow_technical_syntax as false,
        mathematical_symbols_enabled as true,
        error_recovery_enabled as true
    End Parser.ParserMode
    
    Let parser be Parser.create_parser("test_parser", mode)
    
    Test.assert_not_null(parser)
    Test.assert_equals(parser.parser_name, "test_parser")
    Test.assert_not_null(parser.state)
    Test.assert_equals(parser.state.mode.syntax_mode, "natural")
    Test.assert_true(parser.state.mode.strict_natural_language)
    Test.assert_false(parser.state.mode.allow_technical_syntax)
End Process

Process called "test_dual_mode_parser" returns Nothing:
    @Performance_Hints
    Tests parser with dual syntax mode enabled.
    @End Performance_Hints
    
    Let mode be Parser.ParserMode with
        syntax_mode as "dual",
        strict_natural_language as false,
        allow_technical_syntax as true,
        mathematical_symbols_enabled as true,
        error_recovery_enabled as true
    End Parser.ParserMode
    
    Let parser be Parser.create_parser("dual_parser", mode)
    
    Test.assert_equals(parser.state.mode.syntax_mode, "dual")
    Test.assert_false(parser.state.mode.strict_natural_language)
    Test.assert_true(parser.state.mode.allow_technical_syntax)
    Test.assert_true(parser.state.mode.mathematical_symbols_enabled)
End Process

Note: =====================================================================
Note: NATURAL LANGUAGE PARSING TESTS
Note: =====================================================================

Process called "test_parse_let_statement" returns Nothing:
    @Performance_Hints
    Tests parsing of natural language Let statements.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "Let x be 42"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Test.assert_equals(result.errors.length, 0)
    Test.assert_not_null(result.ast_node)
    
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "LetStatement")
    Test.assert_equals(AST.get_identifier(ast), "x")
    Test.assert_equals(AST.get_initializer_value(ast), "42")
End Process

Process called "test_parse_process_declaration" returns Nothing:
    @Performance_Hints
    Tests parsing of Process (function) declarations.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "Process called \"calculate\" that takes x as Integer returns Integer:"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Test.assert_not_null(result.ast_node)
    
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "ProcessDeclaration")
    Test.assert_equals(AST.get_function_name(ast), "calculate")
    Test.assert_equals(AST.get_parameter_count(ast), 1)
    Test.assert_equals(AST.get_return_type(ast), "Integer")
End Process

Process called "test_parse_if_statement" returns Nothing:
    @Performance_Hints
    Tests parsing of conditional statements.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "If x greater than 10:"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "IfStatement")
    
    Let condition be AST.get_condition(ast)
    Test.assert_not_null(condition)
    Test.assert_equals(AST.get_operator(condition), "greater_than")
End Process

Process called "test_parse_for_loop" returns Nothing:
    @Performance_Hints
    Tests parsing of For Each loops.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "For Each item in collection:"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "ForEachStatement")
    Test.assert_equals(AST.get_iterator_variable(ast), "item")
    Test.assert_equals(AST.get_iterable_expression(ast), "collection")
End Process

Note: =====================================================================
Note: TECHNICAL SYNTAX PARSING TESTS
Note: =====================================================================

Process called "test_parse_technical_assignment" returns Nothing:
    @Performance_Hints
    Tests parsing of technical syntax assignments.
    @End Performance_Hints
    
    Let parser be create_technical_parser()
    Let input be "x = 42"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "AssignmentStatement")
    Test.assert_equals(AST.get_lhs(ast), "x")
    Test.assert_equals(AST.get_rhs_value(ast), "42")
End Process

Process called "test_parse_technical_function" returns Nothing:
    @Performance_Hints
    Tests parsing of technical syntax function declarations.
    @End Performance_Hints
    
    Let parser be create_technical_parser()
    Let input be "function calculate(x: Integer): Integer {"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "FunctionDeclaration")
    Test.assert_equals(AST.get_function_name(ast), "calculate")
End Process

Process called "test_parse_technical_conditional" returns Nothing:
    @Performance_Hints
    Tests parsing of technical syntax conditionals.
    @End Performance_Hints
    
    Let parser be create_technical_parser()
    Let input be "if (x > 10) {"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "IfStatement")
    
    Let condition be AST.get_condition(ast)
    Test.assert_equals(AST.get_operator(condition), ">")
End Process

Note: =====================================================================
Note: EXPRESSION PARSING TESTS
Note: =====================================================================

Process called "test_parse_binary_expression" returns Nothing:
    @Performance_Hints
    Tests parsing of binary expressions with precedence.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "x plus y multiplied by z"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_expression(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "BinaryExpression")
    
    Note: Verify precedence (multiply before add)
    Let root_op be AST.get_operator(ast)
    Test.assert_equals(root_op, "plus")
    
    Let right_child be AST.get_right_operand(ast)
    Test.assert_equals(AST.get_operator(right_child), "multiplied_by")
End Process

Process called "test_parse_function_call" returns Nothing:
    @Performance_Hints
    Tests parsing of function call expressions.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "calculate(x, y, z)"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_expression(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "FunctionCall")
    Test.assert_equals(AST.get_function_name(ast), "calculate")
    Test.assert_equals(AST.get_argument_count(ast), 3)
End Process

Process called "test_parse_member_access" returns Nothing:
    @Performance_Hints
    Tests parsing of member access expressions.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "object.property.nested"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_expression(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "MemberAccess")
    
    Let chain be AST.get_access_chain(ast)
    Test.assert_equals(chain.length, 3)
    Test.assert_equals(chain[0], "object")
    Test.assert_equals(chain[1], "property")
    Test.assert_equals(chain[2], "nested")
End Process

Note: =====================================================================
Note: MATHEMATICAL SYMBOL PARSING TESTS
Note: =====================================================================

Process called "test_parse_math_symbols" returns Nothing:
    @Performance_Hints
    Tests parsing of mathematical symbols.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "∀x ∈ ℕ: x ≥ 0"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "UniversalQuantifier")
    
    Let variable be AST.get_quantified_variable(ast)
    Test.assert_equals(variable, "x")
    
    Let domain be AST.get_domain(ast)
    Test.assert_equals(domain, "ℕ")
End Process

Process called "test_parse_greek_letters" returns Nothing:
    @Performance_Hints
    Tests parsing of Greek letters in expressions.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "Let α be π multiplied by β"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(AST.get_identifier(ast), "α")
    
    Let init_expr be AST.get_initializer(ast)
    Test.assert_equals(AST.get_operator(init_expr), "multiplied_by")
    Test.assert_equals(AST.get_left_operand_value(init_expr), "π")
    Test.assert_equals(AST.get_right_operand_value(init_expr), "β")
End Process

Note: =====================================================================
Note: ERROR RECOVERY TESTS
Note: =====================================================================

Process called "test_error_recovery_missing_keyword" returns Nothing:
    @Performance_Hints
    Tests error recovery when keywords are missing.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "x be 42"  Note: Missing "Let"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_false(result.success)
    Test.assert_greater_than(result.errors.length, 0)
    Test.assert_contains(result.errors[0], "Expected 'Let'")
    
    Note: Check if recovery suggestion provided
    Test.assert_greater_than(result.warnings.length, 0)
    Test.assert_contains(result.warnings[0], "Did you mean: Let x be 42")
End Process

Process called "test_error_recovery_unclosed_block" returns Nothing:
    @Performance_Hints
    Tests error recovery for unclosed blocks.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "If x greater than 10:\n    Return true"
    Note: Missing "End If"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_false(result.success)
    Test.assert_contains(result.errors[0], "Expected 'End If'")
    
    Note: Should still create partial AST
    Test.assert_not_null(result.ast_node)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "IfStatement")
End Process

Process called "test_error_recovery_invalid_expression" returns Nothing:
    @Performance_Hints
    Tests error recovery for invalid expressions.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "Let x be 5 plus plus 3"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_false(result.success)
    Test.assert_contains(result.errors[0], "Unexpected operator")
    
    Note: Should recover and parse what it can
    Test.assert_not_null(result.ast_node)
End Process

Note: =====================================================================
Note: PATTERN MATCHING TESTS
Note: =====================================================================

Process called "test_parse_match_statement" returns Nothing:
    @Performance_Hints
    Tests parsing of Match statements.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "Match value:\n    When 1:\n        Return \"one\"\n    When 2:\n        Return \"two\"\n    Otherwise:\n        Return \"other\"\nEnd Match"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "MatchStatement")
    
    Let cases be AST.get_match_cases(ast)
    Test.assert_equals(cases.length, 3)
    Test.assert_equals(AST.get_pattern(cases[0]), "1")
    Test.assert_equals(AST.get_pattern(cases[1]), "2")
    Test.assert_equals(AST.get_pattern(cases[2]), "_")  Note: Otherwise is wildcard
End Process

Process called "test_parse_destructuring" returns Nothing:
    @Performance_Hints
    Tests parsing of destructuring patterns.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "Let [x, y, z] be coordinates"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "LetStatement")
    
    Let pattern be AST.get_destructuring_pattern(ast)
    Test.assert_not_null(pattern)
    Test.assert_equals(pattern.type, "ArrayPattern")
    Test.assert_equals(pattern.elements.length, 3)
End Process

Note: =====================================================================
Note: TYPE ANNOTATION TESTS
Note: =====================================================================

Process called "test_parse_type_annotations" returns Nothing:
    @Performance_Hints
    Tests parsing of type annotations.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "Let x as Integer be 42"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(AST.get_type_annotation(ast), "Integer")
End Process

Process called "test_parse_generic_types" returns Nothing:
    @Performance_Hints
    Tests parsing of generic type annotations.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "Let items as List[String] be empty_list"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    
    Let type_node be AST.get_type_node(ast)
    Test.assert_equals(type_node.type_name, "List")
    Test.assert_equals(type_node.type_parameters.length, 1)
    Test.assert_equals(type_node.type_parameters[0], "String")
End Process

Note: =====================================================================
Note: INCREMENTAL PARSING TESTS
Note: =====================================================================

Process called "test_incremental_parsing" returns Nothing:
    @Performance_Hints
    Tests incremental parsing for IDE integration.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Parser.enable_incremental_mode(parser)
    
    Note: Parse initial document
    Let initial_input be "Let x be 10\nLet y be 20"
    Let initial_tokens be tokenize_input(initial_input)
    Let initial_result be Parser.parse_tokens(parser, initial_tokens)
    
    Test.assert_true(initial_result.success)
    
    Note: Make incremental change
    Let change be Parser.TextChange with
        start_line as 1,
        start_column as 9,
        end_line as 1,
        end_column as 11,
        new_text as "15"
    End Parser.TextChange
    
    Let incremental_result be Parser.parse_incremental(parser, change)
    
    Test.assert_true(incremental_result.success)
    Test.assert_less_than(incremental_result.parsing_time_ms, initial_result.parsing_time_ms)
    
    Note: Verify only affected nodes were reparsed
    Let reparsed_nodes be AST.get_reparsed_nodes(incremental_result.ast_node)
    Test.assert_equals(reparsed_nodes.length, 1)
End Process

Note: =====================================================================
Note: PERFORMANCE BENCHMARKS
Note: =====================================================================

Process called "test_parsing_performance" returns Nothing:
    @Performance_Hints
    Tests parser performance on large inputs.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    
    Note: Generate large input
    Let large_input be generate_large_program(1000)  Note: 1000 statements
    Let tokens be tokenize_input(large_input)
    
    Let start_time be get_timestamp_ms()
    Let result be Parser.parse_tokens(parser, tokens)
    Let end_time be get_timestamp_ms()
    
    Let parsing_time be end_time minus start_time
    
    Test.assert_true(result.success)
    Test.assert_less_than(parsing_time, 1000)  Note: Should parse in under 1 second
    
    Let stats be parser.statistics
    Test.assert_equals(stats.statements_parsed, 1000)
    Test.assert_greater_than(stats.expressions_parsed, 0)
End Process

Note: =====================================================================
Note: EDGE CASES AND MALFORMED INPUT
Note: =====================================================================

Process called "test_empty_input" returns Nothing:
    @Performance_Hints
    Tests parser behavior with empty input.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let empty_tokens be Internals.create_internal_array(0)
    
    Let result be Parser.parse_tokens(parser, empty_tokens)
    
    Test.assert_true(result.success)
    Test.assert_not_null(result.ast_node)
    
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "Program")
    Test.assert_equals(ast.children.length, 0)
End Process

Process called "test_deeply_nested_expressions" returns Nothing:
    @Performance_Hints
    Tests parsing of deeply nested expressions.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "((((((((((a))))))))))"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_expression(parser, tokens)
    
    Test.assert_true(result.success)
    Let ast be AST.get_node(result.ast_node)
    
    Note: Should handle deep nesting without stack overflow
    Let depth be AST.get_nesting_depth(ast)
    Test.assert_equals(depth, 10)
End Process

Process called "test_unicode_identifiers" returns Nothing:
    @Performance_Hints
    Tests parsing of Unicode identifiers.
    @End Performance_Hints
    
    Let parser be create_natural_parser()
    Let input be "Let 变量 be 值\nLet مُتَغَيِّر be قيمة"
    Let tokens be tokenize_input(input)
    
    Let result be Parser.parse_tokens(parser, tokens)
    
    Test.assert_true(result.success)
    Let statements be AST.get_statements(result.ast_node)
    Test.assert_equals(statements.length, 2)
    
    Test.assert_equals(AST.get_identifier(statements[0]), "变量")
    Test.assert_equals(AST.get_identifier(statements[1]), "مُتَغَيِّر")
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "create_natural_parser" returns Parser.Parser:
    @Performance_Hints
    Creates a parser configured for natural language syntax.
    @End Performance_Hints
    
    Let mode be Parser.ParserMode with
        syntax_mode as "natural",
        strict_natural_language as true,
        allow_technical_syntax as false,
        mathematical_symbols_enabled as true,
        error_recovery_enabled as true
    End Parser.ParserMode
    
    Return Parser.create_parser("natural_test_parser", mode)
End Process

Process called "create_technical_parser" returns Parser.Parser:
    @Performance_Hints
    Creates a parser configured for technical syntax.
    @End Performance_Hints
    
    Let mode be Parser.ParserMode with
        syntax_mode as "technical",
        strict_natural_language as false,
        allow_technical_syntax as true,
        mathematical_symbols_enabled as true,
        error_recovery_enabled as true
    End Parser.ParserMode
    
    Return Parser.create_parser("technical_test_parser", mode)
End Process

Process called "tokenize_input" that takes input as String returns Internals.InternalArray:
    @Performance_Hints
    Tokenizes input string for parser testing.
    @End Performance_Hints
    
    Let lexer be Lexer.create_lexer("test_lexer")
    Let token_stream be Lexer.tokenize(lexer, input)
    Return TokenStream.get_all_tokens(token_stream)
End Process

Process called "generate_large_program" that takes statement_count as Integer returns String:
    @Performance_Hints
    Generates a large program for performance testing.
    @End Performance_Hints
    
    Let sb be Internals.create_string_builder()
    
    Let i be 0
    While i less than statement_count:
        Internals.string_builder_append(sb, "Let var")
        Internals.string_builder_append(sb, integer_to_string(i))
        Internals.string_builder_append(sb, " be ")
        Internals.string_builder_append(sb, integer_to_string(i multiplied by 2))
        Internals.string_builder_append(sb, "\n")
        Set i to i plus 1
    End While
    
    Return Internals.string_builder_to_string(sb)
End Process

Process called "get_timestamp_ms" returns Integer:
    @Performance_Hints
    Gets current timestamp in milliseconds.
    @End Performance_Hints
    
    Let seconds as Integer
    Let nanoseconds as Integer
    
    Inline Assembly:
        "mov rax, 228\n"
        "mov rdi, 1\n"
        "lea rsi, [rsp-16]\n"
        "syscall\n"
        "mov %0, [rsi]\n"
        "mov %1, [rsi+8]\n"
        : "=r"(seconds), "=r"(nanoseconds)
        :
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return seconds multiplied by 1000 plus (nanoseconds divided by 1000000)
End Process

Process called "integer_to_string" that takes value as Integer returns String:
    @Performance_Hints
    Converts integer to string.
    @End Performance_Hints
    
    If value equals 0:
        Return "0"
    End If
    
    Let is_negative be value less than 0
    Let num be value
    If is_negative:
        Set num to 0 minus value
    End If
    
    Let sb be Internals.create_string_builder()
    Let digits be Internals.create_internal_array(20)
    Let digit_count be 0
    
    While num greater than 0:
        Let digit be num modulo 10
        Internals.internal_array_add(digits, digit)
        Set digit_count to digit_count plus 1
        Set num to num divided by 10
    End While
    
    If is_negative:
        Internals.string_builder_append(sb, "-")
    End If
    
    Let i be digit_count minus 1
    While i greater than or equal to 0:
        Let digit be Internals.internal_array_get(digits, i)
        Let digit_char be character_from_code(digit plus 48)
        Internals.string_builder_append(sb, digit_char)
        Set i to i minus 1
    End While
    
    Return Internals.string_builder_to_string(sb)
End Process

Process called "character_from_code" that takes code as Integer returns String:
    @Performance_Hints
    Creates single-character string from ASCII code.
    @End Performance_Hints
    
    Let buffer be Internals.allocate_raw_memory(2)
    Internals.write_byte_at(buffer, 0, code)
    Internals.write_byte_at(buffer, 1, 0)  Note: Null terminator
    
    Let str be Internals.ptr_to_string(buffer)
    Internals.free_raw_memory(buffer, 2)
    Return str
End Process

Note: =====================================================================
Note: TEST RUNNER
Note: =====================================================================

Process called "run_all_parser_tests" returns Nothing:
    @Performance_Hints
    Runs all parser tests.
    @End Performance_Hints
    
    Test.start_suite("Parser Tests")
    
    Note: Initialization tests
    Test.run_test("Create Parser", test_create_parser)
    Test.run_test("Dual Mode Parser", test_dual_mode_parser)
    
    Note: Natural language parsing
    Test.run_test("Parse Let Statement", test_parse_let_statement)
    Test.run_test("Parse Process Declaration", test_parse_process_declaration)
    Test.run_test("Parse If Statement", test_parse_if_statement)
    Test.run_test("Parse For Loop", test_parse_for_loop)
    
    Note: Technical syntax parsing
    Test.run_test("Parse Technical Assignment", test_parse_technical_assignment)
    Test.run_test("Parse Technical Function", test_parse_technical_function)
    Test.run_test("Parse Technical Conditional", test_parse_technical_conditional)
    
    Note: Expression parsing
    Test.run_test("Parse Binary Expression", test_parse_binary_expression)
    Test.run_test("Parse Function Call", test_parse_function_call)
    Test.run_test("Parse Member Access", test_parse_member_access)
    
    Note: Mathematical symbols
    Test.run_test("Parse Math Symbols", test_parse_math_symbols)
    Test.run_test("Parse Greek Letters", test_parse_greek_letters)
    
    Note: Error recovery
    Test.run_test("Error Recovery Missing Keyword", test_error_recovery_missing_keyword)
    Test.run_test("Error Recovery Unclosed Block", test_error_recovery_unclosed_block)
    Test.run_test("Error Recovery Invalid Expression", test_error_recovery_invalid_expression)
    
    Note: Pattern matching
    Test.run_test("Parse Match Statement", test_parse_match_statement)
    Test.run_test("Parse Destructuring", test_parse_destructuring)
    
    Note: Type annotations
    Test.run_test("Parse Type Annotations", test_parse_type_annotations)
    Test.run_test("Parse Generic Types", test_parse_generic_types)
    
    Note: Incremental parsing
    Test.run_test("Incremental Parsing", test_incremental_parsing)
    
    Note: Performance
    Test.run_test("Parsing Performance", test_parsing_performance)
    
    Note: Edge cases
    Test.run_test("Empty Input", test_empty_input)
    Test.run_test("Deeply Nested Expressions", test_deeply_nested_expressions)
    Test.run_test("Unicode Identifiers", test_unicode_identifiers)
    
    Test.end_suite()
End Process

@Security_Scope
These tests verify critical security aspects of parsing:
- Input validation to prevent injection attacks
- Stack overflow prevention in deeply nested structures
- Unicode handling to prevent encoding attacks
- Error recovery without information leakage
- Memory safety in AST construction
- Bounds checking for token consumption
@End Security_Scope