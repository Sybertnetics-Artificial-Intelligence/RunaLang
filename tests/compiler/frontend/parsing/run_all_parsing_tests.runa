Note: Master test runner for all Frontend Parsing module tests
Note: Orchestrates execution of parser, AST, and expression parser test suites

@Reasoning
The parsing module is a critical component of the Runa compiler that transforms
tokenized input into Abstract Syntax Trees. A comprehensive test runner ensures
all parsing functionality is thoroughly tested, from basic token parsing to
complex expression evaluation and AST manipulation. This runner coordinates
execution of all parsing-related tests and provides consolidated reporting.
@End Reasoning

@TestCases
- Parser initialization and configuration tests
- Natural language statement parsing tests
- Technical syntax parsing tests
- Expression parsing with precedence tests
- AST creation and manipulation tests
- AST transformation and serialization tests
- Error recovery and handling tests
- Performance and memory tests
- Integration tests across parsing components
@End TestCases

Import module "tests/compiler/frontend/parsing/test_parser" as ParserTests
Import module "tests/compiler/frontend/parsing/test_ast" as ASTTests
Import module "tests/compiler/frontend/parsing/test_expression_parsers" as ExprTests
Import module "stdlib/testing/test_framework" as Test
Import module "stdlib/core/primitives/string_primitives" as StringPrim
Import module "compiler/frontend/primitives/types/compiler_internals" as Internals

Note: =====================================================================
Note: MASTER TEST RUNNER
Note: =====================================================================

Process called "run_all_parsing_tests" returns Nothing:
    @Performance_Hints
    Runs all parsing module tests with timing and reporting.
    @End Performance_Hints
    
    Test.start_master_suite("Frontend Parsing Module Tests")
    
    Note: Record start time for performance tracking
    Let start_time be get_timestamp_ms()
    
    Note: Initialize test statistics
    Let total_tests be 0
    Let passed_tests be 0
    Let failed_tests be 0
    Let skipped_tests be 0
    
    Note: Run Parser tests
    Test.log_info("Starting Parser tests...")
    Let parser_start be get_timestamp_ms()
    ParserTests.run_all_parser_tests()
    Let parser_end be get_timestamp_ms()
    Let parser_time be parser_end minus parser_start
    
    Let parser_stats be Test.get_suite_statistics()
    Set total_tests to total_tests plus parser_stats.total
    Set passed_tests to passed_tests plus parser_stats.passed
    Set failed_tests to failed_tests plus parser_stats.failed
    Set skipped_tests to skipped_tests plus parser_stats.skipped
    
    Test.log_info("Parser tests completed in " + integer_to_string(parser_time) + "ms")
    
    Note: Run AST tests
    Test.log_info("Starting AST tests...")
    Let ast_start be get_timestamp_ms()
    ASTTests.run_all_ast_tests()
    Let ast_end be get_timestamp_ms()
    Let ast_time be ast_end minus ast_start
    
    Let ast_stats be Test.get_suite_statistics()
    Set total_tests to total_tests plus ast_stats.total
    Set passed_tests to passed_tests plus ast_stats.passed
    Set failed_tests to failed_tests plus ast_stats.failed
    Set skipped_tests to skipped_tests plus ast_stats.skipped
    
    Test.log_info("AST tests completed in " + integer_to_string(ast_time) + "ms")
    
    Note: Run Expression Parser tests
    Test.log_info("Starting Expression Parser tests...")
    Let expr_start be get_timestamp_ms()
    ExprTests.run_all_expression_parser_tests()
    Let expr_end be get_timestamp_ms()
    Let expr_time be expr_end minus expr_start
    
    Let expr_stats be Test.get_suite_statistics()
    Set total_tests to total_tests plus expr_stats.total
    Set passed_tests to passed_tests plus expr_stats.passed
    Set failed_tests to failed_tests plus expr_stats.failed
    Set skipped_tests to skipped_tests plus expr_stats.skipped
    
    Test.log_info("Expression Parser tests completed in " + integer_to_string(expr_time) + "ms")
    
    Note: Run integration tests
    Test.log_info("Starting Integration tests...")
    Let integration_start be get_timestamp_ms()
    run_parsing_integration_tests()
    Let integration_end be get_timestamp_ms()
    Let integration_time be integration_end minus integration_start
    
    Let integration_stats be Test.get_suite_statistics()
    Set total_tests to total_tests plus integration_stats.total
    Set passed_tests to passed_tests plus integration_stats.passed
    Set failed_tests to failed_tests plus integration_stats.failed
    Set skipped_tests to skipped_tests plus integration_stats.skipped
    
    Test.log_info("Integration tests completed in " + integer_to_string(integration_time) + "ms")
    
    Note: Calculate total execution time
    Let end_time be get_timestamp_ms()
    Let total_time be end_time minus start_time
    
    Note: Generate comprehensive report
    generate_parsing_test_report(
        total_tests,
        passed_tests,
        failed_tests,
        skipped_tests,
        total_time,
        parser_time,
        ast_time,
        expr_time,
        integration_time
    )
    
    Test.end_master_suite()
End Process

Note: =====================================================================
Note: INTEGRATION TESTS
Note: =====================================================================

Process called "run_parsing_integration_tests" returns Nothing:
    @Performance_Hints
    Tests integration between parser, AST, and expression components.
    @End Performance_Hints
    
    Test.start_suite("Parsing Integration Tests")
    
    Test.run_test("Parser-AST Integration", test_parser_ast_integration)
    Test.run_test("Parser-Expression Integration", test_parser_expression_integration)
    Test.run_test("AST-Expression Integration", test_ast_expression_integration)
    Test.run_test("Full Pipeline Integration", test_full_pipeline_integration)
    Test.run_test("Error Propagation Integration", test_error_propagation_integration)
    Test.run_test("Memory Management Integration", test_memory_management_integration)
    
    Test.end_suite()
End Process

Process called "test_parser_ast_integration" returns Nothing:
    @Performance_Hints
    Tests integration between parser and AST components.
    @End Performance_Hints
    
    Note: Test that parser produces valid AST structures
    Let parser be ParserTests.create_natural_parser()
    Let input be "Let x be 5 plus 3 multiplied by 2"
    Let tokens be ParserTests.tokenize_input(input)
    
    Let parse_result be parser.parse_tokens(tokens)
    Test.assert_true(parse_result.success)
    
    Note: Validate AST structure
    Let ast_validation be ASTTests.validate_ast_structure(parse_result.ast_node)
    Test.assert_true(ast_validation.is_valid)
    
    Note: Verify expression precedence in AST
    Let expr_node be AST.find_first_by_type(parse_result.ast_node, "BinaryExpression")
    Test.assert_not_null(expr_node)
    Test.assert_equals(AST.get_operator(expr_node), "plus")
    
    Let right_operand be AST.get_right_operand(expr_node)
    Test.assert_equals(AST.get_operator(right_operand), "multiplied_by")
End Process

Process called "test_parser_expression_integration" returns Nothing:
    @Performance_Hints
    Tests integration between parser and expression parser.
    @End Performance_Hints
    
    Let parser be ParserTests.create_natural_parser()
    Let expr_parser be ExprTests.create_expression_parser()
    
    Note: Test that parser delegates expression parsing correctly
    Let input be "calculate(x plus y, z multiplied by 2)"
    Let tokens be ParserTests.tokenize_input(input)
    
    Let result be parser.parse_expression(tokens)
    Test.assert_true(result.success)
    
    Let ast be AST.get_node(result.ast_node)
    Test.assert_equals(ast.node_type, "FunctionCall")
    Test.assert_equals(AST.get_function_name(ast), "calculate")
    Test.assert_equals(AST.get_argument_count(ast), 2)
    
    Note: Verify arguments are properly parsed expressions
    Let first_arg be AST.get_argument(ast, 0)
    Test.assert_equals(first_arg.node_type, "BinaryExpression")
    Test.assert_equals(AST.get_operator(first_arg), "plus")
End Process

Process called "test_ast_expression_integration" returns Nothing:
    @Performance_Hints
    Tests integration between AST and expression components.
    @End Performance_Hints
    
    Note: Create expression AST and verify it integrates with AST operations
    Let expr_parser be ExprTests.create_expression_parser()
    Let tokens be ExprTests.tokenize_expression("(a plus b) multiplied by (c minus d)")
    
    Let expr_result be expr_parser.parse_expression(tokens)
    Test.assert_true(expr_result.success)
    
    Let expr_ast be AST.get_node(expr_result.ast_node)
    
    Note: Test AST traversal on expression tree
    Let visited_nodes be Internals.create_internal_array(10)
    ASTTests.traverse_depth_first(expr_ast, visited_nodes)
    
    Test.assert_greater_than(visited_nodes.length, 5)
    
    Note: Test AST transformation on expressions
    Let tech_ast be AST.transform_to_technical_syntax(expr_ast)
    Test.assert_not_null(tech_ast)
    Test.assert_equals(tech_ast.syntax_mode, "technical")
End Process

Process called "test_full_pipeline_integration" returns Nothing:
    @Performance_Hints
    Tests the complete parsing pipeline from tokens to AST.
    @End Performance_Hints
    
    Note: Test complex program through entire pipeline
    Let complex_program be "
        Process called \"fibonacci\" that takes n as Integer returns Integer:
            If n less than or equal to 1:
                Return n
            End If
            Return fibonacci(n minus 1) plus fibonacci(n minus 2)
        End Process
        
        Let result be fibonacci(10)
    "
    
    Let parser be ParserTests.create_natural_parser()
    let tokens be ParserTests.tokenize_input(complex_program)
    
    Let parse_result be parser.parse_tokens(tokens)
    Test.assert_true(parse_result.success)
    
    Note: Validate complete AST structure
    Let program_ast be AST.get_node(parse_result.ast_node)
    Test.assert_equals(program_ast.node_type, "Program")
    
    Let statements be AST.get_statements(program_ast)
    Test.assert_equals(statements.length, 2)
    
    Note: Verify function declaration
    Let func_decl be statements[0]
    Test.assert_equals(func_decl.node_type, "ProcessDeclaration")
    Test.assert_equals(AST.get_function_name(func_decl), "fibonacci")
    
    Note: Verify variable declaration
    Let var_decl be statements[1]
    Test.assert_equals(var_decl.node_type, "LetStatement")
    
    Note: Verify recursive function call in initializer
    Let initializer be AST.get_initializer(var_decl)
    Test.assert_equals(initializer.node_type, "FunctionCall")
    Test.assert_equals(AST.get_function_name(initializer), "fibonacci")
End Process

Process called "test_error_propagation_integration" returns Nothing:
    @Performance_Hints
    Tests error propagation across parsing components.
    @End Performance_Hints
    
    Let parser be ParserTests.create_natural_parser()
    
    Note: Test malformed input propagates errors correctly
    Let malformed_input be "Let x be 5 plus plus 3"  Note: Double operator
    Let tokens be ParserTests.tokenize_input(malformed_input)
    
    Let result be parser.parse_tokens(tokens)
    Test.assert_false(result.success)
    Test.assert_greater_than(result.errors.length, 0)
    
    Note: Verify error contains useful information
    Test.assert_contains(result.errors[0], "operator")
    
    Note: Verify partial AST is still created for recovery
    Test.assert_not_null(result.ast_node)
End Process

Process called "test_memory_management_integration" returns Nothing:
    @Performance_Hints
    Tests memory management across parsing components.
    @End Performance_Hints
    
    Let initial_memory be get_memory_usage()
    
    Note: Parse many programs and ensure memory is managed properly
    Let i be 0
    While i less than 100:
        Let parser be ParserTests.create_natural_parser()
        Let program be generate_test_program(i)
        Let tokens be ParserTests.tokenize_input(program)
        
        Let result be parser.parse_tokens(tokens)
        
        Note: Clean up AST
        If result.ast_node not equals null:
            AST.destroy_ast(result.ast_node)
        End If
        
        Set i to i plus 1
    End While
    
    Let final_memory be get_memory_usage()
    Let memory_growth be final_memory minus initial_memory
    
    Note: Memory growth should be minimal
    Test.assert_less_than(memory_growth, 1048576)  Note: Less than 1MB
End Process

Note: =====================================================================
Note: REPORTING AND UTILITIES
Note: =====================================================================

Process called "generate_parsing_test_report" that takes total as Integer, passed as Integer, failed as Integer, skipped as Integer, total_time as Integer, parser_time as Integer, ast_time as Integer, expr_time as Integer, integration_time as Integer returns Nothing:
    @Performance_Hints
    Generates comprehensive test report.
    @End Performance_Hints
    
    Test.log_info("=")
    Test.log_info("FRONTEND PARSING MODULE TEST REPORT")
    Test.log_info("=")
    Test.log_info("")
    
    Note: Overall statistics
    Test.log_info("OVERALL RESULTS:")
    Test.log_info("Total Tests: " + integer_to_string(total))
    Test.log_info("Passed: " + integer_to_string(passed))
    Test.log_info("Failed: " + integer_to_string(failed))
    Test.log_info("Skipped: " + integer_to_string(skipped))
    
    Let success_rate be (passed as Float) divided by (total as Float) multiplied by 100.0
    Test.log_info("Success Rate: " + float_to_string(success_rate, 2) + "%")
    Test.log_info("")
    
    Note: Timing breakdown
    Test.log_info("TIMING BREAKDOWN:")
    Test.log_info("Total Execution Time: " + integer_to_string(total_time) + "ms")
    Test.log_info("Parser Tests: " + integer_to_string(parser_time) + "ms")
    Test.log_info("AST Tests: " + integer_to_string(ast_time) + "ms")
    Test.log_info("Expression Tests: " + integer_to_string(expr_time) + "ms")
    Test.log_info("Integration Tests: " + integer_to_string(integration_time) + "ms")
    Test.log_info("")
    
    Note: Performance analysis
    Test.log_info("PERFORMANCE ANALYSIS:")
    Let avg_test_time be total_time divided by total
    Test.log_info("Average Test Time: " + integer_to_string(avg_test_time) + "ms")
    
    If avg_test_time greater than 100:
        Test.log_warning("Some tests are running slowly (>100ms average)")
    Otherwise:
        Test.log_info("Test execution time is acceptable")
    End If
    
    Test.log_info("")
    
    Note: Final status
    If failed greater than 0:
        Test.log_error("TEST SUITE FAILED - " + integer_to_string(failed) + " test(s) failed")
    Otherwise:
        Test.log_success("ALL TESTS PASSED - Parsing module is healthy")
    End If
    
    Test.log_info("=")
End Process

Process called "generate_test_program" that takes seed as Integer returns String:
    @Performance_Hints
    Generates test program for memory testing.
    @End Performance_Hints
    
    Let sb be Internals.create_string_builder()
    
    Internals.string_builder_append(sb, "Let var")
    Internals.string_builder_append(sb, integer_to_string(seed))
    Internals.string_builder_append(sb, " be ")
    Internals.string_builder_append(sb, integer_to_string(seed multiplied by 2))
    Internals.string_builder_append(sb, " plus ")
    Internals.string_builder_append(sb, integer_to_string(seed plus 1))
    
    Return Internals.string_builder_to_string(sb)
End Process

Process called "get_timestamp_ms" returns Integer:
    @Performance_Hints
    Gets current timestamp in milliseconds.
    @End Performance_Hints
    
    Let seconds as Integer
    Let nanoseconds as Integer
    
    Inline Assembly:
        "mov rax, 228\n"
        "mov rdi, 1\n"
        "lea rsi, [rsp-16]\n"
        "syscall\n"
        "mov %0, [rsi]\n"
        "mov %1, [rsi+8]\n"
        : "=r"(seconds), "=r"(nanoseconds)
        :
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Return seconds multiplied by 1000 plus (nanoseconds divided by 1000000)
End Process

Process called "get_memory_usage" returns Integer:
    @Performance_Hints
    Gets current memory usage in bytes.
    @End Performance_Hints
    
    Let rusage_struct be Internals.allocate_raw_memory(144)
    
    Inline Assembly:
        "mov rax, 98\n"
        "mov rdi, 0\n"
        "mov rsi, %0\n"
        "syscall\n"
        :
        : "r"(rusage_struct)
        : "rax", "rdi", "rsi", "rcx", "r11", "memory"
    End Assembly
    
    Let memory_kb be Internals.read_integer_at(rusage_struct, 32)
    Internals.free_raw_memory(rusage_struct, 144)
    
    Return memory_kb multiplied by 1024
End Process

Process called "integer_to_string" that takes value as Integer returns String:
    @Performance_Hints
    Converts integer to string.
    @End Performance_Hints
    
    If value equals 0:
        Return "0"
    End If
    
    Let is_negative be value less than 0
    Let num be value
    If is_negative:
        Set num to 0 minus value
    End If
    
    Let sb be Internals.create_string_builder()
    Let digits be Internals.create_internal_array(20)
    Let digit_count be 0
    
    While num greater than 0:
        Let digit be num modulo 10
        Internals.internal_array_add(digits, digit)
        Set digit_count to digit_count plus 1
        Set num to num divided by 10
    End While
    
    If is_negative:
        Internals.string_builder_append(sb, "-")
    End If
    
    Let i be digit_count minus 1
    While i greater than or equal to 0:
        Let digit be Internals.internal_array_get(digits, i)
        Let digit_char be character_from_code(digit plus 48)
        Internals.string_builder_append(sb, digit_char)
        Set i to i minus 1
    End While
    
    Return Internals.string_builder_to_string(sb)
End Process

Process called "float_to_string" that takes value as Float, decimals as Integer returns String:
    @Performance_Hints
    Converts float to string with specified decimal places.
    @End Performance_Hints
    
    Let multiplier be 1
    Let i be 0
    While i less than decimals:
        Set multiplier to multiplier multiplied by 10
        Set i to i plus 1
    End While
    
    Let scaled be value multiplied by (multiplier as Float)
    Let rounded be scaled as Integer
    
    Let integer_part be rounded divided by multiplier
    Let decimal_part be rounded modulo multiplier
    
    Let result be integer_to_string(integer_part)
    
    If decimals greater than 0:
        Set result to result + "."
        
        Let decimal_str be integer_to_string(decimal_part)
        
        Note: Pad with leading zeros if needed
        Let padding_needed be decimals minus StringPrim.length(decimal_str)
        While padding_needed greater than 0:
            Set result to result + "0"
            Set padding_needed to padding_needed minus 1
        End While
        
        Set result to result + decimal_str
    End If
    
    Return result
End Process

Process called "character_from_code" that takes code as Integer returns String:
    @Performance_Hints
    Creates single-character string from ASCII code.
    @End Performance_Hints
    
    Let buffer be Internals.allocate_raw_memory(2)
    Internals.write_byte_at(buffer, 0, code)
    Internals.write_byte_at(buffer, 1, 0)
    
    Let str be Internals.ptr_to_string(buffer)
    Internals.free_raw_memory(buffer, 2)
    Return str
End Process

@Security_Scope
These integration tests verify critical security aspects across parsing components:
- Memory safety during AST construction and destruction
- Input validation to prevent parser state corruption
- Error handling that doesn't leak sensitive information
- Resource cleanup to prevent memory exhaustion attacks
- Thread safety in concurrent parsing operations
- Bounds checking in token and AST traversal
@End Security_Scope