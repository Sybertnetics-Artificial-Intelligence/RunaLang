Note:
test_string_primitive.runa - Comprehensive Tests for String Primitive Operations

This test suite validates all string manipulation functions in the string_primitive
module, ensuring correct behavior for length calculation, comparison, copying,
and memory management operations.

@Reasoning
String primitives are foundational to the compiler's operation, used for symbol
processing, file path manipulation, and syscall interfaces. Complete testing
ensures reliability of core compiler infrastructure.
@End Reasoning

@TestCases
- String length calculation with various encodings
- String comparison with edge cases and null terminators
- String copying with memory boundary validation
- Concatenation operations with buffer management
- Substring operations with bound checking
- Memory safety validation for all operations
@End TestCases

Note: =====================================================================
Note: STRING LENGTH CALCULATION TESTS
Note: =====================================================================

Process called "test_calculate_string_length":
    @Implementation
    Tests the calculate_string_length function with various string types
    including empty strings, single characters, and multi-byte sequences.
    Validates correct handling of null terminators and memory boundaries.
    @End Implementation
    
    Note: Test empty string
    Let empty_string be create_null_terminated_string("")
    Let empty_length be calculate_string_length(empty_string)
    If empty_length not_equals 0:
        Return false
    End If
    
    Note: Test single character string
    Let single_char be create_null_terminated_string("A")
    Let single_length be calculate_string_length(single_char)
    If single_length not_equals 1:
        Return false
    End If
    
    Note: Test multi-character string
    Let multi_char be create_null_terminated_string("Hello")
    Let multi_length be calculate_string_length(multi_char)
    If multi_length not_equals 5:
        Return false
    End If
    
    Note: Test string with special characters
    Let special_string be create_null_terminated_string("Test\t\n\r")
    Let special_length be calculate_string_length(special_string)
    If special_length not_equals 7:
        Return false
    End If
    
    Note: Test maximum length string (boundary condition)
    Let max_string be create_string_of_length(4095)
    Let max_length be calculate_string_length(max_string)
    If max_length not_equals 4095:
        Return false
    End If
    
    Return true
End Process

Process called "test_compare_strings":
    @Implementation
    Tests string comparison functionality including lexicographic ordering,
    case sensitivity, and special character handling. Validates all comparison
    outcomes: equal, less than, and greater than.
    @End Implementation
    
    Note: Test identical strings
    Let str1 be create_null_terminated_string("Hello")
    Let str2 be create_null_terminated_string("Hello")
    Let equal_result be compare_strings(str1, str2)
    If equal_result not_equals 0:
        Return false
    End If
    
    Note: Test lexicographically smaller string
    Let small_str be create_null_terminated_string("Apple")
    Let large_str be create_null_terminated_string("Banana")
    Let less_result be compare_strings(small_str, large_str)
    If less_result greater_than_or_equal_to 0:
        Return false
    End If
    
    Note: Test lexicographically larger string
    Let greater_result be compare_strings(large_str, small_str)
    If greater_result less_than_or_equal_to 0:
        Return false
    End If
    
    Note: Test different length strings with common prefix
    Let short_str be create_null_terminated_string("Test")
    Let long_str be create_null_terminated_string("Testing")
    Let prefix_result be compare_strings(short_str, long_str)
    If prefix_result greater_than_or_equal_to 0:
        Return false
    End If
    
    Note: Test empty string comparisons
    Let empty1 be create_null_terminated_string("")
    Let empty2 be create_null_terminated_string("")
    Let empty_result be compare_strings(empty1, empty2)
    If empty_result not_equals 0:
        Return false
    End If
    
    Let non_empty be create_null_terminated_string("A")
    Let empty_vs_non_empty be compare_strings(empty1, non_empty)
    If empty_vs_non_empty greater_than_or_equal_to 0:
        Return false
    End If
    
    Return true
End Process

Process called "test_copy_string":
    @Implementation
    Tests string copying operations including boundary conditions, memory
    safety, and proper null termination. Validates both successful copies
    and error conditions when buffers are insufficient.
    @End Implementation
    
    Note: Test normal string copy
    Let source be create_null_terminated_string("Hello World")
    Let dest_buffer be allocate_buffer(20)
    Let copy_result be copy_string(source, dest_buffer, 20)
    If not copy_result:
        Return false
    End If
    
    Note: Verify copied string matches original
    Let copied_length be calculate_string_length(dest_buffer)
    Let original_length be calculate_string_length(source)
    If copied_length not_equals original_length:
        Return false
    End If
    
    Let comparison be compare_strings(source, dest_buffer)
    If comparison not_equals 0:
        Return false
    End If
    
    Note: Test copy with exact buffer size
    Let exact_source be create_null_terminated_string("Test")
    Let exact_buffer be allocate_buffer(5) 
    Let exact_result be copy_string(exact_source, exact_buffer, 5)
    If not exact_result:
        Return false
    End If
    
    Note: Test copy with insufficient buffer (should fail)
    Let small_buffer be allocate_buffer(3)
    Let fail_result be copy_string(source, small_buffer, 3)
    If fail_result:
        Return false  Note: Copy should fail with insufficient space
    End If
    
    Note: Test empty string copy
    Let empty_source be create_null_terminated_string("")
    Let empty_dest be allocate_buffer(10)
    Let empty_copy_result be copy_string(empty_source, empty_dest, 10)
    If not empty_copy_result:
        Return false
    End If
    
    Let empty_copied_length be calculate_string_length(empty_dest)
    If empty_copied_length not_equals 0:
        Return false
    End If
    
    Return true
End Process

Note: =====================================================================
Note: STRING CONCATENATION TESTS
Note: =====================================================================

Process called "test_concatenate_strings":
    @Implementation
    Tests string concatenation operations with various combinations of
    string lengths, buffer sizes, and edge cases. Validates proper
    null termination and memory boundary handling.
    @End Implementation
    
    Note: Test normal concatenation
    Let str1 be create_null_terminated_string("Hello")
    Let str2 be create_null_terminated_string(" World")
    Let concat_buffer be allocate_buffer(20)
    Let concat_result be concatenate_strings(str1, str2, concat_buffer, 20)
    If not concat_result:
        Return false
    End If
    
    Note: Verify concatenated result
    Let expected be create_null_terminated_string("Hello World")
    Let concat_comparison be compare_strings(concat_buffer, expected)
    If concat_comparison not_equals 0:
        Return false
    End If
    
    Note: Test concatenation with empty strings
    Let empty1 be create_null_terminated_string("")
    Let non_empty be create_null_terminated_string("Test")
    Let empty_concat_buffer be allocate_buffer(10)
    Let empty_concat_result be concatenate_strings(empty1, non_empty, empty_concat_buffer, 10)
    If not empty_concat_result:
        Return false
    End If
    
    Let empty_comparison be compare_strings(empty_concat_buffer, non_empty)
    If empty_comparison not_equals 0:
        Return false
    End If
    
    Note: Test concatenation with insufficient buffer
    Let long1 be create_null_terminated_string("VeryLongString")
    Let long2 be create_null_terminated_string("AnotherVeryLongString")
    Let small_concat_buffer be allocate_buffer(10)
    Let overflow_result be concatenate_strings(long1, long2, small_concat_buffer, 10)
    If overflow_result:
        Return false  Note: Should fail due to insufficient buffer space
    End If
    
    Return true
End Process

Note: =====================================================================
Note: SUBSTRING AND SEARCH TESTS
Note: =====================================================================

Process called "test_extract_substring":
    @Implementation
    Tests substring extraction with various start positions, lengths,
    and boundary conditions. Validates correct handling of out-of-bounds
    requests and proper null termination of extracted substrings.
    @End Implementation
    
    Note: Test normal substring extraction
    Let source be create_null_terminated_string("Hello World")
    Let substring_buffer be allocate_buffer(10)
    Let substring_result be extract_substring(source, 6, 5, substring_buffer, 10)
    If not substring_result:
        Return false
    End If
    
    Note: Verify extracted substring
    Let expected_substring be create_null_terminated_string("World")
    Let substring_comparison be compare_strings(substring_buffer, expected_substring)
    If substring_comparison not_equals 0:
        Return false
    End If
    
    Note: Test substring from beginning
    Let beginning_buffer be allocate_buffer(10)
    Let beginning_result be extract_substring(source, 0, 5, beginning_buffer, 10)
    If not beginning_result:
        Return false
    End If
    
    Let expected_beginning be create_null_terminated_string("Hello")
    Let beginning_comparison be compare_strings(beginning_buffer, expected_beginning)
    If beginning_comparison not_equals 0:
        Return false
    End If
    
    Note: Test substring extending beyond string end
    Let overflow_buffer be allocate_buffer(20)
    Let overflow_result be extract_substring(source, 8, 10, overflow_buffer, 20)
    If not overflow_result:
        Return false
    End If
    
    Note: Should extract only available characters
    Let expected_overflow be create_null_terminated_string("rld")
    Let overflow_comparison be compare_strings(overflow_buffer, expected_overflow)
    If overflow_comparison not_equals 0:
        Return false
    End If
    
    Note: Test invalid start position (beyond string)
    Let invalid_buffer be allocate_buffer(10)
    Let invalid_result be extract_substring(source, 50, 5, invalid_buffer, 10)
    If invalid_result:
        Return false  Note: Should fail for invalid start position
    End If
    
    Return true
End Process

Note: =====================================================================
Note: STRING SEARCH AND PATTERN MATCHING TESTS
Note: =====================================================================

Process called "test_find_substring":
    @Implementation
    Tests substring search functionality including pattern matching,
    case sensitivity, and handling of overlapping patterns. Validates
    correct position reporting and not-found conditions.
    @End Implementation
    
    Note: Test finding existing substring
    Let haystack be create_null_terminated_string("The quick brown fox")
    Let needle be create_null_terminated_string("quick")
    Let found_position be find_substring(haystack, needle)
    If found_position not_equals 4:
        Return false
    End If
    
    Note: Test finding substring at beginning
    Let beginning_needle be create_null_terminated_string("The")
    Let beginning_position be find_substring(haystack, beginning_needle)
    If beginning_position not_equals 0:
        Return false
    End If
    
    Note: Test finding substring at end
    Let end_needle be create_null_terminated_string("fox")
    Let end_position be find_substring(haystack, end_needle)
    If end_position not_equals 16:
        Return false
    End If
    
    Note: Test substring not found
    Let missing_needle be create_null_terminated_string("elephant")
    Let not_found_position be find_substring(haystack, missing_needle)
    If not_found_position not_equals -1:
        Return false
    End If
    
    Note: Test finding empty string (should return 0)
    Let empty_needle be create_null_terminated_string("")
    Let empty_position be find_substring(haystack, empty_needle)
    If empty_position not_equals 0:
        Return false
    End If
    
    Note: Test overlapping patterns
    Let overlap_haystack be create_null_terminated_string("aaaaa")
    Let overlap_needle be create_null_terminated_string("aa")
    Let overlap_position be find_substring(overlap_haystack, overlap_needle)
    If overlap_position not_equals 0:  Note: Should find first occurrence
        Return false
    End If
    
    Return true
End Process

Note: =====================================================================
Note: MEMORY SAFETY AND BOUNDARY TESTS
Note: =====================================================================

Process called "test_string_memory_safety":
    @Implementation
    Tests memory safety aspects of string operations including null pointer
    handling, buffer overflow protection, and proper cleanup. Validates
    that all string functions properly handle edge cases without crashes.
    @End Implementation
    
    Note: Test null pointer handling
    Let null_ptr be 0
    Let safe_length be calculate_string_length_safe(null_ptr)
    If safe_length not_equals -1:
        Return false  Note: Should return error for null pointer
    End If
    
    Note: Test zero-length buffer handling
    Let test_string be create_null_terminated_string("Test")
    Let zero_buffer be allocate_buffer(0)
    Let zero_copy_result be copy_string_safe(test_string, zero_buffer, 0)
    If zero_copy_result:
        Return false  Note: Should fail with zero-length buffer
    End If
    
    Note: Test maximum string length boundary
    Let max_test_length be 4096
    Let max_string be create_string_of_length(max_test_length)
    Let computed_max_length be calculate_string_length(max_string)
    If computed_max_length not_equals max_test_length:
        Return false
    End If
    
    Note: Test string operations with special characters
    Let special_chars be create_null_terminated_string("Special: \0\t\n\r\"'\\")
    Let special_length be calculate_string_length(special_chars)
    If special_length less_than 8:  Note: Should handle embedded nulls properly
        Return false
    End If
    
    Return true
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS FOR TEST SETUP
Note: =====================================================================

Process called "create_null_terminated_string" that takes content as String returns Pointer:
    @Implementation
    Creates a properly null-terminated string in memory for testing purposes.
    Allocates sufficient space and ensures proper termination.
    @End Implementation
    
    Let content_length be content.length()
    Let buffer_size be content_length + 1  Note: +1 for null terminator
    Let buffer be allocate_buffer(buffer_size)
    
    Let i be 0
    While i < content_length:
        Let char_value be content.get_char_at(i)
        store_byte_to_pointer(add_pointer_offset(buffer, i), char_value)
        Set i to i + 1
    End While
    
    Note: Add null terminator
    store_byte_to_pointer(add_pointer_offset(buffer, content_length), 0)
    
    Return buffer
End Process

Process called "create_string_of_length" that takes length as Integer returns Pointer:
    @Implementation
    Creates a test string of specified length filled with 'A' characters.
    Used for boundary testing and performance validation.
    @End Implementation
    
    Let buffer be allocate_buffer(length + 1)
    
    Let i be 0
    While i < length:
        store_byte_to_pointer(add_pointer_offset(buffer, i), 65)  Note: ASCII 'A'
        Set i to i + 1
    End While
    
    Note: Add null terminator
    store_byte_to_pointer(add_pointer_offset(buffer, length), 0)
    
    Return buffer
End Process

Process called "allocate_buffer" that takes size as Integer returns Pointer:
    @Implementation
    Allocates a memory buffer for testing purposes. Uses system allocation
    with proper error handling and initialization to zero.
    @End Implementation
    
    If size less_than_or_equal_to 0:
        Return 0
    End If
    
    Let buffer be system_allocate_memory(size)
    If buffer equals 0:
        Return 0  Note: Allocation failed
    End If
    
    Note: Initialize buffer to zero
    Let i be 0
    While i < size:
        store_byte_to_pointer(add_pointer_offset(buffer, i), 0)
        Set i to i + 1
    End While
    
    Return buffer
End Process

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_string_primitive_tests" returns Boolean:
    @Implementation
    Executes all string primitive tests and reports results. Returns true
    if all tests pass, false if any test fails. Provides detailed logging
    of test outcomes for debugging purposes.
    @End Implementation
    
    Let all_tests_passed be true
    
    Note: Run length calculation tests
    If not test_calculate_string_length():
        Set all_tests_passed to false
        log_test_failure("test_calculate_string_length")
    End If
    
    Note: Run string comparison tests
    If not test_compare_strings():
        Set all_tests_passed to false
        log_test_failure("test_compare_strings")
    End If
    
    Note: Run string copying tests
    If not test_copy_string():
        Set all_tests_passed to false
        log_test_failure("test_copy_string")
    End If
    
    Note: Run concatenation tests
    If not test_concatenate_strings():
        Set all_tests_passed to false
        log_test_failure("test_concatenate_strings")
    End If
    
    Note: Run substring tests
    If not test_extract_substring():
        Set all_tests_passed to false
        log_test_failure("test_extract_substring")
    End If
    
    Note: Run search tests
    If not test_find_substring():
        Set all_tests_passed to false
        log_test_failure("test_find_substring")
    End If
    
    Note: Run memory safety tests
    If not test_string_memory_safety():
        Set all_tests_passed to false
        log_test_failure("test_string_memory_safety")
    End If
    
    If all_tests_passed:
        log_test_success("All string primitive tests passed")
    Otherwise:
        log_test_failure("Some string primitive tests failed")
    End If
    
    Return all_tests_passed
End Process

Process called "log_test_failure" that takes test_name as String returns Nothing:
    @Implementation
    Logs test failure information for debugging and reporting purposes.
    @End Implementation
    
    Let failure_message be "FAILED: " joined with test_name
    output_test_result(failure_message)
End Process

Process called "log_test_success" that takes message as String returns Nothing:
    @Implementation
    Logs successful test completion for reporting purposes.
    @End Implementation
    
    Let success_message be "SUCCESS: " joined with message
    output_test_result(success_message)
End Process

Process called "output_test_result" that takes message as String returns Nothing:
    @Implementation
    Outputs test results to the console or test log system.
    @End Implementation
    
    Note: This would interface with the test framework's output system
    system_write_string(message)
    system_write_string("\n")
End Process