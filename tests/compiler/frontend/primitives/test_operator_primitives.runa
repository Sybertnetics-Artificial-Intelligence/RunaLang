Note:
test_operator_primitives.runa - Comprehensive Tests for Operator Primitive Operations

This test suite validates logical and bitwise operator primitives including
boolean operations, bit manipulation, comparison operations, and proper
handling of various data types and edge cases.

@Reasoning
Operator primitives form the foundation of expression evaluation in the compiler.
Testing ensures correct implementation of logical operations, bitwise manipulation,
and proper type handling across different integer sizes and boolean values.
@End Reasoning

@TestCases
- Logical operations (AND, OR, NOT, XOR) with boolean and integer types
- Bitwise operations (shift, rotate, mask) with various integer sizes
- Comparison operations and equality testing
- Short-circuit evaluation for logical operators
- Edge cases and boundary condition handling
- Type conversion and promotion validation
@End TestCases

Note: =====================================================================
Note: LOGICAL OPERATOR TESTS
Note: =====================================================================

Process called "test_logical_and_operations":
    @Implementation
    Tests logical AND operations including boolean AND, bitwise AND,
    short-circuit evaluation, and proper handling of different operand types.
    @End Implementation
    
    Note: Test boolean AND operations
    Let true_and_true be logical_and(true, true)
    If not true_and_true:
        Return false  Note: true AND true should be true
    End If
    
    Let true_and_false be logical_and(true, false)
    If true_and_false:
        Return false  Note: true AND false should be false
    End If
    
    Let false_and_true be logical_and(false, true)
    If false_and_true:
        Return false  Note: false AND true should be false
    End If
    
    Let false_and_false be logical_and(false, false)
    If false_and_false:
        Return false  Note: false AND false should be false
    End If
    
    Note: Test integer AND operations (non-zero = true, zero = false)
    Let nonzero_and_nonzero be logical_and_integer(42, 17)
    If not nonzero_and_nonzero:
        Return false  Note: Non-zero AND non-zero should be true
    End If
    
    Let nonzero_and_zero be logical_and_integer(42, 0)
    If nonzero_and_zero:
        Return false  Note: Non-zero AND zero should be false
    End If
    
    Let zero_and_nonzero be logical_and_integer(0, 17)
    If zero_and_nonzero:
        Return false  Note: Zero AND non-zero should be false
    End If
    
    Note: Test bitwise AND operations
    Let bitwise_result1 be bitwise_and(0xFF, 0x0F)
    If bitwise_result1 not_equals 0x0F:
        Return false  Note: 0xFF & 0x0F should equal 0x0F
    End If
    
    Let bitwise_result2 be bitwise_and(0xAAAA, 0x5555)
    If bitwise_result2 not_equals 0:
        Return false  Note: Alternating patterns should result in 0
    End If
    
    Note: Test short-circuit evaluation
    Let short_circuit_result be test_and_short_circuit()
    If not short_circuit_result:
        Return false  Note: Short-circuit AND should work correctly
    End If
    
    Return true
End Process

Process called "test_logical_or_operations":
    @Implementation
    Tests logical OR operations including boolean OR, bitwise OR,
    short-circuit evaluation, and proper handling of different operand types.
    @End Implementation
    
    Note: Test boolean OR operations
    Let true_or_true be logical_or(true, true)
    If not true_or_true:
        Return false  Note: true OR true should be true
    End If
    
    Let true_or_false be logical_or(true, false)
    If not true_or_false:
        Return false  Note: true OR false should be true
    End If
    
    Let false_or_true be logical_or(false, true)
    If not false_or_true:
        Return false  Note: false OR true should be true
    End If
    
    Let false_or_false be logical_or(false, false)
    If false_or_false:
        Return false  Note: false OR false should be false
    End If
    
    Note: Test integer OR operations
    Let nonzero_or_zero be logical_or_integer(42, 0)
    If not nonzero_or_zero:
        Return false  Note: Non-zero OR zero should be true
    End If
    
    Let zero_or_zero be logical_or_integer(0, 0)
    If zero_or_zero:
        Return false  Note: Zero OR zero should be false
    End If
    
    Note: Test bitwise OR operations
    Let bitwise_or_result1 be bitwise_or(0x0F, 0xF0)
    If bitwise_or_result1 not_equals 0xFF:
        Return false  Note: 0x0F | 0xF0 should equal 0xFF
    End If
    
    Let bitwise_or_result2 be bitwise_or(0x5555, 0xAAAA)
    If bitwise_or_result2 not_equals 0xFFFF:
        Return false  Note: Complementary patterns should result in all 1s
    End If
    
    Note: Test short-circuit evaluation
    Let short_circuit_or_result be test_or_short_circuit()
    If not short_circuit_or_result:
        Return false  Note: Short-circuit OR should work correctly
    End If
    
    Return true
End Process

Process called "test_logical_not_operations":
    @Implementation
    Tests logical NOT operations including boolean negation, bitwise NOT,
    and proper handling of integer values as boolean expressions.
    @End Implementation
    
    Note: Test boolean NOT operations
    Let not_true be logical_not(true)
    If not_true:
        Return false  Note: NOT true should be false
    End If
    
    Let not_false be logical_not(false)
    If not not_false:
        Return false  Note: NOT false should be true
    End If
    
    Note: Test integer NOT operations (logical negation)
    Let not_nonzero be logical_not_integer(42)
    If not_nonzero:
        Return false  Note: NOT non-zero should be false
    End If
    
    Let not_zero be logical_not_integer(0)
    If not not_zero:
        Return false  Note: NOT zero should be true
    End If
    
    Note: Test bitwise NOT operations
    Let bitwise_not_result1 be bitwise_not(0x0F)
    Let expected_not1 be 0xFFFFFFF0  Note: Assuming 32-bit
    If (bitwise_not_result1 & 0xFFFFFFFF) not_equals expected_not1:
        Return false  Note: Bitwise NOT should invert all bits
    End If
    
    Let bitwise_not_result2 be bitwise_not(0)
    If (bitwise_not_result2 & 0xFFFFFFFF) not_equals 0xFFFFFFFF:
        Return false  Note: NOT 0 should be all 1s
    End If
    
    Note: Test double negation
    Let double_not be logical_not(logical_not(true))
    If not double_not:
        Return false  Note: NOT NOT true should be true
    End If
    
    Return true
End Process

Process called "test_logical_xor_operations":
    @Implementation
    Tests logical XOR operations including boolean XOR, bitwise XOR,
    and validation of exclusive-or properties and edge cases.
    @End Implementation
    
    Note: Test boolean XOR operations
    Let true_xor_true be logical_xor(true, true)
    If true_xor_true:
        Return false  Note: true XOR true should be false
    End If
    
    Let true_xor_false be logical_xor(true, false)
    If not true_xor_false:
        Return false  Note: true XOR false should be true
    End If
    
    Let false_xor_true be logical_xor(false, true)
    If not false_xor_true:
        Return false  Note: false XOR true should be true
    End If
    
    Let false_xor_false be logical_xor(false, false)
    If false_xor_false:
        Return false  Note: false XOR false should be false
    End If
    
    Note: Test bitwise XOR operations
    Let xor_result1 be bitwise_xor(0xFF, 0x0F)
    If xor_result1 not_equals 0xF0:
        Return false  Note: 0xFF ^ 0x0F should equal 0xF0
    End If
    
    Let xor_result2 be bitwise_xor(0x5555, 0xAAAA)
    If xor_result2 not_equals 0xFFFF:
        Return false  Note: Complementary patterns XOR to all 1s
    End If
    
    Note: Test XOR self-cancellation property
    Let self_xor be bitwise_xor(0x1234, 0x1234)
    If self_xor not_equals 0:
        Return false  Note: A XOR A should equal 0
    End If
    
    Note: Test XOR commutativity
    Let xor_ab be bitwise_xor(0xABCD, 0x1234)
    Let xor_ba be bitwise_xor(0x1234, 0xABCD)
    If xor_ab not_equals xor_ba:
        Return false  Note: XOR should be commutative
    End If
    
    Return true
End Process

Note: =====================================================================
Note: BITWISE OPERATOR TESTS
Note: =====================================================================

Process called "test_bitwise_shift_operations":
    @Implementation
    Tests bitwise shift operations including left shift, right shift,
    arithmetic vs logical shifts, and proper handling of shift counts.
    @End Implementation
    
    Note: Test left shift operations
    Let left_shift_1 be bitwise_left_shift(0x01, 1)
    If left_shift_1 not_equals 0x02:
        Return false  Note: 1 << 1 should equal 2
    End If
    
    Let left_shift_4 be bitwise_left_shift(0x01, 4)
    If left_shift_4 not_equals 0x10:
        Return false  Note: 1 << 4 should equal 16
    End If
    
    Let left_shift_byte be bitwise_left_shift(0xFF, 8)
    If left_shift_byte not_equals 0xFF00:
        Return false  Note: 0xFF << 8 should equal 0xFF00
    End If
    
    Note: Test right shift operations (logical)
    Let right_shift_logical_1 be bitwise_right_shift_logical(0x02, 1)
    If right_shift_logical_1 not_equals 0x01:
        Return false  Note: 2 >> 1 should equal 1
    End If
    
    Let right_shift_logical_4 be bitwise_right_shift_logical(0x10, 4)
    If right_shift_logical_4 not_equals 0x01:
        Return false  Note: 16 >> 4 should equal 1
    End If
    
    Let right_shift_byte be bitwise_right_shift_logical(0xFF00, 8)
    If right_shift_byte not_equals 0xFF:
        Return false  Note: 0xFF00 >> 8 should equal 0xFF
    End If
    
    Note: Test arithmetic right shift (sign extension)
    Let negative_value be 0x80000000  Note: Negative in 32-bit signed
    Let arith_shift be bitwise_right_shift_arithmetic(negative_value, 1)
    If arith_shift not_equals 0xC0000000:
        Return false  Note: Should sign-extend negative values
    End If
    
    Let positive_arith be bitwise_right_shift_arithmetic(0x40000000, 1)
    If positive_arith not_equals 0x20000000:
        Return false  Note: Should not sign-extend positive values
    End If
    
    Note: Test shift by zero (no change)
    Let shift_zero be bitwise_left_shift(0x1234, 0)
    If shift_zero not_equals 0x1234:
        Return false  Note: Shift by 0 should not change value
    End If
    
    Note: Test excessive shift counts
    Let excessive_shift be bitwise_left_shift(0x01, 32)
    If excessive_shift not_equals 0:
        Return false  Note: Shift by word size should result in 0
    End If
    
    Return true
End Process

Process called "test_bitwise_rotate_operations":
    @Implementation
    Tests bitwise rotate operations including left rotate, right rotate,
    and validation that bits wrap around correctly without loss.
    @End Implementation
    
    Note: Test left rotate operations
    Let rotate_left_1 be bitwise_rotate_left(0x80000001, 1)  Note: 32-bit value
    If rotate_left_1 not_equals 0x00000003:
        Return false  Note: High bit should wrap to low bit
    End If
    
    Let rotate_left_4 be bitwise_rotate_left(0xF0000000, 4)
    If rotate_left_4 not_equals 0x0000000F:
        Return false  Note: High nibble should rotate to low nibble
    End If
    
    Note: Test right rotate operations
    Let rotate_right_1 be bitwise_rotate_right(0x80000001, 1)  Note: 32-bit value
    If rotate_right_1 not_equals 0xC0000000:
        Return false  Note: Low bit should wrap to high bit
    End If
    
    Let rotate_right_4 be bitwise_rotate_right(0x0000000F, 4)
    If rotate_right_4 not_equals 0xF0000000:
        Return false  Note: Low nibble should rotate to high nibble
    End If
    
    Note: Test rotate by zero (no change)
    Let rotate_zero be bitwise_rotate_left(0x12345678, 0)
    If rotate_zero not_equals 0x12345678:
        Return false  Note: Rotate by 0 should not change value
    End If
    
    Note: Test rotate by full word size (should return original)
    Let rotate_full be bitwise_rotate_left(0x12345678, 32)
    If rotate_full not_equals 0x12345678:
        Return false  Note: Rotate by word size should return original
    End If
    
    Note: Test rotate equivalence (left vs right)
    Let value be 0xABCDEF01
    Let left_rotate be bitwise_rotate_left(value, 8)
    Let right_rotate be bitwise_rotate_right(value, 24)  Note: 32 - 8 = 24
    If left_rotate not_equals right_rotate:
        Return false  Note: Complementary rotations should be equivalent
    End If
    
    Return true
End Process

Process called "test_bitwise_mask_operations":
    @Implementation
    Tests bitwise masking operations including bit setting, clearing,
    testing, and various masking patterns and edge cases.
    @End Implementation
    
    Note: Test bit setting operations
    Let set_bit_0 be set_bit(0x00, 0)
    If set_bit_0 not_equals 0x01:
        Return false  Note: Setting bit 0 should result in 0x01
    End If
    
    Let set_bit_7 be set_bit(0x00, 7)
    If set_bit_7 not_equals 0x80:
        Return false  Note: Setting bit 7 should result in 0x80
    End If
    
    Let set_multiple be set_bit(set_bit(0x00, 0), 7)
    If set_multiple not_equals 0x81:
        Return false  Note: Setting multiple bits should combine
    End If
    
    Note: Test bit clearing operations
    Let clear_bit_0 be clear_bit(0xFF, 0)
    If clear_bit_0 not_equals 0xFE:
        Return false  Note: Clearing bit 0 from all 1s
    End If
    
    Let clear_bit_7 be clear_bit(0xFF, 7)
    If clear_bit_7 not_equals 0x7F:
        Return false  Note: Clearing bit 7 from all 1s
    End If
    
    Note: Test bit testing operations
    Let test_set_bit be test_bit(0x81, 0)
    If not test_set_bit:
        Return false  Note: Bit 0 should be set in 0x81
    End If
    
    Let test_clear_bit be test_bit(0x81, 1)
    If test_clear_bit:
        Return false  Note: Bit 1 should be clear in 0x81
    End If
    
    Note: Test bit toggling operations
    Let toggle_bit_0 be toggle_bit(0x00, 0)
    If toggle_bit_0 not_equals 0x01:
        Return false  Note: Toggling clear bit should set it
    End If
    
    Let toggle_set_bit be toggle_bit(0x01, 0)
    If toggle_set_bit not_equals 0x00:
        Return false  Note: Toggling set bit should clear it
    End If
    
    Note: Test multi-bit mask operations
    Let apply_mask be bitwise_and(0xABCD, 0x00FF)
    If apply_mask not_equals 0x00CD:
        Return false  Note: Lower byte mask should isolate low byte
    End If
    
    Let set_mask be bitwise_or(0x1200, 0x00FF)
    If set_mask not_equals 0x12FF:
        Return false  Note: Setting mask should set specified bits
    End If
    
    Return true
End Process

Note: =====================================================================
Note: COMPARISON OPERATOR TESTS
Note: =====================================================================

Process called "test_equality_operations":
    @Implementation
    Tests equality and inequality operations including exact equality,
    floating-point comparison issues, and type-specific comparisons.
    @End Implementation
    
    Note: Test integer equality
    Let equal_integers be equals_integer(42, 42)
    If not equal_integers:
        Return false  Note: Equal integers should compare as equal
    End If
    
    Let unequal_integers be equals_integer(42, 43)
    If unequal_integers:
        Return false  Note: Different integers should not be equal
    End If
    
    Note: Test boolean equality
    Let equal_booleans_true be equals_boolean(true, true)
    If not equal_booleans_true:
        Return false  Note: true should equal true
    End If
    
    Let equal_booleans_false be equals_boolean(false, false)
    If not equal_booleans_false:
        Return false  Note: false should equal false
    End If
    
    Let unequal_booleans be equals_boolean(true, false)
    If unequal_booleans:
        Return false  Note: true should not equal false
    End If
    
    Note: Test zero comparisons
    Let zero_equals_zero be equals_integer(0, 0)
    If not zero_equals_zero:
        Return false  Note: Zero should equal zero
    End If
    
    Let zero_not_equals_one be equals_integer(0, 1)
    If zero_not_equals_one:
        Return false  Note: Zero should not equal one
    End If
    
    Note: Test negative number equality
    Let negative_equality be equals_integer(-5, -5)
    If not negative_equality:
        Return false  Note: Equal negative numbers should be equal
    End If
    
    Let negative_inequality be equals_integer(-5, 5)
    If negative_inequality:
        Return false  Note: Negative should not equal positive
    End If
    
    Return true
End Process

Process called "test_comparison_operations":
    @Implementation
    Tests relational comparison operations including less than, greater than,
    and proper ordering of various numeric values including edge cases.
    @End Implementation
    
    Note: Test less than operations
    Let five_less_ten be less_than_integer(5, 10)
    If not five_less_ten:
        Return false  Note: 5 should be less than 10
    End If
    
    Let ten_not_less_five be less_than_integer(10, 5)
    If ten_not_less_five:
        Return false  Note: 10 should not be less than 5
    End If
    
    Let equal_not_less be less_than_integer(7, 7)
    If equal_not_less:
        Return false  Note: Equal values should not be less than
    End If
    
    Note: Test greater than operations
    Let ten_greater_five be greater_than_integer(10, 5)
    If not ten_greater_five:
        Return false  Note: 10 should be greater than 5
    End If
    
    Let five_not_greater_ten be greater_than_integer(5, 10)
    If five_not_greater_ten:
        Return false  Note: 5 should not be greater than 10
    End If
    
    Note: Test less than or equal
    Let five_lte_ten be less_than_or_equal_integer(5, 10)
    If not five_lte_ten:
        Return false  Note: 5 should be <= 10
    End If
    
    Let seven_lte_seven be less_than_or_equal_integer(7, 7)
    If not seven_lte_seven:
        Return false  Note: 7 should be <= 7
    End If
    
    Note: Test greater than or equal
    Let ten_gte_five be greater_than_or_equal_integer(10, 5)
    If not ten_gte_five:
        Return false  Note: 10 should be >= 5
    End If
    
    Let seven_gte_seven be greater_than_or_equal_integer(7, 7)
    If not seven_gte_seven:
        Return false  Note: 7 should be >= 7
    End If
    
    Note: Test negative number comparisons
    Let negative_comparison be less_than_integer(-10, -5)
    If not negative_comparison:
        Return false  Note: -10 should be less than -5
    End If
    
    Let negative_positive be less_than_integer(-1, 1)
    If not negative_positive:
        Return false  Note: Negative should be less than positive
    End If
    
    Return true
End Process

Note: =====================================================================
Note: SHORT-CIRCUIT EVALUATION TESTS
Note: =====================================================================

Process called "test_and_short_circuit" returns Boolean:
    @Implementation
    Tests that logical AND operations properly implement short-circuit
    evaluation, avoiding evaluation of the second operand when the first is false.
    @End Implementation
    
    Note: Set up test counters
    reset_evaluation_counter()
    
    Note: Test false AND x (should not evaluate x)
    Let short_circuit_and be logical_and(false, increment_and_return_true())
    
    Let evaluation_count be get_evaluation_counter()
    If evaluation_count not_equals 0:
        Return false  Note: Second operand should not be evaluated
    End If
    
    If short_circuit_and:
        Return false  Note: Result should be false
    End If
    
    Note: Test true AND x (should evaluate x)
    reset_evaluation_counter()
    Let normal_and be logical_and(true, increment_and_return_true())
    
    Let normal_count be get_evaluation_counter()
    If normal_count not_equals 1:
        Return false  Note: Second operand should be evaluated
    End If
    
    If not normal_and:
        Return false  Note: Result should be true
    End If
    
    Return true
End Process

Process called "test_or_short_circuit" returns Boolean:
    @Implementation
    Tests that logical OR operations properly implement short-circuit
    evaluation, avoiding evaluation of the second operand when the first is true.
    @End Implementation
    
    Note: Set up test counters
    reset_evaluation_counter()
    
    Note: Test true OR x (should not evaluate x)
    Let short_circuit_or be logical_or(true, increment_and_return_false())
    
    Let evaluation_count be get_evaluation_counter()
    If evaluation_count not_equals 0:
        Return false  Note: Second operand should not be evaluated
    End If
    
    If not short_circuit_or:
        Return false  Note: Result should be true
    End If
    
    Note: Test false OR x (should evaluate x)
    reset_evaluation_counter()
    Let normal_or be logical_or(false, increment_and_return_false())
    
    Let normal_count be get_evaluation_counter()
    If normal_count not_equals 1:
        Return false  Note: Second operand should be evaluated
    End If
    
    If normal_or:
        Return false  Note: Result should be false
    End If
    
    Return true
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS FOR TESTING
Note: =====================================================================

Process called "increment_and_return_true" returns Boolean:
    @Implementation
    Helper function that increments a counter and returns true.
    Used to test short-circuit evaluation.
    @End Implementation
    
    increment_evaluation_counter()
    Return true
End Process

Process called "increment_and_return_false" returns Boolean:
    @Implementation
    Helper function that increments a counter and returns false.
    Used to test short-circuit evaluation.
    @End Implementation
    
    increment_evaluation_counter()
    Return false
End Process

Let evaluation_counter as Integer is 0

Process called "reset_evaluation_counter" returns Nothing:
    @Implementation
    Resets the evaluation counter for short-circuit testing.
    @End Implementation
    
    Set evaluation_counter to 0
End Process

Process called "increment_evaluation_counter" returns Nothing:
    @Implementation
    Increments the evaluation counter for short-circuit testing.
    @End Implementation
    
    Set evaluation_counter to evaluation_counter + 1
End Process

Process called "get_evaluation_counter" returns Integer:
    @Implementation
    Returns the current evaluation counter value for testing.
    @End Implementation
    
    Return evaluation_counter
End Process

Note: =====================================================================
Note: TEST RUNNER AND REPORTING
Note: =====================================================================

Process called "run_all_operator_primitive_tests" returns Boolean:
    @Implementation
    Executes all operator primitive tests and reports comprehensive results.
    Returns true if all tests pass, false if any test fails.
    @End Implementation
    
    Let all_tests_passed be true
    
    Note: Run logical operator tests
    If not test_logical_and_operations():
        Set all_tests_passed to false
        log_test_failure("test_logical_and_operations")
    End If
    
    If not test_logical_or_operations():
        Set all_tests_passed to false
        log_test_failure("test_logical_or_operations")
    End If
    
    If not test_logical_not_operations():
        Set all_tests_passed to false
        log_test_failure("test_logical_not_operations")
    End If
    
    If not test_logical_xor_operations():
        Set all_tests_passed to false
        log_test_failure("test_logical_xor_operations")
    End If
    
    Note: Run bitwise operator tests
    If not test_bitwise_shift_operations():
        Set all_tests_passed to false
        log_test_failure("test_bitwise_shift_operations")
    End If
    
    If not test_bitwise_rotate_operations():
        Set all_tests_passed to false
        log_test_failure("test_bitwise_rotate_operations")
    End If
    
    If not test_bitwise_mask_operations():
        Set all_tests_passed to false
        log_test_failure("test_bitwise_mask_operations")
    End If
    
    Note: Run comparison operator tests
    If not test_equality_operations():
        Set all_tests_passed to false
        log_test_failure("test_equality_operations")
    End If
    
    If not test_comparison_operations():
        Set all_tests_passed to false
        log_test_failure("test_comparison_operations")
    End If
    
    Note: Run short-circuit evaluation tests
    If not test_and_short_circuit():
        Set all_tests_passed to false
        log_test_failure("test_and_short_circuit")
    End If
    
    If not test_or_short_circuit():
        Set all_tests_passed to false
        log_test_failure("test_or_short_circuit")
    End If
    
    If all_tests_passed:
        log_test_success("All operator primitive tests passed")
    Otherwise:
        log_test_failure("Some operator primitive tests failed")
    End If
    
    Return all_tests_passed
End Process