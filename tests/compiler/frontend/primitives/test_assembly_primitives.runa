Note:
test_assembly_primitives.runa - Comprehensive Tests for Assembly Primitive Operations

This test suite validates assembly operations including syscall handling,
inline assembly validation, instruction parsing, and machine code generation
across different platforms and architectures.

@Reasoning
Assembly primitives provide direct hardware access and system integration.
Testing ensures correct syscall mapping, instruction parsing accuracy,
and proper machine code generation for cross-platform compatibility.
@End Reasoning

@TestCases
- Syscall number mapping and execution validation
- Inline assembly syntax validation and code generation
- Instruction parsing and address resolution
- Machine code emission and encoding validation
- Platform-specific instruction handling
- Error detection and boundary condition testing
@End TestCases

Note: =====================================================================
Note: SYSCALL PRIMITIVE TESTS
Note: =====================================================================

Process called "test_get_syscall_number":
    @Implementation
    Tests syscall number retrieval for various system calls including
    core syscalls like read, write, open, and proper error handling
    for unknown syscalls.
    @End Implementation
    
    Note: Test known syscalls
    Let exit_syscall be get_syscall_number(create_syscall_name("exit"))
    If exit_syscall not_equals 60:  Note: sys_exit on x86_64 Linux
        Return false
    End If
    
    Let read_syscall be get_syscall_number(create_syscall_name("read"))
    If read_syscall not_equals 0:  Note: sys_read on x86_64 Linux
        Return false
    End If
    
    Let write_syscall be get_syscall_number(create_syscall_name("write"))
    If write_syscall not_equals 1:  Note: sys_write on x86_64 Linux
        Return false
    End If
    
    Let open_syscall be get_syscall_number(create_syscall_name("open"))
    If open_syscall not_equals 2:  Note: sys_open on x86_64 Linux
        Return false
    End If
    
    Let close_syscall be get_syscall_number(create_syscall_name("close"))
    If close_syscall not_equals 3:  Note: sys_close on x86_64 Linux
        Return false
    End If
    
    Let mmap_syscall be get_syscall_number(create_syscall_name("mmap"))
    If mmap_syscall not_equals 9:  Note: sys_mmap on x86_64 Linux
        Return false
    End If
    
    Let munmap_syscall be get_syscall_number(create_syscall_name("munmap"))
    If munmap_syscall not_equals 11:  Note: sys_munmap on x86_64 Linux
        Return false
    End If
    
    Note: Test unknown syscall
    Let unknown_syscall be get_syscall_number(create_syscall_name("nonexistent"))
    If unknown_syscall not_equals -1:  Note: Should return -1 for unknown
        Return false
    End If
    
    Note: Test empty syscall name
    Let empty_syscall be get_syscall_number(create_syscall_name(""))
    If empty_syscall not_equals -1:  Note: Should return -1 for empty name
        Return false
    End If
    
    Return true
End Process

Process called "test_make_syscall":
    @Implementation
    Tests syscall execution including parameter passing, return value
    handling, and proper error detection for failed system calls.
    @End Implementation
    
    Note: Test successful syscall (getpid - should always succeed)
    Let getpid_number be 39  Note: sys_getpid on x86_64 Linux
    Let pid_result be make_syscall_linux(getpid_number, 0, 0, 0, 0, 0, 0)
    
    If is_syscall_error(pid_result):
        Return false  Note: getpid should not fail
    End If
    
    Let pid_value be get_syscall_return_value(pid_result)
    If pid_value less_than_or_equal_to 0:
        Return false  Note: PID should be positive
    End If
    
    Note: Test syscall with parameters (write to stdout)
    Let test_message be create_test_string("Test\n")
    Let write_number be 1  Note: sys_write
    Let write_result be make_syscall_linux(
        write_number, 
        1,  Note: stdout fd
        pointer_to_integer(test_message),
        5,  Note: message length
        0, 0, 0
    )
    
    If is_syscall_error(write_result):
        Return false  Note: Write to stdout should succeed
    End If
    
    Let bytes_written be get_syscall_return_value(write_result)
    If bytes_written not_equals 5:
        Return false  Note: Should write exactly 5 bytes
    End If
    
    Note: Test invalid syscall (should fail)
    Let invalid_result be make_syscall_linux(9999, 0, 0, 0, 0, 0, 0)
    If not is_syscall_error(invalid_result):
        Return false  Note: Invalid syscall should fail
    End If
    
    Return true
End Process

Process called "test_syscall_error_handling":
    @Implementation
    Tests syscall error detection and errno extraction including
    various error conditions and proper error code reporting.
    @End Implementation
    
    Note: Test successful syscall (no error)
    Let success_result be create_successful_syscall_result(42)
    If is_syscall_error(success_result):
        Return false  Note: Successful result should not be error
    End If
    
    Let success_errno be get_errno(success_result)
    If success_errno not_equals 0:
        Return false  Note: Successful call should have errno 0
    End If
    
    Note: Test failed syscall with errno
    Let error_result be create_failed_syscall_result(2)  Note: ENOENT
    If not is_syscall_error(error_result):
        Return false  Note: Error result should be detected as error
    End If
    
    Let error_errno be get_errno(error_result)
    If error_errno not_equals 2:
        Return false  Note: Should return correct errno
    End If
    
    Note: Test various common error codes
    Let permission_error be create_failed_syscall_result(13)  Note: EACCES
    Let permission_errno be get_errno(permission_error)
    If permission_errno not_equals 13:
        Return false
    End If
    
    Let not_found_error be create_failed_syscall_result(2)  Note: ENOENT
    Let not_found_errno be get_errno(not_found_error)
    If not_found_errno not_equals 2:
        Return false
    End If
    
    Return true
End Process

Note: =====================================================================
Note: INLINE ASSEMBLY TESTS
Note: =====================================================================

Process called "test_validate_assembly_syntax":
    @Implementation
    Tests inline assembly syntax validation including proper instruction
    format checking, operand validation, and detection of syntax errors.
    @End Implementation
    
    Note: Test valid assembly syntax
    Let valid_asm be "mov %rax, %rbx\nadd $1, %rax\nret"
    Let valid_result be validate_assembly_syntax(create_asm_pointer(valid_asm))
    If not valid_result:
        Return false  Note: Valid assembly should pass validation
    End If
    
    Note: Test assembly with comments
    Let commented_asm be "mov %rax, %rbx  # Move value\nadd $1, %rax    # Increment\nret            # Return"
    Let comment_result be validate_assembly_syntax(create_asm_pointer(commented_asm))
    If not comment_result:
        Return false  Note: Comments should be allowed
    End If
    
    Note: Test assembly with string literals
    Let string_asm be "lea rdi, [rip + \"hello\"]\ncall puts\nret"
    Let string_result be validate_assembly_syntax(create_asm_pointer(string_asm))
    If not string_result:
        Return false  Note: String literals should be handled
    End If
    
    Note: Test empty assembly (should be valid)
    Let empty_asm be ""
    Let empty_result be validate_assembly_syntax(create_asm_pointer(empty_asm))
    If not empty_result:
        Return false  Note: Empty assembly should be valid
    End If
    
    Note: Test assembly with unmatched quotes (should fail)
    Let unmatched_asm be "lea rdi, [rip + \"hello]\nret"
    Let unmatched_result be validate_assembly_syntax(create_asm_pointer(unmatched_asm))
    If unmatched_result:
        Return false  Note: Unmatched quotes should fail validation
    End If
    
    Note: Test assembly with nested quotes
    Let nested_asm be "lea rdi, [rip + \"say \\\"hello\\\"\"]\nret"
    Let nested_result be validate_assembly_syntax(create_asm_pointer(nested_asm))
    If not nested_result:
        Return false  Note: Properly escaped quotes should be valid
    End If
    
    Return true
End Process

Process called "test_parse_assembly_template":
    @Implementation
    Tests assembly template parsing including placeholder substitution,
    constraint handling, and proper template expansion.
    @End Implementation
    
    Note: Test simple template parsing
    Let simple_template be "mov %0, %1"
    Let simple_constraints be create_constraint_array(["=r", "r"])
    Let parsed_simple be parse_assembly_template(simple_template, simple_constraints)
    
    If parsed_simple.equals(""):
        Return false  Note: Parsing should succeed
    End If
    
    Note: Test template with memory operands
    Let memory_template be "mov %0, (%1)\nadd $1, %0\nmov (%1), %0"
    Let memory_constraints be create_constraint_array(["=&r", "r"])
    Let parsed_memory be parse_assembly_template(memory_template, memory_constraints)
    
    If parsed_memory.equals(""):
        Return false  Note: Memory operand parsing should succeed
    End If
    
    Note: Test template with immediate values
    Let immediate_template be "add $%0, %1\nsub $%2, %1"
    Let immediate_constraints be create_constraint_array(["i", "=r", "i"])
    Let parsed_immediate be parse_assembly_template(immediate_template, immediate_constraints)
    
    If parsed_immediate.equals(""):
        Return false  Note: Immediate parsing should succeed
    End If
    
    Note: Test invalid template (mismatched placeholders)
    Let invalid_template be "mov %0, %1\nadd %2, %3"  Note: %2, %3 not in constraints
    Let invalid_constraints be create_constraint_array(["=r", "r"])
    Let parsed_invalid be parse_assembly_template(invalid_template, invalid_constraints)
    
    If not parsed_invalid.equals(""):
        Return false  Note: Invalid template should fail parsing
    End If
    
    Return true
End Process

Process called "test_optimize_assembly_template":
    @Implementation
    Tests assembly template optimization including redundant instruction
    elimination, register allocation optimization, and performance improvements.
    @End Implementation
    
    Note: Test basic optimization (level 1)
    Let basic_template be "mov %rax, %rbx\nmov %rbx, %rax\nnop\nret"
    Let optimized_basic be optimize_assembly_template(basic_template, 1)
    
    Note: Should remove redundant moves and nops
    If optimized_basic.contains("nop"):
        Return false  Note: NOPs should be eliminated
    End If
    
    Note: Test advanced optimization (level 2)
    Let advanced_template be "mov $0, %rax\nadd %rax, %rbx\nret"
    Let optimized_advanced be optimize_assembly_template(advanced_template, 2)
    
    Note: Should optimize addition with zero
    If optimized_advanced.contains("add %rax, %rbx"):
        Return false  Note: Adding zero should be optimized away
    End If
    
    Note: Test no optimization (level 0)
    Let unoptimized_template be "mov %rax, %rbx\nnop\nret"
    Let no_optimization be optimize_assembly_template(unoptimized_template, 0)
    
    If not no_optimization.equals(unoptimized_template):
        Return false  Note: Level 0 should not optimize
    End If
    
    Note: Test optimization preservation of semantics
    Let semantic_template be "mov $42, %rax\nret"
    Let optimized_semantic be optimize_assembly_template(semantic_template, 2)
    
    Note: Should preserve the essential mov instruction
    If not optimized_semantic.contains("mov $42, %rax"):
        Return false  Note: Essential instructions should be preserved
    End If
    
    Return true
End Process

Note: =====================================================================
Note: INSTRUCTION PARSING TESTS
Note: =====================================================================

Process called "test_parse_instruction":
    @Implementation
    Tests instruction parsing including opcode recognition, operand
    parsing, and proper handling of various instruction formats.
    @End Implementation
    
    Note: Test simple register-to-register instruction
    Let reg_instruction be "mov %rax, %rbx"
    Let parsed_reg be parse_instruction(reg_instruction)
    
    Let reg_opcode be get_parsed_opcode(parsed_reg)
    If not reg_opcode.equals("mov"):
        Return false  Note: Should parse opcode correctly
    End If
    
    Let reg_operands be get_parsed_operands(parsed_reg)
    If get_operand_count(reg_operands) not_equals 2:
        Return false  Note: Should have two operands
    End If
    
    Note: Test immediate value instruction
    Let imm_instruction be "add $42, %rax"
    Let parsed_imm be parse_instruction(imm_instruction)
    
    Let imm_opcode be get_parsed_opcode(parsed_imm)
    If not imm_opcode.equals("add"):
        Return false
    End If
    
    Let imm_operands be get_parsed_operands(parsed_imm)
    Let first_operand be get_operand(imm_operands, 0)
    If not is_immediate_operand(first_operand):
        Return false  Note: First operand should be immediate
    End If
    
    Let immediate_value be get_immediate_value(first_operand)
    If immediate_value not_equals 42:
        Return false  Note: Should parse immediate value correctly
    End If
    
    Note: Test memory operand instruction
    Let mem_instruction be "mov (%rax), %rbx"
    Let parsed_mem be parse_instruction(mem_instruction)
    
    Let mem_operands be get_parsed_operands(parsed_mem)
    Let mem_operand be get_operand(mem_operands, 0)
    If not is_memory_operand(mem_operand):
        Return false  Note: Should recognize memory operand
    End If
    
    Note: Test complex addressing mode
    Let complex_instruction be "mov 8(%rax,%rbx,2), %rcx"
    Let parsed_complex be parse_instruction(complex_instruction)
    
    Let complex_operands be get_parsed_operands(parsed_complex)
    Let complex_operand be get_operand(complex_operands, 0)
    
    If not is_memory_operand(complex_operand):
        Return false  Note: Should recognize complex memory operand
    End If
    
    Let base_reg be get_memory_base(complex_operand)
    Let index_reg be get_memory_index(complex_operand)
    Let scale be get_memory_scale(complex_operand)
    Let displacement be get_memory_displacement(complex_operand)
    
    If not base_reg.equals("rax"):
        Return false  Note: Should parse base register
    End If
    
    If not index_reg.equals("rbx"):
        Return false  Note: Should parse index register
    End If
    
    If scale not_equals 2:
        Return false  Note: Should parse scale factor
    End If
    
    If displacement not_equals 8:
        Return false  Note: Should parse displacement
    End If
    
    Return true
End Process

Process called "test_resolve_address_operand":
    @Implementation
    Tests address operand resolution including symbol lookup, label
    resolution, global variable addresses, and function addresses.
    @End Implementation
    
    Note: Test numeric address resolution
    Let numeric_addr be "0x1000"
    Let resolved_numeric be resolve_address_operand(numeric_addr)
    If resolved_numeric not_equals 4096:  Note: 0x1000 = 4096
        Return false  Note: Should resolve numeric addresses
    End If
    
    Note: Test symbol resolution
    Let symbol_addr be "main"
    Let resolved_symbol be resolve_address_operand(symbol_addr)
    If resolved_symbol equals 0:
        Return false  Note: Should resolve known symbols (assuming main exists)
    End If
    
    Note: Test label resolution (relative)
    Let label_addr be ".L1"
    Let resolved_label be resolve_address_operand(label_addr)
    Note: Labels may resolve to 0 if not defined yet - this is acceptable
    
    Note: Test global variable resolution
    Let global_addr be "global_var"
    Let resolved_global be resolve_address_operand(global_addr)
    Note: Global resolution may fail in test environment - check handling
    
    Note: Test function address resolution
    Let function_addr be "printf"
    Let resolved_function be resolve_address_operand(function_addr)
    Note: Function resolution depends on linking - validate error handling
    
    Note: Test invalid address format
    Let invalid_addr be "not_an_address_123!@#"
    Let resolved_invalid be resolve_address_operand(invalid_addr)
    If resolved_invalid not_equals 0:
        Return false  Note: Invalid addresses should resolve to 0
    End If
    
    Note: Test empty address
    Let empty_addr be ""
    Let resolved_empty be resolve_address_operand(empty_addr)
    If resolved_empty not_equals 0:
        Return false  Note: Empty address should resolve to 0
    End If
    
    Return true
End Process

Note: =====================================================================
Note: MACHINE CODE GENERATION TESTS
Note: =====================================================================

Process called "test_emit_instruction":
    @Implementation
    Tests machine code instruction emission including proper encoding,
    operand encoding, and byte sequence generation for x86_64 instructions.
    @End Implementation
    
    Note: Test simple instruction emission (NOP)
    Let nop_bytes be emit_instruction("nop", create_empty_operands())
    Let nop_length be get_byte_sequence_length(nop_bytes)
    
    If nop_length not_equals 1:
        Return false  Note: NOP should be 1 byte (0x90)
    End If
    
    Let nop_opcode be get_byte_at(nop_bytes, 0)
    If nop_opcode not_equals 144:  Note: 0x90
        Return false  Note: Should emit correct NOP opcode
    End If
    
    Note: Test register-to-register mov
    Let mov_operands be create_operand_list([
        create_register_operand("rax"),
        create_register_operand("rbx")
    ])
    Let mov_bytes be emit_instruction("mov", mov_operands)
    Let mov_length be get_byte_sequence_length(mov_bytes)
    
    If mov_length less_than 2:
        Return false  Note: Should be at least 2 bytes (REX + opcode + ModRM)
    End If
    
    Note: Test immediate instruction
    Let add_operands be create_operand_list([
        create_immediate_operand(42),
        create_register_operand("rax")
    ])
    Let add_bytes be emit_instruction("add", add_operands)
    Let add_length be get_byte_sequence_length(add_bytes)
    
    If add_length less_than 3:
        Return false  Note: Should include opcode, ModRM, and immediate bytes
    End If
    
    Note: Test memory operand instruction
    Let load_operands be create_operand_list([
        create_memory_operand("rax", "", 0, 0),  Note: (%rax)
        create_register_operand("rbx")
    ])
    Let load_bytes be emit_instruction("mov", load_operands)
    Let load_length be get_byte_sequence_length(load_bytes)
    
    If load_length less_than 2:
        Return false  Note: Should include REX prefix and ModRM
    End If
    
    Return true
End Process

Process called "test_encode_operands":
    @Implementation
    Tests operand encoding including register encoding, immediate value
    encoding, and memory operand encoding with various addressing modes.
    @End Implementation
    
    Note: Test register encoding
    Let reg_rax be encode_register("rax")
    If reg_rax not_equals 0:  Note: RAX should encode to 0
        Return false
    End If
    
    Let reg_rbx be encode_register("rbx")
    If reg_rbx not_equals 3:  Note: RBX should encode to 3
        Return false
    End If
    
    Let reg_r8 be encode_register("r8")
    If reg_r8 not_equals 0:  Note: R8 should encode to 0 (with REX.B)
        Return false
    End If
    
    Note: Test immediate encoding
    Let imm_8bit be encode_immediate(42, 1)
    Let imm_8_length be get_byte_sequence_length(imm_8bit)
    If imm_8_length not_equals 1:
        Return false  Note: 8-bit immediate should be 1 byte
    End If
    
    Let imm_32bit be encode_immediate(0x12345678, 4)
    Let imm_32_length be get_byte_sequence_length(imm_32bit)
    If imm_32_length not_equals 4:
        Return false  Note: 32-bit immediate should be 4 bytes
    End If
    
    Note: Test memory operand encoding (SIB byte scenarios)
    Let simple_mem be encode_memory_operand("rax", "", 0, 0)  Note: (%rax)
    Let simple_length be get_byte_sequence_length(simple_mem)
    If simple_length not_equals 1:  Note: Simple memory should be 1 byte (ModRM)
        Return false
    End If
    
    Let sib_mem be encode_memory_operand("rax", "rbx", 2, 8)  Note: 8(%rax,%rbx,2)
    Let sib_length be get_byte_sequence_length(sib_mem)
    If sib_length not_equals 6:  Note: ModRM + SIB + displacement (1 + 1 + 4)
        Return false
    End If
    
    Return true
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS FOR ASSEMBLY TESTING
Note: =====================================================================

Process called "create_syscall_name" that takes name as String returns Pointer:
    @Implementation
    Creates a null-terminated string for syscall name testing.
    @End Implementation
    
    Let name_length be name.length()
    Let name_buffer be allocate(name_length + 1)
    
    Let i be 0
    While i < name_length:
        Let char_code be name.get_char_at(i)
        store_byte_to_pointer(add_pointer_offset(name_buffer, i), char_code)
        Set i to i + 1
    End While
    
    store_byte_to_pointer(add_pointer_offset(name_buffer, name_length), 0)
    
    Return name_buffer
End Process

Process called "create_successful_syscall_result" that takes return_value as Integer returns SyscallResult:
    @Implementation
    Creates a successful syscall result for testing purposes.
    @End Implementation
    
    Let result as SyscallResult
    Set result.is_error to false
    Set result.return_value to return_value
    Set result.error_code to 0
    
    Return result
End Process

Process called "create_failed_syscall_result" that takes errno as Integer returns SyscallResult:
    @Implementation
    Creates a failed syscall result with specified errno for testing.
    @End Implementation
    
    Let result as SyscallResult
    Set result.is_error to true
    Set result.return_value to -1
    Set result.error_code to errno
    
    Return result
End Process

Process called "create_asm_pointer" that takes asm_code as String returns Pointer:
    @Implementation
    Creates a pointer to assembly code string for testing inline assembly.
    @End Implementation
    
    Return create_null_terminated_string(asm_code)
End Process

Process called "create_constraint_array" that takes constraints as Array[String] returns ConstraintArray:
    @Implementation
    Creates a constraint array for assembly template testing.
    @End Implementation
    
    Let constraint_count be constraints.length()
    Let constraint_array be allocate_constraint_array(constraint_count)
    
    Let i be 0
    While i < constraint_count:
        Let constraint_string be constraints[i]
        set_constraint(constraint_array, i, constraint_string)
        Set i to i + 1
    End While
    
    Return constraint_array
End Process

Process called "create_empty_operands" returns OperandList:
    @Implementation
    Creates an empty operand list for instruction testing.
    @End Implementation
    
    Return allocate_operand_list(0)
End Process

Process called "create_operand_list" that takes operands as Array[Operand] returns OperandList:
    @Implementation
    Creates an operand list from an array of operands for testing.
    @End Implementation
    
    Let operand_count be operands.length()
    Let operand_list be allocate_operand_list(operand_count)
    
    Let i be 0
    While i < operand_count:
        set_operand(operand_list, i, operands[i])
        Set i to i + 1
    End While
    
    Return operand_list
End Process

Process called "create_register_operand" that takes register_name as String returns Operand:
    @Implementation
    Creates a register operand for instruction testing.
    @End Implementation
    
    Let operand as Operand
    Set operand.type to "register"
    Set operand.register_name to register_name
    
    Return operand
End Process

Process called "create_immediate_operand" that takes value as Integer returns Operand:
    @Implementation
    Creates an immediate operand for instruction testing.
    @End Implementation
    
    Let operand as Operand
    Set operand.type to "immediate"
    Set operand.immediate_value to value
    
    Return operand
End Process

Process called "create_memory_operand" that takes base as String, index as String, scale as Integer, displacement as Integer returns Operand:
    @Implementation
    Creates a memory operand for instruction testing.
    @End Implementation
    
    Let operand as Operand
    Set operand.type to "memory"
    Set operand.memory_base to base
    Set operand.memory_index to index
    Set operand.memory_scale to scale
    Set operand.memory_displacement to displacement
    
    Return operand
End Process

Note: =====================================================================
Note: TEST RUNNER AND REPORTING
Note: =====================================================================

Process called "run_all_assembly_primitive_tests" returns Boolean:
    @Implementation
    Executes all assembly primitive tests and reports comprehensive results.
    Returns true if all tests pass, false if any test fails.
    @End Implementation
    
    Let all_tests_passed be true
    
    Note: Run syscall tests
    If not test_get_syscall_number():
        Set all_tests_passed to false
        log_test_failure("test_get_syscall_number")
    End If
    
    If not test_make_syscall():
        Set all_tests_passed to false
        log_test_failure("test_make_syscall")
    End If
    
    If not test_syscall_error_handling():
        Set all_tests_passed to false
        log_test_failure("test_syscall_error_handling")
    End If
    
    Note: Run inline assembly tests
    If not test_validate_assembly_syntax():
        Set all_tests_passed to false
        log_test_failure("test_validate_assembly_syntax")
    End If
    
    If not test_parse_assembly_template():
        Set all_tests_passed to false
        log_test_failure("test_parse_assembly_template")
    End If
    
    If not test_optimize_assembly_template():
        Set all_tests_passed to false
        log_test_failure("test_optimize_assembly_template")
    End If
    
    Note: Run instruction parsing tests
    If not test_parse_instruction():
        Set all_tests_passed to false
        log_test_failure("test_parse_instruction")
    End If
    
    If not test_resolve_address_operand():
        Set all_tests_passed to false
        log_test_failure("test_resolve_address_operand")
    End If
    
    Note: Run machine code generation tests
    If not test_emit_instruction():
        Set all_tests_passed to false
        log_test_failure("test_emit_instruction")
    End If
    
    If not test_encode_operands():
        Set all_tests_passed to false
        log_test_failure("test_encode_operands")
    End If
    
    If all_tests_passed:
        log_test_success("All assembly primitive tests passed")
    Otherwise:
        log_test_failure("Some assembly primitive tests failed")
    End If
    
    Return all_tests_passed
End Process