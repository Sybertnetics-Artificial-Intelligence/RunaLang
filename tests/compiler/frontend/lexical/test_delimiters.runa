Note:
tests/compiler/frontend/lexical/test_delimiters.runa
Comprehensive tests for delimiter recognition
:End Note

Import Module "compiler/frontend/lexical/delimiters" as Delimiters
Import Module "testing/assert" as Assert

@Reasoning
    Delimiters define the structure of code - from grouping expressions with
    parentheses to defining blocks with braces. Proper delimiter handling is
    essential for parsing nested structures and maintaining code clarity.
@End Reasoning

Note: =====================================================================
Note: BRACKET DELIMITER TESTS
Note: =====================================================================

Process called "test_parentheses" returns Nothing:
    Note: Test opening and closing parentheses
    Assert.is_true(Delimiters.is_delimiter('('))
    Assert.is_true(Delimiters.is_delimiter(')'))
    Assert.is_true(Delimiters.is_opening_delimiter('('))
    Assert.is_true(Delimiters.is_closing_delimiter(')'))
    
    Note: Test matching
    Assert.is_true(Delimiters.matches_delimiter('(', ')'))
    Assert.is_false(Delimiters.matches_delimiter('(', ']'))
    
    Note: Test delimiter info
    Let paren_info be Delimiters.get_delimiter_info('(')
    Assert.equals(paren_info.delimiter_type, "PARENTHESIS")
    Assert.equals(paren_info.matching_delimiter, ')')
    Assert.equals(paren_info.name, "left parenthesis")
End Process

Process called "test_square_brackets" returns Nothing:
    Note: Test square brackets for array indexing
    Assert.is_true(Delimiters.is_delimiter('['))
    Assert.is_true(Delimiters.is_delimiter(']'))
    Assert.is_true(Delimiters.is_opening_delimiter('['))
    Assert.is_true(Delimiters.is_closing_delimiter(']'))
    
    Note: Test matching
    Assert.is_true(Delimiters.matches_delimiter('[', ']'))
    Assert.is_false(Delimiters.matches_delimiter('[', ')'))
    
    Note: Test delimiter info
    Let bracket_info be Delimiters.get_delimiter_info('[')
    Assert.equals(bracket_info.delimiter_type, "BRACKET")
    Assert.equals(bracket_info.matching_delimiter, ']')
    Assert.equals(bracket_info.name, "left square bracket")
End Process

Process called "test_curly_braces" returns Nothing:
    Note: Test curly braces for blocks and dictionaries
    Assert.is_true(Delimiters.is_delimiter('{'))
    Assert.is_true(Delimiters.is_delimiter('}'))
    Assert.is_true(Delimiters.is_opening_delimiter('{'))
    Assert.is_true(Delimiters.is_closing_delimiter('}'))
    
    Note: Test matching
    Assert.is_true(Delimiters.matches_delimiter('{', '}'))
    Assert.is_false(Delimiters.matches_delimiter('{', ']'))
    
    Note: Test delimiter info
    Let brace_info be Delimiters.get_delimiter_info('{')
    Assert.equals(brace_info.delimiter_type, "BRACE")
    Assert.equals(brace_info.matching_delimiter, '}')
    Assert.equals(brace_info.name, "left curly brace")
End Process

Process called "test_angle_brackets" returns Nothing:
    Note: Test angle brackets for generics
    Assert.is_true(Delimiters.is_delimiter('<'))
    Assert.is_true(Delimiters.is_delimiter('>'))
    Assert.is_true(Delimiters.is_opening_delimiter('<'))
    Assert.is_true(Delimiters.is_closing_delimiter('>'))
    
    Note: Test matching
    Assert.is_true(Delimiters.matches_delimiter('<', '>'))
    Assert.is_false(Delimiters.matches_delimiter('<', ')'))
    
    Note: Test delimiter info
    Let angle_info be Delimiters.get_delimiter_info('<')
    Assert.equals(angle_info.delimiter_type, "ANGLE")
    Assert.equals(angle_info.matching_delimiter, '>')
    Assert.equals(angle_info.name, "left angle bracket")
    Assert.is_true(angle_info.context_sensitive)  Note: Could be comparison operator
End Process

Note: =====================================================================
Note: PUNCTUATION DELIMITER TESTS
Note: =====================================================================

Process called "test_punctuation_delimiters" returns Nothing:
    Note: Test comma
    Assert.is_true(Delimiters.is_delimiter(','))
    Let comma_info be Delimiters.get_delimiter_info(',')
    Assert.equals(comma_info.delimiter_type, "SEPARATOR")
    Assert.equals(comma_info.name, "comma")
    Assert.is_false(comma_info.has_matching)
    
    Note: Test semicolon
    Assert.is_true(Delimiters.is_delimiter(';'))
    Let semicolon_info be Delimiters.get_delimiter_info(';')
    Assert.equals(semicolon_info.delimiter_type, "TERMINATOR")
    Assert.equals(semicolon_info.name, "semicolon")
    
    Note: Test colon
    Assert.is_true(Delimiters.is_delimiter(':'))
    Let colon_info be Delimiters.get_delimiter_info(':')
    Assert.equals(colon_info.delimiter_type, "SEPARATOR")
    Assert.equals(colon_info.name, "colon")
    Assert.is_true(colon_info.context_sensitive)  Note: Used in multiple contexts
    
    Note: Test period (dot)
    Assert.is_true(Delimiters.is_delimiter('.'))
    Let dot_info be Delimiters.get_delimiter_info('.')
    Assert.equals(dot_info.delimiter_type, "ACCESSOR")
    Assert.equals(dot_info.name, "period")
    Assert.is_true(dot_info.context_sensitive)  Note: Could be decimal point
End Process

Note: =====================================================================
Note: QUOTE DELIMITER TESTS
Note: =====================================================================

Process called "test_quote_delimiters" returns Nothing:
    Note: Test double quotes
    Assert.is_true(Delimiters.is_delimiter('"'))
    Let dquote_info be Delimiters.get_delimiter_info('"')
    Assert.equals(dquote_info.delimiter_type, "QUOTE")
    Assert.equals(dquote_info.matching_delimiter, '"')
    Assert.equals(dquote_info.name, "double quote")
    Assert.is_true(dquote_info.self_matching)
    
    Note: Test single quotes
    Assert.is_true(Delimiters.is_delimiter('\''))
    Let squote_info be Delimiters.get_delimiter_info('\'')  
    Assert.equals(squote_info.delimiter_type, "QUOTE")
    Assert.equals(squote_info.matching_delimiter, '\'')  
    Assert.equals(squote_info.name, "single quote")
    Assert.is_true(squote_info.self_matching)
    
    Note: Test backticks
    Assert.is_true(Delimiters.is_delimiter('`'))
    Let backtick_info be Delimiters.get_delimiter_info('`')
    Assert.equals(backtick_info.delimiter_type, "QUOTE")
    Assert.equals(backtick_info.matching_delimiter, '`')
    Assert.equals(backtick_info.name, "backtick")
    Assert.is_true(backtick_info.self_matching)
End Process

Note: =====================================================================
Note: DELIMITER STACK TESTS
Note: =====================================================================

Process called "test_delimiter_stack" returns Nothing:
    Let stack be Delimiters.create_delimiter_stack()
    
    Note: Test pushing delimiters
    Delimiters.push_delimiter(stack, '(', 1, 5)
    Assert.is_false(Delimiters.is_stack_empty(stack))
    Assert.equals(Delimiters.get_current_delimiter(stack), '(')
    
    Delimiters.push_delimiter(stack, '[', 1, 10)
    Assert.equals(Delimiters.get_current_delimiter(stack), '[')
    
    Note: Test matching and popping
    Assert.is_true(Delimiters.check_and_pop(stack, ']', 1, 15))
    Assert.equals(Delimiters.get_current_delimiter(stack), '(')
    
    Assert.is_true(Delimiters.check_and_pop(stack, ')', 1, 20))
    Assert.is_true(Delimiters.is_stack_empty(stack))
    
    Note: Test mismatched delimiter
    Delimiters.push_delimiter(stack, '{', 2, 1)
    Assert.is_false(Delimiters.check_and_pop(stack, ')', 2, 5))
    
    Note: Test unmatched delimiter detection
    Let unmatched be Delimiters.get_unmatched_delimiters(stack)
    Assert.equals(Delimiters.list_length(unmatched), 1)
End Process

Note: =====================================================================
Note: NESTING DEPTH TESTS
Note: =====================================================================

Process called "test_nesting_depth" returns Nothing:
    Let tracker be Delimiters.create_nesting_tracker()
    
    Note: Test initial depth
    Assert.equals(Delimiters.get_current_depth(tracker), 0)
    
    Note: Test increasing depth
    Delimiters.enter_scope(tracker, '(')
    Assert.equals(Delimiters.get_current_depth(tracker), 1)
    
    Delimiters.enter_scope(tracker, '{')
    Assert.equals(Delimiters.get_current_depth(tracker), 2)
    
    Delimiters.enter_scope(tracker, '[')
    Assert.equals(Delimiters.get_current_depth(tracker), 3)
    
    Note: Test decreasing depth
    Delimiters.exit_scope(tracker, ']')
    Assert.equals(Delimiters.get_current_depth(tracker), 2)
    
    Delimiters.exit_scope(tracker, '}')
    Assert.equals(Delimiters.get_current_depth(tracker), 1)
    
    Delimiters.exit_scope(tracker, ')')
    Assert.equals(Delimiters.get_current_depth(tracker), 0)
    
    Note: Test max depth tracking
    For i from 1 to 10:
        Delimiters.enter_scope(tracker, '(')
    End For
    Assert.equals(Delimiters.get_max_depth_reached(tracker), 10)
End Process

Note: =====================================================================
Note: CONTEXT SENSITIVITY TESTS
Note: =====================================================================

Process called "test_context_sensitive_delimiters" returns Nothing:
    Note: Test angle brackets in different contexts
    Assert.is_true(Delimiters.is_generic_context("List<String>"))
    Assert.is_false(Delimiters.is_generic_context("x < y"))
    
    Note: Test period in different contexts
    Assert.is_true(Delimiters.is_member_access("object.field"))
    Assert.is_false(Delimiters.is_member_access("3.14"))
    
    Note: Test colon in different contexts
    Assert.is_true(Delimiters.is_type_annotation("variable: Type"))
    Assert.is_true(Delimiters.is_ternary_operator("condition ? true : false"))
    Assert.is_true(Delimiters.is_block_start("If condition:"))
End Process

Note: =====================================================================
Note: DELIMITER VALIDATION TESTS
Note: =====================================================================

Process called "test_delimiter_validation" returns Nothing:
    Note: Test valid delimiter sequences
    Assert.is_true(Delimiters.is_valid_sequence("()"))
    Assert.is_true(Delimiters.is_valid_sequence("[]"))
    Assert.is_true(Delimiters.is_valid_sequence("{}"))
    Assert.is_true(Delimiters.is_valid_sequence("([{}])"))
    
    Note: Test invalid delimiter sequences
    Assert.is_false(Delimiters.is_valid_sequence("([)"))
    Assert.is_false(Delimiters.is_valid_sequence("(]]"))
    Assert.is_false(Delimiters.is_valid_sequence("{[}]"))
    
    Note: Test incomplete delimiter sequences
    Assert.is_false(Delimiters.is_complete_sequence("("))
    Assert.is_false(Delimiters.is_complete_sequence("[{}"))
    Assert.is_true(Delimiters.is_complete_sequence("([])"))
End Process

Note: =====================================================================
Note: SPECIAL DELIMITER PATTERNS
Note: =====================================================================

Process called "test_special_delimiter_patterns" returns Nothing:
    Note: Test triple quotes for multi-line strings
    Assert.is_true(Delimiters.is_triple_quote('"""'))
    Assert.is_true(Delimiters.is_triple_quote("'''"))
    
    Note: Test heredoc delimiters
    Assert.is_true(Delimiters.is_heredoc_start("<<EOF"))
    Assert.is_true(Delimiters.is_heredoc_end("EOF"))
    
    Note: Test interpolation delimiters
    Assert.is_true(Delimiters.is_interpolation_start("${"))
    Assert.is_true(Delimiters.is_interpolation_end("}")))  
    
    Note: Test template literal delimiters
    Assert.is_true(Delimiters.is_template_delimiter("`${")))  
    Assert.is_true(Delimiters.is_template_delimiter("}`"))
End Process

Note: =====================================================================
Note: TEST RUNNER
Note: =====================================================================

Process called "run_all_delimiter_tests" returns Nothing:
    @TestCases
        - Bracket delimiters: (), [], {}, <>
        - Punctuation delimiters: comma, semicolon, colon, period
        - Quote delimiters: single, double, backtick
        - Delimiter stack for tracking nesting
        - Nesting depth tracking
        - Context-sensitive delimiter interpretation
        - Delimiter sequence validation
        - Special delimiter patterns (triple quotes, heredocs, interpolation)
    @End TestCases
    
    test_parentheses()
    test_square_brackets()
    test_curly_braces()
    test_angle_brackets()
    test_punctuation_delimiters()
    test_quote_delimiters()
    test_delimiter_stack()
    test_nesting_depth()
    test_context_sensitive_delimiters()
    test_delimiter_validation()
    test_special_delimiter_patterns()
    
    Print("All delimiter tests passed!")
End Process