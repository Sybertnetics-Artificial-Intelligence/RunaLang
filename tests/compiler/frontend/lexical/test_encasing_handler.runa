Note:
tests/compiler/frontend/lexical/test_encasing_handler.runa
Comprehensive tests for encasing keyword pattern handling
:End Note

Import Module "compiler/frontend/lexical/encasing_handler" as EncasingHandler
Import Module "compiler/frontend/lexical/keywords" as Keywords
Import Module "compiler/internal/collections" as Collections
Import Module "testing/assert" as Assert

@Reasoning
    Encasing keyword patterns are a revolutionary Runa feature that allows
    variable names to contain spaces. Keywords like "Let" and "be" create
    boundaries around natural language identifiers.
@End Reasoning

Note: =====================================================================
Note: ENCASING STATE TESTS
Note: =====================================================================

Process called "test_encasing_state_creation" returns Nothing:
    Let state be EncasingHandler.create_encasing_state()
    
    Note: Test initial state
    Assert.is_false(state.is_active)
    Assert.equals(state.start_keyword, "")
    Assert.equals(state.end_keyword, "")
    Assert.equals(Collections.list_length(state.captured_words), 0)
    Assert.equals(state.start_line, 0)
    Assert.equals(state.start_column, 0)
End Process

Process called "test_start_encasing" returns Nothing:
    Let state be EncasingHandler.create_encasing_state()
    
    Note: Start encasing with "Let"
    EncasingHandler.start_encasing(state, "Let", 1, 5)
    
    Assert.is_true(state.is_active)
    Assert.equals(state.start_keyword, "Let")
    Assert.equals(state.start_line, 1)
    Assert.equals(state.start_column, 5)
    
    Note: The end keyword should be set by Keywords module
    Note: We'll verify it's "be" for "Let"
End Process

Note: =====================================================================
Note: WORD CAPTURE TESTS
Note: =====================================================================

Process called "test_add_words_to_encasing" returns Nothing:
    Let state be EncasingHandler.create_encasing_state()
    EncasingHandler.start_encasing(state, "Let", 1, 1)
    
    Note: Add multiple words
    EncasingHandler.add_word_to_encasing(state, "my")
    EncasingHandler.add_word_to_encasing(state, "complex")
    EncasingHandler.add_word_to_encasing(state, "variable")
    EncasingHandler.add_word_to_encasing(state, "name")
    
    Assert.equals(Collections.list_length(state.captured_words), 4)
    Assert.equals(Collections.list_get(state.captured_words, 0), "my")
    Assert.equals(Collections.list_get(state.captured_words, 1), "complex")
    Assert.equals(Collections.list_get(state.captured_words, 2), "variable")
    Assert.equals(Collections.list_get(state.captured_words, 3), "name")
End Process

Process called "test_complete_encasing" returns Nothing:
    Let state be EncasingHandler.create_encasing_state()
    EncasingHandler.start_encasing(state, "Let", 1, 1)
    
    Note: Add words to form "my variable name"
    EncasingHandler.add_word_to_encasing(state, "my")
    EncasingHandler.add_word_to_encasing(state, "variable")
    EncasingHandler.add_word_to_encasing(state, "name")
    
    Let identifier be EncasingHandler.complete_encasing(state)
    Assert.equals(identifier, "my variable name")
    
    Note: State should be reset after completion
    Assert.is_false(state.is_active)
    Assert.equals(state.start_keyword, "")
    Assert.equals(Collections.list_length(state.captured_words), 0)
End Process

Note: =====================================================================
Note: END KEYWORD DETECTION TESTS
Note: =====================================================================

Process called "test_should_end_encasing" returns Nothing:
    Let state be EncasingHandler.create_encasing_state()
    
    Note: Not active - should always return false
    Assert.is_false(EncasingHandler.should_end_encasing(state, "be"))
    
    Note: Start encasing with Let (end keyword is "be")
    EncasingHandler.start_encasing(state, "Let", 1, 1)
    Set state.end_keyword to "be"  Note: Simulate Keywords.get_encasing_end
    
    Note: Test non-end keywords
    Assert.is_false(EncasingHandler.should_end_encasing(state, "my"))
    Assert.is_false(EncasingHandler.should_end_encasing(state, "variable"))
    
    Note: Test end keyword
    Assert.is_true(EncasingHandler.should_end_encasing(state, "be"))
    
    Note: Test keywords that force end (assuming If cannot be in identifier)
    Assert.is_true(EncasingHandler.should_end_encasing(state, "If"))
End Process

Note: =====================================================================
Note: AMBIGUITY RESOLUTION TESTS
Note: =====================================================================

Process called "test_find_last_end_keyword" returns Nothing:
    Let words be Collections.create_list()
    Collections.list_append(words, "x")
    Collections.list_append(words, "be")
    Collections.list_append(words, "y")
    Collections.list_append(words, "be")
    Collections.list_append(words, "z")
    
    Let last_index be EncasingHandler.find_last_end_keyword(words, "be")
    Assert.equals(last_index, 3)  Note: Second "be" at index 3
    
    Note: Test with no end keyword
    Let words2 be Collections.create_list()
    Collections.list_append(words2, "just")
    Collections.list_append(words2, "words")
    
    Let last_index2 be EncasingHandler.find_last_end_keyword(words2, "be")
    Assert.equals(last_index2, -1)
End Process

Process called "test_resolve_ambiguous_encasing" returns Nothing:
    Let state be EncasingHandler.create_encasing_state()
    EncasingHandler.start_encasing(state, "Let", 1, 1)
    Set state.end_keyword to "be"
    
    Note: Add "x be y be" - should resolve to "x be y"
    EncasingHandler.add_word_to_encasing(state, "x")
    EncasingHandler.add_word_to_encasing(state, "be")
    EncasingHandler.add_word_to_encasing(state, "y")
    EncasingHandler.add_word_to_encasing(state, "be")
    
    Let identifier be EncasingHandler.resolve_ambiguous_encasing(state)
    Assert.equals(identifier, "x be y")
    
    Note: State should be reset
    Assert.is_false(state.is_active)
End Process

Note: =====================================================================
Note: ERROR RECOVERY TESTS
Note: =====================================================================

Process called "test_abort_encasing" returns Nothing:
    Let state be EncasingHandler.create_encasing_state()
    EncasingHandler.start_encasing(state, "Let", 1, 1)
    
    Note: Add some words then abort
    EncasingHandler.add_word_to_encasing(state, "partial")
    EncasingHandler.add_word_to_encasing(state, "identifier")
    
    Let partial be EncasingHandler.abort_encasing(state)
    Assert.equals(partial, "partial identifier")
    
    Note: State should be reset
    Assert.is_false(state.is_active)
    Assert.equals(state.start_keyword, "")
    
    Note: Test aborting with no words
    EncasingHandler.start_encasing(state, "Let", 2, 1)
    Let empty be EncasingHandler.abort_encasing(state)
    Assert.equals(empty, "")
End Process

Note: =====================================================================
Note: INTEGRATION HELPER TESTS
Note: =====================================================================

Process called "test_is_encasing_active" returns Nothing:
    Let state be EncasingHandler.create_encasing_state()
    
    Assert.is_false(EncasingHandler.is_encasing_active(state))
    
    EncasingHandler.start_encasing(state, "Let", 1, 1)
    Assert.is_true(EncasingHandler.is_encasing_active(state))
    
    EncasingHandler.complete_encasing(state)
    Assert.is_false(EncasingHandler.is_encasing_active(state))
End Process

Process called "test_handle_word_in_encasing" returns Nothing:
    Let state be EncasingHandler.create_encasing_state()
    EncasingHandler.start_encasing(state, "Let", 1, 1)
    Set state.end_keyword to "be"
    
    Note: Add words that are part of identifier
    Let result1 be EncasingHandler.handle_word_in_encasing(state, "my")
    Assert.equals(result1, "")  Note: Not complete yet
    
    Let result2 be EncasingHandler.handle_word_in_encasing(state, "variable")
    Assert.equals(result2, "")  Note: Still not complete
    
    Note: End keyword completes the encasing
    Let result3 be EncasingHandler.handle_word_in_encasing(state, "be")
    Assert.equals(result3, "my variable")
    Assert.is_false(state.is_active)  Note: State reset
End Process

Note: =====================================================================
Note: COMPLEX SCENARIO TESTS
Note: =====================================================================

Process called "test_nested_be_keywords" returns Nothing:
    Note: Test "Let result to be calculated be 42"
    Let state be EncasingHandler.create_encasing_state()
    EncasingHandler.start_encasing(state, "Let", 1, 1)
    Set state.end_keyword to "be"
    
    EncasingHandler.add_word_to_encasing(state, "result")
    EncasingHandler.add_word_to_encasing(state, "to")
    EncasingHandler.add_word_to_encasing(state, "be")
    EncasingHandler.add_word_to_encasing(state, "calculated")
    EncasingHandler.add_word_to_encasing(state, "be")
    
    Note: Last "be" wins - identifier is "result to be calculated"
    Let identifier be EncasingHandler.resolve_ambiguous_encasing(state)
    Assert.equals(identifier, "result to be calculated")
End Process

Process called "test_no_spaces_identifier" returns Nothing:
    Note: Test single-word identifier "Let x be 5"
    Let state be EncasingHandler.create_encasing_state()
    EncasingHandler.start_encasing(state, "Let", 1, 1)
    
    EncasingHandler.add_word_to_encasing(state, "x")
    
    Let identifier be EncasingHandler.complete_encasing(state)
    Assert.equals(identifier, "x")
End Process

Process called "test_very_long_identifier" returns Nothing:
    Note: Test identifier with many words
    Let state be EncasingHandler.create_encasing_state()
    EncasingHandler.start_encasing(state, "Let", 1, 1)
    
    EncasingHandler.add_word_to_encasing(state, "the")
    EncasingHandler.add_word_to_encasing(state, "final")
    EncasingHandler.add_word_to_encasing(state, "calculated")
    EncasingHandler.add_word_to_encasing(state, "result")
    EncasingHandler.add_word_to_encasing(state, "of")
    EncasingHandler.add_word_to_encasing(state, "complex")
    EncasingHandler.add_word_to_encasing(state, "mathematical")
    EncasingHandler.add_word_to_encasing(state, "operation")
    
    Let identifier be EncasingHandler.complete_encasing(state)
    Assert.equals(identifier, "the final calculated result of complex mathematical operation")
End Process

Note: =====================================================================
Note: TEST RUNNER
Note: =====================================================================

Process called "run_all_encasing_handler_tests" returns Nothing:
    @TestCases
        - Encasing state creation and management
        - Starting encasing patterns
        - Capturing words into identifiers
        - Completing encasing and forming identifiers
        - End keyword detection
        - Ambiguity resolution (last occurrence wins)
        - Error recovery and aborting
        - Integration helper functions
        - Complex scenarios with nested keywords
        - Single-word and multi-word identifiers
    @End TestCases
    
    test_encasing_state_creation()
    test_start_encasing()
    test_add_words_to_encasing()
    test_complete_encasing()
    test_should_end_encasing()
    test_find_last_end_keyword()
    test_resolve_ambiguous_encasing()
    test_abort_encasing()
    test_is_encasing_active()
    test_handle_word_in_encasing()
    test_nested_be_keywords()
    test_no_spaces_identifier()
    test_very_long_identifier()
    
    Print("All encasing handler tests passed!")
End Process