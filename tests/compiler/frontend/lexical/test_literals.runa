Note:
tests/compiler/frontend/lexical/test_literals.runa
Comprehensive tests for literal parsing
:End Note

Import Module "compiler/frontend/lexical/literals" as Literals
Import Module "testing/assert" as Assert

@Reasoning
    Literals are fundamental to any programming language. We need to ensure
    that all literal types are correctly parsed, including edge cases like
    scientific notation, escape sequences, and Unicode handling.
@End Reasoning

Note: =====================================================================
Note: NUMBER LITERAL TESTS
Note: =====================================================================

Process called "test_decimal_numbers" returns Nothing:
    Let parser be Literals.create_literal_parser("developer")
    
    Note: Test fundamental integers
    Let int_literal be Literals.parse_literal(parser, "42")
    Assert.equals(int_literal.literal_type, "NUMBER")
    Assert.equals(int_literal.parsed_value, "42")
    Assert.equals(int_literal.data_type, "Integer")
    
    Note: Test floating point
    Let float_literal be Literals.parse_literal(parser, "3.14159")
    Assert.equals(float_literal.literal_type, "NUMBER")
    Assert.equals(float_literal.parsed_value, "3.14159")
    Assert.equals(float_literal.data_type, "Float")
    
    Note: Test scientific notation
    Let sci_literal be Literals.parse_literal(parser, "1.23e-4")
    Assert.equals(sci_literal.literal_type, "NUMBER")
    Assert.equals(sci_literal.parsed_value, "1.23e-4")
    Assert.equals(sci_literal.data_type, "Float")
    
    Note: Test underscores in numbers
    Let underscore_literal be Literals.parse_literal(parser, "1_000_000")
    Assert.equals(underscore_literal.parsed_value, "1000000")
End Process

Process called "test_hex_binary_octal_numbers" returns Nothing:
    Let parser be Literals.create_literal_parser("developer")
    
    Note: Test hexadecimal
    Let hex_literal be Literals.parse_literal(parser, "0xDEADBEEF")
    Assert.equals(hex_literal.literal_type, "NUMBER")
    Let hex_info be Literals.parse_number_literal(parser, "0xDEADBEEF")
    Assert.equals(hex_info.number_base, 16)
    
    Note: Test binary
    Let bin_literal be Literals.parse_literal(parser, "0b101010")
    Assert.equals(bin_literal.literal_type, "NUMBER")
    Let bin_info be Literals.parse_number_literal(parser, "0b101010")
    Assert.equals(bin_info.number_base, 2)
    
    Note: Test octal
    Let oct_literal be Literals.parse_literal(parser, "0o755")
    Assert.equals(oct_literal.literal_type, "NUMBER")
    Let oct_info be Literals.parse_number_literal(parser, "0o755")
    Assert.equals(oct_info.number_base, 8)
End Process

Process called "test_number_edge_cases" returns Nothing:
    Let parser be Literals.create_literal_parser("developer")
    
    Note: Test negative numbers
    Let neg_literal be Literals.parse_literal(parser, "-42")
    Assert.equals(neg_literal.parsed_value, "-42")
    
    Note: Test zero
    Let zero_literal be Literals.parse_literal(parser, "0")
    Assert.equals(zero_literal.parsed_value, "0")
    
    Note: Test very large number (overflow risk)
    Let large_literal be Literals.parse_literal(parser, "99999999999999999999")
    Let large_info be Literals.parse_number_literal(parser, "99999999999999999999")
    Assert.is_true(large_info.overflow_risk)
End Process

Note: =====================================================================
Note: STRING LITERAL TESTS
Note: =====================================================================

Process called "test_fundamental_strings" returns Nothing:
    Let parser be Literals.create_literal_parser("developer")
    
    Note: Test double-quoted string
    Let double_str be Literals.parse_literal(parser, "\"Hello, World!\"")
    Assert.equals(double_str.literal_type, "STRING")
    Assert.equals(double_str.parsed_value, "Hello, World!")
    
    Note: Test single-quoted string
    Let single_str be Literals.parse_literal(parser, "'Hello, World!'")
    Assert.equals(single_str.literal_type, "STRING")
    Assert.equals(single_str.parsed_value, "Hello, World!")
    
    Note: Test empty string
    Let empty_str be Literals.parse_literal(parser, "\"\"")
    Assert.equals(empty_str.parsed_value, "")
End Process

Process called "test_escape_sequences" returns Nothing:
    Let parser be Literals.create_literal_parser("developer")
    
    Note: Test newline escape
    Let newline_str be Literals.parse_literal(parser, "\"Line 1\\nLine 2\"")
    Assert.equals(newline_str.parsed_value, "Line 1\nLine 2")
    
    Note: Test tab escape
    Let tab_str be Literals.parse_literal(parser, "\"Col1\\tCol2\"")
    Assert.equals(tab_str.parsed_value, "Col1\tCol2")
    
    Note: Test quote escapes
    Let quote_str be Literals.parse_literal(parser, "\"He said \\\"Hello\\\"\"")
    Assert.equals(quote_str.parsed_value, "He said \"Hello\"")
    
    Note: Test backslash escape
    Let backslash_str be Literals.parse_literal(parser, "\"Path\\\\to\\\\file\"")
    Assert.equals(backslash_str.parsed_value, "Path\\to\\file")
    
    Note: Test hex escape
    Let hex_str be Literals.parse_literal(parser, "\"\\x41\\x42\\x43\"")
    Assert.equals(hex_str.parsed_value, "ABC")
    
    Note: Test Unicode escape
    Let unicode_str be Literals.parse_literal(parser, "\"\\u03B1\\u03B2\\u03B3\"")
    Assert.equals(unicode_str.parsed_value, "αβγ")
End Process

Process called "test_raw_strings" returns Nothing:
    Let parser be Literals.create_literal_parser("developer")
    
    Note: Raw strings don't process escape sequences
    Let raw_str be Literals.parse_literal(parser, "r\"C:\\Users\\name\\file.txt\"")
    Assert.equals(raw_str.literal_type, "STRING")
    Assert.equals(raw_str.parsed_value, "C:\\Users\\name\\file.txt")
    
    Let raw_info be Literals.parse_string_literal(parser, "r\"test\\nstring\"")
    Assert.is_true(raw_info.is_raw)
    Assert.equals(raw_info.processed_content, "test\\nstring")
End Process

Process called "test_formatted_strings" returns Nothing:
    Let parser be Literals.create_literal_parser("developer")
    
    Note: Test fundamental interpolation
    Let fmt_str be Literals.parse_literal(parser, "f\"Hello {name}!\"")
    Assert.equals(fmt_str.literal_type, "STRING")
    Let fmt_info be Literals.parse_string_literal(parser, "f\"Hello {name}!\"")
    Assert.is_true(fmt_info.is_formatted)
    
    Note: Test nested braces
    Let nested_str be Literals.parse_literal(parser, "f\"Result: {x + {y}}\"")
    Assert.equals(nested_str.parsed_value, "Result: ${x + {y}}")
    
    Note: Test escaped braces
    Let escaped_str be Literals.parse_literal(parser, "f\"Use {{braces}} like this\"")
    Assert.contains(escaped_str.parsed_value, "{braces}")
End Process

Process called "test_triple_quoted_strings" returns Nothing:
    Let parser be Literals.create_literal_parser("developer")
    
    Note: Test multi-line string
    Let triple_str be "\"\"\"Line 1\nLine 2\nLine 3\"\"\""
    Let parsed be Literals.parse_literal(parser, triple_str)
    Assert.equals(parsed.literal_type, "STRING")
    Assert.contains(parsed.parsed_value, "Line 1")
    Assert.contains(parsed.parsed_value, "Line 2")
    Assert.contains(parsed.parsed_value, "Line 3")
End Process

Note: =====================================================================
Note: BOOLEAN LITERAL TESTS
Note: =====================================================================

Process called "test_boolean_literals" returns Nothing:
    Let dev_parser be Literals.create_literal_parser("developer")
    Let canon_parser be Literals.create_literal_parser("canon")
    
    Note: Test true/false in developer mode
    Let true_lit be Literals.parse_literal(dev_parser, "true")
    Assert.equals(true_lit.literal_type, "BOOLEAN")
    Assert.equals(true_lit.parsed_value, "true")
    
    Let false_lit be Literals.parse_literal(dev_parser, "false")
    Assert.equals(false_lit.literal_type, "BOOLEAN")
    Assert.equals(false_lit.parsed_value, "false")
    
    Note: Test yes/no in Canon mode
    Let yes_lit be Literals.parse_literal(canon_parser, "yes")
    Assert.equals(yes_lit.literal_type, "BOOLEAN")
    Assert.equals(yes_lit.parsed_value, "true")
    
    Let no_lit be Literals.parse_literal(canon_parser, "no")
    Assert.equals(no_lit.literal_type, "BOOLEAN")
    Assert.equals(no_lit.parsed_value, "false")
    
    Note: Test case insensitivity
    Assert.is_true(Literals.parse_boolean_literal(dev_parser, "TRUE"))
    Assert.is_false(Literals.parse_boolean_literal(dev_parser, "FALSE"))
End Process

Note: =====================================================================
Note: NULL LITERAL TESTS
Note: =====================================================================

Process called "test_null_literals" returns Nothing:
    Let parser be Literals.create_literal_parser("developer")
    
    Note: Test null variant
    Let null_lit be Literals.parse_literal(parser, "null")
    Assert.equals(null_lit.literal_type, "NULL")
    Assert.equals(null_lit.parsed_value, "null")
    
    Note: Test none variant
    Let none_lit be Literals.parse_literal(parser, "none")
    Assert.equals(none_lit.literal_type, "NULL")
    Assert.equals(none_lit.parsed_value, "none")
    
    Note: Test nil variant
    Let nil_lit be Literals.parse_literal(parser, "nil")
    Assert.equals(nil_lit.literal_type, "NULL")
    Assert.equals(nil_lit.parsed_value, "nil")
End Process

Note: =====================================================================
Note: VALIDATION TESTS
Note: =====================================================================

Process called "test_literal_validation" returns Nothing:
    Let parser be Literals.create_literal_parser("developer")
    
    Note: Test invalid number
    Let bad_num be Literals.parse_literal(parser, "123abc")
    Assert.is_not_empty(bad_num.validation_errors)
    
    Note: Test unclosed string
    Let bad_str be Literals.parse_literal(parser, "\"unclosed")
    Assert.is_not_empty(bad_str.validation_errors)
    
    Note: Test unknown literal
    Let unknown be Literals.parse_literal(parser, "@#$%")
    Assert.equals(unknown.literal_type, "UNKNOWN")
End Process

Note: =====================================================================
Note: TEST RUNNER
Note: =====================================================================

Process called "run_all_literal_tests" returns Nothing:
    @TestCases
        - Decimal numbers: integers, floats, scientific notation
        - Alternative bases: hex, binary, octal
        - String literals: single, double, triple quoted
        - Escape sequences: standard and Unicode
        - Raw and formatted strings
        - Boolean literals in both modes
        - Null literal variants
        - Edge cases and validation
    @End TestCases
    
    test_decimal_numbers()
    test_hex_binary_octal_numbers()
    test_number_edge_cases()
    test_fundamental_strings()
    test_escape_sequences()
    test_raw_strings()
    test_formatted_strings()
    test_triple_quoted_strings()
    test_boolean_literals()
    test_null_literals()
    test_literal_validation()
    
    Print("All literal tests passed!")
End Process