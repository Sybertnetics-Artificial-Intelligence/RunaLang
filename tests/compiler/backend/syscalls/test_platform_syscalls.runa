Note:
tests/compiler/backend/syscalls/test_platform_syscalls.runa
Comprehensive Tests for Platform-Specific Syscall Implementations

This module validates the platform-specific syscall implementations for all
supported operating systems and architectures, ensuring correct syscall
numbers, calling conventions, and error handling across platforms.

Key test areas:
- Linux x64/ARM64 syscall implementations
- Darwin x64/ARM64 syscall implementations
- FreeBSD/OpenBSD/NetBSD syscall implementations
- Windows x64 syscall implementations
- Cross-platform consistency verification
- Architecture-specific calling conventions
- Platform-specific error mappings
- VDSO and fast-path optimizations
:End Note

Import "compiler/backend/syscalls/platforms/linux_x64" as LinuxX64
Import "compiler/backend/syscalls/platforms/linux_arm64" as LinuxARM64
Import "compiler/backend/syscalls/platforms/darwin_x64" as DarwinX64
Import "compiler/backend/syscalls/platforms/darwin_arm64" as DarwinARM64
Import "compiler/backend/syscalls/platforms/freebsd_x64" as FreeBSDX64
Import "compiler/backend/syscalls/platforms/openbsd_x64" as OpenBSDX64
Import "compiler/backend/syscalls/platforms/netbsd_x64" as NetBSDX64
Import "compiler/backend/syscalls/platforms/windows_x64" as WindowsX64
Import "compiler/backend/syscalls/platforms/platform_interface" as PlatformInterface
Import "compiler/backend/syscalls/syscall_registry" as Registry
Import "compiler/frontend/primitives/types/compiler_internals" as Internals
Import "testing/test_framework" as Test

@Reasoning
Platform-specific syscall implementations are critical for OS interaction.
These tests ensure each platform correctly implements syscall numbers,
calling conventions, and error handling according to their respective ABIs.
@End Reasoning

Note: =====================================================================
Note: LINUX X64 PLATFORM TESTS
Note: =====================================================================

Process called "test_linux_x64_syscall_numbers" returns Nothing:
    @TestCases
    - Verify Linux x64 syscall numbers match kernel definitions
    - Check syscall number ranges and validity
    - Validate new syscalls for recent kernels
    - Ensure compatibility with older kernels
    @End TestCases
    
    Let platform be LinuxX64.create_linux_x64_platform()
    
    Note: Test fundamental syscalls
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_READ), 0)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_WRITE), 1)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_OPEN), 2)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_CLOSE), 3)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_STAT), 4)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_FSTAT), 5)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_LSTAT), 6)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_POLL), 7)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_LSEEK), 8)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_MMAP), 9)
    
    Note: Test process management syscalls
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_FORK), 57)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_VFORK), 58)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_EXECVE), 59)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_EXIT), 60)
    
    Note: Test newer syscalls
    Test.assert_equals(platform.get_syscall_number("io_uring_setup"), 425)
    Test.assert_equals(platform.get_syscall_number("io_uring_enter"), 426)
    Test.assert_equals(platform.get_syscall_number("io_uring_register"), 427)
    Test.assert_equals(platform.get_syscall_number("pidfd_open"), 434)
    Test.assert_equals(platform.get_syscall_number("pidfd_getfd"), 438)
    
    Note: Test unsupported syscall returns -1
    Test.assert_equals(platform.get_syscall_number("nonexistent_syscall"), -1)
End Process

Process called "test_linux_x64_calling_convention" returns Nothing:
    @TestCases
    - Verify Linux x64 syscall calling convention
    - Check register allocation order (rdi, rsi, rdx, r10, r8, r9)
    - Validate syscall instruction usage
    - Ensure proper clobber list
    @End TestCases
    
    Let platform be LinuxX64.create_linux_x64_platform()
    Let convention be platform.get_calling_convention()
    
    Note: Verify syscall instruction
    Test.assert_equals(convention.syscall_instruction, "syscall")
    
    Note: Verify parameter registers in correct order
    Test.assert_equals(convention.param_registers[0], "rdi")
    Test.assert_equals(convention.param_registers[1], "rsi")
    Test.assert_equals(convention.param_registers[2], "rdx")
    Test.assert_equals(convention.param_registers[3], "r10")  Note: Not rcx!
    Test.assert_equals(convention.param_registers[4], "r8")
    Test.assert_equals(convention.param_registers[5], "r9")
    
    Note: Verify return register
    Test.assert_equals(convention.return_register, "rax")
    
    Note: Verify clobbered registers
    Test.assert_contains(convention.clobbered_registers, "rcx")  Note: Used by syscall
    Test.assert_contains(convention.clobbered_registers, "r11")  Note: Used by syscall
    
    Note: Verify max register parameters
    Test.assert_equals(convention.max_register_params, 6)
    
    Note: Verify stack alignment requirement
    Test.assert_equals(convention.stack_alignment, 16)
End Process

Process called "test_linux_x64_error_mapping" returns Nothing:
    @TestCases
    - Verify Linux error code mappings
    - Check negative errno return convention
    - Validate error code ranges
    - Ensure complete error coverage
    @End TestCases
    
    Let platform be LinuxX64.create_linux_x64_platform()
    Let error_map be platform.get_error_mapping()
    
    Note: Test common error codes
    Test.assert_equals(get_error_value(error_map, "EPERM"), -1)
    Test.assert_equals(get_error_value(error_map, "ENOENT"), -2)
    Test.assert_equals(get_error_value(error_map, "ESRCH"), -3)
    Test.assert_equals(get_error_value(error_map, "EINTR"), -4)
    Test.assert_equals(get_error_value(error_map, "EIO"), -5)
    Test.assert_equals(get_error_value(error_map, "ENXIO"), -6)
    Test.assert_equals(get_error_value(error_map, "E2BIG"), -7)
    Test.assert_equals(get_error_value(error_map, "ENOEXEC"), -8)
    Test.assert_equals(get_error_value(error_map, "EBADF"), -9)
    Test.assert_equals(get_error_value(error_map, "ECHILD"), -10)
    Test.assert_equals(get_error_value(error_map, "EAGAIN"), -11)
    Test.assert_equals(get_error_value(error_map, "ENOMEM"), -12)
    Test.assert_equals(get_error_value(error_map, "EACCES"), -13)
    Test.assert_equals(get_error_value(error_map, "EFAULT"), -14)
    
    Note: Verify error range convention (negative values)
    For Each error_name in get_all_error_names(error_map):
        Let error_value be get_error_value(error_map, error_name)
        Test.assert_less_than(error_value, 0)
        Test.assert_greater_than(error_value, -200)  Note: Linux errors typically < 200
    End For
End Process

Note: =====================================================================
Note: DARWIN (MACOS) PLATFORM TESTS
Note: =====================================================================

Process called "test_darwin_x64_syscall_numbers" returns Nothing:
    @TestCases
    - Verify Darwin x64 syscall numbers
    - Check syscall class encoding in high bits
    - Validate BSD compatibility syscalls
    - Ensure Mach trap numbers
    @End TestCases
    
    Let platform be DarwinX64.create_darwin_x64_platform()
    
    Note: Darwin uses different syscall numbering with class bits
    Note: BSD syscalls have 0x2000000 class bit
    Let BSD_CLASS be 0x2000000
    
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_EXIT), BSD_CLASS | 1)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_FORK), BSD_CLASS | 2)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_READ), BSD_CLASS | 3)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_WRITE), BSD_CLASS | 4)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_OPEN), BSD_CLASS | 5)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_CLOSE), BSD_CLASS | 6)
    
    Note: Test Mach traps (negative numbers)
    Test.assert_less_than(platform.get_syscall_number("mach_msg_trap"), 0)
    Test.assert_less_than(platform.get_syscall_number("mach_reply_port"), 0)
    Test.assert_less_than(platform.get_syscall_number("thread_self_trap"), 0)
End Process

Process called "test_darwin_arm64_calling_convention" returns Nothing:
    @TestCases
    - Verify Darwin ARM64 syscall calling convention
    - Check register allocation (x0-x7)
    - Validate svc instruction usage
    - Ensure proper preservation of registers
    @End TestCases
    
    Let platform be DarwinARM64.create_darwin_arm64_platform()
    Let convention be platform.get_calling_convention()
    
    Note: Verify syscall instruction for ARM64
    Test.assert_equals(convention.syscall_instruction, "svc")
    
    Note: Verify parameter registers
    Test.assert_equals(convention.param_registers[0], "x0")
    Test.assert_equals(convention.param_registers[1], "x1")
    Test.assert_equals(convention.param_registers[2], "x2")
    Test.assert_equals(convention.param_registers[3], "x3")
    Test.assert_equals(convention.param_registers[4], "x4")
    Test.assert_equals(convention.param_registers[5], "x5")
    Test.assert_equals(convention.param_registers[6], "x6")
    Test.assert_equals(convention.param_registers[7], "x7")
    
    Note: Verify syscall number register
    Test.assert_equals(convention.syscall_number_register, "x16")
    
    Note: Verify return registers
    Test.assert_equals(convention.return_register, "x0")
    Test.assert_equals(convention.error_register, "x1")  Note: Carry flag in x1
    
    Note: Verify max register parameters
    Test.assert_equals(convention.max_register_params, 8)
End Process

Note: =====================================================================
Note: BSD PLATFORM TESTS (FREEBSD, OPENBSD, NETBSD)
Note: =====================================================================

Process called "test_freebsd_x64_syscalls" returns Nothing:
    @TestCases
    - Verify FreeBSD x64 syscall numbers
    - Check FreeBSD-specific syscalls
    - Validate compatibility with BSD standards
    - Ensure capsicum capability syscalls
    @End TestCases
    
    Let platform be FreeBSDX64.create_freebsd_x64_platform()
    
    Note: Test standard BSD syscalls
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_EXIT), 1)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_FORK), 2)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_READ), 3)
    Test.assert_equals(platform.get_syscall_number(Registry.SYSCALL_WRITE), 4)
    
    Note: Test FreeBSD-specific syscalls
    Test.assert_true(platform.supports_syscall("cap_enter"))
    Test.assert_true(platform.supports_syscall("cap_rights_limit"))
    Test.assert_true(platform.supports_syscall("cap_ioctls_limit"))
    Test.assert_true(platform.supports_syscall("cap_fcntls_limit"))
    
    Note: Test kqueue (BSD's epoll equivalent)
    Test.assert_true(platform.supports_syscall("kqueue"))
    Test.assert_true(platform.supports_syscall("kevent"))
End Process

Process called "test_openbsd_x64_syscalls" returns Nothing:
    @TestCases
    - Verify OpenBSD x64 syscall numbers
    - Check pledge/unveil security syscalls
    - Validate OpenBSD-specific features
    - Ensure security-focused syscalls
    @End TestCases
    
    Let platform be OpenBSDX64.create_openbsd_x64_platform()
    
    Note: Test OpenBSD security syscalls
    Test.assert_true(platform.supports_syscall("pledge"))
    Test.assert_true(platform.supports_syscall("unveil"))
    
    Note: Test standard syscalls with OpenBSD numbering
    Test.assert_greater_than(platform.get_syscall_number(Registry.SYSCALL_READ), 0)
    Test.assert_greater_than(platform.get_syscall_number(Registry.SYSCALL_WRITE), 0)
    
    Note: OpenBSD removed some legacy syscalls
    Test.assert_false(platform.supports_syscall("uselib"))
    Test.assert_false(platform.supports_syscall("create_module"))
End Process

Process called "test_netbsd_x64_syscalls" returns Nothing:
    @TestCases
    - Verify NetBSD x64 syscall numbers
    - Check NetBSD-specific features
    - Validate compatibility layer syscalls
    - Ensure proper versioning support
    @End TestCases
    
    Let platform be NetBSDX64.create_netbsd_x64_platform()
    
    Note: Test standard syscalls
    Test.assert_greater_than(platform.get_syscall_number(Registry.SYSCALL_READ), 0)
    Test.assert_greater_than(platform.get_syscall_number(Registry.SYSCALL_WRITE), 0)
    
    Note: Test NetBSD-specific features
    Test.assert_true(platform.supports_syscall("modctl"))  Note: Kernel module control
    Test.assert_true(platform.supports_syscall("pset_create"))  Note: Processor sets
End Process

Note: =====================================================================
Note: WINDOWS PLATFORM TESTS
Note: =====================================================================

Process called "test_windows_x64_syscalls" returns Nothing:
    @TestCases
    - Verify Windows x64 Native API syscalls
    - Check syscall number stability across versions
    - Validate Windows calling convention
    - Ensure proper NTSTATUS handling
    @End TestCases
    
    Let platform be WindowsX64.create_windows_x64_platform()
    
    Note: Test Native API syscalls (Nt* functions)
    Test.assert_true(platform.supports_syscall("NtCreateFile"))
    Test.assert_true(platform.supports_syscall("NtReadFile"))
    Test.assert_true(platform.supports_syscall("NtWriteFile"))
    Test.assert_true(platform.supports_syscall("NtClose"))
    Test.assert_true(platform.supports_syscall("NtQueryInformationProcess"))
    Test.assert_true(platform.supports_syscall("NtAllocateVirtualMemory"))
    Test.assert_true(platform.supports_syscall("NtFreeVirtualMemory"))
    
    Note: Syscall numbers vary by Windows version
    Let create_file_num be platform.get_syscall_number("NtCreateFile")
    Test.assert_greater_than(create_file_num, 0)
    
    Note: Test Windows doesn't support POSIX syscalls directly
    Test.assert_false(platform.supports_syscall(Registry.SYSCALL_FORK))
    Test.assert_false(platform.supports_syscall(Registry.SYSCALL_EXECVE))
End Process

Process called "test_windows_x64_calling_convention" returns Nothing:
    @TestCases
    - Verify Windows x64 calling convention
    - Check register allocation (rcx, rdx, r8, r9)
    - Validate shadow space requirement
    - Ensure proper stack alignment
    @End TestCases
    
    Let platform be WindowsX64.create_windows_x64_platform()
    Let convention be platform.get_calling_convention()
    
    Note: Windows x64 uses different registers than Linux
    Test.assert_equals(convention.param_registers[0], "rcx")
    Test.assert_equals(convention.param_registers[1], "rdx")
    Test.assert_equals(convention.param_registers[2], "r8")
    Test.assert_equals(convention.param_registers[3], "r9")
    
    Note: Verify shadow space requirement (32 bytes)
    Test.assert_equals(convention.shadow_space_size, 32)
    
    Note: Verify return register
    Test.assert_equals(convention.return_register, "rax")
    
    Note: Verify stack alignment
    Test.assert_equals(convention.stack_alignment, 16)
    
    Note: Windows preserves different registers
    Test.assert_contains(convention.preserved_registers, "rbx")
    Test.assert_contains(convention.preserved_registers, "rbp")
    Test.assert_contains(convention.preserved_registers, "rdi")
    Test.assert_contains(convention.preserved_registers, "rsi")
    Test.assert_contains(convention.preserved_registers, "r12")
    Test.assert_contains(convention.preserved_registers, "r13")
    Test.assert_contains(convention.preserved_registers, "r14")
    Test.assert_contains(convention.preserved_registers, "r15")
End Process

Note: =====================================================================
Note: CROSS-PLATFORM CONSISTENCY TESTS
Note: =====================================================================

Process called "test_common_syscall_availability" returns Nothing:
    @TestCases
    - Verify common syscalls across POSIX platforms
    - Check platform-specific exclusions
    - Validate syscall compatibility matrix
    - Ensure proper fallback mechanisms
    @End TestCases
    
    Let posix_platforms be [
        LinuxX64.create_linux_x64_platform(),
        DarwinX64.create_darwin_x64_platform(),
        FreeBSDX64.create_freebsd_x64_platform(),
        OpenBSDX64.create_openbsd_x64_platform(),
        NetBSDX64.create_netbsd_x64_platform()
    ]
    
    Let common_syscalls be [
        Registry.SYSCALL_READ,
        Registry.SYSCALL_WRITE,
        Registry.SYSCALL_OPEN,
        Registry.SYSCALL_CLOSE,
        Registry.SYSCALL_LSEEK,
        Registry.SYSCALL_MMAP,
        Registry.SYSCALL_MUNMAP,
        Registry.SYSCALL_EXIT
    ]
    
    For Each platform in posix_platforms:
        For Each syscall in common_syscalls:
            Test.assert_true(
                platform.supports_syscall(syscall),
                "Platform should support " + syscall
            )
            
            Let syscall_num be platform.get_syscall_number(syscall)
            Test.assert_not_equals(syscall_num, -1)
        End For
    End For
End Process

Process called "test_platform_specific_features" returns Nothing:
    @TestCases
    - Verify platform-specific optimizations
    - Check VDSO support on Linux
    - Validate fast syscall paths
    - Ensure architecture optimizations
    @End TestCases
    
    Let linux_platform be LinuxX64.create_linux_x64_platform()
    
    Note: Test Linux VDSO support
    Test.assert_true(linux_platform.supports_vdso())
    Test.assert_true(linux_platform.has_vdso_function("clock_gettime"))
    Test.assert_true(linux_platform.has_vdso_function("gettimeofday"))
    Test.assert_true(linux_platform.has_vdso_function("getcpu"))
    
    Note: Test io_uring support on Linux
    Test.assert_true(linux_platform.supports_io_uring())
    
    Let darwin_platform be DarwinX64.create_darwin_x64_platform()
    
    Note: Test Darwin commpage optimization
    Test.assert_true(darwin_platform.supports_commpage())
    
    Let windows_platform be WindowsX64.create_windows_x64_platform()
    
    Note: Test Windows fast syscall mechanism
    Test.assert_true(windows_platform.supports_fast_syscall())
End Process

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "get_error_value" that takes error_map as Internals.InternalMap, name as String returns Integer:
    Let name_ptr be Internals.string_to_ptr(name)
    Return Internals.internal_map_get(error_map, name_ptr)
End Process

Process called "get_all_error_names" that takes error_map as Internals.InternalMap returns Internals.InternalArray:
    Return Internals.internal_map_keys(error_map)
End Process

Note: =====================================================================
Note: TEST RUNNER
Note: =====================================================================

Process called "run_all_platform_syscall_tests" returns Nothing:
    @TestCases
    Complete test coverage for platform-specific syscalls:
    - Linux x64/ARM64 implementations
    - Darwin x64/ARM64 implementations
    - FreeBSD x64 implementation
    - OpenBSD x64 implementation
    - NetBSD x64 implementation
    - Windows x64 implementation
    - Cross-platform consistency
    - Platform-specific features
    @End TestCases
    
    Print("Testing Platform-Specific Syscalls...")
    Print("=====================================")
    
    Print("Testing Linux x64...")
    test_linux_x64_syscall_numbers()
    test_linux_x64_calling_convention()
    test_linux_x64_error_mapping()
    
    Print("Testing Darwin platforms...")
    test_darwin_x64_syscall_numbers()
    test_darwin_arm64_calling_convention()
    
    Print("Testing BSD platforms...")
    test_freebsd_x64_syscalls()
    test_openbsd_x64_syscalls()
    test_netbsd_x64_syscalls()
    
    Print("Testing Windows x64...")
    test_windows_x64_syscalls()
    test_windows_x64_calling_convention()
    
    Print("Testing cross-platform consistency...")
    test_common_syscall_availability()
    test_platform_specific_features()
    
    Print("All platform syscall tests passed!")
End Process

@Performance_Hints
These tests should be optimized for:
- Fast platform configuration validation
- Efficient syscall number lookups
- Parallel platform testing where possible
- Minimal memory allocation during tests
@End Performance_Hints

@Security_Scope
The platform syscall tests operate with:
- Read-only access to platform definitions
- No actual syscall execution
- Safe validation of security features
- Platform isolation during testing
@End Security_Scope