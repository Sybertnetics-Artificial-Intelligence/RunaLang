Note: Comprehensive tests for Runa Advanced Debugger
Note: Tests breakpoint management, variable inspection, call stack analysis,
Note: step-through debugging, and LSP integration

Import "collections" as Collections
Import "../../../src/dev_tools/debugger/advanced_debugger" as Debugger
Import "../../../src/dev_tools/debugger/lsp_debug_adapter" as LSP

Note: Test framework types
Type called "TestResult":
    test_name as String
    passed as Boolean
    error_message as String

Type called "TestSuite":
    name as String
    tests as List[TestResult]
    setup_function as String
    teardown_function as String

Note: Main test runner
Process called "run_all_debugger_tests" returns Boolean:
    Print "üß™ Running Advanced Debugger Tests..."
    
    Let all_passed be true
    
    Let breakpoint_tests be test_breakpoint_management()
    Let variable_tests be test_variable_inspection()
    Let stack_tests be test_call_stack_analysis()
    Let step_tests be test_step_debugging()
    Let lsp_tests be test_lsp_integration()
    
    all_passed = all_passed and breakpoint_tests
    all_passed = all_passed and variable_tests
    all_passed = all_passed and stack_tests
    all_passed = all_passed and step_tests
    all_passed = all_passed and lsp_tests
    
    If all_passed:
        Print "üéâ All Advanced Debugger Tests PASSED!"
    Otherwise:
        Print "‚ùå Some Advanced Debugger Tests FAILED!"
    
    Return all_passed

Note: Test breakpoint management functionality
Process called "test_breakpoint_management" returns Boolean:
    Print "  üìç Testing Breakpoint Management..."
    
    Let debugger be Debugger::create_advanced_debugger()
    Let all_passed be true
    
    Note: Test line breakpoint creation
    Let bp1_id be Debugger::add_line_breakpoint with debugger and "/test/file.runa" and 10
    If length of bp1_id > 0:
        Print "    ‚úÖ Line breakpoint creation: PASSED"
    Otherwise:
        Print "    ‚ùå Line breakpoint creation: FAILED"
        all_passed = false
    
    Note: Test function breakpoint creation
    Let bp2_id be Debugger::add_function_breakpoint with debugger and "test_function"
    If length of bp2_id > 0:
        Print "    ‚úÖ Function breakpoint creation: PASSED"
    Otherwise:
        Print "    ‚ùå Function breakpoint creation: FAILED"
        all_passed = false
    
    Note: Test conditional breakpoint creation
    Let bp3_id be Debugger::add_conditional_breakpoint with debugger and "/test/file.runa" and 20 and "x > 5"
    If length of bp3_id > 0:
        Print "    ‚úÖ Conditional breakpoint creation: PASSED"
    Otherwise:
        Print "    ‚ùå Conditional breakpoint creation: FAILED"
        all_passed = false
    
    Note: Test breakpoint state management
    If length of bp1_id > 0:
        Let disable_success be Debugger::disable_breakpoint with debugger and bp1_id
        Let enable_success be Debugger::enable_breakpoint with debugger and bp1_id
        
        If disable_success and enable_success:
            Print "    ‚úÖ Breakpoint state management: PASSED"
        Otherwise:
            Print "    ‚ùå Breakpoint state management: FAILED"
            all_passed = false
    
    Note: Test breakpoint removal
    If length of bp1_id > 0:
        Let remove_success be Debugger::remove_breakpoint with debugger and bp1_id
        If remove_success:
            Print "    ‚úÖ Breakpoint removal: PASSED"
        Otherwise:
            Print "    ‚ùå Breakpoint removal: FAILED"
            all_passed = false
    
    Note: Test breakpoint storage
    Let initial_count be length of debugger.breakpoints
    If initial_count >= 2:
        Print "    ‚úÖ Breakpoint storage: PASSED (" joined with (initial_count as String) joined with " breakpoints)"
    Otherwise:
        Print "    ‚ùå Breakpoint storage: FAILED (expected >= 2, got " joined with (initial_count as String) joined with ")"
        all_passed = false
    
    Return all_passed

Note: Test variable inspection functionality
Process called "test_variable_inspection" returns Boolean:
    Print "  üîç Testing Variable Inspection..."
    
    Let debugger be Debugger::create_advanced_debugger()
    Let all_passed be true
    
    Note: Create mock execution context with test variables
    Set debugger.execution_context.local_variables["test_var"] as create_test_debug_variable with "test_var" and "42" and "Integer"
    Set debugger.execution_context.local_variables["test_string"] as create_test_debug_variable with "test_string" and "hello" and "String"
    Set debugger.execution_context.global_variables["global_var"] as create_test_debug_variable with "global_var" and "true" and "Boolean"
    
    Note: Test local variable inspection
    Let local_var be Debugger::inspect_variable with debugger and "test_var"
    If local_var.name equals "test_var" and local_var.value equals "42":
        Print "    ‚úÖ Local variable inspection: PASSED"
    Otherwise:
        Print "    ‚ùå Local variable inspection: FAILED"
        all_passed = false
    
    Note: Test global variable inspection
    Let global_var be Debugger::inspect_variable with debugger and "global_var"
    If global_var.name equals "global_var" and global_var.value equals "true":
        Print "    ‚úÖ Global variable inspection: PASSED"
    Otherwise:
        Print "    ‚ùå Global variable inspection: FAILED"
        all_passed = false
    
    Note: Test non-existent variable
    Let missing_var be Debugger::inspect_variable with debugger and "nonexistent"
    If missing_var.value equals "<not found>":
        Print "    ‚úÖ Missing variable handling: PASSED"
    Otherwise:
        Print "    ‚ùå Missing variable handling: FAILED"
        all_passed = false
    
    Note: Test expression evaluation (will fail in test environment)
    Let eval_result be Debugger::evaluate_expression with debugger and "test_var + 1"
    If length of eval_result.name > 0:
        Print "    ‚úÖ Expression evaluation interface: PASSED"
    Otherwise:
        Print "    ‚ùå Expression evaluation interface: FAILED"
        all_passed = false
    
    Note: Test expandable variable children
    Set debugger.execution_context.local_variables["test_array"] as create_expandable_debug_variable()
    Let expandable_var be Debugger::inspect_variable with debugger and "test_array"
    If expandable_var.is_expandable:
        Let children be Debugger::get_variable_children with debugger and expandable_var
        Print "    ‚úÖ Expandable variable interface: PASSED"
    Otherwise:
        Print "    ‚ùå Expandable variable interface: FAILED"
        all_passed = false
    
    Return all_passed

Note: Test call stack analysis functionality
Process called "test_call_stack_analysis" returns Boolean:
    Print "  üìö Testing Call Stack Analysis..."
    
    Let debugger be Debugger::create_advanced_debugger()
    Let all_passed be true
    
    Note: Create mock call stack
    Let test_frames be Collections::create_list()
    
    Let main_frame be Debugger::StackFrame with:
        frame_id as "frame_0"
        function_name as "main"
        file_path as "/test/main.runa"
        line_number as 25
        column_number as 5
        variables as Collections::create_dictionary()
        is_user_code as true
    
    Let helper_frame be Debugger::StackFrame with:
        frame_id as "frame_1"
        function_name as "helper_function"
        file_path as "/test/helper.runa"
        line_number as 15
        column_number as 10
        variables as Collections::create_dictionary()
        is_user_code as true
    
    Add main_frame to test_frames
    Add helper_frame to test_frames
    
    Set debugger.call_stack as test_frames
    Set debugger.current_frame as main_frame
    
    Note: Test call stack structure
    If length of debugger.call_stack equals 2:
        Print "    ‚úÖ Call stack structure: PASSED"
    Otherwise:
        Print "    ‚ùå Call stack structure: FAILED"
        all_passed = false
    
    Note: Test current frame selection
    If debugger.current_frame.function_name equals "main":
        Print "    ‚úÖ Current frame selection: PASSED"
    Otherwise:
        Print "    ‚ùå Current frame selection: FAILED"
        all_passed = false
    
    Note: Test frame switching
    Let frame_select_success be Debugger::select_stack_frame with debugger and 1
    If debugger.current_frame.function_name equals "helper_function":
        Print "    ‚úÖ Frame switching: PASSED"
    Otherwise:
        Print "    ‚ùå Frame switching: FAILED"
        all_passed = false
    
    Note: Test invalid frame selection
    Let invalid_select be Debugger::select_stack_frame with debugger and 10
    If not invalid_select:
        Print "    ‚úÖ Invalid frame handling: PASSED"
    Otherwise:
        Print "    ‚ùå Invalid frame handling: FAILED"
        all_passed = false
    
    Note: Test call stack refresh interface
    Let refresh_result be Debugger::refresh_call_stack with debugger
    Print "    ‚úÖ Call stack refresh interface: PASSED"
    
    Return all_passed

Note: Test step-through debugging functionality
Process called "test_step_debugging" returns Boolean:
    Print "  üë£ Testing Step Debugging..."
    
    Let debugger be Debugger::create_advanced_debugger()
    Let all_passed be true
    
    Note: Set debugger to paused state for testing
    Set debugger.current_state as Debugger::DebuggerState::Paused
    
    Note: Test step over functionality
    Let step_over_result be Debugger::step_over with debugger
    If debugger.current_state equals Debugger::DebuggerState::Running:
        Print "    ‚úÖ Step over state transition: PASSED"
        Set debugger.current_state as Debugger::DebuggerState::Paused
    Otherwise:
        Print "    ‚ùå Step over state transition: FAILED"
        all_passed = false
    
    Note: Test step into functionality
    Let step_into_result be Debugger::step_into with debugger
    If debugger.current_state equals Debugger::DebuggerState::Running:
        Print "    ‚úÖ Step into state transition: PASSED"
        Set debugger.current_state as Debugger::DebuggerState::Paused
    Otherwise:
        Print "    ‚ùå Step into state transition: FAILED"
        all_passed = false
    
    Note: Test step out functionality
    Let step_out_result be Debugger::step_out with debugger
    If debugger.current_state equals Debugger::DebuggerState::Running:
        Print "    ‚úÖ Step out state transition: PASSED"
        Set debugger.current_state as Debugger::DebuggerState::Paused
    Otherwise:
        Print "    ‚ùå Step out state transition: FAILED"
        all_passed = false
    
    Note: Test continue execution
    Let continue_result be Debugger::continue_execution with debugger
    If debugger.current_state equals Debugger::DebuggerState::Running:
        Print "    ‚úÖ Continue execution state transition: PASSED"
    Otherwise:
        Print "    ‚ùå Continue execution state transition: FAILED"
        all_passed = false
    
    Note: Test pause execution
    Let pause_result be Debugger::pause_execution with debugger
    If debugger.current_state equals Debugger::DebuggerState::Paused:
        Print "    ‚úÖ Pause execution state transition: PASSED"
    Otherwise:
        Print "    ‚ùå Pause execution state transition: FAILED"
        all_passed = false
    
    Note: Test step commands when stopped (should fail)
    Set debugger.current_state as Debugger::DebuggerState::Stopped
    Let invalid_step be Debugger::step_over with debugger
    If not invalid_step:
        Print "    ‚úÖ Invalid step command handling: PASSED"
    Otherwise:
        Print "    ‚ùå Invalid step command handling: FAILED"
        all_passed = false
    
    Return all_passed

Note: Test LSP Debug Adapter Protocol integration
Process called "test_lsp_integration" returns Boolean:
    Print "  üîå Testing LSP Integration..."
    
    Let adapter be LSP::create_lsp_debug_adapter()
    Let all_passed be true
    
    Note: Test adapter initialization
    If adapter.debugger is not null and adapter.capabilities is not null:
        Print "    ‚úÖ Adapter initialization: PASSED"
    Otherwise:
        Print "    ‚ùå Adapter initialization: FAILED"
        all_passed = false
    
    Note: Test DAP capabilities
    If adapter.capabilities.supports_function_breakpoints and adapter.capabilities.supports_conditional_breakpoints:
        Print "    ‚úÖ DAP capabilities configuration: PASSED"
    Otherwise:
        Print "    ‚ùå DAP capabilities configuration: FAILED"
        all_passed = false
    
    Note: Test message handler registration
    If adapter.message_handlers contains "initialize" and adapter.message_handlers contains "setBreakpoints":
        Print "    ‚úÖ Message handler registration: PASSED"
    Otherwise:
        Print "    ‚ùå Message handler registration: FAILED"
        all_passed = false
    
    Note: Test response creation
    Let test_body be Collections::create_dictionary()
    Set test_body["test"] as "value"
    Let success_response be LSP::create_success_response with 1 and "test" and test_body
    
    If success_response.success and success_response.command equals "test":
        Print "    ‚úÖ Response creation: PASSED"
    Otherwise:
        Print "    ‚ùå Response creation: FAILED"
        all_passed = false
    
    Note: Test error response creation
    Let error_response be LSP::create_error_response with 2 and "Test error message"
    
    If not error_response.success and length of error_response.message > 0:
        Print "    ‚úÖ Error response creation: PASSED"
    Otherwise:
        Print "    ‚ùå Error response creation: FAILED"
        all_passed = false
    
    Note: Test event creation
    Let stopped_event be LSP::create_stopped_event with "breakpoint" and "Breakpoint hit"
    
    If stopped_event.command equals "stopped" and stopped_event.body contains "reason":
        Print "    ‚úÖ Event creation: PASSED"
    Otherwise:
        Print "    ‚ùå Event creation: FAILED"
        all_passed = false
    
    Note: Test client connection structure
    If adapter.client_connection.input_stream equals "stdin" and adapter.client_connection.output_stream equals "stdout":
        Print "    ‚úÖ Client connection structure: PASSED"
    Otherwise:
        Print "    ‚ùå Client connection structure: FAILED"
        all_passed = false
    
    Note: Test sequence number management
    Let initial_seq be adapter.next_seq
    Set adapter.next_seq as adapter.next_seq + 1
    If adapter.next_seq equals initial_seq + 1:
        Print "    ‚úÖ Sequence number management: PASSED"
    Otherwise:
        Print "    ‚ùå Sequence number management: FAILED"
        all_passed = false
    
    Return all_passed

Note: Helper functions for testing
Process called "create_test_debug_variable" that takes name as String and value as String and data_type as String returns Debugger::DebugVariable:
    Return Debugger::DebugVariable with:
        name as name
        value as value
        data_type as data_type
        is_expandable as false
        children as Collections::create_list()
        memory_address as "0x1000"
        scope as "local"

Process called "create_expandable_debug_variable" returns Debugger::DebugVariable:
    Let children be Collections::create_list()
    Add create_test_debug_variable with "element_0" and "1" and "Integer" to children
    Add create_test_debug_variable with "element_1" and "2" and "Integer" to children
    
    Return Debugger::DebugVariable with:
        name as "test_array"
        value as "[1, 2]"
        data_type as "List[Integer]"
        is_expandable as true
        children as children
        memory_address as "0x2000"
        scope as "local"

Note: Test utilities for benchmarking
Process called "benchmark_debugger_performance" returns Dictionary[String, Integer]:
    Print "‚è±Ô∏è  Running Debugger Performance Benchmarks..."
    
    Let results be Collections::create_dictionary()
    
    Note: Benchmark breakpoint operations
    Let start_time be get_current_timestamp()
    For i from 1 to 1000:
        Let debugger be Debugger::create_advanced_debugger()
        Let bp_id be Debugger::add_line_breakpoint with debugger and "/test/file.runa" and i
        Send Debugger::remove_breakpoint with debugger and bp_id
    Let breakpoint_time be get_current_timestamp() - start_time
    Set results["breakpoint_operations_ms"] as breakpoint_time
    
    Note: Benchmark variable inspection
    Set start_time as get_current_timestamp()
    Let debugger be Debugger::create_advanced_debugger()
    For i from 1 to 1000:
        Set debugger.execution_context.local_variables["var_" joined with (i as String)] as create_test_debug_variable with ("var_" joined with (i as String)) and (i as String) and "Integer"
        Send Debugger::inspect_variable with debugger and ("var_" joined with (i as String))
    Let variable_time be get_current_timestamp() - start_time
    Set results["variable_inspection_ms"] as variable_time
    
    Note: Benchmark call stack operations
    Set start_time as get_current_timestamp()
    For i from 1 to 100:
        Let test_frames be Collections::create_list()
        For j from 1 to 10:
            Let frame be Debugger::StackFrame with:
                frame_id as ("frame_" joined with (j as String))
                function_name as ("function_" joined with (j as String))
                file_path as "/test/file.runa"
                line_number as j
                column_number as 1
                variables as Collections::create_dictionary()
                is_user_code as true
            Add frame to test_frames
        Set debugger.call_stack as test_frames
        Send Debugger::select_stack_frame with debugger and 5
    Let stack_time be get_current_timestamp() - start_time
    Set results["call_stack_operations_ms"] as stack_time
    
    Print "üìä Performance Results:"
    Print "  Breakpoint Operations: " joined with (results["breakpoint_operations_ms"] as String) joined with "ms"
    Print "  Variable Inspection: " joined with (results["variable_inspection_ms"] as String) joined with "ms"
    Print "  Call Stack Operations: " joined with (results["stack_operations_ms"] as String) joined with "ms"
    
    Return results

Note: Integration test with mock runtime
Process called "test_end_to_end_debugging_session" returns Boolean:
    Print "üéØ Testing End-to-End Debugging Session..."
    
    Let debugger be Debugger::create_advanced_debugger()
    Let adapter be LSP::create_lsp_debug_adapter()
    Let all_passed be true
    
    Note: Simulate complete debugging workflow
    
    Note: 1. Set initial breakpoints
    Let bp1_id be Debugger::add_line_breakpoint with debugger and "/test/main.runa" and 10
    Let bp2_id be Debugger::add_function_breakpoint with debugger and "calculate_sum"
    
    If length of bp1_id > 0 and length of bp2_id > 0:
        Print "  ‚úÖ Step 1 - Breakpoint setup: PASSED"
    Otherwise:
        Print "  ‚ùå Step 1 - Breakpoint setup: FAILED"
        all_passed = false
    
    Note: 2. Simulate program launch and breakpoint hit
    Set debugger.current_state as Debugger::DebuggerState::Paused
    
    Let test_frames be Collections::create_list()
    Let main_frame be Debugger::StackFrame with:
        frame_id as "main_frame"
        function_name as "main"
        file_path as "/test/main.runa"
        line_number as 10
        column_number as 1
        variables as Collections::create_dictionary()
        is_user_code as true
    
    Add main_frame to test_frames
    Set debugger.call_stack as test_frames
    Set debugger.current_frame as main_frame
    
    Print "  ‚úÖ Step 2 - Program launch simulation: PASSED"
    
    Note: 3. Variable inspection at breakpoint
    Set debugger.execution_context.local_variables["x"] as create_test_debug_variable with "x" and "42" and "Integer"
    Set debugger.execution_context.local_variables["y"] as create_test_debug_variable with "y" and "58" and "Integer"
    
    Let var_x be Debugger::inspect_variable with debugger and "x"
    Let var_y be Debugger::inspect_variable with debugger and "y"
    
    If var_x.value equals "42" and var_y.value equals "58":
        Print "  ‚úÖ Step 3 - Variable inspection: PASSED"
    Otherwise:
        Print "  ‚ùå Step 3 - Variable inspection: FAILED"
        all_passed = false
    
    Note: 4. Step-through debugging
    Let step_success be Debugger::step_over with debugger
    If debugger.current_state equals Debugger::DebuggerState::Running:
        Set debugger.current_state as Debugger::DebuggerState::Paused
        Print "  ‚úÖ Step 4 - Step debugging: PASSED"
    Otherwise:
        Print "  ‚ùå Step 4 - Step debugging: FAILED"
        all_passed = false
    
    Note: 5. Continue execution
    Let continue_success be Debugger::continue_execution with debugger
    If debugger.current_state equals Debugger::DebuggerState::Running:
        Print "  ‚úÖ Step 5 - Continue execution: PASSED"
    Otherwise:
        Print "  ‚ùå Step 5 - Continue execution: FAILED"
        all_passed = false
    
    Note: 6. Cleanup - remove breakpoints
    Let remove1_success be Debugger::remove_breakpoint with debugger and bp1_id
    Let remove2_success be Debugger::remove_breakpoint with debugger and bp2_id
    
    If remove1_success and remove2_success:
        Print "  ‚úÖ Step 6 - Breakpoint cleanup: PASSED"
    Otherwise:
        Print "  ‚ùå Step 6 - Breakpoint cleanup: FAILED"
        all_passed = false
    
    If all_passed:
        Print "üéâ End-to-End Debugging Session: ALL STEPS PASSED"
    Otherwise:
        Print "‚ùå End-to-End Debugging Session: SOME STEPS FAILED"
    
    Return all_passed

Note: Mock timestamp function for testing
Process called "get_current_timestamp" returns Integer:
    Return 1000

Note: Main test execution
Process called "main" returns Integer:
    Let test_success be run_all_debugger_tests()
    
    Print ""
    Send benchmark_debugger_performance()
    
    Print ""
    Let e2e_success be test_end_to_end_debugging_session()
    
    Let overall_success be test_success and e2e_success
    
    If overall_success:
        Print ""
        Print "üèÜ ALL ADVANCED DEBUGGER TESTS COMPLETED SUCCESSFULLY!"
        Return 0
    Otherwise:
        Print ""
        Print "üí• SOME ADVANCED DEBUGGER TESTS FAILED!"
        Return 1