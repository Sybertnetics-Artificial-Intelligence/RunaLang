Note:
tests/unit/libraries/math/analysis/real_test.runa
Unit Tests for Math Analysis Real Analysis Module

This test suite provides comprehensive testing for the real analysis module including:
- Sequence convergence analysis and properties
- Series convergence tests and summation
- Limit theory and epsilon-delta definitions
- Continuity testing and discontinuity classification
- Differentiation theory and derivative computation
- Integration theory (Riemann and Lebesgue)
- Uniform convergence and function sequences
- Metric spaces and completeness properties
- Compactness and connectedness analysis
- Function series and power series analysis
- Approximation theory and polynomial approximation
:End Note

Import "stdlib/math/analysis/real" as RealAnalysis
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "create_arithmetic_sequence" that takes first_term as String, common_difference as String, num_terms as Integer returns RealAnalysis.Sequence:
    Note: Create an arithmetic sequence for testing
    Let terms be List[String]()
    For i from 0 to num_terms - 1:
        Let term be MathOps.add(first_term, MathOps.multiply(common_difference, ToString(i), 15).result_value, 15).result_value
        Set terms to terms.append(term)
    
    Let sequence be RealAnalysis.Sequence()
    Set sequence.terms to terms
    Set sequence.is_monotonic to true
    Set sequence.is_bounded to true
    
    Return sequence

Process called "create_geometric_sequence" that takes first_term as String, common_ratio as String, num_terms as Integer returns RealAnalysis.Sequence:
    Note: Create a geometric sequence for testing
    Let terms be List[String]()
    Let current_term be first_term
    
    For i from 0 to num_terms - 1:
        Set terms to terms.append(current_term)
        Set current_term to MathOps.multiply(current_term, common_ratio, 15).result_value
    
    Let sequence be RealAnalysis.Sequence()
    Set sequence.terms to terms
    Set sequence.is_monotonic to (Parse common_ratio as Float) >= 1.0
    
    Return sequence

Process called "create_test_function" that takes expression as String, domain_start as String, domain_end as String returns RealAnalysis.RealFunction:
    Note: Create a real function for testing
    Let function be RealAnalysis.RealFunction()
    Set function.expression to expression
    Set function.domain to Dictionary[String, String]()
    Set function.domain["start"] to domain_start
    Set function.domain["end"] to domain_end
    Set function.is_continuous to true
    Set function.is_differentiable to true
    Set function.is_integrable to true
    
    Return function

Process called "assert_approximately_equal" that takes value1 as String, value2 as String, tolerance as Float returns Boolean:
    Note: Assert two values are approximately equal within tolerance
    Let val1 be Parse value1 as Float
    Let val2 be Parse value2 as Float
    Let difference be AbsoluteValue(val1 - val2)
    Assert.IsTrue(difference <= tolerance)
    Return true

Process called "generate_convergent_series_terms" that takes num_terms as Integer returns List[String]:
    Note: Generate terms for a convergent series (harmonic series with p > 1)
    Let terms be List[String]()
    For n from 1 to num_terms:
        Let term be MathOps.divide("1", MathOps.power(ToString(n), "2", 15).result_value, 15).result_value
        Set terms to terms.append(term)
    Return terms

Process called "generate_divergent_series_terms" that takes num_terms as Integer returns List[String]:
    Note: Generate terms for a divergent series (harmonic series)
    Let terms be List[String]()
    For n from 1 to num_terms:
        Let term be MathOps.divide("1", ToString(n), 15).result_value
        Set terms to terms.append(term)
    Return terms

Note: =====================================================================
Note: SEQUENCE CONVERGENCE TESTS
Note: =====================================================================

Process called "test_sequence_convergence_arithmetic" that takes no parameters returns Boolean:
    Note: Test convergence of arithmetic sequences
    Let sequence be create_arithmetic_sequence("1", "0", 50)
    Let is_convergent be RealAnalysis.test_sequence_convergence(sequence)
    Assert.IsTrue(is_convergent)
    
    Let limit be RealAnalysis.compute_sequence_limit(sequence)
    Assert.AreEqual(limit, "1")
    Return true

Process called "test_sequence_convergence_geometric" that takes no parameters returns Boolean:
    Note: Test convergence of geometric sequences
    Let convergent_sequence be create_geometric_sequence("1", "0.5", 50)
    Let is_convergent be RealAnalysis.test_sequence_convergence(convergent_sequence)
    Assert.IsTrue(is_convergent)
    
    Let limit be RealAnalysis.compute_sequence_limit(convergent_sequence)
    Assert.IsTrue(assert_approximately_equal(limit, "0", 1e-10))
    
    Let divergent_sequence be create_geometric_sequence("1", "2", 20)
    Let is_divergent be RealAnalysis.test_sequence_convergence(divergent_sequence)
    Assert.IsFalse(is_divergent)
    Return true

Process called "test_sequence_monotonic_bounded" that takes no parameters returns Boolean:
    Note: Test monotonic bounded sequence theorem
    Let sequence be RealAnalysis.Sequence()
    Set sequence.terms to ["1", "1.4", "1.41", "1.414", "1.4142", "1.41421"]
    Set sequence.is_monotonic to true
    Set sequence.is_bounded to true
    
    Let is_convergent be RealAnalysis.test_sequence_convergence(sequence)
    Assert.IsTrue(is_convergent)
    Return true

Process called "test_cauchy_criterion" that takes no parameters returns Boolean:
    Note: Test Cauchy criterion for sequence convergence
    Let sequence be create_geometric_sequence("1", "0.1", 100)
    Let is_cauchy be RealAnalysis.test_cauchy_criterion(sequence, "1e-6")
    Assert.IsTrue(is_cauchy)
    
    Let limit be RealAnalysis.compute_sequence_limit(sequence)
    Assert.IsTrue(assert_approximately_equal(limit, "0", 1e-10))
    Return true

Process called "test_sequence_limit_properties" that takes no parameters returns Boolean:
    Note: Test properties of sequence limits
    Let seq1 be create_arithmetic_sequence("2", "0", 20)
    Let seq2 be create_arithmetic_sequence("3", "0", 20)
    
    Let limit1 be RealAnalysis.compute_sequence_limit(seq1)
    Let limit2 be RealAnalysis.compute_sequence_limit(seq2)
    
    Assert.AreEqual(limit1, "2")
    Assert.AreEqual(limit2, "3")
    
    Note: Test limit of sum equals sum of limits
    Let combined_terms be List[String]()
    For i from 0 to 19:
        Let sum_term be MathOps.add(seq1.terms[i], seq2.terms[i], 15).result_value
        Set combined_terms to combined_terms.append(sum_term)
    
    Let sum_sequence be RealAnalysis.Sequence()
    Set sum_sequence.terms to combined_terms
    Set sum_sequence.is_convergent to true
    
    Let sum_limit be RealAnalysis.compute_sequence_limit(sum_sequence)
    Assert.AreEqual(sum_limit, "5")
    Return true

Note: =====================================================================
Note: SERIES CONVERGENCE TESTS
Note: =====================================================================

Process called "test_series_convergence_geometric" that takes no parameters returns Boolean:
    Note: Test convergence of geometric series
    Let convergent_terms be List[String]()
    For n from 0 to 99:
        Let term be MathOps.power("0.5", ToString(n), 15).result_value
        Set convergent_terms to convergent_terms.append(term)
    
    Let series be RealAnalysis.Series()
    Set series.terms to convergent_terms
    
    Let is_convergent be RealAnalysis.test_series_convergence(series)
    Assert.IsTrue(is_convergent)
    
    Let sum be RealAnalysis.compute_series_sum(series)
    Assert.IsTrue(assert_approximately_equal(sum, "2", 1e-6))
    Return true

Process called "test_series_convergence_harmonic" that takes no parameters returns Boolean:
    Note: Test divergence of harmonic series
    Let harmonic_terms be generate_divergent_series_terms(100)
    
    Let series be RealAnalysis.Series()
    Set series.terms to harmonic_terms
    
    Let is_convergent be RealAnalysis.test_series_convergence(series)
    Assert.IsFalse(is_convergent)
    Return true

Process called "test_series_convergence_p_series" that takes no parameters returns Boolean:
    Note: Test convergence of p-series with p > 1
    Let convergent_p_terms be generate_convergent_series_terms(100)
    
    Let series be RealAnalysis.Series()
    Set series.terms to convergent_p_terms
    
    Let is_convergent be RealAnalysis.test_series_convergence(series)
    Assert.IsTrue(is_convergent)
    
    Note: Should converge to π²/6 ≈ 1.644934
    Let sum be RealAnalysis.compute_series_sum(series)
    Assert.IsTrue(assert_approximately_equal(sum, "1.644934", 1e-3))
    Return true

Process called "test_series_ratio_test" that takes no parameters returns Boolean:
    Note: Test ratio test for series convergence
    Let factorial_terms be List[String]()
    For n from 1 to 20:
        Let term be MathOps.divide(MathOps.power("2", ToString(n), 15).result_value, MathOps.factorial(n).factorial_value, 15).result_value
        Set factorial_terms to factorial_terms.append(term)
    
    Let series be RealAnalysis.Series()
    Set series.terms to factorial_terms
    
    Let ratio_test_result be RealAnalysis.ratio_test(series)
    Assert.IsTrue(ratio_test_result.is_convergent)
    Assert.IsTrue(Parse ratio_test_result.limit as Float < 1.0)
    Return true

Process called "test_series_root_test" that takes no parameters returns Boolean:
    Note: Test root test for series convergence
    Let terms be List[String]()
    For n from 1 to 50:
        Let term be MathOps.power(MathOps.divide("2", ToString(n), 15).result_value, ToString(n), 15).result_value
        Set terms to terms.append(term)
    
    Let series be RealAnalysis.Series()
    Set series.terms to terms
    
    Let root_test_result be RealAnalysis.root_test(series)
    Assert.IsTrue(root_test_result.is_convergent)
    Return true

Process called "test_alternating_series" that takes no parameters returns Boolean:
    Note: Test alternating series test
    Let alternating_terms be List[String]()
    For n from 1 to 100:
        Let sign be If (n % 2 == 1) then "1" else "-1"
        Let magnitude be MathOps.divide("1", ToString(n), 15).result_value
        Let term be MathOps.multiply(sign, magnitude, 15).result_value
        Set alternating_terms to alternating_terms.append(term)
    
    Let series be RealAnalysis.Series()
    Set series.terms to alternating_terms
    
    Let is_convergent be RealAnalysis.test_series_convergence(series)
    Assert.IsTrue(is_convergent)
    
    Note: Should converge to ln(2) ≈ 0.693147
    Let sum be RealAnalysis.compute_series_sum(series)
    Assert.IsTrue(assert_approximately_equal(sum, "0.693147", 1e-3))
    Return true

Note: =====================================================================
Note: POWER SERIES TESTS
Note: =====================================================================

Process called "test_power_series_radius_of_convergence" that takes no parameters returns Boolean:
    Note: Test radius of convergence calculation
    Let coefficients be ["1", "1", "0.5", "0.166667", "0.041667", "0.008333"]
    Let center be "0"
    
    Let analysis be RealAnalysis.power_series_analysis(coefficients, center)
    Let radius be analysis["radius_of_convergence"]
    
    Note: For exponential series, radius should be infinite (very large)
    Assert.IsTrue(Parse radius as Float >= 1000)
    Return true

Process called "test_power_series_convergence_interval" that takes no parameters returns Boolean:
    Note: Test interval of convergence for power series
    Let coefficients be List[String]()
    For n from 1 to 20:
        Let coeff be MathOps.divide("1", ToString(n), 15).result_value
        Set coefficients to coefficients.append(coeff)
    
    Let analysis be RealAnalysis.power_series_analysis(coefficients, "0")
    Let radius be Parse analysis["radius_of_convergence"] as Float
    
    Assert.IsTrue(radius > 0.9 and radius < 1.1)
    Return true

Process called "test_taylor_series_expansion" that takes no parameters returns Boolean:
    Note: Test Taylor series expansion
    Let function be create_test_function("exp(x)", "-10", "10")
    Let center be "0"
    Let order be 10
    
    Let taylor_series be RealAnalysis.taylor_series_expansion(function, center, order)
    
    Assert.IsTrue(Length(taylor_series.coefficients) == order + 1)
    Assert.AreEqual(taylor_series.center, center)
    
    Note: First coefficient should be 1 (exp(0) = 1)
    Assert.AreEqual(taylor_series.coefficients[0], "1")
    
    Note: Second coefficient should be 1 (exp'(0) = 1)
    Assert.AreEqual(taylor_series.coefficients[1], "1")
    Return true

Note: =====================================================================
Note: CONTINUITY AND LIMITS TESTS
Note: =====================================================================

Process called "test_continuity_polynomial" that takes no parameters returns Boolean:
    Note: Test continuity of polynomial functions
    Let polynomial be create_test_function("x^2 + 2*x + 1", "-10", "10")
    
    Let test_points be ["-5", "-1", "0", "1", "5"]
    For point in test_points:
        Let is_continuous be RealAnalysis.test_continuity(polynomial, point)
        Assert.IsTrue(is_continuous)
    
    Return true

Process called "test_discontinuity_rational" that takes no parameters returns Boolean:
    Note: Test discontinuity in rational functions
    Let rational be create_test_function("1/(x-2)", "-10", "10")
    
    Note: Should be continuous everywhere except x = 2
    Let continuous_points be ["-5", "0", "1", "3", "5"]
    For point in continuous_points:
        Let is_continuous be RealAnalysis.test_continuity(rational, point)
        Assert.IsTrue(is_continuous)
    
    Let discontinuous_point be "2"
    Let is_continuous be RealAnalysis.test_continuity(rational, discontinuous_point)
    Assert.IsFalse(is_continuous)
    Return true

Process called "test_limit_computation" that takes no parameters returns Boolean:
    Note: Test limit computation
    Let function be create_test_function("(x^2 - 4)/(x - 2)", "-10", "10")
    Let point be "2"
    
    Let limit be RealAnalysis.compute_limit(function, point, "right")
    Assert.AreEqual(limit, "4")
    
    Let left_limit be RealAnalysis.compute_limit(function, point, "left")
    Assert.AreEqual(left_limit, "4")
    
    Let two_sided_limit be RealAnalysis.compute_limit(function, point, "both")
    Assert.AreEqual(two_sided_limit, "4")
    Return true

Process called "test_epsilon_delta_definition" that takes no parameters returns Boolean:
    Note: Test epsilon-delta definition of limits
    Let function be create_test_function("2*x + 3", "-10", "10")
    Let point be "1"
    Let expected_limit be "5"
    Let epsilon be "0.01"
    
    Let delta be RealAnalysis.find_delta_for_epsilon(function, point, expected_limit, epsilon)
    Assert.IsTrue(Parse delta as Float > 0)
    
    Let verification be RealAnalysis.verify_epsilon_delta(function, point, expected_limit, epsilon, delta)
    Assert.IsTrue(verification)
    Return true

Note: =====================================================================
Note: DIFFERENTIATION TESTS
Note: =====================================================================

Process called "test_derivative_polynomial" that takes no parameters returns Boolean:
    Note: Test derivative of polynomial functions
    Let function be create_test_function("x^3 + 2*x^2 + 3*x + 4", "-10", "10")
    
    Let derivative be RealAnalysis.compute_derivative(function, "x")
    Assert.AreEqual(derivative.expression, "3*x^2 + 4*x + 3")
    Return true

Process called "test_derivative_trigonometric" that takes no parameters returns Boolean:
    Note: Test derivative of trigonometric functions
    Let sin_function be create_test_function("sin(x)", "-10", "10")
    Let cos_function be create_test_function("cos(x)", "-10", "10")
    
    Let sin_derivative be RealAnalysis.compute_derivative(sin_function, "x")
    Assert.AreEqual(sin_derivative.expression, "cos(x)")
    
    Let cos_derivative be RealAnalysis.compute_derivative(cos_function, "x")
    Assert.AreEqual(cos_derivative.expression, "-sin(x)")
    Return true

Process called "test_derivative_chain_rule" that takes no parameters returns Boolean:
    Note: Test chain rule in differentiation
    Let composite_function be create_test_function("sin(x^2)", "-10", "10")
    
    Let derivative be RealAnalysis.compute_derivative(composite_function, "x")
    Assert.AreEqual(derivative.expression, "2*x*cos(x^2)")
    Return true

Process called "test_derivative_product_rule" that takes no parameters returns Boolean:
    Note: Test product rule in differentiation
    Let product_function be create_test_function("x*sin(x)", "-10", "10")
    
    Let derivative be RealAnalysis.compute_derivative(product_function, "x")
    Assert.AreEqual(derivative.expression, "sin(x) + x*cos(x)")
    Return true

Process called "test_derivative_quotient_rule" that takes no parameters returns Boolean:
    Note: Test quotient rule in differentiation
    Let quotient_function be create_test_function("sin(x)/x", "-10", "10")
    
    Let derivative be RealAnalysis.compute_derivative(quotient_function, "x")
    Assert.AreEqual(derivative.expression, "(x*cos(x) - sin(x))/x^2")
    Return true

Process called "test_critical_points" that takes no parameters returns Boolean:
    Note: Test finding critical points
    Let function be create_test_function("x^3 - 3*x^2 + 2", "-10", "10")
    
    Let critical_points be RealAnalysis.find_critical_points(function)
    Assert.AreEqual(Length(critical_points), 2)
    Assert.IsTrue("0" in critical_points)
    Assert.IsTrue("2" in critical_points)
    Return true

Note: =====================================================================
Note: INTEGRATION TESTS
Note: =====================================================================

Process called "test_riemann_integration_polynomial" that takes no parameters returns Boolean:
    Note: Test Riemann integration of polynomials
    Let function be create_test_function("x^2", "0", "2")
    
    Let integral be RealAnalysis.riemann_integrate(function, "0", "2")
    Assert.IsTrue(assert_approximately_equal(integral.value, "2.666667", 1e-5))
    Return true

Process called "test_riemann_integration_trigonometric" that takes no parameters returns Boolean:
    Note: Test Riemann integration of trigonometric functions
    Let sin_function be create_test_function("sin(x)", "0", "3.141592653589793")
    
    Let integral be RealAnalysis.riemann_integrate(sin_function, "0", "3.141592653589793")
    Assert.IsTrue(assert_approximately_equal(integral.value, "2", 1e-5))
    Return true

Process called "test_definite_integral_properties" that takes no parameters returns Boolean:
    Note: Test properties of definite integrals
    Let function be create_test_function("x", "0", "4")
    
    Note: Linearity property
    Let integral1 be RealAnalysis.riemann_integrate(function, "0", "2")
    Let integral2 be RealAnalysis.riemann_integrate(function, "2", "4")
    Let integral_combined be RealAnalysis.riemann_integrate(function, "0", "4")
    
    Let sum_of_parts be MathOps.add(integral1.value, integral2.value, 15).result_value
    Assert.IsTrue(assert_approximately_equal(sum_of_parts, integral_combined.value, 1e-10))
    Return true

Process called "test_fundamental_theorem_calculus" that takes no parameters returns Boolean:
    Note: Test fundamental theorem of calculus
    Let function be create_test_function("2*x", "0", "5")
    
    Note: Integral of 2x from 0 to 5 should be x^2 evaluated at bounds = 25 - 0 = 25
    Let integral be RealAnalysis.riemann_integrate(function, "0", "5")
    Assert.IsTrue(assert_approximately_equal(integral.value, "25", 1e-10))
    
    Note: Test F'(x) = f(x) where F is antiderivative
    Let antiderivative be RealAnalysis.find_antiderivative(function)
    Let derivative_of_antiderivative be RealAnalysis.compute_derivative(antiderivative, "x")
    Assert.AreEqual(derivative_of_antiderivative.expression, function.expression)
    Return true

Process called "test_improper_integrals" that takes no parameters returns Boolean:
    Note: Test improper integral convergence
    Let function be create_test_function("1/x^2", "1", "infinity")
    
    Let improper_integral be RealAnalysis.evaluate_improper_integral(function, "1", "infinity")
    Assert.IsTrue(improper_integral.is_convergent)
    Assert.IsTrue(assert_approximately_equal(improper_integral.value, "1", 1e-6))
    Return true

Note: =====================================================================
Note: UNIFORM CONVERGENCE TESTS
Note: =====================================================================

Process called "test_uniform_convergence_function_sequence" that takes no parameters returns Boolean:
    Note: Test uniform convergence of function sequences
    Let function_sequence be List[RealAnalysis.RealFunction]()
    
    For n from 1 to 20:
        Let expr be "x/" + ToString(n)
        Let func be create_test_function(expr, "0", "1")
        Set function_sequence to function_sequence.append(func)
    
    Let limit_function be create_test_function("0", "0", "1")
    
    Let uniform_conv be RealAnalysis.UniformConvergence()
    Set uniform_conv.function_sequence to function_sequence
    Set uniform_conv.limit_function to limit_function
    
    Let is_uniform be RealAnalysis.test_uniform_convergence(uniform_conv, "0", "1")
    Assert.IsTrue(is_uniform)
    Return true

Process called "test_weierstrass_m_test" that takes no parameters returns Boolean:
    Note: Test Weierstrass M-test for uniform convergence
    Let function_series be List[RealAnalysis.RealFunction]()
    
    For n from 1 to 15:
        Let expr be "sin(x)/" + ToString(n) + "^2"
        Let func be create_test_function(expr, "0", "6.283185307179586")
        Set function_series to function_series.append(func)
    
    Let m_test_result be RealAnalysis.weierstrass_m_test(function_series)
    Assert.IsTrue(m_test_result.is_uniformly_convergent)
    Return true

Note: =====================================================================
Note: METRIC SPACE TESTS
Note: =====================================================================

Process called "test_metric_space_properties" that takes no parameters returns Boolean:
    Note: Test metric space properties
    Let points be ["0", "1", "2", "3", "4"]
    
    Let metric_space be RealAnalysis.MetricSpace()
    Set metric_space.points to points
    Set metric_space.is_complete to true
    Set metric_space.is_compact to false
    Set metric_space.is_connected to true
    
    Note: Test triangle inequality
    Let d12 be RealAnalysis.compute_distance(metric_space, "1", "2")
    Let d23 be RealAnalysis.compute_distance(metric_space, "2", "3")
    Let d13 be RealAnalysis.compute_distance(metric_space, "1", "3")
    
    Assert.IsTrue(Parse d13 as Float <= Parse d12 as Float + Parse d23 as Float)
    Return true

Process called "test_completeness_cauchy_sequences" that takes no parameters returns Boolean:
    Note: Test completeness via Cauchy sequences
    Let rational_points be ["1", "1.4", "1.41", "1.414", "1.4142", "1.41421"]
    
    Let metric_space be RealAnalysis.MetricSpace()
    Set metric_space.points to rational_points
    Set metric_space.is_complete to false
    
    Let cauchy_sequence be RealAnalysis.Sequence()
    Set cauchy_sequence.terms to rational_points
    
    Let is_cauchy be RealAnalysis.test_cauchy_criterion(cauchy_sequence, "1e-6")
    Assert.IsTrue(is_cauchy)
    
    Note: In incomplete space, Cauchy sequences may not converge
    Let has_limit_in_space be RealAnalysis.sequence_has_limit_in_space(cauchy_sequence, metric_space)
    Assert.IsFalse(has_limit_in_space)
    Return true

Process called "test_compactness_heine_borel" that takes no parameters returns Boolean:
    Note: Test compactness using Heine-Borel theorem
    Let closed_interval_points be List[String]()
    For i from 0 to 100:
        Let point be MathOps.divide(ToString(i), "100", 15).result_value
        Set closed_interval_points to closed_interval_points.append(point)
    
    Let compact_space be RealAnalysis.MetricSpace()
    Set compact_space.points to closed_interval_points
    Set compact_space.is_compact to true
    Set compact_space.is_complete to true
    
    Let open_cover be RealAnalysis.generate_open_cover(compact_space)
    Let finite_subcover be RealAnalysis.extract_finite_subcover(open_cover, compact_space)
    
    Assert.IsTrue(Length(finite_subcover) < Length(open_cover))
    Assert.IsTrue(RealAnalysis.subcover_covers_space(finite_subcover, compact_space))
    Return true

Note: =====================================================================
Note: FUNCTION ANALYSIS TESTS
Note: =====================================================================

Process called "test_monotonicity_analysis" that takes no parameters returns Boolean:
    Note: Test monotonicity analysis of functions
    Let increasing_function be create_test_function("x^3", "-10", "10")
    Let decreasing_function be create_test_function("-x^2", "-10", "10")
    
    Let is_increasing be RealAnalysis.test_monotonicity(increasing_function, "increasing")
    Assert.IsTrue(is_increasing)
    
    Let is_decreasing be RealAnalysis.test_monotonicity(decreasing_function, "decreasing")
    Assert.IsTrue(is_decreasing)
    Return true

Process called "test_concavity_analysis" that takes no parameters returns Boolean:
    Note: Test concavity analysis of functions
    Let concave_up_function be create_test_function("x^2", "-10", "10")
    Let concave_down_function be create_test_function("-x^2", "-10", "10")
    
    Let is_concave_up be RealAnalysis.test_concavity(concave_up_function, "up")
    Assert.IsTrue(is_concave_up)
    
    Let is_concave_down be RealAnalysis.test_concavity(concave_down_function, "down")
    Assert.IsTrue(is_concave_down)
    Return true

Process called "test_function_extrema" that takes no parameters returns Boolean:
    Note: Test finding function extrema
    Let function be create_test_function("x^4 - 4*x^3 + 6*x^2 - 4*x + 1", "-5", "5")
    
    Let extrema be RealAnalysis.find_extrema(function)
    
    Assert.IsTrue(Length(extrema.local_maxima) > 0)
    Assert.IsTrue(Length(extrema.local_minima) > 0)
    
    For extremum in extrema.all_extrema:
        Let derivative_at_point be RealAnalysis.evaluate_derivative_at_point(function, extremum.point)
        Assert.IsTrue(assert_approximately_equal(derivative_at_point, "0", 1e-6))
    
    Return true

Note: =====================================================================
Note: APPROXIMATION THEORY TESTS
Note: =====================================================================

Process called "test_polynomial_approximation" that takes no parameters returns Boolean:
    Note: Test polynomial approximation using Weierstrass theorem
    Let function be create_test_function("sin(x)", "0", "3.141592653589793")
    Let degree be 5
    
    Let polynomial_approx be RealAnalysis.polynomial_approximation(function, degree)
    
    Let test_points be ["0", "0.5", "1.0", "1.5", "2.0", "2.5", "3.0"]
    For point in test_points:
        Let original_value be RealAnalysis.evaluate_function_at_point(function, point)
        Let approx_value be RealAnalysis.evaluate_function_at_point(polynomial_approx, point)
        Let error be AbsoluteValue(Parse original_value as Float - Parse approx_value as Float)
        Assert.IsTrue(error < 0.1)
    
    Return true

Process called "test_chebyshev_approximation" that takes no parameters returns Boolean:
    Note: Test Chebyshev polynomial approximation
    Let function be create_test_function("exp(x)", "-1", "1")
    Let degree be 4
    
    Let chebyshev_approx be RealAnalysis.chebyshev_approximation(function, degree)
    
    Let test_points be ["-1", "-0.5", "0", "0.5", "1"]
    For point in test_points:
        Let original_value be RealAnalysis.evaluate_function_at_point(function, point)
        Let approx_value be RealAnalysis.evaluate_function_at_point(chebyshev_approx, point)
        Let error be AbsoluteValue(Parse original_value as Float - Parse approx_value as Float)
        Assert.IsTrue(error < 0.05)
    
    Return true

Process called "test_spline_approximation" that takes no parameters returns Boolean:
    Note: Test spline approximation
    Let data_points be Dictionary[String, String]()
    Set data_points["0"] to "0"
    Set data_points["1"] to "1"
    Set data_points["2"] to "4"
    Set data_points["3"] to "9"
    Set data_points["4"] to "16"
    
    Let cubic_spline be RealAnalysis.cubic_spline_interpolation(data_points)
    
    Note: Test that spline passes through data points
    For x, y in data_points:
        Let spline_value be RealAnalysis.evaluate_function_at_point(cubic_spline, x)
        Assert.IsTrue(assert_approximately_equal(spline_value, y, 1e-10))
    
    Return true

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all real analysis module tests
    Let tests_passed be 0
    Let tests_failed be 0
    
    Note: Sequence and series tests
    Let sequence_series_tests be [
        "test_sequence_convergence_arithmetic",
        "test_sequence_convergence_geometric",
        "test_sequence_monotonic_bounded",
        "test_cauchy_criterion",
        "test_sequence_limit_properties",
        "test_series_convergence_geometric",
        "test_series_convergence_harmonic",
        "test_series_convergence_p_series",
        "test_series_ratio_test",
        "test_series_root_test",
        "test_alternating_series"
    ]
    
    Note: Power series tests
    Let power_series_tests be [
        "test_power_series_radius_of_convergence",
        "test_power_series_convergence_interval",
        "test_taylor_series_expansion"
    ]
    
    Note: Continuity and limits tests
    Let continuity_limit_tests be [
        "test_continuity_polynomial",
        "test_discontinuity_rational",
        "test_limit_computation",
        "test_epsilon_delta_definition"
    ]
    
    Note: Differentiation tests
    Let differentiation_tests be [
        "test_derivative_polynomial",
        "test_derivative_trigonometric",
        "test_derivative_chain_rule",
        "test_derivative_product_rule",
        "test_derivative_quotient_rule",
        "test_critical_points"
    ]
    
    Note: Integration tests
    Let integration_tests be [
        "test_riemann_integration_polynomial",
        "test_riemann_integration_trigonometric",
        "test_definite_integral_properties",
        "test_fundamental_theorem_calculus",
        "test_improper_integrals"
    ]
    
    Note: Uniform convergence tests
    Let uniform_convergence_tests be [
        "test_uniform_convergence_function_sequence",
        "test_weierstrass_m_test"
    ]
    
    Note: Metric space tests
    Let metric_space_tests be [
        "test_metric_space_properties",
        "test_completeness_cauchy_sequences",
        "test_compactness_heine_borel"
    ]
    
    Note: Function analysis tests
    Let function_analysis_tests be [
        "test_monotonicity_analysis",
        "test_concavity_analysis",
        "test_function_extrema"
    ]
    
    Note: Approximation theory tests
    Let approximation_tests be [
        "test_polynomial_approximation",
        "test_chebyshev_approximation",
        "test_spline_approximation"
    ]
    
    Let all_test_groups be [sequence_series_tests, power_series_tests, continuity_limit_tests, 
                           differentiation_tests, integration_tests, uniform_convergence_tests,
                           metric_space_tests, function_analysis_tests, approximation_tests]
    
    Let group_names be ["Sequences & Series", "Power Series", "Continuity & Limits", 
                       "Differentiation", "Integration", "Uniform Convergence",
                       "Metric Spaces", "Function Analysis", "Approximation Theory"]
    
    For group_index from 0 to Length(all_test_groups) - 1:
        Let test_group be all_test_groups[group_index]
        Let group_name be group_names[group_index]
        Print "Testing " + group_name + "..."
        
        For test_name in test_group:
            Try:
                Let test_result be Call test_name()
                If test_result:
                    Set tests_passed to tests_passed + 1
                    Print "  ✓ " + test_name
                Otherwise:
                    Set tests_failed to tests_failed + 1  
                    Print "  ✗ " + test_name + " (returned false)"
            Catch error:
                Set tests_failed to tests_failed + 1
                Print "  ✗ " + test_name + " (error: " + error.message + ")"
    
    Let total_tests be tests_passed + tests_failed
    Print ""
    Print "Real Analysis Module Test Results:"
    Print "=================================="
    Print "Tests passed: " + ToString(tests_passed)
    Print "Tests failed: " + ToString(tests_failed)  
    Print "Total tests: " + ToString(total_tests)
    Print "Success rate: " + ToString((tests_passed * 100) / total_tests) + "%"
    
    Return tests_failed == 0