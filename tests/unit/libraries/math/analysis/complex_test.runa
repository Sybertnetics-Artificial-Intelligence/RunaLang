Note:
tests/unit/libraries/math/analysis/complex_test.runa
Unit Tests for Math Analysis Complex Analysis Module

This test suite provides comprehensive testing for the complex analysis module including:
- Holomorphic function analysis and Cauchy-Riemann equations
- Complex derivatives and analyticity testing
- Singularity classification and residue computation
- Contour integration and Cauchy's theorem
- Complex integration formulas and residue theorem
- Power series and Laurent series expansions
- Conformal mappings and Riemann mapping theorem
- Harmonic functions and Dirichlet problems
- Entire function theory and factorization
- Maximum modulus principle and Phragmen-Lindelöf
:End Note

Import "stdlib/math/analysis/complex" as ComplexAnalysis
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "create_complex_function" that takes real_part as String, imaginary_part as String, domain_type as String returns ComplexAnalysis.ComplexFunction:
    Note: Create a complex function for testing
    Let function be ComplexAnalysis.ComplexFunction()
    Set function.real_part to real_part
    Set function.imaginary_part to imaginary_part
    Set function.domain to Dictionary[String, String]()
    Set function.domain["type"] to domain_type
    Set function.is_holomorphic to true
    Set function.is_analytic to true
    
    Return function

Process called "create_unit_circle_domain" that takes no parameters returns Dictionary[String, String]:
    Note: Create unit circle domain for testing
    Let domain be Dictionary[String, String]()
    Set domain["type"] to "disk"
    Set domain["center"] to "0+0i"
    Set domain["radius"] to "1"
    Return domain

Process called "create_upper_half_plane" that takes no parameters returns Dictionary[String, String]:
    Note: Create upper half-plane domain
    Let domain be Dictionary[String, String]()
    Set domain["type"] to "half_plane"
    Set domain["orientation"] to "upper"
    Set domain["boundary"] to "real_axis"
    Return domain

Process called "assert_complex_approximately_equal" that takes value1 as String, value2 as String, tolerance as Float returns Boolean:
    Note: Assert two complex values are approximately equal
    Let complex1 be ComplexAnalysis.parse_complex_string(value1)
    Let complex2 be ComplexAnalysis.parse_complex_string(value2)
    
    Let real_diff be AbsoluteValue(Parse complex1["real"] as Float - Parse complex2["real"] as Float)
    Let imag_diff be AbsoluteValue(Parse complex1["imaginary"] as Float - Parse complex2["imaginary"] as Float)
    
    Assert.IsTrue(real_diff <= tolerance)
    Assert.IsTrue(imag_diff <= tolerance)
    Return true

Process called "create_simple_contour" that takes center as String, radius as String returns Dictionary[String, String]:
    Note: Create a simple circular contour
    Let contour be Dictionary[String, String]()
    Set contour["type"] to "circle"
    Set contour["center"] to center
    Set contour["radius"] to radius
    Set contour["orientation"] to "counterclockwise"
    Return contour

Process called "generate_test_complex_points" that takes count as Integer returns List[String]:
    Note: Generate test complex points
    Let points be List[String]()
    For i from 0 to count - 1:
        Let real_part be ToString((i - count/2) * 0.5)
        Let imag_part be ToString((i % 3) * 0.3)
        Let point be real_part + "+" + imag_part + "i"
        Set points to points.append(point)
    Return points

Note: =====================================================================
Note: HOLOMORPHIC FUNCTION TESTS
Note: =====================================================================

Process called "test_holomorphicity_polynomial" that takes no parameters returns Boolean:
    Note: Test holomorphicity of polynomial functions
    Let polynomial be create_complex_function("x^2 - y^2", "2*x*y", "entire")
    Let domain be Dictionary[String, String]()
    Set domain["type"] to "entire_plane"
    
    Let is_holomorphic be ComplexAnalysis.test_holomorphicity(polynomial, domain)
    Assert.IsTrue(is_holomorphic)
    Return true

Process called "test_cauchy_riemann_equations" that takes no parameters returns Boolean:
    Note: Test Cauchy-Riemann equations for holomorphic functions
    Let function be create_complex_function("x^2 - y^2", "2*x*y", "entire")
    
    Let cr_result be ComplexAnalysis.cauchy_riemann_equations(function)
    
    Assert.IsTrue(cr_result["u_x_equals_v_y"])
    Assert.IsTrue(cr_result["u_y_equals_minus_v_x"])
    Assert.IsTrue(cr_result["is_holomorphic"])
    Return true

Process called "test_complex_differentiability" that takes no parameters returns Boolean:
    Note: Test complex differentiability
    Let function be create_complex_function("x", "-y", "entire")
    Let test_point be "1+1i"
    
    Let is_differentiable be ComplexAnalysis.test_complex_differentiability_at_point(function, test_point)
    Assert.IsTrue(is_differentiable)
    
    Let derivative be ComplexAnalysis.compute_complex_derivative(function, test_point)
    Assert.AreEqual(derivative, "1+0i")
    Return true

Process called "test_non_holomorphic_function" that takes no parameters returns Boolean:
    Note: Test detection of non-holomorphic functions
    Let non_holomorphic be create_complex_function("x", "y", "entire")
    Let domain be Dictionary[String, String]()
    Set domain["type"] to "entire_plane"
    
    Let is_holomorphic be ComplexAnalysis.test_holomorphicity(non_holomorphic, domain)
    Assert.IsFalse(is_holomorphic)
    
    Let cr_result be ComplexAnalysis.cauchy_riemann_equations(non_holomorphic)
    Assert.IsFalse(cr_result["is_holomorphic"])
    Return true

Process called "test_analytic_continuation" that takes no parameters returns Boolean:
    Note: Test analytic continuation
    Let function be create_complex_function("x", "0", "unit_disk")
    Let path be Dictionary[String, String]()
    Set path["start_domain"] to "unit_disk"
    Set path["end_domain"] to "extended_disk"
    Set path["method"] to "power_series"
    
    Let continued_function be ComplexAnalysis.analytic_continuation(function, path)
    Assert.IsTrue(continued_function.is_analytic)
    Assert.AreEqual(continued_function.real_part, "x")
    Return true

Note: =====================================================================
Note: SINGULARITY AND RESIDUE TESTS
Note: =====================================================================

Process called "test_singularity_detection" that takes no parameters returns Boolean:
    Note: Test detection and classification of singularities
    Let function_with_pole be create_complex_function("1/(x^2 + y^2)", "0", "complex_plane_minus_origin")
    
    Let singularities be ComplexAnalysis.find_singularities(function_with_pole)
    
    Assert.AreEqual(Length(singularities), 1)
    Assert.AreEqual(singularities[0]["location"], "0+0i")
    Assert.AreEqual(singularities[0]["type"], "pole")
    Assert.AreEqual(singularities[0]["order"], "2")
    Return true

Process called "test_residue_computation" that takes no parameters returns Boolean:
    Note: Test residue computation at poles
    Let function be create_complex_function("1/(x^2 + 1)", "0", "complex_plane")
    Let pole1 be "0+1i"
    Let pole2 be "0-1i"
    
    Let residue1 be ComplexAnalysis.compute_residue(function, pole1)
    Let residue2 be ComplexAnalysis.compute_residue(function, pole2)
    
    Assert.IsTrue(assert_complex_approximately_equal(residue1, "0+0.5i", 1e-10))
    Assert.IsTrue(assert_complex_approximately_equal(residue2, "0-0.5i", 1e-10))
    Return true

Process called "test_essential_singularity" that takes no parameters returns Boolean:
    Note: Test essential singularity behavior
    Let function be create_complex_function("cos(1/x)", "sin(1/x)", "complex_plane_minus_origin")
    
    Let singularities be ComplexAnalysis.find_singularities(function)
    Assert.AreEqual(Length(singularities), 1)
    Assert.AreEqual(singularities[0]["location"], "0+0i")
    Assert.AreEqual(singularities[0]["type"], "essential")
    
    Note: Test Picard's theorem for essential singularities
    Let picard_result be ComplexAnalysis.picard_theorem(function)
    Assert.IsTrue(picard_result["has_essential_singularity"])
    Assert.IsTrue(Length(picard_result["exceptional_values"]) <= 2)
    Return true

Process called "test_removable_singularity" that takes no parameters returns Boolean:
    Note: Test removable singularity
    Let function be create_complex_function("sin(x)/x", "0", "complex_plane")
    
    Let singularities be ComplexAnalysis.find_singularities(function)
    If Length(singularities) > 0:
        For singularity in singularities:
            If singularity["location"] == "0+0i":
                Assert.AreEqual(singularity["type"], "removable")
    
    Return true

Note: =====================================================================
Note: CONTOUR INTEGRATION TESTS
Note: =====================================================================

Process called "test_cauchy_theorem" that takes no parameters returns Boolean:
    Note: Test Cauchy's theorem for holomorphic functions
    Let holomorphic_function be create_complex_function("x^2 - y^2", "2*x*y", "entire")
    Let contour be create_simple_contour("0+0i", "2")
    
    Let integral_result be ComplexAnalysis.cauchy_theorem(holomorphic_function, contour)
    Assert.IsTrue(assert_complex_approximately_equal(integral_result, "0+0i", 1e-10))
    Return true

Process called "test_cauchy_integral_formula" that takes no parameters returns Boolean:
    Note: Test Cauchy integral formula
    Let function be create_complex_function("x", "y", "entire")
    Let contour be create_simple_contour("0+0i", "1")
    Let interior_point be "0.5+0i"
    
    Let integral_value be ComplexAnalysis.cauchy_integral_formula(function, contour, interior_point)
    Let function_value be ComplexAnalysis.evaluate_complex_function_at_string_point(function, interior_point)
    
    Assert.IsTrue(assert_complex_approximately_equal(integral_value, function_value, 1e-8))
    Return true

Process called "test_residue_theorem" that takes no parameters returns Boolean:
    Note: Test residue theorem for contour integration
    Let function be create_complex_function("1/((x^2 + 1)*(x^2 + 4))", "0", "complex_plane")
    Let contour be create_simple_contour("0+0i", "3")
    
    Note: Function has simple poles at ±i and ±2i
    Let integral_result be ComplexAnalysis.residue_theorem(function, contour)
    
    Note: Sum of residues times 2πi
    Let expected_result be "0+0i"  
    Assert.IsTrue(assert_complex_approximately_equal(integral_result, expected_result, 1e-8))
    Return true

Process called "test_contour_deformation" that takes no parameters returns Boolean:
    Note: Test contour deformation principles
    Let function be create_complex_function("1/(x^2 + 1)", "0", "complex_plane")
    
    Let contour1 be create_simple_contour("0+0i", "2")
    Let contour2 be create_simple_contour("0+0i", "3")
    
    Let integral1 be ComplexAnalysis.contour_integration(function, contour1)
    Let integral2 be ComplexAnalysis.contour_integration(function, contour2)
    
    Note: Should be equal since no poles between contours
    Assert.IsTrue(assert_complex_approximately_equal(integral1, integral2, 1e-8))
    Return true

Process called "test_winding_number" that takes no parameters returns Boolean:
    Note: Test winding number computation
    Let contour be create_simple_contour("0+0i", "1")
    Let interior_point be "0+0i"
    Let exterior_point be "2+0i"
    
    Let winding_interior be ComplexAnalysis.winding_number(contour, interior_point)
    Let winding_exterior be ComplexAnalysis.winding_number(contour, exterior_point)
    
    Assert.AreEqual(winding_interior, 1)
    Assert.AreEqual(winding_exterior, 0)
    Return true

Note: =====================================================================
Note: POWER SERIES AND LAURENT SERIES TESTS
Note: =====================================================================

Process called "test_power_series_expansion" that takes no parameters returns Boolean:
    Note: Test power series expansion of holomorphic functions
    Let function be create_complex_function("1/(1-x)", "0", "unit_disk")
    Let center be "0+0i"
    
    Let power_series be ComplexAnalysis.power_series_expansion(function, center)
    
    Assert.AreEqual(Length(power_series.coefficients), power_series.degree + 1)
    Assert.AreEqual(power_series.coefficients[0], "1+0i")
    Assert.AreEqual(power_series.coefficients[1], "1+0i")
    Assert.AreEqual(power_series.coefficients[2], "1+0i")
    Return true

Process called "test_radius_of_convergence" that takes no parameters returns Boolean:
    Note: Test radius of convergence calculation
    Let coefficients be ["1", "1", "1", "1", "1", "1"]
    Let power_series be ComplexAnalysis.PowerSeries()
    Set power_series.coefficients to coefficients
    Set power_series.center to "0+0i"
    
    Let radius be ComplexAnalysis.radius_of_convergence(power_series)
    Assert.IsTrue(assert_complex_approximately_equal(radius, "1+0i", 1e-10))
    Return true

Process called "test_laurent_series_expansion" that takes no parameters returns Boolean:
    Note: Test Laurent series expansion around singularities
    Let function be create_complex_function("1/x + x", "0", "punctured_disk")
    Let center be "0+0i"
    
    Let laurent_series be ComplexAnalysis.laurent_series_expansion(function, center)
    
    Assert.IsTrue(Length(laurent_series.positive_coefficients) > 0)
    Assert.IsTrue(Length(laurent_series.negative_coefficients) > 0)
    
    Note: Check principal part coefficient
    Assert.AreEqual(laurent_series.negative_coefficients["1"], "1+0i")
    
    Note: Check regular part coefficient
    Assert.AreEqual(laurent_series.positive_coefficients["1"], "1+0i")
    Return true

Process called "test_series_convergence_analysis" that takes no parameters returns Boolean:
    Note: Test convergence analysis of power series
    Let exponential_coefficients be List[String]()
    For n from 0 to 10:
        Let factorial_n be MathOps.factorial(n).factorial_value
        Let coefficient be MathOps.divide("1", factorial_n, 15).result_value + "+0i"
        Set exponential_coefficients to exponential_coefficients.append(coefficient)
    
    Let power_series be ComplexAnalysis.PowerSeries()
    Set power_series.coefficients to exponential_coefficients
    Set power_series.center to "0+0i"
    
    Let convergence_analysis be ComplexAnalysis.series_convergence_analysis(power_series)
    
    Note: Exponential series converges everywhere
    Assert.AreEqual(convergence_analysis["radius"], "infinity")
    Assert.IsTrue(Parse convergence_analysis["convergence_rate"] as Float > 0)
    Return true

Process called "test_series_manipulation" that takes no parameters returns Boolean:
    Note: Test algebraic operations on power series
    Let series1_coeffs be ["1+0i", "1+0i", "0+0i"]
    Let series2_coeffs be ["0+0i", "1+0i", "1+0i"]
    
    Let series1 be ComplexAnalysis.PowerSeries()
    Set series1.coefficients to series1_coeffs
    Set series1.center to "0+0i"
    
    Let series2 be ComplexAnalysis.PowerSeries()
    Set series2.coefficients to series2_coeffs
    Set series2.center to "0+0i"
    
    Let sum_series be ComplexAnalysis.series_manipulation(series1, series2, "add")
    Let product_series be ComplexAnalysis.series_manipulation(series1, series2, "multiply")
    
    Assert.AreEqual(sum_series.coefficients[0], "1+0i")
    Assert.AreEqual(sum_series.coefficients[1], "2+0i")
    Assert.AreEqual(sum_series.coefficients[2], "1+0i")
    
    Assert.AreEqual(product_series.coefficients[0], "0+0i")
    Assert.AreEqual(product_series.coefficients[1], "1+0i")
    Return true

Note: =====================================================================
Note: CONFORMAL MAPPING TESTS
Note: =====================================================================

Process called "test_mobius_transformation" that takes no parameters returns Boolean:
    Note: Test Möbius transformation
    Let coefficients be ["1+0i", "1+0i", "0+0i", "1+0i"]  
    Let mobius_map be ComplexAnalysis.mobius_transformation(coefficients)
    
    Let test_point be "1+0i"
    Let mapped_point be ComplexAnalysis.apply_conformal_map(mobius_map, test_point)
    
    Note: f(z) = (z+1)/1 = z+1, so f(1) = 2
    Assert.IsTrue(assert_complex_approximately_equal(mapped_point, "2+0i", 1e-10))
    Return true

Process called "test_riemann_mapping_theorem" that takes no parameters returns Boolean:
    Note: Test Riemann mapping theorem application
    Let domain be Dictionary[String, String]()
    Set domain["type"] to "upper_half_plane"
    Set domain["boundary"] to "real_axis"
    
    Let riemann_map be ComplexAnalysis.riemann_mapping_theorem(domain)
    
    Assert.IsTrue(riemann_map.is_conformal)
    Assert.IsTrue(riemann_map.is_bijective)
    Assert.AreEqual(riemann_map.target_domain["type"], "unit_disk")
    Return true

Process called "test_conformal_invariants" that takes no parameters returns Boolean:
    Note: Test preservation of conformal invariants
    Let coefficients be ["2+0i", "0+0i", "0+0i", "1+0i"]
    Let scaling_map be ComplexAnalysis.mobius_transformation(coefficients)
    
    Let invariants be ComplexAnalysis.conformal_invariants(scaling_map)
    
    Assert.IsTrue(invariants["preserves_angles"])
    Assert.IsTrue(invariants["preserves_orientation"])
    Assert.IsFalse(invariants["preserves_distances"])
    Assert.IsTrue(Parse invariants["jacobian_determinant"] as Float > 0)
    Return true

Process called "test_schwarz_christoffel_formula" that takes no parameters returns Boolean:
    Note: Test Schwarz-Christoffel formula for polygon mapping
    Let polygon be Dictionary[String, String]()
    Set polygon["vertices"] to "3"
    Set polygon["angles"] to "60,60,60"
    Set polygon["type"] to "equilateral_triangle"
    
    Let sc_map be ComplexAnalysis.schwarz_christoffel_formula(polygon)
    
    Assert.IsTrue(sc_map.is_conformal)
    Assert.AreEqual(sc_map.source_domain["type"], "upper_half_plane")
    Assert.AreEqual(sc_map.target_domain["type"], "polygon")
    Return true

Note: =====================================================================
Note: HARMONIC FUNCTION TESTS
Note: =====================================================================

Process called "test_harmonic_function_detection" that takes no parameters returns Boolean:
    Note: Test detection of harmonic functions
    Let harmonic_func be Dictionary[String, String]()
    Set harmonic_func["expression"] to "x^2 - y^2"
    Set harmonic_func["type"] to "real_valued"
    
    Let domain be create_unit_circle_domain()
    
    Let is_harmonic be ComplexAnalysis.test_harmonicity(harmonic_func, domain)
    Assert.IsTrue(is_harmonic)
    Return true

Process called "test_harmonic_conjugate" that takes no parameters returns Boolean:
    Note: Test computation of harmonic conjugates
    Let harmonic_function be Dictionary[String, String]()
    Set harmonic_function["expression"] to "x^2 - y^2"
    
    Let conjugate be ComplexAnalysis.harmonic_conjugate(harmonic_function)
    Assert.AreEqual(conjugate["expression"], "2*x*y")
    Return true

Process called "test_dirichlet_problem" that takes no parameters returns Boolean:
    Note: Test solution of Dirichlet problems
    Let boundary_data be Dictionary[String, String]()
    Set boundary_data["boundary_type"] to "circle"
    Set boundary_data["radius"] to "1"
    Set boundary_data["function"] to "sin(theta)"
    
    Let domain be create_unit_circle_domain()
    
    Let solution be ComplexAnalysis.dirichlet_problem(boundary_data, domain)
    
    Assert.IsTrue(solution.contains("harmonic_function"))
    Assert.IsTrue(solution.contains("boundary_values_satisfied"))
    Return true

Process called "test_maximum_principle" that takes no parameters returns Boolean:
    Note: Test maximum modulus principle
    Let function be create_complex_function("x^2 + y^2", "0", "unit_disk")
    Let domain be create_unit_circle_domain()
    
    Let max_principle_result be ComplexAnalysis.maximum_principle(function, domain)
    
    Assert.IsTrue(max_principle_result.contains("maximum_on_boundary"))
    Assert.IsTrue(max_principle_result.contains("maximum_value"))
    Assert.IsTrue(max_principle_result.contains("maximum_location"))
    Return true

Process called "test_greens_function" that takes no parameters returns Boolean:
    Note: Test Green's function construction
    Let domain be create_unit_circle_domain()
    Let singularity_point be "0+0i"
    
    Let greens_func be ComplexAnalysis.greens_function(domain, singularity_point)
    
    Assert.IsTrue(greens_func.contains("singularity_at_point"))
    Assert.IsTrue(greens_func.contains("vanishes_on_boundary"))
    Return true

Note: =====================================================================
Note: ENTIRE FUNCTION THEORY TESTS
Note: =====================================================================

Process called "test_entire_function_classification" that takes no parameters returns Boolean:
    Note: Test classification of entire functions
    Let polynomial_function be create_complex_function("x^3 - 3*x*y^2", "3*x^2*y - y^3", "entire")
    Let exponential_function be create_complex_function("exp(x)*cos(y)", "exp(x)*sin(y)", "entire")
    
    Let poly_classification be ComplexAnalysis.classify_entire_function(polynomial_function)
    Let exp_classification be ComplexAnalysis.classify_entire_function(exponential_function)
    
    Assert.AreEqual(poly_classification, "polynomial")
    Assert.AreEqual(exp_classification, "exponential_type")
    Return true

Process called "test_hadamard_factorization" that takes no parameters returns Boolean:
    Note: Test Hadamard factorization theorem
    Let function be create_complex_function("sin(π*x)", "0", "entire")
    
    Let factorization be ComplexAnalysis.hadamard_factorization(function)
    
    Assert.IsTrue(factorization.contains("canonical_product"))
    Assert.IsTrue(factorization.contains("exponential_factor"))
    Assert.IsTrue(factorization.contains("zero_distribution"))
    Return true

Process called "test_jensen_formula" that takes no parameters returns Boolean:
    Note: Test Jensen's formula for entire functions
    Let function be create_complex_function("x^2", "0", "entire")
    Let radius be "2"
    
    Let jensen_result be ComplexAnalysis.jensen_formula(function, radius)
    
    Assert.IsTrue(Parse jensen_result as Float >= 0)
    Return true

Process called "test_phragmen_lindelof_principle" that takes no parameters returns Boolean:
    Note: Test Phragmén-Lindelöf principle
    Let function be create_complex_function("exp(x)*cos(y)", "exp(x)*sin(y)", "strip")
    Let strip_domain be Dictionary[String, String]()
    Set strip_domain["type"] to "horizontal_strip"
    Set strip_domain["lower_bound"] to "0"
    Set strip_domain["upper_bound"] to "π"
    
    Let pl_result be ComplexAnalysis.phragmen_lindelof_principle(function, strip_domain)
    
    Assert.IsTrue(pl_result.contains("growth_bound"))
    Assert.IsTrue(pl_result.contains("boundary_behavior"))
    Return true

Note: =====================================================================
Note: INTEGRATION AND CONVERGENCE TESTS
Note: =====================================================================

Process called "test_complex_line_integral" that takes no parameters returns Boolean:
    Note: Test complex line integration
    Let function be create_complex_function("x", "y", "entire")
    Let path be Dictionary[String, String]()
    Set path["type"] to "line_segment"
    Set path["start"] to "0+0i"
    Set path["end"] to "1+1i"
    
    Let integral_result be ComplexAnalysis.complex_line_integral(function, path)
    Assert.IsTrue(assert_complex_approximately_equal(integral_result, "1+1i", 1e-10))
    Return true

Process called "test_branch_cuts_and_multivalued" that takes no parameters returns Boolean:
    Note: Test handling of branch cuts and multivalued functions
    Let log_function be create_complex_function("0.5*ln(x^2+y^2)", "atan2(y,x)", "complex_plane_minus_origin")
    
    Let branch_analysis be ComplexAnalysis.analyze_branch_structure(log_function)
    
    Assert.IsTrue(branch_analysis.contains("branch_points"))
    Assert.IsTrue(branch_analysis.contains("branch_cuts"))
    Assert.IsTrue(branch_analysis.contains("principal_branch"))
    Return true

Process called "test_argument_principle" that takes no parameters returns Boolean:
    Note: Test argument principle for counting zeros and poles
    Let function be create_complex_function("(x^2+y^2-1)", "0", "complex_plane")
    Let contour be create_simple_contour("0+0i", "2")
    
    Let argument_result be ComplexAnalysis.argument_principle(function, contour)
    
    Note: Should count the zeros inside the contour
    Assert.IsTrue(argument_result.contains("zero_count"))
    Assert.IsTrue(argument_result.contains("pole_count"))
    Return true

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all complex analysis module tests
    Let tests_passed be 0
    Let tests_failed be 0
    
    Note: Holomorphic function tests
    Let holomorphic_tests be [
        "test_holomorphicity_polynomial",
        "test_cauchy_riemann_equations",
        "test_complex_differentiability",
        "test_non_holomorphic_function",
        "test_analytic_continuation"
    ]
    
    Note: Singularity and residue tests
    Let singularity_residue_tests be [
        "test_singularity_detection",
        "test_residue_computation",
        "test_essential_singularity",
        "test_removable_singularity"
    ]
    
    Note: Contour integration tests
    Let contour_integration_tests be [
        "test_cauchy_theorem",
        "test_cauchy_integral_formula",
        "test_residue_theorem",
        "test_contour_deformation",
        "test_winding_number"
    ]
    
    Note: Power and Laurent series tests
    Let series_tests be [
        "test_power_series_expansion",
        "test_radius_of_convergence",
        "test_laurent_series_expansion",
        "test_series_convergence_analysis",
        "test_series_manipulation"
    ]
    
    Note: Conformal mapping tests
    Let conformal_mapping_tests be [
        "test_mobius_transformation",
        "test_riemann_mapping_theorem",
        "test_conformal_invariants",
        "test_schwarz_christoffel_formula"
    ]
    
    Note: Harmonic function tests
    Let harmonic_function_tests be [
        "test_harmonic_function_detection",
        "test_harmonic_conjugate",
        "test_dirichlet_problem",
        "test_maximum_principle",
        "test_greens_function"
    ]
    
    Note: Entire function theory tests
    Let entire_function_tests be [
        "test_entire_function_classification",
        "test_hadamard_factorization",
        "test_jensen_formula",
        "test_phragmen_lindelof_principle"
    ]
    
    Note: Advanced integration tests
    Let advanced_integration_tests be [
        "test_complex_line_integral",
        "test_branch_cuts_and_multivalued",
        "test_argument_principle"
    ]
    
    Let all_test_groups be [holomorphic_tests, singularity_residue_tests, contour_integration_tests, 
                           series_tests, conformal_mapping_tests, harmonic_function_tests,
                           entire_function_tests, advanced_integration_tests]
    
    Let group_names be ["Holomorphic Functions", "Singularities & Residues", "Contour Integration", 
                       "Power & Laurent Series", "Conformal Mappings", "Harmonic Functions",
                       "Entire Function Theory", "Advanced Integration"]
    
    For group_index from 0 to Length(all_test_groups) - 1:
        Let test_group be all_test_groups[group_index]
        Let group_name be group_names[group_index]
        Print "Testing " + group_name + "..."
        
        For test_name in test_group:
            Try:
                Let test_result be Call test_name()
                If test_result:
                    Set tests_passed to tests_passed + 1
                    Print "  ✓ " + test_name
                Otherwise:
                    Set tests_failed to tests_failed + 1  
                    Print "  ✗ " + test_name + " (returned false)"
            Catch error:
                Set tests_failed to tests_failed + 1
                Print "  ✗ " + test_name + " (error: " + error.message + ")"
    
    Let total_tests be tests_passed + tests_failed
    Print ""
    Print "Complex Analysis Module Test Results:"
    Print "===================================="
    Print "Tests passed: " + ToString(tests_passed)
    Print "Tests failed: " + ToString(tests_failed)  
    Print "Total tests: " + ToString(total_tests)
    Print "Success rate: " + ToString((tests_passed * 100) / total_tests) + "%"
    
    Return tests_failed == 0