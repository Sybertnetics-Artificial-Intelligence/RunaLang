Note:
tests/unit/libraries/math/analysis/harmonic_test.runa
Unit Tests for Math Analysis Harmonic Analysis Module

This test suite provides comprehensive testing for the harmonic analysis module including:
- Fourier series and Fourier transforms
- Discrete Fourier Transform (DFT) and Fast Fourier Transform (FFT)
- Wavelets and wavelet transforms
- Window functions and spectral analysis
- Convolution and correlation operations
- Hilbert transforms and analytic signals
- Filter design and frequency domain analysis
- Parseval's theorem and energy conservation
- Sampling theory and Nyquist criterion
- Time-frequency analysis and spectrograms
:End Note

Import "stdlib/math/analysis/harmonic" as HarmonicAnalysis
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "generate_sine_wave" that takes frequency as String, amplitude as String, phase as String, sample_count as Integer returns List[String]:
    Note: Generate discrete sine wave samples
    Let samples be List[String]()
    
    For n from 0 to sample_count - 1:
        Let t be n / (sample_count - 1.0)
        Let omega be 2.0 * 3.141592653589793 * Parse frequency as Float
        Let value be Parse amplitude as Float * Sin(omega * t + Parse phase as Float)
        Set samples to samples.append(ToString(value))
    
    Return samples

Process called "generate_cosine_wave" that takes frequency as String, amplitude as String, phase as String, sample_count as Integer returns List[String]:
    Note: Generate discrete cosine wave samples
    Let samples be List[String]()
    
    For n from 0 to sample_count - 1:
        Let t be n / (sample_count - 1.0)
        Let omega be 2.0 * 3.141592653589793 * Parse frequency as Float
        Let value be Parse amplitude as Float * Cos(omega * t + Parse phase as Float)
        Set samples to samples.append(ToString(value))
    
    Return samples

Process called "assert_complex_vector_approximately_equal" that takes vec1 as List[String], vec2 as List[String], tolerance as Float returns Boolean:
    Note: Assert two complex vectors are approximately equal
    Assert.AreEqual(Length(vec1), Length(vec2))
    
    For i from 0 to Length(vec1) - 1:
        Let complex1 be HarmonicAnalysis.parse_complex_string(vec1[i])
        Let complex2 be HarmonicAnalysis.parse_complex_string(vec2[i])
        
        Let real_diff be AbsoluteValue(Parse complex1["real"] as Float - Parse complex2["real"] as Float)
        Let imag_diff be AbsoluteValue(Parse complex1["imaginary"] as Float - Parse complex2["imaginary"] as Float)
        
        Assert.IsTrue(real_diff <= tolerance)
        Assert.IsTrue(imag_diff <= tolerance)
    
    Return true

Process called "compute_signal_energy" that takes signal as List[String] returns String:
    Note: Compute total energy of a discrete signal
    Let energy be 0.0
    
    For sample in signal:
        Let magnitude be AbsoluteValue(Parse sample as Float)
        Set energy to energy + magnitude * magnitude
    
    Return ToString(energy)

Process called "create_test_signal" that takes signal_type as String, length as Integer returns List[String]:
    Note: Create various test signals for analysis
    If signal_type == "impulse":
        Let signal be List[String]()
        For i from 0 to length - 1:
            If i == 0:
                Set signal to signal.append("1")
            Otherwise:
                Set signal to signal.append("0")
        Return signal
    
    If signal_type == "step":
        Let signal be List[String]()
        For i from 0 to length - 1:
            Set signal to signal.append("1")
        Return signal
    
    If signal_type == "chirp":
        Let signal be List[String]()
        For n from 0 to length - 1:
            Let t be n / (length - 1.0)
            Let freq be 1.0 + 10.0 * t  
            Let value be Sin(2.0 * 3.141592653589793 * freq * t)
            Set signal to signal.append(ToString(value))
        Return signal
    
    Return List[String]()

Process called "generate_noise_signal" that takes noise_type as String, length as Integer, amplitude as String returns List[String]:
    Note: Generate different types of noise signals
    Let signal be List[String]()
    Let amp be Parse amplitude as Float
    
    For n from 0 to length - 1:
        Let noise_value be 0.0
        
        If noise_type == "white":
            Set noise_value to (Random() - 0.5) * 2.0 * amp
        
        If noise_type == "pink":
            Note: Simple approximation of pink noise
            Set noise_value to (Random() - 0.5) * 2.0 * amp / SquareRoot(n + 1)
        
        Set signal to signal.append(ToString(noise_value))
    
    Return signal

Note: =====================================================================
Note: FOURIER SERIES TESTS
Note: =====================================================================

Process called "test_fourier_series_square_wave" that takes no parameters returns Boolean:
    Note: Test Fourier series expansion of square wave
    Let period be "2"
    Let harmonics be 10
    
    Let square_wave_signal be HarmonicAnalysis.PeriodicSignal()
    Set square_wave_signal.period to period
    Set square_wave_signal.type to "square_wave"
    Set square_wave_signal.amplitude to "1"
    
    Let fourier_series be HarmonicAnalysis.fourier_series_expansion(square_wave_signal, harmonics)
    
    Assert.AreEqual(Length(fourier_series.coefficients), harmonics + 1)
    
    Note: DC component should be zero for symmetric square wave
    Assert.IsTrue(AbsoluteValue(Parse fourier_series.coefficients[0] as Float) < 1e-10)
    
    Note: Only odd harmonics should be present
    For n from 1 to harmonics:
        If n % 2 == 0:
            Assert.IsTrue(AbsoluteValue(Parse fourier_series.coefficients[n] as Float) < 1e-10)
        Otherwise:
            Assert.IsTrue(AbsoluteValue(Parse fourier_series.coefficients[n] as Float) > 0.1)
    
    Return true

Process called "test_fourier_series_sawtooth_wave" that takes no parameters returns Boolean:
    Note: Test Fourier series of sawtooth wave
    Let period be "1"
    Let harmonics be 15
    
    Let sawtooth_signal be HarmonicAnalysis.PeriodicSignal()
    Set sawtooth_signal.period to period
    Set sawtooth_signal.type to "sawtooth"
    Set sawtooth_signal.amplitude to "1"
    
    Let fourier_series be HarmonicAnalysis.fourier_series_expansion(sawtooth_signal, harmonics)
    
    Assert.AreEqual(Length(fourier_series.coefficients), harmonics + 1)
    
    Note: All harmonics should be present with decreasing amplitude
    For n from 1 to harmonics - 1:
        Let current_coeff be AbsoluteValue(Parse fourier_series.coefficients[n] as Float)
        Let next_coeff be AbsoluteValue(Parse fourier_series.coefficients[n + 1] as Float)
        Assert.IsTrue(current_coeff >= next_coeff)
    
    Return true

Process called "test_fourier_series_convergence" that takes no parameters returns Boolean:
    Note: Test convergence of Fourier series
    Let signal be HarmonicAnalysis.PeriodicSignal()
    Set signal.period to "2"
    Set signal.type to "triangle_wave"
    Set signal.amplitude to "2"
    
    Let convergence_test be HarmonicAnalysis.test_fourier_convergence(signal, "uniform")
    Assert.IsTrue(convergence_test.converges_uniformly)
    
    Let pointwise_convergence be HarmonicAnalysis.test_fourier_convergence(signal, "pointwise")
    Assert.IsTrue(pointwise_convergence.converges_pointwise)
    
    Return true

Process called "test_gibbs_phenomenon" that takes no parameters returns Boolean:
    Note: Test Gibbs phenomenon in Fourier series
    Let discontinuous_signal be HarmonicAnalysis.PeriodicSignal()
    Set discontinuous_signal.period to "2"
    Set discontinuous_signal.type to "square_wave"
    Set discontinuous_signal.amplitude to "1"
    
    Let gibbs_analysis be HarmonicAnalysis.analyze_gibbs_phenomenon(discontinuous_signal, 50)
    
    Assert.IsTrue(gibbs_analysis.contains("overshoot_percentage"))
    Assert.IsTrue(Parse gibbs_analysis["overshoot_percentage"] as Float > 8.0)  
    Assert.IsTrue(Parse gibbs_analysis["overshoot_percentage"] as Float < 10.0) 
    
    Return true

Note: =====================================================================
Note: FOURIER TRANSFORM TESTS
Note: =====================================================================

Process called "test_fourier_transform_impulse" that takes no parameters returns Boolean:
    Note: Test Fourier transform of impulse function
    Let impulse_signal be create_test_signal("impulse", 64)
    
    Let fourier_transform be HarmonicAnalysis.discrete_fourier_transform(impulse_signal)
    
    Assert.AreEqual(Length(fourier_transform), Length(impulse_signal))
    
    Note: Fourier transform of impulse should be constant
    Let first_magnitude be HarmonicAnalysis.compute_complex_modulus_from_string(fourier_transform[0])
    For i from 1 to Length(fourier_transform) - 1:
        Let magnitude be HarmonicAnalysis.compute_complex_modulus_from_string(fourier_transform[i])
        Assert.IsTrue(AbsoluteValue(magnitude - first_magnitude) < 1e-10)
    
    Return true

Process called "test_fourier_transform_sine_wave" that takes no parameters returns Boolean:
    Note: Test Fourier transform of sine wave
    Let sine_signal be generate_sine_wave("5", "1", "0", 128)
    
    Let fourier_transform be HarmonicAnalysis.discrete_fourier_transform(sine_signal)
    
    Note: Should have peaks at ±5 Hz (scaled appropriately for discrete case)
    Let spectrum_magnitude be List[String]()
    For coefficient in fourier_transform:
        Let magnitude be HarmonicAnalysis.compute_complex_modulus_from_string(coefficient)
        Set spectrum_magnitude to spectrum_magnitude.append(ToString(magnitude))
    
    Note: Find peak frequencies
    Let peak_locations be HarmonicAnalysis.find_spectral_peaks(spectrum_magnitude, "0.5")
    Assert.IsTrue(Length(peak_locations) >= 2)
    
    Return true

Process called "test_fourier_transform_linearity" that takes no parameters returns Boolean:
    Note: Test linearity property of Fourier transform
    Let signal1 be generate_sine_wave("3", "1", "0", 64)
    Let signal2 be generate_cosine_wave("7", "2", "0", 64)
    
    Let ft1 be HarmonicAnalysis.discrete_fourier_transform(signal1)
    Let ft2 be HarmonicAnalysis.discrete_fourier_transform(signal2)
    
    Note: Compute linear combination of signals
    Let combined_signal be List[String]()
    For i from 0 to Length(signal1) - 1:
        Let combined_value be Parse signal1[i] as Float + Parse signal2[i] as Float
        Set combined_signal to combined_signal.append(ToString(combined_value))
    
    Let ft_combined be HarmonicAnalysis.discrete_fourier_transform(combined_signal)
    
    Note: Compute linear combination of transforms
    Let ft_linear_combination be List[String]()
    For i from 0 to Length(ft1) - 1:
        Let complex1 be HarmonicAnalysis.parse_complex_string(ft1[i])
        Let complex2 be HarmonicAnalysis.parse_complex_string(ft2[i])
        
        Let real_part be Parse complex1["real"] as Float + Parse complex2["real"] as Float
        Let imag_part be Parse complex1["imaginary"] as Float + Parse complex2["imaginary"] as Float
        
        Let combined_complex be ToString(real_part) + "+" + ToString(imag_part) + "i"
        Set ft_linear_combination to ft_linear_combination.append(combined_complex)
    
    Assert.IsTrue(assert_complex_vector_approximately_equal(ft_combined, ft_linear_combination, 1e-10))
    
    Return true

Process called "test_fourier_transform_time_shift" that takes no parameters returns Boolean:
    Note: Test time shift property of Fourier transform
    Let original_signal be generate_sine_wave("4", "1", "0", 64)
    Let shifted_signal be generate_sine_wave("4", "1", "1.57079632679", 64)  
    
    Let ft_original be HarmonicAnalysis.discrete_fourier_transform(original_signal)
    Let ft_shifted be HarmonicAnalysis.discrete_fourier_transform(shifted_signal)
    
    Note: Magnitudes should be equal, phases should differ
    For i from 0 to Length(ft_original) - 1:
        Let mag_original be HarmonicAnalysis.compute_complex_modulus_from_string(ft_original[i])
        Let mag_shifted be HarmonicAnalysis.compute_complex_modulus_from_string(ft_shifted[i])
        
        Assert.IsTrue(AbsoluteValue(mag_original - mag_shifted) < 1e-10)
    
    Return true

Note: =====================================================================
Note: FFT AND DFT TESTS
Note: =====================================================================

Process called "test_fft_vs_dft_equivalence" that takes no parameters returns Boolean:
    Note: Test FFT produces same results as DFT
    Let test_signal be generate_sine_wave("2", "3", "0.5", 128)
    
    Let dft_result be HarmonicAnalysis.discrete_fourier_transform(test_signal)
    Let fft_result be HarmonicAnalysis.fast_fourier_transform(test_signal)
    
    Assert.IsTrue(assert_complex_vector_approximately_equal(dft_result, fft_result, 1e-10))
    
    Return true

Process called "test_fft_inverse_property" that takes no parameters returns Boolean:
    Note: Test FFT inverse property
    Let original_signal be generate_cosine_wave("6", "2", "1", 64)
    
    Let fft_forward be HarmonicAnalysis.fast_fourier_transform(original_signal)
    Let fft_inverse be HarmonicAnalysis.inverse_fast_fourier_transform(fft_forward)
    
    Note: Convert complex result back to real (taking real part)
    Let reconstructed_signal be List[String]()
    For complex_sample in fft_inverse:
        Let complex_parsed be HarmonicAnalysis.parse_complex_string(complex_sample)
        Set reconstructed_signal to reconstructed_signal.append(complex_parsed["real"])
    
    For i from 0 to Length(original_signal) - 1:
        Assert.IsTrue(AbsoluteValue(Parse original_signal[i] as Float - Parse reconstructed_signal[i] as Float) < 1e-10)
    
    Return true

Process called "test_fft_power_of_two_optimization" that takes no parameters returns Boolean:
    Note: Test FFT performance optimization for power-of-two lengths
    Let signal_64 be generate_sine_wave("1", "1", "0", 64)   
    Let signal_63 be generate_sine_wave("1", "1", "0", 63)   
    
    Let performance_64 be HarmonicAnalysis.benchmark_fft_performance(signal_64)
    Let performance_63 be HarmonicAnalysis.benchmark_fft_performance(signal_63)
    
    Note: Power-of-two should be faster (or at least not slower)
    Assert.IsTrue(Parse performance_64["execution_time"] as Float <= Parse performance_63["execution_time"] as Float * 1.5)
    
    Return true

Process called "test_zero_padding_effects" that takes no parameters returns Boolean:
    Note: Test effects of zero padding on FFT
    Let original_signal be generate_sine_wave("3", "1", "0", 32)
    
    Let padded_signal be List[String]()
    For sample in original_signal:
        Set padded_signal to padded_signal.append(sample)
    For i from 0 to 31:
        Set padded_signal to padded_signal.append("0")
    
    Let fft_original be HarmonicAnalysis.fast_fourier_transform(original_signal)
    Let fft_padded be HarmonicAnalysis.fast_fourier_transform(padded_signal)
    
    Assert.AreEqual(Length(fft_padded), 2 * Length(fft_original))
    
    Note: Zero padding should improve frequency resolution
    Let resolution_original be HarmonicAnalysis.compute_frequency_resolution(Length(original_signal), "1")
    Let resolution_padded be HarmonicAnalysis.compute_frequency_resolution(Length(padded_signal), "1")
    
    Assert.IsTrue(Parse resolution_padded as Float < Parse resolution_original as Float)
    
    Return true

Note: =====================================================================
Note: WAVELET TRANSFORM TESTS
Note: =====================================================================

Process called "test_wavelet_transform_properties" that takes no parameters returns Boolean:
    Note: Test basic wavelet transform properties
    Let signal be generate_sine_wave("4", "1", "0", 256)
    Let wavelet_type be "morlet"
    
    Let wavelet_transform be HarmonicAnalysis.continuous_wavelet_transform(signal, wavelet_type)
    
    Assert.IsTrue(wavelet_transform.time_frequency_resolution.contains("uncertainty_principle"))
    Assert.IsTrue(Length(wavelet_transform.coefficients) > 0)
    
    Return true

Process called "test_discrete_wavelet_transform" that takes no parameters returns Boolean:
    Note: Test discrete wavelet transform
    Let signal be create_test_signal("chirp", 128)
    Let wavelet_family be "daubechies"
    Let wavelet_order be 4
    
    Let dwt_result be HarmonicAnalysis.discrete_wavelet_transform(signal, wavelet_family, wavelet_order)
    
    Assert.IsTrue(dwt_result.contains("approximation_coefficients"))
    Assert.IsTrue(dwt_result.contains("detail_coefficients"))
    
    Note: Test perfect reconstruction
    Let reconstructed_signal be HarmonicAnalysis.inverse_discrete_wavelet_transform(dwt_result)
    
    For i from 0 to Length(signal) - 1:
        Assert.IsTrue(AbsoluteValue(Parse signal[i] as Float - Parse reconstructed_signal[i] as Float) < 1e-8)
    
    Return true

Process called "test_wavelet_multiresolution_analysis" that takes no parameters returns Boolean:
    Note: Test multiresolution analysis using wavelets
    Let signal be generate_sine_wave("2", "1", "0", 512)
    Let noise be generate_noise_signal("white", 512, "0.1")
    
    Note: Add noise to signal
    Let noisy_signal be List[String]()
    For i from 0 to Length(signal) - 1:
        Let noisy_value be Parse signal[i] as Float + Parse noise[i] as Float
        Set noisy_signal to noisy_signal.append(ToString(noisy_value))
    
    Let mra_result be HarmonicAnalysis.multiresolution_analysis(noisy_signal, "daubechies", 3)
    
    Assert.AreEqual(mra_result.decomposition_levels, 3)
    Assert.IsTrue(Length(mra_result.detail_levels) == 3)
    
    Note: Test denoising capability
    Let denoised_signal be HarmonicAnalysis.wavelet_denoise(noisy_signal, "soft_thresholding")
    Let snr_improvement be HarmonicAnalysis.compute_snr_improvement(signal, noisy_signal, denoised_signal)
    
    Assert.IsTrue(Parse snr_improvement as Float > 0)
    
    Return true

Note: =====================================================================
Note: SPECTRAL ANALYSIS TESTS
Note: =====================================================================

Process called "test_power_spectral_density" that takes no parameters returns Boolean:
    Note: Test power spectral density estimation
    Let signal be generate_sine_wave("10", "2", "0", 1024)
    
    Let psd_welch be HarmonicAnalysis.power_spectral_density(signal, "welch")
    Let psd_periodogram be HarmonicAnalysis.power_spectral_density(signal, "periodogram")
    
    Assert.IsTrue(Length(psd_welch.frequencies) == Length(psd_welch.power_values))
    Assert.IsTrue(Length(psd_periodogram.frequencies) == Length(psd_periodogram.power_values))
    
    Note: Find peak frequency
    Let peak_frequency_welch be HarmonicAnalysis.find_peak_frequency(psd_welch)
    Assert.IsTrue(AbsoluteValue(Parse peak_frequency_welch as Float - 10.0) < 1.0)
    
    Return true

Process called "test_window_functions" that takes no parameters returns Boolean:
    Note: Test various window functions
    Let window_length be 64
    
    Let hamming_window be HarmonicAnalysis.generate_window("hamming", window_length)
    Let hanning_window be HarmonicAnalysis.generate_window("hanning", window_length)
    Let blackman_window be HarmonicAnalysis.generate_window("blackman", window_length)
    
    Assert.AreEqual(Length(hamming_window), window_length)
    Assert.AreEqual(Length(hanning_window), window_length)
    Assert.AreEqual(Length(blackman_window), window_length)
    
    Note: Test window properties (symmetry, edge values)
    For window in [hamming_window, hanning_window]:
        Assert.IsTrue(AbsoluteValue(Parse window[0] as Float - Parse window[window_length - 1] as Float) < 1e-10)
        Assert.IsTrue(Parse window[window_length / 2] as Float > Parse window[0] as Float)
    
    Return true

Process called "test_spectrogram_analysis" that takes no parameters returns Boolean:
    Note: Test spectrogram computation
    Let signal be create_test_signal("chirp", 2048)
    Let window_size be 256
    Let overlap be 128
    
    Let spectrogram be HarmonicAnalysis.compute_spectrogram(signal, window_size, overlap, "hanning")
    
    Assert.IsTrue(spectrogram.time_bins > 0)
    Assert.IsTrue(spectrogram.frequency_bins > 0)
    Assert.AreEqual(Length(spectrogram.magnitude_matrix), spectrogram.time_bins)
    
    Note: Test time-frequency resolution trade-off
    Let tf_resolution be HarmonicAnalysis.analyze_tf_resolution(spectrogram)
    Assert.IsTrue(tf_resolution.contains("time_resolution"))
    Assert.IsTrue(tf_resolution.contains("frequency_resolution"))
    
    Return true

Note: =====================================================================
Note: CONVOLUTION AND CORRELATION TESTS
Note: =====================================================================

Process called "test_convolution_properties" that takes no parameters returns Boolean:
    Note: Test convolution properties
    Let signal1 be generate_sine_wave("2", "1", "0", 32)
    Let signal2 be generate_cosine_wave("3", "1", "0", 32)
    
    Let conv_12 be HarmonicAnalysis.convolution(signal1, signal2)
    Let conv_21 be HarmonicAnalysis.convolution(signal2, signal1)
    
    Note: Test commutativity
    Assert.IsTrue(Length(conv_12) == Length(conv_21))
    For i from 0 to Length(conv_12) - 1:
        Assert.IsTrue(AbsoluteValue(Parse conv_12[i] as Float - Parse conv_21[i] as Float) < 1e-10)
    
    Return true

Process called "test_circular_convolution" that takes no parameters returns Boolean:
    Note: Test circular convolution
    Let signal1 be ["1", "2", "3", "4"]
    Let signal2 be ["0", "1", "0.5", "0"]
    
    Let circular_conv be HarmonicAnalysis.circular_convolution(signal1, signal2)
    
    Assert.AreEqual(Length(circular_conv), Length(signal1))
    
    Note: Test relationship to DFT
    Let dft1 be HarmonicAnalysis.discrete_fourier_transform(signal1)
    Let dft2 be HarmonicAnalysis.discrete_fourier_transform(signal2)
    
    Let product_dft be List[String]()
    For i from 0 to Length(dft1) - 1:
        Let complex1 be HarmonicAnalysis.parse_complex_string(dft1[i])
        Let complex2 be HarmonicAnalysis.parse_complex_string(dft2[i])
        
        Let product_real be Parse complex1["real"] as Float * Parse complex2["real"] as Float - Parse complex1["imaginary"] as Float * Parse complex2["imaginary"] as Float
        Let product_imag be Parse complex1["real"] as Float * Parse complex2["imaginary"] as Float + Parse complex1["imaginary"] as Float * Parse complex2["real"] as Float
        
        Set product_dft to product_dft.append(ToString(product_real) + "+" + ToString(product_imag) + "i")
    
    Let idft_product be HarmonicAnalysis.inverse_discrete_fourier_transform(product_dft)
    
    Note: Convert to real values and compare
    For i from 0 to Length(circular_conv) - 1:
        Let idft_real be HarmonicAnalysis.parse_complex_string(idft_product[i])["real"]
        Assert.IsTrue(AbsoluteValue(Parse circular_conv[i] as Float - Parse idft_real as Float) < 1e-10)
    
    Return true

Process called "test_cross_correlation" that takes no parameters returns Boolean:
    Note: Test cross-correlation for signal detection
    Let template be generate_sine_wave("5", "1", "0", 50)
    
    Note: Create signal with template embedded in noise
    Let noise be generate_noise_signal("white", 200, "0.3")
    Let signal_with_template be List[String]()
    
    For i from 0 to 199:
        If i >= 75 and i < 125:
            Let template_value be Parse template[i - 75] as Float
            Let noisy_value be template_value + Parse noise[i] as Float
            Set signal_with_template to signal_with_template.append(ToString(noisy_value))
        Otherwise:
            Set signal_with_template to signal_with_template.append(noise[i])
    
    Let cross_corr be HarmonicAnalysis.cross_correlation(signal_with_template, template)
    
    Note: Find peak in cross-correlation
    Let peak_location be HarmonicAnalysis.find_correlation_peak(cross_corr)
    
    Note: Peak should be around position 75 (where template was embedded)
    Assert.IsTrue(AbsoluteValue(Parse peak_location as Float - 75.0) < 10.0)
    
    Return true

Note: =====================================================================
Note: HILBERT TRANSFORM TESTS
Note: =====================================================================

Process called "test_hilbert_transform_properties" that takes no parameters returns Boolean:
    Note: Test Hilbert transform properties
    Let signal be generate_cosine_wave("4", "1", "0", 128)
    
    Let hilbert_transform be HarmonicAnalysis.hilbert_transform(signal)
    
    Assert.AreEqual(Length(hilbert_transform), Length(signal))
    
    Note: Hilbert transform of cosine should be sine (with sign)
    Let expected_sine be generate_sine_wave("4", "1", "0", 128)
    
    For i from 0 to Length(signal) - 1:
        Let expected_value be -Parse expected_sine[i] as Float  
        Assert.IsTrue(AbsoluteValue(Parse hilbert_transform[i] as Float - expected_value) < 1e-8)
    
    Return true

Process called "test_analytic_signal" that takes no parameters returns Boolean:
    Note: Test analytic signal construction
    Let real_signal be generate_cosine_wave("3", "2", "0", 64)
    
    Let analytic_signal be HarmonicAnalysis.construct_analytic_signal(real_signal)
    
    Assert.AreEqual(Length(analytic_signal.real_part), Length(real_signal))
    Assert.AreEqual(Length(analytic_signal.imaginary_part), Length(real_signal))
    
    Note: Real part should match original signal
    For i from 0 to Length(real_signal) - 1:
        Assert.IsTrue(AbsoluteValue(Parse analytic_signal.real_part[i] as Float - Parse real_signal[i] as Float) < 1e-10)
    
    Note: Test instantaneous amplitude and phase
    Let inst_amplitude be HarmonicAnalysis.instantaneous_amplitude(analytic_signal)
    Let inst_phase be HarmonicAnalysis.instantaneous_phase(analytic_signal)
    
    Assert.AreEqual(Length(inst_amplitude), Length(real_signal))
    Assert.AreEqual(Length(inst_phase), Length(real_signal))
    
    Return true

Note: =====================================================================
Note: PARSEVAL'S THEOREM TESTS
Note: =====================================================================

Process called "test_parsevals_theorem" that takes no parameters returns Boolean:
    Note: Test Parseval's theorem (energy conservation)
    Let signal be generate_sine_wave("7", "3", "0.5", 256)
    
    Let time_domain_energy be compute_signal_energy(signal)
    
    Let fft_result be HarmonicAnalysis.fast_fourier_transform(signal)
    Let frequency_domain_energy be compute_signal_energy(fft_result)
    
    Note: Energy should be conserved (up to scaling factor)
    Let energy_ratio be Parse frequency_domain_energy as Float / Parse time_domain_energy as Float
    Let expected_ratio be Length(signal)  
    
    Assert.IsTrue(AbsoluteValue(energy_ratio - expected_ratio) < 1e-6)
    
    Return true

Process called "test_energy_spectral_density" that takes no parameters returns Boolean:
    Note: Test energy spectral density calculation
    Let signal be generate_cosine_wave("6", "2", "0", 512)
    
    Let energy_spectrum be HarmonicAnalysis.energy_spectral_density(signal)
    
    Assert.AreEqual(Length(energy_spectrum.frequencies), Length(energy_spectrum.energy_values))
    
    Note: Total energy from spectrum should match time domain
    Let total_spectral_energy be 0.0
    For energy_value in energy_spectrum.energy_values:
        Set total_spectral_energy to total_spectral_energy + Parse energy_value as Float
    
    Let time_domain_energy be Parse compute_signal_energy(signal) as Float
    Assert.IsTrue(AbsoluteValue(total_spectral_energy - time_domain_energy) < 1e-8)
    
    Return true

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all harmonic analysis module tests
    Let tests_passed be 0
    Let tests_failed be 0
    
    Note: Fourier series tests
    Let fourier_series_tests be [
        "test_fourier_series_square_wave",
        "test_fourier_series_sawtooth_wave",
        "test_fourier_series_convergence",
        "test_gibbs_phenomenon"
    ]
    
    Note: Fourier transform tests
    Let fourier_transform_tests be [
        "test_fourier_transform_impulse",
        "test_fourier_transform_sine_wave",
        "test_fourier_transform_linearity",
        "test_fourier_transform_time_shift"
    ]
    
    Note: FFT and DFT tests
    Let fft_dft_tests be [
        "test_fft_vs_dft_equivalence",
        "test_fft_inverse_property",
        "test_fft_power_of_two_optimization",
        "test_zero_padding_effects"
    ]
    
    Note: Wavelet transform tests
    Let wavelet_tests be [
        "test_wavelet_transform_properties",
        "test_discrete_wavelet_transform",
        "test_wavelet_multiresolution_analysis"
    ]
    
    Note: Spectral analysis tests
    Let spectral_analysis_tests be [
        "test_power_spectral_density",
        "test_window_functions",
        "test_spectrogram_analysis"
    ]
    
    Note: Convolution and correlation tests
    Let convolution_correlation_tests be [
        "test_convolution_properties",
        "test_circular_convolution",
        "test_cross_correlation"
    ]
    
    Note: Hilbert transform tests
    Let hilbert_tests be [
        "test_hilbert_transform_properties",
        "test_analytic_signal"
    ]
    
    Note: Parseval's theorem tests
    Let parseval_tests be [
        "test_parsevals_theorem",
        "test_energy_spectral_density"
    ]
    
    Let all_test_groups be [fourier_series_tests, fourier_transform_tests, fft_dft_tests, 
                           wavelet_tests, spectral_analysis_tests, convolution_correlation_tests,
                           hilbert_tests, parseval_tests]
    
    Let group_names be ["Fourier Series", "Fourier Transforms", "FFT & DFT", 
                       "Wavelet Transforms", "Spectral Analysis", "Convolution & Correlation",
                       "Hilbert Transforms", "Parseval's Theorem"]
    
    For group_index from 0 to Length(all_test_groups) - 1:
        Let test_group be all_test_groups[group_index]
        Let group_name be group_names[group_index]
        Print "Testing " + group_name + "..."
        
        For test_name in test_group:
            Try:
                Let test_result be Call test_name()
                If test_result:
                    Set tests_passed to tests_passed + 1
                    Print "  ✓ " + test_name
                Otherwise:
                    Set tests_failed to tests_failed + 1  
                    Print "  ✗ " + test_name + " (returned false)"
            Catch error:
                Set tests_failed to tests_failed + 1
                Print "  ✗ " + test_name + " (error: " + error.message + ")"
    
    Let total_tests be tests_passed + tests_failed
    Print ""
    Print "Harmonic Analysis Module Test Results:"
    Print "====================================="
    Print "Tests passed: " + ToString(tests_passed)
    Print "Tests failed: " + ToString(tests_failed)  
    Print "Total tests: " + ToString(total_tests)
    Print "Success rate: " + ToString((tests_passed * 100) / total_tests) + "%"
    
    Return tests_failed == 0