Note:
tests/unit/libraries/math/analysis/measure_test.runa
Unit Tests for Math Analysis Measure Theory Module

This test suite provides comprehensive testing for the measure theory module including:
- Measure spaces and sigma-algebras construction
- Lebesgue measure and outer measure theory
- Measurable functions and integration theory
- Convergence theorems (Monotone, Dominated, Fatou)
- Product measures and Fubini's theorem
- Signed measures and decomposition theorems
- Radon-Nikodym theorem and absolute continuity
- Almost everywhere convergence and convergence in measure
- Ergodic theory and martingale convergence
- Hausdorff and Haar measures
:End Note

Import "stdlib/math/analysis/measure" as MeasureTheory
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "create_test_measure_space" that takes base_set_size as Integer returns MeasureTheory.MeasureSpace:
    Note: Create a finite measure space for testing
    Let base_set be Dictionary[String, String]()
    Set base_set["type"] to "finite"
    Set base_set["size"] to ToString(base_set_size)
    
    Let sigma_algebra be List[Dictionary[String, String]]()
    Let empty_set be Dictionary[String, String]()
    Set empty_set["type"] to "empty"
    Set sigma_algebra to sigma_algebra.append(empty_set)
    
    Let full_set be Dictionary[String, String]()
    Set full_set["type"] to "full"
    Set sigma_algebra to sigma_algebra.append(full_set)
    
    Let measure be Dictionary[String, String]()
    Set measure["type"] to "counting"
    Set measure["total"] to ToString(base_set_size)
    
    Let space be MeasureTheory.create_measure_space(base_set, sigma_algebra, measure)
    Return space

Process called "create_lebesgue_interval" that takes start as String, end as String returns MeasureTheory.MeasureSpace:
    Note: Create Lebesgue measure space on interval
    Let lebesgue_space be MeasureTheory.construct_lebesgue_measure(1)
    Set lebesgue_space.domain to Dictionary[String, String]()
    Set lebesgue_space.domain["start"] to start
    Set lebesgue_space.domain["end"] to end
    Return lebesgue_space

Process called "create_simple_function" that takes values as List[String], domains as List[Dictionary[String, String]] returns MeasureTheory.IntegrableFunction:
    Note: Create a simple measurable function
    Let function be MeasureTheory.IntegrableFunction()
    Set function.values to values
    Set function.domains to domains
    Set function.is_simple to true
    Set function.is_measurable to true
    Set function.is_integrable to true
    Return function

Process called "assert_measure_approximately_equal" that takes measure1 as String, measure2 as String, tolerance as Float returns Boolean:
    Note: Assert two measure values are approximately equal
    Let val1 be Parse measure1 as Float
    Let val2 be Parse measure2 as Float
    Let difference be AbsoluteValue(val1 - val2)
    Assert.IsTrue(difference <= tolerance)
    Return true

Process called "generate_test_sets" that takes count as Integer returns List[Dictionary[String, String]]:
    Note: Generate test sets for sigma-algebra operations
    Let sets be List[Dictionary[String, String]]()
    
    For i from 0 to count - 1:
        Let test_set be Dictionary[String, String]()
        Set test_set["type"] to "interval"
        Set test_set["start"] to ToString(i * 0.1)
        Set test_set["end"] to ToString((i + 1) * 0.1)
        Set sets to sets.append(test_set)
    
    Return sets

Process called "create_monotone_function_sequence" that takes length as Integer returns List[MeasureTheory.IntegrableFunction]:
    Note: Create monotone increasing sequence of functions
    Let functions be List[MeasureTheory.IntegrableFunction]()
    
    For n from 1 to length:
        Let values be List[String]()
        For k from 0 to 9:
            Let value be ToString(k / (n * 1.0))
            Set values to values.append(value)
        
        Let domains be generate_test_sets(10)
        Let func be create_simple_function(values, domains)
        Set functions to functions.append(func)
    
    Return functions

Note: =====================================================================
Note: MEASURE SPACE CONSTRUCTION TESTS
Note: =====================================================================

Process called "test_measure_space_creation" that takes no parameters returns Boolean:
    Note: Test creation of measure spaces
    Let space be create_test_measure_space(10)
    
    Assert.IsTrue(space.is_valid)
    Assert.AreEqual(space.base_set["size"], "10")
    Assert.IsTrue(Length(space.sigma_algebra) >= 2)
    
    Return true

Process called "test_sigma_algebra_properties" that takes no parameters returns Boolean:
    Note: Test sigma-algebra closure properties
    Let generating_sets be generate_test_sets(5)
    Let sigma_algebra be MeasureTheory.generate_sigma_algebra(generating_sets)
    
    Assert.IsTrue(sigma_algebra.contains_empty_set)
    Assert.IsTrue(sigma_algebra.closed_under_complements)
    Assert.IsTrue(sigma_algebra.closed_under_countable_unions)
    
    Note: Test that it contains all generating sets
    For generating_set in generating_sets:
        Let contains_set be MeasureTheory.sigma_algebra_contains(sigma_algebra, generating_set)
        Assert.IsTrue(contains_set)
    
    Return true

Process called "test_borel_sigma_algebra" that takes no parameters returns Boolean:
    Note: Test Borel sigma-algebra construction
    Let topological_space be Dictionary[String, String]()
    Set topological_space["type"] to "real_line"
    Set topological_space["topology"] to "standard"
    
    Let borel_algebra be MeasureTheory.borel_sigma_algebra(topological_space)
    
    Assert.IsTrue(borel_algebra.is_sigma_algebra)
    Assert.IsTrue(borel_algebra.generated_by_open_sets)
    
    Return true

Process called "test_product_sigma_algebra" that takes no parameters returns Boolean:
    Note: Test product sigma-algebra construction
    Let space1_sets be generate_test_sets(3)
    Let space2_sets be generate_test_sets(3)
    
    Let algebra1 be MeasureTheory.generate_sigma_algebra(space1_sets)
    Let algebra2 be MeasureTheory.generate_sigma_algebra(space2_sets)
    
    Let algebras be [algebra1, algebra2]
    Let product_algebra be MeasureTheory.product_sigma_algebra(algebras)
    
    Assert.IsTrue(product_algebra.is_sigma_algebra)
    Assert.AreEqual(product_algebra.factor_count, 2)
    
    Return true

Process called "test_caratheodory_extension" that takes no parameters returns Boolean:
    Note: Test Carathéodory extension theorem
    Let algebra_sets be generate_test_sets(4)
    Let pre_measure be Dictionary[String, String]()
    Set pre_measure["type"] to "additive"
    Set pre_measure["finite"] to "true"
    
    Let extended_space be MeasureTheory.caratheodory_extension(pre_measure, algebra_sets)
    
    Assert.IsTrue(extended_space.is_complete_measure_space)
    Assert.IsTrue(extended_space.extends_original_measure)
    
    Return true

Note: =====================================================================
Note: LEBESGUE MEASURE TESTS
Note: =====================================================================

Process called "test_lebesgue_measure_intervals" that takes no parameters returns Boolean:
    Note: Test Lebesgue measure of intervals
    Let space be create_lebesgue_interval("0", "1")
    
    Let unit_interval be Dictionary[String, String]()
    Set unit_interval["type"] to "closed_interval"
    Set unit_interval["start"] to "0"
    Set unit_interval["end"] to "1"
    
    Let measure_value be MeasureTheory.compute_measure(space, unit_interval)
    Assert.IsTrue(assert_measure_approximately_equal(measure_value, "1", 1e-10))
    
    Let half_interval be Dictionary[String, String]()
    Set half_interval["type"] to "closed_interval"
    Set half_interval["start"] to "0"
    Set half_interval["end"] to "0.5"
    
    Let half_measure be MeasureTheory.compute_measure(space, half_interval)
    Assert.IsTrue(assert_measure_approximately_equal(half_measure, "0.5", 1e-10))
    
    Return true

Process called "test_outer_measure_construction" that takes no parameters returns Boolean:
    Note: Test outer measure construction
    Let set_function be Dictionary[String, String]()
    Set set_function["type"] to "interval_length"
    Set set_function["domain"] to "real_line"
    
    Let outer_measure be MeasureTheory.outer_measure_construction(set_function)
    
    Assert.IsTrue(outer_measure.is_monotone)
    Assert.IsTrue(outer_measure.is_countably_subadditive)
    Assert.AreEqual(outer_measure.empty_set_measure, "0")
    
    Return true

Process called "test_measurable_sets" that takes no parameters returns Boolean:
    Note: Test measurable set characterization
    Let space be create_lebesgue_interval("0", "2")
    
    Let interval_set be Dictionary[String, String]()
    Set interval_set["type"] to "interval"
    Set interval_set["start"] to "0.3"
    Set interval_set["end"] to "1.7"
    
    Let is_measurable be MeasureTheory.test_measurability(interval_set, space)
    Assert.IsTrue(is_measurable)
    
    Note: Test Carathéodory criterion
    Let satisfies_caratheodory be MeasureTheory.test_caratheodory_criterion(interval_set, space)
    Assert.IsTrue(satisfies_caratheodory)
    
    Return true

Process called "test_measure_completion" that takes no parameters returns Boolean:
    Note: Test measure space completion
    Let incomplete_space be create_test_measure_space(5)
    Set incomplete_space.is_complete to false
    
    Let complete_space be MeasureTheory.complete_measure_space(incomplete_space)
    
    Assert.IsTrue(complete_space.is_complete)
    Assert.IsTrue(complete_space.contains_all_null_sets)
    
    Return true

Note: =====================================================================
Note: MEASURABLE FUNCTION TESTS
Note: =====================================================================

Process called "test_measurable_function_properties" that takes no parameters returns Boolean:
    Note: Test properties of measurable functions
    Let space be create_lebesgue_interval("0", "1")
    
    Let function be Dictionary[String, String]()
    Set function["expression"] to "x^2"
    Set function["domain"] to "[0,1]"
    
    Let is_measurable be MeasureTheory.test_function_measurability(function, space)
    Assert.IsTrue(is_measurable)
    
    Note: Test preimage of Borel sets is measurable
    Let borel_set be Dictionary[String, String]()
    Set borel_set["type"] to "interval"
    Set borel_set["start"] to "0"
    Set borel_set["end"] to "0.25"
    
    Let preimage be MeasureTheory.compute_preimage(function, borel_set)
    Let preimage_measurable be MeasureTheory.test_measurability(preimage, space)
    Assert.IsTrue(preimage_measurable)
    
    Return true

Process called "test_simple_function_approximation" that takes no parameters returns Boolean:
    Note: Test approximation of measurable functions by simple functions
    Let space be create_lebesgue_interval("0", "1")
    
    Let function be Dictionary[String, String]()
    Set function["expression"] to "sqrt(x)"
    Set function["domain"] to "[0,1]"
    
    Let simple_approximations be MeasureTheory.simple_function_approximation(function, space)
    
    Assert.IsTrue(Length(simple_approximations) > 0)
    
    For approximation in simple_approximations:
        Assert.IsTrue(approximation.is_simple)
        Assert.IsTrue(approximation.is_measurable)
    
    Return true

Process called "test_measurable_function_operations" that takes no parameters returns Boolean:
    Note: Test operations on measurable functions preserve measurability
    Let space = create_lebesgue_interval("0", "1")
    
    Let function1 be Dictionary[String, String]()
    Set function1["expression"] to "x"
    Let function2 be Dictionary[String, String]()
    Set function2["expression"] to "x^2"
    
    Let sum_function be MeasureTheory.add_functions(function1, function2)
    Let product_function be MeasureTheory.multiply_functions(function1, function2)
    
    Assert.IsTrue(MeasureTheory.test_function_measurability(sum_function, space))
    Assert.IsTrue(MeasureTheory.test_function_measurability(product_function, space))
    
    Return true

Note: =====================================================================
Note: INTEGRATION THEORY TESTS
Note: =====================================================================

Process called "test_simple_function_integration" that takes no parameters returns Boolean:
    Note: Test integration of simple functions
    Let space be create_lebesgue_interval("0", "1")
    
    Let values be ["1", "2", "3"]
    Let domains be List[Dictionary[String, String]]()
    
    For i from 0 to 2:
        Let domain be Dictionary[String, String]()
        Set domain["type"] to "interval"
        Set domain["start"] to ToString(i / 3.0)
        Set domain["end"] to ToString((i + 1) / 3.0)
        Set domains to domains.append(domain)
    
    Let simple_func be create_simple_function(values, domains)
    
    Let integral_value be MeasureTheory.lebesgue_integral(simple_func, space)
    Let expected_value be (1 + 2 + 3) * (1.0 / 3.0)
    
    Assert.IsTrue(assert_measure_approximately_equal(integral_value, ToString(expected_value), 1e-10))
    
    Return true

Process called "test_monotone_convergence_theorem" that takes no parameters returns Boolean:
    Note: Test Monotone Convergence Theorem
    Let space be create_lebesgue_interval("0", "1")
    Let function_sequence be create_monotone_function_sequence(10)
    
    Let limit_integral be MeasureTheory.monotone_convergence_theorem(function_sequence)
    
    Note: Compute integrals of individual functions
    Let individual_integrals be List[String]()
    For function in function_sequence:
        Let integral be MeasureTheory.lebesgue_integral(function, space)
        Set individual_integrals to individual_integrals.append(integral)
    
    Note: Sequence of integrals should be increasing
    For i from 0 to Length(individual_integrals) - 2:
        Assert.IsTrue(Parse individual_integrals[i] as Float <= Parse individual_integrals[i + 1] as Float)
    
    Assert.IsTrue(Parse limit_integral as Float >= Parse individual_integrals[Length(individual_integrals) - 1] as Float)
    
    Return true

Process called "test_dominated_convergence_theorem" that takes no parameters returns Boolean:
    Note: Test Dominated Convergence Theorem
    Let space be create_lebesgue_interval("0", "1")
    
    Let function_sequence be List[MeasureTheory.IntegrableFunction]()
    For n from 1 to 20:
        Let values be List[String]()
        For k from 0 to 9:
            Let value be ToString(k / (n * 10.0))
            Set values to values.append(value)
        
        Let domains be generate_test_sets(10)
        Let func be create_simple_function(values, domains)
        Set function_sequence to function_sequence.append(func)
    
    Note: Create dominating function
    Let dominating_values be List[String]()
    For k from 0 to 9:
        Set dominating_values to dominating_values.append("1")
    Let dominating_domains be generate_test_sets(10)
    Let dominating_function be create_simple_function(dominating_values, dominating_domains)
    
    Let limit_integral be MeasureTheory.dominated_convergence_theorem(function_sequence, dominating_function)
    
    Assert.IsTrue(Parse limit_integral as Float >= 0)
    Assert.IsTrue(Parse limit_integral as Float <= 1)
    
    Return true

Process called "test_fatou_lemma" that takes no parameters returns Boolean:
    Note: Test Fatou's Lemma
    Let space be create_lebesgue_interval("0", "1")
    
    Let function_sequence be List[MeasureTheory.IntegrableFunction]()
    For n from 1 to 15:
        Let values be List[String]()
        For k from 0 to 9:
            Let value be ToString(k / 10.0 + 1.0 / n)
            Set values to values.append(value)
        
        Let domains be generate_test_sets(10)
        Let func be create_simple_function(values, domains)
        Set function_sequence to function_sequence.append(func)
    
    Let fatou_result be MeasureTheory.fatou_lemma(function_sequence)
    
    Assert.IsTrue(fatou_result.contains("lower_bound"))
    Assert.IsTrue(fatou_result.contains("liminf_integral"))
    
    Return true

Process called "test_function_integrability" that takes no parameters returns Boolean:
    Note: Test integrability conditions
    Let space be create_lebesgue_interval("0", "1")
    
    Let bounded_function be Dictionary[String, String]()
    Set bounded_function["expression"] to "sin(x)"
    Set bounded_function["domain"] to "[0,1]"
    
    Let is_integrable be MeasureTheory.test_integrability(bounded_function, space)
    Assert.IsTrue(is_integrable)
    
    Note: Test unbounded function on finite measure set
    Let unbounded_function be Dictionary[String, String]()
    Set unbounded_function["expression"] to "1/sqrt(x)"
    Set unbounded_function["domain"] to "(0,1]"
    
    Let unbounded_integrable be MeasureTheory.test_integrability(unbounded_function, space)
    Note: This should still be integrable on (0,1]
    Assert.IsTrue(unbounded_integrable)
    
    Return true

Note: =====================================================================
Note: PRODUCT MEASURE TESTS
Note: =====================================================================

Process called "test_product_measure_construction" that takes no parameters returns Boolean:
    Note: Test construction of product measures
    Let space1 be create_lebesgue_interval("0", "1")
    Let space2 be create_lebesgue_interval("0", "1")
    
    Let measures be [space1.measure, space2.measure]
    Let product_measure be MeasureTheory.construct_product_measure(measures)
    
    Assert.IsTrue(product_measure.is_valid)
    Assert.AreEqual(product_measure.dimension, 2)
    
    Note: Test rectangle measure
    Let rectangle be Dictionary[String, String]()
    Set rectangle["type"] to "rectangle"
    Set rectangle["x_interval"] to "[0,0.5]"
    Set rectangle["y_interval"] to "[0,0.3]"
    
    Let rectangle_measure be MeasureTheory.compute_product_measure(product_measure, rectangle)
    Assert.IsTrue(assert_measure_approximately_equal(rectangle_measure, "0.15", 1e-10))
    
    Return true

Process called "test_fubini_theorem" that takes no parameters returns Boolean:
    Note: Test Fubini's theorem for iterated integration
    Let space1 be create_lebesgue_interval("0", "1")
    Let space2 be create_lebesgue_interval("0", "1")
    Let product_space be MeasureTheory.construct_product_measure([space1.measure, space2.measure])
    
    Let function be MeasureTheory.IntegrableFunction()
    Set function.expression to "x*y"
    Set function.domain to "[0,1]×[0,1]"
    Set function.is_integrable to true
    
    Let fubini_result be MeasureTheory.fubini_theorem(function, product_space)
    
    Assert.IsTrue(fubini_result.contains("x_first_integration"))
    Assert.IsTrue(fubini_result.contains("y_first_integration"))
    Assert.IsTrue(fubini_result.contains("integrals_equal"))
    
    Let x_first_value be fubini_result["x_first_integration"]
    Let y_first_value be fubini_result["y_first_integration"]
    
    Assert.IsTrue(assert_measure_approximately_equal(x_first_value, y_first_value, 1e-10))
    Assert.IsTrue(assert_measure_approximately_equal(x_first_value, "0.25", 1e-10))
    
    Return true

Process called "test_tonelli_theorem" that takes no parameters returns Boolean:
    Note: Test Tonelli's theorem for non-negative functions
    Let space1 be create_lebesgue_interval("0", "1")
    Let space2 be create_lebesgue_interval("0", "1")
    Let product_space be MeasureTheory.construct_product_measure([space1.measure, space2.measure])
    
    Let function be Dictionary[String, String]()
    Set function["expression"] to "x^2 + y^2"
    Set function["domain"] to "[0,1]×[0,1]"
    Set function["is_nonnegative"] to "true"
    
    Let tonelli_result be MeasureTheory.tonelli_theorem(function, product_space)
    
    Assert.IsTrue(tonelli_result.contains("iterated_integrals_equal"))
    Assert.IsTrue(tonelli_result.contains("double_integral_value"))
    
    Return true

Note: =====================================================================
Note: SIGNED MEASURE TESTS
Note: =====================================================================

Process called "test_jordan_decomposition" that takes no parameters returns Boolean:
    Note: Test Jordan decomposition of signed measures
    Let signed_measure be Dictionary[String, String]()
    Set signed_measure["type"] to "difference"
    Set signed_measure["positive_part"] to "mu1"
    Set signed_measure["negative_part"] to "mu2"
    
    Let jordan_decomp be MeasureTheory.jordan_decomposition(signed_measure)
    
    Assert.IsTrue(jordan_decomp.contains("positive_measure"))
    Assert.IsTrue(jordan_decomp.contains("negative_measure"))
    Assert.IsTrue(jordan_decomp.contains("mutually_singular"))
    
    Return true

Process called "test_hahn_decomposition" that takes no parameters returns Boolean:
    Note: Test Hahn decomposition theorem
    Let signed_measure be Dictionary[String, String]()
    Set signed_measure["expression"] to "x - 0.5"
    Set signed_measure["domain"] to "[0,1]"
    
    Let hahn_decomp be MeasureTheory.hahn_decomposition(signed_measure)
    
    Assert.IsTrue(hahn_decomp.contains("positive_set"))
    Assert.IsTrue(hahn_decomp.contains("negative_set"))
    Assert.IsTrue(hahn_decomp.contains("disjoint_union"))
    
    Return true

Process called "test_total_variation_measure" that takes no parameters returns Boolean:
    Note: Test total variation measure
    Let signed_measure be Dictionary[String, String]()
    Set signed_measure["type"] to "alternating"
    Set signed_measure["amplitude"] to "1"
    
    Let total_variation be MeasureTheory.total_variation_measure(signed_measure)
    
    Assert.IsTrue(Parse total_variation.total_mass as Float >= 0)
    Assert.IsTrue(total_variation.is_finite)
    
    Return true

Note: =====================================================================
Note: RADON-NIKODYM TESTS
Note: =====================================================================

Process called "test_absolute_continuity" that takes no parameters returns Boolean:
    Note: Test absolute continuity of measures
    Let space be create_lebesgue_interval("0", "1")
    
    Let measure1 be space.measure
    Let measure2 be Dictionary[String, String]()
    Set measure2["type"] to "weighted_lebesgue"
    Set measure2["weight_function"] to "x"
    
    Let is_absolutely_continuous be MeasureTheory.test_absolute_continuity(measure2, measure1)
    Assert.IsTrue(is_absolutely_continuous)
    
    Return true

Process called "test_radon_nikodym_theorem" that takes no parameters returns Boolean:
    Note: Test Radon-Nikodym theorem
    Let space be create_lebesgue_interval("0", "1")
    
    Let base_measure be space.measure
    Let absolutely_continuous_measure be Dictionary[String, String]()
    Set absolutely_continuous_measure["type"] to "density_measure"
    Set absolutely_continuous_measure["density"] to "2*x"
    
    Let rn_result be MeasureTheory.radon_nikodym_theorem(absolutely_continuous_measure, base_measure)
    
    Assert.IsTrue(rn_result.contains("radon_nikodym_derivative"))
    Assert.AreEqual(rn_result["radon_nikodym_derivative"], "2*x")
    
    Return true

Process called "test_lebesgue_decomposition" that takes no parameters returns Boolean:
    Note: Test Lebesgue decomposition theorem
    Let space be create_lebesgue_interval("0", "1")
    
    Let measure1 be space.measure
    Let measure2 be Dictionary[String, String]()
    Set measure2["type"] to "mixed"
    Set measure2["absolutely_continuous_part"] to "x"
    Set measure2["singular_part"] to "delta_0.5"
    
    Let lebesgue_decomp be MeasureTheory.lebesgue_decomposition(measure2, measure1)
    
    Assert.IsTrue(lebesgue_decomp.contains("absolutely_continuous_part"))
    Assert.IsTrue(lebesgue_decomp.contains("singular_part"))
    Assert.IsTrue(lebesgue_decomp.contains("mutually_singular"))
    
    Return true

Note: =====================================================================
Note: CONVERGENCE TESTS
Note: =====================================================================

Process called "test_almost_everywhere_convergence" that takes no parameters returns Boolean:
    Note: Test almost everywhere convergence
    Let space be create_lebesgue_interval("0", "1")
    
    Let function_sequence be List[Dictionary[String, String]]()
    For n from 1 to 30:
        Let func be Dictionary[String, String]()
        Set func["expression"] to "x^" + ToString(n)
        Set func["domain"] to "[0,1]"
        Set function_sequence to function_sequence.append(func)
    
    Let limit_function be Dictionary[String, String]()
    Set limit_function["expression"] to "0"  
    Set limit_function["domain"] to "[0,1)"
    
    Let is_ae_convergent be MeasureTheory.almost_everywhere_convergence(function_sequence, space)
    Assert.IsTrue(is_ae_convergent)
    
    Return true

Process called "test_convergence_in_measure" that takes no parameters returns Boolean:
    Note: Test convergence in measure
    Let space be create_lebesgue_interval("0", "1")
    
    Let function_sequence be List[Dictionary[String, String]]()
    For n from 1 to 25:
        Let func be Dictionary[String, String]()
        Set func["expression"] to "(1/" + ToString(n) + ")*sin(" + ToString(n) + "*π*x)"
        Set func["domain"] to "[0,1]"
        Set function_sequence to function_sequence.append(func)
    
    Let zero_function be Dictionary[String, String]()
    Set zero_function["expression"] to "0"
    Set zero_function["domain"] to "[0,1]"
    
    Let is_convergent_in_measure be MeasureTheory.convergence_in_measure(function_sequence, space)
    Assert.IsTrue(is_convergent_in_measure)
    
    Return true

Process called "test_egorov_theorem" that takes no parameters returns Boolean:
    Note: Test Egorov's theorem
    Let space be create_lebesgue_interval("0", "1")
    
    Let function_sequence be List[Dictionary[String, String]]()
    For n from 1 to 20:
        Let func be Dictionary[String, String]()
        Set func["expression"] to "x^" + ToString(n)
        Set func["domain"] to "[0,1]"
        Set function_sequence to function_sequence.append(func)
    
    Let egorov_result be MeasureTheory.egorov_theorem(function_sequence, space)
    
    Assert.IsTrue(egorov_result.contains("uniform_convergence_set"))
    Assert.IsTrue(egorov_result.contains("exceptional_set_measure_small"))
    
    Return true

Process called "test_lusin_theorem" that takes no parameters returns Boolean:
    Note: Test Lusin's theorem
    Let space be create_lebesgue_interval("0", "1")
    
    Let measurable_function be Dictionary[String, String]()
    Set measurable_function["expression"] to "floor(10*x)/10"
    Set measurable_function["domain"] to "[0,1]"
    
    Let lusin_result be MeasureTheory.lusin_theorem(measurable_function, space)
    
    Assert.IsTrue(lusin_result.contains("continuous_approximation"))
    Assert.IsTrue(lusin_result.contains("small_exceptional_set"))
    
    Return true

Note: =====================================================================
Note: SPECIAL MEASURES TESTS
Note: =====================================================================

Process called "test_hausdorff_measure" that takes no parameters returns Boolean:
    Note: Test Hausdorff measure construction
    Let dimension be "0.5"
    Let metric_space be Dictionary[String, String]()
    Set metric_space["type"] to "cantor_set"
    Set metric_space["dimension"] to "1"
    
    Let hausdorff_measure be MeasureTheory.hausdorff_measure(dimension, metric_space)
    
    Assert.IsTrue(hausdorff_measure.is_outer_measure)
    Assert.IsTrue(hausdorff_measure.is_metric_measure)
    
    Return true

Process called "test_haar_measure" that takes no parameters returns Boolean:
    Note: Test Haar measure on locally compact groups
    Let group be Dictionary[String, String]()
    Set group["type"] to "real_line"
    Set group["operation"] to "addition"
    Set group["topology"] to "standard"
    
    Let haar_measure be MeasureTheory.haar_measure(group)
    
    Assert.IsTrue(haar_measure.is_translation_invariant)
    Assert.IsTrue(haar_measure.is_regular)
    Assert.IsTrue(haar_measure.is_locally_finite)
    
    Return true

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all measure theory module tests
    Let tests_passed be 0
    Let tests_failed be 0
    
    Note: Measure space construction tests
    Let measure_space_tests be [
        "test_measure_space_creation",
        "test_sigma_algebra_properties",
        "test_borel_sigma_algebra",
        "test_product_sigma_algebra",
        "test_caratheodory_extension"
    ]
    
    Note: Lebesgue measure tests
    Let lebesgue_measure_tests be [
        "test_lebesgue_measure_intervals",
        "test_outer_measure_construction",
        "test_measurable_sets",
        "test_measure_completion"
    ]
    
    Note: Measurable function tests
    Let measurable_function_tests be [
        "test_measurable_function_properties",
        "test_simple_function_approximation",
        "test_measurable_function_operations"
    ]
    
    Note: Integration theory tests
    Let integration_tests be [
        "test_simple_function_integration",
        "test_monotone_convergence_theorem",
        "test_dominated_convergence_theorem",
        "test_fatou_lemma",
        "test_function_integrability"
    ]
    
    Note: Product measure tests
    Let product_measure_tests be [
        "test_product_measure_construction",
        "test_fubini_theorem",
        "test_tonelli_theorem"
    ]
    
    Note: Signed measure tests
    Let signed_measure_tests be [
        "test_jordan_decomposition",
        "test_hahn_decomposition",
        "test_total_variation_measure"
    ]
    
    Note: Radon-Nikodym tests
    Let radon_nikodym_tests be [
        "test_absolute_continuity",
        "test_radon_nikodym_theorem",
        "test_lebesgue_decomposition"
    ]
    
    Note: Convergence tests
    Let convergence_tests be [
        "test_almost_everywhere_convergence",
        "test_convergence_in_measure",
        "test_egorov_theorem",
        "test_lusin_theorem"
    ]
    
    Note: Special measures tests
    Let special_measures_tests be [
        "test_hausdorff_measure",
        "test_haar_measure"
    ]
    
    Let all_test_groups be [measure_space_tests, lebesgue_measure_tests, measurable_function_tests, 
                           integration_tests, product_measure_tests, signed_measure_tests,
                           radon_nikodym_tests, convergence_tests, special_measures_tests]
    
    Let group_names be ["Measure Spaces", "Lebesgue Measure", "Measurable Functions", 
                       "Integration Theory", "Product Measures", "Signed Measures",
                       "Radon-Nikodym Theory", "Convergence Theory", "Special Measures"]
    
    For group_index from 0 to Length(all_test_groups) - 1:
        Let test_group be all_test_groups[group_index]
        Let group_name be group_names[group_index]
        Print "Testing " + group_name + "..."
        
        For test_name in test_group:
            Try:
                Let test_result be Call test_name()
                If test_result:
                    Set tests_passed to tests_passed + 1
                    Print "  ✓ " + test_name
                Otherwise:
                    Set tests_failed to tests_failed + 1  
                    Print "  ✗ " + test_name + " (returned false)"
            Catch error:
                Set tests_failed to tests_failed + 1
                Print "  ✗ " + test_name + " (error: " + error.message + ")"
    
    Let total_tests be tests_passed + tests_failed
    Print ""
    Print "Measure Theory Module Test Results:"
    Print "=================================="
    Print "Tests passed: " + ToString(tests_passed)
    Print "Tests failed: " + ToString(tests_failed)  
    Print "Total tests: " + ToString(total_tests)
    Print "Success rate: " + ToString((tests_passed * 100) / total_tests) + "%"
    
    Return tests_failed == 0