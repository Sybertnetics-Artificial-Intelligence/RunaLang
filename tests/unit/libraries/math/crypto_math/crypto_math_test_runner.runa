Note: Test runner for the math library crypto_math module

Note: 
Note: This module coordinates and executes all tests for cryptographic mathematics operations
Note: including finite field arithmetic, prime generation, hash theory, lattice-based
Note: cryptography, elliptic curves, and advanced cryptographic protocols.
Note: 
Note: It provides a unified interface to run all crypto_math tests and generates
Note: comprehensive reports with detailed statistics and performance metrics.
Note:
Note: Usage:
Note:   runa crypto_math_test_runner.runa                    # Run all tests
Note:   runa crypto_math_test_runner.runa finite_fields      # Run specific module tests
Note:
Note: Author: Generated comprehensive test runner
Note: Version: 1.0.0

Use from "finite_fields_test" take run_finite_fields_tests
Use from "prime_gen_test" take run_prime_gen_tests
Use from "hash_theory_test" take run_hash_theory_tests
Use from "lattice_test" take run_lattice_tests
Use from "elliptic_curves_test" take run_elliptic_curves_tests
Use from "protocols_test" take run_protocols_tests
Use from "stdlib.system.time" take current_time_microseconds
Use from "stdlib.system.args" take get_args

Note: Test module configuration
Type called "TestModuleInfo":
    name as String
    runner as Process that returns [Integer, Integer]
    description as String

Type called "TestResults":
    module_name as String
    passed as Integer
    total as Integer
    duration_microseconds as Integer
    success_rate as Real

Note: Available test modules
Process called "get_test_modules" that returns [TestModuleInfo]:
    Return [
        TestModuleInfo{
            name: "finite_fields",
            runner: run_finite_fields_tests,
            description: "Finite field arithmetic for GF(p) and GF(2^n) operations"
        },
        TestModuleInfo{
            name: "prime_gen",
            runner: run_prime_gen_tests,
            description: "Prime number generation and primality testing algorithms"
        },
        TestModuleInfo{
            name: "hash_theory",
            runner: run_hash_theory_tests,
            description: "Hash function theory and cryptographic analysis"
        },
        TestModuleInfo{
            name: "lattice",
            runner: run_lattice_tests,
            description: "Lattice-based cryptography and post-quantum algorithms"
        },
        TestModuleInfo{
            name: "elliptic_curves",
            runner: run_elliptic_curves_tests,
            description: "Elliptic curve cryptography mathematics and protocols"
        },
        TestModuleInfo{
            name: "protocols",
            runner: run_protocols_tests,
            description: "Advanced cryptographic protocols and zero-knowledge proofs"
        }
    ]

Note: Test execution and reporting functions

Process called "run_single_module" that takes module_info as TestModuleInfo returns TestResults:
    Print("Running " + module_info.name + " tests...")
    Print("Description: " + module_info.description)
    Print("-" * 80)
    
    Let start_time be current_time_microseconds()
    Let [passed, total] be module_info.runner()
    Let end_time be current_time_microseconds()
    Let duration be end_time - start_time
    
    Let success_rate be if total > 0 then (Real(passed) / Real(total)) * 100.0 otherwise 0.0
    
    Print("")
    Print("Module Results:")
    Print("  Tests passed: " + String(passed) + "/" + String(total))
    Print("  Success rate: " + String(success_rate) + "%")
    Print("  Duration: " + String(Real(duration) / 1000.0) + " ms")
    Print("")
    
    Return TestResults{
        module_name: module_info.name,
        passed: passed,
        total: total, 
        duration_microseconds: duration,
        success_rate: success_rate
    }

Process called "print_summary_report" that takes results as [TestResults] returns Nothing:
    Print("=" * 80)
    Print("CRYPTOGRAPHIC MATHEMATICS TEST SUITE - COMPREHENSIVE SUMMARY")
    Print("=" * 80)
    
    Let total_passed be 0
    Let total_tests be 0
    Let total_duration be 0
    
    Note: Calculate totals
    For each result in results:
        total_passed = total_passed + result.passed
        total_tests = total_tests + result.total
        total_duration = total_duration + result.duration_microseconds
    
    Let overall_success_rate be if total_tests > 0 then (Real(total_passed) / Real(total_tests)) * 100.0 otherwise 0.0
    
    Print("\nOVERALL STATISTICS:")
    Print("  Total test modules: " + String(Length(results)))
    Print("  Total tests executed: " + String(total_tests))
    Print("  Total tests passed: " + String(total_passed))
    Print("  Total tests failed: " + String(total_tests - total_passed))
    Print("  Overall success rate: " + String(overall_success_rate) + "%")
    Print("  Total execution time: " + String(Real(total_duration) / 1000000.0) + " seconds")
    Print("  Average time per test: " + String(Real(total_duration) / Real(total_tests) / 1000.0) + " ms")
    
    Print("\nMODULE BREAKDOWN:")
    Print("  Module           Tests    Passed   Failed   Rate     Time(ms)")
    Print("  " + "-" * 70)
    
    For each result in results:
        Let failed be result.total - result.passed
        Let time_ms be Real(result.duration_microseconds) / 1000.0
        Let padded_name be result.module_name + (" " * (15 - Length(result.module_name)))
        Let tests_str be String(result.total) + (" " * (8 - Length(String(result.total))))
        Let passed_str be String(result.passed) + (" " * (8 - Length(String(result.passed))))
        Let failed_str be String(failed) + (" " * (8 - Length(String(failed))))
        Let rate_str be String(result.success_rate)[0:5] + "%" + (" " * (8 - Length(String(result.success_rate)[0:5] + "%")))
        Let time_str be String(time_ms)[0:8]
        
        Print("  " + padded_name + tests_str + passed_str + failed_str + rate_str + time_str)
    
    Print("\nPERFORMANCE ANALYSIS:")
    Let fastest_module be ""
    Let slowest_module be ""
    Let min_time be Real(total_duration)
    Let max_time be 0.0
    
    For each result in results:
        Let avg_time_per_test be Real(result.duration_microseconds) / Real(result.total)
        If avg_time_per_test < min_time:
            min_time = avg_time_per_test
            fastest_module = result.module_name
        If avg_time_per_test > max_time:
            max_time = avg_time_per_test
            slowest_module = result.module_name
    
    Print("  Fastest module (avg per test): " + fastest_module + " (" + String(min_time / 1000.0) + " ms)")
    Print("  Slowest module (avg per test): " + slowest_module + " (" + String(max_time / 1000.0) + " ms)")
    
    Print("\nCRYPTOGRAPHIC MATHEMATICS COVERAGE ASSESSMENT:")
    Print("  Finite Fields: Comprehensive GF(p) and GF(2^n) arithmetic operations")
    Print("    • Prime field arithmetic: addition, multiplication, inversion, exponentiation")
    Print("    • Extension field operations: polynomial arithmetic and irreducible polynomials")
    Print("    • Discrete logarithms: efficient algorithms and security analysis")
    Print("    • Primitive elements: finding and verification of field generators")
    Print("    • Cryptographic applications: ECC field operations and AES S-box computations")
    Print("")
    Print("  Prime Generation: Complete primality testing and cryptographic prime generation")
    Print("    • Primality testing: Miller-Rabin, Solovay-Strassen, and Fermat tests")
    Print("    • Prime generation: probable primes, safe primes, and strong primes")
    Print("    • Cryptographic primes: RSA, Diffie-Hellman, and DSA parameter generation")
    Print("    • Security analysis: timing attack resistance and randomness validation")
    Print("    • Performance optimization: efficient algorithms for large-scale operations")
    Print("")
    Print("  Hash Function Theory: Advanced cryptographic hash analysis and construction")
    Print("    • Hash constructions: Merkle-Damgård and sponge construction analysis")
    Print("    • Security properties: collision resistance, preimage resistance analysis")
    Print("    • Avalanche effect: strict avalanche criterion and bit independence")
    Print("    • Statistical analysis: output distribution uniformity and randomness")
    Print("    • Attack resistance: differential and linear cryptanalysis resistance")
    Print("")
    Print("  Lattice Cryptography: Post-quantum cryptographic foundations")
    Print("    • Lattice problems: shortest vector problem and closest vector problem")
    Print("    • Lattice reduction: LLL and BKZ algorithms with quality assessment")
    Print("    • Learning with errors: LWE and Ring-LWE problem instances")
    Print("    • NTRU cryptosystem: parameter generation and security analysis")
    Print("    • Quantum resistance: security analysis against quantum algorithms")
    Print("")
    Print("  Elliptic Curve Cryptography: Complete ECC mathematical operations")
    Print("    • Point arithmetic: addition, doubling, and scalar multiplication")
    Print("    • Standard curves: secp256k1, P-256, P-384, and P-521 parameters")
    Print("    • Digital signatures: ECDSA mathematics and signature verification")
    Print("    • Key exchange: ECDH shared secret computation and validation")
    Print("    • Security analysis: timing attack resistance and invalid curve protection")
    Print("")
    Print("  Cryptographic Protocols: Advanced protocol mathematics and security")
    Print("    • Zero-knowledge proofs: Schnorr, PLONK, Groth16, and Bulletproofs")
    Print("    • Secret sharing: Shamir's scheme and verifiable secret sharing")
    Print("    • Multiparty computation: secure sum, multiplication, and privacy analysis")
    Print("    • Threshold cryptography: distributed signatures and encryption")
    Print("    • Commitment schemes: Pedersen, hash-based, and vector commitments")
    Print("    • Oblivious transfer: 1-out-of-2, 1-out-of-n, and OT extension")
    
    Print("\nMATHEMATICAL SIGNIFICANCE AND APPLICATIONS:")
    Print("  • Blockchain Technology: Bitcoin, Ethereum, and cryptocurrency mathematics")
    Print("  • Web Security: TLS/SSL cryptographic protocol implementations")
    Print("  • Post-Quantum Cryptography: NIST standardization and quantum resistance")
    Print("  • Privacy-Preserving Technologies: Zero-knowledge proofs and private computing")
    Print("  • Secure Communications: End-to-end encryption and authenticated channels")
    Print("  • Digital Identity: PKI systems and certificate-based authentication")
    Print("  • Financial Cryptography: Digital signatures and secure payment systems")
    Print("  • Cloud Security: Homomorphic encryption and secure multi-party computation")
    
    If overall_success_rate >= 100.0:
        Print("\n🎉 PERFECT SCORE! All cryptographic mathematics tests PASSED!")
        Print("   The cryptographic mathematics library is fully validated and production-ready.")
        Print("   ✓ Finite field arithmetic operations verified for all applications")
        Print("   ✓ Prime generation algorithms validated for cryptographic security")
        Print("   ✓ Hash function theory confirmed for collision and preimage resistance")
        Print("   ✓ Lattice-based cryptography validated for post-quantum security")
        Print("   ✓ Elliptic curve operations verified for ECDSA and ECDH protocols")
        Print("   ✓ Advanced cryptographic protocols validated for zero-knowledge and MPC")
    Otherwise if overall_success_rate >= 95.0:
        Print("\n✅ EXCELLENT! Nearly all tests passed (" + String(overall_success_rate) + "%)")
        Print("   The cryptographic mathematics library is in excellent condition.")
        Print("   Minor issues may need attention in specific edge cases or optimizations.")
        Print("   Ready for production deployment with comprehensive cryptographic support.")
    Otherwise if overall_success_rate >= 90.0:
        Print("\n⚠️  GOOD: Most tests passed (" + String(overall_success_rate) + "%)")
        Print("   Some issues may need attention in:")
        For each result in results:
            If result.success_rate < 95.0:
                Print("   - " + result.module_name + " module (" + String(result.success_rate) + "%)")
        Print("   Review failing tests before production cryptographic deployment.")
    Otherwise:
        Print("\n❌ ATTENTION NEEDED: Success rate is " + String(overall_success_rate) + "%")
        Print("   Significant issues found that require immediate investigation:")
        For each result in results:
            If result.success_rate < 90.0:
                Print("   - " + result.module_name + " module has " + String(result.total - result.passed) + " failing tests")
        Print("   CRITICAL: Review all cryptographic implementations before deployment.")
    
    Print("\n" + "=" * 80)

Process called "print_usage" that returns Nothing:
    Print("Cryptographic Mathematics Test Runner")
    Print("Usage:")
    Print("  runa crypto_math_test_runner.runa              # Run all test modules")
    Print("  runa crypto_math_test_runner.runa <module>     # Run specific module")
    Print("")
    Print("Available modules:")
    Let modules be get_test_modules()
    For each module in modules:
        Print("  " + module.name + " - " + module.description)
    Print("")
    Print("Cryptographic Coverage:")
    Print("  • finite_fields   - GF(p) and GF(2^n) arithmetic for cryptographic applications")
    Print("  • prime_gen       - Primality testing and cryptographic prime generation")  
    Print("  • hash_theory     - Hash function analysis and cryptographic properties")
    Print("  • lattice         - Post-quantum lattice-based cryptography mathematics")
    Print("  • elliptic_curves - ECC point operations, ECDSA, and ECDH protocols")
    Print("  • protocols       - Zero-knowledge proofs, MPC, and advanced cryptography")
    Print("")

Process called "find_module_by_name" that takes name as String returns TestModuleInfo:
    Let modules be get_test_modules()
    For each module in modules:
        If module.name == name:
            Return module
    
    Note: Return empty module if not found
    Return TestModuleInfo{
        name: "",
        runner: run_finite_fields_tests,  Note: Placeholder, won't be used
        description: ""
    }

Process called "run_all_tests" that returns Nothing:
    Print("🔐 RUNA CRYPTOGRAPHIC MATHEMATICS - COMPREHENSIVE TEST SUITE")
    Print("=" * 80)
    Print("Testing cryptographic mathematics foundations and advanced protocols")
    Print("Modules: finite_fields, prime_gen, hash_theory, lattice, elliptic_curves, protocols")
    Print("Coverage: Post-quantum crypto, blockchain math, zero-knowledge proofs, secure MPC")
    Print("=" * 80)
    Print("")
    
    Let modules be get_test_modules()
    Let results be []TestResults
    
    Let overall_start_time be current_time_microseconds()
    
    For each module in modules:
        Let result be run_single_module(module)
        results = results + [result]
        Print("✓ Completed " + module.name + " tests")
        Print("")
    
    Let overall_end_time be current_time_microseconds()
    Let total_suite_time be overall_end_time - overall_start_time
    
    print_summary_report(results)
    
    Print("\nSUITE EXECUTION COMPLETED")
    Print("Total suite execution time: " + String(Real(total_suite_time) / 1000000.0) + " seconds")
    Print("Test suite finished at: " + String(overall_end_time))
    Print("")
    Print("CRYPTOGRAPHIC MATHEMATICS VALIDATION COMPLETE")
    Print("The Runa cryptographic mathematics library has been comprehensively tested")
    Print("across all major areas of modern cryptography including post-quantum algorithms,")
    Print("blockchain mathematics, zero-knowledge proofs, and advanced cryptographic protocols.")

Process called "run_specific_module" that takes module_name as String returns Nothing:
    Let module be find_module_by_name(module_name)
    
    If module.name == "":
        Print("❌ Error: Module '" + module_name + "' not found.")
        Print("")
        print_usage()
        Return
    
    Print("🔐 RUNA CRYPTOGRAPHIC MATHEMATICS - SINGLE MODULE TEST")
    Print("=" * 60)
    Print("Module: " + module.name)
    Print("Focus: " + module.description)
    Print("=" * 60)
    Print("")
    
    Let start_time be current_time_microseconds()
    Let result be run_single_module(module)
    Let end_time be current_time_microseconds()
    
    Print("=" * 60)
    Print("SINGLE MODULE TEST COMPLETED")
    Print("=" * 60)
    Print("Module: " + result.module_name)
    Print("Tests passed: " + String(result.passed) + "/" + String(result.total))
    Print("Success rate: " + String(result.success_rate) + "%")
    Print("Execution time: " + String(Real(result.duration_microseconds) / 1000000.0) + " seconds")
    
    Print("\nModule-Specific Analysis:")
    If result.module_name == "finite_fields":
        Print("  Finite field operations validated:")
        Print("  • GF(p) arithmetic: addition, multiplication, inversion, exponentiation")
        Print("  • GF(2^n) polynomial operations: irreducible polynomials and extensions")
        Print("  • Discrete logarithm computations: efficient algorithms and security")
        Print("  • Cryptographic applications: ECC field operations and AES mathematics")
    Otherwise if result.module_name == "prime_gen":
        Print("  Prime generation algorithms validated:")
        Print("  • Primality testing: Miller-Rabin, Solovay-Strassen, Fermat tests")
        Print("  • Prime generation: probable primes, safe primes, strong primes")
        Print("  • Cryptographic primes: RSA, Diffie-Hellman, DSA parameters")
        Print("  • Security analysis: timing resistance and quality assessment")
    Otherwise if result.module_name == "hash_theory":
        Print("  Hash function theory validated:")
        Print("  • Hash constructions: Merkle-Damgård and sponge constructions")
        Print("  • Security analysis: collision, preimage, second preimage resistance")
        Print("  • Avalanche effect: strict avalanche criterion and bit independence")
        Print("  • Cryptanalysis resistance: differential and linear attack resistance")
    Otherwise if result.module_name == "lattice":
        Print("  Lattice-based cryptography validated:")
        Print("  • Lattice problems: SVP, CVP, and reduction algorithms")
        Print("  • Learning with errors: LWE and Ring-LWE problem instances")
        Print("  • NTRU operations: parameter generation and security analysis")
        Print("  • Post-quantum security: quantum algorithm resistance analysis")
    Otherwise if result.module_name == "elliptic_curves":
        Print("  Elliptic curve cryptography validated:")
        Print("  • Point arithmetic: addition, doubling, scalar multiplication")
        Print("  • Standard curves: secp256k1, P-256, P-384, P-521 operations")
        Print("  • ECDSA mathematics: signature generation and verification")
        Print("  • ECDH protocols: shared secret computation and validation")
    Otherwise if result.module_name == "protocols":
        Print("  Cryptographic protocols validated:")
        Print("  • Zero-knowledge proofs: Schnorr, PLONK, Groth16, Bulletproofs")
        Print("  • Secret sharing: Shamir's scheme and verifiable sharing")
        Print("  • Multiparty computation: secure protocols and privacy analysis")
        Print("  • Advanced protocols: threshold crypto, commitments, oblivious transfer")
    
    If result.success_rate >= 100.0:
        Print("\n🎉 All tests PASSED! Module is fully validated and production-ready.")
    Otherwise if result.success_rate >= 95.0:
        Print("\n✅ Nearly all tests passed! Module is in excellent condition.")
        Print("   Minor optimizations may enhance edge case handling.")
    Otherwise if result.success_rate >= 90.0:
        Print("\n⚠️  Most tests passed. Some edge cases need attention before deployment.")
        Print("   Review failing tests for cryptographic security implications.")
    Otherwise:
        Print("\n❌ Multiple test failures detected. Immediate investigation required.")
        Print("   CRITICAL: Do not deploy until all cryptographic issues are resolved.")
        Print("   Review test output above for specific failure details and security impact.")
    
    Print("=" * 60)

Process called "main" that returns Nothing:
    Let args be get_args()
    
    If Length(args) == 0:
        Note: No arguments - run all tests
        run_all_tests()
    Otherwise if Length(args) == 1:
        Let module_name be args[0]
        If module_name == "help" or module_name == "--help" or module_name == "-h":
            print_usage()
        Otherwise:
            run_specific_module(module_name)
    Otherwise:
        Print("❌ Error: Too many arguments.")
        Print("")
        print_usage()

Note: Entry point
main()