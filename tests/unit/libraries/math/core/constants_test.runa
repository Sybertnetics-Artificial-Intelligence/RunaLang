Note:
tests/unit/libraries/math/core/constants_test.runa
Unit Tests for Math Core Constants Module

This test suite provides comprehensive testing for the math core constants module including:
- Universal mathematical constants (π, e, φ, γ)
- Number theory constants (Apéry, Catalan, Glaisher-Kinkelin, Khinchin)
- Physical constants (c, h, G, elementary charge)
- Computational constants (machine epsilon, safe integers, overflow/underflow limits)
- Geometric constants (unit circle, sphere calculations)
- Logarithmic constants (ln(2), ln(10), log₁₀(e), log₂(e))
- Statistical constants (normal distribution normalization, Stirling approximation)
- Constant computation operations (arbitrary precision, validation, optimization)
- Constant series operations (π series, e series, zeta function)
- Constant relationship verification and validation
- Utility operations (listing, information retrieval, precision comparison)
:End Note

Import "stdlib/math/core/constants" as Constants
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "assert_precision_valid" that takes computed_value as String, expected_value as String, tolerance as Float returns Boolean:
    Note: Assert that computed value matches expected within tolerance
    Let computed_float be Parse computed_value as Float
    Let expected_float be Parse expected_value as Float
    Let difference be AbsoluteValue(computed_float - expected_float)
    If difference <= tolerance:
        Return True
    Throw Assert.AssertionError with "Precision validation failed: difference " + ToString(difference) + " > tolerance " + ToString(tolerance)

Process called "assert_constant_properties" that takes constant as MathematicalConstant, expected_name as String, expected_symbol as String returns Boolean:
    Note: Assert basic properties of mathematical constant
    Assert.AreEqual(constant.name, expected_name)
    Assert.AreEqual(constant.symbol, expected_symbol)
    Assert.IsTrue(Length(constant.value) > 0)
    Assert.IsTrue(constant.precision > 0)
    Assert.IsTrue(constant.decimal_places >= 0)
    Assert.IsNotEmpty(constant.mathematical_definition)
    Assert.IsNotEmpty(constant.computation_method)
    Return True

Process called "generate_precision_levels" that takes no parameters returns List[Integer]:
    Note: Generate various precision levels for testing
    Return [5, 10, 15, 20, 25, 30, 50, 100]

Process called "generate_known_constants" that takes no parameters returns Dictionary[String, String]:
    Note: Generate dictionary of known constant values for validation
    Let known_values be Dictionary[String, String]
    Set known_values["pi"] to "3.1415926535897932384626433832795"
    Set known_values["e"] to "2.7182818284590452353602874713527"
    Set known_values["golden_ratio"] to "1.6180339887498948482045868343656"
    Set known_values["euler_gamma"] to "0.5772156649015328606065120900824"
    Set known_values["sqrt_2"] to "1.4142135623730950488016887242097"
    Set known_values["ln_2"] to "0.6931471805599453094172321214582"
    Set known_values["ln_10"] to "2.3025850929940456840179914546844"
    Return known_values

Note: =====================================================================
Note: UNIVERSAL MATHEMATICAL CONSTANTS TESTS
Note: =====================================================================

Process called "test_get_pi_basic" that takes no parameters returns Boolean:
    Note: Test basic π calculation with standard precision
    Let pi_value be Constants.get_pi(15)
    Let expected_pi be "3.141592653589793"
    Assert.AreEqual(pi_value, expected_pi)
    Return True

Process called "test_get_pi_high_precision" that takes no parameters returns Boolean:
    Note: Test π calculation with high precision
    Let pi_50 be Constants.get_pi(50)
    Let expected_pi_50 be "3.14159265358979323846264338327950288419716939937511"
    Assert.IsTrue(assert_precision_valid(pi_50, expected_pi_50, 1e-49))
    Return True

Process called "test_get_pi_various_precisions" that takes no parameters returns Boolean:
    Note: Test π calculation with various precision levels
    Let precision_levels be generate_precision_levels()
    For precision in precision_levels:
        Let pi_value be Constants.get_pi(precision)
        Assert.IsTrue(Length(pi_value) >= precision + 1)
        Assert.IsTrue(StartsWith(pi_value, "3.14"))
    Return True

Process called "test_get_pi_invalid_precision" that takes no parameters returns Boolean:
    Note: Test π calculation with invalid precision
    Try:
        Let invalid_pi be Constants.get_pi(-1)
        Return False
    Catch error:
        Return True

Process called "test_get_e_basic" that takes no parameters returns Boolean:
    Note: Test basic e calculation
    Let e_value be Constants.get_e(15)
    Let expected_e be "2.718281828459045"
    Assert.AreEqual(e_value, expected_e)
    Return True

Process called "test_get_e_high_precision" that takes no parameters returns Boolean:
    Note: Test e calculation with high precision
    Let e_50 be Constants.get_e(50)
    Let expected_e_50 be "2.71828182845904523536028747135266249775724709370001"
    Assert.IsTrue(assert_precision_valid(e_50, expected_e_50, 1e-49))
    Return True

Process called "test_get_golden_ratio_basic" that takes no parameters returns Boolean:
    Note: Test basic golden ratio calculation
    Let phi_value be Constants.get_golden_ratio(15)
    Let expected_phi be "1.618033988749894"
    Assert.AreEqual(phi_value, expected_phi)
    Return True

Process called "test_get_golden_ratio_properties" that takes no parameters returns Boolean:
    Note: Test golden ratio mathematical properties (φ² = φ + 1)
    Let phi be Constants.get_golden_ratio(20)
    Let phi_float be Parse phi as Float
    Let phi_squared be phi_float * phi_float
    Let phi_plus_one be phi_float + 1.0
    Assert.IsTrue(AbsoluteValue(phi_squared - phi_plus_one) < 1e-15)
    Return True

Process called "test_get_euler_gamma_basic" that takes no parameters returns Boolean:
    Note: Test Euler-Mascheroni constant calculation
    Let gamma_value be Constants.get_euler_gamma(15)
    Let expected_gamma be "0.577215664901532"
    Assert.AreEqual(gamma_value, expected_gamma)
    Return True

Process called "test_get_sqrt_2_basic" that takes no parameters returns Boolean:
    Note: Test square root of 2 calculation
    Let sqrt2_value be Constants.get_sqrt_2(15)
    Let expected_sqrt2 be "1.414213562373095"
    Assert.AreEqual(sqrt2_value, expected_sqrt2)
    Return True

Process called "test_get_sqrt_2_properties" that takes no parameters returns Boolean:
    Note: Test √2 mathematical properties (√2)² = 2)
    Let sqrt2 be Constants.get_sqrt_2(20)
    Let sqrt2_float be Parse sqrt2 as Float
    Let sqrt2_squared be sqrt2_float * sqrt2_float
    Assert.IsTrue(AbsoluteValue(sqrt2_squared - 2.0) < 1e-15)
    Return True

Note: =====================================================================
Note: NUMBER THEORY CONSTANTS TESTS
Note: =====================================================================

Process called "test_get_apery_constant" that takes no parameters returns Boolean:
    Note: Test Apéry's constant ζ(3) calculation
    Let apery_value be Constants.get_apery_constant(15)
    Let expected_apery be "1.202056903159594"
    Assert.AreEqual(apery_value, expected_apery)
    Return True

Process called "test_get_catalan_constant" that takes no parameters returns Boolean:
    Note: Test Catalan's constant calculation
    Let catalan_value be Constants.get_catalan_constant(15)
    Let expected_catalan be "0.915965594177219"
    Assert.AreEqual(catalan_value, expected_catalan)
    Return True

Process called "test_get_glaisher_kinkelin" that takes no parameters returns Boolean:
    Note: Test Glaisher-Kinkelin constant calculation
    Let glaisher_value be Constants.get_glaisher_kinkelin(15)
    Let expected_glaisher be "1.282427129100623"
    Assert.AreEqual(glaisher_value, expected_glaisher)
    Return True

Process called "test_get_khinchin_constant" that takes no parameters returns Boolean:
    Note: Test Khinchin's constant calculation
    Let khinchin_value be Constants.get_khinchin_constant(15)
    Let expected_khinchin be "2.685452001065306"
    Assert.AreEqual(khinchin_value, expected_khinchin)
    Return True

Note: =====================================================================
Note: PHYSICAL CONSTANTS TESTS
Note: =====================================================================

Process called "test_get_speed_of_light_si" that takes no parameters returns Boolean:
    Note: Test speed of light in SI units
    Let c_constant be Constants.get_speed_of_light("SI")
    Assert.AreEqual(c_constant.constant_name, "Speed of light in vacuum")
    Assert.AreEqual(c_constant.symbol, "c")
    Assert.AreEqual(c_constant.value, "299792458")
    Assert.AreEqual(c_constant.units, "m/s")
    Assert.AreEqual(c_constant.uncertainty, "0")
    Return True

Process called "test_get_speed_of_light_various_units" that takes no parameters returns Boolean:
    Note: Test speed of light in various unit systems
    Let unit_systems be ["SI", "CGS", "natural", "imperial"]
    For unit_system in unit_systems:
        Let c_value be Constants.get_speed_of_light(unit_system)
        Assert.IsNotEmpty(c_value.value)
        Assert.IsNotEmpty(c_value.units)
        Assert.AreEqual(c_value.symbol, "c")
    Return True

Process called "test_get_planck_constant_si" that takes no parameters returns Boolean:
    Note: Test Planck constant in SI units
    Let h_constant be Constants.get_planck_constant("SI")
    Assert.AreEqual(h_constant.constant_name, "Planck constant")
    Assert.AreEqual(h_constant.symbol, "h")
    Assert.AreEqual(h_constant.value, "6.62607015e-34")
    Assert.AreEqual(h_constant.units, "J⋅s")
    Return True

Process called "test_get_gravitational_constant" that takes no parameters returns Boolean:
    Note: Test gravitational constant calculation
    Let g_constant be Constants.get_gravitational_constant("SI")
    Assert.AreEqual(g_constant.constant_name, "Gravitational constant")
    Assert.AreEqual(g_constant.symbol, "G")
    Assert.AreEqual(g_constant.value, "6.67430e-11")
    Assert.AreEqual(g_constant.units, "m³⋅kg⁻¹⋅s⁻²")
    Assert.IsNotEmpty(g_constant.uncertainty)
    Return True

Process called "test_get_elementary_charge" that takes no parameters returns Boolean:
    Note: Test elementary charge calculation
    Let e_charge be Constants.get_elementary_charge("SI")
    Assert.AreEqual(e_charge.constant_name, "Elementary charge")
    Assert.AreEqual(e_charge.symbol, "e")
    Assert.AreEqual(e_charge.value, "1.602176634e-19")
    Assert.AreEqual(e_charge.units, "C")
    Return True

Note: =====================================================================
Note: COMPUTATIONAL CONSTANTS TESTS
Note: =====================================================================

Process called "test_get_machine_epsilon_float64" that takes no parameters returns Boolean:
    Note: Test machine epsilon for double precision
    Let epsilon be Constants.get_machine_epsilon("float64")
    Assert.AreEqual(epsilon.limit_type, "machine_epsilon")
    Assert.AreEqual(epsilon.value, "2.220446049250313e-16")
    Assert.IsTrue(epsilon.platform_dependent)
    Assert.IsTrue("double_precision_arithmetic" in epsilon.affects_calculations)
    Return True

Process called "test_get_machine_epsilon_float32" that takes no parameters returns Boolean:
    Note: Test machine epsilon for single precision
    Let epsilon be Constants.get_machine_epsilon("float32")
    Assert.AreEqual(epsilon.value, "1.1920929e-07")
    Assert.IsTrue("floating_point_arithmetic" in epsilon.affects_calculations)
    Return True

Process called "test_get_max_safe_integer_various_types" that takes no parameters returns Boolean:
    Note: Test maximum safe integers for different types
    Let int_types be ["int32", "int64", "uint64", "javascript_safe"]
    Let expected_values be ["2147483647", "9223372036854775807", "18446744073709551615", "9007199254740991"]
    For index from 0 to Length(int_types) - 1:
        Let max_int be Constants.get_max_safe_integer(int_types[index])
        Assert.AreEqual(max_int.value, expected_values[index])
        Assert.AreEqual(max_int.limit_type, "max_safe_integer")
    Return True

Process called "test_get_overflow_threshold" that takes no parameters returns Boolean:
    Note: Test overflow thresholds for numeric types
    Let overflow_float64 be Constants.get_overflow_threshold("float64")
    Assert.AreEqual(overflow_float64.limit_type, "overflow_threshold")
    Assert.AreEqual(overflow_float64.value, "1.7976931348623157e+308")
    Assert.IsTrue("double_precision_overflow" in overflow_float64.affects_calculations)
    Return True

Process called "test_get_underflow_threshold" that takes no parameters returns Boolean:
    Note: Test underflow thresholds for numeric types
    Let underflow_float64 be Constants.get_underflow_threshold("float64")
    Assert.AreEqual(underflow_float64.limit_type, "underflow_threshold")
    Assert.AreEqual(underflow_float64.value, "2.2250738585072014e-308")
    Assert.IsTrue("double_precision_underflow" in underflow_float64.affects_calculations)
    Return True

Note: =====================================================================
Note: GEOMETRIC CONSTANTS TESTS
Note: =====================================================================

Process called "test_get_unit_circle_circumference" that takes no parameters returns Boolean:
    Note: Test unit circle circumference (2π)
    Let circumference be Constants.get_unit_circle_circumference(15)
    Let expected_value be "6.283185307179586"
    Assert.IsTrue(assert_precision_valid(circumference, expected_value, 1e-14))
    Return True

Process called "test_get_unit_sphere_surface_area" that takes no parameters returns Boolean:
    Note: Test unit sphere surface area (4π)
    Let surface_area be Constants.get_unit_sphere_surface_area(15)
    Let expected_value be "12.566370614359173"
    Assert.IsTrue(assert_precision_valid(surface_area, expected_value, 1e-14))
    Return True

Process called "test_get_unit_sphere_volume" that takes no parameters returns Boolean:
    Note: Test unit sphere volume (4π/3)
    Let volume be Constants.get_unit_sphere_volume(15)
    Let expected_value be "4.188790204786391"
    Assert.IsTrue(assert_precision_valid(volume, expected_value, 1e-14))
    Return True

Note: =====================================================================
Note: LOGARITHMIC CONSTANTS TESTS
Note: =====================================================================

Process called "test_get_natural_log_2" that takes no parameters returns Boolean:
    Note: Test natural logarithm of 2
    Let ln2_value be Constants.get_natural_log_2(15)
    Let expected_ln2 be "0.693147180559945"
    Assert.AreEqual(ln2_value, expected_ln2)
    Return True

Process called "test_get_natural_log_10" that takes no parameters returns Boolean:
    Note: Test natural logarithm of 10
    Let ln10_value be Constants.get_natural_log_10(15)
    Let expected_ln10 be "2.302585092994046"
    Assert.AreEqual(ln10_value, expected_ln10)
    Return True

Process called "test_get_log10_e" that takes no parameters returns Boolean:
    Note: Test common logarithm of e
    Let log10e_value be Constants.get_log10_e(15)
    Let expected_log10e be "0.434294481903252"
    Assert.AreEqual(log10e_value, expected_log10e)
    Return True

Process called "test_get_log2_e" that takes no parameters returns Boolean:
    Note: Test binary logarithm of e
    Let log2e_value be Constants.get_log2_e(15)
    Let expected_log2e be "1.442695040888963"
    Assert.AreEqual(log2e_value, expected_log2e)
    Return True

Note: =====================================================================
Note: STATISTICAL CONSTANTS TESTS
Note: =====================================================================

Process called "test_get_normal_distribution_normalization" that takes no parameters returns Boolean:
    Note: Test normal distribution normalization constant (1/√(2π))
    Let norm_const be Constants.get_normal_distribution_normalization(15)
    Let expected_value be "0.398942280401433"
    Assert.AreEqual(norm_const, expected_value)
    Return True

Process called "test_get_stirling_approximation_constant" that takes no parameters returns Boolean:
    Note: Test Stirling approximation constant (√(2π))
    Let stirling_const be Constants.get_stirling_approximation_constant(15)
    Let expected_value be "2.506628274631000"
    Assert.AreEqual(stirling_const, expected_value)
    Return True

Process called "test_get_chi_squared_normalization" that takes no parameters returns Boolean:
    Note: Test chi-squared distribution normalization constant
    Let chi2_norm be Constants.get_chi_squared_normalization(4, 10)
    Assert.IsTrue(Length(chi2_norm) > 0)
    Let parsed_value be Parse chi2_norm as Float
    Assert.IsTrue(parsed_value > 0.0)
    Return True

Note: =====================================================================
Note: CONSTANT COMPUTATION OPERATIONS TESTS
Note: =====================================================================

Process called "test_compute_constant_arbitrary_precision_pi" that takes no parameters returns Boolean:
    Note: Test arbitrary precision π computation
    Let pi_computation be Constants.compute_constant_arbitrary_precision("pi", 30, "machin")
    Assert.AreEqual(pi_computation["algorithm"], "machin")
    Assert.IsTrue(StartsWith(pi_computation["value"], "3.14"))
    Assert.IsNotEmpty(pi_computation["computation_time"])
    Return True

Process called "test_compute_constant_arbitrary_precision_e" that takes no parameters returns Boolean:
    Note: Test arbitrary precision e computation
    Let e_computation be Constants.compute_constant_arbitrary_precision("e", 25, "taylor")
    Assert.IsTrue(StartsWith(e_computation["value"], "2.71"))
    Assert.AreEqual(e_computation["method"], "Taylor series")
    Return True

Process called "test_validate_constant_precision" that takes no parameters returns Boolean:
    Note: Test constant precision validation
    Let computed_pi be "3.141592653589793"
    Let reference_pi be "3.141592653589793"
    Let is_valid be Constants.validate_constant_precision(computed_pi, reference_pi, 1e-15)
    Assert.IsTrue(is_valid)
    
    Let invalid_pi be "3.14"
    Let is_invalid be Constants.validate_constant_precision(invalid_pi, reference_pi, 1e-15)
    Assert.IsFalse(is_invalid)
    Return True

Process called "test_optimize_constant_algorithm" that takes no parameters returns Boolean:
    Note: Test constant algorithm optimization
    Let pi_algorithm_low be Constants.optimize_constant_algorithm("pi", 50)
    Assert.AreEqual(pi_algorithm_low, "machin")
    
    Let pi_algorithm_high be Constants.optimize_constant_algorithm("pi", 5000)
    Assert.AreEqual(pi_algorithm_high, "chudnovsky")
    
    Let e_algorithm be Constants.optimize_constant_algorithm("e", 500)
    Assert.AreEqual(e_algorithm, "taylor_series")
    Return True

Process called "test_estimate_computation_time" that takes no parameters returns Boolean:
    Note: Test computation time estimation
    Let time_estimate_pi be Constants.estimate_computation_time("pi", 100, "machin")
    Assert.IsTrue(time_estimate_pi > 0.0)
    
    Let time_estimate_e be Constants.estimate_computation_time("e", 100, "taylor_series")
    Assert.IsTrue(time_estimate_e > 0.0)
    Return True

Note: =====================================================================
Note: CONSTANT SERIES OPERATIONS TESTS
Note: =====================================================================

Process called "test_compute_pi_series_machin" that takes no parameters returns Boolean:
    Note: Test π computation using Machin series
    Let pi_machin be Constants.compute_pi_series("machin", 20)
    Assert.AreEqual(pi_machin["series_type"], "machin")
    Assert.IsTrue(StartsWith(pi_machin["value"], "3.14"))
    Assert.AreEqual(pi_machin["convergence_rate"], "O(1/5^n)")
    Return True

Process called "test_compute_pi_series_chudnovsky" that takes no parameters returns Boolean:
    Note: Test π computation using Chudnovsky series
    Let pi_chudnovsky be Constants.compute_pi_series("chudnovsky", 15)
    Assert.AreEqual(pi_chudnovsky["series_type"], "chudnovsky")
    Assert.IsTrue(StartsWith(pi_chudnovsky["value"], "3.14"))
    Assert.AreEqual(pi_chudnovsky["convergence_rate"], "O(1/426880^n)")
    Return True

Process called "test_compute_e_series_taylor" that takes no parameters returns Boolean:
    Note: Test e computation using Taylor series
    Let e_taylor be Constants.compute_e_series("taylor", 20)
    Assert.AreEqual(e_taylor["series_type"], "taylor")
    Assert.IsTrue(StartsWith(e_taylor["value"], "2.71"))
    Assert.AreEqual(e_taylor["convergence_rate"], "O(1/n!)")
    Return True

Process called "test_compute_zeta_function_special_values" that takes no parameters returns Boolean:
    Note: Test Riemann zeta function for special values
    Let zeta_2 be Constants.compute_zeta_function("2", 15)
    Let expected_zeta_2 be "1.644934066848226"
    Assert.IsTrue(assert_precision_valid(zeta_2, expected_zeta_2, 1e-14))
    
    Let zeta_4 be Constants.compute_zeta_function("4", 15)
    Let expected_zeta_4 be "1.082323233711138"
    Assert.IsTrue(assert_precision_valid(zeta_4, expected_zeta_4, 1e-14))
    Return True

Note: =====================================================================
Note: CONSTANT RELATIONSHIP VERIFICATION TESTS
Note: =====================================================================

Process called "test_verify_constant_relationships_euler_identity" that takes no parameters returns Boolean:
    Note: Test verification of Euler's identity
    Let relationships be Constants.verify_constant_relationships(["euler_identity"], 15)
    Assert.AreEqual(Length(relationships), 1)
    Assert.AreEqual(relationships[0]["relationship"], "e^(iπ) + 1 = 0")
    Return True

Process called "test_verify_constant_relationships_golden_ratio" that takes no parameters returns Boolean:
    Note: Test verification of golden ratio properties
    Let relationships be Constants.verify_constant_relationships(["golden_ratio_properties"], 15)
    Assert.AreEqual(Length(relationships), 1)
    Assert.AreEqual(relationships[0]["relationship"], "φ² = φ + 1")
    Return True

Process called "test_verify_constant_relationships_zeta_2" that takes no parameters returns Boolean:
    Note: Test verification of ζ(2) = π²/6
    Let relationships be Constants.verify_constant_relationships(["zeta_2_identity"], 15)
    Assert.AreEqual(Length(relationships), 1)
    Assert.AreEqual(relationships[0]["relationship"], "ζ(2) = π²/6")
    Return True

Process called "test_derive_constant_from_others" that takes no parameters returns Boolean:
    Note: Test deriving constants from other constants
    Let derived_phi be Constants.derive_constant_from_others("golden_ratio", ["sqrt_5"], 15)
    Assert.IsTrue(StartsWith(derived_phi, "1.618"))
    
    Let derived_log10e be Constants.derive_constant_from_others("log10_e", ["ln_10"], 15)
    Assert.IsTrue(StartsWith(derived_log10e, "0.434"))
    Return True

Process called "test_find_rational_approximations" that takes no parameters returns Boolean:
    Note: Test finding rational approximations to constants
    Let pi_approximations be Constants.find_rational_approximations("3.141592653589793", 100)
    Assert.IsTrue(Length(pi_approximations) > 0)
    Assert.IsTrue("22" in pi_approximations[0]["numerator"] OR "355" in pi_approximations[1]["numerator"])
    Return True

Note: =====================================================================
Note: UTILITY OPERATIONS TESTS
Note: =====================================================================

Process called "test_list_available_constants_universal" that takes no parameters returns Boolean:
    Note: Test listing universal mathematical constants
    Let universal_constants be Constants.list_available_constants("universal")
    Assert.IsTrue(Length(universal_constants) >= 3)
    Let found_pi be False
    Let found_e be False
    Let found_phi be False
    For constant in universal_constants:
        If constant.symbol = "π":
            Set found_pi to True
        If constant.symbol = "e":
            Set found_e to True
        If constant.symbol = "φ":
            Set found_phi to True
    Assert.IsTrue(found_pi AND found_e AND found_phi)
    Return True

Process called "test_list_available_constants_all" that takes no parameters returns Boolean:
    Note: Test listing all available constants
    Let all_constants be Constants.list_available_constants("all")
    Assert.IsTrue(Length(all_constants) >= 5)
    Return True

Process called "test_get_constant_information_pi" that takes no parameters returns Boolean:
    Note: Test getting detailed π information
    Let pi_info be Constants.get_constant_information("pi")
    Assert.IsTrue(assert_constant_properties(pi_info, "Pi", "π"))
    Assert.IsTrue(StartsWith(pi_info.value, "3.14"))
    Assert.IsFalse(pi_info.is_rational)
    Assert.IsFalse(pi_info.is_algebraic)
    Return True

Process called "test_get_constant_information_e" that takes no parameters returns Boolean:
    Note: Test getting detailed e information
    Let e_info be Constants.get_constant_information("e")
    Assert.IsTrue(assert_constant_properties(e_info, "Euler's number", "e"))
    Assert.IsTrue(StartsWith(e_info.value, "2.71"))
    Assert.IsFalse(e_info.is_rational)
    Assert.IsFalse(e_info.is_algebraic)
    Return True

Process called "test_get_constant_information_golden_ratio" that takes no parameters returns Boolean:
    Note: Test getting detailed golden ratio information
    Let phi_info be Constants.get_constant_information("golden_ratio")
    Assert.IsTrue(assert_constant_properties(phi_info, "Golden ratio", "φ"))
    Assert.IsTrue(StartsWith(phi_info.value, "1.618"))
    Assert.IsFalse(phi_info.is_rational)
    Assert.IsTrue(phi_info.is_algebraic)
    Return True

Process called "test_get_constant_information_unknown" that takes no parameters returns Boolean:
    Note: Test getting information for unknown constant
    Let unknown_info be Constants.get_constant_information("unknown_constant")
    Assert.AreEqual(unknown_info.name, "Unknown constant")
    Assert.AreEqual(unknown_info.symbol, "?")
    Assert.AreEqual(unknown_info.value, "0")
    Return True

Process called "test_compare_constant_precisions" that takes no parameters returns Boolean:
    Note: Test comparing constant precision calculations
    Let test_values be ["3.1415926535", "2.7182818284", "1.6180339887"]
    Let precision_results be Constants.compare_constant_precisions(test_values, 10)
    Assert.IsTrue("pi_accuracy" in precision_results)
    Assert.IsTrue("e_accuracy" in precision_results)
    Assert.IsTrue("phi_accuracy" in precision_results)
    Assert.IsTrue("overall_precision" in precision_results)
    Return True

Note: =====================================================================
Note: INTEGRATION AND PERFORMANCE TESTS
Note: =====================================================================

Process called "test_constant_precision_consistency" that takes no parameters returns Boolean:
    Note: Test consistency across different precision levels
    Let known_constants be generate_known_constants()
    For constant_name, expected_value in known_constants:
        Let precision_10 be ""
        Let precision_20 be ""
        If constant_name = "pi":
            Set precision_10 to Constants.get_pi(10)
            Set precision_20 to Constants.get_pi(20)
        If constant_name = "e":
            Set precision_10 to Constants.get_e(10)
            Set precision_20 to Constants.get_e(20)
        If constant_name = "golden_ratio":
            Set precision_10 to Constants.get_golden_ratio(10)
            Set precision_20 to Constants.get_golden_ratio(20)
        Assert.IsTrue(StartsWith(precision_20, precision_10))
    Return True

Process called "test_error_handling_comprehensive" that takes no parameters returns Boolean:
    Note: Test comprehensive error handling scenarios
    Try:
        Let invalid_precision_pi be Constants.get_pi(0)
        Return False
    Catch error:
        Pass
    
    Try:
        Let invalid_unit_system be Constants.get_speed_of_light("invalid")
        Assert.IsEmpty(invalid_unit_system.value)
    Catch error:
        Pass
    
    Try:
        Let invalid_constant be Constants.derive_constant_from_others("nonexistent", ["pi"], 10)
        Return False
    Catch error:
        Pass
    
    Return True

Process called "test_constant_caching_behavior" that takes no parameters returns Boolean:
    Note: Test constant caching and performance optimization
    Let start_time be GetCurrentTime()
    Let pi_first_call be Constants.get_pi(100)
    Let first_call_time be GetCurrentTime() - start_time
    
    Let second_start_time be GetCurrentTime()
    Let pi_second_call be Constants.get_pi(100)
    Let second_call_time be GetCurrentTime() - second_start_time
    
    Assert.AreEqual(pi_first_call, pi_second_call)
    Return True

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all constants module tests
    Let tests_passed be 0
    Let tests_failed be 0
    Let test_results be List[Dictionary[String, String]]
    
    Note: Universal constants tests
    Let universal_tests be [
        "test_get_pi_basic",
        "test_get_pi_high_precision", 
        "test_get_pi_various_precisions",
        "test_get_pi_invalid_precision",
        "test_get_e_basic",
        "test_get_e_high_precision",
        "test_get_golden_ratio_basic",
        "test_get_golden_ratio_properties",
        "test_get_euler_gamma_basic",
        "test_get_sqrt_2_basic",
        "test_get_sqrt_2_properties"
    ]
    
    Note: Number theory constants tests
    Let number_theory_tests be [
        "test_get_apery_constant",
        "test_get_catalan_constant", 
        "test_get_glaisher_kinkelin",
        "test_get_khinchin_constant"
    ]
    
    Note: Physical constants tests
    Let physical_tests be [
        "test_get_speed_of_light_si",
        "test_get_speed_of_light_various_units",
        "test_get_planck_constant_si",
        "test_get_gravitational_constant",
        "test_get_elementary_charge"
    ]
    
    Note: Computational constants tests
    Let computational_tests be [
        "test_get_machine_epsilon_float64",
        "test_get_machine_epsilon_float32",
        "test_get_max_safe_integer_various_types",
        "test_get_overflow_threshold",
        "test_get_underflow_threshold"
    ]
    
    Note: Geometric constants tests
    Let geometric_tests be [
        "test_get_unit_circle_circumference",
        "test_get_unit_sphere_surface_area",
        "test_get_unit_sphere_volume"
    ]
    
    Note: Logarithmic constants tests
    Let logarithmic_tests be [
        "test_get_natural_log_2",
        "test_get_natural_log_10",
        "test_get_log10_e",
        "test_get_log2_e"
    ]
    
    Note: Statistical constants tests
    Let statistical_tests be [
        "test_get_normal_distribution_normalization",
        "test_get_stirling_approximation_constant",
        "test_get_chi_squared_normalization"
    ]
    
    Note: Computation operations tests
    Let computation_tests be [
        "test_compute_constant_arbitrary_precision_pi",
        "test_compute_constant_arbitrary_precision_e",
        "test_validate_constant_precision",
        "test_optimize_constant_algorithm",
        "test_estimate_computation_time"
    ]
    
    Note: Series operations tests
    Let series_tests be [
        "test_compute_pi_series_machin",
        "test_compute_pi_series_chudnovsky",
        "test_compute_e_series_taylor",
        "test_compute_zeta_function_special_values"
    ]
    
    Note: Relationship verification tests
    Let relationship_tests be [
        "test_verify_constant_relationships_euler_identity",
        "test_verify_constant_relationships_golden_ratio",
        "test_verify_constant_relationships_zeta_2",
        "test_derive_constant_from_others",
        "test_find_rational_approximations"
    ]
    
    Note: Utility operations tests
    Let utility_tests be [
        "test_list_available_constants_universal",
        "test_list_available_constants_all",
        "test_get_constant_information_pi",
        "test_get_constant_information_e",
        "test_get_constant_information_golden_ratio",
        "test_get_constant_information_unknown",
        "test_compare_constant_precisions"
    ]
    
    Note: Integration and performance tests
    Let integration_tests be [
        "test_constant_precision_consistency",
        "test_error_handling_comprehensive",
        "test_constant_caching_behavior"
    ]
    
    Let all_test_groups be [universal_tests, number_theory_tests, physical_tests, computational_tests,
                           geometric_tests, logarithmic_tests, statistical_tests, computation_tests,
                           series_tests, relationship_tests, utility_tests, integration_tests]
    
    Let group_names be ["Universal Constants", "Number Theory", "Physical Constants", "Computational Limits",
                       "Geometric Constants", "Logarithmic Constants", "Statistical Constants", "Computation Operations", 
                       "Series Operations", "Relationship Verification", "Utility Operations", "Integration Tests"]
    
    For group_index from 0 to Length(all_test_groups) - 1:
        Let test_group be all_test_groups[group_index]
        Let group_name be group_names[group_index]
        Print "Testing " + group_name + "..."
        
        For test_name in test_group:
            Try:
                Let test_result be Call test_name()
                If test_result:
                    Set tests_passed to tests_passed + 1
                    Print "  ✓ " + test_name
                Else:
                    Set tests_failed to tests_failed + 1  
                    Print "  ✗ " + test_name + " (returned false)"
            Catch error:
                Set tests_failed to tests_failed + 1
                Print "  ✗ " + test_name + " (error: " + error.message + ")"
    
    Let total_tests be tests_passed + tests_failed
    Print ""
    Print "Constants Module Test Results:"
    Print "=============================="
    Print "Tests passed: " + ToString(tests_passed)
    Print "Tests failed: " + ToString(tests_failed)
    Print "Total tests: " + ToString(total_tests)
    Print "Success rate: " + ToString((tests_passed * 100) / total_tests) + "%"
    
    Return tests_failed = 0