Note:
tests/unit/libraries/math/core/operations_test.runa
Unit Tests for Math Core Operations Module

This test suite provides comprehensive testing for the math core operations module including:
- Basic arithmetic operations (add, subtract, multiply, divide)
- Power and root operations (pow, sqrt, nth_root, cbrt)
- Logarithmic operations (log, ln, log2, log10, arbitrary base)
- Factorial and combinatorial operations
- Absolute value and sign operations
- Modular arithmetic and GCD/LCM operations
- Complex number arithmetic
- Arbitrary precision arithmetic support
- Error handling for mathematical edge cases
- Performance optimized implementations
- Numerical stability considerations
:End Note

Import "stdlib/math/core/operations" as Operations
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "assert_arithmetic_result_valid" that takes result as ArithmeticResult, expected_value as String, operation_type as String returns Boolean:
    Note: Assert arithmetic result is valid and matches expected values
    Assert.AreEqual(result.operation_type, operation_type)
    Assert.AreEqual(result.result_value, expected_value)
    Assert.IsTrue(result.precision_used > 0)
    Assert.IsFalse(result.overflow_occurred)
    Assert.IsFalse(result.underflow_occurred)
    Return True

Process called "assert_complex_number_valid" that takes complex_num as ComplexNumber, expected_real as String, expected_imag as String returns Boolean:
    Note: Assert complex number is valid and matches expected values
    Assert.AreEqual(complex_num.real_part, expected_real)
    Assert.AreEqual(complex_num.imaginary_part, expected_imag)
    Assert.IsTrue(Length(complex_num.magnitude) > 0)
    Assert.IsTrue(Length(complex_num.argument) > 0)
    Return True

Process called "generate_test_numbers" that takes no parameters returns List[String]:
    Note: Generate various test numbers for operations
    Return ["0", "1", "-1", "2.5", "-3.7", "10", "100", "0.001", "-0.001", "1234.5678"]

Process called "generate_precision_levels" that takes no parameters returns List[Integer]:
    Note: Generate various precision levels for testing
    Return [5, 10, 15, 20, 30, 50]

Process called "is_approximately_equal" that takes value1 as String, value2 as String, tolerance as Float returns Boolean:
    Note: Check if two string values are approximately equal within tolerance
    Let val1 be Parse value1 as Float
    Let val2 be Parse value2 as Float
    Let difference be AbsoluteValue(val1 - val2)
    Return difference <= tolerance

Note: =====================================================================
Note: BASIC ARITHMETIC OPERATIONS TESTS
Note: =====================================================================

Process called "test_add_basic" that takes no parameters returns Boolean:
    Note: Test basic addition operations
    Let result be Operations.add("2.5", "3.7", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result, "6.2", "addition"))
    Return True

Process called "test_add_negative_numbers" that takes no parameters returns Boolean:
    Note: Test addition with negative numbers
    Let result1 be Operations.add("-2.5", "3.7", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result1, "1.2", "addition"))
    
    Let result2 be Operations.add("-2.5", "-3.7", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result2, "-6.2", "addition"))
    Return True

Process called "test_add_high_precision" that takes no parameters returns Boolean:
    Note: Test addition with high precision
    Let result be Operations.add("1.23456789012345", "2.34567890123456", 20)
    Assert.IsTrue(is_approximately_equal(result.result_value, "3.58024679135801", 1e-14))
    Assert.AreEqual(result.precision_used, 20)
    Return True

Process called "test_add_zero" that takes no parameters returns Boolean:
    Note: Test addition with zero (identity property)
    Let result be Operations.add("42.5", "0", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result, "42.5", "addition"))
    Return True

Process called "test_subtract_basic" that takes no parameters returns Boolean:
    Note: Test basic subtraction operations
    Let result be Operations.subtract("7.5", "2.3", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result, "5.2", "subtraction"))
    Return True

Process called "test_subtract_negative_result" that takes no parameters returns Boolean:
    Note: Test subtraction resulting in negative number
    Let result be Operations.subtract("2.3", "7.5", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result, "-5.2", "subtraction"))
    Return True

Process called "test_subtract_high_precision" that takes no parameters returns Boolean:
    Note: Test subtraction with high precision
    Let result be Operations.subtract("3.141592653589793", "2.718281828459045", 15)
    Assert.IsTrue(is_approximately_equal(result.result_value, "0.423310825130748", 1e-14))
    Return True

Process called "test_multiply_basic" that takes no parameters returns Boolean:
    Note: Test basic multiplication operations
    Let result be Operations.multiply("2.5", "4", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result, "10", "multiplication"))
    Return True

Process called "test_multiply_by_zero" that takes no parameters returns Boolean:
    Note: Test multiplication by zero
    Let result be Operations.multiply("42.5", "0", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result, "0", "multiplication"))
    Return True

Process called "test_multiply_by_one" that takes no parameters returns Boolean:
    Note: Test multiplication by one (identity property)
    Let result be Operations.multiply("42.5", "1", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result, "42.5", "multiplication"))
    Return True

Process called "test_multiply_negative_numbers" that takes no parameters returns Boolean:
    Note: Test multiplication with negative numbers
    Let result1 be Operations.multiply("-2.5", "3", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result1, "-7.5", "multiplication"))
    
    Let result2 be Operations.multiply("-2.5", "-3", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result2, "7.5", "multiplication"))
    Return True

Process called "test_divide_basic" that takes no parameters returns Boolean:
    Note: Test basic division operations
    Let result be Operations.divide("10", "2.5", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result, "4", "division"))
    Return True

Process called "test_divide_by_one" that takes no parameters returns Boolean:
    Note: Test division by one (identity property)
    Let result be Operations.divide("42.5", "1", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result, "42.5", "division"))
    Return True

Process called "test_divide_fractional_result" that takes no parameters returns Boolean:
    Note: Test division resulting in fraction
    Let result be Operations.divide("1", "3", 15)
    Assert.IsTrue(is_approximately_equal(result.result_value, "0.333333333333333", 1e-14))
    Return True

Process called "test_divide_by_zero_error" that takes no parameters returns Boolean:
    Note: Test division by zero error handling
    Try:
        Let result be Operations.divide("10", "0", 10)
        Assert.IsTrue(result.error_occurred)
        Return True
    Catch error:
        Return True

Note: =====================================================================
Note: POWER AND ROOT OPERATIONS TESTS
Note: =====================================================================

Process called "test_power_integer_exponent" that takes no parameters returns Boolean:
    Note: Test power with integer exponent
    Let result be Operations.power("2", "3", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result, "8", "power"))
    Return True

Process called "test_power_fractional_exponent" that takes no parameters returns Boolean:
    Note: Test power with fractional exponent
    Let result be Operations.power("4", "0.5", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result, "2", "power"))
    Return True

Process called "test_power_negative_exponent" that takes no parameters returns Boolean:
    Note: Test power with negative exponent
    Let result be Operations.power("2", "-2", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result, "0.25", "power"))
    Return True

Process called "test_power_zero_exponent" that takes no parameters returns Boolean:
    Note: Test power with zero exponent (should equal 1)
    Let result be Operations.power("42.5", "0", 10)
    Assert.IsTrue(assert_arithmetic_result_valid(result, "1", "power"))
    Return True

Process called "test_square_root_basic" that takes no parameters returns Boolean:
    Note: Test basic square root calculation
    Let result be Operations.square_root("4", 10)
    Assert.IsTrue(is_approximately_equal(result.result_value, "2", 1e-9))
    Return True

Process called "test_square_root_irrational" that takes no parameters returns Boolean:
    Note: Test square root of irrational number
    Let result be Operations.square_root("2", 15)
    Assert.IsTrue(is_approximately_equal(result.result_value, "1.414213562373095", 1e-14))
    Return True

Process called "test_square_root_negative_error" that takes no parameters returns Boolean:
    Note: Test square root of negative number error
    Try:
        Let result be Operations.square_root("-1", 10)
        Assert.IsTrue(result.error_occurred)
        Return True
    Catch error:
        Return True

Process called "test_cube_root_basic" that takes no parameters returns Boolean:
    Note: Test basic cube root calculation
    Let result be Operations.cube_root("8", 10)
    Assert.IsTrue(is_approximately_equal(result.result_value, "2", 1e-9))
    Return True

Process called "test_cube_root_negative" that takes no parameters returns Boolean:
    Note: Test cube root of negative number
    Let result be Operations.cube_root("-8", 10)
    Assert.IsTrue(is_approximately_equal(result.result_value, "-2", 1e-9))
    Return True

Process called "test_nth_root_basic" that takes no parameters returns Boolean:
    Note: Test nth root calculation
    Let result be Operations.nth_root("32", "5", 10)
    Assert.IsTrue(is_approximately_equal(result.result_value, "2", 1e-9))
    Return True

Note: =====================================================================
Note: LOGARITHMIC OPERATIONS TESTS
Note: =====================================================================

Process called "test_natural_log_basic" that takes no parameters returns Boolean:
    Note: Test natural logarithm calculation
    Let result be Operations.natural_log("2.718281828459045", 15)
    Assert.IsTrue(is_approximately_equal(result.result_value, "1", 1e-14))
    Return True

Process called "test_natural_log_powers_of_e" that takes no parameters returns Boolean:
    Note: Test natural log of powers of e
    Let result be Operations.natural_log("7.38905609893065", 10)
    Assert.IsTrue(is_approximately_equal(result.result_value, "2", 1e-9))
    Return True

Process called "test_log_base_10" that takes no parameters returns Boolean:
    Note: Test base-10 logarithm calculation
    Let result be Operations.log_base_10("100", 10)
    Assert.IsTrue(is_approximately_equal(result.result_value, "2", 1e-9))
    Return True

Process called "test_log_base_2" that takes no parameters returns Boolean:
    Note: Test base-2 logarithm calculation
    Let result be Operations.log_base_2("8", 10)
    Assert.IsTrue(is_approximately_equal(result.result_value, "3", 1e-9))
    Return True

Process called "test_log_arbitrary_base" that takes no parameters returns Boolean:
    Note: Test logarithm with arbitrary base
    Let result be Operations.log_arbitrary_base("125", "5", 10)
    Assert.IsTrue(is_approximately_equal(result.result_value, "3", 1e-9))
    Return True

Process called "test_log_negative_error" that takes no parameters returns Boolean:
    Note: Test logarithm of negative number error
    Try:
        Let result be Operations.natural_log("-1", 10)
        Assert.IsTrue(result.error_occurred)
        Return True
    Catch error:
        Return True

Process called "test_log_zero_error" that takes no parameters returns Boolean:
    Note: Test logarithm of zero error
    Try:
        Let result be Operations.natural_log("0", 10)
        Assert.IsTrue(result.error_occurred)
        Return True
    Catch error:
        Return True

Note: =====================================================================
Note: FACTORIAL AND COMBINATORIAL TESTS
Note: =====================================================================

Process called "test_factorial_small_numbers" that takes no parameters returns Boolean:
    Note: Test factorial of small numbers
    Let result0 be Operations.factorial(0)
    Assert.AreEqual(result0.factorial_value, "1")
    
    Let result5 be Operations.factorial(5)
    Assert.AreEqual(result5.factorial_value, "120")
    
    Let result10 be Operations.factorial(10)
    Assert.AreEqual(result10.factorial_value, "3628800")
    Return True

Process called "test_factorial_large_numbers" that takes no parameters returns Boolean:
    Note: Test factorial of larger numbers
    Let result20 be Operations.factorial(20)
    Assert.AreEqual(result20.factorial_value, "2432902008176640000")
    Return True

Process called "test_factorial_negative_error" that takes no parameters returns Boolean:
    Note: Test factorial of negative number error
    Try:
        Let result be Operations.factorial(-1)
        Assert.IsTrue(result.error_occurred)
        Return True
    Catch error:
        Return True

Process called "test_combination_basic" that takes no parameters returns Boolean:
    Note: Test combination calculation C(n,k)
    Let result be Operations.combination(5, 2)
    Assert.AreEqual(result.result_value, "10")
    
    Let result2 be Operations.combination(10, 3)
    Assert.AreEqual(result2.result_value, "120")
    Return True

Process called "test_permutation_basic" that takes no parameters returns Boolean:
    Note: Test permutation calculation P(n,k)
    Let result be Operations.permutation(5, 2)
    Assert.AreEqual(result.result_value, "20")
    
    Let result2 be Operations.permutation(10, 3)
    Assert.AreEqual(result2.result_value, "720")
    Return True

Note: =====================================================================
Note: ABSOLUTE VALUE AND SIGN OPERATIONS TESTS
Note: =====================================================================

Process called "test_absolute_value_positive" that takes no parameters returns Boolean:
    Note: Test absolute value of positive numbers
    Let result be Operations.absolute_value("42.5")
    Assert.AreEqual(result.result_value, "42.5")
    Return True

Process called "test_absolute_value_negative" that takes no parameters returns Boolean:
    Note: Test absolute value of negative numbers
    Let result be Operations.absolute_value("-42.5")
    Assert.AreEqual(result.result_value, "42.5")
    Return True

Process called "test_absolute_value_zero" that takes no parameters returns Boolean:
    Note: Test absolute value of zero
    Let result be Operations.absolute_value("0")
    Assert.AreEqual(result.result_value, "0")
    Return True

Process called "test_sign_function_positive" that takes no parameters returns Boolean:
    Note: Test sign function for positive numbers
    Let result be Operations.sign_function("42.5")
    Assert.AreEqual(result.result_value, "1")
    Return True

Process called "test_sign_function_negative" that takes no parameters returns Boolean:
    Note: Test sign function for negative numbers
    Let result be Operations.sign_function("-42.5")
    Assert.AreEqual(result.result_value, "-1")
    Return True

Process called "test_sign_function_zero" that takes no parameters returns Boolean:
    Note: Test sign function for zero
    Let result be Operations.sign_function("0")
    Assert.AreEqual(result.result_value, "0")
    Return True

Note: =====================================================================
Note: MODULAR ARITHMETIC TESTS
Note: =====================================================================

Process called "test_modulo_basic" that takes no parameters returns Boolean:
    Note: Test basic modulo operation
    Let result be Operations.modulo("17", "5")
    Assert.AreEqual(result.remainder, "2")
    Assert.AreEqual(result.quotient, "3")
    Return True

Process called "test_modulo_negative_dividend" that takes no parameters returns Boolean:
    Note: Test modulo with negative dividend
    Let result be Operations.modulo("-17", "5")
    Assert.AreEqual(result.remainder, "3")
    Assert.AreEqual(result.quotient, "-4")
    Return True

Process called "test_gcd_basic" that takes no parameters returns Boolean:
    Note: Test greatest common divisor calculation
    Let result be Operations.gcd("48", "18")
    Assert.AreEqual(result.gcd_result, "6")
    Return True

Process called "test_gcd_coprime" that takes no parameters returns Boolean:
    Note: Test GCD of coprime numbers
    Let result be Operations.gcd("17", "13")
    Assert.AreEqual(result.gcd_result, "1")
    Return True

Process called "test_lcm_basic" that takes no parameters returns Boolean:
    Note: Test least common multiple calculation
    Let result be Operations.lcm("12", "18")
    Assert.AreEqual(result.lcm_result, "36")
    Return True

Process called "test_gcd_lcm_relationship" that takes no parameters returns Boolean:
    Note: Test relationship between GCD and LCM: gcd(a,b) * lcm(a,b) = a * b
    Let a be "12"
    Let b be "18"
    Let gcd_result be Operations.gcd(a, b)
    Let lcm_result be Operations.lcm(a, b)
    
    Let gcd_val be Parse gcd_result.gcd_result as Integer
    Let lcm_val be Parse lcm_result.lcm_result as Integer
    Let a_val be Parse a as Integer
    Let b_val be Parse b as Integer
    
    Assert.AreEqual(gcd_val * lcm_val, a_val * b_val)
    Return True

Note: =====================================================================
Note: COMPLEX NUMBER ARITHMETIC TESTS
Note: =====================================================================

Process called "test_complex_add_basic" that takes no parameters returns Boolean:
    Note: Test complex number addition
    Let result be Operations.complex_add("3", "4", "1", "2", 10)
    Assert.IsTrue(assert_complex_number_valid(result, "4", "6"))
    Return True

Process called "test_complex_subtract_basic" that takes no parameters returns Boolean:
    Note: Test complex number subtraction
    Let result be Operations.complex_subtract("3", "4", "1", "2", 10)
    Assert.IsTrue(assert_complex_number_valid(result, "2", "2"))
    Return True

Process called "test_complex_multiply_basic" that takes no parameters returns Boolean:
    Note: Test complex number multiplication
    Let result be Operations.complex_multiply("1", "2", "3", "4", 10)
    Assert.IsTrue(assert_complex_number_valid(result, "-5", "10"))
    Return True

Process called "test_complex_divide_basic" that takes no parameters returns Boolean:
    Note: Test complex number division
    Let result be Operations.complex_divide("1", "2", "1", "1", 10)
    Assert.IsTrue(assert_complex_number_valid(result, "1.5", "0.5"))
    Return True

Process called "test_complex_magnitude" that takes no parameters returns Boolean:
    Note: Test complex number magnitude calculation
    Let result be Operations.complex_magnitude("3", "4", 10)
    Assert.IsTrue(is_approximately_equal(result.magnitude, "5", 1e-9))
    Return True

Process called "test_complex_argument" that takes no parameters returns Boolean:
    Note: Test complex number argument (phase) calculation
    Let result be Operations.complex_argument("1", "1", 10)
    Assert.IsTrue(is_approximately_equal(result.argument, "0.785398163397448", 1e-14))
    Return True

Process called "test_complex_conjugate" that takes no parameters returns Boolean:
    Note: Test complex conjugate calculation
    Let result be Operations.complex_conjugate("3", "4", 10)
    Assert.IsTrue(assert_complex_number_valid(result, "3", "-4"))
    Return True

Note: =====================================================================
Note: PRECISION AND ERROR HANDLING TESTS
Note: =====================================================================

Process called "test_precision_consistency" that takes no parameters returns Boolean:
    Note: Test precision consistency across operations
    Let precision_levels be generate_precision_levels()
    For precision in precision_levels:
        Let result be Operations.add("1.234567890123456789", "2.345678901234567890", precision)
        Assert.IsTrue(result.precision_used = precision)
        Assert.IsTrue(Length(result.result_value) <= precision + 2)
    Return True

Process called "test_overflow_detection" that takes no parameters returns Boolean:
    Note: Test overflow detection in calculations
    Let large_num1 be "1e308"
    Let large_num2 be "1e308"
    Let result be Operations.multiply(large_num1, large_num2, 10)
    Assert.IsTrue(result.overflow_occurred OR result.error_occurred)
    Return True

Process called "test_underflow_detection" that takes no parameters returns Boolean:
    Note: Test underflow detection in calculations
    Let small_num1 be "1e-320"
    Let small_num2 be "1e-320"
    Let result be Operations.multiply(small_num1, small_num2, 10)
    Assert.IsTrue(result.underflow_occurred OR result.error_occurred)
    Return True

Process called "test_invalid_input_handling" that takes no parameters returns Boolean:
    Note: Test handling of invalid inputs
    Try:
        Let result be Operations.add("not_a_number", "2.5", 10)
        Assert.IsTrue(result.error_occurred)
    Catch error:
        Pass
    
    Try:
        Let result be Operations.divide("10", "not_a_number", 10)
        Assert.IsTrue(result.error_occurred)
    Catch error:
        Pass
    
    Return True

Note: =====================================================================
Note: PERFORMANCE AND OPTIMIZATION TESTS
Note: =====================================================================

Process called "test_arithmetic_associativity" that takes no parameters returns Boolean:
    Note: Test arithmetic associativity: (a + b) + c = a + (b + c)
    Let a be "1.5"
    Let b be "2.7"
    Let c be "3.9"
    
    Let result1 be Operations.add(Operations.add(a, b, 15).result_value, c, 15)
    Let result2 be Operations.add(a, Operations.add(b, c, 15).result_value, 15)
    
    Assert.IsTrue(is_approximately_equal(result1.result_value, result2.result_value, 1e-14))
    Return True

Process called "test_arithmetic_commutativity" that takes no parameters returns Boolean:
    Note: Test arithmetic commutativity: a + b = b + a, a * b = b * a
    Let a be "3.7"
    Let b be "2.5"
    
    Let add1 be Operations.add(a, b, 10)
    Let add2 be Operations.add(b, a, 10)
    Assert.AreEqual(add1.result_value, add2.result_value)
    
    Let mul1 be Operations.multiply(a, b, 10)
    Let mul2 be Operations.multiply(b, a, 10)
    Assert.AreEqual(mul1.result_value, mul2.result_value)
    Return True

Process called "test_distributive_property" that takes no parameters returns Boolean:
    Note: Test distributive property: a * (b + c) = a * b + a * c
    Let a be "2.5"
    Let b be "3.2"
    Let c be "1.8"
    
    Let sum_bc be Operations.add(b, c, 15)
    Let left_side be Operations.multiply(a, sum_bc.result_value, 15)
    
    Let ab be Operations.multiply(a, b, 15)
    Let ac be Operations.multiply(a, c, 15)
    Let right_side be Operations.add(ab.result_value, ac.result_value, 15)
    
    Assert.IsTrue(is_approximately_equal(left_side.result_value, right_side.result_value, 1e-13))
    Return True

Process called "test_operation_chaining" that takes no parameters returns Boolean:
    Note: Test chaining multiple operations
    Let step1 be Operations.add("1.5", "2.5", 15)
    Let step2 be Operations.multiply(step1.result_value, "3", 15)
    Let step3 be Operations.subtract(step2.result_value, "1", 15)
    Let step4 be Operations.divide(step3.result_value, "2", 15)
    
    Assert.IsTrue(is_approximately_equal(step4.result_value, "5.5", 1e-14))
    Return True

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all operations module tests
    Let tests_passed be 0
    Let tests_failed be 0
    
    Note: Basic arithmetic tests
    Let arithmetic_tests be [
        "test_add_basic",
        "test_add_negative_numbers",
        "test_add_high_precision",
        "test_add_zero",
        "test_subtract_basic",
        "test_subtract_negative_result",
        "test_subtract_high_precision",
        "test_multiply_basic",
        "test_multiply_by_zero",
        "test_multiply_by_one",
        "test_multiply_negative_numbers",
        "test_divide_basic",
        "test_divide_by_one",
        "test_divide_fractional_result",
        "test_divide_by_zero_error"
    ]
    
    Note: Power and root operation tests
    Let power_root_tests be [
        "test_power_integer_exponent",
        "test_power_fractional_exponent",
        "test_power_negative_exponent",
        "test_power_zero_exponent",
        "test_square_root_basic",
        "test_square_root_irrational",
        "test_square_root_negative_error",
        "test_cube_root_basic",
        "test_cube_root_negative",
        "test_nth_root_basic"
    ]
    
    Note: Logarithmic operation tests
    Let logarithmic_tests be [
        "test_natural_log_basic",
        "test_natural_log_powers_of_e",
        "test_log_base_10",
        "test_log_base_2",
        "test_log_arbitrary_base",
        "test_log_negative_error",
        "test_log_zero_error"
    ]
    
    Note: Factorial and combinatorial tests
    Let factorial_tests be [
        "test_factorial_small_numbers",
        "test_factorial_large_numbers",
        "test_factorial_negative_error",
        "test_combination_basic",
        "test_permutation_basic"
    ]
    
    Note: Absolute value and sign tests
    Let abs_sign_tests be [
        "test_absolute_value_positive",
        "test_absolute_value_negative",
        "test_absolute_value_zero",
        "test_sign_function_positive",
        "test_sign_function_negative",
        "test_sign_function_zero"
    ]
    
    Note: Modular arithmetic tests
    Let modular_tests be [
        "test_modulo_basic",
        "test_modulo_negative_dividend",
        "test_gcd_basic",
        "test_gcd_coprime",
        "test_lcm_basic",
        "test_gcd_lcm_relationship"
    ]
    
    Note: Complex number tests
    Let complex_tests be [
        "test_complex_add_basic",
        "test_complex_subtract_basic",
        "test_complex_multiply_basic",
        "test_complex_divide_basic",
        "test_complex_magnitude",
        "test_complex_argument",
        "test_complex_conjugate"
    ]
    
    Note: Precision and error handling tests
    Let precision_tests be [
        "test_precision_consistency",
        "test_overflow_detection",
        "test_underflow_detection",
        "test_invalid_input_handling"
    ]
    
    Note: Performance and optimization tests
    Let performance_tests be [
        "test_arithmetic_associativity",
        "test_arithmetic_commutativity",
        "test_distributive_property",
        "test_operation_chaining"
    ]
    
    Let all_test_groups be [arithmetic_tests, power_root_tests, logarithmic_tests, factorial_tests,
                           abs_sign_tests, modular_tests, complex_tests, precision_tests, performance_tests]
    
    Let group_names be ["Basic Arithmetic", "Power & Root Operations", "Logarithmic Operations", "Factorial & Combinatorial",
                       "Absolute Value & Sign", "Modular Arithmetic", "Complex Numbers", "Precision & Error Handling", "Performance & Optimization"]
    
    For group_index from 0 to Length(all_test_groups) - 1:
        Let test_group be all_test_groups[group_index]
        Let group_name be group_names[group_index]
        Print "Testing " + group_name + "..."
        
        For test_name in test_group:
            Try:
                Let test_result be Call test_name()
                If test_result:
                    Set tests_passed to tests_passed + 1
                    Print "  ✓ " + test_name
                Else:
                    Set tests_failed to tests_failed + 1  
                    Print "  ✗ " + test_name + " (returned false)"
            Catch error:
                Set tests_failed to tests_failed + 1
                Print "  ✗ " + test_name + " (error: " + error.message + ")"
    
    Let total_tests be tests_passed + tests_failed
    Print ""
    Print "Operations Module Test Results:"
    Print "==============================="
    Print "Tests passed: " + ToString(tests_passed)
    Print "Tests failed: " + ToString(tests_failed)
    Print "Total tests: " + ToString(total_tests)
    Print "Success rate: " + ToString((tests_passed * 100) / total_tests) + "%"
    
    Return tests_failed = 0