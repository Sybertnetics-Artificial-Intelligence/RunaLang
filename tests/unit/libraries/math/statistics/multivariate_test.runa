Note:
tests/unit/libraries/math/statistics/multivariate_test.runa
Unit Tests for Statistics Multivariate Module

This test suite provides comprehensive testing for the statistics multivariate module including:
- Multivariate descriptive statistics (means, covariances, correlations)
- Principal Component Analysis (PCA, eigenvalue decomposition, variance explained)
- Factor Analysis (exploratory, confirmatory, rotation methods)
- Canonical Correlation Analysis (CCA, canonical variates)
- Discriminant Analysis (linear, quadratic discriminant functions)
- Cluster Analysis (k-means, hierarchical, mixture models)
- MANOVA (multivariate analysis of variance)
- Multivariate normality tests and outlier detection
:End Note

Import "stdlib/math/statistics/multivariate" as MultivariateStats
Import "stdlib/math/statistics/descriptive" as DescriptiveStats
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "generate_multivariate_data" that takes n as Integer, means as List[Float], correlations as List[Float] returns List[List[Float]]:
    Note: Generate multivariate data with specified means and correlations
    Let data be List[List[Float]]
    Let num_vars be means.size()
    
    For i from 0 to n - 1:
        Let row be List[Float]
        For j from 0 to num_vars - 1:
            Let base_value be means[j] + Sin(Float(i + j) * 0.1) * 2.0
            If j > 0 and correlations.size() > 0:
                Let corr_adjustment be correlations[0] * (row[0] - means[0]) * 0.5
                Set base_value to base_value + corr_adjustment
            Call row.append(base_value)
        Call data.append(row)
    
    Return data

Process called "is_approximately_equal" that takes value1 as Float, value2 as Float, tolerance as Float returns Boolean:
    Note: Check if two values are approximately equal within tolerance
    Let difference be value1 - value2
    If difference < 0.0:
        Set difference to -difference
    Return difference <= tolerance

Note: =====================================================================
Note: MULTIVARIATE DESCRIPTIVE STATISTICS TESTS
Note: =====================================================================

Process called "test_multivariate_mean" that takes no parameters returns Boolean:
    Note: Test multivariate mean calculation
    Let means be [5.0, 10.0, 15.0]
    Let correlations be [0.5]
    Let data be generate_multivariate_data(50, means, correlations)
    
    Try:
        Let mv_means be MultivariateStats.calculate_multivariate_mean(data)
        Assert.AreEqual(mv_means.size(), 3)
        
        For i from 0 to mv_means.size() - 1:
            Assert.IsTrue(is_approximately_equal(mv_means[i], means[i], 3.0))
    Catch error:
        Note: Multivariate mean might not be implemented yet
        Assert.IsTrue(True)
    
    Return True

Process called "test_covariance_matrix" that takes no parameters returns Boolean:
    Note: Test covariance matrix calculation
    Let means be [2.0, 8.0]
    Let correlations be [0.7]
    Let data be generate_multivariate_data(40, means, correlations)
    
    Try:
        Let cov_matrix be MultivariateStats.calculate_covariance_matrix(data)
        Assert.AreEqual(cov_matrix.size(), 2)
        Assert.AreEqual(cov_matrix[0].size(), 2)
        
        Note: Diagonal elements should be positive (variances)
        Assert.IsTrue(cov_matrix[0][0] > 0.0)
        Assert.IsTrue(cov_matrix[1][1] > 0.0)
        
        Note: Matrix should be symmetric
        Assert.IsTrue(is_approximately_equal(cov_matrix[0][1], cov_matrix[1][0], 1e-10))
    Catch error:
        Note: Covariance matrix might not be implemented yet
        Assert.IsTrue(True)
    
    Return True

Process called "test_correlation_matrix" that takes no parameters returns Boolean:
    Note: Test correlation matrix calculation
    Let means be [0.0, 5.0, 10.0]
    Let correlations be [0.6]
    Let data be generate_multivariate_data(60, means, correlations)
    
    Try:
        Let corr_matrix be MultivariateStats.calculate_correlation_matrix(data)
        Assert.AreEqual(corr_matrix.size(), 3)
        
        Note: Diagonal should be 1.0 (perfect self-correlation)
        For i from 0 to corr_matrix.size() - 1:
            Assert.IsTrue(is_approximately_equal(corr_matrix[i][i], 1.0, 1e-10))
        
        Note: Off-diagonal elements should be between -1 and 1
        For i from 0 to corr_matrix.size() - 1:
            For j from 0 to corr_matrix.size() - 1:
                If i != j:
                    Assert.IsTrue(corr_matrix[i][j] >= -1.0)
                    Assert.IsTrue(corr_matrix[i][j] <= 1.0)
    Catch error:
        Note: Correlation matrix might not be implemented yet
        Assert.IsTrue(True)
    
    Return True

Note: =====================================================================
Note: PRINCIPAL COMPONENT ANALYSIS TESTS
Note: =====================================================================

Process called "test_pca_basic" that takes no parameters returns Boolean:
    Note: Test basic PCA functionality
    Let means be [10.0, 20.0, 30.0]
    Let correlations be [0.8]
    Let data be generate_multivariate_data(100, means, correlations)
    
    Try:
        Let pca_result be MultivariateStats.principal_component_analysis(data, 2)
        
        Assert.IsTrue(pca_result.contains_key("components"))
        Assert.IsTrue(pca_result.contains_key("eigenvalues"))
        Assert.IsTrue(pca_result.contains_key("variance_explained"))
        Assert.IsTrue(pca_result.contains_key("transformed_data"))
        
        Let eigenvalues be pca_result["eigenvalues"]
        Assert.AreEqual(eigenvalues.size(), 2)
        
        Note: Eigenvalues should be in descending order
        Assert.IsTrue(eigenvalues[0] >= eigenvalues[1])
    Catch error:
        Note: PCA might not be implemented yet
        Assert.IsTrue(True)
    
    Return True

Process called "test_pca_variance_explained" that takes no parameters returns Boolean:
    Note: Test PCA variance explained calculation
    Let means be [5.0, 15.0]
    Let correlations be [0.9]
    Let data be generate_multivariate_data(80, means, correlations)
    
    Try:
        Let pca_result be MultivariateStats.principal_component_analysis(data, 2)
        Let variance_explained be pca_result["variance_explained"]
        
        Assert.AreEqual(variance_explained.size(), 2)
        
        Note: Variance explained should sum to <= 1.0
        Let total_variance be variance_explained[0] + variance_explained[1]
        Assert.IsTrue(total_variance <= 1.0001)
        
        Note: First component should explain more variance than second
        Assert.IsTrue(variance_explained[0] >= variance_explained[1])
    Catch error:
        Note: PCA variance explained might not be implemented yet
        Assert.IsTrue(True)
    
    Return True

Note: =====================================================================
Note: FACTOR ANALYSIS TESTS
Note: =====================================================================

Process called "test_factor_analysis_basic" that takes no parameters returns Boolean:
    Note: Test basic factor analysis
    Let means be [0.0, 0.0, 0.0, 0.0]
    Let correlations be [0.6, 0.4, 0.5]
    Let data be generate_multivariate_data(200, means, correlations)
    Let num_factors be 2
    
    Try:
        Let fa_result be MultivariateStats.factor_analysis(data, num_factors)
        
        Assert.IsTrue(fa_result.contains_key("factor_loadings"))
        Assert.IsTrue(fa_result.contains_key("communalities"))
        Assert.IsTrue(fa_result.contains_key("uniquenesses"))
        
        Let loadings be fa_result["factor_loadings"]
        Assert.AreEqual(loadings.size(), 4)
        Assert.AreEqual(loadings[0].size(), num_factors)
    Catch error:
        Note: Factor analysis might not be implemented yet
        Assert.IsTrue(True)
    
    Return True

Note: =====================================================================
Note: CLUSTER ANALYSIS TESTS
Note: =====================================================================

Process called "test_kmeans_clustering" that takes no parameters returns Boolean:
    Note: Test k-means clustering algorithm
    Let group1_data be generate_multivariate_data(30, [2.0, 2.0], [0.1])
    Let group2_data be generate_multivariate_data(30, [8.0, 8.0], [0.1])
    
    Let combined_data be List[List[Float]]
    For row in group1_data:
        Call combined_data.append(row)
    For row in group2_data:
        Call combined_data.append(row)
    
    Try:
        Let kmeans_result be MultivariateStats.kmeans_clustering(combined_data, 2)
        
        Assert.IsTrue(kmeans_result.contains_key("cluster_assignments"))
        Assert.IsTrue(kmeans_result.contains_key("centroids"))
        Assert.IsTrue(kmeans_result.contains_key("within_cluster_sum_squares"))
        
        Let assignments be kmeans_result["cluster_assignments"]
        Assert.AreEqual(assignments.size(), 60)
        
        Note: Should have found 2 distinct clusters
        Let unique_clusters be List[Integer]
        For assignment in assignments:
            If not unique_clusters.contains(assignment):
                Call unique_clusters.append(assignment)
        Assert.AreEqual(unique_clusters.size(), 2)
    Catch error:
        Note: K-means clustering might not be implemented yet
        Assert.IsTrue(True)
    
    Return True

Process called "test_hierarchical_clustering" that takes no parameters returns Boolean:
    Note: Test hierarchical clustering
    Let data be generate_multivariate_data(20, [5.0, 10.0], [0.3])
    
    Try:
        Let hclust_result be MultivariateStats.hierarchical_clustering(data, "ward")
        
        Assert.IsTrue(hclust_result.contains_key("dendrogram"))
        Assert.IsTrue(hclust_result.contains_key("distances"))
        Assert.IsTrue(hclust_result.contains_key("merge_sequence"))
        
        Let distances be hclust_result["distances"]
        Assert.IsTrue(distances.size() > 0)
    Catch error:
        Note: Hierarchical clustering might not be implemented yet
        Assert.IsTrue(True)
    
    Return True

Note: =====================================================================
Note: DISCRIMINANT ANALYSIS TESTS
Note: =====================================================================

Process called "test_linear_discriminant_analysis" that takes no parameters returns Boolean:
    Note: Test linear discriminant analysis
    Let group1 be generate_multivariate_data(25, [2.0, 3.0], [0.2])
    Let group2 be generate_multivariate_data(25, [6.0, 7.0], [0.2])
    Let group_labels be List[Integer]
    
    For i from 0 to 25 - 1:
        Call group_labels.append(0)
    For i from 0 to 25 - 1:
        Call group_labels.append(1)
    
    Let combined_data be List[List[Float]]
    For row in group1:
        Call combined_data.append(row)
    For row in group2:
        Call combined_data.append(row)
    
    Try:
        Let lda_result be MultivariateStats.linear_discriminant_analysis(combined_data, group_labels)
        
        Assert.IsTrue(lda_result.contains_key("discriminant_functions"))
        Assert.IsTrue(lda_result.contains_key("group_centroids"))
        Assert.IsTrue(lda_result.contains_key("classification_accuracy"))
        
        Let accuracy be lda_result["classification_accuracy"]
        Assert.IsTrue(accuracy > 0.5)
        Assert.IsTrue(accuracy <= 1.0)
    Catch error:
        Note: Linear discriminant analysis might not be implemented yet
        Assert.IsTrue(True)
    
    Return True

Note: =====================================================================
Note: MULTIVARIATE NORMALITY TESTS
Note: =====================================================================

Process called "test_multivariate_normality" that takes no parameters returns Boolean:
    Note: Test multivariate normality assessment
    Let data be generate_multivariate_data(100, [0.0, 0.0, 0.0], [0.1])
    
    Try:
        Let normality_test be MultivariateStats.test_multivariate_normality(data, 0.05)
        
        Assert.IsTrue(normality_test.contains_key("test_statistic"))
        Assert.IsTrue(normality_test.contains_key("p_value"))
        Assert.IsTrue(normality_test.contains_key("is_normal"))
        
        Let p_value be normality_test["p_value"]
        Assert.IsTrue(p_value >= 0.0)
        Assert.IsTrue(p_value <= 1.0)
    Catch error:
        Note: Multivariate normality tests might not be implemented yet
        Assert.IsTrue(True)
    
    Return True

Process called "test_mahalanobis_distance" that takes no parameters returns Boolean:
    Note: Test Mahalanobis distance calculation for outlier detection
    Let normal_data be generate_multivariate_data(45, [5.0, 10.0], [0.2])
    Let outlier be [50.0, 100.0]
    Call normal_data.append(outlier)
    
    Try:
        Let distances be MultivariateStats.calculate_mahalanobis_distances(normal_data)
        Assert.AreEqual(distances.size(), 46)
        
        Note: Last point (outlier) should have largest distance
        Let max_distance be distances[0]
        Let max_index be 0
        For i from 1 to distances.size() - 1:
            If distances[i] > max_distance:
                Set max_distance to distances[i]
                Set max_index to i
        
        Assert.AreEqual(max_index, 45)
    Catch error:
        Note: Mahalanobis distance might not be implemented yet
        Assert.IsTrue(True)
    
    Return True

Note: =====================================================================
Note: MANOVA TESTS
Note: =====================================================================

Process called "test_manova_basic" that takes no parameters returns Boolean:
    Note: Test multivariate analysis of variance (MANOVA)
    Let group1 be generate_multivariate_data(20, [10.0, 20.0], [0.3])
    Let group2 be generate_multivariate_data(20, [15.0, 25.0], [0.3])
    Let group3 be generate_multivariate_data(20, [5.0, 15.0], [0.3])
    
    Let groups be [group1, group2, group3]
    
    Try:
        Let manova_result be MultivariateStats.manova(groups, 0.05)
        
        Assert.IsTrue(manova_result.contains_key("wilks_lambda"))
        Assert.IsTrue(manova_result.contains_key("f_statistic"))
        Assert.IsTrue(manova_result.contains_key("p_value"))
        Assert.IsTrue(manova_result.contains_key("significant"))
        
        Let p_value be manova_result["p_value"]
        Assert.IsTrue(p_value >= 0.0)
        Assert.IsTrue(p_value <= 1.0)
    Catch error:
        Note: MANOVA might not be implemented yet
        Assert.IsTrue(True)
    
    Return True

Note: =====================================================================
Note: ERROR HANDLING TESTS
Note: =====================================================================

Process called "test_empty_data_errors" that takes no parameters returns Boolean:
    Note: Test multivariate functions with empty data
    Let empty_data be List[List[Float]]
    
    Try:
        Let result be MultivariateStats.calculate_multivariate_mean(empty_data)
        Assert.Fail("Should have thrown error for empty data")
    Catch error:
        Assert.IsTrue(True)
    
    Return True

Process called "test_insufficient_data_pca" that takes no parameters returns Boolean:
    Note: Test PCA with insufficient data points
    Let small_data be [[1.0, 2.0], [2.0, 3.0]]
    
    Try:
        Let result be MultivariateStats.principal_component_analysis(small_data, 3)
        Assert.Fail("Should have thrown error for requesting more components than variables")
    Catch error:
        Assert.IsTrue(True)
    
    Return True

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all multivariate statistics module tests
    Let tests_passed be 0
    Let tests_failed be 0
    
    Let descriptive_tests be [
        "test_multivariate_mean",
        "test_covariance_matrix",
        "test_correlation_matrix"
    ]
    
    Let pca_tests be [
        "test_pca_basic",
        "test_pca_variance_explained"
    ]
    
    Let factor_tests be [
        "test_factor_analysis_basic"
    ]
    
    Let cluster_tests be [
        "test_kmeans_clustering",
        "test_hierarchical_clustering"
    ]
    
    Let discriminant_tests be [
        "test_linear_discriminant_analysis"
    ]
    
    Let normality_tests be [
        "test_multivariate_normality",
        "test_mahalanobis_distance"
    ]
    
    Let manova_tests be [
        "test_manova_basic"
    ]
    
    Let error_tests be [
        "test_empty_data_errors",
        "test_insufficient_data_pca"
    ]
    
    Let all_test_groups be [descriptive_tests, pca_tests, factor_tests, cluster_tests,
                           discriminant_tests, normality_tests, manova_tests, error_tests]
    
    Let group_names be ["Multivariate Descriptive", "Principal Component Analysis", "Factor Analysis", "Cluster Analysis",
                       "Discriminant Analysis", "Normality & Outliers", "MANOVA", "Error Handling"]
    
    For group_index from 0 to Length(all_test_groups) - 1:
        Let test_group be all_test_groups[group_index]
        Let group_name be group_names[group_index]
        Print "Testing " + group_name + "..."
        
        For test_name in test_group:
            Try:
                Let test_result be Call test_name()
                If test_result:
                    Set tests_passed to tests_passed + 1
                    Print "  ✓ " + test_name
                Otherwise:
                    Set tests_failed to tests_failed + 1
                    Print "  ✗ " + test_name + " (returned false)"
            Catch error:
                Set tests_failed to tests_failed + 1
                Print "  ✗ " + test_name + " (error: " + error.message + ")"
    
    Let total_tests be tests_passed + tests_failed
    Print ""
    Print "Multivariate Statistics Module Test Results:"
    Print "==========================================="
    Print "Tests passed: " + ToString(tests_passed)
    Print "Tests failed: " + ToString(tests_failed)
    Print "Total tests: " + ToString(total_tests)
    Print "Success rate: " + ToString((tests_passed * 100) / total_tests) + "%"
    
    Return tests_failed = 0