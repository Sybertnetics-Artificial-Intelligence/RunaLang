Note:
tests/unit/libraries/math/statistics/descriptive_test.runa
Unit Tests for Statistics Descriptive Module

This test suite provides comprehensive testing for the statistics descriptive module including:
- Central tendency measures (mean, median, mode, geometric mean, harmonic mean)
- Variability measures (variance, standard deviation, range, coefficient of variation)
- Distribution shape analysis (skewness, kurtosis, normality assessment)
- Quantile analysis (percentiles, quartiles, outlier detection)
- Robust statistics (trimmed mean, winsorized mean, robust scale estimators)
- Comprehensive statistical summaries and profiling
- Data transformation and bootstrapping methods
- Missing value handling and validation
:End Note

Import "stdlib/math/statistics/descriptive" as DescriptiveStats
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "generate_normal_sample" that takes n as Integer returns List[Float]:
    Note: Generate sample data that approximates normal distribution
    Let data be List[Float]
    For i from 0 to n - 1:
        Let value be 50.0 + 10.0 * Sin(Float(i) * 0.1) + Float(i % 3 - 1) * 2.0
        Call data.append(value)
    Return data

Process called "generate_skewed_sample" that takes n as Integer returns List[Float]:
    Note: Generate positively skewed sample data
    Let data be List[Float]
    For i from 0 to n - 1:
        Let base be Float(i + 1)
        Let value be base * base * 0.1 + base * 0.5 + 1.0
        Call data.append(value)
    Return data

Process called "generate_uniform_sample" that takes n as Integer, min_val as Float, max_val as Float returns List[Float]:
    Note: Generate uniform sample data between min and max values
    Let data be List[Float]
    Let range_val be max_val - min_val
    For i from 0 to n - 1:
        Let normalized be Float(i) / Float(n - 1)
        Let value be min_val + normalized * range_val
        Call data.append(value)
    Return data

Process called "is_approximately_equal" that takes value1 as Float, value2 as Float, tolerance as Float returns Boolean:
    Note: Check if two values are approximately equal within tolerance
    Let difference be value1 - value2
    If difference < 0.0:
        Set difference to -difference
    Return difference <= tolerance

Process called "validate_statistical_summary" that takes summary as StatisticalSummary, expected_mean as Float, tolerance as Float returns Boolean:
    Note: Validate key components of statistical summary
    Assert.IsTrue(summary.sample_size > 0)
    Assert.IsTrue(is_approximately_equal(summary.mean, expected_mean, tolerance))
    Assert.IsTrue(summary.standard_deviation >= 0.0)
    Assert.IsTrue(summary.variance >= 0.0)
    Assert.IsTrue(summary.minimum <= summary.maximum)
    Return True

Note: =====================================================================
Note: CENTRAL TENDENCY TESTS
Note: =====================================================================

Process called "test_arithmetic_mean_basic" that takes no parameters returns Boolean:
    Note: Test basic arithmetic mean calculation
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let weights be List[Float]
    Let result be DescriptiveStats.calculate_arithmetic_mean(data, weights)
    Assert.IsTrue(is_approximately_equal(result, 3.0, 1e-10))
    Return True

Process called "test_arithmetic_mean_weighted" that takes no parameters returns Boolean:
    Note: Test weighted arithmetic mean calculation
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let weights be [1.0, 1.0, 2.0, 1.0, 1.0]
    Let result be DescriptiveStats.calculate_arithmetic_mean(data, weights)
    Let expected be (1.0 + 2.0 + 6.0 + 4.0 + 5.0) / 6.0
    Assert.IsTrue(is_approximately_equal(result, expected, 1e-10))
    Return True

Process called "test_arithmetic_mean_empty_error" that takes no parameters returns Boolean:
    Note: Test arithmetic mean with empty dataset error
    Try:
        Let data be List[Float]
        Let weights be List[Float]
        Let result be DescriptiveStats.calculate_arithmetic_mean(data, weights)
        Assert.Fail("Should have thrown error for empty dataset")
    Catch error:
        Assert.IsTrue(True)
    Return True

Process called "test_geometric_mean_basic" that takes no parameters returns Boolean:
    Note: Test basic geometric mean calculation
    Let data be [1.0, 2.0, 4.0, 8.0]
    Let result be DescriptiveStats.calculate_geometric_mean(data, false)
    Let expected be 2.828427124746190
    Assert.IsTrue(is_approximately_equal(result, expected, 1e-10))
    Return True

Process called "test_geometric_mean_with_zero" that takes no parameters returns Boolean:
    Note: Test geometric mean with zero value
    Let data be [1.0, 0.0, 4.0, 8.0]
    Let result be DescriptiveStats.calculate_geometric_mean(data, false)
    Assert.IsTrue(is_approximately_equal(result, 0.0, 1e-10))
    Return True

Process called "test_geometric_mean_negative_error" that takes no parameters returns Boolean:
    Note: Test geometric mean with negative values error
    Try:
        Let data be [1.0, -2.0, 4.0, 8.0]
        Let result be DescriptiveStats.calculate_geometric_mean(data, false)
        Assert.Fail("Should have thrown error for negative values")
    Catch error:
        Assert.IsTrue(True)
    Return True

Process called "test_harmonic_mean_basic" that takes no parameters returns Boolean:
    Note: Test basic harmonic mean calculation
    Let data be [1.0, 2.0, 4.0]
    Let result be DescriptiveStats.calculate_harmonic_mean(data, false)
    Let expected be 3.0 / (1.0 + 0.5 + 0.25)
    Assert.IsTrue(is_approximately_equal(result, expected, 1e-10))
    Return True

Process called "test_harmonic_mean_with_zero_error" that takes no parameters returns Boolean:
    Note: Test harmonic mean with zero value error
    Try:
        Let data be [1.0, 0.0, 4.0]
        Let result be DescriptiveStats.calculate_harmonic_mean(data, false)
        Assert.Fail("Should have thrown error for zero values")
    Catch error:
        Assert.IsTrue(True)
    Return True

Process called "test_harmonic_mean_exclude_zero" that takes no parameters returns Boolean:
    Note: Test harmonic mean excluding zero values
    Let data be [1.0, 0.0, 4.0]
    Let result be DescriptiveStats.calculate_harmonic_mean(data, true)
    Let expected be 2.0 / (1.0 + 0.25)
    Assert.IsTrue(is_approximately_equal(result, expected, 1e-10))
    Return True

Process called "test_median_odd_size" that takes no parameters returns Boolean:
    Note: Test median with odd number of elements
    Let data be [3.0, 1.0, 4.0, 1.0, 5.0]
    Let result be DescriptiveStats.find_median(data, "linear")
    Assert.IsTrue(is_approximately_equal(result, 3.0, 1e-10))
    Return True

Process called "test_median_even_size" that takes no parameters returns Boolean:
    Note: Test median with even number of elements
    Let data be [1.0, 2.0, 3.0, 4.0]
    Let result be DescriptiveStats.find_median(data, "linear")
    Assert.IsTrue(is_approximately_equal(result, 2.5, 1e-10))
    Return True

Process called "test_median_interpolation_methods" that takes no parameters returns Boolean:
    Note: Test different median interpolation methods
    Let data be [1.0, 2.0, 3.0, 4.0]
    
    Let linear_result be DescriptiveStats.find_median(data, "linear")
    Assert.IsTrue(is_approximately_equal(linear_result, 2.5, 1e-10))
    
    Let lower_result be DescriptiveStats.find_median(data, "lower")
    Assert.IsTrue(is_approximately_equal(lower_result, 2.0, 1e-10))
    
    Let higher_result be DescriptiveStats.find_median(data, "higher")
    Assert.IsTrue(is_approximately_equal(higher_result, 3.0, 1e-10))
    
    Return True

Process called "test_mode_single" that takes no parameters returns Boolean:
    Note: Test mode with single most frequent value
    Let data be [1.0, 2.0, 2.0, 3.0, 4.0]
    Let result be DescriptiveStats.find_mode(data, 0.1)
    Assert.AreEqual(result.size(), 1)
    Assert.IsTrue(is_approximately_equal(result[0], 2.0, 1e-10))
    Return True

Process called "test_mode_multimodal" that takes no parameters returns Boolean:
    Note: Test mode with multiple most frequent values
    Let data be [1.0, 2.0, 2.0, 3.0, 3.0]
    Let result be DescriptiveStats.find_mode(data, 0.1)
    Assert.AreEqual(result.size(), 2)
    Return True

Process called "test_mode_with_tolerance" that takes no parameters returns Boolean:
    Note: Test mode with tolerance for continuous data
    Let data be [1.01, 1.02, 2.0, 2.01, 3.0]
    Let result be DescriptiveStats.find_mode(data, 0.1)
    Assert.IsTrue(result.size() >= 1)
    Return True

Note: =====================================================================
Note: VARIABILITY MEASURES TESTS
Note: =====================================================================

Process called "test_variance_population" that takes no parameters returns Boolean:
    Note: Test population variance calculation
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let result be DescriptiveStats.calculate_variance(data, true, false)
    Assert.IsTrue(is_approximately_equal(result, 2.0, 1e-10))
    Return True

Process called "test_variance_sample" that takes no parameters returns Boolean:
    Note: Test sample variance calculation with Bessel's correction
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let result be DescriptiveStats.calculate_variance(data, false, true)
    Assert.IsTrue(is_approximately_equal(result, 2.5, 1e-10))
    Return True

Process called "test_variance_single_value_error" that takes no parameters returns Boolean:
    Note: Test sample variance error with single data point
    Try:
        Let data be [5.0]
        Let result be DescriptiveStats.calculate_variance(data, false, true)
        Assert.Fail("Should have thrown error for single data point")
    Catch error:
        Assert.IsTrue(True)
    Return True

Process called "test_standard_deviation_basic" that takes no parameters returns Boolean:
    Note: Test basic standard deviation calculation
    Let data be [2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0]
    Let result be DescriptiveStats.calculate_standard_deviation(data, false)
    Assert.IsTrue(result > 0.0)
    Return True

Process called "test_standard_deviation_zero_variance" that takes no parameters returns Boolean:
    Note: Test standard deviation with zero variance (constant values)
    Let data be [5.0, 5.0, 5.0, 5.0]
    Let result be DescriptiveStats.calculate_standard_deviation(data, false)
    Assert.IsTrue(is_approximately_equal(result, 0.0, 1e-10))
    Return True

Process called "test_range_basic" that takes no parameters returns Boolean:
    Note: Test basic range calculation
    Let data be [1.0, 3.0, 2.0, 8.0, 5.0]
    Let result be DescriptiveStats.calculate_range(data)
    Assert.IsTrue(is_approximately_equal(result["minimum"], 1.0, 1e-10))
    Assert.IsTrue(is_approximately_equal(result["maximum"], 8.0, 1e-10))
    Assert.IsTrue(is_approximately_equal(result["range"], 7.0, 1e-10))
    Return True

Process called "test_range_with_quartiles" that takes no parameters returns Boolean:
    Note: Test range calculation with quartile information
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]
    Let result be DescriptiveStats.calculate_range(data)
    Assert.IsTrue(result.contains_key("Q1"))
    Assert.IsTrue(result.contains_key("Q3"))
    Assert.IsTrue(result.contains_key("IQR"))
    Assert.IsTrue(result["IQR"] > 0.0)
    Return True

Process called "test_coefficient_of_variation" that takes no parameters returns Boolean:
    Note: Test coefficient of variation calculation
    Let data be [10.0, 15.0, 20.0, 25.0, 30.0]
    Let result be DescriptiveStats.calculate_coefficient_of_variation(data)
    Assert.IsTrue(result > 0.0)
    Assert.IsTrue(result < 100.0)
    Return True

Process called "test_coefficient_of_variation_zero_mean_error" that takes no parameters returns Boolean:
    Note: Test coefficient of variation with zero mean error
    Try:
        Let data be [-2.0, 0.0, 2.0]
        Let result be DescriptiveStats.calculate_coefficient_of_variation(data)
        Assert.Fail("Should have thrown error for zero mean")
    Catch error:
        Assert.IsTrue(True)
    Return True

Process called "test_mean_absolute_deviation" that takes no parameters returns Boolean:
    Note: Test mean absolute deviation calculation
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let result_mean be DescriptiveStats.calculate_mean_absolute_deviation(data, "mean")
    Let result_median be DescriptiveStats.calculate_mean_absolute_deviation(data, "median")
    Assert.IsTrue(result_mean > 0.0)
    Assert.IsTrue(result_median > 0.0)
    Return True

Process called "test_mean_absolute_deviation_invalid_center" that takes no parameters returns Boolean:
    Note: Test mean absolute deviation with invalid center parameter
    Try:
        Let data be [1.0, 2.0, 3.0]
        Let result be DescriptiveStats.calculate_mean_absolute_deviation(data, "invalid")
        Assert.Fail("Should have thrown error for invalid center")
    Catch error:
        Assert.IsTrue(True)
    Return True

Note: =====================================================================
Note: QUANTILE ANALYSIS TESTS
Note: =====================================================================

Process called "test_percentiles_basic" that takes no parameters returns Boolean:
    Note: Test basic percentile calculations
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
    Let percentiles be [25.0, 50.0, 75.0]
    Let result be DescriptiveStats.calculate_percentiles(data, percentiles, "linear")
    Assert.IsTrue(result.contains_key("25.0"))
    Assert.IsTrue(result.contains_key("50.0"))
    Assert.IsTrue(result.contains_key("75.0"))
    Assert.IsTrue(is_approximately_equal(result["50.0"], 5.5, 1e-10))
    Return True

Process called "test_percentiles_interpolation_methods" that takes no parameters returns Boolean:
    Note: Test different percentile interpolation methods
    Let data be [1.0, 2.0, 3.0, 4.0]
    Let percentiles be [50.0]
    
    Let linear_result be DescriptiveStats.calculate_percentiles(data, percentiles, "linear")
    Let nearest_result be DescriptiveStats.calculate_percentiles(data, percentiles, "nearest")
    Let lower_result be DescriptiveStats.calculate_percentiles(data, percentiles, "lower")
    Let higher_result be DescriptiveStats.calculate_percentiles(data, percentiles, "higher")
    
    Assert.IsTrue(linear_result.contains_key("50.0"))
    Assert.IsTrue(nearest_result.contains_key("50.0"))
    Assert.IsTrue(lower_result.contains_key("50.0"))
    Assert.IsTrue(higher_result.contains_key("50.0"))
    
    Return True

Process called "test_percentiles_invalid_range" that takes no parameters returns Boolean:
    Note: Test percentiles with invalid range values
    Try:
        Let data be [1.0, 2.0, 3.0]
        Let percentiles be [150.0]
        Let result be DescriptiveStats.calculate_percentiles(data, percentiles, "linear")
        Assert.Fail("Should have thrown error for percentile > 100")
    Catch error:
        Assert.IsTrue(True)
    Return True

Process called "test_quartiles_basic" that takes no parameters returns Boolean:
    Note: Test quartile calculation
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]
    Let result be DescriptiveStats.calculate_quartiles(data)
    Assert.IsTrue(result.contains_key("Q1"))
    Assert.IsTrue(result.contains_key("Q2"))
    Assert.IsTrue(result.contains_key("Q3"))
    Assert.IsTrue(result.contains_key("IQR"))
    Assert.IsTrue(result["Q1"] < result["Q2"])
    Assert.IsTrue(result["Q2"] < result["Q3"])
    Assert.IsTrue(result["IQR"] > 0.0)
    Return True

Process called "test_quartiles_outlier_boundaries" that takes no parameters returns Boolean:
    Note: Test quartile outlier boundary calculations
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]
    Let result be DescriptiveStats.calculate_quartiles(data)
    Assert.IsTrue(result.contains_key("lower_outlier_boundary"))
    Assert.IsTrue(result.contains_key("upper_outlier_boundary"))
    Assert.IsTrue(result["lower_outlier_boundary"] < result["Q1"])
    Assert.IsTrue(result["upper_outlier_boundary"] > result["Q3"])
    Return True

Process called "test_quantile_function" that takes no parameters returns Boolean:
    Note: Test quantile function (inverse CDF) calculation
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let probabilities be [0.25, 0.5, 0.75]
    Let result be DescriptiveStats.calculate_quantile_function(data, probabilities)
    Assert.IsTrue(result.contains_key("0.25"))
    Assert.IsTrue(result.contains_key("0.5"))
    Assert.IsTrue(result.contains_key("0.75"))
    Return True

Process called "test_quantile_function_invalid_probability" that takes no parameters returns Boolean:
    Note: Test quantile function with invalid probability values
    Try:
        Let data be [1.0, 2.0, 3.0]
        Let probabilities be [1.5]
        Let result be DescriptiveStats.calculate_quantile_function(data, probabilities)
        Assert.Fail("Should have thrown error for probability > 1")
    Catch error:
        Assert.IsTrue(True)
    Return True

Process called "test_outlier_detection_iqr" that takes no parameters returns Boolean:
    Note: Test IQR-based outlier detection
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0, 100.0]
    Let result be DescriptiveStats.detect_outliers_iqr(data, 1.5)
    Assert.IsTrue(result.size() > 0)
    Assert.IsTrue(result.contains(5))
    Return True

Process called "test_outlier_detection_no_outliers" that takes no parameters returns Boolean:
    Note: Test outlier detection with no outliers
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let result be DescriptiveStats.detect_outliers_iqr(data, 1.5)
    Assert.AreEqual(result.size(), 0)
    Return True

Note: =====================================================================
Note: DISTRIBUTION SHAPE TESTS
Note: =====================================================================

Process called "test_skewness_symmetric" that takes no parameters returns Boolean:
    Note: Test skewness of symmetric distribution
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let result be DescriptiveStats.calculate_skewness(data, "Fisher")
    Assert.IsTrue(is_approximately_equal(result, 0.0, 0.5))
    Return True

Process called "test_skewness_positively_skewed" that takes no parameters returns Boolean:
    Note: Test skewness of positively skewed distribution
    Let data be generate_skewed_sample(20)
    Let result be DescriptiveStats.calculate_skewness(data, "Fisher")
    Assert.IsTrue(result > 0.0)
    Return True

Process called "test_skewness_insufficient_data" that takes no parameters returns Boolean:
    Note: Test skewness with insufficient data points
    Try:
        Let data be [1.0, 2.0]
        Let result be DescriptiveStats.calculate_skewness(data, "Fisher")
        Assert.Fail("Should have thrown error for insufficient data")
    Catch error:
        Assert.IsTrue(True)
    Return True

Process called "test_skewness_zero_variance" that takes no parameters returns Boolean:
    Note: Test skewness with zero variance (constant values)
    Try:
        Let data be [5.0, 5.0, 5.0, 5.0]
        Let result be DescriptiveStats.calculate_skewness(data, "Fisher")
        Assert.Fail("Should have thrown error for zero variance")
    Catch error:
        Assert.IsTrue(True)
    Return True

Process called "test_kurtosis_normal" that takes no parameters returns Boolean:
    Note: Test kurtosis of approximately normal distribution
    Let data be generate_normal_sample(50)
    Let result be DescriptiveStats.calculate_kurtosis(data, true)
    Assert.IsTrue(result >= -3.0)
    Assert.IsTrue(result <= 3.0)
    Return True

Process called "test_kurtosis_insufficient_data" that takes no parameters returns Boolean:
    Note: Test kurtosis with insufficient data points
    Try:
        Let data be [1.0, 2.0, 3.0]
        Let result be DescriptiveStats.calculate_kurtosis(data, true)
        Assert.Fail("Should have thrown error for insufficient data")
    Catch error:
        Assert.IsTrue(True)
    Return True

Process called "test_kurtosis_excess_vs_raw" that takes no parameters returns Boolean:
    Note: Test difference between excess and raw kurtosis
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let raw_kurtosis be DescriptiveStats.calculate_kurtosis(data, false)
    Let excess_kurtosis be DescriptiveStats.calculate_kurtosis(data, true)
    Assert.IsTrue(is_approximately_equal(excess_kurtosis, raw_kurtosis - 3.0, 1e-10))
    Return True

Process called "test_normality_assessment" that takes no parameters returns Boolean:
    Note: Test normality assessment functionality
    Let normal_data be generate_normal_sample(30)
    Let skewed_data be generate_skewed_sample(30)
    
    Let normal_result be DescriptiveStats.assess_normality(normal_data, 0.05)
    Let skewed_result be DescriptiveStats.assess_normality(skewed_data, 0.05)
    
    Assert.IsTrue(normal_result.contains_key("skewness"))
    Assert.IsTrue(normal_result.contains_key("excess_kurtosis"))
    Assert.IsTrue(normal_result.contains_key("normality_score"))
    Assert.IsTrue(normal_result.contains_key("is_normal"))
    
    Assert.IsTrue(skewed_result["is_normal"] <= normal_result["is_normal"])
    
    Return True

Process called "test_moments_calculation" that takes no parameters returns Boolean:
    Note: Test moments calculation up to specified order
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let result be DescriptiveStats.calculate_moments(data, 4, true)
    
    Assert.AreEqual(result.moment_order, 4)
    Assert.AreEqual(result.raw_moments.size(), 5)
    Assert.AreEqual(result.central_moments.size(), 5)
    Assert.AreEqual(result.standardized_moments.size(), 5)
    Assert.AreEqual(result.cumulants.size(), 5)
    
    Assert.IsTrue(is_approximately_equal(result.raw_moments[0], 1.0, 1e-10))
    Assert.IsTrue(is_approximately_equal(result.central_moments[0], 1.0, 1e-10))
    Assert.IsTrue(is_approximately_equal(result.central_moments[1], 0.0, 1e-10))
    
    Return True

Note: =====================================================================
Note: ROBUST STATISTICS TESTS
Note: =====================================================================

Process called "test_trimmed_mean_basic" that takes no parameters returns Boolean:
    Note: Test basic trimmed mean calculation
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
    Let result be DescriptiveStats.calculate_trimmed_mean(data, 10.0)
    Assert.IsTrue(result > 3.0)
    Assert.IsTrue(result < 8.0)
    Return True

Process called "test_trimmed_mean_no_trimming" that takes no parameters returns Boolean:
    Note: Test trimmed mean with zero trimming (should equal regular mean)
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let empty_weights be List[Float]
    Let trimmed_result be DescriptiveStats.calculate_trimmed_mean(data, 0.0)
    Let regular_mean be DescriptiveStats.calculate_arithmetic_mean(data, empty_weights)
    Assert.IsTrue(is_approximately_equal(trimmed_result, regular_mean, 1e-10))
    Return True

Process called "test_trimmed_mean_excessive_trimming" that takes no parameters returns Boolean:
    Note: Test trimmed mean with excessive trimming percentage
    Try:
        Let data be [1.0, 2.0, 3.0]
        Let result be DescriptiveStats.calculate_trimmed_mean(data, 60.0)
        Assert.Fail("Should have thrown error for excessive trimming")
    Catch error:
        Assert.IsTrue(True)
    Return True

Process called "test_winsorized_mean_basic" that takes no parameters returns Boolean:
    Note: Test basic winsorized mean calculation
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 100.0]
    Let limits be [10.0, 90.0]
    Let result be DescriptiveStats.calculate_winsorized_mean(data, limits)
    Assert.IsTrue(result < 20.0)
    Return True

Process called "test_winsorized_mean_invalid_limits" that takes no parameters returns Boolean:
    Note: Test winsorized mean with invalid limit parameters
    Try:
        Let data be [1.0, 2.0, 3.0]
        Let limits be [50.0, 30.0]
        Let result be DescriptiveStats.calculate_winsorized_mean(data, limits)
        Assert.Fail("Should have thrown error for invalid limits")
    Catch error:
        Assert.IsTrue(True)
    Return True

Process called "test_robust_scale_mad" that takes no parameters returns Boolean:
    Note: Test MAD (Median Absolute Deviation) robust scale estimator
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0, 100.0]
    Let result be DescriptiveStats.calculate_robust_scale(data, "MAD")
    Assert.IsTrue(result > 0.0)
    Return True

Process called "test_robust_scale_iqr" that takes no parameters returns Boolean:
    Note: Test IQR robust scale estimator
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]
    Let result be DescriptiveStats.calculate_robust_scale(data, "IQR")
    Assert.IsTrue(result > 0.0)
    Return True

Process called "test_robust_scale_rousseeuw_croux" that takes no parameters returns Boolean:
    Note: Test Rousseeuw-Croux robust scale estimator
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let result be DescriptiveStats.calculate_robust_scale(data, "Rousseeuw-Croux")
    Assert.IsTrue(result >= 0.0)
    Return True

Process called "test_hodges_lehmann_estimator" that takes no parameters returns Boolean:
    Note: Test Hodges-Lehmann location estimator
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let result be DescriptiveStats.calculate_hodges_lehmann_estimator(data)
    Assert.IsTrue(result >= 1.0)
    Assert.IsTrue(result <= 5.0)
    Return True

Process called "test_hodges_lehmann_single_value" that takes no parameters returns Boolean:
    Note: Test Hodges-Lehmann estimator with single value
    Let data be [3.5]
    Let result be DescriptiveStats.calculate_hodges_lehmann_estimator(data)
    Assert.IsTrue(is_approximately_equal(result, 3.5, 1e-10))
    Return True

Note: =====================================================================
Note: COMPREHENSIVE SUMMARY TESTS
Note: =====================================================================

Process called "test_descriptive_summary_basic" that takes no parameters returns Boolean:
    Note: Test comprehensive descriptive statistics summary
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
    Let result be DescriptiveStats.generate_descriptive_summary(data, true)
    
    Assert.AreEqual(result.sample_size, 10)
    Assert.IsTrue(is_approximately_equal(result.mean, 5.5, 1e-10))
    Assert.IsTrue(is_approximately_equal(result.median, 5.5, 1e-10))
    Assert.IsTrue(result.variance > 0.0)
    Assert.IsTrue(result.standard_deviation > 0.0)
    Assert.IsTrue(is_approximately_equal(result.minimum, 1.0, 1e-10))
    Assert.IsTrue(is_approximately_equal(result.maximum, 10.0, 1e-10))
    Assert.IsTrue(is_approximately_equal(result.range, 9.0, 1e-10))
    
    Return True

Process called "test_five_number_summary" that takes no parameters returns Boolean:
    Note: Test five-number summary creation
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]
    Let result be DescriptiveStats.create_five_number_summary(data)
    
    Assert.IsTrue(result.contains_key("minimum"))
    Assert.IsTrue(result.contains_key("Q1"))
    Assert.IsTrue(result.contains_key("median"))
    Assert.IsTrue(result.contains_key("Q3"))
    Assert.IsTrue(result.contains_key("maximum"))
    Assert.IsTrue(result.contains_key("IQR"))
    Assert.IsTrue(result.contains_key("outlier_count"))
    
    Assert.IsTrue(result["minimum"] <= result["Q1"])
    Assert.IsTrue(result["Q1"] <= result["median"])
    Assert.IsTrue(result["median"] <= result["Q3"])
    Assert.IsTrue(result["Q3"] <= result["maximum"])
    
    Return True

Process called "test_frequency_distribution_equal_width" that takes no parameters returns Boolean:
    Note: Test frequency distribution with equal-width bins
    Let data be generate_uniform_sample(50, 0.0, 100.0)
    Let result be DescriptiveStats.calculate_frequency_distribution(data, 10, "equal-width")
    
    Assert.IsTrue(result.contains_key("bin_edges"))
    Assert.IsTrue(result.contains_key("bin_counts"))
    Assert.IsTrue(result.contains_key("bin_centers"))
    
    Let bin_edges be result["bin_edges"]
    Let bin_counts be result["bin_counts"]
    
    Assert.AreEqual(bin_edges.size(), 11)
    Assert.AreEqual(bin_counts.size(), 10)
    
    Return True

Process called "test_frequency_distribution_sturges" that takes no parameters returns Boolean:
    Note: Test frequency distribution with Sturges rule
    Let data be generate_normal_sample(100)
    Let result be DescriptiveStats.calculate_frequency_distribution(data, 0, "Sturges")
    
    Assert.IsTrue(result.contains_key("bin_edges"))
    Assert.IsTrue(result.contains_key("bin_counts"))
    Assert.IsTrue(result.contains_key("bin_centers"))
    
    Return True

Process called "test_statistical_profile" that takes no parameters returns Boolean:
    Note: Test comprehensive statistical profile generation
    Let data be generate_normal_sample(50)
    Let config be Dictionary[String, String]
    Let result be DescriptiveStats.generate_statistical_profile(data, config)
    
    Assert.IsTrue(result.contains_key("basic_statistics"))
    Assert.IsTrue(result.contains_key("range_statistics"))
    Assert.IsTrue(result.contains_key("quartile_statistics"))
    Assert.IsTrue(result.contains_key("outlier_analysis"))
    Assert.IsTrue(result.contains_key("normality_assessment"))
    
    Return True

Note: =====================================================================
Note: COMPARATIVE STATISTICS TESTS
Note: =====================================================================

Process called "test_compare_distributions" that takes no parameters returns Boolean:
    Note: Test distribution comparison functionality
    Let data1 be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let data2 be [3.0, 4.0, 5.0, 6.0, 7.0]
    Let result be DescriptiveStats.compare_distributions(data1, data2)
    
    Assert.IsTrue(result.contains_key("mean_difference"))
    Assert.IsTrue(result.contains_key("std_dev_ratio"))
    Assert.IsTrue(result.contains_key("cohens_d"))
    Assert.IsTrue(result.contains_key("median_difference"))
    
    Assert.IsTrue(result["mean_difference"] < 0.0)
    Assert.IsTrue(result["median_difference"] < 0.0)
    
    Return True

Process called "test_effect_size_cohens_d" that takes no parameters returns Boolean:
    Note: Test Cohen's d effect size calculation
    Let group1 be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let group2 be [3.0, 4.0, 5.0, 6.0, 7.0]
    Let result be DescriptiveStats.calculate_effect_size(group1, group2, "cohens_d")
    Assert.IsTrue(result < 0.0)
    Return True

Process called "test_effect_size_glass_delta" that takes no parameters returns Boolean:
    Note: Test Glass's delta effect size calculation
    Let group1 be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let group2 be [3.0, 4.0, 5.0, 6.0, 7.0]
    Let result be DescriptiveStats.calculate_effect_size(group1, group2, "glass_delta")
    Assert.IsTrue(result < 0.0)
    Return True

Process called "test_distribution_overlap" that takes no parameters returns Boolean:
    Note: Test distribution overlap assessment
    Let data1 be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let data2 be [4.0, 5.0, 6.0, 7.0, 8.0]
    Let result be DescriptiveStats.assess_distribution_overlap(data1, data2)
    
    Assert.IsTrue(result.contains_key("range_overlap_ratio"))
    Assert.IsTrue(result.contains_key("iqr_overlap_ratio"))
    Assert.IsTrue(result.contains_key("standardized_mean_distance"))
    
    Assert.IsTrue(result["range_overlap_ratio"] > 0.0)
    Assert.IsTrue(result["range_overlap_ratio"] <= 1.0)
    
    Return True

Note: =====================================================================
Note: UTILITY AND DATA HANDLING TESTS
Note: =====================================================================

Process called "test_validate_assumptions_normality" that takes no parameters returns Boolean:
    Note: Test statistical assumption validation for normality
    Let normal_data be generate_normal_sample(100)
    Let assumptions be ["normality", "no_outliers", "finite_variance"]
    Let result be DescriptiveStats.validate_statistical_assumptions(normal_data, assumptions)
    
    Assert.IsTrue(result.contains_key("normality"))
    Assert.IsTrue(result.contains_key("no_outliers"))
    Assert.IsTrue(result.contains_key("finite_variance"))
    
    Return True

Process called "test_handle_missing_values_listwise" that takes no parameters returns Boolean:
    Note: Test listwise deletion of missing values
    Let data be [1.0, -999999.0, 3.0, 4.0, -999999.0, 6.0]
    Let result be DescriptiveStats.handle_missing_values(data, "listwise_deletion")
    Assert.AreEqual(result.size(), 4)
    Return True

Process called "test_handle_missing_values_mean_imputation" that takes no parameters returns Boolean:
    Note: Test mean imputation for missing values
    Let data be [1.0, -999999.0, 3.0, 5.0]
    Let result be DescriptiveStats.handle_missing_values(data, "mean_imputation")
    Assert.AreEqual(result.size(), 4)
    Assert.IsTrue(result[1] > 1.0)
    Assert.IsTrue(result[1] < 5.0)
    Return True

Process called "test_handle_missing_values_median_imputation" that takes no parameters returns Boolean:
    Note: Test median imputation for missing values
    Let data be [1.0, -999999.0, 3.0, 5.0]
    Let result be DescriptiveStats.handle_missing_values(data, "median_imputation")
    Assert.AreEqual(result.size(), 4)
    Return True

Process called "test_transform_data_log" that takes no parameters returns Boolean:
    Note: Test logarithmic data transformation
    Let data be [1.0, 2.0, 4.0, 8.0]
    Let result be DescriptiveStats.transform_data(data, "log")
    Assert.AreEqual(result.size(), 4)
    For each value in result:
        Assert.IsTrue(value > Float.NEGATIVE_INFINITY)
    Return True

Process called "test_transform_data_standardize" that takes no parameters returns Boolean:
    Note: Test z-score standardization
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let result be DescriptiveStats.transform_data(data, "standardize")
    Assert.AreEqual(result.size(), 5)
    
    Let empty_weights be List[Float]
    Let result_mean be DescriptiveStats.calculate_arithmetic_mean(result, empty_weights)
    Assert.IsTrue(is_approximately_equal(result_mean, 0.0, 1e-10))
    
    Return True

Process called "test_transform_data_normalize" that takes no parameters returns Boolean:
    Note: Test min-max normalization
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let result be DescriptiveStats.transform_data(data, "normalize")
    Assert.AreEqual(result.size(), 5)
    Assert.IsTrue(is_approximately_equal(result[0], 0.0, 1e-10))
    Assert.IsTrue(is_approximately_equal(result[4], 1.0, 1e-10))
    Return True

Process called "test_bootstrap_statistic_mean" that takes no parameters returns Boolean:
    Note: Test bootstrap sampling for mean statistic
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let result be DescriptiveStats.bootstrap_statistic(data, "mean", 10)
    Assert.AreEqual(result.size(), 10)
    For each bootstrap_mean in result:
        Assert.IsTrue(bootstrap_mean >= 1.0)
        Assert.IsTrue(bootstrap_mean <= 5.0)
    Return True

Process called "test_bootstrap_statistic_median" that takes no parameters returns Boolean:
    Note: Test bootstrap sampling for median statistic
    Let data be [1.0, 2.0, 3.0, 4.0, 5.0]
    Let result be DescriptiveStats.bootstrap_statistic(data, "median", 5)
    Assert.AreEqual(result.size(), 5)
    Return True

Note: =====================================================================
Note: ERROR HANDLING AND EDGE CASES TESTS
Note: =====================================================================

Process called "test_empty_dataset_errors" that takes no parameters returns Boolean:
    Note: Test various functions with empty datasets
    Let empty_data be List[Float]
    
    Try:
        Let mean_result be DescriptiveStats.calculate_arithmetic_mean(empty_data, [])
        Assert.Fail("Should have thrown error for empty dataset")
    Catch error:
        Assert.IsTrue(True)
    
    Try:
        Let median_result be DescriptiveStats.find_median(empty_data, "linear")
        Assert.Fail("Should have thrown error for empty dataset")
    Catch error:
        Assert.IsTrue(True)
    
    Try:
        Let variance_result be DescriptiveStats.calculate_variance(empty_data, false, true)
        Assert.Fail("Should have thrown error for empty dataset")
    Catch error:
        Assert.IsTrue(True)
    
    Return True

Process called "test_single_value_handling" that takes no parameters returns Boolean:
    Note: Test functions with single value datasets
    Let single_data be [42.0]
    
    Let empty_weights be List[Float]
    Let mean_result be DescriptiveStats.calculate_arithmetic_mean(single_data, empty_weights)
    Assert.IsTrue(is_approximately_equal(mean_result, 42.0, 1e-10))
    
    Let median_result be DescriptiveStats.find_median(single_data, "linear")
    Assert.IsTrue(is_approximately_equal(median_result, 42.0, 1e-10))
    
    Let hodges_lehmann_result be DescriptiveStats.calculate_hodges_lehmann_estimator(single_data)
    Assert.IsTrue(is_approximately_equal(hodges_lehmann_result, 42.0, 1e-10))
    
    Return True

Process called "test_extreme_values_handling" that takes no parameters returns Boolean:
    Note: Test functions with extreme values
    Let extreme_data be [1e-10, 1.0, 1e10]
    
    Let empty_weights be List[Float]
    Let mean_result be DescriptiveStats.calculate_arithmetic_mean(extreme_data, empty_weights)
    Assert.IsTrue(mean_result > 0.0)
    
    Let range_result be DescriptiveStats.calculate_range(extreme_data)
    Assert.IsTrue(range_result["range"] > 1e9)
    
    Return True

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all descriptive statistics module tests
    Let tests_passed be 0
    Let tests_failed be 0
    
    Note: Central tendency tests
    Let central_tendency_tests be [
        "test_arithmetic_mean_basic",
        "test_arithmetic_mean_weighted", 
        "test_arithmetic_mean_empty_error",
        "test_geometric_mean_basic",
        "test_geometric_mean_with_zero",
        "test_geometric_mean_negative_error",
        "test_harmonic_mean_basic",
        "test_harmonic_mean_with_zero_error",
        "test_harmonic_mean_exclude_zero",
        "test_median_odd_size",
        "test_median_even_size",
        "test_median_interpolation_methods",
        "test_mode_single",
        "test_mode_multimodal",
        "test_mode_with_tolerance"
    ]
    
    Note: Variability measures tests
    Let variability_tests be [
        "test_variance_population",
        "test_variance_sample",
        "test_variance_single_value_error",
        "test_standard_deviation_basic",
        "test_standard_deviation_zero_variance",
        "test_range_basic",
        "test_range_with_quartiles",
        "test_coefficient_of_variation",
        "test_coefficient_of_variation_zero_mean_error",
        "test_mean_absolute_deviation",
        "test_mean_absolute_deviation_invalid_center"
    ]
    
    Note: Quantile analysis tests
    Let quantile_tests be [
        "test_percentiles_basic",
        "test_percentiles_interpolation_methods",
        "test_percentiles_invalid_range",
        "test_quartiles_basic",
        "test_quartiles_outlier_boundaries",
        "test_quantile_function",
        "test_quantile_function_invalid_probability",
        "test_outlier_detection_iqr",
        "test_outlier_detection_no_outliers"
    ]
    
    Note: Distribution shape tests
    Let shape_tests be [
        "test_skewness_symmetric",
        "test_skewness_positively_skewed",
        "test_skewness_insufficient_data",
        "test_skewness_zero_variance",
        "test_kurtosis_normal",
        "test_kurtosis_insufficient_data",
        "test_kurtosis_excess_vs_raw",
        "test_normality_assessment",
        "test_moments_calculation"
    ]
    
    Note: Robust statistics tests
    Let robust_tests be [
        "test_trimmed_mean_basic",
        "test_trimmed_mean_no_trimming",
        "test_trimmed_mean_excessive_trimming",
        "test_winsorized_mean_basic",
        "test_winsorized_mean_invalid_limits",
        "test_robust_scale_mad",
        "test_robust_scale_iqr",
        "test_robust_scale_rousseeuw_croux",
        "test_hodges_lehmann_estimator",
        "test_hodges_lehmann_single_value"
    ]
    
    Note: Summary and comprehensive tests
    Let summary_tests be [
        "test_descriptive_summary_basic",
        "test_five_number_summary",
        "test_frequency_distribution_equal_width",
        "test_frequency_distribution_sturges",
        "test_statistical_profile"
    ]
    
    Note: Comparative statistics tests
    Let comparative_tests be [
        "test_compare_distributions",
        "test_effect_size_cohens_d",
        "test_effect_size_glass_delta",
        "test_distribution_overlap"
    ]
    
    Note: Utility and data handling tests
    Let utility_tests be [
        "test_validate_assumptions_normality",
        "test_handle_missing_values_listwise",
        "test_handle_missing_values_mean_imputation",
        "test_handle_missing_values_median_imputation",
        "test_transform_data_log",
        "test_transform_data_standardize",
        "test_transform_data_normalize",
        "test_bootstrap_statistic_mean",
        "test_bootstrap_statistic_median"
    ]
    
    Note: Error handling tests
    Let error_tests be [
        "test_empty_dataset_errors",
        "test_single_value_handling",
        "test_extreme_values_handling"
    ]
    
    Let all_test_groups be [central_tendency_tests, variability_tests, quantile_tests, shape_tests, 
                           robust_tests, summary_tests, comparative_tests, utility_tests, error_tests]
    
    Let group_names be ["Central Tendency Measures", "Variability Measures", "Quantile Analysis", 
                       "Distribution Shape Analysis", "Robust Statistics", "Summary Functions",
                       "Comparative Statistics", "Utility Functions", "Error Handling"]
    
    For group_index from 0 to Length(all_test_groups) - 1:
        Let test_group be all_test_groups[group_index]
        Let group_name be group_names[group_index]
        Print "Testing " + group_name + "..."
        
        For test_name in test_group:
            Try:
                Let test_result be Call test_name()
                If test_result:
                    Set tests_passed to tests_passed + 1
                    Print "  ✓ " + test_name
                Otherwise:
                    Set tests_failed to tests_failed + 1
                    Print "  ✗ " + test_name + " (returned false)"
            Catch error:
                Set tests_failed to tests_failed + 1
                Print "  ✗ " + test_name + " (error: " + error.message + ")"
    
    Let total_tests be tests_passed + tests_failed
    Print ""
    Print "Descriptive Statistics Module Test Results:"
    Print "=========================================="
    Print "Tests passed: " + ToString(tests_passed)
    Print "Tests failed: " + ToString(tests_failed)
    Print "Total tests: " + ToString(total_tests)
    Print "Success rate: " + ToString((tests_passed * 100) / total_tests) + "%"
    
    Return tests_failed = 0