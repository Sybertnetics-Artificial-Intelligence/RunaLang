Note: Comprehensive Unit Tests for Bessel Functions Module

This module provides comprehensive testing for Bessel function implementations,
including Bessel functions of the first and second kind, modified Bessel functions,
spherical Bessel functions, Airy functions, Hankel functions, zeros computation,
and asymptotic expansions with numerical analysis support.

Test Coverage:
- Bessel functions of the first kind J_ν(x)
- Bessel functions of the second kind Y_ν(x)
- Modified Bessel functions I_ν(x) and K_ν(x)
- Spherical Bessel functions j_n(x) and y_n(x)
- Airy functions Ai(x) and Bi(x)
- Hankel functions H_ν^(1)(x) and H_ν^(2)(x)
- Zeros computation and asymptotic estimates
- Recurrence relations and differential equations
- Orthogonality properties and integrals
- Performance benchmarking

Mathematical Foundations Tested:
- Series expansions and asymptotic behavior
- Recurrence relations and stability
- Wronskian determinants and linear independence
- Integral representations and transforms
- Connection formulas and analytic continuation
- Numerical stability in critical regions

:End Note

Import "math/special/bessel" as Bessel
Import "math/special/gamma" as Gamma
Import "math/core/operations" as MathOps
Import "math/core/constants" as Constants
Import "math/core/trigonometry" as Trig
Import "os/system/time" as SystemTime

Note: ===== Test Helper Functions =====

Process called "assert_equal" that takes actual as Float64, expected as Float64, tolerance as Float64 returns Boolean:
    Let difference be MathOps.absolute_value(actual - expected)
    Return difference <= tolerance

Process called "assert_relative_error" that takes actual as Float64, expected as Float64, relative_tolerance as Float64 returns Boolean:
    If MathOps.absolute_value(expected) < 1e-15:
        Return MathOps.absolute_value(actual) < 1e-15
    Let relative_error be MathOps.absolute_value((actual - expected) / expected)
    Return relative_error <= relative_tolerance

Process called "create_default_bessel_config" that takes returns Bessel.BesselConfig:
    Return Bessel.BesselConfig{
        precision: 15.0,
        max_iterations: 100,
        convergence_threshold: 1e-12,
        series_method: "power_series",
        asymptotic_threshold: 10.0,
        recurrence_direction: "forward",
        scaling_factor: 1.0
    }

Process called "create_high_precision_config" that takes returns Bessel.BesselConfig:
    Return Bessel.BesselConfig{
        precision: 25.0,
        max_iterations: 200,
        convergence_threshold: 1e-20,
        series_method: "asymptotic",
        asymptotic_threshold: 15.0,
        recurrence_direction: "backward",
        scaling_factor: 1.0
    }

Process called "bessel_j0_exact" that takes x as Float64 returns Float64:
    Note: Exact values for J_0(x) at specific points for testing
    If MathOps.absolute_value(x) < 1e-15:
        Return 1.0
    If MathOps.absolute_value(x - MathOps.pi()) < 1e-10:
        Return -0.304242235
    If MathOps.absolute_value(x - 2.0*MathOps.pi()) < 1e-10:
        Return 0.246926761
    Return 0.0

Note: ===== Bessel Functions First Kind Tests =====

Process called "test_bessel_j_basic_values" that takes returns Boolean:
    Note: Tests Bessel function J_ν(x) for basic values and special cases
    Let config be create_default_bessel_config()
    
    Let j0_0 be Bessel.compute_bessel_j(0.0, 0.0, config)
    If not assert_equal(j0_0.value, 1.0, 1e-12):
        Return false
    
    Let j1_0 be Bessel.compute_bessel_j(1.0, 0.0, config)
    If not assert_equal(j1_0.value, 0.0, 1e-12):
        Return false
    
    Let j2_0 be Bessel.compute_bessel_j(2.0, 0.0, config)
    If not assert_equal(j2_0.value, 0.0, 1e-12):
        Return false
    
    Let j0_1 be Bessel.compute_bessel_j(0.0, 1.0, config)
    If not assert_relative_error(j0_1.value, 0.7651976866, 1e-8):
        Return false
    
    Let j1_1 be Bessel.compute_bessel_j(1.0, 1.0, config)
    If not assert_relative_error(j1_1.value, 0.4400505857, 1e-8):
        Return false
    
    Return true

Process called "test_bessel_j_recurrence_relations" that takes returns Boolean:
    Note: Tests Bessel function recurrence relations J_{ν-1}(x) + J_{ν+1}(x) = (2ν/x)J_ν(x)
    Let config be create_default_bessel_config()
    
    Let test_points be [0.5, 1.0, 2.0, 5.0, 10.0]
    Let test_orders be [1.0, 2.0, 3.0, 4.0, 5.0]
    
    For x in test_points:
        For nu in test_orders:
            Let j_nu_minus_1 be Bessel.compute_bessel_j(nu - 1.0, x, config)
            Let j_nu be Bessel.compute_bessel_j(nu, x, config)
            Let j_nu_plus_1 be Bessel.compute_bessel_j(nu + 1.0, x, config)
            
            Let left_side be j_nu_minus_1.value + j_nu_plus_1.value
            Let right_side be (2.0 * nu / x) * j_nu.value
            
            If not assert_relative_error(left_side, right_side, 1e-10):
                Return false
    
    Return true

Process called "test_bessel_j_derivatives" that takes returns Boolean:
    Note: Tests Bessel function derivatives J'_ν(x) = [J_{ν-1}(x) - J_{ν+1}(x)]/2
    Let config be create_default_bessel_config()
    
    Let test_points be [1.0, 2.0, 3.0, 5.0]
    Let test_orders be [0.0, 1.0, 2.0, 3.0]
    
    For x in test_points:
        For nu in test_orders:
            Let derivative_analytical be Bessel.compute_bessel_j_derivative(nu, x, config)
            
            Let j_nu_minus_1 be Bessel.compute_bessel_j(nu - 1.0, x, config)
            Let j_nu_plus_1 be Bessel.compute_bessel_j(nu + 1.0, x, config)
            Let derivative_recurrence be (j_nu_minus_1.value - j_nu_plus_1.value) / 2.0
            
            If not assert_relative_error(derivative_analytical, derivative_recurrence, 1e-10):
                Return false
    
    Return true

Process called "test_bessel_j_zeros" that takes returns Boolean:
    Note: Tests computation of Bessel function zeros using asymptotic estimates
    Let config be create_default_bessel_config()
    
    Let j0_zeros be Bessel.compute_bessel_j_zeros(0.0, 5, config)
    
    If j0_zeros.zeros_list.size != 5:
        Return false
    
    Let expected_j0_zeros be [2.4048255577, 5.5200781103, 8.6537279129, 11.7915344391, 14.9309177084]
    
    For i from 0 to 4:
        If not assert_relative_error(j0_zeros.zeros_list[i], expected_j0_zeros[i], 1e-6):
            Return false
    
    For i from 0 to j0_zeros.zeros_list.size - 1:
        Let zero_value be j0_zeros.zeros_list[i]
        Let j_at_zero be Bessel.compute_bessel_j(0.0, zero_value, config)
        If not assert_equal(j_at_zero.value, 0.0, 1e-8):
            Return false
    
    Return true

Process called "test_bessel_j_asymptotic_behavior" that takes returns Boolean:
    Note: Tests asymptotic behavior J_ν(x) ~ √(2/πx) cos(x - νπ/2 - π/4) for large x
    Let config be create_default_bessel_config()
    config.asymptotic_threshold = 5.0
    
    Let large_x_values be [20.0, 50.0, 100.0]
    Let orders be [0.0, 1.0, 2.0]
    
    For x in large_x_values:
        For nu in orders:
            Let bessel_result be Bessel.compute_bessel_j(nu, x, config)
            
            Let asymptotic_amplitude be MathOps.square_root(2.0 / (MathOps.pi() * x))
            Let phase_shift be x - nu * MathOps.pi() / 2.0 - MathOps.pi() / 4.0
            Let asymptotic_value be asymptotic_amplitude * MathOps.cosine(phase_shift)
            
            If not assert_relative_error(bessel_result.value, asymptotic_value, 0.1):
                Return false
            
            If x >= 50.0 and bessel_result.method_used != "asymptotic_expansion":
                Return false
    
    Return true

Note: ===== Bessel Functions Second Kind Tests =====

Process called "test_bessel_y_basic_values" that takes returns Boolean:
    Note: Tests Bessel function Y_ν(x) for basic values
    Let config be create_default_bessel_config()
    
    Let y0_1 be Bessel.compute_bessel_y(0.0, 1.0, config)
    If not assert_relative_error(y0_1.value, 0.0882569643, 1e-8):
        Return false
    
    Let y1_1 be Bessel.compute_bessel_y(1.0, 1.0, config)
    If not assert_relative_error(y1_1.value, -0.7812128213, 1e-8):
        Return false
    
    Let y0_2 be Bessel.compute_bessel_y(0.0, 2.0, config)
    If not assert_relative_error(y0_2.value, 0.5103756726, 1e-8):
        Return false
    
    Return true

Process called "test_bessel_y_singularity_behavior" that takes returns Boolean:
    Note: Tests Y_ν(x) behavior near x = 0 (logarithmic singularity)
    Let config be create_default_bessel_config()
    
    Let small_x_values be [0.001, 0.01, 0.1]
    
    For x in small_x_values:
        Let y0_x be Bessel.compute_bessel_y(0.0, x, config)
        
        If not MathOps.is_finite(y0_x.value):
            Return false
        
        If y0_x.value >= 0.0:
            Return false
        
        Let expected_magnitude be MathOps.absolute_value(2.0 / MathOps.pi() * MathOps.natural_log(x / 2.0))
        If not assert_relative_error(MathOps.absolute_value(y0_x.value), expected_magnitude, 0.5):
            Return false
    
    Return true

Process called "test_bessel_wronskian" that takes returns Boolean:
    Note: Tests Wronskian determinant W{J_ν(x), Y_ν(x)} = 2/(πx)
    Let config be create_default_bessel_config()
    
    Let test_points be [0.5, 1.0, 2.0, 5.0, 10.0]
    Let test_orders be [0.0, 1.0, 2.0, 0.5]
    
    For x in test_points:
        For nu in test_orders:
            Let j_nu be Bessel.compute_bessel_j(nu, x, config)
            Let y_nu be Bessel.compute_bessel_y(nu, x, config)
            Let j_prime be Bessel.compute_bessel_j_derivative(nu, x, config)
            Let y_prime be Bessel.compute_bessel_y_derivative(nu, x, config)
            
            Let wronskian be j_nu.value * y_prime - y_nu.value * j_prime
            Let expected_wronskian be 2.0 / (MathOps.pi() * x)
            
            If not assert_relative_error(wronskian, expected_wronskian, 1e-8):
                Return false
    
    Return true

Note: ===== Modified Bessel Functions Tests =====

Process called "test_modified_bessel_i_basic" that takes returns Boolean:
    Note: Tests modified Bessel function I_ν(x) basic values and properties
    Let config be create_default_bessel_config()
    
    Let i0_0 be Bessel.compute_modified_bessel_i(0.0, 0.0, config)
    If not assert_equal(i0_0.value, 1.0, 1e-12):
        Return false
    
    Let i1_0 be Bessel.compute_modified_bessel_i(1.0, 0.0, config)
    If not assert_equal(i1_0.value, 0.0, 1e-12):
        Return false
    
    Let i0_1 be Bessel.compute_modified_bessel_i(0.0, 1.0, config)
    If not assert_relative_error(i0_1.value, 1.2660658777, 1e-8):
        Return false
    
    Let i1_1 be Bessel.compute_modified_bessel_i(1.0, 1.0, config)
    If not assert_relative_error(i1_1.value, 0.5651591040, 1e-8):
        Return false
    
    Return true

Process called "test_modified_bessel_k_basic" that takes returns Boolean:
    Note: Tests modified Bessel function K_ν(x) basic values and properties
    Let config be create_default_bessel_config()
    
    Let k0_1 be Bessel.compute_modified_bessel_k(0.0, 1.0, config)
    If not assert_relative_error(k0_1.value, 0.4210244382, 1e-8):
        Return false
    
    Let k1_1 be Bessel.compute_modified_bessel_k(1.0, 1.0, config)
    If not assert_relative_error(k1_1.value, 0.6019072302, 1e-8):
        Return false
    
    Let k0_2 be Bessel.compute_modified_bessel_k(0.0, 2.0, config)
    If not assert_relative_error(k0_2.value, 0.1138938727, 1e-8):
        Return false
    
    Return true

Process called "test_modified_bessel_recurrence" that takes returns Boolean:
    Note: Tests modified Bessel recurrence I_{ν-1}(x) - I_{ν+1}(x) = (2ν/x)I_ν(x)
    Let config be create_default_bessel_config()
    
    Let test_points be [0.5, 1.0, 2.0, 5.0]
    Let test_orders be [1.0, 2.0, 3.0]
    
    For x in test_points:
        For nu in test_orders:
            Let i_nu_minus_1 be Bessel.compute_modified_bessel_i(nu - 1.0, x, config)
            Let i_nu be Bessel.compute_modified_bessel_i(nu, x, config)
            Let i_nu_plus_1 be Bessel.compute_modified_bessel_i(nu + 1.0, x, config)
            
            Let left_side be i_nu_minus_1.value - i_nu_plus_1.value
            Let right_side be (2.0 * nu / x) * i_nu.value
            
            If not assert_relative_error(left_side, right_side, 1e-10):
                Return false
    
    Return true

Process called "test_modified_bessel_exponential_growth" that takes returns Boolean:
    Note: Tests exponential growth behavior of I_ν(x) for large x
    Let config be create_default_bessel_config()
    
    Let large_x_values be [10.0, 20.0, 50.0]
    
    For x in large_x_values:
        Let i0_x be Bessel.compute_modified_bessel_i(0.0, x, config)
        
        Let asymptotic_estimate be MathOps.exponential(x) / MathOps.square_root(2.0 * MathOps.pi() * x)
        
        If not assert_relative_error(i0_x.value, asymptotic_estimate, 0.2):
            Return false
    
    Return true

Note: ===== Spherical Bessel Functions Tests =====

Process called "test_spherical_bessel_basic" that takes returns Boolean:
    Note: Tests spherical Bessel functions j_n(x) and y_n(x)
    Let config be create_default_bessel_config()
    
    Let j0_0 be Bessel.compute_spherical_bessel_j(0, 0.0, config)
    If not assert_equal(j0_0.value, 1.0, 1e-12):
        Return false
    
    Let j1_0 be Bessel.compute_spherical_bessel_j(1, 0.0, config)
    If not assert_equal(j1_0.value, 0.0, 1e-12):
        Return false
    
    Let j0_pi be Bessel.compute_spherical_bessel_j(0, MathOps.pi(), config)
    If not assert_relative_error(j0_pi.value, 0.0, 1e-6):
        Return false
    
    Let j1_pi be Bessel.compute_spherical_bessel_j(1, MathOps.pi(), config)
    If not assert_relative_error(j1_pi.value, -0.3183098862, 1e-8):
        Return false
    
    Return true

Process called "test_spherical_bessel_orthogonality" that takes returns Boolean:
    Note: Tests orthogonality relations for spherical Bessel functions
    Let config be create_default_bessel_config()
    
    Let zeros_j0 be Bessel.compute_spherical_bessel_zeros(0, 3, config)
    Let zeros_j1 be Bessel.compute_spherical_bessel_zeros(1, 3, config)
    
    If zeros_j0.zeros_list.size != 3 or zeros_j1.zeros_list.size != 3:
        Return false
    
    For i from 0 to 2:
        Let zero_0 be zeros_j0.zeros_list[i]
        Let zero_1 be zeros_j1.zeros_list[i]
        
        If zero_0 <= 0.0 or zero_1 <= 0.0:
            Return false
        
        If i > 0 and zero_0 <= zeros_j0.zeros_list[i-1]:
            Return false
    
    Return true

Note: ===== Airy Functions Tests =====

Process called "test_airy_functions_basic" that takes returns Boolean:
    Note: Tests Airy functions Ai(x) and Bi(x) basic values
    Let config be create_default_bessel_config()
    
    Let ai_0 be Bessel.compute_airy_ai(0.0, config)
    Let expected_ai_0 be 0.3550280538
    If not assert_relative_error(ai_0.value, expected_ai_0, 1e-8):
        Return false
    
    Let bi_0 be Bessel.compute_airy_bi(0.0, config)
    Let expected_bi_0 be 0.6149266274
    If not assert_relative_error(bi_0.value, expected_bi_0, 1e-8):
        Return false
    
    Let ai_1 be Bessel.compute_airy_ai(1.0, config)
    Let expected_ai_1 be 0.1352924163
    If not assert_relative_error(ai_1.value, expected_ai_1, 1e-8):
        Return false
    
    Let bi_1 be Bessel.compute_airy_bi(1.0, config)
    Let expected_bi_1 be 1.2074235806
    If not assert_relative_error(bi_1.value, expected_bi_1, 1e-8):
        Return false
    
    Return true

Process called "test_airy_differential_equation" that takes returns Boolean:
    Note: Tests that Airy functions satisfy y'' - xy = 0
    Let config be create_default_bessel_config()
    
    Let test_points be [-2.0, -1.0, 0.0, 1.0, 2.0]
    Let h be 1e-6
    
    For x in test_points:
        Let ai_x be Bessel.compute_airy_ai(x, config)
        Let ai_x_plus_h be Bessel.compute_airy_ai(x + h, config)
        Let ai_x_minus_h be Bessel.compute_airy_ai(x - h, config)
        
        Let ai_second_derivative be (ai_x_plus_h.value - 2.0 * ai_x.value + ai_x_minus_h.value) / (h * h)
        Let expected_second_derivative be x * ai_x.value
        
        If MathOps.absolute_value(x) > 0.1:
            If not assert_relative_error(ai_second_derivative, expected_second_derivative, 1e-4):
                Return false
    
    Return true

Process called "test_airy_asymptotic_behavior" that takes returns Boolean:
    Note: Tests asymptotic behavior of Airy functions for large arguments
    Let config be create_default_bessel_config()
    
    Let large_positive_x be [5.0, 10.0, 20.0]
    Let large_negative_x be [-5.0, -10.0, -20.0]
    
    For x in large_positive_x:
        Let ai_x be Bessel.compute_airy_ai(x, config)
        Let asymptotic_ai be 0.5 / MathOps.square_root(MathOps.pi()) * MathOps.power(x, -0.25) * MathOps.exponential(-2.0/3.0 * MathOps.power(x, 1.5))
        
        If not assert_relative_error(ai_x.value, asymptotic_ai, 0.1):
            Return false
    
    For x in large_negative_x:
        Let ai_x be Bessel.compute_airy_ai(x, config)
        Let abs_x be MathOps.absolute_value(x)
        Let asymptotic_amplitude be 1.0 / MathOps.square_root(MathOps.pi()) * MathOps.power(abs_x, -0.25)
        
        If MathOps.absolute_value(ai_x.value) > 2.0 * asymptotic_amplitude:
            Return false
    
    Return true

Note: ===== Hankel Functions Tests =====

Process called "test_hankel_functions_basic" that takes returns Boolean:
    Note: Tests Hankel functions H_ν^(1)(x) and H_ν^(2)(x) = J_ν(x) ± iY_ν(x)
    Let config be create_default_bessel_config()
    
    Let test_points be [1.0, 2.0, 5.0]
    Let test_orders be [0.0, 1.0, 2.0]
    
    For x in test_points:
        For nu in test_orders:
            Let j_nu be Bessel.compute_bessel_j(nu, x, config)
            Let y_nu be Bessel.compute_bessel_y(nu, x, config)
            Let h1_nu be Bessel.compute_hankel_first(nu, x, config)
            Let h2_nu be Bessel.compute_hankel_second(nu, x, config)
            
            If not assert_relative_error(h1_nu.real_part, j_nu.value, 1e-10):
                Return false
            
            If not assert_relative_error(h1_nu.imaginary_part, y_nu.value, 1e-10):
                Return false
            
            If not assert_relative_error(h2_nu.real_part, j_nu.value, 1e-10):
                Return false
            
            If not assert_relative_error(h2_nu.imaginary_part, -y_nu.value, 1e-10):
                Return false
    
    Return true

Process called "test_hankel_asymptotic_phase" that takes returns Boolean:
    Note: Tests asymptotic phase behavior of Hankel functions for large x
    Let config be create_default_bessel_config()
    
    Let large_x_values be [20.0, 50.0, 100.0]
    Let orders be [0.0, 1.0]
    
    For x in large_x_values:
        For nu in orders:
            Let h1_nu be Bessel.compute_hankel_first(nu, x, config)
            
            Let magnitude be MathOps.square_root(h1_nu.real_part * h1_nu.real_part + h1_nu.imaginary_part * h1_nu.imaginary_part)
            Let expected_magnitude be MathOps.square_root(2.0 / (MathOps.pi() * x))
            
            If not assert_relative_error(magnitude, expected_magnitude, 0.1):
                Return false
    
    Return true

Note: ===== Numerical Accuracy and Performance Tests =====

Process called "test_bessel_convergence" that takes returns Boolean:
    Note: Tests convergence behavior of different Bessel function algorithms
    Let low_precision_config be create_default_bessel_config()
    low_precision_config.convergence_threshold = 1e-6
    low_precision_config.max_iterations = 50
    
    Let high_precision_config be create_high_precision_config()
    
    Let test_values be [0.5, 1.0, 2.0, 5.0, 10.0]
    
    For x in test_values:
        Let low_result be Bessel.compute_bessel_j(0.0, x, low_precision_config)
        Let high_result be Bessel.compute_bessel_j(0.0, x, high_precision_config)
        
        If low_result.convergence_status != "converged":
            Return false
        
        If high_result.convergence_status != "converged":
            Return false
        
        If not assert_relative_error(low_result.value, high_result.value, 1e-5):
            Return false
    
    Return true

Process called "test_bessel_method_consistency" that takes returns Boolean:
    Note: Tests consistency between series and asymptotic methods
    Let series_config be create_default_bessel_config()
    series_config.series_method = "power_series"
    series_config.asymptotic_threshold = 20.0
    
    Let asymptotic_config be create_default_bessel_config()
    asymptotic_config.series_method = "asymptotic"
    asymptotic_config.asymptotic_threshold = 5.0
    
    Let transition_x_values be [8.0, 10.0, 12.0, 15.0]
    
    For x in transition_x_values:
        Let series_result be Bessel.compute_bessel_j(0.0, x, series_config)
        Let asymptotic_result be Bessel.compute_bessel_j(0.0, x, asymptotic_config)
        
        If not assert_relative_error(series_result.value, asymptotic_result.value, 1e-6):
            Return false
    
    Return true

Process called "test_bessel_performance" that takes returns Boolean:
    Note: Tests performance of Bessel function computations
    Let config be create_default_bessel_config()
    Let test_values be [0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 20.0]
    Let test_orders be [0.0, 1.0, 2.0, 0.5, 1.5]
    
    Let start_time be SystemTime.current_timestamp_microseconds()
    
    For i from 0 to 99:
        For x in test_values:
            For nu in test_orders:
                Let result be Bessel.compute_bessel_j(nu, x, config)
                If MathOps.is_nan(result.value):
                    Return false
    
    Let end_time be SystemTime.current_timestamp_microseconds()
    Let total_time_ms be MathOps.integer_to_float(end_time - start_time) / 1000.0
    
    If total_time_ms > 3000.0:
        Return false
    
    Return true

Process called "test_bessel_zeros_performance" that takes returns Boolean:
    Note: Tests performance of Bessel zeros computation
    Let config be create_default_bessel_config()
    
    Let start_time be SystemTime.current_timestamp_microseconds()
    
    For nu in [0.0, 1.0, 2.0, 3.0]:
        Let zeros_result be Bessel.compute_bessel_j_zeros(nu, 10, config)
        If zeros_result.zeros_list.size != 10:
            Return false
    
    Let end_time be SystemTime.current_timestamp_microseconds()
    Let total_time_ms be MathOps.integer_to_float(end_time - start_time) / 1000.0
    
    If total_time_ms > 1000.0:
        Return false
    
    Return true

Note: ===== Main Test Runner =====

Process called "run_all_bessel_tests" that takes returns Tuple[Integer, Integer]:
    Note: Runs all Bessel function tests and returns [passed, total] counts
    
    Let test_results be MathOps.create_empty_list(20)
    Let test_names be [
        "Bessel J Basic Values",
        "Bessel J Recurrence Relations",
        "Bessel J Derivatives",
        "Bessel J Zeros",
        "Bessel J Asymptotic Behavior",
        "Bessel Y Basic Values", 
        "Bessel Y Singularity Behavior",
        "Bessel Wronskian",
        "Modified Bessel I Basic",
        "Modified Bessel K Basic",
        "Modified Bessel Recurrence",
        "Modified Bessel Exponential Growth",
        "Spherical Bessel Basic",
        "Spherical Bessel Orthogonality",
        "Airy Functions Basic",
        "Airy Differential Equation",
        "Airy Asymptotic Behavior",
        "Hankel Functions Basic",
        "Hankel Asymptotic Phase",
        "Bessel Convergence",
        "Bessel Method Consistency",
        "Bessel Performance",
        "Bessel Zeros Performance"
    ]
    
    test_results[0] = test_bessel_j_basic_values()
    test_results[1] = test_bessel_j_recurrence_relations()
    test_results[2] = test_bessel_j_derivatives()
    test_results[3] = test_bessel_j_zeros()
    test_results[4] = test_bessel_j_asymptotic_behavior()
    test_results[5] = test_bessel_y_basic_values()
    test_results[6] = test_bessel_y_singularity_behavior()
    test_results[7] = test_bessel_wronskian()
    test_results[8] = test_modified_bessel_i_basic()
    test_results[9] = test_modified_bessel_k_basic()
    test_results[10] = test_modified_bessel_recurrence()
    test_results[11] = test_modified_bessel_exponential_growth()
    test_results[12] = test_spherical_bessel_basic()
    test_results[13] = test_spherical_bessel_orthogonality()
    test_results[14] = test_airy_functions_basic()
    test_results[15] = test_airy_differential_equation()
    test_results[16] = test_airy_asymptotic_behavior()
    test_results[17] = test_hankel_functions_basic()
    test_results[18] = test_hankel_asymptotic_phase()
    test_results[19] = test_bessel_convergence()
    test_results[20] = test_bessel_method_consistency()
    test_results[21] = test_bessel_performance()
    test_results[22] = test_bessel_zeros_performance()
    
    Let passed_count be 0
    Let total_count be test_results.size
    
    For i from 0 to total_count - 1:
        If test_results[i]:
            passed_count = passed_count + 1
            Let test_status be "PASSED"
            MathOps.print_string(test_names[i] + ": " + test_status)
        Otherwise:
            Let test_status be "FAILED"
            MathOps.print_string(test_names[i] + ": " + test_status)
    
    MathOps.print_string("Bessel Functions Tests: " + MathOps.integer_to_string(passed_count) + " / " + MathOps.integer_to_string(total_count) + " passed")
    
    Return [passed_count, total_count]