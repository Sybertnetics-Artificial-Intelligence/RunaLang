Note: Comprehensive Unit Tests for Orthogonal Polynomials Module

This module provides comprehensive testing for orthogonal polynomial implementations,
including Legendre polynomials, Chebyshev polynomials, Hermite polynomials, Laguerre
polynomials, Jacobi polynomials, Gegenbauer polynomials, orthogonality relations,
generating functions, zeros computation, and quadrature rules with weight functions.

Test Coverage:
- Legendre polynomials P_n(x) and associated Legendre P_n^m(x)
- Chebyshev polynomials T_n(x) and U_n(x)
- Hermite polynomials H_n(x) (physicist's and probabilist's)
- Laguerre polynomials L_n(x) and associated L_n^α(x)
- Jacobi polynomials P_n^(α,β)(x)
- Gegenbauer (ultraspherical) polynomials C_n^λ(x)
- Orthogonality relations and weight functions
- Zeros computation and quadrature rules
- Recurrence relations and generating functions
- Performance benchmarking

Mathematical Foundations Tested:
- Three-term recurrence relations
- Rodrigues formulas and differential operators
- Orthogonality integrals and norms
- Gaussian quadrature and numerical integration
- Asymptotic behavior and uniform bounds
- Connection coefficients and expansions

:End Note

Import "math/special/orthogonal" as Orthogonal
Import "math/special/gamma" as Gamma
Import "math/discrete/combinatorics" as Combinatorics
Import "math/core/operations" as MathOps
Import "math/core/constants" as Constants
Import "math/core/trigonometry" as Trig
Import "os/system/time" as SystemTime

Note: ===== Test Helper Functions =====

Process called "assert_equal" that takes actual as Float64, expected as Float64, tolerance as Float64 returns Boolean:
    Let difference be MathOps.absolute_value(actual - expected)
    Return difference <= tolerance

Process called "assert_relative_error" that takes actual as Float64, expected as Float64, relative_tolerance as Float64 returns Boolean:
    If MathOps.absolute_value(expected) < 1e-15:
        Return MathOps.absolute_value(actual) < 1e-15
    Let relative_error be MathOps.absolute_value((actual - expected) / expected)
    Return relative_error <= relative_tolerance

Process called "create_default_orthogonal_config" that takes returns Orthogonal.OrthogonalConfig:
    Return Orthogonal.OrthogonalConfig{
        precision: 15.0,
        max_degree: 100,
        convergence_threshold: 1e-12,
        normalization_type: "standard",
        weight_function: "uniform",
        interval_type: "finite",
        quadrature_points: 50
    }

Process called "create_high_precision_config" that takes returns Orthogonal.OrthogonalConfig:
    Return Orthogonal.OrthogonalConfig{
        precision: 25.0,
        max_degree: 200,
        convergence_threshold: 1e-20,
        normalization_type: "orthonormal",
        weight_function: "gaussian",
        interval_type: "infinite",
        quadrature_points: 100
    }

Process called "integrate_product" that takes f1 as List[Float64], f2 as List[Float64], x_points as List[Float64], weights as List[Float64] returns Float64:
    Note: Numerical integration using provided quadrature points and weights
    If f1.size != f2.size or f1.size != x_points.size or x_points.size != weights.size:
        Return 0.0
    
    Let integral be 0.0
    For i from 0 to f1.size - 1:
        integral = integral + f1[i] * f2[i] * weights[i]
    
    Return integral

Note: ===== Legendre Polynomials Tests =====

Process called "test_legendre_basic_values" that takes returns Boolean:
    Note: Tests basic Legendre polynomial values and properties
    Let config be create_default_orthogonal_config()
    
    Let p0_x be Orthogonal.compute_legendre_polynomial(0, 0.5, config)
    If not assert_equal(p0_x.value, 1.0, 1e-12):
        Return false
    
    Let p1_x be Orthogonal.compute_legendre_polynomial(1, 0.5, config)
    If not assert_equal(p1_x.value, 0.5, 1e-12):
        Return false
    
    Let p2_x be Orthogonal.compute_legendre_polynomial(2, 0.5, config)
    If not assert_equal(p2_x.value, -0.125, 1e-12):
        Return false
    
    Let p1_1 be Orthogonal.compute_legendre_polynomial(1, 1.0, config)
    If not assert_equal(p1_1.value, 1.0, 1e-12):
        Return false
    
    Let p1_minus1 be Orthogonal.compute_legendre_polynomial(1, -1.0, config)
    If not assert_equal(p1_minus1.value, -1.0, 1e-12):
        Return false
    
    Return true

Process called "test_legendre_recurrence_relation" that takes returns Boolean:
    Note: Tests Legendre polynomial recurrence (n+1)P_{n+1}(x) = (2n+1)xP_n(x) - nP_{n-1}(x)
    Let config be create_default_orthogonal_config()
    
    Let test_x_values be [-0.8, -0.3, 0.0, 0.3, 0.8]
    Let test_degrees be [2, 3, 4, 5, 10]
    
    For x in test_x_values:
        For n in test_degrees:
            Let p_n_minus_1 be Orthogonal.compute_legendre_polynomial(n - 1, x, config)
            Let p_n be Orthogonal.compute_legendre_polynomial(n, x, config)
            Let p_n_plus_1 be Orthogonal.compute_legendre_polynomial(n + 1, x, config)
            
            Let left_side be MathOps.integer_to_float(n + 1) * p_n_plus_1.value
            Let right_side be MathOps.integer_to_float(2*n + 1) * x * p_n.value - MathOps.integer_to_float(n) * p_n_minus_1.value
            
            If not assert_relative_error(left_side, right_side, 1e-12):
                Return false
    
    Return true

Process called "test_legendre_orthogonality" that takes returns Boolean:
    Note: Tests Legendre polynomial orthogonality relations
    Let config be create_default_orthogonal_config()
    
    Let quadrature_rule be Orthogonal.compute_gauss_legendre_quadrature(20, config)
    Let x_points be quadrature_rule.nodes
    Let weights be quadrature_rule.weights
    
    Let degrees be [0, 1, 2, 3, 4]
    
    For i from 0 to degrees.size - 1:
        For j from 0 to degrees.size - 1:
            Let n_i be degrees[i]
            Let n_j be degrees[j]
            
            Let p_i_values be MathOps.create_empty_list(x_points.size)
            Let p_j_values be MathOps.create_empty_list(x_points.size)
            
            For k from 0 to x_points.size - 1:
                Let p_i_result be Orthogonal.compute_legendre_polynomial(n_i, x_points[k], config)
                Let p_j_result be Orthogonal.compute_legendre_polynomial(n_j, x_points[k], config)
                p_i_values[k] = p_i_result.value
                p_j_values[k] = p_j_result.value
            
            Let orthogonality_integral be integrate_product(p_i_values, p_j_values, x_points, weights)
            
            If i == j:
                Let expected_norm be 2.0 / (2.0 * MathOps.integer_to_float(n_i) + 1.0)
                If not assert_relative_error(orthogonality_integral, expected_norm, 1e-10):
                    Return false
            Otherwise:
                If not assert_equal(orthogonality_integral, 0.0, 1e-10):
                    Return false
    
    Return true

Process called "test_associated_legendre_polynomials" that takes returns Boolean:
    Note: Tests associated Legendre polynomials P_n^m(x)
    Let config be create_default_orthogonal_config()
    
    Let p_1_0 be Orthogonal.compute_associated_legendre(1, 0, 0.5, config)
    Let regular_p_1 be Orthogonal.compute_legendre_polynomial(1, 0.5, config)
    If not assert_equal(p_1_0, regular_p_1.value, 1e-12):
        Return false
    
    Let p_1_1 be Orthogonal.compute_associated_legendre(1, 1, 0.5, config)
    If not assert_relative_error(p_1_1, -MathOps.square_root(3.0/4.0), 1e-10):
        Return false
    
    Let p_2_1 be Orthogonal.compute_associated_legendre(2, 1, 0.5, config)
    If not assert_relative_error(p_2_1, -1.5 * MathOps.square_root(3.0/4.0), 1e-10):
        Return false
    
    Return true

Process called "test_legendre_generating_function" that takes returns Boolean:
    Note: Tests Legendre generating function (1-2tx+t²)^(-1/2) = Σ P_n(x) t^n
    Let config be create_default_orthogonal_config()
    
    Let x be 0.3
    Let t be 0.4
    Let max_degree be 10
    
    Let generating_function_value be 1.0 / MathOps.square_root(1.0 - 2.0*t*x + t*t)
    
    Let series_sum be 0.0
    Let t_power be 1.0
    
    For n from 0 to max_degree:
        Let p_n be Orthogonal.compute_legendre_polynomial(n, x, config)
        series_sum = series_sum + p_n.value * t_power
        t_power = t_power * t
    
    If not assert_relative_error(series_sum, generating_function_value, 1e-6):
        Return false
    
    Return true

Note: ===== Chebyshev Polynomials Tests =====

Process called "test_chebyshev_first_kind" that takes returns Boolean:
    Note: Tests Chebyshev polynomials of the first kind T_n(x)
    Let config be create_default_orthogonal_config()
    
    Let t0_x be Orthogonal.compute_chebyshev_first_kind(0, 0.5, config)
    If not assert_equal(t0_x.value, 1.0, 1e-12):
        Return false
    
    Let t1_x be Orthogonal.compute_chebyshev_first_kind(1, 0.5, config)
    If not assert_equal(t1_x.value, 0.5, 1e-12):
        Return false
    
    Let t2_x be Orthogonal.compute_chebyshev_first_kind(2, 0.5, config)
    If not assert_equal(t2_x.value, -0.5, 1e-12):
        Return false
    
    Let t_n_cos_identity be Orthogonal.compute_chebyshev_first_kind(5, MathOps.cosine(0.3), config)
    Let expected_cos_5theta be MathOps.cosine(5.0 * 0.3)
    If not assert_relative_error(t_n_cos_identity.value, expected_cos_5theta, 1e-10):
        Return false
    
    Return true

Process called "test_chebyshev_second_kind" that takes returns Boolean:
    Note: Tests Chebyshev polynomials of the second kind U_n(x)
    Let config be create_default_orthogonal_config()
    
    Let u0_x be Orthogonal.compute_chebyshev_second_kind(0, 0.5, config)
    If not assert_equal(u0_x.value, 1.0, 1e-12):
        Return false
    
    Let u1_x be Orthogonal.compute_chebyshev_second_kind(1, 0.5, config)
    If not assert_equal(u1_x.value, 1.0, 1e-12):
        Return false
    
    Let u2_x be Orthogonal.compute_chebyshev_second_kind(2, 0.5, config)
    If not assert_equal(u2_x.value, 0.0, 1e-12):
        Return false
    
    Return true

Process called "test_chebyshev_recurrence" that takes returns Boolean:
    Note: Tests Chebyshev recurrence T_{n+1}(x) = 2xT_n(x) - T_{n-1}(x)
    Let config be create_default_orthogonal_config()
    
    Let test_x_values be [-0.9, -0.5, 0.0, 0.5, 0.9]
    Let test_degrees be [2, 3, 4, 5, 8]
    
    For x in test_x_values:
        For n in test_degrees:
            Let t_n_minus_1 be Orthogonal.compute_chebyshev_first_kind(n - 1, x, config)
            Let t_n be Orthogonal.compute_chebyshev_first_kind(n, x, config)
            Let t_n_plus_1 be Orthogonal.compute_chebyshev_first_kind(n + 1, x, config)
            
            Let left_side be t_n_plus_1.value
            Let right_side be 2.0 * x * t_n.value - t_n_minus_1.value
            
            If not assert_relative_error(left_side, right_side, 1e-12):
                Return false
    
    Return true

Process called "test_chebyshev_orthogonality" that takes returns Boolean:
    Note: Tests Chebyshev polynomial orthogonality with weight (1-x²)^(-1/2)
    Let config be create_default_orthogonal_config()
    
    Let quadrature_rule be Orthogonal.compute_gauss_chebyshev_quadrature(15, config)
    Let x_points be quadrature_rule.nodes
    Let weights be quadrature_rule.weights
    
    Let degrees be [0, 1, 2, 3, 4]
    
    For i from 0 to degrees.size - 1:
        For j from 0 to degrees.size - 1:
            Let n_i be degrees[i]
            Let n_j be degrees[j]
            
            Let t_i_values be MathOps.create_empty_list(x_points.size)
            Let t_j_values be MathOps.create_empty_list(x_points.size)
            
            For k from 0 to x_points.size - 1:
                Let t_i_result be Orthogonal.compute_chebyshev_first_kind(n_i, x_points[k], config)
                Let t_j_result be Orthogonal.compute_chebyshev_first_kind(n_j, x_points[k], config)
                t_i_values[k] = t_i_result.value
                t_j_values[k] = t_j_result.value
            
            Let orthogonality_integral be integrate_product(t_i_values, t_j_values, x_points, weights)
            
            If i == j:
                Let expected_norm be MathOps.pi() / 2.0
                If n_i == 0:
                    expected_norm = MathOps.pi()
                If not assert_relative_error(orthogonality_integral, expected_norm, 1e-8):
                    Return false
            Otherwise:
                If not assert_equal(orthogonality_integral, 0.0, 1e-10):
                    Return false
    
    Return true

Note: ===== Hermite Polynomials Tests =====

Process called "test_hermite_physicist_basic" that takes returns Boolean:
    Note: Tests physicist's Hermite polynomials H_n(x)
    Let config be create_default_orthogonal_config()
    
    Let h0_x be Orthogonal.compute_hermite_physicist(0, 1.0, config)
    If not assert_equal(h0_x.value, 1.0, 1e-12):
        Return false
    
    Let h1_x be Orthogonal.compute_hermite_physicist(1, 1.0, config)
    If not assert_equal(h1_x.value, 2.0, 1e-12):
        Return false
    
    Let h2_x be Orthogonal.compute_hermite_physicist(2, 1.0, config)
    If not assert_equal(h2_x.value, 2.0, 1e-12):
        Return false
    
    Let h3_x be Orthogonal.compute_hermite_physicist(3, 1.0, config)
    If not assert_equal(h3_x.value, -4.0, 1e-12):
        Return false
    
    Return true

Process called "test_hermite_probabilist_basic" that takes returns Boolean:
    Note: Tests probabilist's Hermite polynomials He_n(x)
    Let config be create_default_orthogonal_config()
    
    Let he0_x be Orthogonal.compute_hermite_probabilist(0, 1.0, config)
    If not assert_equal(he0_x.value, 1.0, 1e-12):
        Return false
    
    Let he1_x be Orthogonal.compute_hermite_probabilist(1, 1.0, config)
    If not assert_equal(he1_x.value, 1.0, 1e-12):
        Return false
    
    Let he2_x be Orthogonal.compute_hermite_probabilist(2, 1.0, config)
    If not assert_equal(he2_x.value, 0.0, 1e-12):
        Return false
    
    Let he3_x be Orthogonal.compute_hermite_probabilist(3, 1.0, config)
    If not assert_equal(he3_x.value, -2.0, 1e-12):
        Return false
    
    Return true

Process called "test_hermite_recurrence" that takes returns Boolean:
    Note: Tests Hermite recurrence H_{n+1}(x) = 2xH_n(x) - 2nH_{n-1}(x)
    Let config be create_default_orthogonal_config()
    
    Let test_x_values be [-2.0, -1.0, 0.0, 1.0, 2.0]
    Let test_degrees be [2, 3, 4, 5, 8]
    
    For x in test_x_values:
        For n in test_degrees:
            Let h_n_minus_1 be Orthogonal.compute_hermite_physicist(n - 1, x, config)
            Let h_n be Orthogonal.compute_hermite_physicist(n, x, config)
            Let h_n_plus_1 be Orthogonal.compute_hermite_physicist(n + 1, x, config)
            
            Let left_side be h_n_plus_1.value
            Let right_side be 2.0 * x * h_n.value - 2.0 * MathOps.integer_to_float(n) * h_n_minus_1.value
            
            If not assert_relative_error(left_side, right_side, 1e-12):
                Return false
    
    Return true

Process called "test_hermite_orthogonality" that takes returns Boolean:
    Note: Tests Hermite polynomial orthogonality with weight e^(-x²)
    Let config be create_default_orthogonal_config()
    
    Let quadrature_rule be Orthogonal.compute_gauss_hermite_quadrature(12, config)
    Let x_points be quadrature_rule.nodes
    Let weights be quadrature_rule.weights
    
    Let degrees be [0, 1, 2, 3]
    
    For i from 0 to degrees.size - 1:
        For j from 0 to degrees.size - 1:
            Let n_i be degrees[i]
            Let n_j be degrees[j]
            
            Let h_i_values be MathOps.create_empty_list(x_points.size)
            Let h_j_values be MathOps.create_empty_list(x_points.size)
            
            For k from 0 to x_points.size - 1:
                Let h_i_result be Orthogonal.compute_hermite_physicist(n_i, x_points[k], config)
                Let h_j_result be Orthogonal.compute_hermite_physicist(n_j, x_points[k], config)
                h_i_values[k] = h_i_result.value
                h_j_values[k] = h_j_result.value
            
            Let orthogonality_integral be integrate_product(h_i_values, h_j_values, x_points, weights)
            
            If i == j:
                Let expected_norm be MathOps.square_root(MathOps.pi()) * MathOps.power(2.0, MathOps.integer_to_float(n_i)) * factorial_integer(n_i)
                If not assert_relative_error(orthogonality_integral, expected_norm, 1e-6):
                    Return false
            Otherwise:
                If not assert_equal(orthogonality_integral, 0.0, 1e-10):
                    Return false
    
    Return true

Note: ===== Laguerre Polynomials Tests =====

Process called "test_laguerre_basic" that takes returns Boolean:
    Note: Tests basic Laguerre polynomials L_n(x)
    Let config be create_default_orthogonal_config()
    
    Let l0_x be Orthogonal.compute_laguerre_polynomial(0, 1.0, config)
    If not assert_equal(l0_x.value, 1.0, 1e-12):
        Return false
    
    Let l1_x be Orthogonal.compute_laguerre_polynomial(1, 1.0, config)
    If not assert_equal(l1_x.value, 0.0, 1e-12):
        Return false
    
    Let l2_x be Orthogonal.compute_laguerre_polynomial(2, 1.0, config)
    If not assert_equal(l2_x.value, -0.5, 1e-12):
        Return false
    
    Let l1_2 be Orthogonal.compute_laguerre_polynomial(1, 2.0, config)
    If not assert_equal(l1_2.value, -1.0, 1e-12):
        Return false
    
    Return true

Process called "test_associated_laguerre" that takes returns Boolean:
    Note: Tests associated Laguerre polynomials L_n^α(x)
    Let config be create_default_orthogonal_config()
    
    Let l_1_0 be Orthogonal.compute_associated_laguerre(1, 0.0, 1.0, config)
    Let regular_l_1 be Orthogonal.compute_laguerre_polynomial(1, 1.0, config)
    If not assert_equal(l_1_0.value, regular_l_1.value, 1e-12):
        Return false
    
    Let l_1_1 be Orthogonal.compute_associated_laguerre(1, 1.0, 1.0, config)
    If not assert_equal(l_1_1.value, 1.0, 1e-12):
        Return false
    
    Let l_2_1 be Orthogonal.compute_associated_laguerre(2, 1.0, 1.0, config)
    If not assert_equal(l_2_1.value, 0.5, 1e-12):
        Return false
    
    Return true

Process called "test_laguerre_recurrence" that takes returns Boolean:
    Note: Tests Laguerre recurrence (n+1)L_{n+1}(x) = (2n+1-x)L_n(x) - nL_{n-1}(x)
    Let config be create_default_orthogonal_config()
    
    Let test_x_values be [0.1, 0.5, 1.0, 2.0, 5.0]
    Let test_degrees be [2, 3, 4, 5, 8]
    
    For x in test_x_values:
        For n in test_degrees:
            Let l_n_minus_1 be Orthogonal.compute_laguerre_polynomial(n - 1, x, config)
            Let l_n be Orthogonal.compute_laguerre_polynomial(n, x, config)
            Let l_n_plus_1 be Orthogonal.compute_laguerre_polynomial(n + 1, x, config)
            
            Let left_side be MathOps.integer_to_float(n + 1) * l_n_plus_1.value
            Let right_side be (2.0 * MathOps.integer_to_float(n) + 1.0 - x) * l_n.value - MathOps.integer_to_float(n) * l_n_minus_1.value
            
            If not assert_relative_error(left_side, right_side, 1e-12):
                Return false
    
    Return true

Process called "test_laguerre_orthogonality" that takes returns Boolean:
    Note: Tests Laguerre polynomial orthogonality with weight e^(-x)
    Let config be create_default_orthogonal_config()
    
    Let quadrature_rule be Orthogonal.compute_gauss_laguerre_quadrature(10, config)
    Let x_points be quadrature_rule.nodes
    Let weights be quadrature_rule.weights
    
    Let degrees be [0, 1, 2, 3]
    
    For i from 0 to degrees.size - 1:
        For j from 0 to degrees.size - 1:
            Let n_i be degrees[i]
            Let n_j be degrees[j]
            
            Let l_i_values be MathOps.create_empty_list(x_points.size)
            Let l_j_values be MathOps.create_empty_list(x_points.size)
            
            For k from 0 to x_points.size - 1:
                Let l_i_result be Orthogonal.compute_laguerre_polynomial(n_i, x_points[k], config)
                Let l_j_result be Orthogonal.compute_laguerre_polynomial(n_j, x_points[k], config)
                l_i_values[k] = l_i_result.value
                l_j_values[k] = l_j_result.value
            
            Let orthogonality_integral be integrate_product(l_i_values, l_j_values, x_points, weights)
            
            If i == j:
                If not assert_relative_error(orthogonality_integral, 1.0, 1e-8):
                    Return false
            Otherwise:
                If not assert_equal(orthogonality_integral, 0.0, 1e-10):
                    Return false
    
    Return true

Note: ===== Jacobi Polynomials Tests =====

Process called "test_jacobi_polynomials_basic" that takes returns Boolean:
    Note: Tests basic Jacobi polynomials P_n^(α,β)(x)
    Let config be create_default_orthogonal_config()
    
    Let p0_00 be Orthogonal.compute_jacobi_polynomial(0, 0.0, 0.0, 0.5, config)
    If not assert_equal(p0_00.value, 1.0, 1e-12):
        Return false
    
    Let p1_00 be Orthogonal.compute_jacobi_polynomial(1, 0.0, 0.0, 0.5, config)
    If not assert_equal(p1_00.value, 0.5, 1e-12):
        Return false
    
    Let p0_00_legendre be Orthogonal.compute_jacobi_polynomial(2, 0.0, 0.0, 0.5, config)
    Let legendre_p2 be Orthogonal.compute_legendre_polynomial(2, 0.5, config)
    If not assert_relative_error(p0_00_legendre.value, legendre_p2.value, 1e-10):
        Return false
    
    Return true

Process called "test_jacobi_special_cases" that takes returns Boolean:
    Note: Tests Jacobi polynomials for special parameter values
    Let config be create_default_orthogonal_config()
    
    Let jacobi_half_minus_half be Orthogonal.compute_jacobi_polynomial(3, -0.5, -0.5, MathOps.cosine(0.3), config)
    Let chebyshev_t3 be Orthogonal.compute_chebyshev_first_kind(3, MathOps.cosine(0.3), config)
    If not assert_relative_error(jacobi_half_minus_half.value, chebyshev_t3.value, 1e-8):
        Return false
    
    Let jacobi_half_half be Orthogonal.compute_jacobi_polynomial(2, 0.5, 0.5, MathOps.cosine(0.4), config)
    Let chebyshev_u2 be Orthogonal.compute_chebyshev_second_kind(2, MathOps.cosine(0.4), config)
    If not assert_relative_error(jacobi_half_half.value, chebyshev_u2.value / MathOps.sine(0.4), 1e-6):
        Return false
    
    Return true

Process called "test_jacobi_recurrence" that takes returns Boolean:
    Note: Tests Jacobi polynomial recurrence relation
    Let config be create_default_orthogonal_config()
    
    Let alpha be 0.5
    Let beta be 1.5
    Let x be 0.3
    Let n be 3
    
    Let p_n_minus_1 be Orthogonal.compute_jacobi_polynomial(n - 1, alpha, beta, x, config)
    Let p_n be Orthogonal.compute_jacobi_polynomial(n, alpha, beta, x, config)
    Let p_n_plus_1 be Orthogonal.compute_jacobi_polynomial(n + 1, alpha, beta, x, config)
    
    Let a_n be 2.0 * MathOps.integer_to_float(n + 1) * MathOps.integer_to_float(n + alpha + beta + 1) / 
              (MathOps.integer_to_float(2*n + alpha + beta + 1) * MathOps.integer_to_float(2*n + alpha + beta + 2))
    Let b_n be (beta*beta - alpha*alpha) / 
              (MathOps.integer_to_float(2*n + alpha + beta) * MathOps.integer_to_float(2*n + alpha + beta + 2))
    Let c_n be 2.0 * MathOps.integer_to_float(n + alpha) * MathOps.integer_to_float(n + beta) / 
              (MathOps.integer_to_float(2*n + alpha + beta + 1) * MathOps.integer_to_float(2*n + alpha + beta + 2))
    
    Let left_side be p_n_plus_1.value
    Let right_side be ((x + b_n) * p_n.value - c_n * p_n_minus_1.value) / a_n
    
    If not assert_relative_error(left_side, right_side, 1e-8):
        Return false
    
    Return true

Note: ===== Gegenbauer (Ultraspherical) Polynomials Tests =====

Process called "test_gegenbauer_polynomials" that takes returns Boolean:
    Note: Tests Gegenbauer (ultraspherical) polynomials C_n^λ(x)
    Let config be create_default_orthogonal_config()
    
    Let c0_lambda be Orthogonal.compute_gegenbauer_polynomial(0, 1.5, 0.5, config)
    If not assert_equal(c0_lambda.value, 1.0, 1e-12):
        Return false
    
    Let c1_lambda be Orthogonal.compute_gegenbauer_polynomial(1, 1.5, 0.5, config)
    If not assert_equal(c1_lambda.value, 1.5, 1e-12):
        Return false
    
    Let c2_lambda be Orthogonal.compute_gegenbauer_polynomial(2, 1.5, 0.5, config)
    If not assert_equal(c2_lambda.value, -0.375, 1e-12):
        Return false
    
    Let gegenbauer_half be Orthogonal.compute_gegenbauer_polynomial(3, 0.5, 0.7, config)
    Let legendre_p3 be Orthogonal.compute_legendre_polynomial(3, 0.7, config)
    If not assert_relative_error(gegenbauer_half.value, legendre_p3.value, 1e-10):
        Return false
    
    Return true

Process called "test_gegenbauer_recurrence" that takes returns Boolean:
    Note: Tests Gegenbauer recurrence relation
    Let config be create_default_orthogonal_config()
    
    Let lambda be 2.0
    Let x be 0.4
    Let n be 4
    
    Let c_n_minus_1 be Orthogonal.compute_gegenbauer_polynomial(n - 1, lambda, x, config)
    Let c_n be Orthogonal.compute_gegenbauer_polynomial(n, lambda, x, config)
    Let c_n_plus_1 be Orthogonal.compute_gegenbauer_polynomial(n + 1, lambda, x, config)
    
    Let left_side be MathOps.integer_to_float(n + 1) * c_n_plus_1.value
    Let right_side be 2.0 * x * (MathOps.integer_to_float(n) + lambda) * c_n.value - 
                      (MathOps.integer_to_float(n) + 2.0 * lambda - 1.0) * c_n_minus_1.value
    
    If not assert_relative_error(left_side, right_side, 1e-10):
        Return false
    
    Return true

Note: ===== Quadrature Rules Tests =====

Process called "test_gauss_legendre_quadrature" that takes returns Boolean:
    Note: Tests Gauss-Legendre quadrature exactness
    Let config be create_default_orthogonal_config()
    
    Let quadrature_rule be Orthogonal.compute_gauss_legendre_quadrature(5, config)
    
    If quadrature_rule.nodes.size != 5 or quadrature_rule.weights.size != 5:
        Return false
    
    If quadrature_rule.degree_exactness != 9:
        Return false
    
    Let polynomial_degrees be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    For degree in polynomial_degrees:
        Let quadrature_result be 0.0
        For i from 0 to quadrature_rule.nodes.size - 1:
            Let x be quadrature_rule.nodes[i]
            Let weight be quadrature_rule.weights[i]
            quadrature_result = quadrature_result + weight * MathOps.power(x, MathOps.integer_to_float(degree))
        
        Let exact_integral be 0.0
        If degree % 2 == 0:
            exact_integral = 2.0 / (MathOps.integer_to_float(degree) + 1.0)
        
        If not assert_equal(quadrature_result, exact_integral, 1e-12):
            Return false
    
    Return true

Process called "test_gauss_hermite_quadrature" that takes returns Boolean:
    Note: Tests Gauss-Hermite quadrature for integrals with weight e^(-x²)
    Let config be create_default_orthogonal_config()
    
    Let quadrature_rule be Orthogonal.compute_gauss_hermite_quadrature(6, config)
    
    If quadrature_rule.nodes.size != 6 or quadrature_rule.weights.size != 6:
        Return false
    
    Let integral_e_neg_x_squared be 0.0
    For i from 0 to quadrature_rule.nodes.size - 1:
        integral_e_neg_x_squared = integral_e_neg_x_squared + quadrature_rule.weights[i]
    
    If not assert_relative_error(integral_e_neg_x_squared, MathOps.square_root(MathOps.pi()), 1e-12):
        Return false
    
    Let integral_x2_e_neg_x_squared be 0.0
    For i from 0 to quadrature_rule.nodes.size - 1:
        Let x be quadrature_rule.nodes[i]
        Let weight be quadrature_rule.weights[i]
        integral_x2_e_neg_x_squared = integral_x2_e_neg_x_squared + weight * x * x
    
    If not assert_relative_error(integral_x2_e_neg_x_squared, MathOps.square_root(MathOps.pi()) / 2.0, 1e-10):
        Return false
    
    Return true

Note: ===== Zeros and Root Finding Tests =====

Process called "test_polynomial_zeros" that takes returns Boolean:
    Note: Tests computation of orthogonal polynomial zeros
    Let config be create_default_orthogonal_config()
    
    Let legendre_zeros be Orthogonal.compute_legendre_zeros(5, config)
    If legendre_zeros.size != 5:
        Return false
    
    For zero in legendre_zeros:
        If MathOps.absolute_value(zero) >= 1.0:
            Return false
        
        Let p5_at_zero be Orthogonal.compute_legendre_polynomial(5, zero, config)
        If not assert_equal(p5_at_zero.value, 0.0, 1e-10):
            Return false
    
    Let hermite_zeros be Orthogonal.compute_hermite_zeros(4, config)
    If hermite_zeros.size != 4:
        Return false
    
    For zero in hermite_zeros:
        Let h4_at_zero be Orthogonal.compute_hermite_physicist(4, zero, config)
        If not assert_equal(h4_at_zero.value, 0.0, 1e-8):
            Return false
    
    Return true

Note: ===== Performance Tests =====

Process called "test_orthogonal_performance" that takes returns Boolean:
    Note: Tests performance of orthogonal polynomial computations
    Let config be create_default_orthogonal_config()
    
    Let degrees be [5, 10, 20, 30, 50]
    Let x_values be [-0.8, -0.3, 0.0, 0.3, 0.8]
    
    Let start_time be SystemTime.current_timestamp_microseconds()
    
    For i from 0 to 99:
        For degree in degrees:
            For x in x_values:
                Let legendre_result be Orthogonal.compute_legendre_polynomial(degree, x, config)
                Let chebyshev_result be Orthogonal.compute_chebyshev_first_kind(degree, x, config)
                Let hermite_result be Orthogonal.compute_hermite_physicist(degree, x, config)
                
                If MathOps.is_nan(legendre_result.value) or MathOps.is_nan(chebyshev_result.value) or MathOps.is_nan(hermite_result.value):
                    Return false
    
    Let end_time be SystemTime.current_timestamp_microseconds()
    Let total_time_ms be MathOps.integer_to_float(end_time - start_time) / 1000.0
    
    If total_time_ms > 5000.0:
        Return false
    
    Return true

Process called "factorial_integer" that takes n as Integer returns Float64:
    If n <= 1:
        Return 1.0
    Let result be 1.0
    For i from 2 to n:
        result = result * MathOps.integer_to_float(i)
    Return result

Note: ===== Main Test Runner =====

Process called "run_all_orthogonal_tests" that takes returns Tuple[Integer, Integer]:
    Note: Runs all orthogonal polynomial tests and returns [passed, total] counts
    
    Let test_results be MathOps.create_empty_list(22)
    Let test_names be [
        "Legendre Basic Values",
        "Legendre Recurrence Relation",
        "Legendre Orthogonality",
        "Associated Legendre Polynomials",
        "Legendre Generating Function",
        "Chebyshev First Kind",
        "Chebyshev Second Kind",
        "Chebyshev Recurrence",
        "Chebyshev Orthogonality",
        "Hermite Physicist Basic",
        "Hermite Probabilist Basic",
        "Hermite Recurrence",
        "Hermite Orthogonality",
        "Laguerre Basic",
        "Associated Laguerre",
        "Laguerre Recurrence",
        "Laguerre Orthogonality",
        "Jacobi Polynomials Basic",
        "Jacobi Special Cases",
        "Jacobi Recurrence",
        "Gegenbauer Polynomials",
        "Gegenbauer Recurrence",
        "Gauss-Legendre Quadrature",
        "Gauss-Hermite Quadrature",
        "Polynomial Zeros",
        "Orthogonal Performance"
    ]
    
    test_results[0] = test_legendre_basic_values()
    test_results[1] = test_legendre_recurrence_relation()
    test_results[2] = test_legendre_orthogonality()
    test_results[3] = test_associated_legendre_polynomials()
    test_results[4] = test_legendre_generating_function()
    test_results[5] = test_chebyshev_first_kind()
    test_results[6] = test_chebyshev_second_kind()
    test_results[7] = test_chebyshev_recurrence()
    test_results[8] = test_chebyshev_orthogonality()
    test_results[9] = test_hermite_physicist_basic()
    test_results[10] = test_hermite_probabilist_basic()
    test_results[11] = test_hermite_recurrence()
    test_results[12] = test_hermite_orthogonality()
    test_results[13] = test_laguerre_basic()
    test_results[14] = test_associated_laguerre()
    test_results[15] = test_laguerre_recurrence()
    test_results[16] = test_laguerre_orthogonality()
    test_results[17] = test_jacobi_polynomials_basic()
    test_results[18] = test_jacobi_special_cases()
    test_results[19] = test_jacobi_recurrence()
    test_results[20] = test_gegenbauer_polynomials()
    test_results[21] = test_gegenbauer_recurrence()
    test_results[22] = test_gauss_legendre_quadrature()
    test_results[23] = test_gauss_hermite_quadrature()
    test_results[24] = test_polynomial_zeros()
    test_results[25] = test_orthogonal_performance()
    
    Let passed_count be 0
    Let total_count be test_results.size
    
    For i from 0 to total_count - 1:
        If test_results[i]:
            passed_count = passed_count + 1
            Let test_status be "PASSED"
            MathOps.print_string(test_names[i] + ": " + test_status)
        Otherwise:
            Let test_status be "FAILED"
            MathOps.print_string(test_names[i] + ": " + test_status)
    
    MathOps.print_string("Orthogonal Polynomials Tests: " + MathOps.integer_to_string(passed_count) + " / " + MathOps.integer_to_string(total_count) + " passed")
    
    Return [passed_count, total_count]