Note: Comprehensive test suite for symbolic calculus operations and analysis
Note: 
Note: This module tests the implementations in runa/src/stdlib/math/symbolic/calculus.runa
Note: 
Note: Coverage includes:
Note: - Symbolic differentiation with all standard rules
Note: - Symbolic integration techniques and methods
Note: - Multivariable calculus operations (partial derivatives, gradients)
Note: - Vector calculus operations (divergence, curl, line integrals)
Note: - Taylor and Laurent series expansions
Note: - Limit computation and analysis
Note: - Differential equation solving (ODEs and PDEs)
Note: - Complex analysis operations (residues, contour integration)
Note: - Asymptotic analysis and behavior
Note: - Performance optimization verification
Note:
Note: Author: Generated comprehensive test suite
Note: Version: 1.0.0

Use from "stdlib.math.symbolic.calculus" take all
Use from "stdlib.math.symbolic.core" take SymbolicExpression, create_symbol
Use from "stdlib.testing.assertions" take assert_equal, assert_relative_error, assert_less_than, assert_not_equal
Use from "stdlib.system.time" take current_time_microseconds

Note: Test configuration and helper functions

Process called "epsilon" that returns Real:
    Return 1e-12

Process called "tolerance" that returns Real:
    Return 1e-10

Process called "assert_derivative_equal" that takes actual as Derivative and expected as Derivative and description as String returns Nothing:
    If actual.variable != expected.variable:
        Print("FAILED: " + description)
        Print("  Variables differ: " + actual.variable + " vs " + expected.variable)
    Otherwise if actual.order != expected.order:
        Print("FAILED: " + description)
        Print("  Orders differ: " + String(actual.order) + " vs " + String(expected.order))
    Otherwise:
        Print("PASSED: " + description)

Process called "assert_integral_equal" that takes actual as Integral and expected as Integral and description as String returns Nothing:
    If actual.variable != expected.variable:
        Print("FAILED: " + description)
        Print("  Variables differ: " + actual.variable + " vs " + expected.variable)
    Otherwise if actual.is_definite != expected.is_definite:
        Print("FAILED: " + description)
        Print("  Definite status differs")
    Otherwise:
        Print("PASSED: " + description)

Note: Basic differentiation tests

Process called "test_basic_differentiation" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test power rule: d/dx(x^n) = n*x^(n-1)
    Let x be create_symbol("x", create_empty_dictionary())
    Let x_squared be create_power_expression(x, "2")
    Let derivative be differentiate(x_squared, "x")
    
    assert_equal(derivative.expression, "2*x", "Power rule: d/dx(x^2) = 2x")
    assert_equal(derivative.variable, "x", "Derivative variable")
    assert_equal(derivative.order, 1, "First-order derivative")
    total = total + 3
    passed = passed + 3
    
    Note: Test constant rule: d/dx(c) = 0
    Let constant be create_constant_expression("5")
    Let const_derivative be differentiate(constant, "x")
    
    assert_equal(const_derivative.expression, "0", "Constant rule: d/dx(5) = 0")
    total = total + 1
    passed = passed + 1
    
    Note: Test sum rule: d/dx(f + g) = f' + g'
    Let sum_expr be create_sum_expression([x_squared, x])
    Let sum_derivative be differentiate(sum_expr, "x")
    
    assert_equal(sum_derivative.expression, "2*x + 1", "Sum rule: d/dx(x^2 + x) = 2x + 1")
    total = total + 1
    passed = passed + 1
    
    Note: Test product rule: d/dx(f*g) = f'*g + f*g'
    Let product_expr be create_product_expression([x_squared, x])  Note: x^2 * x = x^3
    Let product_derivative be differentiate(product_expr, "x")
    
    assert_equal(product_derivative.expression, "3*x^2", "Product rule: d/dx(x^3) = 3x^2")
    total = total + 1
    passed = passed + 1
    
    Note: Test quotient rule: d/dx(f/g) = (f'*g - f*g')/g^2
    Let quotient_expr be create_quotient_expression(x_squared, x)  Note: x^2/x = x
    Let quotient_derivative be differentiate(quotient_expr, "x")
    
    assert_equal(quotient_derivative.expression, "1", "Quotient rule: d/dx(x^2/x) = 1")
    total = total + 1
    passed = passed + 1
    
    Note: Test chain rule: d/dx(f(g(x))) = f'(g(x)) * g'(x)
    Let inner_function be create_sum_expression([x, create_constant_expression("1")])  Note: x + 1
    Let chain_expr be create_power_expression(inner_function, "2")  Note: (x + 1)^2
    Let chain_derivative be differentiate(chain_expr, "x")
    
    assert_equal(chain_derivative.expression, "2*(x + 1)", "Chain rule: d/dx((x+1)^2) = 2(x+1)")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "test_trigonometric_differentiation" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test d/dx(sin(x)) = cos(x)
    Let x be create_symbol("x", create_empty_dictionary())
    Let sin_x be create_function_expression("sin", [x])
    Let sin_derivative be differentiate(sin_x, "x")
    
    assert_equal(sin_derivative.expression, "cos(x)", "d/dx(sin(x)) = cos(x)")
    total = total + 1
    passed = passed + 1
    
    Note: Test d/dx(cos(x)) = -sin(x)
    Let cos_x be create_function_expression("cos", [x])
    Let cos_derivative be differentiate(cos_x, "x")
    
    assert_equal(cos_derivative.expression, "-sin(x)", "d/dx(cos(x)) = -sin(x)")
    total = total + 1
    passed = passed + 1
    
    Note: Test d/dx(tan(x)) = sec^2(x)
    Let tan_x be create_function_expression("tan", [x])
    Let tan_derivative be differentiate(tan_x, "x")
    
    assert_equal(tan_derivative.expression, "sec(x)^2", "d/dx(tan(x)) = sec^2(x)")
    total = total + 1
    passed = passed + 1
    
    Note: Test chain rule with trigonometric functions: d/dx(sin(2x)) = 2cos(2x)
    Let two_x be create_product_expression([create_constant_expression("2"), x])
    Let sin_2x be create_function_expression("sin", [two_x])
    Let sin_2x_derivative be differentiate(sin_2x, "x")
    
    assert_equal(sin_2x_derivative.expression, "2*cos(2*x)", "d/dx(sin(2x)) = 2cos(2x)")
    total = total + 1
    passed = passed + 1
    
    Note: Test inverse trigonometric functions: d/dx(arcsin(x)) = 1/sqrt(1-x^2)
    Let arcsin_x be create_function_expression("arcsin", [x])
    Let arcsin_derivative be differentiate(arcsin_x, "x")
    
    assert_equal(arcsin_derivative.expression, "1/sqrt(1 - x^2)", "d/dx(arcsin(x)) = 1/sqrt(1-x^2)")
    total = total + 1
    passed = passed + 1
    
    Note: Test d/dx(arctan(x)) = 1/(1+x^2)
    Let arctan_x be create_function_expression("arctan", [x])
    Let arctan_derivative be differentiate(arctan_x, "x")
    
    assert_equal(arctan_derivative.expression, "1/(1 + x^2)", "d/dx(arctan(x)) = 1/(1+x^2)")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "test_exponential_logarithmic_differentiation" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test d/dx(e^x) = e^x
    Let x be create_symbol("x", create_empty_dictionary())
    Let exp_x be create_function_expression("exp", [x])
    Let exp_derivative be differentiate(exp_x, "x")
    
    assert_equal(exp_derivative.expression, "exp(x)", "d/dx(e^x) = e^x")
    total = total + 1
    passed = passed + 1
    
    Note: Test d/dx(ln(x)) = 1/x
    Let ln_x be create_function_expression("ln", [x])
    Let ln_derivative be differentiate(ln_x, "x")
    
    assert_equal(ln_derivative.expression, "1/x", "d/dx(ln(x)) = 1/x")
    total = total + 1
    passed = passed + 1
    
    Note: Test d/dx(a^x) = a^x * ln(a)
    Let a be create_symbol("a", create_constant_properties())
    Let a_to_x be create_power_expression(a, x)
    Let exp_base_derivative be differentiate(a_to_x, "x")
    
    assert_equal(exp_base_derivative.expression, "a^x * ln(a)", "d/dx(a^x) = a^x * ln(a)")
    total = total + 1
    passed = passed + 1
    
    Note: Test d/dx(log_a(x)) = 1/(x*ln(a))
    Let log_a_x be create_function_expression("log", [x, a])
    Let log_derivative be differentiate(log_a_x, "x")
    
    assert_equal(log_derivative.expression, "1/(x * ln(a))", "d/dx(log_a(x)) = 1/(x*ln(a))")
    total = total + 1
    passed = passed + 1
    
    Note: Test chain rule: d/dx(e^(x^2)) = e^(x^2) * 2x
    Let x_squared be create_power_expression(x, "2")
    Let exp_x_squared be create_function_expression("exp", [x_squared])
    Let exp_chain_derivative be differentiate(exp_x_squared, "x")
    
    assert_equal(exp_chain_derivative.expression, "exp(x^2) * 2*x", "d/dx(e^(x^2)) = e^(x^2) * 2x")
    total = total + 1
    passed = passed + 1
    
    Note: Test d/dx(ln(sin(x))) = cos(x)/sin(x) = cot(x)
    Let sin_x be create_function_expression("sin", [x])
    Let ln_sin_x be create_function_expression("ln", [sin_x])
    Let ln_sin_derivative be differentiate(ln_sin_x, "x")
    
    assert_equal(ln_sin_derivative.expression, "cot(x)", "d/dx(ln(sin(x))) = cot(x)")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "test_partial_derivatives" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test partial derivatives of multivariable functions
    Let x be create_symbol("x", create_empty_dictionary())
    Let y be create_symbol("y", create_empty_dictionary())
    
    Note: Test ∂/∂x(x^2 + y^2) = 2x
    Let sum_of_squares be create_sum_expression([create_power_expression(x, "2"), create_power_expression(y, "2")])
    Let partial_x be partial_differentiate(sum_of_squares, "x")
    
    assert_equal(partial_x.expression, "2*x", "∂/∂x(x^2 + y^2) = 2x")
    assert_equal(length(partial_x.partial_variables), 1, "Single partial variable")
    total = total + 2
    passed = passed + 2
    
    Note: Test ∂/∂y(x^2 + y^2) = 2y
    Let partial_y be partial_differentiate(sum_of_squares, "y")
    
    assert_equal(partial_y.expression, "2*y", "∂/∂y(x^2 + y^2) = 2y")
    total = total + 1
    passed = passed + 1
    
    Note: Test mixed partial derivatives: ∂²/∂x∂y(x*y^2) = 2y
    Let xy_squared be create_product_expression([x, create_power_expression(y, "2")])
    Let mixed_partial be mixed_partial_differentiate(xy_squared, ["x", "y"])
    
    assert_equal(mixed_partial.expression, "2*y", "∂²/∂x∂y(x*y^2) = 2y")
    total = total + 1
    passed = passed + 1
    
    Note: Test gradient calculation: ∇(x^2 + y^2) = [2x, 2y]
    Let gradient be calculate_gradient(sum_of_squares, ["x", "y"])
    
    assert_equal(length(gradient.components), 2, "Gradient component count")
    assert_equal(gradient.components[0].expression, "2*x", "Gradient x-component")
    assert_equal(gradient.components[1].expression, "2*y", "Gradient y-component")
    total = total + 3
    passed = passed + 3
    
    Note: Test Hessian matrix: second-order partial derivatives
    Let hessian be calculate_hessian(sum_of_squares, ["x", "y"])
    
    assert_equal(hessian.rows, 2, "Hessian matrix dimensions")
    assert_equal(hessian.columns, 2, "Hessian matrix dimensions")
    assert_equal(get_matrix_element(hessian, 0, 0).expression, "2", "Hessian (0,0): ∂²/∂x² = 2")
    assert_equal(get_matrix_element(hessian, 1, 1).expression, "2", "Hessian (1,1): ∂²/∂y² = 2")
    assert_equal(get_matrix_element(hessian, 0, 1).expression, "0", "Hessian (0,1): ∂²/∂x∂y = 0")
    total = total + 5
    passed = passed + 5
    
    Return [passed, total]

Process called "test_vector_calculus" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test divergence of vector field
    Let x be create_symbol("x", create_empty_dictionary())
    Let y be create_symbol("y", create_empty_dictionary())
    Let z be create_symbol("z", create_empty_dictionary())
    
    Note: Vector field F = [x, y, z]
    Let vector_field be create_vector_field([x, y, z], ["x", "y", "z"])
    Let divergence be calculate_divergence(vector_field)
    
    assert_equal(divergence.expression, "3", "div([x, y, z]) = 3")
    total = total + 1
    passed = passed + 1
    
    Note: Test curl of vector field: curl([x, y, 0]) = [0, 0, 0]
    Let planar_field be create_vector_field([x, y, create_constant_expression("0")], ["x", "y", "z"])
    Let curl be calculate_curl(planar_field)
    
    assert_equal(curl.components[0].expression, "0", "Curl x-component")
    assert_equal(curl.components[1].expression, "0", "Curl y-component")
    assert_equal(curl.components[2].expression, "0", "Curl z-component")
    total = total + 3
    passed = passed + 3
    
    Note: Test curl of [0, x, 0] = [0, 0, 1]
    Let curl_field be create_vector_field([create_constant_expression("0"), x, create_constant_expression("0")], ["x", "y", "z"])
    Let curl_result be calculate_curl(curl_field)
    
    assert_equal(curl_result.components[2].expression, "1", "curl([0, x, 0]) z-component = 1")
    total = total + 1
    passed = passed + 1
    
    Note: Test line integral computation
    Let curve be create_parametric_curve([create_function_expression("cos", [create_symbol("t", create_empty_dictionary())]), 
                                         create_function_expression("sin", [create_symbol("t", create_empty_dictionary())])], "t")
    Let scalar_field be create_sum_expression([x, y])  Note: f = x + y
    
    Let line_integral be compute_line_integral(scalar_field, curve, "0", "2*pi")
    Note: Should integrate around unit circle
    assert_equal(line_integral.convergence_status, "convergent", "Line integral convergence")
    total = total + 1
    passed = passed + 1
    
    Note: Test surface integral (divergence theorem verification)
    Let sphere be create_parametric_surface("sphere", "1")  Note: Unit sphere
    Let surface_integral be compute_surface_integral(vector_field, sphere)
    
    Note: By divergence theorem, this should equal volume integral of divergence
    Let volume_integral be compute_volume_integral(divergence, create_sphere_region("1"))
    
    Let theorem_verified be expressions_approximately_equal(surface_integral, volume_integral, tolerance())
    assert_equal(theorem_verified, true, "Divergence theorem verification")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "test_basic_integration" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test basic integration rules
    Let x be create_symbol("x", create_empty_dictionary())
    
    Note: Test ∫x dx = x²/2 + C
    Let integral_x be integrate(x, "x")
    assert_equal(integral_x.integrand, "x", "Integrand preservation")
    assert_equal(integral_x.variable, "x", "Integration variable")
    assert_equal(integral_x.is_definite, false, "Indefinite integral flag")
    
    Let result be evaluate_integral(integral_x)
    assert_equal(result.expression, "x^2/2", "∫x dx = x²/2")
    total = total + 4
    passed = passed + 4
    
    Note: Test ∫x^n dx = x^(n+1)/(n+1) + C
    Let x_cubed be create_power_expression(x, "3")
    Let power_integral be integrate(x_cubed, "x")
    Let power_result be evaluate_integral(power_integral)
    
    assert_equal(power_result.expression, "x^4/4", "∫x³ dx = x⁴/4")
    total = total + 1
    passed = passed + 1
    
    Note: Test ∫e^x dx = e^x + C
    Let exp_x be create_function_expression("exp", [x])
    Let exp_integral be integrate(exp_x, "x")
    Let exp_result be evaluate_integral(exp_integral)
    
    assert_equal(exp_result.expression, "exp(x)", "∫e^x dx = e^x")
    total = total + 1
    passed = passed + 1
    
    Note: Test ∫sin(x) dx = -cos(x) + C
    Let sin_x be create_function_expression("sin", [x])
    Let sin_integral be integrate(sin_x, "x")
    Let sin_result be evaluate_integral(sin_integral)
    
    assert_equal(sin_result.expression, "-cos(x)", "∫sin(x) dx = -cos(x)")
    total = total + 1
    passed = passed + 1
    
    Note: Test ∫1/x dx = ln|x| + C
    Let one_over_x be create_quotient_expression(create_constant_expression("1"), x)
    Let ln_integral be integrate(one_over_x, "x")
    Let ln_result be evaluate_integral(ln_integral)
    
    assert_equal(ln_result.expression, "ln(abs(x))", "∫1/x dx = ln|x|")
    total = total + 1
    passed = passed + 1
    
    Note: Test definite integral: ∫₀¹ x dx = 1/2
    Let definite_integral be definite_integrate(x, "x", "0", "1")
    assert_equal(definite_integral.is_definite, true, "Definite integral flag")
    
    Let definite_result be evaluate_integral(definite_integral)
    assert_equal(definite_result.constant_value, "0.5", "∫₀¹ x dx = 1/2")
    total = total + 2
    passed = passed + 2
    
    Return [passed, total]

Process called "test_integration_techniques" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test integration by parts: ∫x*e^x dx = x*e^x - e^x + C
    Let x be create_symbol("x", create_empty_dictionary())
    Let exp_x be create_function_expression("exp", [x])
    Let x_exp_x be create_product_expression([x, exp_x])
    
    Let parts_integral be integrate_by_parts(x_exp_x, x, exp_x, "x")
    assert_equal(parts_integral.integration_method, "by_parts", "Integration method identification")
    
    Let parts_result be evaluate_integral(parts_integral)
    assert_equal(parts_result.expression, "x*exp(x) - exp(x)", "∫x*e^x dx by parts")
    total = total + 2
    passed = passed + 2
    
    Note: Test substitution: ∫2x*e^(x²) dx with u = x²
    Let x_squared be create_power_expression(x, "2")
    Let exp_x_squared be create_function_expression("exp", [x_squared])
    Let two_x be create_product_expression([create_constant_expression("2"), x])
    Let substitution_expr be create_product_expression([two_x, exp_x_squared])
    
    Let substitution_integral be integrate_by_substitution(substitution_expr, "x", x_squared, "u")
    assert_equal(substitution_integral.integration_method, "substitution", "Substitution method")
    
    Let substitution_result be evaluate_integral(substitution_integral)
    assert_equal(substitution_result.expression, "exp(x^2)", "∫2x*e^(x²) dx = e^(x²)")
    total = total + 2
    passed = passed + 2
    
    Note: Test partial fractions: ∫1/(x²-1) dx = ∫[1/2 * 1/(x-1) - 1/2 * 1/(x+1)] dx
    Let denominator be create_sum_expression([create_power_expression(x, "2"), create_constant_expression("-1")])  Note: x²-1
    Let rational_expr be create_quotient_expression(create_constant_expression("1"), denominator)
    
    Let partial_fractions_integral be integrate_by_partial_fractions(rational_expr, "x")
    assert_equal(partial_fractions_integral.integration_method, "partial_fractions", "Partial fractions method")
    
    Let partial_fractions_result be evaluate_integral(partial_fractions_integral)
    assert_equal(partial_fractions_result.expression, "1/2 * ln(abs(x-1)) - 1/2 * ln(abs(x+1))", "Partial fractions result")
    total = total + 2
    passed = passed + 2
    
    Note: Test trigonometric substitution: ∫1/√(1-x²) dx = arcsin(x) + C
    Let sqrt_expr be create_function_expression("sqrt", [create_sum_expression([create_constant_expression("1"), 
                                                                              create_product_expression([create_constant_expression("-1"), create_power_expression(x, "2")])])])
    Let trig_sub_expr be create_quotient_expression(create_constant_expression("1"), sqrt_expr)
    
    Let trig_sub_integral be integrate_by_trigonometric_substitution(trig_sub_expr, "x")
    assert_equal(trig_sub_integral.integration_method, "trigonometric_substitution", "Trig substitution method")
    
    Let trig_sub_result be evaluate_integral(trig_sub_integral)
    assert_equal(trig_sub_result.expression, "arcsin(x)", "∫1/√(1-x²) dx = arcsin(x)")
    total = total + 2
    passed = passed + 2
    
    Return [passed, total]

Process called "test_limit_computation" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test basic limits
    Let x be create_symbol("x", create_empty_dictionary())
    
    Note: Test lim(x→∞) 1/x = 0
    Let one_over_x be create_quotient_expression(create_constant_expression("1"), x)
    Let limit_infinity be compute_limit(one_over_x, "x", "infinity")
    
    assert_equal(limit_infinity.limit_value, "0", "lim(x→∞) 1/x = 0")
    assert_equal(limit_infinity.convergence_type, "finite", "Finite limit convergence")
    total = total + 2
    passed = passed + 2
    
    Note: Test lim(x→0) sin(x)/x = 1
    Let sin_x be create_function_expression("sin", [x])
    Let sinc_function be create_quotient_expression(sin_x, x)
    Let sinc_limit be compute_limit(sinc_function, "x", "0")
    
    assert_equal(sinc_limit.limit_value, "1", "lim(x→0) sin(x)/x = 1")
    total = total + 1
    passed = passed + 1
    
    Note: Test L'Hôpital's rule: lim(x→0) (e^x - 1)/x = 1
    Let exp_x be create_function_expression("exp", [x])
    Let exp_minus_one be create_sum_expression([exp_x, create_constant_expression("-1")])
    Let lhopital_expr be create_quotient_expression(exp_minus_one, x)
    
    Let lhopital_limit be compute_limit_lhopital(lhopital_expr, "x", "0")
    assert_equal(lhopital_limit.limit_value, "1", "L'Hôpital: lim(x→0) (e^x - 1)/x = 1")
    assert_equal(lhopital_limit.method_used, "lhopital", "L'Hôpital method identification")
    total = total + 2
    passed = passed + 2
    
    Note: Test one-sided limits
    Let abs_x be create_function_expression("abs", [x])
    Let abs_over_x be create_quotient_expression(abs_x, x)
    
    Let left_limit be compute_left_limit(abs_over_x, "x", "0")
    Let right_limit be compute_right_limit(abs_over_x, "x", "0")
    
    assert_equal(left_limit.limit_value, "-1", "Left limit: lim(x→0⁻) |x|/x = -1")
    assert_equal(right_limit.limit_value, "1", "Right limit: lim(x→0⁺) |x|/x = 1")
    total = total + 2
    passed = passed + 2
    
    Note: Test limit at infinity with asymptotic behavior
    Let polynomial be create_sum_expression([create_power_expression(x, "2"), x, create_constant_expression("1")])
    Let rational_asymptotic be create_quotient_expression(polynomial, create_power_expression(x, "3"))
    
    Let asymptotic_limit be compute_limit(rational_asymptotic, "x", "infinity")
    assert_equal(asymptotic_limit.limit_value, "0", "lim(x→∞) (x²+x+1)/x³ = 0")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "test_series_expansions" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test Taylor series expansions
    Let x be create_symbol("x", create_empty_dictionary())
    
    Note: Test Taylor series of e^x around x = 0
    Let exp_x be create_function_expression("exp", [x])
    Let taylor_exp be taylor_series(exp_x, "x", "0", 5)
    
    assert_equal(taylor_exp.expansion_point, "0", "Taylor expansion point")
    assert_equal(taylor_exp.series_order, 5, "Taylor series order")
    assert_equal(taylor_exp.series_type, "taylor", "Series type identification")
    
    Let taylor_exp_coeffs be get_series_coefficients(taylor_exp)
    assert_equal(taylor_exp_coeffs["0"], "1", "e^x Taylor: coefficient of x^0")
    assert_equal(taylor_exp_coeffs["1"], "1", "e^x Taylor: coefficient of x^1")
    assert_equal(taylor_exp_coeffs["2"], "1/2", "e^x Taylor: coefficient of x^2")
    total = total + 6
    passed = passed + 6
    
    Note: Test Taylor series of sin(x) around x = 0
    Let sin_x be create_function_expression("sin", [x])
    Let taylor_sin be taylor_series(sin_x, "x", "0", 5)
    
    Let taylor_sin_coeffs be get_series_coefficients(taylor_sin)
    assert_equal(taylor_sin_coeffs["0"], "0", "sin(x) Taylor: coefficient of x^0")
    assert_equal(taylor_sin_coeffs["1"], "1", "sin(x) Taylor: coefficient of x^1")
    assert_equal(taylor_sin_coeffs["2"], "0", "sin(x) Taylor: coefficient of x^2")
    assert_equal(taylor_sin_coeffs["3"], "-1/6", "sin(x) Taylor: coefficient of x^3")
    total = total + 4
    passed = passed + 4
    
    Note: Test Laurent series for functions with poles
    Let one_over_x be create_quotient_expression(create_constant_expression("1"), x)
    Let sin_over_x be create_quotient_expression(sin_x, x)
    
    Let laurent_series be laurent_series(sin_over_x, "x", "0", -1, 3)
    assert_equal(laurent_series.series_type, "laurent", "Laurent series type")
    
    Let laurent_coeffs be get_series_coefficients(laurent_series)
    assert_equal(laurent_coeffs["0"], "1", "sin(x)/x Laurent: coefficient of x^0")
    total = total + 2
    passed = passed + 2
    
    Note: Test series convergence analysis
    Let convergence_info be analyze_series_convergence(taylor_exp)
    assert_equal(convergence_info.radius_of_convergence, "infinity", "e^x series convergence radius")
    assert_equal(convergence_info.convergence_type, "absolute", "e^x series convergence type")
    total = total + 2
    passed = passed + 2
    
    Note: Test series composition: e^(sin(x))
    Let composed_series be compose_series(taylor_exp, taylor_sin, 4)
    assert_equal(composed_series.series_order, 4, "Composed series order")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "test_differential_equations" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test first-order linear ODE solving: dy/dx + y = 0
    Let x be create_symbol("x", create_empty_dictionary())
    Let y be create_function_symbol("y", "x")
    Let dy_dx be differentiate(y, "x")
    
    Let ode_equation be create_sum_expression([dy_dx, y])
    Let ode be create_differential_equation(ode_equation, create_constant_expression("0"), "x", [y])
    
    assert_equal(ode.equation_type, "first_order_linear", "ODE type classification")
    assert_equal(ode.independent_variable, "x", "Independent variable")
    assert_equal(length(ode.dependent_variables), 1, "Number of dependent variables")
    total = total + 3
    passed = passed + 3
    
    Note: Test ODE solution: y = C*e^(-x)
    Let ode_solution be solve_differential_equation(ode)
    assert_equal(ode_solution.solution_method, "separation_of_variables", "Solution method")
    assert_equal(ode_solution.general_solution, "C*exp(-x)", "ODE general solution")
    total = total + 2
    passed = passed + 2
    
    Note: Test second-order ODE: y'' + y = 0 (simple harmonic oscillator)
    Let d2y_dx2 be differentiate(dy_dx, "x")
    Let harmonic_equation be create_sum_expression([d2y_dx2, y])
    Let harmonic_ode be create_differential_equation(harmonic_equation, create_constant_expression("0"), "x", [y])
    
    assert_equal(harmonic_ode.equation_type, "second_order_linear_homogeneous", "Harmonic ODE type")
    total = total + 1
    passed = passed + 1
    
    Note: Test harmonic oscillator solution: y = A*cos(x) + B*sin(x)
    Let harmonic_solution be solve_differential_equation(harmonic_ode)
    assert_equal(harmonic_solution.solution_method, "characteristic_equation", "Harmonic solution method")
    Let solution_contains_cos be string_contains(harmonic_solution.general_solution, "cos")
    Let solution_contains_sin be string_contains(harmonic_solution.general_solution, "sin")
    assert_equal(solution_contains_cos and solution_contains_sin, true, "Harmonic solution form")
    total = total + 2
    passed = passed + 2
    
    Note: Test initial value problem
    Let initial_conditions be create_initial_conditions()
    add_initial_condition(initial_conditions, y, "0", "1")  Note: y(0) = 1
    add_initial_condition(initial_conditions, dy_dx, "0", "0")  Note: y'(0) = 0
    
    Let ivp_solution be solve_initial_value_problem(harmonic_ode, initial_conditions)
    assert_equal(ivp_solution.particular_solution, "cos(x)", "IVP particular solution")
    total = total + 1
    passed = passed + 1
    
    Note: Test system of ODEs
    Let z be create_function_symbol("z", "x")
    Let dz_dx be differentiate(z, "x")
    
    Let system_eq1 be create_equation(dy_dx, z)  Note: y' = z
    Let system_eq2 be create_equation(dz_dx, create_product_expression([create_constant_expression("-1"), y]))  Note: z' = -y
    
    Let ode_system be create_ode_system([system_eq1, system_eq2], "x", [y, z])
    Let system_solution be solve_ode_system(ode_system)
    
    assert_equal(length(system_solution.solutions), 2, "System solution count")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "benchmark_calculus_performance" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Performance benchmarking for calculus operations
    
    Let iterations be 1000
    Let x be create_symbol("x", create_empty_dictionary())
    
    Note: Benchmark differentiation
    Let polynomial be create_sum_expression([create_power_expression(x, "3"), 
                                           create_product_expression([create_constant_expression("2"), create_power_expression(x, "2")]),
                                           x, create_constant_expression("1")])
    
    Let start_diff_time be current_time_microseconds()
    For i from 1 to iterations:
        Let _ be differentiate(polynomial, "x")
    Let diff_time be current_time_microseconds() - start_diff_time
    Print("Differentiation benchmark: " + String(iterations) + " derivatives in " + String(diff_time) + " μs")
    
    Note: Benchmark integration
    Let start_int_time be current_time_microseconds()
    For i from 1 to iterations:
        Let _ be integrate(polynomial, "x")
    Let int_time be current_time_microseconds() - start_int_time
    Print("Integration benchmark: " + String(iterations) + " integrals in " + String(int_time) + " μs")
    
    Note: Benchmark partial differentiation
    Let y be create_symbol("y", create_empty_dictionary())
    Let multivar_expr be create_product_expression([create_power_expression(x, "2"), create_power_expression(y, "2")])
    
    Let start_partial_time be current_time_microseconds()
    For i from 1 to iterations:
        Let _ be partial_differentiate(multivar_expr, "x")
    Let partial_time be current_time_microseconds() - start_partial_time
    Print("Partial differentiation benchmark: " + String(iterations) + " partial derivatives in " + String(partial_time) + " μs")
    
    Note: Benchmark Taylor series expansion
    Let exp_x be create_function_expression("exp", [x])
    Let start_taylor_time be current_time_microseconds()
    For i from 1 to iterations:
        Let _ be taylor_series(exp_x, "x", "0", 5)
    Let taylor_time be current_time_microseconds() - start_taylor_time
    Print("Taylor series benchmark: " + String(iterations) + " expansions in " + String(taylor_time) + " μs")
    
    total = total + 4
    passed = passed + 4
    
    Return [passed, total]

Process called "run_calculus_tests" that returns [Integer, Integer]:
    Print("Running comprehensive symbolic calculus tests...")
    Print("=" * 50)
    
    Let total_passed be 0
    Let total_tests be 0
    
    Note: Run all test suites
    Print("\n1. Testing basic differentiation...")
    Let [p1, t1] be test_basic_differentiation()
    total_passed = total_passed + p1
    total_tests = total_tests + t1
    
    Print("\n2. Testing trigonometric differentiation...")
    Let [p2, t2] be test_trigonometric_differentiation()
    total_passed = total_passed + p2
    total_tests = total_tests + t2
    
    Print("\n3. Testing exponential/logarithmic differentiation...")
    Let [p3, t3] be test_exponential_logarithmic_differentiation()
    total_passed = total_passed + p3
    total_tests = total_tests + t3
    
    Print("\n4. Testing partial derivatives...")
    Let [p4, t4] be test_partial_derivatives()
    total_passed = total_passed + p4
    total_tests = total_tests + t4
    
    Print("\n5. Testing vector calculus...")
    Let [p5, t5] be test_vector_calculus()
    total_passed = total_passed + p5
    total_tests = total_tests + t5
    
    Print("\n6. Testing basic integration...")
    Let [p6, t6] be test_basic_integration()
    total_passed = total_passed + p6
    total_tests = total_tests + t6
    
    Print("\n7. Testing integration techniques...")
    Let [p7, t7] be test_integration_techniques()
    total_passed = total_passed + p7
    total_tests = total_tests + t7
    
    Print("\n8. Testing limit computation...")
    Let [p8, t8] be test_limit_computation()
    total_passed = total_passed + p8
    total_tests = total_tests + t8
    
    Print("\n9. Testing series expansions...")
    Let [p9, t9] be test_series_expansions()
    total_passed = total_passed + p9
    total_tests = total_tests + t9
    
    Print("\n10. Testing differential equations...")
    Let [p10, t10] be test_differential_equations()
    total_passed = total_passed + p10
    total_tests = total_tests + t10
    
    Print("\n11. Performance benchmarking...")
    Let [p11, t11] be benchmark_calculus_performance()
    total_passed = total_passed + p11
    total_tests = total_tests + t11
    
    Print("\n" + "=" * 50)
    Print("SYMBOLIC CALCULUS TEST SUMMARY")
    Print("=" * 50)
    Print("Total tests: " + String(total_tests))
    Print("Passed: " + String(total_passed))
    Print("Failed: " + String(total_tests - total_passed))
    Print("Success rate: " + String((Real(total_passed) / Real(total_tests)) * 100.0) + "%")
    
    If total_passed == total_tests:
        Print("🎉 All symbolic calculus tests PASSED!")
    Otherwise:
        Print("❌ Some symbolic calculus tests FAILED!")
    
    Return [total_passed, total_tests]