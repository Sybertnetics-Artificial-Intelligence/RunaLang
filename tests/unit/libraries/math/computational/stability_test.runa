Note:
tests/unit/libraries/math/computational/stability_test.runa
Unit Tests for Math Computational Stability Module

This test suite provides comprehensive testing for the numerical stability module including:
- Condition number analysis and matrix stability assessment
- Perturbation theory and sensitivity analysis
- Backward error analysis and stability verification
- Forward error analysis and error propagation
- Algorithm stability classification and assessment
- Numerical method stability evaluation
- Round-off error analysis and accumulation
- Truncation error bounds and convergence
- Discretization error analysis and grid refinement
- Iterative error analysis and convergence criteria
- Stability constant computation and verification
- Integration with linear algebra and numerical methods
:End Note

Import "stdlib/math/computational/stability" as Stability
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "assert_condition_number_valid" that takes condition as ConditionNumber, expected_class as String returns Boolean:
    Note: Assert condition number has valid mathematical properties
    Assert.IsNotEmpty(condition.condition_id)
    Assert.IsNotEmpty(condition.matrix_operator)
    Assert.IsNotEmpty(condition.norm_type)
    Assert.IsTrue(condition.condition_value > 0.0)
    Assert.AreEqual(condition.stability_classification, expected_class)
    Assert.IsNotEmpty(condition.interpretation)
    Assert.IsTrue(condition.sensitivity_analysis.contains_key("relative_error_amplification"))
    Return True

Process called "assert_perturbation_analysis_valid" that takes analysis as PerturbationAnalysis returns Boolean:
    Note: Assert perturbation analysis has valid properties
    Assert.IsNotEmpty(analysis.analysis_id)
    Assert.IsNotEmpty(analysis.original_problem)
    Assert.IsNotEmpty(analysis.perturbed_problem)
    Assert.IsTrue(analysis.perturbation_magnitude >= 0.0)
    Assert.IsTrue(analysis.solution_change >= 0.0)
    Assert.IsTrue(analysis.amplification_factor >= 0.0)
    Return True

Process called "assert_error_analysis_valid" that takes error as BackwardError returns Boolean:
    Note: Assert backward error analysis has valid properties
    Assert.IsNotEmpty(error.error_id)
    Assert.IsNotEmpty(error.computed_solution)
    Assert.IsNotEmpty(error.exact_problem)
    Assert.IsTrue(error.backward_perturbation.size() > 0)
    Assert.IsTrue(error.stability_radius >= 0.0)
    Assert.IsTrue(error.error_magnification >= 0.0)
    Return True

Process called "generate_test_matrices_well_conditioned" that takes no parameters returns List[List[List[Float]]]:
    Note: Generate well-conditioned test matrices
    Let matrices be List[List[List[Float]]]()
    
    Note: Identity matrix
    Let identity be [[1.0, 0.0], [0.0, 1.0]]
    Call matrices.add(identity)
    
    Note: Diagonal matrix with reasonable condition
    Let diagonal be [[2.0, 0.0], [0.0, 1.0]]
    Call matrices.add(diagonal)
    
    Note: Symmetric positive definite
    Let spd be [[4.0, 1.0], [1.0, 3.0]]
    Call matrices.add(spd)
    
    Return matrices

Process called "generate_test_matrices_ill_conditioned" that takes no parameters returns List[List[List[Float]]]:
    Note: Generate ill-conditioned test matrices
    Let matrices be List[List[List[Float]]]()
    
    Note: Hilbert matrix (2x2)
    Let hilbert be [[1.0, 0.5], [0.5, 0.33333]]
    Call matrices.add(hilbert)
    
    Note: Nearly singular matrix
    Let nearly_singular be [[1.0, 1.0], [1.0, 1.00001]]
    Call matrices.add(nearly_singular)
    
    Note: Matrix with large condition number
    Let large_cond be [[1.0, 0.0], [0.0, 0.001]]
    Call matrices.add(large_cond)
    
    Return matrices

Process called "create_perturbed_matrix" that takes original as List[List[Float]], perturbation_magnitude as Float returns List[List[Float]]:
    Note: Create perturbed version of matrix for stability testing
    Let perturbed be List[List[Float]]()
    
    For i from 0 to original.length - 1:
        Let row be List[Float]()
        For j from 0 to original[i].length - 1:
            Let perturbation be perturbation_magnitude * (Random() - 0.5)
            Let perturbed_value be original[i][j] + perturbation
            Call row.add(perturbed_value)
        Call perturbed.add(row)
    
    Return perturbed

Process called "compute_matrix_norm_frobenius" that takes matrix as List[List[Float]] returns Float:
    Note: Compute Frobenius norm of matrix for testing purposes
    Let sum_squares be 0.0
    
    For i from 0 to matrix.length - 1:
        For j from 0 to matrix[i].length - 1:
            Let element be matrix[i][j]
            Set sum_squares to sum_squares + element * element
    
    Return SquareRoot(sum_squares)

Note: =====================================================================
Note: CONDITION NUMBER ANALYSIS TESTS
Note: =====================================================================

Process called "test_compute_matrix_condition_number_well_conditioned" that takes no parameters returns Boolean:
    Note: Test condition number computation for well-conditioned matrices
    Let well_conditioned_matrices be generate_test_matrices_well_conditioned()
    
    For matrix in well_conditioned_matrices:
        Let condition_2norm be Stability.compute_matrix_condition_number(matrix, "2")
        Let condition_1norm be Stability.compute_matrix_condition_number(matrix, "1")
        Let condition_inf_norm be Stability.compute_matrix_condition_number(matrix, "inf")
        
        Assert.IsTrue(assert_condition_number_valid(condition_2norm, "well-conditioned"))
        Assert.IsTrue(assert_condition_number_valid(condition_1norm, "well-conditioned"))
        Assert.IsTrue(assert_condition_number_valid(condition_inf_norm, "well-conditioned"))
        
        Note: Well-conditioned matrices should have condition numbers close to 1
        Assert.IsTrue(condition_2norm.condition_value < 100.0)
        Assert.IsTrue(condition_1norm.condition_value < 100.0)
        Assert.IsTrue(condition_inf_norm.condition_value < 100.0)
    
    Return True

Process called "test_compute_matrix_condition_number_ill_conditioned" that takes no parameters returns Boolean:
    Note: Test condition number computation for ill-conditioned matrices
    Let ill_conditioned_matrices be generate_test_matrices_ill_conditioned()
    
    For matrix in ill_conditioned_matrices:
        Let condition_2norm be Stability.compute_matrix_condition_number(matrix, "2")
        
        Assert.IsTrue(condition_2norm.condition_value > 10.0) Note: Should be large
        Assert.IsTrue(condition_2norm.stability_classification = "ill-conditioned" OR 
                      condition_2norm.stability_classification = "poorly_conditioned")
        
        Note: Check sensitivity analysis
        Assert.IsTrue(condition_2norm.sensitivity_analysis.contains_key("relative_error_amplification"))
        Assert.IsTrue(condition_2norm.sensitivity_analysis["relative_error_amplification"] > 10.0)
    
    Return True

Process called "test_analyze_condition_number_interpretation" that takes no parameters returns Boolean:
    Note: Test condition number interpretation and classification
    Let test_values be [1.0, 5.0, 50.0, 1000.0, 1e12, 1e16]
    Let expected_classes be ["perfectly_conditioned", "well_conditioned", "moderately_conditioned", 
                            "poorly_conditioned", "ill_conditioned", "singular"]
    
    For i from 0 to Length(test_values) - 1:
        Let condition_value be test_values[i]
        Let expected_class be expected_classes[i]
        
        Let interpretation be Stability.analyze_condition_number_interpretation(condition_value)
        
        Assert.IsTrue(interpretation.contains_key("conditioning_level"))
        Assert.IsTrue(interpretation.contains_key("stability_assessment"))
        Assert.IsTrue(interpretation.contains_key("numerical_behavior"))
        
        Assert.IsTrue(Contains(interpretation["conditioning_level"], expected_class) OR 
                      Contains(interpretation["stability_assessment"], expected_class))
    
    Return True

Process called "test_condition_number_norm_consistency" that takes no parameters returns Boolean:
    Note: Test consistency of condition numbers across different norms
    Let test_matrix be [[2.0, 1.0], [1.0, 2.0]]
    
    Let cond_1 be Stability.compute_matrix_condition_number(test_matrix, "1")
    Let cond_2 be Stability.compute_matrix_condition_number(test_matrix, "2")
    Let cond_inf be Stability.compute_matrix_condition_number(test_matrix, "inf")
    
    Note: All condition numbers should be finite and positive
    Assert.IsTrue(cond_1.condition_value > 0.0)
    Assert.IsTrue(cond_2.condition_value > 0.0)
    Assert.IsTrue(cond_inf.condition_value > 0.0)
    
    Note: For symmetric positive definite matrices, all norms should give similar results
    Let max_cond be Maximum([cond_1.condition_value, cond_2.condition_value, cond_inf.condition_value])
    Let min_cond be Minimum([cond_1.condition_value, cond_2.condition_value, cond_inf.condition_value])
    Assert.IsTrue(max_cond / min_cond < 10.0) Note: Should be within reasonable factor
    
    Return True

Note: =====================================================================
Note: PERTURBATION ANALYSIS TESTS
Note: =====================================================================

Process called "test_analyze_perturbation_sensitivity" that takes no parameters returns Boolean:
    Note: Test perturbation sensitivity analysis for linear systems
    Let original_matrix be [[2.0, 1.0], [1.0, 2.0]]
    Let original_rhs be [3.0, 3.0]
    Let perturbation_magnitude be 0.01
    
    Let perturbed_matrix be create_perturbed_matrix(original_matrix, perturbation_magnitude)
    Let perturbed_rhs be [3.01, 2.99]
    
    Let perturbation_analysis be Stability.analyze_perturbation_sensitivity(
        original_matrix, original_rhs, perturbed_matrix, perturbed_rhs)
    
    Assert.IsTrue(assert_perturbation_analysis_valid(perturbation_analysis))
    Assert.IsTrue(perturbation_analysis.perturbation_magnitude > 0.0)
    Assert.IsTrue(perturbation_analysis.amplification_factor >= 1.0)
    
    Return True

Process called "test_compute_perturbation_bounds" that takes no parameters returns Boolean:
    Note: Test computation of perturbation bounds using matrix norms
    Let matrix be [[3.0, 2.0], [1.0, 4.0]]
    Let perturbation_matrix be [[0.1, -0.05], [0.02, -0.08]]
    
    Let bounds be Stability.compute_perturbation_bounds(matrix, perturbation_matrix)
    
    Assert.IsTrue(bounds.contains_key("relative_perturbation"))
    Assert.IsTrue(bounds.contains_key("solution_change_bound"))
    Assert.IsTrue(bounds.contains_key("amplification_factor"))
    Assert.IsTrue(bounds["relative_perturbation"] >= 0.0)
    Assert.IsTrue(bounds["solution_change_bound"] >= 0.0)
    Assert.IsTrue(bounds["amplification_factor"] >= 1.0)
    
    Return True

Process called "test_linearized_perturbation_analysis" that takes no parameters returns Boolean:
    Note: Test linearized perturbation analysis for nonlinear problems
    Let nonlinear_function be "x^2 + 2*x - 1"
    Let evaluation_point be 1.0
    Let perturbation_size be 0.1
    
    Let linearized_analysis be Stability.analyze_linearized_perturbation(
        nonlinear_function, evaluation_point, perturbation_size)
    
    Assert.IsTrue(assert_perturbation_analysis_valid(linearized_analysis))
    Assert.IsTrue(linearized_analysis.linearized_analysis)
    
    Note: For f(x) = x² + 2x - 1 at x = 1, f'(1) = 4
    Note: Small perturbation should be amplified by factor ≈ 4
    Assert.IsTrue(AbsoluteValue(linearized_analysis.amplification_factor - 4.0) < 1.0)
    
    Return True

Note: =====================================================================
Note: BACKWARD ERROR ANALYSIS TESTS
Note: =====================================================================

Process called "test_compute_backward_error_linear_system" that takes no parameters returns Boolean:
    Note: Test backward error analysis for linear system solutions
    Let coefficient_matrix be [[2.0, 1.0], [1.0, 2.0]]
    Let right_hand_side be [5.0, 4.0]
    Let computed_solution be [2.0, 1.0] Note: Exact solution is [2, 1]
    
    Let backward_error be Stability.compute_backward_error_linear_system(
        coefficient_matrix, right_hand_side, computed_solution)
    
    Assert.IsTrue(assert_error_analysis_valid(backward_error))
    Assert.AreEqual(backward_error.computed_solution, "[2.0, 1.0]")
    
    Note: For exact solution, backward error should be very small
    Assert.IsTrue(backward_error.stability_radius < 1e-12)
    
    Return True

Process called "test_compute_backward_error_polynomial_roots" that takes no parameters returns Boolean:
    Note: Test backward error analysis for polynomial root finding
    Let polynomial_coefficients be [1.0, -3.0, 2.0] Note: p(x) = x² - 3x + 2 = (x-1)(x-2)
    Let computed_roots be [1.0, 2.0] Note: Exact roots
    
    Let backward_error be Stability.compute_backward_error_polynomial_roots(
        polynomial_coefficients, computed_roots)
    
    Assert.IsNotEmpty(backward_error.error_id)
    Assert.IsTrue(backward_error.backward_perturbation.contains_key("coefficient_perturbations"))
    
    Note: For exact roots, backward perturbations should be minimal
    Assert.IsTrue(backward_error.stability_radius < 1e-10)
    
    Return True

Process called "test_backward_stability_verification" that takes no parameters returns Boolean:
    Note: Test verification of backward stability for numerical algorithms
    Let algorithm_name be "gaussian_elimination_partial_pivoting"
    Let test_matrix be [[4.0, 3.0], [2.0, 1.0]]
    Let test_rhs be [7.0, 3.0]
    
    Let stability_verification be Stability.verify_backward_stability(
        algorithm_name, test_matrix, test_rhs)
    
    Assert.IsTrue(stability_verification.contains_key("backward_stable"))
    Assert.IsTrue(stability_verification.contains_key("stability_constant"))
    Assert.IsTrue(stability_verification.contains_key("error_growth_bound"))
    
    Note: Gaussian elimination with partial pivoting should be backward stable
    Assert.IsTrue(stability_verification["backward_stable"])
    
    Return True

Note: =====================================================================
Note: FORWARD ERROR ANALYSIS TESTS
Note: =====================================================================

Process called "test_analyze_forward_error_propagation" that takes no parameters returns Boolean:
    Note: Test forward error propagation analysis
    Let input_data be [1.0, 2.0, 3.0]
    Let input_perturbations be [0.01, -0.005, 0.002]
    Let operation be "matrix_vector_multiplication"
    
    Let forward_error be Stability.analyze_forward_error_propagation(
        input_data, input_perturbations, operation)
    
    Assert.IsNotEmpty(forward_error.error_id)
    Assert.AreEqual(forward_error.input_perturbation.size(), input_perturbations.length)
    Assert.IsTrue(forward_error.output_error.size() > 0)
    Assert.IsNotEmpty(forward_error.error_propagation)
    Assert.IsTrue(forward_error.amplification_bounds.contains_key("worst_case"))
    
    Return True

Process called "test_compute_forward_error_bounds" that takes no parameters returns Boolean:
    Note: Test computation of forward error bounds using condition numbers
    Let well_conditioned_matrix be [[2.0, 0.0], [0.0, 1.0]]
    Let input_error_magnitude be 0.01
    
    Let forward_bounds be Stability.compute_forward_error_bounds(
        well_conditioned_matrix, input_error_magnitude)
    
    Assert.IsTrue(forward_bounds.contains_key("absolute_error_bound"))
    Assert.IsTrue(forward_bounds.contains_key("relative_error_bound"))
    Assert.IsTrue(forward_bounds["absolute_error_bound"] >= 0.0)
    Assert.IsTrue(forward_bounds["relative_error_bound"] >= 0.0)
    
    Note: Forward error should be bounded by condition number times input error
    Let condition_number be Stability.compute_matrix_condition_number(well_conditioned_matrix, "2").condition_value
    Let expected_bound be condition_number * input_error_magnitude
    Assert.IsTrue(forward_bounds["relative_error_bound"] <= expected_bound * 1.1) Note: Allow small tolerance
    
    Return True

Process called "test_error_amplification_analysis" that takes no parameters returns Boolean:
    Note: Test analysis of error amplification through computational steps
    Let computational_steps be [
        ("matrix_multiplication", 2.0),
        ("linear_system_solve", 5.0),
        ("eigenvalue_computation", 10.0)
    ]
    
    Let amplification_analysis be Stability.analyze_error_amplification_chain(computational_steps)
    
    Assert.IsTrue(amplification_analysis.contains_key("cumulative_amplification"))
    Assert.IsTrue(amplification_analysis.contains_key("step_by_step_analysis"))
    Assert.IsTrue(amplification_analysis.contains_key("worst_case_scenario"))
    
    Note: Cumulative amplification should be product of individual factors
    Let expected_cumulative be 2.0 * 5.0 * 10.0
    Assert.IsTrue(AbsoluteValue(amplification_analysis["cumulative_amplification"] - expected_cumulative) < 1.0)
    
    Return True

Note: =====================================================================
Note: ALGORITHM STABILITY TESTS
Note: =====================================================================

Process called "test_classify_algorithm_stability_stable" that takes no parameters returns Boolean:
    Note: Test stability classification for stable algorithms
    Let stable_algorithms be ["qr_decomposition", "svd_decomposition", "cholesky_decomposition"]
    
    For algorithm in stable_algorithms:
        Let stability_classification be Stability.classify_algorithm_stability(algorithm)
        
        Assert.IsNotEmpty(stability_classification.algorithm_id)
        Assert.AreEqual(stability_classification.stability_type, "backward_stable")
        Assert.IsTrue(stability_classification.stability_constant < 10.0)
        Assert.IsTrue(stability_classification.growth_factor < 2.0)
        Assert.IsTrue(stability_classification.stability_verification)
    
    Return True

Process called "test_classify_algorithm_stability_unstable" that takes no parameters returns Boolean:
    Note: Test stability classification for potentially unstable algorithms
    Let unstable_algorithms be ["gaussian_elimination_no_pivoting", "normal_equations", "gram_schmidt_classical"]
    
    For algorithm in unstable_algorithms:
        Let stability_classification be Stability.classify_algorithm_stability(algorithm)
        
        Assert.IsNotEmpty(stability_classification.algorithm_id)
        Assert.IsTrue(stability_classification.stability_type = "unstable" OR 
                      stability_classification.stability_type = "conditionally_stable")
        Assert.IsTrue(stability_classification.growth_factor >= 1.0)
    
    Return True

Process called "test_compute_stability_constant" that takes no parameters returns Boolean:
    Note: Test computation of stability constants for numerical methods
    Let test_matrices be generate_test_matrices_well_conditioned()
    Let algorithm be "lu_decomposition_partial_pivoting"
    
    For matrix in test_matrices:
        Let stability_constant be Stability.compute_algorithm_stability_constant(algorithm, matrix)
        
        Assert.IsTrue(stability_constant > 0.0)
        Assert.IsTrue(stability_constant < 100.0) Note: Should be reasonable for well-conditioned matrices
    
    Return True

Note: =====================================================================
Note: NUMERICAL ERROR ANALYSIS TESTS
Note: =====================================================================

Process called "test_analyze_roundoff_error_accumulation" that takes no parameters returns Boolean:
    Note: Test analysis of round-off error accumulation in computations
    Let computation_sequence be [
        ("addition", 1000),
        ("multiplication", 500),
        ("division", 100)
    ]
    
    Let roundoff_analysis be Stability.analyze_roundoff_error_accumulation(computation_sequence)
    
    Assert.IsNotEmpty(roundoff_analysis.error_source)
    Assert.IsTrue(roundoff_analysis.machine_precision > 0.0)
    Assert.IsTrue(roundoff_analysis.error_accumulation.contains_key("total_error"))
    Assert.IsTrue(roundoff_analysis.propagation_analysis.size() > 0)
    Assert.IsTrue(roundoff_analysis.mitigation_strategies.length > 0)
    
    Return True

Process called "test_estimate_truncation_error" that takes no parameters returns Boolean:
    Note: Test truncation error estimation for series approximations
    Let series_function be "exp(x)"
    Let truncation_order be 5
    Let evaluation_point be 0.5
    Let step_size be 0.1
    
    Let truncation_error be Stability.estimate_truncation_error(
        series_function, truncation_order, evaluation_point, step_size)
    
    Assert.AreEqual(truncation_error.approximation_order, truncation_order)
    Assert.IsNotEmpty(truncation_error.error_estimate)
    Assert.IsNotEmpty(truncation_error.convergence_rate)
    Assert.IsNotEmpty(truncation_error.refinement_strategy)
    
    Return True

Process called "test_analyze_discretization_error" that takes no parameters returns Boolean:
    Note: Test discretization error analysis for numerical methods
    Let pde_scheme be "finite_difference_central"
    Let mesh_spacing be 0.01
    Let accuracy_order be 2
    
    Let discretization_error be Stability.analyze_discretization_error(
        pde_scheme, mesh_spacing, accuracy_order)
    
    Assert.AreEqual(discretization_error.discretization_scheme, pde_scheme)
    Assert.AreEqual(discretization_error.mesh_spacing, mesh_spacing)
    Assert.AreEqual(discretization_error.order_of_accuracy, accuracy_order)
    Assert.IsTrue(discretization_error.error_bounds.contains_key("leading_term"))
    Assert.IsTrue(discretization_error.grid_refinement_analysis.contains_key("convergence_rate"))
    
    Return True

Note: =====================================================================
Note: ITERATIVE METHOD STABILITY TESTS
Note: =====================================================================

Process called "test_analyze_iterative_method_stability" that takes no parameters returns Boolean:
    Note: Test stability analysis for iterative numerical methods
    Let iteration_matrix be [[0.5, 0.2], [0.1, 0.3]]
    Let method_name be "jacobi_iteration"
    Let convergence_tolerance be 1e-8
    
    Let iterative_stability be Stability.analyze_iterative_method_stability(
        method_name, iteration_matrix, convergence_tolerance)
    
    Assert.AreEqual(iterative_stability.iteration_method, method_name)
    Assert.AreEqual(iterative_stability.convergence_criterion, convergence_tolerance)
    Assert.IsTrue(iterative_stability.residual_analysis.contains_key("spectral_radius"))
    Assert.IsTrue(iterative_stability.error_reduction_rate > 0.0)
    Assert.IsTrue(iterative_stability.stopping_criterion.contains_key("tolerance"))
    
    Return True

Process called "test_compute_convergence_rate_iterative" that takes no parameters returns Boolean:
    Note: Test convergence rate computation for iterative methods
    Let residual_sequence be [1.0, 0.5, 0.25, 0.125, 0.0625]
    
    Let convergence_rate be Stability.compute_iterative_convergence_rate(residual_sequence)
    
    Assert.IsTrue(convergence_rate > 0.0)
    Assert.IsTrue(convergence_rate < 1.0) Note: Should be contractive
    
    Note: For this geometric sequence, rate should be approximately 0.5
    Assert.IsTrue(AbsoluteValue(convergence_rate - 0.5) < 0.1)
    
    Return True

Note: =====================================================================
Note: STABILITY VERIFICATION TESTS
Note: =====================================================================

Process called "test_verify_numerical_stability_comprehensive" that takes no parameters returns Boolean:
    Note: Test comprehensive numerical stability verification
    Let test_problem be "linear_system_solve"
    Let problem_parameters be Dictionary[String, Float]
    Set problem_parameters["matrix_size"] to 10.0
    Set problem_parameters["condition_number"] to 50.0
    
    Let stability_verification be Stability.verify_numerical_stability(test_problem, problem_parameters)
    
    Assert.IsTrue(stability_verification.contains_key("overall_stability"))
    Assert.IsTrue(stability_verification.contains_key("condition_analysis"))
    Assert.IsTrue(stability_verification.contains_key("error_bounds"))
    Assert.IsTrue(stability_verification.contains_key("recommendations"))
    
    Return True

Process called "test_stability_diagnosis_and_recommendations" that takes no parameters returns Boolean:
    Note: Test stability diagnosis and improvement recommendations
    Let ill_conditioned_matrix be [[1.0, 1.0], [1.0, 1.0001]]
    
    Let diagnosis be Stability.diagnose_stability_issues(ill_conditioned_matrix, "linear_solve")
    
    Assert.IsTrue(diagnosis.contains_key("identified_issues"))
    Assert.IsTrue(diagnosis.contains_key("severity_assessment"))
    Assert.IsTrue(diagnosis.contains_key("improvement_recommendations"))
    Assert.IsTrue(diagnosis.contains_key("alternative_methods"))
    
    Assert.IsTrue(Length(diagnosis["identified_issues"]) > 0)
    Assert.IsTrue(Length(diagnosis["improvement_recommendations"]) > 0)
    
    Return True

Note: =====================================================================
Note: ERROR HANDLING AND EDGE CASES TESTS
Note: =====================================================================

Process called "test_stability_analysis_invalid_input" that takes no parameters returns Boolean:
    Note: Test stability analysis with invalid input
    Let empty_matrix be List[List[Float]]()
    
    Try:
        Let invalid_condition be Stability.compute_matrix_condition_number(empty_matrix, "2")
        Return False
    Catch error:
        Assert.IsTrue(Contains(error.message, "empty") OR Contains(error.message, "matrix"))
    
    Let non_square_matrix be [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]
    
    Try:
        Let invalid_square be Stability.compute_matrix_condition_number(non_square_matrix, "2")
        Return False
    Catch error:
        Assert.IsTrue(Contains(error.message, "square") OR Contains(error.message, "matrix"))
    
    Return True

Process called "test_stability_analysis_singular_matrix" that takes no parameters returns Boolean:
    Note: Test stability analysis with singular matrices
    Let singular_matrix be [[1.0, 2.0], [2.0, 4.0]]
    
    Try:
        Let condition be Stability.compute_matrix_condition_number(singular_matrix, "2")
        Note: Should either handle gracefully or throw appropriate error
        If condition.stability_classification = "singular":
            Assert.IsTrue(condition.condition_value > 1e12)
        Return True
    Catch error:
        Assert.IsTrue(Contains(error.message, "singular") OR Contains(error.message, "invertible"))
        Return True
    
    Return True

Note: =====================================================================
Note: INTEGRATION TESTS
Note: =====================================================================

Process called "test_stability_analysis_integration_workflow" that takes no parameters returns Boolean:
    Note: Test complete stability analysis workflow integration
    Let test_matrix be [[3.0, 2.0], [1.0, 4.0]]
    
    Note: Step 1: Compute condition number
    Let condition_analysis be Stability.compute_matrix_condition_number(test_matrix, "2")
    Assert.IsTrue(assert_condition_number_valid(condition_analysis, condition_analysis.stability_classification))
    
    Note: Step 2: Perform perturbation analysis
    Let perturbed_matrix be create_perturbed_matrix(test_matrix, 0.01)
    Let rhs be [5.0, 7.0]
    Let perturbation_analysis be Stability.analyze_perturbation_sensitivity(test_matrix, rhs, perturbed_matrix, rhs)
    Assert.IsTrue(assert_perturbation_analysis_valid(perturbation_analysis))
    
    Note: Step 3: Verify consistency between analyses
    Let condition_amplification be condition_analysis.sensitivity_analysis["relative_error_amplification"]
    Let perturbation_amplification be perturbation_analysis.amplification_factor
    
    Note: Should be approximately consistent (within factor of 2)
    Assert.IsTrue(perturbation_amplification <= condition_amplification * 2.0)
    Assert.IsTrue(condition_amplification <= perturbation_amplification * 2.0)
    
    Return True

Process called "test_stability_method_comparison" that takes no parameters returns Boolean:
    Note: Test comparison of stability across different numerical methods
    Let test_matrix be [[4.0, 1.0], [1.0, 3.0]]
    Let methods be ["lu_decomposition", "qr_decomposition", "cholesky_decomposition"]
    
    Let stability_results be List[AlgorithmStability]()
    
    For method in methods:
        Let stability_analysis be Stability.classify_algorithm_stability(method)
        Call stability_results.add(stability_analysis)
    
    Note: All should be stable methods
    For stability in stability_results:
        Assert.IsTrue(stability.stability_type = "backward_stable" OR 
                      stability.stability_type = "numerically_stable")
        Assert.IsTrue(stability.stability_constant < 10.0)
        Assert.IsTrue(stability.growth_factor < 5.0)
    
    Return True

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all stability module tests
    Let tests_passed be 0
    Let tests_failed be 0
    
    Note: Condition number analysis tests
    Let condition_tests be [
        "test_compute_matrix_condition_number_well_conditioned",
        "test_compute_matrix_condition_number_ill_conditioned",
        "test_analyze_condition_number_interpretation",
        "test_condition_number_norm_consistency"
    ]
    
    Note: Perturbation analysis tests
    Let perturbation_tests be [
        "test_analyze_perturbation_sensitivity",
        "test_compute_perturbation_bounds",
        "test_linearized_perturbation_analysis"
    ]
    
    Note: Backward error analysis tests
    Let backward_error_tests be [
        "test_compute_backward_error_linear_system",
        "test_compute_backward_error_polynomial_roots",
        "test_backward_stability_verification"
    ]
    
    Note: Forward error analysis tests
    Let forward_error_tests be [
        "test_analyze_forward_error_propagation",
        "test_compute_forward_error_bounds",
        "test_error_amplification_analysis"
    ]
    
    Note: Algorithm stability tests
    Let algorithm_stability_tests be [
        "test_classify_algorithm_stability_stable",
        "test_classify_algorithm_stability_unstable",
        "test_compute_stability_constant"
    ]
    
    Note: Numerical error analysis tests
    Let error_analysis_tests be [
        "test_analyze_roundoff_error_accumulation",
        "test_estimate_truncation_error",
        "test_analyze_discretization_error"
    ]
    
    Note: Iterative method stability tests
    Let iterative_tests be [
        "test_analyze_iterative_method_stability",
        "test_compute_convergence_rate_iterative"
    ]
    
    Note: Stability verification tests
    Let verification_tests be [
        "test_verify_numerical_stability_comprehensive",
        "test_stability_diagnosis_and_recommendations"
    ]
    
    Note: Error handling tests
    Let error_handling_tests be [
        "test_stability_analysis_invalid_input",
        "test_stability_analysis_singular_matrix"
    ]
    
    Note: Integration tests
    Let integration_tests be [
        "test_stability_analysis_integration_workflow",
        "test_stability_method_comparison"
    ]
    
    Let all_test_groups be [condition_tests, perturbation_tests, backward_error_tests, forward_error_tests,
                           algorithm_stability_tests, error_analysis_tests, iterative_tests, verification_tests,
                           error_handling_tests, integration_tests]
    
    Let group_names be ["Condition Number Analysis", "Perturbation Analysis", "Backward Error Analysis", "Forward Error Analysis",
                       "Algorithm Stability", "Numerical Error Analysis", "Iterative Method Stability", "Stability Verification",
                       "Error Handling", "Integration Tests"]
    
    For group_index from 0 to Length(all_test_groups) - 1:
        Let test_group be all_test_groups[group_index]
        Let group_name be group_names[group_index]
        Print "Testing " + group_name + "..."
        
        For test_name in test_group:
            Try:
                Let test_result be Call test_name()
                If test_result:
                    Set tests_passed to tests_passed + 1
                    Print "  ✓ " + test_name
                Else:
                    Set tests_failed to tests_failed + 1  
                    Print "  ✗ " + test_name + " (returned false)"
            Catch error:
                Set tests_failed to tests_failed + 1
                Print "  ✗ " + test_name + " (error: " + error.message + ")"
    
    Let total_tests be tests_passed + tests_failed
    Print ""
    Print "Stability Module Test Results:"
    Print "=============================="
    Print "Tests passed: " + ToString(tests_passed)
    Print "Tests failed: " + ToString(tests_failed)
    Print "Total tests: " + ToString(total_tests)
    Print "Success rate: " + ToString((tests_passed * 100) / total_tests) + "%"
    
    Return tests_failed = 0