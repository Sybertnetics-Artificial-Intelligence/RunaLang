Note:
Unit tests for math/discrete/coding_theory.runa module
Testing error-correcting codes, information theory, channel coding,
finite field operations, and communication system analysis.
:End Note

Import "dev/test" as UnitTest
Import "collections" as Collections
Import "stdlib/math/discrete/coding_theory" as CodingTheory
Import "engine/linalg/core" as LinAlg

Note: =====================================================================
Note: TEST DATA GENERATORS
Note: =====================================================================

Process called "create_test_generator_matrix":
    Note: 7,4 Hamming code generator matrix
    Let matrix be List.create()
    List.push(matrix, List.from_array([1, 0, 0, 0, 1, 1, 0]))
    List.push(matrix, List.from_array([0, 1, 0, 0, 1, 0, 1]))
    List.push(matrix, List.from_array([0, 0, 1, 0, 0, 1, 1]))
    List.push(matrix, List.from_array([0, 0, 0, 1, 1, 1, 1]))
    Return matrix

Process called "create_test_parity_check_matrix":
    Note: Corresponding parity check matrix for 7,4 Hamming
    Let matrix be List.create()
    List.push(matrix, List.from_array([1, 1, 0, 1, 1, 0, 0]))
    List.push(matrix, List.from_array([1, 0, 1, 1, 0, 1, 0]))
    List.push(matrix, List.from_array([0, 1, 1, 1, 0, 0, 1]))
    Return matrix

Process called "create_test_messages":
    Let messages be List.create()
    List.push(messages, List.from_array([0, 0, 0, 0]))
    List.push(messages, List.from_array([1, 0, 0, 0]))
    List.push(messages, List.from_array([0, 1, 0, 0]))
    List.push(messages, List.from_array([1, 1, 0, 0]))
    List.push(messages, List.from_array([0, 0, 1, 0]))
    List.push(messages, List.from_array([1, 0, 1, 0]))
    List.push(messages, List.from_array([0, 1, 1, 0]))
    List.push(messages, List.from_array([1, 1, 1, 0]))
    List.push(messages, List.from_array([0, 0, 0, 1]))
    List.push(messages, List.from_array([1, 0, 0, 1]))
    List.push(messages, List.from_array([0, 1, 0, 1]))
    List.push(messages, List.from_array([1, 1, 0, 1]))
    List.push(messages, List.from_array([0, 0, 1, 1]))
    List.push(messages, List.from_array([1, 0, 1, 1]))
    List.push(messages, List.from_array([0, 1, 1, 1]))
    List.push(messages, List.from_array([1, 1, 1, 1]))
    Return messages

Process called "create_test_channel":
    Let noise_chars be Dictionary.create()
    Dictionary.set(noise_chars, "variance", 0.1)
    Dictionary.set(noise_chars, "mean", 0.0)
    
    Return CodingTheory.Channel with:
        channel_type: "BSC"
        error_probability: 0.01
        capacity: 0.92
        noise_characteristics: noise_chars
        modulation_scheme: "BPSK"
        bandwidth: 1000.0
        signal_to_noise_ratio: 10.0

Process called "create_single_error_patterns" that takes length as Integer returns List[List[Integer]]:
    Let patterns be List.create()
    For i from 0 to (length - 1):
        Let pattern be List.create()
        For j from 0 to (length - 1):
            If j == i:
                List.push(pattern, 1)
            Otherwise:
                List.push(pattern, 0)
        List.push(patterns, pattern)
    Return patterns

Process called "create_test_probabilities":
    Return List.from_array([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])

Note: =====================================================================
Note: ASSERTION HELPERS
Note: =====================================================================

Process called "assert_code_valid" that takes code as CodingTheory.Code, message as String:
    UnitTest.assert_true(code.block_length > 0, message + " - block length must be positive")
    UnitTest.assert_true(code.message_length > 0, message + " - message length must be positive")
    UnitTest.assert_true(code.message_length <= code.block_length, message + " - message length cannot exceed block length")
    UnitTest.assert_true(code.minimum_distance > 0, message + " - minimum distance must be positive")
    UnitTest.assert_true(code.code_rate >= 0.0 and code.code_rate <= 1.0, message + " - code rate must be in [0,1]")

Process called "assert_matrix_valid" that takes matrix as List[List[Integer]], rows as Integer, cols as Integer, message as String:
    UnitTest.assert_equals(List.size(matrix), rows, message + " - incorrect number of rows")
    For each row in matrix:
        UnitTest.assert_equals(List.size(row), cols, message + " - incorrect number of columns")

Process called "assert_codeword_valid" that takes codeword as List[Integer], expected_length as Integer, message as String:
    UnitTest.assert_equals(List.size(codeword), expected_length, message + " - incorrect codeword length")
    For each bit in codeword:
        UnitTest.assert_true(bit == 0 or bit == 1, message + " - codeword bits must be binary")

Process called "assert_syndrome_zero" that takes syndrome as List[Integer], message as String:
    For each value in syndrome:
        UnitTest.assert_equals(value, 0, message + " - syndrome should be zero for valid codeword")

Process called "assert_decoding_result_valid" that takes result as CodingTheory.DecodingResult, message as String:
    UnitTest.assert_false(List.is_empty(result.received_word), message + " - received word cannot be empty")
    UnitTest.assert_false(List.is_empty(result.decoded_word), message + " - decoded word cannot be empty")
    UnitTest.assert_true(result.errors_corrected >= 0, message + " - errors corrected cannot be negative")
    UnitTest.assert_true(result.confidence_measure >= 0.0 and result.confidence_measure <= 1.0, message + " - confidence must be in [0,1]")

Process called "assert_float_approximately_equals" that takes actual as Float, expected as Float, tolerance as Float, message as String:
    Let difference be Float.absolute_value(actual - expected)
    UnitTest.assert_true(difference <= tolerance, message + " - values differ by more than tolerance")

Note: =====================================================================
Note: LINEAR CODE TESTS
Note: =====================================================================

Process called "test_create_linear_code":
    Let generator_matrix be create_test_generator_matrix()
    Let code be CodingTheory.create_linear_code(generator_matrix, 7, 4)
    
    assert_code_valid(code, "Linear code creation")
    UnitTest.assert_equals(code.block_length, 7, "Block length should be 7")
    UnitTest.assert_equals(code.message_length, 4, "Message length should be 4")
    assert_float_approximately_equals(code.code_rate, 0.571, 0.001, "Code rate should be 4/7")

Process called "test_compute_parity_check_matrix":
    Let generator_matrix be create_test_generator_matrix()
    Let parity_check be CodingTheory.compute_parity_check_matrix(generator_matrix, 7, 4)
    
    assert_matrix_valid(parity_check, 3, 7, "Parity check matrix")
    
    Note: Verify GH^T = 0 property
    Let product be LinAlg.matrix_multiply(generator_matrix, LinAlg.matrix_transpose(parity_check))
    For each row in product:
        For each element in row:
            UnitTest.assert_equals(Integer.modulo(element, 2), 0, "GH^T should be zero matrix mod 2")

Process called "test_encode_message":
    Let generator_matrix be create_test_generator_matrix()
    Let code be CodingTheory.create_linear_code(generator_matrix, 7, 4)
    Let message be List.from_array([1, 0, 1, 0])
    Let encoded be CodingTheory.encode_message(code, message)
    
    assert_codeword_valid(encoded, 7, "Encoded message")
    
    Let syndrome be CodingTheory.compute_syndrome(code, encoded)
    assert_syndrome_zero(syndrome, "Valid codeword syndrome")

Process called "test_compute_minimum_distance":
    Let generator_matrix be create_test_generator_matrix()
    Let code be CodingTheory.create_linear_code(generator_matrix, 7, 4)
    Let distance be CodingTheory.compute_minimum_distance(code)
    
    UnitTest.assert_equals(distance, 3, "Hamming code should have minimum distance 3")
    UnitTest.assert_equals(code.error_correction_capability, 1, "Should correct 1 error")

Process called "test_linear_code_systematic":
    Let messages be create_test_messages()
    Let generator_matrix be create_test_generator_matrix()
    Let code be CodingTheory.create_linear_code(generator_matrix, 7, 4)
    
    For each message in messages:
        Let encoded be CodingTheory.encode_message(code, message)
        
        Note: Check systematic property - first k bits should be message
        For i from 0 to 3:
            UnitTest.assert_equals(List.get(encoded, i), List.get(message, i), "Systematic encoding property")

Note: =====================================================================
Note: HAMMING CODE TESTS
Note: =====================================================================

Process called "test_create_hamming_code":
    Let hamming_code be CodingTheory.create_hamming_code(3)
    
    assert_code_valid(hamming_code, "Hamming code creation")
    UnitTest.assert_equals(hamming_code.block_length, 7, "Hamming(7,4) block length")
    UnitTest.assert_equals(hamming_code.message_length, 4, "Hamming(7,4) message length")
    UnitTest.assert_equals(hamming_code.minimum_distance, 3, "Hamming minimum distance")

Process called "test_create_extended_hamming_code":
    Let extended_hamming be CodingTheory.create_extended_hamming_code(3)
    
    assert_code_valid(extended_hamming, "Extended Hamming code")
    UnitTest.assert_equals(extended_hamming.block_length, 8, "Extended Hamming(8,4) block length")
    UnitTest.assert_equals(extended_hamming.minimum_distance, 4, "Extended Hamming minimum distance")

Process called "test_decode_hamming_syndrome":
    Let hamming_code be CodingTheory.create_hamming_code(3)
    Let message be List.from_array([1, 0, 1, 1])
    Let encoded be CodingTheory.encode_message(hamming_code, message)
    
    Note: Introduce single bit error
    Let received be List.copy(encoded)
    Let error_position be 2
    List.set(received, error_position, 1 - List.get(received, error_position))
    
    Let decoded_result be CodingTheory.decode_hamming_syndrome(hamming_code, received)
    
    assert_decoding_result_valid(decoded_result, "Hamming syndrome decoding")
    UnitTest.assert_true(decoded_result.decoding_successful, "Should successfully decode single error")
    UnitTest.assert_equals(decoded_result.errors_corrected, 1, "Should correct exactly one error")
    UnitTest.assert_equals(decoded_result.decoded_word, encoded, "Should recover original codeword")

Process called "test_hamming_error_detection":
    Let hamming_code be CodingTheory.create_hamming_code(3)
    Let message be List.from_array([0, 1, 1, 0])
    Let encoded be CodingTheory.encode_message(hamming_code, message)
    
    Note: Introduce double bit error (undetectable by Hamming)
    Let received be List.copy(encoded)
    List.set(received, 0, 1 - List.get(received, 0))
    List.set(received, 1, 1 - List.get(received, 1))
    
    Let decoded_result be CodingTheory.decode_hamming_syndrome(hamming_code, received)
    UnitTest.assert_false(decoded_result.decoding_successful, "Should fail to decode double error")

Process called "test_analyze_hamming_performance":
    Let hamming_code be CodingTheory.create_hamming_code(3)
    Let channel be create_test_channel()
    Let analysis be CodingTheory.analyze_hamming_performance(hamming_code, channel)
    
    UnitTest.assert_true(Dictionary.has_key(analysis, "bit_error_rate"), "Should analyze bit error rate")
    UnitTest.assert_true(Dictionary.has_key(analysis, "word_error_rate"), "Should analyze word error rate")
    UnitTest.assert_true(Dictionary.has_key(analysis, "coding_gain"), "Should compute coding gain")

Note: =====================================================================
Note: REED-SOLOMON CODE TESTS
Note: =====================================================================

Process called "test_create_reed_solomon_code":
    Let rs_code be CodingTheory.create_reed_solomon_code(15, 11, 8)
    
    assert_code_valid(rs_code, "Reed-Solomon code creation")
    UnitTest.assert_equals(rs_code.block_length, 15, "RS(15,11) block length")
    UnitTest.assert_equals(rs_code.message_length, 11, "RS(15,11) message length")
    UnitTest.assert_equals(rs_code.minimum_distance, 5, "RS minimum distance should be n-k+1")

Process called "test_encode_reed_solomon":
    Let rs_code be CodingTheory.create_reed_solomon_code(7, 3, 8)
    Let message be List.from_array([1, 2, 3])
    Let encoded be CodingTheory.encode_reed_solomon(rs_code, message)
    
    assert_codeword_valid(encoded, 7, "RS encoded message")
    
    Note: Check systematic property for RS codes
    For i from 0 to 2:
        UnitTest.assert_equals(List.get(encoded, i), List.get(message, i), "RS systematic encoding")

Process called "test_decode_reed_solomon_berlekamp_massey":
    Let rs_code be CodingTheory.create_reed_solomon_code(7, 3, 8)
    Let message be List.from_array([1, 2, 3])
    Let encoded be CodingTheory.encode_reed_solomon(rs_code, message)
    
    Note: Introduce correctable errors
    Let received be List.copy(encoded)
    List.set(received, 3, 7)  Note: Change parity symbol
    List.set(received, 4, 6)  Note: Change another parity symbol
    
    Let decoded_result be CodingTheory.decode_reed_solomon_berlekamp_massey(rs_code, received)
    
    assert_decoding_result_valid(decoded_result, "RS Berlekamp-Massey decoding")
    UnitTest.assert_true(decoded_result.decoding_successful, "Should decode correctable errors")
    UnitTest.assert_equals(decoded_result.errors_corrected, 2, "Should correct 2 errors")

Process called "test_decode_reed_solomon_euclidean":
    Let rs_code be CodingTheory.create_reed_solomon_code(7, 3, 8)
    Let message be List.from_array([2, 1, 4])
    Let encoded be CodingTheory.encode_reed_solomon(rs_code, message)
    
    Note: Single symbol error
    Let received be List.copy(encoded)
    List.set(received, 5, 0)
    
    Let decoded_result be CodingTheory.decode_reed_solomon_euclidean(rs_code, received)
    
    assert_decoding_result_valid(decoded_result, "RS Euclidean decoding")
    UnitTest.assert_true(decoded_result.decoding_successful, "Should decode single error")
    UnitTest.assert_equals(decoded_result.decoded_word, encoded, "Should recover original codeword")

Process called "test_find_primitive_polynomial":
    Let poly be CodingTheory.find_primitive_polynomial(3, 8)
    UnitTest.assert_false(List.is_empty(poly), "Should find primitive polynomial for GF(8)")
    
    Let is_primitive be CodingTheory.is_primitive_polynomial(poly, 8)
    UnitTest.assert_true(is_primitive, "Found polynomial should be primitive")

Process called "test_reed_solomon_error_bounds":
    Let rs_code be CodingTheory.create_reed_solomon_code(15, 9, 16)
    Let max_correctable be (rs_code.minimum_distance - 1) / 2
    
    UnitTest.assert_equals(max_correctable, 3, "RS(15,9) should correct 3 errors")
    
    Let message be List.from_array([1, 2, 3, 4, 5, 6, 7, 8, 9])
    Let encoded be CodingTheory.encode_reed_solomon(rs_code, message)
    
    Note: Test maximum correctable errors
    Let received be List.copy(encoded)
    For i from 9 to 11:  Note: Corrupt 3 parity symbols
        List.set(received, i, 15)
    
    Let decoded_result be CodingTheory.decode_reed_solomon_berlekamp_massey(rs_code, received)
    UnitTest.assert_true(decoded_result.decoding_successful, "Should decode at error correction limit")

Note: =====================================================================
Note: BCH CODE TESTS
Note: =====================================================================

Process called "test_create_bch_code":
    Let bch_code be CodingTheory.create_bch_code(15, 5)
    
    assert_code_valid(bch_code, "BCH code creation")
    UnitTest.assert_equals(bch_code.block_length, 15, "BCH(15,5) block length")
    UnitTest.assert_true(bch_code.minimum_distance >= 5, "BCH minimum distance should be at least designed distance")

Process called "test_find_bch_generator_polynomial":
    Let gen_poly be CodingTheory.find_bch_generator_polynomial(15, 5, 2)
    UnitTest.assert_false(List.is_empty(gen_poly), "Should find BCH generator polynomial")
    
    Note: Generator polynomial degree should be n - k
    Let expected_degree be 15 - 11  Note: BCH(15,11) for t=1
    UnitTest.assert_true(List.size(gen_poly) >= expected_degree, "Generator polynomial degree")

Process called "test_decode_bch_syndrome":
    Let bch_code be CodingTheory.create_bch_code(15, 3)
    Let message be create_bch_test_message()
    Let encoded be CodingTheory.encode_message(bch_code, message)
    
    Note: Single error injection
    Let received be List.copy(encoded)
    List.set(received, 7, 1 - List.get(received, 7))
    
    Let decoded_result be CodingTheory.decode_bch_syndrome(bch_code, received)
    
    assert_decoding_result_valid(decoded_result, "BCH syndrome decoding")
    UnitTest.assert_true(decoded_result.decoding_successful, "Should decode single error")

Process called "test_analyze_bch_bounds":
    Let bounds be CodingTheory.analyze_bch_bounds(31, 7, 2)
    
    UnitTest.assert_true(Dictionary.has_key(bounds, "singleton_bound"), "Should compute Singleton bound")
    UnitTest.assert_true(Dictionary.has_key(bounds, "hamming_bound"), "Should compute Hamming bound")
    UnitTest.assert_true(Dictionary.has_key(bounds, "plotkin_bound"), "Should compute Plotkin bound")

Process called "create_bch_test_message":
    Return List.from_array([1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1])

Note: =====================================================================
Note: CONVOLUTIONAL CODE TESTS
Note: =====================================================================

Process called "test_create_convolutional_code":
    Let generator_polys be List.from_array([List.from_array([1, 0, 1]), List.from_array([1, 1, 1])])
    Let conv_code be CodingTheory.create_convolutional_code(generator_polys, 3, 2)
    
    UnitTest.assert_true(Dictionary.has_key(conv_code, "generator_polynomials"), "Should have generator polynomials")
    UnitTest.assert_true(Dictionary.has_key(conv_code, "constraint_length"), "Should have constraint length")
    UnitTest.assert_true(Dictionary.has_key(conv_code, "code_rate"), "Should have code rate")

Process called "test_encode_convolutional":
    Let generator_polys be List.from_array([List.from_array([1, 0, 1]), List.from_array([1, 1, 1])])
    Let conv_code be CodingTheory.create_convolutional_code(generator_polys, 3, 2)
    Let message be List.from_array([1, 1, 0, 1])
    
    Let encoded be CodingTheory.encode_convolutional(conv_code, message)
    UnitTest.assert_true(List.size(encoded) > List.size(message), "Encoded should be longer than message")

Process called "test_decode_viterbi":
    Let generator_polys be List.from_array([List.from_array([1, 1, 1]), List.from_array([1, 0, 1])])
    Let conv_code be CodingTheory.create_convolutional_code(generator_polys, 3, 2)
    Let message be List.from_array([1, 0, 1])
    
    Let encoded = CodingTheory.encode_convolutional(conv_code, message)
    
    Note: Add noise to encoded sequence
    Let received be List.copy(encoded)
    If List.size(received) > 2:
        List.set(received, 2, 1 - List.get(received, 2))
    
    Let decoded_result be CodingTheory.decode_viterbi(conv_code, received)
    assert_decoding_result_valid(decoded_result, "Viterbi decoding")

Process called "test_compute_convolutional_free_distance":
    Let generator_polys be List.from_array([List.from_array([1, 1, 1]), List.from_array([1, 0, 1])])
    Let conv_code be CodingTheory.create_convolutional_code(generator_polys, 3, 2)
    
    Let free_distance be CodingTheory.compute_convolutional_free_distance(conv_code, 100)
    UnitTest.assert_true(free_distance > 0, "Free distance should be positive")
    UnitTest.assert_true(free_distance >= 3, "Should have reasonable free distance")

Note: =====================================================================
Note: SYNDROME DECODING TESTS
Note: =====================================================================

Process called "test_compute_syndrome":
    Let generator_matrix be create_test_generator_matrix()
    Let code be CodingTheory.create_linear_code(generator_matrix, 7, 4)
    Let message be List.from_array([1, 1, 0, 1])
    Let encoded be CodingTheory.encode_message(code, message)
    
    Let syndrome be CodingTheory.compute_syndrome(code, encoded)
    assert_syndrome_zero(syndrome, "Valid codeword syndrome")
    
    Note: Test error syndrome
    Let received_with_error be List.copy(encoded)
    List.set(received_with_error, 1, 1 - List.get(received_with_error, 1))
    
    Let error_syndrome be CodingTheory.compute_syndrome(code, received_with_error)
    UnitTest.assert_false(List.all_equal(error_syndrome, List.from_array([0, 0, 0])), "Error syndrome should be non-zero")

Process called "test_create_syndrome_table":
    Let generator_matrix be create_test_generator_matrix()
    Let code be CodingTheory.create_linear_code(generator_matrix, 7, 4)
    Let syndrome_table be CodingTheory.create_syndrome_table(code)
    
    UnitTest.assert_true(Dictionary.size(syndrome_table) > 0, "Syndrome table should have entries")
    UnitTest.assert_true(Dictionary.size(syndrome_table) <= 8, "Syndrome table should have at most 2^(n-k) entries")

Process called "test_decode_standard_array":
    Let generator_matrix be create_test_generator_matrix()
    Let code be CodingTheory.create_linear_code(generator_matrix, 7, 4)
    Let message be List.from_array([0, 1, 0, 1])
    Let encoded be CodingTheory.encode_message(code, message)
    
    Let single_errors be create_single_error_patterns(7)
    For each error_pattern in single_errors:
        Let received be add_error_pattern(encoded, error_pattern)
        Let decoded_result be CodingTheory.decode_standard_array(code, received)
        
        assert_decoding_result_valid(decoded_result, "Standard array decoding")
        UnitTest.assert_true(decoded_result.decoding_successful, "Should decode correctable error")

Process called "test_decode_nearest_neighbor":
    Let generator_matrix be create_test_generator_matrix()
    Let code be CodingTheory.create_linear_code(generator_matrix, 7, 4)
    Let encoded be CodingTheory.encode_message(code, List.from_array([1, 0, 0, 1]))
    
    Let received_with_error be List.copy(encoded)
    List.set(received_with_error, 3, 1 - List.get(received_with_error, 3))
    
    Let decoded_result be CodingTheory.decode_nearest_neighbor(code, received_with_error)
    assert_decoding_result_valid(decoded_result, "Nearest neighbor decoding")
    UnitTest.assert_equals(decoded_result.decoded_word, encoded, "Should find nearest codeword")

Process called "add_error_pattern" that takes codeword as List[Integer], error_pattern as List[Integer] returns List[Integer]:
    Let result be List.create()
    For i from 0 to (List.size(codeword) - 1):
        Let bit be List.get(codeword, i)
        Let error be List.get(error_pattern, i)
        List.push(result, Integer.modulo(bit + error, 2))
    Return result

Note: =====================================================================
Note: ERROR DETECTION TESTS
Note: =====================================================================

Process called "test_compute_checksum":
    Let data be List.from_array([1, 2, 3, 4, 5])
    Let checksum be CodingTheory.compute_checksum(data, "sum")
    
    UnitTest.assert_true(checksum > 0, "Checksum should be positive")
    
    Let xor_checksum be CodingTheory.compute_checksum(data, "xor")
    UnitTest.assert_true(xor_checksum >= 0, "XOR checksum should be non-negative")

Process called "test_compute_crc":
    Let data be List.from_array([1, 1, 0, 1, 0, 0, 1])
    Let generator_poly be List.from_array([1, 0, 0, 1, 1])  Note: CRC-4
    
    Let crc be CodingTheory.compute_crc(data, generator_poly)
    UnitTest.assert_false(List.is_empty(crc), "CRC should produce check bits")
    UnitTest.assert_equals(List.size(crc), 4, "CRC-4 should produce 4 bits")

Process called "test_verify_error_detection":
    Let data be List.from_array([1, 0, 1, 1])
    Let generator_poly be List.from_array([1, 0, 1, 1])
    Let codeword be CodingTheory.compute_crc(data, generator_poly)
    
    Let verification be CodingTheory.verify_error_detection(codeword, generator_poly)
    UnitTest.assert_true(verification, "Valid CRC codeword should verify")
    
    Note: Test error detection
    Let corrupted be List.copy(codeword)
    List.set(corrupted, 0, 1 - List.get(corrupted, 0))
    
    Let error_verification be CodingTheory.verify_error_detection(corrupted, generator_poly)
    UnitTest.assert_false(error_verification, "Corrupted codeword should fail verification")

Process called "test_analyze_detection_capability":
    Let generator_poly be List.from_array([1, 0, 0, 1, 1])
    Let analysis be CodingTheory.analyze_detection_capability(generator_poly, 1000)
    
    UnitTest.assert_true(Dictionary.has_key(analysis, "undetected_error_probability"), "Should analyze undetected errors")
    UnitTest.assert_true(Dictionary.has_key(analysis, "burst_error_detection"), "Should analyze burst detection")

Note: =====================================================================
Note: INFORMATION THEORY TESTS
Note: =====================================================================

Process called "test_compute_entropy":
    Let probabilities be List.from_array([0.5, 0.5])
    Let entropy be CodingTheory.compute_entropy(probabilities)
    
    assert_float_approximately_equals(entropy, 1.0, 0.001, "Binary uniform source should have entropy 1")
    
    Let biased_probs be List.from_array([0.9, 0.1])
    Let biased_entropy be CodingTheory.compute_entropy(biased_probs)
    UnitTest.assert_true(biased_entropy < 1.0, "Biased source should have lower entropy")

Process called "test_compute_mutual_information":
    Let joint_probs be create_joint_probability_matrix()
    Let mutual_info be CodingTheory.compute_mutual_information(joint_probs)
    
    UnitTest.assert_true(mutual_info >= 0.0, "Mutual information should be non-negative")
    UnitTest.assert_true(mutual_info <= 1.0, "Mutual information should be bounded")

Process called "test_compute_channel_capacity":
    Let channel be create_test_channel()
    Let capacity be CodingTheory.compute_channel_capacity(channel)
    
    assert_float_approximately_equals(capacity, 0.92, 0.1, "BSC capacity should match theoretical")
    UnitTest.assert_true(capacity >= 0.0 and capacity <= 1.0, "Capacity should be in [0,1]")

Process called "test_analyze_source_coding":
    Let source_probs be List.from_array([0.4, 0.3, 0.2, 0.1])
    Let analysis be CodingTheory.analyze_source_coding(source_probs)
    
    UnitTest.assert_true(Dictionary.has_key(analysis, "entropy"), "Should compute source entropy")
    UnitTest.assert_true(Dictionary.has_key(analysis, "average_codeword_length"), "Should analyze average length")
    UnitTest.assert_true(Dictionary.has_key(analysis, "compression_efficiency"), "Should analyze efficiency")

Process called "create_joint_probability_matrix":
    Let matrix be List.create()
    List.push(matrix, List.from_array([0.4, 0.1]))
    List.push(matrix, List.from_array([0.1, 0.4]))
    Return matrix

Note: =====================================================================
Note: CHANNEL CODING TESTS
Note: =====================================================================

Process called "test_analyze_channel_coding_theorem":
    Let channel be create_test_channel()
    Let code_rate be 0.5
    Let analysis be CodingTheory.analyze_channel_coding_theorem(channel, code_rate)
    
    UnitTest.assert_true(Dictionary.has_key(analysis, "achievability"), "Should test achievability")
    UnitTest.assert_true(Dictionary.has_key(analysis, "error_probability_bound"), "Should provide error bounds")

Process called "test_compute_error_probability_bounds":
    Let hamming_code be CodingTheory.create_hamming_code(3)
    Let channel be create_test_channel()
    Let bounds be CodingTheory.compute_error_probability_bounds(hamming_code, channel)
    
    UnitTest.assert_true(Dictionary.has_key(bounds, "union_bound"), "Should compute union bound")
    UnitTest.assert_true(Dictionary.has_key(bounds, "sphere_packing_bound"), "Should compute sphere packing bound")

Process called "test_optimize_code_parameters":
    Let requirements be Dictionary.from_entries([
        ["target_error_rate", 0.001],
        ["minimum_code_rate", 0.5],
        ["maximum_complexity", 1000]
    ])
    
    Let optimized be CodingTheory.optimize_code_parameters(requirements)
    
    UnitTest.assert_true(Dictionary.has_key(optimized, "recommended_code"), "Should recommend code type")
    UnitTest.assert_true(Dictionary.has_key(optimized, "parameters"), "Should provide parameters")

Process called "test_simulate_coded_communication":
    Let hamming_code be CodingTheory.create_hamming_code(3)
    Let channel be create_test_channel()
    Let num_trials be 1000
    
    Let simulation be CodingTheory.simulate_coded_communication(hamming_code, channel, num_trials)
    
    UnitTest.assert_true(Dictionary.has_key(simulation, "bit_error_rate"), "Should measure bit error rate")
    UnitTest.assert_true(Dictionary.has_key(simulation, "block_error_rate"), "Should measure block error rate")
    UnitTest.assert_true(Dictionary.has_key(simulation, "throughput"), "Should measure throughput")

Note: =====================================================================
Note: FINITE FIELD TESTS
Note: =====================================================================

Process called "test_construct_finite_field":
    Let field be CodingTheory.construct_finite_field(8)
    
    UnitTest.assert_true(Dictionary.has_key(field, "field_size"), "Should have field size")
    UnitTest.assert_true(Dictionary.has_key(field, "primitive_polynomial"), "Should have primitive polynomial")
    UnitTest.assert_true(Dictionary.has_key(field, "generator_element"), "Should have generator element")

Process called "test_multiply_and_reduce_polynomials":
    Let poly1 be List.from_array([1, 0, 1])
    Let poly2 be List.from_array([1, 1, 0])
    Let modulus be List.from_array([1, 0, 1, 1])
    
    Let result be CodingTheory.multiply_and_reduce_polynomials(poly1, poly2, modulus)
    UnitTest.assert_false(List.is_empty(result), "Polynomial multiplication should produce result")
    UnitTest.assert_true(List.size(result) < List.size(modulus), "Result should be reduced modulo")

Process called "test_find_primitive_element":
    Let field_size be 8
    Let primitive_element be CodingTheory.find_primitive_element(field_size)
    
    UnitTest.assert_true(primitive_element > 0, "Primitive element should be positive")
    UnitTest.assert_true(primitive_element < field_size, "Primitive element should be in field")

Process called "test_compute_element_order":
    Let element be 3
    Let field_size be 8
    Let order be CodingTheory.compute_element_order(element, field_size)
    
    UnitTest.assert_true(order > 0, "Element order should be positive")
    UnitTest.assert_true(order <= field_size - 1, "Order should divide field order")

Process called "test_compute_minimal_polynomials":
    Let field_size be 8
    Let minimal_polys be CodingTheory.compute_minimal_polynomials(field_size)
    
    UnitTest.assert_false(Dictionary.is_empty(minimal_polys), "Should find minimal polynomials")
    UnitTest.assert_true(Dictionary.size(minimal_polys) > 0, "Should have multiple minimal polynomials")

Note: =====================================================================
Note: CONCATENATED CODE TESTS
Note: =====================================================================

Process called "test_create_concatenated_code":
    Let outer_code be CodingTheory.create_reed_solomon_code(7, 3, 8)
    Let inner_code be CodingTheory.create_hamming_code(3)
    
    Let concat_code be CodingTheory.create_concatenated_code(outer_code, inner_code)
    
    UnitTest.assert_true(Dictionary.has_key(concat_code, "outer_code"), "Should have outer code")
    UnitTest.assert_true(Dictionary.has_key(concat_code, "inner_code"), "Should have inner code")
    UnitTest.assert_true(Dictionary.has_key(concat_code, "overall_rate"), "Should compute overall rate")

Process called "test_decode_concatenated_iterative":
    Let outer_code be CodingTheory.create_reed_solomon_code(7, 5, 8)
    Let inner_code be CodingTheory.create_hamming_code(3)
    Let concat_code be CodingTheory.create_concatenated_code(outer_code, inner_code)
    
    Let message be List.from_array([1, 2, 3, 4, 5])
    Let encoded_outer be CodingTheory.encode_reed_solomon(outer_code, message)
    
    Note: Simulate concatenated encoding and decoding
    Let received be simulate_channel_errors(encoded_outer, 0.02)
    Let decoded_result be CodingTheory.decode_concatenated_iterative(concat_code, received, 5)
    
    assert_decoding_result_valid(decoded_result, "Concatenated iterative decoding")

Process called "test_analyze_concatenated_performance":
    Let outer_code be CodingTheory.create_reed_solomon_code(15, 9, 16)
    Let inner_code be CodingTheory.create_bch_code(31, 5)
    Let concat_code be CodingTheory.create_concatenated_code(outer_code, inner_code)
    
    Let channel be create_test_channel()
    Let performance be CodingTheory.analyze_concatenated_performance(concat_code, channel)
    
    UnitTest.assert_true(Dictionary.has_key(performance, "inner_performance"), "Should analyze inner code")
    UnitTest.assert_true(Dictionary.has_key(performance, "outer_performance"), "Should analyze outer code")
    UnitTest.assert_true(Dictionary.has_key(performance, "overall_performance"), "Should analyze overall performance")

Process called "simulate_channel_errors" that takes data as List[Integer], error_rate as Float returns List[Integer]:
    Let result be List.copy(data)
    For i from 0 to (List.size(data) - 1):
        If Float.random() < error_rate:
            List.set(result, i, Integer.random_range(0, 7))
    Return result

Note: =====================================================================
Note: LDPC CODE TESTS
Note: =====================================================================

Process called "test_create_ldpc_code":
    Let ldpc_code be CodingTheory.create_ldpc_code(1024, 512, 3, 6)
    
    UnitTest.assert_true(Dictionary.has_key(ldpc_code, "parity_check_matrix"), "Should have parity check matrix")
    UnitTest.assert_true(Dictionary.has_key(ldpc_code, "variable_degree"), "Should have variable degree")
    UnitTest.assert_true(Dictionary.has_key(ldpc_code, "check_degree"), "Should have check degree")

Process called "test_construct_ldpc_regular":
    Let regular_ldpc be CodingTheory.construct_ldpc_regular(200, 100, 3)
    
    UnitTest.assert_true(Dictionary.has_key(regular_ldpc, "block_length"), "Should have block length")
    UnitTest.assert_equals(Dictionary.get_integer(regular_ldpc, "block_length"), 200, "Block length should be 200")

Process called "test_decode_ldpc_belief_propagation":
    Let ldpc_code be CodingTheory.create_ldpc_code(100, 50, 3, 6)
    Let message be create_random_binary_message(50)
    
    Note: Simulate LDPC encoding and channel transmission
    Let received be simulate_bsc_transmission(message, 0.05)
    Let decoded_result be CodingTheory.decode_ldpc_belief_propagation(ldpc_code, received, 20)
    
    assert_decoding_result_valid(decoded_result, "LDPC belief propagation decoding")

Process called "test_analyze_ldpc_graph_properties":
    Let ldpc_code be CodingTheory.construct_ldpc_regular(1000, 500, 4)
    Let analysis be CodingTheory.analyze_ldpc_graph_properties(ldpc_code)
    
    UnitTest.assert_true(Dictionary.has_key(analysis, "girth"), "Should compute graph girth")
    UnitTest.assert_true(Dictionary.has_key(analysis, "degree_distribution"), "Should analyze degree distribution")
    UnitTest.assert_true(Dictionary.has_key(analysis, "connectivity"), "Should analyze connectivity")

Process called "create_random_binary_message" that takes length as Integer returns List[Integer]:
    Let message be List.create()
    For i from 0 to (length - 1):
        List.push(message, Integer.random_range(0, 1))
    Return message

Process called "simulate_bsc_transmission" that takes data as List[Integer], error_prob as Float returns List[Integer]:
    Let result be List.copy(data)
    For i from 0 to (List.size(data) - 1):
        If Float.random() < error_prob:
            List.set(result, i, 1 - List.get(result, i))
    Return result

Note: =====================================================================
Note: POLAR CODE TESTS
Note: =====================================================================

Process called "test_create_polar_code":
    Let polar_code be CodingTheory.create_polar_code(8, 4, 0.1)
    
    UnitTest.assert_true(Dictionary.has_key(polar_code, "block_length"), "Should have block length")
    UnitTest.assert_true(Dictionary.has_key(polar_code, "information_set"), "Should have information set")
    UnitTest.assert_true(Dictionary.has_key(polar_code, "frozen_set"), "Should have frozen set")

Process called "test_compute_channel_polarization":
    Let channel_params be Dictionary.from_entries([["type", "BSC"], ["error_probability", 0.1]])
    Let polarization be CodingTheory.compute_channel_polarization(channel_params, 8)
    
    UnitTest.assert_true(Dictionary.has_key(polarization, "channel_reliabilities"), "Should compute reliabilities")
    UnitTest.assert_true(Dictionary.has_key(polarization, "information_indices"), "Should identify good channels")

Process called "test_decode_polar_successive_cancellation":
    Let polar_code be CodingTheory.create_polar_code(8, 4, 0.1)
    Let message be List.from_array([1, 0, 1, 1])
    
    Note: Simulate polar encoding and transmission
    Let llr_values be create_test_llr_values(8)
    Let decoded_result be CodingTheory.decode_polar_successive_cancellation(polar_code, llr_values)
    
    assert_decoding_result_valid(decoded_result, "Polar SC decoding")

Process called "test_decode_polar_list":
    Let polar_code be CodingTheory.create_polar_code(8, 4, 0.1)
    Let llr_values be create_test_llr_values(8)
    Let list_size be 4
    
    Let decoded_result be CodingTheory.decode_polar_list(polar_code, llr_values, list_size)
    
    assert_decoding_result_valid(decoded_result, "Polar list decoding")
    UnitTest.assert_true(decoded_result.confidence_measure > 0.0, "List decoding should provide confidence")

Process called "test_compute_polar_llr":
    Let received_bits be List.from_array([0.9, -0.7, 0.8, -0.9, 0.6, -0.8, 0.7, -0.6])
    Let noise_variance be 0.5
    
    Let llr_values be CodingTheory.compute_polar_llr(received_bits, noise_variance)
    
    UnitTest.assert_equals(List.size(llr_values), 8, "Should compute LLR for all bits")
    For each llr in llr_values:
        UnitTest.assert_true(Float.is_finite(llr), "LLR values should be finite")

Process called "create_test_llr_values" that takes length as Integer returns List[Float]:
    Let llr_values be List.create()
    For i from 0 to (length - 1):
        Let value be Float.random_range(-5.0, 5.0)
        List.push(llr_values, value)
    Return llr_values

Note: =====================================================================
Note: ADVANCED CODING TESTS
Note: =====================================================================

Process called "test_turbo_code_simulation":
    Let turbo_params be Dictionary.from_entries([
        ["block_length", 1000],
        ["code_rate", 0.5],
        ["interleaver_type", "random"]
    ])
    
    Let channel be create_test_channel()
    Let simulation be CodingTheory.simulate_coded_communication(turbo_params, channel, 500)
    
    UnitTest.assert_true(Dictionary.has_key(simulation, "ber_performance"), "Should simulate BER")
    UnitTest.assert_true(Dictionary.has_key(simulation, "convergence_iterations"), "Should track iterations")

Process called "test_fountain_code_operations":
    Let fountain_params be Dictionary.from_entries([
        ["source_symbols", 1000],
        ["degree_distribution", "robust_soliton"]
    ])
    
    Let fountain_code be CodingTheory.create_fountain_code(fountain_params)
    
    UnitTest.assert_true(Dictionary.has_key(fountain_code, "encoding_symbols"), "Should generate encoding symbols")
    UnitTest.assert_true(Dictionary.has_key(fountain_code, "overhead_ratio"), "Should compute overhead")

Process called "test_network_coding_operations":
    Let network_topology be create_test_network()
    Let coding_strategy be "random_linear"
    
    Let network_code be CodingTheory.create_network_coding(network_topology, coding_strategy)
    
    UnitTest.assert_true(Dictionary.has_key(network_code, "coding_coefficients"), "Should have coding coefficients")
    UnitTest.assert_true(Dictionary.has_key(network_code, "min_cut_capacity"), "Should compute min-cut")

Process called "create_test_network":
    Let topology be Dictionary.create()
    Dictionary.set(topology, "nodes", List.from_array(["source", "relay1", "relay2", "destination"]))
    Dictionary.set(topology, "edges", List.from_array([["source", "relay1"], ["source", "relay2"], ["relay1", "destination"], ["relay2", "destination"]]))
    Dictionary.set(topology, "capacities", Dictionary.from_entries([["source_relay1", 1], ["source_relay2", 1], ["relay1_dest", 1], ["relay2_dest", 1]]))
    Return topology

Note: =====================================================================
Note: CRYPTOGRAPHIC CODING TESTS
Note: =====================================================================

Process called "test_create_mceliece_cryptosystem":
    Let goppa_code_params be Dictionary.from_entries([
        ["field_size", 1024],
        ["code_length", 1024],
        ["error_capability", 50]
    ])
    
    Let mceliece_system be CodingTheory.create_mceliece_cryptosystem(goppa_code_params)
    
    UnitTest.assert_true(Dictionary.has_key(mceliece_system, "public_key"), "Should have public key")
    UnitTest.assert_true(Dictionary.has_key(mceliece_system, "private_key"), "Should have private key")
    UnitTest.assert_true(Dictionary.has_key(mceliece_system, "security_parameters"), "Should have security parameters")

Process called "test_niederreiter_cryptosystem":
    Let niederreiter_params be Dictionary.from_entries([
        ["code_type", "binary_goppa"],
        ["security_level", 128]
    ])
    
    Let niederreiter_system be CodingTheory.create_niederreiter_cryptosystem(niederreiter_params)
    
    UnitTest.assert_true(Dictionary.has_key(niederreiter_system, "syndrome_mapping"), "Should have syndrome mapping")
    UnitTest.assert_true(Dictionary.has_key(niederreiter_system, "decoding_key"), "Should have decoding key")

Note: =====================================================================
Note: PERFORMANCE AND BOUNDS TESTS
Note: =====================================================================

Process called "test_shannon_capacity_bounds":
    Let channel be create_test_channel()
    Let bounds = CodingTheory.compute_shannon_bounds(channel)
    
    UnitTest.assert_true(Dictionary.has_key(bounds, "channel_capacity"), "Should compute channel capacity")
    UnitTest.assert_true(Dictionary.has_key(bounds, "cutoff_rate"), "Should compute cutoff rate")
    UnitTest.assert_true(Dictionary.has_key(bounds, "sphere_packing_bound"), "Should compute sphere packing bound")

Process called "test_plotkin_bound_analysis":
    Let n be 15
    Let d be 7
    Let q be 2
    
    Let plotkin_bound be CodingTheory.compute_plotkin_bound(n, d, q)
    UnitTest.assert_true(plotkin_bound > 0, "Plotkin bound should be positive")

Process called "test_singleton_bound_verification":
    Let codes be List.create()
    List.push(codes, CodingTheory.create_hamming_code(3))
    List.push(codes, CodingTheory.create_reed_solomon_code(7, 3, 8))
    
    For each code in codes:
        Let satisfies_bound be CodingTheory.verify_singleton_bound(code)
        UnitTest.assert_true(satisfies_bound, "All good codes should satisfy Singleton bound")

Process called "test_hamming_bound_verification":
    Let hamming_code be CodingTheory.create_hamming_code(3)
    Let perfect_bound be CodingTheory.verify_hamming_bound(hamming_code)
    
    UnitTest.assert_true(perfect_bound, "Hamming codes should achieve Hamming bound")

Note: =====================================================================
Note: DECODING ALGORITHM COMPARISON TESTS
Note: =====================================================================

Process called "test_compare_decoding_algorithms":
    Let rs_code be CodingTheory.create_reed_solomon_code(15, 9, 16)
    Let message be List.from_array([1, 2, 3, 4, 5, 6, 7, 8, 9])
    Let encoded be CodingTheory.encode_reed_solomon(rs_code, message)
    
    Note: Introduce 2 symbol errors
    Let received be List.copy(encoded)
    List.set(received, 10, 15)
    List.set(received, 12, 14)
    
    Let bm_result be CodingTheory.decode_reed_solomon_berlekamp_massey(rs_code, received)
    Let euclidean_result be CodingTheory.decode_reed_solomon_euclidean(rs_code, received)
    
    UnitTest.assert_equals(bm_result.decoding_successful, euclidean_result.decoding_successful, "Both algorithms should agree")
    UnitTest.assert_equals(bm_result.errors_corrected, euclidean_result.errors_corrected, "Both should correct same number of errors")

Process called "test_syndrome_vs_ml_decoding":
    Let hamming_code be CodingTheory.create_hamming_code(3)
    Let message be List.from_array([1, 0, 1, 0])
    Let encoded be CodingTheory.encode_message(hamming_code, message)
    
    Let received_with_error be List.copy(encoded)
    List.set(received_with_error, 2, 1 - List.get(received_with_error, 2))
    
    Let syndrome_result be CodingTheory.decode_hamming_syndrome(hamming_code, received_with_error)
    Let ml_result be CodingTheory.decode_nearest_neighbor(hamming_code, received_with_error)
    
    UnitTest.assert_equals(syndrome_result.decoded_word, ml_result.decoded_word, "Syndrome and ML should produce same result")

Note: =====================================================================
Note: INFORMATION THEORY COMPREHENSIVE TESTS
Note: =====================================================================

Process called "test_entropy_properties":
    Note: Test fundamental entropy properties
    Let uniform_probs be List.from_array([0.25, 0.25, 0.25, 0.25])
    Let deterministic_probs be List.from_array([1.0, 0.0, 0.0, 0.0])
    
    Let uniform_entropy be CodingTheory.compute_entropy(uniform_probs)
    Let deterministic_entropy be CodingTheory.compute_entropy(deterministic_probs)
    
    assert_float_approximately_equals(uniform_entropy, 2.0, 0.001, "Uniform distribution should have maximum entropy")
    assert_float_approximately_equals(deterministic_entropy, 0.0, 0.001, "Deterministic source should have zero entropy")

Process called "test_mutual_information_properties":
    Note: Test mutual information properties
    Let independent_joint be List.create()
    List.push(independent_joint, List.from_array([0.25, 0.25]))
    List.push(independent_joint, List.from_array([0.25, 0.25]))
    
    Let dependent_joint be List.create()
    List.push(dependent_joint, List.from_array([0.4, 0.1]))
    List.push(dependent_joint, List.from_array([0.1, 0.4]))
    
    Let independent_mi be CodingTheory.compute_mutual_information(independent_joint)
    Let dependent_mi be CodingTheory.compute_mutual_information(dependent_joint)
    
    assert_float_approximately_equals(independent_mi, 0.0, 0.001, "Independent variables should have zero MI")
    UnitTest.assert_true(dependent_mi > 0.0, "Dependent variables should have positive MI")

Process called "test_channel_capacity_bounds":
    Let bsc_channels be create_bsc_test_channels()
    
    For each channel in bsc_channels:
        Let capacity be CodingTheory.compute_channel_capacity(channel)
        Let error_prob be channel.error_probability
        Let theoretical_capacity be 1.0 + error_prob * Math.log2(error_prob) + (1.0 - error_prob) * Math.log2(1.0 - error_prob)
        
        assert_float_approximately_equals(capacity, theoretical_capacity, 0.01, "BSC capacity should match theory")

Process called "create_bsc_test_channels":
    Let channels be List.create()
    Let error_probs be List.from_array([0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5])
    
    For each prob in error_probs:
        Let noise_chars be Dictionary.create()
        Dictionary.set(noise_chars, "error_probability", prob)
        
        Let channel be CodingTheory.Channel with:
            channel_type: "BSC"
            error_probability: prob
            capacity: 0.0
            noise_characteristics: noise_chars
            modulation_scheme: "BPSK"
            bandwidth: 1000.0
            signal_to_noise_ratio: 10.0
        
        List.push(channels, channel)
    Return channels

Note: =====================================================================
Note: ALGEBRAIC OPERATIONS TESTS
Note: =====================================================================

Process called "test_finite_field_arithmetic":
    Let field be CodingTheory.construct_finite_field(16)
    
    Note: Test field properties
    UnitTest.assert_equals(Dictionary.get_integer(field, "field_size"), 16, "Field size should be 16")
    UnitTest.assert_true(Dictionary.has_key(field, "primitive_polynomial"), "Should have primitive polynomial")
    
    Note: Test multiplicative group properties
    Let primitive_element be CodingTheory.find_primitive_element(16)
    Let element_order be CodingTheory.compute_element_order(primitive_element, 16)
    UnitTest.assert_equals(element_order, 15, "Primitive element should have order q-1")

Process called "test_polynomial_operations":
    Let poly1 be List.from_array([1, 0, 1, 1])  Note: x^3 + x + 1
    Let poly2 be List.from_array([1, 1, 0])     Note: x^2 + x
    Let modulus be List.from_array([1, 0, 0, 1, 1])  Note: x^4 + x + 1
    
    Let product be CodingTheory.multiply_and_reduce_polynomials(poly1, poly2, modulus)
    
    UnitTest.assert_false(List.is_empty(product), "Polynomial multiplication should produce result")
    UnitTest.assert_true(List.size(product) < List.size(modulus), "Result should be reduced")

Process called "test_minimal_polynomial_computation":
    Let field_size be 16
    Let minimal_polys be CodingTheory.compute_minimal_polynomials(field_size)
    
    UnitTest.assert_true(Dictionary.size(minimal_polys) > 0, "Should find minimal polynomials")
    
    Note: Verify each minimal polynomial
    For each element in Dictionary.keys(minimal_polys):
        Let poly be Dictionary.get(minimal_polys, element)
        UnitTest.assert_false(List.is_empty(poly), "Minimal polynomial should not be empty")

Note: =====================================================================
Note: ERROR PATTERN AND CORRECTION TESTS
Note: =====================================================================

Process called "test_single_error_correction":
    Let hamming_code be CodingTheory.create_hamming_code(3)
    Let messages be create_test_messages()
    
    For each message in messages:
        Let encoded be CodingTheory.encode_message(hamming_code, message)
        Let error_patterns be create_single_error_patterns(7)
        
        For each error_pattern in error_patterns:
            Let received be add_error_pattern(encoded, error_pattern)
            Let decoded_result be CodingTheory.decode_hamming_syndrome(hamming_code, received)
            
            UnitTest.assert_true(decoded_result.decoding_successful, "Should correct single error")
            UnitTest.assert_equals(decoded_result.decoded_word, encoded, "Should recover original codeword")

Process called "test_burst_error_detection":
    Let generator_poly be List.from_array([1, 0, 0, 0, 1, 0, 1, 1])  Note: CRC-7
    Let data be List.from_array([1, 1, 0, 1, 0, 1, 1, 0])
    
    Let crc_codeword be CodingTheory.compute_crc(data, generator_poly)
    
    Note: Introduce burst error of length 3
    Let burst_error be List.copy(crc_codeword)
    List.set(burst_error, 3, 1 - List.get(burst_error, 3))
    List.set(burst_error, 4, 1 - List.get(burst_error, 4))
    List.set(burst_error, 5, 1 - List.get(burst_error, 5))
    
    Let detection_result be CodingTheory.verify_error_detection(burst_error, generator_poly)
    UnitTest.assert_false(detection_result, "CRC should detect burst errors within guarantee")

Process called "test_random_error_correction":
    Let rs_code be CodingTheory.create_reed_solomon_code(31, 15, 32)
    Let message be create_random_symbols(15, 32)
    Let encoded be CodingTheory.encode_reed_solomon(rs_code, message)
    
    Note: Inject random errors up to correction capability
    Let max_errors be (rs_code.minimum_distance - 1) / 2
    Let received be inject_random_errors(encoded, max_errors)
    
    Let decoded_result be CodingTheory.decode_reed_solomon_berlekamp_massey(rs_code, received)
    UnitTest.assert_true(decoded_result.decoding_successful, "Should correct random errors within capability")

Process called "create_random_symbols" that takes count as Integer, field_size as Integer returns List[Integer]:
    Let symbols be List.create()
    For i from 0 to (count - 1):
        List.push(symbols, Integer.random_range(0, field_size - 1))
    Return symbols

Process called "inject_random_errors" that takes codeword as List[Integer], num_errors as Integer returns List[Integer]:
    Let result be List.copy(codeword)
    Let error_positions be List.create()
    
    Note: Select random error positions
    For i from 0 to (num_errors - 1):
        Let position be Integer.random_range(0, List.size(codeword) - 1)
        List.push(error_positions, position)
    
    Note: Inject errors
    For each position in error_positions:
        Let original_value be List.get(result, position)
        Let error_value be Integer.random_range(1, 7)  Note: Non-zero error for GF(8)
        List.set(result, position, Integer.modulo(original_value + error_value, 8))
    
    Return result

Note: =====================================================================
Note: CHANNEL SIMULATION AND ANALYSIS TESTS
Note: =====================================================================

Process called "test_awgn_channel_simulation":
    Let awgn_channel be create_awgn_channel()
    Let bpsk_symbols be List.from_array([1.0, -1.0, 1.0, 1.0, -1.0])
    
    Let received_symbols be CodingTheory.simulate_awgn_transmission(bpsk_symbols, awgn_channel)
    
    UnitTest.assert_equals(List.size(received_symbols), List.size(bpsk_symbols), "Should preserve symbol count")
    For each symbol in received_symbols:
        UnitTest.assert_true(Float.is_finite(symbol), "Received symbols should be finite")

Process called "test_fading_channel_analysis":
    Let fading_channel be create_rayleigh_fading_channel()
    Let analysis be CodingTheory.analyze_fading_channel_capacity(fading_channel)
    
    UnitTest.assert_true(Dictionary.has_key(analysis, "ergodic_capacity"), "Should compute ergodic capacity")
    UnitTest.assert_true(Dictionary.has_key(analysis, "outage_probability"), "Should compute outage probability")

Process called "test_mimo_channel_coding":
    Let mimo_params be Dictionary.from_entries([
        ["transmit_antennas", 2],
        ["receive_antennas", 2],
        ["channel_matrix", create_mimo_channel_matrix()]
    ])
    
    Let mimo_analysis be CodingTheory.analyze_mimo_channel_capacity(mimo_params)
    
    UnitTest.assert_true(Dictionary.has_key(mimo_analysis, "capacity_matrix"), "Should compute MIMO capacity")
    UnitTest.assert_true(Dictionary.has_key(mimo_analysis, "diversity_gain"), "Should analyze diversity")

Process called "create_awgn_channel":
    Let noise_chars be Dictionary.create()
    Dictionary.set(noise_chars, "variance", 1.0)
    Dictionary.set(noise_chars, "mean", 0.0)
    
    Return CodingTheory.Channel with:
        channel_type: "AWGN"
        error_probability: 0.0
        capacity: 1.0
        noise_characteristics: noise_chars
        modulation_scheme: "BPSK"
        bandwidth: 1000.0
        signal_to_noise_ratio: 5.0

Process called "create_rayleigh_fading_channel":
    Let noise_chars be Dictionary.create()
    Dictionary.set(noise_chars, "fading_parameter", 1.0)
    Dictionary.set(noise_chars, "coherence_time", 100.0)
    
    Return CodingTheory.Channel with:
        channel_type: "Rayleigh"
        error_probability: 0.1
        capacity: 0.5
        noise_characteristics: noise_chars
        modulation_scheme: "QPSK"
        bandwidth: 2000.0
        signal_to_noise_ratio: 3.0

Process called "create_mimo_channel_matrix":
    Let matrix be List.create()
    List.push(matrix, List.from_array([0.8, 0.3]))
    List.push(matrix, List.from_array([0.2, 0.9]))
    Return matrix

Note: =====================================================================
Note: OPTIMIZATION AND SYSTEM TESTS
Note: =====================================================================

Process called "test_optimize_coding_system":
    Let requirements be Dictionary.from_entries([
        ["target_ber", 0.0001],
        ["minimum_throughput", 0.8],
        ["maximum_latency", 100],
        ["complexity_budget", 10000]
    ])
    
    Let optimization be CodingTheory.optimize_coding_system(requirements)
    
    UnitTest.assert_true(Dictionary.has_key(optimization, "recommended_codes"), "Should recommend code types")
    UnitTest.assert_true(Dictionary.has_key(optimization, "system_parameters"), "Should provide system parameters")
    UnitTest.assert_true(Dictionary.has_key(optimization, "performance_prediction"), "Should predict performance")

Process called "test_compare_code_performance":
    Let codes be List.create()
    List.push(codes, CodingTheory.create_hamming_code(4))
    List.push(codes, CodingTheory.create_reed_solomon_code(15, 9, 16))
    List.push(codes, CodingTheory.create_bch_code(31, 5))
    
    Let channel be create_test_channel()
    Let comparison be CodingTheory.compare_code_performance(codes, channel)
    
    UnitTest.assert_true(Dictionary.has_key(comparison, "error_rates"), "Should compare error rates")
    UnitTest.assert_true(Dictionary.has_key(comparison, "decoding_complexity"), "Should compare complexity")
    UnitTest.assert_true(Dictionary.has_key(comparison, "coding_gains"), "Should compare coding gains")

Process called "test_validate_code_parameters":
    Let valid_params be Dictionary.from_entries([
        ["n", 15],
        ["k", 11], 
        ["d", 5],
        ["q", 2]
    ])
    
    Let invalid_params be Dictionary.from_entries([
        ["n", 15],
        ["k", 20],  Note: k > n (invalid)
        ["d", 5],
        ["q", 2]
    ])
    
    Let valid_result be CodingTheory.validate_code_parameters(valid_params)
    Let invalid_result be CodingTheory.validate_code_parameters(invalid_params)
    
    UnitTest.assert_true(Dictionary.get_boolean(valid_result, "is_valid"), "Valid parameters should pass")
    UnitTest.assert_false(Dictionary.get_boolean(invalid_result, "is_valid"), "Invalid parameters should fail")

Note: =====================================================================
Note: ADVANCED ERROR INJECTION AND TESTING
Note: =====================================================================

Process called "test_systematic_error_patterns":
    Let bch_code be CodingTheory.create_bch_code(31, 5)
    Let message be create_random_binary_message(26)
    Let encoded be CodingTheory.encode_message(bch_code, message)
    
    Note: Test all single-bit error patterns
    Let single_errors be create_single_error_patterns(31)
    Let correction_count be 0
    
    For each error_pattern in single_errors:
        Let received be add_error_pattern(encoded, error_pattern)
        Let decoded_result be CodingTheory.decode_bch_syndrome(bch_code, received)
        
        If decoded_result.decoding_successful:
            correction_count be correction_count + 1
    
    UnitTest.assert_equals(correction_count, 31, "Should correct all single-bit errors")

Process called "test_weight_distribution_analysis":
    Let hamming_code be CodingTheory.create_hamming_code(3)
    Let weight_distribution be CodingTheory.compute_weight_distribution(hamming_code)
    
    UnitTest.assert_true(Dictionary.has_key(weight_distribution, "weight_enumerator"), "Should compute weight enumerator")
    UnitTest.assert_equals(Dictionary.get_integer(weight_distribution, "minimum_weight"), 3, "Minimum weight should be 3")

Process called "test_distance_spectrum_computation":
    Let rs_code be CodingTheory.create_reed_solomon_code(7, 3, 8)
    Let distance_spectrum be CodingTheory.compute_distance_spectrum(rs_code)
    
    UnitTest.assert_true(Dictionary.has_key(distance_spectrum, "distance_distribution"), "Should compute distance distribution")
    UnitTest.assert_equals(Dictionary.get_integer(distance_spectrum, "minimum_distance"), 5, "Should identify correct minimum distance")

Note: =====================================================================
Note: COMPREHENSIVE INTEGRATION TESTS
Note: =====================================================================

Process called "test_end_to_end_communication_system":
    Note: Test complete communication system with coding
    Let source_data be create_random_binary_message(100)
    Let rs_code be CodingTheory.create_reed_solomon_code(255, 200, 256)
    Let channel be create_test_channel()
    
    Note: Encode data
    Let encoded_blocks be encode_data_blocks(source_data, rs_code)
    
    Note: Simulate transmission
    Let received_blocks be simulate_transmission(encoded_blocks, channel)
    
    Note: Decode and measure performance
    Let decoded_data be decode_data_blocks(received_blocks, rs_code)
    Let error_count be count_bit_errors(source_data, decoded_data)
    
    UnitTest.assert_true(error_count < List.size(source_data) * 0.001, "End-to-end BER should be very low")

Process called "test_adaptive_coding_system":
    Let channels be create_varying_quality_channels()
    Let adaptive_system be CodingTheory.create_adaptive_coding_system()
    
    For each channel in channels:
        Let recommended_code be CodingTheory.select_optimal_code(adaptive_system, channel)
        UnitTest.assert_true(Dictionary.has_key(recommended_code, "code_type"), "Should recommend appropriate code")
        UnitTest.assert_true(Dictionary.has_key(recommended_code, "parameters"), "Should provide parameters")

Process called "test_multi_level_coding":
    Let level1_code be CodingTheory.create_hamming_code(3)
    Let level2_code be CodingTheory.create_reed_solomon_code(15, 11, 16)
    
    Let mlc_system be CodingTheory.create_multi_level_coding([level1_code, level2_code])
    
    UnitTest.assert_true(Dictionary.has_key(mlc_system, "protection_levels"), "Should have protection levels")
    UnitTest.assert_true(Dictionary.has_key(mlc_system, "overall_rate"), "Should compute overall rate")

Process called "encode_data_blocks" that takes data as List[Integer], code as CodingTheory.Code returns List[List[Integer]]:
    Let blocks be List.create()
    Let block_size be code.message_length
    
    For i from 0 to (List.size(data) - 1) step block_size:
        Let block be List.create()
        For j from i to (Integer.min(i + block_size - 1, List.size(data) - 1)):
            List.push(block, List.get(data, j))
        
        Let encoded_block be CodingTheory.encode_message(code, block)
        List.push(blocks, encoded_block)
    
    Return blocks

Process called "simulate_transmission" that takes blocks as List[List[Integer]], channel as CodingTheory.Channel returns List[List[Integer]]:
    Let received_blocks be List.create()
    
    For each block in blocks:
        Let received_block be List.copy(block)
        For i from 0 to (List.size(block) - 1):
            If Float.random() < channel.error_probability:
                List.set(received_block, i, 1 - List.get(received_block, i))
        List.push(received_blocks, received_block)
    
    Return received_blocks

Process called "decode_data_blocks" that takes blocks as List[List[Integer]], code as CodingTheory.Code returns List[Integer]:
    Let decoded_data be List.create()
    
    For each block in blocks:
        Let decoded_result be CodingTheory.decode_nearest_neighbor(code, block)
        If decoded_result.decoding_successful:
            For i from 0 to (code.message_length - 1):
                List.push(decoded_data, List.get(decoded_result.decoded_word, i))
    
    Return decoded_data

Process called "count_bit_errors" that takes original as List[Integer], decoded as List[Integer] returns Integer:
    Let errors be 0
    Let min_length be Integer.min(List.size(original), List.size(decoded))
    
    For i from 0 to (min_length - 1):
        If not Integer.equals(List.get(original, i), List.get(decoded, i)):
            errors be errors + 1
    
    Return errors

Process called "create_varying_quality_channels":
    Let channels be List.create()
    Let snr_values be List.from_array([0.0, 5.0, 10.0, 15.0, 20.0])
    
    For each snr in snr_values:
        Let error_prob be compute_ber_from_snr(snr)
        Let channel be create_channel_with_snr(snr, error_prob)
        List.push(channels, channel)
    
    Return channels

Process called "compute_ber_from_snr" that takes snr_db as Float returns Float:
    Let snr_linear be Math.power(10.0, snr_db / 10.0)
    Return 0.5 * Math.exp(-snr_linear / 2.0)

Process called "create_channel_with_snr" that takes snr as Float, ber as Float returns CodingTheory.Channel:
    Let noise_chars be Dictionary.create()
    Dictionary.set(noise_chars, "snr_db", snr)
    Dictionary.set(noise_chars, "variance", 1.0 / snr)
    
    Return CodingTheory.Channel with:
        channel_type: "AWGN"
        error_probability: ber
        capacity: 0.5 * Math.log2(1.0 + snr)
        noise_characteristics: noise_chars
        modulation_scheme: "BPSK"
        bandwidth: 1000.0
        signal_to_noise_ratio: snr

Note: =====================================================================
Note: UTILITY AND DEBUGGING TESTS
Note: =====================================================================

Process called "test_troubleshoot_coding_issues":
    Let issue_description be "High bit error rate despite good SNR"
    Let suggestions be CodingTheory.troubleshoot_coding_issues(issue_description)
    
    UnitTest.assert_false(List.is_empty(suggestions), "Should provide troubleshooting suggestions")
    UnitTest.assert_true(List.size(suggestions) > 0, "Should have at least one suggestion")

Process called "test_code_parameter_validation":
    Let test_cases be create_parameter_test_cases()
    
    For each test_case in test_cases:
        Let validation be CodingTheory.validate_code_parameters(test_case)
        Let expected_validity be Dictionary.get_boolean(test_case, "should_be_valid")
        Let actual_validity be Dictionary.get_boolean(validation, "is_valid")
        
        UnitTest.assert_equals(actual_validity, expected_validity, "Parameter validation should match expectation")

Process called "create_parameter_test_cases":
    Let test_cases be List.create()
    
    Note: Valid case
    List.push(test_cases, Dictionary.from_entries([
        ["n", 15], ["k", 11], ["d", 3], ["q", 2], ["should_be_valid", True]
    ]))
    
    Note: Invalid case - k > n
    List.push(test_cases, Dictionary.from_entries([
        ["n", 15], ["k", 20], ["d", 3], ["q", 2], ["should_be_valid", False]
    ]))
    
    Note: Invalid case - d > n - k + 1 (Singleton bound violation)
    List.push(test_cases, Dictionary.from_entries([
        ["n", 15], ["k", 11], ["d", 10], ["q", 2], ["should_be_valid", False]
    ]))
    
    Return test_cases

Note: =====================================================================
Note: TEST SUITE COORDINATION
Note: =====================================================================

Process called "run_all_coding_theory_tests":
    UnitTest.start_test_suite("Coding Theory Module Tests")
    
    Note: Linear Code Tests
    UnitTest.run_test("test_create_linear_code", test_create_linear_code)
    UnitTest.run_test("test_compute_parity_check_matrix", test_compute_parity_check_matrix)
    UnitTest.run_test("test_encode_message", test_encode_message)
    UnitTest.run_test("test_compute_minimum_distance", test_compute_minimum_distance)
    UnitTest.run_test("test_linear_code_systematic", test_linear_code_systematic)
    
    Note: Hamming Code Tests
    UnitTest.run_test("test_create_hamming_code", test_create_hamming_code)
    UnitTest.run_test("test_create_extended_hamming_code", test_create_extended_hamming_code)
    UnitTest.run_test("test_decode_hamming_syndrome", test_decode_hamming_syndrome)
    UnitTest.run_test("test_hamming_error_detection", test_hamming_error_detection)
    UnitTest.run_test("test_analyze_hamming_performance", test_analyze_hamming_performance)
    
    Note: Reed-Solomon Code Tests
    UnitTest.run_test("test_create_reed_solomon_code", test_create_reed_solomon_code)
    UnitTest.run_test("test_encode_reed_solomon", test_encode_reed_solomon)
    UnitTest.run_test("test_decode_reed_solomon_berlekamp_massey", test_decode_reed_solomon_berlekamp_massey)
    UnitTest.run_test("test_decode_reed_solomon_euclidean", test_decode_reed_solomon_euclidean)
    UnitTest.run_test("test_find_primitive_polynomial", test_find_primitive_polynomial)
    UnitTest.run_test("test_reed_solomon_error_bounds", test_reed_solomon_error_bounds)
    
    Note: BCH Code Tests
    UnitTest.run_test("test_create_bch_code", test_create_bch_code)
    UnitTest.run_test("test_find_bch_generator_polynomial", test_find_bch_generator_polynomial)
    UnitTest.run_test("test_decode_bch_syndrome", test_decode_bch_syndrome)
    UnitTest.run_test("test_analyze_bch_bounds", test_analyze_bch_bounds)
    
    Note: Convolutional Code Tests
    UnitTest.run_test("test_create_convolutional_code", test_create_convolutional_code)
    UnitTest.run_test("test_encode_convolutional", test_encode_convolutional)
    UnitTest.run_test("test_decode_viterbi", test_decode_viterbi)
    UnitTest.run_test("test_compute_convolutional_free_distance", test_compute_convolutional_free_distance)
    
    Note: Syndrome Decoding Tests
    UnitTest.run_test("test_compute_syndrome", test_compute_syndrome)
    UnitTest.run_test("test_create_syndrome_table", test_create_syndrome_table)
    UnitTest.run_test("test_decode_standard_array", test_decode_standard_array)
    UnitTest.run_test("test_decode_nearest_neighbor", test_decode_nearest_neighbor)
    
    Note: Error Detection Tests
    UnitTest.run_test("test_compute_checksum", test_compute_checksum)
    UnitTest.run_test("test_compute_crc", test_compute_crc)
    UnitTest.run_test("test_verify_error_detection", test_verify_error_detection)
    UnitTest.run_test("test_analyze_detection_capability", test_analyze_detection_capability)
    
    Note: Information Theory Tests
    UnitTest.run_test("test_compute_entropy", test_compute_entropy)
    UnitTest.run_test("test_compute_mutual_information", test_compute_mutual_information)
    UnitTest.run_test("test_compute_channel_capacity", test_compute_channel_capacity)
    UnitTest.run_test("test_analyze_source_coding", test_analyze_source_coding)
    UnitTest.run_test("test_entropy_properties", test_entropy_properties)
    UnitTest.run_test("test_mutual_information_properties", test_mutual_information_properties)
    UnitTest.run_test("test_channel_capacity_bounds", test_channel_capacity_bounds)
    
    Note: Channel Coding Tests
    UnitTest.run_test("test_analyze_channel_coding_theorem", test_analyze_channel_coding_theorem)
    UnitTest.run_test("test_compute_error_probability_bounds", test_compute_error_probability_bounds)
    UnitTest.run_test("test_optimize_code_parameters", test_optimize_code_parameters)
    UnitTest.run_test("test_simulate_coded_communication", test_simulate_coded_communication)
    
    Note: Finite Field Tests
    UnitTest.run_test("test_finite_field_arithmetic", test_finite_field_arithmetic)
    UnitTest.run_test("test_polynomial_operations", test_polynomial_operations)
    UnitTest.run_test("test_minimal_polynomial_computation", test_minimal_polynomial_computation)
    
    Note: Concatenated Code Tests
    UnitTest.run_test("test_create_concatenated_code", test_create_concatenated_code)
    UnitTest.run_test("test_decode_concatenated_iterative", test_decode_concatenated_iterative)
    UnitTest.run_test("test_analyze_concatenated_performance", test_analyze_concatenated_performance)
    
    Note: LDPC Code Tests
    UnitTest.run_test("test_create_ldpc_code", test_create_ldpc_code)
    UnitTest.run_test("test_construct_ldpc_regular", test_construct_ldpc_regular)
    UnitTest.run_test("test_decode_ldpc_belief_propagation", test_decode_ldpc_belief_propagation)
    UnitTest.run_test("test_analyze_ldpc_graph_properties", test_analyze_ldpc_graph_properties)
    
    Note: Polar Code Tests
    UnitTest.run_test("test_create_polar_code", test_create_polar_code)
    UnitTest.run_test("test_compute_channel_polarization", test_compute_channel_polarization)
    UnitTest.run_test("test_decode_polar_successive_cancellation", test_decode_polar_successive_cancellation)
    UnitTest.run_test("test_decode_polar_list", test_decode_polar_list)
    UnitTest.run_test("test_compute_polar_llr", test_compute_polar_llr)
    
    Note: Advanced Tests
    UnitTest.run_test("test_turbo_code_simulation", test_turbo_code_simulation)
    UnitTest.run_test("test_fountain_code_operations", test_fountain_code_operations)
    UnitTest.run_test("test_network_coding_operations", test_network_coding_operations)
    
    Note: Cryptographic Tests
    UnitTest.run_test("test_create_mceliece_cryptosystem", test_create_mceliece_cryptosystem)
    UnitTest.run_test("test_niederreiter_cryptosystem", test_niederreiter_cryptosystem)
    
    Note: Performance and Bounds Tests
    UnitTest.run_test("test_shannon_capacity_bounds", test_shannon_capacity_bounds)
    UnitTest.run_test("test_plotkin_bound_analysis", test_plotkin_bound_analysis)
    UnitTest.run_test("test_singleton_bound_verification", test_singleton_bound_verification)
    UnitTest.run_test("test_hamming_bound_verification", test_hamming_bound_verification)
    
    Note: Algorithm Comparison Tests
    UnitTest.run_test("test_compare_decoding_algorithms", test_compare_decoding_algorithms)
    UnitTest.run_test("test_syndrome_vs_ml_decoding", test_syndrome_vs_ml_decoding)
    
    Note: Channel Simulation Tests
    UnitTest.run_test("test_awgn_channel_simulation", test_awgn_channel_simulation)
    UnitTest.run_test("test_fading_channel_analysis", test_fading_channel_analysis)
    UnitTest.run_test("test_mimo_channel_coding", test_mimo_channel_coding)
    
    Note: Optimization Tests
    UnitTest.run_test("test_optimize_coding_system", test_optimize_coding_system)
    UnitTest.run_test("test_compare_code_performance", test_compare_code_performance)
    UnitTest.run_test("test_validate_code_parameters", test_validate_code_parameters)
    
    Note: Error Pattern Tests
    UnitTest.run_test("test_single_error_correction", test_single_error_correction)
    UnitTest.run_test("test_burst_error_detection", test_burst_error_detection)
    UnitTest.run_test("test_random_error_correction", test_random_error_correction)
    UnitTest.run_test("test_systematic_error_patterns", test_systematic_error_patterns)
    UnitTest.run_test("test_weight_distribution_analysis", test_weight_distribution_analysis)
    UnitTest.run_test("test_distance_spectrum_computation", test_distance_spectrum_computation)
    
    Note: Integration Tests
    UnitTest.run_test("test_end_to_end_communication_system", test_end_to_end_communication_system)
    UnitTest.run_test("test_adaptive_coding_system", test_adaptive_coding_system)
    UnitTest.run_test("test_multi_level_coding", test_multi_level_coding)
    
    Note: Utility Tests
    UnitTest.run_test("test_troubleshoot_coding_issues", test_troubleshoot_coding_issues)
    UnitTest.run_test("test_code_parameter_validation", test_code_parameter_validation)
    
    UnitTest.end_test_suite()