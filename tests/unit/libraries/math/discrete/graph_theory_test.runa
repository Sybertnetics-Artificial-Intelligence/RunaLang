Note:
Unit tests for math/discrete/graph_theory.runa module
Testing graph algorithms, connectivity analysis, shortest paths,
spanning trees, matching, coloring, planarity, and network analysis.
:End Note

Import "dev/test" as UnitTest
Import "collections" as Collections
Import "stdlib/math/discrete/graph_theory" as GraphTheory

Note: =====================================================================
Note: TEST DATA GENERATORS
Note: =====================================================================

Process called "create_simple_undirected_graph":
    Note: Simple triangle graph: A-B-C-A
    Let vertices be List.from_array(["A", "B", "C"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "C"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "C"], ["target", "A"], ["weight", "1.0"]]))
    
    Let adjacency_list be Dictionary.create()
    Dictionary.set(adjacency_list, "A", List.from_array(["B", "C"]))
    Dictionary.set(adjacency_list, "B", List.from_array(["A", "C"]))
    Dictionary.set(adjacency_list, "C", List.from_array(["A", "B"]))
    
    Let adjacency_matrix be List.create()
    List.push(adjacency_matrix, List.from_array([0.0, 1.0, 1.0]))
    List.push(adjacency_matrix, List.from_array([1.0, 0.0, 1.0]))
    List.push(adjacency_matrix, List.from_array([1.0, 1.0, 0.0]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: False
        is_weighted: True
        adjacency_matrix: adjacency_matrix
        adjacency_list: adjacency_list
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_simple_directed_graph":
    Note: Directed acyclic graph: A->B->C
    Let vertices be List.from_array(["A", "B", "C"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "2.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "C"], ["weight", "3.0"]]))
    
    Let adjacency_list be Dictionary.create()
    Dictionary.set(adjacency_list, "A", List.from_array(["B"]))
    Dictionary.set(adjacency_list, "B", List.from_array(["C"]))
    Dictionary.set(adjacency_list, "C", List.create())
    
    Let adjacency_matrix be List.create()
    List.push(adjacency_matrix, List.from_array([0.0, 2.0, 0.0]))
    List.push(adjacency_matrix, List.from_array([0.0, 0.0, 3.0]))
    List.push(adjacency_matrix, List.from_array([0.0, 0.0, 0.0]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: True
        is_weighted: True
        adjacency_matrix: adjacency_matrix
        adjacency_list: adjacency_list
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_weighted_graph":
    Note: Weighted graph for shortest path testing
    Let vertices be List.from_array(["S", "A", "B", "T"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "S"], ["target", "A"], ["weight", "10.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "S"], ["target", "B"], ["weight", "5.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "T"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "A"], ["weight", "3.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "T"], ["weight", "2.0"]]))
    
    Let adjacency_list be Dictionary.create()
    Dictionary.set(adjacency_list, "S", List.from_array(["A", "B"]))
    Dictionary.set(adjacency_list, "A", List.from_array(["T"]))
    Dictionary.set(adjacency_list, "B", List.from_array(["A", "T"]))
    Dictionary.set(adjacency_list, "T", List.create())
    
    Let adjacency_matrix be List.create()
    List.push(adjacency_matrix, List.from_array([0.0, 10.0, 5.0, 0.0]))
    List.push(adjacency_matrix, List.from_array([0.0, 0.0, 0.0, 1.0]))
    List.push(adjacency_matrix, List.from_array([0.0, 3.0, 0.0, 2.0]))
    List.push(adjacency_matrix, List.from_array([0.0, 0.0, 0.0, 0.0]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: True
        is_weighted: True
        adjacency_matrix: adjacency_matrix
        adjacency_list: adjacency_list
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_bipartite_graph":
    Note: Bipartite graph for matching tests
    Let vertices be List.from_array(["A1", "A2", "A3", "B1", "B2", "B3"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "A1"], ["target", "B1"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "A1"], ["target", "B2"], ["weight", "2.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "A2"], ["target", "B2"], ["weight", "3.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "A2"], ["target", "B3"], ["weight", "4.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "A3"], ["target", "B1"], ["weight", "5.0"]]))
    
    Let adjacency_list be Dictionary.create()
    Dictionary.set(adjacency_list, "A1", List.from_array(["B1", "B2"]))
    Dictionary.set(adjacency_list, "A2", List.from_array(["B2", "B3"]))
    Dictionary.set(adjacency_list, "A3", List.from_array(["B1"]))
    Dictionary.set(adjacency_list, "B1", List.from_array(["A1", "A3"]))
    Dictionary.set(adjacency_list, "B2", List.from_array(["A1", "A2"]))
    Dictionary.set(adjacency_list, "B3", List.from_array(["A2"]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: False
        is_weighted: True
        adjacency_matrix: create_bipartite_adjacency_matrix()
        adjacency_list: adjacency_list
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_bipartite_adjacency_matrix":
    Let matrix be List.create()
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 1.0, 2.0, 0.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 0.0, 3.0, 4.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 5.0, 0.0, 0.0]))
    List.push(matrix, List.from_array([1.0, 0.0, 5.0, 0.0, 0.0, 0.0]))
    List.push(matrix, List.from_array([2.0, 3.0, 0.0, 0.0, 0.0, 0.0]))
    List.push(matrix, List.from_array([0.0, 4.0, 0.0, 0.0, 0.0, 0.0]))
    Return matrix

Process called "create_flow_network":
    Note: Flow network for max flow testing
    Let vertices be List.from_array(["S", "A", "B", "C", "T"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "S"], ["target", "A"], ["weight", "10.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "S"], ["target", "C"], ["weight", "8.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "5.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "C"], ["weight", "2.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "T"], ["weight", "10.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "C"], ["target", "B"], ["weight", "7.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "C"], ["target", "T"], ["weight", "10.0"]]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: True
        is_weighted: True
        adjacency_matrix: create_flow_adjacency_matrix()
        adjacency_list: create_flow_adjacency_list()
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_flow_adjacency_matrix":
    Let matrix be List.create()
    List.push(matrix, List.from_array([0.0, 10.0, 0.0, 8.0, 0.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 5.0, 2.0, 0.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 0.0, 10.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 7.0, 0.0, 10.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 0.0, 0.0]))
    Return matrix

Process called "create_flow_adjacency_list":
    Let adjacency_list be Dictionary.create()
    Dictionary.set(adjacency_list, "S", List.from_array(["A", "C"]))
    Dictionary.set(adjacency_list, "A", List.from_array(["B", "C"]))
    Dictionary.set(adjacency_list, "B", List.from_array(["T"]))
    Dictionary.set(adjacency_list, "C", List.from_array(["B", "T"]))
    Dictionary.set(adjacency_list, "T", List.create())
    Return adjacency_list

Note: =====================================================================
Note: ASSERTION HELPERS
Note: =====================================================================

Process called "assert_graph_valid" that takes graph as GraphTheory.Graph, message as String:
    UnitTest.assert_false(List.is_empty(graph.vertices), message + " - graph must have vertices")
    UnitTest.assert_equals(List.size(graph.adjacency_matrix), List.size(graph.vertices), message + " - matrix size must match vertex count")
    
    For each row in graph.adjacency_matrix:
        UnitTest.assert_equals(List.size(row), List.size(graph.vertices), message + " - matrix must be square")

Process called "assert_path_valid" that takes path as GraphTheory.GraphPath, graph as GraphTheory.Graph, message as String:
    UnitTest.assert_false(List.is_empty(path.path_vertices), message + " - path must contain vertices")
    UnitTest.assert_equals(List.size(path.path_edges), List.size(path.path_vertices) - 1, message + " - edge count should be vertex count minus 1")
    UnitTest.assert_true(path.total_weight >= 0.0, message + " - path weight should be non-negative")
    UnitTest.assert_equals(path.path_length, List.size(path.path_edges), message + " - path length should match edge count")

Process called "assert_spanning_tree_valid" that takes tree as GraphTheory.SpanningTree, graph as GraphTheory.Graph, message as String:
    UnitTest.assert_equals(List.size(tree.tree_edges), List.size(graph.vertices) - 1, message + " - spanning tree should have V-1 edges")
    UnitTest.assert_equals(List.size(tree.tree_vertices), List.size(graph.vertices), message + " - spanning tree should include all vertices")
    UnitTest.assert_true(tree.total_weight >= 0.0, message + " - tree weight should be non-negative")

Process called "assert_connectivity_result_valid" that takes result as GraphTheory.ConnectivityResult, graph as GraphTheory.Graph, message as String:
    UnitTest.assert_true(result.component_count > 0, message + " - must have at least one component")
    UnitTest.assert_equals(List.size(result.connected_components), result.component_count, message + " - component count must match list size")
    UnitTest.assert_true(result.connectivity_strength >= 0.0, message + " - connectivity strength must be non-negative")

Process called "assert_matching_valid" that takes matching as Dictionary[String, String], graph as GraphTheory.Graph, message as String:
    Note: Verify each matched vertex appears exactly once
    Let matched_vertices be List.create()
    
    For each vertex in Dictionary.keys(matching):
        UnitTest.assert_false(List.contains(matched_vertices, vertex), message + " - vertex should not be matched twice")
        List.push(matched_vertices, vertex)
        
        Let partner be Dictionary.get(matching, vertex)
        UnitTest.assert_false(List.contains(matched_vertices, partner), message + " - partner should not be matched twice")
        List.push(matched_vertices, partner)

Process called "assert_coloring_valid" that takes coloring as Dictionary[String, Integer], graph as GraphTheory.Graph, message as String:
    Note: Verify no adjacent vertices have same color
    For each edge in graph.edges:
        Let source be Dictionary.get(edge, "source")
        Let target be Dictionary.get(edge, "target")
        Let source_color be Dictionary.get(coloring, source)
        Let target_color be Dictionary.get(coloring, target)
        
        UnitTest.assert_false(Integer.equals(source_color, target_color), message + " - adjacent vertices must have different colors")

Process called "assert_float_approximately_equals" that takes actual as Float, expected as Float, tolerance as Float, message as String:
    Let difference be Float.absolute_value(actual - expected)
    UnitTest.assert_true(difference <= tolerance, message + " - values differ by more than tolerance")

Note: =====================================================================
Note: GRAPH CREATION TESTS
Note: =====================================================================

Process called "test_create_empty_graph":
    Let empty_graph be GraphTheory.create_empty_graph(5, False)
    
    assert_graph_valid(empty_graph, "Empty graph creation")
    UnitTest.assert_equals(List.size(empty_graph.vertices), 5, "Should have 5 vertices")
    UnitTest.assert_equals(List.size(empty_graph.edges), 0, "Should have no edges")
    UnitTest.assert_false(empty_graph.is_directed, "Should be undirected")

Process called "test_create_complete_graph":
    Let edge_weights be Dictionary.from_entries([["uniform", "1.0"]])
    Let complete_graph be GraphTheory.create_complete_graph(4, edge_weights)
    
    assert_graph_valid(complete_graph, "Complete graph creation")
    UnitTest.assert_equals(List.size(complete_graph.vertices), 4, "Should have 4 vertices")
    UnitTest.assert_equals(List.size(complete_graph.edges), 6, "Complete graph K4 should have 6 edges")

Process called "test_create_cycle_graph":
    Let cycle_graph be GraphTheory.create_cycle_graph(6, True)
    
    assert_graph_valid(cycle_graph, "Cycle graph creation")
    UnitTest.assert_equals(List.size(cycle_graph.vertices), 6, "Should have 6 vertices")
    UnitTest.assert_equals(List.size(cycle_graph.edges), 6, "Cycle should have 6 edges")

Process called "test_create_random_graph":
    Let random_graph be GraphTheory.create_random_graph(10, 0.3, 12345)
    
    assert_graph_valid(random_graph, "Random graph creation")
    UnitTest.assert_equals(List.size(random_graph.vertices), 10, "Should have 10 vertices")
    UnitTest.assert_true(List.size(random_graph.edges) > 0, "Should have some edges with p=0.3")

Note: =====================================================================
Note: GRAPH REPRESENTATION TESTS
Note: =====================================================================

Process called "test_convert_to_adjacency_matrix":
    Let graph be create_simple_undirected_graph()
    Let matrix be GraphTheory.convert_to_adjacency_matrix(graph)
    
    UnitTest.assert_equals(List.size(matrix), 3, "Matrix should be 3x3")
    UnitTest.assert_equals(List.get(List.get(matrix, 0), 1), 1.0, "A-B edge should be represented")
    UnitTest.assert_equals(List.get(List.get(matrix, 1), 0), 1.0, "Undirected graph should be symmetric")

Process called "test_convert_to_adjacency_list":
    Let graph be create_simple_directed_graph()
    Let adjacency_list be GraphTheory.convert_to_adjacency_list(graph)
    
    UnitTest.assert_true(Dictionary.has_key(adjacency_list, "A"), "Should have vertex A")
    Let a_neighbors be Dictionary.get(adjacency_list, "A")
    UnitTest.assert_true(List.contains(a_neighbors, "B"), "A should be connected to B")

Process called "test_convert_to_edge_list":
    Let graph be create_simple_undirected_graph()
    Let edge_list be GraphTheory.convert_to_edge_list(graph)
    
    UnitTest.assert_equals(List.size(edge_list), 3, "Should have 3 edges")
    For each edge in edge_list:
        UnitTest.assert_true(Dictionary.has_key(edge, "source"), "Edge should have source")
        UnitTest.assert_true(Dictionary.has_key(edge, "target"), "Edge should have target")

Process called "test_convert_to_incidence_matrix":
    Let graph be create_simple_undirected_graph()
    Let incidence_matrix be GraphTheory.convert_to_incidence_matrix(graph)
    
    UnitTest.assert_equals(List.size(incidence_matrix), 3, "Should have 3 rows for vertices")
    UnitTest.assert_equals(List.size(List.get(incidence_matrix, 0)), 3, "Should have 3 columns for edges")

Note: =====================================================================
Note: GRAPH TRAVERSAL TESTS
Note: =====================================================================

Process called "test_depth_first_search":
    Let graph be create_simple_undirected_graph()
    Let dfs_result be GraphTheory.depth_first_search(graph, "A", "preorder")
    
    UnitTest.assert_true(Dictionary.has_key(dfs_result, "visit_order"), "Should have visit order")
    UnitTest.assert_true(Dictionary.has_key(dfs_result, "discovery_times"), "Should have discovery times")
    UnitTest.assert_true(Dictionary.has_key(dfs_result, "finish_times"), "Should have finish times")

Process called "test_breadth_first_search":
    Let graph be create_simple_directed_graph()
    Let bfs_result be GraphTheory.breadth_first_search(graph, "A")
    
    UnitTest.assert_true(Dictionary.has_key(bfs_result, "distances"), "Should compute distances")
    UnitTest.assert_true(Dictionary.has_key(bfs_result, "parent_pointers"), "Should have parent pointers")
    UnitTest.assert_equals(Dictionary.get_integer(Dictionary.get(bfs_result, "distances"), "A"), 0, "Source distance should be 0")

Process called "test_iterative_deepening_search":
    Let graph be create_simple_undirected_graph()
    Let ids_result be GraphTheory.iterative_deepening_search(graph, "A", 3)
    
    UnitTest.assert_true(Dictionary.has_key(ids_result, "reachable_vertices"), "Should find reachable vertices")
    UnitTest.assert_true(Dictionary.has_key(ids_result, "depth_reached"), "Should track depth reached")

Process called "test_bidirectional_search":
    Let graph be create_weighted_graph()
    Let bidir_path be GraphTheory.bidirectional_search(graph, "S", "T")
    
    assert_path_valid(bidir_path, graph, "Bidirectional search")
    UnitTest.assert_equals(List.get(bidir_path.path_vertices, 0), "S", "Path should start at S")
    UnitTest.assert_equals(List.get(bidir_path.path_vertices, -1), "T", "Path should end at T")

Note: =====================================================================
Note: SHORTEST PATH TESTS
Note: =====================================================================

Process called "test_dijkstra_shortest_path":
    Let graph be create_weighted_graph()
    Let paths be GraphTheory.dijkstra_shortest_path(graph, "S")
    
    UnitTest.assert_true(Dictionary.has_key(paths, "T"), "Should find path to T")
    Let path_to_t be Dictionary.get(paths, "T")
    assert_path_valid(path_to_t, graph, "Dijkstra path")
    assert_float_approximately_equals(path_to_t.total_weight, 7.0, 0.001, "Should find optimal path S->B->T")

Process called "test_bellman_ford_shortest_path":
    Let graph be create_graph_with_negative_edges()
    Let paths be GraphTheory.bellman_ford_shortest_path(graph, "S")
    
    UnitTest.assert_true(Dictionary.has_key(paths, "has_negative_cycle"), "Should detect negative cycles")
    
    If not Dictionary.get_boolean(paths, "has_negative_cycle"):
        UnitTest.assert_true(Dictionary.has_key(paths, "distances"), "Should compute distances if no negative cycle")

Process called "test_floyd_warshall_all_pairs":
    Let graph be create_weighted_graph()
    Let all_paths be GraphTheory.floyd_warshall_all_pairs(graph)
    
    UnitTest.assert_true(Dictionary.has_key(all_paths, "S"), "Should have paths from S")
    Let paths_from_s be Dictionary.get(all_paths, "S")
    UnitTest.assert_true(Dictionary.has_key(paths_from_s, "T"), "Should have path S to T")

Process called "test_johnson_all_pairs":
    Let graph be create_weighted_graph()
    Let all_paths be GraphTheory.johnson_all_pairs(graph)
    
    Note: Compare with Floyd-Warshall results
    Let floyd_paths be GraphTheory.floyd_warshall_all_pairs(graph)
    
    For each source in Dictionary.keys(all_paths):
        Let johnson_source_paths be Dictionary.get(all_paths, source)
        Let floyd_source_paths be Dictionary.get(floyd_paths, source)
        
        For each target in Dictionary.keys(johnson_source_paths):
            Let johnson_path be Dictionary.get(johnson_source_paths, target)
            Let floyd_path be Dictionary.get(floyd_source_paths, target)
            assert_float_approximately_equals(johnson_path.total_weight, floyd_path.total_weight, 0.001, "Johnson and Floyd-Warshall should agree")

Process called "create_graph_with_negative_edges":
    Let vertices be List.from_array(["S", "A", "B", "T"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "S"], ["target", "A"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "-3.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "T"], ["weight", "2.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "S"], ["target", "T"], ["weight", "4.0"]]))
    
    Let adjacency_matrix be List.create()
    List.push(adjacency_matrix, List.from_array([0.0, 1.0, 0.0, 4.0]))
    List.push(adjacency_matrix, List.from_array([0.0, 0.0, -3.0, 0.0]))
    List.push(adjacency_matrix, List.from_array([0.0, 0.0, 0.0, 2.0]))
    List.push(adjacency_matrix, List.from_array([0.0, 0.0, 0.0, 0.0]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: True
        is_weighted: True
        adjacency_matrix: adjacency_matrix
        adjacency_list: Dictionary.create()
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Note: =====================================================================
Note: MINIMUM SPANNING TREE TESTS
Note: =====================================================================

Process called "test_kruskal_minimum_spanning_tree":
    Let graph be create_weighted_undirected_graph()
    Let mst be GraphTheory.kruskal_minimum_spanning_tree(graph)
    
    assert_spanning_tree_valid(mst, graph, "Kruskal MST")
    UnitTest.assert_equals(mst.construction_algorithm, "Kruskal", "Should identify algorithm used")

Process called "test_prim_minimum_spanning_tree":
    Let graph be create_weighted_undirected_graph()
    Let mst be GraphTheory.prim_minimum_spanning_tree(graph, "A")
    
    assert_spanning_tree_valid(mst, graph, "Prim MST")
    UnitTest.assert_equals(mst.construction_algorithm, "Prim", "Should identify algorithm used")

Process called "test_boruvka_minimum_spanning_tree":
    Let graph be create_weighted_undirected_graph()
    Let mst be GraphTheory.boruvka_minimum_spanning_tree(graph)
    
    assert_spanning_tree_valid(mst, graph, "Borůvka MST")
    UnitTest.assert_equals(mst.construction_algorithm, "Boruvka", "Should identify algorithm used")

Process called "test_mst_algorithms_agreement":
    Let graph be create_weighted_undirected_graph()
    
    Let kruskal_mst be GraphTheory.kruskal_minimum_spanning_tree(graph)
    Let prim_mst be GraphTheory.prim_minimum_spanning_tree(graph, "A")
    Let boruvka_mst be GraphTheory.boruvka_minimum_spanning_tree(graph)
    
    assert_float_approximately_equals(kruskal_mst.total_weight, prim_mst.total_weight, 0.001, "Kruskal and Prim should find same weight")
    assert_float_approximately_equals(prim_mst.total_weight, boruvka_mst.total_weight, 0.001, "Prim and Borůvka should find same weight")

Process called "test_steiner_tree_approximation":
    Let graph be create_weighted_undirected_graph()
    Let terminals be List.from_array(["A", "C", "E"])
    Let steiner_tree be GraphTheory.steiner_tree_approximation(graph, terminals)
    
    assert_spanning_tree_valid(steiner_tree, graph, "Steiner tree approximation")
    UnitTest.assert_true(steiner_tree.total_weight > 0.0, "Steiner tree should have positive weight")

Process called "create_weighted_undirected_graph":
    Let vertices be List.from_array(["A", "B", "C", "D", "E"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "2.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "C"], ["weight", "3.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "C"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "D"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "C"], ["target", "D"], ["weight", "4.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "C"], ["target", "E"], ["weight", "5.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "D"], ["target", "E"], ["weight", "1.0"]]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: False
        is_weighted: True
        adjacency_matrix: create_weighted_adjacency_matrix()
        adjacency_list: create_weighted_adjacency_list()
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_weighted_adjacency_matrix":
    Let matrix be List.create()
    List.push(matrix, List.from_array([0.0, 2.0, 3.0, 0.0, 0.0]))
    List.push(matrix, List.from_array([2.0, 0.0, 1.0, 1.0, 0.0]))
    List.push(matrix, List.from_array([3.0, 1.0, 0.0, 4.0, 5.0]))
    List.push(matrix, List.from_array([0.0, 1.0, 4.0, 0.0, 1.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 5.0, 1.0, 0.0]))
    Return matrix

Process called "create_weighted_adjacency_list":
    Let adjacency_list be Dictionary.create()
    Dictionary.set(adjacency_list, "A", List.from_array(["B", "C"]))
    Dictionary.set(adjacency_list, "B", List.from_array(["A", "C", "D"]))
    Dictionary.set(adjacency_list, "C", List.from_array(["A", "B", "D", "E"]))
    Dictionary.set(adjacency_list, "D", List.from_array(["B", "C", "E"]))
    Dictionary.set(adjacency_list, "E", List.from_array(["C", "D"]))
    Return adjacency_list

Note: =====================================================================
Note: TOPOLOGICAL SORTING TESTS
Note: =====================================================================

Process called "test_topological_sort_dfs":
    Let dag be create_dag_graph()
    Let topo_order be GraphTheory.topological_sort_dfs(dag)
    
    UnitTest.assert_equals(List.size(topo_order), List.size(dag.vertices), "Should include all vertices")
    UnitTest.assert_true(is_valid_topological_order(dag, topo_order), "Should be valid topological order")

Process called "test_topological_sort_kahn":
    Let dag be create_dag_graph()
    Let topo_order be GraphTheory.topological_sort_kahn(dag)
    
    UnitTest.assert_equals(List.size(topo_order), List.size(dag.vertices), "Should include all vertices")
    UnitTest.assert_true(is_valid_topological_order(dag, topo_order), "Should be valid topological order")

Process called "test_detect_cycle_directed":
    Let cyclic_graph be create_cyclic_directed_graph()
    Let acyclic_graph be create_dag_graph()
    
    Let cyclic_result be GraphTheory.detect_cycle_directed(cyclic_graph)
    Let acyclic_result be GraphTheory.detect_cycle_directed(acyclic_graph)
    
    UnitTest.assert_true(Dictionary.get_boolean(cyclic_result, "has_cycle"), "Should detect cycle")
    UnitTest.assert_false(Dictionary.get_boolean(acyclic_result, "has_cycle"), "Should detect no cycle")

Process called "create_dag_graph":
    Note: Directed acyclic graph for topological sorting
    Let vertices be List.from_array(["A", "B", "C", "D"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "C"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "D"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "C"], ["target", "D"], ["weight", "1.0"]]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: True
        is_weighted: True
        adjacency_matrix: create_dag_adjacency_matrix()
        adjacency_list: create_dag_adjacency_list()
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_cyclic_directed_graph":
    Let vertices be List.from_array(["A", "B", "C"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "C"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "C"], ["target", "A"], ["weight", "1.0"]]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: True
        is_weighted: True
        adjacency_matrix: create_simple_undirected_graph().adjacency_matrix
        adjacency_list: Dictionary.create()
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_dag_adjacency_matrix":
    Let matrix be List.create()
    List.push(matrix, List.from_array([0.0, 1.0, 1.0, 0.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 1.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 1.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 0.0]))
    Return matrix

Process called "create_dag_adjacency_list":
    Let adjacency_list be Dictionary.create()
    Dictionary.set(adjacency_list, "A", List.from_array(["B", "C"]))
    Dictionary.set(adjacency_list, "B", List.from_array(["D"]))
    Dictionary.set(adjacency_list, "C", List.from_array(["D"]))
    Dictionary.set(adjacency_list, "D", List.create())
    Return adjacency_list

Process called "is_valid_topological_order" that takes graph as GraphTheory.Graph, order as List[String] returns Boolean:
    Note: Check that all edges go from earlier to later in the order
    Let vertex_positions be Dictionary.create()
    For i from 0 to (List.size(order) - 1):
        Dictionary.set(vertex_positions, List.get(order, i), i)
    
    For each edge in graph.edges:
        Let source be Dictionary.get(edge, "source")
        Let target be Dictionary.get(edge, "target")
        Let source_pos be Dictionary.get(vertex_positions, source)
        Let target_pos be Dictionary.get(vertex_positions, target)
        
        If source_pos >= target_pos:
            Return False
    
    Return True

Note: =====================================================================
Note: CONNECTIVITY ANALYSIS TESTS
Note: =====================================================================

Process called "test_strongly_connected_components":
    Let directed_graph be create_scc_test_graph()
    Let sccs be GraphTheory.strongly_connected_components(directed_graph)
    
    UnitTest.assert_true(List.size(sccs) > 0, "Should find at least one component")
    
    Let total_vertices be 0
    For each component in sccs:
        total_vertices be total_vertices + List.size(component)
    UnitTest.assert_equals(total_vertices, List.size(directed_graph.vertices), "All vertices should be in exactly one SCC")

Process called "test_analyze_graph_connectivity":
    Let graph be create_simple_undirected_graph()
    Let connectivity be GraphTheory.analyze_graph_connectivity(graph)
    
    assert_connectivity_result_valid(connectivity, graph, "Graph connectivity analysis")
    UnitTest.assert_true(connectivity.is_connected, "Triangle graph should be connected")
    UnitTest.assert_equals(connectivity.component_count, 1, "Connected graph should have 1 component")

Process called "test_find_bridges":
    Let graph_with_bridge be create_bridge_graph()
    Let bridges be GraphTheory.find_bridges(graph_with_bridge)
    
    UnitTest.assert_true(List.size(bridges) > 0, "Should find bridge edges")
    UnitTest.assert_true(List.contains(bridges, "B-D"), "Should identify the bridge edge")

Process called "test_find_articulation_points":
    Let graph be create_bridge_graph()
    Let articulation_points be GraphTheory.find_articulation_points(graph)
    
    UnitTest.assert_true(List.size(articulation_points) > 0, "Should find articulation points")
    UnitTest.assert_true(List.contains(articulation_points, "B"), "B should be an articulation point")

Process called "test_compute_vertex_connectivity":
    Let graph be create_simple_undirected_graph()
    Let connectivity be GraphTheory.compute_vertex_connectivity(graph, "A", "C")
    
    UnitTest.assert_true(connectivity > 0, "Connected vertices should have positive connectivity")
    UnitTest.assert_true(connectivity <= List.size(graph.vertices) - 2, "Connectivity bounded by vertex count")

Process called "create_scc_test_graph":
    Let vertices be List.from_array(["A", "B", "C", "D"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "C"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "C"], ["target", "A"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "C"], ["target", "D"], ["weight", "1.0"]]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: True
        is_weighted: True
        adjacency_matrix: create_scc_adjacency_matrix()
        adjacency_list: Dictionary.create()
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_bridge_graph":
    Note: Graph with bridge: (A-B-C) connected by bridge to (D-E)
    Let vertices be List.from_array(["A", "B", "C", "D", "E"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "C"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "C"], ["target", "A"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "D"], ["weight", "1.0"]]))  Note: Bridge
    List.push(edges, Dictionary.from_entries([["source", "D"], ["target", "E"], ["weight", "1.0"]]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: False
        is_weighted: True
        adjacency_matrix: create_bridge_adjacency_matrix()
        adjacency_list: Dictionary.create()
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_scc_adjacency_matrix":
    Let matrix be List.create()
    List.push(matrix, List.from_array([0.0, 1.0, 0.0, 0.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 1.0, 0.0]))
    List.push(matrix, List.from_array([1.0, 0.0, 0.0, 1.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 0.0]))
    Return matrix

Process called "create_bridge_adjacency_matrix":
    Let matrix be List.create()
    List.push(matrix, List.from_array([0.0, 1.0, 1.0, 0.0, 0.0]))
    List.push(matrix, List.from_array([1.0, 0.0, 1.0, 1.0, 0.0]))
    List.push(matrix, List.from_array([1.0, 1.0, 0.0, 0.0, 0.0]))
    List.push(matrix, List.from_array([0.0, 1.0, 0.0, 0.0, 1.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 1.0, 0.0]))
    Return matrix

Note: =====================================================================
Note: MAXIMUM FLOW TESTS
Note: =====================================================================

Process called "test_ford_fulkerson_max_flow":
    Let flow_graph be create_flow_network()
    Let max_flow be GraphTheory.ford_fulkerson_max_flow(flow_graph, "S", "T")
    
    UnitTest.assert_true(Dictionary.has_key(max_flow, "max_flow_value"), "Should compute max flow value")
    UnitTest.assert_true(Dictionary.has_key(max_flow, "flow_assignment"), "Should provide flow assignment")
    UnitTest.assert_true(Dictionary.get_float(max_flow, "max_flow_value") > 0.0, "Max flow should be positive")

Process called "test_edmonds_karp_max_flow":
    Let flow_graph be create_flow_network()
    Let max_flow be GraphTheory.edmonds_karp_max_flow(flow_graph, "S", "T")
    
    UnitTest.assert_true(Dictionary.has_key(max_flow, "max_flow_value"), "Should compute max flow value")
    UnitTest.assert_true(Dictionary.has_key(max_flow, "augmenting_paths"), "Should track augmenting paths")

Process called "test_dinic_max_flow":
    Let flow_graph be create_flow_network()
    Let max_flow be GraphTheory.dinic_max_flow(flow_graph, "S", "T")
    
    UnitTest.assert_true(Dictionary.has_key(max_flow, "max_flow_value"), "Should compute max flow value")
    UnitTest.assert_true(Dictionary.has_key(max_flow, "blocking_flows"), "Should use blocking flows")

Process called "test_push_relabel_max_flow":
    Let flow_graph be create_flow_network()
    Let max_flow be GraphTheory.push_relabel_max_flow(flow_graph, "S", "T")
    
    UnitTest.assert_true(Dictionary.has_key(max_flow, "max_flow_value"), "Should compute max flow value")
    UnitTest.assert_true(Dictionary.has_key(max_flow, "preflow_operations"), "Should track preflow operations")

Process called "test_max_flow_min_cut_theorem":
    Let flow_graph be create_flow_network()
    
    Let ford_fulkerson_flow be GraphTheory.ford_fulkerson_max_flow(flow_graph, "S", "T")
    Let edmonds_karp_flow be GraphTheory.edmonds_karp_max_flow(flow_graph, "S", "T")
    Let dinic_flow be GraphTheory.dinic_max_flow(flow_graph, "S", "T")
    
    Let ff_value be Dictionary.get_float(ford_fulkerson_flow, "max_flow_value")
    Let ek_value be Dictionary.get_float(edmonds_karp_flow, "max_flow_value")
    Let dinic_value be Dictionary.get_float(dinic_flow, "max_flow_value")
    
    assert_float_approximately_equals(ff_value, ek_value, 0.001, "Ford-Fulkerson and Edmonds-Karp should agree")
    assert_float_approximately_equals(ek_value, dinic_value, 0.001, "Edmonds-Karp and Dinic should agree")

Note: =====================================================================
Note: MATCHING TESTS
Note: =====================================================================

Process called "test_maximum_bipartite_matching":
    Let bipartite_graph be create_bipartite_graph()
    Let left_set be List.from_array(["A1", "A2", "A3"])
    Let right_set be List.from_array(["B1", "B2", "B3"])
    
    Let matching be GraphTheory.maximum_bipartite_matching(bipartite_graph, left_set, right_set)
    
    assert_matching_valid(matching, bipartite_graph, "Bipartite matching")
    UnitTest.assert_true(Dictionary.size(matching) > 0, "Should find some matching")

Process called "test_maximum_weight_bipartite_matching":
    Let bipartite_graph be create_bipartite_graph()
    Let left_set be List.from_array(["A1", "A2", "A3"])
    Let right_set be List.from_array(["B1", "B2", "B3"])
    
    Let weight_matching be GraphTheory.maximum_weight_bipartite_matching(bipartite_graph, left_set, right_set)
    
    assert_matching_valid(weight_matching, bipartite_graph, "Weighted bipartite matching")
    UnitTest.assert_true(Dictionary.has_key(weight_matching, "total_weight"), "Should compute total weight")

Process called "test_maximum_general_matching":
    Let general_graph be create_simple_undirected_graph()
    Let matching be GraphTheory.maximum_general_matching(general_graph)
    
    assert_matching_valid(matching, general_graph, "General matching")

Process called "test_perfect_matching_detection":
    Let complete_graph be GraphTheory.create_complete_graph(4, Dictionary.from_entries([["uniform", "1.0"]]))
    Let incomplete_graph be create_simple_undirected_graph()
    
    Let perfect_exists be GraphTheory.perfect_matching_detection(complete_graph)
    Let no_perfect be GraphTheory.perfect_matching_detection(incomplete_graph)
    
    UnitTest.assert_true(perfect_exists, "Complete graph K4 should have perfect matching")
    UnitTest.assert_false(no_perfect, "Triangle graph cannot have perfect matching")

Note: =====================================================================
Note: CLIQUE AND INDEPENDENT SET TESTS
Note: =====================================================================

Process called "test_find_maximum_clique":
    Let complete_graph be GraphTheory.create_complete_graph(4, Dictionary.from_entries([["uniform", "1.0"]]))
    Let max_clique be GraphTheory.find_maximum_clique(complete_graph)
    
    UnitTest.assert_equals(List.size(max_clique), 4, "Complete graph K4 should have clique of size 4")

Process called "test_find_maximum_independent_set":
    Let path_graph be create_path_graph()
    Let max_independent be GraphTheory.find_maximum_independent_set(path_graph)
    
    UnitTest.assert_true(List.size(max_independent) > 0, "Should find independent set")
    UnitTest.assert_true(is_independent_set(path_graph, max_independent), "Should be valid independent set")

Process called "test_find_minimum_vertex_cover":
    Let triangle_graph be create_simple_undirected_graph()
    Let vertex_cover be GraphTheory.find_minimum_vertex_cover(triangle_graph)
    
    UnitTest.assert_true(List.size(vertex_cover) >= 2, "Triangle needs at least 2 vertices to cover all edges")
    UnitTest.assert_true(is_vertex_cover(triangle_graph, vertex_cover), "Should be valid vertex cover")

Process called "test_enumerate_all_cliques":
    Let triangle_graph be create_simple_undirected_graph()
    Let all_cliques be GraphTheory.enumerate_all_cliques(triangle_graph, 2)
    
    UnitTest.assert_true(List.size(all_cliques) > 0, "Should find cliques of size >= 2")
    
    For each clique in all_cliques:
        UnitTest.assert_true(List.size(clique) >= 2, "All cliques should have minimum size")
        UnitTest.assert_true(is_clique(triangle_graph, clique), "Should be valid clique")

Process called "create_path_graph":
    Let vertices be List.from_array(["A", "B", "C", "D", "E"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "C"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "C"], ["target", "D"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "D"], ["target", "E"], ["weight", "1.0"]]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: False
        is_weighted: True
        adjacency_matrix: create_path_adjacency_matrix()
        adjacency_list: create_path_adjacency_list()
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_path_adjacency_matrix":
    Let matrix be List.create()
    List.push(matrix, List.from_array([0.0, 1.0, 0.0, 0.0, 0.0]))
    List.push(matrix, List.from_array([1.0, 0.0, 1.0, 0.0, 0.0]))
    List.push(matrix, List.from_array([0.0, 1.0, 0.0, 1.0, 0.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 1.0, 0.0, 1.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 1.0, 0.0]))
    Return matrix

Process called "create_path_adjacency_list":
    Let adjacency_list be Dictionary.create()
    Dictionary.set(adjacency_list, "A", List.from_array(["B"]))
    Dictionary.set(adjacency_list, "B", List.from_array(["A", "C"]))
    Dictionary.set(adjacency_list, "C", List.from_array(["B", "D"]))
    Dictionary.set(adjacency_list, "D", List.from_array(["C", "E"]))
    Dictionary.set(adjacency_list, "E", List.from_array(["D"]))
    Return adjacency_list

Process called "is_independent_set" that takes graph as GraphTheory.Graph, vertices as List[String] returns Boolean:
    For each vertex1 in vertices:
        For each vertex2 in vertices:
            If not String.equals(vertex1, vertex2):
                If has_edge(graph, vertex1, vertex2):
                    Return False
    Return True

Process called "is_vertex_cover" that takes graph as GraphTheory.Graph, cover as List[String] returns Boolean:
    For each edge in graph.edges:
        Let source be Dictionary.get(edge, "source")
        Let target be Dictionary.get(edge, "target")
        
        If not (List.contains(cover, source) or List.contains(cover, target)):
            Return False
    Return True

Process called "is_clique" that takes graph as GraphTheory.Graph, vertices as List[String] returns Boolean:
    For each vertex1 in vertices:
        For each vertex2 in vertices:
            If not String.equals(vertex1, vertex2):
                If not has_edge(graph, vertex1, vertex2):
                    Return False
    Return True

Process called "has_edge" that takes graph as GraphTheory.Graph, vertex1 as String, vertex2 as String returns Boolean:
    For each edge in graph.edges:
        Let source be Dictionary.get(edge, "source")
        Let target be Dictionary.get(edge, "target")
        
        If (String.equals(source, vertex1) and String.equals(target, vertex2)):
            Return True
        If not graph.is_directed and (String.equals(source, vertex2) and String.equals(target, vertex1)):
            Return True
    Return False

Note: =====================================================================
Note: GRAPH COLORING TESTS
Note: =====================================================================

Process called "test_graph_coloring_greedy":
    Let graph be create_simple_undirected_graph()
    Let vertex_order be List.from_array(["A", "B", "C"])
    Let coloring be GraphTheory.graph_coloring_greedy(graph, vertex_order)
    
    assert_coloring_valid(coloring, graph, "Greedy coloring")
    UnitTest.assert_equals(Dictionary.size(coloring), 3, "Should color all vertices")

Process called "test_compute_chromatic_number":
    Let triangle_graph be create_simple_undirected_graph()
    Let path_graph be create_path_graph()
    
    Let triangle_chromatic be GraphTheory.compute_chromatic_number(triangle_graph)
    Let path_chromatic be GraphTheory.compute_chromatic_number(path_graph)
    
    UnitTest.assert_equals(triangle_chromatic, 3, "Triangle should need 3 colors")
    UnitTest.assert_equals(path_chromatic, 2, "Path should need 2 colors")

Process called "test_edge_coloring":
    Let graph be create_simple_undirected_graph()
    Let edge_coloring be GraphTheory.edge_coloring(graph)
    
    UnitTest.assert_true(Dictionary.size(edge_coloring) > 0, "Should color edges")
    
    Note: Verify no adjacent edges have same color
    For each vertex in graph.vertices:
        Let incident_edges be get_incident_edges(graph, vertex)
        Let colors_used be List.create()
        
        For each edge_id in incident_edges:
            Let color be Dictionary.get(edge_coloring, edge_id)
            UnitTest.assert_false(List.contains(colors_used, color), "Adjacent edges must have different colors")
            List.push(colors_used, color)

Process called "test_list_coloring":
    Let graph be create_simple_undirected_graph()
    Let color_lists be Dictionary.create()
    Dictionary.set(color_lists, "A", List.from_array([1, 2]))
    Dictionary.set(color_lists, "B", List.from_array([1, 3]))
    Dictionary.set(color_lists, "C", List.from_array([2, 3]))
    
    Let list_coloring be GraphTheory.list_coloring(graph, color_lists)
    
    assert_coloring_valid(list_coloring, graph, "List coloring")
    
    Note: Verify colors are from allowed lists
    For each vertex in Dictionary.keys(list_coloring):
        Let color be Dictionary.get(list_coloring, vertex)
        Let allowed_colors be Dictionary.get(color_lists, vertex)
        UnitTest.assert_true(List.contains(allowed_colors, color), "Color must be from allowed list")

Process called "get_incident_edges" that takes graph as GraphTheory.Graph, vertex as String returns List[String]:
    Let incident_edges be List.create()
    
    For i from 0 to (List.size(graph.edges) - 1):
        Let edge be List.get(graph.edges, i)
        Let source be Dictionary.get(edge, "source")
        Let target be Dictionary.get(edge, "target")
        
        If String.equals(source, vertex) or String.equals(target, vertex):
            Let edge_id be source + "-" + target
            List.push(incident_edges, edge_id)
    
    Return incident_edges

Note: =====================================================================
Note: PLANARITY TESTS
Note: =====================================================================

Process called "test_planarity":
    Let planar_graph be create_simple_undirected_graph()
    Let non_planar_graph be GraphTheory.create_complete_graph(5, Dictionary.from_entries([["uniform", "1.0"]]))
    
    UnitTest.assert_true(GraphTheory.test_planarity(planar_graph), "Triangle should be planar")
    UnitTest.assert_false(GraphTheory.test_planarity(non_planar_graph), "K5 should not be planar")

Process called "test_find_planar_embedding":
    Let planar_graph be create_simple_undirected_graph()
    Let embedding be GraphTheory.find_planar_embedding(planar_graph)
    
    UnitTest.assert_true(Dictionary.size(embedding) > 0, "Should find planar embedding")
    UnitTest.assert_true(Dictionary.has_key(embedding, "face_list"), "Should identify faces")

Process called "test_compute_crossing_number":
    Let k5_graph be GraphTheory.create_complete_graph(5, Dictionary.from_entries([["uniform", "1.0"]]))
    Let crossing_number be GraphTheory.compute_crossing_number(k5_graph)
    
    UnitTest.assert_equals(crossing_number, 1, "K5 should have crossing number 1")

Process called "test_find_kuratowski_subdivision":
    Let k5_graph be GraphTheory.create_complete_graph(5, Dictionary.from_entries([["uniform", "1.0"]]))
    Let kuratowski be GraphTheory.find_kuratowski_subdivision(k5_graph)
    
    UnitTest.assert_true(Dictionary.has_key(kuratowski, "subdivision_type"), "Should identify subdivision type")
    UnitTest.assert_true(Dictionary.has_key(kuratowski, "forbidden_subgraph"), "Should find forbidden subgraph")

Note: =====================================================================
Note: NETWORK ANALYSIS TESTS
Note: =====================================================================

Process called "test_compute_centrality_measures":
    Let graph be create_weighted_undirected_graph()
    Let centralities be GraphTheory.compute_centrality_measures(graph)
    
    UnitTest.assert_true(Dictionary.has_key(centralities, "betweenness"), "Should compute betweenness centrality")
    UnitTest.assert_true(Dictionary.has_key(centralities, "closeness"), "Should compute closeness centrality")
    UnitTest.assert_true(Dictionary.has_key(centralities, "degree"), "Should compute degree centrality")
    UnitTest.assert_true(Dictionary.has_key(centralities, "eigenvector"), "Should compute eigenvector centrality")

Process called "test_detect_communities":
    Let graph be create_community_graph()
    Let communities be GraphTheory.detect_communities(graph, "modularity_optimization")
    
    UnitTest.assert_true(List.size(communities) > 1, "Should detect multiple communities")
    
    Let total_vertices be 0
    For each community in communities:
        total_vertices be total_vertices + List.size(community)
    UnitTest.assert_equals(total_vertices, List.size(graph.vertices), "All vertices should be assigned to communities")

Process called "test_analyze_small_world_properties":
    Let small_world_graph be create_small_world_graph()
    Let properties be GraphTheory.analyze_small_world_properties(small_world_graph)
    
    UnitTest.assert_true(Dictionary.has_key(properties, "clustering_coefficient"), "Should compute clustering coefficient")
    UnitTest.assert_true(Dictionary.has_key(properties, "average_path_length"), "Should compute average path length")
    UnitTest.assert_true(Dictionary.has_key(properties, "small_world_index"), "Should compute small-world index")

Process called "test_compute_network_resilience":
    Let graph be create_weighted_undirected_graph()
    Let resilience be GraphTheory.compute_network_resilience(graph, "random_removal")
    
    UnitTest.assert_true(Dictionary.has_key(resilience, "critical_threshold"), "Should find critical threshold")
    UnitTest.assert_true(Dictionary.has_key(resilience, "robustness_measure"), "Should measure robustness")

Process called "create_community_graph":
    Note: Graph with two obvious communities
    Let vertices be List.from_array(["A1", "A2", "A3", "B1", "B2", "B3"])
    Let edges be List.create()
    
    Note: Community A - densely connected
    List.push(edges, Dictionary.from_entries([["source", "A1"], ["target", "A2"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "A2"], ["target", "A3"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "A3"], ["target", "A1"], ["weight", "1.0"]]))
    
    Note: Community B - densely connected  
    List.push(edges, Dictionary.from_entries([["source", "B1"], ["target", "B2"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B2"], ["target", "B3"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B3"], ["target", "B1"], ["weight", "1.0"]]))
    
    Note: Sparse inter-community connections
    List.push(edges, Dictionary.from_entries([["source", "A1"], ["target", "B1"], ["weight", "0.5"]]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: False
        is_weighted: True
        adjacency_matrix: create_community_adjacency_matrix()
        adjacency_list: Dictionary.create()
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_small_world_graph":
    Note: Small-world network with high clustering and low path length
    Return GraphTheory.create_random_graph(20, 0.1, 54321)

Process called "create_community_adjacency_matrix":
    Let matrix be List.create()
    List.push(matrix, List.from_array([0.0, 1.0, 1.0, 0.5, 0.0, 0.0]))
    List.push(matrix, List.from_array([1.0, 0.0, 1.0, 0.0, 0.0, 0.0]))
    List.push(matrix, List.from_array([1.0, 1.0, 0.0, 0.0, 0.0, 0.0]))
    List.push(matrix, List.from_array([0.5, 0.0, 0.0, 0.0, 1.0, 1.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 1.0, 0.0, 1.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 1.0, 1.0, 0.0]))
    Return matrix

Note: =====================================================================
Note: UTILITY AND OPTIMIZATION TESTS
Note: =====================================================================

Process called "test_validate_graph_structure":
    Let valid_graph be create_simple_undirected_graph()
    Let invalid_graph be create_invalid_graph()
    
    Let validation_rules be Dictionary.from_entries([["check_connectivity", "true"], ["check_weights", "true"]])
    
    Let valid_result be GraphTheory.validate_graph_structure(valid_graph, validation_rules)
    Let invalid_result be GraphTheory.validate_graph_structure(invalid_graph, validation_rules)
    
    UnitTest.assert_true(Dictionary.get_boolean(valid_result, "is_valid"), "Valid graph should pass validation")
    UnitTest.assert_false(Dictionary.get_boolean(invalid_result, "is_valid"), "Invalid graph should fail validation")

Process called "test_optimize_graph_algorithms":
    Let algorithm_config be Dictionary.from_entries([
        ["algorithm", "shortest_path"],
        ["graph_size", "medium"],
        ["sparsity", "dense"]
    ])
    
    Let performance_requirements be Dictionary.from_entries([
        ["max_time_ms", "100.0"],
        ["max_memory_mb", "50.0"]
    ])
    
    Let optimization be GraphTheory.optimize_graph_algorithms(algorithm_config, performance_requirements)
    
    UnitTest.assert_true(Dictionary.has_key(optimization, "recommended_algorithm"), "Should recommend algorithm")
    UnitTest.assert_true(Dictionary.has_key(optimization, "parameter_settings"), "Should provide parameters")

Process called "test_benchmark_graph_algorithms":
    Let algorithms be List.from_array(["dijkstra", "bellman_ford", "floyd_warshall"])
    Let test_graphs be List.from_array([create_simple_undirected_graph(), create_weighted_graph()])
    
    Let benchmarks be GraphTheory.benchmark_graph_algorithms(algorithms, test_graphs)
    
    UnitTest.assert_true(Dictionary.has_key(benchmarks, "dijkstra"), "Should benchmark Dijkstra")
    UnitTest.assert_true(Dictionary.has_key(benchmarks, "bellman_ford"), "Should benchmark Bellman-Ford")

Process called "test_troubleshoot_graph_issues":
    Let issue be Dictionary.from_entries([
        ["problem", "slow_shortest_path"],
        ["graph_size", "10000"],
        ["edge_count", "50000"]
    ])
    
    Let suggestions be GraphTheory.troubleshoot_graph_issues(issue)
    
    UnitTest.assert_false(List.is_empty(suggestions), "Should provide troubleshooting suggestions")

Process called "create_invalid_graph":
    Note: Graph with inconsistent adjacency representations
    Let vertices be List.from_array(["A", "B"])
    Let edges = List.create()
    
    Note: Add edge but not in adjacency list/matrix
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "1.0"]]))
    
    Let empty_adjacency_list be Dictionary.create()
    Dictionary.set(empty_adjacency_list, "A", List.create())
    Dictionary.set(empty_adjacency_list, "B", List.create())
    
    Let inconsistent_matrix be List.create()
    List.push(inconsistent_matrix, List.from_array([0.0, 0.0]))  Note: No edge in matrix
    List.push(inconsistent_matrix, List.from_array([0.0, 0.0]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: False
        is_weighted: True
        adjacency_matrix: inconsistent_matrix
        adjacency_list: empty_adjacency_list
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Note: =====================================================================
Note: COMPREHENSIVE INTEGRATION TESTS
Note: =====================================================================

Process called "test_shortest_path_algorithms_comparison":
    Let graph be create_weighted_graph()
    
    Let dijkstra_paths be GraphTheory.dijkstra_shortest_path(graph, "S")
    Let bellman_ford_paths be GraphTheory.bellman_ford_shortest_path(graph, "S")
    
    Note: Compare distances for reachable vertices
    For each vertex in Dictionary.keys(dijkstra_paths):
        Let dijkstra_distance be Dictionary.get(dijkstra_paths, vertex).total_weight
        Let bellman_ford_distance be Dictionary.get(bellman_ford_paths, vertex).total_weight
        
        assert_float_approximately_equals(dijkstra_distance, bellman_ford_distance, 0.001, "Dijkstra and Bellman-Ford should agree on distances")

Process called "test_mst_weight_optimality":
    Let graph be create_weighted_undirected_graph()
    
    Let kruskal_mst be GraphTheory.kruskal_minimum_spanning_tree(graph)
    Let prim_mst be GraphTheory.prim_minimum_spanning_tree(graph, "A")
    
    Note: Both should find optimal MST weight
    assert_float_approximately_equals(kruskal_mst.total_weight, prim_mst.total_weight, 0.001, "MST algorithms should find same optimal weight")

Process called "test_connectivity_and_flows":
    Let flow_graph be create_flow_network()
    
    Let connectivity_analysis be GraphTheory.analyze_graph_connectivity(flow_graph)
    Let max_flow_result be GraphTheory.ford_fulkerson_max_flow(flow_graph, "S", "T")
    
    UnitTest.assert_true(connectivity_analysis.is_connected, "Flow network should be connected")
    UnitTest.assert_true(Dictionary.get_float(max_flow_result, "max_flow_value") > 0.0, "Should have positive max flow")

Process called "test_complete_graph_analysis_pipeline":
    Note: Test complete analysis of a graph
    Let graph be create_weighted_undirected_graph()
    
    Note: Structural analysis
    Let connectivity be GraphTheory.analyze_graph_connectivity(graph)
    Let bridges be GraphTheory.find_bridges(graph)
    Let articulation_points be GraphTheory.find_articulation_points(graph)
    
    Note: Algorithmic analysis
    Let mst be GraphTheory.kruskal_minimum_spanning_tree(graph)
    Let paths be GraphTheory.dijkstra_shortest_path(graph, "A")
    Let centralities be GraphTheory.compute_centrality_measures(graph)
    
    Note: Optimization
    Let coloring be GraphTheory.graph_coloring_greedy(graph, graph.vertices)
    
    assert_connectivity_result_valid(connectivity, graph, "Connectivity analysis")
    assert_spanning_tree_valid(mst, graph, "MST analysis")
    assert_coloring_valid(coloring, graph, "Coloring analysis")

Note: =====================================================================
Note: PERFORMANCE AND SCALABILITY TESTS
Note: =====================================================================

Process called "test_large_graph_shortest_paths":
    Let large_graph be GraphTheory.create_random_graph(100, 0.1, 98765)
    
    Let start_time be Time.get_current_milliseconds()
    Let paths be GraphTheory.dijkstra_shortest_path(large_graph, List.get(large_graph.vertices, 0))
    Let end_time be Time.get_current_milliseconds()
    
    UnitTest.assert_true((end_time - start_time) < 5000, "Large graph shortest paths should complete within 5 seconds")
    UnitTest.assert_true(Dictionary.size(paths) > 0, "Should find paths in large graph")

Process called "test_large_graph_mst":
    Let large_graph be GraphTheory.create_random_graph(200, 0.05, 11111)
    
    Let start_time be Time.get_current_milliseconds()
    Let mst be GraphTheory.kruskal_minimum_spanning_tree(large_graph)
    Let end_time be Time.get_current_milliseconds()
    
    UnitTest.assert_true((end_time - start_time) < 3000, "Large graph MST should complete within 3 seconds")
    assert_spanning_tree_valid(mst, large_graph, "Large graph MST")

Process called "test_dense_graph_operations":
    Let dense_graph be GraphTheory.create_complete_graph(50, Dictionary.from_entries([["uniform", "1.0"]]))
    
    Let coloring be GraphTheory.graph_coloring_greedy(dense_graph, dense_graph.vertices)
    Let max_clique be GraphTheory.find_maximum_clique(dense_graph)
    
    UnitTest.assert_equals(List.size(max_clique), 50, "Complete graph should have clique of all vertices")
    assert_coloring_valid(coloring, dense_graph, "Dense graph coloring")

Note: =====================================================================
Note: ERROR HANDLING AND EDGE CASE TESTS
Note: =====================================================================

Process called "test_empty_graph_operations":
    Let empty_graph be GraphTheory.create_empty_graph(1, False)
    
    Let paths be GraphTheory.dijkstra_shortest_path(empty_graph, List.get(empty_graph.vertices, 0))
    Let connectivity = GraphTheory.analyze_graph_connectivity(empty_graph)
    
    UnitTest.assert_equals(Dictionary.size(paths), 1, "Should have path to self only")
    UnitTest.assert_equals(connectivity.component_count, 1, "Single vertex is connected component")

Process called "test_disconnected_graph_analysis":
    Let disconnected_graph be create_disconnected_graph()
    Let connectivity be GraphTheory.analyze_graph_connectivity(disconnected_graph)
    
    UnitTest.assert_false(connectivity.is_connected, "Should detect disconnection")
    UnitTest.assert_true(connectivity.component_count > 1, "Should find multiple components")

Process called "test_self_loop_handling":
    Let graph_with_loops be create_graph_with_self_loops()
    
    Let paths be GraphTheory.dijkstra_shortest_path(graph_with_loops, "A")
    Let coloring be GraphTheory.graph_coloring_greedy(graph_with_loops, graph_with_loops.vertices)
    
    UnitTest.assert_true(Dictionary.size(paths) > 0, "Should handle self loops in shortest paths")
    assert_coloring_valid(coloring, graph_with_loops, "Coloring with self loops")

Process called "test_negative_weight_cycle_detection":
    Let graph_with_negative_cycle be create_negative_cycle_graph()
    Let bellman_ford_result be GraphTheory.bellman_ford_shortest_path(graph_with_negative_cycle, "A")
    
    UnitTest.assert_true(Dictionary.get_boolean(bellman_ford_result, "has_negative_cycle"), "Should detect negative cycle")

Process called "create_disconnected_graph":
    Let vertices be List.from_array(["A", "B", "C", "D"])
    Let edges be List.create()
    
    Note: Two disconnected components: A-B and C-D
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "C"], ["target", "D"], ["weight", "1.0"]]))
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: False
        is_weighted: True
        adjacency_matrix: create_disconnected_adjacency_matrix()
        adjacency_list: Dictionary.create()
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_graph_with_self_loops":
    Let vertices be List.from_array(["A", "B"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "A"], ["weight", "1.0"]]))  Note: Self loop
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "2.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "B"], ["weight", "1.0"]]))  Note: Self loop
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: False
        is_weighted: True
        adjacency_matrix: List.from_array([List.from_array([1.0, 2.0]), List.from_array([2.0, 1.0])])
        adjacency_list: Dictionary.create()
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_negative_cycle_graph":
    Let vertices be List.from_array(["A", "B", "C"])
    Let edges be List.create()
    
    List.push(edges, Dictionary.from_entries([["source", "A"], ["target", "B"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "B"], ["target", "C"], ["weight", "1.0"]]))
    List.push(edges, Dictionary.from_entries([["source", "C"], ["target", "A"], ["weight", "-5.0"]]))  Note: Creates negative cycle
    
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: True
        is_weighted: True
        adjacency_matrix: List.create()
        adjacency_list: Dictionary.create()
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "create_disconnected_adjacency_matrix":
    Let matrix be List.create()
    List.push(matrix, List.from_array([0.0, 1.0, 0.0, 0.0]))
    List.push(matrix, List.from_array([1.0, 0.0, 0.0, 0.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 0.0, 1.0]))
    List.push(matrix, List.from_array([0.0, 0.0, 1.0, 0.0]))
    Return matrix

Note: =====================================================================
Note: SPECIALIZED ALGORITHM TESTS
Note: =====================================================================

Process called "test_quicksort_edges_by_weight":
    Let edges be List.create()
    List.push(edges, Dictionary.from_entries([["weight", 5.0]]))
    List.push(edges, Dictionary.from_entries([["weight", 1.0]]))
    List.push(edges, Dictionary.from_entries([["weight", 3.0]]))
    List.push(edges, Dictionary.from_entries([["weight", 2.0]]))
    
    Let sorted_edges be GraphTheory.quicksort_edges_by_weight(edges, 0, 3)
    
    UnitTest.assert_equals(List.size(sorted_edges), 4, "Should preserve all edges")
    UnitTest.assert_true(Dictionary.get_float(List.get(sorted_edges, 0), "weight") <= Dictionary.get_float(List.get(sorted_edges, 1), "weight"), "Should be sorted by weight")

Process called "test_steiner_tree_exact_small":
    Let small_graph be create_simple_undirected_graph()
    Let terminals be List.from_array(["A", "C"])
    
    Let exact_steiner be GraphTheory.steiner_tree_exact_small(small_graph, terminals)
    
    assert_spanning_tree_valid(exact_steiner, small_graph, "Exact Steiner tree")
    UnitTest.assert_true(exact_steiner.total_weight <= create_minimum_terminal_spanning_weight(small_graph, terminals), "Steiner tree should be no worse than terminal spanning tree")

Process called "create_minimum_terminal_spanning_weight" that takes graph as GraphTheory.Graph, terminals as List[String] returns Float:
    Note: Compute minimum spanning tree weight over terminal vertices only
    Let terminal_edges be List.create()
    
    For each edge in graph.edges:
        Let source be Dictionary.get(edge, "source")
        Let target be Dictionary.get(edge, "target")
        
        If List.contains(terminals, source) and List.contains(terminals, target):
            List.push(terminal_edges, edge)
    
    Note: Return sum of lightest edges connecting terminals
    Let total_weight be 0.0
    For each edge in terminal_edges:
        total_weight be total_weight + Float.parse(Dictionary.get(edge, "weight"))
    
    Return total_weight

Note: =====================================================================
Note: TEST SUITE COORDINATION
Note: =====================================================================

Process called "run_all_graph_theory_tests":
    UnitTest.start_test_suite("Graph Theory Module Tests")
    
    Note: Graph Creation Tests
    UnitTest.run_test("test_create_empty_graph", test_create_empty_graph)
    UnitTest.run_test("test_create_complete_graph", test_create_complete_graph)
    UnitTest.run_test("test_create_cycle_graph", test_create_cycle_graph)
    UnitTest.run_test("test_create_random_graph", test_create_random_graph)
    
    Note: Graph Representation Tests
    UnitTest.run_test("test_convert_to_adjacency_matrix", test_convert_to_adjacency_matrix)
    UnitTest.run_test("test_convert_to_adjacency_list", test_convert_to_adjacency_list)
    UnitTest.run_test("test_convert_to_edge_list", test_convert_to_edge_list)
    UnitTest.run_test("test_convert_to_incidence_matrix", test_convert_to_incidence_matrix)
    
    Note: Graph Traversal Tests
    UnitTest.run_test("test_depth_first_search", test_depth_first_search)
    UnitTest.run_test("test_breadth_first_search", test_breadth_first_search)
    UnitTest.run_test("test_iterative_deepening_search", test_iterative_deepening_search)
    UnitTest.run_test("test_bidirectional_search", test_bidirectional_search)
    
    Note: Shortest Path Tests
    UnitTest.run_test("test_dijkstra_shortest_path", test_dijkstra_shortest_path)
    UnitTest.run_test("test_bellman_ford_shortest_path", test_bellman_ford_shortest_path)
    UnitTest.run_test("test_floyd_warshall_all_pairs", test_floyd_warshall_all_pairs)
    UnitTest.run_test("test_johnson_all_pairs", test_johnson_all_pairs)
    
    Note: Minimum Spanning Tree Tests
    UnitTest.run_test("test_kruskal_minimum_spanning_tree", test_kruskal_minimum_spanning_tree)
    UnitTest.run_test("test_prim_minimum_spanning_tree", test_prim_minimum_spanning_tree)
    UnitTest.run_test("test_boruvka_minimum_spanning_tree", test_boruvka_minimum_spanning_tree)
    UnitTest.run_test("test_mst_algorithms_agreement", test_mst_algorithms_agreement)
    UnitTest.run_test("test_steiner_tree_approximation", test_steiner_tree_approximation)
    
    Note: Topological Sorting Tests
    UnitTest.run_test("test_topological_sort_dfs", test_topological_sort_dfs)
    UnitTest.run_test("test_topological_sort_kahn", test_topological_sort_kahn)
    UnitTest.run_test("test_detect_cycle_directed", test_detect_cycle_directed)
    
    Note: Connectivity Analysis Tests
    UnitTest.run_test("test_strongly_connected_components", test_strongly_connected_components)
    UnitTest.run_test("test_analyze_graph_connectivity", test_analyze_graph_connectivity)
    UnitTest.run_test("test_find_bridges", test_find_bridges)
    UnitTest.run_test("test_find_articulation_points", test_find_articulation_points)
    UnitTest.run_test("test_compute_vertex_connectivity", test_compute_vertex_connectivity)
    
    Note: Maximum Flow Tests
    UnitTest.run_test("test_ford_fulkerson_max_flow", test_ford_fulkerson_max_flow)
    UnitTest.run_test("test_edmonds_karp_max_flow", test_edmonds_karp_max_flow)
    UnitTest.run_test("test_dinic_max_flow", test_dinic_max_flow)
    UnitTest.run_test("test_push_relabel_max_flow", test_push_relabel_max_flow)
    UnitTest.run_test("test_max_flow_min_cut_theorem", test_max_flow_min_cut_theorem)
    
    Note: Matching Tests
    UnitTest.run_test("test_maximum_bipartite_matching", test_maximum_bipartite_matching)
    UnitTest.run_test("test_maximum_weight_bipartite_matching", test_maximum_weight_bipartite_matching)
    UnitTest.run_test("test_maximum_general_matching", test_maximum_general_matching)
    UnitTest.run_test("test_perfect_matching_detection", test_perfect_matching_detection)
    
    Note: Clique and Independent Set Tests
    UnitTest.run_test("test_find_maximum_clique", test_find_maximum_clique)
    UnitTest.run_test("test_find_maximum_independent_set", test_find_maximum_independent_set)
    UnitTest.run_test("test_find_minimum_vertex_cover", test_find_minimum_vertex_cover)
    UnitTest.run_test("test_enumerate_all_cliques", test_enumerate_all_cliques)
    
    Note: Graph Coloring Tests
    UnitTest.run_test("test_graph_coloring_greedy", test_graph_coloring_greedy)
    UnitTest.run_test("test_compute_chromatic_number", test_compute_chromatic_number)
    UnitTest.run_test("test_edge_coloring", test_edge_coloring)
    UnitTest.run_test("test_list_coloring", test_list_coloring)
    
    Note: Planarity Tests
    UnitTest.run_test("test_planarity", test_planarity)
    UnitTest.run_test("test_find_planar_embedding", test_find_planar_embedding)
    UnitTest.run_test("test_compute_crossing_number", test_compute_crossing_number)
    UnitTest.run_test("test_find_kuratowski_subdivision", test_find_kuratowski_subdivision)
    
    Note: Network Analysis Tests
    UnitTest.run_test("test_compute_centrality_measures", test_compute_centrality_measures)
    UnitTest.run_test("test_detect_communities", test_detect_communities)
    UnitTest.run_test("test_analyze_small_world_properties", test_analyze_small_world_properties)
    UnitTest.run_test("test_compute_network_resilience", test_compute_network_resilience)
    
    Note: Utility Tests
    UnitTest.run_test("test_validate_graph_structure", test_validate_graph_structure)
    UnitTest.run_test("test_optimize_graph_algorithms", test_optimize_graph_algorithms)
    UnitTest.run_test("test_benchmark_graph_algorithms", test_benchmark_graph_algorithms)
    UnitTest.run_test("test_troubleshoot_graph_issues", test_troubleshoot_graph_issues)
    
    Note: Integration Tests
    UnitTest.run_test("test_shortest_path_algorithms_comparison", test_shortest_path_algorithms_comparison)
    UnitTest.run_test("test_mst_weight_optimality", test_mst_weight_optimality)
    UnitTest.run_test("test_connectivity_and_flows", test_connectivity_and_flows)
    UnitTest.run_test("test_complete_graph_analysis_pipeline", test_complete_graph_analysis_pipeline)
    
    Note: Performance Tests
    UnitTest.run_test("test_large_graph_shortest_paths", test_large_graph_shortest_paths)
    UnitTest.run_test("test_large_graph_mst", test_large_graph_mst)
    UnitTest.run_test("test_dense_graph_operations", test_dense_graph_operations)
    
    Note: Specialized Algorithm Tests
    UnitTest.run_test("test_quicksort_edges_by_weight", test_quicksort_edges_by_weight)
    UnitTest.run_test("test_steiner_tree_exact_small", test_steiner_tree_exact_small)
    
    Note: Error Handling Tests
    UnitTest.run_test("test_empty_graph_operations", test_empty_graph_operations)
    UnitTest.run_test("test_disconnected_graph_analysis", test_disconnected_graph_analysis)
    UnitTest.run_test("test_self_loop_handling", test_self_loop_handling)
    UnitTest.run_test("test_negative_weight_cycle_detection", test_negative_weight_cycle_detection)
    
    UnitTest.end_test_suite()

Note: =====================================================================
Note: ADDITIONAL HELPER FUNCTIONS
Note: =====================================================================

Process called "create_graph_from_edge_list" that takes vertices as List[String], edges as List[Dictionary[String, String]] returns GraphTheory.Graph:
    Return GraphTheory.Graph with:
        vertices: vertices
        edges: edges
        is_directed: False
        is_weighted: True
        adjacency_matrix: List.create()
        adjacency_list: Dictionary.create()
        vertex_properties: Dictionary.create()
        edge_properties: Dictionary.create()

Process called "verify_graph_property" that takes graph as GraphTheory.Graph, property as String returns Boolean:
    If String.equals(property, "connected"):
        Let connectivity be GraphTheory.analyze_graph_connectivity(graph)
        Return connectivity.is_connected
    Otherwise:
        Return False

Process called "compute_graph_density" that takes graph as GraphTheory.Graph returns Float:
    Let vertex_count be List.size(graph.vertices)
    Let edge_count be List.size(graph.edges)
    Let max_edges be vertex_count * (vertex_count - 1)
    
    If not graph.is_directed:
        max_edges be max_edges / 2
    
    Return Float.divide(edge_count, max_edges)