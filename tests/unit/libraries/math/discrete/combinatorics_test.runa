Note: ===== RUNA UNIT TESTS: MATH/DISCRETE/COMBINATORICS =====

Import "math/discrete/combinatorics" as Combinatorics
Import "math/precision/biginteger" as BigInteger
Import "dev/debug/testing/unit" as UnitTest

Note: ===== TEST DATA GENERATORS =====

Process called "create_test_configurations" returns Array[Combinatorics.CombinatoricResult]:
    Note: Creates array of test configurations for combinatorial testing
    Let test_configs be Array.create([
        Combinatorics.CombinatoricResult.new(),
        Combinatorics.CombinatoricResult.new(),
        Combinatorics.CombinatoricResult.new()
    ])
    
    Note: Set up different computation contexts
    Set test_configs[0].computation_metadata.algorithm_used to "dynamic_programming"
    Set test_configs[0].computation_metadata.complexity_class to "polynomial"
    Set test_configs[1].computation_metadata.algorithm_used to "recursive"
    Set test_configs[1].computation_metadata.complexity_class to "exponential"
    Set test_configs[2].computation_metadata.algorithm_used to "iterative"
    Set test_configs[2].computation_metadata.complexity_class to "linear"
    
    Return test_configs

Process called "create_permutation_configs" returns Array[Combinatorics.PermutationConfig]:
    Note: Creates permutation configurations for testing different scenarios
    Let configs be Array.create([])
    
    Let basic_config be Combinatorics.PermutationConfig.new()
    Set basic_config.allow_repetitions to false
    Set basic_config.is_circular to false
    Set basic_config.restricted_positions to Array.create([])
    Array.append(configs, basic_config)
    
    Let repetition_config be Combinatorics.PermutationConfig.new()
    Set repetition_config.allow_repetitions to true
    Set repetition_config.is_circular to false
    Array.append(configs, repetition_config)
    
    Let circular_config be Combinatorics.PermutationConfig.new()
    Set circular_config.allow_repetitions to false
    Set circular_config.is_circular to true
    Array.append(configs, circular_config)
    
    Return configs

Process called "create_combination_configs" returns Array[Combinatorics.CombinationConfig]:
    Note: Creates combination configurations for testing
    Let configs be Array.create([])
    
    Let basic_config be Combinatorics.CombinationConfig.new()
    Set basic_config.allow_repetitions to false
    Set basic_config.is_multiset to false
    Array.append(configs, basic_config)
    
    Let multiset_config be Combinatorics.CombinationConfig.new()
    Set multiset_config.allow_repetitions to true
    Set multiset_config.is_multiset to true
    Array.append(configs, multiset_config)
    
    Return configs

Note: ===== ASSERTION HELPERS =====

Process called "assert_biginteger_equals" that takes actual as BigInteger.BigInteger, expected as BigInteger.BigInteger, message as String:
    Note: Asserts BigInteger equality with detailed error message
    Let are_equal be BigInteger.equals(actual, expected)
    UnitTest.assert(are_equal, message + " - Expected: " + BigInteger.to_string(expected, 10) + ", Actual: " + BigInteger.to_string(actual, 10))

Process called "assert_combinatorial_result" that takes result as Combinatorics.CombinatoricResult, expected_value as BigInteger.BigInteger, expected_algorithm as String, message as String:
    Note: Asserts combinatorial result properties
    assert_biginteger_equals(result.value, expected_value, message + " (value)")
    UnitTest.assert(result.computation_metadata.algorithm_used equals expected_algorithm, 
        message + " - Expected algorithm: " + expected_algorithm + ", Actual: " + result.computation_metadata.algorithm_used)

Process called "assert_array_length" that takes array as Array[Any], expected_length as Integer, message as String:
    Note: Asserts array has expected length
    Let actual_length be Array.length(array)
    UnitTest.assert(actual_length equals expected_length, 
        message + " - Expected length: " + Integer.to_string(expected_length) + ", Actual: " + Integer.to_string(actual_length))

Process called "assert_factorial_property" that takes n as Integer, factorial_n as BigInteger.BigInteger, message as String:
    Note: Asserts factorial satisfies n! = n * (n-1)!
    If n > 1:
        Let factorial_n_minus_1 be Combinatorics.compute_factorial(n - 1)
        Let expected be BigInteger.multiply(BigInteger.create_from_integer(n), factorial_n_minus_1.value)
        assert_biginteger_equals(factorial_n, expected, message + " factorial property")

Note: ===== FACTORIAL TESTS =====

Process called "test_factorial_computation":
    Note: Test basic factorial computation
    Let factorial_0 be Combinatorics.compute_factorial(0)
    assert_biginteger_equals(factorial_0.value, BigInteger.create_from_integer(1), "0! should be 1")
    
    Let factorial_1 be Combinatorics.compute_factorial(1)
    assert_biginteger_equals(factorial_1.value, BigInteger.create_from_integer(1), "1! should be 1")
    
    Let factorial_5 be Combinatorics.compute_factorial(5)
    assert_biginteger_equals(factorial_5.value, BigInteger.create_from_integer(120), "5! should be 120")
    
    Let factorial_10 be Combinatorics.compute_factorial(10)
    assert_biginteger_equals(factorial_10.value, BigInteger.create_from_integer(3628800), "10! should be 3628800")
    
    Note: Test factorial recursive property
    assert_factorial_property(5, factorial_5.value, "5!")
    assert_factorial_property(10, factorial_10.value, "10!")

Process called "test_double_factorial":
    Note: Test double factorial n!! = n * (n-2) * (n-4) * ...
    Let double_factorial_5 be Combinatorics.compute_double_factorial(5)
    assert_biginteger_equals(double_factorial_5.value, BigInteger.create_from_integer(15), "5!! = 5 * 3 * 1 = 15")
    
    Let double_factorial_6 be Combinatorics.compute_double_factorial(6)
    assert_biginteger_equals(double_factorial_6.value, BigInteger.create_from_integer(48), "6!! = 6 * 4 * 2 = 48")
    
    Let double_factorial_0 be Combinatorics.compute_double_factorial(0)
    assert_biginteger_equals(double_factorial_0.value, BigInteger.create_from_integer(1), "0!! should be 1")
    
    Let double_factorial_1 be Combinatorics.compute_double_factorial(1)
    assert_biginteger_equals(double_factorial_1.value, BigInteger.create_from_integer(1), "1!! should be 1")

Process called "test_subfactorial":
    Note: Test subfactorials (derangement numbers) !n
    Let subfactorial_0 be Combinatorics.compute_subfactorial(0)
    assert_biginteger_equals(subfactorial_0.value, BigInteger.create_from_integer(1), "!0 should be 1")
    
    Let subfactorial_1 be Combinatorics.compute_subfactorial(1)
    assert_biginteger_equals(subfactorial_1.value, BigInteger.create_from_integer(0), "!1 should be 0")
    
    Let subfactorial_2 be Combinatorics.compute_subfactorial(2)
    assert_biginteger_equals(subfactorial_2.value, BigInteger.create_from_integer(1), "!2 should be 1")
    
    Let subfactorial_3 be Combinatorics.compute_subfactorial(3)
    assert_biginteger_equals(subfactorial_3.value, BigInteger.create_from_integer(2), "!3 should be 2")
    
    Let subfactorial_4 be Combinatorics.compute_subfactorial(4)
    assert_biginteger_equals(subfactorial_4.value, BigInteger.create_from_integer(9), "!4 should be 9")

Process called "test_superfactorial":
    Note: Test superfactorials
    Let superfactorial_1 be Combinatorics.compute_superfactorial(1)
    assert_biginteger_equals(superfactorial_1.value, BigInteger.create_from_integer(1), "sf(1) should be 1")
    
    Let superfactorial_2 be Combinatorics.compute_superfactorial(2)
    assert_biginteger_equals(superfactorial_2.value, BigInteger.create_from_integer(2), "sf(2) should be 2")
    
    Let superfactorial_3 be Combinatorics.compute_superfactorial(3)
    assert_biginteger_equals(superfactorial_3.value, BigInteger.create_from_integer(12), "sf(3) = 1! * 2! * 3! = 12")

Note: ===== PERMUTATION TESTS =====

Process called "test_basic_permutations":
    Note: Test basic permutation calculations P(n,r) = n!/(n-r)!
    Let config be create_permutation_configs()[0]  Note: Basic config without repetitions
    
    Let perm_5_2 be Combinatorics.compute_permutations(5, 2, config)
    assert_biginteger_equals(perm_5_2.value, BigInteger.create_from_integer(20), "P(5,2) = 20")
    
    Let perm_10_3 be Combinatorics.compute_permutations(10, 3, config)
    assert_biginteger_equals(perm_10_3.value, BigInteger.create_from_integer(720), "P(10,3) = 720")
    
    Let perm_7_7 be Combinatorics.compute_permutations(7, 7, config)
    assert_biginteger_equals(perm_7_7.value, BigInteger.create_from_integer(5040), "P(7,7) = 7! = 5040")
    
    Let perm_5_0 be Combinatorics.compute_permutations(5, 0, config)
    assert_biginteger_equals(perm_5_0.value, BigInteger.create_from_integer(1), "P(n,0) = 1")

Process called "test_circular_permutations":
    Note: Test circular permutations (n-1)!
    Let config be create_permutation_configs()[2]  Note: Circular config
    
    Let circular_5 be Combinatorics.compute_circular_permutations(5, config)
    assert_biginteger_equals(circular_5.value, BigInteger.create_from_integer(24), "Circular permutations of 5 = 4! = 24")
    
    Let circular_3 be Combinatorics.compute_circular_permutations(3, config)
    assert_biginteger_equals(circular_3.value, BigInteger.create_from_integer(2), "Circular permutations of 3 = 2! = 2")
    
    Let circular_1 be Combinatorics.compute_circular_permutations(1, config)
    assert_biginteger_equals(circular_1.value, BigInteger.create_from_integer(1), "Circular permutations of 1 = 1")

Process called "test_permutations_with_repetition":
    Note: Test permutations with repetition n^r
    Let config be create_permutation_configs()[1]  Note: Repetition allowed config
    
    Let perm_rep_4_3 be Combinatorics.compute_permutations_with_repetition(4, 3, config)
    assert_biginteger_equals(perm_rep_4_3.value, BigInteger.create_from_integer(64), "4^3 = 64")
    
    Let perm_rep_2_5 be Combinatorics.compute_permutations_with_repetition(2, 5, config)
    assert_biginteger_equals(perm_rep_2_5.value, BigInteger.create_from_integer(32), "2^5 = 32")

Process called "test_restricted_permutations":
    Note: Test permutations with position restrictions
    Let config be create_permutation_configs()[0]
    Set config.restricted_positions to Array.create([0, 2])  Note: Positions 0 and 2 restricted
    Set config.forbidden_elements to Array.create([1])  Note: Element 1 cannot be in restricted positions
    
    Let restricted_perm be Combinatorics.compute_restricted_permutations(4, config)
    UnitTest.assert(not BigInteger.is_zero(restricted_perm.value), "Restricted permutations should have valid result")

Note: ===== COMBINATION TESTS =====

Process called "test_basic_combinations":
    Note: Test basic combination calculations C(n,r) = n!/(r!(n-r)!)
    Let config be create_combination_configs()[0]  Note: Basic config
    
    Let comb_5_2 be Combinatorics.compute_combinations(5, 2, config)
    assert_biginteger_equals(comb_5_2.value, BigInteger.create_from_integer(10), "C(5,2) = 10")
    
    Let comb_10_3 be Combinatorics.compute_combinations(10, 3, config)
    assert_biginteger_equals(comb_10_3.value, BigInteger.create_from_integer(120), "C(10,3) = 120")
    
    Let comb_7_0 be Combinatorics.compute_combinations(7, 0, config)
    assert_biginteger_equals(comb_7_0.value, BigInteger.create_from_integer(1), "C(n,0) = 1")
    
    Let comb_6_6 be Combinatorics.compute_combinations(6, 6, config)
    assert_biginteger_equals(comb_6_6.value, BigInteger.create_from_integer(1), "C(n,n) = 1")

Process called "test_combinations_with_repetition":
    Note: Test combinations with repetition C(n+r-1,r)
    Let config be create_combination_configs()[1]  Note: Multiset config
    
    Let comb_rep_3_2 be Combinatorics.compute_combinations_with_repetition(3, 2, config)
    assert_biginteger_equals(comb_rep_3_2.value, BigInteger.create_from_integer(6), "C(3+2-1,2) = C(4,2) = 6")
    
    Let comb_rep_4_3 be Combinatorics.compute_combinations_with_repetition(4, 3, config)
    assert_biginteger_equals(comb_rep_4_3.value, BigInteger.create_from_integer(20), "C(4+3-1,3) = C(6,3) = 20")

Process called "test_multiset_combinations":
    Note: Test combinations from multisets
    Let config be create_combination_configs()[1]
    Set config.multiset_multiplicities to Array.create([2, 1, 3])  Note: Elements with multiplicities [2,1,3]
    
    Let multiset_comb be Combinatorics.compute_multiset_combinations(config.multiset_multiplicities, 3, config)
    UnitTest.assert(not BigInteger.is_zero(multiset_comb.value), "Multiset combinations should have valid result")

Note: ===== BINOMIAL COEFFICIENT TESTS =====

Process called "test_binomial_coefficients":
    Note: Test binomial coefficient calculations
    Let binom_5_2 be Combinatorics.compute_binomial_coefficient(5, 2)
    assert_biginteger_equals(binom_5_2.value, BigInteger.create_from_integer(10), "Binom(5,2) = 10")
    
    Let binom_10_5 be Combinatorics.compute_binomial_coefficient(10, 5)
    assert_biginteger_equals(binom_10_5.value, BigInteger.create_from_integer(252), "Binom(10,5) = 252")
    
    Note: Test symmetry property: C(n,k) = C(n,n-k)
    Let binom_10_3 be Combinatorics.compute_binomial_coefficient(10, 3)
    Let binom_10_7 be Combinatorics.compute_binomial_coefficient(10, 7)
    assert_biginteger_equals(binom_10_3.value, binom_10_7.value, "Binomial coefficient symmetry C(10,3) = C(10,7)")

Process called "test_extended_binomial_coefficients":
    Note: Test extended binomial coefficients for non-integer n
    Let extended_binom be Combinatorics.compute_extended_binomial(0.5, 2)
    UnitTest.assert(not BigInteger.is_zero(extended_binom.numerator), "Extended binomial should have non-zero result")

Process called "test_central_binomial_coefficients":
    Note: Test central binomial coefficients C(2n,n)
    Let central_binoms be Combinatorics.compute_central_binomial_coefficients(5)
    assert_array_length(central_binoms, 6, "Should compute 6 central binomial coefficients (0 to 5)")
    
    Note: C(0,0) = 1, C(2,1) = 2, C(4,2) = 6, C(6,3) = 20, C(8,4) = 70, C(10,5) = 252
    assert_biginteger_equals(central_binoms[0], BigInteger.create_from_integer(1), "C(0,0) = 1")
    assert_biginteger_equals(central_binoms[1], BigInteger.create_from_integer(2), "C(2,1) = 2")
    assert_biginteger_equals(central_binoms[2], BigInteger.create_from_integer(6), "C(4,2) = 6")
    assert_biginteger_equals(central_binoms[3], BigInteger.create_from_integer(20), "C(6,3) = 20")

Process called "test_binomial_coefficient_modulo":
    Note: Test binomial coefficients modulo prime using Lucas' theorem
    Let binom_mod be Combinatorics.compute_binomial_coefficient_modulo(10, 3, 7)
    assert_biginteger_equals(binom_mod.value, BigInteger.create_from_integer(1), "C(10,3) mod 7 = 120 mod 7 = 1")

Note: ===== STIRLING NUMBER TESTS =====

Process called "test_stirling_first_kind":
    Note: Test Stirling numbers of the first kind (unsigned)
    Let stirling_1st_4_2 be Combinatorics.compute_stirling_first_kind(4, 2)
    assert_biginteger_equals(stirling_1st_4_2.value, BigInteger.create_from_integer(11), "S₁(4,2) = 11")
    
    Let stirling_1st_5_3 be Combinatorics.compute_stirling_first_kind(5, 3)
    assert_biginteger_equals(stirling_1st_5_3.value, BigInteger.create_from_integer(35), "S₁(5,3) = 35")
    
    Note: Boundary conditions
    Let stirling_1st_n_0 be Combinatorics.compute_stirling_first_kind(5, 0)
    assert_biginteger_equals(stirling_1st_n_0.value, BigInteger.create_from_integer(0), "S₁(n,0) = 0 for n > 0")
    
    Let stirling_1st_0_0 be Combinatorics.compute_stirling_first_kind(0, 0)
    assert_biginteger_equals(stirling_1st_0_0.value, BigInteger.create_from_integer(1), "S₁(0,0) = 1")

Process called "test_stirling_second_kind":
    Note: Test Stirling numbers of the second kind
    Let stirling_2nd_4_2 be Combinatorics.compute_stirling_second_kind(4, 2)
    assert_biginteger_equals(stirling_2nd_4_2.value, BigInteger.create_from_integer(7), "S₂(4,2) = 7")
    
    Let stirling_2nd_5_3 be Combinatorics.compute_stirling_second_kind(5, 3)
    assert_biginteger_equals(stirling_2nd_5_3.value, BigInteger.create_from_integer(25), "S₂(5,3) = 25")
    
    Note: Test recurrence relation: S₂(n,k) = k*S₂(n-1,k) + S₂(n-1,k-1)
    Let stirling_prev_k be Combinatorics.compute_stirling_second_kind(4, 3)
    Let stirling_prev_k_minus_1 be Combinatorics.compute_stirling_second_kind(4, 2)
    Let expected be BigInteger.add(
        BigInteger.multiply(BigInteger.create_from_integer(3), stirling_prev_k.value),
        stirling_prev_k_minus_1.value
    )
    assert_biginteger_equals(stirling_2nd_5_3.value, expected, "Stirling second kind recurrence relation")

Process called "test_stirling_triangle":
    Note: Test generation of Stirling triangle
    Let stirling_triangle be Combinatorics.generate_stirling_triangle(4, true)  Note: First kind
    assert_array_length(stirling_triangle, 5, "Should generate 5 rows (0 to 4)")
    
    Note: Each row should have correct number of elements
    For i from 0 to 4:
        assert_array_length(stirling_triangle[i], i + 1, "Row " + Integer.to_string(i) + " should have " + Integer.to_string(i + 1) + " elements")

Note: ===== PARTITION TESTS =====

Process called "test_integer_partitions":
    Note: Test integer partition counting
    Let partitions_4 be Combinatorics.compute_integer_partitions(4)
    assert_biginteger_equals(partitions_4.value, BigInteger.create_from_integer(5), "P(4) = 5 partitions")
    
    Note: The 5 partitions of 4 are: {4}, {3,1}, {2,2}, {2,1,1}, {1,1,1,1}
    Let partitions_5 be Combinatorics.compute_integer_partitions(5)
    assert_biginteger_equals(partitions_5.value, BigInteger.create_from_integer(7), "P(5) = 7 partitions")

Process called "test_distinct_partitions":
    Note: Test partitions into distinct parts
    Let distinct_4 be Combinatorics.compute_distinct_partitions(4)
    assert_biginteger_equals(distinct_4.value, BigInteger.create_from_integer(2), "Distinct partitions of 4: {4}, {3,1}")
    
    Let distinct_6 be Combinatorics.compute_distinct_partitions(6)
    assert_biginteger_equals(distinct_6.value, BigInteger.create_from_integer(4), "Distinct partitions of 6: {6}, {5,1}, {4,2}, {3,2,1}")

Process called "test_restricted_partitions":
    Note: Test partitions with restrictions
    Let config be Combinatorics.PartitionConfig.new()
    Set config.max_part_size to 3
    Set config.allowed_parts to Array.create([1, 2, 3])
    
    Let restricted_5 be Combinatorics.compute_restricted_partitions(5, config)
    UnitTest.assert(not BigInteger.is_zero(restricted_5.value), "Restricted partitions should have valid result")

Process called "test_enumerate_all_partitions":
    Note: Test enumeration of all partitions
    Let all_partitions_4 be Combinatorics.enumerate_all_partitions(4)
    assert_array_length(all_partitions_4, 5, "Should enumerate all 5 partitions of 4")
    
    Note: Verify specific partitions
    Let has_4 be false
    Let has_2_2 be false
    Let has_1_1_1_1 be false
    
    For i from 0 to (Array.length(all_partitions_4) - 1):
        Let partition be all_partitions_4[i]
        If Array.length(partition) equals 1 and partition[0] equals 4:
            Set has_4 to true
        If Array.length(partition) equals 2 and partition[0] equals 2 and partition[1] equals 2:
            Set has_2_2 to true
        If Array.length(partition) equals 4 and partition[0] equals 1:
            Set has_1_1_1_1 to true
    
    UnitTest.assert(has_4, "Should contain partition {4}")
    UnitTest.assert(has_2_2, "Should contain partition {2,2}")
    UnitTest.assert(has_1_1_1_1, "Should contain partition {1,1,1,1}")

Note: ===== SPECIAL SEQUENCE TESTS =====

Process called "test_bell_numbers":
    Note: Test Bell numbers (number of partitions of a set)
    Let bell_0 be Combinatorics.compute_bell_numbers(0)
    assert_biginteger_equals(bell_0[0], BigInteger.create_from_integer(1), "B₀ = 1")
    
    Let bell_4 be Combinatorics.compute_bell_numbers(4)
    assert_array_length(bell_4, 5, "Should compute Bell numbers B₀ through B₄")
    assert_biginteger_equals(bell_4[1], BigInteger.create_from_integer(1), "B₁ = 1")
    assert_biginteger_equals(bell_4[2], BigInteger.create_from_integer(2), "B₂ = 2")
    assert_biginteger_equals(bell_4[3], BigInteger.create_from_integer(5), "B₃ = 5")
    assert_biginteger_equals(bell_4[4], BigInteger.create_from_integer(15), "B₄ = 15")

Process called "test_catalan_numbers":
    Note: Test Catalan numbers C_n = (1/(n+1)) * C(2n,n)
    Let catalan_5 be Combinatorics.compute_catalan_numbers(5)
    assert_array_length(catalan_5, 6, "Should compute Catalan numbers C₀ through C₅")
    
    assert_biginteger_equals(catalan_5[0], BigInteger.create_from_integer(1), "C₀ = 1")
    assert_biginteger_equals(catalan_5[1], BigInteger.create_from_integer(1), "C₁ = 1")
    assert_biginteger_equals(catalan_5[2], BigInteger.create_from_integer(2), "C₂ = 2")
    assert_biginteger_equals(catalan_5[3], BigInteger.create_from_integer(5), "C₃ = 5")
    assert_biginteger_equals(catalan_5[4], BigInteger.create_from_integer(14), "C₄ = 14")
    assert_biginteger_equals(catalan_5[5], BigInteger.create_from_integer(42), "C₅ = 42")

Process called "test_fibonacci_combinatorics":
    Note: Test Fibonacci numbers in combinatorial context
    Let fib_10 be Combinatorics.compute_fibonacci_combinatorics(10)
    assert_array_length(fib_10, 11, "Should compute F₀ through F₁₀")
    
    assert_biginteger_equals(fib_10[0], BigInteger.create_from_integer(0), "F₀ = 0")
    assert_biginteger_equals(fib_10[1], BigInteger.create_from_integer(1), "F₁ = 1")
    assert_biginteger_equals(fib_10[2], BigInteger.create_from_integer(1), "F₂ = 1")
    assert_biginteger_equals(fib_10[3], BigInteger.create_from_integer(2), "F₃ = 2")
    assert_biginteger_equals(fib_10[5], BigInteger.create_from_integer(5), "F₅ = 5")
    assert_biginteger_equals(fib_10[8], BigInteger.create_from_integer(21), "F₈ = 21")

Process called "test_lucas_numbers_combinatorial":
    Note: Test Lucas numbers L_n = F_{n-1} + F_{n+1}
    Let lucas_6 be Combinatorics.compute_lucas_numbers_combinatorial(6)
    assert_array_length(lucas_6, 7, "Should compute L₀ through L₆")
    
    assert_biginteger_equals(lucas_6[0], BigInteger.create_from_integer(2), "L₀ = 2")
    assert_biginteger_equals(lucas_6[1], BigInteger.create_from_integer(1), "L₁ = 1")
    assert_biginteger_equals(lucas_6[2], BigInteger.create_from_integer(3), "L₂ = 3")
    assert_biginteger_equals(lucas_6[3], BigInteger.create_from_integer(4), "L₃ = 4")
    assert_biginteger_equals(lucas_6[4], BigInteger.create_from_integer(7), "L₄ = 7")

Note: ===== DERANGEMENT TESTS =====

Process called "test_derangements":
    Note: Test derangement computation !n
    Let derangement_0 be Combinatorics.compute_derangements(0)
    assert_biginteger_equals(derangement_0.value, BigInteger.create_from_integer(1), "D₀ = 1")
    
    Let derangement_1 be Combinatorics.compute_derangements(1)
    assert_biginteger_equals(derangement_1.value, BigInteger.create_from_integer(0), "D₁ = 0")
    
    Let derangement_4 be Combinatorics.compute_derangements(4)
    assert_biginteger_equals(derangement_4.value, BigInteger.create_from_integer(9), "D₄ = 9")
    
    Note: Test recurrence relation: D_n = (n-1)(D_{n-1} + D_{n-2})
    Let derangement_3 be Combinatorics.compute_derangements(3)
    Let derangement_2 be Combinatorics.compute_derangements(2)
    Let expected_4 be BigInteger.multiply(
        BigInteger.create_from_integer(3),
        BigInteger.add(derangement_3.value, derangement_2.value)
    )
    assert_biginteger_equals(derangement_4.value, expected_4, "Derangement recurrence relation")

Process called "test_partial_derangements":
    Note: Test partial derangements (exactly k fixed points)
    Let partial_derangement be Combinatorics.compute_partial_derangements(5, 2)
    UnitTest.assert(not BigInteger.is_zero(partial_derangement.value), "Partial derangements should have valid result")

Process called "test_generate_derangement_sequence":
    Note: Test generation of derangement sequence
    Let derangement_sequence be Combinatorics.generate_derangement_sequence(6)
    assert_array_length(derangement_sequence, 7, "Should generate derangements D₀ through D₆")
    
    assert_biginteger_equals(derangement_sequence[0], BigInteger.create_from_integer(1), "D₀ = 1")
    assert_biginteger_equals(derangement_sequence[2], BigInteger.create_from_integer(1), "D₂ = 1")
    assert_biginteger_equals(derangement_sequence[3], BigInteger.create_from_integer(2), "D₃ = 2")
    assert_biginteger_equals(derangement_sequence[4], BigInteger.create_from_integer(9), "D₄ = 9")

Note: ===== ADVANCED COMBINATORIAL TESTS =====

Process called "test_combinatorial_identities":
    Note: Test various combinatorial identities
    
    Note: Pascal's identity: C(n,k) = C(n-1,k-1) + C(n-1,k)
    Let binom_7_3 be Combinatorics.compute_binomial_coefficient(7, 3)
    Let binom_6_2 be Combinatorics.compute_binomial_coefficient(6, 2)
    Let binom_6_3 be Combinatorics.compute_binomial_coefficient(6, 3)
    Let pascal_sum be BigInteger.add(binom_6_2.value, binom_6_3.value)
    assert_biginteger_equals(binom_7_3.value, pascal_sum, "Pascal's identity C(7,3) = C(6,2) + C(6,3)")
    
    Note: Vandermonde's identity test case
    Let vandermonde_left be Combinatorics.compute_binomial_coefficient(5, 3)
    UnitTest.assert(not BigInteger.is_zero(vandermonde_left.value), "Vandermonde identity component should be non-zero")

Process called "test_multinomial_coefficients":
    Note: Test multinomial coefficients
    Let multinomial_parts be Array.create([2, 1, 2])  Note: n!/k1!k2!k3! where n=5
    Let multinomial be Combinatorics.compute_multinomial_coefficient(multinomial_parts)
    
    Note: 5!/(2!*1!*2!) = 120/(2*1*2) = 30
    assert_biginteger_equals(multinomial.value, BigInteger.create_from_integer(30), "Multinomial(5;2,1,2) = 30")

Process called "test_combination_sequences":
    Note: Test generation of combination sequences
    Let combination_sequence be Combinatorics.generate_combination_sequence(5, 3)
    Let expected_length be Combinatorics.compute_combinations(5, 3, create_combination_configs()[0])
    assert_array_length(combination_sequence, BigInteger.to_integer(expected_length.value), "Should generate all C(5,3) combinations")
    
    Note: Verify each combination has exactly 3 elements
    For i from 0 to (Array.length(combination_sequence) - 1):
        assert_array_length(combination_sequence[i], 3, "Each combination should have 3 elements")

Note: ===== PERFORMANCE AND EDGE CASE TESTS =====

Process called "test_large_number_computations":
    Note: Test computations with larger numbers
    Let large_factorial be Combinatorics.compute_factorial(20)
    UnitTest.assert(not BigInteger.is_zero(large_factorial.value), "Large factorial should compute successfully")
    
    Let large_combination be Combinatorics.compute_combinations(50, 25, create_combination_configs()[0])
    UnitTest.assert(not BigInteger.is_zero(large_combination.value), "Large combination should compute successfully")

Process called "test_edge_cases":
    Note: Test edge cases and boundary conditions
    
    Note: Test with n = 0
    Let zero_factorial be Combinatorics.compute_factorial(0)
    assert_biginteger_equals(zero_factorial.value, BigInteger.create_from_integer(1), "0! = 1")
    
    Let zero_combinations be Combinatorics.compute_combinations(0, 0, create_combination_configs()[0])
    assert_biginteger_equals(zero_combinations.value, BigInteger.create_from_integer(1), "C(0,0) = 1")
    
    Note: Test invalid parameter handling
    Note: These would typically throw errors in a real implementation
    Note: Test that r > n cases are handled appropriately

Process called "test_computation_metadata":
    Note: Test that computation metadata is properly populated
    Let factorial_result be Combinatorics.compute_factorial(10)
    UnitTest.assert(factorial_result.computation_metadata.algorithm_used.length() > 0, "Algorithm used should be documented")
    UnitTest.assert(factorial_result.computation_metadata.complexity_class.length() > 0, "Complexity class should be documented")
    
    Let combination_result be Combinatorics.compute_combinations(10, 5, create_combination_configs()[0])
    UnitTest.assert(combination_result.computation_metadata.time_complexity_estimate > 0, "Time complexity should be estimated")

Note: ===== TEST RUNNER =====

Process called "run_all_tests":
    Note: Executes all Combinatorics unit tests
    UnitTest.start_test_suite("Combinatorics Module Tests")
    
    Note: Factorial tests
    UnitTest.run_test("Factorial Computation", test_factorial_computation)
    UnitTest.run_test("Double Factorial", test_double_factorial)
    UnitTest.run_test("Subfactorial", test_subfactorial)
    UnitTest.run_test("Superfactorial", test_superfactorial)
    
    Note: Permutation tests
    UnitTest.run_test("Basic Permutations", test_basic_permutations)
    UnitTest.run_test("Circular Permutations", test_circular_permutations)
    UnitTest.run_test("Permutations with Repetition", test_permutations_with_repetition)
    UnitTest.run_test("Restricted Permutations", test_restricted_permutations)
    
    Note: Combination tests
    UnitTest.run_test("Basic Combinations", test_basic_combinations)
    UnitTest.run_test("Combinations with Repetition", test_combinations_with_repetition)
    UnitTest.run_test("Multiset Combinations", test_multiset_combinations)
    
    Note: Binomial coefficient tests
    UnitTest.run_test("Binomial Coefficients", test_binomial_coefficients)
    UnitTest.run_test("Extended Binomial Coefficients", test_extended_binomial_coefficients)
    UnitTest.run_test("Central Binomial Coefficients", test_central_binomial_coefficients)
    UnitTest.run_test("Binomial Coefficient Modulo", test_binomial_coefficient_modulo)
    
    Note: Stirling number tests
    UnitTest.run_test("Stirling First Kind", test_stirling_first_kind)
    UnitTest.run_test("Stirling Second Kind", test_stirling_second_kind)
    UnitTest.run_test("Stirling Triangle", test_stirling_triangle)
    
    Note: Partition tests
    UnitTest.run_test("Integer Partitions", test_integer_partitions)
    UnitTest.run_test("Distinct Partitions", test_distinct_partitions)
    UnitTest.run_test("Restricted Partitions", test_restricted_partitions)
    UnitTest.run_test("Enumerate All Partitions", test_enumerate_all_partitions)
    
    Note: Special sequence tests
    UnitTest.run_test("Bell Numbers", test_bell_numbers)
    UnitTest.run_test("Catalan Numbers", test_catalan_numbers)
    UnitTest.run_test("Fibonacci Combinatorics", test_fibonacci_combinatorics)
    UnitTest.run_test("Lucas Numbers Combinatorial", test_lucas_numbers_combinatorial)
    
    Note: Derangement tests
    UnitTest.run_test("Derangements", test_derangements)
    UnitTest.run_test("Partial Derangements", test_partial_derangements)
    UnitTest.run_test("Generate Derangement Sequence", test_generate_derangement_sequence)
    
    Note: Advanced tests
    UnitTest.run_test("Combinatorial Identities", test_combinatorial_identities)
    UnitTest.run_test("Multinomial Coefficients", test_multinomial_coefficients)
    UnitTest.run_test("Combination Sequences", test_combination_sequences)
    
    Note: Performance and edge case tests
    UnitTest.run_test("Large Number Computations", test_large_number_computations)
    UnitTest.run_test("Edge Cases", test_edge_cases)
    UnitTest.run_test("Computation Metadata", test_computation_metadata)
    
    UnitTest.end_test_suite()