Note: ===== RUNA UNIT TESTS: MATH/DISCRETE/NUMBER_THEORY =====

Import "math/discrete/number_theory" as NumberTheory
Import "math/precision/biginteger" as BigInteger
Import "dev/debug/testing/unit" as UnitTest

Note: ===== TEST DATA GENERATORS =====

Process called "create_test_primes" returns Array[Integer]:
    Note: Creates array of known prime numbers for testing
    Return Array.create([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47])

Process called "create_test_composites" returns Array[Integer]:
    Note: Creates array of known composite numbers for testing
    Return Array.create([4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28])

Process called "create_test_coprime_pairs" returns Array[Array[Integer]]:
    Note: Creates pairs of coprime numbers for GCD testing
    Return Array.create([
        [3, 5], [7, 11], [9, 16], [13, 25], [21, 32], [35, 64], [15, 28], [17, 19]
    ])

Process called "create_large_test_numbers" returns Array[BigInteger.BigInteger]:
    Note: Creates large numbers for stress testing
    Return Array.create([
        BigInteger.create_from_string("982451653", 10),     Note: Known 9-digit prime
        BigInteger.create_from_string("1073741827", 10),    Note: Mersenne prime 2^30 - 1
        BigInteger.create_from_string("2147483647", 10),    Note: Mersenne prime 2^31 - 1
        BigInteger.create_from_string("123456789012345", 10), Note: Large composite
        BigInteger.create_from_string("999999999999999989", 10) Note: Large prime
    ])

Note: ===== ASSERTION HELPERS =====

Process called "assert_biginteger_equals" that takes actual as BigInteger.BigInteger, expected as BigInteger.BigInteger, message as String:
    Note: Asserts BigInteger equality
    Let are_equal be BigInteger.equals(actual, expected)
    UnitTest.assert(are_equal, message + " - Expected: " + BigInteger.to_string(expected, 10) + ", Actual: " + BigInteger.to_string(actual, 10))

Process called "assert_prime_result" that takes result as NumberTheory.PrimeResult, expected_is_prime as Boolean, message as String:
    Note: Asserts primality test result properties
    UnitTest.assert(result.is_prime equals expected_is_prime, message + " - Expected: " + Boolean.to_string(expected_is_prime) + ", Actual: " + Boolean.to_string(result.is_prime))
    If expected_is_prime:
        UnitTest.assert(result.certainty_level >= 0.99, message + " - Prime certainty should be high")
    UnitTest.assert(result.algorithm_used.length() > 0, message + " - Algorithm should be documented")

Process called "assert_factorization_complete" that takes result as NumberTheory.FactorizationResult, original_number as BigInteger.BigInteger, message as String:
    Note: Asserts factorization is complete and correct
    UnitTest.assert(Array.length(result.prime_factors) > 0, message + " - Should have prime factors")
    UnitTest.assert(Array.length(result.factor_powers) equals Array.length(result.prime_factors), message + " - Factors and powers should match")
    
    Note: Verify factorization by multiplication
    Let product be BigInteger.create_from_integer(1)
    For i from 0 to (Array.length(result.prime_factors) - 1):
        Let factor be result.prime_factors[i]
        Let power be result.factor_powers[i]
        Let factor_contribution be BigInteger.power(factor, power)
        Set product to BigInteger.multiply(product, factor_contribution)
    
    assert_biginteger_equals(product, original_number, message + " - Factorization product should equal original")

Process called "assert_gcd_properties" that takes a as BigInteger.BigInteger, b as BigInteger.BigInteger, gcd_result as BigInteger.BigInteger, message as String:
    Note: Asserts GCD properties: gcd(a,b) divides both a and b
    Let remainder_a be BigInteger.mod(a, gcd_result)
    Let remainder_b be BigInteger.mod(b, gcd_result)
    
    UnitTest.assert(BigInteger.is_zero(remainder_a), message + " - GCD should divide first argument")
    UnitTest.assert(BigInteger.is_zero(remainder_b), message + " - GCD should divide second argument")

Note: ===== PRIMALITY TESTING TESTS =====

Process called "test_deterministic_primality":
    Note: Test deterministic primality testing for small numbers
    Let primes be create_test_primes()
    Let composites be create_test_composites()
    
    Note: Test known primes
    For i from 0 to (Array.length(primes) - 1):
        Let prime be primes[i]
        Let result be NumberTheory.test_primality_deterministic(BigInteger.create_from_integer(prime))
        assert_prime_result(result, true, "Prime " + Integer.to_string(prime) + " should test as prime")
    
    Note: Test known composites
    For i from 0 to (Array.length(composites) - 1):
        Let composite be composites[i]
        Let result be NumberTheory.test_primality_deterministic(BigInteger.create_from_integer(composite))
        assert_prime_result(result, false, "Composite " + Integer.to_string(composite) + " should test as composite")
    
    Note: Test special cases
    Let one_result be NumberTheory.test_primality_deterministic(BigInteger.create_from_integer(1))
    assert_prime_result(one_result, false, "1 should not be prime")
    
    Let two_result be NumberTheory.test_primality_deterministic(BigInteger.create_from_integer(2))
    assert_prime_result(two_result, true, "2 should be prime")

Process called "test_miller_rabin_primality":
    Note: Test Miller-Rabin probabilistic primality testing
    Let large_numbers be create_large_test_numbers()
    
    For i from 0 to (Array.length(large_numbers) - 1):
        Let number be large_numbers[i]
        Let result be NumberTheory.test_primality_miller_rabin(number, 10)  Note: 10 rounds
        
        UnitTest.assert(result.certainty_level > 0.9, "Miller-Rabin should provide high certainty")
        UnitTest.assert(result.algorithm_used equals "miller_rabin", "Should use Miller-Rabin algorithm")
        UnitTest.assert(Array.length(result.witnesses) <= 10, "Should have at most 10 witnesses")

Process called "test_solovay_strassen_primality":
    Note: Test Solovay-Strassen probabilistic primality testing
    let known_prime be BigInteger.create_from_string("982451653", 10)
    let result be NumberTheory.test_primality_solovay_strassen(known_prime, 5)
    
    UnitTest.assert(result.certainty_level > 0.8, "Solovay-Strassen should provide reasonable certainty")
    UnitTest.assert(result.algorithm_used equals "solovay_strassen", "Should use Solovay-Strassen algorithm")

Process called "test_aks_primality":
    Note: Test AKS deterministic polynomial-time primality testing
    Note: AKS is typically only practical for smaller numbers due to large constants
    Let small_prime be BigInteger.create_from_integer(97)
    Let aks_result be NumberTheory.test_primality_aks(small_prime)
    
    assert_prime_result(aks_result, true, "AKS should correctly identify 97 as prime")
    UnitTest.assert(aks_result.is_deterministic, "AKS result should be deterministic")
    UnitTest.assert(aks_result.algorithm_used equals "aks", "Should use AKS algorithm")

Note: ===== PRIME GENERATION TESTS =====

Process called "test_sieve_of_eratosthenes":
    Note: Test Sieve of Eratosthenes prime generation
    Let primes_up_to_30 be NumberTheory.generate_primes_sieve_eratosthenes(30)
    let expected_primes be [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    
    assert_array_length(primes_up_to_30, Array.length(expected_primes), "Should find all primes up to 30")
    
    Note: Verify all generated numbers are actually prime
    For i from 0 to (Array.length(primes_up_to_30) - 1):
        Let prime_candidate be primes_up_to_30[i]
        UnitTest.assert(prime_candidate equals expected_primes[i], "Prime " + Integer.to_string(i) + " should match expected")

Process called "test_sieve_of_atkin":
    Note: Test Sieve of Atkin prime generation
    Let primes_atkin be NumberTheory.generate_primes_sieve_atkin(50)
    Let primes_eratosthenes be NumberTheory.generate_primes_sieve_eratosthenes(50)
    
    assert_array_length(primes_atkin, Array.length(primes_eratosthenes), "Atkin and Eratosthenes should find same number of primes")
    
    Note: Verify both methods find the same primes
    For i from 0 to (Array.length(primes_atkin) - 1):
        UnitTest.assert(primes_atkin[i] equals primes_eratosthenes[i], "Atkin and Eratosthenes should find same primes")

Process called "test_segmented_sieve":
    Note: Test segmented sieve for large ranges
    let range_start be 1000000
    let range_end be 1000100
    Let primes_segmented be NumberTheory.generate_primes_segmented_sieve(range_start, range_end)
    
    Note: Verify all results are in range and prime
    For i from 0 to (Array.length(primes_segmented) - 1):
        Let prime be primes_segmented[i]
        UnitTest.assert(prime >= range_start and prime <= range_end, "Prime should be in specified range")
        
        Note: Quick primality check
        Let prime_big be BigInteger.create_from_integer(prime)
        Let is_prime be NumberTheory.test_primality_miller_rabin(prime_big, 3).is_prime
        UnitTest.assert(is_prime, "Generated number should be prime")

Note: ===== GCD AND LCM TESTS =====

Process called "test_euclidean_gcd":
    Note: Test Euclidean algorithm for GCD
    Let gcd_48_18 be NumberTheory.compute_gcd_euclidean(
        BigInteger.create_from_integer(48),
        BigInteger.create_from_integer(18)
    )
    assert_biginteger_equals(gcd_48_18.gcd, BigInteger.create_from_integer(6), "gcd(48,18) = 6")
    
    Let gcd_17_13 be NumberTheory.compute_gcd_euclidean(
        BigInteger.create_from_integer(17),
        BigInteger.create_from_integer(13)
    )
    assert_biginteger_equals(gcd_17_13.gcd, BigInteger.create_from_integer(1), "gcd(17,13) = 1 (coprime)")
    
    Note: Test GCD properties
    assert_gcd_properties(
        BigInteger.create_from_integer(48),
        BigInteger.create_from_integer(18),
        gcd_48_18.gcd,
        "GCD(48,18) properties"
    )

Process called "test_extended_euclidean":
    Note: Test Extended Euclidean Algorithm
    Let ext_gcd_result be NumberTheory.compute_gcd_extended_euclidean(
        BigInteger.create_from_integer(30),
        BigInteger.create_from_integer(18)
    )
    
    assert_biginteger_equals(ext_gcd_result.gcd, BigInteger.create_from_integer(6), "Extended GCD(30,18) = 6")
    
    Note: Test Bezout identity: ax + by = gcd(a,b)
    Let a be BigInteger.create_from_integer(30)
    Let b be BigInteger.create_from_integer(18)
    Let bezout_sum be BigInteger.add(
        BigInteger.multiply(a, ext_gcd_result.x),
        BigInteger.multiply(b, ext_gcd_result.y)
    )
    assert_biginteger_equals(bezout_sum, ext_gcd_result.gcd, "Bezout identity should hold")

Process called "test_binary_gcd":
    Note: Test binary GCD (Stein's algorithm)
    Let binary_gcd be NumberTheory.compute_gcd_binary(
        BigInteger.create_from_integer(48),
        BigInteger.create_from_integer(18)
    )
    assert_biginteger_equals(binary_gcd.gcd, BigInteger.create_from_integer(6), "Binary GCD(48,18) = 6")
    
    Note: Compare with Euclidean algorithm result
    Let euclidean_gcd be NumberTheory.compute_gcd_euclidean(
        BigInteger.create_from_integer(48),
        BigInteger.create_from_integer(18)
    )
    assert_biginteger_equals(binary_gcd.gcd, euclidean_gcd.gcd, "Binary and Euclidean GCD should match")

Process called "test_lcm_computation":
    Note: Test LCM computation using GCD
    Let lcm_12_18 be NumberTheory.compute_lcm(
        BigInteger.create_from_integer(12),
        BigInteger.create_from_integer(18)
    )
    assert_biginteger_equals(lcm_12_18.lcm, BigInteger.create_from_integer(36), "LCM(12,18) = 36")
    
    Note: Test LCM property: LCM(a,b) * GCD(a,b) = a * b
    let gcd_12_18 be NumberTheory.compute_gcd_euclidean(
        BigInteger.create_from_integer(12),
        BigInteger.create_from_integer(18)
    )
    Let lcm_times_gcd be BigInteger.multiply(lcm_12_18.lcm, gcd_12_18.gcd)
    let a_times_b be BigInteger.multiply(BigInteger.create_from_integer(12), BigInteger.create_from_integer(18))
    assert_biginteger_equals(lcm_times_gcd, a_times_b, "LCM * GCD = a * b property")

Note: ===== MODULAR ARITHMETIC TESTS =====

Process called "test_modular_exponentiation":
    Note: Test modular exponentiation a^b mod m
    Let mod_exp_result be NumberTheory.compute_modular_exponentiation(
        BigInteger.create_from_integer(3),
        BigInteger.create_from_integer(4),
        BigInteger.create_from_integer(5)
    )
    assert_biginteger_equals(mod_exp_result.result, BigInteger.create_from_integer(1), "3^4 mod 5 = 81 mod 5 = 1")
    
    Let large_mod_exp be NumberTheory.compute_modular_exponentiation(
        BigInteger.create_from_integer(2),
        BigInteger.create_from_integer(100),
        BigInteger.create_from_integer(7)
    )
    UnitTest.assert(BigInteger.compare(large_mod_exp.result, BigInteger.create_from_integer(7)) < 0, "Result should be less than modulus")

Process called "test_modular_inverse":
    Note: Test modular multiplicative inverse
    Let mod_inv_3_7 be NumberTheory.compute_modular_inverse(
        BigInteger.create_from_integer(3),
        BigInteger.create_from_integer(7)
    )
    
    Note: 3 * 5 = 15 ≡ 1 (mod 7), so inverse of 3 mod 7 is 5
    assert_biginteger_equals(mod_inv_3_7.inverse, BigInteger.create_from_integer(5), "Inverse of 3 mod 7 is 5")
    
    Note: Verify inverse property: a * a^(-1) ≡ 1 (mod m)
    Let verification = BigInteger.mod(
        BigInteger.multiply(BigInteger.create_from_integer(3), mod_inv_3_7.inverse),
        BigInteger.create_from_integer(7)
    )
    assert_biginteger_equals(verification, BigInteger.create_from_integer(1), "Inverse verification")

Process called "test_linear_congruence":
    Note: Test linear congruence solving ax ≡ b (mod m)
    Let congruence_result be NumberTheory.solve_linear_congruence(
        BigInteger.create_from_integer(3),
        BigInteger.create_from_integer(2),
        BigInteger.create_from_integer(7)
    )
    
    UnitTest.assert(Array.length(congruence_result.solutions) > 0, "Should find solution to 3x ≡ 2 (mod 7)")
    
    Note: Verify solution: 3x ≡ 2 (mod 7) has solution x ≡ 3 (mod 7)
    Let solution be congruence_result.solutions[0]
    Let verification = BigInteger.mod(
        BigInteger.multiply(BigInteger.create_from_integer(3), solution),
        BigInteger.create_from_integer(7)
    )
    assert_biginteger_equals(verification, BigInteger.create_from_integer(2), "Linear congruence solution verification")

Note: ===== CHINESE REMAINDER THEOREM TESTS =====

Process called "test_chinese_remainder_theorem":
    Note: Test Chinese Remainder Theorem for coprime moduli
    Let moduli be Array.create([
        BigInteger.create_from_integer(3),
        BigInteger.create_from_integer(5),
        BigInteger.create_from_integer(7)
    ])
    Let remainders be Array.create([
        BigInteger.create_from_integer(1),
        BigInteger.create_from_integer(2),
        BigInteger.create_from_integer(3)
    ])
    
    Let crt_result be NumberTheory.solve_chinese_remainder_theorem(moduli, remainders)
    
    UnitTest.assert(crt_result.has_solution, "CRT should find solution for coprime moduli")
    
    Note: Verify solution satisfies all congruences
    For i from 0 to (Array.length(moduli) - 1):
        let verification = BigInteger.mod(crt_result.solution, moduli[i])
        assert_biginteger_equals(verification, remainders[i], 
            "CRT solution should satisfy congruence " + Integer.to_string(i))

Process called "test_generalized_crt":
    Note: Test generalized CRT for non-coprime moduli
    Let non_coprime_moduli be Array.create([
        BigInteger.create_from_integer(6),
        BigInteger.create_from_integer(9),
        BigInteger.create_from_integer(15)
    ])
    Let compatible_remainders be Array.create([
        BigInteger.create_from_integer(3),
        BigInteger.create_from_integer(3),
        BigInteger.create_from_integer(3)
    ])
    
    Let gen_crt_result be NumberTheory.solve_generalized_crt(non_coprime_moduli, compatible_remainders)
    UnitTest.assert(gen_crt_result.has_solution, "Generalized CRT should find solution for compatible remainders")

Note: ===== DIOPHANTINE EQUATION TESTS =====

Process called "test_linear_diophantine":
    Note: Test linear Diophantine equation ax + by = c
    Let diophantine_result be NumberTheory.solve_linear_diophantine(
        BigInteger.create_from_integer(3),
        BigInteger.create_from_integer(5),
        BigInteger.create_from_integer(7)
    )
    
    UnitTest.assert(diophantine_result.has_solution, "3x + 5y = 7 should have integer solutions")
    
    Note: Verify particular solution
    Let verification = BigInteger.add(
        BigInteger.multiply(BigInteger.create_from_integer(3), diophantine_result.particular_solution_x),
        BigInteger.multiply(BigInteger.create_from_integer(5), diophantine_result.particular_solution_y)
    )
    assert_biginteger_equals(verification, BigInteger.create_from_integer(7), "Particular solution verification")

Process called "test_pell_equation":
    Note: Test Pell equation x² - Dy² = 1
    let pell_result be NumberTheory.solve_pell_equation(BigInteger.create_from_integer(2))
    
    UnitTest.assert(pell_result.has_solution, "Pell equation x² - 2y² = 1 should have solutions")
    
    Note: Verify fundamental solution for D = 2: (3, 2)
    let x be pell_result.fundamental_solution_x
    let y be pell_result.fundamental_solution_y
    let d be BigInteger.create_from_integer(2)
    
    let verification = BigInteger.subtract(
        BigInteger.multiply(x, x),
        BigInteger.multiply(d, BigInteger.multiply(y, y))
    )
    assert_biginteger_equals(verification, BigInteger.create_from_integer(1), "Pell equation verification")

Process called "test_generalized_pell":
    Note: Test generalized Pell equation x² - Dy² = N
    Let gen_pell_result be NumberTheory.solve_generalized_pell(
        BigInteger.create_from_integer(2),
        BigInteger.create_from_integer(7)
    )
    
    Note: x² - 2y² = 7 has solutions
    If gen_pell_result.has_solution:
        let solutions be gen_pell_result.all_solutions
        UnitTest.assert(Array.length(solutions) > 0, "Should find solutions to generalized Pell equation")

Note: ===== FACTORIZATION TESTS =====

Process called "test_trial_division_factorization":
    Note: Test trial division factorization
    let composite_60 be BigInteger.create_from_integer(60)
    Let factorization be NumberTheory.factorize_trial_division(composite_60, 100)
    
    assert_factorization_complete(factorization, composite_60, "Trial division factorization of 60")
    
    Note: 60 = 2² × 3 × 5
    let has_2 be false
    let has_3 be false
    let has_5 be false
    
    For i from 0 to (Array.length(factorization.prime_factors) - 1):
        let factor = factorization.prime_factors[i]
        If BigInteger.equals(factor, BigInteger.create_from_integer(2)):
            Set has_2 to true
            UnitTest.assert(factorization.factor_powers[i] equals 2, "Power of 2 should be 2")
        If BigInteger.equals(factor, BigInteger.create_from_integer(3)):
            Set has_3 to true
            UnitTest.assert(factorization.factor_powers[i] equals 1, "Power of 3 should be 1")
        If BigInteger.equals(factor, BigInteger.create_from_integer(5)):
            Set has_5 to true
            UnitTest.assert(factorization.factor_powers[i] equals 1, "Power of 5 should be 1")
    
    UnitTest.assert(has_2 and has_3 and has_5, "Should find all prime factors of 60")

Process called "test_pollard_rho_factorization":
    Note: Test Pollard's rho algorithm for factorization
    Let composite_example be BigInteger.multiply(
        BigInteger.create_from_integer(1009),  Note: Prime
        BigInteger.create_from_integer(1013)   Note: Prime
    )
    
    let pollard_result be NumberTheory.factorize_pollard_rho(composite_example)
    assert_factorization_complete(pollard_result, composite_example, "Pollard rho factorization")
    
    Note: Should find the two prime factors
    UnitTest.assert(Array.length(pollard_result.prime_factors) equals 2, "Should find exactly 2 prime factors")

Process called "test_complete_factorization":
    Note: Test complete factorization combining multiple methods
    let number_to_factor be BigInteger.create_from_integer(1000)
    Let complete_factorization be NumberTheory.factorize_complete(number_to_factor)
    
    assert_factorization_complete(complete_factorization, number_to_factor, "Complete factorization of 1000")
    
    Note: 1000 = 2³ × 5³
    UnitTest.assert(complete_factorization.is_complete, "Factorization should be marked as complete")

Note: ===== SPECIALIZED NUMBER THEORY TESTS =====

Process called "test_euler_totient":
    Note: Test Euler's totient function φ(n)
    Let totient_10 be NumberTheory.compute_euler_totient(BigInteger.create_from_integer(10))
    assert_biginteger_equals(totient_10.value, BigInteger.create_from_integer(4), "φ(10) = 4")
    
    let totient_15 be NumberTheory.compute_euler_totient(BigInteger.create_from_integer(15))
    assert_biginteger_equals(totient_15.value, BigInteger.create_from_integer(8), "φ(15) = 8")
    
    Note: Test for prime numbers: φ(p) = p - 1
    let totient_17 be NumberTheory.compute_euler_totient(BigInteger.create_from_integer(17))
    assert_biginteger_equals(totient_17.value, BigInteger.create_from_integer(16), "φ(17) = 16 for prime 17")

Process called "test_carmichael_function":
    Note: Test Carmichael function λ(n)
    let carmichael_15 be NumberTheory.compute_carmichael_function(BigInteger.create_from_integer(15))
    assert_biginteger_equals(carmichael_15.value, BigInteger.create_from_integer(4), "λ(15) = 4")
    
    let carmichael_21 be NumberTheory.compute_carmichael_function(BigInteger.create_from_integer(21))
    assert_biginteger_equals(carmichael_21.value, BigInteger.create_from_integer(6), "λ(21) = 6")

Process called "test_jacobi_symbol":
    Note: Test Jacobi symbol computation
    Let jacobi_2_15 be NumberTheory.compute_jacobi_symbol(
        BigInteger.create_from_integer(2),
        BigInteger.create_from_integer(15)
    )
    assert_biginteger_equals(jacobi_2_15, BigInteger.create_from_integer(1), "Jacobi symbol (2/15) = 1")
    
    let jacobi_3_7 be NumberTheory.compute_jacobi_symbol(
        BigInteger.create_from_integer(3),
        BigInteger.create_from_integer(7)
    )
    assert_biginteger_equals(jacobi_3_7, BigInteger.create_from_integer(-1), "Jacobi symbol (3/7) = -1")

Process called "test_legendre_symbol":
    Note: Test Legendre symbol for primes
    let legendre_2_7 be NumberTheory.compute_legendre_symbol(
        BigInteger.create_from_integer(2),
        BigInteger.create_from_integer(7)
    )
    assert_biginteger_equals(legendre_2_7, BigInteger.create_from_integer(1), "Legendre symbol (2/7) = 1")
    
    let legendre_3_7 be NumberTheory.compute_legendre_symbol(
        BigInteger.create_from_integer(3),
        BigInteger.create_from_integer(7)
    )
    assert_biginteger_equals(legendre_3_7, BigInteger.create_from_integer(-1), "Legendre symbol (3/7) = -1")

Note: ===== ADVANCED NUMBER THEORY TESTS =====

Process called "test_quadratic_residues":
    Note: Test quadratic residue detection
    let is_qr_4_7 be NumberTheory.is_quadratic_residue(
        BigInteger.create_from_integer(4),
        BigInteger.create_from_integer(7)
    )
    UnitTest.assert(is_qr_4_7.is_residue, "4 is a quadratic residue mod 7 (2² ≡ 4)")
    
    let is_qr_3_7 be NumberTheory.is_quadratic_residue(
        BigInteger.create_from_integer(3),
        BigInteger.create_from_integer(7)
    )
    UnitTest.assert(not is_qr_3_7.is_residue, "3 is not a quadratic residue mod 7")

Process called "test_primitive_roots":
    Note: Test primitive root computation
    let primitive_7 be NumberTheory.find_primitive_root(BigInteger.create_from_integer(7))
    UnitTest.assert(primitive_7.has_primitive_root, "7 should have primitive roots")
    
    Note: Verify primitive root property: order equals φ(7) = 6
    UnitTest.assert(primitive_7.order equals 6, "Primitive root of 7 should have order 6")

Process called "test_mobius_function":
    Note: Test Möbius function μ(n)
    let mobius_1 be NumberTheory.compute_mobius_function(BigInteger.create_from_integer(1))
    assert_biginteger_equals(mobius_1, BigInteger.create_from_integer(1), "μ(1) = 1")
    
    let mobius_6 be NumberTheory.compute_mobius_function(BigInteger.create_from_integer(6))
    assert_biginteger_equals(mobius_6, BigInteger.create_from_integer(1), "μ(6) = μ(2×3) = 1")
    
    let mobius_12 be NumberTheory.compute_mobius_function(BigInteger.create_from_integer(12))
    assert_biginteger_equals(mobius_12, BigInteger.create_from_integer(0), "μ(12) = 0 (has squared factor)")
    
    let mobius_15 be NumberTheory.compute_mobius_function(BigInteger.create_from_integer(15))
    assert_biginteger_equals(mobius_15, BigInteger.create_from_integer(1), "μ(15) = μ(3×5) = 1")

Process called "test_divisor_functions":
    Note: Test divisor function computations
    let sigma_12 be NumberTheory.compute_divisor_sum(BigInteger.create_from_integer(12), 1)
    assert_biginteger_equals(sigma_12.sum, BigInteger.create_from_integer(28), "σ₁(12) = 1+2+3+4+6+12 = 28")
    
    let tau_12 be NumberTheory.compute_divisor_count(BigInteger.create_from_integer(12))
    assert_biginteger_equals(tau_12.count, BigInteger.create_from_integer(6), "τ(12) = 6 divisors")
    
    let perfect_6 be NumberTheory.is_perfect_number(BigInteger.create_from_integer(6))
    UnitTest.assert(perfect_6.is_perfect, "6 should be a perfect number")
    
    let perfect_28 be NumberTheory.is_perfect_number(BigInteger.create_from_integer(28))
    UnitTest.assert(perfect_28.is_perfect, "28 should be a perfect number")

Note: ===== PERFORMANCE AND EDGE CASE TESTS =====

Process called "test_large_number_operations":
    Note: Test operations with large numbers
    let large_numbers be create_large_test_numbers()
    
    For i from 0 to (Array.length(large_numbers) - 1):
        Let number be large_numbers[i]
        
        Note: Test that operations complete without hanging
        let primality_result be NumberTheory.test_primality_miller_rabin(number, 3)
        UnitTest.assert(primality_result.algorithm_used.length() > 0, "Large number primality test should complete")
        
        Note: Test GCD with smaller number
        let gcd_result be NumberTheory.compute_gcd_euclidean(number, BigInteger.create_from_integer(1000000))
        UnitTest.assert(not BigInteger.is_zero(gcd_result.gcd), "Large number GCD should compute")

Process called "test_edge_cases":
    Note: Test edge cases and boundary conditions
    
    Note: Test operations with 0, 1, and 2
    let gcd_0_5 be NumberTheory.compute_gcd_euclidean(
        BigInteger.create_from_integer(0),
        BigInteger.create_from_integer(5)
    )
    assert_biginteger_equals(gcd_0_5.gcd, BigInteger.create_from_integer(5), "gcd(0,5) = 5")
    
    let gcd_1_n be NumberTheory.compute_gcd_euclidean(
        BigInteger.create_from_integer(1),
        BigInteger.create_from_integer(42)
    )
    assert_biginteger_equals(gcd_1_n.gcd, BigInteger.create_from_integer(1), "gcd(1,n) = 1")

Process called "test_algorithm_consistency":
    Note: Test that different algorithms produce consistent results
    let test_number be BigInteger.create_from_integer(12345)
    
    Note: Compare different GCD algorithms
    let euclidean_result be NumberTheory.compute_gcd_euclidean(test_number, BigInteger.create_from_integer(6789))
    let binary_result be NumberTheory.compute_gcd_binary(test_number, BigInteger.create_from_integer(6789))
    
    assert_biginteger_equals(euclidean_result.gcd, binary_result.gcd, "Different GCD algorithms should agree")

Note: ===== TEST RUNNER =====

Process called "run_all_tests":
    Note: Executes all NumberTheory unit tests
    UnitTest.start_test_suite("NumberTheory Module Tests")
    
    Note: Primality testing tests
    UnitTest.run_test("Deterministic Primality", test_deterministic_primality)
    UnitTest.run_test("Miller-Rabin Primality", test_miller_rabin_primality)
    UnitTest.run_test("Solovay-Strassen Primality", test_solovay_strassen_primality)
    UnitTest.run_test("AKS Primality", test_aks_primality)
    
    Note: Prime generation tests
    UnitTest.run_test("Sieve of Eratosthenes", test_sieve_of_eratosthenes)
    UnitTest.run_test("Sieve of Atkin", test_sieve_of_atkin)
    UnitTest.run_test("Segmented Sieve", test_segmented_sieve)
    
    Note: GCD and LCM tests
    UnitTest.run_test("Euclidean GCD", test_euclidean_gcd)
    UnitTest.run_test("Extended Euclidean", test_extended_euclidean)
    UnitTest.run_test("Binary GCD", test_binary_gcd)
    UnitTest.run_test("LCM Computation", test_lcm_computation)
    
    Note: Modular arithmetic tests
    UnitTest.run_test("Modular Exponentiation", test_modular_exponentiation)
    UnitTest.run_test("Modular Inverse", test_modular_inverse)
    UnitTest.run_test("Linear Congruence", test_linear_congruence)
    
    Note: Chinese Remainder Theorem tests
    UnitTest.run_test("Chinese Remainder Theorem", test_chinese_remainder_theorem)
    UnitTest.run_test("Generalized CRT", test_generalized_crt)
    
    Note: Diophantine equation tests
    UnitTest.run_test("Linear Diophantine", test_linear_diophantine)
    UnitTest.run_test("Pell Equation", test_pell_equation)
    UnitTest.run_test("Generalized Pell", test_generalized_pell)
    
    Note: Factorization tests
    UnitTest.run_test("Trial Division Factorization", test_trial_division_factorization)
    UnitTest.run_test("Pollard Rho Factorization", test_pollard_rho_factorization)
    UnitTest.run_test("Complete Factorization", test_complete_factorization)
    
    Note: Specialized function tests
    UnitTest.run_test("Euler Totient", test_euler_totient)
    UnitTest.run_test("Carmichael Function", test_carmichael_function)
    UnitTest.run_test("Jacobi Symbol", test_jacobi_symbol)
    UnitTest.run_test("Legendre Symbol", test_legendre_symbol)
    
    Note: Advanced tests
    UnitTest.run_test("Quadratic Residues", test_quadratic_residues)
    UnitTest.run_test("Primitive Roots", test_primitive_roots)
    UnitTest.run_test("Mobius Function", test_mobius_function)
    UnitTest.run_test("Divisor Functions", test_divisor_functions)
    
    Note: Performance and edge case tests
    UnitTest.run_test("Large Number Operations", test_large_number_operations)
    UnitTest.run_test("Edge Cases", test_edge_cases)
    UnitTest.run_test("Algorithm Consistency", test_algorithm_consistency)
    
    UnitTest.end_test_suite()