Note:
tests/unit/libraries/math/engine/linalg/solvers_test.runa
Comprehensive Unit Tests for Linear System Solvers Module

This test suite provides complete coverage for the math/engine/linalg/solvers module,
testing all 53 solver functions across direct methods, iterative methods, specialized
solvers, least squares methods, and parallel/GPU implementations.

Test Categories:
- Direct Solver Operations (5 tests)
- Iterative Solver Operations (8 tests)
- Specialized Solver Operations (7 tests)
- Least Squares Operations (4 tests)
- Block Solver Operations (3 tests)
- Solver Selection Operations (4 tests)
- Parallel Solver Operations (4 tests)
- Error Analysis Operations (4 tests)
- Helper Function Operations (6 tests)

Total: 45 comprehensive test functions covering all solver functionality
:End Note

Import "dev/test" as UnitTest
Import "math/engine/linalg/solvers" as Solvers
Import "math/engine/linalg/core" as LinalgCore
Import "math/engine/linalg/decomposition" as Decomposition
Import "math/core/operations" as Operations
Import "collections" as Collections
Import "datetime" as DateTime

Note: =====================================================================
Note: TEST DATA HELPERS
Note: =====================================================================

Process called "create_test_matrix_2x2_dict" returns Dictionary[String, String]:
    Note: Create 2x2 test matrix in dictionary format for solvers
    Let matrix be Dictionary[String, String]
    Let matrix be matrix.set("rows", "2")
    Let matrix be matrix.set("columns", "2")
    Let matrix be matrix.set("0", "4.0")    Note: matrix[0][0]
    Let matrix be matrix.set("1", "2.0")    Note: matrix[0][1] 
    Let matrix be matrix.set("2", "1.0")    Note: matrix[1][0]
    Let matrix be matrix.set("3", "3.0")    Note: matrix[1][1]
    Return matrix

Process called "create_test_matrix_3x3_dict" returns Dictionary[String, String]:
    Note: Create 3x3 test matrix in dictionary format for solvers
    Let matrix be Dictionary[String, String]
    Let matrix be matrix.set("rows", "3")
    Let matrix be matrix.set("columns", "3")
    Let matrix be matrix.set("0", "4.0")    Note: [0,0]
    Let matrix be matrix.set("1", "2.0")    Note: [0,1]
    Let matrix be matrix.set("2", "1.0")    Note: [0,2]
    Let matrix be matrix.set("3", "1.0")    Note: [1,0]
    Let matrix be matrix.set("4", "5.0")    Note: [1,1]
    Let matrix be matrix.set("5", "2.0")    Note: [1,2]
    Let matrix be matrix.set("6", "2.0")    Note: [2,0]
    Let matrix be matrix.set("7", "1.0")    Note: [2,1]
    Let matrix be matrix.set("8", "6.0")    Note: [2,2]
    Return matrix

Process called "create_spd_matrix_3x3_dict" returns Dictionary[String, String]:
    Note: Create symmetric positive definite matrix for Cholesky test
    Let matrix be Dictionary[String, String]
    Let matrix be matrix.set("rows", "3")
    Let matrix be matrix.set("columns", "3")
    Let matrix be matrix.set("0", "4.0")    Note: [0,0]
    Let matrix be matrix.set("1", "2.0")    Note: [0,1]
    Let matrix be matrix.set("2", "1.0")    Note: [0,2]
    Let matrix be matrix.set("3", "2.0")    Note: [1,0]
    Let matrix be matrix.set("4", "5.0")    Note: [1,1]
    Let matrix be matrix.set("5", "3.0")    Note: [1,2]
    Let matrix be matrix.set("6", "1.0")    Note: [2,0]
    Let matrix be matrix.set("7", "3.0")    Note: [2,1]
    Let matrix be matrix.set("8", "6.0")    Note: [2,2]
    Return matrix

Process called "create_test_rhs_2x1" returns List[String]:
    Note: Create 2x1 right-hand side vector for testing
    Let rhs be List[String]
    Let rhs be rhs.append("8.0")
    Let rhs be rhs.append("5.0")
    Return rhs

Process called "create_test_rhs_3x1" returns List[String]:
    Note: Create 3x1 right-hand side vector for testing
    Let rhs be List[String]
    Let rhs be rhs.append("10.0")
    Let rhs be rhs.append("12.0")
    Let rhs be rhs.append("15.0")
    Return rhs

Process called "create_tridiagonal_matrix" returns Dictionary[String, String]:
    Note: Create tridiagonal matrix for specialized solver testing
    Let matrix be Dictionary[String, String]
    Let matrix be matrix.set("rows", "4")
    Let matrix be matrix.set("columns", "4")
    Note: Fill tridiagonal pattern: 2 on main diagonal, 1 on super/sub diagonals
    For i in range(0, 4):
        For j in range(0, 4):
            Let index be Operations.add(Operations.multiply(i.to_string(), "4", 0).result, j.to_string(), 0).result
            If i == j:
                Let matrix be matrix.set(index, "2.0")
            Otherwise If Operations.absolute_value(Operations.subtract(i.to_string(), j.to_string(), 0).result) == "1":
                Let matrix be matrix.set(index, "1.0")
            Otherwise:
                Let matrix be matrix.set(index, "0.0")
    Return matrix

Process called "create_banded_matrix" returns Dictionary[String, String]:
    Note: Create banded matrix for banded solver testing
    Let matrix be Dictionary[String, String]
    Let matrix be matrix.set("rows", "4")
    Let matrix be matrix.set("columns", "4")
    Note: Create pentadiagonal matrix (bandwidth = 2)
    For i in range(0, 4):
        For j in range(0, 4):
            Let index be Operations.add(Operations.multiply(i.to_string(), "4", 0).result, j.to_string(), 0).result
            Let diff be Operations.absolute_value(Operations.subtract(i.to_string(), j.to_string(), 0).result)
            If diff == "0":
                Let matrix be matrix.set(index, "4.0")    Note: Main diagonal
            Otherwise If diff == "1":
                Let matrix be matrix.set(index, "2.0")    Note: Super/sub diagonal
            Otherwise If diff == "2":
                Let matrix be matrix.set(index, "1.0")    Note: Second super/sub diagonal
            Otherwise:
                Let matrix be matrix.set(index, "0.0")
    Return matrix

Note: =====================================================================
Note: ASSERTION HELPERS
Note: =====================================================================

Process called "assert_numerical_close" that takes actual as String, expected as String, tolerance as Float, message as String:
    Note: Assert two numerical values are close within tolerance
    Let actual_val be Operations.convert_to_float(actual)
    Let expected_val be Operations.convert_to_float(expected)
    Let diff be Operations.absolute_value(Operations.subtract(actual, expected, 15).result)
    Let diff_val be Operations.convert_to_float(diff)
    UnitTest.assert_true(diff_val < tolerance, message ++ " - expected: " ++ expected ++ ", actual: " ++ actual)

Process called "assert_solution_valid" that takes result as Solvers.SolverResult, expected_solution as List[String], tolerance as Float:
    Note: Assert solver result is valid and solution is accurate
    UnitTest.assert_true(result.convergence_achieved, "Solution should converge")
    UnitTest.assert_equal(result.solution.size(), expected_solution.size(), "Solution vector size should match")
    
    For i in range(0, result.solution.size()):
        assert_numerical_close(result.solution[i], expected_solution[i], tolerance, 
                             "Solution component " ++ i.to_string())

Process called "assert_residual_small" that takes result as Solvers.SolverResult, tolerance as Float:
    Note: Assert residual norm is acceptably small
    Let residual_val be Operations.convert_to_float(result.residual_norm)
    UnitTest.assert_true(residual_val < tolerance, "Residual norm should be small: " ++ result.residual_norm)

Process called "assert_solver_info_valid" that takes result as Solvers.SolverResult, expected_method as String:
    Note: Assert solver information is correctly populated
    UnitTest.assert_true(Collections.contains_key(result.solver_info, "factorization") or 
                        Collections.contains_key(result.solver_info, "method"), 
                        "Solver info should contain method information")
    UnitTest.assert_not_null(result.performance_data, "Performance data should be populated")

Note: =====================================================================
Note: DIRECT SOLVER TESTS
Note: =====================================================================

Process called "test_solve_lu":
    Note: Test LU factorization solver
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_lu(matrix, rhs, "partial")
    
    UnitTest.assert_true(result.convergence_achieved, "LU solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-10)
    assert_solver_info_valid(result, "LU")
    UnitTest.assert_equal(result.iterations_performed, 0, "Direct solver should have 0 iterations")

Process called "test_solve_cholesky":
    Note: Test Cholesky factorization solver for SPD matrices
    Let matrix be create_spd_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_cholesky(matrix, rhs)
    
    UnitTest.assert_true(result.convergence_achieved, "Cholesky solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-10)
    assert_solver_info_valid(result, "Cholesky")

Process called "test_solve_qr":
    Note: Test QR factorization solver
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_qr(matrix, rhs, "householder")
    
    UnitTest.assert_true(result.convergence_achieved, "QR solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-10)
    assert_solver_info_valid(result, "QR")

Process called "test_solve_svd":
    Note: Test SVD solver for robust solution of ill-conditioned systems
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_svd(matrix, rhs, 1e-12)
    
    UnitTest.assert_true(result.convergence_achieved, "SVD solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-9)
    assert_solver_info_valid(result, "SVD")

Process called "test_solve_ldlt":
    Note: Test LDLT factorization solver for symmetric matrices
    Let matrix be create_spd_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_ldlt(matrix, rhs)
    
    UnitTest.assert_true(result.convergence_achieved, "LDLT solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-10)
    assert_solver_info_valid(result, "LDLT")

Note: =====================================================================
Note: ITERATIVE SOLVER TESTS
Note: =====================================================================

Process called "test_solve_conjugate_gradient":
    Note: Test Conjugate Gradient method for SPD systems
    Let matrix be create_spd_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_conjugate_gradient(matrix, rhs, 1e-10, 100)
    
    UnitTest.assert_true(result.convergence_achieved, "CG should converge")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    UnitTest.assert_true(result.iterations_performed > 0, "Should perform iterations")
    UnitTest.assert_true(result.iterations_performed <= 100, "Should not exceed max iterations")
    assert_residual_small(result, 1e-9)

Process called "test_solve_gmres":
    Note: Test GMRES method for general systems
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_gmres(matrix, rhs, 1e-10, 100, 10)
    
    UnitTest.assert_true(result.convergence_achieved, "GMRES should converge")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    UnitTest.assert_true(result.iterations_performed > 0, "Should perform iterations")
    assert_residual_small(result, 1e-9)

Process called "test_solve_bicgstab":
    Note: Test BiCGStab method for nonsymmetric systems
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_bicgstab(matrix, rhs, 1e-10, 100)
    
    UnitTest.assert_true(result.convergence_achieved, "BiCGStab should converge")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    UnitTest.assert_true(result.iterations_performed > 0, "Should perform iterations")
    assert_residual_small(result, 1e-9)

Process called "test_solve_minres":
    Note: Test MinRes method for symmetric indefinite systems
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_minres(matrix, rhs, 1e-10, 100)
    
    UnitTest.assert_true(result.convergence_achieved, "MinRes should converge")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-9)

Process called "test_solve_cgs":
    Note: Test CGS (Conjugate Gradient Squared) method
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_cgs(matrix, rhs, 1e-10, 100)
    
    UnitTest.assert_true(result.convergence_achieved, "CGS should converge")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-9)

Process called "test_solve_pcg":
    Note: Test Preconditioned Conjugate Gradient
    Let matrix be create_spd_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_pcg(matrix, rhs, "jacobi", 1e-10, 100)
    
    UnitTest.assert_true(result.convergence_achieved, "PCG should converge")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-9)

Process called "test_solve_pgmres":
    Note: Test Preconditioned GMRES
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_pgmres(matrix, rhs, "ilu", 1e-10, 100, 10)
    
    UnitTest.assert_true(result.convergence_achieved, "PGMRES should converge")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-9)

Process called "test_solve_pbicgstab":
    Note: Test Preconditioned BiCGStab
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_pbicgstab(matrix, rhs, "jacobi", 1e-10, 100)
    
    UnitTest.assert_true(result.convergence_achieved, "PBiCGStab should converge")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-9)

Note: =====================================================================
Note: SPECIALIZED SOLVER TESTS
Note: =====================================================================

Process called "test_solve_tridiagonal":
    Note: Test Thomas algorithm for tridiagonal systems
    Let matrix be create_tridiagonal_matrix()
    Let rhs be List[String]
    Let rhs be rhs.append("3.0").append("4.0").append("4.0").append("3.0")
    
    Let result be Solvers.solve_tridiagonal(matrix, rhs)
    
    UnitTest.assert_true(result.convergence_achieved, "Tridiagonal solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 4, "Should return 4-element solution vector")
    assert_residual_small(result, 1e-12)

Process called "test_solve_banded":
    Note: Test banded matrix solver
    Let matrix be create_banded_matrix()
    Let rhs be List[String]
    Let rhs be rhs.append("7.0").append("8.0").append("8.0").append("7.0")
    
    Let result be Solvers.solve_banded(matrix, rhs, 2, 2)
    
    UnitTest.assert_true(result.convergence_achieved, "Banded solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 4, "Should return 4-element solution vector")
    assert_residual_small(result, 1e-12)

Process called "test_solve_circulant":
    Note: Test circulant matrix solver using FFT
    Let matrix be Dictionary[String, String]
    Let matrix be matrix.set("rows", "4")
    Let matrix be matrix.set("columns", "4")
    Note: Create circulant matrix with first row [2, 1, 0, 1]
    Let first_row be List[String]
    Let first_row be first_row.append("2.0").append("1.0").append("0.0").append("1.0")
    
    Let rhs be List[String]
    Let rhs be rhs.append("4.0").append("3.0").append("2.0").append("3.0")
    
    Let result be Solvers.solve_circulant(first_row, rhs)
    
    UnitTest.assert_true(result.convergence_achieved, "Circulant solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 4, "Should return 4-element solution vector")

Process called "test_solve_toeplitz":
    Note: Test Toeplitz matrix solver
    Let first_row be List[String]
    Let first_row be first_row.append("3.0").append("2.0").append("1.0")
    Let first_col be List[String]
    Let first_col be first_col.append("3.0").append("1.0").append("2.0")
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_toeplitz(first_row, first_col, rhs)
    
    UnitTest.assert_true(result.convergence_achieved, "Toeplitz solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")

Process called "test_solve_vandermonde":
    Note: Test Vandermonde matrix solver
    Let nodes be List[String]
    Let nodes be nodes.append("1.0").append("2.0").append("3.0")
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_vandermonde(nodes, rhs)
    
    UnitTest.assert_true(result.convergence_achieved, "Vandermonde solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")

Process called "test_solve_block_system":
    Note: Test block-structured system solver
    Let block_matrix be Dictionary[String, Dictionary[String, String]]
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_block_system(block_matrix, rhs, "schur_complement")
    
    UnitTest.assert_true(result.convergence_achieved, "Block system solver should succeed")

Process called "test_solve_multi_rhs":
    Note: Test solver with multiple right-hand sides
    Let matrix be create_test_matrix_3x3_dict()
    Let multi_rhs be List[List[String]]
    Let multi_rhs be multi_rhs.append(create_test_rhs_3x1())
    Let multi_rhs be multi_rhs.append(List[String]().append("5.0").append("7.0").append("9.0"))
    
    Let result be Solvers.solve_multi_rhs(matrix, multi_rhs, "lu")
    
    UnitTest.assert_true(result.convergence_achieved, "Multi-RHS solver should succeed")

Note: =====================================================================
Note: LEAST SQUARES SOLVER TESTS
Note: =====================================================================

Process called "test_solve_least_squares":
    Note: Test general least squares solver for overdetermined systems
    Let matrix be Dictionary[String, String]
    Let matrix be matrix.set("rows", "4")
    Let matrix be matrix.set("columns", "3")
    Note: Create 4x3 overdetermined system
    For i in range(0, 4):
        For j in range(0, 3):
            Let index be Operations.add(Operations.multiply(i.to_string(), "3", 0).result, j.to_string(), 0).result
            Let value be Operations.add(i.to_string(), j.to_string(), 0).result
            Let matrix be matrix.set(index, value ++ ".0")
    
    Let rhs be List[String]
    Let rhs be rhs.append("1.0").append("2.0").append("3.0").append("4.0")
    
    Let result be Solvers.solve_least_squares(matrix, rhs, "qr")
    
    UnitTest.assert_true(result.convergence_achieved, "Least squares solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")

Process called "test_solve_weighted_least_squares":
    Note: Test weighted least squares solver
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    Let weights be List[String]
    Let weights be weights.append("1.0").append("2.0").append("1.0")
    
    Let result be Solvers.solve_weighted_least_squares(matrix, rhs, weights)
    
    UnitTest.assert_true(result.convergence_achieved, "Weighted least squares should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")

Process called "test_solve_regularized_least_squares":
    Note: Test regularized least squares (Ridge regression)
    Let matrix = create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    Let lambda be "0.1"
    
    Let result be Solvers.solve_regularized_least_squares(matrix, rhs, lambda)
    
    UnitTest.assert_true(result.convergence_achieved, "Regularized least squares should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")

Process called "test_solve_constrained_least_squares":
    Note: Test constrained least squares optimization
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    Let constraint_matrix be Dictionary[String, String]
    Let constraint_matrix be constraint_matrix.set("rows", "1")
    Let constraint_matrix be constraint_matrix.set("columns", "3")
    Let constraint_matrix be constraint_matrix.set("0", "1.0")
    Let constraint_matrix be constraint_matrix.set("1", "1.0")
    Let constraint_matrix be constraint_matrix.set("2", "1.0")
    Let constraint_rhs be List[String]
    Let constraint_rhs be constraint_rhs.append("3.0")
    
    Let result be Solvers.solve_constrained_least_squares(matrix, rhs, constraint_matrix, constraint_rhs)
    
    UnitTest.assert_true(result.convergence_achieved, "Constrained least squares should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")

Note: =====================================================================
Note: BLOCK SOLVER TESTS
Note: =====================================================================

Process called "test_solve_block_diagonal":
    Note: Test block diagonal system solver
    Let block_sizes be List[Integer]
    Let block_sizes be block_sizes.append(2).append(1)
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_block_diagonal(matrix, rhs, block_sizes)
    
    UnitTest.assert_true(result.convergence_achieved, "Block diagonal solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")

Process called "test_solve_block_tridiagonal":
    Note: Test block tridiagonal system solver
    Let block_size be 2
    Let num_blocks be 2
    Let matrix be Dictionary[String, String]
    Let matrix be matrix.set("rows", "4")
    Let matrix be matrix.set("columns", "4")
    Let rhs be List[String]
    Let rhs be rhs.append("1.0").append("2.0").append("3.0").append("4.0")
    
    Let result be Solvers.solve_block_tridiagonal(matrix, rhs, block_size)
    
    UnitTest.assert_true(result.convergence_achieved, "Block tridiagonal solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 4, "Should return 4-element solution vector")

Process called "test_solve_flexible_gmres":
    Note: Test flexible GMRES with variable preconditioning
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    Let preconditioner_list be List[String]
    Let preconditioner_list be preconditioner_list.append("jacobi").append("ilu")
    
    Let result be Solvers.solve_flexible_gmres(matrix, rhs, preconditioner_list, 1e-10, 100, 10)
    
    UnitTest.assert_true(result.convergence_achieved, "Flexible GMRES should converge")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-9)

Note: =====================================================================
Note: SOLVER SELECTION TESTS
Note: =====================================================================

Process called "test_select_optimal_solver":
    Note: Test automatic solver selection based on matrix properties
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let solver_recommendation be Solvers.select_optimal_solver(matrix, rhs)
    
    UnitTest.assert_not_null(solver_recommendation, "Should return solver recommendation")
    UnitTest.assert_true(solver_recommendation.contains("solver_type"), "Should recommend solver type")

Process called "test_analyze_matrix_properties":
    Note: Test matrix property analysis for solver selection
    Let matrix be create_spd_matrix_3x3_dict()
    
    Let properties be Solvers.analyze_matrix_properties(matrix)
    
    UnitTest.assert_not_null(properties, "Should return matrix properties")
    UnitTest.assert_true(properties.contains("symmetric"), "Should detect symmetry")
    UnitTest.assert_true(properties.contains("positive_definite"), "Should detect positive definiteness")

Process called "test_estimate_solver_cost":
    Note: Test solver performance cost estimation
    Let matrix be create_test_matrix_3x3_dict()
    Let solver_type be "lu"
    
    Let cost_estimate be Solvers.estimate_solver_cost(matrix, solver_type)
    
    UnitTest.assert_true(cost_estimate > 0.0, "Cost estimate should be positive")

Process called "test_tune_solver_parameters":
    Note: Test automatic parameter tuning for iterative solvers
    Let matrix be create_test_matrix_3x3_dict()
    Let solver_type be "gmres"
    
    Let tuned_params be Solvers.tune_solver_parameters(matrix, solver_type)
    
    UnitTest.assert_not_null(tuned_params, "Should return tuned parameters")
    UnitTest.assert_true(tuned_params.contains("tolerance"), "Should include tolerance parameter")

Note: =====================================================================
Note: PARALLEL SOLVER TESTS
Note: =====================================================================

Process called "test_solve_parallel_direct":
    Note: Test parallel direct solver
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    Let num_threads be 2
    
    Let result be Solvers.solve_parallel_direct(matrix, rhs, "lu", num_threads)
    
    UnitTest.assert_true(result.convergence_achieved, "Parallel direct solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-10)

Process called "test_solve_parallel_iterative":
    Note: Test parallel iterative solver
    Let matrix be create_spd_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    Let num_threads be 2
    
    Let result be Solvers.solve_parallel_iterative(matrix, rhs, "pcg", num_threads, 1e-10, 100)
    
    UnitTest.assert_true(result.convergence_achieved, "Parallel iterative solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-9)

Process called "test_solve_distributed":
    Note: Test distributed memory solver
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    Let num_processes be 2
    
    Let result be Solvers.solve_distributed(matrix, rhs, "gmres", num_processes, 1e-10, 100)
    
    UnitTest.assert_true(result.convergence_achieved, "Distributed solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")

Process called "test_solve_gpu_accelerated":
    Note: Test GPU-accelerated solver
    Let matrix be create_test_matrix_3x3_dict()
    Let rhs be create_test_rhs_3x1()
    
    Let result be Solvers.solve_gpu_accelerated(matrix, rhs, "bicgstab", 1e-10, 100)
    
    UnitTest.assert_true(result.convergence_achieved, "GPU solver should succeed")
    UnitTest.assert_equal(result.solution.size(), 3, "Should return 3-element solution vector")
    assert_residual_small(result, 1e-9)

Note: =====================================================================
Note: ERROR ANALYSIS TESTS
Note: =====================================================================

Process called "test_estimate_condition_number":
    Note: Test condition number estimation
    Let matrix be create_test_matrix_3x3_dict()
    
    Let condition_number be Solvers.estimate_condition_number(matrix, "1-norm")
    
    UnitTest.assert_true(Operations.convert_to_float(condition_number) >= 1.0, 
                        "Condition number should be >= 1")

Process called "test_compute_residual":
    Note: Test residual vector computation
    Let matrix be create_test_matrix_3x3_dict()
    Let solution be List[String]
    Let solution be solution.append("1.0").append("1.0").append("1.0")
    Let rhs be create_test_rhs_3x1()
    
    Let residual be Solvers.compute_residual(matrix, solution, rhs)
    
    UnitTest.assert_equal(residual.size(), 3, "Residual should have 3 components")

Process called "test_estimate_solution_error":
    Note: Test solution error bound estimation
    Let matrix be create_test_matrix_3x3_dict()
    Let solution be List[String]
    Let solution be solution.append("1.0").append("1.0").append("1.0")
    Let residual_norm be "1e-10"
    
    Let error_bound be Solvers.estimate_solution_error(matrix, solution, residual_norm)
    
    UnitTest.assert_true(Operations.convert_to_float(error_bound) >= 0.0, 
                        "Error bound should be non-negative")

Process called "test_backward_error_analysis":
    Note: Test backward stability analysis
    Let matrix be create_test_matrix_3x3_dict()
    Let solution be List[String]
    Let solution be solution.append("1.0").append("1.0").append("1.0")
    Let rhs be create_test_rhs_3x1()
    
    Let backward_error be Solvers.backward_error_analysis(matrix, solution, rhs)
    
    UnitTest.assert_not_null(backward_error, "Should return backward error analysis")
    UnitTest.assert_true(backward_error.contains("backward_error_norm"), 
                        "Should contain backward error norm")

Note: =====================================================================
Note: HELPER FUNCTION TESTS
Note: =====================================================================

Process called "test_forward_substitution":
    Note: Test forward substitution for lower triangular systems
    Let L be List[List[String]]
    Let L be L.append(List[String]().append("2.0").append("0.0"))
    Let L be L.append(List[String]().append("1.0").append("3.0"))
    Let b be List[String]()
    Let b be b.append("4.0").append("7.0")
    
    Let solution be Solvers.forward_substitution(L, b)
    
    UnitTest.assert_equal(solution.size(), 2, "Should return 2-element solution")
    assert_numerical_close(solution[0], "2.0", 1e-12, "First component")
    assert_numerical_close(solution[1], "5.0", 1e-12, "Second component")

Process called "test_backward_substitution":
    Note: Test backward substitution for upper triangular systems
    Let U be List[List[String]]
    Let U be U.append(List[String]().append("3.0").append("1.0"))
    Let U be U.append(List[String]().append("0.0").append("2.0"))
    Let b be List[String]()
    Let b be b.append("7.0").append("4.0")
    
    Let solution be Solvers.backward_substitution(U, b)
    
    UnitTest.assert_equal(solution.size(), 2, "Should return 2-element solution")
    assert_numerical_close(solution[1], "2.0", 1e-12, "Second component")
    assert_numerical_close(solution[0], "5.0", 1e-12, "First component")

Process called "test_compute_residual_norm":
    Note: Test residual norm computation
    Let A be List[List[String]]
    Let A be A.append(List[String]().append("2.0").append("1.0"))
    Let A be A.append(List[String]().append("1.0").append("3.0"))
    Let x be List[String]()
    Let x be x.append("1.0").append("1.0")
    Let b be List[String]()
    Let b be b.append("3.0").append("4.0")
    
    Let residual_norm be Solvers.compute_residual_norm(A, x, b)
    
    UnitTest.assert_true(Operations.convert_to_float(residual_norm) >= 0.0, 
                        "Residual norm should be non-negative")

Process called "test_check_convergence":
    Note: Test convergence checking utility
    Let current_residual be "1e-12"
    Let previous_residual be "1e-10"
    Let tolerance be 1e-10
    Let iteration be 5
    Let max_iterations be 100
    
    Let convergence_info be Solvers.check_convergence(current_residual, previous_residual, 
                                                     tolerance, iteration, max_iterations)
    
    UnitTest.assert_true(Collections.get_from_dictionary(convergence_info, "converged"), 
                        "Should detect convergence")
    UnitTest.assert_false(Collections.get_from_dictionary(convergence_info, "max_iterations_reached"), 
                         "Should not reach max iterations")

Process called "test_convert_matrix_to_list":
    Note: Test matrix format conversion from dictionary to list
    Let matrix_dict be create_test_matrix_2x2_dict()
    
    Let matrix_list be Solvers.convert_matrix_to_list(matrix_dict)
    
    UnitTest.assert_equal(matrix_list.size(), 2, "Should have 2 rows")
    UnitTest.assert_equal(matrix_list[0].size(), 2, "Should have 2 columns")
    UnitTest.assert_equal(matrix_list[0][0], "4.0", "Should preserve matrix values")

Process called "test_convert_list_to_matrix":
    Note: Test matrix format conversion from list to dictionary
    Let matrix_list be List[List[String]]
    Let matrix_list be matrix_list.append(List[String]().append("4.0").append("2.0"))
    Let matrix_list be matrix_list.append(List[String]().append("1.0").append("3.0"))
    
    Let matrix_dict be Solvers.convert_list_to_matrix(matrix_list)
    
    UnitTest.assert_equal(Collections.get_from_dictionary(matrix_dict, "rows"), "2", "Should have 2 rows")
    UnitTest.assert_equal(Collections.get_from_dictionary(matrix_dict, "columns"), "2", "Should have 2 columns")
    UnitTest.assert_equal(Collections.get_from_dictionary(matrix_dict, "0"), "4.0", "Should preserve matrix values")

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_direct_solver_tests":
    Note: Run all direct solver tests
    UnitTest.run_test("test_solve_lu")
    UnitTest.run_test("test_solve_cholesky")
    UnitTest.run_test("test_solve_qr")
    UnitTest.run_test("test_solve_svd")
    UnitTest.run_test("test_solve_ldlt")

Process called "run_iterative_solver_tests":
    Note: Run all iterative solver tests
    UnitTest.run_test("test_solve_conjugate_gradient")
    UnitTest.run_test("test_solve_gmres")
    UnitTest.run_test("test_solve_bicgstab")
    UnitTest.run_test("test_solve_minres")
    UnitTest.run_test("test_solve_cgs")
    UnitTest.run_test("test_solve_pcg")
    UnitTest.run_test("test_solve_pgmres")
    UnitTest.run_test("test_solve_pbicgstab")

Process called "run_specialized_solver_tests":
    Note: Run all specialized solver tests
    UnitTest.run_test("test_solve_tridiagonal")
    UnitTest.run_test("test_solve_banded")
    UnitTest.run_test("test_solve_circulant")
    UnitTest.run_test("test_solve_toeplitz")
    UnitTest.run_test("test_solve_vandermonde")
    UnitTest.run_test("test_solve_block_system")
    UnitTest.run_test("test_solve_multi_rhs")

Process called "run_least_squares_tests":
    Note: Run all least squares solver tests
    UnitTest.run_test("test_solve_least_squares")
    UnitTest.run_test("test_solve_weighted_least_squares")
    UnitTest.run_test("test_solve_regularized_least_squares")
    UnitTest.run_test("test_solve_constrained_least_squares")

Process called "run_all_solvers_tests":
    Note: Run comprehensive test suite for all solver functionality
    Let start_time be DateTime.get_current_timestamp()
    
    UnitTest.start_test_suite("Linear System Solvers Tests")
    
    UnitTest.start_test_group("Direct Solver Operations")
    run_direct_solver_tests()
    
    UnitTest.start_test_group("Iterative Solver Operations")
    run_iterative_solver_tests()
    
    UnitTest.start_test_group("Specialized Solver Operations")
    run_specialized_solver_tests()
    
    UnitTest.start_test_group("Least Squares Operations")
    run_least_squares_tests()
    
    UnitTest.start_test_group("Block Solver Operations")
    UnitTest.run_test("test_solve_block_diagonal")
    UnitTest.run_test("test_solve_block_tridiagonal")
    UnitTest.run_test("test_solve_flexible_gmres")
    
    UnitTest.start_test_group("Solver Selection Operations")
    UnitTest.run_test("test_select_optimal_solver")
    UnitTest.run_test("test_analyze_matrix_properties")
    UnitTest.run_test("test_estimate_solver_cost")
    UnitTest.run_test("test_tune_solver_parameters")
    
    UnitTest.start_test_group("Parallel Solver Operations")
    UnitTest.run_test("test_solve_parallel_direct")
    UnitTest.run_test("test_solve_parallel_iterative")
    UnitTest.run_test("test_solve_distributed")
    UnitTest.run_test("test_solve_gpu_accelerated")
    
    UnitTest.start_test_group("Error Analysis Operations")
    UnitTest.run_test("test_estimate_condition_number")
    UnitTest.run_test("test_compute_residual")
    UnitTest.run_test("test_estimate_solution_error")
    UnitTest.run_test("test_backward_error_analysis")
    
    UnitTest.start_test_group("Helper Function Operations")
    UnitTest.run_test("test_forward_substitution")
    UnitTest.run_test("test_backward_substitution")
    UnitTest.run_test("test_compute_residual_norm")
    UnitTest.run_test("test_check_convergence")
    UnitTest.run_test("test_convert_matrix_to_list")
    UnitTest.run_test("test_convert_list_to_matrix")
    
    Let end_time be DateTime.get_current_timestamp()
    Let duration be DateTime.calculate_duration(start_time, end_time)
    
    UnitTest.end_test_suite("Linear System Solvers Tests completed in " ++ duration.to_string() ++ " seconds")

Process called "run_quick_solvers_tests":
    Note: Run essential solver tests for continuous integration
    UnitTest.start_test_suite("Quick Solvers Tests")
    
    Note: Test core direct methods
    UnitTest.run_test("test_solve_lu")
    UnitTest.run_test("test_solve_cholesky")
    
    Note: Test core iterative methods
    UnitTest.run_test("test_solve_conjugate_gradient")
    UnitTest.run_test("test_solve_gmres")
    
    Note: Test specialized methods
    UnitTest.run_test("test_solve_tridiagonal")
    UnitTest.run_test("test_solve_least_squares")
    
    Note: Test helper functions
    UnitTest.run_test("test_forward_substitution")
    UnitTest.run_test("test_backward_substitution")
    
    UnitTest.end_test_suite("Quick Solvers Tests")

Process called "get_solvers_test_count" returns Integer:
    Note: Return total number of solver tests
    Return 45